Project Path: arc_ChengChengCC_Ark-tools_zxg97puu

Source Tree:

```txt
arc_ChengChengCC_Ark-tools_zxg97puu
├── DpcTimer_x64
│   ├── DpcTimer
│   │   ├── DpcTimer
│   │   │   ├── DpcTimer.aps
│   │   │   ├── DpcTimer.cpp
│   │   │   ├── DpcTimer.h
│   │   │   ├── DpcTimer.rc
│   │   │   ├── DpcTimer.vcxproj
│   │   │   ├── DpcTimer.vcxproj.filters
│   │   │   ├── DpcTimer.vcxproj.user
│   │   │   ├── DpcTimerDlg.cpp
│   │   │   ├── DpcTimerDlg.h
│   │   │   ├── ReadMe.txt
│   │   │   ├── res
│   │   │   │   ├── DpcTimer.ico
│   │   │   │   └── DpcTimer.rc2
│   │   │   ├── resource.h
│   │   │   ├── stdafx.cpp
│   │   │   ├── stdafx.h
│   │   │   └── targetver.h
│   │   ├── DpcTimer.sln
│   │   └── DpcTimer.suo
│   ├── DpcTimer.PNG
│   ├── DpcTimerDrv
│   │   ├── DpcTimerDrv.c
│   │   ├── DpcTimerDrv.h
│   │   ├── DpcTimerDrv.sln
│   │   ├── DpcTimerDrv.suo
│   │   ├── DpcTimerDrv.vcxproj
│   │   ├── DpcTimerDrv.vcxproj.user
│   │   ├── clean.bat
│   │   ├── ddkbuild.cmd
│   │   ├── makefile
│   │   ├── mybuild.bat
│   │   └── sources
│   ├── PCHunter64.PNG
│   └── bin
│       ├── DpcTimer.exe
│       └── DpcTimerDrv.sys
├── DrxHook
│   ├── DrxHook
│   │   ├── DrxHook.c
│   │   ├── DrxHook.h
│   │   ├── DrxHook.sln
│   │   ├── DrxHook.suo
│   │   ├── DrxHook.vcxproj
│   │   ├── DrxHook.vcxproj.user
│   │   ├── clean.bat
│   │   ├── ddkbuild.cmd
│   │   ├── makefile
│   │   ├── mybuild.bat
│   │   └── sources
│   └── README.md
├── HideIDTHook
│   ├── HideIDTHook
│   │   ├── HideIDTHook.c
│   │   ├── HideIDTHook.h
│   │   ├── HideIDTHook.sln
│   │   ├── HideIDTHook.suo
│   │   ├── HideIDTHook.vcxproj
│   │   ├── HideIDTHook.vcxproj.user
│   │   ├── clean.bat
│   │   ├── ddkbuild.cmd
│   │   ├── makefile
│   │   ├── mybuild.bat
│   │   └── sources
│   └── README.md
├── Inject_By_kernelAPC
│   ├── ReadMe.md
│   ├── ring0
│   │   ├── KeInjectApc.c
│   │   ├── KeInjectApc.h
│   │   ├── KeInjectApc.opensdf
│   │   ├── KeInjectApc.sln
│   │   ├── KeInjectApc.suo
│   │   ├── KeInjectApc.vcxproj
│   │   ├── KeInjectApc.vcxproj.user
│   │   ├── clean.bat
│   │   ├── ddkbuild.cmd
│   │   ├── makefile
│   │   ├── mybuild.bat
│   │   ├── readme.txt
│   │   └── sources
│   └── ring3
│       ├── KeInjectApc
│       │   ├── KeInjectApc.cpp
│       │   ├── KeInjectApc.vcxproj
│       │   ├── KeInjectApc.vcxproj.filters
│       │   ├── KeInjectApc.vcxproj.user
│       │   ├── stdafx.cpp
│       │   ├── stdafx.h
│       │   └── targetver.h
│       ├── KeInjectApc.sln
│       └── KeInjectApc.suo
├── InlineHook_ShadowSSDT
│   ├── ReadMe.md
│   ├── ring0
│   │   ├── InlineHookSSSDT.c
│   │   ├── InlineHookSSSDT.h
│   │   ├── InlineHookSSSDT.sln
│   │   ├── InlineHookSSSDT.suo
│   │   ├── InlineHookSSSDT.vcxproj
│   │   ├── InlineHookSSSDT.vcxproj.user
│   │   ├── clean.bat
│   │   ├── ddkbuild.cmd
│   │   ├── makefile
│   │   ├── mybuild.bat
│   │   ├── readme.txt
│   │   └── sources
│   └── ring3
│       ├── InlineHookSSSDT应用程序
│       │   ├── InlineHookSSSDT应用程序.aps
│       │   ├── InlineHookSSSDT应用程序.cpp
│       │   ├── InlineHookSSSDT应用程序.h
│       │   ├── InlineHookSSSDT应用程序.rc
│       │   ├── InlineHookSSSDT应用程序.vcxproj
│       │   ├── InlineHookSSSDT应用程序.vcxproj.filters
│       │   ├── InlineHookSSSDT应用程序.vcxproj.user
│       │   ├── InlineHookSSSDT应用程序Dlg.cpp
│       │   ├── InlineHookSSSDT应用程序Dlg.h
│       │   ├── ReadMe.txt
│       │   ├── res
│       │   │   ├── InlineHookSSSDT.rc2
│       │   │   └── InlineHookSSSDT应用程序.ico
│       │   ├── resource.h
│       │   ├── stdafx.cpp
│       │   ├── stdafx.h
│       │   └── targetver.h
│       ├── InlineHookSSSDT应用程序.opensdf
│       ├── InlineHookSSSDT应用程序.sln
│       └── InlineHookSSSDT应用程序.suo
├── README.md
├── Register
│   ├── ReadMe.md
│   ├── RegisterManager
│   │   ├── RegisterManager
│   │   │   ├── KeyDlg.cpp
│   │   │   ├── KeyDlg.h
│   │   │   ├── ReadMe.txt
│   │   │   ├── RegFindDlg.cpp
│   │   │   ├── RegFindDlg.h
│   │   │   ├── RegHexEditDlg.cpp
│   │   │   ├── RegHexEditDlg.h
│   │   │   ├── RegModifyDlg.cpp
│   │   │   ├── RegModifyDlg.h
│   │   │   ├── RegisterManager.aps
│   │   │   ├── RegisterManager.cpp
│   │   │   ├── RegisterManager.h
│   │   │   ├── RegisterManager.rc
│   │   │   ├── RegisterManager.vcxproj
│   │   │   ├── RegisterManager.vcxproj.filters
│   │   │   ├── RegisterManager.vcxproj.user
│   │   │   ├── RegisterManagerDlg.cpp
│   │   │   ├── RegisterManagerDlg.h
│   │   │   ├── res
│   │   │   │   ├── Bmp
│   │   │   │   │   ├── Copy.bmp
│   │   │   │   │   ├── Delete.bmp
│   │   │   │   │   ├── Export.bmp
│   │   │   │   │   ├── Lookfor.bmp
│   │   │   │   │   └── Refresh.bmp
│   │   │   │   ├── Check.avi
│   │   │   │   ├── Icon
│   │   │   │   │   ├── CloseDir.ico
│   │   │   │   │   ├── Computer.ico
│   │   │   │   │   ├── OpenDir.ico
│   │   │   │   │   ├── REG_DWORD.ico
│   │   │   │   │   └── REG_SZ.ico
│   │   │   │   ├── RegisterManager.ico
│   │   │   │   ├── RegisterManager.rc2
│   │   │   │   └── Search.avi
│   │   │   ├── resource.h
│   │   │   ├── stdafx.cpp
│   │   │   ├── stdafx.h
│   │   │   └── targetver.h
│   │   ├── RegisterManager.sln
│   │   └── RegisterManager.suo
│   └── RegisterManagerDrv
│       ├── RegisterManagerDrv.c
│       ├── RegisterManagerDrv.h
│       ├── RegisterManagerDrv.sln
│       ├── RegisterManagerDrv.suo
│       ├── RegisterManagerDrv.vcxproj
│       ├── RegisterManagerDrv.vcxproj.user
│       ├── clean.bat
│       ├── ddkbuild.cmd
│       ├── makefile
│       ├── mybuild.bat
│       └── sources
├── Wow64Injectx64
│   ├── ReadMe.md
│   ├── Wow64Injectx64
│   │   ├── Messagebox.dll
│   │   ├── Resource.h
│   │   ├── Wow64Injectx64.cpp
│   │   ├── Wow64Injectx64.h
│   │   ├── Wow64Injectx64.rc
│   │   ├── Wow64Injectx64.vcxproj
│   │   ├── Wow64Injectx64.vcxproj.filters
│   │   ├── Wow64Injectx64.vcxproj.user
│   │   ├── stdafx.cpp
│   │   ├── stdafx.h
│   │   ├── targetver.h
│   │   ├── wow64ext.dll
│   │   ├── wow64ext.h
│   │   └── wow64ext.lib
│   ├── Wow64Injectx64.sln
│   └── Wow64Injectx64.suo
├── arkProject
│   ├── HeavenShadow
│   │   ├── HeavenShadow
│   │   │   ├── AlertWnd.cpp
│   │   │   ├── AlertWnd.h
│   │   │   ├── ButtonNotify.cpp
│   │   │   ├── CallbackFunc.cpp
│   │   │   ├── CallbackFunc.h
│   │   │   ├── Common.cpp
│   │   │   ├── Common.h
│   │   │   ├── DetailFunc.cpp
│   │   │   ├── DetailFunc.h
│   │   │   ├── DpcTimerFunc.cpp
│   │   │   ├── DpcTimerFunc.h
│   │   │   ├── FileDlg.cpp
│   │   │   ├── FileDlg.h
│   │   │   ├── FileFunc.cpp
│   │   │   ├── FileFunc.h
│   │   │   ├── FilterDriverFunc.cpp
│   │   │   ├── FilterDriverFunc.h
│   │   │   ├── HandleFunc.cpp
│   │   │   ├── HandleFunc.h
│   │   │   ├── HeavenShadow.aps
│   │   │   ├── HeavenShadow.cpp
│   │   │   ├── HeavenShadow.h
│   │   │   ├── HeavenShadow.idc
│   │   │   ├── HeavenShadow.rc
│   │   │   ├── HeavenShadow.vcxproj
│   │   │   ├── HeavenShadow.vcxproj.filters
│   │   │   ├── HeavenShadow.vcxproj.user
│   │   │   ├── HeavenShadowDlg.cpp
│   │   │   ├── HeavenShadowDlg.h
│   │   │   ├── HsAboutDlg.cpp
│   │   │   ├── HsAboutDlg.h
│   │   │   ├── InjectFunc.cpp
│   │   │   ├── InjectFunc.h
│   │   │   ├── IoTimerFunc.cpp
│   │   │   ├── IoTimerFunc.h
│   │   │   ├── KernelDlg.cpp
│   │   │   ├── KernelDlg.h
│   │   │   ├── KernelFunc.cpp
│   │   │   ├── KernelFunc.h
│   │   │   ├── LoadSys.cpp
│   │   │   ├── LoadSys.h
│   │   │   ├── MemoryFunc.cpp
│   │   │   ├── MemoryFunc.h
│   │   │   ├── ModuleDlg.cpp
│   │   │   ├── ModuleDlg.h
│   │   │   ├── ModuleFunc.cpp
│   │   │   ├── ModuleFunc.h
│   │   │   ├── MyCheckBtn.cpp
│   │   │   ├── MyCheckBtn.h
│   │   │   ├── MyEdit.cpp
│   │   │   ├── MyEdit.h
│   │   │   ├── MyList.cpp
│   │   │   ├── MyList.h
│   │   │   ├── MyPicButton.cpp
│   │   │   ├── MyPicButton.h
│   │   │   ├── MyText.cpp
│   │   │   ├── MyText.h
│   │   │   ├── MyText2.cpp
│   │   │   ├── MyText2.h
│   │   │   ├── PModuleFunc.cpp
│   │   │   ├── PModuleFunc.h
│   │   │   ├── PrivilegeFunc.cpp
│   │   │   ├── PrivilegeFunc.h
│   │   │   ├── ProcessDlg.cpp
│   │   │   ├── ProcessDlg.h
│   │   │   ├── ProcessFunc.cpp
│   │   │   ├── ProcessFunc.h
│   │   │   ├── ProcessViewDlg.cpp
│   │   │   ├── ProcessViewDlg.h
│   │   │   ├── ReadMe.txt
│   │   │   ├── SSDTFunc.cpp
│   │   │   ├── SSDTFunc.h
│   │   │   ├── SSSDTFunc.cpp
│   │   │   ├── SSSDTFunc.h
│   │   │   ├── SSSDTName.cpp
│   │   │   ├── ServiceDlg.cpp
│   │   │   ├── ServiceDlg.h
│   │   │   ├── SettingDlg.cpp
│   │   │   ├── SettingDlg.h
│   │   │   ├── SysThread.cpp
│   │   │   ├── SysThread.h
│   │   │   ├── SystemDlg.cpp
│   │   │   ├── SystemDlg.h
│   │   │   ├── ThreadFunc.cpp
│   │   │   ├── ThreadFunc.h
│   │   │   ├── ToolsDlg.cpp
│   │   │   ├── ToolsDlg.h
│   │   │   ├── TrueColorToolBar.cpp
│   │   │   ├── TrueColorToolBar.h
│   │   │   ├── WindowFunc.cpp
│   │   │   ├── WindowFunc.h
│   │   │   ├── WzdSplash.cpp
│   │   │   ├── WzdSplash.h
│   │   │   ├── res
│   │   │   │   ├── HeavenShadow.ico
│   │   │   │   ├── HeavenShadow.rc2
│   │   │   │   ├── HeavenShadowLittle.ico
│   │   │   │   ├── HeavenShadow_old.ico
│   │   │   │   ├── HomeCheckBtn.bmp
│   │   │   │   ├── HomeCheckBtn.psd
│   │   │   │   ├── HomeCheckBtn_click.bmp
│   │   │   │   ├── HomeCheckBtn_click.psd
│   │   │   │   ├── HomeCheckBtn_hover.bmp
│   │   │   │   ├── HomeCheckBtn_hover.psd
│   │   │   │   ├── ICON.bmp
│   │   │   │   ├── LOGO.bmp
│   │   │   │   ├── LOGO.psd
│   │   │   │   ├── WzdSplash.bmp
│   │   │   │   ├── WzdSplash.psd
│   │   │   │   ├── alert_btn_allow.bmp
│   │   │   │   ├── alert_btn_allow_clicked.bmp
│   │   │   │   ├── alert_btn_prevent.bmp
│   │   │   │   ├── alert_btn_prevent_clicked.bmp
│   │   │   │   ├── alert_btnexit.bmp
│   │   │   │   ├── bitmap1.bmp
│   │   │   │   ├── bmp00001.bmp
│   │   │   │   ├── check_alt_v.bmp
│   │   │   │   ├── check_alt_x.bmp
│   │   │   │   ├── drivers
│   │   │   │   │   ├── HeavenShadowDrv32.sys
│   │   │   │   │   └── HeavenShadowDrv64.sys
│   │   │   │   ├── file_toolbar.bmp
│   │   │   │   ├── file_toolbar_goto.bmp
│   │   │   │   ├── mainmenu_button.bmp
│   │   │   │   ├── system_alert.WAV
│   │   │   │   ├── toolbar.psd
│   │   │   │   ├── toolbar1.bmp
│   │   │   │   ├── toolbar_file.bmp
│   │   │   │   ├── toolbar_file.psd
│   │   │   │   ├── toolbar_file_now.bmp
│   │   │   │   ├── toolbar_file_now.psd
│   │   │   │   ├── toolbar_kernel.bmp
│   │   │   │   ├── toolbar_kernel.psd
│   │   │   │   ├── toolbar_kernel_now.bmp
│   │   │   │   ├── toolbar_kernel_now.psd
│   │   │   │   ├── toolbar_logo.bmp
│   │   │   │   ├── toolbar_logo.psd
│   │   │   │   ├── toolbar_logo_now.bmp
│   │   │   │   ├── toolbar_logo_now.psd
│   │   │   │   ├── toolbar_module.bmp
│   │   │   │   ├── toolbar_module.psd
│   │   │   │   ├── toolbar_module_now.bmp
│   │   │   │   ├── toolbar_module_now.psd
│   │   │   │   ├── toolbar_process.bmp
│   │   │   │   ├── toolbar_process.psd
│   │   │   │   ├── toolbar_process_now.bmp
│   │   │   │   ├── toolbar_process_now.psd
│   │   │   │   ├── toolbar_service.bmp
│   │   │   │   ├── toolbar_service.psd
│   │   │   │   ├── toolbar_service_now.bmp
│   │   │   │   ├── toolbar_service_now.psd
│   │   │   │   ├── toolbar_setting.bmp
│   │   │   │   ├── toolbar_setting.psd
│   │   │   │   ├── toolbar_setting_now.bmp
│   │   │   │   ├── toolbar_setting_now.psd
│   │   │   │   ├── toolbar_system.bmp
│   │   │   │   ├── toolbar_system.psd
│   │   │   │   ├── toolbar_system_now.bmp
│   │   │   │   ├── toolbar_system_now.psd
│   │   │   │   ├── toolbar_tools.bmp
│   │   │   │   ├── toolbar_tools.psd
│   │   │   │   ├── toolbar_tools_now.bmp
│   │   │   │   ├── toolbar_tools_now.psd
│   │   │   │   ├── toolbar_youhua.bmp
│   │   │   │   ├── toolbar_youhua.psd
│   │   │   │   ├── toolbar_youhua_now.bmp
│   │   │   │   └── toolbar_youhua_now.psd
│   │   │   ├── resource.h
│   │   │   ├── stdafx.cpp
│   │   │   ├── stdafx.h
│   │   │   └── targetver.h
│   │   ├── HeavenShadow.sln
│   │   ├── HeavenShadow.suo
│   │   ├── injectdll32
│   │   │   ├── InjectFunc32.cpp
│   │   │   ├── InjectFunc32.h
│   │   │   ├── ReadMe.txt
│   │   │   ├── Resource.h
│   │   │   ├── injectdll32.cpp
│   │   │   ├── injectdll32.h
│   │   │   ├── injectdll32.ico
│   │   │   ├── injectdll32.rc
│   │   │   ├── injectdll32.vcxproj
│   │   │   ├── injectdll32.vcxproj.filters
│   │   │   ├── injectdll32.vcxproj.user
│   │   │   ├── small.ico
│   │   │   ├── stdafx.cpp
│   │   │   ├── stdafx.h
│   │   │   └── targetver.h
│   │   └── injectdll64
│   │       ├── InjectFunc64.cpp
│   │       ├── InjectFunc64.h
│   │       ├── ReadMe.txt
│   │       ├── Resource.h
│   │       ├── injectdll64.cpp
│   │       ├── injectdll64.h
│   │       ├── injectdll64.ico
│   │       ├── injectdll64.rc
│   │       ├── injectdll64.vcxproj
│   │       ├── injectdll64.vcxproj.filters
│   │       ├── injectdll64.vcxproj.user
│   │       ├── small.ico
│   │       ├── stdafx.cpp
│   │       ├── stdafx.h
│   │       └── targetver.h
│   ├── HeavenShadowDrv
│   │   ├── Build
│   │   │   └── HeavenShadowDrv
│   │   │       ├── DbgX64
│   │   │       │   └── HeavenShadowDrv.sys
│   │   │       └── DbgX86
│   │   │           └── HeavenShadowDrv.sys
│   │   ├── HeavenShadowDrv
│   │   │   ├── HeavenShadowDrv.vcxproj
│   │   │   ├── HeavenShadowDrv.vcxproj.filters
│   │   │   ├── HeavenShadowDrv.vcxproj.user
│   │   │   ├── Signature.bat
│   │   │   └── Source
│   │   │       ├── CallBack.c
│   │   │       ├── CallBack.h
│   │   │       ├── DpcTimer.c
│   │   │       ├── DpcTimer.h
│   │   │       ├── FilterDriver.c
│   │   │       ├── FilterDriver.h
│   │   │       ├── GetFuncAddress.c
│   │   │       ├── GetFuncAddress.h
│   │   │       ├── GetSSSDTFuncAddress.c
│   │   │       ├── GetSSSDTFuncAddress.h
│   │   │       ├── Handle.c
│   │   │       ├── Handle.h
│   │   │       ├── HeavenShadowDrv.c
│   │   │       ├── HeavenShadowDrv.h
│   │   │       ├── IoTimer.c
│   │   │       ├── IoTimer.h
│   │   │       ├── Kernel.c
│   │   │       ├── Kernel.h
│   │   │       ├── KrnlFile.c
│   │   │       ├── KrnlFile.h
│   │   │       ├── Memory.c
│   │   │       ├── Memory.h
│   │   │       ├── Module.c
│   │   │       ├── Module.h
│   │   │       ├── Privilege.c
│   │   │       ├── Privilege.h
│   │   │       ├── Process.c
│   │   │       ├── Process.h
│   │   │       ├── SysThread.c
│   │   │       ├── SysThread.h
│   │   │       ├── System.c
│   │   │       ├── System.h
│   │   │       ├── Thread.c
│   │   │       ├── Thread.h
│   │   │       ├── Window.c
│   │   │       ├── Window.h
│   │   │       ├── common.c
│   │   │       └── common.h
│   │   ├── HeavenShadowDrv.sln
│   │   └── HeavenShadowDrv.suo
│   ├── ReadMe.md
│   └── bin
│       ├── HeavenShadow.exe
│       ├── injectdll32.exe
│       ├── injectdll64.exe
│       └── sys
│           └── x64
│               └── HeavenShadowDrv.sys
└── hook_IDT
    ├── IDTHook
    │   ├── IDTHook.c
    │   ├── IDTHook.h
    │   ├── IDTHook.sln
    │   ├── IDTHook.suo
    │   ├── IDTHook.vcxproj
    │   ├── IDTHook.vcxproj.user
    │   ├── clean.bat
    │   ├── ddkbuild.cmd
    │   ├── makefile
    │   ├── mybuild.bat
    │   └── sources
    └── README.md

```

`DpcTimer_x64/DpcTimer/DpcTimer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DpcTimer", "DpcTimer\DpcTimer.vcxproj", "{87B5C41B-A5BE-434E-A019-C698B70BDE5F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Debug|Win32.ActiveCfg = Debug|Win32
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Debug|Win32.Build.0 = Debug|Win32
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Debug|x64.ActiveCfg = Debug|x64
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Debug|x64.Build.0 = Debug|x64
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Release|Win32.ActiveCfg = Release|Win32
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Release|Win32.Build.0 = Release|Win32
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Release|x64.ActiveCfg = Release|x64
		{87B5C41B-A5BE-434E-A019-C698B70BDE5F}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimer.cpp`:

```cpp

// DpcTimer.cpp : 定义应用程序的类行为。
//

#include "stdafx.h"
#include "DpcTimer.h"
#include "DpcTimerDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CDpcTimerApp

BEGIN_MESSAGE_MAP(CDpcTimerApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CDpcTimerApp 构造

CDpcTimerApp::CDpcTimerApp()
{
	// 支持重新启动管理器
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: 在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的一个 CDpcTimerApp 对象

CDpcTimerApp theApp;


// CDpcTimerApp 初始化

BOOL CDpcTimerApp::InitInstance()
{
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

	CDpcTimerDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	}

	// 删除上面创建的 shell 管理器。
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}

	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
	//  而不是启动应用程序的消息泵。
	return FALSE;
}


```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimer.h`:

```h

// DpcTimer.h : PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
	#error "在包含此文件之前包含“stdafx.h”以生成 PCH 文件"
#endif

#include "resource.h"		// 主符号


// CDpcTimerApp:
// 有关此类的实现，请参阅 DpcTimer.cpp
//

class CDpcTimerApp : public CWinApp
{
public:
	CDpcTimerApp();

// 重写
public:
	virtual BOOL InitInstance();

// 实现

	DECLARE_MESSAGE_MAP()
};

extern CDpcTimerApp theApp;
```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimer.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\DpcTimer.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\DpcTimer.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 DpcTimer"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "DpcTimer，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2015",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_DPCTIMER_DIALOG DIALOGEX 0, 0, 463, 254
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CAPTION "DpcTimer"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,0,28,463,226
    PUSHBUTTON      "开始",IDC_BUTTON,341,4,76,19
    LTEXT           "总数：",IDC_STATIC,13,9,23,12
    LTEXT           "Static",IDC_STATIC_COUNT,44,9,25,9
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404B0"
        BEGIN
            VALUE "CompanyName", "TODO: <公司名>"
            VALUE "FileDescription", "DpcTimer"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "DpcTimer.exe"
            VALUE "LegalCopyright", "TODO: (C) <公司名>。保留所有权利。"
            VALUE "OriginalFilename", "DpcTimer.exe"
            VALUE "ProductName", "TODO: <产品名>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_DPCTIMER_DIALOG, DIALOG
    BEGIN
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 DpcTimer(&A)..."
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\DpcTimer.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{87B5C41B-A5BE-434E-A019-C698B70BDE5F}</ProjectGuid>
    <RootNamespace>DpcTimer</RootNamespace>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\DpcTimer.ico" />
    <None Include="res\DpcTimer.rc2" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DpcTimer.h" />
    <ClInclude Include="DpcTimerDlg.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DpcTimer.cpp" />
    <ClCompile Include="DpcTimerDlg.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="DpcTimer.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="DpcTimer.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\DpcTimer.rc2">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\DpcTimer.ico">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DpcTimer.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="DpcTimerDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DpcTimer.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="DpcTimerDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="DpcTimer.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimer.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimerDlg.cpp`:

```cpp

// DpcTimerDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "DpcTimer.h"
#include "DpcTimerDlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


#define CTL_GET_DPCTIMER \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_GET_DRIVER \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x831,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_REMOVEDPCTIMER \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x832,METHOD_NEITHER,FILE_ANY_ACCESS)


typedef struct _COLUMNSTRUCT
{
	WCHAR*	szTitle;
	UINT    nWidth;
}COLUMNSTRUCT;


COLUMNSTRUCT g_Column_DPCTimer[] = 
{
	{	L"定时器对象",	150	},
	{	L"DPC",			150	},
	{	L"触发周期(s)",	80 },
	{	L"函数入口",	150	},
	{	L"所属模块",	420 }

};

UINT g_Column_DCPTimer_Count  = 5;	  //进程列表列数
HANDLE  g_hDevice = NULL;



// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CDpcTimerDlg 对话框




CDpcTimerDlg::CDpcTimerDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(CDpcTimerDlg::IDD, pParent)
	, m_strDPCTimer(_T(""))
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDpcTimerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST, m_List);
	DDX_Text(pDX, IDC_STATIC_COUNT, m_strDPCTimer);
}

BEGIN_MESSAGE_MAP(CDpcTimerDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON, &CDpcTimerDlg::OnBnClickedButton)
	ON_NOTIFY(NM_RCLICK, IDC_LIST, &CDpcTimerDlg::OnNMRClickList)
	ON_COMMAND(ID_REMOVE,OnRemove)
END_MESSAGE_MAP()


// CDpcTimerDlg 消息处理程序

BOOL CDpcTimerDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码

	InitList();
	
	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}



VOID CDpcTimerDlg::InitList()
{
	while(m_List.DeleteColumn(0));
	m_List.DeleteAllItems();

	m_List.SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_DCPTimer_Count;i++)
	{
		m_List.InsertColumn(i, g_Column_DPCTimer[i].szTitle,LVCFMT_LEFT,g_Column_DPCTimer[i].nWidth);
	}
}


void CDpcTimerDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CDpcTimerDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CDpcTimerDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



void CDpcTimerDlg::OnBnClickedButton()
{
	// TODO: 在此添加控件通知处理程序代码
	g_hDevice = OpenDevice(L"\\\\.\\DPCTimerLink");

	if (g_hDevice==NULL)
	{
		::MessageBox(NULL,L"设备获取失败",NULL,0);
		return;
	}
	EnumDriver();
	GetDPC();


	CloseHandle(g_hDevice);
}


HANDLE CDpcTimerDlg::OpenDevice(LPCTSTR lpDevicePath)
{
	HANDLE hDevice = CreateFile(lpDevicePath,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
	}

	return hDevice;

}



void CDpcTimerDlg::GetDPC()
{
	ULONG_PTR ulCnt = 100;
	PDPC_TIMER_INFOR TimerInfor = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	m_List.DeleteAllItems();
	m_DPCVector.clear();

	do 
	{
		ULONG_PTR ulSize = sizeof(DPC_TIMER_INFOR) + ulCnt * sizeof(DPC_TIMER);

		if (TimerInfor)
		{
			free(TimerInfor);
			TimerInfor = NULL;
		}

		TimerInfor = (PDPC_TIMER_INFOR)malloc(ulSize);

		if (TimerInfor)
		{
			memset(TimerInfor, 0, ulSize);
			TimerInfor->ulCnt = ulCnt;		
			bRet = DeviceIoControl(g_hDevice,CTL_GET_DPCTIMER,
				NULL,
				0,
				TimerInfor,
				ulSize,
				&ulReturnSize,
				NULL);
		}

		ulCnt =TimerInfor->ulCnt + 10;

	} while (!bRet && TimerInfor->ulRetCnt > TimerInfor->ulCnt);

	if (bRet &&
		TimerInfor->ulCnt >= TimerInfor->ulRetCnt)
	{
		for (ULONG i = 0; i < TimerInfor->ulRetCnt; i++)
		{
			m_DPCVector.push_back(TimerInfor->DpcTimer[i]);
		}
	}

	if (TimerInfor)
	{
		free(TimerInfor);
		TimerInfor = NULL;
	}

	InsertDPCItem();
}




void CDpcTimerDlg::InsertDPCItem()
{
	m_ulDPCCount = 0;
	int i = 0;
	for (vector<DPC_TIMER>::iterator itor = m_DPCVector.begin(); itor != m_DPCVector.end(); itor++)
	{
		CString strTimerObject, strPeriod, strDispatch, strPath, strDpc;

		strTimerObject.Format(L"0x%08p", itor->TimerObject);
		strPeriod.Format(L"%d", itor->Period / 1000);
		strDispatch.Format(L"0x%08p", itor->TimeDispatch);
		strPath = GetDriverPath(itor->TimeDispatch);
		strDpc.Format(L"0x%08p", itor->Dpc);

		int n = m_List.InsertItem(m_List.GetItemCount(),strTimerObject);
		m_List.SetItemText(n, 1, strDpc);
		m_List.SetItemText(n, 2, strPeriod);
		m_List.SetItemText(n, 3, strDispatch);
		m_List.SetItemText(n, 4, strPath);
	
		i++;
		m_ulDPCCount++;
	}


	m_strDPCTimer.Format(L"%d",m_ulDPCCount);

	UpdateData(FALSE);

}




BOOL CDpcTimerDlg::EnumDriver()
{
	ULONG ulReturnSize = 0;
	BOOL bRet = FALSE;


	m_DriverList.clear();

	ULONG ulCount = 1000;
	PALL_DRIVERS Drivers = NULL;

	do 
	{
		ULONG ulSize = 0;
		if (Drivers)
		{
			free(Drivers);
			Drivers = NULL;
		}
		ulSize = sizeof(ALL_DRIVERS) + ulCount * sizeof(DRIVER_INFO);
		Drivers = (PALL_DRIVERS)malloc(ulSize);
		if (!Drivers)
		{
			break;
		}
		memset(Drivers,0,ulSize);
		bRet = DeviceIoControl(g_hDevice,CTL_GET_DRIVER,
			NULL,
			0,
			Drivers,
			ulSize,
			&ulReturnSize,
			NULL);

		ulCount = Drivers->ulCount + 100;
	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && Drivers->ulCount > 0)
	{
		for (ULONG i = 0;i<Drivers->ulCount; i++)
		{
			FixDriverPath(&Drivers->Drivers[i]);
			m_DriverList.push_back(Drivers->Drivers[i]);
		}
	}

	if (Drivers)
	{
		free(Drivers);
		Drivers = NULL;
	}

	return bRet;
}




CString CDpcTimerDlg::GetDriverPath(ULONG_PTR Address)
{
	CString strPath;

	for (vector<DRIVER_INFO>::iterator itor = m_DriverList.begin(); 
		itor != m_DriverList.end(); 
		itor++)
	{
		ULONG_PTR ulBase = itor->Base;
		ULONG_PTR ulEnd = itor->Base + itor->Size;
		if (Address >= ulBase && Address <= ulEnd)
		{
			strPath = itor->wzDriverPath;
			break;
		}
	}
	return strPath;
}


void CDpcTimerDlg::FixDriverPath(PDRIVER_INFO DriverInfor)
{
	if (!DriverInfor || wcslen(DriverInfor->wzDriverPath) == 0)
	{
		return;
	}

	WCHAR wzWindowsDirectory[MAX_PATH] = {0};
	WCHAR wzDriverDirectory[MAX_PATH] = {0};	
	WCHAR wzDriver[] = L"\\system32\\drivers\\";

	GetWindowsDirectory(wzWindowsDirectory, MAX_PATH - 1);
	wcscpy(wzDriverDirectory, wzWindowsDirectory);
	wcscat(wzDriverDirectory, wzDriver);

	WCHAR* wzOriginPath = DriverInfor->wzDriverPath;
	WCHAR  wzPath[MAX_PATH] = {0};
	WCHAR* wzTemp = wcschr(wzOriginPath, L'\\');

	// 没有目录信息，只有一个驱动名字的，直接拼接Driver目录。
	if (!wzTemp)
	{
		wcscpy(wzPath, wzDriverDirectory);
		wcscat(wzPath, wzOriginPath);
		wcscpy(wzOriginPath, wzPath);
		wzOriginPath[wcslen(wzPath)] = L'\0';
	}
	else
	{
		WCHAR wzUnknow[] = L"\\??\\";
		WCHAR wzSystemRoot[] = L"\\SystemRoot";
		WCHAR wzWindows[] = L"\\Windows";
		WCHAR wzWinnt[] = L"\\Winnt";
		size_t nOrigin = wcslen(wzOriginPath);

		if ( nOrigin >= wcslen(wzUnknow) && !_wcsnicmp(wzOriginPath, wzUnknow, wcslen(wzUnknow)) )
		{
			wcscpy(wzPath, wzOriginPath + wcslen(wzUnknow));
			wcscpy(wzOriginPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
		else if (nOrigin >= wcslen(wzSystemRoot) && !_wcsnicmp(wzOriginPath, wzSystemRoot, wcslen(wzSystemRoot)))
		{
			wcscpy(wzPath, wzWindowsDirectory);
			wcscat(wzPath, wzOriginPath + wcslen(wzSystemRoot));
			wcscpy(wzOriginPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
		else if (nOrigin >= wcslen(wzWindows) && !_wcsnicmp(wzOriginPath, wzWindows, wcslen(wzWindows)))
		{
			wcscpy(wzPath, wzWindowsDirectory);
			wcscat(wzPath, wzOriginPath + wcslen(wzWindows));
			wcscpy(wzOriginPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
		else if (nOrigin >= wcslen(wzWinnt) && !_wcsnicmp(wzOriginPath, wzWinnt, wcslen(wzWinnt)))
		{
			wcscpy(wzPath, wzWindowsDirectory);
			wcscat(wzPath, wzOriginPath + wcslen(wzWinnt));
			wcscpy(wzOriginPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
	}

	// 如果是短文件名
	if (wcschr(wzOriginPath, '~'))
	{
		WCHAR wzLongPath[MAX_PATH] = {0};
		DWORD nRet = GetLongPathName(wzOriginPath, wzLongPath, MAX_PATH);
		if ( !(nRet >= MAX_PATH || nRet == 0) )
		{
			wcscpy(wzOriginPath, wzLongPath);
			wzOriginPath[wcslen(wzLongPath)] = L'\0';
		}
	}
}

void CDpcTimerDlg::OnNMRClickList(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码
	CMenu Menu;
	Menu.CreatePopupMenu();
	Menu.AppendMenu(MF_STRING, ID_REMOVE,L"移除");	
	CPoint Pt;
	GetCursorPos(&Pt);         //得到鼠标位置
	Menu.TrackPopupMenu(TPM_RIGHTBUTTON, Pt.x, Pt.y, this);
	Menu.DestroyMenu();        //销毁资源
	*pResult = 0;
}




void CDpcTimerDlg::OnRemove()
{

	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;
	int Index = m_List.GetSelectionMark();
	if (Index<0)
	{
		return;
	}
	g_hDevice = OpenDevice(L"\\\\.\\DPCTimerLink");
	if (g_hDevice==NULL)
	{
		::MessageBox(NULL,L"设备获取失败",NULL,0);
		return;
	}

	CString Temp = m_List.GetItemText(Index,0);
	REMOVE_DPCTIMER  RemoveDPCTimer;
	for ( vector <DPC_TIMER>::iterator Iter = m_DPCVector.begin( ); Iter != m_DPCVector.end( ); Iter++ )
	{
		CString strTimerObject;
		strTimerObject.Format(L"0x%08p", Iter->TimerObject);
		if (!strTimerObject.CompareNoCase(Temp))
		{
			RemoveDPCTimer.TimerObject = Iter->TimerObject;
			bRet = DeviceIoControl(g_hDevice,CTL_REMOVEDPCTIMER,
				&RemoveDPCTimer,
				sizeof(REMOVE_DPCTIMER),
				NULL,
				0,
				&ulReturnSize,
				NULL);
			break;
		}	
	}
	m_ulDPCCount--;
	m_List.DeleteItem(Index);
	m_strDPCTimer.Format(L"%d",m_ulDPCCount);
	UpdateData(FALSE);
	CloseHandle(g_hDevice);


}
```

`DpcTimer_x64/DpcTimer/DpcTimer/DpcTimerDlg.h`:

```h

// DpcTimerDlg.h : 头文件
//

#pragma once
#include "afxcmn.h"
#include <iostream>
#include <vector>
#include <WinIoCtl.h>
using namespace std;



typedef struct _DRIVER_INFO_
{
	ULONG_PTR LodeOrder;
	ULONG_PTR Base;
	ULONG_PTR Size;
	ULONG_PTR DriverObject;
	ULONG_PTR DirverStartAddress;
	WCHAR wzDriverPath[MAX_PATH];
	WCHAR wzKeyName[MAX_PATH];
}DRIVER_INFO, *PDRIVER_INFO;

typedef struct _ALL_DRIVERS_
{
	ULONG_PTR ulCount;
	DRIVER_INFO Drivers[1];
}ALL_DRIVERS, *PALL_DRIVERS;


typedef struct _REMOVE_DPCTIMER
{
	ULONG_PTR     TimerObject;
}REMOVE_DPCTIMER,*PREMOVE_DPCTIMER;

typedef struct _DPC_TIMER_
{
	ULONG_PTR TimerObject;
	ULONG_PTR Period;			// 周期
	ULONG_PTR TimeDispatch;
	ULONG_PTR Dpc;
}DPC_TIMER, *PDPC_TIMER;

typedef struct _DPC_TIMER_INFOR_
{
	ULONG ulCnt;
	ULONG ulRetCnt;
	DPC_TIMER DpcTimer[1];
}DPC_TIMER_INFOR, *PDPC_TIMER_INFOR;

// CDpcTimerDlg 对话框
class CDpcTimerDlg : public CDialogEx
{
// 构造
public:
	CDpcTimerDlg(CWnd* pParent = NULL);	// 标准构造函数

// 对话框数据
	enum { IDD = IDD_DPCTIMER_DIALOG };

	vector<DRIVER_INFO> m_DriverList;
	vector<DPC_TIMER>   m_DPCVector;
	ULONG m_ulDPCCount;
	~CDpcTimerDlg()
	{
		m_DPCVector.clear();
		m_DriverList.clear();
	}
	HANDLE OpenDevice(LPCTSTR lpDevicePath);
	void GetDPC();
	void InsertDPCItem();
	BOOL EnumDriver();
	CString GetDriverPath(ULONG_PTR Address);
	void FixDriverPath(PDRIVER_INFO DriverInfor);
	void OnRemove();
	VOID InitList();

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	CListCtrl m_List;
	afx_msg void OnBnClickedButton();
	afx_msg void OnNMRClickList(NMHDR *pNMHDR, LRESULT *pResult);
	CString m_strDPCTimer;
};

```

`DpcTimer_x64/DpcTimer/DpcTimer/ReadMe.txt`:

```txt
================================================================================
MICROSOFT 基础类库: DpcTimer 项目概述
===============================================================================

应用程序向导已为您创建了这个 DpcTimer 应用程序。此应用程序不仅演示 Microsoft 基础类的基本使用方法，还可作为您编写应用程序的起点。

本文件概要介绍组成 DpcTimer 应用程序的每个文件的内容。

DpcTimer.vcxproj
这是使用应用程序向导生成的 VC++ 项目的主项目文件。 
它包含生成该文件的 Visual C++ 的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

DpcTimer.vcxproj.filters
    这是使用“应用程序向导”生成的 VC++ 项目筛选器文件。
    它包含有关项目文件与筛选器之间的关联信息。在 IDE 中，通过这种关联，在特定节点下以分组形式显示具有相似扩展名的文件。例如，“.cpp”文件与“源文件”筛选器关联。

DpcTimer.h
这是应用程序的主要头文件。它包括其他项目特定的头文件(包括 Resource.h)，并声明 CDpcTimerApp 应用程序类。

DpcTimer.cpp
这是包含应用程序类 CDpcTimerApp 的主要应用程序源文件。

DpcTimer.rc
这是程序使用的所有 Microsoft Windows 资源的列表。它包括 RES 子目录中存储的图标、位图和光标。此文件可以直接在 Microsoft Visual C++ 中进行编辑。项目资源位于 2052 中。

res\DpcTimer.ico
这是用作应用程序图标的图标文件。此图标包括在主要资源文件 DpcTimer.rc 中。

res\DpcTimer.rc2
此文件包含不在 Microsoft Visual C++ 中进行编辑的资源。您应该将不可由资源编辑器编辑的所有资源放在此文件中。


/////////////////////////////////////////////////////////////////////////////

应用程序向导创建一个对话框类:

DpcTimerDlg.h，DpcTimerDlg.cpp - 对话框
这些文件包含 CDpcTimerDlg 类。该类定义应用程序主对话框的行为。该对话框的模板位于 DpcTimer.rc 中，该文件可以在 Microsoft Visual C++ 中进行编辑。


/////////////////////////////////////////////////////////////////////////////

其他功能:

ActiveX 控件
应用程序包括对使用 ActiveX 控件的支持。

打印及打印预览支持
应用程序向导已通过从 MFC 库调用 CView 类中的成员函数，生成了用于处理打印、打印设置和打印预览命令的代码。

/////////////////////////////////////////////////////////////////////////////

其他标准文件:

StdAfx.h，StdAfx.cpp
这些文件用于生成名为 DpcTimer.pch 的预编译头 (PCH) 文件和名为 StdAfx.obj 的预编译类型文件。

Resource.h
这是标准头文件，它定义新的资源 ID。
Microsoft Visual C++ 读取并更新此文件。

DpcTimer.manifest
	应用程序清单文件供 Windows XP 用来描述应用程序
	对特定版本并行程序集的依赖性。加载程序使用此
	信息从程序集缓存加载适当的程序集或
	从应用程序加载私有信息。应用程序清单可能为了重新分发而作为
	与应用程序可执行文件安装在相同文件夹中的外部 .manifest 文件包括，
	也可能以资源的形式包括在该可执行文件中。 
/////////////////////////////////////////////////////////////////////////////

其他注释:

应用程序向导使用“TODO:”指示应添加或自定义的源代码部分。

如果应用程序在共享的 DLL 中使用 MFC，则需要重新发布这些 MFC DLL；如果应用程序所用的语言与操作系统的当前区域设置不同，则还需要重新发布对应的本地化资源 MFC100XXX.DLL。有关这两个主题的更多信息，请参见 MSDN 文档中有关 Redistributing Visual C++ applications (重新发布 Visual C++ 应用程序)的章节。

/////////////////////////////////////////////////////////////////////////////

```

`DpcTimer_x64/DpcTimer/DpcTimer/res/DpcTimer.rc2`:

```rc2
//
// DpcTimer.RC2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`DpcTimer_x64/DpcTimer/DpcTimer/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by DpcTimer.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DPCTIMER_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_LIST                        1000
#define IDC_BUTTON                      1001
#define IDC_STATIC_COUNT                1002
#define ID_REMOVE						1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`DpcTimer_x64/DpcTimer/DpcTimer/stdafx.cpp`:

```cpp

// stdafx.cpp : 只包括标准包含文件的源文件
// DpcTimer.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"



```

`DpcTimer_x64/DpcTimer/DpcTimer/stdafx.h`:

```h

// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件

#pragma once

#ifndef _SECURE_ATL
#define _SECURE_ATL 1
#endif

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // 功能区和控件条的 MFC 支持









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`DpcTimer_x64/DpcTimer/DpcTimer/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义最高版本的可用 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`DpcTimer_x64/DpcTimerDrv/DpcTimerDrv.c`:

```c
/***************************************************************************************
* AUTHOR : 懒人
* DATE   : 2014-10-25
* MODULE : DpcTimerDrv.C
* 
* Command: 
*	Source of IOCTRL Sample Driver
*
* Description:
*		Demonstrates communications between USER and KERNEL.
*
****************************************************************************************
* Copyright (C) 2010 懒人.
****************************************************************************************/

//#######################################################################################
//# I N C L U D E S
//#######################################################################################


#include "DpcTimerDrv.h"

PDRIVER_OBJECT g_DriverObject = NULL;
PVOID Ntoskrnl_KLDR_DATA_TABLE_ENTRY = NULL;

//////////////////////////////////////////////////////////////////////////

//#######################################################################################
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@				D R I V E R   E N T R Y   P O I N T						 @@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//#######################################################################################
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryString)
{
	NTSTATUS  Status;
	UNICODE_STRING   uniDeviceName;
	UNICODE_STRING   uniLinkName;
	ULONG_PTR i = 0;
	PDEVICE_OBJECT   DeviceObject = NULL;
	RtlInitUnicodeString(&uniDeviceName,DEVICE_NAME);
	RtlInitUnicodeString(&uniLinkName,LINK_NAME);
	for (i=0;i<IRP_MJ_MAXIMUM_FUNCTION;i++)
	{
		DriverObject->MajorFunction[i] = DefaultDispatchFunction;
	}
	DriverObject->DriverUnload = UnloadDriver;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchControl;
	//创建设备对象
	Status = IoCreateDevice(DriverObject,0,&uniDeviceName,FILE_DEVICE_UNKNOWN,0,FALSE,&DeviceObject);
	if (!NT_SUCCESS(Status))
	{
		return STATUS_UNSUCCESSFUL;
	}
	Status = IoCreateSymbolicLink(&uniLinkName,&uniDeviceName);
	if (!NT_SUCCESS(Status))
	{
		IoDeleteDevice(DeviceObject);
		return STATUS_UNSUCCESSFUL;
	}

	g_DriverObject = DriverObject;

	return STATUS_SUCCESS;

}


NTSTATUS DefaultDispatchFunction(PDEVICE_OBJECT  DeviceObject,PIRP Irp)
{
	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(Irp,IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}


NTSTATUS DispatchControl(PDEVICE_OBJECT  DeviceObject,PIRP Irp)
{
	NTSTATUS  Status = STATUS_SUCCESS;
	PIO_STACK_LOCATION   IrpSp;
	PVOID     InputBuffer  = NULL;
	PVOID     OutputBuffer = NULL;
	ULONG_PTR InputSize  = 0;
	ULONG_PTR OutputSize = 0;
	ULONG_PTR IoControlCode = 0;

	IrpSp = IoGetCurrentIrpStackLocation(Irp);
	InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
	OutputBuffer = Irp->UserBuffer;
	InputSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	OutputSize  = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
	IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	switch(IoControlCode)
	{

	case CTL_GET_DPCTIMER:
		{
			EnumDpcTimer(OutputBuffer);
			Irp->IoStatus.Information = 0;
			Status = Irp->IoStatus.Status = Status;
			break;
		}

	case CTL_REMOVEDPCTIMER:
		{

			Status =  RemoveDPCTimer(InputBuffer);
			Irp->IoStatus.Information = 0;
			Status = Irp->IoStatus.Status = Status;
			break;
		}

	case CTL_GET_DRIVER:
		{
			GetKernelLdrDataTableEntry(g_DriverObject);
			Status = EnumDrivers(OutputBuffer,OutputSize);
			Irp->IoStatus.Information = 0;
			Status = Irp->IoStatus.Status = Status;
			break;
		}
	default:
		{

			Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
			Irp->IoStatus.Information = 0;
			break;
		}
	}

	IoCompleteRequest(Irp,IO_NO_INCREMENT);
	return Status;
}



NTSTATUS EnumDpcTimer(PVOID OutBuffer)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PDPC_TIMER_INFOR DpcTimerInfor = (PDPC_TIMER_INFOR)OutBuffer;
	GetDpcTimerInformation_x64(DpcTimerInfor);
	if (DpcTimerInfor->ulCnt >= DpcTimerInfor->ulRetCnt)
	{
		Status = STATUS_SUCCESS;
	}

	return Status;
}


KDPC* TransTimerDpcEx(
	IN PKTIMER InTimer,
	IN ULONGLONG InKiWaitNever,
	IN ULONGLONG InKiWaitAlways)
{
	ULONGLONG			RDX = (ULONGLONG)InTimer->Dpc;
	RDX ^= InKiWaitNever;
	RDX = _rotl64(RDX, (UCHAR)(InKiWaitNever & 0xFF));
	RDX ^= (ULONGLONG)InTimer;
	RDX = _byteswap_uint64(RDX);
	RDX ^= InKiWaitAlways;
	return (KDPC*)RDX;
}


NTSTATUS GetDpcTimerInformation_x64(PDPC_TIMER_INFOR DpcTimerInfor)
{
	ULONG CPUNumber = KeNumberProcessors;   //系统变量
	PUCHAR CurrentKPRCBAddress = NULL;            
	PUCHAR CurrentTimerTableEntry = NULL;
	PLIST_ENTRY CurrentEntry = NULL;
	PLIST_ENTRY NextEntry = NULL;
	PULONG64    KiWaitAlways = NULL;
	PULONG64    KiWaitNever  = NULL;
	int i = 0;
	int j = 0;
	int n = 0;
	PKTIMER Timer;
	typedef struct _KTIMER_TABLE_ENTRY
	{
		ULONG64			Lock;
		LIST_ENTRY		Entry;
		ULARGE_INTEGER	Time;
	} KTIMER_TABLE_ENTRY, *PKTIMER_TABLE_ENTRY;

	for(j=0; j<CPUNumber; j++)
	{
		KeSetSystemAffinityThread(j+1);   //使当前线程运行在第一个处理器上
		CurrentKPRCBAddress=(PUCHAR)__readmsr(0xC0000101) + 0x20;
		KeRevertToUserAffinityThread();   //恢复线程运行的处理器
		
		CurrentTimerTableEntry=(PUCHAR)(*(ULONG64*)CurrentKPRCBAddress + 0x2200 + 0x200);
		FindKiWaitFunc(&KiWaitNever,&KiWaitAlways);  //找KiWaitAlways 函数的地址
		for(i=0; i<0x100; i++)
		{
			CurrentEntry = (PLIST_ENTRY)(CurrentTimerTableEntry + sizeof(KTIMER_TABLE_ENTRY) * i + 8);
			NextEntry = CurrentEntry->Blink;
			if( MmIsAddressValid(CurrentEntry) && MmIsAddressValid(CurrentEntry) )
			{
				while( NextEntry != CurrentEntry )
				{
					PKDPC RealDpc;
					//获得首地址
					Timer = CONTAINING_RECORD(NextEntry,KTIMER,TimerListEntry);
					RealDpc=TransTimerDpcEx(Timer,*KiWaitNever,*KiWaitAlways);
					if( MmIsAddressValid(Timer)&&MmIsAddressValid(RealDpc)&&MmIsAddressValid(RealDpc->DeferredRoutine))
					{				
						if (DpcTimerInfor->ulCnt > DpcTimerInfor->ulRetCnt)
						{
							DpcTimerInfor->DpcTimer[n].Dpc = (ULONG64)RealDpc;
							DpcTimerInfor->DpcTimer[n].Period = Timer->Period;
							DpcTimerInfor->DpcTimer[n].TimeDispatch = (ULONG64)RealDpc->DeferredRoutine;
							DpcTimerInfor->DpcTimer[n].TimerObject = (ULONG64)Timer;
							n++;
						}					
						DpcTimerInfor->ulRetCnt++;					
					}
					NextEntry = NextEntry->Blink;
				}
			}
		}
	}
}



VOID FindKiWaitFunc(PULONG64 *KiWaitNeverAddr, PULONG64 *KiWaitAlwaysAddr)
{
	long Temp;
	PUCHAR StartAddress,i;
	UNICODE_STRING  uniFuncName;
	WCHAR wzFunName[] = L"KeSetTimer";
	RtlInitUnicodeString(&uniFuncName,wzFunName);
	StartAddress = (PUCHAR)MmGetSystemRoutineAddress(&uniFuncName);
	for(i=StartAddress; i<StartAddress+0xFF; i++)
	{
		if(*i==0x48 && *(i+1)==0x8B && *(i+2)==0x05)
		{
			memcpy(&Temp,i+3,4);
			*KiWaitNeverAddr=(PULONG64)((ULONGLONG)Temp + (ULONGLONG)i + 7);
			i=i+7;
			memcpy(&Temp,i+3,4);
			*KiWaitAlwaysAddr=(PULONG64)((ULONGLONG)Temp + (ULONGLONG)i + 7);
			return;
		}
	}
}

BOOLEAN GetKernelLdrDataTableEntry(PDRIVER_OBJECT DriverObject)  
{
	BOOLEAN bRet = FALSE;
	if (DriverObject)
	{
		PKLDR_DATA_TABLE_ENTRY Entry = NULL, FirstEntry = NULL;
		WCHAR wzNtoskrnl[] = L"ntoskrnl.exe";                                      
		int nLen = wcslen(wzNtoskrnl) * sizeof(WCHAR);
		FirstEntry = Entry = (PKLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;  

		while((PKLDR_DATA_TABLE_ENTRY)Entry->InLoadOrderLinks.Flink != FirstEntry)
		{

			if (Entry->BaseDllName.Buffer																			&& 
				nLen == Entry->BaseDllName.Length																	&&
				MmIsAddressValid((PVOID)Entry->BaseDllName.Buffer)													&&
				!_wcsnicmp(wzNtoskrnl,(WCHAR*)Entry->BaseDllName.Buffer, nLen / sizeof(WCHAR)))
			{
				Ntoskrnl_KLDR_DATA_TABLE_ENTRY = (PVOID)Entry;
				bRet = TRUE;
				break;
			}

			Entry = (PKLDR_DATA_TABLE_ENTRY)Entry->InLoadOrderLinks.Flink;
		}

		// 如果没找到ntoskrnl,那么使用自己
		if (!bRet)
		{
			Ntoskrnl_KLDR_DATA_TABLE_ENTRY = (PVOID)FirstEntry;
			bRet = TRUE;
		}
	}

	return bRet;
}




NTSTATUS EnumDrivers(PVOID OutBuffer, ULONG OutSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PALL_DRIVERS DriversInfor = (PALL_DRIVERS)OutBuffer;
	ULONG ulCount = (OutSize - sizeof(ALL_DRIVERS)) / sizeof(DRIVER_INFO);
	if (!OutBuffer)
	{
		return STATUS_INVALID_PARAMETER;
	}

	EnumDriverByLdrDataTableEntry(DriversInfor,ulCount);
	if (ulCount >= DriversInfor->ulCount)
	{
		Status = STATUS_SUCCESS;
	}
	else
	{
		Status = STATUS_BUFFER_TOO_SMALL;
	}

	return Status;
}




VOID EnumDriverByLdrDataTableEntry(PALL_DRIVERS DriversInfor, ULONG_PTR ulCount)
{
	PKLDR_DATA_TABLE_ENTRY Entry = NULL, FirstEntry = NULL;
	ULONG nMax = PAGE_SIZE;
	ULONG i = 0;
	KIRQL OldIrql;

	FirstEntry = Entry = (PKLDR_DATA_TABLE_ENTRY)Ntoskrnl_KLDR_DATA_TABLE_ENTRY;

	if (!FirstEntry || !DriversInfor)
	{
		return;
	}
	OldIrql = KeRaiseIrqlToDpcLevel();
	__try
	{
		do
		{
			if ((ULONG_PTR)Entry->DllBase > SYSTEM_ADDRESS_START && Entry->SizeOfImage > 0)
			{
				ULONG_PTR Temp = DriversInfor->ulCount;
				if (ulCount > Temp)
				{

					DriversInfor->Drivers[Temp].LodeOrder = ++i;
					DriversInfor->Drivers[Temp].Base = (ULONG_PTR)Entry->DllBase;
					DriversInfor->Drivers[Temp].Size = Entry->SizeOfImage;

					if (IsUnicodeStringValid(&(Entry->FullDllName)))
					{
						wcsncpy(DriversInfor->Drivers[Temp].wzDriverPath, Entry->FullDllName.Buffer, Entry->FullDllName.Length);
					}
					else if (IsUnicodeStringValid(&(Entry->BaseDllName)))
					{
						wcsncpy(DriversInfor->Drivers[Temp].wzDriverPath, Entry->BaseDllName.Buffer, Entry->BaseDllName.Length);
					}
				}
				DriversInfor->ulCount++;
			}

			Entry = (PKLDR_DATA_TABLE_ENTRY)Entry->InLoadOrderLinks.Flink;

		}while(Entry && Entry != FirstEntry && nMax--);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("LdrDataTable Exception!\r\n");
	}

	KeLowerIrql(OldIrql);
}

BOOLEAN IsUnicodeStringValid(PUNICODE_STRING uniString)
{
	BOOLEAN bRet = FALSE;

	__try
	{
		if (uniString->Length > 0	&&
			uniString->Buffer		&&
			MmIsAddressValid(uniString->Buffer) &&
			MmIsAddressValid(&uniString->Buffer[uniString->Length / sizeof(WCHAR) - 1]))
		{
			bRet = TRUE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{	
		bRet = FALSE;
	}

	return bRet;
}



PVOID GetFunctionAddressByName(WCHAR *wzFunction)
{
	UNICODE_STRING uniFunction;  
	PVOID AddrBase = NULL;

	if (wzFunction && wcslen(wzFunction) > 0)
	{
		RtlInitUnicodeString(&uniFunction, wzFunction);      //常量指针
		AddrBase = MmGetSystemRoutineAddress(&uniFunction);  //在System 进程  第一个模块  Ntosknrl.exe  ExportTable
	}

	return AddrBase;
}



NTSTATUS RemoveDPCTimer(PVOID InBuffer)
{
	PREMOVE_DPCTIMER Temp = (PREMOVE_DPCTIMER)InBuffer;
	ULONG_PTR TimerObject = Temp->TimerObject;
	if (TimerObject&&MmIsAddressValid((PVOID)TimerObject))
	{

		if (KeCancelTimer((PKTIMER)TimerObject))
		{
			return STATUS_SUCCESS;
		}
	}
	return STATUS_UNSUCCESSFUL;
}



VOID UnloadDriver(PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING  uniLinkName;
	PDEVICE_OBJECT  CurrentDeviceObject;
	PDEVICE_OBJECT  NextDeviceObject;

	RtlInitUnicodeString(&uniLinkName,LINK_NAME);
	IoDeleteSymbolicLink(&uniLinkName);
	if (DriverObject->DeviceObject!=NULL)
	{
		CurrentDeviceObject = DriverObject->DeviceObject;
		while(CurrentDeviceObject!=NULL)
		{
			NextDeviceObject  = CurrentDeviceObject->NextDevice;
			IoDeleteDevice(CurrentDeviceObject);
			CurrentDeviceObject = NextDeviceObject;
		}
	}
	DbgPrint("UnloadDriver\r\n");
}
```

`DpcTimer_x64/DpcTimerDrv/DpcTimerDrv.h`:

```h
/***************************************************************************************
* AUTHOR : ÀÁÈË
* DATE   : 2014-10-25
* MODULE : DpcTimerDrv.H
*
* IOCTRL Sample Driver
*
* Description:
*		Demonstrates communications between USER and KERNEL.
*
****************************************************************************************
* Copyright (C) 2010 ÀÁÈË.
****************************************************************************************/


#include <ntifs.h>
#include <devioctl.h>

#define CTL_GET_DPCTIMER \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_GET_DRIVER \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x831,METHOD_NEITHER,FILE_ANY_ACCESS)

#define CTL_REMOVEDPCTIMER \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x832,METHOD_NEITHER,FILE_ANY_ACCESS)

#define DEVICE_NAME   L"\\Device\\DPCTimer"
#define LINK_NAME 	  L"\\DosDevices\\DPCTimerLink"

#define MAX_PATH  260

#define SYSTEM_ADDRESS_START32 0x80000000
#define SYSTEM_ADDRESS_START64 0x80000000000

typedef struct _REMOVE_DPCTIMER
{
	ULONG_PTR     TimerObject;
}REMOVE_DPCTIMER,*PREMOVE_DPCTIMER;

typedef struct _DRIVER_INFO_
{
	ULONG_PTR LodeOrder;
	ULONG_PTR Base;
	ULONG_PTR Size;
	ULONG_PTR DriverObject;
	ULONG_PTR DirverStartAddress;
	WCHAR wzDriverPath[MAX_PATH];
	WCHAR wzKeyName[MAX_PATH];
}DRIVER_INFO, *PDRIVER_INFO;

typedef struct _ALL_DRIVERS_
{
	ULONG_PTR ulCount;
	DRIVER_INFO Drivers[1];
}ALL_DRIVERS, *PALL_DRIVERS;


typedef struct _DPC_TIMER_
{
	ULONG_PTR TimerObject;
	ULONG_PTR Period;			// ÖÜÆÚ
	ULONG_PTR TimeDispatch;
	ULONG_PTR Dpc;
}DPC_TIMER, *PDPC_TIMER;


typedef struct _DPC_TIMER_INFOR_
{
	ULONG ulCnt;
	ULONG ulRetCnt;
	DPC_TIMER DpcTimer[1];
}DPC_TIMER_INFOR, *PDPC_TIMER_INFOR;


typedef struct _KLDR_DATA_TABLE_ENTRY64 {
	LIST_ENTRY64 InLoadOrderLinks;
	ULONG64 __Undefined1;
	ULONG64 __Undefined2;
	ULONG64 __Undefined3;
	ULONG64 NonPagedDebugInfo;
	ULONG64 DllBase;
	ULONG64 EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING64 FullDllName;
	UNICODE_STRING64 BaseDllName;
	ULONG   Flags;
	USHORT  LoadCount;
	USHORT  __Undefined5;
	ULONG64 __Undefined6;
	ULONG   CheckSum;
	ULONG   __padding1;
	ULONG   TimeDateStamp;
	ULONG   __padding2;
} KLDR_DATA_TABLE_ENTRY64, *PKLDR_DATA_TABLE_ENTRY64;

typedef struct _KLDR_DATA_TABLE_ENTRY32 {
	LIST_ENTRY32 InLoadOrderLinks;
	ULONG __Undefined1;
	ULONG __Undefined2;
	ULONG __Undefined3;
	ULONG NonPagedDebugInfo;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Undefined5;
	ULONG  __Undefined6;
	ULONG  CheckSum;
	ULONG  TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY32, *PKLDR_DATA_TABLE_ENTRY32;

#ifdef _WIN64
#define PKLDR_DATA_TABLE_ENTRY  PKLDR_DATA_TABLE_ENTRY64
#define SYSTEM_ADDRESS_START    SYSTEM_ADDRESS_START64
#else
#define PKLDR_DATA_TABLE_ENTRY  PKLDR_DATA_TABLE_ENTRY32
#define SYSTEM_ADDRESS_START	SYSTEM_ADDRESS_START32
#endif

VOID UnloadDriver(PDRIVER_OBJECT DriverObject);
PVOID GetFunctionAddressByName(WCHAR *wzFunction);
NTSTATUS DefaultDispatchFunction(PDEVICE_OBJECT  DeviceObject,PIRP Irp);
NTSTATUS EnumDpcTimer(PVOID OutBuffer);
NTSTATUS DispatchControl(PDEVICE_OBJECT  DeviceObject,PIRP Irp);
NTSTATUS GetDpcTimerInformation_x64(PDPC_TIMER_INFOR DpcTimerInfor);
VOID FindKiWaitFunc(PULONG64 *KiWaitNeverAddr, PULONG64 *KiWaitAlwaysAddr);
KDPC* TransTimerDpcEx(
	IN PKTIMER InTimer,
	IN ULONGLONG InKiWaitNever,
	IN ULONGLONG InKiWaitAlways);

VOID EnumDriverByLdrDataTableEntry(PALL_DRIVERS DriversInfor, ULONG_PTR ulCount);
NTSTATUS EnumDrivers(PVOID OutBuffer, ULONG OutSize);
BOOLEAN GetKernelLdrDataTableEntry(PDRIVER_OBJECT DriverObject);
BOOLEAN IsUnicodeStringValid(PUNICODE_STRING uniString);
NTSTATUS RemoveDPCTimer(PVOID InBuffer);
```

`DpcTimer_x64/DpcTimerDrv/DpcTimerDrv.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DpcTimerDrv", "DpcTimerDrv.vcxproj", "{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		WinDDK|Win32 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.ActiveCfg = WinDDK|Win32
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.Build.0 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`DpcTimer_x64/DpcTimerDrv/DpcTimerDrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="WinDDK|Win32">
      <Configuration>WinDDK</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>"DpcTimerDrv"</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
    <ExecutablePath>$(WLHBASE)\bin\x86\x86;$(WLHBASE)\bin\x86</ExecutablePath>
    <IncludePath>$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc</IncludePath>
    <ReferencePath />
    <LibraryPath>$(WLHBASE)\lib\win7\i386</LibraryPath>
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG=1</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include=".\DpcTimerDrv.c" />
    <ClCompile Include=".\DpcTimerDrv.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DpcTimer_x64/DpcTimerDrv/DpcTimerDrv.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`DpcTimer_x64/DpcTimerDrv/clean.bat`:

```bat
rem /////////////////
rem / Add by ChiChou
rem / 
rem / FileName:Clean.bat
rem / Description:Clean
rem /
rem ////////////////
rd .\bin /s /q
rd .\WinDDK /s /q
rd .\objchk_w2k_x86 /s /q
rd .\objchk_wxp_x86 /s /q
rd .\objchk_wnet_x86 /s /q
rd .\objchk_wlh_x86 /s /q
rd .\objfre_w2k_x86 /s /q
rd .\objfre_wxp_x86 /s /q
rd .\objfre_wnet_x86 /s /q
rd .\objfre_wlh_x86 /s /q
del .\*.log
del .\*.err
del .\*.xml
rem ***** del VS2005 file *****
del .\*.ncb
del .\*.user
del .\*.suo /A:H
rem ***** del VS6.0 file *****
del .\*.plg
del .\*.opt
exit
```

`DpcTimer_x64/DpcTimerDrv/ddkbuild.cmd`:

```cmd
@echo off
@set VERSION=V7.3
@set OSR_DEBUG=off
@if "%OS%"=="Windows_NT" goto :Prerequisites
@echo This script requires Windows NT 4.0 or later to run properly!
goto :EOF
:Prerequisites
:: Check whether FINDSTR is available. It's used to show warnings etc.
findstr /? > NUL 2>&1 || echo "FINDSTR is a prerequisite but wasn't found!" && goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    $Id: ddkbuild.cmd 27 2008-09-06 12:02:06Z oliver $
::
::    This software is supplied for instructional purposes only.
::
::    OSR Open Systems Resources, Inc. (OSR) expressly disclaims any warranty
::    for this software.  THIS SOFTWARE IS PROVIDED  "AS IS" WITHOUT WARRANTY
::    OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
::    THE IMPLIED WARRANTIES OF MECHANTABILITY OR FITNESS FOR A PARTICULAR
::    PURPOSE.  THE ENTIRE RISK ARISING FROM THE USE OF THIS SOFTWARE REMAINS
::    WITH YOU.  OSR's entire liability and your exclusive remedy shall not
::    exceed the price paid for this material.  In no event shall OSR or its
::    suppliers be liable for any damages whatsoever (including, without
::    limitation, damages for loss of business profit, business interruption,
::    loss of business information, or any other pecuniary loss) arising out
::    of the use or inability to use this software, even if OSR has been
::    advised of the possibility of such damages.  Because some states/
::    jurisdictions do not allow the exclusion or limitation of liability for
::    consequential or incidental damages, the above limitation may not apply
::    to you.
::
::    OSR Open Systems Resources, Inc.
::    105 Route 101A Suite 19
::    Amherst, NH 03031  (603) 595-6500 FAX: (603) 595-6503
::    report bugs to <bugs@osr.com>
::    alternatively report them via <http://assarbad.net/contact/>
::
::
::    MODULE:
::
::      ddkbuild.cmd
::
::    ABSTRACT:
::
::      This script allows drivers to be built with Visual Studio 2002 through
::      Visual Studio 2008 and possibly future versions. It will also work fine
::      from the command line.
::      If you are interested in a project wizard that makes use of this script,
::      try DDKWizard from <http://ddkwizard.assarbad.net>.
::
::    AUTHOR(S):
::
::      - OSR Open Systems Resources, Inc.
::      - Oliver Schneider (ddkwizard.assarbad.net)
::
::    REQUIREMENTS:
::
::      Environment variables that must be set.
::        %NT4BASE%  - Set this up for "-NT4" builds (legacy, support not tested)
::        %W2KBASE%  - Set this up for "-W2K*" builds (legacy, support not tested)
::        %WXPBASE%  - Set this up for "-WXP*" builds
::        %WNETBASE% - Set this up for "-WNET*" builds
::        %WLHBASE%  - Set this up for "-WLH*" builds
::        %WDF_ROOT% - Must be set if attempting to do a WDF Build.
::
::      Examples:
::        NT4BASE : could be "D:\NT4DDK"
::        W2KBASE : could be "D:\Nt50DDK"
::        WXPBASE : could be "D:\WINDDK\2600"
::        WNETBASE: could be "D:\WINDDK\3790.1830" or "C:\WINDDK\3790"
::
::    COMMAND FORMAT:
::
::      Run the script without any parameters to get the whole help content!
::      Note: "-WDF" has been tested with the 01.00.5054 version of the framework
::
::    RETURN CODES AND THEIR MEANING:
::
::      001 == Unknown build type. Check the <platform> parameter
::      002 == No WDF_ROOT given using WDF build type.
::      003 == The DDK-specific base directory variable (NT4BASE, W2KBASE, WXPBASE,
::             WNETBASE) is not set at all and could not be auto-detected!
::      004 == BASEDIR variable is empty. Check to see that the DDK-specific
::             variable is set correctly (i.e. NT4BASE, W2KBASE, WXPBASE, WNETBASE)
::      005 == No mode (checked/free) was given. Check the respective parameter!
::      006 == No DIR or SOURCES file found in the given target directory.
::      007 == No target directory given.
::      008 == Given target directory does not exist.
::      009 == The SETENV script failed.
::
::      Note: If %OSR_ERRCODE% and %ERRORLEVEL% are equal, the return code stems
::            from one of the tools being called during the build process.
::
::    BROWSE FILES:
::
::      This procedure supports the building of BROWSE files to be used by
::      Visual Studio 6 and by Visual Studio.NET  However, the BSCfiles created
::      by bscmake for the two are not compatible. When this command procedure
::      runs, it selects the first bscmake.exe found in the path. So, make sure
::      that the correct bscmake.exe is in the path ...
::
::      Note that if using Visual Studio.NET the .BSC must be added to the project
::      in order for the project to be browsed.
::      Another alternative is the VS addon named "Visual Assist X" which will
::      parse the header files - no more need for browse files.
::
::    COMPILERS:
::
::      If you are building NT4 you should really be using the VC6 compiler.
::      Later versions of the DDK now contain the compiler and the linker. This
::      procedure should use the correct compiler.
::
::    GENERAL COMMENTS:
::
::      This procedure has been cleaned up to be modular and easy to understand.
::
::      As of the Server 2003 SP1 DDK DDKBUILD now clears the NO_BROWSE_FILE and
::      NO_BINPLACE environment variables so that users can use these features.
::
::      Starting with the Vista WDK, the output in the respective tool window
::      in VS is in Unicode by default. This garbles the output from DDKBUILD
::      and we therefore clear the environment variable VS_UNICODE_OUTPUT.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MAIN
:: Building "stack frame"
setlocal ENABLEEXTENSIONS & pushd .
:: Check whether the REG utility is available
reg /? > NUL 2>&1 && set OSR_REGAVAILABLE=1

:: This is set by client-side keyword substitution
set SVN_REVISION=$Revision: 27 $
:: Extract the revision number from the revision keyword
set SVN_REVISION=%SVN_REVISION:~0,-2%
set SVN_REVISION=%SVN_REVISION:~11%
:: This is set by client-side keyword substitution
set SVN_REVDATE=$Date: 2008-09-06 12:02:06 +0000 (Sat, 06 Sep 2008) $
:: Extract the date from the Date keyword
set SVN_REVDATE=%SVN_REVDATE:~7,10%
set VERSION=%VERSION%/r%SVN_REVISION%

:: Init some special variables
set OSR_VERSTR=OSR DDKBUILD.CMD %VERSION% (%SVN_REVDATE%) - OSR, Open Systems Resources, Inc.
set OSR_PREBUILD_SCRIPT=ddkprebld.cmd
set OSR_POSTBUILD_SCRIPT=ddkpostbld.cmd
set OSR_SETENV_SCRIPT=ddkbldenv.cmd
set OSR_ECHO=@echo DDKBLD:

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set error messages
:: Possible codes: 1
set ERR_UnknownBuildType=Unknown type of build. Please recheck parameters.
:: Possible codes: 2
set ERR_NoWdfRoot=WDF_ROOT is not defined, are you using 00.01.5054 or later?
:: Possible codes: 3
set ERR_BaseDirNotSet=To build using type %%OSR_TARGET%% you need to set the %%%%%%BASEDIRVAR%%%%%% environment variable to point to the %%BASEDIROS%% DDK base directory!
:: Possible codes: 4
set ERR_NoBASEDIR=NT4BASE, W2KBASE, WXPBASE and/or WNETBASE environment variable(s) not set. Environment variable(s) must be set by user according to DDK version(s) installed.
:: Possible codes: 5
set ERR_BadMode=^<build type^> must be 'checked', 'free', 'chk' or 'fre' (case-insensitive).
:: Possible codes: 6
set ERR_NoTarget=Target directory must contain a SOURCES or DIRS file.
:: Possible codes: 7, 8
set ERR_NoDir=The ^<directory^> parameter must be a valid directory.
:: Possible codes: 9
set ERR_SetEnvFailed=The SETENV script failed.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Clear the error code variable
set OSR_ERRCODE=0
set prefast_build=0

:: Turn on tracing, use %OSR_TRACE% instead of ECHO
if /i "%OSR_DEBUG%" == "on" (set OSR_TRACE=%OSR_ECHO% [TRACE]) else (set OSR_TRACE=rem)
:: Turn on echoing of current line if %OSR_DEBUG% is set to "on"
@echo %OSR_DEBUG%

:: Output version string
@echo %OSR_VERSTR%
%OSR_TRACE% ^(Current module: ^"%~f0^"^)
@echo.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set the target platform variable
set OSR_TARGET=%~1
:: Remove any dashes in the variable
if not "%OSR_TARGET%" == "" set OSR_TARGET=%OSR_TARGET:-=%
:: Show help if the target parameter is empty after removal of the dashes
if "%OSR_TARGET%" == "" goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: In the build directory check for this script and call it if it exists.
:: This allows to override any global system variable setting, if desired.
if not "%3" == "" call :GetCustomEnvironment "%~f3"
if not "%OSR_ERRCODE%" == "0" goto :USAGE
:: Additional error handling for better usability
:: These subroutines will also attempt to locate the requested DDK!!!
set OSR_ERRCODE=3
%OSR_TRACE% Checking whether the environment variable for the build type was set
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Check > NUL 2>&1
:: If the BASEDIROS/BASEDIRVAR variable is not defined, it means the subroutine did not exist!
if not DEFINED BASEDIROS call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIROS)" & goto :USAGE
if not DEFINED BASEDIRVAR call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIRVAR)" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BaseDirNotSet%" & goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
set BASEDIR=%%%BASEDIRVAR%%%
call :ResolveVar BASEDIR
call :MakeShort BASEDIR "%BASEDIR%"
:: Check for existing %BASEDIR%
if "%BASEDIR%" == "" call :ShowErrorMsg 4 "%ERR_NoBASEDIR%" & goto :USAGE
set PATH=%BASEDIR%\bin;%PATH%
%OSR_TRACE% Now jump to the initialization of the commandline
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Build

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_TRACE% We returned from the variable initialization
if not DEFINED OSR_CMDLINE call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (OSR_CMDLINE)" & goto :USAGE

%OSR_TRACE% Hurrah, all the variables have been initialized, continuing
:: Proceed with common build steps
goto :CommonBuild

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Check whether the parameter makes sense and try to
:: correct it if possible
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WLH64Check
:WLHA64Check
:WLHXP64Check
:WLHNET64Check
:WLHNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WLHCheck
:WLHX64Check
:WLHI64Check
:WLHNETX64Check
:WLHNETI64Check
:WLHXPCheck
:WLH2KCheck
:WLHNETCheck
set BASEDIROS=Windows Vista/Windows 2008 Server
set BASEDIRVAR=WLHBASE
:: Compatibility between BUILD and VS ... prevent pipes from being used
%OSR_ECHO% Clearing %%VS_UNICODE_OUTPUT%% ...
set VS_UNICODE_OUTPUT=
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "6001.18000 6000"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WNETW2KCheck
:WNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WNET2KCheck
:WNETXPCheck
:WNETWXPCheck
:WNETXP64Check
:WNET64Check
:WNETI64Check
:WNETAMD64Check
:WNETX64Check
:WNETCheck
set BASEDIROS=Windows 2003 Server
set BASEDIRVAR=WNETBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "3790.1830 3790.1218 3790"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:XPCheck
:XP64Check
:XPW2KCheck
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WXP64Check
:WXPI64Check
:WXPCheck
:WXP2KCheck
set BASEDIROS=Windows XP
set BASEDIRVAR=WXPBASE
:: Other flavor of DDKBUILD
if not DEFINED WXPBASE if DEFINED XPBASE set BASEDIRVAR=XPBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "2600.1106 2600"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:W2K64Check
:W2KI64Check
:W2KCheck
set BASEDIROS=Windows 2000
set BASEDIRVAR=W2KBASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:NT4Check
set BASEDIROS=Windows NT4
set BASEDIRVAR=NT4BASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg1
echo.
%OSR_ECHO% WARNING: %%%BASEDIRVAR%%% NOT SET!
%OSR_ECHO%   Attempting to auto-detect the installation folder and set %%%BASEDIRVAR%%%.
%OSR_ECHO%   (If this fails *you* will have to set it!)
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg2
echo.
%OSR_ECHO% WARNING:
%OSR_ECHO%   Auto-detection of the folder settings is not supported for the requested DDK.
%OSR_ECHO%   Please set %%%BASEDIRVAR%%% yourself!
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckSetVarWithReturn
%OSR_ECHO% Found!
echo.
set %BASEDIRVAR%=%BASEDIRTEMP%
set BASEDIRTEMP=
:: Tell the caller it was successful
:CommonCheckNoErrorWithReturn
set OSR_ERRCODE=0
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckErrorNotDetectedWithReturn
echo.
%OSR_ECHO% None of the usual default paths works. Set %%%BASEDIRVAR%%% manually!
:CommonCheckErrorNotSupportedWithReturn
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Initialize variables specific to the respective platform
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: 
:: Valid parameters for setenv in different DDKs/WDKs:
::
:: 2600       - "setenv <directory> [fre|chk] [64] [hal]"
:: 2600.1106  - "setenv <directory> [fre|chk] [64] [hal] [WXP|W2K]"
:: 3790       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K]"
:: 3790.1830  - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K] [no_prefast] [bscmake]"
:: 6000       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"
:: 6001.18000 - "setenv <directory> [fre|chk] [64|x64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: NT 4.0 build using NT4 DDK
:NT4Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% "%%MSDEVDIR%%"
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WXP DDK
:XPW2KBuild
:WXP2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\w2k\set2k.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 64bit (Intel) using W2K DDK
:W2K64Build
:W2KI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv64.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using W2K DDK
:W2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WXP DDK
:XP64Build
:WXP64Build
:WXPI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WXP DDK
:XPBuild
:WXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WNET DDK
:WNETW2KBuild
:WNET2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% W2K %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WNET DDK
:WNETXPBuild
:WNETWXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit using WNET DDK
:WNETXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WNET DDK
:WNET64Build
:WNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WNET DDK
:WNETA64Build
:WNETAMD64Build
:WNETX64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% AMD64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WNET DDK
:WNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 32bit using WLH DDK
:WLHBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (AMD) using WLH DDK
:WLHA64Build
:WLHX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (Intel) using WLH DDK
:WLH64Build
:WLHI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WLH DDK
:WLHNETA64Build
:WLHNETX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WLH DDK
:WLHNET64Build
:WLHNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WLH DDK
:WLHXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WLH DDK
:WLHXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WLH DDK
:WLH2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% W2K
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WLH DDK
:WLHNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: All builds go here for the rest of the procedure. Now,
:: we are getting ready to call build. The big problem
:: here is to figure our the name of the buildxxx files
:: being generated for the different platforms.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:CommonBuild
:: Remove first command line arg
shift
call :SetMode %1
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BadMode%" & goto :USAGE
set OSR_BUILDNAME=%OSR_TARGET% (%BuildMode%) using the %BASEDIROS% DDK and %%%BASEDIRVAR%%%

call :CheckTargets %2
if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :USAGE

:: Resolve any variables in the command line string
call :ResolveVar OSR_CMDLINE

pushd .
set ERRORLEVEL=0
:: This external script prepares the build environment (e.g. setenv.bat)
call %OSR_CMDLINE%
:: Will only work with newer SETENV.BAT versions, but will be helpful in this case.
if not "%ERRORLEVEL%" == "0" call :ShowErrorMsg 9 "%ERR_SetEnvFailed%" & goto :USAGE
popd

:: ----------------------------------------------------------------------------
:: Setting global variables for the scope of this CMD session
set NO_BROWSER_FILE=
set NO_BINPLACE=
set buildDirectory=%~fs2
call :MakeShort buildDirectory "%buildDirectory%"
set buildDirectory_raw=%2
set buildDirectory_fname=%~n2
%OSR_TRACE% buildDirectory       == %buildDirectory%
%OSR_TRACE% buildDirectory_raw   == %buildDirectory_raw%
%OSR_TRACE% buildDirectory_fname == %buildDirectory_fname%

set mpFlag=-M
if "%BUILD_ALT_DIR%" == "" goto :NT4

:: W2K sets this!
set OSR_EXT=%BUILD_ALT_DIR%
set mpFlag=-MI

:NT4
if "%NUMBER_OF_PROCESSORS%" == "" set mpFlag=
if "%NUMBER_OF_PROCESSORS%" == "1" set mpFlag=

:: Set additional variables at this point or do whatever you please
@if exist "%buildDirectory%\%OSR_PREBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_PREBUILD_SCRIPT%" > "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
)
:: Save the current directory (before changing into the build directory!)
:: AFTERPREBUILD
pushd .

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Determine the settings of flags, WDF and PREFAST in
:: other words what was set for %3 and beyond....
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_ECHO% %OSR_BUILDNAME%
set OSR_ARGS= + argument(s):
if not "%3" == "" set OSR_ARGS=%OSR_ARGS% %3
if not "%4" == "" set OSR_ARGS=%OSR_ARGS% %4
if not "%5" == "" set OSR_ARGS=%OSR_ARGS% %5
if /i "%OSR_ARGS%" == " + argument(s):" set OSR_ARGS=
%OSR_ECHO% Directory: %buildDirectory%%OSR_ARGS%
%OSR_ECHO% %BASEDIRVAR%: %BASEDIR%

cd /D %~s2
set bFlags=-Ze
set bscFlags=

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ContinueParsing
if "%3" == "" goto :DONE
if "%3" == "/a" goto :RebuildallFound
if /i "%3" == "-WDF" goto :WDFFound
if /i "%3" == "-PREFAST" goto :PrefastFound
set bscFlags=/n
set bFlags=%bFlags% %3
:: Remove next arg
shift
goto :ContinueParsing

:WDFFound
shift
:: Note, that the setwdf.bat is called from setenv.bat in the WDK,
:: therefore we skip it.
if /i "%BASEDIRVAR%" == "WLHBASE" goto :WDFOkay
if "%WDF_ROOT%" == "" call :ShowErrorMsg 2 "%ERR_NoWdfRoot%" & goto :USAGE
pushd .
if exist "%WDF_ROOT%\set_wdf_env.cmd" call "%WDF_ROOT%\set_wdf_env.cmd"
popd
:WDFOkay
goto :ContinueParsing

:PrefastFound
shift
set prefast_build=1
goto :ContinueParsing

:RebuildallFound
shift
set bscFlags=/n
set bFlags=%bFlags:-Ze=-cfeZ%
set bFlags=%bFlags: -cZ=%
goto :ContinueParsing
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:DONE
for %%x in (build%OSR_EXT%.err build%OSR_EXT%.wrn build%OSR_EXT%.log prefast%OSR_EXT%.log) do @(
  if exist "%%x"   del /f /q "%%x"
)

if not "%prefast_build%" == "0" goto :RunPrefastBuild
%OSR_ECHO% Run build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
pushd .
build %mpFlag% %bFlags%
popd
goto :BuildComplete

:RunPrefastBuild
%OSR_ECHO% Run prefast build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
setlocal ENABLEEXTENSIONS & pushd .
set PREFASTLOG=PREfast_defects_%OSR_EXT%.xml
prefast /log=%PREFASTLOG% /reset build %mpFlag% %bFlags% > NUL 2>&1
if "%errorlevel%" GTR "0" set OSR_ERRCODE=%errorlevel%
prefast /log=%PREFASTLOG% list > prefast%OSR_EXT%.log
%OSR_ECHO% The PREfast logfile is ^"%prefastlog%^"!
popd & endlocal

:BuildComplete
if not "%errorlevel%" == "0" set OSR_ERRCODE=%errorlevel%

@echo %OSR_DEBUG%
:: Assume that the onscreen errors are complete!
setlocal
set WARNING_FILE_COUNT=0
if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+1
)
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% ================ Build warnings =======================
  if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set WARNING_FILE_COUNT_PRE=0
if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT_PRE=%WARNING_FILE_COUNT_PRE%+1
)
:: Reset if this is no PREfast build
if "%prefast_build%" == "0" set WARNING_FILE_COUNT_PRE=0
if not "%WARNING_FILE_COUNT_PRE%" == "0" (
  %OSR_ECHO% =============== PREfast warnings ======================
  if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+%WARNING_FILE_COUNT_PRE%
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% =======================================================
)
endlocal
@echo.
%OSR_ECHO% Build complete
%OSR_ECHO% Building browse information files
if exist "buildbrowse.cmd" call "buildbrowse.cmd" & goto :postBuildSteps
set sbrlist=sbrList.txt
if not exist sbrList%CPU%.txt goto :sbrDefault
set sbrlist=sbrList%CPU%.txt

:sbrDefault
if not exist %sbrlist% goto :postBuildSteps
:: Prepend blank space
if not "%bscFlags%" == "" set bscFlags= %bscFlags%
:: bscmake%bscFlags% prevents a double blank space ...
bscmake%bscFlags% @%sbrlist%

:: Perform whatever post-build steps
:postBuildSteps
:: Restore the current directory (after changing into the build directory!)
:: Search upwards for "AFTERPREBUILD" to find the corresponding PUSHD
popd
@if exist "%buildDirectory%\%OSR_POSTBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_POSTBUILD_SCRIPT%" > "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
)
goto :END
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / GetCustomEnvironment
::    First parameter is the "directory" that supposedly contains the SOURCES
::    or DIRS file (and the build scripts)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:GetCustomEnvironment
pushd .
call :CheckTargets "%~f1"
@if not "%OSR_ERRCODE%" == "0" @(
  echo.
  %OSR_ECHO% The target directory seemed to not contain a DIRS or SOURCES file
  %OSR_ECHO% when trying to set a custom environment! Quitting.
  set buildDirectory=%~f1
  if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :GetCustomEnvironment_ret
  call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :GetCustomEnvironment_ret
  goto :GetCustomEnvironment_ret
)
:: If the user provided a script to customize the environment, execute it.
@if exist "%~f1\%OSR_SETENV_SCRIPT%" @(
  %OSR_ECHO% ^>^> Setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
  pushd "%~f1"
  call "%OSR_SETENV_SCRIPT%" > "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_SETENV_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
)
:GetCustomEnvironment_ret
popd
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ GetCustomEnvironment
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / SetMode
::    Subroutine to validate the mode of the build passed in. It must be free,
::    FREE, fre, FRE or checked, CHECKED, chk, CHK. Anything else is an error.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetMode
set BuildMode=
if /i "%OSR_TARGET%" == "WLH2K" goto :SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=free
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=checked
goto :SetModeCommonEnd
:SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=f
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=c
:SetModeCommonEnd
%OSR_TRACE% Mode set to ^"%BuildMode%^"
if "%BuildMode%" == "" set OSR_ERRCODE=5
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ SetMode
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / CheckTargets subroutine
::   Subroutine to validate that the target directory exists and that there is
::   either a DIRS or SOURCES and MakeFile in it.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CheckTargets
:: Building "stack frame"
setlocal & pushd . & set OSR_ERRCODE=0
set lTarget=%~1
if not "%lTarget%" == "" goto :CheckTargets1
set OSR_ERRCODE=7
goto :CheckTargets_ret
:CheckTargets1
if exist "%lTarget%" goto :CheckTargets2
set OSR_ERRCODE=8
goto :CheckTargets_ret
:CheckTargets2
if not exist "%lTarget%\DIRS" goto :CheckTargets3
set OSR_ERRCODE=0
goto :CheckTargets_ret
:CheckTargets3
if exist "%lTarget%\SOURCES" goto :CheckTargets4
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets4
if exist "%lTarget%\MAKEFILE" goto :CheckTargets5
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets5
set OSR_ERRCODE=0
:CheckTargets_ret
:: Cleaning "stack frame" and returning error code into global scope
popd & endlocal & set OSR_ERRCODE=%OSR_ERRCODE%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ CheckTargets subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ResolveVar subroutine
::   There is only one parameter, the name of the variable to be resolved!
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ResolveVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
set VAR_TEMPRET2=%%%VAR_NAME%%%
:ResolveVarLoop
set VAR_TEMPRET1=%VAR_TEMPRET2%
set VAR_TEMPRET2=%VAR_TEMPRET1%
for /f "tokens=*" %%i in ('echo %VAR_TEMPRET1%') do (
  set VAR_TEMPRET2=%%i
)
if not "%VAR_TEMPRET1%" == "%VAR_TEMPRET2%" goto :ResolveVarLoop
:: Re-export the variable out of the local scope
endlocal & set %VAR_NAME%=%VAR_TEMPRET1%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ResolveVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MakeShort subroutine
::   Two parameters. First parameter is the variable name, second is the path
::   to convert into a short filename.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MakeShort
setlocal ENABLEEXTENSIONS
:: Get the name of the variable we are working with and the path to convert
set VAR_NAME=%~1
set PATH_SHORT=%~dpns2
set PATH_EXTSHORT=%~xs2
if not "" == "%PATH_EXTSHORT%" set PATH_EXTSHORT=%PATH_EXTSHORT:~0,4%
set PATH_SHORT=%PATH_SHORT%%PATH_EXTSHORT%
endlocal & set %VAR_NAME%=%PATH_SHORT%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MakeShort subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ErrorWithUsage subroutine
::   This one will take the passed in parameters and build a nice error
::   message which is returned to the user along with the usage hints.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ShowErrorMsg
@set OSR_ERRCODE=%~1
@set OSR_ERRMSG=%~2
@set OSR_ERRMSG=%OSR_ERRMSG:'="%
@set OSR_ERRMSG=ERROR #%OSR_ERRCODE%: %OSR_ERRMSG%
@echo.
%OSR_ECHO% %OSR_ERRMSG%
if DEFINED buildDirectory %OSR_ECHO% -^> Target directory: %buildDirectory%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ErrorWithUsage subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / SetVar subroutine
::   Param1 == name of the variable, Param2 == value to be set for the variable
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
endlocal & set %VAR_NAME%=%~2
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ SetVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectVistaWDK subroutine
::   No parameters expected
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectVistaWDK
setlocal ENABLEEXTENSIONS
:: Newer flag (starting with W2K8) is default
set OSR_AMD64FLAG=x64
:: The Vista WDK accepted *only* "AMD64", the newer W2K8 WDK accepts only "x64"
:: We detect the older one by checking the setenv.bat for a certain string
findstr /C:"Windows Server Longhorn" "%BASEDIR%\bin\setenv.bat" > NUL 2>&1 && set OSR_AMD64FLAG=AMD64
endlocal & set OSR_AMD64FLAG=%OSR_AMD64FLAG%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectVistaWDK subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectBaseDirTemp subroutine
::   The first parameter is the list of directory names to check, separated by
::   blank spaces.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectBaseDirTemp
:: Get the name of the variable we are working with
if "%~1" == "" goto :EOF
setlocal ENABLEEXTENSIONS
call :CommonCheckMsg1
:: Try to find an installed DDK/WDK from the registry keys
if DEFINED OSR_REGAVAILABLE if not "%OSR_REGAVAILABLE%" == "0" (
  for %%i in (%~1) do @(
    call :RegTryBaseDirTemp "%%i"
  )
)
:: Try all the "default" locations
if not DEFINED BASEDIRTEMP (
  for %%i in (%~1) do @(
    for %%a in (WINDDK DDK) do @(
      call :BruteTryBaseDirTemp "%SystemDrive%\%%a\%%i"
      call :BruteTryBaseDirTemp "%ProgramFiles%\%%a\%%i"
    )
  )
)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTemp subroutine
::   Attempt to find the install key in the registry.
::   This functions tests old-style DDKs and new-style WDKs.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
call :RegTryBaseDirTempSingle "%~1" "LFNDirectory" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
call :RegTryBaseDirTempSingle "%~1\Setup" "BUILD" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
if not DEFINED BASEDIRTEMP (endlocal & goto :EOF)
:RegTryBaseDirTemp_EOF
%OSR_ECHO% Found directory (%BASEDIRTEMP%) from install key
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTempSingle subroutine
::   Attempt to find the install key in the registry.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTempSingle
setlocal ENABLEEXTENSIONS
set REGSUBKEY=%~1
set REGVALUE=%~2
set VARIABLETOSET=%~3
set REGMAINKEY=HKLM\SOFTWARE\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_WOW64
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_WOW64
set REGMAINKEY=HKLM\SOFTWARE\Wow6432Node\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_EOF
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_EOF
endlocal
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTempSingle subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / BruteTryBaseDirTemp subroutine
::   Brute-force test the given directory.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:BruteTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
:: We will not overwrite BASETEMPDIR if it has been set and is valid
:: Just try
set BASEDIRTEMP=%~1
%OSR_ECHO% Trying %BASEDIRTEMP% ...
if not exist "%BASEDIRTEMP%" (endlocal & goto :EOF)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ BruteTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Usage output
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:USAGE
@echo.
@echo USAGE:
@echo ======
@echo   %~n0 ^<target^> ^<build type^> ^<directory^> [flags] [-WDF] [-PREFAST]
@echo.
@echo Values for ^<target^>:
@echo    --------------------------------------------------------------------------
@echo     Target platform and OS   ^| Miscellaneous
@echo    --------------------------^|-----------------------------------------------
@echo     Target     ^| Windows     ^| CPU     ^| Base directory ^| Target alias(es)
@echo    ------------^|-------------^|---------^|----------------^|--------------------
@echo     -W2K       ^| 2000        ^| x86     ^| %%W2KBASE%%      ^|
@echo     -W2K64     ^| 2000        ^| Itanium ^| %%W2KBASE%%      ^| -W2KI64
@echo     -WXP       ^| XP          ^| x86     ^| %%WXPBASE%%      ^| -XP
@echo     -WXP64     ^| XP          ^| Itanium ^| %%WXPBASE%%      ^| -WXPI64, -XP64
@echo     -WXP2K     ^| 2000        ^| x86     ^| %%WXPBASE%%      ^| -XPW2K
@echo     -WNET      ^| 2003        ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNET64    ^| 2003        ^| Itanium ^| %%WNETBASE%%     ^| -WNETI64
@echo     -WNETXP    ^| XP          ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNETXP64  ^| XP          ^| Itanium ^| %%WNETBASE%%     ^|
@echo     -WNETAMD64 ^| 2003/XP x64 ^| x64     ^| %%WNETBASE%%     ^| -WNETX64, -WNETA64
@echo     -WNET2K    ^| 2000 SP3    ^| x86     ^| %%WNETBASE%%     ^| -WNETW2K
@echo     -WLH       ^| Vista/2008  ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLH2K     ^| 2000 SP4    ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP     ^| XP          ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP64   ^| XP          ^| Itanium ^| %%WLHBASE%%      ^|
@echo     -WLHNET    ^| 2003        ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHNETI64 ^| 2003        ^| Itanium ^| %%WLHBASE%%      ^| -WLHNET64
@echo     -WLHNETX64 ^| 2003/XP x64 ^| x64     ^| %%WLHBASE%%      ^| -WLHNETA64
@echo     -WLHI64    ^| Vista/2008  ^| Itanium ^| %%WLHBASE%%      ^| -WLH64
@echo     -WLHX64    ^| Vista/2008  ^| x64     ^| %%WLHBASE%%      ^| -WLHA64
@echo     -NT4       ^| NT 4.0      ^| x86     ^| %%NT4BASE%%      ^|
@echo    --------------------------------------------------------------------------
@echo     Support for NT4 and W2K DDKs is deprecated and not checked anymore
@echo     in new versions. It may or may not work properly.
@echo    --------------------------------------------------------------------------
@echo.
@echo Values for ^<build type^>:
@echo       checked, chk     indicates a checked build
@echo       free, fre        indicates a free build
@echo.
@echo Remaining parameters ("opt!" = optional parameter):
@echo       ^<directory^>      path to build directory, try . (current directory)
@echo       [flags]    opt!  any flags you think should be passed to build (try /a
@echo                        for clean)
@echo       -WDF       opt!  performs a WDF build
@echo       -PREFAST   opt!  performs a PREFAST build
@echo.
@echo Special files:
@echo       The build target directory (where the DIRS or SOURCES file resides) can
@echo       contain the following files:
@echo       - %OSR_PREBUILD_SCRIPT%
@echo         Allows to include a step before the BUILD tool from the DDK is called
@echo         but after the environment for the respective DDK has been set!
@echo       - %OSR_POSTBUILD_SCRIPT%
@echo         Allows to include a step after the BUILD tool from the DDK is called,
@echo         so the environment is still available to the script.
@echo       - %OSR_SETENV_SCRIPT%
@echo         Allows to set (or override) _any_ environment variables that may exist
@echo         in the global environment. Thus you can set the base directory for the
@echo         DDK from inside this script, making your project more self-contained.
@echo.
@echo       DDKBUILD will only handle those files which exist, so you may choose to
@echo       use none, one or multiple of these script files.
@echo       (All scripts execute inside their current directory. Consider this!)
@echo.
@echo Examples:
@echo       ^"%~n0 -NT4 checked .^" (for NT4 BUILD)
@echo       ^"%~n0 -WXP64 chk .^"
@echo       ^"%~n0 -WXP chk c:\projects\myproject^"
@echo       ^"%~n0 -WNET64 chk .^"      (IA64 build)
@echo       ^"%~n0 -WNETAMD64 chk .^"   (AMD64/EM64T build)
@echo       ^"%~n0 -WNETXP chk . -cZ -WDF^"
@echo       ^"%~n0 -WNETXP chk . -cZ -PREFAST^"
@echo.
@echo       In order for this procedure to work correctly for each platform, it
@echo       requires an environment variable to be set up for certain platforms.
@echo       There is an auto-detection mechanism in this script, which will work best
@echo       if the DDK/WDK was installed using the normal installer (i.e. not just
@echo       copied). The auto-detection is based on the DDK/WDK for which you request
@echo       a build. Whenever you set the variable explicitly, this will take
@echo       precedence over the auto-detected path!
@echo       The environment variables are as follows:
@echo.
@echo       %%NT4BASE%%  - Set this up for ^"-NT4^" builds
@echo       %%W2KBASE%%  - Set this up for ^"-W2K^" and ^"-W2K64^" builds
@echo       %%WXPBASE%%  - Set this up for ^"-WXP^", ^"-WXP64^", ^"-WXP2K^" builds
@echo       %%WNETBASE%% - Set this up for ^"-WNET*^" builds
@echo       %%WLHBASE%%  - Set this up for ^"-WLH*^" builds
@echo.
@echo       %%WDF_ROOT%% must be set if attempting to do a WDF Build previous to the
@echo       Vista WDK (in later DDKs there is no need to set WDF_ROOT).
@echo.
@echo Path to this script:
@echo      %~f0
@echo.
@echo   %OSR_VERSTR%
@echo   -^> report any problems to ^<info@osr.com^> or ^<http://assarbad.net/contact/^>
@echo.

:END
popd & endlocal & exit /b %OSR_ERRCODE%
```

`DpcTimer_x64/DpcTimerDrv/makefile`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

`DpcTimer_x64/DpcTimerDrv/mybuild.bat`:

```bat
set WLHBASE=C:\WINDDK\7600.16385.0
set WDF_ROOT=C:\WINDDK\7600.16385.0
ddkbuild.cmd -WLH chk . -cZ -WDF
```

`DpcTimer_x64/DpcTimerDrv/sources`:

```
TARGETNAME=DpcTimerDrv
#TARGETPATH=$(BASEDIR)\lib
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=.\

SOURCES=DpcTimerDrv.c


```

`DrxHook/DrxHook/DrxHook.c`:

```c


#ifndef CXX_DRXHOOK_H
#	include "DrxHook.h"
#endif

#include <ntimage.h>


KIRQL  Irql;
PDRIVER_OBJECT g_LocalDriverObj;
BOOLEAN        g_bHookSuccess;
ULONG_PTR      g_RtlDispatchExeceptionAddress;
ULONG_PTR      g_JmpOrigDispatchException;
UCHAR		   g_cDisExceptionCode[5];

ULONG_PTR g_JmpOrigNtOpenProcess;

void __declspec(naked)  NewNtOpenProcess()
{

	__asm
	{
		pushad
		pushfd

		call FilterNtOpenProcess

		popfd
		popad

		mov		edi , edi
		push	esp
		mov		ebp , esp
		//跳过NtOpenProcess的前五个字节，
		//避免再次触发异常
		jmp		g_JmpOrigNtOpenProcess
	}
}


void __declspec(naked) NewRtlDispatchException()
{
	__asm
	{
		mov   edi,edi
		push  ebp
		mov   ebp , esp
		pushad     //保存所有寄存器
		pushfd     //保存标志寄存器
		push	[ebp+0xc]
		push	[ebp+0x8]
		call	FilterRtlDispatchException
		//检测返回值是否为0
		test	eax , eax
		jz		__SafeExit  // 若eax为0 跳转__SafeExit
		popfd
		popad
		mov		esp , ebp
		pop		ebp
		//  将KiDispatchException中对于RtlDispatchException的返回值进行校验，
		//  如果为0 则对异常进行重新派发，为1则不再做处理
		mov		eax ,0x01   
		retn	0x8     //平衡堆栈，两个参数8字节

__SafeExit:

		popfd
		popad
		mov		esp , ebp
		pop		ebp

		//先执行RtlDispatchException原来的5个字节的内容
		mov		edi , edi
		push	ebp
		mov		ebp , esp
		jmp g_JmpOrigDispatchException
	}
}


NTSTATUS  _stdcall FilterNtOpenProcess ()
{
	DbgPrint("FilterNtOpenProcess---%s\r\n",(ULONG_PTR)PsGetCurrentProcess()+0x16c);
	return  STATUS_SUCCESS;
}



ULONG_PTR _stdcall
	FilterRtlDispatchException (
	IN PEXCEPTION_RECORD ExceptionRecord,
	IN PCONTEXT ContextRecord
	)
{

	//DbgPrint("Address:%x -- ExceptionCode:%x\r\n",ExceptionRecord->ExceptionAddress,ExceptionRecord->ExceptionCode);
	//如果是NtOpenProcess处的异常
	if (ExceptionRecord->ExceptionAddress == (PVOID)KeServiceDescriptorTable.ServiceTableBase[190])
	{
		KdPrint(("<Except addresss>:%X <seh callBack>:%X -- <Except code>:%X",
			ContextRecord->Eip,ExceptionRecord->ExceptionAddress,ExceptionRecord->ExceptionCode));

		//将执行的下一条指令置为NewNtOpenProcess() 函数的地址，CPU接着去执行NewNtOpenProcess
		ContextRecord->Eip = (ULONG_PTR)NewNtOpenProcess;
		//返回TRUE,异常不再进行派发
		return 1;
	}
	return 0;
}

VOID SetMonitor(PVOID Address)
{

	__asm
	{
		mov eax , Address
		mov DR0 , eax
		mov eax , 0x02  //全局的，仅当执行时产生异常
		mov DR7 , eax
	}
}


VOID CancelMonitor(PVOID Address)
{

	__asm
	{
		xor eax , eax
		mov DR0 , eax
		mov DR7 , eax
	}
}
NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING RegistryString)
{
	NTSTATUS	Status = STATUS_SUCCESS;
	g_LocalDriverObj = pDriverObject;
	HookRtlDispatchException();
	g_JmpOrigNtOpenProcess = (ULONG_PTR)(KeServiceDescriptorTable.ServiceTableBase[190] + 0x5);
	//为了方便，这里写死了，NtOpenProcess  Win7 x86 
	SetMonitor((PVOID)KeServiceDescriptorTable.ServiceTableBase[190]);
	return Status;
}

VOID HookRtlDispatchException()
{

	PLDR_DATA_TABLE_ENTRY Ldr = NULL;
	//构建RtlDispatchException 的特征码
	// 	nt!KiDispatchException+0x160:
	// 	83eff040 53              push    ebx
	// 	83eff041 ff750c          push    dword ptr [ebp+0Ch]
	// 	83eff044 ff7510          push    dword ptr [ebp+10h]
	// 	83eff047 ff15bc49fb83    call    dword ptr [nt!KiDebugRoutine (83fb49bc)]
	// 	83eff04d 84c0            test    al,al
	// 	83eff04f 0f859d000000    jne     nt!KiDispatchException+0x211 (83eff0f2)
	// 	83eff055 57              push    edi
	// 	83eff056 53              push    ebx
	// 	83eff057 e8 a372ffff      call    nt!RtlDispatchException (83ef62ff)


	// 	kd> u 83ef62ff
	// 	nt!RtlDispatchException:
	// 	83ef62ff 8bff            mov     edi,edi
	// 	83ef6301 55              push    ebp
	// 	83ef6302 8bec            mov     ebp,esp


	// 	83ef6304 83e4f8          and     esp,0FFFFFFF8h
	// 	83ef6307 83ec6c          sub     esp,6Ch
	// 	83ef630a 53              push    ebx
	// 	83ef630b 56              push    esi
	// 	83ef630c 57              push    edi


	SIGNATURE_INFO SignCode[] = {{0x84,10},{0xc0,9},{0x57,2},{0x53,1},{0xE8,0}};
#ifndef _DEBUG
	__asm int 3
#endif 

	g_bHookSuccess  = FALSE;
	Ldr = SearchDriver(g_LocalDriverObj,L"ntoskrnl.exe");
	if (!Ldr)   return;
	g_RtlDispatchExeceptionAddress = SearchAddressForSignFromPE((ULONG_PTR)(Ldr->DllBase),Ldr->SizeOfImage,SignCode);	
	if (!MmIsAddressValid((PVOID)g_RtlDispatchExeceptionAddress))  return;
	//利用偏移转成绝对地址                                    +5 过e8 a372ffff 这五个字节
	g_RtlDispatchExeceptionAddress = g_RtlDispatchExeceptionAddress+5 + *(ULONG_PTR*)(g_RtlDispatchExeceptionAddress+1);
	//过被占的前5个字节，继续执行的代码
	DbgPrint("RtlDispatchExceptionAddresss:%x",g_RtlDispatchExeceptionAddress);
	g_JmpOrigDispatchException = g_RtlDispatchExeceptionAddress + 5;
	g_bHookSuccess = Jmp_HookFunction(g_RtlDispatchExeceptionAddress,(ULONG_PTR)NewRtlDispatchException,g_cDisExceptionCode);
}

//搜索整个PE文件的
ULONG_PTR SearchAddressForSignFromPE(ULONG_PTR uStartBase,ULONG_PTR uSearchLength,SIGNATURE_INFO SignatureInfo[5])
{
	UCHAR *p;
	ULONG_PTR u_index1,u_index2;

	//ULONG uIndex;
	PIMAGE_DOS_HEADER pimage_dos_header;
	PIMAGE_NT_HEADERS pimage_nt_header;
	PIMAGE_SECTION_HEADER pimage_section_header;

	if(!MmIsAddressValid((PVOID)uStartBase))
	{	return 0;	}

	pimage_dos_header = (PIMAGE_DOS_HEADER)uStartBase;
	pimage_nt_header = (PIMAGE_NT_HEADERS)((ULONG)uStartBase+pimage_dos_header->e_lfanew);
	pimage_section_header = (PIMAGE_SECTION_HEADER)((ULONG)pimage_nt_header+sizeof(IMAGE_NT_HEADERS));

	for (u_index1 = 0;u_index1<pimage_nt_header->FileHeader.NumberOfSections;u_index1++)
	{
		//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
		//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
		//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
		//0x60000000 = IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_READ
		if (pimage_section_header[u_index1].Characteristics&0x60000000)
		{
			p = (UCHAR*)uStartBase + pimage_section_header[u_index1].VirtualAddress;
			for (u_index2 = 0;u_index2<pimage_section_header[u_index1].Misc.VirtualSize;u_index2++)
			{
				if (!MmIsAddressValid((p-SignatureInfo[0].Offset))||
					!MmIsAddressValid((p-SignatureInfo[4].Offset)))
				{
					p++;
					continue;
				}
				__try{
					if (*(p-SignatureInfo[0].Offset)==SignatureInfo[0].cSingature&&
						*(p-SignatureInfo[1].Offset)==SignatureInfo[1].cSingature&&
						*(p-SignatureInfo[2].Offset)==SignatureInfo[2].cSingature&&
						*(p-SignatureInfo[3].Offset)==SignatureInfo[3].cSingature&&
						*(p-SignatureInfo[4].Offset)==SignatureInfo[4].cSingature)
					{
						return (ULONG_PTR)p;
					}

				}__except(EXCEPTION_EXECUTE_HANDLER){
					DbgPrint("Search error!");
				}
				p++;
			}
		}
	}

	return 0;
}


BOOLEAN	Jmp_HookFunction(
	IN ULONG Destination,
	IN ULONG Source,
	IN UCHAR *Ori_Code
	)
{
	ULONG	jmp_offset;
	UCHAR	jmp_code[5] = {0xE9};

	KSPIN_LOCK lock;
	KIRQL irql;

	if (Destination==0||Source==0)
	{
		DbgPrint("Params error!");
		return FALSE;
	}

	RtlCopyMemory(Ori_Code,(PVOID)Destination,5);
	jmp_offset = Source - (Destination+5);

	*(ULONG*)&jmp_code[1] = jmp_offset;   //放入偏移

	KeInitializeSpinLock (&lock );
	KeAcquireSpinLock(&lock,&irql);

	WPOFF();
	RtlCopyMemory((PVOID)Destination,jmp_code,5);
	WPON();

	KeReleaseSpinLock (&lock,irql);

	return TRUE;
}




VOID WPOFF()
{
	ULONG_PTR cr0 = 0;
	Irql = KeRaiseIrqlToDpcLevel();
	cr0 =__readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);

}





VOID WPON()
{

	ULONG_PTR cr0=__readcr0();
	cr0 |= 0x10000;
	__writecr0(cr0);
	KeLowerIrql(Irql);
}


//简单的通过链表获得内核模块的基本信息
PLDR_DATA_TABLE_ENTRY SearchDriver(PDRIVER_OBJECT pDriverObject,wchar_t *strDriverName)
{
	LDR_DATA_TABLE_ENTRY	*pdata_table_entry,*ptemp_data_table_entry;
	PLIST_ENTRY				plist;
	UNICODE_STRING			str_module_name;

	RtlInitUnicodeString(&str_module_name,strDriverName);
	pdata_table_entry = (LDR_DATA_TABLE_ENTRY*)pDriverObject->DriverSection;
	if (!pdata_table_entry)
	{
		return 0;
	}
	plist = pdata_table_entry->InLoadOrderLinks.Flink;

	while(plist!= &pdata_table_entry->InLoadOrderLinks)
	{
		ptemp_data_table_entry = (LDR_DATA_TABLE_ENTRY *)plist;

		//DbgPrint("%wZ",&pTempDataTableEntry->BaseDllName);
		if (0==RtlCompareUnicodeString(&ptemp_data_table_entry->BaseDllName,&str_module_name,FALSE))
		{
			return ptemp_data_table_entry;
		}

		plist = plist->Flink;
	}

	return 0;
}





VOID UnloadDriver(PDRIVER_OBJECT DriverObject)
{
	if (g_bHookSuccess)
	{
		ResumeHookFunction(g_RtlDispatchExeceptionAddress,g_cDisExceptionCode,0x5);
	}

}


VOID ResumeHookFunction(
	IN ULONG	Destination,
	IN UCHAR	*Ori_Code,
	IN ULONG	Length
	)
{
	KSPIN_LOCK lock;
	KIRQL irql;

	if (Destination==0||Ori_Code==0)	return;	

	KeInitializeSpinLock (&lock );
	KeAcquireSpinLock(&lock,&irql);

	WPOFF();
	RtlCopyMemory((PVOID)Destination,Ori_Code,Length);
	WPON();

	KeReleaseSpinLock (&lock,irql);
}

```

`DrxHook/DrxHook/DrxHook.h`:

```h

#ifndef CXX_DRXHOOK_H
#define CXX_DRXHOOK_H



#include <ntifs.h>
#include <devioctl.h>
#endif	

typedef struct _SYSTEM_SERVICE_TABLE32 {
	ULONG_PTR*   ServiceTableBase;
	ULONG_PTR*   ServiceCounterTableBase;
	ULONG32 NumberOfServices;
	ULONG_PTR*   ParamTableBase;
} SYSTEM_SERVICE_TABLE32, *PSYSTEM_SERVICE_TABLE32;

typedef struct _SYSTEM_SERVICE_TABLE64{
	ULONG_PTR* 		ServiceTableBase; 
	ULONG_PTR* 		ServiceCounterTableBase; 
	ULONG64  		NumberOfServices; 
	ULONG_PTR* 		ParamTableBase; 
} SYSTEM_SERVICE_TABLE64, *PSYSTEM_SERVICE_TABLE64;

#ifndef _WIN64
#define		_SYSTEM_SERVICE_TABLE   _SYSTEM_SERVICE_TABLE64
#define		SYSTEM_SERVICE_TABLE	 SYSTEM_SERVICE_TABLE64
#define		PSYSTEM_SERVICE_TABLE	 PSYSTEM_SERVICE_TABLE64
#else
#define		_SYSTEM_SERVICE_TABLE   _SYSTEM_SERVICE_TABLE32
#define		SYSTEM_SERVICE_TABLE	 SYSTEM_SERVICE_TABLE32
#define		PSYSTEM_SERVICE_TABLE	 PSYSTEM_SERVICE_TABLE32
#endif



__declspec(dllimport) SYSTEM_SERVICE_TABLE KeServiceDescriptorTable;

//结构声明
typedef struct _SIGNATURE_INFO{
	UCHAR	cSingature;
	int		Offset;
}SIGNATURE_INFO,*PSIGNATURE_INFO;


typedef struct _LDR_DATA_TABLE_ENTRY                         // 24 elements, 0x78 bytes (sizeof) 
{                                                                                                
	/*0x000*/     struct _LIST_ENTRY InLoadOrderLinks;       // 2 elements, 0x8 bytes (sizeof)   
	/*0x008*/     PVOID ExceptionTable;  
	/*0x00C*/	  ULONG ExceptionTableSize;
	/*0x010*/     struct _LIST_ENTRY InInitializationOrderLinks; // 2 elements, 0x8 bytes (sizeof)   
	/*0x018*/     VOID*        DllBase;                                                                        
	/*0x01C*/     VOID*        EntryPoint;                                                                     
	/*0x020*/     ULONG32      SizeOfImage;                                                                    
	/*0x024*/     struct _UNICODE_STRING FullDllName;             // 3 elements, 0x8 bytes (sizeof)   
	/*0x02C*/     struct _UNICODE_STRING BaseDllName;             // 3 elements, 0x8 bytes (sizeof)   
	/*0x034*/     ULONG32      Flags;                                                                          
	/*0x038*/     UINT16       LoadCount;                                                                      
	/*0x03A*/     UINT16       TlsIndex;                                                                       
	union                                                    // 2 elements, 0x8 bytes (sizeof)   
	{                                                                                            
    /*0x03C*/     struct _LIST_ENTRY HashLinks;           // 2 elements, 0x8 bytes (sizeof)   
		struct                                          // 2 elements, 0x8 bytes (sizeof)   
		{                                                                                        
			/*0x03C*/             VOID*        SectionPointer;                                                         
			/*0x040*/             ULONG32      CheckSum;                                                               
		};                                                                                       
	};                                                                                           
	union                                                    // 2 elements, 0x4 bytes (sizeof)   
	{                                                                                            
		/*0x044*/         ULONG32      TimeDateStamp;                                                              
		/*0x044*/         VOID*        LoadedImports;                                                              
	};                                                                                           
	/*0x048*/     VOID* EntryPointActivationContext;                                     
	/*0x04C*/     VOID*        PatchInformation;                                                               
	/*0x050*/     struct _LIST_ENTRY ForwarderLinks;                       // 2 elements, 0x8 bytes (sizeof)   
	/*0x058*/     struct _LIST_ENTRY ServiceTagLinks;                      // 2 elements, 0x8 bytes (sizeof)   
	/*0x060*/     struct _LIST_ENTRY StaticLinks;                          // 2 elements, 0x8 bytes (sizeof)   
	/*0x068*/     VOID*        ContextInformation;                                                             
	/*0x06C*/     ULONG32      OriginalBase;                                                                   
	/*0x070*/     union _LARGE_INTEGER LoadTime;                           // 4 elements, 0x8 bytes (sizeof)   
}LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;


ULONG_PTR _stdcall
	FilterRtlDispatchException (
	IN PEXCEPTION_RECORD ExceptionRecord,
	IN PCONTEXT ContextRecord
	);
VOID HookRtlDispatchException();
VOID UnloadDriver(PDRIVER_OBJECT DriverObject);
PLDR_DATA_TABLE_ENTRY SearchDriver(PDRIVER_OBJECT pDriverObject,wchar_t *strDriverName);
BOOLEAN	Jmp_HookFunction(IN ULONG Destination,IN ULONG Source,IN UCHAR *Ori_Code);
VOID ResumeHookFunction(IN ULONG	Destination,IN UCHAR	*Ori_Code,IN ULONG	Length);
ULONG_PTR SearchAddressForSignFromPE(ULONG_PTR uStartBase,
                 ULONG_PTR uSearchLength,
                 SIGNATURE_INFO SignatureInfo[5]);
VOID WPOFF();
NTSTATUS  _stdcall FilterNtOpenProcess ();
VOID WPON();
VOID SetMonitor(PVOID Address);
VOID CancelMonitor(PVOID Address);
```

`DrxHook/DrxHook/DrxHook.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DrxHook", "DrxHook.vcxproj", "{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		WinDDK|Win32 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.ActiveCfg = WinDDK|Win32
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.Build.0 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`DrxHook/DrxHook/DrxHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="WinDDK|Win32">
      <Configuration>WinDDK</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>"DrxHook"</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
    <ExecutablePath>$(WLHBASE)\bin\x86\x86;$(WLHBASE)\bin\x86</ExecutablePath>
    <IncludePath>$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc</IncludePath>
    <ReferencePath />
    <LibraryPath>$(WLHBASE)\lib\win7\i386</LibraryPath>
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG=1</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include=".\DrxHook.c" />
    <ClCompile Include=".\DrxHook.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DrxHook/DrxHook/DrxHook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`DrxHook/DrxHook/clean.bat`:

```bat
rem /////////////////
rem / Add by ChiChou
rem / 
rem / FileName:Clean.bat
rem / Description:Clean
rem /
rem ////////////////
rd .\bin /s /q
rd .\WinDDK /s /q
rd .\objchk_w2k_x86 /s /q
rd .\objchk_wxp_x86 /s /q
rd .\objchk_wnet_x86 /s /q
rd .\objchk_wlh_x86 /s /q
rd .\objfre_w2k_x86 /s /q
rd .\objfre_wxp_x86 /s /q
rd .\objfre_wnet_x86 /s /q
rd .\objfre_wlh_x86 /s /q
del .\*.log
del .\*.err
del .\*.xml
rem ***** del VS2005 file *****
del .\*.ncb
del .\*.user
del .\*.suo /A:H
rem ***** del VS6.0 file *****
del .\*.plg
del .\*.opt
exit
```

`DrxHook/DrxHook/ddkbuild.cmd`:

```cmd
@echo off
@set VERSION=V7.3
@set OSR_DEBUG=off
@if "%OS%"=="Windows_NT" goto :Prerequisites
@echo This script requires Windows NT 4.0 or later to run properly!
goto :EOF
:Prerequisites
:: Check whether FINDSTR is available. It's used to show warnings etc.
findstr /? > NUL 2>&1 || echo "FINDSTR is a prerequisite but wasn't found!" && goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    $Id: ddkbuild.cmd 27 2008-09-06 12:02:06Z oliver $
::
::    This software is supplied for instructional purposes only.
::
::    OSR Open Systems Resources, Inc. (OSR) expressly disclaims any warranty
::    for this software.  THIS SOFTWARE IS PROVIDED  "AS IS" WITHOUT WARRANTY
::    OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
::    THE IMPLIED WARRANTIES OF MECHANTABILITY OR FITNESS FOR A PARTICULAR
::    PURPOSE.  THE ENTIRE RISK ARISING FROM THE USE OF THIS SOFTWARE REMAINS
::    WITH YOU.  OSR's entire liability and your exclusive remedy shall not
::    exceed the price paid for this material.  In no event shall OSR or its
::    suppliers be liable for any damages whatsoever (including, without
::    limitation, damages for loss of business profit, business interruption,
::    loss of business information, or any other pecuniary loss) arising out
::    of the use or inability to use this software, even if OSR has been
::    advised of the possibility of such damages.  Because some states/
::    jurisdictions do not allow the exclusion or limitation of liability for
::    consequential or incidental damages, the above limitation may not apply
::    to you.
::
::    OSR Open Systems Resources, Inc.
::    105 Route 101A Suite 19
::    Amherst, NH 03031  (603) 595-6500 FAX: (603) 595-6503
::    report bugs to <bugs@osr.com>
::    alternatively report them via <http://assarbad.net/contact/>
::
::
::    MODULE:
::
::      ddkbuild.cmd
::
::    ABSTRACT:
::
::      This script allows drivers to be built with Visual Studio 2002 through
::      Visual Studio 2008 and possibly future versions. It will also work fine
::      from the command line.
::      If you are interested in a project wizard that makes use of this script,
::      try DDKWizard from <http://ddkwizard.assarbad.net>.
::
::    AUTHOR(S):
::
::      - OSR Open Systems Resources, Inc.
::      - Oliver Schneider (ddkwizard.assarbad.net)
::
::    REQUIREMENTS:
::
::      Environment variables that must be set.
::        %NT4BASE%  - Set this up for "-NT4" builds (legacy, support not tested)
::        %W2KBASE%  - Set this up for "-W2K*" builds (legacy, support not tested)
::        %WXPBASE%  - Set this up for "-WXP*" builds
::        %WNETBASE% - Set this up for "-WNET*" builds
::        %WLHBASE%  - Set this up for "-WLH*" builds
::        %WDF_ROOT% - Must be set if attempting to do a WDF Build.
::
::      Examples:
::        NT4BASE : could be "D:\NT4DDK"
::        W2KBASE : could be "D:\Nt50DDK"
::        WXPBASE : could be "D:\WINDDK\2600"
::        WNETBASE: could be "D:\WINDDK\3790.1830" or "C:\WINDDK\3790"
::
::    COMMAND FORMAT:
::
::      Run the script without any parameters to get the whole help content!
::      Note: "-WDF" has been tested with the 01.00.5054 version of the framework
::
::    RETURN CODES AND THEIR MEANING:
::
::      001 == Unknown build type. Check the <platform> parameter
::      002 == No WDF_ROOT given using WDF build type.
::      003 == The DDK-specific base directory variable (NT4BASE, W2KBASE, WXPBASE,
::             WNETBASE) is not set at all and could not be auto-detected!
::      004 == BASEDIR variable is empty. Check to see that the DDK-specific
::             variable is set correctly (i.e. NT4BASE, W2KBASE, WXPBASE, WNETBASE)
::      005 == No mode (checked/free) was given. Check the respective parameter!
::      006 == No DIR or SOURCES file found in the given target directory.
::      007 == No target directory given.
::      008 == Given target directory does not exist.
::      009 == The SETENV script failed.
::
::      Note: If %OSR_ERRCODE% and %ERRORLEVEL% are equal, the return code stems
::            from one of the tools being called during the build process.
::
::    BROWSE FILES:
::
::      This procedure supports the building of BROWSE files to be used by
::      Visual Studio 6 and by Visual Studio.NET  However, the BSCfiles created
::      by bscmake for the two are not compatible. When this command procedure
::      runs, it selects the first bscmake.exe found in the path. So, make sure
::      that the correct bscmake.exe is in the path ...
::
::      Note that if using Visual Studio.NET the .BSC must be added to the project
::      in order for the project to be browsed.
::      Another alternative is the VS addon named "Visual Assist X" which will
::      parse the header files - no more need for browse files.
::
::    COMPILERS:
::
::      If you are building NT4 you should really be using the VC6 compiler.
::      Later versions of the DDK now contain the compiler and the linker. This
::      procedure should use the correct compiler.
::
::    GENERAL COMMENTS:
::
::      This procedure has been cleaned up to be modular and easy to understand.
::
::      As of the Server 2003 SP1 DDK DDKBUILD now clears the NO_BROWSE_FILE and
::      NO_BINPLACE environment variables so that users can use these features.
::
::      Starting with the Vista WDK, the output in the respective tool window
::      in VS is in Unicode by default. This garbles the output from DDKBUILD
::      and we therefore clear the environment variable VS_UNICODE_OUTPUT.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MAIN
:: Building "stack frame"
setlocal ENABLEEXTENSIONS & pushd .
:: Check whether the REG utility is available
reg /? > NUL 2>&1 && set OSR_REGAVAILABLE=1

:: This is set by client-side keyword substitution
set SVN_REVISION=$Revision: 27 $
:: Extract the revision number from the revision keyword
set SVN_REVISION=%SVN_REVISION:~0,-2%
set SVN_REVISION=%SVN_REVISION:~11%
:: This is set by client-side keyword substitution
set SVN_REVDATE=$Date: 2008-09-06 12:02:06 +0000 (Sat, 06 Sep 2008) $
:: Extract the date from the Date keyword
set SVN_REVDATE=%SVN_REVDATE:~7,10%
set VERSION=%VERSION%/r%SVN_REVISION%

:: Init some special variables
set OSR_VERSTR=OSR DDKBUILD.CMD %VERSION% (%SVN_REVDATE%) - OSR, Open Systems Resources, Inc.
set OSR_PREBUILD_SCRIPT=ddkprebld.cmd
set OSR_POSTBUILD_SCRIPT=ddkpostbld.cmd
set OSR_SETENV_SCRIPT=ddkbldenv.cmd
set OSR_ECHO=@echo DDKBLD:

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set error messages
:: Possible codes: 1
set ERR_UnknownBuildType=Unknown type of build. Please recheck parameters.
:: Possible codes: 2
set ERR_NoWdfRoot=WDF_ROOT is not defined, are you using 00.01.5054 or later?
:: Possible codes: 3
set ERR_BaseDirNotSet=To build using type %%OSR_TARGET%% you need to set the %%%%%%BASEDIRVAR%%%%%% environment variable to point to the %%BASEDIROS%% DDK base directory!
:: Possible codes: 4
set ERR_NoBASEDIR=NT4BASE, W2KBASE, WXPBASE and/or WNETBASE environment variable(s) not set. Environment variable(s) must be set by user according to DDK version(s) installed.
:: Possible codes: 5
set ERR_BadMode=^<build type^> must be 'checked', 'free', 'chk' or 'fre' (case-insensitive).
:: Possible codes: 6
set ERR_NoTarget=Target directory must contain a SOURCES or DIRS file.
:: Possible codes: 7, 8
set ERR_NoDir=The ^<directory^> parameter must be a valid directory.
:: Possible codes: 9
set ERR_SetEnvFailed=The SETENV script failed.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Clear the error code variable
set OSR_ERRCODE=0
set prefast_build=0

:: Turn on tracing, use %OSR_TRACE% instead of ECHO
if /i "%OSR_DEBUG%" == "on" (set OSR_TRACE=%OSR_ECHO% [TRACE]) else (set OSR_TRACE=rem)
:: Turn on echoing of current line if %OSR_DEBUG% is set to "on"
@echo %OSR_DEBUG%

:: Output version string
@echo %OSR_VERSTR%
%OSR_TRACE% ^(Current module: ^"%~f0^"^)
@echo.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set the target platform variable
set OSR_TARGET=%~1
:: Remove any dashes in the variable
if not "%OSR_TARGET%" == "" set OSR_TARGET=%OSR_TARGET:-=%
:: Show help if the target parameter is empty after removal of the dashes
if "%OSR_TARGET%" == "" goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: In the build directory check for this script and call it if it exists.
:: This allows to override any global system variable setting, if desired.
if not "%3" == "" call :GetCustomEnvironment "%~f3"
if not "%OSR_ERRCODE%" == "0" goto :USAGE
:: Additional error handling for better usability
:: These subroutines will also attempt to locate the requested DDK!!!
set OSR_ERRCODE=3
%OSR_TRACE% Checking whether the environment variable for the build type was set
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Check > NUL 2>&1
:: If the BASEDIROS/BASEDIRVAR variable is not defined, it means the subroutine did not exist!
if not DEFINED BASEDIROS call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIROS)" & goto :USAGE
if not DEFINED BASEDIRVAR call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIRVAR)" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BaseDirNotSet%" & goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
set BASEDIR=%%%BASEDIRVAR%%%
call :ResolveVar BASEDIR
call :MakeShort BASEDIR "%BASEDIR%"
:: Check for existing %BASEDIR%
if "%BASEDIR%" == "" call :ShowErrorMsg 4 "%ERR_NoBASEDIR%" & goto :USAGE
set PATH=%BASEDIR%\bin;%PATH%
%OSR_TRACE% Now jump to the initialization of the commandline
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Build

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_TRACE% We returned from the variable initialization
if not DEFINED OSR_CMDLINE call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (OSR_CMDLINE)" & goto :USAGE

%OSR_TRACE% Hurrah, all the variables have been initialized, continuing
:: Proceed with common build steps
goto :CommonBuild

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Check whether the parameter makes sense and try to
:: correct it if possible
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WLH64Check
:WLHA64Check
:WLHXP64Check
:WLHNET64Check
:WLHNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WLHCheck
:WLHX64Check
:WLHI64Check
:WLHNETX64Check
:WLHNETI64Check
:WLHXPCheck
:WLH2KCheck
:WLHNETCheck
set BASEDIROS=Windows Vista/Windows 2008 Server
set BASEDIRVAR=WLHBASE
:: Compatibility between BUILD and VS ... prevent pipes from being used
%OSR_ECHO% Clearing %%VS_UNICODE_OUTPUT%% ...
set VS_UNICODE_OUTPUT=
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "6001.18000 6000"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WNETW2KCheck
:WNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WNET2KCheck
:WNETXPCheck
:WNETWXPCheck
:WNETXP64Check
:WNET64Check
:WNETI64Check
:WNETAMD64Check
:WNETX64Check
:WNETCheck
set BASEDIROS=Windows 2003 Server
set BASEDIRVAR=WNETBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "3790.1830 3790.1218 3790"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:XPCheck
:XP64Check
:XPW2KCheck
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WXP64Check
:WXPI64Check
:WXPCheck
:WXP2KCheck
set BASEDIROS=Windows XP
set BASEDIRVAR=WXPBASE
:: Other flavor of DDKBUILD
if not DEFINED WXPBASE if DEFINED XPBASE set BASEDIRVAR=XPBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "2600.1106 2600"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:W2K64Check
:W2KI64Check
:W2KCheck
set BASEDIROS=Windows 2000
set BASEDIRVAR=W2KBASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:NT4Check
set BASEDIROS=Windows NT4
set BASEDIRVAR=NT4BASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg1
echo.
%OSR_ECHO% WARNING: %%%BASEDIRVAR%%% NOT SET!
%OSR_ECHO%   Attempting to auto-detect the installation folder and set %%%BASEDIRVAR%%%.
%OSR_ECHO%   (If this fails *you* will have to set it!)
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg2
echo.
%OSR_ECHO% WARNING:
%OSR_ECHO%   Auto-detection of the folder settings is not supported for the requested DDK.
%OSR_ECHO%   Please set %%%BASEDIRVAR%%% yourself!
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckSetVarWithReturn
%OSR_ECHO% Found!
echo.
set %BASEDIRVAR%=%BASEDIRTEMP%
set BASEDIRTEMP=
:: Tell the caller it was successful
:CommonCheckNoErrorWithReturn
set OSR_ERRCODE=0
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckErrorNotDetectedWithReturn
echo.
%OSR_ECHO% None of the usual default paths works. Set %%%BASEDIRVAR%%% manually!
:CommonCheckErrorNotSupportedWithReturn
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Initialize variables specific to the respective platform
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: 
:: Valid parameters for setenv in different DDKs/WDKs:
::
:: 2600       - "setenv <directory> [fre|chk] [64] [hal]"
:: 2600.1106  - "setenv <directory> [fre|chk] [64] [hal] [WXP|W2K]"
:: 3790       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K]"
:: 3790.1830  - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K] [no_prefast] [bscmake]"
:: 6000       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"
:: 6001.18000 - "setenv <directory> [fre|chk] [64|x64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: NT 4.0 build using NT4 DDK
:NT4Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% "%%MSDEVDIR%%"
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WXP DDK
:XPW2KBuild
:WXP2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\w2k\set2k.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 64bit (Intel) using W2K DDK
:W2K64Build
:W2KI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv64.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using W2K DDK
:W2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WXP DDK
:XP64Build
:WXP64Build
:WXPI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WXP DDK
:XPBuild
:WXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WNET DDK
:WNETW2KBuild
:WNET2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% W2K %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WNET DDK
:WNETXPBuild
:WNETWXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit using WNET DDK
:WNETXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WNET DDK
:WNET64Build
:WNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WNET DDK
:WNETA64Build
:WNETAMD64Build
:WNETX64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% AMD64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WNET DDK
:WNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 32bit using WLH DDK
:WLHBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (AMD) using WLH DDK
:WLHA64Build
:WLHX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (Intel) using WLH DDK
:WLH64Build
:WLHI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WLH DDK
:WLHNETA64Build
:WLHNETX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WLH DDK
:WLHNET64Build
:WLHNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WLH DDK
:WLHXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WLH DDK
:WLHXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WLH DDK
:WLH2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% W2K
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WLH DDK
:WLHNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: All builds go here for the rest of the procedure. Now,
:: we are getting ready to call build. The big problem
:: here is to figure our the name of the buildxxx files
:: being generated for the different platforms.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:CommonBuild
:: Remove first command line arg
shift
call :SetMode %1
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BadMode%" & goto :USAGE
set OSR_BUILDNAME=%OSR_TARGET% (%BuildMode%) using the %BASEDIROS% DDK and %%%BASEDIRVAR%%%

call :CheckTargets %2
if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :USAGE

:: Resolve any variables in the command line string
call :ResolveVar OSR_CMDLINE

pushd .
set ERRORLEVEL=0
:: This external script prepares the build environment (e.g. setenv.bat)
call %OSR_CMDLINE%
:: Will only work with newer SETENV.BAT versions, but will be helpful in this case.
if not "%ERRORLEVEL%" == "0" call :ShowErrorMsg 9 "%ERR_SetEnvFailed%" & goto :USAGE
popd

:: ----------------------------------------------------------------------------
:: Setting global variables for the scope of this CMD session
set NO_BROWSER_FILE=
set NO_BINPLACE=
set buildDirectory=%~fs2
call :MakeShort buildDirectory "%buildDirectory%"
set buildDirectory_raw=%2
set buildDirectory_fname=%~n2
%OSR_TRACE% buildDirectory       == %buildDirectory%
%OSR_TRACE% buildDirectory_raw   == %buildDirectory_raw%
%OSR_TRACE% buildDirectory_fname == %buildDirectory_fname%

set mpFlag=-M
if "%BUILD_ALT_DIR%" == "" goto :NT4

:: W2K sets this!
set OSR_EXT=%BUILD_ALT_DIR%
set mpFlag=-MI

:NT4
if "%NUMBER_OF_PROCESSORS%" == "" set mpFlag=
if "%NUMBER_OF_PROCESSORS%" == "1" set mpFlag=

:: Set additional variables at this point or do whatever you please
@if exist "%buildDirectory%\%OSR_PREBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_PREBUILD_SCRIPT%" > "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
)
:: Save the current directory (before changing into the build directory!)
:: AFTERPREBUILD
pushd .

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Determine the settings of flags, WDF and PREFAST in
:: other words what was set for %3 and beyond....
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_ECHO% %OSR_BUILDNAME%
set OSR_ARGS= + argument(s):
if not "%3" == "" set OSR_ARGS=%OSR_ARGS% %3
if not "%4" == "" set OSR_ARGS=%OSR_ARGS% %4
if not "%5" == "" set OSR_ARGS=%OSR_ARGS% %5
if /i "%OSR_ARGS%" == " + argument(s):" set OSR_ARGS=
%OSR_ECHO% Directory: %buildDirectory%%OSR_ARGS%
%OSR_ECHO% %BASEDIRVAR%: %BASEDIR%

cd /D %~s2
set bFlags=-Ze
set bscFlags=

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ContinueParsing
if "%3" == "" goto :DONE
if "%3" == "/a" goto :RebuildallFound
if /i "%3" == "-WDF" goto :WDFFound
if /i "%3" == "-PREFAST" goto :PrefastFound
set bscFlags=/n
set bFlags=%bFlags% %3
:: Remove next arg
shift
goto :ContinueParsing

:WDFFound
shift
:: Note, that the setwdf.bat is called from setenv.bat in the WDK,
:: therefore we skip it.
if /i "%BASEDIRVAR%" == "WLHBASE" goto :WDFOkay
if "%WDF_ROOT%" == "" call :ShowErrorMsg 2 "%ERR_NoWdfRoot%" & goto :USAGE
pushd .
if exist "%WDF_ROOT%\set_wdf_env.cmd" call "%WDF_ROOT%\set_wdf_env.cmd"
popd
:WDFOkay
goto :ContinueParsing

:PrefastFound
shift
set prefast_build=1
goto :ContinueParsing

:RebuildallFound
shift
set bscFlags=/n
set bFlags=%bFlags:-Ze=-cfeZ%
set bFlags=%bFlags: -cZ=%
goto :ContinueParsing
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:DONE
for %%x in (build%OSR_EXT%.err build%OSR_EXT%.wrn build%OSR_EXT%.log prefast%OSR_EXT%.log) do @(
  if exist "%%x"   del /f /q "%%x"
)

if not "%prefast_build%" == "0" goto :RunPrefastBuild
%OSR_ECHO% Run build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
pushd .
build %mpFlag% %bFlags%
popd
goto :BuildComplete

:RunPrefastBuild
%OSR_ECHO% Run prefast build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
setlocal ENABLEEXTENSIONS & pushd .
set PREFASTLOG=PREfast_defects_%OSR_EXT%.xml
prefast /log=%PREFASTLOG% /reset build %mpFlag% %bFlags% > NUL 2>&1
if "%errorlevel%" GTR "0" set OSR_ERRCODE=%errorlevel%
prefast /log=%PREFASTLOG% list > prefast%OSR_EXT%.log
%OSR_ECHO% The PREfast logfile is ^"%prefastlog%^"!
popd & endlocal

:BuildComplete
if not "%errorlevel%" == "0" set OSR_ERRCODE=%errorlevel%

@echo %OSR_DEBUG%
:: Assume that the onscreen errors are complete!
setlocal
set WARNING_FILE_COUNT=0
if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+1
)
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% ================ Build warnings =======================
  if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set WARNING_FILE_COUNT_PRE=0
if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT_PRE=%WARNING_FILE_COUNT_PRE%+1
)
:: Reset if this is no PREfast build
if "%prefast_build%" == "0" set WARNING_FILE_COUNT_PRE=0
if not "%WARNING_FILE_COUNT_PRE%" == "0" (
  %OSR_ECHO% =============== PREfast warnings ======================
  if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+%WARNING_FILE_COUNT_PRE%
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% =======================================================
)
endlocal
@echo.
%OSR_ECHO% Build complete
%OSR_ECHO% Building browse information files
if exist "buildbrowse.cmd" call "buildbrowse.cmd" & goto :postBuildSteps
set sbrlist=sbrList.txt
if not exist sbrList%CPU%.txt goto :sbrDefault
set sbrlist=sbrList%CPU%.txt

:sbrDefault
if not exist %sbrlist% goto :postBuildSteps
:: Prepend blank space
if not "%bscFlags%" == "" set bscFlags= %bscFlags%
:: bscmake%bscFlags% prevents a double blank space ...
bscmake%bscFlags% @%sbrlist%

:: Perform whatever post-build steps
:postBuildSteps
:: Restore the current directory (after changing into the build directory!)
:: Search upwards for "AFTERPREBUILD" to find the corresponding PUSHD
popd
@if exist "%buildDirectory%\%OSR_POSTBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_POSTBUILD_SCRIPT%" > "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
)
goto :END
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / GetCustomEnvironment
::    First parameter is the "directory" that supposedly contains the SOURCES
::    or DIRS file (and the build scripts)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:GetCustomEnvironment
pushd .
call :CheckTargets "%~f1"
@if not "%OSR_ERRCODE%" == "0" @(
  echo.
  %OSR_ECHO% The target directory seemed to not contain a DIRS or SOURCES file
  %OSR_ECHO% when trying to set a custom environment! Quitting.
  set buildDirectory=%~f1
  if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :GetCustomEnvironment_ret
  call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :GetCustomEnvironment_ret
  goto :GetCustomEnvironment_ret
)
:: If the user provided a script to customize the environment, execute it.
@if exist "%~f1\%OSR_SETENV_SCRIPT%" @(
  %OSR_ECHO% ^>^> Setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
  pushd "%~f1"
  call "%OSR_SETENV_SCRIPT%" > "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_SETENV_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
)
:GetCustomEnvironment_ret
popd
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ GetCustomEnvironment
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / SetMode
::    Subroutine to validate the mode of the build passed in. It must be free,
::    FREE, fre, FRE or checked, CHECKED, chk, CHK. Anything else is an error.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetMode
set BuildMode=
if /i "%OSR_TARGET%" == "WLH2K" goto :SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=free
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=checked
goto :SetModeCommonEnd
:SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=f
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=c
:SetModeCommonEnd
%OSR_TRACE% Mode set to ^"%BuildMode%^"
if "%BuildMode%" == "" set OSR_ERRCODE=5
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ SetMode
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / CheckTargets subroutine
::   Subroutine to validate that the target directory exists and that there is
::   either a DIRS or SOURCES and MakeFile in it.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CheckTargets
:: Building "stack frame"
setlocal & pushd . & set OSR_ERRCODE=0
set lTarget=%~1
if not "%lTarget%" == "" goto :CheckTargets1
set OSR_ERRCODE=7
goto :CheckTargets_ret
:CheckTargets1
if exist "%lTarget%" goto :CheckTargets2
set OSR_ERRCODE=8
goto :CheckTargets_ret
:CheckTargets2
if not exist "%lTarget%\DIRS" goto :CheckTargets3
set OSR_ERRCODE=0
goto :CheckTargets_ret
:CheckTargets3
if exist "%lTarget%\SOURCES" goto :CheckTargets4
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets4
if exist "%lTarget%\MAKEFILE" goto :CheckTargets5
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets5
set OSR_ERRCODE=0
:CheckTargets_ret
:: Cleaning "stack frame" and returning error code into global scope
popd & endlocal & set OSR_ERRCODE=%OSR_ERRCODE%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ CheckTargets subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ResolveVar subroutine
::   There is only one parameter, the name of the variable to be resolved!
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ResolveVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
set VAR_TEMPRET2=%%%VAR_NAME%%%
:ResolveVarLoop
set VAR_TEMPRET1=%VAR_TEMPRET2%
set VAR_TEMPRET2=%VAR_TEMPRET1%
for /f "tokens=*" %%i in ('echo %VAR_TEMPRET1%') do (
  set VAR_TEMPRET2=%%i
)
if not "%VAR_TEMPRET1%" == "%VAR_TEMPRET2%" goto :ResolveVarLoop
:: Re-export the variable out of the local scope
endlocal & set %VAR_NAME%=%VAR_TEMPRET1%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ResolveVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MakeShort subroutine
::   Two parameters. First parameter is the variable name, second is the path
::   to convert into a short filename.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MakeShort
setlocal ENABLEEXTENSIONS
:: Get the name of the variable we are working with and the path to convert
set VAR_NAME=%~1
set PATH_SHORT=%~dpns2
set PATH_EXTSHORT=%~xs2
if not "" == "%PATH_EXTSHORT%" set PATH_EXTSHORT=%PATH_EXTSHORT:~0,4%
set PATH_SHORT=%PATH_SHORT%%PATH_EXTSHORT%
endlocal & set %VAR_NAME%=%PATH_SHORT%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MakeShort subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ErrorWithUsage subroutine
::   This one will take the passed in parameters and build a nice error
::   message which is returned to the user along with the usage hints.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ShowErrorMsg
@set OSR_ERRCODE=%~1
@set OSR_ERRMSG=%~2
@set OSR_ERRMSG=%OSR_ERRMSG:'="%
@set OSR_ERRMSG=ERROR #%OSR_ERRCODE%: %OSR_ERRMSG%
@echo.
%OSR_ECHO% %OSR_ERRMSG%
if DEFINED buildDirectory %OSR_ECHO% -^> Target directory: %buildDirectory%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ErrorWithUsage subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / SetVar subroutine
::   Param1 == name of the variable, Param2 == value to be set for the variable
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
endlocal & set %VAR_NAME%=%~2
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ SetVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectVistaWDK subroutine
::   No parameters expected
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectVistaWDK
setlocal ENABLEEXTENSIONS
:: Newer flag (starting with W2K8) is default
set OSR_AMD64FLAG=x64
:: The Vista WDK accepted *only* "AMD64", the newer W2K8 WDK accepts only "x64"
:: We detect the older one by checking the setenv.bat for a certain string
findstr /C:"Windows Server Longhorn" "%BASEDIR%\bin\setenv.bat" > NUL 2>&1 && set OSR_AMD64FLAG=AMD64
endlocal & set OSR_AMD64FLAG=%OSR_AMD64FLAG%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectVistaWDK subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectBaseDirTemp subroutine
::   The first parameter is the list of directory names to check, separated by
::   blank spaces.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectBaseDirTemp
:: Get the name of the variable we are working with
if "%~1" == "" goto :EOF
setlocal ENABLEEXTENSIONS
call :CommonCheckMsg1
:: Try to find an installed DDK/WDK from the registry keys
if DEFINED OSR_REGAVAILABLE if not "%OSR_REGAVAILABLE%" == "0" (
  for %%i in (%~1) do @(
    call :RegTryBaseDirTemp "%%i"
  )
)
:: Try all the "default" locations
if not DEFINED BASEDIRTEMP (
  for %%i in (%~1) do @(
    for %%a in (WINDDK DDK) do @(
      call :BruteTryBaseDirTemp "%SystemDrive%\%%a\%%i"
      call :BruteTryBaseDirTemp "%ProgramFiles%\%%a\%%i"
    )
  )
)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTemp subroutine
::   Attempt to find the install key in the registry.
::   This functions tests old-style DDKs and new-style WDKs.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
call :RegTryBaseDirTempSingle "%~1" "LFNDirectory" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
call :RegTryBaseDirTempSingle "%~1\Setup" "BUILD" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
if not DEFINED BASEDIRTEMP (endlocal & goto :EOF)
:RegTryBaseDirTemp_EOF
%OSR_ECHO% Found directory (%BASEDIRTEMP%) from install key
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTempSingle subroutine
::   Attempt to find the install key in the registry.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTempSingle
setlocal ENABLEEXTENSIONS
set REGSUBKEY=%~1
set REGVALUE=%~2
set VARIABLETOSET=%~3
set REGMAINKEY=HKLM\SOFTWARE\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_WOW64
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_WOW64
set REGMAINKEY=HKLM\SOFTWARE\Wow6432Node\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_EOF
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_EOF
endlocal
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTempSingle subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / BruteTryBaseDirTemp subroutine
::   Brute-force test the given directory.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:BruteTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
:: We will not overwrite BASETEMPDIR if it has been set and is valid
:: Just try
set BASEDIRTEMP=%~1
%OSR_ECHO% Trying %BASEDIRTEMP% ...
if not exist "%BASEDIRTEMP%" (endlocal & goto :EOF)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ BruteTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Usage output
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:USAGE
@echo.
@echo USAGE:
@echo ======
@echo   %~n0 ^<target^> ^<build type^> ^<directory^> [flags] [-WDF] [-PREFAST]
@echo.
@echo Values for ^<target^>:
@echo    --------------------------------------------------------------------------
@echo     Target platform and OS   ^| Miscellaneous
@echo    --------------------------^|-----------------------------------------------
@echo     Target     ^| Windows     ^| CPU     ^| Base directory ^| Target alias(es)
@echo    ------------^|-------------^|---------^|----------------^|--------------------
@echo     -W2K       ^| 2000        ^| x86     ^| %%W2KBASE%%      ^|
@echo     -W2K64     ^| 2000        ^| Itanium ^| %%W2KBASE%%      ^| -W2KI64
@echo     -WXP       ^| XP          ^| x86     ^| %%WXPBASE%%      ^| -XP
@echo     -WXP64     ^| XP          ^| Itanium ^| %%WXPBASE%%      ^| -WXPI64, -XP64
@echo     -WXP2K     ^| 2000        ^| x86     ^| %%WXPBASE%%      ^| -XPW2K
@echo     -WNET      ^| 2003        ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNET64    ^| 2003        ^| Itanium ^| %%WNETBASE%%     ^| -WNETI64
@echo     -WNETXP    ^| XP          ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNETXP64  ^| XP          ^| Itanium ^| %%WNETBASE%%     ^|
@echo     -WNETAMD64 ^| 2003/XP x64 ^| x64     ^| %%WNETBASE%%     ^| -WNETX64, -WNETA64
@echo     -WNET2K    ^| 2000 SP3    ^| x86     ^| %%WNETBASE%%     ^| -WNETW2K
@echo     -WLH       ^| Vista/2008  ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLH2K     ^| 2000 SP4    ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP     ^| XP          ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP64   ^| XP          ^| Itanium ^| %%WLHBASE%%      ^|
@echo     -WLHNET    ^| 2003        ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHNETI64 ^| 2003        ^| Itanium ^| %%WLHBASE%%      ^| -WLHNET64
@echo     -WLHNETX64 ^| 2003/XP x64 ^| x64     ^| %%WLHBASE%%      ^| -WLHNETA64
@echo     -WLHI64    ^| Vista/2008  ^| Itanium ^| %%WLHBASE%%      ^| -WLH64
@echo     -WLHX64    ^| Vista/2008  ^| x64     ^| %%WLHBASE%%      ^| -WLHA64
@echo     -NT4       ^| NT 4.0      ^| x86     ^| %%NT4BASE%%      ^|
@echo    --------------------------------------------------------------------------
@echo     Support for NT4 and W2K DDKs is deprecated and not checked anymore
@echo     in new versions. It may or may not work properly.
@echo    --------------------------------------------------------------------------
@echo.
@echo Values for ^<build type^>:
@echo       checked, chk     indicates a checked build
@echo       free, fre        indicates a free build
@echo.
@echo Remaining parameters ("opt!" = optional parameter):
@echo       ^<directory^>      path to build directory, try . (current directory)
@echo       [flags]    opt!  any flags you think should be passed to build (try /a
@echo                        for clean)
@echo       -WDF       opt!  performs a WDF build
@echo       -PREFAST   opt!  performs a PREFAST build
@echo.
@echo Special files:
@echo       The build target directory (where the DIRS or SOURCES file resides) can
@echo       contain the following files:
@echo       - %OSR_PREBUILD_SCRIPT%
@echo         Allows to include a step before the BUILD tool from the DDK is called
@echo         but after the environment for the respective DDK has been set!
@echo       - %OSR_POSTBUILD_SCRIPT%
@echo         Allows to include a step after the BUILD tool from the DDK is called,
@echo         so the environment is still available to the script.
@echo       - %OSR_SETENV_SCRIPT%
@echo         Allows to set (or override) _any_ environment variables that may exist
@echo         in the global environment. Thus you can set the base directory for the
@echo         DDK from inside this script, making your project more self-contained.
@echo.
@echo       DDKBUILD will only handle those files which exist, so you may choose to
@echo       use none, one or multiple of these script files.
@echo       (All scripts execute inside their current directory. Consider this!)
@echo.
@echo Examples:
@echo       ^"%~n0 -NT4 checked .^" (for NT4 BUILD)
@echo       ^"%~n0 -WXP64 chk .^"
@echo       ^"%~n0 -WXP chk c:\projects\myproject^"
@echo       ^"%~n0 -WNET64 chk .^"      (IA64 build)
@echo       ^"%~n0 -WNETAMD64 chk .^"   (AMD64/EM64T build)
@echo       ^"%~n0 -WNETXP chk . -cZ -WDF^"
@echo       ^"%~n0 -WNETXP chk . -cZ -PREFAST^"
@echo.
@echo       In order for this procedure to work correctly for each platform, it
@echo       requires an environment variable to be set up for certain platforms.
@echo       There is an auto-detection mechanism in this script, which will work best
@echo       if the DDK/WDK was installed using the normal installer (i.e. not just
@echo       copied). The auto-detection is based on the DDK/WDK for which you request
@echo       a build. Whenever you set the variable explicitly, this will take
@echo       precedence over the auto-detected path!
@echo       The environment variables are as follows:
@echo.
@echo       %%NT4BASE%%  - Set this up for ^"-NT4^" builds
@echo       %%W2KBASE%%  - Set this up for ^"-W2K^" and ^"-W2K64^" builds
@echo       %%WXPBASE%%  - Set this up for ^"-WXP^", ^"-WXP64^", ^"-WXP2K^" builds
@echo       %%WNETBASE%% - Set this up for ^"-WNET*^" builds
@echo       %%WLHBASE%%  - Set this up for ^"-WLH*^" builds
@echo.
@echo       %%WDF_ROOT%% must be set if attempting to do a WDF Build previous to the
@echo       Vista WDK (in later DDKs there is no need to set WDF_ROOT).
@echo.
@echo Path to this script:
@echo      %~f0
@echo.
@echo   %OSR_VERSTR%
@echo   -^> report any problems to ^<info@osr.com^> or ^<http://assarbad.net/contact/^>
@echo.

:END
popd & endlocal & exit /b %OSR_ERRCODE%
```

`DrxHook/DrxHook/makefile`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

`DrxHook/DrxHook/mybuild.bat`:

```bat
set WLHBASE=C:\WINDDK\7600.16385.0
set WDF_ROOT=C:\WINDDK\7600.16385.0
ddkbuild.cmd -WLH chk . -cZ -WDF
```

`DrxHook/DrxHook/sources`:

```
TARGETNAME=DrxHook
#TARGETPATH=$(BASEDIR)\lib
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=.\

SOURCES=DrxHook.c


```

`DrxHook/README.md`:

```md
##硬件断点

WDK7600命令行编译即可，通过在内核层设置Drx寄存器的值，达到hook目标地址的功能。

[http://www.cnblogs.com/lanrenxinxin/p/4680320.html](http://www.cnblogs.com/lanrenxinxin/p/4680320.html)
```

`HideIDTHook/HideIDTHook/HideIDTHook.c`:

```c


#ifndef CXX_HIDEIDTHOOK_H
#	include "HideIDTHook.h"
#endif


KIRQL  Irql;
ULONG_PTR g_jmp_offset = 0;
ULONG_PTR  OldBase;
PKGDTENTRY NewGDTAddr;
ULONG_PTR g_OrigKiTrap03;
unsigned short OldSelector;
IDTENTRY*  idt_entries;

__declspec(naked) void NewKiTrap03()
{
	__asm
	{
		    push    0   ;ErrorCode
			push    ebp
			push    ebx
			push    esi
			push    edi
			push    fs
			mov     ebx,30h
			mov     fs,bx
			mov     ebx,dword ptr fs:[0]
		    push    ebx
			sub     esp,4
			push    eax
			push    ecx
			push    edx
			push    ds
			push    es
			push    gs

			sub     esp,30h    //esp此时就指向陷阱帧

			push    esp         //FilterExceptionInfo自己清理了

			call   FilterExceptionInfo   //过滤函数

			add     esp , 0x30
			pop		gs
			pop		es
			pop		ds
			pop		edx
			pop		ecx
			pop		eax
			add		esp , 4
			pop		ebx
			pop		fs
			pop		edi
			pop		esi
			pop		ebx
			pop		ebp
			add     esp , 0x4
			jmp     g_OrigKiTrap03

	}
}




VOID __stdcall FilterExceptionInfo(PX86_KTRAP_FRAME pTrapFrame)
{

	//eip的值减一过int3，汇编代码分析中dec， 
	DbgPrint("Eip:%x\r\n",(pTrapFrame->Eip)-1);
}

NTSTATUS
DriverEntry(IN PDRIVER_OBJECT pDriverObj, IN PUNICODE_STRING pRegistryString)
{
	ULONG	oriaddr=0;
	ULONG	newaddr=0;
	PKGDTENTRY GDT_Addr;
	KGDTENTRY  GDTInfo;
	PKGDTENTRY Gdt_Addr3e0;
	PKGDTENTRY Gdt_Addr8;
	ULONG	jmpoffset=0;
	IDTR    idt_info;    
	
	unsigned short selector;

#ifdef _DBG
	__asm int 3
#endif
	pDriverObj->DriverUnload = DriverUnLoad;

	__asm 
	{
		sidt  idt_info
			
		push edx
		sgdt [esp-2]
		pop edx
		mov GDT_Addr,edx

	}
	idt_entries = (IDTENTRY*) MAKELONG(idt_info.IDT_LOWbase,idt_info.IDT_HIGbase);
	g_OrigKiTrap03 = MAKELONG(idt_entries[3].LowOffset,idt_entries[3].HiOffset);
	jmpoffset	=	(ULONG)NewKiTrap03 - g_OrigKiTrap03;
	selector = idt_entries[1].selector;
	//我选择的是索引为0x10的，空白的GDT表项
	NewGDTAddr = GDT_Addr + 0x10;

	//保存原来的
 	memcpy((UCHAR*)&OldBase,(char*)(&(NewGDTAddr->BaseLow)),2);
 	memcpy((UCHAR*)&OldBase+2,(char*)(&(NewGDTAddr->HighWord.Bytes.BaseMid)),1);
 	memcpy((UCHAR*)&OldBase+3,(char*)(&(NewGDTAddr->HighWord.Bytes.BaseHi)),1);

	//修改
	WPOFF();
	memcpy((char*)(&(NewGDTAddr->BaseLow)),(UCHAR*)&jmpoffset,2);
	memcpy((char*)(&(NewGDTAddr->HighWord.Bytes.BaseMid)),(UCHAR*)(&jmpoffset)+2,1);
	memcpy((char*)(&(NewGDTAddr->HighWord.Bytes.BaseHi)),(UCHAR*)(&jmpoffset)+3,1);
	OldSelector = idt_entries[3].selector;
	idt_entries[3].selector  = 0x80;
	WPON();

	return  STATUS_SUCCESS;
}



void DriverUnLoad(PDRIVER_OBJECT pDriverObject)
{
	WPOFF();
	memcpy((char*)(&(NewGDTAddr->BaseLow)),(UCHAR*)(&OldBase),2);
	memcpy((char*)(&(NewGDTAddr->HighWord.Bytes.BaseMid)),(UCHAR*)(&OldBase)+2,1);
	memcpy((char*)(&(NewGDTAddr->HighWord.Bytes.BaseHi)),(UCHAR*)(&OldBase)+3,1);
	idt_entries[3].selector = OldSelector;
	WPON();
}




VOID WPOFF()
{
	ULONG_PTR cr0 = 0;
	Irql = KeRaiseIrqlToDpcLevel();
	cr0 =__readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);

}





VOID WPON()
{

	ULONG_PTR cr0=__readcr0();
	cr0 |= 0x10000;
	__writecr0(cr0);
	KeLowerIrql(Irql);
}



```

`HideIDTHook/HideIDTHook/HideIDTHook.h`:

```h


#ifndef CXX_HIDEIDTHOOK_H
#define CXX_HIDEIDTHOOK_H


#include <ntifs.h>
#include <devioctl.h>
#include <WINDEF.H>

#endif	


typedef struct _KGDTENTRY                 // 3 elements, 0x8 bytes (sizeof)  
{                                                                            
	/*0x000*/     UINT16       LimitLow;                                                   
	/*0x002*/     UINT16       BaseLow;                                                    
	union                                 // 2 elements, 0x4 bytes (sizeof)  
	{                                                                        
		struct                            // 4 elements, 0x4 bytes (sizeof)  
		{                                                                    
			/*0x004*/             UINT8        BaseMid;                                            
			/*0x005*/             UINT8        Flags1;                                             
			/*0x006*/             UINT8        Flags2;                                             
			/*0x007*/             UINT8        BaseHi;                                             
		}Bytes;                                                              
		struct                            // 10 elements, 0x4 bytes (sizeof) 
		{                                                                    
			/*0x004*/             ULONG32      BaseMid : 8;     // 0 BitPosition                   
			/*0x004*/             ULONG32      Type : 5;        // 8 BitPosition                   
			/*0x004*/             ULONG32      Dpl : 2;         // 13 BitPosition                  
			/*0x004*/             ULONG32      Pres : 1;        // 15 BitPosition                  
			/*0x004*/             ULONG32      LimitHi : 4;     // 16 BitPosition                  
			/*0x004*/             ULONG32      Sys : 1;         // 20 BitPosition                  
			/*0x004*/             ULONG32      Reserved_0 : 1;  // 21 BitPosition                  
			/*0x004*/             ULONG32      Default_Big : 1; // 22 BitPosition                  
			/*0x004*/             ULONG32      Granularity : 1; // 23 BitPosition                  
			/*0x004*/             ULONG32      BaseHi : 8;      // 24 BitPosition                  
		}Bits;                                                               
	}HighWord;                                                               
}KGDTENTRY, *PKGDTENTRY;

typedef struct _IDTR{
	USHORT   IDT_limit;
	USHORT   IDT_LOWbase;
	USHORT   IDT_HIGbase;
}IDTR,*PIDTR;

typedef struct _IDTENTRY
{
	unsigned short LowOffset;
	unsigned short selector;
	unsigned char retention:5;
	unsigned char zero1:3;
	unsigned char gate_type:1;
	unsigned char zero2:1;
	unsigned char interrupt_gate_size:1;
	unsigned char zero3:1;
	unsigned char zero4:1;
	unsigned char DPL:2;
	unsigned char P:1;
	unsigned short HiOffset;
} IDTENTRY,*PIDTENTRY;

typedef struct _X86_KTRAP_FRAME {
	ULONG   DbgEbp;
	ULONG   DbgEip;
	ULONG   DbgArgMark;
	ULONG   DbgArgPointer;
	ULONG   TempSegCs;
	ULONG   TempEsp;
	ULONG   Dr0;
	ULONG   Dr1;
	ULONG   Dr2;
	ULONG   Dr3;
	ULONG   Dr6;
	ULONG   Dr7;
	ULONG   SegGs;
	ULONG   SegEs;
	ULONG   SegDs;
	ULONG   Edx;
	ULONG   Ecx;
	ULONG   Eax;
	ULONG   PreviousPreviousMode;
	ULONG   ExceptionList;
	ULONG   SegFs;
	ULONG   Edi;
	ULONG   Esi;
	ULONG   Ebx;
	ULONG   Ebp;
	ULONG   ErrCode;

	ULONG   Eip;
	ULONG   SegCs;
	ULONG   EFlags;
	ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
	ULONG   HardwareSegSs;  // that involve a ring transition.
	ULONG   V86Es;          // these will be present for all transitions from
	ULONG   V86Ds;          // V86 mode
	ULONG   V86Fs;
	ULONG   V86Gs;
} X86_KTRAP_FRAME, *PX86_KTRAP_FRAME;

VOID __stdcall FilterExceptionInfo(PX86_KTRAP_FRAME pTrapFrame);

void DriverUnLoad(PDRIVER_OBJECT pDriverObject);

VOID WPOFF();
VOID WPON();

```

`HideIDTHook/HideIDTHook/HideIDTHook.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HideIDTHook", "HideIDTHook.vcxproj", "{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		WinDDK|Win32 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.ActiveCfg = WinDDK|Win32
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.Build.0 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`HideIDTHook/HideIDTHook/HideIDTHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="WinDDK|Win32">
      <Configuration>WinDDK</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>"HideIDTHook"</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
    <ExecutablePath>$(WLHBASE)\bin\x86\x86;$(WLHBASE)\bin\x86</ExecutablePath>
    <IncludePath>$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc</IncludePath>
    <ReferencePath />
    <LibraryPath>$(WLHBASE)\lib\win7\i386</LibraryPath>
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG=1</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include=".\HideIDTHook.c" />
    <ClCompile Include=".\HideIDTHook.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HideIDTHook/HideIDTHook/HideIDTHook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`HideIDTHook/HideIDTHook/clean.bat`:

```bat
rem /////////////////
rem / Add by ChiChou
rem / 
rem / FileName:Clean.bat
rem / Description:Clean
rem /
rem ////////////////
rd .\bin /s /q
rd .\WinDDK /s /q
rd .\objchk_w2k_x86 /s /q
rd .\objchk_wxp_x86 /s /q
rd .\objchk_wnet_x86 /s /q
rd .\objchk_wlh_x86 /s /q
rd .\objfre_w2k_x86 /s /q
rd .\objfre_wxp_x86 /s /q
rd .\objfre_wnet_x86 /s /q
rd .\objfre_wlh_x86 /s /q
del .\*.log
del .\*.err
del .\*.xml
rem ***** del VS2005 file *****
del .\*.ncb
del .\*.user
del .\*.suo /A:H
rem ***** del VS6.0 file *****
del .\*.plg
del .\*.opt
exit
```

`HideIDTHook/HideIDTHook/ddkbuild.cmd`:

```cmd
@echo off
@set VERSION=V7.3
@set OSR_DEBUG=off
@if "%OS%"=="Windows_NT" goto :Prerequisites
@echo This script requires Windows NT 4.0 or later to run properly!
goto :EOF
:Prerequisites
:: Check whether FINDSTR is available. It's used to show warnings etc.
findstr /? > NUL 2>&1 || echo "FINDSTR is a prerequisite but wasn't found!" && goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    $Id: ddkbuild.cmd 27 2008-09-06 12:02:06Z oliver $
::
::    This software is supplied for instructional purposes only.
::
::    OSR Open Systems Resources, Inc. (OSR) expressly disclaims any warranty
::    for this software.  THIS SOFTWARE IS PROVIDED  "AS IS" WITHOUT WARRANTY
::    OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
::    THE IMPLIED WARRANTIES OF MECHANTABILITY OR FITNESS FOR A PARTICULAR
::    PURPOSE.  THE ENTIRE RISK ARISING FROM THE USE OF THIS SOFTWARE REMAINS
::    WITH YOU.  OSR's entire liability and your exclusive remedy shall not
::    exceed the price paid for this material.  In no event shall OSR or its
::    suppliers be liable for any damages whatsoever (including, without
::    limitation, damages for loss of business profit, business interruption,
::    loss of business information, or any other pecuniary loss) arising out
::    of the use or inability to use this software, even if OSR has been
::    advised of the possibility of such damages.  Because some states/
::    jurisdictions do not allow the exclusion or limitation of liability for
::    consequential or incidental damages, the above limitation may not apply
::    to you.
::
::    OSR Open Systems Resources, Inc.
::    105 Route 101A Suite 19
::    Amherst, NH 03031  (603) 595-6500 FAX: (603) 595-6503
::    report bugs to <bugs@osr.com>
::    alternatively report them via <http://assarbad.net/contact/>
::
::
::    MODULE:
::
::      ddkbuild.cmd
::
::    ABSTRACT:
::
::      This script allows drivers to be built with Visual Studio 2002 through
::      Visual Studio 2008 and possibly future versions. It will also work fine
::      from the command line.
::      If you are interested in a project wizard that makes use of this script,
::      try DDKWizard from <http://ddkwizard.assarbad.net>.
::
::    AUTHOR(S):
::
::      - OSR Open Systems Resources, Inc.
::      - Oliver Schneider (ddkwizard.assarbad.net)
::
::    REQUIREMENTS:
::
::      Environment variables that must be set.
::        %NT4BASE%  - Set this up for "-NT4" builds (legacy, support not tested)
::        %W2KBASE%  - Set this up for "-W2K*" builds (legacy, support not tested)
::        %WXPBASE%  - Set this up for "-WXP*" builds
::        %WNETBASE% - Set this up for "-WNET*" builds
::        %WLHBASE%  - Set this up for "-WLH*" builds
::        %WDF_ROOT% - Must be set if attempting to do a WDF Build.
::
::      Examples:
::        NT4BASE : could be "D:\NT4DDK"
::        W2KBASE : could be "D:\Nt50DDK"
::        WXPBASE : could be "D:\WINDDK\2600"
::        WNETBASE: could be "D:\WINDDK\3790.1830" or "C:\WINDDK\3790"
::
::    COMMAND FORMAT:
::
::      Run the script without any parameters to get the whole help content!
::      Note: "-WDF" has been tested with the 01.00.5054 version of the framework
::
::    RETURN CODES AND THEIR MEANING:
::
::      001 == Unknown build type. Check the <platform> parameter
::      002 == No WDF_ROOT given using WDF build type.
::      003 == The DDK-specific base directory variable (NT4BASE, W2KBASE, WXPBASE,
::             WNETBASE) is not set at all and could not be auto-detected!
::      004 == BASEDIR variable is empty. Check to see that the DDK-specific
::             variable is set correctly (i.e. NT4BASE, W2KBASE, WXPBASE, WNETBASE)
::      005 == No mode (checked/free) was given. Check the respective parameter!
::      006 == No DIR or SOURCES file found in the given target directory.
::      007 == No target directory given.
::      008 == Given target directory does not exist.
::      009 == The SETENV script failed.
::
::      Note: If %OSR_ERRCODE% and %ERRORLEVEL% are equal, the return code stems
::            from one of the tools being called during the build process.
::
::    BROWSE FILES:
::
::      This procedure supports the building of BROWSE files to be used by
::      Visual Studio 6 and by Visual Studio.NET  However, the BSCfiles created
::      by bscmake for the two are not compatible. When this command procedure
::      runs, it selects the first bscmake.exe found in the path. So, make sure
::      that the correct bscmake.exe is in the path ...
::
::      Note that if using Visual Studio.NET the .BSC must be added to the project
::      in order for the project to be browsed.
::      Another alternative is the VS addon named "Visual Assist X" which will
::      parse the header files - no more need for browse files.
::
::    COMPILERS:
::
::      If you are building NT4 you should really be using the VC6 compiler.
::      Later versions of the DDK now contain the compiler and the linker. This
::      procedure should use the correct compiler.
::
::    GENERAL COMMENTS:
::
::      This procedure has been cleaned up to be modular and easy to understand.
::
::      As of the Server 2003 SP1 DDK DDKBUILD now clears the NO_BROWSE_FILE and
::      NO_BINPLACE environment variables so that users can use these features.
::
::      Starting with the Vista WDK, the output in the respective tool window
::      in VS is in Unicode by default. This garbles the output from DDKBUILD
::      and we therefore clear the environment variable VS_UNICODE_OUTPUT.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MAIN
:: Building "stack frame"
setlocal ENABLEEXTENSIONS & pushd .
:: Check whether the REG utility is available
reg /? > NUL 2>&1 && set OSR_REGAVAILABLE=1

:: This is set by client-side keyword substitution
set SVN_REVISION=$Revision: 27 $
:: Extract the revision number from the revision keyword
set SVN_REVISION=%SVN_REVISION:~0,-2%
set SVN_REVISION=%SVN_REVISION:~11%
:: This is set by client-side keyword substitution
set SVN_REVDATE=$Date: 2008-09-06 12:02:06 +0000 (Sat, 06 Sep 2008) $
:: Extract the date from the Date keyword
set SVN_REVDATE=%SVN_REVDATE:~7,10%
set VERSION=%VERSION%/r%SVN_REVISION%

:: Init some special variables
set OSR_VERSTR=OSR DDKBUILD.CMD %VERSION% (%SVN_REVDATE%) - OSR, Open Systems Resources, Inc.
set OSR_PREBUILD_SCRIPT=ddkprebld.cmd
set OSR_POSTBUILD_SCRIPT=ddkpostbld.cmd
set OSR_SETENV_SCRIPT=ddkbldenv.cmd
set OSR_ECHO=@echo DDKBLD:

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set error messages
:: Possible codes: 1
set ERR_UnknownBuildType=Unknown type of build. Please recheck parameters.
:: Possible codes: 2
set ERR_NoWdfRoot=WDF_ROOT is not defined, are you using 00.01.5054 or later?
:: Possible codes: 3
set ERR_BaseDirNotSet=To build using type %%OSR_TARGET%% you need to set the %%%%%%BASEDIRVAR%%%%%% environment variable to point to the %%BASEDIROS%% DDK base directory!
:: Possible codes: 4
set ERR_NoBASEDIR=NT4BASE, W2KBASE, WXPBASE and/or WNETBASE environment variable(s) not set. Environment variable(s) must be set by user according to DDK version(s) installed.
:: Possible codes: 5
set ERR_BadMode=^<build type^> must be 'checked', 'free', 'chk' or 'fre' (case-insensitive).
:: Possible codes: 6
set ERR_NoTarget=Target directory must contain a SOURCES or DIRS file.
:: Possible codes: 7, 8
set ERR_NoDir=The ^<directory^> parameter must be a valid directory.
:: Possible codes: 9
set ERR_SetEnvFailed=The SETENV script failed.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Clear the error code variable
set OSR_ERRCODE=0
set prefast_build=0

:: Turn on tracing, use %OSR_TRACE% instead of ECHO
if /i "%OSR_DEBUG%" == "on" (set OSR_TRACE=%OSR_ECHO% [TRACE]) else (set OSR_TRACE=rem)
:: Turn on echoing of current line if %OSR_DEBUG% is set to "on"
@echo %OSR_DEBUG%

:: Output version string
@echo %OSR_VERSTR%
%OSR_TRACE% ^(Current module: ^"%~f0^"^)
@echo.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set the target platform variable
set OSR_TARGET=%~1
:: Remove any dashes in the variable
if not "%OSR_TARGET%" == "" set OSR_TARGET=%OSR_TARGET:-=%
:: Show help if the target parameter is empty after removal of the dashes
if "%OSR_TARGET%" == "" goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: In the build directory check for this script and call it if it exists.
:: This allows to override any global system variable setting, if desired.
if not "%3" == "" call :GetCustomEnvironment "%~f3"
if not "%OSR_ERRCODE%" == "0" goto :USAGE
:: Additional error handling for better usability
:: These subroutines will also attempt to locate the requested DDK!!!
set OSR_ERRCODE=3
%OSR_TRACE% Checking whether the environment variable for the build type was set
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Check > NUL 2>&1
:: If the BASEDIROS/BASEDIRVAR variable is not defined, it means the subroutine did not exist!
if not DEFINED BASEDIROS call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIROS)" & goto :USAGE
if not DEFINED BASEDIRVAR call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIRVAR)" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BaseDirNotSet%" & goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
set BASEDIR=%%%BASEDIRVAR%%%
call :ResolveVar BASEDIR
call :MakeShort BASEDIR "%BASEDIR%"
:: Check for existing %BASEDIR%
if "%BASEDIR%" == "" call :ShowErrorMsg 4 "%ERR_NoBASEDIR%" & goto :USAGE
set PATH=%BASEDIR%\bin;%PATH%
%OSR_TRACE% Now jump to the initialization of the commandline
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Build

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_TRACE% We returned from the variable initialization
if not DEFINED OSR_CMDLINE call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (OSR_CMDLINE)" & goto :USAGE

%OSR_TRACE% Hurrah, all the variables have been initialized, continuing
:: Proceed with common build steps
goto :CommonBuild

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Check whether the parameter makes sense and try to
:: correct it if possible
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WLH64Check
:WLHA64Check
:WLHXP64Check
:WLHNET64Check
:WLHNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WLHCheck
:WLHX64Check
:WLHI64Check
:WLHNETX64Check
:WLHNETI64Check
:WLHXPCheck
:WLH2KCheck
:WLHNETCheck
set BASEDIROS=Windows Vista/Windows 2008 Server
set BASEDIRVAR=WLHBASE
:: Compatibility between BUILD and VS ... prevent pipes from being used
%OSR_ECHO% Clearing %%VS_UNICODE_OUTPUT%% ...
set VS_UNICODE_OUTPUT=
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "6001.18000 6000"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WNETW2KCheck
:WNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WNET2KCheck
:WNETXPCheck
:WNETWXPCheck
:WNETXP64Check
:WNET64Check
:WNETI64Check
:WNETAMD64Check
:WNETX64Check
:WNETCheck
set BASEDIROS=Windows 2003 Server
set BASEDIRVAR=WNETBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "3790.1830 3790.1218 3790"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:XPCheck
:XP64Check
:XPW2KCheck
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WXP64Check
:WXPI64Check
:WXPCheck
:WXP2KCheck
set BASEDIROS=Windows XP
set BASEDIRVAR=WXPBASE
:: Other flavor of DDKBUILD
if not DEFINED WXPBASE if DEFINED XPBASE set BASEDIRVAR=XPBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "2600.1106 2600"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:W2K64Check
:W2KI64Check
:W2KCheck
set BASEDIROS=Windows 2000
set BASEDIRVAR=W2KBASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:NT4Check
set BASEDIROS=Windows NT4
set BASEDIRVAR=NT4BASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg1
echo.
%OSR_ECHO% WARNING: %%%BASEDIRVAR%%% NOT SET!
%OSR_ECHO%   Attempting to auto-detect the installation folder and set %%%BASEDIRVAR%%%.
%OSR_ECHO%   (If this fails *you* will have to set it!)
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg2
echo.
%OSR_ECHO% WARNING:
%OSR_ECHO%   Auto-detection of the folder settings is not supported for the requested DDK.
%OSR_ECHO%   Please set %%%BASEDIRVAR%%% yourself!
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckSetVarWithReturn
%OSR_ECHO% Found!
echo.
set %BASEDIRVAR%=%BASEDIRTEMP%
set BASEDIRTEMP=
:: Tell the caller it was successful
:CommonCheckNoErrorWithReturn
set OSR_ERRCODE=0
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckErrorNotDetectedWithReturn
echo.
%OSR_ECHO% None of the usual default paths works. Set %%%BASEDIRVAR%%% manually!
:CommonCheckErrorNotSupportedWithReturn
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Initialize variables specific to the respective platform
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: 
:: Valid parameters for setenv in different DDKs/WDKs:
::
:: 2600       - "setenv <directory> [fre|chk] [64] [hal]"
:: 2600.1106  - "setenv <directory> [fre|chk] [64] [hal] [WXP|W2K]"
:: 3790       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K]"
:: 3790.1830  - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K] [no_prefast] [bscmake]"
:: 6000       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"
:: 6001.18000 - "setenv <directory> [fre|chk] [64|x64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: NT 4.0 build using NT4 DDK
:NT4Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% "%%MSDEVDIR%%"
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WXP DDK
:XPW2KBuild
:WXP2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\w2k\set2k.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 64bit (Intel) using W2K DDK
:W2K64Build
:W2KI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv64.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using W2K DDK
:W2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WXP DDK
:XP64Build
:WXP64Build
:WXPI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WXP DDK
:XPBuild
:WXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WNET DDK
:WNETW2KBuild
:WNET2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% W2K %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WNET DDK
:WNETXPBuild
:WNETWXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit using WNET DDK
:WNETXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WNET DDK
:WNET64Build
:WNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WNET DDK
:WNETA64Build
:WNETAMD64Build
:WNETX64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% AMD64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WNET DDK
:WNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 32bit using WLH DDK
:WLHBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (AMD) using WLH DDK
:WLHA64Build
:WLHX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (Intel) using WLH DDK
:WLH64Build
:WLHI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WLH DDK
:WLHNETA64Build
:WLHNETX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WLH DDK
:WLHNET64Build
:WLHNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WLH DDK
:WLHXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WLH DDK
:WLHXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WLH DDK
:WLH2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% W2K
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WLH DDK
:WLHNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: All builds go here for the rest of the procedure. Now,
:: we are getting ready to call build. The big problem
:: here is to figure our the name of the buildxxx files
:: being generated for the different platforms.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:CommonBuild
:: Remove first command line arg
shift
call :SetMode %1
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BadMode%" & goto :USAGE
set OSR_BUILDNAME=%OSR_TARGET% (%BuildMode%) using the %BASEDIROS% DDK and %%%BASEDIRVAR%%%

call :CheckTargets %2
if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :USAGE

:: Resolve any variables in the command line string
call :ResolveVar OSR_CMDLINE

pushd .
set ERRORLEVEL=0
:: This external script prepares the build environment (e.g. setenv.bat)
call %OSR_CMDLINE%
:: Will only work with newer SETENV.BAT versions, but will be helpful in this case.
if not "%ERRORLEVEL%" == "0" call :ShowErrorMsg 9 "%ERR_SetEnvFailed%" & goto :USAGE
popd

:: ----------------------------------------------------------------------------
:: Setting global variables for the scope of this CMD session
set NO_BROWSER_FILE=
set NO_BINPLACE=
set buildDirectory=%~fs2
call :MakeShort buildDirectory "%buildDirectory%"
set buildDirectory_raw=%2
set buildDirectory_fname=%~n2
%OSR_TRACE% buildDirectory       == %buildDirectory%
%OSR_TRACE% buildDirectory_raw   == %buildDirectory_raw%
%OSR_TRACE% buildDirectory_fname == %buildDirectory_fname%

set mpFlag=-M
if "%BUILD_ALT_DIR%" == "" goto :NT4

:: W2K sets this!
set OSR_EXT=%BUILD_ALT_DIR%
set mpFlag=-MI

:NT4
if "%NUMBER_OF_PROCESSORS%" == "" set mpFlag=
if "%NUMBER_OF_PROCESSORS%" == "1" set mpFlag=

:: Set additional variables at this point or do whatever you please
@if exist "%buildDirectory%\%OSR_PREBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_PREBUILD_SCRIPT%" > "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
)
:: Save the current directory (before changing into the build directory!)
:: AFTERPREBUILD
pushd .

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Determine the settings of flags, WDF and PREFAST in
:: other words what was set for %3 and beyond....
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_ECHO% %OSR_BUILDNAME%
set OSR_ARGS= + argument(s):
if not "%3" == "" set OSR_ARGS=%OSR_ARGS% %3
if not "%4" == "" set OSR_ARGS=%OSR_ARGS% %4
if not "%5" == "" set OSR_ARGS=%OSR_ARGS% %5
if /i "%OSR_ARGS%" == " + argument(s):" set OSR_ARGS=
%OSR_ECHO% Directory: %buildDirectory%%OSR_ARGS%
%OSR_ECHO% %BASEDIRVAR%: %BASEDIR%

cd /D %~s2
set bFlags=-Ze
set bscFlags=

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ContinueParsing
if "%3" == "" goto :DONE
if "%3" == "/a" goto :RebuildallFound
if /i "%3" == "-WDF" goto :WDFFound
if /i "%3" == "-PREFAST" goto :PrefastFound
set bscFlags=/n
set bFlags=%bFlags% %3
:: Remove next arg
shift
goto :ContinueParsing

:WDFFound
shift
:: Note, that the setwdf.bat is called from setenv.bat in the WDK,
:: therefore we skip it.
if /i "%BASEDIRVAR%" == "WLHBASE" goto :WDFOkay
if "%WDF_ROOT%" == "" call :ShowErrorMsg 2 "%ERR_NoWdfRoot%" & goto :USAGE
pushd .
if exist "%WDF_ROOT%\set_wdf_env.cmd" call "%WDF_ROOT%\set_wdf_env.cmd"
popd
:WDFOkay
goto :ContinueParsing

:PrefastFound
shift
set prefast_build=1
goto :ContinueParsing

:RebuildallFound
shift
set bscFlags=/n
set bFlags=%bFlags:-Ze=-cfeZ%
set bFlags=%bFlags: -cZ=%
goto :ContinueParsing
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:DONE
for %%x in (build%OSR_EXT%.err build%OSR_EXT%.wrn build%OSR_EXT%.log prefast%OSR_EXT%.log) do @(
  if exist "%%x"   del /f /q "%%x"
)

if not "%prefast_build%" == "0" goto :RunPrefastBuild
%OSR_ECHO% Run build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
pushd .
build %mpFlag% %bFlags%
popd
goto :BuildComplete

:RunPrefastBuild
%OSR_ECHO% Run prefast build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
setlocal ENABLEEXTENSIONS & pushd .
set PREFASTLOG=PREfast_defects_%OSR_EXT%.xml
prefast /log=%PREFASTLOG% /reset build %mpFlag% %bFlags% > NUL 2>&1
if "%errorlevel%" GTR "0" set OSR_ERRCODE=%errorlevel%
prefast /log=%PREFASTLOG% list > prefast%OSR_EXT%.log
%OSR_ECHO% The PREfast logfile is ^"%prefastlog%^"!
popd & endlocal

:BuildComplete
if not "%errorlevel%" == "0" set OSR_ERRCODE=%errorlevel%

@echo %OSR_DEBUG%
:: Assume that the onscreen errors are complete!
setlocal
set WARNING_FILE_COUNT=0
if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+1
)
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% ================ Build warnings =======================
  if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set WARNING_FILE_COUNT_PRE=0
if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT_PRE=%WARNING_FILE_COUNT_PRE%+1
)
:: Reset if this is no PREfast build
if "%prefast_build%" == "0" set WARNING_FILE_COUNT_PRE=0
if not "%WARNING_FILE_COUNT_PRE%" == "0" (
  %OSR_ECHO% =============== PREfast warnings ======================
  if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+%WARNING_FILE_COUNT_PRE%
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% =======================================================
)
endlocal
@echo.
%OSR_ECHO% Build complete
%OSR_ECHO% Building browse information files
if exist "buildbrowse.cmd" call "buildbrowse.cmd" & goto :postBuildSteps
set sbrlist=sbrList.txt
if not exist sbrList%CPU%.txt goto :sbrDefault
set sbrlist=sbrList%CPU%.txt

:sbrDefault
if not exist %sbrlist% goto :postBuildSteps
:: Prepend blank space
if not "%bscFlags%" == "" set bscFlags= %bscFlags%
:: bscmake%bscFlags% prevents a double blank space ...
bscmake%bscFlags% @%sbrlist%

:: Perform whatever post-build steps
:postBuildSteps
:: Restore the current directory (after changing into the build directory!)
:: Search upwards for "AFTERPREBUILD" to find the corresponding PUSHD
popd
@if exist "%buildDirectory%\%OSR_POSTBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_POSTBUILD_SCRIPT%" > "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
)
goto :END
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / GetCustomEnvironment
::    First parameter is the "directory" that supposedly contains the SOURCES
::    or DIRS file (and the build scripts)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:GetCustomEnvironment
pushd .
call :CheckTargets "%~f1"
@if not "%OSR_ERRCODE%" == "0" @(
  echo.
  %OSR_ECHO% The target directory seemed to not contain a DIRS or SOURCES file
  %OSR_ECHO% when trying to set a custom environment! Quitting.
  set buildDirectory=%~f1
  if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :GetCustomEnvironment_ret
  call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :GetCustomEnvironment_ret
  goto :GetCustomEnvironment_ret
)
:: If the user provided a script to customize the environment, execute it.
@if exist "%~f1\%OSR_SETENV_SCRIPT%" @(
  %OSR_ECHO% ^>^> Setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
  pushd "%~f1"
  call "%OSR_SETENV_SCRIPT%" > "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_SETENV_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
)
:GetCustomEnvironment_ret
popd
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ GetCustomEnvironment
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / SetMode
::    Subroutine to validate the mode of the build passed in. It must be free,
::    FREE, fre, FRE or checked, CHECKED, chk, CHK. Anything else is an error.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetMode
set BuildMode=
if /i "%OSR_TARGET%" == "WLH2K" goto :SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=free
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=checked
goto :SetModeCommonEnd
:SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=f
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=c
:SetModeCommonEnd
%OSR_TRACE% Mode set to ^"%BuildMode%^"
if "%BuildMode%" == "" set OSR_ERRCODE=5
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ SetMode
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / CheckTargets subroutine
::   Subroutine to validate that the target directory exists and that there is
::   either a DIRS or SOURCES and MakeFile in it.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CheckTargets
:: Building "stack frame"
setlocal & pushd . & set OSR_ERRCODE=0
set lTarget=%~1
if not "%lTarget%" == "" goto :CheckTargets1
set OSR_ERRCODE=7
goto :CheckTargets_ret
:CheckTargets1
if exist "%lTarget%" goto :CheckTargets2
set OSR_ERRCODE=8
goto :CheckTargets_ret
:CheckTargets2
if not exist "%lTarget%\DIRS" goto :CheckTargets3
set OSR_ERRCODE=0
goto :CheckTargets_ret
:CheckTargets3
if exist "%lTarget%\SOURCES" goto :CheckTargets4
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets4
if exist "%lTarget%\MAKEFILE" goto :CheckTargets5
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets5
set OSR_ERRCODE=0
:CheckTargets_ret
:: Cleaning "stack frame" and returning error code into global scope
popd & endlocal & set OSR_ERRCODE=%OSR_ERRCODE%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ CheckTargets subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ResolveVar subroutine
::   There is only one parameter, the name of the variable to be resolved!
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ResolveVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
set VAR_TEMPRET2=%%%VAR_NAME%%%
:ResolveVarLoop
set VAR_TEMPRET1=%VAR_TEMPRET2%
set VAR_TEMPRET2=%VAR_TEMPRET1%
for /f "tokens=*" %%i in ('echo %VAR_TEMPRET1%') do (
  set VAR_TEMPRET2=%%i
)
if not "%VAR_TEMPRET1%" == "%VAR_TEMPRET2%" goto :ResolveVarLoop
:: Re-export the variable out of the local scope
endlocal & set %VAR_NAME%=%VAR_TEMPRET1%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ResolveVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MakeShort subroutine
::   Two parameters. First parameter is the variable name, second is the path
::   to convert into a short filename.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MakeShort
setlocal ENABLEEXTENSIONS
:: Get the name of the variable we are working with and the path to convert
set VAR_NAME=%~1
set PATH_SHORT=%~dpns2
set PATH_EXTSHORT=%~xs2
if not "" == "%PATH_EXTSHORT%" set PATH_EXTSHORT=%PATH_EXTSHORT:~0,4%
set PATH_SHORT=%PATH_SHORT%%PATH_EXTSHORT%
endlocal & set %VAR_NAME%=%PATH_SHORT%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MakeShort subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ErrorWithUsage subroutine
::   This one will take the passed in parameters and build a nice error
::   message which is returned to the user along with the usage hints.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ShowErrorMsg
@set OSR_ERRCODE=%~1
@set OSR_ERRMSG=%~2
@set OSR_ERRMSG=%OSR_ERRMSG:'="%
@set OSR_ERRMSG=ERROR #%OSR_ERRCODE%: %OSR_ERRMSG%
@echo.
%OSR_ECHO% %OSR_ERRMSG%
if DEFINED buildDirectory %OSR_ECHO% -^> Target directory: %buildDirectory%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ErrorWithUsage subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / SetVar subroutine
::   Param1 == name of the variable, Param2 == value to be set for the variable
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
endlocal & set %VAR_NAME%=%~2
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ SetVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectVistaWDK subroutine
::   No parameters expected
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectVistaWDK
setlocal ENABLEEXTENSIONS
:: Newer flag (starting with W2K8) is default
set OSR_AMD64FLAG=x64
:: The Vista WDK accepted *only* "AMD64", the newer W2K8 WDK accepts only "x64"
:: We detect the older one by checking the setenv.bat for a certain string
findstr /C:"Windows Server Longhorn" "%BASEDIR%\bin\setenv.bat" > NUL 2>&1 && set OSR_AMD64FLAG=AMD64
endlocal & set OSR_AMD64FLAG=%OSR_AMD64FLAG%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectVistaWDK subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectBaseDirTemp subroutine
::   The first parameter is the list of directory names to check, separated by
::   blank spaces.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectBaseDirTemp
:: Get the name of the variable we are working with
if "%~1" == "" goto :EOF
setlocal ENABLEEXTENSIONS
call :CommonCheckMsg1
:: Try to find an installed DDK/WDK from the registry keys
if DEFINED OSR_REGAVAILABLE if not "%OSR_REGAVAILABLE%" == "0" (
  for %%i in (%~1) do @(
    call :RegTryBaseDirTemp "%%i"
  )
)
:: Try all the "default" locations
if not DEFINED BASEDIRTEMP (
  for %%i in (%~1) do @(
    for %%a in (WINDDK DDK) do @(
      call :BruteTryBaseDirTemp "%SystemDrive%\%%a\%%i"
      call :BruteTryBaseDirTemp "%ProgramFiles%\%%a\%%i"
    )
  )
)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTemp subroutine
::   Attempt to find the install key in the registry.
::   This functions tests old-style DDKs and new-style WDKs.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
call :RegTryBaseDirTempSingle "%~1" "LFNDirectory" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
call :RegTryBaseDirTempSingle "%~1\Setup" "BUILD" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
if not DEFINED BASEDIRTEMP (endlocal & goto :EOF)
:RegTryBaseDirTemp_EOF
%OSR_ECHO% Found directory (%BASEDIRTEMP%) from install key
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTempSingle subroutine
::   Attempt to find the install key in the registry.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTempSingle
setlocal ENABLEEXTENSIONS
set REGSUBKEY=%~1
set REGVALUE=%~2
set VARIABLETOSET=%~3
set REGMAINKEY=HKLM\SOFTWARE\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_WOW64
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_WOW64
set REGMAINKEY=HKLM\SOFTWARE\Wow6432Node\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_EOF
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_EOF
endlocal
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTempSingle subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / BruteTryBaseDirTemp subroutine
::   Brute-force test the given directory.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:BruteTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
:: We will not overwrite BASETEMPDIR if it has been set and is valid
:: Just try
set BASEDIRTEMP=%~1
%OSR_ECHO% Trying %BASEDIRTEMP% ...
if not exist "%BASEDIRTEMP%" (endlocal & goto :EOF)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ BruteTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Usage output
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:USAGE
@echo.
@echo USAGE:
@echo ======
@echo   %~n0 ^<target^> ^<build type^> ^<directory^> [flags] [-WDF] [-PREFAST]
@echo.
@echo Values for ^<target^>:
@echo    --------------------------------------------------------------------------
@echo     Target platform and OS   ^| Miscellaneous
@echo    --------------------------^|-----------------------------------------------
@echo     Target     ^| Windows     ^| CPU     ^| Base directory ^| Target alias(es)
@echo    ------------^|-------------^|---------^|----------------^|--------------------
@echo     -W2K       ^| 2000        ^| x86     ^| %%W2KBASE%%      ^|
@echo     -W2K64     ^| 2000        ^| Itanium ^| %%W2KBASE%%      ^| -W2KI64
@echo     -WXP       ^| XP          ^| x86     ^| %%WXPBASE%%      ^| -XP
@echo     -WXP64     ^| XP          ^| Itanium ^| %%WXPBASE%%      ^| -WXPI64, -XP64
@echo     -WXP2K     ^| 2000        ^| x86     ^| %%WXPBASE%%      ^| -XPW2K
@echo     -WNET      ^| 2003        ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNET64    ^| 2003        ^| Itanium ^| %%WNETBASE%%     ^| -WNETI64
@echo     -WNETXP    ^| XP          ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNETXP64  ^| XP          ^| Itanium ^| %%WNETBASE%%     ^|
@echo     -WNETAMD64 ^| 2003/XP x64 ^| x64     ^| %%WNETBASE%%     ^| -WNETX64, -WNETA64
@echo     -WNET2K    ^| 2000 SP3    ^| x86     ^| %%WNETBASE%%     ^| -WNETW2K
@echo     -WLH       ^| Vista/2008  ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLH2K     ^| 2000 SP4    ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP     ^| XP          ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP64   ^| XP          ^| Itanium ^| %%WLHBASE%%      ^|
@echo     -WLHNET    ^| 2003        ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHNETI64 ^| 2003        ^| Itanium ^| %%WLHBASE%%      ^| -WLHNET64
@echo     -WLHNETX64 ^| 2003/XP x64 ^| x64     ^| %%WLHBASE%%      ^| -WLHNETA64
@echo     -WLHI64    ^| Vista/2008  ^| Itanium ^| %%WLHBASE%%      ^| -WLH64
@echo     -WLHX64    ^| Vista/2008  ^| x64     ^| %%WLHBASE%%      ^| -WLHA64
@echo     -NT4       ^| NT 4.0      ^| x86     ^| %%NT4BASE%%      ^|
@echo    --------------------------------------------------------------------------
@echo     Support for NT4 and W2K DDKs is deprecated and not checked anymore
@echo     in new versions. It may or may not work properly.
@echo    --------------------------------------------------------------------------
@echo.
@echo Values for ^<build type^>:
@echo       checked, chk     indicates a checked build
@echo       free, fre        indicates a free build
@echo.
@echo Remaining parameters ("opt!" = optional parameter):
@echo       ^<directory^>      path to build directory, try . (current directory)
@echo       [flags]    opt!  any flags you think should be passed to build (try /a
@echo                        for clean)
@echo       -WDF       opt!  performs a WDF build
@echo       -PREFAST   opt!  performs a PREFAST build
@echo.
@echo Special files:
@echo       The build target directory (where the DIRS or SOURCES file resides) can
@echo       contain the following files:
@echo       - %OSR_PREBUILD_SCRIPT%
@echo         Allows to include a step before the BUILD tool from the DDK is called
@echo         but after the environment for the respective DDK has been set!
@echo       - %OSR_POSTBUILD_SCRIPT%
@echo         Allows to include a step after the BUILD tool from the DDK is called,
@echo         so the environment is still available to the script.
@echo       - %OSR_SETENV_SCRIPT%
@echo         Allows to set (or override) _any_ environment variables that may exist
@echo         in the global environment. Thus you can set the base directory for the
@echo         DDK from inside this script, making your project more self-contained.
@echo.
@echo       DDKBUILD will only handle those files which exist, so you may choose to
@echo       use none, one or multiple of these script files.
@echo       (All scripts execute inside their current directory. Consider this!)
@echo.
@echo Examples:
@echo       ^"%~n0 -NT4 checked .^" (for NT4 BUILD)
@echo       ^"%~n0 -WXP64 chk .^"
@echo       ^"%~n0 -WXP chk c:\projects\myproject^"
@echo       ^"%~n0 -WNET64 chk .^"      (IA64 build)
@echo       ^"%~n0 -WNETAMD64 chk .^"   (AMD64/EM64T build)
@echo       ^"%~n0 -WNETXP chk . -cZ -WDF^"
@echo       ^"%~n0 -WNETXP chk . -cZ -PREFAST^"
@echo.
@echo       In order for this procedure to work correctly for each platform, it
@echo       requires an environment variable to be set up for certain platforms.
@echo       There is an auto-detection mechanism in this script, which will work best
@echo       if the DDK/WDK was installed using the normal installer (i.e. not just
@echo       copied). The auto-detection is based on the DDK/WDK for which you request
@echo       a build. Whenever you set the variable explicitly, this will take
@echo       precedence over the auto-detected path!
@echo       The environment variables are as follows:
@echo.
@echo       %%NT4BASE%%  - Set this up for ^"-NT4^" builds
@echo       %%W2KBASE%%  - Set this up for ^"-W2K^" and ^"-W2K64^" builds
@echo       %%WXPBASE%%  - Set this up for ^"-WXP^", ^"-WXP64^", ^"-WXP2K^" builds
@echo       %%WNETBASE%% - Set this up for ^"-WNET*^" builds
@echo       %%WLHBASE%%  - Set this up for ^"-WLH*^" builds
@echo.
@echo       %%WDF_ROOT%% must be set if attempting to do a WDF Build previous to the
@echo       Vista WDK (in later DDKs there is no need to set WDF_ROOT).
@echo.
@echo Path to this script:
@echo      %~f0
@echo.
@echo   %OSR_VERSTR%
@echo   -^> report any problems to ^<info@osr.com^> or ^<http://assarbad.net/contact/^>
@echo.

:END
popd & endlocal & exit /b %OSR_ERRCODE%
```

`HideIDTHook/HideIDTHook/makefile`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

`HideIDTHook/HideIDTHook/mybuild.bat`:

```bat
set WLHBASE=C:\WINDDK\7600.16385.0
set WDF_ROOT=C:\WINDDK\7600.16385.0
ddkbuild.cmd -WLH chk . -cZ -WDF
```

`HideIDTHook/HideIDTHook/sources`:

```
TARGETNAME=HideIDTHook
#TARGETPATH=$(BASEDIR)\lib
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=.\

SOURCES=HideIDTHook.c


```

`HideIDTHook/README.md`:

```md
##隐藏IDT HOOk

WDK7600编译，通过Hook GDT表简介改变IDT中断服务例程的地址。
[http://www.cnblogs.com/lanrenxinxin/p/4692013.html](http://www.cnblogs.com/lanrenxinxin/p/4692013.html)
```

`Inject_By_kernelAPC/ReadMe.md`:

```md
##内核APC注入
```

`Inject_By_kernelAPC/ring0/KeInjectApc.c`:

```c


#ifndef CXX_KEINJECTAPC_H
#	include "KeInjectApc.h"
#endif


ULONG ApcStateOffset; 
PLDR_LOAD_DLL LdrLoadDll; 


NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING pRegistryPath)
{
	NTSTATUS Status;
	PDEVICE_OBJECT DeviceObject;
	PEPROCESS Process;
	PETHREAD Thread;
	PKAPC_STATE ApcState;

	PVOID KdVersionBlock,NtdllBase;
	PULONG ptr,Functions,Names;
	PUSHORT Ordinals;

	PLDR_DATA_TABLE_ENTRY MmLoadedUserImageList,ModuleEntry;
	ULONG i;

	PIMAGE_DOS_HEADER pIDH;
	PIMAGE_NT_HEADERS pINH;
	PIMAGE_EXPORT_DIRECTORY pIED;

	UNICODE_STRING   uniDeviceName;
	UNICODE_STRING   uniLinkName;

	RtlInitUnicodeString(&uniDeviceName,DEVICE_NAME);

	RtlInitUnicodeString(&uniLinkName,LINK_NAME);

	for (i=0;i<IRP_MJ_MAXIMUM_FUNCTION;i++)
	{
		DriverObject->MajorFunction[i] = DefaultPassThrough;
	}
	DriverObject->DriverUnload = UnloadDriver;

	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDispatch;

	//创建设备对象
	Status = IoCreateDevice(DriverObject,0,&uniDeviceName,FILE_DEVICE_UNKNOWN,0,FALSE,&DeviceObject);

	if (!NT_SUCCESS(Status))
	{

		return Status;
	}

	Status = IoCreateSymbolicLink(&uniLinkName,&uniDeviceName);

	if (!NT_SUCCESS(Status))
	{
		IoDeleteDevice(DeviceObject);

		return Status;
	}

	//使当前线程运行在第一个处理器上
	KeSetSystemAffinityThread(1);
	KdVersionBlock=(PVOID)__readfsdword(0x34); //得到KdVersionBlock
	KeRevertToUserAffinityThread();//恢复线程运行的处理器
	MmLoadedUserImageList=*(PLDR_DATA_TABLE_ENTRY*)((PUCHAR)KdVersionBlock+0x228); // Get the MmLoadUserImageList

	/*
	kd> !pcr
	KPCR for Processor 0 at 83f3ec00:


	kd> dt _kpcr 83f3ec00
	+0x034 KdVersionBlock   : 0x83f3dc00 Void

	kd> dd 0x83f3dc00+0x228
	83f3de28  83f5de38 00000000 83e5dfa8 00000000
	83f3de38  00000000 00000000 83f7d8c0 00000000
	83f3de48  83f7d560 00000000 83f5d84c 00000000


	kd> dd 83f5de38
	83f5de38  8706b1e8 877cb660 00000000 00000000
	83f5de48  00000000 00000000 00040107 00000000
	83f5de58  865d0690 865d0690 c0403188 0007ff7e

	kd> dt _LDR_DATA_TABLE_ENTRY 8706b1e8
	nt!_LDR_DATA_TABLE_ENTRY
	+0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x8713b4e0 - 0x83f5de38 ]
	+0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]
	+0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]
	+0x018 DllBase          : 0x77ce0000 Void
	+0x01c EntryPoint       : (null) 
	+0x020 SizeOfImage      : 0x13c000
	+0x024 FullDllName      : _UNICODE_STRING "\Windows\System32\ntdll.dll"
	+0x02c BaseDllName      : _UNICODE_STRING ""
	+0x034 Flags            : 0
	+0x038 LoadCount        : 1
	+0x03a TlsIndex         : 0
	+0x03c HashLinks        : _LIST_ENTRY [ 0x0 - 0x1490d9 ]
	+0x03c SectionPointer   : (null) 
	+0x040 CheckSum         : 0x1490d9
	+0x044 TimeDateStamp    : 0
	+0x044 LoadedImports    : (null) 
	+0x048 EntryPointActivationContext : (null) 
	+0x04c PatchInformation : (null) 
	+0x050 ForwarderLinks   : _LIST_ENTRY [ 0x0 - 0x0 ]
	+0x058 ServiceTagLinks  : _LIST_ENTRY [ 0x0 - 0x57005c ]
	+0x060 StaticLinks      : _LIST_ENTRY [ 0x6e0069 - 0x6f0064 ]
	+0x068 ContextInformation : 0x00730077 Void
	+0x06c OriginalBase     : 0x53005c
	+0x070 LoadTime         : _LARGE_INTEGER 0x650074`00730079

	*/
	DbgPrint("KdVersionBlock address: %#x",KdVersionBlock);
	DbgPrint("MmLoadedUserImageList address: %#x",MmLoadedUserImageList);

	ModuleEntry=(PLDR_DATA_TABLE_ENTRY)MmLoadedUserImageList->InLoadOrderLinks.Flink; //第一模块
	NtdllBase=ModuleEntry->DllBase; //ntdll基地址

	DbgPrint("ntdll base address: %#x",NtdllBase);

	pIDH=(PIMAGE_DOS_HEADER)NtdllBase;
	pINH=(PIMAGE_NT_HEADERS)((PUCHAR)NtdllBase+pIDH->e_lfanew);
	pIED=(PIMAGE_EXPORT_DIRECTORY)((PUCHAR)NtdllBase+pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	Functions=(PULONG)((PUCHAR)NtdllBase+pIED->AddressOfFunctions);
	Names=(PULONG)((PUCHAR)NtdllBase+pIED->AddressOfNames);

	Ordinals=(PUSHORT)((PUCHAR)NtdllBase+pIED->AddressOfNameOrdinals);

	//搜索LdrLoadDll
	for(i=0;i<pIED->NumberOfNames;i++)
	{
		if(!strcmp((char*)NtdllBase+Names[i],"LdrLoadDll"))
		{
			LdrLoadDll=(PLDR_LOAD_DLL)((PUCHAR)NtdllBase+Functions[Ordinals[i]]);
			break;
		}
	}

	DbgPrint("LdrLoadDll address: %#x",LdrLoadDll);

	Process=PsGetCurrentProcess();
	Thread=PsGetCurrentThread();

	ptr=(PULONG)Thread;

	//确定ApcState在EThread中的偏移
	for(i=0;i<512;i++)
	{
		if(ptr[i]==(ULONG)Process)
		{
			ApcState=CONTAINING_RECORD(&ptr[i],KAPC_STATE,Process); 
			ApcStateOffset=(ULONG)ApcState-(ULONG)Thread; 
			break;
		}
	}

	DbgPrint("ApcState offset: %#x",ApcStateOffset);
	DbgPrint("DLL injection driver loaded.");
	return STATUS_SUCCESS;
}




NTSTATUS DefaultPassThrough(PDEVICE_OBJECT  DeviceObject,PIRP Irp)
{
	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = STATUS_SUCCESS;

	IoCompleteRequest(Irp,IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}


void UnloadDriver(PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING  uniLinkName;
	PDEVICE_OBJECT  CurrentDeviceObject;
	PDEVICE_OBJECT  NextDeviceObject;

	RtlInitUnicodeString(&uniLinkName,LINK_NAME);

	IoDeleteSymbolicLink(&uniLinkName);

	if (DriverObject->DeviceObject!=NULL)
	{
		CurrentDeviceObject = DriverObject->DeviceObject;

		while(CurrentDeviceObject!=NULL)
		{
			NextDeviceObject  = CurrentDeviceObject->NextDevice;
			IoDeleteDevice(CurrentDeviceObject);

			CurrentDeviceObject = NextDeviceObject;
		}
	}
	DbgPrint("UnloadDriver\r\n");
}


void NTAPI InjectDllApc(PVOID NormalContext,PVOID SystemArgument1,PVOID SystemArgument2)
{
	PKINJECT inject=(PKINJECT)NormalContext;

	inject->LdrLoadDll(NULL,NULL,&inject->DllName,&inject->DllBase);
	inject->Executed=TRUE;
}


void NTAPI KernelRoutine(PKAPC apc,PKNORMAL_ROUTINE* NormalRoutine,PVOID* NormalContext,\
	PVOID* SystemArgument1,PVOID* SystemArgument2)
{
	ExFreePool(apc);
}

BOOLEAN InjectDll(PINJECT_INFO InjectInfo)
{
	PEPROCESS Process;
	PETHREAD Thread;
	PKINJECT mem;
    ULONG size;
	PKAPC_STATE ApcState;
	PKAPC apc;
	PVOID buffer;
	PSYSTEM_PROCESS_INFO pSpi;
	LARGE_INTEGER delay;
	buffer=ExAllocatePool(NonPagedPool,1024*1024); 
	if(!buffer)
	{
		DbgPrint("Error: Unable to allocate memory for the process thread list.");
		return FALSE;
	}

	//5	SystemProcessInformation,
	if(!NT_SUCCESS(ZwQuerySystemInformation(5,buffer,1024*1024,NULL)))
	{
		DbgPrint("Error: Unable to query process thread list.");

		ExFreePool(buffer);
		return FALSE;
	}

	pSpi=(PSYSTEM_PROCESS_INFO)buffer;

	//找到目标进程
	while(pSpi->NextEntryOffset)
	{
		if(pSpi->UniqueProcessId==InjectInfo->ProcessId)
		{
			DbgPrint("Target thread found. TID: %d",pSpi->Threads[0].ClientId.UniqueThread);
			break;
		}

		pSpi=(PSYSTEM_PROCESS_INFO)((PUCHAR)pSpi+pSpi->NextEntryOffset);
	}

	// 引用目标进程EProcess,
	if(!NT_SUCCESS(PsLookupProcessByProcessId(InjectInfo->ProcessId,&Process)))
	{
		DbgPrint("Error: Unable to reference the target process.");
		ExFreePool(buffer);
		return FALSE;
	}

	DbgPrint("Process name: %s",PsGetProcessImageFileName(Process));
	DbgPrint("EPROCESS address: %#x",Process);

	//目标进程主线程
	if(!NT_SUCCESS(PsLookupThreadByThreadId(pSpi->Threads[0].ClientId.UniqueThread,&Thread)))
	{
		DbgPrint("Error: Unable to reference the target thread.");
		ObDereferenceObject(Process); 
		ExFreePool(buffer); 
		return FALSE;
	}

	DbgPrint("ETHREAD address: %#x",Thread);

	ExFreePool(buffer); 
	//切入到目标进程
	KeAttachProcess(Process); 

	mem=NULL;
	size=4096;

	//在目标进程申请内存
	if(!NT_SUCCESS(ZwAllocateVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,0,&size,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE)))
	{
		DbgPrint("Error: Unable to allocate memory in the target process.");
		KeDetachProcess(); 

		ObDereferenceObject(Process);
		ObDereferenceObject(Thread); 
		return FALSE;
	}

	DbgPrint("Memory allocated at %#x",mem);
	mem->LdrLoadDll=LdrLoadDll; 
	wcscpy(mem->Buffer,InjectInfo->DllName); 
	RtlInitUnicodeString(&mem->DllName,mem->Buffer); 
	ApcState=(PKAPC_STATE)((PUCHAR)Thread+ApcStateOffset); 
	ApcState->UserApcPending=TRUE;   
	memcpy((PKINJECT)(mem+1),InjectDllApc,(ULONG)KernelRoutine-(ULONG)InjectDllApc); 
	DbgPrint("APC code address: %#x",(PKINJECT)(mem+1));

	//申请apc对象
	apc=(PKAPC)ExAllocatePool(NonPagedPool,sizeof(KAPC)); 

	if(!apc)
	{
		DbgPrint("Error: Unable to allocate the APC object.");
		size=0;
		ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE);  
		KeDetachProcess();
		ObDereferenceObject(Process); 
		ObDereferenceObject(Thread); 
		return FALSE;
	}

	KeInitializeApc(apc,
		Thread,    //目标进程主线程
		OriginalApcEnvironment,   //目标apcz状态
		KernelRoutine,  //内核apc总入口
		NULL,       //Rundown Rounine=NULL
		(PKNORMAL_ROUTINE)((PKINJECT)mem+1),   //用户空间的总apc
		UserMode,   //插入到用户apc队列
		mem); // 自己的apc队列

	DbgPrint("Inserting APC to target thread");

	// 插入apc队列
	if(!KeInsertQueueApc(apc,NULL,NULL,IO_NO_INCREMENT))
	{
		DbgPrint("Error: Unable to insert APC to target thread.");
		size=0;
		ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE); 
		KeDetachProcess(); 
		ObDereferenceObject(Process); 
		ObDereferenceObject(Thread); 
		ExFreePool(apc); 
		return FALSE;
	}

	delay.QuadPart=-100*10000;
	while(!mem->Executed)
	{
		KeDelayExecutionThread(KernelMode,FALSE,&delay);  //等待apc执行 
	}
	if(!mem->DllBase)
	{
		DbgPrint("Error: Unable to inject DLL into target process.");
		size=0;
		ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE);
		KeDetachProcess();
		ObDereferenceObject(Process);
		ObDereferenceObject(Thread);
		return FALSE;
	}

	DbgPrint("DLL injected at %#x",mem->DllBase);
	size=0;
	ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE); 
	ObDereferenceObject(Process); 
	ObDereferenceObject(Thread); 
	return TRUE;
}

NTSTATUS DriverDispatch(PDEVICE_OBJECT DeviceObject,PIRP Irp)
{
	PIO_STACK_LOCATION io;
	PINJECT_INFO InjectInfo;
	NTSTATUS  Status = STATUS_SUCCESS;
	PIO_STACK_LOCATION   IrpSp;
	PVOID     InputBuffer  = NULL;
	PVOID     OutputBuffer = NULL;
	ULONG_PTR InputSize  = 0;
	ULONG_PTR OutputSize = 0;
	ULONG_PTR IoControlCode = 0;

	IrpSp = IoGetCurrentIrpStackLocation(Irp);
 	InputBuffer = OutputBuffer = Irp->AssociatedIrp.SystemBuffer;
 	InputSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
 	OutputSize  = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
	IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

	switch(IoControlCode)
	{
	case CTL_KEINJECTAPC:

		InjectInfo=(PINJECT_INFO)InputBuffer;

		if(!InjectInfo)
		{
			Status=STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		if(!InjectDll(InjectInfo))
		{
			Status=STATUS_UNSUCCESSFUL;
			break;
		}

		Status=STATUS_SUCCESS;
		Irp->IoStatus.Information=0;

		break;

	default:
		Status=STATUS_INVALID_DEVICE_REQUEST;
		break;
	}

	Irp->IoStatus.Status=Status;

	IoCompleteRequest(Irp,IO_NO_INCREMENT);
	return Status;
}

```

`Inject_By_kernelAPC/ring0/KeInjectApc.h`:

```h


#ifndef CXX_KEINJECTAPC_H
#define CXX_KEINJECTAPC_H



#include <ntifs.h>
#include <devioctl.h>
#include <ntimage.h>

#endif	


#define DEVICE_NAME       L"\\Device\\DriverDevice"
#define LINK_NAME 	  L"\\DosDevices\\DriverLink"

#define CTL_KEINJECTAPC \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION,*PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO,*PSYSTEM_PROCESS_INFO;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;

	union
	{
		LIST_ENTRY HashLinks;

		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};

	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};

	struct _ACTIVATION_CONTEXT * EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
}LDR_DATA_TABLE_ENTRY,*PLDR_DATA_TABLE_ENTRY;


typedef struct _INJECT_INFO
{
	ULONG ProcessId;
	wchar_t DllName[1024];
}INJECT_INFO,*PINJECT_INFO;

typedef NTSTATUS (*PLDR_LOAD_DLL)(PWSTR,PULONG,PUNICODE_STRING,PVOID*);

typedef struct _KINJECT
{
	UNICODE_STRING DllName;
	wchar_t Buffer[1024];
	PLDR_LOAD_DLL LdrLoadDll;
	PVOID DllBase;
	ULONG Executed;
}KINJECT,*PKINJECT;

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
}KAPC_ENVIRONMENT,*PKAPC_ENVIRONMENT;

typedef VOID (NTAPI *PKNORMAL_ROUTINE)(
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
	);

typedef VOID KKERNEL_ROUTINE(
	PRKAPC Apc,
	PKNORMAL_ROUTINE *NormalRoutine,
	PVOID *NormalContext,
	PVOID *SystemArgument1,
	PVOID *SystemArgument2
	);

typedef KKERNEL_ROUTINE (NTAPI *PKKERNEL_ROUTINE);

typedef VOID (NTAPI *PKRUNDOWN_ROUTINE)(
	PRKAPC Apc
	);

void KeInitializeApc(
	PRKAPC Apc,
	PRKTHREAD Thread,
	KAPC_ENVIRONMENT Environment,
	PKKERNEL_ROUTINE KernelRoutine,
	PKRUNDOWN_ROUTINE RundownRoutine,
	PKNORMAL_ROUTINE NormalRoutine,
	KPROCESSOR_MODE ProcessorMode,
	PVOID NormalContext
	);

BOOLEAN KeInsertQueueApc(
	PRKAPC Apc,
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	KPRIORITY Increment
	);



NTSTATUS ZwQuerySystemInformation(ULONG InfoClass,PVOID Buffer,ULONG Length,PULONG ReturnLength);
LPSTR PsGetProcessImageFileName(PEPROCESS Process);

NTSTATUS DefaultPassThrough(PDEVICE_OBJECT  DeviceObject,PIRP Irp);
void UnloadDriver(PDRIVER_OBJECT DriverObject);
NTSTATUS DriverDispatch(PDEVICE_OBJECT DeviceObject,PIRP Irp);
```

`Inject_By_kernelAPC/ring0/KeInjectApc.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KeInjectApc", "KeInjectApc.vcxproj", "{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		WinDDK|Win32 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.ActiveCfg = WinDDK|Win32
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.Build.0 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Inject_By_kernelAPC/ring0/KeInjectApc.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="WinDDK|Win32">
      <Configuration>WinDDK</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>"KeInjectApc"</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
    <ExecutablePath>$(WLHBASE)\bin\x86\x86;$(WLHBASE)\bin\x86</ExecutablePath>
    <IncludePath>$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc</IncludePath>
    <ReferencePath />
    <LibraryPath>$(WLHBASE)\lib\win7\i386</LibraryPath>
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG=1</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include=".\KeInjectApc.c" />
    <ClCompile Include=".\KeInjectApc.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Inject_By_kernelAPC/ring0/KeInjectApc.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Inject_By_kernelAPC/ring0/clean.bat`:

```bat
rem /////////////////
rem / Add by ChiChou
rem / 
rem / FileName:Clean.bat
rem / Description:Clean
rem /
rem ////////////////
rd .\bin /s /q
rd .\WinDDK /s /q
rd .\objchk_w2k_x86 /s /q
rd .\objchk_wxp_x86 /s /q
rd .\objchk_wnet_x86 /s /q
rd .\objchk_wlh_x86 /s /q
rd .\objfre_w2k_x86 /s /q
rd .\objfre_wxp_x86 /s /q
rd .\objfre_wnet_x86 /s /q
rd .\objfre_wlh_x86 /s /q
del .\*.log
del .\*.err
del .\*.xml
rem ***** del VS2005 file *****
del .\*.ncb
del .\*.user
del .\*.suo /A:H
rem ***** del VS6.0 file *****
del .\*.plg
del .\*.opt
exit
```

`Inject_By_kernelAPC/ring0/ddkbuild.cmd`:

```cmd
@echo off
@set VERSION=V7.3
@set OSR_DEBUG=off
@if "%OS%"=="Windows_NT" goto :Prerequisites
@echo This script requires Windows NT 4.0 or later to run properly!
goto :EOF
:Prerequisites
:: Check whether FINDSTR is available. It's used to show warnings etc.
findstr /? > NUL 2>&1 || echo "FINDSTR is a prerequisite but wasn't found!" && goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    $Id: ddkbuild.cmd 27 2008-09-06 12:02:06Z oliver $
::
::    This software is supplied for instructional purposes only.
::
::    OSR Open Systems Resources, Inc. (OSR) expressly disclaims any warranty
::    for this software.  THIS SOFTWARE IS PROVIDED  "AS IS" WITHOUT WARRANTY
::    OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
::    THE IMPLIED WARRANTIES OF MECHANTABILITY OR FITNESS FOR A PARTICULAR
::    PURPOSE.  THE ENTIRE RISK ARISING FROM THE USE OF THIS SOFTWARE REMAINS
::    WITH YOU.  OSR's entire liability and your exclusive remedy shall not
::    exceed the price paid for this material.  In no event shall OSR or its
::    suppliers be liable for any damages whatsoever (including, without
::    limitation, damages for loss of business profit, business interruption,
::    loss of business information, or any other pecuniary loss) arising out
::    of the use or inability to use this software, even if OSR has been
::    advised of the possibility of such damages.  Because some states/
::    jurisdictions do not allow the exclusion or limitation of liability for
::    consequential or incidental damages, the above limitation may not apply
::    to you.
::
::    OSR Open Systems Resources, Inc.
::    105 Route 101A Suite 19
::    Amherst, NH 03031  (603) 595-6500 FAX: (603) 595-6503
::    report bugs to <bugs@osr.com>
::    alternatively report them via <http://assarbad.net/contact/>
::
::
::    MODULE:
::
::      ddkbuild.cmd
::
::    ABSTRACT:
::
::      This script allows drivers to be built with Visual Studio 2002 through
::      Visual Studio 2008 and possibly future versions. It will also work fine
::      from the command line.
::      If you are interested in a project wizard that makes use of this script,
::      try DDKWizard from <http://ddkwizard.assarbad.net>.
::
::    AUTHOR(S):
::
::      - OSR Open Systems Resources, Inc.
::      - Oliver Schneider (ddkwizard.assarbad.net)
::
::    REQUIREMENTS:
::
::      Environment variables that must be set.
::        %NT4BASE%  - Set this up for "-NT4" builds (legacy, support not tested)
::        %W2KBASE%  - Set this up for "-W2K*" builds (legacy, support not tested)
::        %WXPBASE%  - Set this up for "-WXP*" builds
::        %WNETBASE% - Set this up for "-WNET*" builds
::        %WLHBASE%  - Set this up for "-WLH*" builds
::        %WDF_ROOT% - Must be set if attempting to do a WDF Build.
::
::      Examples:
::        NT4BASE : could be "D:\NT4DDK"
::        W2KBASE : could be "D:\Nt50DDK"
::        WXPBASE : could be "D:\WINDDK\2600"
::        WNETBASE: could be "D:\WINDDK\3790.1830" or "C:\WINDDK\3790"
::
::    COMMAND FORMAT:
::
::      Run the script without any parameters to get the whole help content!
::      Note: "-WDF" has been tested with the 01.00.5054 version of the framework
::
::    RETURN CODES AND THEIR MEANING:
::
::      001 == Unknown build type. Check the <platform> parameter
::      002 == No WDF_ROOT given using WDF build type.
::      003 == The DDK-specific base directory variable (NT4BASE, W2KBASE, WXPBASE,
::             WNETBASE) is not set at all and could not be auto-detected!
::      004 == BASEDIR variable is empty. Check to see that the DDK-specific
::             variable is set correctly (i.e. NT4BASE, W2KBASE, WXPBASE, WNETBASE)
::      005 == No mode (checked/free) was given. Check the respective parameter!
::      006 == No DIR or SOURCES file found in the given target directory.
::      007 == No target directory given.
::      008 == Given target directory does not exist.
::      009 == The SETENV script failed.
::
::      Note: If %OSR_ERRCODE% and %ERRORLEVEL% are equal, the return code stems
::            from one of the tools being called during the build process.
::
::    BROWSE FILES:
::
::      This procedure supports the building of BROWSE files to be used by
::      Visual Studio 6 and by Visual Studio.NET  However, the BSCfiles created
::      by bscmake for the two are not compatible. When this command procedure
::      runs, it selects the first bscmake.exe found in the path. So, make sure
::      that the correct bscmake.exe is in the path ...
::
::      Note that if using Visual Studio.NET the .BSC must be added to the project
::      in order for the project to be browsed.
::      Another alternative is the VS addon named "Visual Assist X" which will
::      parse the header files - no more need for browse files.
::
::    COMPILERS:
::
::      If you are building NT4 you should really be using the VC6 compiler.
::      Later versions of the DDK now contain the compiler and the linker. This
::      procedure should use the correct compiler.
::
::    GENERAL COMMENTS:
::
::      This procedure has been cleaned up to be modular and easy to understand.
::
::      As of the Server 2003 SP1 DDK DDKBUILD now clears the NO_BROWSE_FILE and
::      NO_BINPLACE environment variables so that users can use these features.
::
::      Starting with the Vista WDK, the output in the respective tool window
::      in VS is in Unicode by default. This garbles the output from DDKBUILD
::      and we therefore clear the environment variable VS_UNICODE_OUTPUT.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MAIN
:: Building "stack frame"
setlocal ENABLEEXTENSIONS & pushd .
:: Check whether the REG utility is available
reg /? > NUL 2>&1 && set OSR_REGAVAILABLE=1

:: This is set by client-side keyword substitution
set SVN_REVISION=$Revision: 27 $
:: Extract the revision number from the revision keyword
set SVN_REVISION=%SVN_REVISION:~0,-2%
set SVN_REVISION=%SVN_REVISION:~11%
:: This is set by client-side keyword substitution
set SVN_REVDATE=$Date: 2008-09-06 12:02:06 +0000 (Sat, 06 Sep 2008) $
:: Extract the date from the Date keyword
set SVN_REVDATE=%SVN_REVDATE:~7,10%
set VERSION=%VERSION%/r%SVN_REVISION%

:: Init some special variables
set OSR_VERSTR=OSR DDKBUILD.CMD %VERSION% (%SVN_REVDATE%) - OSR, Open Systems Resources, Inc.
set OSR_PREBUILD_SCRIPT=ddkprebld.cmd
set OSR_POSTBUILD_SCRIPT=ddkpostbld.cmd
set OSR_SETENV_SCRIPT=ddkbldenv.cmd
set OSR_ECHO=@echo DDKBLD:

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set error messages
:: Possible codes: 1
set ERR_UnknownBuildType=Unknown type of build. Please recheck parameters.
:: Possible codes: 2
set ERR_NoWdfRoot=WDF_ROOT is not defined, are you using 00.01.5054 or later?
:: Possible codes: 3
set ERR_BaseDirNotSet=To build using type %%OSR_TARGET%% you need to set the %%%%%%BASEDIRVAR%%%%%% environment variable to point to the %%BASEDIROS%% DDK base directory!
:: Possible codes: 4
set ERR_NoBASEDIR=NT4BASE, W2KBASE, WXPBASE and/or WNETBASE environment variable(s) not set. Environment variable(s) must be set by user according to DDK version(s) installed.
:: Possible codes: 5
set ERR_BadMode=^<build type^> must be 'checked', 'free', 'chk' or 'fre' (case-insensitive).
:: Possible codes: 6
set ERR_NoTarget=Target directory must contain a SOURCES or DIRS file.
:: Possible codes: 7, 8
set ERR_NoDir=The ^<directory^> parameter must be a valid directory.
:: Possible codes: 9
set ERR_SetEnvFailed=The SETENV script failed.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Clear the error code variable
set OSR_ERRCODE=0
set prefast_build=0

:: Turn on tracing, use %OSR_TRACE% instead of ECHO
if /i "%OSR_DEBUG%" == "on" (set OSR_TRACE=%OSR_ECHO% [TRACE]) else (set OSR_TRACE=rem)
:: Turn on echoing of current line if %OSR_DEBUG% is set to "on"
@echo %OSR_DEBUG%

:: Output version string
@echo %OSR_VERSTR%
%OSR_TRACE% ^(Current module: ^"%~f0^"^)
@echo.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set the target platform variable
set OSR_TARGET=%~1
:: Remove any dashes in the variable
if not "%OSR_TARGET%" == "" set OSR_TARGET=%OSR_TARGET:-=%
:: Show help if the target parameter is empty after removal of the dashes
if "%OSR_TARGET%" == "" goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: In the build directory check for this script and call it if it exists.
:: This allows to override any global system variable setting, if desired.
if not "%3" == "" call :GetCustomEnvironment "%~f3"
if not "%OSR_ERRCODE%" == "0" goto :USAGE
:: Additional error handling for better usability
:: These subroutines will also attempt to locate the requested DDK!!!
set OSR_ERRCODE=3
%OSR_TRACE% Checking whether the environment variable for the build type was set
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Check > NUL 2>&1
:: If the BASEDIROS/BASEDIRVAR variable is not defined, it means the subroutine did not exist!
if not DEFINED BASEDIROS call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIROS)" & goto :USAGE
if not DEFINED BASEDIRVAR call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIRVAR)" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BaseDirNotSet%" & goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
set BASEDIR=%%%BASEDIRVAR%%%
call :ResolveVar BASEDIR
call :MakeShort BASEDIR "%BASEDIR%"
:: Check for existing %BASEDIR%
if "%BASEDIR%" == "" call :ShowErrorMsg 4 "%ERR_NoBASEDIR%" & goto :USAGE
set PATH=%BASEDIR%\bin;%PATH%
%OSR_TRACE% Now jump to the initialization of the commandline
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Build

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_TRACE% We returned from the variable initialization
if not DEFINED OSR_CMDLINE call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (OSR_CMDLINE)" & goto :USAGE

%OSR_TRACE% Hurrah, all the variables have been initialized, continuing
:: Proceed with common build steps
goto :CommonBuild

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Check whether the parameter makes sense and try to
:: correct it if possible
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WLH64Check
:WLHA64Check
:WLHXP64Check
:WLHNET64Check
:WLHNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WLHCheck
:WLHX64Check
:WLHI64Check
:WLHNETX64Check
:WLHNETI64Check
:WLHXPCheck
:WLH2KCheck
:WLHNETCheck
set BASEDIROS=Windows Vista/Windows 2008 Server
set BASEDIRVAR=WLHBASE
:: Compatibility between BUILD and VS ... prevent pipes from being used
%OSR_ECHO% Clearing %%VS_UNICODE_OUTPUT%% ...
set VS_UNICODE_OUTPUT=
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "6001.18000 6000"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WNETW2KCheck
:WNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WNET2KCheck
:WNETXPCheck
:WNETWXPCheck
:WNETXP64Check
:WNET64Check
:WNETI64Check
:WNETAMD64Check
:WNETX64Check
:WNETCheck
set BASEDIROS=Windows 2003 Server
set BASEDIRVAR=WNETBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "3790.1830 3790.1218 3790"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:XPCheck
:XP64Check
:XPW2KCheck
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WXP64Check
:WXPI64Check
:WXPCheck
:WXP2KCheck
set BASEDIROS=Windows XP
set BASEDIRVAR=WXPBASE
:: Other flavor of DDKBUILD
if not DEFINED WXPBASE if DEFINED XPBASE set BASEDIRVAR=XPBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "2600.1106 2600"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:W2K64Check
:W2KI64Check
:W2KCheck
set BASEDIROS=Windows 2000
set BASEDIRVAR=W2KBASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:NT4Check
set BASEDIROS=Windows NT4
set BASEDIRVAR=NT4BASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg1
echo.
%OSR_ECHO% WARNING: %%%BASEDIRVAR%%% NOT SET!
%OSR_ECHO%   Attempting to auto-detect the installation folder and set %%%BASEDIRVAR%%%.
%OSR_ECHO%   (If this fails *you* will have to set it!)
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg2
echo.
%OSR_ECHO% WARNING:
%OSR_ECHO%   Auto-detection of the folder settings is not supported for the requested DDK.
%OSR_ECHO%   Please set %%%BASEDIRVAR%%% yourself!
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckSetVarWithReturn
%OSR_ECHO% Found!
echo.
set %BASEDIRVAR%=%BASEDIRTEMP%
set BASEDIRTEMP=
:: Tell the caller it was successful
:CommonCheckNoErrorWithReturn
set OSR_ERRCODE=0
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckErrorNotDetectedWithReturn
echo.
%OSR_ECHO% None of the usual default paths works. Set %%%BASEDIRVAR%%% manually!
:CommonCheckErrorNotSupportedWithReturn
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Initialize variables specific to the respective platform
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: 
:: Valid parameters for setenv in different DDKs/WDKs:
::
:: 2600       - "setenv <directory> [fre|chk] [64] [hal]"
:: 2600.1106  - "setenv <directory> [fre|chk] [64] [hal] [WXP|W2K]"
:: 3790       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K]"
:: 3790.1830  - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K] [no_prefast] [bscmake]"
:: 6000       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"
:: 6001.18000 - "setenv <directory> [fre|chk] [64|x64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: NT 4.0 build using NT4 DDK
:NT4Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% "%%MSDEVDIR%%"
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WXP DDK
:XPW2KBuild
:WXP2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\w2k\set2k.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 64bit (Intel) using W2K DDK
:W2K64Build
:W2KI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv64.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using W2K DDK
:W2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WXP DDK
:XP64Build
:WXP64Build
:WXPI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WXP DDK
:XPBuild
:WXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WNET DDK
:WNETW2KBuild
:WNET2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% W2K %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WNET DDK
:WNETXPBuild
:WNETWXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit using WNET DDK
:WNETXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WNET DDK
:WNET64Build
:WNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WNET DDK
:WNETA64Build
:WNETAMD64Build
:WNETX64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% AMD64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WNET DDK
:WNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 32bit using WLH DDK
:WLHBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (AMD) using WLH DDK
:WLHA64Build
:WLHX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (Intel) using WLH DDK
:WLH64Build
:WLHI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WLH DDK
:WLHNETA64Build
:WLHNETX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WLH DDK
:WLHNET64Build
:WLHNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WLH DDK
:WLHXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WLH DDK
:WLHXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WLH DDK
:WLH2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% W2K
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WLH DDK
:WLHNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: All builds go here for the rest of the procedure. Now,
:: we are getting ready to call build. The big problem
:: here is to figure our the name of the buildxxx files
:: being generated for the different platforms.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:CommonBuild
:: Remove first command line arg
shift
call :SetMode %1
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BadMode%" & goto :USAGE
set OSR_BUILDNAME=%OSR_TARGET% (%BuildMode%) using the %BASEDIROS% DDK and %%%BASEDIRVAR%%%

call :CheckTargets %2
if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :USAGE

:: Resolve any variables in the command line string
call :ResolveVar OSR_CMDLINE

pushd .
set ERRORLEVEL=0
:: This external script prepares the build environment (e.g. setenv.bat)
call %OSR_CMDLINE%
:: Will only work with newer SETENV.BAT versions, but will be helpful in this case.
if not "%ERRORLEVEL%" == "0" call :ShowErrorMsg 9 "%ERR_SetEnvFailed%" & goto :USAGE
popd

:: ----------------------------------------------------------------------------
:: Setting global variables for the scope of this CMD session
set NO_BROWSER_FILE=
set NO_BINPLACE=
set buildDirectory=%~fs2
call :MakeShort buildDirectory "%buildDirectory%"
set buildDirectory_raw=%2
set buildDirectory_fname=%~n2
%OSR_TRACE% buildDirectory       == %buildDirectory%
%OSR_TRACE% buildDirectory_raw   == %buildDirectory_raw%
%OSR_TRACE% buildDirectory_fname == %buildDirectory_fname%

set mpFlag=-M
if "%BUILD_ALT_DIR%" == "" goto :NT4

:: W2K sets this!
set OSR_EXT=%BUILD_ALT_DIR%
set mpFlag=-MI

:NT4
if "%NUMBER_OF_PROCESSORS%" == "" set mpFlag=
if "%NUMBER_OF_PROCESSORS%" == "1" set mpFlag=

:: Set additional variables at this point or do whatever you please
@if exist "%buildDirectory%\%OSR_PREBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_PREBUILD_SCRIPT%" > "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
)
:: Save the current directory (before changing into the build directory!)
:: AFTERPREBUILD
pushd .

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Determine the settings of flags, WDF and PREFAST in
:: other words what was set for %3 and beyond....
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_ECHO% %OSR_BUILDNAME%
set OSR_ARGS= + argument(s):
if not "%3" == "" set OSR_ARGS=%OSR_ARGS% %3
if not "%4" == "" set OSR_ARGS=%OSR_ARGS% %4
if not "%5" == "" set OSR_ARGS=%OSR_ARGS% %5
if /i "%OSR_ARGS%" == " + argument(s):" set OSR_ARGS=
%OSR_ECHO% Directory: %buildDirectory%%OSR_ARGS%
%OSR_ECHO% %BASEDIRVAR%: %BASEDIR%

cd /D %~s2
set bFlags=-Ze
set bscFlags=

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ContinueParsing
if "%3" == "" goto :DONE
if "%3" == "/a" goto :RebuildallFound
if /i "%3" == "-WDF" goto :WDFFound
if /i "%3" == "-PREFAST" goto :PrefastFound
set bscFlags=/n
set bFlags=%bFlags% %3
:: Remove next arg
shift
goto :ContinueParsing

:WDFFound
shift
:: Note, that the setwdf.bat is called from setenv.bat in the WDK,
:: therefore we skip it.
if /i "%BASEDIRVAR%" == "WLHBASE" goto :WDFOkay
if "%WDF_ROOT%" == "" call :ShowErrorMsg 2 "%ERR_NoWdfRoot%" & goto :USAGE
pushd .
if exist "%WDF_ROOT%\set_wdf_env.cmd" call "%WDF_ROOT%\set_wdf_env.cmd"
popd
:WDFOkay
goto :ContinueParsing

:PrefastFound
shift
set prefast_build=1
goto :ContinueParsing

:RebuildallFound
shift
set bscFlags=/n
set bFlags=%bFlags:-Ze=-cfeZ%
set bFlags=%bFlags: -cZ=%
goto :ContinueParsing
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:DONE
for %%x in (build%OSR_EXT%.err build%OSR_EXT%.wrn build%OSR_EXT%.log prefast%OSR_EXT%.log) do @(
  if exist "%%x"   del /f /q "%%x"
)

if not "%prefast_build%" == "0" goto :RunPrefastBuild
%OSR_ECHO% Run build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
pushd .
build %mpFlag% %bFlags%
popd
goto :BuildComplete

:RunPrefastBuild
%OSR_ECHO% Run prefast build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
setlocal ENABLEEXTENSIONS & pushd .
set PREFASTLOG=PREfast_defects_%OSR_EXT%.xml
prefast /log=%PREFASTLOG% /reset build %mpFlag% %bFlags% > NUL 2>&1
if "%errorlevel%" GTR "0" set OSR_ERRCODE=%errorlevel%
prefast /log=%PREFASTLOG% list > prefast%OSR_EXT%.log
%OSR_ECHO% The PREfast logfile is ^"%prefastlog%^"!
popd & endlocal

:BuildComplete
if not "%errorlevel%" == "0" set OSR_ERRCODE=%errorlevel%

@echo %OSR_DEBUG%
:: Assume that the onscreen errors are complete!
setlocal
set WARNING_FILE_COUNT=0
if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+1
)
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% ================ Build warnings =======================
  if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set WARNING_FILE_COUNT_PRE=0
if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT_PRE=%WARNING_FILE_COUNT_PRE%+1
)
:: Reset if this is no PREfast build
if "%prefast_build%" == "0" set WARNING_FILE_COUNT_PRE=0
if not "%WARNING_FILE_COUNT_PRE%" == "0" (
  %OSR_ECHO% =============== PREfast warnings ======================
  if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+%WARNING_FILE_COUNT_PRE%
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% =======================================================
)
endlocal
@echo.
%OSR_ECHO% Build complete
%OSR_ECHO% Building browse information files
if exist "buildbrowse.cmd" call "buildbrowse.cmd" & goto :postBuildSteps
set sbrlist=sbrList.txt
if not exist sbrList%CPU%.txt goto :sbrDefault
set sbrlist=sbrList%CPU%.txt

:sbrDefault
if not exist %sbrlist% goto :postBuildSteps
:: Prepend blank space
if not "%bscFlags%" == "" set bscFlags= %bscFlags%
:: bscmake%bscFlags% prevents a double blank space ...
bscmake%bscFlags% @%sbrlist%

:: Perform whatever post-build steps
:postBuildSteps
:: Restore the current directory (after changing into the build directory!)
:: Search upwards for "AFTERPREBUILD" to find the corresponding PUSHD
popd
@if exist "%buildDirectory%\%OSR_POSTBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_POSTBUILD_SCRIPT%" > "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
)
goto :END
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / GetCustomEnvironment
::    First parameter is the "directory" that supposedly contains the SOURCES
::    or DIRS file (and the build scripts)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:GetCustomEnvironment
pushd .
call :CheckTargets "%~f1"
@if not "%OSR_ERRCODE%" == "0" @(
  echo.
  %OSR_ECHO% The target directory seemed to not contain a DIRS or SOURCES file
  %OSR_ECHO% when trying to set a custom environment! Quitting.
  set buildDirectory=%~f1
  if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :GetCustomEnvironment_ret
  call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :GetCustomEnvironment_ret
  goto :GetCustomEnvironment_ret
)
:: If the user provided a script to customize the environment, execute it.
@if exist "%~f1\%OSR_SETENV_SCRIPT%" @(
  %OSR_ECHO% ^>^> Setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
  pushd "%~f1"
  call "%OSR_SETENV_SCRIPT%" > "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_SETENV_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
)
:GetCustomEnvironment_ret
popd
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ GetCustomEnvironment
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / SetMode
::    Subroutine to validate the mode of the build passed in. It must be free,
::    FREE, fre, FRE or checked, CHECKED, chk, CHK. Anything else is an error.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetMode
set BuildMode=
if /i "%OSR_TARGET%" == "WLH2K" goto :SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=free
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=checked
goto :SetModeCommonEnd
:SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=f
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=c
:SetModeCommonEnd
%OSR_TRACE% Mode set to ^"%BuildMode%^"
if "%BuildMode%" == "" set OSR_ERRCODE=5
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ SetMode
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / CheckTargets subroutine
::   Subroutine to validate that the target directory exists and that there is
::   either a DIRS or SOURCES and MakeFile in it.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CheckTargets
:: Building "stack frame"
setlocal & pushd . & set OSR_ERRCODE=0
set lTarget=%~1
if not "%lTarget%" == "" goto :CheckTargets1
set OSR_ERRCODE=7
goto :CheckTargets_ret
:CheckTargets1
if exist "%lTarget%" goto :CheckTargets2
set OSR_ERRCODE=8
goto :CheckTargets_ret
:CheckTargets2
if not exist "%lTarget%\DIRS" goto :CheckTargets3
set OSR_ERRCODE=0
goto :CheckTargets_ret
:CheckTargets3
if exist "%lTarget%\SOURCES" goto :CheckTargets4
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets4
if exist "%lTarget%\MAKEFILE" goto :CheckTargets5
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets5
set OSR_ERRCODE=0
:CheckTargets_ret
:: Cleaning "stack frame" and returning error code into global scope
popd & endlocal & set OSR_ERRCODE=%OSR_ERRCODE%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ CheckTargets subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ResolveVar subroutine
::   There is only one parameter, the name of the variable to be resolved!
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ResolveVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
set VAR_TEMPRET2=%%%VAR_NAME%%%
:ResolveVarLoop
set VAR_TEMPRET1=%VAR_TEMPRET2%
set VAR_TEMPRET2=%VAR_TEMPRET1%
for /f "tokens=*" %%i in ('echo %VAR_TEMPRET1%') do (
  set VAR_TEMPRET2=%%i
)
if not "%VAR_TEMPRET1%" == "%VAR_TEMPRET2%" goto :ResolveVarLoop
:: Re-export the variable out of the local scope
endlocal & set %VAR_NAME%=%VAR_TEMPRET1%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ResolveVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MakeShort subroutine
::   Two parameters. First parameter is the variable name, second is the path
::   to convert into a short filename.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MakeShort
setlocal ENABLEEXTENSIONS
:: Get the name of the variable we are working with and the path to convert
set VAR_NAME=%~1
set PATH_SHORT=%~dpns2
set PATH_EXTSHORT=%~xs2
if not "" == "%PATH_EXTSHORT%" set PATH_EXTSHORT=%PATH_EXTSHORT:~0,4%
set PATH_SHORT=%PATH_SHORT%%PATH_EXTSHORT%
endlocal & set %VAR_NAME%=%PATH_SHORT%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MakeShort subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ErrorWithUsage subroutine
::   This one will take the passed in parameters and build a nice error
::   message which is returned to the user along with the usage hints.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ShowErrorMsg
@set OSR_ERRCODE=%~1
@set OSR_ERRMSG=%~2
@set OSR_ERRMSG=%OSR_ERRMSG:'="%
@set OSR_ERRMSG=ERROR #%OSR_ERRCODE%: %OSR_ERRMSG%
@echo.
%OSR_ECHO% %OSR_ERRMSG%
if DEFINED buildDirectory %OSR_ECHO% -^> Target directory: %buildDirectory%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ErrorWithUsage subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / SetVar subroutine
::   Param1 == name of the variable, Param2 == value to be set for the variable
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
endlocal & set %VAR_NAME%=%~2
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ SetVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectVistaWDK subroutine
::   No parameters expected
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectVistaWDK
setlocal ENABLEEXTENSIONS
:: Newer flag (starting with W2K8) is default
set OSR_AMD64FLAG=x64
:: The Vista WDK accepted *only* "AMD64", the newer W2K8 WDK accepts only "x64"
:: We detect the older one by checking the setenv.bat for a certain string
findstr /C:"Windows Server Longhorn" "%BASEDIR%\bin\setenv.bat" > NUL 2>&1 && set OSR_AMD64FLAG=AMD64
endlocal & set OSR_AMD64FLAG=%OSR_AMD64FLAG%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectVistaWDK subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectBaseDirTemp subroutine
::   The first parameter is the list of directory names to check, separated by
::   blank spaces.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectBaseDirTemp
:: Get the name of the variable we are working with
if "%~1" == "" goto :EOF
setlocal ENABLEEXTENSIONS
call :CommonCheckMsg1
:: Try to find an installed DDK/WDK from the registry keys
if DEFINED OSR_REGAVAILABLE if not "%OSR_REGAVAILABLE%" == "0" (
  for %%i in (%~1) do @(
    call :RegTryBaseDirTemp "%%i"
  )
)
:: Try all the "default" locations
if not DEFINED BASEDIRTEMP (
  for %%i in (%~1) do @(
    for %%a in (WINDDK DDK) do @(
      call :BruteTryBaseDirTemp "%SystemDrive%\%%a\%%i"
      call :BruteTryBaseDirTemp "%ProgramFiles%\%%a\%%i"
    )
  )
)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTemp subroutine
::   Attempt to find the install key in the registry.
::   This functions tests old-style DDKs and new-style WDKs.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
call :RegTryBaseDirTempSingle "%~1" "LFNDirectory" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
call :RegTryBaseDirTempSingle "%~1\Setup" "BUILD" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
if not DEFINED BASEDIRTEMP (endlocal & goto :EOF)
:RegTryBaseDirTemp_EOF
%OSR_ECHO% Found directory (%BASEDIRTEMP%) from install key
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTempSingle subroutine
::   Attempt to find the install key in the registry.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTempSingle
setlocal ENABLEEXTENSIONS
set REGSUBKEY=%~1
set REGVALUE=%~2
set VARIABLETOSET=%~3
set REGMAINKEY=HKLM\SOFTWARE\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_WOW64
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_WOW64
set REGMAINKEY=HKLM\SOFTWARE\Wow6432Node\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_EOF
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_EOF
endlocal
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTempSingle subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / BruteTryBaseDirTemp subroutine
::   Brute-force test the given directory.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:BruteTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
:: We will not overwrite BASETEMPDIR if it has been set and is valid
:: Just try
set BASEDIRTEMP=%~1
%OSR_ECHO% Trying %BASEDIRTEMP% ...
if not exist "%BASEDIRTEMP%" (endlocal & goto :EOF)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ BruteTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Usage output
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:USAGE
@echo.
@echo USAGE:
@echo ======
@echo   %~n0 ^<target^> ^<build type^> ^<directory^> [flags] [-WDF] [-PREFAST]
@echo.
@echo Values for ^<target^>:
@echo    --------------------------------------------------------------------------
@echo     Target platform and OS   ^| Miscellaneous
@echo    --------------------------^|-----------------------------------------------
@echo     Target     ^| Windows     ^| CPU     ^| Base directory ^| Target alias(es)
@echo    ------------^|-------------^|---------^|----------------^|--------------------
@echo     -W2K       ^| 2000        ^| x86     ^| %%W2KBASE%%      ^|
@echo     -W2K64     ^| 2000        ^| Itanium ^| %%W2KBASE%%      ^| -W2KI64
@echo     -WXP       ^| XP          ^| x86     ^| %%WXPBASE%%      ^| -XP
@echo     -WXP64     ^| XP          ^| Itanium ^| %%WXPBASE%%      ^| -WXPI64, -XP64
@echo     -WXP2K     ^| 2000        ^| x86     ^| %%WXPBASE%%      ^| -XPW2K
@echo     -WNET      ^| 2003        ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNET64    ^| 2003        ^| Itanium ^| %%WNETBASE%%     ^| -WNETI64
@echo     -WNETXP    ^| XP          ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNETXP64  ^| XP          ^| Itanium ^| %%WNETBASE%%     ^|
@echo     -WNETAMD64 ^| 2003/XP x64 ^| x64     ^| %%WNETBASE%%     ^| -WNETX64, -WNETA64
@echo     -WNET2K    ^| 2000 SP3    ^| x86     ^| %%WNETBASE%%     ^| -WNETW2K
@echo     -WLH       ^| Vista/2008  ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLH2K     ^| 2000 SP4    ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP     ^| XP          ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP64   ^| XP          ^| Itanium ^| %%WLHBASE%%      ^|
@echo     -WLHNET    ^| 2003        ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHNETI64 ^| 2003        ^| Itanium ^| %%WLHBASE%%      ^| -WLHNET64
@echo     -WLHNETX64 ^| 2003/XP x64 ^| x64     ^| %%WLHBASE%%      ^| -WLHNETA64
@echo     -WLHI64    ^| Vista/2008  ^| Itanium ^| %%WLHBASE%%      ^| -WLH64
@echo     -WLHX64    ^| Vista/2008  ^| x64     ^| %%WLHBASE%%      ^| -WLHA64
@echo     -NT4       ^| NT 4.0      ^| x86     ^| %%NT4BASE%%      ^|
@echo    --------------------------------------------------------------------------
@echo     Support for NT4 and W2K DDKs is deprecated and not checked anymore
@echo     in new versions. It may or may not work properly.
@echo    --------------------------------------------------------------------------
@echo.
@echo Values for ^<build type^>:
@echo       checked, chk     indicates a checked build
@echo       free, fre        indicates a free build
@echo.
@echo Remaining parameters ("opt!" = optional parameter):
@echo       ^<directory^>      path to build directory, try . (current directory)
@echo       [flags]    opt!  any flags you think should be passed to build (try /a
@echo                        for clean)
@echo       -WDF       opt!  performs a WDF build
@echo       -PREFAST   opt!  performs a PREFAST build
@echo.
@echo Special files:
@echo       The build target directory (where the DIRS or SOURCES file resides) can
@echo       contain the following files:
@echo       - %OSR_PREBUILD_SCRIPT%
@echo         Allows to include a step before the BUILD tool from the DDK is called
@echo         but after the environment for the respective DDK has been set!
@echo       - %OSR_POSTBUILD_SCRIPT%
@echo         Allows to include a step after the BUILD tool from the DDK is called,
@echo         so the environment is still available to the script.
@echo       - %OSR_SETENV_SCRIPT%
@echo         Allows to set (or override) _any_ environment variables that may exist
@echo         in the global environment. Thus you can set the base directory for the
@echo         DDK from inside this script, making your project more self-contained.
@echo.
@echo       DDKBUILD will only handle those files which exist, so you may choose to
@echo       use none, one or multiple of these script files.
@echo       (All scripts execute inside their current directory. Consider this!)
@echo.
@echo Examples:
@echo       ^"%~n0 -NT4 checked .^" (for NT4 BUILD)
@echo       ^"%~n0 -WXP64 chk .^"
@echo       ^"%~n0 -WXP chk c:\projects\myproject^"
@echo       ^"%~n0 -WNET64 chk .^"      (IA64 build)
@echo       ^"%~n0 -WNETAMD64 chk .^"   (AMD64/EM64T build)
@echo       ^"%~n0 -WNETXP chk . -cZ -WDF^"
@echo       ^"%~n0 -WNETXP chk . -cZ -PREFAST^"
@echo.
@echo       In order for this procedure to work correctly for each platform, it
@echo       requires an environment variable to be set up for certain platforms.
@echo       There is an auto-detection mechanism in this script, which will work best
@echo       if the DDK/WDK was installed using the normal installer (i.e. not just
@echo       copied). The auto-detection is based on the DDK/WDK for which you request
@echo       a build. Whenever you set the variable explicitly, this will take
@echo       precedence over the auto-detected path!
@echo       The environment variables are as follows:
@echo.
@echo       %%NT4BASE%%  - Set this up for ^"-NT4^" builds
@echo       %%W2KBASE%%  - Set this up for ^"-W2K^" and ^"-W2K64^" builds
@echo       %%WXPBASE%%  - Set this up for ^"-WXP^", ^"-WXP64^", ^"-WXP2K^" builds
@echo       %%WNETBASE%% - Set this up for ^"-WNET*^" builds
@echo       %%WLHBASE%%  - Set this up for ^"-WLH*^" builds
@echo.
@echo       %%WDF_ROOT%% must be set if attempting to do a WDF Build previous to the
@echo       Vista WDK (in later DDKs there is no need to set WDF_ROOT).
@echo.
@echo Path to this script:
@echo      %~f0
@echo.
@echo   %OSR_VERSTR%
@echo   -^> report any problems to ^<info@osr.com^> or ^<http://assarbad.net/contact/^>
@echo.

:END
popd & endlocal & exit /b %OSR_ERRCODE%
```

`Inject_By_kernelAPC/ring0/makefile`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

`Inject_By_kernelAPC/ring0/mybuild.bat`:

```bat
set WLHBASE=C:\WINDDK\7600.16385.0
set WDF_ROOT=C:\WINDDK\7600.16385.0
ddkbuild.cmd -WLH chk . -cZ -WDF
```

`Inject_By_kernelAPC/ring0/readme.txt`:

```txt
-----------------------
ithurricane [http://hi.baidu.com/ithurricane]
2010/02/04
-----------------------
support WDK7/VS2008
fix Privilege Problem
modify register source

-----------------------
bobo 2009/05/21
-----------------------
ÐÞ¸´bug: VC6 + DDK2003 -> vc6.dsp --> # PROP Cmd_Line "ddkbuild -WNETWXP free ."
         ÐÞ¸Ä: ÔÚddkbuild.cmdÖÐ,¹ØÓÚDDk2003Ã»ÓÐWNETWXP²ÎÊý£¬ÏÖÔÚÔö¼ÓWNETWXP²ÎÊý£¬Ð§¹ûµÈÍ¬ÓÚWNETXP

-----------------------
bobo 2009/05/08
-----------------------
exe:
  1.TestAppÓÉUnicode¸ÄÎªMulti-Byte(ÎªÁËÊ¡ÊÂ,×Ö·ûÆ´½Ó,×¢²á±úÒÁÐ´¶¼ÊÇMulti-Byte°æµÄ), 
      ¼´TestApp.vcprojµÄCharacterSet="1" ¸ÄÎªCharacterSet="2"
  2.TestApp¼ÓÔØºÍÐ¶ÔØsys(modify from MyZwDriverControl.c)£¬ Ã²ËÆ½â¾öÕâ¸öÎÊÌE
	  a.Æô¶¯app,load driver
	  b.°ÑappÇ¿ÖÆ¹ØµE´ËÊ±Ã»ÓÐÕý³£unload driver
	  c.ÔÙÆô¶¯app,´ËÊ±²»»áÔÙ´Îload driver(»òÕßËµÃ»ÓÐloadÊ§°Ü),Ò»ÇÐÕý³£Ê¹ÓÃdriver
	  d.Õý³£ÍË³öapp,unload driver

	  ps: MyZwDriverControl ÓEclass LoadNTDriver(copy from 0ginr.com)ÓÐÇø±ð´¦, 
	      MyZwDriverControlÔÚloadºÍunloadÄÚ,¶¼»á×ö×¢²á±úèúØÓ,É¾³ý¹¤×E
		  class LoadNTDriverµÄloadÄÚÌúØÓ×¢²á±EunloadÄÚÉ¾³ý×¢²á±E
		  MyZwDriverControl¿ÉÒÔLockXxxDatabase.
  3.¼ÓÔØºÍÐ¶ÔØsys¿ÉÒÔÓÃclass LoadNTDriver, ·½·¨¼ELoadNTDriver.h"

sys:
  DriverEntryÀEòÓ¡×¢²á±úÞ·¾¶
  default uIoControlCode Êä³EIoCode
  ËùÓÐº¯ÊýÔö¼Ó·ÖÒ³¡¢·Ç·ÖÒ³ÉùÃE#pragma alloc_text(PAGE, DispatchXX))

-----------------------
bobo 2009/04/27
-----------------------
1.¸÷¸ötarget os»¥³EÖ»ÄÜÑ¡Ò»¸öos
2.¸ù¾ÝDDK°æ±¾£¬ÏÞÖÆOSÑ¡ÔE
3.fix bug : "mybuild.bat" ÄÚµÄ PROJECT_MYBUILD_CMD_LINE ²ÎÊý¸ù¾Ý(DDK + OS)Ð´ËÀ£¬
            DDKÂ·¾¶¶¼ÊÇÄ¬ÈÏµÄ£¬ÔÙ¸ã¸ö¶ÁÐ´Âé·³¸ö¡£

			DDK 2000       --- C:\\NTDDK
			DDK XP         --- C:\\WINDDK\\2600
			DDK 2003       --- C:\\WINDDK\\3790.1830
			WDK 6001.18002 --- C:\\WINDDK\\6001.18002

4.Ö§³ÖWDK + win2008
// todo : 5.Ôö¼Ócheck£¬ freeÑ¡ÔE(mybuild.bat½Å±¾ÀEàÒEÎÊý "chk ." ÓE"fre .")

6.µÚÒ»´ÎÆô¶¯EasySysÊ±£¬»á×Ô¶¯Éè¶¨ÓÃ»§»·¾³±äÁ¿(WXPBASE,WNETBASE...)£¬
  ÕâÊÇ¸ù¾Ý×¢²á±EHKEY_LOCAL_MACHINE -- SOFTWARE\\Microsoft\\WINDDK Éè¶¨DDKÂ·¾¶µÄ¡£
  (ÍòÒ»ÓÃ»§°²×°ÁË¶à¸öDDK£¬ÔÙ¼Ó¸öWDK£¬Õâ¸öÂ·¾¶¾ÍÒªÁúéâÅÐ¶ÏÁË)

  µ«"mybuild.bat"Ò²»áset»·¾³±äÁ¿£¬ËùÒÔÕâÀEäÊµÃ»ÓÃÁË¡£

7.½Å±¾ÃEûÎÎÊý¾ßÌå¿´ "ddkbuild.cmd":: Usage output

-----------------------
bobo 2009/04/23
-----------------------
1.²ÎÕÕMS sample¸ñÊ½ÐÞ¸Ä"sources"

-----------------------.
bobo 2009/04/18
-----------------------
1. Ôö¼Ócommon.h, ÓÃÓÚ¶¨Òåexe¡¢sysµÄ¹²Í¨IOCTL
2. Ôö¼Óconsole APP (for VS2005)¹¤³Ì, ÓÃÓÚ²âÊÔsys. ´ÓÄÄ¸öhello world°áÀ´µÄ.
   (ÕâÑùÖ»ÒªÅäºÏDriverMonitor¾Í¿ÉÒÔ²âÊÔÇý¶¯ÁË)
// todo : 3. ÔÚdsp_proj.htm(VC6)ÀEö¼Óclean±àÒEÎÊý,ÈÃVC6Ê¹ÓÃclean.bat
// todo : 4. Ôö¼ÓMFC APP¹¤³Ì,ÓÃÓÚ²âÊÔsys
5. ÌúØÓÐÞ¸Ä×¢ÊÍ
6.ÐÞ¸Äprintºê£¬¶ÔÓ¦checkºÍfree°æ±¾µÄbuild
  #if DBG
  #define dprintf DbgPrint
  #else
  #define dprintf
  #endif

Ô½Ð´Ô½¸´ÔÓÁË£¬²»easyÁË.....

-----------------------
bobo 2009/04/16
-----------------------
1.OnInitDialog()ÀEö¼ÓOnChangeAuthor()
2.ÐÞ¸ÄOnChangeAuthor()×Ö·û´®
3.ÐÞ¸Ähfile.htm,cfile.htmÀ´ÊÊÓ¦×Ô¼ºÏ°¹ß
-----------------------

bobo 2009/04/10
-----------------------
1.GenerateRandomStrings()µÄnew Ã»ÓÐÊÍ·Å£¬
  ¸ÄÎª¾Ö²¿Êý×EÃû×Ö²»Ì«³¤¾ÍÐÐ,64´óÐ¡)
2.OnInitDialog()ÀEö¼ÓOnSelectIdeType(),³õÊ¼»¯IdeType
				  Ôö¼ÓOnSelchangeDdkVersion(),³õÊ¼»¯DDK type
3.ddkbuild.cmd ¸EÂÎª VERSION=V7.3
4.VC6µÄddkbuild.bat¸ÄÎªddkbuild.cmd
5.ÐÞ¸ÄOnSelchangeDdkVersion()ÄÚµÄDDK2000µÄÂß¼­ÅÐ¶Ï
6.ÔÚVC6µÄdsp.htmÖÐÔö¼Óstruct.h

-----------------------
ChiChou [http://hi.baidu.com/517826104]
2009/02/03
-----------------------

ChiChou ¸ù¾Ý sudamiÐÞ¸Ä°EÖÆ×E

* ÐÞÕýBUG
	1.·Ç³£ÑÏÖØµÄBUG¡­¡­³ÌÐòÍË³öÊ±Ã»ÓÐÒÆ³ýÍÐÅÌÍ¼±ê£¬ÔÚÄ³Ð©»úÆ÷ÉÏÍË³öÊ±
»á±ÀÀ££¨ÖÁÉÙÎÒµÄµçÄÔÊÇÕâÑE- -!£©¡£

	2.Ô­°æ»ñµÃDDKÂ·¾¶Ê±£¬¶ÁÈ¡µÄ×¢²á±úÞ·¾¶Ð´´úÝË£¬µ¼ÖÂÎÞ·¨»ñµÃ DDK µÄ 
Path£¨Ã²ËÆ´óÃ×Ö±½ÓÌûåÏ×Ô¼ÒµÄDDKÂ·¾¶ÁËÖ®¡£¡£Î´ÃâÓÐµã¡£¡£¡££©¡£

	3.Ô­°æÃ»ÓÐ¼Eé¹¤³ÌÃû£¬Èç¹ûÀEæ°E¬·Ç·¨×Ö·û£¬ÄÇÃ´´´½¨¹¤³ÌÄ¿Â¼µÄÊ±ºE
¾Í»á³ö´ú½£ÐÞÕýÊ±Ôö¼Ó¶Ô·Ç·¨×Ö·ûµÄcheck¹¦ÄÜ¡£°E¨£º/\|"<>*?:

	4.»¹ÓÐÒ»¸öBUGÃ»ÓÐÐÞ¸´¡£Èç¹ûÔÚ¹¤³ÌÃûÖÐÌûäEÎÈç¡°project..¡±µÄÃû³ÆÊ±£¬
Ò²»áÒý·¢ÎÄ¼þ·ÃÎÊ´úêó¡£µ«ÊÇÎÒÃ»ÓÐ°E¨ÐÞ¸´¡­¡­Õâ¸ö×Ö·û´®µÄÅÐ¶ÏÓÐµãÄÑ¶È¡£¡£
Ë®Æ½µÍÁÓ¡£¡£(- -...)

* ÃÀ»¯½çÃE
	1.°Ñ´óÃ×ÅªµÄ XPBUTTON ¸øÈ¥µôÁË...Í¼±àÒEÙ¶È¡£
	2.È»ºóPÁËÕÅ±³¾°Í¼£¬·ÅÔÚÖ÷½çÃæ£¬»¹ÂùºÃ¿´µÄ~~
	3.Ï°¹ßÐÔµÄ XP Manifest ´¦ÀúëÂ¡£

* ÐÞ¸ÄÄ£°E
	1.¸ù¾Ý¸öÈËÏ²ºÃ´úÂEÄ¸ñÊ½ÐÞ¸ÄÁËÏÂ~
	2.Ë³±ã°Ñ¡¶ÌEéÒ¹¶Á¡·ÀEæ¿´µ½µÄÄ³¸ö¶«Î÷£¨ÅÐ¶Ï·ûºÅÁ´½ÓÓÃ»§Ïà¹ØÐÔÈ»ºE
´´½¨²»Í¬µÄÉè±¸·ûºÅÃû£©¼ÓÁË½øÈ¥¡­¡­

* ÍEÆ¹¦ÄÜ
	1.sudami°æµÄÓÐµãÂé·³£¬ÍË³ö³ÌÐò»¹ÒªµãÍÐÅÌ¡£Ö±½ÓÔÚÖ÷½çÃæÉèÖÃÁËÍË³ö°´
Å¥¡£
	2.¹¤³Ì´´½¨Ö®ºóEasySYS»ù±¾Ã»ÓÃ´¦ÁË£¬±ãÔö¼ÓÁË¡°ÍEÉºóÍË³ö¡±Ñ¡Ïû›
	3.Éú³É¹¤³Ìºó¿ÉÒÔÔ´ÂEÐÌúØÓÈÕÆÚ¡¢×÷ÕßµÈÐÅÏ¢¡£
	4.Éú³É¹¤³ÌºóµÄ²Ù×÷Ò²ÊÇ¿ÉÑ¡µÄ¡£¿ÉÒÔÑ¡Ôñ×Ô¶¯´ò¿ª¹¤³ÌÎÄ¼þ¡¢¹¤³ÌÄ¿Â¼¡£
	5.Ôö¼ÓClean¹¦ÄÜ~~~
-----------------------


-----------------------
sudami [sudami@163.com]
2008/08/13
-----------------------

	VS 2005ÏÂÐ´Çý¶¯±ÈVC 6.0·½±ãºÜ¶Eµ«ºÃ¶àEasySYS°æ±¾(Include DIY)¶¼Ö»
Ö§³ÖVC 6.0.½ñ¶ùÔçÉÏÔÚVBGOODÂÛÌ³¿´µ½IceBoyÐ¡Í¬Ñ§ÓÃVBÐ´ÁË¸öÖ§³Övs 2005µÄ
demo.ÓÚÊÇ,°³Ò²ÊÔ×ÅÐ´¸öÊÊÓÃÓÚ×Ô¼ºµÄ¹¤¾ß,·½±ãÒÔºó¿EÙµÄ¿ª·¢Çý¶¯³ÌÐE

	¹þ¹þ,Ö÷ÒªÊÇ·½±ã×Ô¼ºÐ´code,¹ÊÉú³ÉµÄcode·ç¸ñ¶¼ÊÇ°´ÕÕ×Ô¼ºµÄÒâÔ¸À´°²ÅÅ
µÎ...

-----------------------

```

`Inject_By_kernelAPC/ring0/sources`:

```
TARGETNAME=KeInjectApc
#TARGETPATH=$(BASEDIR)\lib
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=.\

SOURCES=KeInjectApc.c


```

`Inject_By_kernelAPC/ring3/KeInjectApc.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KeInjectApc", "KeInjectApc\KeInjectApc.vcxproj", "{20C8BB71-37A7-4DA1-96E5-BD96B4CBC698}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{20C8BB71-37A7-4DA1-96E5-BD96B4CBC698}.Debug|Win32.ActiveCfg = Debug|Win32
		{20C8BB71-37A7-4DA1-96E5-BD96B4CBC698}.Debug|Win32.Build.0 = Debug|Win32
		{20C8BB71-37A7-4DA1-96E5-BD96B4CBC698}.Release|Win32.ActiveCfg = Release|Win32
		{20C8BB71-37A7-4DA1-96E5-BD96B4CBC698}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Inject_By_kernelAPC/ring3/KeInjectApc/KeInjectApc.cpp`:

```cpp
// KeInjectApc.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <iostream>
#include <Windows.h>
#include <WinIoCtl.h>
using namespace std;




#define CTL_KEINJECTAPC \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_BUFFERED,FILE_ANY_ACCESS)



typedef struct _INJECT_INFO
{
	ULONG ProcessId;
	wchar_t DllName[1024];
}INJECT_INFO,*PINJECT_INFO;

int _tmain(int argc, _TCHAR* argv[])
{
	HANDLE hFile;
	INJECT_INFO InjectInfo;
	hFile=CreateFile(L"\\\\.\\DriverLink",
		GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,
		NULL,OPEN_EXISTING,0,NULL);

	if(hFile==INVALID_HANDLE_VALUE)
	{
		printf("\nError: Unable to connect to the driver (%d)\n",GetLastError());
		return -1;
	}

	memset(&InjectInfo,0,sizeof(INJECT_INFO));
	scanf("%d",&(InjectInfo.ProcessId));
	wscanf(L"%s",InjectInfo.DllName);


	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;
	//发送IO 控制码
	dwRet = DeviceIoControl(hFile,CTL_KEINJECTAPC,   //
		&InjectInfo,
		sizeof(INJECT_INFO),
		NULL,
		NULL,
		&dwReturnSize,
		NULL);

	CloseHandle(hFile);
	return 0;
}


```

`Inject_By_kernelAPC/ring3/KeInjectApc/KeInjectApc.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{20C8BB71-37A7-4DA1-96E5-BD96B4CBC698}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>KeInjectApc</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="KeInjectApc.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Inject_By_kernelAPC/ring3/KeInjectApc/KeInjectApc.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="KeInjectApc.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Inject_By_kernelAPC/ring3/KeInjectApc/KeInjectApc.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Inject_By_kernelAPC/ring3/KeInjectApc/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// KeInjectApc.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中
// 引用任何所需的附加头文件，而不是在此文件中引用

```

`Inject_By_kernelAPC/ring3/KeInjectApc/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: 在此处引用程序需要的其他头文件

```

`Inject_By_kernelAPC/ring3/KeInjectApc/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`InlineHook_ShadowSSDT/ReadMe.md`:

```md
##ShadowSSDT inline hook
因为ShadowSSDT需要GUI进程，带一个应用层MFC程序。
```

`InlineHook_ShadowSSDT/ring0/InlineHookSSSDT.c`:

```c


#ifndef CXX_INLINEHOOKSSSDT_H
#	include "InlineHookSSSDT.h"
#endif
KIRQL Irql;
ULONG_PTR  SSSDTDescriptor = 0;


ULONG   IndexOfNtUserPostMessageWin7  = 15;
ULONG   IndexOfNtUserPostMessageWinXP = 475;
ULONG	IndexOfNtUserQueryWindowWin7  = 16;
ULONG   IndexOfNtUserQueryWindowWinXP = 483;


ULONG   CurrentProcessID = 0;


pfnNtUserQueryWindow     CurrentNtUserQueryWindowAddress = NULL;
pfnNtUserPostMessage     CurrentNtUserPostMessageAddress = NULL;


PVOID  OrigianlFunctionCode = NULL;

typedef int (*LDE_DISASM64)(void *Base, int Temp);
LDE_DISASM64 LDEx64 = NULL;


//获得PatchSize的ShellCode
unsigned char szShellCode64[12800] = 
{ 
	0x55, 0x48, 0x83, 0xEC, 0x2B, 0x48, 0x89, 0xE5, 0x51, 0x52, 0x56, 0xE8, 0x00, 0x21, 0x00, 0x00,
	0xEF, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBF, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x65, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x25, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEF, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x98, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x58, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x65, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x97, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x87, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x77, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x67, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x60, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x16, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA8, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB5, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA0, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x90, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x85, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x75, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x65, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x55, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x45, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x35, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x25, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x15, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCF, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBF, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x60, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF1, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x55, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x45, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC5, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x90, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x85, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x75, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x65, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x55, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x60, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5E, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2E, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDA, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA0, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x68, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF2, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB5, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8A, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3A, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xED, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEE, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA0, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x90, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x60, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x91, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAB, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD0, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC0, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x90, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDC, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x38, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA0, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB9, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAB, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2E, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB5, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x90, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x67, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDB, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9F, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8B, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6B, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0B, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCB, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBB, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAB, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0B, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xED, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAC, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5E, 0x51, 0x8F, 0x45, 0x23, 0x89, 0x55, 0x1E, 0xC6, 0x45, 0x22, 0x00, 0xC7, 0x45, 0x02, 0x20,
	0x00, 0x00, 0x00, 0xC7, 0x45, 0x06, 0x20, 0x00, 0x00, 0x00, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x07,
	0xC7, 0x45, 0x06, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48,
	0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0x5E, 0x5A, 0x59, 0x48, 0x83, 0xF8, 0xFF, 0x74,
	0x07, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x29, 0xC8, 0x48, 0x83, 0xC4, 0x2B, 0x5D, 0xC3, 0xC7, 0x45,
	0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x25, 0xC7, 0x00,
	0x00, 0x00, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x48, 0x31, 0xD2, 0xF7, 0xF1, 0x89, 0x45, 0x0A, 0x83,
	0xF8, 0x01, 0x75, 0x04, 0x83, 0x45, 0x1A, 0x01, 0x83, 0xF8, 0x02, 0x75, 0x04, 0x83, 0x45, 0x1A,
	0x04, 0x89, 0x55, 0x0E, 0xC1, 0xE0, 0x06, 0x48, 0x01, 0xF0, 0x48, 0x05, 0x00, 0x20, 0x00, 0x00,
	0x48, 0x8D, 0x04, 0xD0, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6,
	0x40, 0x01, 0x83, 0xE0, 0x38, 0xC1, 0xE8, 0x03, 0x89, 0x45, 0x16, 0xC3, 0xC3, 0x83, 0x7D, 0x06,
	0x20, 0x7C, 0x23, 0x83, 0x45, 0x1A, 0x01, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x02, 0x83,
	0xE0, 0x07, 0x89, 0x45, 0x12, 0x83, 0x7D, 0x12, 0x05, 0x75, 0x0A, 0x83, 0x7D, 0x0A, 0x00, 0x75,
	0x04, 0x83, 0x45, 0x1A, 0x04, 0xC3, 0xC3, 0x83, 0x7D, 0x06, 0x20, 0x7C, 0x05, 0x83, 0x45, 0x1A,
	0x04, 0xC3, 0xC3, 0x83, 0x7D, 0x06, 0x10, 0x75, 0x05, 0x83, 0x45, 0x1A, 0x02, 0xC3, 0xC3, 0xE8,
	0x5A, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3,
	0x48, 0xFF, 0x45, 0x23, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x83, 0x7D, 0x02, 0x10, 0x75,
	0x06, 0xE8, 0xD9, 0xFF, 0xFF, 0xFF, 0xC3, 0xE8, 0x51, 0x02, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x1E,
	0x40, 0x75, 0x06, 0xE8, 0x45, 0x02, 0x00, 0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xC3, 0x83, 0x7D,
	0x02, 0x20, 0x7C, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3,
	0x83, 0x7D, 0x02, 0x40, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x09, 0xC3, 0x83, 0x7D, 0x02, 0x20,
	0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0x8C,
	0xFF, 0xFF, 0xFF, 0x48, 0xFF, 0x45, 0x23, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x24, 0xC7, 0x45,
	0x02, 0x40, 0x00, 0x00, 0x00, 0x48, 0xFF, 0x45, 0x23, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6,
	0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC7, 0x45, 0x02, 0x20, 0x00, 0x00,
	0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x25, 0x48, 0xFF, 0x45,
	0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0xBE, 0x01, 0x00, 0x00, 0xC3,
	0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF,
	0xD0, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x01, 0xC3, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D,
	0x22, 0x0F, 0x75, 0x06, 0xE8, 0x94, 0x01, 0x00, 0x00, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F,
	0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3, 0x83, 0x7D, 0x02, 0x20,
	0x7C, 0x0B, 0xE8, 0xF8, 0xFE, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3, 0xE8, 0xED, 0xFE,
	0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0x5A,
	0x01, 0x00, 0x00, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3,
	0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0x3C, 0x01, 0x00,
	0x00, 0xC3, 0xE8, 0xB8, 0xFE, 0xFF, 0xFF, 0xC3, 0xE8, 0x11, 0xFE, 0xFF, 0xFF, 0x83, 0x7D, 0x0A,
	0x03, 0x75, 0x06, 0xE8, 0xA7, 0xFE, 0xFF, 0xFF, 0xC3, 0xE8, 0x1F, 0x01, 0x00, 0x00, 0xC3, 0x48,
	0x83, 0x45, 0x23, 0x03, 0xC3, 0x83, 0x7D, 0x06, 0x40, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x09,
	0xC3, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x83, 0x7D, 0x06, 0x10, 0x75, 0x06, 0x48, 0x83, 0x45,
	0x23, 0x03, 0xC3, 0x83, 0x7D, 0x06, 0x20, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x48,
	0x83, 0x45, 0x23, 0x09, 0xC3, 0x80, 0x7D, 0x00, 0x01, 0x75, 0x06, 0xE8, 0x5F, 0xFE, 0xFF, 0xFF,
	0xC3, 0xE8, 0xD7, 0x00, 0x00, 0x00, 0xC3, 0x80, 0x7D, 0x00, 0x01, 0x75, 0x06, 0xE8, 0x4D, 0xFE,
	0xFF, 0xFF, 0xC3, 0x80, 0x7D, 0x01, 0x01, 0x75, 0x06, 0xE8, 0x41, 0xFE, 0xFF, 0xFF, 0xC3, 0x83,
	0x7D, 0x02, 0x10, 0x75, 0x06, 0xE8, 0x35, 0xFE, 0xFF, 0xFF, 0xC3, 0xE8, 0xAD, 0x00, 0x00, 0x00,
	0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0xA1, 0x00, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x02,
	0x20, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x07, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0xC3,
	0x83, 0x7D, 0x02, 0x10, 0x74, 0x11, 0xE8, 0x63, 0xFD, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45,
	0x23, 0x48, 0x83, 0x45, 0x23, 0x06, 0xC3, 0xE8, 0x52, 0xFD, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01,
	0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0x5A,
	0x00, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x02, 0x20, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x07, 0xC3,
	0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0xE8, 0x6F, 0xFD, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75,
	0x06, 0xE8, 0xB9, 0xFD, 0xFF, 0xFF, 0xC3, 0xE8, 0x31, 0x00, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x1E,
	0x40, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x83, 0x7D, 0x02, 0x20, 0x75, 0x06, 0x48,
	0x83, 0x45, 0x23, 0x05, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0x80, 0x7D, 0x00, 0x01, 0x75,
	0x06, 0xE8, 0x89, 0xFD, 0xFF, 0xFF, 0xC3, 0xE8, 0x01, 0x00, 0x00, 0x00, 0xC3, 0x48, 0xB8, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0xEA,
	0xFF, 0xFF, 0xFF, 0xC3, 0xE8, 0x66, 0xFD, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x01, 0xC3, 0x83,
	0x7D, 0x02, 0x20, 0x7C, 0x0B, 0xE8, 0x55, 0xFD, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3,
	0xE8, 0x4A, 0xFD, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0x9E, 0xFC, 0xFF, 0xFF,
	0xE8, 0xE5, 0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x0C, 0x8B, 0x45, 0x1A, 0x01, 0x45,
	0x23, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x9B, 0xFF,
	0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x83,
	0x7D, 0x02, 0x20, 0x7C, 0x34, 0xE8, 0x64, 0xFC, 0xFF, 0xFF, 0xE8, 0xAB, 0xFC, 0xFF, 0xFF, 0x83,
	0x7D, 0x16, 0x00, 0x75, 0x0C, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x06,
	0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x61, 0xFF, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A,
	0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0x30, 0xFC, 0xFF, 0xFF, 0xE8, 0x77,
	0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x0C, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
	0x83, 0x45, 0x23, 0x04, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x2D, 0xFF, 0xFF, 0xFF,
	0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0xFC, 0xFB,
	0xFF, 0xFF, 0xE8, 0x43, 0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x01, 0x7E, 0x06, 0xE8, 0x0B, 0xFF,
	0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8,
	0x26, 0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x06, 0x7E, 0x06, 0xE8, 0xEE, 0xFE, 0xFF, 0xFF, 0xC3,
	0xE8, 0xC9, 0xFB, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02,
	0xC3, 0xE8, 0xB8, 0xFB, 0xFF, 0xFF, 0xE8, 0xFF, 0xFB, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x05, 0x7E,
	0x06, 0xE8, 0xC7, 0xFE, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45,
	0x23, 0x02, 0xC3, 0xE8, 0x96, 0xFB, 0xFF, 0xFF, 0xE8, 0xDD, 0xFB, 0xFF, 0xFF, 0x83, 0x7D, 0x16,
	0x00, 0x75, 0x1A, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0xAC, 0x00, 0x00, 0x00, 0x83, 0x7D, 0x0E,
	0x04, 0x0F, 0x8E, 0xA2, 0x00, 0x00, 0x00, 0xE8, 0x91, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
	0x01, 0x75, 0x1A, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0x8C, 0x00, 0x00, 0x00, 0x83, 0x7D, 0x0E,
	0x01, 0x0F, 0x8E, 0x82, 0x00, 0x00, 0x00, 0xE8, 0x71, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
	0x02, 0x75, 0x10, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0x6C, 0x00, 0x00, 0x00, 0xE8, 0x5B, 0xFE,
	0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x0C, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x5A, 0xE8,
	0x49, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x0C, 0x83, 0x7D, 0x0A, 0x03, 0x75,
	0x48, 0xE8, 0x37, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0x2B, 0xFE,
	0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x0C, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x2A, 0xE8,
	0x19, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x07, 0x75, 0x1E, 0x83, 0x7D, 0x0A, 0x03, 0x75,
	0x18, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x0C, 0x83, 0x7D, 0x0E, 0x00, 0x74, 0x0C, 0xE8, 0xFB, 0xFD,
	0xFF, 0xFF, 0xC3, 0xE8, 0xF5, 0xFD, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
	0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0xC4, 0xFA, 0xFF, 0xFF, 0xE8, 0x0B, 0xFB, 0xFF, 0xFF, 0x83,
	0x7D, 0x16, 0x04, 0x7D, 0x06, 0xE8, 0xD3, 0xFD, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45,
	0x23, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0xA2, 0xFA, 0xFF, 0xFF, 0xE8, 0xE9, 0xFA, 0xFF,
	0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06, 0xE8, 0xB1, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
	0x02, 0x75, 0x06, 0xE8, 0xA5, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x06, 0xE8,
	0x99, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x06, 0xE8, 0x8D, 0xFD, 0xFF, 0xFF,
	0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0x81, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
	0x07, 0x7E, 0x06, 0xE8, 0x75, 0xFD, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
	0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0x90, 0xFA, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06,
	0xE8, 0x58, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x4C, 0xFD, 0xFF,
	0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x02, 0x75, 0x11, 0xE8, 0x21, 0xFA, 0xFF, 0xFF, 0x83, 0x7D, 0x0A,
	0x03, 0x74, 0x52, 0xE8, 0x35, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x06, 0xE8,
	0x29, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x11, 0xE8, 0xFE, 0xF9, 0xFF, 0xFF,
	0x83, 0x7D, 0x0A, 0x03, 0x74, 0x2F, 0xE8, 0x12, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05,
	0x75, 0x06, 0xE8, 0x06, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0xDB,
	0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x0C, 0xE8, 0xEF, 0xFC, 0xFF, 0xFF, 0xC3, 0xE8,
	0xE9, 0xFC, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x03,
	0xC3, 0xE8, 0x04, 0xFA, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06, 0xE8, 0xCC, 0xFC, 0xFF,
	0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0xC0, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D,
	0x16, 0x02, 0x75, 0x11, 0xE8, 0x95, 0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x52, 0xE8,
	0xA9, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x06, 0xE8, 0x9D, 0xFC, 0xFF, 0xFF,
	0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x11, 0xE8, 0x72, 0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03,
	0x74, 0x2F, 0xE8, 0x86, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0x7A,
	0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0x4F, 0xF9, 0xFF, 0xFF, 0x83,
	0x7D, 0x0A, 0x03, 0x74, 0x0C, 0xE8, 0x63, 0xFC, 0xFF, 0xFF, 0xC3, 0xE8, 0x5D, 0xFC, 0xFF, 0xFF,
	0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0x78, 0xF9,
	0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06, 0xE8, 0x40, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D,
	0x16, 0x01, 0x75, 0x06, 0xE8, 0x34, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x02, 0x75, 0x15,
	0xE8, 0x09, 0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x84, 0x7B, 0x00, 0x00, 0x00, 0xE8,
	0x19, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x1D, 0x83, 0x7D, 0x02, 0x10, 0x75,
	0x11, 0xE8, 0xE8, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x5E, 0xE8, 0xFC, 0xFB, 0xFF,
	0xFF, 0xC3, 0xE8, 0xF6, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x06, 0xE8, 0xEA,
	0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0xDE, 0xFB, 0xFF, 0xFF, 0xC3,
	0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0xB3, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74,
	0x29, 0xE8, 0xC7, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x07, 0x75, 0x17, 0x83, 0x7D, 0x02,
	0x10, 0x75, 0x11, 0xE8, 0x96, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x0C, 0xE8, 0xAA,
	0xFB, 0xFF, 0xFF, 0xC3, 0xE8, 0xA4, 0xFB, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23,
	0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0xBF, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75,
	0x15, 0xE8, 0x68, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0xA0, 0x00, 0x00, 0x00,
	0xE8, 0x78, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x15, 0xE8, 0x4D, 0xF8, 0xFF,
	0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0x85, 0x00, 0x00, 0x00, 0xE8, 0x5D, 0xFB, 0xFF, 0xFF,
	0xC3, 0x83, 0x7D, 0x16, 0x02, 0x75, 0x15, 0xE8, 0x32, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03,
	0x0F, 0x85, 0x6A, 0x00, 0x00, 0x00, 0xE8, 0x42, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03,
	0x75, 0x11, 0xE8, 0x17, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x53, 0xE8, 0x2B, 0xFB,
	0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x06, 0xE8, 0x1F, 0xFB, 0xFF, 0xFF, 0xC3, 0x83,
	0x7D, 0x16, 0x05, 0x75, 0x11, 0xE8, 0xF4, 0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x30,
	0xE8, 0x08, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0xDD, 0xF7, 0xFF,
	0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x19, 0xE8, 0xF1, 0xFA, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
	0x07, 0x7F, 0x07, 0xE8, 0xC6, 0xF7, 0xFF, 0xFF, 0xEB, 0x06, 0xE8, 0xDE, 0xFA, 0xFF, 0xFF, 0xC3,
	0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0xF9, 0xF7, 0xFF,
	0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x11, 0xE8, 0xA2, 0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03,
	0x75, 0x51, 0xE8, 0xB6, 0xFA, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x11, 0xE8, 0x8B,
	0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x3A, 0xE8, 0x9F, 0xFA, 0xFF, 0xFF, 0xC3, 0x83,
	0x7D, 0x16, 0x02, 0x75, 0x11, 0xE8, 0x74, 0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x23,
	0xE8, 0x88, 0xFA, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x11, 0xE8, 0x5D, 0xF7, 0xFF,
	0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x0C, 0xE8, 0x71, 0xFA, 0xFF, 0xFF, 0xC3, 0xE8, 0x6B, 0xFA,
	0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x48,
	0xFF, 0x45, 0x23, 0xC7, 0x45, 0x02, 0x10, 0x00, 0x00, 0x00, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22,
	0x0F, 0x75, 0x06, 0xE8, 0x45, 0xFA, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6,
	0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC7, 0x45, 0x02, 0x20, 0x00, 0x00,
	0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8,
	0x19, 0xFA, 0xFF, 0xFF, 0xC3, 0x8B, 0x4D, 0x06, 0xD1, 0xE9, 0x89, 0x5D, 0x06, 0x48, 0x8B, 0x45,
	0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0x8B, 0x5D,
	0x06, 0xD1, 0xE1, 0x89, 0x4D, 0x06, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D,
	0x22, 0x0F, 0x75, 0x06, 0xE8, 0xE4, 0xF9, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6,
	0x00, 0x3C, 0xA4, 0x74, 0x12, 0x3C, 0xA7, 0x74, 0x0E, 0x3C, 0xAE, 0x74, 0x0A, 0x3C, 0xAF, 0x74,
	0x06, 0x3C, 0x0F, 0x74, 0x02, 0xEB, 0x04, 0xC6, 0x45, 0x00, 0x01, 0x48, 0x8B, 0x45, 0x23, 0x48,
	0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC6, 0x45, 0x00, 0x00,
	0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0x9A,
	0xF9, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x00, 0x3C, 0x90, 0x74, 0x3E, 0x3C,
	0xA4, 0x74, 0x3A, 0x3C, 0xA5, 0x74, 0x36, 0x3C, 0xA6, 0x74, 0x32, 0x3C, 0xA7, 0x74, 0x2E, 0x3C,
	0xAA, 0x74, 0x2A, 0x3C, 0xAB, 0x74, 0x26, 0x3C, 0xAC, 0x74, 0x22, 0x3C, 0xAD, 0x74, 0x1E, 0x3C,
	0xAE, 0x74, 0x1A, 0x3C, 0xAF, 0x74, 0x16, 0x3C, 0x6C, 0x74, 0x12, 0x3C, 0x6D, 0x74, 0x0E, 0x3C,
	0x6E, 0x74, 0x0A, 0x3C, 0x6F, 0x74, 0x06, 0x3C, 0x0F, 0x74, 0x02, 0xEB, 0x04, 0xC6, 0x45, 0x01,
	0x01, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00,
	0xFF, 0xD0, 0xC6, 0x45, 0x01, 0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D,
	0x22, 0x0F, 0x75, 0x06, 0xE8, 0x24, 0xF9, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F,
	0xB6, 0x08, 0x48, 0x8D, 0x84, 0xCE, 0x00, 0x08, 0x00, 0x00, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3,
	0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0xFB, 0xF8,
	0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x84, 0xCE, 0x00,
	0x10, 0x00, 0x00, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22,
	0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0xD2, 0xF8, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23,
	0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x84, 0xCE, 0x00, 0x18, 0x00, 0x00, 0x48, 0x03, 0x00, 0xFF,
	0xD0, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40,
	0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11, 0xE8, 0xCD, 0xF5, 0xFF, 0xFF, 0x83, 0x7D, 0x16,
	0x07, 0x7E, 0x06, 0xE8, 0x95, 0xF8, 0xFF, 0xFF, 0xC3, 0xE8, 0x70, 0xF5, 0xFF, 0xFF, 0x8B, 0x45,
	0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x17,
	0xE8, 0x95, 0xF5, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x69, 0x83, 0x7D, 0x16, 0x07, 0x7E,
	0x63, 0xE8, 0x57, 0xF8, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C, 0x56, 0x89, 0xC2,
	0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA, 0x0D, 0x75, 0x0B, 0x83, 0xF9, 0x00,
	0x74, 0x42, 0xE8, 0x36, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0E, 0x75, 0x37, 0x83, 0xF9, 0x02,
	0x75, 0x06, 0xE8, 0x26, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xF9, 0x03, 0x75, 0x06, 0xE8, 0x1B, 0xF8,
	0xFF, 0xFF, 0xC3, 0x83, 0xF9, 0x06, 0x75, 0x06, 0xE8, 0x10, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xF9,
	0x07, 0x75, 0x06, 0xE8, 0x05, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xF9, 0x0F, 0x75, 0x06, 0xE8, 0xFA,
	0xF7, 0xFF, 0xFF, 0xC3, 0xE8, 0xD5, 0xF4, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
	0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23,
	0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11, 0xE8, 0xFA, 0xF4, 0xFF, 0xFF,
	0x83, 0x7D, 0x16, 0x07, 0x7E, 0x32, 0xE8, 0xC2, 0xF7, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00, 0x00,
	0x00, 0x7C, 0x25, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA, 0x0E,
	0x75, 0x0B, 0x83, 0xF9, 0x09, 0x74, 0x11, 0xE8, 0xA1, 0xF7, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0F,
	0x75, 0x06, 0xE8, 0x96, 0xF7, 0xFF, 0xFF, 0xC3, 0xE8, 0x71, 0xF4, 0xFF, 0xFF, 0x8B, 0x45, 0x1A,
	0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x1F, 0xE8,
	0x96, 0xF4, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x04, 0x74, 0x0E, 0x83, 0x7D, 0x16, 0x06, 0x74, 0x08,
	0x83, 0x7D, 0x16, 0x07, 0x7F, 0x02, 0xEB, 0x41, 0xE8, 0x50, 0xF7, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0,
	0x00, 0x00, 0x00, 0x7C, 0x34, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83,
	0xFA, 0x0E, 0x75, 0x15, 0x83, 0xF9, 0x08, 0x7D, 0x20, 0x83, 0xF9, 0x03, 0x74, 0x1B, 0x83, 0xF9,
	0x02, 0x74, 0x16, 0xE8, 0x25, 0xF7, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0F, 0x75, 0x0B, 0x83, 0xF9,
	0x08, 0x7C, 0x06, 0xE8, 0x15, 0xF7, 0xFF, 0xFF, 0xC3, 0xE8, 0xF0, 0xF3, 0xFF, 0xFF, 0x8B, 0x45,
	0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11,
	0xE8, 0x15, 0xF4, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x07, 0x7E, 0x22, 0xE8, 0xDD, 0xF6, 0xFF, 0xFF,
	0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C, 0x15, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83,
	0xE1, 0x0F, 0x83, 0xFA, 0x0D, 0x75, 0x06, 0xE8, 0xC1, 0xF6, 0xFF, 0xFF, 0xC3, 0xE8, 0x9C, 0xF3,
	0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45,
	0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00,
	0x00, 0x00, 0x7F, 0x19, 0xE8, 0xC1, 0xF3, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x05, 0x74, 0x08, 0x83,
	0x7D, 0x16, 0x07, 0x7F, 0x02, 0xEB, 0x32, 0xE8, 0x81, 0xF6, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00,
	0x00, 0x00, 0x7C, 0x25, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA,
	0x0C, 0x75, 0x0B, 0x83, 0xF9, 0x08, 0x7C, 0x11, 0xE8, 0x60, 0xF6, 0xFF, 0xFF, 0xC3, 0x83, 0xFA,
	0x0F, 0x75, 0x06, 0xE8, 0x55, 0xF6, 0xFF, 0xFF, 0xC3, 0xE8, 0x30, 0xF3, 0xFF, 0xFF, 0x8B, 0x45,
	0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11,
	0xE8, 0x55, 0xF3, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x07, 0x7E, 0x27, 0xE8, 0x1D, 0xF6, 0xFF, 0xFF,
	0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C, 0x1A, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83,
	0xE1, 0x0F, 0x83, 0xFA, 0x0D, 0x75, 0x0B, 0x83, 0xF9, 0x09, 0x74, 0x06, 0xE8, 0xFC, 0xF5, 0xFF,
	0xFF, 0xC3, 0xE8, 0xD7, 0xF2, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45,
	0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6,
	0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11, 0xE8, 0xFC, 0xF2, 0xFF, 0xFF, 0x83, 0x7D,
	0x16, 0x07, 0x7E, 0x52, 0xE8, 0xC4, 0xF5, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C,
	0x45, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA, 0x0C, 0x75, 0x06,
	0xE8, 0xA8, 0xF5, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0D, 0x75, 0x06, 0xE8, 0x9D, 0xF5, 0xFF, 0xFF,
	0xC3, 0x83, 0xFA, 0x0E, 0x75, 0x10, 0x83, 0xF9, 0x00, 0x74, 0x1B, 0x83, 0xF9, 0x08, 0x7D, 0x16,
	0xE8, 0x88, 0xF5, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0F, 0x75, 0x0B, 0x83, 0xF9, 0x08, 0x7C, 0x06,
	0xE8, 0x78, 0xF5, 0xFF, 0xFF, 0xC3, 0xE8, 0x53, 0xF2, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45,
	0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
}; 




//在InlineHook之前调用，构建 LDEx64() 函数
void LDE_Init64()   
{
	LDEx64 = ExAllocatePool(NonPagedPool,12800);
	memcpy(LDEx64,szShellCode64,12800);
}


//获得Address中需要被Patch的字节数
ULONG GetPatchSize64(PUCHAR Address)
{
	ULONG LenCount=0,Len=0;

	while(LenCount<=14)	//至少需要14字节
	{
		Len = LDEx64(Address,64);
		Address=Address+Len;
		LenCount=LenCount+Len;
	}
	return LenCount;
}



//卸载驱动，恢复InlineHook后，释放LDEx64的内存

void LDE_Del64()
{
	if (LDEx64!=NULL)
	{
		ExFreePool(LDEx64);
	}

	LDEx64 = NULL;
}
  
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegisterPath)
{


	PDEVICE_OBJECT	        DeviceObject;
	NTSTATUS		        Status = STATUS_SUCCESS;
	ULONG			        i;
	UNICODE_STRING	        uniDeviceName;
	UNICODE_STRING	        uniLinkName;

	RtlInitUnicodeString(&uniDeviceName,DEVICE_NAME);
	RtlInitUnicodeString(&uniLinkName,LINK_NAME);

	//创建设备对象;
	Status = IoCreateDevice(DriverObject,0,&uniDeviceName,FILE_DEVICE_UNKNOWN,0,FALSE,&DeviceObject);
	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	//创建符号链接;
	Status = IoCreateSymbolicLink(&uniLinkName,&uniDeviceName);

	if (!NT_SUCCESS(Status))
	{
		IoDeleteDevice(DeviceObject);
		return Status;
	}

	for (i = 0; i<IRP_MJ_MAXIMUM_FUNCTION; i ++)
	{
		DriverObject->MajorFunction[i] = DefaultPassThrough;
	}
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlPassThrough;
	DriverObject->DriverUnload = UnloadDriver;


	DbgPrint("HelloDriver\r\n");

	return Status;

}


NTSTATUS ControlPassThrough(PDEVICE_OBJECT  DeviceObject,PIRP Irp)
{

	NTSTATUS  Status       = STATUS_SUCCESS;
	PVOID     InputBuffer  = NULL;
	PVOID     OutputBuffer = NULL;
	ULONG_PTR InputSize    = 0;
	ULONG_PTR OutputSize   = 0;
	ULONG_PTR IoControlCode = 0;
	PIO_STACK_LOCATION   IrpSp;
	PVOID     SSSDTFunctionAddress = NULL;
	IrpSp = IoGetCurrentIrpStackLocation(Irp);

	InputBuffer  = Irp->AssociatedIrp.SystemBuffer;
	OutputBuffer = Irp->AssociatedIrp.SystemBuffer;
	InputSize    = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	OutputSize   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

	switch(IoControlCode)
	{
	case IOCTL_GET_SSSDTSERVERICE:
		{

#ifdef _WIN64
			SSSDTDescriptor = GetKeShadowServiceDescriptorTable64();
#else
			SSSDTDescriptor = GetKeShadowServiceDescriptorTable32();		
#endif

			CurrentProcessID = PsGetCurrentProcessId();
			if (SSSDTDescriptor==NULL)
			{
				Irp->IoStatus.Information = 0;
				Status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

				break;
			}

			Irp->IoStatus.Information = 0;
			Status = Irp->IoStatus.Status = STATUS_SUCCESS;

			break;

		}
	case IOCTL_INLINEUNHOOK_SSSDT:
		{

			if (SSSDTDescriptor==NULL)
			{
				Irp->IoStatus.Information = 0;
				Status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

				break;
			}

			else
			{
#ifdef _WIN64
				
				InlineUnHookSSSDTWin7(CurrentNtUserPostMessageAddress,OrigianlFunctionCode,14);
				LDE_Del64();
#else


				InlineUnHookSSSDTWinXP(CurrentNtUserPostMessageAddress,OrigianlFunctionCode,5);

#endif


				if (OrigianlFunctionCode!=NULL)
				{
					ExFreePool(OrigianlFunctionCode);
					OrigianlFunctionCode = NULL;
				}
				Irp->IoStatus.Information = 0;
				Status = Irp->IoStatus.Status = STATUS_SUCCESS;

				break;
			}

			break;
		}
	case IOCTL_INLINEHOOK_SSSDT:
		{

			if (SSSDTDescriptor==NULL)
			{
				Irp->IoStatus.Information = 0;
				Status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

				break;
			}

			else
			{

#ifdef _WIN64

				LDE_Init64();
				CurrentNtUserQueryWindowAddress = (pfnNtUserQueryWindow)GetSSSDTFunctionAddress64(IndexOfNtUserQueryWindowWin7);
				CurrentNtUserPostMessageAddress = (pfnNtUserPostMessage)GetSSSDTFunctionAddress64(IndexOfNtUserPostMessageWin7);
			

				if (CurrentNtUserPostMessageAddress==NULL||CurrentNtUserQueryWindowAddress==NULL)
				{
					Irp->IoStatus.Information = 0;
					Status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

					break;
				}




				InlineHookSSSDTWin7(CurrentNtUserPostMessageAddress,Fake_NtUserPostMessageAddress,14,&OrigianlFunctionCode);

#else


				CurrentNtUserQueryWindowAddress = (pfnNtUserQueryWindow)GetSSSDTFunctionAddress32(IndexOfNtUserQueryWindowWinXP);
				CurrentNtUserPostMessageAddress = (pfnNtUserPostMessage)GetSSSDTFunctionAddress32(IndexOfNtUserPostMessageWinXP);


				if (CurrentNtUserPostMessageAddress==NULL||CurrentNtUserQueryWindowAddress==NULL)
				{
					Irp->IoStatus.Information = 0;
					Status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

					break;
				}


				InlineHookSSSDTWinXP(CurrentNtUserPostMessageAddress,Fake_NtUserPostMessageAddress,5,
					&OrigianlFunctionCode);



#endif



				Irp->IoStatus.Information = 0;
				Status = Irp->IoStatus.Status = STATUS_SUCCESS;

				break;

			}
		}

	default:
		{

			Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
			Irp->IoStatus.Information = 0;



			break;
		}
	}


	IoCompleteRequest(Irp,IO_NO_INCREMENT);

	return Status;
}

BOOLEAN  InlineHookSSSDTWin7(PVOID OriginalFunctionAddress,PVOID NewFucntionAddress,ULONG ulPatchSize,
	PVOID* OrigianlFunctionCode)
{
	PVOID OriginalFunctionAddressHeaderBytes = NULL;  
	UCHAR szJmpCode[]="\xFF\x25\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
	ULONG_PTR VirtaulAddress = NULL;
	ulPatchSize = GetPatchSize64((PUCHAR)OriginalFunctionAddress);
	OriginalFunctionAddressHeaderBytes = ExAllocatePool(NonPagedPool,ulPatchSize);

	if (OriginalFunctionAddressHeaderBytes==NULL)
	{
		return FALSE;
	}

	WPOFF();
	memcpy(OriginalFunctionAddressHeaderBytes,OriginalFunctionAddress,ulPatchSize);
	//保存了Original函数的前14个字节
	WPON();

	*OrigianlFunctionCode = ExAllocatePool(NonPagedPool,(ulPatchSize+14));
	RtlFillMemory(*OrigianlFunctionCode,ulPatchSize+14,0x90);


	memcpy((PUCHAR)*OrigianlFunctionCode,OriginalFunctionAddressHeaderBytes,ulPatchSize);   //保存原先的14个字节


	ExFreePool(OriginalFunctionAddressHeaderBytes);

	VirtaulAddress = (ULONG_PTR)OriginalFunctionAddress+ulPatchSize;	                        
	memcpy(szJmpCode+6,&VirtaulAddress,8);                                   
	memcpy((PUCHAR)*OrigianlFunctionCode+ulPatchSize,szJmpCode,sizeof(szJmpCode)-1);




	VirtaulAddress = (ULONG_PTR)NewFucntionAddress;
	memcpy(szJmpCode+6,&VirtaulAddress,8);



	//修改原先的14个字节为跳转到Fake的指令
	WPOFF();
	RtlFillMemory(OriginalFunctionAddress,ulPatchSize,0x90);
	memcpy(OriginalFunctionAddress,szJmpCode,sizeof(szJmpCode)-1);
	WPON();

	return TRUE;
}

VOID InlineUnHookSSSDTWin7(PVOID OriginalFunctionAddress,PVOID OrigianlFunctionCode,ULONG ulPatchSize)
{
	WPOFF();
	memcpy(OriginalFunctionAddress,OrigianlFunctionCode,ulPatchSize);   
	WPON();
}




BOOL InlineHookSSSDTWinXP(PVOID OriginalFunctionAddress,PVOID NewFunctionAddress,ULONG ulPatchSize,PVOID* OrigianlFunctionCode)
{
	UCHAR szJmpCode[] = "\xe9\x00\x00\x00\x00";

	ULONG_PTR VirtualAddress = 0;
	PVOID OriginalFunctionAddressHeaderBytes = NULL;  

	OriginalFunctionAddressHeaderBytes = ExAllocatePool(NonPagedPool,ulPatchSize);

	if (OriginalFunctionAddressHeaderBytes==NULL)
	{
		return FALSE;
	}
	WPOFF();
	memcpy(OriginalFunctionAddressHeaderBytes,OriginalFunctionAddress,ulPatchSize);
	WPON();


	*OrigianlFunctionCode = ExAllocatePool(NonPagedPool,(ulPatchSize+5));
	RtlFillMemory(*OrigianlFunctionCode,ulPatchSize+5,0x90);


	memcpy((PUCHAR)*OrigianlFunctionCode,OriginalFunctionAddressHeaderBytes,ulPatchSize);   

	VirtualAddress = (ULONG_PTR)OriginalFunctionAddress+ulPatchSize;	                        

	*((int*)&szJmpCode[1]) = (int)VirtualAddress  - ((int)(*OrigianlFunctionCode) +5 + 5); //第一个+5 是过前5个字节 第二个加 是 新 - （旧+5）



	memcpy((PUCHAR)(*OrigianlFunctionCode)+ulPatchSize,szJmpCode,sizeof(szJmpCode)-1);


	VirtualAddress = (ULONG_PTR)NewFunctionAddress;

	*((int*)&szJmpCode[1]) = (int)VirtualAddress  - ((int)OriginalFunctionAddress +5); 

	WPOFF();
	RtlFillMemory(OriginalFunctionAddress,ulPatchSize,0x90);
	memcpy(OriginalFunctionAddress,szJmpCode,sizeof(szJmpCode)-1);
	WPON();

	return TRUE;
}
VOID InlineUnHookSSSDTWinXP(PVOID OriginalFunctionAddress,PVOID OrigianlFunctionCode,ULONG ulPatchSize)
{
	WPOFF();
	memcpy(OriginalFunctionAddress,OrigianlFunctionCode,ulPatchSize);  
	WPON();
}

ULONG_PTR Fake_NtUserPostMessageAddress(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if(CurrentNtUserQueryWindowAddress(hWnd,0)==CurrentProcessID && PsGetCurrentProcessId()!=(HANDLE)CurrentProcessID )
	{

		return 0;
	}
	else
	{	
		return ((pfnNtUserPostMessage)OrigianlFunctionCode)(hWnd,uMsg,wParam,lParam);
	}
}


PVOID GetKeShadowServiceDescriptorTable64()
{
	PUCHAR StartAddress = (PUCHAR)__readmsr(0xC0000082);

	PUCHAR i = NULL;
	UCHAR v1=0,v2=0,v3=0;
	int       iOffset = 0;
	ULONG_PTR SSSDTDescriptor = 0;
	for(i=StartAddress;i<StartAddress+PAGE_SIZE;i++)
	{
		if( MmIsAddressValid(i) && MmIsAddressValid(i+1) && MmIsAddressValid(i+2) )
		{
			v1 = *i;
			v2 = *(i+1);
			v3 = *(i+2);
			if(v1==0x4c && v2==0x8d && v3==0x1d) 
			{
				memcpy(&iOffset,i+3,4);
				SSSDTDescriptor = iOffset + (ULONG_PTR)i + 7;
				SSSDTDescriptor+=32;

				return (PVOID)SSSDTDescriptor;
			}
		}
	}
	return 0;
}

PVOID GetKeShadowServiceDescriptorTable32()
{
	WCHAR wzKeAddSystemServiceTable[] = L"KeAddSystemServiceTable";

	ULONG_PTR SSSDTDescriptor = 0;
	PUCHAR i = 0;
	PUCHAR StartAddress;
	UCHAR v1=0,v2=0;
	StartAddress = (PUCHAR)GetFunctionAddressByNameFromNtosExport(wzKeAddSystemServiceTable);

	if (StartAddress==NULL)
	{
		return 0;
	}

	for(i=StartAddress;i<StartAddress+PAGE_SIZE;i++)
	{
		if( MmIsAddressValid(i) && MmIsAddressValid(i+1))
		{
			v1 = *i;
			v2 = *(i+1);
			if(v1==0x8d && v2==0x88) 
			{
				SSSDTDescriptor = *(ULONG_PTR*)(i+2);
				SSSDTDescriptor = SSSDTDescriptor + 16;


				return (PVOID)SSSDTDescriptor;
			}

		}
	}

	return 0;
}

PVOID 
	GetFunctionAddressByNameFromNtosExport(WCHAR *wzFunctionName)
{
	UNICODE_STRING uniFunctionName;  
	PVOID FunctionAddress = NULL;

	if (wzFunctionName && wcslen(wzFunctionName) > 0)
	{
		RtlInitUnicodeString(&uniFunctionName, wzFunctionName);      
		FunctionAddress = MmGetSystemRoutineAddress(&uniFunctionName);  
	}
	return FunctionAddress;
}


PVOID GetSSSDTFunctionAddress32(ULONG ulIndex)
{

	ULONG_PTR ServiceTableBase= 0 ;
	PSYSTEM_SERVICE_TABLE32 SSSDT = (PSYSTEM_SERVICE_TABLE32)SSSDTDescriptor;
	ServiceTableBase = (ULONG_PTR)(SSSDT->ServiceTableBase);
	return (PVOID)(*(PULONG_PTR)((ULONG_PTR)ServiceTableBase + 4 * ulIndex));
}

PVOID GetSSSDTFunctionAddress64(ULONG ulIndex)
{

	LONG      v1 = 0;
	ULONG_PTR v2 = 0;
	ULONG_PTR ServiceTableBase= 0 ;
	PSYSTEM_SERVICE_TABLE64 SSSDT = (PSYSTEM_SERVICE_TABLE64)SSSDTDescriptor;
	ServiceTableBase=(ULONG_PTR)(SSSDT ->ServiceTableBase);
	v2 = ServiceTableBase + 4 * ulIndex;
	v1 = *(PLONG)v2;
	v1 = v1>>4;
	return (PVOID)(ServiceTableBase + (ULONG_PTR)v1);
}


NTSTATUS DefaultPassThrough(PDEVICE_OBJECT  DeviceObject,PIRP Irp)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp,IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}




VOID WPOFF()
{
	ULONG_PTR cr0 = 0;
	Irql = KeRaiseIrqlToDpcLevel();
	cr0 =__readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);
	//	_disable();                      //这句话 屏蔽也没有啥
}

VOID WPON()
{
	ULONG_PTR cr0=__readcr0();
	cr0 |= 0x10000;
	//	_enable();                      //这句话 屏蔽也没有啥
	__writecr0(cr0);
	KeLowerIrql(Irql);
}


VOID UnloadDriver(PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING  uniLinkName;
	PDEVICE_OBJECT	NextDeviceObject    = NULL;
	PDEVICE_OBJECT  CurrentDeviceObject = NULL;

	RtlInitUnicodeString(&uniLinkName,LINK_NAME);

	IoDeleteSymbolicLink(&uniLinkName);
	CurrentDeviceObject = DriverObject->DeviceObject;
	while (CurrentDeviceObject != NULL) 
	{

		NextDeviceObject = CurrentDeviceObject->NextDevice;
		IoDeleteDevice(CurrentDeviceObject);
		CurrentDeviceObject = NextDeviceObject;
	}
	return;
}
```

`InlineHook_ShadowSSDT/ring0/InlineHookSSSDT.h`:

```h


#ifndef CXX_INLINEHOOKSSSDT_H
#define CXX_INLINEHOOKSSSDT_H



#include <ntifs.h>
#include <WINDEF.H>

typedef struct _SYSTEM_SERVICE_TABLE64{
	PVOID  		ServiceTableBase; 
	PVOID  		ServiceCounterTableBase; 
	ULONG64  	NumberOfServices; 
	PVOID  		ParamTableBase; 
} SYSTEM_SERVICE_TABLE64, *PSYSTEM_SERVICE_TABLE64;

typedef struct _SYSTEM_SERVICE_TABLE32 {
	PVOID   ServiceTableBase;
	PVOID   ServiceCounterTableBase;
	ULONG32 NumberOfServices;
	PVOID   ParamTableBase;
} SYSTEM_SERVICE_TABLE32, *PSYSTEM_SERVICE_TABLE32;

#define DEVICE_NAME   L"\\Device\\InlineHookSSSDTDevice"
#define LINK_NAME 	  L"\\DosDevices\\InlineHookSSSDTLink"

#define IOCTL_GET_SSSDTSERVERICE	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INLINEHOOK_SSSDT \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_INLINEUNHOOK_SSSDT \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x831,METHOD_BUFFERED,FILE_ANY_ACCESS)


NTSTATUS ControlPassThrough(PDEVICE_OBJECT  DeviceObject,PIRP Irp);
NTSTATUS DefaultPassThrough(PDEVICE_OBJECT  DeviceObject,PIRP Irp);
VOID UnloadDriver(PDRIVER_OBJECT DriverObject);

PVOID 
	GetFunctionAddressByNameFromNtosExport(WCHAR *wzFunctionName);
PVOID GetKeShadowServiceDescriptorTable32();
PVOID GetKeShadowServiceDescriptorTable64();
PVOID GetSSSDTFunctionAddress64(ULONG ulIndex);
PVOID GetSSSDTFunctionAddress32(ULONG ulIndex);

typedef ULONG_PTR (*pfnNtUserQueryWindow)(HWND WindowHandle, ULONG_PTR TypeInformation);
typedef ULONG_PTR (*pfnNtUserPostMessage)(HWND WindowHandle,UINT uMsg,WPARAM wParam,LPARAM lParam);

VOID WPOFF();
VOID WPON();

BOOLEAN  InlineHookSSSDTWin7(PVOID OriginalFunctionAddress,PVOID NewFucntionAddress,ULONG ulPatchSize,
	PVOID* OrigianlFunctionCode);
VOID InlineUnHookSSSDTWin7(PVOID OriginalFunctionAddress,PVOID OrigianlFunctionCode,ULONG ulPatchSize);



BOOL InlineHookSSSDTWinXP(PVOID OriginalFunctionAddress,PVOID NewFunctionAddress,ULONG ulPatchSize,PVOID* OrigianlFunctionCode);
VOID InlineUnHookSSSDTWinXP(PVOID OriginalFunctionAddress,PVOID OrigianlFunctionCode,ULONG ulPatchSize);

ULONG_PTR Fake_NtUserPostMessageAddress(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void LDE_Init64() ;
ULONG GetPatchSize64(PUCHAR Address);
#endif

```

`InlineHook_ShadowSSDT/ring0/InlineHookSSSDT.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "InlineHookSSSDT", "InlineHookSSSDT.vcxproj", "{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		WinDDK|Win32 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.ActiveCfg = WinDDK|Win32
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.Build.0 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`InlineHook_ShadowSSDT/ring0/InlineHookSSSDT.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="WinDDK|Win32">
      <Configuration>WinDDK</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>"InlineHookSSSDT"</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
    <ExecutablePath>$(WLHBASE)\bin\x86\x86;$(WLHBASE)\bin\x86</ExecutablePath>
    <IncludePath>$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc</IncludePath>
    <ReferencePath />
    <LibraryPath>$(WLHBASE)\lib\win7\i386</LibraryPath>
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG=1</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include=".\InlineHookSSSDT.c" />
    <ClCompile Include=".\InlineHookSSSDT.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`InlineHook_ShadowSSDT/ring0/InlineHookSSSDT.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`InlineHook_ShadowSSDT/ring0/clean.bat`:

```bat
rem /////////////////
rem / Add by ChiChou
rem / 
rem / FileName:Clean.bat
rem / Description:Clean
rem /
rem ////////////////
rd .\bin /s /q
rd .\WinDDK /s /q
rd .\objchk_w2k_x86 /s /q
rd .\objchk_wxp_x86 /s /q
rd .\objchk_wnet_x86 /s /q
rd .\objchk_wlh_x86 /s /q
rd .\objfre_w2k_x86 /s /q
rd .\objfre_wxp_x86 /s /q
rd .\objfre_wnet_x86 /s /q
rd .\objfre_wlh_x86 /s /q
del .\*.log
del .\*.err
del .\*.xml
rem ***** del VS2005 file *****
del .\*.ncb
del .\*.user
del .\*.suo /A:H
rem ***** del VS6.0 file *****
del .\*.plg
del .\*.opt
exit
```

`InlineHook_ShadowSSDT/ring0/ddkbuild.cmd`:

```cmd
@echo off
@set VERSION=V7.3
@set OSR_DEBUG=off
@if "%OS%"=="Windows_NT" goto :Prerequisites
@echo This script requires Windows NT 4.0 or later to run properly!
goto :EOF
:Prerequisites
:: Check whether FINDSTR is available. It's used to show warnings etc.
findstr /? > NUL 2>&1 || echo "FINDSTR is a prerequisite but wasn't found!" && goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    $Id: ddkbuild.cmd 27 2008-09-06 12:02:06Z oliver $
::
::    This software is supplied for instructional purposes only.
::
::    OSR Open Systems Resources, Inc. (OSR) expressly disclaims any warranty
::    for this software.  THIS SOFTWARE IS PROVIDED  "AS IS" WITHOUT WARRANTY
::    OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
::    THE IMPLIED WARRANTIES OF MECHANTABILITY OR FITNESS FOR A PARTICULAR
::    PURPOSE.  THE ENTIRE RISK ARISING FROM THE USE OF THIS SOFTWARE REMAINS
::    WITH YOU.  OSR's entire liability and your exclusive remedy shall not
::    exceed the price paid for this material.  In no event shall OSR or its
::    suppliers be liable for any damages whatsoever (including, without
::    limitation, damages for loss of business profit, business interruption,
::    loss of business information, or any other pecuniary loss) arising out
::    of the use or inability to use this software, even if OSR has been
::    advised of the possibility of such damages.  Because some states/
::    jurisdictions do not allow the exclusion or limitation of liability for
::    consequential or incidental damages, the above limitation may not apply
::    to you.
::
::    OSR Open Systems Resources, Inc.
::    105 Route 101A Suite 19
::    Amherst, NH 03031  (603) 595-6500 FAX: (603) 595-6503
::    report bugs to <bugs@osr.com>
::    alternatively report them via <http://assarbad.net/contact/>
::
::
::    MODULE:
::
::      ddkbuild.cmd
::
::    ABSTRACT:
::
::      This script allows drivers to be built with Visual Studio 2002 through
::      Visual Studio 2008 and possibly future versions. It will also work fine
::      from the command line.
::      If you are interested in a project wizard that makes use of this script,
::      try DDKWizard from <http://ddkwizard.assarbad.net>.
::
::    AUTHOR(S):
::
::      - OSR Open Systems Resources, Inc.
::      - Oliver Schneider (ddkwizard.assarbad.net)
::
::    REQUIREMENTS:
::
::      Environment variables that must be set.
::        %NT4BASE%  - Set this up for "-NT4" builds (legacy, support not tested)
::        %W2KBASE%  - Set this up for "-W2K*" builds (legacy, support not tested)
::        %WXPBASE%  - Set this up for "-WXP*" builds
::        %WNETBASE% - Set this up for "-WNET*" builds
::        %WLHBASE%  - Set this up for "-WLH*" builds
::        %WDF_ROOT% - Must be set if attempting to do a WDF Build.
::
::      Examples:
::        NT4BASE : could be "D:\NT4DDK"
::        W2KBASE : could be "D:\Nt50DDK"
::        WXPBASE : could be "D:\WINDDK\2600"
::        WNETBASE: could be "D:\WINDDK\3790.1830" or "C:\WINDDK\3790"
::
::    COMMAND FORMAT:
::
::      Run the script without any parameters to get the whole help content!
::      Note: "-WDF" has been tested with the 01.00.5054 version of the framework
::
::    RETURN CODES AND THEIR MEANING:
::
::      001 == Unknown build type. Check the <platform> parameter
::      002 == No WDF_ROOT given using WDF build type.
::      003 == The DDK-specific base directory variable (NT4BASE, W2KBASE, WXPBASE,
::             WNETBASE) is not set at all and could not be auto-detected!
::      004 == BASEDIR variable is empty. Check to see that the DDK-specific
::             variable is set correctly (i.e. NT4BASE, W2KBASE, WXPBASE, WNETBASE)
::      005 == No mode (checked/free) was given. Check the respective parameter!
::      006 == No DIR or SOURCES file found in the given target directory.
::      007 == No target directory given.
::      008 == Given target directory does not exist.
::      009 == The SETENV script failed.
::
::      Note: If %OSR_ERRCODE% and %ERRORLEVEL% are equal, the return code stems
::            from one of the tools being called during the build process.
::
::    BROWSE FILES:
::
::      This procedure supports the building of BROWSE files to be used by
::      Visual Studio 6 and by Visual Studio.NET  However, the BSCfiles created
::      by bscmake for the two are not compatible. When this command procedure
::      runs, it selects the first bscmake.exe found in the path. So, make sure
::      that the correct bscmake.exe is in the path ...
::
::      Note that if using Visual Studio.NET the .BSC must be added to the project
::      in order for the project to be browsed.
::      Another alternative is the VS addon named "Visual Assist X" which will
::      parse the header files - no more need for browse files.
::
::    COMPILERS:
::
::      If you are building NT4 you should really be using the VC6 compiler.
::      Later versions of the DDK now contain the compiler and the linker. This
::      procedure should use the correct compiler.
::
::    GENERAL COMMENTS:
::
::      This procedure has been cleaned up to be modular and easy to understand.
::
::      As of the Server 2003 SP1 DDK DDKBUILD now clears the NO_BROWSE_FILE and
::      NO_BINPLACE environment variables so that users can use these features.
::
::      Starting with the Vista WDK, the output in the respective tool window
::      in VS is in Unicode by default. This garbles the output from DDKBUILD
::      and we therefore clear the environment variable VS_UNICODE_OUTPUT.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MAIN
:: Building "stack frame"
setlocal ENABLEEXTENSIONS & pushd .
:: Check whether the REG utility is available
reg /? > NUL 2>&1 && set OSR_REGAVAILABLE=1

:: This is set by client-side keyword substitution
set SVN_REVISION=$Revision: 27 $
:: Extract the revision number from the revision keyword
set SVN_REVISION=%SVN_REVISION:~0,-2%
set SVN_REVISION=%SVN_REVISION:~11%
:: This is set by client-side keyword substitution
set SVN_REVDATE=$Date: 2008-09-06 12:02:06 +0000 (Sat, 06 Sep 2008) $
:: Extract the date from the Date keyword
set SVN_REVDATE=%SVN_REVDATE:~7,10%
set VERSION=%VERSION%/r%SVN_REVISION%

:: Init some special variables
set OSR_VERSTR=OSR DDKBUILD.CMD %VERSION% (%SVN_REVDATE%) - OSR, Open Systems Resources, Inc.
set OSR_PREBUILD_SCRIPT=ddkprebld.cmd
set OSR_POSTBUILD_SCRIPT=ddkpostbld.cmd
set OSR_SETENV_SCRIPT=ddkbldenv.cmd
set OSR_ECHO=@echo DDKBLD:

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set error messages
:: Possible codes: 1
set ERR_UnknownBuildType=Unknown type of build. Please recheck parameters.
:: Possible codes: 2
set ERR_NoWdfRoot=WDF_ROOT is not defined, are you using 00.01.5054 or later?
:: Possible codes: 3
set ERR_BaseDirNotSet=To build using type %%OSR_TARGET%% you need to set the %%%%%%BASEDIRVAR%%%%%% environment variable to point to the %%BASEDIROS%% DDK base directory!
:: Possible codes: 4
set ERR_NoBASEDIR=NT4BASE, W2KBASE, WXPBASE and/or WNETBASE environment variable(s) not set. Environment variable(s) must be set by user according to DDK version(s) installed.
:: Possible codes: 5
set ERR_BadMode=^<build type^> must be 'checked', 'free', 'chk' or 'fre' (case-insensitive).
:: Possible codes: 6
set ERR_NoTarget=Target directory must contain a SOURCES or DIRS file.
:: Possible codes: 7, 8
set ERR_NoDir=The ^<directory^> parameter must be a valid directory.
:: Possible codes: 9
set ERR_SetEnvFailed=The SETENV script failed.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Clear the error code variable
set OSR_ERRCODE=0
set prefast_build=0

:: Turn on tracing, use %OSR_TRACE% instead of ECHO
if /i "%OSR_DEBUG%" == "on" (set OSR_TRACE=%OSR_ECHO% [TRACE]) else (set OSR_TRACE=rem)
:: Turn on echoing of current line if %OSR_DEBUG% is set to "on"
@echo %OSR_DEBUG%

:: Output version string
@echo %OSR_VERSTR%
%OSR_TRACE% ^(Current module: ^"%~f0^"^)
@echo.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set the target platform variable
set OSR_TARGET=%~1
:: Remove any dashes in the variable
if not "%OSR_TARGET%" == "" set OSR_TARGET=%OSR_TARGET:-=%
:: Show help if the target parameter is empty after removal of the dashes
if "%OSR_TARGET%" == "" goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: In the build directory check for this script and call it if it exists.
:: This allows to override any global system variable setting, if desired.
if not "%3" == "" call :GetCustomEnvironment "%~f3"
if not "%OSR_ERRCODE%" == "0" goto :USAGE
:: Additional error handling for better usability
:: These subroutines will also attempt to locate the requested DDK!!!
set OSR_ERRCODE=3
%OSR_TRACE% Checking whether the environment variable for the build type was set
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Check > NUL 2>&1
:: If the BASEDIROS/BASEDIRVAR variable is not defined, it means the subroutine did not exist!
if not DEFINED BASEDIROS call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIROS)" & goto :USAGE
if not DEFINED BASEDIRVAR call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIRVAR)" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BaseDirNotSet%" & goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
set BASEDIR=%%%BASEDIRVAR%%%
call :ResolveVar BASEDIR
call :MakeShort BASEDIR "%BASEDIR%"
:: Check for existing %BASEDIR%
if "%BASEDIR%" == "" call :ShowErrorMsg 4 "%ERR_NoBASEDIR%" & goto :USAGE
set PATH=%BASEDIR%\bin;%PATH%
%OSR_TRACE% Now jump to the initialization of the commandline
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Build

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_TRACE% We returned from the variable initialization
if not DEFINED OSR_CMDLINE call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (OSR_CMDLINE)" & goto :USAGE

%OSR_TRACE% Hurrah, all the variables have been initialized, continuing
:: Proceed with common build steps
goto :CommonBuild

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Check whether the parameter makes sense and try to
:: correct it if possible
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WLH64Check
:WLHA64Check
:WLHXP64Check
:WLHNET64Check
:WLHNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WLHCheck
:WLHX64Check
:WLHI64Check
:WLHNETX64Check
:WLHNETI64Check
:WLHXPCheck
:WLH2KCheck
:WLHNETCheck
set BASEDIROS=Windows Vista/Windows 2008 Server
set BASEDIRVAR=WLHBASE
:: Compatibility between BUILD and VS ... prevent pipes from being used
%OSR_ECHO% Clearing %%VS_UNICODE_OUTPUT%% ...
set VS_UNICODE_OUTPUT=
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "6001.18000 6000"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WNETW2KCheck
:WNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WNET2KCheck
:WNETXPCheck
:WNETWXPCheck
:WNETXP64Check
:WNET64Check
:WNETI64Check
:WNETAMD64Check
:WNETX64Check
:WNETCheck
set BASEDIROS=Windows 2003 Server
set BASEDIRVAR=WNETBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "3790.1830 3790.1218 3790"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:XPCheck
:XP64Check
:XPW2KCheck
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WXP64Check
:WXPI64Check
:WXPCheck
:WXP2KCheck
set BASEDIROS=Windows XP
set BASEDIRVAR=WXPBASE
:: Other flavor of DDKBUILD
if not DEFINED WXPBASE if DEFINED XPBASE set BASEDIRVAR=XPBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "2600.1106 2600"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:W2K64Check
:W2KI64Check
:W2KCheck
set BASEDIROS=Windows 2000
set BASEDIRVAR=W2KBASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:NT4Check
set BASEDIROS=Windows NT4
set BASEDIRVAR=NT4BASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg1
echo.
%OSR_ECHO% WARNING: %%%BASEDIRVAR%%% NOT SET!
%OSR_ECHO%   Attempting to auto-detect the installation folder and set %%%BASEDIRVAR%%%.
%OSR_ECHO%   (If this fails *you* will have to set it!)
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg2
echo.
%OSR_ECHO% WARNING:
%OSR_ECHO%   Auto-detection of the folder settings is not supported for the requested DDK.
%OSR_ECHO%   Please set %%%BASEDIRVAR%%% yourself!
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckSetVarWithReturn
%OSR_ECHO% Found!
echo.
set %BASEDIRVAR%=%BASEDIRTEMP%
set BASEDIRTEMP=
:: Tell the caller it was successful
:CommonCheckNoErrorWithReturn
set OSR_ERRCODE=0
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckErrorNotDetectedWithReturn
echo.
%OSR_ECHO% None of the usual default paths works. Set %%%BASEDIRVAR%%% manually!
:CommonCheckErrorNotSupportedWithReturn
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Initialize variables specific to the respective platform
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: 
:: Valid parameters for setenv in different DDKs/WDKs:
::
:: 2600       - "setenv <directory> [fre|chk] [64] [hal]"
:: 2600.1106  - "setenv <directory> [fre|chk] [64] [hal] [WXP|W2K]"
:: 3790       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K]"
:: 3790.1830  - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K] [no_prefast] [bscmake]"
:: 6000       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"
:: 6001.18000 - "setenv <directory> [fre|chk] [64|x64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: NT 4.0 build using NT4 DDK
:NT4Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% "%%MSDEVDIR%%"
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WXP DDK
:XPW2KBuild
:WXP2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\w2k\set2k.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 64bit (Intel) using W2K DDK
:W2K64Build
:W2KI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv64.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using W2K DDK
:W2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WXP DDK
:XP64Build
:WXP64Build
:WXPI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WXP DDK
:XPBuild
:WXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WNET DDK
:WNETW2KBuild
:WNET2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% W2K %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WNET DDK
:WNETXPBuild
:WNETWXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit using WNET DDK
:WNETXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WNET DDK
:WNET64Build
:WNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WNET DDK
:WNETA64Build
:WNETAMD64Build
:WNETX64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% AMD64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WNET DDK
:WNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 32bit using WLH DDK
:WLHBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (AMD) using WLH DDK
:WLHA64Build
:WLHX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (Intel) using WLH DDK
:WLH64Build
:WLHI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WLH DDK
:WLHNETA64Build
:WLHNETX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WLH DDK
:WLHNET64Build
:WLHNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WLH DDK
:WLHXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WLH DDK
:WLHXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WLH DDK
:WLH2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% W2K
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WLH DDK
:WLHNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: All builds go here for the rest of the procedure. Now,
:: we are getting ready to call build. The big problem
:: here is to figure our the name of the buildxxx files
:: being generated for the different platforms.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:CommonBuild
:: Remove first command line arg
shift
call :SetMode %1
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BadMode%" & goto :USAGE
set OSR_BUILDNAME=%OSR_TARGET% (%BuildMode%) using the %BASEDIROS% DDK and %%%BASEDIRVAR%%%

call :CheckTargets %2
if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :USAGE

:: Resolve any variables in the command line string
call :ResolveVar OSR_CMDLINE

pushd .
set ERRORLEVEL=0
:: This external script prepares the build environment (e.g. setenv.bat)
call %OSR_CMDLINE%
:: Will only work with newer SETENV.BAT versions, but will be helpful in this case.
if not "%ERRORLEVEL%" == "0" call :ShowErrorMsg 9 "%ERR_SetEnvFailed%" & goto :USAGE
popd

:: ----------------------------------------------------------------------------
:: Setting global variables for the scope of this CMD session
set NO_BROWSER_FILE=
set NO_BINPLACE=
set buildDirectory=%~fs2
call :MakeShort buildDirectory "%buildDirectory%"
set buildDirectory_raw=%2
set buildDirectory_fname=%~n2
%OSR_TRACE% buildDirectory       == %buildDirectory%
%OSR_TRACE% buildDirectory_raw   == %buildDirectory_raw%
%OSR_TRACE% buildDirectory_fname == %buildDirectory_fname%

set mpFlag=-M
if "%BUILD_ALT_DIR%" == "" goto :NT4

:: W2K sets this!
set OSR_EXT=%BUILD_ALT_DIR%
set mpFlag=-MI

:NT4
if "%NUMBER_OF_PROCESSORS%" == "" set mpFlag=
if "%NUMBER_OF_PROCESSORS%" == "1" set mpFlag=

:: Set additional variables at this point or do whatever you please
@if exist "%buildDirectory%\%OSR_PREBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_PREBUILD_SCRIPT%" > "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
)
:: Save the current directory (before changing into the build directory!)
:: AFTERPREBUILD
pushd .

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Determine the settings of flags, WDF and PREFAST in
:: other words what was set for %3 and beyond....
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_ECHO% %OSR_BUILDNAME%
set OSR_ARGS= + argument(s):
if not "%3" == "" set OSR_ARGS=%OSR_ARGS% %3
if not "%4" == "" set OSR_ARGS=%OSR_ARGS% %4
if not "%5" == "" set OSR_ARGS=%OSR_ARGS% %5
if /i "%OSR_ARGS%" == " + argument(s):" set OSR_ARGS=
%OSR_ECHO% Directory: %buildDirectory%%OSR_ARGS%
%OSR_ECHO% %BASEDIRVAR%: %BASEDIR%

cd /D %~s2
set bFlags=-Ze
set bscFlags=

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ContinueParsing
if "%3" == "" goto :DONE
if "%3" == "/a" goto :RebuildallFound
if /i "%3" == "-WDF" goto :WDFFound
if /i "%3" == "-PREFAST" goto :PrefastFound
set bscFlags=/n
set bFlags=%bFlags% %3
:: Remove next arg
shift
goto :ContinueParsing

:WDFFound
shift
:: Note, that the setwdf.bat is called from setenv.bat in the WDK,
:: therefore we skip it.
if /i "%BASEDIRVAR%" == "WLHBASE" goto :WDFOkay
if "%WDF_ROOT%" == "" call :ShowErrorMsg 2 "%ERR_NoWdfRoot%" & goto :USAGE
pushd .
if exist "%WDF_ROOT%\set_wdf_env.cmd" call "%WDF_ROOT%\set_wdf_env.cmd"
popd
:WDFOkay
goto :ContinueParsing

:PrefastFound
shift
set prefast_build=1
goto :ContinueParsing

:RebuildallFound
shift
set bscFlags=/n
set bFlags=%bFlags:-Ze=-cfeZ%
set bFlags=%bFlags: -cZ=%
goto :ContinueParsing
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:DONE
for %%x in (build%OSR_EXT%.err build%OSR_EXT%.wrn build%OSR_EXT%.log prefast%OSR_EXT%.log) do @(
  if exist "%%x"   del /f /q "%%x"
)

if not "%prefast_build%" == "0" goto :RunPrefastBuild
%OSR_ECHO% Run build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
pushd .
build %mpFlag% %bFlags%
popd
goto :BuildComplete

:RunPrefastBuild
%OSR_ECHO% Run prefast build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
setlocal ENABLEEXTENSIONS & pushd .
set PREFASTLOG=PREfast_defects_%OSR_EXT%.xml
prefast /log=%PREFASTLOG% /reset build %mpFlag% %bFlags% > NUL 2>&1
if "%errorlevel%" GTR "0" set OSR_ERRCODE=%errorlevel%
prefast /log=%PREFASTLOG% list > prefast%OSR_EXT%.log
%OSR_ECHO% The PREfast logfile is ^"%prefastlog%^"!
popd & endlocal

:BuildComplete
if not "%errorlevel%" == "0" set OSR_ERRCODE=%errorlevel%

@echo %OSR_DEBUG%
:: Assume that the onscreen errors are complete!
setlocal
set WARNING_FILE_COUNT=0
if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+1
)
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% ================ Build warnings =======================
  if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set WARNING_FILE_COUNT_PRE=0
if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT_PRE=%WARNING_FILE_COUNT_PRE%+1
)
:: Reset if this is no PREfast build
if "%prefast_build%" == "0" set WARNING_FILE_COUNT_PRE=0
if not "%WARNING_FILE_COUNT_PRE%" == "0" (
  %OSR_ECHO% =============== PREfast warnings ======================
  if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+%WARNING_FILE_COUNT_PRE%
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% =======================================================
)
endlocal
@echo.
%OSR_ECHO% Build complete
%OSR_ECHO% Building browse information files
if exist "buildbrowse.cmd" call "buildbrowse.cmd" & goto :postBuildSteps
set sbrlist=sbrList.txt
if not exist sbrList%CPU%.txt goto :sbrDefault
set sbrlist=sbrList%CPU%.txt

:sbrDefault
if not exist %sbrlist% goto :postBuildSteps
:: Prepend blank space
if not "%bscFlags%" == "" set bscFlags= %bscFlags%
:: bscmake%bscFlags% prevents a double blank space ...
bscmake%bscFlags% @%sbrlist%

:: Perform whatever post-build steps
:postBuildSteps
:: Restore the current directory (after changing into the build directory!)
:: Search upwards for "AFTERPREBUILD" to find the corresponding PUSHD
popd
@if exist "%buildDirectory%\%OSR_POSTBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_POSTBUILD_SCRIPT%" > "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
)
goto :END
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / GetCustomEnvironment
::    First parameter is the "directory" that supposedly contains the SOURCES
::    or DIRS file (and the build scripts)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:GetCustomEnvironment
pushd .
call :CheckTargets "%~f1"
@if not "%OSR_ERRCODE%" == "0" @(
  echo.
  %OSR_ECHO% The target directory seemed to not contain a DIRS or SOURCES file
  %OSR_ECHO% when trying to set a custom environment! Quitting.
  set buildDirectory=%~f1
  if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :GetCustomEnvironment_ret
  call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :GetCustomEnvironment_ret
  goto :GetCustomEnvironment_ret
)
:: If the user provided a script to customize the environment, execute it.
@if exist "%~f1\%OSR_SETENV_SCRIPT%" @(
  %OSR_ECHO% ^>^> Setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
  pushd "%~f1"
  call "%OSR_SETENV_SCRIPT%" > "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_SETENV_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
)
:GetCustomEnvironment_ret
popd
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ GetCustomEnvironment
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / SetMode
::    Subroutine to validate the mode of the build passed in. It must be free,
::    FREE, fre, FRE or checked, CHECKED, chk, CHK. Anything else is an error.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetMode
set BuildMode=
if /i "%OSR_TARGET%" == "WLH2K" goto :SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=free
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=checked
goto :SetModeCommonEnd
:SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=f
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=c
:SetModeCommonEnd
%OSR_TRACE% Mode set to ^"%BuildMode%^"
if "%BuildMode%" == "" set OSR_ERRCODE=5
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ SetMode
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / CheckTargets subroutine
::   Subroutine to validate that the target directory exists and that there is
::   either a DIRS or SOURCES and MakeFile in it.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CheckTargets
:: Building "stack frame"
setlocal & pushd . & set OSR_ERRCODE=0
set lTarget=%~1
if not "%lTarget%" == "" goto :CheckTargets1
set OSR_ERRCODE=7
goto :CheckTargets_ret
:CheckTargets1
if exist "%lTarget%" goto :CheckTargets2
set OSR_ERRCODE=8
goto :CheckTargets_ret
:CheckTargets2
if not exist "%lTarget%\DIRS" goto :CheckTargets3
set OSR_ERRCODE=0
goto :CheckTargets_ret
:CheckTargets3
if exist "%lTarget%\SOURCES" goto :CheckTargets4
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets4
if exist "%lTarget%\MAKEFILE" goto :CheckTargets5
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets5
set OSR_ERRCODE=0
:CheckTargets_ret
:: Cleaning "stack frame" and returning error code into global scope
popd & endlocal & set OSR_ERRCODE=%OSR_ERRCODE%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ CheckTargets subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ResolveVar subroutine
::   There is only one parameter, the name of the variable to be resolved!
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ResolveVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
set VAR_TEMPRET2=%%%VAR_NAME%%%
:ResolveVarLoop
set VAR_TEMPRET1=%VAR_TEMPRET2%
set VAR_TEMPRET2=%VAR_TEMPRET1%
for /f "tokens=*" %%i in ('echo %VAR_TEMPRET1%') do (
  set VAR_TEMPRET2=%%i
)
if not "%VAR_TEMPRET1%" == "%VAR_TEMPRET2%" goto :ResolveVarLoop
:: Re-export the variable out of the local scope
endlocal & set %VAR_NAME%=%VAR_TEMPRET1%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ResolveVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MakeShort subroutine
::   Two parameters. First parameter is the variable name, second is the path
::   to convert into a short filename.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MakeShort
setlocal ENABLEEXTENSIONS
:: Get the name of the variable we are working with and the path to convert
set VAR_NAME=%~1
set PATH_SHORT=%~dpns2
set PATH_EXTSHORT=%~xs2
if not "" == "%PATH_EXTSHORT%" set PATH_EXTSHORT=%PATH_EXTSHORT:~0,4%
set PATH_SHORT=%PATH_SHORT%%PATH_EXTSHORT%
endlocal & set %VAR_NAME%=%PATH_SHORT%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MakeShort subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ErrorWithUsage subroutine
::   This one will take the passed in parameters and build a nice error
::   message which is returned to the user along with the usage hints.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ShowErrorMsg
@set OSR_ERRCODE=%~1
@set OSR_ERRMSG=%~2
@set OSR_ERRMSG=%OSR_ERRMSG:'="%
@set OSR_ERRMSG=ERROR #%OSR_ERRCODE%: %OSR_ERRMSG%
@echo.
%OSR_ECHO% %OSR_ERRMSG%
if DEFINED buildDirectory %OSR_ECHO% -^> Target directory: %buildDirectory%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ErrorWithUsage subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / SetVar subroutine
::   Param1 == name of the variable, Param2 == value to be set for the variable
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
endlocal & set %VAR_NAME%=%~2
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ SetVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectVistaWDK subroutine
::   No parameters expected
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectVistaWDK
setlocal ENABLEEXTENSIONS
:: Newer flag (starting with W2K8) is default
set OSR_AMD64FLAG=x64
:: The Vista WDK accepted *only* "AMD64", the newer W2K8 WDK accepts only "x64"
:: We detect the older one by checking the setenv.bat for a certain string
findstr /C:"Windows Server Longhorn" "%BASEDIR%\bin\setenv.bat" > NUL 2>&1 && set OSR_AMD64FLAG=AMD64
endlocal & set OSR_AMD64FLAG=%OSR_AMD64FLAG%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectVistaWDK subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectBaseDirTemp subroutine
::   The first parameter is the list of directory names to check, separated by
::   blank spaces.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectBaseDirTemp
:: Get the name of the variable we are working with
if "%~1" == "" goto :EOF
setlocal ENABLEEXTENSIONS
call :CommonCheckMsg1
:: Try to find an installed DDK/WDK from the registry keys
if DEFINED OSR_REGAVAILABLE if not "%OSR_REGAVAILABLE%" == "0" (
  for %%i in (%~1) do @(
    call :RegTryBaseDirTemp "%%i"
  )
)
:: Try all the "default" locations
if not DEFINED BASEDIRTEMP (
  for %%i in (%~1) do @(
    for %%a in (WINDDK DDK) do @(
      call :BruteTryBaseDirTemp "%SystemDrive%\%%a\%%i"
      call :BruteTryBaseDirTemp "%ProgramFiles%\%%a\%%i"
    )
  )
)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTemp subroutine
::   Attempt to find the install key in the registry.
::   This functions tests old-style DDKs and new-style WDKs.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
call :RegTryBaseDirTempSingle "%~1" "LFNDirectory" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
call :RegTryBaseDirTempSingle "%~1\Setup" "BUILD" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
if not DEFINED BASEDIRTEMP (endlocal & goto :EOF)
:RegTryBaseDirTemp_EOF
%OSR_ECHO% Found directory (%BASEDIRTEMP%) from install key
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTempSingle subroutine
::   Attempt to find the install key in the registry.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTempSingle
setlocal ENABLEEXTENSIONS
set REGSUBKEY=%~1
set REGVALUE=%~2
set VARIABLETOSET=%~3
set REGMAINKEY=HKLM\SOFTWARE\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_WOW64
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_WOW64
set REGMAINKEY=HKLM\SOFTWARE\Wow6432Node\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_EOF
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_EOF
endlocal
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTempSingle subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / BruteTryBaseDirTemp subroutine
::   Brute-force test the given directory.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:BruteTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
:: We will not overwrite BASETEMPDIR if it has been set and is valid
:: Just try
set BASEDIRTEMP=%~1
%OSR_ECHO% Trying %BASEDIRTEMP% ...
if not exist "%BASEDIRTEMP%" (endlocal & goto :EOF)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ BruteTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Usage output
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:USAGE
@echo.
@echo USAGE:
@echo ======
@echo   %~n0 ^<target^> ^<build type^> ^<directory^> [flags] [-WDF] [-PREFAST]
@echo.
@echo Values for ^<target^>:
@echo    --------------------------------------------------------------------------
@echo     Target platform and OS   ^| Miscellaneous
@echo    --------------------------^|-----------------------------------------------
@echo     Target     ^| Windows     ^| CPU     ^| Base directory ^| Target alias(es)
@echo    ------------^|-------------^|---------^|----------------^|--------------------
@echo     -W2K       ^| 2000        ^| x86     ^| %%W2KBASE%%      ^|
@echo     -W2K64     ^| 2000        ^| Itanium ^| %%W2KBASE%%      ^| -W2KI64
@echo     -WXP       ^| XP          ^| x86     ^| %%WXPBASE%%      ^| -XP
@echo     -WXP64     ^| XP          ^| Itanium ^| %%WXPBASE%%      ^| -WXPI64, -XP64
@echo     -WXP2K     ^| 2000        ^| x86     ^| %%WXPBASE%%      ^| -XPW2K
@echo     -WNET      ^| 2003        ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNET64    ^| 2003        ^| Itanium ^| %%WNETBASE%%     ^| -WNETI64
@echo     -WNETXP    ^| XP          ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNETXP64  ^| XP          ^| Itanium ^| %%WNETBASE%%     ^|
@echo     -WNETAMD64 ^| 2003/XP x64 ^| x64     ^| %%WNETBASE%%     ^| -WNETX64, -WNETA64
@echo     -WNET2K    ^| 2000 SP3    ^| x86     ^| %%WNETBASE%%     ^| -WNETW2K
@echo     -WLH       ^| Vista/2008  ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLH2K     ^| 2000 SP4    ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP     ^| XP          ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP64   ^| XP          ^| Itanium ^| %%WLHBASE%%      ^|
@echo     -WLHNET    ^| 2003        ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHNETI64 ^| 2003        ^| Itanium ^| %%WLHBASE%%      ^| -WLHNET64
@echo     -WLHNETX64 ^| 2003/XP x64 ^| x64     ^| %%WLHBASE%%      ^| -WLHNETA64
@echo     -WLHI64    ^| Vista/2008  ^| Itanium ^| %%WLHBASE%%      ^| -WLH64
@echo     -WLHX64    ^| Vista/2008  ^| x64     ^| %%WLHBASE%%      ^| -WLHA64
@echo     -NT4       ^| NT 4.0      ^| x86     ^| %%NT4BASE%%      ^|
@echo    --------------------------------------------------------------------------
@echo     Support for NT4 and W2K DDKs is deprecated and not checked anymore
@echo     in new versions. It may or may not work properly.
@echo    --------------------------------------------------------------------------
@echo.
@echo Values for ^<build type^>:
@echo       checked, chk     indicates a checked build
@echo       free, fre        indicates a free build
@echo.
@echo Remaining parameters ("opt!" = optional parameter):
@echo       ^<directory^>      path to build directory, try . (current directory)
@echo       [flags]    opt!  any flags you think should be passed to build (try /a
@echo                        for clean)
@echo       -WDF       opt!  performs a WDF build
@echo       -PREFAST   opt!  performs a PREFAST build
@echo.
@echo Special files:
@echo       The build target directory (where the DIRS or SOURCES file resides) can
@echo       contain the following files:
@echo       - %OSR_PREBUILD_SCRIPT%
@echo         Allows to include a step before the BUILD tool from the DDK is called
@echo         but after the environment for the respective DDK has been set!
@echo       - %OSR_POSTBUILD_SCRIPT%
@echo         Allows to include a step after the BUILD tool from the DDK is called,
@echo         so the environment is still available to the script.
@echo       - %OSR_SETENV_SCRIPT%
@echo         Allows to set (or override) _any_ environment variables that may exist
@echo         in the global environment. Thus you can set the base directory for the
@echo         DDK from inside this script, making your project more self-contained.
@echo.
@echo       DDKBUILD will only handle those files which exist, so you may choose to
@echo       use none, one or multiple of these script files.
@echo       (All scripts execute inside their current directory. Consider this!)
@echo.
@echo Examples:
@echo       ^"%~n0 -NT4 checked .^" (for NT4 BUILD)
@echo       ^"%~n0 -WXP64 chk .^"
@echo       ^"%~n0 -WXP chk c:\projects\myproject^"
@echo       ^"%~n0 -WNET64 chk .^"      (IA64 build)
@echo       ^"%~n0 -WNETAMD64 chk .^"   (AMD64/EM64T build)
@echo       ^"%~n0 -WNETXP chk . -cZ -WDF^"
@echo       ^"%~n0 -WNETXP chk . -cZ -PREFAST^"
@echo.
@echo       In order for this procedure to work correctly for each platform, it
@echo       requires an environment variable to be set up for certain platforms.
@echo       There is an auto-detection mechanism in this script, which will work best
@echo       if the DDK/WDK was installed using the normal installer (i.e. not just
@echo       copied). The auto-detection is based on the DDK/WDK for which you request
@echo       a build. Whenever you set the variable explicitly, this will take
@echo       precedence over the auto-detected path!
@echo       The environment variables are as follows:
@echo.
@echo       %%NT4BASE%%  - Set this up for ^"-NT4^" builds
@echo       %%W2KBASE%%  - Set this up for ^"-W2K^" and ^"-W2K64^" builds
@echo       %%WXPBASE%%  - Set this up for ^"-WXP^", ^"-WXP64^", ^"-WXP2K^" builds
@echo       %%WNETBASE%% - Set this up for ^"-WNET*^" builds
@echo       %%WLHBASE%%  - Set this up for ^"-WLH*^" builds
@echo.
@echo       %%WDF_ROOT%% must be set if attempting to do a WDF Build previous to the
@echo       Vista WDK (in later DDKs there is no need to set WDF_ROOT).
@echo.
@echo Path to this script:
@echo      %~f0
@echo.
@echo   %OSR_VERSTR%
@echo   -^> report any problems to ^<info@osr.com^> or ^<http://assarbad.net/contact/^>
@echo.

:END
popd & endlocal & exit /b %OSR_ERRCODE%
```

`InlineHook_ShadowSSDT/ring0/makefile`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

`InlineHook_ShadowSSDT/ring0/mybuild.bat`:

```bat
set WLHBASE=C:\WINDDK\6001.18002
set WDF_ROOT=C:\WINDDK\6001.18002
ddkbuild.cmd -WLHXP chk . -cZ -WDF
```

`InlineHook_ShadowSSDT/ring0/readme.txt`:

```txt
-----------------------
ithurricane [http://hi.baidu.com/ithurricane]
2010/02/04
-----------------------
support WDK7/VS2008
fix Privilege Problem
modify register source

-----------------------
bobo 2009/05/21
-----------------------
ÐÞ¸´bug: VC6 + DDK2003 -> vc6.dsp --> # PROP Cmd_Line "ddkbuild -WNETWXP free ."
         ÐÞ¸Ä: ÔÚddkbuild.cmdÖÐ,¹ØÓÚDDk2003Ã»ÓÐWNETWXP²ÎÊý£¬ÏÖÔÚÔö¼ÓWNETWXP²ÎÊý£¬Ð§¹ûµÈÍ¬ÓÚWNETXP

-----------------------
bobo 2009/05/08
-----------------------
exe:
  1.TestAppÓÉUnicode¸ÄÎªMulti-Byte(ÎªÁËÊ¡ÊÂ,×Ö·ûÆ´½Ó,×¢²á±úÒÁÐ´¶¼ÊÇMulti-Byte°æµÄ), 
      ¼´TestApp.vcprojµÄCharacterSet="1" ¸ÄÎªCharacterSet="2"
  2.TestApp¼ÓÔØºÍÐ¶ÔØsys(modify from MyZwDriverControl.c)£¬ Ã²ËÆ½â¾öÕâ¸öÎÊÌE
	  a.Æô¶¯app,load driver
	  b.°ÑappÇ¿ÖÆ¹ØµE´ËÊ±Ã»ÓÐÕý³£unload driver
	  c.ÔÙÆô¶¯app,´ËÊ±²»»áÔÙ´Îload driver(»òÕßËµÃ»ÓÐloadÊ§°Ü),Ò»ÇÐÕý³£Ê¹ÓÃdriver
	  d.Õý³£ÍË³öapp,unload driver

	  ps: MyZwDriverControl ÓEclass LoadNTDriver(copy from 0ginr.com)ÓÐÇø±ð´¦, 
	      MyZwDriverControlÔÚloadºÍunloadÄÚ,¶¼»á×ö×¢²á±úèúØÓ,É¾³ý¹¤×E
		  class LoadNTDriverµÄloadÄÚÌúØÓ×¢²á±EunloadÄÚÉ¾³ý×¢²á±E
		  MyZwDriverControl¿ÉÒÔLockXxxDatabase.
  3.¼ÓÔØºÍÐ¶ÔØsys¿ÉÒÔÓÃclass LoadNTDriver, ·½·¨¼ELoadNTDriver.h"

sys:
  DriverEntryÀEòÓ¡×¢²á±úÞ·¾¶
  default uIoControlCode Êä³EIoCode
  ËùÓÐº¯ÊýÔö¼Ó·ÖÒ³¡¢·Ç·ÖÒ³ÉùÃE#pragma alloc_text(PAGE, DispatchXX))

-----------------------
bobo 2009/04/27
-----------------------
1.¸÷¸ötarget os»¥³EÖ»ÄÜÑ¡Ò»¸öos
2.¸ù¾ÝDDK°æ±¾£¬ÏÞÖÆOSÑ¡ÔE
3.fix bug : "mybuild.bat" ÄÚµÄ PROJECT_MYBUILD_CMD_LINE ²ÎÊý¸ù¾Ý(DDK + OS)Ð´ËÀ£¬
            DDKÂ·¾¶¶¼ÊÇÄ¬ÈÏµÄ£¬ÔÙ¸ã¸ö¶ÁÐ´Âé·³¸ö¡£

			DDK 2000       --- C:\\NTDDK
			DDK XP         --- C:\\WINDDK\\2600
			DDK 2003       --- C:\\WINDDK\\3790.1830
			WDK 6001.18002 --- C:\\WINDDK\\6001.18002

4.Ö§³ÖWDK + win2008
// todo : 5.Ôö¼Ócheck£¬ freeÑ¡ÔE(mybuild.bat½Å±¾ÀEàÒEÎÊý "chk ." ÓE"fre .")

6.µÚÒ»´ÎÆô¶¯EasySysÊ±£¬»á×Ô¶¯Éè¶¨ÓÃ»§»·¾³±äÁ¿(WXPBASE,WNETBASE...)£¬
  ÕâÊÇ¸ù¾Ý×¢²á±EHKEY_LOCAL_MACHINE -- SOFTWARE\\Microsoft\\WINDDK Éè¶¨DDKÂ·¾¶µÄ¡£
  (ÍòÒ»ÓÃ»§°²×°ÁË¶à¸öDDK£¬ÔÙ¼Ó¸öWDK£¬Õâ¸öÂ·¾¶¾ÍÒªÁúéâÅÐ¶ÏÁË)

  µ«"mybuild.bat"Ò²»áset»·¾³±äÁ¿£¬ËùÒÔÕâÀEäÊµÃ»ÓÃÁË¡£

7.½Å±¾ÃEûÎÎÊý¾ßÌå¿´ "ddkbuild.cmd":: Usage output

-----------------------
bobo 2009/04/23
-----------------------
1.²ÎÕÕMS sample¸ñÊ½ÐÞ¸Ä"sources"

-----------------------.
bobo 2009/04/18
-----------------------
1. Ôö¼Ócommon.h, ÓÃÓÚ¶¨Òåexe¡¢sysµÄ¹²Í¨IOCTL
2. Ôö¼Óconsole APP (for VS2005)¹¤³Ì, ÓÃÓÚ²âÊÔsys. ´ÓÄÄ¸öhello world°áÀ´µÄ.
   (ÕâÑùÖ»ÒªÅäºÏDriverMonitor¾Í¿ÉÒÔ²âÊÔÇý¶¯ÁË)
// todo : 3. ÔÚdsp_proj.htm(VC6)ÀEö¼Óclean±àÒEÎÊý,ÈÃVC6Ê¹ÓÃclean.bat
// todo : 4. Ôö¼ÓMFC APP¹¤³Ì,ÓÃÓÚ²âÊÔsys
5. ÌúØÓÐÞ¸Ä×¢ÊÍ
6.ÐÞ¸Äprintºê£¬¶ÔÓ¦checkºÍfree°æ±¾µÄbuild
  #if DBG
  #define dprintf DbgPrint
  #else
  #define dprintf
  #endif

Ô½Ð´Ô½¸´ÔÓÁË£¬²»easyÁË.....

-----------------------
bobo 2009/04/16
-----------------------
1.OnInitDialog()ÀEö¼ÓOnChangeAuthor()
2.ÐÞ¸ÄOnChangeAuthor()×Ö·û´®
3.ÐÞ¸Ähfile.htm,cfile.htmÀ´ÊÊÓ¦×Ô¼ºÏ°¹ß
-----------------------

bobo 2009/04/10
-----------------------
1.GenerateRandomStrings()µÄnew Ã»ÓÐÊÍ·Å£¬
  ¸ÄÎª¾Ö²¿Êý×EÃû×Ö²»Ì«³¤¾ÍÐÐ,64´óÐ¡)
2.OnInitDialog()ÀEö¼ÓOnSelectIdeType(),³õÊ¼»¯IdeType
				  Ôö¼ÓOnSelchangeDdkVersion(),³õÊ¼»¯DDK type
3.ddkbuild.cmd ¸EÂÎª VERSION=V7.3
4.VC6µÄddkbuild.bat¸ÄÎªddkbuild.cmd
5.ÐÞ¸ÄOnSelchangeDdkVersion()ÄÚµÄDDK2000µÄÂß¼­ÅÐ¶Ï
6.ÔÚVC6µÄdsp.htmÖÐÔö¼Óstruct.h

-----------------------
ChiChou [http://hi.baidu.com/517826104]
2009/02/03
-----------------------

ChiChou ¸ù¾Ý sudamiÐÞ¸Ä°EÖÆ×E

* ÐÞÕýBUG
	1.·Ç³£ÑÏÖØµÄBUG¡­¡­³ÌÐòÍË³öÊ±Ã»ÓÐÒÆ³ýÍÐÅÌÍ¼±ê£¬ÔÚÄ³Ð©»úÆ÷ÉÏÍË³öÊ±
»á±ÀÀ££¨ÖÁÉÙÎÒµÄµçÄÔÊÇÕâÑE- -!£©¡£

	2.Ô­°æ»ñµÃDDKÂ·¾¶Ê±£¬¶ÁÈ¡µÄ×¢²á±úÞ·¾¶Ð´´úÝË£¬µ¼ÖÂÎÞ·¨»ñµÃ DDK µÄ 
Path£¨Ã²ËÆ´óÃ×Ö±½ÓÌûåÏ×Ô¼ÒµÄDDKÂ·¾¶ÁËÖ®¡£¡£Î´ÃâÓÐµã¡£¡£¡££©¡£

	3.Ô­°æÃ»ÓÐ¼Eé¹¤³ÌÃû£¬Èç¹ûÀEæ°E¬·Ç·¨×Ö·û£¬ÄÇÃ´´´½¨¹¤³ÌÄ¿Â¼µÄÊ±ºE
¾Í»á³ö´ú½£ÐÞÕýÊ±Ôö¼Ó¶Ô·Ç·¨×Ö·ûµÄcheck¹¦ÄÜ¡£°E¨£º/\|"<>*?:

	4.»¹ÓÐÒ»¸öBUGÃ»ÓÐÐÞ¸´¡£Èç¹ûÔÚ¹¤³ÌÃûÖÐÌûäEÎÈç¡°project..¡±µÄÃû³ÆÊ±£¬
Ò²»áÒý·¢ÎÄ¼þ·ÃÎÊ´úêó¡£µ«ÊÇÎÒÃ»ÓÐ°E¨ÐÞ¸´¡­¡­Õâ¸ö×Ö·û´®µÄÅÐ¶ÏÓÐµãÄÑ¶È¡£¡£
Ë®Æ½µÍÁÓ¡£¡£(- -...)

* ÃÀ»¯½çÃE
	1.°Ñ´óÃ×ÅªµÄ XPBUTTON ¸øÈ¥µôÁË...Í¼±àÒEÙ¶È¡£
	2.È»ºóPÁËÕÅ±³¾°Í¼£¬·ÅÔÚÖ÷½çÃæ£¬»¹ÂùºÃ¿´µÄ~~
	3.Ï°¹ßÐÔµÄ XP Manifest ´¦ÀúëÂ¡£

* ÐÞ¸ÄÄ£°E
	1.¸ù¾Ý¸öÈËÏ²ºÃ´úÂEÄ¸ñÊ½ÐÞ¸ÄÁËÏÂ~
	2.Ë³±ã°Ñ¡¶ÌEéÒ¹¶Á¡·ÀEæ¿´µ½µÄÄ³¸ö¶«Î÷£¨ÅÐ¶Ï·ûºÅÁ´½ÓÓÃ»§Ïà¹ØÐÔÈ»ºE
´´½¨²»Í¬µÄÉè±¸·ûºÅÃû£©¼ÓÁË½øÈ¥¡­¡­

* ÍEÆ¹¦ÄÜ
	1.sudami°æµÄÓÐµãÂé·³£¬ÍË³ö³ÌÐò»¹ÒªµãÍÐÅÌ¡£Ö±½ÓÔÚÖ÷½çÃæÉèÖÃÁËÍË³ö°´
Å¥¡£
	2.¹¤³Ì´´½¨Ö®ºóEasySYS»ù±¾Ã»ÓÃ´¦ÁË£¬±ãÔö¼ÓÁË¡°ÍEÉºóÍË³ö¡±Ñ¡Ïû›
	3.Éú³É¹¤³Ìºó¿ÉÒÔÔ´ÂEÐÌúØÓÈÕÆÚ¡¢×÷ÕßµÈÐÅÏ¢¡£
	4.Éú³É¹¤³ÌºóµÄ²Ù×÷Ò²ÊÇ¿ÉÑ¡µÄ¡£¿ÉÒÔÑ¡Ôñ×Ô¶¯´ò¿ª¹¤³ÌÎÄ¼þ¡¢¹¤³ÌÄ¿Â¼¡£
	5.Ôö¼ÓClean¹¦ÄÜ~~~
-----------------------


-----------------------
sudami [sudami@163.com]
2008/08/13
-----------------------

	VS 2005ÏÂÐ´Çý¶¯±ÈVC 6.0·½±ãºÜ¶Eµ«ºÃ¶àEasySYS°æ±¾(Include DIY)¶¼Ö»
Ö§³ÖVC 6.0.½ñ¶ùÔçÉÏÔÚVBGOODÂÛÌ³¿´µ½IceBoyÐ¡Í¬Ñ§ÓÃVBÐ´ÁË¸öÖ§³Övs 2005µÄ
demo.ÓÚÊÇ,°³Ò²ÊÔ×ÅÐ´¸öÊÊÓÃÓÚ×Ô¼ºµÄ¹¤¾ß,·½±ãÒÔºó¿EÙµÄ¿ª·¢Çý¶¯³ÌÐE

	¹þ¹þ,Ö÷ÒªÊÇ·½±ã×Ô¼ºÐ´code,¹ÊÉú³ÉµÄcode·ç¸ñ¶¼ÊÇ°´ÕÕ×Ô¼ºµÄÒâÔ¸À´°²ÅÅ
µÎ...

-----------------------

```

`InlineHook_ShadowSSDT/ring0/sources`:

```
TARGETNAME=InlineHookSSSDT
#TARGETPATH=$(BASEDIR)\lib
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=.\

SOURCES=InlineHookSSSDT.c


```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "InlineHookSSSDT应用程序", "InlineHookSSSDT应用程序\InlineHookSSSDT应用程序.vcxproj", "{03D87002-4439-4130-B570-6D696846B780}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{03D87002-4439-4130-B570-6D696846B780}.Debug|Win32.ActiveCfg = Debug|Win32
		{03D87002-4439-4130-B570-6D696846B780}.Debug|Win32.Build.0 = Debug|Win32
		{03D87002-4439-4130-B570-6D696846B780}.Debug|x64.ActiveCfg = Debug|x64
		{03D87002-4439-4130-B570-6D696846B780}.Debug|x64.Build.0 = Debug|x64
		{03D87002-4439-4130-B570-6D696846B780}.Release|Win32.ActiveCfg = Release|Win32
		{03D87002-4439-4130-B570-6D696846B780}.Release|Win32.Build.0 = Release|Win32
		{03D87002-4439-4130-B570-6D696846B780}.Release|x64.ActiveCfg = Release|x64
		{03D87002-4439-4130-B570-6D696846B780}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序.cpp`:

```cpp

// InlineHookSSSDT应用程序.cpp : 定义应用程序的类行为。
//

#include "stdafx.h"
#include "InlineHookSSSDT应用程序.h"
#include "InlineHookSSSDT应用程序Dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CInlineHookSSSDT应用程序App

BEGIN_MESSAGE_MAP(CInlineHookSSSDT应用程序App, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CInlineHookSSSDT应用程序App 构造

CInlineHookSSSDT应用程序App::CInlineHookSSSDT应用程序App()
{
	// 支持重新启动管理器
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: 在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的一个 CInlineHookSSSDT应用程序App 对象

CInlineHookSSSDT应用程序App theApp;


// CInlineHookSSSDT应用程序App 初始化

BOOL CInlineHookSSSDT应用程序App::InitInstance()
{
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

	CInlineHookSSSDT应用程序Dlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	}

	// 删除上面创建的 shell 管理器。
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}

	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
	//  而不是启动应用程序的消息泵。
	return FALSE;
}


```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序.h`:

```h

// InlineHookSSSDT应用程序.h : PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
	#error "在包含此文件之前包含“stdafx.h”以生成 PCH 文件"
#endif

#include "resource.h"		// 主符号


// CInlineHookSSSDT应用程序App:
// 有关此类的实现，请参阅 InlineHookSSSDT应用程序.cpp
//

class CInlineHookSSSDT应用程序App : public CWinApp
{
public:
	CInlineHookSSSDT应用程序App();

// 重写
public:
	virtual BOOL InitInstance();

// 实现

	DECLARE_MESSAGE_MAP()
};

extern CInlineHookSSSDT应用程序App theApp;
```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\InlineHookSSSDT.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\InlineHookSSSDT应用程序.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 InlineHookSSSDT应用程序"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "InlineHookSSSDT应用程序，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2015",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_INLINEHOOKSSSDT_DIALOG DIALOGEX 0, 0, 320, 109
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CAPTION "InlineHookSSSDT应用程序"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    PUSHBUTTON      "保护自己",IDC_BUTTON_PROTECT,203,88,50,14
    PUSHBUTTON      "取消保护",IDC_BUTTON_UNPROTECT,263,88,50,14
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404B0"
        BEGIN
            VALUE "CompanyName", "TODO: <公司名>"
            VALUE "FileDescription", "InlineHookSSSDT应用程序"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "InlineHookSSSDT应用程序.exe"
            VALUE "LegalCopyright", "TODO: (C) <公司名>。保留所有权利。"
            VALUE "OriginalFilename", "InlineHookSSSDT应用程序.exe"
            VALUE "ProductName", "TODO: <产品名>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_INLINEHOOKSSSDT_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 313
        TOPMARGIN, 7
        BOTTOMMARGIN, 102
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 InlineHookSSSDT应用程序(&A)..."
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\InlineHookSSSDT.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{03D87002-4439-4130-B570-6D696846B780}</ProjectGuid>
    <RootNamespace>InlineHookSSSDT应用程序</RootNamespace>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\InlineHookSSSDT.rc2" />
    <None Include="res\InlineHookSSSDT应用程序.ico" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="InlineHookSSSDT应用程序.h" />
    <ClInclude Include="InlineHookSSSDT应用程序Dlg.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="InlineHookSSSDT应用程序.cpp" />
    <ClCompile Include="InlineHookSSSDT应用程序Dlg.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="InlineHookSSSDT应用程序.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="InlineHookSSSDT应用程序.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\InlineHookSSSDT.rc2">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\InlineHookSSSDT应用程序.ico">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="InlineHookSSSDT应用程序.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="InlineHookSSSDT应用程序Dlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="InlineHookSSSDT应用程序.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="InlineHookSSSDT应用程序Dlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="InlineHookSSSDT应用程序.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序Dlg.cpp`:

```cpp

// InlineHookSSSDT应用程序Dlg.cpp : 实现文件
//

#include "stdafx.h"
#include "InlineHookSSSDT应用程序.h"
#include "InlineHookSSSDT应用程序Dlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框
HANDLE  g_hDevice = NULL;
class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CInlineHookSSSDT应用程序Dlg 对话框




CInlineHookSSSDT应用程序Dlg::CInlineHookSSSDT应用程序Dlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(CInlineHookSSSDT应用程序Dlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	m_bHook = FALSE;
}

void CInlineHookSSSDT应用程序Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CInlineHookSSSDT应用程序Dlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_PROTECT, &CInlineHookSSSDT应用程序Dlg::OnBnClickedButtonProtect)
	ON_BN_CLICKED(IDC_BUTTON_UNPROTECT, &CInlineHookSSSDT应用程序Dlg::OnBnClickedButtonUnprotect)
	ON_WM_CLOSE()
END_MESSAGE_MAP()


// CInlineHookSSSDT应用程序Dlg 消息处理程序

BOOL CInlineHookSSSDT应用程序Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CInlineHookSSSDT应用程序Dlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CInlineHookSSSDT应用程序Dlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CInlineHookSSSDT应用程序Dlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



void CInlineHookSSSDT应用程序Dlg::OnBnClickedButtonProtect()
{
	if (m_bHook==FALSE)
	{
		g_hDevice = OpenDevice(L"\\\\.\\InlineHookSSSDTLink");

		if (g_hDevice==(HANDLE)-1)
		{
			MessageBox(L"打开设备失败");

			return;
		}

		if(SendIoControlCode(INITILIZE)==FALSE)
		{


			CloseHandle(g_hDevice);
			return;
		}


		if(SendIoControlCode(HOOK)==FALSE)
		{


			CloseHandle(g_hDevice);
			return;
		}

		CloseHandle(g_hDevice);

		m_bHook = TRUE;
	}
}


void CInlineHookSSSDT应用程序Dlg::OnBnClickedButtonUnprotect()
{
	if (m_bHook==TRUE)
	{
		g_hDevice = OpenDevice(L"\\\\.\\InlineHookSSSDTLink");

		if (g_hDevice==(HANDLE)-1)
		{
			MessageBox(L"打开设备失败");

			return;
		}

		if(SendIoControlCode(UNHOOK)==FALSE)
		{

			CloseHandle(g_hDevice);
			return;
		}

		CloseHandle(g_hDevice);


		m_bHook = FALSE;
	}

}


void CInlineHookSSSDT应用程序Dlg::OnClose()
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	OnBnClickedButtonUnprotect();

	CDialogEx::OnClose();
}

BOOL CInlineHookSSSDT应用程序Dlg::SendIoControlCode(ULONG_PTR ulControlCode)
{
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	if (ulControlCode==INITILIZE)
	{
		bRet = DeviceIoControl(g_hDevice,IOCTL_GET_SSSDTSERVERICE,
			NULL,
			NULL,
			NULL,
			NULL,
			&ulReturnSize,
			NULL);

		if (bRet==FALSE)
		{
			return FALSE;
		}


	}

	if (ulControlCode==HOOK)
	{

		bRet = DeviceIoControl(g_hDevice,IOCTL_INLINEHOOK_SSSDT,
			NULL,
			NULL,
			NULL,
			NULL,
			&ulReturnSize,
			NULL);

		if (bRet==FALSE)
		{
			return FALSE;
		}
	}


	if (ulControlCode==UNHOOK)
	{

		bRet = DeviceIoControl(g_hDevice,IOCTL_INLINEUNHOOK_SSSDT,
			NULL,
			NULL,
			NULL,
			NULL,
			&ulReturnSize,
			NULL);

		if (bRet==FALSE)
		{
			return FALSE;
		}
	}



	return TRUE;
}

```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/InlineHookSSSDT应用程序Dlg.h`:

```h

// InlineHookSSSDT应用程序Dlg.h : 头文件
//

#pragma once

#include <WinIoCtl.h>


#define INITILIZE  20
#define  HOOK  10
#define  UNHOOK 30


#define IOCTL_GET_SSSDTSERVERICE	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INLINEHOOK_SSSDT \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_INLINEUNHOOK_SSSDT \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x831,METHOD_BUFFERED,FILE_ANY_ACCESS)
// CInlineHookSSSDT应用程序Dlg 对话框
class CInlineHookSSSDT应用程序Dlg : public CDialogEx
{
// 构造
public:
	BOOL m_bHook;
	BOOL CInlineHookSSSDT应用程序Dlg::SendIoControlCode(ULONG_PTR ulControlCode);
	CInlineHookSSSDT应用程序Dlg(CWnd* pParent = NULL);	// 标准构造函数
	HANDLE CInlineHookSSSDT应用程序Dlg::OpenDevice(LPCTSTR wzLinkPath)
	{
		HANDLE hDevice = CreateFile(wzLinkPath,
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL);

		if (hDevice == INVALID_HANDLE_VALUE)
		{

		}

		return hDevice;

	}
// 对话框数据
	enum { IDD = IDD_INLINEHOOKSSSDT_DIALOG };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedButtonProtect();
	afx_msg void OnBnClickedButtonUnprotect();
	afx_msg void OnClose();
};

```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/ReadMe.txt`:

```txt
================================================================================
MICROSOFT 基础类库: InlineHookSSSDT应用程序 项目概述
===============================================================================

应用程序向导已为您创建了这个 InlineHookSSSDT应用程序 应用程序。此应用程序不仅演示 Microsoft 基础类的基本使用方法，还可作为您编写应用程序的起点。

本文件概要介绍组成 InlineHookSSSDT应用程序 应用程序的每个文件的内容。

InlineHookSSSDT应用程序.vcxproj
这是使用应用程序向导生成的 VC++ 项目的主项目文件。 
它包含生成该文件的 Visual C++ 的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

InlineHookSSSDT应用程序.vcxproj.filters
    这是使用“应用程序向导”生成的 VC++ 项目筛选器文件。
    它包含有关项目文件与筛选器之间的关联信息。在 IDE 中，通过这种关联，在特定节点下以分组形式显示具有相似扩展名的文件。例如，“.cpp”文件与“源文件”筛选器关联。

InlineHookSSSDT应用程序.h
这是应用程序的主要头文件。它包括其他项目特定的头文件(包括 Resource.h)，并声明 CInlineHookSSSDT应用程序App 应用程序类。

InlineHookSSSDT应用程序.cpp
这是包含应用程序类 CInlineHookSSSDT应用程序App 的主要应用程序源文件。

InlineHookSSSDT应用程序.rc
这是程序使用的所有 Microsoft Windows 资源的列表。它包括 RES 子目录中存储的图标、位图和光标。此文件可以直接在 Microsoft Visual C++ 中进行编辑。项目资源位于 2052 中。

res\InlineHookSSSDT应用程序.ico
这是用作应用程序图标的图标文件。此图标包括在主要资源文件 InlineHookSSSDT应用程序.rc 中。

res\InlineHookSSSDT.rc2
此文件包含不在 Microsoft Visual C++ 中进行编辑的资源。您应该将不可由资源编辑器编辑的所有资源放在此文件中。


/////////////////////////////////////////////////////////////////////////////

应用程序向导创建一个对话框类:

InlineHookSSSDT应用程序Dlg.h，InlineHookSSSDT应用程序Dlg.cpp - 对话框
这些文件包含 CInlineHookSSSDT应用程序Dlg 类。该类定义应用程序主对话框的行为。该对话框的模板位于 InlineHookSSSDT应用程序.rc 中，该文件可以在 Microsoft Visual C++ 中进行编辑。


/////////////////////////////////////////////////////////////////////////////

其他功能:

ActiveX 控件
应用程序包括对使用 ActiveX 控件的支持。

打印及打印预览支持
应用程序向导已通过从 MFC 库调用 CView 类中的成员函数，生成了用于处理打印、打印设置和打印预览命令的代码。

/////////////////////////////////////////////////////////////////////////////

其他标准文件:

StdAfx.h，StdAfx.cpp
这些文件用于生成名为 InlineHookSSSDT应用程序.pch 的预编译头 (PCH) 文件和名为 StdAfx.obj 的预编译类型文件。

Resource.h
这是标准头文件，它定义新的资源 ID。
Microsoft Visual C++ 读取并更新此文件。

InlineHookSSSDT应用程序.manifest
	应用程序清单文件供 Windows XP 用来描述应用程序
	对特定版本并行程序集的依赖性。加载程序使用此
	信息从程序集缓存加载适当的程序集或
	从应用程序加载私有信息。应用程序清单可能为了重新分发而作为
	与应用程序可执行文件安装在相同文件夹中的外部 .manifest 文件包括，
	也可能以资源的形式包括在该可执行文件中。 
/////////////////////////////////////////////////////////////////////////////

其他注释:

应用程序向导使用“TODO:”指示应添加或自定义的源代码部分。

如果应用程序在共享的 DLL 中使用 MFC，则需要重新发布这些 MFC DLL；如果应用程序所用的语言与操作系统的当前区域设置不同，则还需要重新发布对应的本地化资源 MFC100XXX.DLL。有关这两个主题的更多信息，请参见 MSDN 文档中有关 Redistributing Visual C++ applications (重新发布 Visual C++ 应用程序)的章节。

/////////////////////////////////////////////////////////////////////////////

```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/res/InlineHookSSSDT.rc2`:

```rc2
//
// InlineHookSSSDT.RC2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by InlineHookSSSDT应用程序.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_INLINEHOOKSSSDT_DIALOG      102
#define IDR_MAINFRAME                   128
#define IDC_BUTTON_PROTECT              1000
#define IDC_BUTTON2                     1001
#define IDC_BUTTON_UNPROTECT            1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/stdafx.cpp`:

```cpp

// stdafx.cpp : 只包括标准包含文件的源文件
// InlineHookSSSDT应用程序.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"



```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/stdafx.h`:

```h

// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件

#pragma once

#ifndef _SECURE_ATL
#define _SECURE_ATL 1
#endif

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // 功能区和控件条的 MFC 支持









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`InlineHook_ShadowSSDT/ring3/InlineHookSSSDT应用程序/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义最高版本的可用 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`README.md`:

```md
# Ark-tools
Windows Ark 工具的工程和一些demo

##文件结构
* DpcTimer_X64：Windows x64 下枚举DCP定时器的小demo,之前有在看雪放出；
* DrxHook：利用调试寄存器来达到hook的目的；
* HideIDTHook：hook IDT,一种是直接hook，一种是通过修改GDT表来实现；
* Inject_By_kernelAPC：内核apc注入；
* InlineHook_ShadowSSDT：inline hook Shadow SSDT；
* Register：注册表编辑器，和regedit.exe功能类似，通过驱动实现；
* Wow64Injectx64：32位进程注入64位进程；
* arkProject：ark工具的完整项目源码；

```

`Register/ReadMe.md`:

```md
##注册表编辑器
和Windows自带的注册表编辑器功能呢一样，不过整个功能性代码的实现是在驱动层实现，
直接用WDK7600命令行编译即可，兼容Windows 7 X64 SP1和Windows XP SP 3。
没有签名，因此在Win7 下测试的时候需要打开WinDBG调试器，抑制内核强制签名。
```

`Register/RegisterManager/RegisterManager.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RegisterManager", "RegisterManager\RegisterManager.vcxproj", "{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Debug|Win32.ActiveCfg = Debug|Win32
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Debug|Win32.Build.0 = Debug|Win32
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Debug|x64.ActiveCfg = Debug|x64
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Debug|x64.Build.0 = Debug|x64
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Release|Win32.ActiveCfg = Release|Win32
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Release|Win32.Build.0 = Release|Win32
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Release|x64.ActiveCfg = Release|x64
		{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Register/RegisterManager/RegisterManager/KeyDlg.cpp`:

```cpp
// KeyDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "RegisterManager.h"
#include "KeyDlg.h"
#include "afxdialogex.h"


// CKeyDlg 对话框

IMPLEMENT_DYNAMIC(CKeyDlg, CDialog)

CKeyDlg::CKeyDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CKeyDlg::IDD, pParent)
	, m_strKeyNameStatic(_T(""))
	, m_strKeyNameEdit(_T(""))
{

}

CKeyDlg::~CKeyDlg()
{
}

void CKeyDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_KEY_NAME, m_strKeyNameStatic);
	DDX_Text(pDX, IDC_EDIT, m_strKeyNameEdit);
}


BEGIN_MESSAGE_MAP(CKeyDlg, CDialog)
END_MESSAGE_MAP()


// CKeyDlg 消息处理程序


BOOL CKeyDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	switch (m_nDlgType)
	{
	case enumRenameKey:
		SetWindowText(L"重命名键");
		m_strKeyNameStatic = L"新键名";
		break;

	case enumRenameValue:
		SetWindowText(L"重命名键值");
		m_strKeyNameStatic = L"新键值";
		break;

	case enumCreateKey:
		SetWindowText(L"创建新键");
		m_strKeyNameStatic = L"新键名";
		break;

	case enumSetValueKey:
		SetWindowText(L"创建新值");
		m_strKeyNameStatic = L"新键值";
		break;
	}

	UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}

```

`Register/RegisterManager/RegisterManager/KeyDlg.h`:

```h
#pragma once


// CKeyDlg 对话框


typedef enum DLG_TYPE
{
	enumRenameKey,
	enumCreateKey,
	enumSetValueKey,
	enumRenameValue,
};
class CKeyDlg : public CDialog
{
	DECLARE_DYNAMIC(CKeyDlg)

public:
	CKeyDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CKeyDlg();

	DLG_TYPE m_nDlgType;
	
	
// 对话框数据
	enum { IDD = IDD_KEY_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	CString m_strKeyNameStatic;
	CString m_strKeyNameEdit;
	virtual BOOL OnInitDialog();
};

```

`Register/RegisterManager/RegisterManager/ReadMe.txt`:

```txt
================================================================================
MICROSOFT 基础类库: RegisterManager 项目概述
===============================================================================

应用程序向导已为您创建了这个 RegisterManager 应用程序。此应用程序不仅演示 Microsoft 基础类的基本使用方法，还可作为您编写应用程序的起点。

本文件概要介绍组成 RegisterManager 应用程序的每个文件的内容。

RegisterManager.vcxproj
这是使用应用程序向导生成的 VC++ 项目的主项目文件。 
它包含生成该文件的 Visual C++ 的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

RegisterManager.vcxproj.filters
    这是使用“应用程序向导”生成的 VC++ 项目筛选器文件。
    它包含有关项目文件与筛选器之间的关联信息。在 IDE 中，通过这种关联，在特定节点下以分组形式显示具有相似扩展名的文件。例如，“.cpp”文件与“源文件”筛选器关联。

RegisterManager.h
这是应用程序的主要头文件。它包括其他项目特定的头文件(包括 Resource.h)，并声明 CRegisterManagerApp 应用程序类。

RegisterManager.cpp
这是包含应用程序类 CRegisterManagerApp 的主要应用程序源文件。

RegisterManager.rc
这是程序使用的所有 Microsoft Windows 资源的列表。它包括 RES 子目录中存储的图标、位图和光标。此文件可以直接在 Microsoft Visual C++ 中进行编辑。项目资源位于 2052 中。

res\RegisterManager.ico
这是用作应用程序图标的图标文件。此图标包括在主要资源文件 RegisterManager.rc 中。

res\RegisterManager.rc2
此文件包含不在 Microsoft Visual C++ 中进行编辑的资源。您应该将不可由资源编辑器编辑的所有资源放在此文件中。


/////////////////////////////////////////////////////////////////////////////

应用程序向导创建一个对话框类:

RegisterManagerDlg.h，RegisterManagerDlg.cpp - 对话框
这些文件包含 CRegisterManagerDlg 类。该类定义应用程序主对话框的行为。该对话框的模板位于 RegisterManager.rc 中，该文件可以在 Microsoft Visual C++ 中进行编辑。


/////////////////////////////////////////////////////////////////////////////

其他功能:

ActiveX 控件
应用程序包括对使用 ActiveX 控件的支持。

打印及打印预览支持
应用程序向导已通过从 MFC 库调用 CView 类中的成员函数，生成了用于处理打印、打印设置和打印预览命令的代码。

/////////////////////////////////////////////////////////////////////////////

其他标准文件:

StdAfx.h，StdAfx.cpp
这些文件用于生成名为 RegisterManager.pch 的预编译头 (PCH) 文件和名为 StdAfx.obj 的预编译类型文件。

Resource.h
这是标准头文件，它定义新的资源 ID。
Microsoft Visual C++ 读取并更新此文件。

RegisterManager.manifest
	应用程序清单文件供 Windows XP 用来描述应用程序
	对特定版本并行程序集的依赖性。加载程序使用此
	信息从程序集缓存加载适当的程序集或
	从应用程序加载私有信息。应用程序清单可能为了重新分发而作为
	与应用程序可执行文件安装在相同文件夹中的外部 .manifest 文件包括，
	也可能以资源的形式包括在该可执行文件中。 
/////////////////////////////////////////////////////////////////////////////

其他注释:

应用程序向导使用“TODO:”指示应添加或自定义的源代码部分。

如果应用程序在共享的 DLL 中使用 MFC，则需要重新发布这些 MFC DLL；如果应用程序所用的语言与操作系统的当前区域设置不同，则还需要重新发布对应的本地化资源 MFC100XXX.DLL。有关这两个主题的更多信息，请参见 MSDN 文档中有关 Redistributing Visual C++ applications (重新发布 Visual C++ 应用程序)的章节。

/////////////////////////////////////////////////////////////////////////////

```

`Register/RegisterManager/RegisterManager/RegFindDlg.cpp`:

```cpp
// RegFindDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "RegisterManager.h"
#include "RegFindDlg.h"
#include "afxdialogex.h"
#include "RegisterManagerDlg.h"

// CRegFindDlg 对话框

IMPLEMENT_DYNAMIC(CRegFindDlg, CDialog)

#define  WM_SEARCH_FINISH   WM_USER + 105
#define  WM_UPDATE_UI		WM_USER + 106


extern CWnd*  g_Father;

DWORD WINAPI SearchRegistryProc(PVOID lPParam)
{
	if (lPParam)
	{
		CRegFindDlg *Dlg = (CRegFindDlg*)lPParam;
		Dlg->SearchRegistry();
	}

	return 0;
}

CRegFindDlg::CRegFindDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRegFindDlg::IDD, pParent)
	, m_strSearchInKey(_T(""))
	, m_nRadio(0)
	, m_strFindWhat(_T(""))
	, m_bKeys(TRUE)
	, m_bMachCase(FALSE)
	, m_bMachWholeString(FALSE)
	, m_bData(TRUE)
	, m_bValues(TRUE)
	, m_strSearchResult(_T(""))
{
	m_strFindWhatUpper = L"";
	m_nCnt = 0;
	m_bStop = FALSE;
	m_hThread = NULL;

}

CRegFindDlg::~CRegFindDlg()
{
}

void CRegFindDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST, m_List);
	DDX_Text(pDX, IDC_EDIT, m_strSearchInKey);
	DDX_Radio(pDX, IDC_RADIO_SEARCH_IN, m_nRadio);
	DDX_Text(pDX, IDC_EDIT_FIND_WHAT, m_strFindWhat);
	DDX_Check(pDX, IDC_CHECK_KEY, m_bKeys);
	DDX_Check(pDX, IDC_CHECK_MACH_CASE, m_bMachCase);
	DDX_Check(pDX, IDC_CHECK_MACH_WHOLE_STRING, m_bMachWholeString);
	DDX_Check(pDX, IDC_CHECK_DATA, m_bData);
	DDX_Check(pDX, IDC_CHECK_VALUES, m_bValues);
	DDX_Text(pDX, IDC_STATIC_FIND_RESULT, m_strSearchResult);
	DDX_Control(pDX, IDC_ANIMATE, m_ctlAnimate);
}


BEGIN_MESSAGE_MAP(CRegFindDlg, CDialog)
	
	ON_BN_CLICKED(IDC_BUTTON_START, &CRegFindDlg::OnBnClickedButtonStart)
	ON_MESSAGE(WM_UPDATE_UI, &CRegFindDlg::UpdateUI)
	ON_BN_CLICKED(IDC_BUTTON_STOP, &CRegFindDlg::OnBnClickedButtonStop)
	ON_WM_CLOSE()
	ON_NOTIFY(NM_DBLCLK, IDC_LIST, &CRegFindDlg::OnNMDblclkList)
END_MESSAGE_MAP()


// CRegFindDlg 消息处理程序
LRESULT CRegFindDlg::UpdateUI(WPARAM, LPARAM)
{
	UpdateData(FALSE);
	return 0;
}

BOOL CRegFindDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_ctlAnimate.Open(IDR_AVI);//载入AVI文件
	m_List.SetExtendedStyle(LVS_EX_FULLROWSELECT);
	m_List.InsertColumn(0,L"键", LVCFMT_LEFT, 300);
	m_List.InsertColumn(1,L"键值", LVCFMT_LEFT, 80);
	m_List.InsertColumn(2,L"数据", LVCFMT_LEFT, 120);


	m_strSearchInKey.IsEmpty() ? m_nRadio = 1 : m_nRadio = 0;     //注意控件的属性设置
	GetDlgItem(IDC_EDIT)->EnableWindow(!m_nRadio);
	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}





void CRegFindDlg::OnBnClickedButtonStart()
{
	UpdateData(TRUE);
	m_List.DeleteAllItems();

	// 判断搜索条件是否已经填写
	if (m_strFindWhat.IsEmpty())
	{
		MessageBox(L"输入查找内容",L"Shine", MB_OK | MB_ICONWARNING);
		return;
	}

	// 如果是在某个键值中查询
	if (m_nRadio == 0)
	{
		//	首先判断是否填写
		if (m_strSearchInKey.IsEmpty())
		{
			MessageBox(L"输入查找范围", L"Shine", MB_OK | MB_ICONWARNING);
			return;
		}

		// 判断根键是否存在
		HKEY hKey = GetRootKey(m_strSearchInKey);
		if (!hKey)
		{
			MessageBox(L"根键不存在",L"Shine", MB_OK | MB_ICONERROR);
			return;
		}

		// 判断能否打开该键
		CString strSubKey;
		if (m_strSearchInKey.Find('\\') != -1)
		{
			strSubKey = m_strSearchInKey.Right(m_strSearchInKey.GetLength() - m_strSearchInKey.Find('\\') - 1);
		}
		HKEY hKeyTemp = NULL;
		LONG ulRet = RegOpenKeyEx(hKey, strSubKey, 0, KEY_READ, &hKeyTemp);

		if (ERROR_SUCCESS != ulRet)
		{
			MessageBox(L"不能打开该键值", L"Shine", MB_OK | MB_ICONERROR);
			return;
		}

		RegCloseKey(hKeyTemp);
	}

	// 保存一份大写字母的查找内容,如果查找忽略大小写,就可以使用这份了
	m_strFindWhatUpper = m_strFindWhat;
	m_strFindWhatUpper.MakeUpper();

	// 通过了前面的检查，开始搜索
	InitControl(FALSE);   //锁定控件

	if (m_hThread)
	{
		CloseHandle(m_hThread);
		m_hThread = NULL;
	}
	DWORD dwTid = 0;
	m_hThread = CreateThread(NULL, 0, SearchRegistryProc, this, 0, &dwTid);
}



HKEY CRegFindDlg::GetRootKey(CString strKey)
{
	HKEY hRet = NULL;

	if (strKey.IsEmpty())
	{
		return hRet;
	}

	CString strKeyRoot;
	if (strKey.Find('\\') != -1)
	{
		strKeyRoot = strKey.Left(strKey.Find('\\'));
	}
	else
	{
		strKeyRoot = strKey;
	}

	if (!strKeyRoot.CompareNoCase(L"HKEY_CLASSES_ROOT"))
	{
		hRet = HKEY_CLASSES_ROOT;
	}
	else if (!strKeyRoot.CompareNoCase(L"HKEY_CURRENT_USER"))
	{
		hRet = HKEY_CURRENT_USER;
	}
	else if (!strKeyRoot.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
	{
		hRet = HKEY_LOCAL_MACHINE;
	}
	else if (!strKeyRoot.CompareNoCase(L"HKEY_USERS"))
	{
		hRet = HKEY_USERS;
	}
	else if (!strKeyRoot.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
	{
		hRet = HKEY_CURRENT_CONFIG;
	}

	return hRet;
}


VOID CRegFindDlg::SearchRegistry()
{
	m_bStop = FALSE;
	m_nCnt = 0;
	m_strSearchResult = L"正在查询";
   	SendMessage(WM_UPDATE_UI);



	// 搜索指定键
	if (m_nRadio == 0)
	{
		HKEY hKey = GetRootKey(m_strSearchInKey);
		CString strSubKey;
		if (m_strSearchInKey.Find('\\') != -1)
		{
			strSubKey = m_strSearchInKey.Right(m_strSearchInKey.GetLength() - m_strSearchInKey.Find('\\') - 1);
		}

		EnumKeys(hKey, strSubKey);
	}

	// 搜索整个注册表
	else
	{
		m_ctlAnimate.Play(0,-1,-1);//播放动画
		EnumKeys(HKEY_CLASSES_ROOT, NULL);
		EnumKeys(HKEY_CURRENT_USER, NULL);
		EnumKeys(HKEY_LOCAL_MACHINE, NULL);
		EnumKeys(HKEY_USERS, NULL);
		EnumKeys(HKEY_CURRENT_CONFIG, NULL);
		m_ctlAnimate.Stop();//停止播放
	
	}

	InitControl(TRUE);
	m_strSearchResult.Format(L"共查询到%d匹配项", m_nCnt);

	SendMessage(WM_UPDATE_UI);

//	SendMessage(WM_SEARCH_FINISH);
}



void CRegFindDlg::EnumKeys(HKEY hRoot, CString strSubKey)
{
	if (!hRoot)
	{
		return;
	}

	strSubKey.TrimLeft('\\');
	HKEY hKeyTemp = NULL;
	LONG nRet = RegOpenKeyEx(hRoot, strSubKey, 0, KEY_READ, &hKeyTemp);
	if (nRet != ERROR_SUCCESS)
	{
		return;
	}

	DWORD dwSubKeys = 0, dwSubValues = 0;
	LONG ulRet = ::RegQueryInfoKey(hKeyTemp, NULL, NULL, NULL, &dwSubKeys, NULL, NULL, &dwSubValues, NULL, NULL, NULL, NULL);
	if (ulRet != ERROR_SUCCESS)
	{
		RegCloseKey(hKeyTemp);
		return;
	}

	// 如果查找项  CheckBox
	if (m_bKeys)
	{
		for (DWORD dwIndex = 0; !m_bStop && dwIndex < dwSubKeys; dwIndex++)
		{
			DWORD dwLen = 1024;
			TCHAR szSubName[1024];
			memset(szSubName, 0, 1024 * sizeof(TCHAR));

			ulRet = RegEnumKey(hKeyTemp, dwIndex, szSubName, dwLen);
			if (ulRet == ERROR_SUCCESS)
			{ 
				CString strSubName = CString(szSubName);

				// 区分大小写 & 匹配全字符
				if (m_bMachCase && m_bMachWholeString)
				{
					if (!strSubName.Compare(m_strFindWhat))
					{
						InsertKeys(hRoot, strSubKey, strSubName);
					}
				}

				// 区分大小写,但是不全字匹配
				else if (m_bMachCase && !m_bMachWholeString)
				{
					if (-1 != strSubName.Find(m_strFindWhat))
					{
						InsertKeys(hRoot, strSubKey, strSubName);
					}
				}	

				// 不区分大小写 & 全字匹配
				else if (!m_bMachCase && m_bMachWholeString)
				{
					if (!strSubName.CompareNoCase(m_strFindWhat))
					{
						InsertKeys(hRoot, strSubKey, strSubName);
					}
				}

				// 不区分大小写 & 不全字匹配
				else if (!m_bMachCase && !m_bMachWholeString)
				{
					CString szTemp = strSubName;
					szTemp.MakeUpper();

					if (szTemp.Find(m_strFindWhatUpper) != -1)
					{
						InsertKeys(hRoot, strSubKey, strSubName);
					}
				}

				// 递归枚举
				EnumKeys(hRoot, strSubKey + L"\\" + szSubName);
			}
		}
	}

	// 如果值和内容都不需要,那么直接返回了
	if (!m_bData && !m_bValues)
	{
		RegCloseKey(hKeyTemp);
		return;
	}

	// 枚举值
	for (DWORD dwIndex = 0; !m_bStop && dwIndex < dwSubValues; dwIndex++)
	{
		DWORD dwLen = 1024;
		TCHAR szSubName[1024];
		memset(szSubName, 0, 1024 * sizeof(TCHAR));

		DWORD dwType = 0, dwDataLen = 0x2000;
		BYTE  Data[0x2000] = {0};
		ulRet = RegEnumValue(hKeyTemp, dwIndex, szSubName, &dwLen, NULL, &dwType, Data, &dwDataLen);
		if (ulRet == ERROR_SUCCESS)
		{ 
			// 如果枚举值被选中了
			if (m_bValues)
			{
				CString strSubName = CString(szSubName);

				// 区分大小写 & 匹配全字符
				if (m_bMachCase && m_bMachWholeString)
				{
					if (!strSubName.Compare(m_strFindWhat))
					{
						InsertVlaues(hRoot, strSubKey, strSubName);
					}
				}

				// 区分大小写,但是不全字匹配
				else if (m_bMachCase && !m_bMachWholeString)
				{
					if (-1 != strSubName.Find(m_strFindWhat))
					{
						InsertVlaues(hRoot, strSubKey, strSubName);
					}
				}	

				// 不区分大小写 & 全字匹配
				else if (!m_bMachCase && m_bMachWholeString)
				{
					if (!strSubName.CompareNoCase(m_strFindWhat))
					{
						InsertVlaues(hRoot, strSubKey, strSubName);
					}
				}

				// 不区分大小写 & 不全字匹配
				else if (!m_bMachCase && !m_bMachWholeString)
				{
					CString szTemp = strSubName;
					szTemp.MakeUpper();

					if (szTemp.Find(m_strFindWhatUpper) != -1)
					{
						InsertVlaues(hRoot, strSubKey, strSubName);
					}
				}
			}

			// 如果枚举数据被选中了
			if (m_bData)
			{
				InsertData(hRoot, strSubKey, szSubName, dwType, Data, dwDataLen);
			}
		}
	}

	RegCloseKey(hKeyTemp);
}



void CRegFindDlg::InsertKeys(HKEY hRoot, CString strSubKey, CString strSubSubKey)
{
	if (!hRoot)
	{
		return;
	}

	CString strKeyPath = GetRootKeyString(hRoot);
	strKeyPath += L"\\" + strSubKey + L"\\" + strSubSubKey;
	int nItem = m_List.InsertItem(m_List.GetItemCount(), strKeyPath);
	m_List.SetItemText(nItem, 1, L"");
	m_List.SetItemText(nItem, 2, L"");
    m_nCnt++;
}


void CRegFindDlg::InsertVlaues(HKEY hRoot, CString strSubKey, CString strValue)
{
	if (!hRoot || strValue.IsEmpty())
	{
		return;
	}

	CString strKeyPath = GetRootKeyString(hRoot);
	strKeyPath += L"\\" + strSubKey;
	int nItem = m_List.InsertItem(m_List.GetItemCount(), strKeyPath);
	m_List.SetItemText(nItem, 1, strValue);
	m_List.SetItemText(nItem, 2, L"");
	m_nCnt++;
}



void CRegFindDlg::InsertData(HKEY hRoot, CString strSubKey, CString strValue, DWORD dwType, PBYTE Data, DWORD dwDataLen)
{
	if (!hRoot || !Data || dwDataLen <= 0)
	{
		return;
	}

	CString strRet, strCmp;
	switch (dwType)
	{
	case REG_SZ:
	case REG_EXPAND_SZ:
		strCmp = strRet = (WCHAR*)Data;
		break;

	case REG_DWORD:
		{
			strCmp.Format(L"%ld", *(PULONG)Data);
			if (m_strFindWhat.GetLength() == strCmp.GetLength())
			{
				BOOL bNumber = TRUE;
				for (int i = 0; i < m_strFindWhat.GetLength(); i++)
				{
					WCHAR ch = m_strFindWhat.GetAt(i);
					if (ch < '0' || ch > '9')
					{
						bNumber = FALSE;
						break;
					}
				}

				if (bNumber && *(PULONG)Data == _wtoi(m_strFindWhat))
				{
					strRet.Format(L"0x%08X (%d)", *(PULONG)Data, *(PULONG)Data);
				}
				else
				{
					return;
				}
			}
			else
			{
				return;
			}
		}
		break;

	case REG_DWORD_BIG_ENDIAN:
		{
			BYTE Value[4] = {0};
			Value[0] = *((PBYTE)Data + 3);
			Value[1] = *((PBYTE)Data + 2);
			Value[2] = *((PBYTE)Data + 1);
			Value[3] = *((PBYTE)Data + 0);
			strCmp.Format(L"%ld", *(PULONG)Value);
			strRet.Format(L"0x%08X (%ld)", *(PULONG)Value, *(PULONG)Value);
		}
		break;
	case REG_QWORD:
		{
			strCmp.Format(L"%ld", *(PQWORD)Data);
			if (m_strFindWhat.GetLength() == strCmp.GetLength())
			{
				BOOL bNumber = TRUE;
				for (int i = 0; i < m_strFindWhat.GetLength(); i++)
				{
					WCHAR ch = m_strFindWhat.GetAt(i);
					if (ch < '0' || ch > '9')
					{
						bNumber = FALSE;
						break;
					}
				}

				if (bNumber && *(PQWORD)Data == _wtoi(m_strFindWhat))
				{
					strRet.Format(L"0x%08X (%ld)", *(PQWORD)Data, *(PQWORD)Data);
				}
				else
				{
					return;
				}
			}
			else
			{
				return;
			}
		}
		break;
	case REG_MULTI_SZ:
		{
			DWORD len = 0;
			while (wcslen((WCHAR*)Data + len))
			{
				strRet += ((WCHAR*)Data + len);
				strRet += L" ";
				len += wcslen((WCHAR*)Data + len) + 1;
			}

			strCmp = strRet;
		}
		break;

	default:
		return;
	}

	if (strCmp.IsEmpty())
	{
		return;
	}

	CString strSubName = strCmp;
	BOOL bInsert = FALSE;

	// 区分大小写 & 匹配全字符
	if (m_bMachCase && m_bMachWholeString)
	{
		if (!strSubName.Compare(m_strFindWhat))
		{
			bInsert = TRUE;
		}
	}

	// 区分大小写,但是不全字匹配
	else if (m_bMachCase && !m_bMachWholeString)
	{
		if (-1 != strSubName.Find(m_strFindWhat))
		{
			bInsert = TRUE;
		}
	}	

	// 不区分大小写 & 全字匹配
	else if (!m_bMachCase && m_bMachWholeString)
	{
		if (!strSubName.CompareNoCase(m_strFindWhat))
		{
			bInsert = TRUE;
		}
	}

	// 不区分大小写 & 不全字匹配
	else if (!m_bMachCase && !m_bMachWholeString)
	{
		CString strTemp = strSubName;
		strTemp.MakeUpper();

		if (strTemp.Find(m_strFindWhatUpper) != -1)
		{
			bInsert = TRUE;
		}
	}

	if (bInsert)
	{
		CString strKeyPath = GetRootKeyString(hRoot);
		strKeyPath += L"\\" + strSubKey;
		int nItem = m_List.InsertItem(m_List.GetItemCount(), strKeyPath);
		m_List.SetItemText(nItem, 1, strValue);
		m_List.SetItemText(nItem, 2, strRet);
		m_nCnt++;
	}
}



CString CRegFindDlg::GetRootKeyString(HKEY hRoot)
{
	CString strRet;
	if (!hRoot)
	{
		return strRet;
	}

	if (hRoot == HKEY_CLASSES_ROOT)
	{
		strRet = L"HKEY_CLASSES_ROOT";
	}
	else if (hRoot == HKEY_CURRENT_USER)
	{
		strRet = L"HKEY_CURRENT_USER";
	}
	else if (hRoot == HKEY_LOCAL_MACHINE)
	{
		strRet = L"HKEY_LOCAL_MACHINE";
	}
	else if (hRoot == HKEY_USERS)
	{
		strRet = L"HKEY_USERS";
	}
	else if (hRoot == HKEY_CURRENT_CONFIG)
	{
		strRet = L"HKEY_CURRENT_CONFIG";
	}

	return strRet;
}

void CRegFindDlg::OnBnClickedButtonStop()
{
	m_bStop = TRUE;
	InitControl(TRUE);
}



void CRegFindDlg::InitControl(BOOL bOk)
{
	GetDlgItem(IDC_CHECK_KEY)->EnableWindow(bOk);
	GetDlgItem(IDC_CHECK_VALUES)->EnableWindow(bOk);
	GetDlgItem(IDC_CHECK_DATA)->EnableWindow(bOk);
	GetDlgItem(IDC_CHECK_MACH_CASE)->EnableWindow(bOk);
	GetDlgItem(IDC_CHECK_MACH_WHOLE_STRING)->EnableWindow(bOk);
	GetDlgItem(IDC_RADIO_SEARCH_IN)->EnableWindow(bOk);
	GetDlgItem(IDC_RADIO_SEARCH_ALL)->EnableWindow(bOk);
	GetDlgItem(IDC_BUTTON_START)->EnableWindow(bOk);
	GetDlgItem(IDC_EDIT_FIND_WHAT)->EnableWindow(bOk);
	GetDlgItem(IDC_EDIT)->EnableWindow(bOk);
	GetDlgItem(IDC_EDIT_FIND_WHAT)->EnableWindow(bOk);
	GetDlgItem(IDC_BUTTON_STOP)->EnableWindow(!bOk);
}

void CRegFindDlg::OnClose()
{
	m_bStop = TRUE;
	if (m_hThread)
	{
		if (WaitForSingleObject(m_hThread, 500) != WAIT_OBJECT_0)
		{
			TerminateThread(m_hThread, 0);
		}

		CloseHandle(m_hThread);
		m_hThread = NULL;
	}


	CDialog::OnClose();

	delete this;
}



void CRegFindDlg::OnNMDblclkList(NMHDR *pNMHDR, LRESULT *pResult)
{
	int nItem = m_List.GetSelectionMark();
	if (nItem != -1)
	{
		CString strKey = m_List.GetItemText(nItem, 0);
		CString strValue = m_List.GetItemText(nItem, 1);
		
		JmpToRegistry(strKey, strValue);
	}
	*pResult = 0;
}


void CRegFindDlg::JmpToRegistry(CString strKey, CString strData)
{
	if (!strKey.IsEmpty() && g_Father)
	{

		((CRegisterManagerDlg*)g_Father)->JmpToReg(strKey, strData);
	}
}
```

`Register/RegisterManager/RegisterManager/RegFindDlg.h`:

```h
#pragma once
#include "afxcmn.h"


// CRegFindDlg 对话框

class CRegFindDlg : public CDialog
{
	DECLARE_DYNAMIC(CRegFindDlg)

public:
	CRegFindDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CRegFindDlg();
	HKEY CRegFindDlg::GetRootKey(CString strKey);
	VOID CRegFindDlg::SearchRegistry();
	void CRegFindDlg::EnumKeys(HKEY hRoot, CString strSubKey);
	void CRegFindDlg::InsertKeys(HKEY hRoot, CString strSubKey, CString strSubSubKey);
	CString CRegFindDlg::GetRootKeyString(HKEY hRoot);
	void CRegFindDlg::InsertVlaues(HKEY hRoot, CString strSubKey, CString strValue);
	void CRegFindDlg::InsertData(HKEY hRoot, CString strSubKey, CString strValue, DWORD dwType, PBYTE Data, DWORD dwDataLen);
	void CRegFindDlg::InitControl(BOOL bOk);
	void CRegFindDlg::JmpToRegistry(CString strKey, CString strData);
// 对话框数据
	enum { IDD = IDD_FIND_REG_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	CListCtrl m_List;
	virtual BOOL OnInitDialog();
	CString m_strSearchInKey;
	int m_nRadio;
	afx_msg void OnBnClickedRadioSearchIn();
	afx_msg void OnBnClickedButtonStart();
	afx_msg LRESULT UpdateUI(WPARAM,LPARAM);
	CString m_strFindWhat;
	CString m_strFindWhatUpper;		// 大写的搜索内容
	BOOL m_bStop;
	HANDLE m_hThread;
	BOOL m_bKeys;
	BOOL m_bMachCase;
	BOOL m_bMachWholeString;
	BOOL m_bData;
	BOOL m_bValues;
	ULONG m_nCnt;    //记录查找的个数
	CString m_strSearchResult;
	CAnimateCtrl m_ctlAnimate;
	afx_msg void OnBnClickedButtonStop();
	afx_msg void OnClose();
	afx_msg void OnNMDblclkList(NMHDR *pNMHDR, LRESULT *pResult);
};

```

`Register/RegisterManager/RegisterManager/RegHexEditDlg.cpp`:

```cpp
// RegHexEditDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "RegisterManager.h"
#include "RegHexEditDlg.h"
#include "afxdialogex.h"


// CRegHexEditDlg 对话框

IMPLEMENT_DYNAMIC(CRegHexEditDlg, CDialog)

CRegHexEditDlg::CRegHexEditDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRegHexEditDlg::IDD, pParent)
	, m_strValueNameEdit(_T(""))
	, m_strHex(_T(""))
{

}

CRegHexEditDlg::~CRegHexEditDlg()
{
}

void CRegHexEditDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_HEXEDIT, m_HexEdit);
	DDX_Text(pDX, IDC_EDIT_VALUE_NAME, m_strValueNameEdit);
	DDX_Text(pDX, IDC_HEXEDIT, m_strHex);
}


BEGIN_MESSAGE_MAP(CRegHexEditDlg, CDialog)
	ON_BN_CLICKED(IDOK, &CRegHexEditDlg::OnBnClickedOk)
END_MESSAGE_MAP()


// CRegHexEditDlg 消息处理程序


BOOL CRegHexEditDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

		
	SetWindowText(L"二进制编辑器");

	ULONG i = 0;
	CString  strShowData;
	for (i=0;i<m_DataLen;i++)
	{
		CString Temp;


		Temp.Format(L"%02X ",(UCHAR)m_Data[i]);

		strShowData += Temp;

	}


	m_HexEdit.SetWindowTextW(strShowData);



	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CRegHexEditDlg::OnBnClickedOk()
{

	UpdateData(TRUE);
	WCHAR* p = m_strHex.GetBuffer();
	m_RetLen = 0;

	int j = 0;
	WCHAR* q = m_strHex.GetBuffer();

	int n = m_strHex.GetLength();
	while (j!=m_strHex.GetLength())
	{
		if (q[j]==' ')
		{
			m_RetLen++;
		}

		j++;
	}
	int i = 0;
	int nTemp = 0;

	m_RetData = (PBYTE)malloc(m_RetLen);
	if (m_RetData)
	{
		memset(m_RetData, 0, m_RetLen);


		while (1)
		{
			if (*p==' ')
			{
				p++;
				continue;
			}

			if (*p=='\r')
			{
				p+=2;
				continue;
			}


			swscanf(p,L"%2x",&nTemp);

			m_RetData[i] = (UCHAR)nTemp;

			i++;

			if (i==m_RetLen)
			{
				break;
			}

			p+=2;
		}
	
	}


	CDialog::OnOK();
}

```

`Register/RegisterManager/RegisterManager/RegHexEditDlg.h`:

```h
#pragma once
#include "afxwin.h"


// CRegHexEditDlg 对话框

class CRegHexEditDlg : public CDialog
{
	DECLARE_DYNAMIC(CRegHexEditDlg)

public:
	CRegHexEditDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CRegHexEditDlg();

// 对话框数据
	enum { IDD = IDD_REG_HEX_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	CEdit m_HexEdit;
	CString m_strValueNameEdit;

	ULONG m_DataLen;
	PBYTE m_Data;
	PBYTE m_RetData;
	ULONG m_RetLen;
	virtual BOOL OnInitDialog();
	afx_msg void OnBnClickedOk();
	CString m_strHex;
};

```

`Register/RegisterManager/RegisterManager/RegModifyDlg.cpp`:

```cpp
// RegModifyDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "RegisterManager.h"
#include "RegModifyDlg.h"
#include "afxdialogex.h"


// CRegModifyDlg 对话框

IMPLEMENT_DYNAMIC(CRegModifyDlg, CDialog)

CRegModifyDlg::CRegModifyDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRegModifyDlg::IDD, pParent)
	, m_strValueNameStatic(_T(""))
	, m_strValueNameEdit(_T(""))
	, m_strValueDataStatic(_T(""))
	, m_strValueDataEdit(_T(""))
{

}

CRegModifyDlg::~CRegModifyDlg()
{
}

void CRegModifyDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_VALUE_NAME_STATIC, m_strValueNameStatic);
	DDX_Text(pDX, IDC_EDIT_VALUE_NAME, m_strValueNameEdit);
	DDX_Text(pDX, IDC_VALUE_DATA_STATIC, m_strValueDataStatic);
	DDX_Text(pDX, IDC_EDIT_VALUE_DATA, m_strValueDataEdit);
}


BEGIN_MESSAGE_MAP(CRegModifyDlg, CDialog)
END_MESSAGE_MAP()


// CRegModifyDlg 消息处理程序

```

`Register/RegisterManager/RegisterManager/RegModifyDlg.h`:

```h
#pragma once
#include "afxwin.h"


// CRegModifyDlg 对话框

class CRegModifyDlg : public CDialog
{
	DECLARE_DYNAMIC(CRegModifyDlg)

public:
	CRegModifyDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CRegModifyDlg();

// 对话框数据
	enum { IDD = IDD_REG_MODIFY_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	CString m_strValueNameStatic;

	CString m_strValueNameEdit;
	CString m_strValueDataStatic;
	CString m_strValueDataEdit;
};

```

`Register/RegisterManager/RegisterManager/RegisterManager.cpp`:

```cpp

// RegisterManager.cpp : 定义应用程序的类行为。
//

#include "stdafx.h"
#include "RegisterManager.h"
#include "RegisterManagerDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CRegisterManagerApp

BEGIN_MESSAGE_MAP(CRegisterManagerApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CRegisterManagerApp 构造

CRegisterManagerApp::CRegisterManagerApp()
{
	// 支持重新启动管理器
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: 在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的一个 CRegisterManagerApp 对象

CRegisterManagerApp theApp;


// CRegisterManagerApp 初始化

BOOL CRegisterManagerApp::InitInstance()
{
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

	CRegisterManagerDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	}

	// 删除上面创建的 shell 管理器。
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}

	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
	//  而不是启动应用程序的消息泵。
	return FALSE;
}


```

`Register/RegisterManager/RegisterManager/RegisterManager.h`:

```h

// RegisterManager.h : PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
	#error "在包含此文件之前包含“stdafx.h”以生成 PCH 文件"
#endif

#include "resource.h"		// 主符号


// CRegisterManagerApp:
// 有关此类的实现，请参阅 RegisterManager.cpp
//

class CRegisterManagerApp : public CWinApp
{
public:
	CRegisterManagerApp();

// 重写
public:
	virtual BOOL InitInstance();

// 实现

	DECLARE_MESSAGE_MAP()
};

extern CRegisterManagerApp theApp;
```

`Register/RegisterManager/RegisterManager/RegisterManager.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\RegisterManager.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\RegisterManager.ico"
IDI_COMPUTER            ICON                    "res\\Icon\\Computer.ico"
IDI_CLOSE_DIRECTORY     ICON                    "res\\Icon\\CloseDir.ico"
IDI_OPEN_DIRECTORY      ICON                    "res\\Icon\\OpenDir.ico"
IDI_REG_SZ              ICON                    "res\\Icon\\REG_SZ.ico"
IDI_DWORD               ICON                    "res\\Icon\\REG_DWORD.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 RegisterManager"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "RegisterManager，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2015",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_REGISTERMANAGER_DIALOG DIALOGEX 0, 0, 449, 263
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CAPTION "RegisterManager"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_TREE,"SysTreeView32",TVS_HASBUTTONS | TVS_HASLINES | WS_BORDER | WS_HSCROLL | WS_TABSTOP,7,30,154,226
    CONTROL         "",IDC_LIST,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,162,30,280,226
    PUSHBUTTON      "转到",IDC_GOTO,406,6,36,14
    COMBOBOX        IDC_COMBO,61,7,339,30,CBS_DROPDOWN | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    LTEXT           "快速定位:",IDC_STATIC,10,9,49,8
END

IDD_KEY_DIALOG DIALOGEX 0, 0, 179, 60
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "确定",IDOK,7,39,50,14
    PUSHBUTTON      "取消",IDCANCEL,119,39,50,14
    LTEXT           "Key Name:",IDC_KEY_NAME,7,7,80,8
    EDITTEXT        IDC_EDIT,7,20,164,14,ES_AUTOHSCROLL
END

IDD_FIND_REG_DIALOG DIALOGEX 0, 0, 299, 310
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    LTEXT           "查找内容:",IDC_STATIC_FIND_WHAT,7,7,38,19
    EDITTEXT        IDC_EDIT_FIND_WHAT,46,7,120,14,ES_AUTOHSCROLL
    PUSHBUTTON      "查找",IDC_BUTTON_START,168,7,68,14
    PUSHBUTTON      "停止",IDC_BUTTON_STOP,242,7,50,14
    GROUPBOX        "Static",IDC_STATIC,7,30,285,35
    CONTROL         "键",IDC_CHECK_KEY,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,18,44,25,10
    CONTROL         "键值",IDC_CHECK_VALUES,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,50,44,33,10
    CONTROL         "数据",IDC_CHECK_DATA,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,95,44,33,10
    CONTROL         "区分大小写",IDC_CHECK_MACH_CASE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,154,44,59,10
    CONTROL         "匹配整个字符串",IDC_CHECK_MACH_WHOLE_STRING,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,216,44,76,10
    GROUPBOX        "搜索范围",IDC_STATIC_WHERE_TO_SEARCH,7,71,285,68
    CONTROL         "在此项中搜索",IDC_RADIO_SEARCH_IN,"Button",BS_AUTORADIOBUTTON | WS_GROUP,18,85,67,10
    EDITTEXT        IDC_EDIT,95,80,197,14,ES_AUTOHSCROLL
    CONTROL         "搜索整个注册表",IDC_RADIO_SEARCH_ALL,"Button",BS_AUTORADIOBUTTON,18,110,76,10
    LTEXT           "查找结果:",IDC_STATIC_FIND_RESULT,7,144,285,11
    CONTROL         "",IDC_LIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,156,285,147
    CONTROL         "",IDC_ANIMATE,"SysAnimate32",ACS_TRANSPARENT | WS_TABSTOP,96,102,33,25,WS_EX_TRANSPARENT
END

IDD_REG_MODIFY_DIALOG DIALOGEX 0, 0, 197, 111
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    LTEXT           "Static",IDC_VALUE_NAME_STATIC,7,7,58,8
    EDITTEXT        IDC_EDIT_VALUE_NAME,7,21,183,14,ES_AUTOHSCROLL | ES_READONLY
    LTEXT           "Static",IDC_VALUE_DATA_STATIC,7,38,59,8
    EDITTEXT        IDC_EDIT_VALUE_DATA,7,52,183,14,ES_AUTOHSCROLL
    PUSHBUTTON      "确定",IDOK,66,90,50,14
    PUSHBUTTON      "取消",IDCANCEL,136,90,50,14
END

IDD_REG_HEX_DIALOG DIALOGEX 0, 0, 287, 185
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "确定",IDOK,163,164,50,14
    PUSHBUTTON      "取消",IDCANCEL,230,164,50,14
    LTEXT           "键值名称",IDC_VALUE_NAME,7,7,83,8
    EDITTEXT        IDC_EDIT_VALUE_NAME,7,22,273,14,ES_AUTOHSCROLL | ES_READONLY
    LTEXT           "键值数据",IDC_VALUE_DATA,7,48,83,8
    EDITTEXT        IDC_HEXEDIT,7,64,273,98,ES_MULTILINE
    LTEXT           "注意每个数据后都要跟空格键",IDC_STATIC,95,48,128,8
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404B0"
        BEGIN
            VALUE "CompanyName", "TODO: <公司名>"
            VALUE "FileDescription", "RegisterManager"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "RegisterManager.exe"
            VALUE "LegalCopyright", "TODO: (C) <公司名>。保留所有权利。"
            VALUE "OriginalFilename", "RegisterManager.exe"
            VALUE "ProductName", "TODO: <产品名>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_REGISTERMANAGER_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 442
        TOPMARGIN, 7
        BOTTOMMARGIN, 256
    END

    IDD_KEY_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 172
        TOPMARGIN, 7
        BOTTOMMARGIN, 53
    END

    IDD_FIND_REG_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 292
        TOPMARGIN, 7
        BOTTOMMARGIN, 303
    END

    IDD_REG_MODIFY_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 190
        TOPMARGIN, 7
        BOTTOMMARGIN, 104
    END

    IDD_REG_HEX_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 280
        TOPMARGIN, 7
        BOTTOMMARGIN, 178
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_REG_TREE MENU
BEGIN
    POPUP "REG_TREE"
    BEGIN
        MENUITEM "刷新",                          ID_REG_REFRESH
        MENUITEM "新建项",                         ID_REG_NEW_KEY
        POPUP "新建值"
        BEGIN
            MENUITEM "字符串值",                        ID_STRING_VALUE
            MENUITEM "二进制",                         ID_BINARY_VALUE
            MENUITEM "DWORD值",                      ID_DWORD_VALUE
            MENUITEM "QWORD值",                      ID_QWORD_VALUE
            MENUITEM "多字符串值",                       ID_MUI_STRING_VALUE
            MENUITEM "可扩充字符串值",                     ID_EXPAND_STRING_VALUE
        END
        MENUITEM "删除",                          ID_REG_DELETE
        MENUITEM "重命名",                         ID_REG_RENAME
        MENUITEM "复制项名称",                       ID_REG_COPY_KEY_NAME
        MENUITEM "复制项完整名称",                     ID_REG_COPY_FULL_KEY_NAME
        MENUITEM "添加到快速定位",                     ID_REG_ADD_TO_QUICK_ADDRESS
        MENUITEM "导入",                          ID_REG_INPORT
        MENUITEM "导出",                          ID_REG_EXPORT
        MENUITEM "查找",                          ID_REG_LOOK_FOR
    END
END

IDR_REG_LIST MENU
BEGIN
    POPUP "REG_LIST"
    BEGIN
        MENUITEM "刷新",                          ID_REG_LIST_REFRESH
        MENUITEM "修改",                          ID_REG_LIST_MODIFY
        MENUITEM "删除",                          ID_REG_LIST_DELETE
        MENUITEM "重命名",                         ID_REG_LIST_RENAME
        MENUITEM "复制值名称",                       ID_REG_LIST_COPY_VALUE
        MENUITEM "复制值数据",                       ID_REG_LIST_COPY_VALUE_DATA
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDB_REFRESH             BITMAP                  "res\\Bmp\\Refresh.bmp"
IDB_DELETE              BITMAP                  "res\\Bmp\\Delete.bmp"
IDB_COPY                BITMAP                  "res\\Bmp\\Copy.bmp"
IDB_EXPORT              BITMAP                  "res\\Bmp\\Export.bmp"
IDB_LOOKFOR             BITMAP                  "res\\Bmp\\Lookfor.bmp"

/////////////////////////////////////////////////////////////////////////////
//
// AVI
//

IDR_AVI                 AVI                     "res\\Check.avi"

/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 RegisterManager(&A)..."
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\RegisterManager.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Register/RegisterManager/RegisterManager/RegisterManager.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{118E09E5-83B5-4DC6-A3ED-70F0F1BFE66C}</ProjectGuid>
    <RootNamespace>RegisterManager</RootNamespace>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\Bmp\Copy.bmp" />
    <None Include="res\Bmp\Delete.bmp" />
    <None Include="res\Bmp\Export.bmp" />
    <None Include="res\Bmp\Lookfor.bmp" />
    <None Include="res\Bmp\Refresh.bmp" />
    <None Include="res\Check.avi" />
    <None Include="res\Icon\CloseDir.ico" />
    <None Include="res\Icon\Computer.ico" />
    <None Include="res\Icon\OpenDir.ico" />
    <None Include="res\Icon\REG_DWORD.ico" />
    <None Include="res\Icon\REG_SZ.ico" />
    <None Include="res\RegisterManager.ico" />
    <None Include="res\RegisterManager.rc2" />
    <None Include="res\Search.avi" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="KeyDlg.h" />
    <ClInclude Include="RegFindDlg.h" />
    <ClInclude Include="RegHexEditDlg.h" />
    <ClInclude Include="RegisterManager.h" />
    <ClInclude Include="RegisterManagerDlg.h" />
    <ClInclude Include="RegModifyDlg.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="KeyDlg.cpp" />
    <ClCompile Include="RegFindDlg.cpp" />
    <ClCompile Include="RegHexEditDlg.cpp" />
    <ClCompile Include="RegisterManager.cpp" />
    <ClCompile Include="RegisterManagerDlg.cpp" />
    <ClCompile Include="RegModifyDlg.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="RegisterManager.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="RegisterManager.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`Register/RegisterManager/RegisterManager/RegisterManager.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\RegisterManager.rc2">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\RegisterManager.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Icon\Computer.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Icon\CloseDir.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Icon\OpenDir.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Icon\REG_SZ.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Icon\REG_DWORD.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Bmp\Refresh.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Bmp\Delete.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Bmp\Copy.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Bmp\Export.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Bmp\Lookfor.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\Search.avi" />
    <None Include="res\Check.avi" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="RegisterManager.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="RegisterManagerDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="KeyDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="RegFindDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="RegModifyDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="RegHexEditDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="RegisterManager.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="RegisterManagerDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="KeyDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="RegFindDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="RegModifyDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="RegHexEditDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="RegisterManager.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Register/RegisterManager/RegisterManager/RegisterManager.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Register/RegisterManager/RegisterManager/RegisterManagerDlg.cpp`:

```cpp

// RegisterManagerDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "RegisterManager.h"
#include "RegisterManagerDlg.h"
#include "afxdialogex.h"
#include "KeyDlg.h"
#include "RegFindDlg.h"
#include "RegModifyDlg.h"
#include "RegHexEditDlg.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框
HANDLE g_hDevice = NULL;
CWnd*  g_Father = NULL;

HANDLE
OpenDevice(LPCTSTR lpDevicePath)
{
	HANDLE hDevice = CreateFile(lpDevicePath,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		
	}

	return hDevice;

}

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CRegisterManagerDlg 对话框




CRegisterManagerDlg::CRegisterManagerDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(CRegisterManagerDlg::IDD, pParent)
	, m_strComboText(_T(""))
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	m_wzhKeyCurrentUser = NULL;
	m_RegPathList.clear();
	m_bmRefresh.LoadBitmap(IDB_REFRESH);   //加载图标
	m_bmDelete.LoadBitmap(IDB_DELETE);
	m_bmCopy.LoadBitmap(IDB_COPY);
	m_bmExport.LoadBitmap(IDB_EXPORT);
	m_bmLookfor.LoadBitmap(IDB_LOOKFOR);

	m_FindRegDlg = NULL;
}

CRegisterManagerDlg::~CRegisterManagerDlg()
{
	if (m_wzhKeyCurrentUser)
	{
		free(m_wzhKeyCurrentUser);
		m_wzhKeyCurrentUser = NULL;
	}

	m_RegPathList.clear();
}

void CRegisterManagerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_TREE, m_Tree);
	DDX_Control(pDX, IDC_LIST, m_List);
	DDX_Control(pDX, IDC_COMBO, m_ComboBox);
	DDX_CBString(pDX, IDC_COMBO, m_strComboText);
}

BEGIN_MESSAGE_MAP(CRegisterManagerDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(TVN_ITEMEXPANDING, IDC_TREE, &CRegisterManagerDlg::OnTvnItemexpandingTree)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREE, &CRegisterManagerDlg::OnTvnSelchangedTree)
	ON_BN_CLICKED(IDC_GOTO, &CRegisterManagerDlg::OnBnClickedGoto)
	ON_CBN_DROPDOWN(IDC_COMBO, &CRegisterManagerDlg::OnCbnDropdownCombo)
	ON_COMMAND(ID_REG_REFRESH, &CRegisterManagerDlg::OnRegRefresh)
	ON_NOTIFY(NM_RCLICK, IDC_TREE, &CRegisterManagerDlg::OnNMRClickTree)
	ON_COMMAND(ID_REG_NEW_KEY, &CRegisterManagerDlg::OnRegNewKey)
	ON_COMMAND(ID_STRING_VALUE, &CRegisterManagerDlg::OnStringValue)
	ON_COMMAND(ID_BINARY_VALUE, &CRegisterManagerDlg::OnBinaryValue)
	ON_COMMAND(ID_DWORD_VALUE, &CRegisterManagerDlg::OnDwordValue)
	ON_COMMAND(ID_MUI_STRING_VALUE, &CRegisterManagerDlg::OnMuiStringValue)
	ON_COMMAND(ID_EXPAND_STRING_VALUE, &CRegisterManagerDlg::OnExpandStringValue)
	ON_COMMAND(ID_REG_DELETE, &CRegisterManagerDlg::OnRegDelete)
	ON_COMMAND(ID_REG_RENAME, &CRegisterManagerDlg::OnRegRename)
	ON_COMMAND(ID_QWORD_VALUE, &CRegisterManagerDlg::OnQwordValue)
	ON_COMMAND(ID_REG_COPY_KEY_NAME, &CRegisterManagerDlg::OnRegCopyKeyName)
	ON_COMMAND(ID_REG_COPY_FULL_KEY_NAME, &CRegisterManagerDlg::OnRegCopyFullKeyName)
	ON_COMMAND(ID_REG_ADD_TO_QUICK_ADDRESS, &CRegisterManagerDlg::OnRegAddToQuickAddress)
	ON_COMMAND(ID_REG_INPORT, &CRegisterManagerDlg::OnRegInport)
	ON_COMMAND(ID_REG_EXPORT, &CRegisterManagerDlg::OnRegExport)
	ON_COMMAND(ID_REG_LOOK_FOR, &CRegisterManagerDlg::OnRegLookFor)
	ON_NOTIFY(NM_RCLICK, IDC_LIST, &CRegisterManagerDlg::OnNMRClickList)
	ON_COMMAND(ID_REG_LIST_REFRESH, &CRegisterManagerDlg::OnRegListRefresh)
	ON_COMMAND(ID_REG_LIST_MODIFY, &CRegisterManagerDlg::OnRegListModify)
	ON_COMMAND(ID_REG_LIST_DELETE, &CRegisterManagerDlg::OnRegListDelete)
	ON_COMMAND(ID_REG_LIST_RENAME, &CRegisterManagerDlg::OnRegListRename)
	ON_COMMAND(ID_REG_LIST_COPY_VALUE, &CRegisterManagerDlg::OnRegListCopyValue)
	ON_COMMAND(ID_REG_LIST_COPY_VALUE_DATA, &CRegisterManagerDlg::OnRegListCopyValueData)
END_MESSAGE_MAP()


// CRegisterManagerDlg 消息处理程序

BOOL CRegisterManagerDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码



	g_Father = this;
	

	InitControlTree();   //初始化树控件


	//初始化List控件
	HICON hIcon[10];
	hIcon[0] = AfxGetApp()->LoadIcon (IDI_REG_SZ);
	hIcon[1] = AfxGetApp()->LoadIcon (IDI_DWORD);
	m_ImageList.Create(16, 16, ILC_COLOR16 | ILC_MASK, 2, 2); 
	for(int n = 0; n < 2; n++)
	{
		m_ImageList.Add(hIcon[n]);
		m_List.SetImageList(&m_ImageList, LVSIL_SMALL);
	}

	m_List.SetExtendedStyle(LVS_EX_FULLROWSELECT);
	m_List.InsertColumn(0, L"名称", LVCFMT_LEFT, 200);
	m_List.InsertColumn(1, L"类型", LVCFMT_LEFT, 130);
	m_List.InsertColumn(2, L"数据", LVCFMT_LEFT, 590);

	InitRegistry();
	InitRegPathList();    //Combo 上的快速定位项
	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CRegisterManagerDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CRegisterManagerDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CRegisterManagerDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}




BOOL CRegisterManagerDlg::InitControlTree()
{

	//导入Icon资源
	int iCount = 3;
	HICON hIcon[4];
	hIcon[0] = AfxGetApp()->LoadIcon (IDI_COMPUTER);
	hIcon[1] = AfxGetApp()->LoadIcon (IDI_CLOSE_DIRECTORY);
	hIcon[2] = AfxGetApp()->LoadIcon (IDI_OPEN_DIRECTORY);


	//定义图片链表
	m_TreeImageList.Create(16, 16, ILC_COLOR16 | ILC_MASK, 2, 2); 
	for(int n = 0; n < iCount; n++)
	{
		m_TreeImageList.Add(hIcon[n]);
		m_Tree.SetImageList(&m_TreeImageList, LVSIL_NORMAL);
	}

	DWORD dwStyle = GetWindowLong(m_Tree.m_hWnd, GWL_STYLE);
	dwStyle |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT;
	::SetWindowLong (m_Tree.m_hWnd, GWL_STYLE, dwStyle);

	HTREEITEM Computer = m_Tree.InsertItem(L"我的电脑", 0, 0);
	HTREEITEM hTreeItem0 = m_Tree.InsertItem(L"HKEY_CLASSES_ROOT", 1, 2, Computer, TVI_LAST);
	HTREEITEM hTreeItem1 = m_Tree.InsertItem(L"HKEY_CURRENT_USER", 1, 2, Computer, TVI_LAST);
	HTREEITEM hTreeItem2 = m_Tree.InsertItem(L"HKEY_LOCAL_MACHINE", 1, 2, Computer, TVI_LAST);
	HTREEITEM hTreeItem3 = m_Tree.InsertItem(L"HKEY_USERS", 1, 2, Computer, TVI_LAST);
	HTREEITEM hTreeItem4 = m_Tree.InsertItem(L"HKEY_CURRENT_CONFIG", 1, 2, Computer, TVI_LAST);

	m_Tree.Expand(Computer, TVE_EXPAND);

	return TRUE;
}


VOID CRegisterManagerDlg::InitRegistry()
{
	

	m_List.DeleteAllItems();
	m_strComboText = L"";
	UpdateData( FALSE );

	HTREEITEM hRootItem = m_Tree.GetRootItem();

	if (hRootItem != NULL)
	{
		HTREEITEM hChild = m_Tree.GetChildItem(hRootItem);
		while(hChild != NULL)
		{
			m_Tree.Expand(hChild, TVE_COLLAPSE);

			CString strKey = m_Tree.GetItemText(hChild);

			if (!strKey.CompareNoCase(L"HKEY_CLASSES_ROOT"))
			{
				EnumSubKeys(CLASSES_ROOT, hChild, TRUE);
			}
			else if (!strKey.CompareNoCase(L"HKEY_CURRENT_USER"))
			{
				EnumCurrentUserSubKeys(hChild);  //这个比较特殊
			}
			else if (!strKey.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
			{
				EnumSubKeys(LOCAL_MACHINE, hChild);
			}
			else if (!strKey.CompareNoCase(L"HKEY_USERS"))
			{
				EnumSubKeys(USERS, hChild);
			}
			else if (!strKey.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
			{
				EnumSubKeys(CURRENT_CONFIGL, hChild, TRUE);
			}
			else
			{
				break;
			}

			hChild = m_Tree.GetNextSiblingItem(hChild);
		}
	}

	m_Tree.Invalidate(TRUE);
}



VOID CRegisterManagerDlg::EnumSubKeys(CString strKey, HTREEITEM hItem, BOOL bSubSubKey/* = FALSE */)
{
	if ( !strKey.IsEmpty() && hItem != NULL )
	{
		DeleteSubTree(hItem);   //屏蔽看效果

		UNICODE_STRING uniKey;

		if (InitUnicodeString(&uniKey, strKey.GetBuffer()))
		{
			HANDLE hKey;
			OBJECT_ATTRIBUTES oa;

			InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

			if (OpenKey(&hKey,KEY_ALL_ACCESS, &oa))
			{
			/*	WCHAR  wzBuffer[256] = {0};
				wsprintf(wzBuffer,L"0x%p",hKey);
				::MessageBox(NULL,wzBuffer,L"Data",MB_OK);*/
				
				for (ULONG i = 0;;i++)
				{
					ULONG nRetLen = 0;
					BOOL bRet = EnumerateKey(hKey,i,KeyBasicInformation,NULL,0,&nRetLen);

					if (!bRet && GetLastError() == ERROR_NO_MORE_ITEMS) 
					{
						break;
					}
					else if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) // STATUS_BUFFER_TOO_SMALL
					{


						//MessageBox(L"1",L"1");
						PKEY_BASIC_INFORMATION Buffer = (PKEY_BASIC_INFORMATION)malloc(nRetLen + 0x100);
						if (Buffer)
						{
							memset(Buffer, 0, nRetLen + 0x100);
							bRet = EnumerateKey(hKey, i, KeyBasicInformation,Buffer, nRetLen + 0x100, &nRetLen);

							if (bRet)
							{
								m_Tree.InsertItem(Buffer->Name, 1, 2, hItem, TVI_LAST);
							}

							free(Buffer);

							// 如果是枚举子项的子项，那么只要插入一个就可以了，
							// 因为前面已经有了一个+号了，主要为了速度优化。
							if (bRet && bSubSubKey)
							{
								break;
							}
						}
					}
				}

				CloseHandle(hKey);
			}

			FreeUnicodeString(&uniKey);
		}
	}
}


VOID CRegisterManagerDlg::DeleteSubTree(HTREEITEM hTreeItem)
{
	if(hTreeItem == NULL)   
	{
		return;   
	}

	if(m_Tree.ItemHasChildren(hTreeItem))
	{
		HTREEITEM hNext, hChild = m_Tree.GetChildItem(hTreeItem);
		while(hChild != NULL)
		{
			hNext = m_Tree.GetNextSiblingItem(hChild);
			m_Tree.DeleteItem(hChild);
			hChild = hNext; 
		}
	}
}



BOOL CRegisterManagerDlg::InitUnicodeString(PUNICODE_STRING uniString, WCHAR *wzString)
{
	BOOL bRet = FALSE;
	if (!wzString)
	{
		uniString->Buffer = NULL;
		uniString->Length = 0;
		uniString->MaximumLength = 2;
		bRet = TRUE;
	}
	else
	{
		ULONG nLen = wcslen(wzString);
		if (uniString && nLen > 0)
		{
			PWCHAR Buffer = (PWCHAR)malloc((nLen + 1) * sizeof(WCHAR));
			if (Buffer)
			{
				memset(Buffer, 0, (nLen + 1) * sizeof(WCHAR));
				wcscpy_s(Buffer, nLen + 1, wzString);
				uniString->Buffer = Buffer;
				uniString->Length = (USHORT)(nLen * sizeof(WCHAR));
				uniString->MaximumLength = (USHORT)((nLen + 1) * sizeof(WCHAR));
				bRet = TRUE;
			}
		}
	}

	return bRet;
}
VOID CRegisterManagerDlg::FreeUnicodeString(UNICODE_STRING *uniString)
{
	if (uniString && uniString->Buffer && uniString->Length > 0)
	{
		uniString->Length = 0;
		uniString->MaximumLength = 0;
		free(uniString->Buffer);
		uniString->Buffer = NULL;
	}
}

BOOL CRegisterManagerDlg::OpenKey(OUT PHANDLE  KeyHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES  ObjectAttributes
	)
{

	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	struct{
		ACCESS_MASK DesiredAccess;
		POBJECT_ATTRIBUTES ObjectAttributes;
	}Open;



	memset(&Open, 0, sizeof(Open));

	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}
	
	Open.DesiredAccess = DesiredAccess;
	Open.ObjectAttributes = ObjectAttributes;
	
	
	dwRet = DeviceIoControl(g_hDevice,CTL_OPEN_KEY,
		&Open,
		sizeof(Open),
		KeyHandle,
		sizeof(KeyHandle),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;
}



BOOL CRegisterManagerDlg::EnumerateKey(IN HANDLE  KeyHandle,
	IN ULONG  ulIndex,
	IN ULONG  ulKeyInformationClass,
	OUT PVOID  KeyInformation,
	IN ULONG   ulLength,
	OUT PULONG ResultLength
	)
{

	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	struct{
		HANDLE hKey;
		ULONG Index;
		ULONG InformationClass;
		ULONG Length;
	}Enum;


	memset(&Enum, 0, sizeof(Enum));

	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}


	Enum.hKey = KeyHandle;
	Enum.Index = ulIndex;
	Enum.InformationClass = ulKeyInformationClass;
	Enum.Length = ulLength;


	typedef struct _ENUM_VALUE_
	{
		PULONG RetLength;
		PVOID  ValueInfor;
	}ENUM_VALUE, *PENUM_VALUE;


	ENUM_VALUE EnumValue;
	memset(&EnumValue, 0, sizeof(ENUM_VALUE));
	EnumValue.RetLength = ResultLength;
	EnumValue.ValueInfor = KeyInformation;

	dwRet = DeviceIoControl(g_hDevice,CTL_ENUM_KEY,
		&Enum,
		sizeof(Enum),
		&EnumValue,
		sizeof(ENUM_VALUE),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;
}


void CRegisterManagerDlg::EnumCurrentUserSubKeys(HTREEITEM hChild)
{
	DeleteSubTree(hChild);

	if (!m_wzhKeyCurrentUser)
	{
		m_wzhKeyCurrentUser = (WCHAR*)malloc(1024 * sizeof(WCHAR));
		if (m_wzhKeyCurrentUser)
		{
			memset(m_wzhKeyCurrentUser, 0, 1024 * sizeof(WCHAR));

			if (!GetCurrentUserKeyPath(m_wzhKeyCurrentUser))
			{
				wcscpy_s(m_wzhKeyCurrentUser, 1024, L"\\Registry\\User\\.Default");
			}
		}
	}

	if (m_wzhKeyCurrentUser && wcslen(m_wzhKeyCurrentUser) > 0)
	{
		EnumSubKeys(m_wzhKeyCurrentUser, hChild, TRUE);
	}
}



BOOL CRegisterManagerDlg::GetCurrentUserKeyPath(OUT WCHAR *wzCurrentUserPath)
{
	if (!wzCurrentUserPath)
	{
		return FALSE;
	}

	HANDLE hToken;
	UCHAR szBuffer[256] = {0};
	PSID_AND_ATTRIBUTES SidBuffer;
	ULONG Length;
	BOOL Status = FALSE;

	Status = OpenThreadToken(GetCurrentThread(),
		TOKEN_QUERY,
		TRUE,
		&hToken);

	if (!Status)
	{
		Status = OpenProcessToken(GetCurrentProcess(),
			TOKEN_QUERY,
			&hToken);

		if (!Status) 
		{
			return Status;
		}
	}

	SidBuffer = (PSID_AND_ATTRIBUTES)szBuffer;
	Status = GetTokenInformation(hToken,
		TokenUser,
		(PVOID)SidBuffer,
		sizeof(szBuffer),
		&Length);

	CloseHandle(hToken);
	if (!Status)
	{
		return Status;
	}

	LPTSTR StringSid;
	Status = ConvertSidToStringSid(SidBuffer[0].Sid, &StringSid);
	if (!Status) return Status;

	WCHAR wzUser[] =  L"\\Registry\\User\\";

	Length = wcslen(StringSid) * sizeof(WCHAR) + sizeof(wzUser);

	WCHAR *wzPath = (WCHAR *)malloc(Length);
	if (!wzPath)
	{
		LocalFree((HLOCAL)StringSid);
		return FALSE;
	}

	memset(wzPath, 0, Length);
	wcscpy_s(wzPath, Length / sizeof(WCHAR),wzUser);
	wcscat_s(wzPath, Length / sizeof(WCHAR), StringSid);

	LocalFree((HLOCAL)StringSid);

	wcscpy_s(wzCurrentUserPath, 1024, wzPath);
	free(wzPath);

	return TRUE;
}

void CRegisterManagerDlg::OnTvnItemexpandingTree(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMTREEVIEW pNMTreeView = reinterpret_cast<LPNMTREEVIEW>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码
	HTREEITEM hItem = pNMTreeView->itemNew.hItem;
	BOOL nRet = FALSE;
	if (!nRet)
	{
		// 当是折叠状态的时候才插入子节点
		if(!(TVIS_EXPANDED & m_Tree.GetItemState(hItem, TVIS_EXPANDED)) &&
			m_Tree.GetRootItem() != hItem &&
			hItem != NULL)
		{
			DeleteSubTree(hItem);

			HTREEITEM hItemTemp = hItem;
			CString strKeyPath, strKeyPathTemp;
			while (1)
			{
				CString strText = m_Tree.GetItemText(hItemTemp);

				if (!strText.CompareNoCase(L"HKEY_CLASSES_ROOT"))
				{
					strKeyPath = CLASSES_ROOT;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_USER"))
				{
					strKeyPath = m_wzhKeyCurrentUser;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
				{
					strKeyPath = LOCAL_MACHINE;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_USERS"))
				{
					strKeyPath = USERS;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
				{
					strKeyPath = CURRENT_CONFIGL;
					break;
				}
				else
				{
					strKeyPathTemp = strText + L"\\" + strKeyPathTemp;
				}

				hItemTemp = m_Tree.GetParentItem(hItemTemp);
			}

			strKeyPath = strKeyPath + L"\\" + strKeyPathTemp;
			EnumSubKeys(strKeyPath, hItem);
			EnumSubSubKeys(strKeyPath, hItem);
		}
	}


	*pResult = 0;
}


void CRegisterManagerDlg::EnumSubSubKeys(CString strKey, HTREEITEM hItem)
{
	if (!strKey.IsEmpty() && hItem != NULL)
	{
		HTREEITEM hChild = m_Tree.GetChildItem(hItem);
		while(hChild != NULL)
		{
			CString strKeyPath = strKey + L"\\" + m_Tree.GetItemText(hChild);
			EnumSubKeys(strKeyPath, hChild, TRUE);  // bSubSubKey 为true,优化枚举速度
			hChild = m_Tree.GetNextSiblingItem(hChild);
		}
	}
}


void CRegisterManagerDlg::OnTvnSelchangedTree(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMTREEVIEW pNMTreeView = reinterpret_cast<LPNMTREEVIEW>(pNMHDR);
	


	HTREEITEM hItem = pNMTreeView->itemNew.hItem;
	CString strKeyShowPath;

	if(m_Tree.GetRootItem() != hItem &&
		hItem != NULL)
	{
		BOOL nRet = FALSE;
		if (!nRet)
		{
			HTREEITEM hItemTemp = hItem;
			CString strKeyPath, strKeyPathTemp;
			while (1)
			{
				CString strText = m_Tree.GetItemText(hItemTemp);

				if (!strText.CompareNoCase(L"HKEY_CLASSES_ROOT"))
				{
					strKeyPath = CLASSES_ROOT;
					strKeyShowPath = L"HKEY_CLASSES_ROOT";
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_USER"))
				{
					strText = m_wzhKeyCurrentUser;
					strKeyShowPath = L"HKEY_CURRENT_USER";
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
				{
					strKeyPath = LOCAL_MACHINE;
					strKeyShowPath = L"HKEY_LOCAL_MACHINE";
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_USERS"))
				{
					strKeyPath = USERS;
					strKeyShowPath = L"HKEY_USERS";
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
				{
					strKeyPath = CURRENT_CONFIGL;
					strKeyShowPath = L"HKEY_CURRENT_CONFIG";
					break;
				}
				else
				{
					strKeyPathTemp = strText + L"\\" + strKeyPathTemp;
				}

				hItemTemp = m_Tree.GetParentItem(hItemTemp);
			}

			strKeyPath = strKeyPath + L"\\" + strKeyPathTemp;
			strKeyShowPath = strKeyShowPath + L"\\" + strKeyPathTemp;
			EnumValues(strKeyPath);   //List 控件显示数据
		}
	}

	strKeyShowPath.TrimRight('\\');
	m_strComboText = strKeyShowPath;
	UpdateData(FALSE);

	*pResult = 0;
}



void CRegisterManagerDlg::EnumValues(CString strKey)
{
	if (strKey.IsEmpty())
	{
		return;
	}

	UNICODE_STRING uniKey;

	if (InitUnicodeString(&uniKey, strKey.GetBuffer()))
	{
		HANDLE hKey;
		OBJECT_ATTRIBUTES oa;

		InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);
		if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
		{
			m_List.DeleteAllItems();
			BOOL bDefault = FALSE;

			for (ULONG i = 0; ; i++)
			{
				ULONG nRetLen = 0;
				BOOL bRet = EnumerateValueKey(hKey,i,KeyValueFullInformation,NULL,0,&nRetLen);
				if (!bRet && GetLastError() == ERROR_NO_MORE_ITEMS) 
				{
					//没有了
					break;
				}
				else if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
				{
					PKEY_VALUE_FULL_INFORMATION Buffer = (PKEY_VALUE_FULL_INFORMATION)malloc(nRetLen + 0x100);
					if (Buffer)
					{
						memset(Buffer, 0, nRetLen + 0x100);
						bRet = EnumerateValueKey(hKey, i, KeyValueFullInformation, Buffer, nRetLen + 0x100, &nRetLen);

						if (bRet)
						{
							CString strName, strType, strData;
							WCHAR wzTempName[1024] = {0};

							strType = GetKeyType(Buffer->Type);
							strData = GetKeyData(Buffer->Type, (WCHAR*)((PBYTE)Buffer + Buffer->DataOffset), Buffer->DataLength);

							// NameLength为0
							if (Buffer->NameLength == 0)
							{
								strName = L"默认";
								bDefault = TRUE;
							}
							else
							{
								wcsncpy_s(wzTempName, 1024, Buffer->Name, Buffer->NameLength / sizeof(WCHAR));
								strName = wzTempName;
							}

							int nImage = 1;
							if (Buffer->Type == REG_SZ ||
								Buffer->Type == REG_EXPAND_SZ ||
								Buffer->Type == REG_MULTI_SZ)
							{
								nImage = 0;
							}

							int n = m_List.InsertItem(m_List.GetItemCount(),strName, nImage);

							if (strType == L"REG_QWORD")
							{
								Sleep(1);
							}
							m_List.SetItemText(n, 1, strType);
							m_List.SetItemText(n, 2, strData);

							if (Buffer->NameLength == 0)
							{
								m_List.SetItemData(n, 1);
							}
						}

						free(Buffer);
					}
				}
			}

			// 添加一个默认的键，内容为空
			if (!bDefault)
			{
				int n = m_List.InsertItem(0,L"默认", 0);
				m_List.SetItemText(n, 1, L"REG_SZ");
				m_List.SetItemText(n, 2, L"数值未设置");
			
				m_List.SetItemData(n, 1);
			}

			CloseHandle(hKey);
		}

			
		FreeUnicodeString(&uniKey);
	}
}


BOOL CRegisterManagerDlg::EnumerateValueKey(IN HANDLE  KeyHandle,
	IN ULONG  ulIndex,
	IN ULONG  ulKeyValueInformationClass,
	OUT PVOID  KeyValueInformation,
	IN ULONG  ulLength,
	OUT PULONG  ulResultLength
	)
{

	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	struct{
		HANDLE hKey;
		ULONG Index;
		ULONG InformationClass;
		ULONG Length;
	}Enum;


	memset(&Enum, 0, sizeof(Enum));

	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}


	Enum.hKey = KeyHandle;
	Enum.Index = ulIndex;
	Enum.InformationClass = ulKeyValueInformationClass;
	Enum.Length = ulLength;

	typedef struct _ENUM_VALUE_
	{
		PULONG RetLength;
		PVOID  ValueInfor;
	}ENUM_VALUE, *PENUM_VALUE;


	ENUM_VALUE EnumValue;
	memset(&EnumValue, 0, sizeof(ENUM_VALUE));
	EnumValue.RetLength = ulResultLength;
	EnumValue.ValueInfor = KeyValueInformation;

	dwRet = DeviceIoControl(g_hDevice,CTL_ENUM_KEY_VALUE,
		&Enum,
		sizeof(Enum),
		&EnumValue,
		sizeof(ENUM_VALUE),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;

}




CString CRegisterManagerDlg::GetKeyType(ULONG ulType)
{
	CString strRet;

	switch (ulType)
	{
	case REG_NONE:
		strRet = L"REG_NONE";
		break;

	case REG_SZ:
		strRet = L"REG_SZ";
		break;

	case REG_EXPAND_SZ:
		strRet = L"REG_EXPAND_SZ";
		break;

	case REG_BINARY:
		strRet = L"REG_BINARY";
		break;

	case REG_DWORD:
		strRet = L"REG_DWORD";
		break;

	case REG_DWORD_BIG_ENDIAN:
		strRet = L"REG_DWORD_BIG_ENDIAN";
		break;

	case REG_LINK:
		strRet = L"REG_LINK";
		break;

	case REG_MULTI_SZ:
		strRet = L"REG_MULTI_SZ";
		break;

	case REG_RESOURCE_LIST:
		strRet = L"REG_RESOURCE_LIST";
		break;

	case REG_FULL_RESOURCE_DESCRIPTOR:
		strRet = L"REG_FULL_RESOURCE_DESCRIPTOR";
		break;

	case REG_RESOURCE_REQUIREMENTS_LIST:
		strRet = L"REG_RESOURCE_REQUIREMENTS_LIST";
		break;

	case REG_QWORD:
		strRet = L"REG_QWORD";
		break;

	default:
		strRet = L"Unknow";
	}

	return strRet;
}

CString CRegisterManagerDlg::GetKeyData(ULONG ulType, WCHAR* wzData, ULONG ulDataLength)
{
	CString strRet;

	if (!ulDataLength)
	{
		return strRet;
	}

	switch (ulType)
	{
	case REG_SZ:
	case REG_EXPAND_SZ:
		strRet = wzData;
		break;

	case REG_LINK:
	case REG_NONE:
	case REG_RESOURCE_REQUIREMENTS_LIST:
	case REG_FULL_RESOURCE_DESCRIPTOR:
	case REG_RESOURCE_LIST:
	case REG_BINARY:
		{
			for (ULONG i = 0; i<ulDataLength; i++)
			{
				CString strTemp;
				strTemp.Format(L"%02x ", *((PBYTE)wzData + i));
				strRet += strTemp;
			}
		}
		break;

	case REG_DWORD:
		strRet.Format(L"0x%08X (%d)", *(PULONG)wzData, *(PULONG)wzData);
		break;

	case REG_DWORD_BIG_ENDIAN:
		{
			BYTE Value[4] = {0};
			Value[0] = *((PBYTE)wzData + 3);
			Value[1] = *((PBYTE)wzData + 2);
			Value[2] = *((PBYTE)wzData + 1);
			Value[3] = *((PBYTE)wzData + 0);
			strRet.Format(L"0x%08X (%d)", *(PULONG)Value, *(PULONG)Value);
		}
		break;
	case REG_MULTI_SZ:
		{
			DWORD len = 0;
			while (wcslen(wzData + len))
			{
				strRet += (wzData + len);
				strRet += L" ";
				len += wcslen(wzData + len) + 1;
			}
		}
		break;

	case REG_QWORD:
		{
			QWORD qwValue = *((PQWORD)wzData);

			strRet.Format(L"0x%08X (%ld)", qwValue, qwValue);
		}

		break;

	default:
		strRet = L"Unknow";
	}

	return strRet;
}

void CRegisterManagerDlg::OnCbnDropdownCombo()
{
	m_ComboBox.ResetContent();
	InitializeComboBox();
}



VOID CRegisterManagerDlg::InitializeComboBox()
{
	

	list <CString> RegPathList;
	GetAllRegPath(RegPathList);
	m_nComboBoxCnt = 0;

	for (list <CString>::iterator ir = RegPathList.begin(); 
		ir != RegPathList.end();
		ir++)
	{
		m_ComboBox.InsertString(m_nComboBoxCnt, *ir);
		m_nComboBoxCnt++;
	}
}



void CRegisterManagerDlg::GetAllRegPath(std::list <CString> &RegPathList)
{
	RegPathList.clear();

	for (std::list <CString>::iterator itor = m_RegPathList.begin();
		itor != m_RegPathList.end();
		itor++)
	{
		RegPathList.push_back(*itor);
	}
}


void CRegisterManagerDlg::InitRegPathList()
{
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellExecuteHooks");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local");
	m_RegPathList.push_back(L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace");
}

void CRegisterManagerDlg::OnBnClickedGoto()
{
	UpdateData(TRUE);
	m_ComboBox.ResetContent();
	m_ComboBox.SetWindowText(m_strComboText);


	if (m_strComboText.IsEmpty())
	{
		return;
	}


	CString strKeyPath = ComboString2KeyPath();
	if (strKeyPath.IsEmpty())
	{
		return;
	}

	CString strHead = m_strComboText.Left(m_strComboText.Find(L"\\"));
	if (strHead.IsEmpty())
	{
		strHead = m_strComboText;
	}

	if (strHead.IsEmpty())
	{
		return;
	}

	HTREEITEM hRootItem = m_Tree.GetRootItem();
	if (hRootItem == NULL)
	{
	
		return;
	}

	HTREEITEM hChild = m_Tree.GetChildItem(hRootItem);
	CString strRoot;

	WCHAR wzhKeyRoot[] = L"HKEY_CLASSES_ROOT";
	WCHAR wzhKCR[] = L"HKCR";

	WCHAR wzhKeyCurrentUser[] = L"HKEY_CURRENT_USER";
	WCHAR wzhKCU[] = L"HKCU";

	WCHAR wzhKeyLocalMachine[] = L"HKEY_LOCAL_MACHINE";
	WCHAR wzhKLM[] = L"HKLM";

	WCHAR wzhKeyUsers[] = L"HKEY_USERS";
	WCHAR wzhKU[] = L"HKU";;

	WCHAR wzhKeyCurrentConfig[] = L"HKEY_CURRENT_CONFIG";
	WCHAR wzhKCC[] = L"HKCC";;

	while(hChild != NULL)
	{
		CString strKey = m_Tree.GetItemText(hChild);

		if ((!strHead.CompareNoCase(wzhKeyRoot) || !strHead.CompareNoCase(wzhKCR)) &&
			!strKey.CompareNoCase(wzhKeyRoot))
		{
			strRoot = CLASSES_ROOT;
			break;
		}
		else if ((!strHead.CompareNoCase(wzhKeyCurrentUser) || !strHead.CompareNoCase(wzhKCU)) &&
			!strKey.CompareNoCase(wzhKeyCurrentUser))
		{
			strRoot = m_wzhKeyCurrentUser;
			break;
		}
		else if ((!strHead.CompareNoCase(wzhKeyLocalMachine) || !strHead.CompareNoCase(wzhKLM)) &&
			!strKey.CompareNoCase(wzhKeyLocalMachine))
		{
			strRoot = LOCAL_MACHINE;
			break;
		}
		else if ((!strHead.CompareNoCase(wzhKeyUsers) || !strHead.CompareNoCase(wzhKU)) &&
			!strKey.CompareNoCase(wzhKeyUsers))
		{
			strRoot = USERS;
			break;
		}
		else if ((!strHead.CompareNoCase(wzhKeyCurrentConfig) || !strHead.CompareNoCase(wzhKCC)) &&
			!strKey.CompareNoCase(wzhKeyCurrentConfig))
		{
			strRoot = CURRENT_CONFIGL;
			break;
		}

		hChild = m_Tree.GetNextSiblingItem(hChild);
	}

	if (hChild == NULL || strRoot.IsEmpty())
	{
		return;
	}

	// 首先展开次根键，类似HKEY_LOCAL_MACHINE，HKEY_USERS
	m_Tree.Expand(hChild, TVE_COLLAPSE);
	EnumSubKeys(strRoot, hChild);
	m_Tree.Expand(hChild, TVE_EXPAND);

	if (m_strComboText.Find(L"\\") != -1)
	{
		CString strKeyEnd = strKeyPath.GetBuffer() + strRoot.GetLength();
		strKeyPath.ReleaseBuffer();

		if (strKeyEnd.IsEmpty())
		{
		
			return;
		}

		strKeyEnd.TrimLeft('\\');

		if (strKeyEnd.IsEmpty())
		{
		
			return;
		}

		CString strTemp;
		BOOL bQuiet = FALSE;

		do 
		{
			strTemp = strKeyEnd.Left(strKeyEnd.Find('\\'));

			if (strTemp.IsEmpty())
			{
				strTemp = strKeyEnd;
				bQuiet = TRUE;
			}

			hChild = GetTreeSubItemByName(hChild, strTemp);
			if (hChild == NULL)
			{
				CString strMsgBox; 

				strMsgBox = L"该项不存在";
				strMsgBox += L" \'" + m_strComboText + L"\'"; 
				MessageBox(strMsgBox, L"Registry", MB_OK | MB_ICONINFORMATION);
				break;
			}

			strRoot += L"\\" + strTemp;

			if (bQuiet)
			{
				EnumValues(strRoot);
				m_Tree.Expand(hChild, TVE_EXPAND);
				m_Tree.Select(hChild, TVGN_FIRSTVISIBLE);
				m_Tree.SelectItem(hChild);
				m_Tree.SetItemState(hChild, TVIS_DROPHILITED | TVIS_BOLD, TVIS_DROPHILITED | TVIS_BOLD);
				//m_hChild = hChild;
			}
			else
			{
				EnumSubKeys(strRoot, hChild);
				m_Tree.Expand(hChild, TVE_EXPAND);
			}

			strKeyEnd = strKeyEnd.Right(strKeyEnd.GetLength() - strKeyEnd.Find('\\') - 1);

		} while (!bQuiet);
	}
}




CString CRegisterManagerDlg::ComboString2KeyPath()
{
	CString strHead = m_strComboText.Left(m_strComboText.Find('\\'));
	CString strRight = m_strComboText.Right(m_strComboText.GetLength() - m_strComboText.Find('\\'));
	CString strKeyPath;

	if (strHead.IsEmpty())
	{
		strHead = strRight;
		strRight.Empty();
	}

	WCHAR wzhKeyRoot[] = L"HKEY_CLASSES_ROOT";
	WCHAR wzhKCR[] = L"HKCR";

	WCHAR wzhKeyCurrentUser[] = L"HKEY_CURRENT_USER";
	WCHAR wzhKCU[] = L"HKCU";

	WCHAR wzhKeyLocalMachine[] = L"HKEY_LOCAL_MACHINE";
	WCHAR wzhKLM[] = L"HKLM";

	WCHAR wzhKeyUsers[] = L"HKEY_USERS";
	WCHAR wzhKU[] = L"HKU";;

	WCHAR wzhKeyCurrentConfig[] = L"HKEY_CURRENT_CONFIG";
	WCHAR wzhKCC[] = L"HKCC";;

	if (!strHead.CompareNoCase(wzhKeyRoot) || !strHead.CompareNoCase(wzhKCR))
	{
		strKeyPath = CLASSES_ROOT;
	}
	else if (!strHead.CompareNoCase(wzhKeyCurrentUser) || !strHead.CompareNoCase(wzhKCU))
	{
		strKeyPath = m_wzhKeyCurrentUser;
	}
	else if (!strHead.CompareNoCase(wzhKeyLocalMachine) || !strHead.CompareNoCase(wzhKLM))
	{
		strKeyPath = LOCAL_MACHINE;
	}
	else if (!strHead.CompareNoCase(wzhKeyUsers) || !strHead.CompareNoCase(wzhKU))
	{
		strKeyPath = USERS;
	}
	else if (!strHead.CompareNoCase(wzhKeyCurrentConfig) || !strHead.CompareNoCase(wzhKCC))
	{
		strKeyPath = CURRENT_CONFIGL;
	}

	strKeyPath += strRight;
	strKeyPath.TrimRight('\\');

	return strKeyPath;
}



HTREEITEM CRegisterManagerDlg::GetTreeSubItemByName(HTREEITEM hPatentItem, CString strName)
{
	HTREEITEM hChild = m_Tree.GetChildItem(hPatentItem);
	HTREEITEM hRetItem = NULL;

	while(hChild != NULL)
	{
		CString strKey = m_Tree.GetItemText(hChild);

		if (!strKey.CompareNoCase(strName))
		{
			hRetItem = hChild;
			break;
		}
		else if (!strKey.CompareNoCase(strName))
		{
			hRetItem = hChild;
			break;
		}
		else if (!strKey.CompareNoCase(strName))
		{
			hRetItem = hChild;
			break;
		}
		else if (!strKey.CompareNoCase(strName))
		{
			hRetItem = hChild;
			break;
		}
		else if (!strKey.CompareNoCase(strName))
		{
			hRetItem = hChild;
			break;
		}

		hChild = m_Tree.GetNextSiblingItem(hChild);
	}

	return hRetItem;
}


BOOL CRegisterManagerDlg::PreTranslateMessage(MSG* pMsg)
{
	if(pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE) return TRUE; 

	if(pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN) 
	{
		OnBnClickedGoto();
		return TRUE;
	}


	return CDialogEx::PreTranslateMessage(pMsg);
}



void CRegisterManagerDlg::OnNMRClickTree(NMHDR *pNMHDR, LRESULT *pResult)
{

	CPoint Point;

	GetCursorPos(&Point);
	m_Tree.ScreenToClient(&Point);

	m_RightClickTreeItem = m_Tree.HitTest(Point, NULL);
	CString strItemText;

	if ( m_RightClickTreeItem != NULL )
	{ 
		strItemText = m_Tree.GetItemText(m_RightClickTreeItem);
		m_Tree.SelectItem(m_RightClickTreeItem);
	}


	if (m_RightClickTreeItem == NULL ||
		!strItemText.CompareNoCase(L"我的电脑"))
	{

	}

	else
	{

		CMenu ExMenu;
		ExMenu.CreatePopupMenu();
		ExMenu.AppendMenu(MF_STRING, ID_STRING_VALUE,L"字符串值");
		ExMenu.AppendMenu(MF_STRING, ID_BINARY_VALUE,L"二进制值");
		ExMenu.AppendMenu(MF_STRING, ID_DWORD_VALUE, L"DWORD值");
		ExMenu.AppendMenu(MF_STRING, ID_QWORD_VALUE, L"QWORD值");
		ExMenu.AppendMenu(MF_STRING, ID_MUI_STRING_VALUE,L"多字符串值");
		ExMenu.AppendMenu(MF_STRING, ID_EXPAND_STRING_VALUE,L"可扩充字符串值");



	    CMenu Menu;
		Menu.CreatePopupMenu();
		Menu.AppendMenu(MF_STRING, ID_REG_REFRESH,L"刷新");
		Menu.AppendMenu(MF_SEPARATOR);
		Menu.AppendMenu(MF_STRING, ID_REG_LOOK_FOR,L"查找");
		Menu.AppendMenu(MF_SEPARATOR);
		Menu.AppendMenu(MF_STRING, ID_REG_NEW_KEY,L"新建项");
		Menu.AppendMenu(MF_POPUP, (UINT)ExMenu.m_hMenu,L"新建值");
		Menu.AppendMenu(MF_SEPARATOR);
		Menu.AppendMenu(MF_STRING, ID_REG_DELETE,L"删除");
		Menu.AppendMenu(MF_STRING, ID_REG_RENAME, L"重命名");

		Menu.AppendMenu(MF_SEPARATOR);
		Menu.AppendMenu(MF_STRING, ID_REG_INPORT,L"导入");
		Menu.AppendMenu(MF_STRING, ID_REG_EXPORT,L"导出");
		Menu.AppendMenu(MF_SEPARATOR);
	
		Menu.AppendMenu(MF_STRING, ID_REG_COPY_KEY_NAME,L"拷贝键名");
		Menu.AppendMenu(MF_STRING, ID_REG_COPY_FULL_KEY_NAME,L"拷贝键完整路径");
		Menu.AppendMenu(MF_SEPARATOR);
		Menu.AppendMenu(MF_STRING, ID_REG_ADD_TO_QUICK_ADDRESS,L"添加到快速定位");
		Menu.AppendMenu(MF_SEPARATOR);
		int x = GetSystemMetrics(SM_CXMENUCHECK);
		int y = GetSystemMetrics(SM_CYMENUCHECK);


		if (x >= 15 && y >= 15)
		{
			Menu.SetMenuItemBitmaps(ID_REG_REFRESH, MF_BYCOMMAND, &m_bmRefresh, &m_bmRefresh);
			Menu.SetMenuItemBitmaps(ID_REG_LOOK_FOR, MF_BYCOMMAND, &m_bmLookfor, &m_bmLookfor);
			Menu.SetMenuItemBitmaps(ID_REG_DELETE, MF_BYCOMMAND, &m_bmDelete, &m_bmDelete);

			Menu.SetMenuItemBitmaps(ID_REG_COPY_KEY_NAME, MF_BYCOMMAND, &m_bmCopy, &m_bmCopy);
			Menu.SetMenuItemBitmaps(ID_REG_COPY_FULL_KEY_NAME, MF_BYCOMMAND, &m_bmCopy, &m_bmCopy);


			Menu.SetMenuItemBitmaps(ID_REG_INPORT, MF_BYCOMMAND, &m_bmExport, &m_bmExport);
			Menu.SetMenuItemBitmaps(ID_REG_EXPORT, MF_BYCOMMAND, &m_bmExport, &m_bmExport);
		}


		if (!strItemText.CompareNoCase(L"HKEY_CLASSES_ROOT") ||
			!strItemText.CompareNoCase(L"HKEY_CURRENT_USER") ||
			!strItemText.CompareNoCase(L"HKEY_LOCAL_MACHINE") ||
			!strItemText.CompareNoCase(L"HKEY_USERS") ||
			!strItemText.CompareNoCase(L"HKEY_CURRENT_CONFIG") )
		{
			Menu.EnableMenuItem(ID_REG_DELETE, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
			Menu.EnableMenuItem(ID_REG_RENAME, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
		}

		CPoint Point;
		GetCursorPos(&Point);
		Menu.TrackPopupMenu(TPM_RIGHTBUTTON, Point.x, Point.y, this);
		Menu.DestroyMenu();
		ExMenu.DestroyMenu();
	}



	*pResult = 0;
}


void CRegisterManagerDlg::OnRegRefresh()
{
	CString  strItemText;

	if ( m_RightClickTreeItem != NULL )
	{ 
		strItemText = m_Tree.GetItemText(m_RightClickTreeItem);
	}

	// 如果是computer这个根键，那么就直接初始化注册表
	if (m_RightClickTreeItem == NULL ||
		!strItemText.CompareNoCase(L"我的电脑"))
	{
		InitRegistry();
	}
	else
	{
		// 当是打开状态才刷新
		if(m_RightClickTreeItem != NULL && 
			(TVIS_EXPANDED & m_Tree.GetItemState(m_RightClickTreeItem, TVIS_EXPANDED)))
		{
			m_Tree.Expand(m_RightClickTreeItem, TVE_COLLAPSE);
			DeleteSubTree(m_RightClickTreeItem);

			HTREEITEM hItemTemp = m_RightClickTreeItem;
			CString strKeyPath, strKeyPathTemp;

			while (1)
			{
				CString strText = m_Tree.GetItemText(hItemTemp);

				if (!strText.CompareNoCase(L"HKEY_CLASSES_ROOT"))
				{
					strKeyPath = CLASSES_ROOT;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_USER"))
				{
					strKeyPath = m_wzhKeyCurrentUser;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
				{
					strKeyPath = LOCAL_MACHINE;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_USERS"))
				{
					strKeyPath = USERS;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
				{
					strKeyPath = CURRENT_CONFIGL;
					break;
				}
				else
				{
					strKeyPathTemp = strText + L"\\" + strKeyPathTemp;
				}

				hItemTemp = m_Tree.GetParentItem(hItemTemp);
			}

			strKeyPath = strKeyPath + L"\\" + strKeyPathTemp;
			EnumSubKeys(strKeyPath, m_RightClickTreeItem);
			EnumSubSubKeys(strKeyPath, m_RightClickTreeItem);

			m_Tree.Expand(m_RightClickTreeItem, TVE_EXPAND);
		}
	}
}





void CRegisterManagerDlg::OnRegNewKey()
{
	CString strKeyPath = String2KeyPath();
	if (strKeyPath.IsEmpty())
	{
		return;
	}

	CKeyDlg CreateKeyDlg;   //这个Dlg 会在新建和重命名中 被创建 所以定义一个DlgType
	CString strNewKey;

	CreateKeyDlg.m_nDlgType = enumCreateKey;
	if (CreateKeyDlg.DoModal() == IDOK)
	{
		strNewKey = CreateKeyDlg.m_strKeyNameEdit;
	}

	if (strNewKey.IsEmpty())
	{
		return;
	}

	CString strKeyPathTemp = strKeyPath + L"\\";
	strKeyPathTemp += strNewKey;

	UNICODE_STRING uniKey;
	if (InitUnicodeString(&uniKey, strKeyPathTemp.GetBuffer()))
	{
		HANDLE hKey;
		OBJECT_ATTRIBUTES oa;
		ULONG Disposition = 0;

		InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

		if (CreateKey(&hKey, KEY_ALL_ACCESS, &oa, 0, NULL, 0, &Disposition))
		{
			if (Disposition == REG_OPENED_EXISTING_KEY)
			{
				MessageBox(L"该键已经存在",L"Shine", MB_ICONERROR | MB_OK);
			}
			else
			{
			
				HTREEITEM hItem = m_Tree.GetSelectedItem();
				m_Tree.InsertItem(strNewKey, 1, 2, hItem, TVI_LAST);
			}

			CloseHandle(hKey);
		}

		FreeUnicodeString(&uniKey);
	}
}




CString CRegisterManagerDlg::String2KeyPath()
{
	CString strHead = m_strComboText.Left(m_strComboText.Find('\\'));
	CString strRight = m_strComboText.Right(m_strComboText.GetLength() - m_strComboText.Find('\\'));
	CString strKeyPath;

	if (strHead.IsEmpty())
	{
		strHead = strRight;
		strRight.Empty();
	}

	if (!strHead.CompareNoCase(L"HKEY_CLASSES_ROOT"))
	{
		strKeyPath = CLASSES_ROOT;
	}
	else if (!strHead.CompareNoCase(L"HKEY_CURRENT_USER"))
	{
		strKeyPath = m_wzhKeyCurrentUser;
	}
	else if (!strHead.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
	{
		strKeyPath = LOCAL_MACHINE;
	}
	else if (!strHead.CompareNoCase(L"HKEY_USERS"))
	{
		strKeyPath = USERS;
	}
	else if (!strHead.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
	{
		strKeyPath = CURRENT_CONFIGL;
	}

	strKeyPath += strRight;

	return strKeyPath;
}



BOOL CRegisterManagerDlg::CreateKey(
	OUT PHANDLE  KeyHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES  ObjectAttributes,
	IN ULONG  ulTitleIndex,
	IN PUNICODE_STRING  uniClass,
	IN ULONG  ulCreateOptions,
	OUT PULONG  Disposition
	)

{

	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	struct{
		ACCESS_MASK DesiredAccess;
		POBJECT_ATTRIBUTES ObjectAttributes;
	}Create;

	memset(&Create, 0, sizeof(Create));
	Create.DesiredAccess = DesiredAccess;
	Create.ObjectAttributes = ObjectAttributes;

	

	typedef struct _CREATE_VALUE_
	{
		PHANDLE KeyHandle;
		PULONG  Disposition;
	}CREATE_VALUE, *PCREATE_VALUE;


	CREATE_VALUE CreateValue;
	memset(&CreateValue, 0, sizeof(CREATE_VALUE));
	

	CreateValue.KeyHandle = KeyHandle;
	CreateValue.Disposition = Disposition;

	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}

	

	dwRet = DeviceIoControl(g_hDevice,CTL_CREATE_KEY,
		&Create,
		sizeof(Create),
		&CreateValue,
		sizeof(CREATE_VALUE),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;
}


void CRegisterManagerDlg::OnStringValue()
{
	SetValueKey(REG_SZ,NULL,0);
}




void CRegisterManagerDlg::SetValueKey(ULONG ulType, PVOID Data, ULONG ulDataSize)
{
	CString strKeyPath = String2KeyPath();
	if (strKeyPath.IsEmpty())
	{
		return;
	}

	CKeyDlg SetValueKeyDlg;
	CString strValue;

	SetValueKeyDlg.m_nDlgType = enumSetValueKey;
	if (SetValueKeyDlg.DoModal() == IDOK)
	{
		strValue = SetValueKeyDlg.m_strKeyNameEdit;
	}

	if (strValue.IsEmpty())
	{
		return;
	}

	UNICODE_STRING uniKey;
	if (InitUnicodeString(&uniKey, strKeyPath.GetBuffer()))
	{
		HANDLE hKey;
		OBJECT_ATTRIBUTES oa;

		InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

		if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
		{
			UNICODE_STRING uniValue;

			if (InitUnicodeString(&uniValue, strValue.GetBuffer()))
			{
				SetValueKey(hKey, &uniValue, 0, ulType, Data, ulDataSize);
				FreeUnicodeString(&uniValue);
			}

			CloseHandle(hKey);
		}

		FreeUnicodeString(&uniKey);
	}

	OnRegListRefresh();   //刷新ControlList
}




BOOL CRegisterManagerDlg::SetValueKey(
	IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  uniValueName,
	IN ULONG  ulTitleIndex,
	IN ULONG  ulType,
	IN PVOID  Data,
	IN ULONG  ulDataSize
	)
{



	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	struct{
		HANDLE hKey;
		PUNICODE_STRING ValueName;
		ULONG Type;
		PVOID Data;
		ULONG DataSize;
	}Set;

	memset(&Set, 0, sizeof(Set));

	Set.hKey = KeyHandle;
	Set.ValueName = uniValueName;
	Set.Type = ulType;
	Set.Data = Data;
	Set.DataSize = ulDataSize;

	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}



	dwRet = DeviceIoControl(g_hDevice,CTL_SET_KEY_VALUE,
		&Set,
		sizeof(Set),
		NULL,0,
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;
}



void CRegisterManagerDlg::OnRegListRefresh()
{
	CString strKeyPath = String2KeyPath();
	EnumValues(strKeyPath);
}

void CRegisterManagerDlg::OnBinaryValue()
{
	SetValueKey(REG_BINARY,NULL,0);
}


void CRegisterManagerDlg::OnDwordValue()
{
	DWORD dwValue = 0;
	SetValueKey(REG_DWORD,&dwValue,sizeof(DWORD));
}


void CRegisterManagerDlg::OnQwordValue()
{
	QWORD dwValue = 0;
	SetValueKey(REG_QWORD,&dwValue,sizeof(QWORD));
}

void CRegisterManagerDlg::OnMuiStringValue()
{
	SetValueKey(REG_MULTI_SZ,NULL,0);
}


void CRegisterManagerDlg::OnExpandStringValue()
{
	SetValueKey(REG_EXPAND_SZ,NULL,0);
}



void CRegisterManagerDlg::OnRegDelete()
{
	if (m_RightClickTreeItem != NULL)
	{
		if (MessageBox(L"确定删除该项吗？",L"Shine", MB_YESNO | MB_ICONQUESTION) != IDYES)
		{
			return;
		}

		HTREEITEM hItemTemp = m_RightClickTreeItem;
		CString strKeyPath, strKeyPathTemp;

		while (1)
		{
			CString strText = m_Tree.GetItemText(hItemTemp);

			if (!strText.CompareNoCase(L"HKEY_CLASSES_ROOT"))
			{
				strKeyPath = CLASSES_ROOT;
				break;
			}
			else if (!strText.CompareNoCase(L"HKEY_CURRENT_USER"))
			{
				strKeyPath = m_wzhKeyCurrentUser;
				break;
			}
			else if (!strText.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
			{
				strKeyPath = LOCAL_MACHINE;
				break;
			}
			else if (!strText.CompareNoCase(L"HKEY_USERS"))
			{
				strKeyPath = USERS;
				break;
			}
			else if (!strText.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
			{
				strKeyPath = CURRENT_CONFIGL;
				break;
			}
			else
			{
				strKeyPathTemp = strText + L"\\" + strKeyPathTemp;
			}

			hItemTemp = m_Tree.GetParentItem(hItemTemp);
		}

		strKeyPath = strKeyPath + L"\\" + strKeyPathTemp;
		strKeyPath.TrimRight('\\');

		m_Tree.Expand(m_RightClickTreeItem, TVE_COLLAPSE);
		DeleteKeyAndSubKeys(strKeyPath);
		UpdateKey(strKeyPath, m_RightClickTreeItem);   //刷新Tree控件
	}
}



void CRegisterManagerDlg::DeleteKeyAndSubKeys(CString strKey)
{
	if (strKey.IsEmpty())
	{
		return;
	}

	UNICODE_STRING uniKey;
	BOOL bQuit = FALSE;
	if (InitUnicodeString(&uniKey, strKey.GetBuffer()))
	{
		strKey.ReleaseBuffer();

		HANDLE hKey;
		OBJECT_ATTRIBUTES oa;

		InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

		if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
		{
			ULONG i = 0;
			while (1)
			{
				if (bQuit)
				{
					break;
				}

				ULONG ulRetLen = 0;
				BOOL bRet = EnumerateKey(hKey, i, KeyBasicInformation, NULL, 0, &ulRetLen);
				if (!bRet && GetLastError() == ERROR_NO_MORE_ITEMS) // STATUS_NO_MORE_ENTRIES
				{
					if (!DeleteKey(hKey) )
					{
						
						bQuit = TRUE;
					}

					break;
				}
				else if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) // STATUS_BUFFER_TOO_SMALL
				{
					PKEY_BASIC_INFORMATION Buffer = (PKEY_BASIC_INFORMATION)malloc(ulRetLen + 100);

					if (Buffer)
					{
						memset(Buffer, 0, ulRetLen + 100);
						bRet = EnumerateKey(hKey, i, KeyBasicInformation, Buffer, ulRetLen + 100, &ulRetLen);

						if (bRet && Buffer->NameLength)
						{
							WCHAR wzName[1024] = {0};
							wcsncpy_s(wzName, 1024, Buffer->Name, Buffer->NameLength / sizeof(WCHAR));
							CString strKeyTemp = strKey + L"\\" + wzName;
							DeleteKeyAndSubKeys(strKeyTemp);
						}
						else
						{
							break;
						}

						free(Buffer);
					}
				}
			}

			CloseHandle(hKey);
		}

		FreeUnicodeString(&uniKey);
	}
}


BOOL CRegisterManagerDlg::DeleteKey(IN HANDLE KeyHandle)
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;
	struct   
	{
		HANDLE  hKey;
	}Delete;
	
	memset(&Delete, 0, sizeof(Delete));
	Delete.hKey = KeyHandle;



	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}



	dwRet = DeviceIoControl(g_hDevice,CTL_DELETE_KEY,
		&Delete,
		sizeof(Delete),
		NULL,0,
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;
}



void CRegisterManagerDlg::UpdateKey(CString strKey, HTREEITEM hItem)
{
	if ( !strKey.IsEmpty() && hItem != NULL )
	{
		DeleteSubTree(hItem);

		UNICODE_STRING uniKey;

		if (InitUnicodeString(&uniKey, strKey.GetBuffer()))
		{
			HANDLE hKey;
			OBJECT_ATTRIBUTES oa;

			InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

			if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
			{
				for (ULONG i = 0; ; i++)
				{
					ULONG ulRetLen = 0;
					BOOL bRet = EnumerateKey(hKey, i, KeyBasicInformation, NULL, 0, &ulRetLen);

					if (!bRet && GetLastError() == ERROR_NO_MORE_ITEMS) 
					{
						break;
					}
					else if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
					{
						PKEY_BASIC_INFORMATION Buffer = (PKEY_BASIC_INFORMATION)malloc(ulRetLen + 0x100);
						if (Buffer)
						{
							memset(Buffer, 0, ulRetLen + 0x100);
							bRet = EnumerateKey(hKey, i, KeyBasicInformation, Buffer, ulRetLen + 0x100, &ulRetLen);

							if (bRet)
							{
								m_Tree.InsertItem(Buffer->Name, 1, 2, hItem, TVI_LAST);
							}

							free(Buffer);
						}
					}
				}

				CloseHandle(hKey);
			}
			else
			{
				m_Tree.DeleteItem(hItem);
			}

			FreeUnicodeString(&uniKey);
		}
	}
}

void CRegisterManagerDlg::OnRegRename()
{
	CString strKeyPath = String2KeyPath();
	if (strKeyPath.IsEmpty())
	{
		return;
	}

	CString strKeyName = m_Tree.GetItemText(m_RightClickTreeItem);
	CKeyDlg RenameKeyDlg;
	RenameKeyDlg.m_nDlgType = enumRenameKey;
	RenameKeyDlg.m_strKeyNameEdit = strKeyName;
	if (RenameKeyDlg.DoModal() == IDOK)
	{
		CString strNewKeyName = RenameKeyDlg.m_strKeyNameEdit;
		if (strNewKeyName.CompareNoCase(strKeyName))   //如果两个名字不相等
		{
			UNICODE_STRING uniKey;
			if (strNewKeyName.GetBuffer()!=NULL)
			{
				HANDLE hKey;
				OBJECT_ATTRIBUTES oa;
				HTREEITEM hItemTemp = m_RightClickTreeItem;
				CString strKeyPath, strKeyPathTemp;
				while (1)
				{
					CString strText = m_Tree.GetItemText(hItemTemp);

					if (!strText.CompareNoCase(L"HKEY_CLASSES_ROOT"))
					{
						strKeyPath = CLASSES_ROOT;
						break;
					}
					else if (!strText.CompareNoCase(L"HKEY_CURRENT_USER"))
					{
						strKeyPath = m_wzhKeyCurrentUser;
						break;
					}
					else if (!strText.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
					{
						strKeyPath = LOCAL_MACHINE;
						break;
					}
					else if (!strText.CompareNoCase(L"HKEY_USERS"))
					{
						strKeyPath = USERS;
						break;
					}
					else if (!strText.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
					{
						strKeyPath = CURRENT_CONFIGL;
						break;
					}
					else
					{
						strKeyPathTemp = strText + L"\\" + strKeyPathTemp;
					}

					hItemTemp = m_Tree.GetParentItem(hItemTemp);
				}

				strKeyPath = strKeyPath + L"\\" + strKeyPathTemp;

				InitUnicodeString(&uniKey, strKeyPath.GetBuffer());

				InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

				if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
				{
					UNICODE_STRING uniNewKey;
					if (InitUnicodeString(&uniNewKey,strNewKeyName.GetBuffer()))
					{
						if (RenameKey(hKey, &uniNewKey))
						{
							m_Tree.SetItemText(m_RightClickTreeItem, strNewKeyName);  //在树控件上修改成新的名字


							//修正ComboBox数据
							CString strTemp = m_strComboText.Left(m_strComboText.ReverseFind('\\'));

							strTemp+=L"\\";

							strTemp+=strNewKeyName;


							m_ComboBox.SetWindowText(strTemp);


						}

						FreeUnicodeString(&uniNewKey);
					}

					CloseHandle(hKey);
				}

				FreeUnicodeString(&uniKey);
			}
		}
	}
}


BOOL CRegisterManagerDlg::RenameKey(
	IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  uniNewName
	)
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	struct
	{
		HANDLE hKey;
		PUNICODE_STRING  uniNewName;
	}Rename;

	memset(&Rename, 0, sizeof(Rename));
	
	Rename.hKey = KeyHandle;
	Rename.uniNewName = uniNewName;

	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}



	dwRet = DeviceIoControl(g_hDevice,CTL_RENAME_KEY,
		&Rename,
		sizeof(Rename),
		NULL,0,
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;
}



void CRegisterManagerDlg::OnRegCopyKeyName()
{
	UpdateData(TRUE);
	CString strKeyName = m_strComboText.Right(m_strComboText.GetLength() - m_strComboText.ReverseFind('\\') - 1);
	if (strKeyName.IsEmpty())
	{
		strKeyName = m_strComboText;
	}

	SetStringToClipboard(strKeyName);
}


void CRegisterManagerDlg::OnRegCopyFullKeyName()
{
	UpdateData(TRUE);
	SetStringToClipboard(m_strComboText);
}



BOOL CRegisterManagerDlg::SetStringToClipboard(CString strImageName)
{
	if (strImageName.IsEmpty())
	{
		return TRUE;
	}

	BOOL bRet = FALSE;

	if( OpenClipboard() )
	{
		HGLOBAL hClipBuffer = 0;
		WCHAR* wzBuffer = NULL;

		EmptyClipboard();
		hClipBuffer = LocalAlloc(GMEM_ZEROINIT, (strImageName.GetLength() + 1) * sizeof(WCHAR));
		if (hClipBuffer)
		{
			wzBuffer = (WCHAR*)GlobalLock(hClipBuffer);
			if (wzBuffer)
			{
				wcsncpy_s(wzBuffer, strImageName.GetLength() + 1, strImageName.GetBuffer(), strImageName.GetLength());
				strImageName.ReleaseBuffer();
				SetClipboardData(CF_UNICODETEXT, hClipBuffer);
				GlobalUnlock(hClipBuffer);

				bRet = TRUE;
			}
		}

		CloseClipboard();
	}

	return bRet;
}


void CRegisterManagerDlg::OnRegAddToQuickAddress()
{
	UpdateData(TRUE);
	if (!m_strComboText.IsEmpty())
	{
		m_RegPathList.push_back(m_strComboText);
		m_nComboBoxCnt++;

		UpdateData(FALSE);
	}
}


void CRegisterManagerDlg::OnRegInport()
{
	CFileDialog FileDlg(TRUE);			
	FileDlg.m_ofn.lpstrTitle = L"Open Register File";
	FileDlg.m_ofn.lpstrFilter = L"Registration Files(*.reg)\0*.reg\0\0";

	if (IDOK == FileDlg.DoModal())
	{
		CString strPath = FileDlg.GetPathName();
		ShellImportRegister(strPath);

		MessageBox(L"导入成功",L"Shine", MB_OK | MB_ICONINFORMATION);

		OnRegRefresh();
	}	
}


VOID CRegisterManagerDlg::ShellImportRegister(
	LPCTSTR ImportFile)    //导入的注册表文件
{
	CString strItem(ImportFile);
	CString strParameters;
	strParameters = L"/s \"" + strItem + L"\"";
	ShellExecute(NULL, L"open", L"regedit.exe",
		strParameters, NULL, SW_HIDE);

}

void CRegisterManagerDlg::OnRegExport()
{
	CString strItemText;

	if ( m_RightClickTreeItem != NULL )
	{ 
		strItemText = m_Tree.GetItemText(m_RightClickTreeItem);

		if (strItemText.CompareNoCase(L"我的电脑"))
		{
			HTREEITEM hItemTemp = m_RightClickTreeItem;
			CString strKeyPath, strKeyPathTemp;

			while (1)
			{
				CString strText = m_Tree.GetItemText(hItemTemp);

				if (!strText.CompareNoCase(L"HKEY_CLASSES_ROOT"))
				{
					strKeyPath = L"HKEY_CLASSES_ROOT";
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_USER"))
				{
					strKeyPath = m_wzhKeyCurrentUser;
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
				{
					strKeyPath = L"HKEY_LOCAL_MACHINE";
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_USERS"))
				{
					strKeyPath = L"HKEY_USERS";
					break;
				}
				else if (!strText.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
				{
					strKeyPath = L"HKEY_CURRENT_CONFIG";
					break;
				}
				else
				{
					strKeyPathTemp = strText + L"\\" + strKeyPathTemp;
				}

				hItemTemp = m_Tree.GetParentItem(hItemTemp);
			}

			strKeyPath = strKeyPath + L"\\" + strKeyPathTemp;
			strKeyPath.TrimRight('\\');

			CString strFileName = strKeyPath.Right(strKeyPath.GetLength() - strKeyPath.ReverseFind(L'\\') - 1);
			CFileDialog FileDlg( FALSE, 0, strFileName, 0, L"Register Files (*.reg)|*.reg;|All Files (*.*)|*.*||", 0 );
			if (IDOK == FileDlg.DoModal())
			{
				CString strFilePath = FileDlg.GetFileName();
				CString strExtern = strFilePath.Right(4);

			

				if (strExtern.CompareNoCase(L".reg"))
				{
					strFilePath += L".reg";
				}

				if ( !PathFileExists(strFilePath) ||
					(PathFileExists(strFilePath) && 
					MessageBox(L"文件已经存在",L"Shine", MB_YESNO | MB_ICONQUESTION) == IDYES &&
					DeleteFile(strFilePath)))
				{
					ShellExportRegister(strKeyPath, strFilePath);

					MessageBox(L"导出成功",L"Shine", MB_OK | MB_ICONINFORMATION);
				}
			}
		}
	}
}


VOID CRegisterManagerDlg::ShellExportRegister(
	CString strItem,		
	CString strFileName)	
{
	CString strParameters = L"/e \"" + strFileName + L"\" \"" + strItem + L"\"";
	ShellExecute(0, L"open", L"regedit.exe", strParameters, NULL, SW_SHOWNORMAL);
}


void CRegisterManagerDlg::OnRegLookFor()
{
	m_FindRegDlg = new CRegFindDlg();
	m_FindRegDlg->m_strSearchInKey = m_strComboText;
	m_FindRegDlg->Create(IDD_FIND_REG_DIALOG);
	m_FindRegDlg->ShowWindow(SW_SHOWNORMAL);
}



void CRegisterManagerDlg::JmpToReg(CString strKey, CString strData)
{
	if (strKey.IsEmpty())
	{
		return;
	}

	JmpToRegCommon(strKey, strData);
}


void CRegisterManagerDlg::JmpToRegCommon(CString strKey, CString strData)
{
	HTREEITEM hRootItem = m_Tree.GetRootItem();
	if (hRootItem == NULL)
	{
		return;
	}

	HTREEITEM hChild = m_Tree.GetChildItem(hRootItem);
	CString strRoot;

	while(hChild != NULL)
	{
		CString strKeyTemp = m_Tree.GetItemText(hChild);

		if (!_wcsnicmp(strKey.GetBuffer(), L"HKEY_CLASSES_ROOT", wcslen(L"HKEY_CLASSES_ROOT")) &&
			!strKeyTemp.CompareNoCase(L"HKEY_CLASSES_ROOT"))
		{
			strRoot = CLASSES_ROOT;
			break;
		}
		else if (!_wcsnicmp(strKey.GetBuffer(), L"HKEY_CURRENT_USER", wcslen(L"HKEY_CURRENT_USER")) &&
			!strKeyTemp.CompareNoCase(L"HKEY_CURRENT_USER"))
		{
			strRoot = m_wzhKeyCurrentUser;
			break;
		}
		else if (!_wcsnicmp(strKey.GetBuffer(), L"HKEY_LOCAL_MACHINE", wcslen(L"HKEY_LOCAL_MACHINE")) &&
			!strKeyTemp.CompareNoCase(L"HKEY_LOCAL_MACHINE"))
		{
			strRoot = LOCAL_MACHINE;
			break;
		}
		else if (!_wcsnicmp(strKey.GetBuffer(), L"HKEY_USERS", wcslen(L"HKEY_USERS")) &&
			!strKeyTemp.CompareNoCase(L"HKEY_USERS"))
		{
			strRoot = USERS;
			break;
		}
		else if (!_wcsnicmp(strKey.GetBuffer(), L"HKEY_CURRENT_CONFIG", wcslen(L"HKEY_CURRENT_CONFIG")) &&
			!strKeyTemp.CompareNoCase(L"HKEY_CURRENT_CONFIG"))
		{
			strRoot = CURRENT_CONFIGL;
			break;
		}

		hChild = m_Tree.GetNextSiblingItem(hChild);
	}

	if (hChild == NULL || strRoot.IsEmpty())
	{
		return;
	}

	m_Tree.Expand(hChild, TVE_COLLAPSE);
	EnumSubKeys(strRoot, hChild);
	m_Tree.Expand(hChild, TVE_EXPAND);

	if (strKey.Find(L"\\") != -1)
	{
		CString strKeyEnd = strKey.Right(strKey.GetLength() - strKey.Find('\\') - 1);

		if (strKeyEnd.IsEmpty())
		{
			return;
		}

		strKeyEnd.TrimLeft('\\');

		if (strKeyEnd.IsEmpty())
		{
			return;
		}

		CString strTemp;
		BOOL bQuiet = FALSE;

		do 
		{
			strTemp = strKeyEnd.Left(strKeyEnd.Find('\\'));

			if (strTemp.IsEmpty())
			{
				strTemp = strKeyEnd;
				bQuiet = TRUE;
			}

			hChild = GetTreeSubItemByName(hChild, strTemp);
			if (hChild == NULL)
			{
				CString strMsgBox; 

				strMsgBox = L"不存在";
				strMsgBox += L" \'" + strKey + L"\'"; 
				MessageBox(strMsgBox, L"Shine", MB_OK | MB_ICONINFORMATION);
				break;
			}

			strRoot += L"\\" + strTemp;

			if (bQuiet)
			{
				EnumValues(strRoot);
				m_Tree.Expand(hChild, TVE_EXPAND);
				m_Tree.Select(hChild, TVGN_FIRSTVISIBLE);
				m_Tree.SelectItem(hChild);
				m_Tree.SetItemState(hChild, TVIS_DROPHILITED | TVIS_BOLD, TVIS_DROPHILITED | TVIS_BOLD);
				
				if (!strData.IsEmpty())
				{
					DWORD dwCnt = m_List.GetItemCount();
					for (DWORD i = 0; i < dwCnt; i++)
					{
						if (!(m_List.GetItemText(i, 0)).CompareNoCase(strData))
						{
							m_List.EnsureVisible(i, false);
							m_List.SetItemState(i, LVIS_FOCUSED | LVIS_SELECTED,LVIS_FOCUSED | LVIS_SELECTED);
							m_List.SetFocus();
							break;
						}
					}
				}	

				break;
			}
			else
			{
				EnumSubKeys(strRoot, hChild);
				m_Tree.Expand(hChild, TVE_EXPAND);
			}

			strKeyEnd = strKeyEnd.Right(strKeyEnd.GetLength() - strKeyEnd.Find('\\') - 1);

		} while (!bQuiet);
	}
}

void CRegisterManagerDlg::OnNMRClickList(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	
	if (!m_strComboText.IsEmpty())
	{
	

		CMenu Menu;
		Menu.CreatePopupMenu();
		Menu.AppendMenu(MF_STRING, ID_REG_LIST_REFRESH,L"刷新");
	
		Menu.AppendMenu(MF_SEPARATOR);
		Menu.AppendMenu(MF_STRING, ID_REG_LIST_MODIFY,L"修改");
		Menu.AppendMenu(MF_STRING, ID_REG_LIST_DELETE, L"删除");
		Menu.AppendMenu(MF_STRING, ID_REG_LIST_RENAME, L"重命名");
		Menu.AppendMenu(MF_SEPARATOR);
		Menu.AppendMenu(MF_STRING, ID_REG_LIST_COPY_VALUE, L"复制值名称");
		Menu.AppendMenu(MF_STRING, ID_REG_LIST_COPY_VALUE_DATA,L"复制值数据");

		Menu.AppendMenu(MF_SEPARATOR);


		int x = GetSystemMetrics(SM_CXMENUCHECK);
		int y = GetSystemMetrics(SM_CYMENUCHECK);
		if (x >= 15 && y >= 15)
		{
			Menu.SetMenuItemBitmaps(ID_REG_LIST_REFRESH, MF_BYCOMMAND, &m_bmRefresh, &m_bmRefresh);
			Menu.SetMenuItemBitmaps(ID_REG_LIST_DELETE, MF_BYCOMMAND, &m_bmDelete, &m_bmDelete);
			Menu.SetMenuItemBitmaps(ID_REG_LIST_COPY_VALUE, MF_BYCOMMAND, &m_bmCopy, &m_bmCopy);
			Menu.SetMenuItemBitmaps(ID_REG_LIST_COPY_VALUE_DATA, MF_BYCOMMAND, &m_bmCopy, &m_bmCopy);
		}

		if (m_List.GetSelectedCount() == 0)
		{
			Menu.EnableMenuItem(ID_REG_LIST_MODIFY, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
			Menu.EnableMenuItem(ID_REG_LIST_DELETE, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
			Menu.EnableMenuItem(ID_REG_LIST_RENAME, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
			Menu.EnableMenuItem(ID_REG_LIST_COPY_VALUE, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
			Menu.EnableMenuItem(ID_REG_LIST_COPY_VALUE_DATA, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
		}
		else if (m_List.GetSelectedCount() == 1)
		{
			int nItem = m_List.GetSelectionMark();
			if (nItem != -1)
			{
				if (m_List.GetItemData(nItem))
				{
					Menu.EnableMenuItem(ID_REG_LIST_RENAME, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);

					if (!(m_List.GetItemText(nItem, 2)).CompareNoCase(L"(数值未设置)"))
					{
						Menu.EnableMenuItem(ID_REG_LIST_DELETE, MF_BYCOMMAND | MF_GRAYED | MF_DISABLED);
					}
				}
			}
		}

		CPoint Point;
		GetCursorPos(&Point);
		Menu.TrackPopupMenu(TPM_RIGHTBUTTON, Point.x, Point.y, this);
		Menu.DestroyMenu();
		
	}

	*pResult = 0;
}


void CRegisterManagerDlg::OnRegListModify()
{
	int nItem = m_List.GetSelectionMark();
	if (nItem != -1)
	{
		CString strType = m_List.GetItemText(nItem, 1);

		if (strType.Find(L"SZ") != -1)
		{
			CString strValue = m_List.GetItemText(nItem, 0);
			CString strData = m_List.GetItemText(nItem, 2);

			if (m_List.GetItemData(nItem) && !strData.CompareNoCase(L"(数值未设置)"))
			{
				strData = L"";
			}

			CRegModifyDlg RegModifyDlg;
			RegModifyDlg.m_strValueDataEdit = strData;
			RegModifyDlg.m_strValueNameEdit = strValue;

			if (RegModifyDlg.DoModal() == IDOK)
			{
				CString strDataNew = RegModifyDlg.m_strValueDataEdit;
				if (m_List.GetItemData(nItem))
				{
					strValue = L"";
				}

				ModifyValue(strValue,GetValueType(m_List.GetItemText(nItem, 1)),strDataNew.GetBuffer(), strDataNew.GetLength() * sizeof(WCHAR));
				OnRegListRefresh();
			}
		}
		else if (!strType.CompareNoCase(L"REG_DWORD"))
		{
			CString strValue = m_List.GetItemText(nItem, 0);
			CString strData = m_List.GetItemText(nItem, 2);

			CString strShowData;
			strShowData.Format(L"%ld", HexStringToLong(strData));

			CRegModifyDlg RegModifyDlg;
			RegModifyDlg.m_strValueDataEdit = strShowData;
			RegModifyDlg.m_strValueNameEdit = strValue;

			if (RegModifyDlg.DoModal() == IDOK)
			{
				CString strDataNew = RegModifyDlg.m_strValueDataEdit;
				DWORD dwData = 0;

			
			
				swscanf_s(strDataNew.GetBuffer(0), L"%x", &dwData);
			
			

				ModifyValue(strValue, GetValueType(m_List.GetItemText(nItem, 1)), &dwData, sizeof(DWORD));
				OnRegListRefresh();
			}
		}

		else if (!strType.CompareNoCase(L"REG_QWORD"))
		{
			CString strValue = m_List.GetItemText(nItem, 0);
			CString strData = m_List.GetItemText(nItem, 2);

			CString strShowData;
			strShowData.Format(L"%ld", HexStringToLong(strData));

			CRegModifyDlg RegModifyDlg;
			RegModifyDlg.m_strValueDataEdit = strShowData;
			RegModifyDlg.m_strValueNameEdit = strValue;

			if (RegModifyDlg.DoModal() == IDOK)
			{
				CString strDataNew = RegModifyDlg.m_strValueDataEdit;
				LONGLONG dwData = 0;



				swscanf_s(strDataNew.GetBuffer(0), L"%p", &dwData);



				ModifyValue(strValue, GetValueType(m_List.GetItemText(nItem, 1)), &dwData, sizeof(LONGLONG));
				OnRegListRefresh();
			}
		}



		else if (!strType.CompareNoCase(L"REG_BINARY") ||
			!strType.CompareNoCase(L"REG_RESOURCE_REQUIREMENTS_LIST") ||
			!strType.CompareNoCase(L"REG_FULL_RESOURCE_DESCRIPTOR") ||
			!strType.CompareNoCase(L"REG_RESOURCE_LIST"))
		{
			CString strValue = m_List.GetItemText(nItem, 0);
			CString strData = m_List.GetItemText(nItem, 2);
			ULONG ulLen = strData.GetLength() + strData.GetLength() % 2 + 10;
			PBYTE Data = (PBYTE)malloc(ulLen);
			ULONG ulDataLen = 0;

			if (Data)
			{
				memset(Data, 0, ulLen);
				int n = strData.Find(' ');
				while (n != -1)
				{
					swscanf_s(strData, L"%2x", &Data[ulDataLen++]);
					strData = strData.Right(strData.GetLength() - n - 1);
					n = strData.Find(' ');
				}

				CRegHexEditDlg EditDlg;
				EditDlg.m_Data = Data;
				EditDlg.m_DataLen = ulDataLen;
				EditDlg.m_strValueNameEdit = strValue;

				if (EditDlg.DoModal() == IDOK)
				{
					PBYTE RetData = EditDlg.m_RetData;
					ULONG RetLen = EditDlg.m_RetLen;
					if (RetData && RetLen)
					{
						ModifyValue(strValue, GetValueType(m_List.GetItemText(nItem, 1)),RetData, RetLen);
						OnRegListRefresh();
					}

					if (RetData)
					{
						free(RetData);
					}
				}

				if (Data)
				{
					free(Data);
					Data = NULL;
				}
			}
		}
	}
}

ULONG CRegisterManagerDlg::GetValueType(CString strType)
{
	ULONG ulRet = 0;
	if (strType.IsEmpty())
	{
		return 0;
	}

	if (!strType.CompareNoCase(L"REG_NONE"))
	{
		ulRet = REG_NONE;
	}
	else if (!strType.CompareNoCase(L"REG_SZ"))
	{
		ulRet = REG_SZ;
	}
	else if (!strType.CompareNoCase(L"REG_EXPAND_SZ"))
	{
		ulRet = REG_EXPAND_SZ;
	}
	else if (!strType.CompareNoCase(L"REG_BINARY"))
	{
		ulRet = REG_BINARY;
	}
	else if (!strType.CompareNoCase(L"REG_DWORD"))
	{
		ulRet = REG_DWORD;
	}
	else if (!strType.CompareNoCase(L"REG_DWORD_BIG_ENDIAN"))
	{
		ulRet = REG_DWORD_BIG_ENDIAN;
	}
	else if (!strType.CompareNoCase(L"REG_LINK"))
	{
		ulRet = REG_LINK;
	}
	else if (!strType.CompareNoCase(L"REG_MULTI_SZ"))
	{
		ulRet = REG_MULTI_SZ;
	}
	else if (!strType.CompareNoCase(L"REG_RESOURCE_LIST"))
	{
		ulRet = REG_RESOURCE_LIST;
	}
	else if (!strType.CompareNoCase(L"REG_FULL_RESOURCE_DESCRIPTOR"))
	{
		ulRet = REG_FULL_RESOURCE_DESCRIPTOR;
	}
	else if (!strType.CompareNoCase(L"REG_RESOURCE_REQUIREMENTS_LIST"))
	{
		ulRet = REG_RESOURCE_REQUIREMENTS_LIST;
	}
	else if (!strType.CompareNoCase(L"REG_QWORD"))
	{
		ulRet = REG_QWORD;
	}
	else if (!strType.CompareNoCase(L"Unknow"))
	{
		ulRet = 0;
	}

	return ulRet;
}



void CRegisterManagerDlg::ModifyValue(CString strValue, ULONG ulType, PVOID Data, ULONG ulDataSize)
{
	CString strKeyPath = String2KeyPath();

	if (!strKeyPath.IsEmpty())
	{
		UNICODE_STRING uniKey;
		if (InitUnicodeString(&uniKey, strKeyPath.GetBuffer()))
		{
			HANDLE hKey;
			OBJECT_ATTRIBUTES oa;

			InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

			if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
			{
				if (strValue.IsEmpty())
				{
					UNICODE_STRING uniValue;
					uniValue.Buffer = NULL;
					uniValue.Length = 0;
					uniValue.MaximumLength = 2;

					if (SetValueKey(hKey, &uniValue, 0, ulType,Data, ulDataSize))
					{
					
					}
				}
				else 
				{
					UNICODE_STRING uniValue;
					if (InitUnicodeString(&uniValue, strValue.GetBuffer()))
					{
						SetValueKey(hKey, &uniValue, 0, ulType, Data, ulDataSize);
						FreeUnicodeString(&uniValue);
					}
				}

				CloseHandle(hKey);
			}

			FreeUnicodeString(&uniKey);
		}
	}
}


void CRegisterManagerDlg::OnRegListDelete()
{
	int nItem = m_List.GetSelectionMark();
	if (nItem != -1)
	{
		CString strValue = m_List.GetItemText(nItem, 0);
		CString strKeyPath = String2KeyPath();

		if (!strKeyPath.IsEmpty())
		{
			if (MessageBox(L"确定删除吗？",L"Shine", MB_ICONQUESTION | MB_YESNO) != IDYES)
			{
				return;
			}

			UNICODE_STRING uniKey;
			BOOL bOk = FALSE;
			if (InitUnicodeString(&uniKey, strKeyPath.GetBuffer()))
			{
				HANDLE hKey;
				OBJECT_ATTRIBUTES oa;

				InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

				if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
				{
					UNICODE_STRING uniValue;

					if (m_List.GetItemData(nItem))
					{
						uniValue.Buffer = NULL;
						uniValue.Length = 0;
						uniValue.MaximumLength = 2;

						bOk = DeleteValueKey(hKey, &uniValue);
					}
					else
					{
						if (InitUnicodeString(&uniValue, strValue.GetBuffer()))
						{
							bOk = DeleteValueKey(hKey, &uniValue);
							FreeUnicodeString(&uniValue);
							
						}
					}

					CloseHandle(hKey);
				}

				FreeUnicodeString(&uniKey);
			}

			if (bOk)
			{
				OnRegListRefresh();
			}
		}
	}
}

ULONG CRegisterManagerDlg::HexStringToLong(CString strHex)
{
	ULONG ulRet = 0;

	if (!strHex.IsEmpty())
	{
		swscanf_s(strHex.GetBuffer(wcslen(L"0x")), L"%x", &ulRet);
		strHex.ReleaseBuffer(wcslen(L"0x"));
	}

	return ulRet;
}


BOOL CRegisterManagerDlg::DeleteValueKey(
	IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  uniValueName
	)
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;


	struct
	{
		HANDLE hKey;
		PUNICODE_STRING  uniValueName;
	}DeleteValueKey;


	memset(&DeleteValueKey, 0, sizeof(DeleteValueKey));
	
	DeleteValueKey.hKey = KeyHandle;
	DeleteValueKey.uniValueName = uniValueName;

	g_hDevice = OpenDevice(L"\\\\.\\RegisterManagerLink");


	if (g_hDevice==(HANDLE)-1)
	{
		return FALSE;
	}



	dwRet = DeviceIoControl(g_hDevice,CTL_DELETE_KEY_VALUE,
		&DeleteValueKey,
		sizeof(DeleteValueKey),
		NULL,0,
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{

		CloseHandle(g_hDevice);
		return FALSE;
	}

	CloseHandle(g_hDevice);

	return TRUE;
}


void CRegisterManagerDlg::OnRegListRename()
{
	CString strKeyPath = String2KeyPath();
	if (strKeyPath.IsEmpty())
	{
		return;
	}

	int nItem = m_List.GetSelectionMark();
	if (nItem != -1)
	{
		CKeyDlg RenameValueDlg;
		RenameValueDlg.m_nDlgType = enumRenameValue;
		CString strValueNameOld = m_List.GetItemText(nItem, 0);
		RenameValueDlg.m_strKeyNameEdit = strValueNameOld;
		CString strNewValueName;
		if (RenameValueDlg.DoModal() == IDOK)
		{
			strNewValueName = RenameValueDlg.m_strKeyNameEdit;
		}

		if (strNewValueName.IsEmpty())
		{
			return;
		}

		if (strNewValueName.CompareNoCase(strValueNameOld))
		{
			//获得原先键值的各种属性
			PKEY_VALUE_FULL_INFORMATION ValueInfor = (PKEY_VALUE_FULL_INFORMATION)GetValueInfo(strKeyPath, strValueNameOld);
			if (ValueInfor)
			{
				//重建一个新的
				CreateValueKey(strNewValueName, ValueInfor->Type, 
					(PVOID)((PBYTE)ValueInfor + ValueInfor->DataOffset), ValueInfor->DataLength);

				// 删除旧的键值
				UNICODE_STRING uniKey;
				if (InitUnicodeString(&uniKey, strKeyPath.GetBuffer()))
				{
					HANDLE hKey;
					OBJECT_ATTRIBUTES oa;

					InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

					if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
					{
						UNICODE_STRING uniValue;

						if (InitUnicodeString(&uniValue, strValueNameOld.GetBuffer()))
						{
							DeleteValueKey(hKey, &uniValue);
							FreeUnicodeString(&uniValue);
							m_List.DeleteItem(nItem);
						}

						CloseHandle(hKey);
					}

					FreeUnicodeString(&uniKey);
				}

				// 释放资源
				free(ValueInfor);
				ValueInfor = NULL;
			}
		}
	}	
}



PVOID CRegisterManagerDlg::GetValueInfo(CString strKey, CString strValue)
{
	PVOID Ret = NULL;

	if (strKey.IsEmpty() || strValue.IsEmpty())
	{
		return NULL;
	}

	UNICODE_STRING uniKey;

	if (InitUnicodeString(&uniKey,strKey.GetBuffer()))
	{
		HANDLE hKey;
		OBJECT_ATTRIBUTES oa;

		InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);
		if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
		{
			for (ULONG i = 0; ; i++)
			{
				ULONG ulRetLen = 0;
				BOOL bRet = EnumerateValueKey(hKey, i, KeyValueFullInformation, NULL, 0, &ulRetLen);
				if (!bRet && GetLastError() == ERROR_NO_MORE_ITEMS) 
				{
					break;
				}
				else if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) // STATUS_BUFFER_TOO_SMALL
				{
					PKEY_VALUE_FULL_INFORMATION Buffer = (PKEY_VALUE_FULL_INFORMATION)malloc(ulRetLen + 0x100);
					if (Buffer)
					{
						memset(Buffer, 0, ulRetLen + 0x100);
						bRet = EnumerateValueKey(hKey, i, KeyValueFullInformation, Buffer, ulRetLen + 0x100, &ulRetLen);

						if (bRet)
						{
							WCHAR wzTempName[1024] = {0};
							wcsncpy_s(wzTempName, 1024, Buffer->Name,Buffer->NameLength / sizeof(WCHAR));

							if (!strValue.CompareNoCase(wzTempName))
							{
								Ret = (PVOID)Buffer;
								break;
							}
						}

						free(Buffer);
					}
				}
			}

			CloseHandle(hKey);
		}

		FreeUnicodeString(&uniKey);
	}

	return Ret;
}




void CRegisterManagerDlg::CreateValueKey(CString strValue, ULONG ulType, PVOID Data, ULONG ulDataSize)
{
	CString strKeyPath = String2KeyPath();
	if (strKeyPath.IsEmpty() || strValue.IsEmpty())
	{
		return;
	}

	UNICODE_STRING uniKey;
	if (InitUnicodeString(&uniKey, strKeyPath.GetBuffer()))
	{
		HANDLE hKey;
		OBJECT_ATTRIBUTES oa;

		InitializeObjectAttributes(&oa, &uniKey, OBJ_CASE_INSENSITIVE, 0, NULL);

		if (OpenKey(&hKey, KEY_ALL_ACCESS, &oa))
		{
			UNICODE_STRING uniValue;

			if (InitUnicodeString(&uniValue, strValue.GetBuffer()))
			{
				SetValueKey(hKey, &uniValue, 0, ulType, Data, ulDataSize);
				FreeUnicodeString(&uniValue);
			}

			CloseHandle(hKey);
		}

		FreeUnicodeString(&uniKey);
	}

	OnRegListRefresh();
}


void CRegisterManagerDlg::OnRegListCopyValue()
{
	int nItem = m_List.GetSelectionMark();
	if (nItem != -1)
	{
		CString strValue = m_List.GetItemText(nItem, 0);
		SetStringToClipboard(strValue);
	}
}


void CRegisterManagerDlg::OnRegListCopyValueData()
{
	int nItem = m_List.GetSelectionMark();
	if (nItem != -1)
	{
		CString strData = m_List.GetItemText(nItem, 2);
		SetStringToClipboard(strData);
	}
}

```

`Register/RegisterManager/RegisterManager/RegisterManagerDlg.h`:

```h

// RegisterManagerDlg.h : 头文件
//

#pragma once
#include "afxcmn.h"
#include "afxwin.h"
#include <WinIoCtl.h>
#include <Sddl.h>
#include <list>
#include "RegFindDlg.h"
using namespace std;
typedef struct _KEY_BASIC_INFORMATION {
	LARGE_INTEGER LastWriteTime;
	ULONG   TitleIndex;
	ULONG   NameLength;
	WCHAR   Name[1];           
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;


typedef enum _KEY_INFORMATION_CLASS {
	KeyBasicInformation,
	KeyNodeInformation,
	KeyFullInformation,
	KeyNameInformation,
	KeyCachedInformation,
	KeyFlagsInformation,
	KeyVirtualizationInformation,
	KeyHandleTagsInformation,
	MaxKeyInfoClass 
} KEY_INFORMATION_CLASS;

typedef struct _KEY_VALUE_FULL_INFORMATION {
	ULONG   TitleIndex;
	ULONG   Type;
	ULONG   DataOffset;
	ULONG   DataLength;
	ULONG   NameLength;
	WCHAR   Name[1];          
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64,
	MaxKeyValueInfoClass  
} KEY_VALUE_INFORMATION_CLASS;


#define	CLASSES_ROOT		L"\\Registry\\Machine\\SOFTWARE\\Classes"
#define	LOCAL_MACHINE		L"\\Registry\\Machine"
#define USERS				L"\\Registry\\User"
#define CURRENT_CONFIGL     L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Hardware Profiles\\Current"



#define CTL_CREATE_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x833,METHOD_NEITHER,FILE_ANY_ACCESS)

#define CTL_OPEN_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_NEITHER,FILE_ANY_ACCESS)

#define CTL_ENUM_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x831,METHOD_NEITHER,FILE_ANY_ACCESS)

#define CTL_ENUM_KEY_VALUE \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x832,METHOD_NEITHER,FILE_ANY_ACCESS)

#define CTL_SET_KEY_VALUE \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x834,METHOD_NEITHER,FILE_ANY_ACCESS)


#define CTL_DELETE_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x835,METHOD_NEITHER,FILE_ANY_ACCESS)

#define CTL_RENAME_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x836,METHOD_NEITHER,FILE_ANY_ACCESS)


#define CTL_DELETE_KEY_VALUE \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x837,METHOD_NEITHER,FILE_ANY_ACCESS)

#define OBJ_CASE_INSENSITIVE    0x00000040L
#define InitializeObjectAttributes( p, n, a, r, s ) { \
	(p)->Length = sizeof(OBJECT_ATTRIBUTES);          \
	(p)->RootDirectory = r;                             \
	(p)->Attributes = a;                                \
	(p)->ObjectName = n;                                \
	(p)->SecurityDescriptor = s;                        \
	(p)->SecurityQualityOfService = NULL;               \
}

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
}UNICODE_STRING, *PUNICODE_STRING;


typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;       
	PVOID SecurityQualityOfService; 
}OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;


// CRegisterManagerDlg 对话框
class CRegisterManagerDlg : public CDialogEx
{
// 构造
public:
	CRegisterManagerDlg(CWnd* pParent = NULL);	// 标准构造函数
	CRegisterManagerDlg::~CRegisterManagerDlg();
	BOOL InitControlTree();
	VOID InitRegistry();
	VOID EnumSubKeys(CString strKey, HTREEITEM hItem, BOOL bSubSubKey = FALSE);
	VOID DeleteSubTree(HTREEITEM hTreeItem);
	VOID CRegisterManagerDlg::FreeUnicodeString(UNICODE_STRING *uniString);
	BOOL InitUnicodeString(PUNICODE_STRING uniString, WCHAR *wzString);
	BOOL CRegisterManagerDlg::OpenKey(OUT PHANDLE  KeyHandle,
		IN ACCESS_MASK  DesiredAccess,
		IN POBJECT_ATTRIBUTES  ObjectAttributes
		);
	BOOL CRegisterManagerDlg::EnumerateKey(IN HANDLE  KeyHandle,
		IN ULONG  ulIndex,
		IN ULONG  ulKeyInformationClass,
		OUT PVOID  KeyInformation,
		IN ULONG   ulLength,
		OUT PULONG ResultLength
		);
	void CRegisterManagerDlg::EnumCurrentUserSubKeys(HTREEITEM hChild);
	BOOL CRegisterManagerDlg::GetCurrentUserKeyPath(OUT WCHAR *wzCurrentUserPath);
	void CRegisterManagerDlg::EnumSubSubKeys(CString strKey, HTREEITEM hItem);
    void CRegisterManagerDlg::EnumValues(CString strKey);

	BOOL CRegisterManagerDlg::EnumerateValueKey(IN HANDLE  KeyHandle,
		IN ULONG  ulIndex,
		IN ULONG  ulKeyValueInformationClass,
		OUT PVOID  KeyValueInformation,
		IN ULONG  ulLength,
		OUT PULONG  ulResultLength
		);
	CString CRegisterManagerDlg::GetKeyType(ULONG ulType);
	CString CRegisterManagerDlg::GetKeyData(ULONG ulType, WCHAR* wzData, ULONG ulDataLength);


	VOID CRegisterManagerDlg::InitializeComboBox();
	void CRegisterManagerDlg::GetAllRegPath(std::list <CString> &RegPathList);
	void CRegisterManagerDlg::InitRegPathList();
	CString CRegisterManagerDlg::ComboString2KeyPath();
	HTREEITEM CRegisterManagerDlg::GetTreeSubItemByName(HTREEITEM hPatentItem, CString strName);
	CString CRegisterManagerDlg::String2KeyPath();

	BOOL CRegisterManagerDlg::CreateKey(
		OUT PHANDLE  KeyHandle,
		IN ACCESS_MASK  DesiredAccess,
		IN POBJECT_ATTRIBUTES  ObjectAttributes,
		IN ULONG  ulTitleIndex,
		IN PUNICODE_STRING  uniClass,
		IN ULONG  ulCreateOptions,
		OUT PULONG  Disposition
		);

	void CRegisterManagerDlg::SetValueKey(ULONG ulType, PVOID Data, ULONG ulDataSize);

	BOOL CRegisterManagerDlg::SetValueKey(
		IN HANDLE  KeyHandle,
		IN PUNICODE_STRING  uniValueName,
		IN ULONG  ulTitleIndex,
		IN ULONG  ulType,
		IN PVOID  Data,
		IN ULONG  ulDataSize
		);


	void CRegisterManagerDlg::DeleteKeyAndSubKeys(CString strKey);
	BOOL CRegisterManagerDlg::DeleteKey(IN HANDLE KeyHandle);
	void CRegisterManagerDlg::UpdateKey(CString strKey, HTREEITEM hItem);


	BOOL CRegisterManagerDlg::RenameKey(
		IN HANDLE  KeyHandle,
		IN PUNICODE_STRING  uniNewName
		);
	BOOL SetStringToClipboard(CString strImageName);
	VOID CRegisterManagerDlg::ShellImportRegister(
		LPCTSTR ImportFile) ;

	VOID CRegisterManagerDlg::ShellExportRegister(
		CString strItem,		
		CString strFileName);


	void CRegisterManagerDlg::JmpToReg(CString strKey, CString strData);
	void CRegisterManagerDlg::JmpToRegCommon(CString strKey, CString strData);

	BOOL CRegisterManagerDlg::DeleteValueKey(
		IN HANDLE  KeyHandle,
		IN PUNICODE_STRING  uniValueName
		);
	

	PVOID CRegisterManagerDlg::GetValueInfo(CString strKey, CString strValue);
	void CRegisterManagerDlg::CreateValueKey(CString strValue, ULONG ulType, PVOID Data, ULONG ulDataSize);
	ULONG CRegisterManagerDlg::GetValueType(CString strType);
	void CRegisterManagerDlg::ModifyValue(CString strValue, ULONG ulType, PVOID Data, ULONG ulDataSize);
	ULONG CRegisterManagerDlg::HexStringToLong(CString strHex);
	// 对话框数据
	enum { IDD = IDD_REGISTERMANAGER_DIALOG };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	CTreeCtrl m_Tree;
	CImageList m_TreeImageList;
	CListCtrl m_List;
	CImageList m_ImageList;
	CComboBox m_ComboBox;
	CString m_strComboText;
	WCHAR* m_wzhKeyCurrentUser;   //这个是存储Current_User 键值    注意在析构函数要进行释放内存
	std::list <CString> m_RegPathList;		// 注册表的快速定位项
	ULONG m_nComboBoxCnt;                   // 快速定位的总数
	HTREEITEM m_RightClickTreeItem;         // 在树控件上的右键选择项
	CBitmap m_bmRefresh;
	CBitmap m_bmDelete;
	CBitmap m_bmCopy;
	CBitmap m_bmExport;
	CBitmap m_bmLookfor;
	CRegFindDlg *m_FindRegDlg;            //查找Dlg
	afx_msg void OnTvnItemexpandingTree(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnTvnSelchangedTree(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnBnClickedGoto();
	afx_msg void OnCbnDropdownCombo();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnRegRefresh();
	afx_msg void OnNMRClickTree(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnRegNewKey();
	afx_msg void OnStringValue();
	afx_msg void OnBinaryValue();
	afx_msg void OnDwordValue();
	afx_msg void OnMuiStringValue();
	afx_msg void OnExpandStringValue();
	afx_msg void OnRegDelete();
	afx_msg void OnRegRename();
	afx_msg void OnQwordValue();
	afx_msg void OnRegCopyKeyName();
	afx_msg void OnRegCopyFullKeyName();
	afx_msg void OnRegAddToQuickAddress();
	afx_msg void OnRegInport();
	afx_msg void OnRegExport();
	afx_msg void OnRegLookFor();
	afx_msg void OnNMRClickList(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnRegListRefresh();
	afx_msg void OnRegListModify();
	afx_msg void OnRegListDelete();
	afx_msg void OnRegListRename();
	afx_msg void OnRegListCopyValue();
	afx_msg void OnRegListCopyValueData();
};

```

`Register/RegisterManager/RegisterManager/res/RegisterManager.rc2`:

```rc2
//
// RegisterManager.RC2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`Register/RegisterManager/RegisterManager/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RegisterManager.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_REGISTERMANAGER_DIALOG      102
#define IDR_MAINFRAME                   128
#define IDI_COMPUTER                    129
#define IDI_CLOSE_DIRECTORY             130
#define IDI_OPEN_DIRECTORY              131
#define IDI_REG_SZ                      132
#define IDI_DWORD                       133
#define IDR_REG_TREE                    134
#define IDB_REFRESH                     137
#define IDD_KEY_DIALOG                  138
#define IDB_DELETE                      139
#define IDB_COPY                        140
#define IDB_EXPORT                      141
#define IDD_FIND_REG_DIALOG             142
#define IDB_LOOKFOR                     143
#define IDR_AVI                         145
#define IDR_REG_LIST                    146
#define IDD_REG_MODIFY_DIALOG           147
#define IDD_REG_HEX_DIALOG              148
#define IDC_TREE                        1000
#define IDC_LIST                        1001
#define IDC_GOTO                        1002
#define IDC_COMBO                       1003
#define IDC_KEY_NAME                    1004
#define IDC_EDIT                        1005
#define IDC_STATIC_FIND_WHAT            1006
#define IDC_EDIT_FIND_WHAT              1007
#define IDC_BUTTON_START                1008
#define IDC_BUTTON_STOP                 1009
#define IDC_CHECK_KEY                   1010
#define IDC_CHECK_VALUES                1011
#define IDC_CHECK_DATA                  1012
#define IDC_CHECK_MACH_CASE             1013
#define IDC_CHECK_MACH_WHOLE_STRING     1014
#define IDC_STATIC_WHERE_TO_SEARCH      1015
#define IDC_RADIO_SEARCH_IN             1016
#define IDC_RADIO_SEARCH_ALL            1018
#define IDC_STATIC_FIND_RESULT          1019
#define IDC_ANIMATE                     1021
#define IDC_VALUE_NAME_STATIC           1022
#define IDC_EDIT_VALUE_NAME             1023
#define IDC_VALUE_DATA_STATIC           1024
#define IDC_EDIT_VALUE_DATA             1025
#define IDC_VALUE_NAME                  1028
#define IDC_VALUE_DATA                  1030
#define IDC_EDIT2                       1031
#define IDC_HEXEDIT                     1031
#define ID_REG_REFRESH                  32773
#define ID_REG_NEW_KEY                  32774
#define ID_STRING_VALUE                 32777
#define ID_BINARY_VALUE                 32780
#define ID_DWORD_VALUE                  32781
#define ID_EXPAND_STRING_VALUE          32784
#define ID_MUI_STRING_VALUE             32785
#define ID_REG_DELETE                   32787
#define ID_REG_RENAME                   32789
#define ID_QWORD_VALUE                  32791
#define ID_REG_COPY_KEY_NAME            32793
#define ID_REG_COPY_FULL_KEY_NAME       32795
#define ID_REG_ADD_TO_QUICK_ADDRESS     32797
#define ID_REG_INPORT                   32799
#define ID_REG_EXPORT                   32801
#define ID_REG_LOOK_FOR                 32803
#define ID_REG_LIST_REFRESH             32805
#define ID_REG_LIST_MODIFY              32807
#define ID_REG_LIST_DELETE              32809
#define ID_REG_LIST_RENAME              32811
#define ID_REG_LIST_COPY_VALUE          32813
#define ID_REG_LIST_COPY_VALUE_DATA     32815

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        149
#define _APS_NEXT_COMMAND_VALUE         32816
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Register/RegisterManager/RegisterManager/stdafx.cpp`:

```cpp

// stdafx.cpp : 只包括标准包含文件的源文件
// RegisterManager.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"



```

`Register/RegisterManager/RegisterManager/stdafx.h`:

```h

// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件

#pragma once

#ifndef _SECURE_ATL
#define _SECURE_ATL 1
#endif

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // 功能区和控件条的 MFC 支持









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`Register/RegisterManager/RegisterManager/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义最高版本的可用 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`Register/RegisterManagerDrv/RegisterManagerDrv.c`:

```c
#include "RegisterManagerDrv.h"

PDRIVER_OBJECT  g_DriverObject = NULL;
WIN_VERSION     WinVersion = WINDOWS_UNKNOW;
ULONG_PTR       SYSTEM_ADDRESS_START = 0;
ULONG_PTR       PreviousModeOffsetOf_KTHREAD = 0;
ULONG_PTR       IndexOffset = 0;
pfnNtEnumerateValueKey NtEnumerateValueKeyAddress = NULL;
pfnNtOpenKey    NtOpenKeyAddress = NULL;
pfnNtEnumerateKey      NtEnumerateKeyAddress = NULL;
pfnNtCreateKey         NtCreateKeyAddress = NULL;
pfnNtSetValueKey       NtSetValueKeyAddress = NULL;
pfnNtDeleteKey         NtDeleteKeyAddress = NULL;
pfnNtRenameKey         NtRenameKeyAddress = NULL;
pfnNtDeleteValueKey    NtDeleteValueKeyAddress = NULL;
ULONG_PTR		SSDTDescriptor = 0;
ULONG_PTR		ulIndex = 0;
ULONG_PTR		SSDTFuncAddress = 0;


HANDLE  hRoot = NULL;
NTSTATUS DriverEntry(PDRIVER_OBJECT  DriverObject,PUNICODE_STRING  RegisterPath)
{
	PDEVICE_OBJECT	DeviceObject;
	NTSTATUS		Status;
	ULONG			i;

	UNICODE_STRING	uniDeviceName;
	UNICODE_STRING	uniLinkName;

	RtlInitUnicodeString(&uniDeviceName,DEVICE_NAME);
	RtlInitUnicodeString(&uniLinkName,LINK_NAME);

	//创建设备对象;
	Status = IoCreateDevice(DriverObject,0,&uniDeviceName,FILE_DEVICE_UNKNOWN,0,FALSE,&DeviceObject);
	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	//创建符号链接;
	Status = IoCreateSymbolicLink(&uniLinkName,&uniDeviceName);

	for (i = 0; i<IRP_MJ_MAXIMUM_FUNCTION; i ++)
	{
		DriverObject->MajorFunction[i] = DefaultDispatch;
	}
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlDispatch;
	DriverObject->DriverUnload = UnloadDriver;
	
#ifdef WIN64
/*	__asm
	{
		xchg rax,rbx
	}
*/	DbgPrint("X64: RegisterManager IS RUNNING!!!\n");
#else
/*	__asm
	{
		xor eax,eax
	}
*/	DbgPrint("X86: RegisterManager IS RUNNING!!!\n");
#endif
	

	g_DriverObject = DriverObject;
	WinVersion = GetWindowsVersion();
	SetGolbalMember();
	return STATUS_SUCCESS;
}



NTSTATUS ControlDispatch(PDEVICE_OBJECT  DeviceObject,PIRP Irp)
{

	NTSTATUS  Status = STATUS_SUCCESS;
	PIO_STACK_LOCATION   IrpSp;
	PVOID     InputBuffer  = NULL;
	PVOID     OutputBuffer = NULL;
	ULONG_PTR InputSize  = 0;
	ULONG_PTR OutputSize = 0;
	ULONG_PTR IoControlCode = 0;
	PETHREAD EThread = NULL;
	CHAR     PreMode = 0;
	IrpSp = IoGetCurrentIrpStackLocation(Irp);

	IrpSp = IoGetCurrentIrpStackLocation(Irp);
	InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
	OutputBuffer = Irp->UserBuffer;
	InputSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	OutputSize  = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;


	switch(IoControlCode)
	{
	
	case CTL_OPEN_KEY:
		{


			DbgPrint("应用层事件到达");

		
			Status  = RegOpenKey(InputBuffer,OutputBuffer);
		
			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}
			

			break;
		
		}

	case CTL_ENUM_KEY:
		{


			Status = RegEnumerateKey(InputBuffer,OutputBuffer);


			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}



			break;
		}

	case CTL_ENUM_KEY_VALUE:
		{

			Status = RegEnumerateValueKey(InputBuffer,OutputBuffer);


			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}

			break;
		}

	case CTL_CREATE_KEY:
		{

			Status = RegCreateKey(InputBuffer,OutputBuffer);


			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}

			break;
		}

	case CTL_SET_KEY_VALUE:
		{

			Status = RegSetValueKey(InputBuffer,OutputBuffer);


			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}

			break;
		}

	case CTL_DELETE_KEY:
		{

			Status = RegDeleteKey(InputBuffer,OutputBuffer);


			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}

			break;
		}

	case CTL_RENAME_KEY:
		{

			Status = RegRenameKey(InputBuffer,OutputBuffer);


			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}

			break;
		}


	case CTL_DELETE_KEY_VALUE:
		{

			Status = RegDeleteValueKey(InputBuffer,OutputBuffer);


			if (NT_SUCCESS(Status))
			{
				Irp->IoStatus.Information = OutputSize;
				Irp->IoStatus.Status = Status;
			}

			else
			{
				Irp->IoStatus.Information = 0;
				Irp->IoStatus.Status = Status;
			}

			break;
		}
	default:
		{

			Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
			Irp->IoStatus.Information = 0;



			break;
		}
	}


	IoCompleteRequest(Irp,IO_NO_INCREMENT);

	return Status;
}

NTSTATUS RegOpenKey(PVOID InBuffer,PVOID OutBuffer)
{
	POPEN Open = (POPEN)InBuffer;
	ACCESS_MASK Mask = Open->DesiredAccess;
	POBJECT_ATTRIBUTES oa = Open->ObjectAttributes;
	PHANDLE KeyHandle = (PHANDLE)OutBuffer;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	__try
	{
		ProbeForRead(oa,sizeof(OBJECT_ATTRIBUTES),1);
		Status = KernelOpenKey(KeyHandle,Mask,oa);

	
	}
	__except(1)
	{
		Status = STATUS_UNSUCCESSFUL;
	}	

	return Status;
}



NTSTATUS KernelOpenKey(OUT PHANDLE KeyHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES  ObjectAttributes
	)

{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;

	if (!KeyHandle ||
		!ObjectAttributes)
	{
		return Status;
	}

	
	EThread = PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);
	Status = NtOpenKeyAddress(KeyHandle, DesiredAccess, ObjectAttributes);
	RecoverPreMode(EThread, PreMode);
	

	return Status;	
}




NTSTATUS RegEnumerateKey(PVOID InBuffer,PVOID OutBuffer)
{
	PENUM Enum = (PENUM)InBuffer;
	HANDLE KeyHandle = Enum->hKey;
	ULONG Index = Enum->Index;
	KEY_INFORMATION_CLASS KeyInformationClass = Enum->InformationClass;
	ULONG Length = Enum->Length;
	PENUM_VALUE EnumValue = (PENUM_VALUE)OutBuffer;
	ULONG ulReturn = 0;
	return KernelEnumerateKey(KeyHandle, Index, KeyInformationClass,EnumValue->ValueInfor,Length,EnumValue->RetLength);
}



NTSTATUS KernelEnumerateKey(IN HANDLE  KeyHandle,
	IN ULONG  Index,
	IN KEY_INFORMATION_CLASS  KeyInformationClass,
	OUT PVOID  KeyInformation,
	IN ULONG  Length,
	OUT PULONG  ResultLength
	)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;
	
	if (!KeyHandle)
	{
		return Status;
	}



	EThread = PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);;
	Status = NtEnumerateKeyAddress(KeyHandle, Index, KeyInformationClass, KeyInformation, Length, ResultLength);
	RecoverPreMode(EThread, PreMode);
	if (Status == STATUS_BUFFER_TOO_SMALL)
	{
		DbgPrint("STATUS_BUFFER_TOO_SMALL\r\n");
	}
	else if (STATUS_NO_MORE_ENTRIES == Status)
	{
		DbgPrint("STATUS_NO_MORE_ENTRIES\r\n");
	}

	else if (Status==STATUS_ACCESS_VIOLATION)
	{
		DbgPrint("STATUS_ACCESS_VIOLATION  %d\r\n",RtlNtStatusToDosError(Status));
	}
	
	return Status;
}




NTSTATUS RegEnumerateValueKey(PVOID InBuffer,PVOID OutBuffer)
{
	PENUM Enum = (PENUM)InBuffer;
	HANDLE KeyHandle = Enum->hKey;
	ULONG Index = Enum->Index;
	KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass = Enum->InformationClass;
	ULONG Length = Enum->Length;
	PENUM_VALUE EnumValue = (PENUM_VALUE)OutBuffer;

	return KernelEnumerateValueKey(KeyHandle, Index, KeyValueInformationClass, EnumValue->ValueInfor, Length, EnumValue->RetLength);
}


NTSTATUS KernelEnumerateValueKey(IN HANDLE  KeyHandle,
	IN ULONG  Index,
	IN KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass,
	OUT PVOID  KeyValueInformation,
	IN ULONG  Length,
	OUT PULONG  ResultLength
	)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;
	

	if (!KeyHandle)
	{
		return Status;
	}

	EThread  =  PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);

	Status = NtEnumerateValueKeyAddress(KeyHandle, Index, KeyValueInformationClass, KeyValueInformation, Length, ResultLength);

	if (Status == STATUS_BUFFER_TOO_SMALL)
	{
		DbgPrint("STATUS_BUFFER_TOO_SMALL\r\n");
	}
	else if (STATUS_NO_MORE_ENTRIES == Status)
	{
		DbgPrint("STATUS_NO_MORE_ENTRIES\r\n");
	}

	else if (Status==STATUS_ACCESS_VIOLATION)
	{
		DbgPrint("STATUS_ACCESS_VIOLATION  %d\r\n",RtlNtStatusToDosError(Status));
	}

	RecoverPreMode(EThread, PreMode);
	return Status;
}


NTSTATUS RegCreateKey(PVOID InBuffer,PVOID OutBuffer)
{
	PCREATE Create = (PCREATE)InBuffer;
	ACCESS_MASK DesiredAccess = Create->DesiredAccess;
	POBJECT_ATTRIBUTES oa = Create->ObjectAttributes;

	PCREATE_VALUE CreateValue = (PCREATE_VALUE)OutBuffer;
	PHANDLE  KeyHandle = CreateValue->KeyHandle;
	PULONG   Disposition = CreateValue->Disposition;
	return KernelCreateKey(KeyHandle, DesiredAccess, oa, 0, NULL, REG_OPTION_NON_VOLATILE, Disposition);
}



NTSTATUS 
	KernelCreateKey(
	OUT PHANDLE  KeyHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES  ObjectAttributes,
	IN ULONG  TitleIndex,
	IN PUNICODE_STRING  Class  OPTIONAL,
	IN ULONG  CreateOptions,
	OUT PULONG  Disposition  OPTIONAL
	)
{
	
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	if (!KeyHandle)
	{
		return Status;
	}

	EThread = PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);

	Status = NtCreateKeyAddress(KeyHandle, DesiredAccess, ObjectAttributes, TitleIndex, Class, CreateOptions, Disposition);

	RecoverPreMode(EThread, PreMode);
	return Status;
}


NTSTATUS RegSetValueKey(PVOID InBuffer,PVOID OutBuffer)
{
	PSET_KEY_VALUE SetKeyValue = (PSET_KEY_VALUE)InBuffer;
	HANDLE KeyHandle = SetKeyValue->hKey;
	PUNICODE_STRING uniValueName = (PUNICODE_STRING)(SetKeyValue->ValueName);
	ULONG Type = SetKeyValue->Type;
	PVOID Data = SetKeyValue->Data;
	ULONG DataSize = SetKeyValue->DataSize;
	return KernelSetValueKey(KeyHandle, uniValueName, 0, Type, Data, DataSize);
}

NTSTATUS 
	KernelSetValueKey(IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  ValueName,
	IN ULONG  TitleIndex  OPTIONAL,
	IN ULONG  Type,
	IN PVOID  Data,
	IN ULONG  DataSize
	)
{
	
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	if (!KeyHandle)
	{
		return Status;
	}

	EThread = PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);

	Status = NtSetValueKeyAddress(KeyHandle, ValueName, TitleIndex, Type, Data, DataSize);

	RecoverPreMode(EThread, PreMode);
	return Status;
}

NTSTATUS RegDeleteKey(PVOID InBuffer,PVOID OutBuffer)
{
	PDELETE Delete = (PDELETE)InBuffer;
	HANDLE KeyHandle = Delete->hKey;

	return KernelDeleteKey(KeyHandle);
}



NTSTATUS 
	KernelDeleteKey(
	IN HANDLE  KeyHandle
	)
{
	
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	if (!KeyHandle)
	{
		return Status;
	}

	EThread = PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);

	Status = NtDeleteKeyAddress(KeyHandle);

	RecoverPreMode(EThread, PreMode);
	return Status;
}


NTSTATUS RegRenameKey(PVOID InBuffer,PVOID OutBuffer)
{
	PRENAME Rename = (PRENAME)InBuffer;
	HANDLE KeyHandle = Rename->hKey;
	PUNICODE_STRING uniNewName = (PUNICODE_STRING)(Rename->uniNewName);


	return KernelRenameKey(KeyHandle, uniNewName);
}




NTSTATUS KernelRenameKey(IN HANDLE KeyHandle, IN PUNICODE_STRING uniNewName)
{
	
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	if (!KeyHandle)
	{
		return Status;
	}

	EThread = PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);

	Status = NtRenameKeyAddress(KeyHandle, uniNewName);

	RecoverPreMode(EThread, PreMode);
	return Status;
}


NTSTATUS RegDeleteValueKey(PVOID InBuffer,PVOID OutBuffer)
{
	PDELETE_KEY_VALUE DeleteKeyValue = (PDELETE_KEY_VALUE)InBuffer;
	HANDLE KeyHandle = DeleteKeyValue->hKey;
	PUNICODE_STRING uniValueName = (PUNICODE_STRING)(DeleteKeyValue->uniValueName);


	return KernelDeleteValueKey(KeyHandle, uniValueName);
}


NTSTATUS 
	KernelDeleteValueKey(IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  uniValueName
	)
{
	
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	if (!KeyHandle)
	{
		return Status;
	}

	EThread = PsGetCurrentThread();
	PreMode = ChangePreMode(EThread);

	Status = NtDeleteValueKeyAddress(KeyHandle,uniValueName);

	RecoverPreMode(EThread, PreMode);
	return Status;
}


NTSTATUS DefaultDispatch(PDEVICE_OBJECT  DeviceObject,PIRP Irp)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp,IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

VOID UnloadDriver(PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING  uniLinkName;
	PDEVICE_OBJECT	NextObject = NULL;
	PDEVICE_OBJECT  CurrentObject = NULL;
	RtlInitUnicodeString(&uniLinkName,LINK_NAME);

	IoDeleteSymbolicLink(&uniLinkName);
	CurrentObject = DriverObject->DeviceObject;
	while (CurrentObject != NULL) 
	{
	
		NextObject = CurrentObject->NextDevice;
		IoDeleteDevice(CurrentObject);
		CurrentObject = NextObject;
	}

#ifdef WIN64
	DbgPrint("X64: RegisterManager IS STOPPED!!!\n");
#else
	DbgPrint("X86: RegisterManager IS STOPPED!!!\n");
#endif

	return;
}


CHAR ChangePreMode(PETHREAD EThread)
{

	CHAR PreMode = *(PCHAR)((ULONG_PTR)EThread + PreviousModeOffsetOf_KTHREAD);
	*(PCHAR)((ULONG_PTR)EThread + PreviousModeOffsetOf_KTHREAD) = KernelMode;
	return PreMode;
}

VOID RecoverPreMode(PETHREAD EThread, CHAR PreMode)
{

	*(PCHAR)((ULONG_PTR)EThread + PreviousModeOffsetOf_KTHREAD) = PreMode;
}



WIN_VERSION GetWindowsVersion()
{
	RTL_OSVERSIONINFOEXW osverInfo = {sizeof(osverInfo)}; 
	pfnRtlGetVersion RtlGetVersion = NULL;
	WIN_VERSION WinVersion;
	WCHAR wzRtlGetVersion[] = L"RtlGetVersion";

	RtlGetVersion = GetFunctionAddressByName(wzRtlGetVersion);    
	if (RtlGetVersion)
	{
		RtlGetVersion((PRTL_OSVERSIONINFOW)&osverInfo); 
	} 
	else 
	{
		PsGetVersion(&osverInfo.dwMajorVersion, &osverInfo.dwMinorVersion, &osverInfo.dwBuildNumber, NULL);
	}

	DbgPrint("Build Number: %d\r\n", osverInfo.dwBuildNumber);

	if (osverInfo.dwMajorVersion == 5 && osverInfo.dwMinorVersion == 1) 
	{
		DbgPrint("WINDOWS_XP\r\n");
		WinVersion = WINDOWS_XP;
	}
	else if (osverInfo.dwMajorVersion == 6 && osverInfo.dwMinorVersion == 1)
	{
		DbgPrint("WINDOWS 7\r\n");
		WinVersion = WINDOWS_7;
	}
	else if (osverInfo.dwMajorVersion == 6 && 
		osverInfo.dwMinorVersion == 2 &&
		osverInfo.dwBuildNumber == 9200)
	{
		DbgPrint("WINDOWS 8\r\n");
		WinVersion = WINDOWS_8;
	}
	else if (osverInfo.dwMajorVersion == 6 && 
		osverInfo.dwMinorVersion == 3 && 
		osverInfo.dwBuildNumber == 9600)
	{
		DbgPrint("WINDOWS 8.1\r\n");
		WinVersion = WINDOWS_8_1;
	}
	else
	{
		DbgPrint("WINDOWS_UNKNOW\r\n");
		WinVersion = WINDOWS_UNKNOW;
	}

	return WinVersion;
}
VOID SetGolbalMember()
{
	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			SYSTEM_ADDRESS_START = 0x80000000;


			PreviousModeOffsetOf_KTHREAD = 0x140;
			IndexOffset = 1;
			SSDTDescriptor = (ULONG_PTR)GetFunctionAddressByName(L"KeServiceDescriptorTable");
			//获得NtQueryObject函数的地址
			ulIndex = GetSSDTApiFunIndex("NtOpenKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtOpenKeyAddress  = (pfnNtOpenKey)SSDTFuncAddress;


			ulIndex = GetSSDTApiFunIndex("NtEnumerateKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtEnumerateKeyAddress  = (pfnNtEnumerateKey)SSDTFuncAddress;

			
			ulIndex = GetSSDTApiFunIndex("NtEnumerateValueKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtEnumerateValueKeyAddress  = (pfnNtEnumerateValueKey)SSDTFuncAddress;


			ulIndex = GetSSDTApiFunIndex("NtCreateKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtCreateKeyAddress  = (pfnNtCreateKey)SSDTFuncAddress;



			ulIndex = GetSSDTApiFunIndex("NtSetValueKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtSetValueKeyAddress  = (pfnNtSetValueKey)SSDTFuncAddress;


			ulIndex = GetSSDTApiFunIndex("NtDeleteKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtDeleteKeyAddress  = (pfnNtDeleteKey)SSDTFuncAddress;


			ulIndex = GetSSDTApiFunIndex("NtRenameKey");     
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtRenameKeyAddress  = (pfnNtRenameKey)SSDTFuncAddress;

			ulIndex = GetSSDTApiFunIndex("NtDeleteValueKey");     
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtDeleteValueKeyAddress  = (pfnNtDeleteValueKey)SSDTFuncAddress;

			break;
		}
	case WINDOWS_7:
		{

			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			IndexOffset = 4;
			SSDTDescriptor = GetKeServiceDescriptorTable64();

			ulIndex = GetSSDTApiFunIndex("NtOpenKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtOpenKeyAddress  = (pfnNtOpenKey)SSDTFuncAddress;

			ulIndex = GetSSDTApiFunIndex("NtEnumerateKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtEnumerateKeyAddress  = (pfnNtEnumerateKey)SSDTFuncAddress;

			ulIndex = GetSSDTApiFunIndex("NtEnumerateValueKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtEnumerateValueKeyAddress  = (pfnNtEnumerateValueKey)SSDTFuncAddress;


			ulIndex = GetSSDTApiFunIndex("NtCreateKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtCreateKeyAddress  = (pfnNtCreateKey)SSDTFuncAddress;

			ulIndex = GetSSDTApiFunIndex("NtSetValueKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtSetValueKeyAddress  = (pfnNtSetValueKey)SSDTFuncAddress;


			ulIndex = GetSSDTApiFunIndex("NtDeleteKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtDeleteKeyAddress  = (pfnNtDeleteKey)SSDTFuncAddress;

			ulIndex = GetSSDTApiFunIndex("NtRenameKey");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtRenameKeyAddress  = (pfnNtRenameKey)SSDTFuncAddress;

			ulIndex = GetSSDTApiFunIndex("NtDeleteValueKey");     
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);
			NtDeleteValueKeyAddress  = (pfnNtDeleteValueKey)SSDTFuncAddress;
			SYSTEM_ADDRESS_START = 0x80000000000;
			break;
		}
	}
}

PVOID GetFunctionAddressByName(WCHAR *wzFunction)
{
	UNICODE_STRING uniFunction;  
	PVOID AddrBase = NULL;

	if (wzFunction && wcslen(wzFunction) > 0)
	{
		RtlInitUnicodeString(&uniFunction, wzFunction);     
		AddrBase = MmGetSystemRoutineAddress(&uniFunction); 
	}

	return AddrBase;
}


ULONG_PTR GetKeServiceDescriptorTable64()
{
	PUCHAR StartSearchAddress = (PUCHAR)__readmsr(0xC0000082);
	PUCHAR EndSearchAddress = StartSearchAddress + 0x500;
	PUCHAR i = NULL;
	UCHAR b1=0,b2=0,b3=0;
	ULONG_PTR Temp = 0;
	ULONG_PTR Address = 0;
	for(i=StartSearchAddress;i<EndSearchAddress;i++)
	{
		if( MmIsAddressValid(i) && MmIsAddressValid(i+1) && MmIsAddressValid(i+2) )
		{
			b1=*i;
			b2=*(i+1);
			b3=*(i+2);
			if( b1==0x4c && b2==0x8d && b3==0x15 ) //4c8d15
			{
				memcpy(&Temp,i+3,4);
				Address = (ULONG_PTR)Temp + (ULONG_PTR)i + 7;
				return Address;
			}
		}
	}
	return 0;
}




LONG GetSSDTApiFunIndex(IN LPSTR lpszFunName)
{
	LONG Index = -1;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PVOID    MapBase = NULL;
	PIMAGE_NT_HEADERS  NtHeader;
	PIMAGE_EXPORT_DIRECTORY ExportTable;
	ULONG*  FunctionAddresses;
	ULONG*  FunctionNames;
	USHORT* FunIndexs;
	ULONG   ulFunIndex;
	ULONG   i;
	CHAR*   FunName;
	SIZE_T  ViewSize=0;
	ULONG_PTR FunAddress;
	WCHAR wzNtdll[] = L"\\SystemRoot\\System32\\ntdll.dll";

	Status = MapFileInUserSpace(wzNtdll, NtCurrentProcess(), &MapBase, &ViewSize);
	if (!NT_SUCCESS(Status))
	{

		return STATUS_UNSUCCESSFUL;

	}
	else
	{
		__try{
			NtHeader = RtlImageNtHeader(MapBase);
			if (NtHeader && NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress){
				ExportTable =(IMAGE_EXPORT_DIRECTORY *)((ULONG_PTR)MapBase + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
				FunctionAddresses = (ULONG*)((ULONG_PTR)MapBase + ExportTable->AddressOfFunctions);
				FunctionNames = (ULONG*)((ULONG_PTR)MapBase + ExportTable->AddressOfNames);
				FunIndexs = (USHORT*)((ULONG_PTR)MapBase + ExportTable->AddressOfNameOrdinals);
				for(i = 0; i < ExportTable->NumberOfNames; i++)
				{
					FunName = (LPSTR)((ULONG_PTR)MapBase + FunctionNames[i]);
					if (_stricmp(FunName, lpszFunName) == 0) 
					{
						ulFunIndex = FunIndexs[i]; 
						FunAddress = (ULONG_PTR)((ULONG_PTR)MapBase + FunctionAddresses[ulFunIndex]);
						Index=*(ULONG*)(FunAddress+IndexOffset);
						break;
					}
				}
			}
		}__except(EXCEPTION_EXECUTE_HANDLER)
		{
			;
		}
	}

	if (Index == -1)
	{
		DbgPrint("%s Get Index Error\n", lpszFunName);
	}

	ZwUnmapViewOfSection(NtCurrentProcess(), MapBase);
	return Index;
}




NTSTATUS 
MapFileInUserSpace(IN LPWSTR lpszFileName,IN HANDLE ProcessHandle OPTIONAL,
	OUT PVOID *BaseAddress,
	OUT PSIZE_T ViewSize OPTIONAL)
{
	NTSTATUS Status = STATUS_INVALID_PARAMETER;
	HANDLE   hFile = NULL;
	HANDLE   hSection = NULL;
	OBJECT_ATTRIBUTES oa;
	SIZE_T MapViewSize = 0;
	IO_STATUS_BLOCK Iosb;
	UNICODE_STRING uniFileName;

	if (!lpszFileName || !BaseAddress){
		return Status;
	}

	RtlInitUnicodeString(&uniFileName, lpszFileName);
	InitializeObjectAttributes(&oa,
		&uniFileName,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL,
		NULL
		);

	Status = IoCreateFile(&hFile,
		GENERIC_READ | SYNCHRONIZE,
		&oa,
		&Iosb,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ,
		FILE_OPEN,
		FILE_SYNCHRONOUS_IO_NONALERT,
		NULL,
		0,
		CreateFileTypeNone,
		NULL,
		IO_NO_PARAMETER_CHECKING
		);

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("ZwCreateFile Failed! Error=%08x\n",Status);
		return Status;
	}

	oa.ObjectName = NULL;
	Status = ZwCreateSection(&hSection,
		SECTION_QUERY | SECTION_MAP_READ,
		&oa,
		NULL,
		PAGE_WRITECOPY,
		SEC_IMAGE,
		hFile
		);
	ZwClose(hFile);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("ZwCreateSection Failed! Error=%08x\n",Status);
		return Status;

	}

	if (!ProcessHandle){
		ProcessHandle = NtCurrentProcess();
	}

	Status = ZwMapViewOfSection(hSection, 
		ProcessHandle, 
		BaseAddress, 
		0, 
		0, 
		0, 
		ViewSize ? ViewSize : &MapViewSize, 
		ViewUnmap, 
		0, 
		PAGE_WRITECOPY
		);
	ZwClose(hSection);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("ZwMapViewOfSection Failed! Error=%08x\n",Status);
		return Status;
	}

	return Status;
}




ULONG_PTR GetSSDTApiFunAddress(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor)
{
	ULONG_PTR  SSDTFuncAddress = 0;
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			SSDTFuncAddress = GetSSDTFunctionAddress64(ulIndex,SSDTDescriptor);
			break;
		}

	case WINDOWS_XP:
		{
			SSDTFuncAddress = GetSSDTFunctionAddress32(ulIndex,SSDTDescriptor);
			break;
		}
	}
}


ULONG_PTR GetSSDTFunctionAddress32(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor)
{
	ULONG_PTR ServiceTableBase= 0 ;
	PSYSTEM_SERVICE_TABLE32 SSDT = (PSYSTEM_SERVICE_TABLE32)SSDTDescriptor;

	ServiceTableBase=(ULONG_PTR)(SSDT ->ServiceTableBase);

	return (ULONG_PTR)(((ULONG*)ServiceTableBase)[(ULONG)ulIndex]);
}

ULONG_PTR GetSSDTFunctionAddress64(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor)
{
	LONG dwTemp=0;
	ULONG_PTR qwTemp=0;
	ULONG_PTR ServiceTableBase= 0 ;
	ULONG_PTR FuncAddress =0;
	PSYSTEM_SERVICE_TABLE64 SSDT = (PSYSTEM_SERVICE_TABLE64)SSDTDescriptor;
	ServiceTableBase=(ULONG_PTR)(SSDT ->ServiceTableBase);
	qwTemp = ServiceTableBase + 4 * ulIndex;
	dwTemp = *(PLONG)qwTemp;
	dwTemp = dwTemp>>4;
	FuncAddress = ServiceTableBase + (ULONG_PTR)dwTemp;
	return FuncAddress;
}




```

`Register/RegisterManagerDrv/RegisterManagerDrv.h`:

```h
#pragma once

#include <ntifs.h>
#include <devioctl.h>
#include <ntimage.h>
#define SEC_IMAGE 0x01000000

typedef struct _OPEN_
{
	ACCESS_MASK DesiredAccess;
	POBJECT_ATTRIBUTES ObjectAttributes;
}OPEN,*POPEN;

typedef struct _ENUM_
{
	HANDLE hKey;
	ULONG Index;
	ULONG InformationClass;
	ULONG Length;
}ENUM,*PENUM;

typedef struct _ENUM_VALUE_
{
	PULONG RetLength;
	PVOID  ValueInfor;
}ENUM_VALUE, *PENUM_VALUE;


typedef struct  _CREATE_
{
	ACCESS_MASK DesiredAccess;
	POBJECT_ATTRIBUTES ObjectAttributes;
}CREATE,*PCREATE;



typedef struct _CREATE_VALUE_
{
	PHANDLE KeyHandle;
	PULONG  Disposition;
}CREATE_VALUE, *PCREATE_VALUE;

typedef struct _SET_KEY_VALUE_
{
	HANDLE hKey;
	PUNICODE_STRING ValueName;
	ULONG Type;
	PVOID Data;
	ULONG DataSize;
}SET_KEY_VALUE,*PSET_KEY_VALUE;


typedef struct _DELETE_   
{
	HANDLE  hKey;

}*PDELETE;


typedef  struct _DELETE_KEY_VALUE_ 
{
	HANDLE hKey;
	PUNICODE_STRING  uniValueName;

}DELETE_KEY_VALUE,*PDELETE_KEY_VALUE;


typedef struct  _RENAME_
{
	HANDLE hKey;
	PUNICODE_STRING  uniNewName;
}RENAME,*PRENAME;



typedef enum WIN_VERSION {
	WINDOWS_UNKNOW,
	WINDOWS_XP,
	WINDOWS_7,
	WINDOWS_8,
	WINDOWS_8_1
} WIN_VERSION;


typedef struct _SYSTEM_SERVICE_TABLE64{
	PVOID  		ServiceTableBase; 
	PVOID  		ServiceCounterTableBase; 
	ULONG64  	NumberOfServices; 
	PVOID  		ParamTableBase; 
} SYSTEM_SERVICE_TABLE64, *PSYSTEM_SERVICE_TABLE64;

typedef struct _SYSTEM_SERVICE_TABLE32 {
	PVOID   ServiceTableBase;
	PVOID   ServiceCounterTableBase;
	ULONG32 NumberOfServices;
	PVOID   ParamTableBase;
} SYSTEM_SERVICE_TABLE32, *PSYSTEM_SERVICE_TABLE32;

#define DEVICE_NAME  L"\\Device\\RegisterManagerDevice"
#define LINK_NAME    L"\\??\\RegisterManagerLink"


#define CTL_CREATE_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x833,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_OPEN_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_ENUM_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x831,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_ENUM_KEY_VALUE \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x832,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_SET_KEY_VALUE \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x834,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_DELETE_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x835,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_RENAME_KEY \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x836,METHOD_NEITHER,FILE_ANY_ACCESS)
#define CTL_DELETE_KEY_VALUE \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x837,METHOD_NEITHER,FILE_ANY_ACCESS)

NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID Base);

typedef NTSTATUS(NTAPI *pfnNtOpenKey)(PHANDLE KeyHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes);

typedef NTSTATUS(NTAPI *pfnNtEnumerateKey)(
	HANDLE KeyHandle,
	ULONG Index,
	KEY_INFORMATION_CLASS KeyInformationClass,
	PVOID KeyInformation,
	ULONG Length,
	PULONG ResultLength);

typedef NTSTATUS(*pfnNtEnumerateValueKey)(
	HANDLE KeyHandle,
	ULONG Index,
	KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	PVOID KeyValueInformation,
	ULONG Length,
	PULONG ResultLength);


typedef NTSTATUS (*pfnNtCreateKey)(
	OUT PHANDLE  KeyHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES  ObjectAttributes,
	IN ULONG  TitleIndex,
	IN PUNICODE_STRING  Class  OPTIONAL,
	IN ULONG  CreateOptions,
	OUT PULONG  Disposition  OPTIONAL);

typedef NTSTATUS (*pfnNtSetValueKey)(
	IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  ValueName,
	IN ULONG  TitleIndex  OPTIONAL,
	IN ULONG  Type,
	IN PVOID  Data,
	IN ULONG  DataSize);

typedef NTSTATUS (*pfnNtDeleteKey)(
	IN HANDLE  KeyHandle);

typedef NTSTATUS(*pfnNtRenameKey)(
	IN HANDLE KeyHandle,
	IN PUNICODE_STRING uniNewName);

typedef NTSTATUS (*pfnNtDeleteValueKey)(
	IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  uniValueName);

VOID UnloadDriver(PDRIVER_OBJECT DriverObject);
NTSTATUS DefaultDispatch(PDEVICE_OBJECT  DeviceObject,PIRP Irp);
NTSTATUS ControlDispatch(PDEVICE_OBJECT  DeviceObject,PIRP Irp);

typedef NTSTATUS (*pfnRtlGetVersion)(OUT PRTL_OSVERSIONINFOW lpVersionInformation);
PVOID GetFunctionAddressByName(WCHAR *wzFunction);
WIN_VERSION GetWindowsVersion();
VOID SetGolbalMember();
LONG GetSSDTApiFunIndex(IN LPSTR lpszFunName);
NTSTATUS MapFileInUserSpace(IN LPWSTR lpszFileName,
	IN HANDLE ProcessHandle OPTIONAL,
	OUT PVOID *BaseAddress,
	OUT PSIZE_T ViewSize OPTIONAL);

ULONG_PTR GetSSDTApiFunAddress(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor);
ULONG_PTR GetSSDTFunctionAddress64(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor);
ULONG_PTR GetSSDTFunctionAddress32(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor);
ULONG_PTR GetKeServiceDescriptorTable64();

VOID RecoverPreMode(PETHREAD EThread, CHAR PreMode);
CHAR ChangePreMode(PETHREAD EThread);
NTSTATUS RegOpenKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelOpenKey(OUT PHANDLE KeyHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES  ObjectAttributes);

NTSTATUS RegEnumerateKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelEnumerateKey(IN HANDLE  KeyHandle,
	IN ULONG  Index,
	IN KEY_INFORMATION_CLASS  KeyInformationClass,
	OUT PVOID  KeyInformation,
	IN ULONG  Length,
	OUT PULONG  ResultLength);

NTSTATUS RegEnumerateValueKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelEnumerateValueKey(IN HANDLE KeyHandle,
	IN ULONG  Index,
	IN KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass,
	OUT PVOID  KeyValueInformation,
	IN ULONG  Length,
	OUT PULONG  ResultLength);

NTSTATUS RegCreateKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelCreateKey(
	OUT PHANDLE  KeyHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES  ObjectAttributes,
	IN ULONG  TitleIndex,
	IN PUNICODE_STRING  Class  OPTIONAL,
	IN ULONG  CreateOptions,
	OUT PULONG  Disposition  OPTIONAL);
NTSTATUS RegSetValueKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelSetValueKey(IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  ValueName,
	IN ULONG  TitleIndex  OPTIONAL,
	IN ULONG  Type,
	IN PVOID  Data,
	IN ULONG  DataSize);
NTSTATUS RegDeleteKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelDeleteKey(
	IN HANDLE  KeyHandle);
NTSTATUS RegRenameKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelRenameKey(IN HANDLE KeyHandle, IN PUNICODE_STRING uniNewName);
NTSTATUS RegDeleteValueKey(PVOID InBuffer,PVOID OutBuffer);
NTSTATUS KernelDeleteValueKey(IN HANDLE  KeyHandle,
	IN PUNICODE_STRING  uniValueName);


```

`Register/RegisterManagerDrv/RegisterManagerDrv.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RegisterManagerDrv", "RegisterManagerDrv.vcxproj", "{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		WinDDK|Win32 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.ActiveCfg = WinDDK|Win32
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.Build.0 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Register/RegisterManagerDrv/RegisterManagerDrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="WinDDK|Win32">
      <Configuration>WinDDK</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>"RegisterManagerDrv"</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
    <ExecutablePath>$(WLHBASE)\bin\x86\x86;$(WLHBASE)\bin\x86</ExecutablePath>
    <IncludePath>$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc</IncludePath>
    <ReferencePath />
    <LibraryPath>$(WLHBASE)\lib\win7\i386</LibraryPath>
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG=1</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include=".\RegisterManagerDrv.c" />
    <ClCompile Include=".\RegisterManagerDrv.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Register/RegisterManagerDrv/RegisterManagerDrv.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Register/RegisterManagerDrv/clean.bat`:

```bat
rem /////////////////
rem / Add by ChiChou
rem / 
rem / FileName:Clean.bat
rem / Description:Clean
rem /
rem ////////////////
rd .\bin /s /q
rd .\WinDDK /s /q
rd .\objchk_w2k_x86 /s /q
rd .\objchk_wxp_x86 /s /q
rd .\objchk_wnet_x86 /s /q
rd .\objchk_wlh_x86 /s /q
rd .\objfre_w2k_x86 /s /q
rd .\objfre_wxp_x86 /s /q
rd .\objfre_wnet_x86 /s /q
rd .\objfre_wlh_x86 /s /q
del .\*.log
del .\*.err
del .\*.xml
rem ***** del VS2005 file *****
del .\*.ncb
del .\*.user
del .\*.suo /A:H
rem ***** del VS6.0 file *****
del .\*.plg
del .\*.opt
exit
```

`Register/RegisterManagerDrv/ddkbuild.cmd`:

```cmd
@echo off
@set VERSION=V7.3
@set OSR_DEBUG=off
@if "%OS%"=="Windows_NT" goto :Prerequisites
@echo This script requires Windows NT 4.0 or later to run properly!
goto :EOF
:Prerequisites
:: Check whether FINDSTR is available. It's used to show warnings etc.
findstr /? > NUL 2>&1 || echo "FINDSTR is a prerequisite but wasn't found!" && goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    $Id: ddkbuild.cmd 27 2008-09-06 12:02:06Z oliver $
::
::    This software is supplied for instructional purposes only.
::
::    OSR Open Systems Resources, Inc. (OSR) expressly disclaims any warranty
::    for this software.  THIS SOFTWARE IS PROVIDED  "AS IS" WITHOUT WARRANTY
::    OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
::    THE IMPLIED WARRANTIES OF MECHANTABILITY OR FITNESS FOR A PARTICULAR
::    PURPOSE.  THE ENTIRE RISK ARISING FROM THE USE OF THIS SOFTWARE REMAINS
::    WITH YOU.  OSR's entire liability and your exclusive remedy shall not
::    exceed the price paid for this material.  In no event shall OSR or its
::    suppliers be liable for any damages whatsoever (including, without
::    limitation, damages for loss of business profit, business interruption,
::    loss of business information, or any other pecuniary loss) arising out
::    of the use or inability to use this software, even if OSR has been
::    advised of the possibility of such damages.  Because some states/
::    jurisdictions do not allow the exclusion or limitation of liability for
::    consequential or incidental damages, the above limitation may not apply
::    to you.
::
::    OSR Open Systems Resources, Inc.
::    105 Route 101A Suite 19
::    Amherst, NH 03031  (603) 595-6500 FAX: (603) 595-6503
::    report bugs to <bugs@osr.com>
::    alternatively report them via <http://assarbad.net/contact/>
::
::
::    MODULE:
::
::      ddkbuild.cmd
::
::    ABSTRACT:
::
::      This script allows drivers to be built with Visual Studio 2002 through
::      Visual Studio 2008 and possibly future versions. It will also work fine
::      from the command line.
::      If you are interested in a project wizard that makes use of this script,
::      try DDKWizard from <http://ddkwizard.assarbad.net>.
::
::    AUTHOR(S):
::
::      - OSR Open Systems Resources, Inc.
::      - Oliver Schneider (ddkwizard.assarbad.net)
::
::    REQUIREMENTS:
::
::      Environment variables that must be set.
::        %NT4BASE%  - Set this up for "-NT4" builds (legacy, support not tested)
::        %W2KBASE%  - Set this up for "-W2K*" builds (legacy, support not tested)
::        %WXPBASE%  - Set this up for "-WXP*" builds
::        %WNETBASE% - Set this up for "-WNET*" builds
::        %WLHBASE%  - Set this up for "-WLH*" builds
::        %WDF_ROOT% - Must be set if attempting to do a WDF Build.
::
::      Examples:
::        NT4BASE : could be "D:\NT4DDK"
::        W2KBASE : could be "D:\Nt50DDK"
::        WXPBASE : could be "D:\WINDDK\2600"
::        WNETBASE: could be "D:\WINDDK\3790.1830" or "C:\WINDDK\3790"
::
::    COMMAND FORMAT:
::
::      Run the script without any parameters to get the whole help content!
::      Note: "-WDF" has been tested with the 01.00.5054 version of the framework
::
::    RETURN CODES AND THEIR MEANING:
::
::      001 == Unknown build type. Check the <platform> parameter
::      002 == No WDF_ROOT given using WDF build type.
::      003 == The DDK-specific base directory variable (NT4BASE, W2KBASE, WXPBASE,
::             WNETBASE) is not set at all and could not be auto-detected!
::      004 == BASEDIR variable is empty. Check to see that the DDK-specific
::             variable is set correctly (i.e. NT4BASE, W2KBASE, WXPBASE, WNETBASE)
::      005 == No mode (checked/free) was given. Check the respective parameter!
::      006 == No DIR or SOURCES file found in the given target directory.
::      007 == No target directory given.
::      008 == Given target directory does not exist.
::      009 == The SETENV script failed.
::
::      Note: If %OSR_ERRCODE% and %ERRORLEVEL% are equal, the return code stems
::            from one of the tools being called during the build process.
::
::    BROWSE FILES:
::
::      This procedure supports the building of BROWSE files to be used by
::      Visual Studio 6 and by Visual Studio.NET  However, the BSCfiles created
::      by bscmake for the two are not compatible. When this command procedure
::      runs, it selects the first bscmake.exe found in the path. So, make sure
::      that the correct bscmake.exe is in the path ...
::
::      Note that if using Visual Studio.NET the .BSC must be added to the project
::      in order for the project to be browsed.
::      Another alternative is the VS addon named "Visual Assist X" which will
::      parse the header files - no more need for browse files.
::
::    COMPILERS:
::
::      If you are building NT4 you should really be using the VC6 compiler.
::      Later versions of the DDK now contain the compiler and the linker. This
::      procedure should use the correct compiler.
::
::    GENERAL COMMENTS:
::
::      This procedure has been cleaned up to be modular and easy to understand.
::
::      As of the Server 2003 SP1 DDK DDKBUILD now clears the NO_BROWSE_FILE and
::      NO_BINPLACE environment variables so that users can use these features.
::
::      Starting with the Vista WDK, the output in the respective tool window
::      in VS is in Unicode by default. This garbles the output from DDKBUILD
::      and we therefore clear the environment variable VS_UNICODE_OUTPUT.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MAIN
:: Building "stack frame"
setlocal ENABLEEXTENSIONS & pushd .
:: Check whether the REG utility is available
reg /? > NUL 2>&1 && set OSR_REGAVAILABLE=1

:: This is set by client-side keyword substitution
set SVN_REVISION=$Revision: 27 $
:: Extract the revision number from the revision keyword
set SVN_REVISION=%SVN_REVISION:~0,-2%
set SVN_REVISION=%SVN_REVISION:~11%
:: This is set by client-side keyword substitution
set SVN_REVDATE=$Date: 2008-09-06 12:02:06 +0000 (Sat, 06 Sep 2008) $
:: Extract the date from the Date keyword
set SVN_REVDATE=%SVN_REVDATE:~7,10%
set VERSION=%VERSION%/r%SVN_REVISION%

:: Init some special variables
set OSR_VERSTR=OSR DDKBUILD.CMD %VERSION% (%SVN_REVDATE%) - OSR, Open Systems Resources, Inc.
set OSR_PREBUILD_SCRIPT=ddkprebld.cmd
set OSR_POSTBUILD_SCRIPT=ddkpostbld.cmd
set OSR_SETENV_SCRIPT=ddkbldenv.cmd
set OSR_ECHO=@echo DDKBLD:

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set error messages
:: Possible codes: 1
set ERR_UnknownBuildType=Unknown type of build. Please recheck parameters.
:: Possible codes: 2
set ERR_NoWdfRoot=WDF_ROOT is not defined, are you using 00.01.5054 or later?
:: Possible codes: 3
set ERR_BaseDirNotSet=To build using type %%OSR_TARGET%% you need to set the %%%%%%BASEDIRVAR%%%%%% environment variable to point to the %%BASEDIROS%% DDK base directory!
:: Possible codes: 4
set ERR_NoBASEDIR=NT4BASE, W2KBASE, WXPBASE and/or WNETBASE environment variable(s) not set. Environment variable(s) must be set by user according to DDK version(s) installed.
:: Possible codes: 5
set ERR_BadMode=^<build type^> must be 'checked', 'free', 'chk' or 'fre' (case-insensitive).
:: Possible codes: 6
set ERR_NoTarget=Target directory must contain a SOURCES or DIRS file.
:: Possible codes: 7, 8
set ERR_NoDir=The ^<directory^> parameter must be a valid directory.
:: Possible codes: 9
set ERR_SetEnvFailed=The SETENV script failed.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Clear the error code variable
set OSR_ERRCODE=0
set prefast_build=0

:: Turn on tracing, use %OSR_TRACE% instead of ECHO
if /i "%OSR_DEBUG%" == "on" (set OSR_TRACE=%OSR_ECHO% [TRACE]) else (set OSR_TRACE=rem)
:: Turn on echoing of current line if %OSR_DEBUG% is set to "on"
@echo %OSR_DEBUG%

:: Output version string
@echo %OSR_VERSTR%
%OSR_TRACE% ^(Current module: ^"%~f0^"^)
@echo.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set the target platform variable
set OSR_TARGET=%~1
:: Remove any dashes in the variable
if not "%OSR_TARGET%" == "" set OSR_TARGET=%OSR_TARGET:-=%
:: Show help if the target parameter is empty after removal of the dashes
if "%OSR_TARGET%" == "" goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: In the build directory check for this script and call it if it exists.
:: This allows to override any global system variable setting, if desired.
if not "%3" == "" call :GetCustomEnvironment "%~f3"
if not "%OSR_ERRCODE%" == "0" goto :USAGE
:: Additional error handling for better usability
:: These subroutines will also attempt to locate the requested DDK!!!
set OSR_ERRCODE=3
%OSR_TRACE% Checking whether the environment variable for the build type was set
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Check > NUL 2>&1
:: If the BASEDIROS/BASEDIRVAR variable is not defined, it means the subroutine did not exist!
if not DEFINED BASEDIROS call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIROS)" & goto :USAGE
if not DEFINED BASEDIRVAR call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIRVAR)" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BaseDirNotSet%" & goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
set BASEDIR=%%%BASEDIRVAR%%%
call :ResolveVar BASEDIR
call :MakeShort BASEDIR "%BASEDIR%"
:: Check for existing %BASEDIR%
if "%BASEDIR%" == "" call :ShowErrorMsg 4 "%ERR_NoBASEDIR%" & goto :USAGE
set PATH=%BASEDIR%\bin;%PATH%
%OSR_TRACE% Now jump to the initialization of the commandline
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Build

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_TRACE% We returned from the variable initialization
if not DEFINED OSR_CMDLINE call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (OSR_CMDLINE)" & goto :USAGE

%OSR_TRACE% Hurrah, all the variables have been initialized, continuing
:: Proceed with common build steps
goto :CommonBuild

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Check whether the parameter makes sense and try to
:: correct it if possible
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WLH64Check
:WLHA64Check
:WLHXP64Check
:WLHNET64Check
:WLHNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WLHCheck
:WLHX64Check
:WLHI64Check
:WLHNETX64Check
:WLHNETI64Check
:WLHXPCheck
:WLH2KCheck
:WLHNETCheck
set BASEDIROS=Windows Vista/Windows 2008 Server
set BASEDIRVAR=WLHBASE
:: Compatibility between BUILD and VS ... prevent pipes from being used
%OSR_ECHO% Clearing %%VS_UNICODE_OUTPUT%% ...
set VS_UNICODE_OUTPUT=
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "6001.18000 6000"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WNETW2KCheck
:WNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WNET2KCheck
:WNETXPCheck
:WNETWXPCheck
:WNETXP64Check
:WNET64Check
:WNETI64Check
:WNETAMD64Check
:WNETX64Check
:WNETCheck
set BASEDIROS=Windows 2003 Server
set BASEDIRVAR=WNETBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "3790.1830 3790.1218 3790"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:XPCheck
:XP64Check
:XPW2KCheck
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WXP64Check
:WXPI64Check
:WXPCheck
:WXP2KCheck
set BASEDIROS=Windows XP
set BASEDIRVAR=WXPBASE
:: Other flavor of DDKBUILD
if not DEFINED WXPBASE if DEFINED XPBASE set BASEDIRVAR=XPBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "2600.1106 2600"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:W2K64Check
:W2KI64Check
:W2KCheck
set BASEDIROS=Windows 2000
set BASEDIRVAR=W2KBASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:NT4Check
set BASEDIROS=Windows NT4
set BASEDIRVAR=NT4BASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg1
echo.
%OSR_ECHO% WARNING: %%%BASEDIRVAR%%% NOT SET!
%OSR_ECHO%   Attempting to auto-detect the installation folder and set %%%BASEDIRVAR%%%.
%OSR_ECHO%   (If this fails *you* will have to set it!)
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg2
echo.
%OSR_ECHO% WARNING:
%OSR_ECHO%   Auto-detection of the folder settings is not supported for the requested DDK.
%OSR_ECHO%   Please set %%%BASEDIRVAR%%% yourself!
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckSetVarWithReturn
%OSR_ECHO% Found!
echo.
set %BASEDIRVAR%=%BASEDIRTEMP%
set BASEDIRTEMP=
:: Tell the caller it was successful
:CommonCheckNoErrorWithReturn
set OSR_ERRCODE=0
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckErrorNotDetectedWithReturn
echo.
%OSR_ECHO% None of the usual default paths works. Set %%%BASEDIRVAR%%% manually!
:CommonCheckErrorNotSupportedWithReturn
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Initialize variables specific to the respective platform
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: 
:: Valid parameters for setenv in different DDKs/WDKs:
::
:: 2600       - "setenv <directory> [fre|chk] [64] [hal]"
:: 2600.1106  - "setenv <directory> [fre|chk] [64] [hal] [WXP|W2K]"
:: 3790       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K]"
:: 3790.1830  - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K] [no_prefast] [bscmake]"
:: 6000       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"
:: 6001.18000 - "setenv <directory> [fre|chk] [64|x64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: NT 4.0 build using NT4 DDK
:NT4Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% "%%MSDEVDIR%%"
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WXP DDK
:XPW2KBuild
:WXP2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\w2k\set2k.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 64bit (Intel) using W2K DDK
:W2K64Build
:W2KI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv64.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using W2K DDK
:W2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WXP DDK
:XP64Build
:WXP64Build
:WXPI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WXP DDK
:XPBuild
:WXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WNET DDK
:WNETW2KBuild
:WNET2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% W2K %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WNET DDK
:WNETXPBuild
:WNETWXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit using WNET DDK
:WNETXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WNET DDK
:WNET64Build
:WNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WNET DDK
:WNETA64Build
:WNETAMD64Build
:WNETX64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% AMD64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WNET DDK
:WNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 32bit using WLH DDK
:WLHBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (AMD) using WLH DDK
:WLHA64Build
:WLHX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (Intel) using WLH DDK
:WLH64Build
:WLHI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WLH DDK
:WLHNETA64Build
:WLHNETX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WLH DDK
:WLHNET64Build
:WLHNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WLH DDK
:WLHXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WLH DDK
:WLHXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WLH DDK
:WLH2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% W2K
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WLH DDK
:WLHNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: All builds go here for the rest of the procedure. Now,
:: we are getting ready to call build. The big problem
:: here is to figure our the name of the buildxxx files
:: being generated for the different platforms.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:CommonBuild
:: Remove first command line arg
shift
call :SetMode %1
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BadMode%" & goto :USAGE
set OSR_BUILDNAME=%OSR_TARGET% (%BuildMode%) using the %BASEDIROS% DDK and %%%BASEDIRVAR%%%

call :CheckTargets %2
if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :USAGE

:: Resolve any variables in the command line string
call :ResolveVar OSR_CMDLINE

pushd .
set ERRORLEVEL=0
:: This external script prepares the build environment (e.g. setenv.bat)
call %OSR_CMDLINE%
:: Will only work with newer SETENV.BAT versions, but will be helpful in this case.
if not "%ERRORLEVEL%" == "0" call :ShowErrorMsg 9 "%ERR_SetEnvFailed%" & goto :USAGE
popd

:: ----------------------------------------------------------------------------
:: Setting global variables for the scope of this CMD session
set NO_BROWSER_FILE=
set NO_BINPLACE=
set buildDirectory=%~fs2
call :MakeShort buildDirectory "%buildDirectory%"
set buildDirectory_raw=%2
set buildDirectory_fname=%~n2
%OSR_TRACE% buildDirectory       == %buildDirectory%
%OSR_TRACE% buildDirectory_raw   == %buildDirectory_raw%
%OSR_TRACE% buildDirectory_fname == %buildDirectory_fname%

set mpFlag=-M
if "%BUILD_ALT_DIR%" == "" goto :NT4

:: W2K sets this!
set OSR_EXT=%BUILD_ALT_DIR%
set mpFlag=-MI

:NT4
if "%NUMBER_OF_PROCESSORS%" == "" set mpFlag=
if "%NUMBER_OF_PROCESSORS%" == "1" set mpFlag=

:: Set additional variables at this point or do whatever you please
@if exist "%buildDirectory%\%OSR_PREBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_PREBUILD_SCRIPT%" > "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
)
:: Save the current directory (before changing into the build directory!)
:: AFTERPREBUILD
pushd .

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Determine the settings of flags, WDF and PREFAST in
:: other words what was set for %3 and beyond....
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_ECHO% %OSR_BUILDNAME%
set OSR_ARGS= + argument(s):
if not "%3" == "" set OSR_ARGS=%OSR_ARGS% %3
if not "%4" == "" set OSR_ARGS=%OSR_ARGS% %4
if not "%5" == "" set OSR_ARGS=%OSR_ARGS% %5
if /i "%OSR_ARGS%" == " + argument(s):" set OSR_ARGS=
%OSR_ECHO% Directory: %buildDirectory%%OSR_ARGS%
%OSR_ECHO% %BASEDIRVAR%: %BASEDIR%

cd /D %~s2
set bFlags=-Ze
set bscFlags=

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ContinueParsing
if "%3" == "" goto :DONE
if "%3" == "/a" goto :RebuildallFound
if /i "%3" == "-WDF" goto :WDFFound
if /i "%3" == "-PREFAST" goto :PrefastFound
set bscFlags=/n
set bFlags=%bFlags% %3
:: Remove next arg
shift
goto :ContinueParsing

:WDFFound
shift
:: Note, that the setwdf.bat is called from setenv.bat in the WDK,
:: therefore we skip it.
if /i "%BASEDIRVAR%" == "WLHBASE" goto :WDFOkay
if "%WDF_ROOT%" == "" call :ShowErrorMsg 2 "%ERR_NoWdfRoot%" & goto :USAGE
pushd .
if exist "%WDF_ROOT%\set_wdf_env.cmd" call "%WDF_ROOT%\set_wdf_env.cmd"
popd
:WDFOkay
goto :ContinueParsing

:PrefastFound
shift
set prefast_build=1
goto :ContinueParsing

:RebuildallFound
shift
set bscFlags=/n
set bFlags=%bFlags:-Ze=-cfeZ%
set bFlags=%bFlags: -cZ=%
goto :ContinueParsing
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:DONE
for %%x in (build%OSR_EXT%.err build%OSR_EXT%.wrn build%OSR_EXT%.log prefast%OSR_EXT%.log) do @(
  if exist "%%x"   del /f /q "%%x"
)

if not "%prefast_build%" == "0" goto :RunPrefastBuild
%OSR_ECHO% Run build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
pushd .
build %mpFlag% %bFlags%
popd
goto :BuildComplete

:RunPrefastBuild
%OSR_ECHO% Run prefast build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
setlocal ENABLEEXTENSIONS & pushd .
set PREFASTLOG=PREfast_defects_%OSR_EXT%.xml
prefast /log=%PREFASTLOG% /reset build %mpFlag% %bFlags% > NUL 2>&1
if "%errorlevel%" GTR "0" set OSR_ERRCODE=%errorlevel%
prefast /log=%PREFASTLOG% list > prefast%OSR_EXT%.log
%OSR_ECHO% The PREfast logfile is ^"%prefastlog%^"!
popd & endlocal

:BuildComplete
if not "%errorlevel%" == "0" set OSR_ERRCODE=%errorlevel%

@echo %OSR_DEBUG%
:: Assume that the onscreen errors are complete!
setlocal
set WARNING_FILE_COUNT=0
if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+1
)
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% ================ Build warnings =======================
  if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set WARNING_FILE_COUNT_PRE=0
if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT_PRE=%WARNING_FILE_COUNT_PRE%+1
)
:: Reset if this is no PREfast build
if "%prefast_build%" == "0" set WARNING_FILE_COUNT_PRE=0
if not "%WARNING_FILE_COUNT_PRE%" == "0" (
  %OSR_ECHO% =============== PREfast warnings ======================
  if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+%WARNING_FILE_COUNT_PRE%
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% =======================================================
)
endlocal
@echo.
%OSR_ECHO% Build complete
%OSR_ECHO% Building browse information files
if exist "buildbrowse.cmd" call "buildbrowse.cmd" & goto :postBuildSteps
set sbrlist=sbrList.txt
if not exist sbrList%CPU%.txt goto :sbrDefault
set sbrlist=sbrList%CPU%.txt

:sbrDefault
if not exist %sbrlist% goto :postBuildSteps
:: Prepend blank space
if not "%bscFlags%" == "" set bscFlags= %bscFlags%
:: bscmake%bscFlags% prevents a double blank space ...
bscmake%bscFlags% @%sbrlist%

:: Perform whatever post-build steps
:postBuildSteps
:: Restore the current directory (after changing into the build directory!)
:: Search upwards for "AFTERPREBUILD" to find the corresponding PUSHD
popd
@if exist "%buildDirectory%\%OSR_POSTBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_POSTBUILD_SCRIPT%" > "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
)
goto :END
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / GetCustomEnvironment
::    First parameter is the "directory" that supposedly contains the SOURCES
::    or DIRS file (and the build scripts)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:GetCustomEnvironment
pushd .
call :CheckTargets "%~f1"
@if not "%OSR_ERRCODE%" == "0" @(
  echo.
  %OSR_ECHO% The target directory seemed to not contain a DIRS or SOURCES file
  %OSR_ECHO% when trying to set a custom environment! Quitting.
  set buildDirectory=%~f1
  if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :GetCustomEnvironment_ret
  call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :GetCustomEnvironment_ret
  goto :GetCustomEnvironment_ret
)
:: If the user provided a script to customize the environment, execute it.
@if exist "%~f1\%OSR_SETENV_SCRIPT%" @(
  %OSR_ECHO% ^>^> Setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
  pushd "%~f1"
  call "%OSR_SETENV_SCRIPT%" > "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_SETENV_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
)
:GetCustomEnvironment_ret
popd
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ GetCustomEnvironment
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / SetMode
::    Subroutine to validate the mode of the build passed in. It must be free,
::    FREE, fre, FRE or checked, CHECKED, chk, CHK. Anything else is an error.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetMode
set BuildMode=
if /i "%OSR_TARGET%" == "WLH2K" goto :SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=free
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=checked
goto :SetModeCommonEnd
:SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=f
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=c
:SetModeCommonEnd
%OSR_TRACE% Mode set to ^"%BuildMode%^"
if "%BuildMode%" == "" set OSR_ERRCODE=5
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ SetMode
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / CheckTargets subroutine
::   Subroutine to validate that the target directory exists and that there is
::   either a DIRS or SOURCES and MakeFile in it.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CheckTargets
:: Building "stack frame"
setlocal & pushd . & set OSR_ERRCODE=0
set lTarget=%~1
if not "%lTarget%" == "" goto :CheckTargets1
set OSR_ERRCODE=7
goto :CheckTargets_ret
:CheckTargets1
if exist "%lTarget%" goto :CheckTargets2
set OSR_ERRCODE=8
goto :CheckTargets_ret
:CheckTargets2
if not exist "%lTarget%\DIRS" goto :CheckTargets3
set OSR_ERRCODE=0
goto :CheckTargets_ret
:CheckTargets3
if exist "%lTarget%\SOURCES" goto :CheckTargets4
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets4
if exist "%lTarget%\MAKEFILE" goto :CheckTargets5
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets5
set OSR_ERRCODE=0
:CheckTargets_ret
:: Cleaning "stack frame" and returning error code into global scope
popd & endlocal & set OSR_ERRCODE=%OSR_ERRCODE%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ CheckTargets subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ResolveVar subroutine
::   There is only one parameter, the name of the variable to be resolved!
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ResolveVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
set VAR_TEMPRET2=%%%VAR_NAME%%%
:ResolveVarLoop
set VAR_TEMPRET1=%VAR_TEMPRET2%
set VAR_TEMPRET2=%VAR_TEMPRET1%
for /f "tokens=*" %%i in ('echo %VAR_TEMPRET1%') do (
  set VAR_TEMPRET2=%%i
)
if not "%VAR_TEMPRET1%" == "%VAR_TEMPRET2%" goto :ResolveVarLoop
:: Re-export the variable out of the local scope
endlocal & set %VAR_NAME%=%VAR_TEMPRET1%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ResolveVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MakeShort subroutine
::   Two parameters. First parameter is the variable name, second is the path
::   to convert into a short filename.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MakeShort
setlocal ENABLEEXTENSIONS
:: Get the name of the variable we are working with and the path to convert
set VAR_NAME=%~1
set PATH_SHORT=%~dpns2
set PATH_EXTSHORT=%~xs2
if not "" == "%PATH_EXTSHORT%" set PATH_EXTSHORT=%PATH_EXTSHORT:~0,4%
set PATH_SHORT=%PATH_SHORT%%PATH_EXTSHORT%
endlocal & set %VAR_NAME%=%PATH_SHORT%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MakeShort subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ErrorWithUsage subroutine
::   This one will take the passed in parameters and build a nice error
::   message which is returned to the user along with the usage hints.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ShowErrorMsg
@set OSR_ERRCODE=%~1
@set OSR_ERRMSG=%~2
@set OSR_ERRMSG=%OSR_ERRMSG:'="%
@set OSR_ERRMSG=ERROR #%OSR_ERRCODE%: %OSR_ERRMSG%
@echo.
%OSR_ECHO% %OSR_ERRMSG%
if DEFINED buildDirectory %OSR_ECHO% -^> Target directory: %buildDirectory%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ErrorWithUsage subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / SetVar subroutine
::   Param1 == name of the variable, Param2 == value to be set for the variable
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
endlocal & set %VAR_NAME%=%~2
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ SetVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectVistaWDK subroutine
::   No parameters expected
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectVistaWDK
setlocal ENABLEEXTENSIONS
:: Newer flag (starting with W2K8) is default
set OSR_AMD64FLAG=x64
:: The Vista WDK accepted *only* "AMD64", the newer W2K8 WDK accepts only "x64"
:: We detect the older one by checking the setenv.bat for a certain string
findstr /C:"Windows Server Longhorn" "%BASEDIR%\bin\setenv.bat" > NUL 2>&1 && set OSR_AMD64FLAG=AMD64
endlocal & set OSR_AMD64FLAG=%OSR_AMD64FLAG%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectVistaWDK subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectBaseDirTemp subroutine
::   The first parameter is the list of directory names to check, separated by
::   blank spaces.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectBaseDirTemp
:: Get the name of the variable we are working with
if "%~1" == "" goto :EOF
setlocal ENABLEEXTENSIONS
call :CommonCheckMsg1
:: Try to find an installed DDK/WDK from the registry keys
if DEFINED OSR_REGAVAILABLE if not "%OSR_REGAVAILABLE%" == "0" (
  for %%i in (%~1) do @(
    call :RegTryBaseDirTemp "%%i"
  )
)
:: Try all the "default" locations
if not DEFINED BASEDIRTEMP (
  for %%i in (%~1) do @(
    for %%a in (WINDDK DDK) do @(
      call :BruteTryBaseDirTemp "%SystemDrive%\%%a\%%i"
      call :BruteTryBaseDirTemp "%ProgramFiles%\%%a\%%i"
    )
  )
)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTemp subroutine
::   Attempt to find the install key in the registry.
::   This functions tests old-style DDKs and new-style WDKs.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
call :RegTryBaseDirTempSingle "%~1" "LFNDirectory" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
call :RegTryBaseDirTempSingle "%~1\Setup" "BUILD" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
if not DEFINED BASEDIRTEMP (endlocal & goto :EOF)
:RegTryBaseDirTemp_EOF
%OSR_ECHO% Found directory (%BASEDIRTEMP%) from install key
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTempSingle subroutine
::   Attempt to find the install key in the registry.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTempSingle
setlocal ENABLEEXTENSIONS
set REGSUBKEY=%~1
set REGVALUE=%~2
set VARIABLETOSET=%~3
set REGMAINKEY=HKLM\SOFTWARE\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_WOW64
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_WOW64
set REGMAINKEY=HKLM\SOFTWARE\Wow6432Node\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_EOF
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_EOF
endlocal
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTempSingle subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / BruteTryBaseDirTemp subroutine
::   Brute-force test the given directory.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:BruteTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
:: We will not overwrite BASETEMPDIR if it has been set and is valid
:: Just try
set BASEDIRTEMP=%~1
%OSR_ECHO% Trying %BASEDIRTEMP% ...
if not exist "%BASEDIRTEMP%" (endlocal & goto :EOF)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ BruteTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Usage output
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:USAGE
@echo.
@echo USAGE:
@echo ======
@echo   %~n0 ^<target^> ^<build type^> ^<directory^> [flags] [-WDF] [-PREFAST]
@echo.
@echo Values for ^<target^>:
@echo    --------------------------------------------------------------------------
@echo     Target platform and OS   ^| Miscellaneous
@echo    --------------------------^|-----------------------------------------------
@echo     Target     ^| Windows     ^| CPU     ^| Base directory ^| Target alias(es)
@echo    ------------^|-------------^|---------^|----------------^|--------------------
@echo     -W2K       ^| 2000        ^| x86     ^| %%W2KBASE%%      ^|
@echo     -W2K64     ^| 2000        ^| Itanium ^| %%W2KBASE%%      ^| -W2KI64
@echo     -WXP       ^| XP          ^| x86     ^| %%WXPBASE%%      ^| -XP
@echo     -WXP64     ^| XP          ^| Itanium ^| %%WXPBASE%%      ^| -WXPI64, -XP64
@echo     -WXP2K     ^| 2000        ^| x86     ^| %%WXPBASE%%      ^| -XPW2K
@echo     -WNET      ^| 2003        ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNET64    ^| 2003        ^| Itanium ^| %%WNETBASE%%     ^| -WNETI64
@echo     -WNETXP    ^| XP          ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNETXP64  ^| XP          ^| Itanium ^| %%WNETBASE%%     ^|
@echo     -WNETAMD64 ^| 2003/XP x64 ^| x64     ^| %%WNETBASE%%     ^| -WNETX64, -WNETA64
@echo     -WNET2K    ^| 2000 SP3    ^| x86     ^| %%WNETBASE%%     ^| -WNETW2K
@echo     -WLH       ^| Vista/2008  ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLH2K     ^| 2000 SP4    ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP     ^| XP          ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP64   ^| XP          ^| Itanium ^| %%WLHBASE%%      ^|
@echo     -WLHNET    ^| 2003        ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHNETI64 ^| 2003        ^| Itanium ^| %%WLHBASE%%      ^| -WLHNET64
@echo     -WLHNETX64 ^| 2003/XP x64 ^| x64     ^| %%WLHBASE%%      ^| -WLHNETA64
@echo     -WLHI64    ^| Vista/2008  ^| Itanium ^| %%WLHBASE%%      ^| -WLH64
@echo     -WLHX64    ^| Vista/2008  ^| x64     ^| %%WLHBASE%%      ^| -WLHA64
@echo     -NT4       ^| NT 4.0      ^| x86     ^| %%NT4BASE%%      ^|
@echo    --------------------------------------------------------------------------
@echo     Support for NT4 and W2K DDKs is deprecated and not checked anymore
@echo     in new versions. It may or may not work properly.
@echo    --------------------------------------------------------------------------
@echo.
@echo Values for ^<build type^>:
@echo       checked, chk     indicates a checked build
@echo       free, fre        indicates a free build
@echo.
@echo Remaining parameters ("opt!" = optional parameter):
@echo       ^<directory^>      path to build directory, try . (current directory)
@echo       [flags]    opt!  any flags you think should be passed to build (try /a
@echo                        for clean)
@echo       -WDF       opt!  performs a WDF build
@echo       -PREFAST   opt!  performs a PREFAST build
@echo.
@echo Special files:
@echo       The build target directory (where the DIRS or SOURCES file resides) can
@echo       contain the following files:
@echo       - %OSR_PREBUILD_SCRIPT%
@echo         Allows to include a step before the BUILD tool from the DDK is called
@echo         but after the environment for the respective DDK has been set!
@echo       - %OSR_POSTBUILD_SCRIPT%
@echo         Allows to include a step after the BUILD tool from the DDK is called,
@echo         so the environment is still available to the script.
@echo       - %OSR_SETENV_SCRIPT%
@echo         Allows to set (or override) _any_ environment variables that may exist
@echo         in the global environment. Thus you can set the base directory for the
@echo         DDK from inside this script, making your project more self-contained.
@echo.
@echo       DDKBUILD will only handle those files which exist, so you may choose to
@echo       use none, one or multiple of these script files.
@echo       (All scripts execute inside their current directory. Consider this!)
@echo.
@echo Examples:
@echo       ^"%~n0 -NT4 checked .^" (for NT4 BUILD)
@echo       ^"%~n0 -WXP64 chk .^"
@echo       ^"%~n0 -WXP chk c:\projects\myproject^"
@echo       ^"%~n0 -WNET64 chk .^"      (IA64 build)
@echo       ^"%~n0 -WNETAMD64 chk .^"   (AMD64/EM64T build)
@echo       ^"%~n0 -WNETXP chk . -cZ -WDF^"
@echo       ^"%~n0 -WNETXP chk . -cZ -PREFAST^"
@echo.
@echo       In order for this procedure to work correctly for each platform, it
@echo       requires an environment variable to be set up for certain platforms.
@echo       There is an auto-detection mechanism in this script, which will work best
@echo       if the DDK/WDK was installed using the normal installer (i.e. not just
@echo       copied). The auto-detection is based on the DDK/WDK for which you request
@echo       a build. Whenever you set the variable explicitly, this will take
@echo       precedence over the auto-detected path!
@echo       The environment variables are as follows:
@echo.
@echo       %%NT4BASE%%  - Set this up for ^"-NT4^" builds
@echo       %%W2KBASE%%  - Set this up for ^"-W2K^" and ^"-W2K64^" builds
@echo       %%WXPBASE%%  - Set this up for ^"-WXP^", ^"-WXP64^", ^"-WXP2K^" builds
@echo       %%WNETBASE%% - Set this up for ^"-WNET*^" builds
@echo       %%WLHBASE%%  - Set this up for ^"-WLH*^" builds
@echo.
@echo       %%WDF_ROOT%% must be set if attempting to do a WDF Build previous to the
@echo       Vista WDK (in later DDKs there is no need to set WDF_ROOT).
@echo.
@echo Path to this script:
@echo      %~f0
@echo.
@echo   %OSR_VERSTR%
@echo   -^> report any problems to ^<info@osr.com^> or ^<http://assarbad.net/contact/^>
@echo.

:END
popd & endlocal & exit /b %OSR_ERRCODE%
```

`Register/RegisterManagerDrv/makefile`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

`Register/RegisterManagerDrv/mybuild.bat`:

```bat
set WLHBASE=C:\WINDDK\7600.16385.0
set WDF_ROOT=C:\WINDDK\7600.16385.0
ddkbuild.cmd -WLH chk . -cZ -WDF
```

`Register/RegisterManagerDrv/sources`:

```
TARGETNAME=RegisterManagerDrv
#TARGETPATH=$(BASEDIR)\lib
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=.\

SOURCES=RegisterManagerDrv.c


```

`Wow64Injectx64/ReadMe.md`:

```md
##Wow64进程注入x64进程
在Win7 Ultimate Sp1 测试成功
[http://www.cnblogs.com/lanrenxinxin/p/4821152.html](http://www.cnblogs.com/lanrenxinxin/p/4821152.html)
```

`Wow64Injectx64/Wow64Injectx64.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Wow64Injectx64", "Wow64Injectx64\Wow64Injectx64.vcxproj", "{D39AFEDB-19C8-4F2E-AAD2-8F25A75D581C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D39AFEDB-19C8-4F2E-AAD2-8F25A75D581C}.Debug|Win32.ActiveCfg = Debug|Win32
		{D39AFEDB-19C8-4F2E-AAD2-8F25A75D581C}.Debug|Win32.Build.0 = Debug|Win32
		{D39AFEDB-19C8-4F2E-AAD2-8F25A75D581C}.Release|Win32.ActiveCfg = Release|Win32
		{D39AFEDB-19C8-4F2E-AAD2-8F25A75D581C}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Wow64Injectx64/Wow64Injectx64/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Wow64Injectx64.rc
//

#define IDS_APP_TITLE			103

// 新对象的下一组默认值
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE	101
#define _APS_NEXT_COMMAND_VALUE		40001
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#endif
#endif

```

`Wow64Injectx64/Wow64Injectx64/Wow64Injectx64.cpp`:

```cpp
// Wow64Injectx64.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "Wow64Injectx64.h"
#include <memory>
#include <string>
#include <Windows.h>
#include "wow64ext.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#pragma comment(lib,"wow64ext.lib")

// 唯一的应用程序对象
CWinApp theApp;

using namespace std;

typedef struct _UNICODE_STRING {
	USHORT    Length;     //UNICODE占用的内存字节数，个数*2；
	USHORT	  MaximumLength; 
	DWORD64   Buffer;     //注意这里指针的问题
} UNICODE_STRING ,*PUNICODE_STRING;



unsigned char shell_code[] = {
	0x48, 0x89, 0x4c, 0x24, 0x08,                               // mov       qword ptr [rsp+8],rcx 
	0x57,                                                       // push      rdi
	0x48, 0x83, 0xec, 0x20,                                     // sub       rsp,20h
	0x48, 0x8b, 0xfc,                                           // mov       rdi,rsp
	0xb9, 0x08, 0x00, 0x00, 0x00,                               // mov       ecx,8
	0xb8, 0xcc, 0xcc, 0xcc, 0xcc,                               // mov       eac,0CCCCCCCCh
	0xf3, 0xab,                                                 // rep stos  dword ptr [rdi]
	0x48, 0x8b, 0x4c, 0x24, 0x30,                               // mov       rcx,qword ptr [__formal]
	0x49, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov       r9,0  //PVOID*  BaseAddr opt
	0x49, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov       r8,0  //PUNICODE_STRING Name
	0x48, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov       rdx,0
	0x48, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov       rcx,0
	0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov       rax,0 
	0xff, 0xd0,                                                 // call      rax   LdrLoadDll
	0x48, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov       rcx,0
	0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov       rax,0
	0xff, 0xd0                                                  // call      rax
};


enum  InjectResult{
	OK,
	Error_NoSuchFile,
	Error_OpenProcess,
	Error_VirtualAllocEx,
	Error_GetProcAddress,
	Error_WriteProcessMemory,
	Error_CreateRemoteThread
};


InjectResult Wow64Injectx64(DWORD processid,const TCHAR* file_path);

int _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
	cout<<"查看要注入进程的ID"<<endl;   
	ULONG_PTR ProcessID = 0;
	
	printf("Input ProcessID\r\n");
	cin>>ProcessID;
	WCHAR file_path[] = L"E:\\Messagebox.dll";

	
	if (OK==Wow64Injectx64(ProcessID,file_path))
	{
		printf("Inject Success!\n");
	}
	return 0;
}


InjectResult Wow64Injectx64(DWORD processid,const TCHAR* file_path)
{
	
	if (!PathFileExists(file_path))
	{
		return Error_NoSuchFile;
	}

	HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS,FALSE,processid);
	if (INVALID_HANDLE_VALUE == handle)
	{
		return Error_OpenProcess;
	}

	size_t file_path_mem_length = (size_t)::_tcslen(file_path);
	size_t paramemter_size = (file_path_mem_length+1)*sizeof(TCHAR) + sizeof(UNICODE_STRING) + sizeof(DWORD64);
	DWORD64 paramemter_mem_addr = (DWORD64)VirtualAllocEx64(handle,NULL,paramemter_size,MEM_COMMIT,PAGE_READWRITE);
	DWORD64  shell_code_addr = (DWORD64)VirtualAllocEx64(handle,NULL,sizeof(shell_code),MEM_COMMIT,PAGE_EXECUTE_READWRITE);
	if ((!paramemter_mem_addr) || (!shell_code_addr))
	{
		return Error_VirtualAllocEx;
	}
	
	char * paramemter_mem_local = new char[paramemter_size];
	memset(paramemter_mem_local,0,paramemter_size);

	PUNICODE_STRING ptr_unicode_string = (PUNICODE_STRING)(paramemter_mem_local + sizeof(DWORD64));
	ptr_unicode_string->Length = file_path_mem_length;
	ptr_unicode_string->MaximumLength = file_path_mem_length*2;
	wcscpy((WCHAR*)(ptr_unicode_string+1),file_path);
	ptr_unicode_string->Buffer = (DWORD64)((char*)paramemter_mem_addr+sizeof(DWORD64)+sizeof(UNICODE_STRING));

	DWORD64 ntdll64 = GetModuleHandle64(L"ntdll.dll");
	DWORD64 ntdll_LdrLoadDll = GetProcAddress64(ntdll64,"LdrLoadDll");
	DWORD64 ntdll_RtlCreateUserThread = GetProcAddress64(ntdll64,"RtlCreateUserThread");
	DWORD64 ntdll_RtlExitThread = GetProcAddress64(ntdll64,"RtlExitUserThread");
	if (NULL == ntdll_LdrLoadDll || NULL==ntdll_RtlCreateUserThread || NULL==ntdll_RtlExitThread)
	{
		return Error_GetProcAddress;
	}

	//r9
	memcpy(shell_code+32,&paramemter_mem_addr,sizeof(DWORD64));

	//r8
	DWORD64 ptr = paramemter_mem_addr+sizeof(DWORD64);
	memcpy(shell_code+42,&ptr,sizeof(PUNICODE_STRING));

	//LdrLoaddll
	memcpy(shell_code+72,&ntdll_LdrLoadDll,sizeof(DWORD64));

	//RtlExitUserThread
	memcpy(shell_code+94,&ntdll_RtlExitThread,sizeof(DWORD64));
	size_t write_size = 0;
	if (!WriteProcessMemory64(handle,paramemter_mem_addr,paramemter_mem_local,paramemter_size,NULL) ||
		!WriteProcessMemory64(handle,shell_code_addr,shell_code,sizeof(shell_code),NULL))
	{
		return Error_WriteProcessMemory;
	}
	DWORD64 hRemoteThread = 0;
	struct {
		DWORD64 UniqueProcess;
		DWORD64 UniqueThread;
	} client_id;
	int a = X64Call(ntdll_RtlCreateUserThread,10,
		(DWORD64)handle,					// ProcessHandle
		(DWORD64)NULL,                      // SecurityDescriptor
		(DWORD64)FALSE,                     // CreateSuspended
		(DWORD64)0,                         // StackZeroBits
		(DWORD64)NULL,                      // StackReserved
		(DWORD64)NULL,                      // StackCommit
		shell_code_addr,					// StartAddress
		(DWORD64)NULL,                      // StartParameter
		(DWORD64)&hRemoteThread,            // ThreadHandle
		(DWORD64)&client_id);               // ClientID)
	if (INVALID_HANDLE_VALUE == (HANDLE)hRemoteThread)
	{
		return Error_CreateRemoteThread;
	}
	return OK;
}
```

`Wow64Injectx64/Wow64Injectx64/Wow64Injectx64.h`:

```h
#pragma once

#include "resource.h"

```

`Wow64Injectx64/Wow64Injectx64/Wow64Injectx64.rc`:

```rc
//Microsoft Visual C++ 生成的资源脚本。
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 2 资源生成。
//
#include "afxres.h"
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2


#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// 字符串表
//

STRINGTABLE
BEGIN
   IDS_APP_TITLE       "Wow64Injectx64"
END

#endif
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 3 资源生成。
//
#ifndef _AFXDLL
#include "l.CHS\\afxres.rc"
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // 不是 APSTUDIO_INVOKED

```

`Wow64Injectx64/Wow64Injectx64/Wow64Injectx64.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D39AFEDB-19C8-4F2E-AAD2-8F25A75D581C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Wow64Injectx64</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="wow64ext.h" />
    <ClInclude Include="Wow64Injectx64.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Wow64Injectx64.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Wow64Injectx64.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Wow64Injectx64/Wow64Injectx64/Wow64Injectx64.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Wow64Injectx64.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="wow64ext.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Wow64Injectx64.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Wow64Injectx64.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Wow64Injectx64/Wow64Injectx64/Wow64Injectx64.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Wow64Injectx64/Wow64Injectx64/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// Wow64Injectx64.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中
// 引用任何所需的附加头文件，而不是在此文件中引用

```

`Wow64Injectx64/Wow64Injectx64/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>
#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            //  从 Windows 头文件中排除极少使用的信息
#endif

#include <afx.h>
#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展
#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>                     // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>



// TODO: 在此处引用程序需要的其他头文件

```

`Wow64Injectx64/Wow64Injectx64/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`Wow64Injectx64/Wow64Injectx64/wow64ext.h`:

```h
/**
 *
 * WOW64Ext Library
 *
 * Copyright (c) 2014 ReWolf
 * http://blog.rewolf.pl/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
#pragma once

#include <windows.h>

#ifndef STATUS_SUCCESS
#   define STATUS_SUCCESS 0
#endif

#pragma pack(push)
#pragma pack(1)
template <class T>
struct _LIST_ENTRY_T
{
    T Flink;
    T Blink;
};

template <class T>
struct _UNICODE_STRING_T
{
    union
    {
        struct
        {
            WORD Length;
            WORD MaximumLength;
        };
        T dummy;
    };
    T Buffer;
};

template <class T>
struct _NT_TIB_T
{
    T ExceptionList;
    T StackBase;
    T StackLimit;
    T SubSystemTib;
    T FiberData;
    T ArbitraryUserPointer;
    T Self;
};

template <class T>
struct _CLIENT_ID
{
    T UniqueProcess;
    T UniqueThread;
};

template <class T>
struct _TEB_T_
{
    _NT_TIB_T<T> NtTib;
    T EnvironmentPointer;
    _CLIENT_ID<T> ClientId;
    T ActiveRpcHandle;
    T ThreadLocalStoragePointer;
    T ProcessEnvironmentBlock;
    DWORD LastErrorValue;
    DWORD CountOfOwnedCriticalSections;
    T CsrClientThread;
    T Win32ThreadInfo;
    DWORD User32Reserved[26];
    //rest of the structure is not defined for now, as it is not needed
};

template <class T>
struct _LDR_DATA_TABLE_ENTRY_T
{
    _LIST_ENTRY_T<T> InLoadOrderLinks;
    _LIST_ENTRY_T<T> InMemoryOrderLinks;
    _LIST_ENTRY_T<T> InInitializationOrderLinks;
    T DllBase;
    T EntryPoint;
    union
    {
        DWORD SizeOfImage;
        T dummy01;
    };
    _UNICODE_STRING_T<T> FullDllName;
    _UNICODE_STRING_T<T> BaseDllName;
    DWORD Flags;
    WORD LoadCount;
    WORD TlsIndex;
    union
    {
        _LIST_ENTRY_T<T> HashLinks;
        struct 
        {
            T SectionPointer;
            T CheckSum;
        };
    };
    union
    {
        T LoadedImports;
        DWORD TimeDateStamp;
    };
    T EntryPointActivationContext;
    T PatchInformation;
    _LIST_ENTRY_T<T> ForwarderLinks;
    _LIST_ENTRY_T<T> ServiceTagLinks;
    _LIST_ENTRY_T<T> StaticLinks;
    T ContextInformation;
    T OriginalBase;
    _LARGE_INTEGER LoadTime;
};

template <class T>
struct _PEB_LDR_DATA_T
{
    DWORD Length;
    DWORD Initialized;
    T SsHandle;
    _LIST_ENTRY_T<T> InLoadOrderModuleList;
    _LIST_ENTRY_T<T> InMemoryOrderModuleList;
    _LIST_ENTRY_T<T> InInitializationOrderModuleList;
    T EntryInProgress;
    DWORD ShutdownInProgress;
    T ShutdownThreadId;

};

template <class T, class NGF, int A>
struct _PEB_T
{
    union
    {
        struct
        {
            BYTE InheritedAddressSpace;
            BYTE ReadImageFileExecOptions;
            BYTE BeingDebugged;
            BYTE BitField;
        };
        T dummy01;
    };
    T Mutant;
    T ImageBaseAddress;
    T Ldr;
    T ProcessParameters;
    T SubSystemData;
    T ProcessHeap;
    T FastPebLock;
    T AtlThunkSListPtr;
    T IFEOKey;
    T CrossProcessFlags;
    T UserSharedInfoPtr;
    DWORD SystemReserved;
    DWORD AtlThunkSListPtr32;
    T ApiSetMap;
    T TlsExpansionCounter;
    T TlsBitmap;
    DWORD TlsBitmapBits[2];
    T ReadOnlySharedMemoryBase;
    T HotpatchInformation;
    T ReadOnlyStaticServerData;
    T AnsiCodePageData;
    T OemCodePageData;
    T UnicodeCaseTableData;
    DWORD NumberOfProcessors;
    union
    {
        DWORD NtGlobalFlag;
        NGF dummy02;
    };
    LARGE_INTEGER CriticalSectionTimeout;
    T HeapSegmentReserve;
    T HeapSegmentCommit;
    T HeapDeCommitTotalFreeThreshold;
    T HeapDeCommitFreeBlockThreshold;
    DWORD NumberOfHeaps;
    DWORD MaximumNumberOfHeaps;
    T ProcessHeaps;
    T GdiSharedHandleTable;
    T ProcessStarterHelper;
    T GdiDCAttributeList;
    T LoaderLock;
    DWORD OSMajorVersion;
    DWORD OSMinorVersion;
    WORD OSBuildNumber;
    WORD OSCSDVersion;
    DWORD OSPlatformId;
    DWORD ImageSubsystem;
    DWORD ImageSubsystemMajorVersion;
    T ImageSubsystemMinorVersion;
    T ActiveProcessAffinityMask;
    T GdiHandleBuffer[A];
    T PostProcessInitRoutine; 
    T TlsExpansionBitmap; 
    DWORD TlsExpansionBitmapBits[32];
    T SessionId;
    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    T pShimData;
    T AppCompatInfo;
    _UNICODE_STRING_T<T> CSDVersion;
    T ActivationContextData;
    T ProcessAssemblyStorageMap;
    T SystemDefaultActivationContextData;
    T SystemAssemblyStorageMap;
    T MinimumStackCommit;
    T FlsCallback;
    _LIST_ENTRY_T<T> FlsListHead;
    T FlsBitmap;
    DWORD FlsBitmapBits[4];
    T FlsHighIndex;
    T WerRegistrationData;
    T WerShipAssertPtr;
    T pContextData;
    T pImageHeaderHash;
    T TracingFlags;
};

typedef _LDR_DATA_TABLE_ENTRY_T<DWORD> LDR_DATA_TABLE_ENTRY32;
typedef _LDR_DATA_TABLE_ENTRY_T<DWORD64> LDR_DATA_TABLE_ENTRY64;

typedef _TEB_T_<DWORD> TEB32;
typedef _TEB_T_<DWORD64> TEB64;

typedef _PEB_LDR_DATA_T<DWORD> PEB_LDR_DATA32;
typedef _PEB_LDR_DATA_T<DWORD64> PEB_LDR_DATA64;

typedef _PEB_T<DWORD, DWORD64, 34> PEB32;
typedef _PEB_T<DWORD64, DWORD, 30> PEB64;

struct _XSAVE_FORMAT64
{
    WORD ControlWord;
    WORD StatusWord;
    BYTE TagWord;
    BYTE Reserved1;
    WORD ErrorOpcode;
    DWORD ErrorOffset;
    WORD ErrorSelector;
    WORD Reserved2;
    DWORD DataOffset;
    WORD DataSelector;
    WORD Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    _M128A FloatRegisters[8];
    _M128A XmmRegisters[16];
    BYTE Reserved4[96];
};

struct _CONTEXT64
{
    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;
    DWORD ContextFlags;
    DWORD MxCsr;
    WORD SegCs;
    WORD SegDs;
    WORD SegEs;
    WORD SegFs;
    WORD SegGs;
    WORD SegSs;
    DWORD EFlags;
    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;
    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;
    DWORD64 Rip;
    _XSAVE_FORMAT64 FltSave;
    _M128A Header[2];
    _M128A Legacy[8];
    _M128A Xmm0;
    _M128A Xmm1;
    _M128A Xmm2;
    _M128A Xmm3;
    _M128A Xmm4;
    _M128A Xmm5;
    _M128A Xmm6;
    _M128A Xmm7;
    _M128A Xmm8;
    _M128A Xmm9;
    _M128A Xmm10;
    _M128A Xmm11;
    _M128A Xmm12;
    _M128A Xmm13;
    _M128A Xmm14;
    _M128A Xmm15;
    _M128A VectorRegister[26];
    DWORD64 VectorControl;
    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
};

// Below defines for .ContextFlags field are taken from WinNT.h
#ifndef CONTEXT_AMD64
#define CONTEXT_AMD64 0x100000
#endif

#define CONTEXT64_CONTROL (CONTEXT_AMD64 | 0x1L)
#define CONTEXT64_INTEGER (CONTEXT_AMD64 | 0x2L)
#define CONTEXT64_SEGMENTS (CONTEXT_AMD64 | 0x4L)
#define CONTEXT64_FLOATING_POINT  (CONTEXT_AMD64 | 0x8L)
#define CONTEXT64_DEBUG_REGISTERS (CONTEXT_AMD64 | 0x10L)
#define CONTEXT64_FULL (CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_FLOATING_POINT)
#define CONTEXT64_ALL (CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_SEGMENTS | CONTEXT64_FLOATING_POINT | CONTEXT64_DEBUG_REGISTERS)
#define CONTEXT64_XSTATE (CONTEXT_AMD64 | 0x20L)

#pragma pack(pop)

#ifdef WOW64EXT_EXPORTS
#   define SPEC dllexport
#else
#   define SPEC dllimport
#endif

extern "C"
{
	__declspec(SPEC)DWORD64 __cdecl X64Call(DWORD64 func, int argC, ...);
	__declspec(SPEC)DWORD64 __cdecl GetModuleHandle64(wchar_t* lpModuleName);
	__declspec(SPEC)DWORD64 __cdecl GetProcAddress64(DWORD64 hModule, char* funcName);
	__declspec(SPEC)SIZE_T __cdecl VirtualQueryEx64(HANDLE hProcess, DWORD64 lpAddress, MEMORY_BASIC_INFORMATION64* lpBuffer, SIZE_T dwLength);
	__declspec(SPEC)DWORD64 __cdecl VirtualAllocEx64(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
	__declspec(SPEC)BOOL __cdecl VirtualFreeEx64(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD dwFreeType);
	__declspec(SPEC)BOOL __cdecl VirtualProtectEx64(HANDLE hProcess, DWORD64 lpAddress, SIZE_T dwSize, DWORD flNewProtect, DWORD* lpflOldProtect);
	__declspec(SPEC)BOOL __cdecl ReadProcessMemory64(HANDLE hProcess, DWORD64 lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
	__declspec(SPEC)BOOL __cdecl WriteProcessMemory64(HANDLE hProcess, DWORD64 lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
	__declspec(SPEC)BOOL __cdecl GetThreadContext64(HANDLE hThread, _CONTEXT64* lpContext);
	__declspec(SPEC)BOOL __cdecl SetThreadContext64(HANDLE hThread, _CONTEXT64* lpContext);
	__declspec(SPEC)VOID __cdecl SetLastErrorFromX64Call(DWORD64 status);
}

```

`arkProject/HeavenShadow/HeavenShadow.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HeavenShadow", "HeavenShadow\HeavenShadow.vcxproj", "{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "injectdll64", "injectdll64\injectdll64.vcxproj", "{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "injectdll32", "injectdll32\injectdll32.vcxproj", "{53E8A28F-7458-42B6-9AFA-200CBCC48221}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Debug|Win32.ActiveCfg = Debug|Win32
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Debug|Win32.Build.0 = Debug|Win32
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Debug|x64.ActiveCfg = Debug|x64
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Debug|x64.Build.0 = Debug|x64
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Release|Win32.ActiveCfg = Release|Win32
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Release|Win32.Build.0 = Release|Win32
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Release|x64.ActiveCfg = Release|x64
		{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}.Release|x64.Build.0 = Release|x64
		{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}.Debug|Win32.ActiveCfg = Debug|x64
		{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}.Debug|Win32.Build.0 = Debug|x64
		{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}.Debug|x64.ActiveCfg = Debug|x64
		{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}.Debug|x64.Build.0 = Debug|x64
		{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}.Release|Win32.ActiveCfg = Release|Win32
		{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}.Release|Win32.Build.0 = Release|Win32
		{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}.Release|x64.ActiveCfg = Release|Win32
		{53E8A28F-7458-42B6-9AFA-200CBCC48221}.Debug|Win32.ActiveCfg = Debug|Win32
		{53E8A28F-7458-42B6-9AFA-200CBCC48221}.Debug|Win32.Build.0 = Debug|Win32
		{53E8A28F-7458-42B6-9AFA-200CBCC48221}.Debug|x64.ActiveCfg = Debug|Win32
		{53E8A28F-7458-42B6-9AFA-200CBCC48221}.Debug|x64.Build.0 = Debug|Win32
		{53E8A28F-7458-42B6-9AFA-200CBCC48221}.Release|Win32.ActiveCfg = Release|Win32
		{53E8A28F-7458-42B6-9AFA-200CBCC48221}.Release|Win32.Build.0 = Release|Win32
		{53E8A28F-7458-42B6-9AFA-200CBCC48221}.Release|x64.ActiveCfg = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`arkProject/HeavenShadow/HeavenShadow/AlertWnd.cpp`:

```cpp
// AlertWnd.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "AlertWnd.h"
#include "afxdialogex.h"


#include <Mmsystem.h>


// CAlertWnd 对话框

IMPLEMENT_DYNAMIC(CAlertWnd, CDialog)

CAlertWnd::CAlertWnd(CWnd* pParent /*=NULL*/)
	: CDialog(CAlertWnd::IDD, pParent)
{
	m_ulCount = 20;
	m_TimerTip = _T("");
}

CAlertWnd::~CAlertWnd()
{
}

void CAlertWnd::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_STATIC_TIMERTIP, m_TimerTip);
	DDX_Control(pDX, IDC_STATIC_BTN_ALLOW, m_btnAllow);
	DDX_Control(pDX, IDC_STATIC_BTN_PREVENT, m_btnPrevent);
	DDX_Control(pDX, IDC_STATIC_TIMERTIP, m_TextTimer);
	DDX_Control(pDX, IDC_STATIC_ALERT_CONTEXT, m_TextContext);
	DDX_Control(pDX, IDC_STATIC_ALERT_TITLE, m_TextTitle);
}


BEGIN_MESSAGE_MAP(CAlertWnd, CDialog)
	ON_WM_CLOSE()
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
	ON_WM_CTLCOLOR()
//	ON_STN_CLICKED(IDC_STATIC_ALERTBTNEXIT, &CAlertWnd::OnStnClickedStaticAlertbtnexit)
	ON_WM_TIMER()
	ON_STN_CLICKED(IDC_STATIC_BTN_PREVENT, &CAlertWnd::OnStnClickedStaticBtnPrevent)
	ON_STN_CLICKED(IDC_STATIC_BTN_ALLOW, &CAlertWnd::OnStnClickedStaticBtnAllow)
	ON_WM_SYSCOMMAND()
	ON_WM_SIZE()
END_MESSAGE_MAP()


// CAlertWnd 消息处理程序






BOOL CAlertWnd::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	ModifyStyleEx(WS_EX_APPWINDOW,WS_EX_TOOLWINDOW);//设置扩展工具窗模式。阻止任务栏显示图标

	m_ulCount = 20;

	m_TimerTip.Format(L"将执行阻止操作： %2d 秒     ",m_ulCount);

	UpdateData(FALSE);

	//获得桌面大小
	CRect rectWorkArea;
	SystemParametersInfoW(SPI_GETWORKAREA,0,&rectWorkArea,SPIF_SENDCHANGE);

	//获得对话框大小
	CRect rectDlg;
	GetWindowRect(&rectDlg);
	int nW = rectDlg.Width();
	int nH = rectDlg.Height();

	//将窗口设置到右下脚
	::SetWindowPos(this->m_hWnd,HWND_BOTTOM,
		rectWorkArea.right-nW-6,rectWorkArea.bottom-nH,
		nW,nH,
		SWP_NOZORDER);

	//动画显示
	//AnimateWindow(150,AW_CENTER|AW_ACTIVATE|AW_VER_NEGATIVE);
	//AnimateWindow(200,AW_SLIDE|AW_ACTIVATE|AW_VER_NEGATIVE);//
	//AnimateWindow(150,AW_BLEND|AW_ACTIVATE|AW_VER_NEGATIVE);

	


	CloseHandle(CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsPlayAlertSound,NULL, 0,NULL));


	SetTimer(3333,1000,NULL);





	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


BOOL CAlertWnd::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类

	if(pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}

	return CDialog::PreTranslateMessage(pMsg);
}


void CAlertWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()

	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(0,116,179));
}


void CAlertWnd::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	if (bShow == TRUE)
	{
	}
}

void CAlertWnd::OnClose()
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	//动画显示
	//AnimateWindow(150,AW_CENTER|AW_HIDE|AW_VER_POSITIVE);
	//AnimateWindow(200,AW_SLIDE|AW_HIDE|AW_VER_POSITIVE);//AW_SLIDE|
	//AnimateWindow(150,AW_BLEND|AW_HIDE|AW_VER_POSITIVE);

	CDialog::OnClose();
}


HBRUSH CAlertWnd::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

	// TODO:  在此更改 DC 的任何特性

	if ( nCtlColor == CTLCOLOR_BTN)
	{
		pDC->SetBkMode(TRANSPARENT);
		return (HBRUSH)::GetStockObject(NULL_BRUSH);

	}

// 	if ( nCtlColor == CTLCOLOR_STATIC|| nCtlColor == CTLCOLOR_BTN|| nCtlColor == CTLCOLOR_MAX )
// 	{
// 		//pDC->SetBkColor(RGB(232,80,80));
// 
// 		pDC->SetBkMode(TRANSPARENT);
// 
// 		pDC->SetTextColor(RGB(255,255,255));
// 
// 		// TODO:  如果默认的不是所需画笔，则返回另一个画笔
// 		return (HBRUSH)::GetStockObject(NULL_BRUSH);
// 	}

	return hbr;
}


void CAlertWnd::OnOK()
{
	// TODO: 在此添加专用代码和/或调用基类

	CDialog::OnOK();
}


void CAlertWnd::OnCancel()
{
	// TODO: 在此添加专用代码和/或调用基类

	CDialog::OnCancel();
}


//void CAlertWnd::OnStnClickedStaticAlertbtnexit()
//{
//	// TODO: 在此添加控件通知处理程序代码
//	SendMessage(WM_CLOSE);
//}


void CAlertWnd::OnTimer(UINT_PTR nIDEvent)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	switch(nIDEvent)
	{
	case 3333:
		{
			if (m_ulCount == 0)
			{
				KillTimer(3333);
				SendMessage(WM_CLOSE);
			}
			m_ulCount--;

			
			m_TimerTip.Format(L"将执行阻止操作： %2d 秒",m_ulCount);

			UpdateData(FALSE);

			SendMessage(WM_PAINT);
		}
	}

	CDialog::OnTimer(nIDEvent);
}


void HsPlayAlertSound(void)
{
	::PlaySoundW(MAKEINTRESOURCE(IDR_WAVE_SYSTEM_ALERT), ::GetModuleHandle(NULL), SND_RESOURCE | SND_SYNC);

}


void CAlertWnd::OnStnClickedStaticBtnPrevent()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_BTN_PREVENT_C),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_BTN_PREVENT_C));

	m_btnPrevent.SetBitmap(hBmp);

	Sleep(100);

	SendMessage(WM_CLOSE);
}


void CAlertWnd::OnStnClickedStaticBtnAllow()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_BTN_ALLOW_C),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_BTN_ALLOW_C));

	m_btnAllow.SetBitmap(hBmp);

	Sleep(100);

	SendMessage(WM_CLOSE);
}


void CAlertWnd::OnSysCommand(UINT nID, LPARAM lParam)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	CDialog::OnSysCommand(nID, lParam);
}


void CAlertWnd::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	// TODO: 在此处添加消息处理程序代码

	if (SIZE_MINIMIZED==nType)
	{
		ShowWindow(TRUE);
	}
}

```

`arkProject/HeavenShadow/HeavenShadow/AlertWnd.h`:

```h
#pragma once

#include "MyPicButton.h"

#include "MyText.h"
#include "afxwin.h"

// CAlertWnd 对话框

class CAlertWnd : public CDialog
{
	DECLARE_DYNAMIC(CAlertWnd)

public:
	CAlertWnd(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CAlertWnd();

// 对话框数据
	enum { IDD = IDD_DIALOG_ALERT };

	ULONG m_ulCount;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnClose();
	virtual BOOL OnInitDialog();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnPaint();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	virtual void OnOK();
	virtual void OnCancel();
//	afx_msg void OnStnClickedStaticAlertbtnexit();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	CString m_TimerTip;
	afx_msg void OnStnClickedStaticBtnPrevent();
	afx_msg void OnStnClickedStaticBtnAllow();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	CMyPicButton m_btnAllow;
	CMyPicButton m_btnPrevent;
	CMyText m_TextTimer;
	CMyText m_TextContext;
	CMyText m_TextTitle;
};


void HsPlayAlertSound(void);
```

`arkProject/HeavenShadow/HeavenShadow/ButtonNotify.cpp`:

```cpp
#include "stdafx.h"
#include "HeavenShadow.h"
#include "HeavenShadowDlg.h"
#include "afxdialogex.h"


extern BOOL bIsChecking;
extern BOOL bDriverIsOK;

//////////////////////////////////////////////////////////////////////////

void CHeavenShadowDlg::OnClickedStaticProcess()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_PROCESS);
	}
}
void CHeavenShadowDlg::OnClickedStaticModule()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_MODULE);
	}
}




void CHeavenShadowDlg::OnClickedStaticService()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_SERVICE);
	}
}





void CHeavenShadowDlg::OnEnableStaticProcess()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns_proc = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_PROCESS),RT_GROUP_ICON);

	HBITMAP   hBmp_proc = ::LoadBitmap(hIns_proc, MAKEINTRESOURCE(IDB_BITMAP_PROCESS));

	m_btnProc.SetBitmap(hBmp_proc);
}


void CHeavenShadowDlg::OnDisableStaticProcess()
{
	// TODO: 在此添加控件通知处理程序代码
	//加载位图
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_PROCESS_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_PROCESS_NOW));

	m_btnProc.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnEnableStaticModule()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_MODULE),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_MODULE));

	m_btnModu.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticModule()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_MODULE_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_MODULE_NOW));

	m_btnModu.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnEnableStaticService()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_SERVICE),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_SERVICE));

	m_btnServ.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticService()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_SERVICE_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_SERVICE_NOW));

	m_btnServ.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnClickedStaticLogo()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_ABOUT);
	}

}

void CHeavenShadowDlg::OnEnableStaticLogo()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_LOGOBAR),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_LOGOBAR));

	m_btnAbou.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticLogo()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_LOGOBAR_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_LOGOBAR_NOW));

	m_btnAbou.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnClickedStaticFile()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_FILE);
	}
}





void CHeavenShadowDlg::OnEnableStaticFile()
{
	// TODO: 在此添加控件通知处理程序代码

	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_FILE),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_FILE));

	m_btnFile.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticFile()
{
	// TODO: 在此添加控件通知处理程序代码

	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_FILE_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_FILE_NOW));

	m_btnFile.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnClickedStaticSystem()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_SYSTEM);
	}
}


void CHeavenShadowDlg::OnEnableStaticSystem()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_SYSTEM),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_SYSTEM));

	m_btnSys.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticSystem()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_SYSTEM_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_SYSTEM_NOW));

	m_btnSys.SetBitmap(hBmp);
}



void CHeavenShadowDlg::OnClickedStaticSetting()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_SETTING);
	}
}


void CHeavenShadowDlg::OnEnableStaticSetting()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_SETTING),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_SETTING));

	m_btnSet.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticSetting()
{
	// TODO: 在此添加控件通知处理程序代码

	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_SETTING_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_SETTING_NOW));

	m_btnSet.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnClickedStaticTools()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_TOOLS);
	}
}


void CHeavenShadowDlg::OnEnableStaticTools()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_TOOLS),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_TOOLS));

	m_btnTool.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticTools()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_TOOLS_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_TOOLS_NOW));

	m_btnTool.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnClickedStaticKernel()
{
	// TODO: 在此添加控件通知处理程序代码
	if (!bIsChecking && bDriverIsOK)
	{
		HsEnableNowButton();
		HsSelectWindow(HS_DIALOG_KERNEL);
	}
}


void CHeavenShadowDlg::OnEnableStaticKernel()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_KERNEL),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_KERNEL));

	m_btnKrnl.SetBitmap(hBmp);
}


void CHeavenShadowDlg::OnDisableStaticKernel()
{
	// TODO: 在此添加控件通知处理程序代码
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_KERNEL_NOW),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_KERNEL_NOW));

	m_btnKrnl.SetBitmap(hBmp);
}
```

`arkProject/HeavenShadow/HeavenShadow/CallbackFunc.cpp`:

```cpp
#include "stdafx.h"
#include "CallbackFunc.h"
#include "ModuleFunc.h"
#include "SSDTFunc.h"
#include "ProcessFunc.h"
#include "Common.h"
#include <vector>

using namespace std;

extern HANDLE g_hDevice;
extern WIN_VERSION WinVersion;
extern BOOL bIsChecking;

ULONG_PTR m_ulAllNotify = 0;
extern vector<DRIVER_INFO> m_DriverList;
vector<CALLBACK_INFO> m_CallbackVector;

COLUMNSTRUCT g_Column_CallBack[] = 
{
	{	L"回调地址",				125	},
	{	L"回调类型",				125	},
	{	L"模块文件",				225	},
	{	L"出品厂商",				125	},
	{	L"描述",					125	},
};

UINT g_Column_CallBack_Count = 5;


extern int dpix;
extern int dpiy;


ULONG_PTR m_ulNotifyLoadImage = 0;
ULONG_PTR m_ulNotifyCmpCallback = 0;
ULONG_PTR m_ulNotifyCreateProcess = 0;
ULONG_PTR m_ulNotifyCreateThread = 0;
ULONG_PTR m_ulNotifyShutdown = 0;
ULONG_PTR m_ulNotifyCheckReason = 0;
ULONG_PTR m_ulNotifyCheck = 0;



VOID HsInitCallBackList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_CallBack_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_CallBack[i].szTitle,LVCFMT_LEFT,(int)(g_Column_CallBack[i].nWidth*(dpix/96.0)));
	}
}



VOID HsLoadCallBackList(CListCtrl *m_ListCtrl)
{
	if (bIsChecking == TRUE)
	{
		return;
	}

	// 	while(bIsChecking == TRUE)
	// 	{
	// 		Sleep(10);
	// 	}

	bIsChecking = TRUE;

	HsSendStatusDetail(L"系统回调正在加载...");
	HsSendStatusTip(L"系统回调");

	HsQueryCallBackList(m_ListCtrl);

	bIsChecking = FALSE;
}



VOID HsQueryCallBackList(CListCtrl *m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();
	m_CallbackVector.clear();

	EnumDriver();

	if (HsQueryCallBackList() == FALSE)
	{
		HsSendStatusDetail(L"系统回调加载失败。");
		return;
	}

	HsInsertCallbackItem(m_ListCtrl);
}

BOOL HsQueryCallBackList()
{
	ULONG_PTR ulCnt = 100;
	PGET_CALLBACK CallbackInfor = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	do 
	{
		ULONG_PTR ulSize = sizeof(GET_CALLBACK) + ulCnt * sizeof(CALLBACK_INFO);

		if (CallbackInfor)
		{
			free(CallbackInfor);
			CallbackInfor = NULL;
		}

		CallbackInfor = (PGET_CALLBACK)malloc(ulSize);

		if (CallbackInfor)
		{
			memset(CallbackInfor, 0, ulSize);
			CallbackInfor->ulCnt = ulCnt;

			BOOL NotifyType = NotifyLoadImage;

			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_CALLBACKLIST),
				&NotifyType,
				sizeof(BOOL),
				CallbackInfor,
				(DWORD)ulSize,
				&ulReturnSize,
				NULL);
		}

		ulCnt =CallbackInfor->ulCnt + 10;

	} while (!bRet && CallbackInfor->ulRetCnt > CallbackInfor->ulCnt);

	if (bRet &&
		CallbackInfor->ulCnt >= CallbackInfor->ulRetCnt)
	{
		for (ULONG i = 0; i < CallbackInfor->ulRetCnt; i++)
		{
			m_CallbackVector.push_back(CallbackInfor->Callbacks[i]);
		}
	}

	if (CallbackInfor)
	{
		free(CallbackInfor);
		CallbackInfor = NULL;
	}

	return bRet;
}




VOID HsInsertCallbackItem(CListCtrl* m_ListCtrl)
{
	m_ulNotifyLoadImage = 0;
	m_ulNotifyCmpCallback = 0;
	m_ulNotifyCreateProcess = 0;
	m_ulNotifyCreateThread = 0;
	m_ulNotifyShutdown = 0;
	m_ulNotifyCheckReason = 0;
	m_ulNotifyCheck = 0;

	m_ulAllNotify = 0;

	for (vector<CALLBACK_INFO>::iterator itor = m_CallbackVector.begin(); itor != m_CallbackVector.end(); itor++)
	{
		CString strCallbackAddress, strType, strPath, strComp, strNote;

		strCallbackAddress.Format(L"0x%p", itor->CallbackAddress);
		int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strCallbackAddress);


		strNote.Format(L"0x%p", itor->Note);


		switch (itor->Type)
		{
		case NotifyLoadImage:
			{
				strType = L"LoadImage";

				m_ulNotifyLoadImage++;
				break;
			}
		case NotifyCmCallBack:
			{
				strType = L"CmpCallBack";

				m_ulNotifyCmpCallback++;
				break;
			}
		case NotifyCreateProcess:
			{
				strType = L"CreateProcess";

				m_ulNotifyCreateProcess++;
				break;
			}
		case NotifyCreateThread:
			{
				strType = L"CreateThread";

				m_ulNotifyCreateThread++;
				break;
			}
		case NotifyShutdown:
			{
				strType = L"Shutdown";

				m_ulNotifyShutdown++;
				break;
			}
		case NotifyKeBugCheckReason:
			{
				strType = L"BugCheckReason";

				m_ulNotifyCheckReason++;
				break;
			}
		case NotifyKeBugCheck:
			{
				strType = L"BugCheck";

				m_ulNotifyCheck++;
				break;
			}
		default:
			{
				break;
			}
		}
		m_ulAllNotify++;



		strPath = GetDriverPath(itor->CallbackAddress);
		strComp = HsGetFileCompanyName(strPath);

		m_ListCtrl->SetItemText(n, 1, strType);
		m_ListCtrl->SetItemText(n, 2, strPath);
		m_ListCtrl->SetItemText(n, 3, strComp);
		m_ListCtrl->SetItemText(n, 4, strNote);


		CString StatusBarContext;
		StatusBarContext.Format(
			L"系统回调正在加载。 驱动加载：%d，注册表：%d，进程创建：%d，线程创建：%d，关机：%d，其他：%d",
			m_ulNotifyLoadImage,
			m_ulNotifyCmpCallback,
			m_ulNotifyCreateProcess,
			m_ulNotifyCreateThread,
			m_ulNotifyShutdown,
			m_ulNotifyCheckReason+m_ulNotifyCheck);

		HsSendStatusDetail(StatusBarContext);

	}

	CString StatusBarContext;
	StatusBarContext.Format(
		L"系统回调加载完成。 驱动加载：%d，注册表：%d，进程创建：%d，线程创建：%d，关机：%d，其他：%d",
		m_ulNotifyLoadImage,
		m_ulNotifyCmpCallback,
		m_ulNotifyCreateProcess,
		m_ulNotifyCreateThread,
		m_ulNotifyShutdown,
		m_ulNotifyCheckReason+m_ulNotifyCheck);

	HsSendStatusDetail(StatusBarContext);

}


VOID HsRemoveCallBackItem(CListCtrl* m_ListCtrl)
{
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;
	int Index = m_ListCtrl->GetSelectionMark();

	if (Index<0)
	{
		return;
	}


	CString Temp = m_ListCtrl->GetItemText(Index,0);

	REMOVE_CALLBACK  RemoveCallBack;

	for ( vector <CALLBACK_INFO>::iterator Iter = m_CallbackVector.begin( ); Iter != m_CallbackVector.end( ); Iter++ )
	{
		CString strCallback;
		strCallback.Format(L"0x%p", Iter->CallbackAddress);
		if (!strCallback.CompareNoCase(Temp))
		{

			RemoveCallBack.CallbackAddress = Iter->CallbackAddress;
			RemoveCallBack.Note = Iter->Note;
			RemoveCallBack.NotifyType = Iter->Type;

			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_REMOVECALLBACK),
				&RemoveCallBack,
				sizeof(REMOVE_CALLBACK),
				NULL,
				0,
				&ulReturnSize,
				NULL);


			break;
		}	
	}

	if (bRet)
	{
		m_ulNotifyLoadImage--;
		m_ulAllNotify--;
		m_ListCtrl->DeleteItem(Index);

		CString StatusBarContext;
		StatusBarContext.Format(
			L"系统回调加载完成。 驱动加载：%d，注册表：%d，进程创建：%d，线程创建：%d，关机：%d，其他：%d",
			m_ulNotifyLoadImage,
			m_ulNotifyCmpCallback,
			m_ulNotifyCreateProcess,
			m_ulNotifyCreateThread,
			m_ulNotifyShutdown,
			m_ulNotifyCheckReason+m_ulNotifyCheck);

		HsSendStatusDetail(StatusBarContext);
	}
	

	bIsChecking = FALSE;
}
```

`arkProject/HeavenShadow/HeavenShadow/CallbackFunc.h`:

```h
#pragma once
#include "stdafx.h"

typedef enum _CALLBACK_TYPE_
{
	NotifyCreateProcess,
	NotifyCreateThread,
	NotifyLoadImage,
	NotifyShutdown,
	NotifyCmCallBack,
	NotifyKeBugCheckReason,
	NotifyKeBugCheck
}CALLBACK_TYPE;

typedef struct _CALLBACK_INFO_
{
	CALLBACK_TYPE Type;
	ULONG_PTR     CallbackAddress;
	ULONG_PTR     Note;
}CALLBACK_INFO, *PCALLBACK_INFO;

typedef struct _GET_CALLBACK_
{
	ULONG_PTR ulCnt;
	ULONG_PTR ulRetCnt;
	CALLBACK_INFO Callbacks[1];
}GET_CALLBACK, *PGET_CALLBACK;

typedef struct _REMOVE_CALLBACK
{
	CALLBACK_TYPE NotifyType;
	ULONG_PTR     CallbackAddress;
	ULONG_PTR     Note;
}REMOVE_CALLBACK,*PREMOVE_CALLBACK;



VOID HsInitCallBackList(CListCtrl *m_ListCtrl);

VOID HsLoadCallBackList(CListCtrl *m_ListCtrl);

VOID HsQueryCallBackList(CListCtrl *m_ListCtrl);

BOOL HsQueryCallBackList();

VOID HsInsertCallbackItem(CListCtrl* m_ListCtrl);

VOID HsRemoveCallBackItem(CListCtrl* m_ListCtrl);




```

`arkProject/HeavenShadow/HeavenShadow/Common.cpp`:

```cpp

#include "stdafx.h"
#include "Common.h"



#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS       ((NTSTATUS)0x00000000L)
#endif
#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
#endif



HANDLE g_hDevice = NULL;


extern WIN_VERSION WinVersion;
extern CWnd* g_wParent;



//在虚拟机中测试: WinXP, Vista, Win7, Win8(RP) 包含32/64位
typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
BOOL HsIs64BitWindows()
{
#if defined(_WIN64)
	return TRUE;  // 64位程序只在Win64系统中运行
#elif defined(_WIN32)
	// 32位程序在32/64位系统中运行。
	// 所以必须判断
	BOOL f64 = FALSE;
	LPFN_ISWOW64PROCESS fnIsWow64Process;

	fnIsWow64Process = (LPFN_ISWOW64PROCESS) GetProcAddress(GetModuleHandle(_T("kernel32")),"IsWow64Process");
	if(NULL != fnIsWow64Process)
	{
		return fnIsWow64Process(GetCurrentProcess(),&f64) && f64;
	}
	return FALSE;
#else
	return FALSE; // Win64不支持16位系统
#endif
}


VOID HsSendStatusDetail(LPCWSTR szBuffer)
{
	::SendMessageW(g_wParent->m_hWnd,HS_MESSAGE_STATUSDETAIL,NULL,(LPARAM)szBuffer);
}

VOID HsSendStatusTip(LPCWSTR szBuffer)
{
	::SendMessageW(g_wParent->m_hWnd,HS_MESSAGE_STATUSTIP,NULL,(LPARAM)szBuffer);
}


CString TrimPath(WCHAR * wzPath)
{
	CString strPath;

	if (wzPath[1] == ':' && wzPath[2] == '\\')
	{
		strPath = wzPath;
	}
	else if (wcslen(wzPath) > wcslen(L"\\SystemRoot\\") && 
		!_wcsnicmp(wzPath, L"\\SystemRoot\\", wcslen(L"\\SystemRoot\\")))
	{
		WCHAR szSystemDir[MAX_PATH] = {0};
		GetWindowsDirectory(szSystemDir, MAX_PATH);
		strPath.Format(L"%s\\%s", szSystemDir, wzPath + wcslen(L"\\SystemRoot\\"));
	}
	else if (wcslen(wzPath) > wcslen(L"system32\\") && 
		!_wcsnicmp(wzPath, L"system32\\", wcslen(L"system32\\")))
	{
		WCHAR szSystemDir[MAX_PATH] = {0};
		GetWindowsDirectory(szSystemDir, MAX_PATH);
		strPath.Format(L"%s\\%s", szSystemDir, wzPath/* + wcslen(L"system32\\")*/);
	}
	else if (wcslen(wzPath) > wcslen(L"\\??\\") &&
		!_wcsnicmp(wzPath, L"\\??\\", wcslen(L"\\??\\")))
	{
		strPath = wzPath + wcslen(L"\\??\\");
	}
	else if (wcslen(wzPath) > wcslen(L"%ProgramFiles%") &&
		!_wcsnicmp(wzPath, L"%ProgramFiles%", wcslen(L"%ProgramFiles%")))
	{
		WCHAR szSystemDir[MAX_PATH] = {0};
		if (GetWindowsDirectory(szSystemDir, MAX_PATH) != 0)
		{
			CString szTemp = szSystemDir;
			szTemp = szTemp.Left(szTemp.Find('\\'));
			szTemp += L"\\Program Files";
			szTemp += wzPath + wcslen(L"%ProgramFiles%"); 
			strPath = szTemp;
		}
	}
	else
	{
		strPath = wzPath;
	}

	strPath = GetLongPath(strPath);

	return strPath;
}

CString GetLongPath(CString szPath)
{
	CString strPath;

	if (szPath.Find(L'~') != -1)
	{
		WCHAR szLongPath[MAX_PATH] = {0};
		DWORD nRet = GetLongPathName(szPath, szLongPath, MAX_PATH);
		if (nRet >= MAX_PATH || nRet == 0)
		{
			strPath = szPath;
		}
		else
		{
			strPath = szLongPath;
		}
	}
	else
	{
		strPath = szPath;
	}

	return strPath;
}





CHAR* HsLoadDllContext(char* szFileName)
{
	DWORD dwReadWrite, LenOfFile=FileLen(szFileName);
	HANDLE hFile = CreateFileA(szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		PCHAR Buffer=(PCHAR)malloc(LenOfFile);
		SetFilePointer(hFile, 0, 0, FILE_BEGIN);
		ReadFile(hFile, Buffer, LenOfFile, &dwReadWrite, 0);
		CloseHandle(hFile);
		return Buffer;
	}
	return NULL;
}


DWORD FileLen(char* szFileName)
{
	WIN32_FIND_DATAA FileInfo= {0};
	DWORD FileSize = 0;
	HANDLE hFind;
	hFind = FindFirstFileA(szFileName ,&FileInfo);
	if(hFind != INVALID_HANDLE_VALUE)
	{
		FileSize = FileInfo.nFileSizeLow;
		FindClose(hFind);
	}
	return FileSize;
}




ULONG_PTR HsGetKernelBase(char* szNtosName)
{
	typedef long (__stdcall *pfnZwQuerySystemInformation)
		(
		IN ULONG SystemInformationClass,
		IN PVOID SystemInformation,
		IN ULONG SystemInformationLength,
		IN PULONG ReturnLength OPTIONAL
		);
	typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY64
	{
		ULONG Unknow1;
		ULONG Unknow2;
		ULONG Unknow3;
		ULONG Unknow4;
		PVOID Base;
		ULONG Size;
		ULONG Flags;
		USHORT Index;
		USHORT NameLength;
		USHORT LoadCount;
		USHORT ModuleNameOffset;
		char ImageName[256];
	} SYSTEM_MODULE_INFORMATION_ENTRY64, *PSYSTEM_MODULE_INFORMATION_ENTRY64;



	typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY32
	{
		ULONG  Reserved[2];  
		ULONG  Base;        
		ULONG  Size;         
		ULONG  Flags;        
		USHORT Index;       
		USHORT Unknown;     
		USHORT LoadCount;   
		USHORT ModuleNameOffset;
		CHAR   ImageName[256];   
	} SYSTEM_MODULE_INFORMATION_ENTRY32, *PSYSTEM_MODULE_INFORMATION_ENTRY32;

#ifdef _WIN64
#define SYSTEM_MODULE_INFORMATION_ENTRY SYSTEM_MODULE_INFORMATION_ENTRY64
#else
#define SYSTEM_MODULE_INFORMATION_ENTRY SYSTEM_MODULE_INFORMATION_ENTRY32
#endif


	typedef struct _SYSTEM_MODULE_INFORMATION
	{
		ULONG Count;
		SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
	} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
#define SystemModuleInformation 11
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)
	pfnZwQuerySystemInformation ZwQuerySystemInformationAddress = NULL;
	PSYSTEM_MODULE_INFORMATION  SystemModuleInformationPoint;
	ULONG NeedSize, BufferSize = 0x5000;
	PVOID Buffer = NULL;
	NTSTATUS bOk;
	ZwQuerySystemInformationAddress = (pfnZwQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"),"ZwQuerySystemInformation");
	do
	{
		Buffer = malloc(BufferSize);
		if(Buffer == NULL ) 
		{
			return 0;
		}
		bOk = ZwQuerySystemInformationAddress( SystemModuleInformation, Buffer, BufferSize, &NeedSize );
		if( bOk == STATUS_INFO_LENGTH_MISMATCH )
		{
			free(Buffer);
			BufferSize *= 2;
		}
		else if(!NT_SUCCESS(bOk))
		{
			free(Buffer);
			return 0;
		}
	}
	while(bOk==STATUS_INFO_LENGTH_MISMATCH );
	SystemModuleInformationPoint = (PSYSTEM_MODULE_INFORMATION)Buffer;
	ULONG_PTR Address = (ULONG_PTR)(SystemModuleInformationPoint->Module[0].Base);

	if(szNtosName!=NULL)
	{
		//*////////////////////////////////////////////////////////////////////////
		memcpy(
			szNtosName,
			SystemModuleInformationPoint->Module[0].ImageName+SystemModuleInformationPoint->Module[0].ModuleNameOffset,
			strlen(SystemModuleInformationPoint->Module[0].ImageName+SystemModuleInformationPoint->Module[0].ModuleNameOffset)
			);
	}

	free(Buffer);

	return Address;
}



char *Strcat(char *Str1, char *Str2) 
{
	DWORD dwLen = (DWORD)(strlen(Str1)+strlen(Str2)+1);
	char* Str3 =(char*)malloc(dwLen);
	memcpy(Str3,Str1,strlen(Str1));
	memcpy(Str3+strlen(Str1),Str2,strlen(Str2)+1);
	return Str3;
}



int HsReloc(ULONG_PTR NewBase, ULONG_PTR OrigBase)
{
	PIMAGE_DOS_HEADER		DosHeader;
	PIMAGE_NT_HEADERS		NtHeader;
	PIMAGE_BASE_RELOCATION	RelocTable;
	ULONG i,dwOldProtect;
	DosHeader = (PIMAGE_DOS_HEADER)NewBase;
	if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		return 0;
	}
	NtHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)NewBase + DosHeader->e_lfanew );
	if (NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)//是否存在重定位表
	{
		RelocTable=(PIMAGE_BASE_RELOCATION)((ULONG_PTR)NewBase + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		do
		{
			ULONG	NumOfReloc=(RelocTable->SizeOfBlock-sizeof(IMAGE_BASE_RELOCATION))/2;
			SHORT	MiniOffset=0;
			PUSHORT RelocData =(PUSHORT)((ULONG_PTR)RelocTable+sizeof(IMAGE_BASE_RELOCATION));
			for (i=0; i<NumOfReloc; i++) 
			{
				PULONG_PTR RelocAddress;//需要重定位的地址

				if (((*RelocData)>>12)==IMAGE_REL_BASED_DIR64||((*RelocData)>>12)==IMAGE_REL_BASED_HIGHLOW)//判断重定位类型是否为IMAGE_REL_BASED_HIGHLOW[32]或IMAGE_REL_BASED_DIR64[64]
				{

					MiniOffset=(*RelocData)&0xFFF;//小偏移

					RelocAddress=(PULONG_PTR)(NewBase+RelocTable->VirtualAddress+MiniOffset);

					VirtualProtect((PVOID)RelocAddress,sizeof(ULONG_PTR),PAGE_EXECUTE_READWRITE, &dwOldProtect);

					*RelocAddress=*RelocAddress+OrigBase-NtHeader->OptionalHeader.ImageBase;

					VirtualProtect((PVOID)RelocAddress, sizeof(ULONG_PTR),dwOldProtect,&dwOldProtect);
				}
				//下一个重定位数据
				RelocData++;
			}
			//下一个重定位块
			RelocTable=(PIMAGE_BASE_RELOCATION)((ULONG_PTR)RelocTable+RelocTable->SizeOfBlock);
		}
		while (RelocTable->VirtualAddress);
		return TRUE;
	}
	return FALSE;
}



CHAR *HsGetTempNtdll()
{
	char *szPath;
	szPath=(char*)malloc(260);
	memset(szPath,0,260);
	GetTempPathA(260,szPath);   //没有释放内存  
	return Strcat(szPath,"ntdll.dll");    
}


CHAR* HsGetSystemDir()
{
	char* szPath;
	szPath =(char *)malloc(20);
	memset(szPath,0,20);
	GetWindowsDirectoryA(szPath,20);
	return Strcat(szPath,"\\system32\\");
}





DWORD HsGetSSDTFunctionIndex(char *FunctionName)
{

	ULONG_PTR IndexOffset = 0;

	switch(WinVersion)
	{
	case Windows7:
		{		
			IndexOffset = 4;

			break;
		}

	case WindowsXP:
		{

			IndexOffset = 1;

			break;
		}
	}



	return *(DWORD*)((PUCHAR)GetProcAddress(GetModuleHandleW(L"ntdll.dll"),FunctionName)+IndexOffset);
}


DWORD HsGetSpecialIndex(char *FunctionName)
{
	switch(WinVersion)
	{
	case Windows7:
		{
			if(!_stricmp(FunctionName,"ZwQuerySystemTime"))
			{
				return 0x57;
			}
			return 0;
		}

	default:
		return 0;
	}
}



CHAR* HsGetTempWin32k()
{
	char* szPath = NULL;
	szPath=(char*)malloc(260);
	memset(szPath,0,260);
	GetTempPathA(260,szPath);
	return Strcat(szPath,"win32k.sys");
}



ULONG_PTR HsGetWin32kBase()
{
	typedef long (__stdcall *pfnZwQuerySystemInformation)
		(
		IN ULONG SystemInformationClass,
		IN PVOID SystemInformation,
		IN ULONG SystemInformationLength,
		IN PULONG ReturnLength OPTIONAL
		);
	typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY64
	{
		ULONG Unknow1;
		ULONG Unknow2;
		ULONG Unknow3;
		ULONG Unknow4;
		PVOID Base;
		ULONG Size;
		ULONG Flags;
		USHORT Index;
		USHORT NameLength;
		USHORT LoadCount;
		USHORT ModuleNameOffset;
		char ImageName[256];
	} SYSTEM_MODULE_INFORMATION_ENTRY64, *PSYSTEM_MODULE_INFORMATION_ENTRY64;



	typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY32
	{
		ULONG  Reserved[2];  
		ULONG  Base;        
		ULONG  Size;         
		ULONG  Flags;        
		USHORT Index;       
		USHORT Unknown;     
		USHORT LoadCount;   
		USHORT ModuleNameOffset;
		CHAR   ImageName[256];   
	} SYSTEM_MODULE_INFORMATION_ENTRY32, *PSYSTEM_MODULE_INFORMATION_ENTRY32;



#ifdef _WIN64
#define SYSTEM_MODULE_INFORMATION_ENTRY SYSTEM_MODULE_INFORMATION_ENTRY64
#else
#define SYSTEM_MODULE_INFORMATION_ENTRY SYSTEM_MODULE_INFORMATION_ENTRY32
#endif


	typedef struct _SYSTEM_MODULE_INFORMATION
	{
		ULONG Count;
		SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
	} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
#define SystemModuleInformation 11
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)
	pfnZwQuerySystemInformation ZwQuerySystemInformationAddress = NULL;
	PSYSTEM_MODULE_INFORMATION  SystemModuleInformationPoint;
	ULONG NeedSize, BufferSize = 0x5000;
	PVOID Buffer = NULL;
	NTSTATUS bOk;
	ZwQuerySystemInformationAddress = (pfnZwQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"),"ZwQuerySystemInformation");
	do
	{
		Buffer = malloc(BufferSize);
		if(Buffer == NULL ) 
		{
			return 0;
		}
		bOk = ZwQuerySystemInformationAddress( SystemModuleInformation, Buffer, BufferSize, &NeedSize );
		if( bOk == STATUS_INFO_LENGTH_MISMATCH )
		{
			free(Buffer);
			BufferSize *= 2;
		}
		else if(!NT_SUCCESS(bOk))
		{
			free(Buffer);
			return 0;
		}
	}
	while(bOk==STATUS_INFO_LENGTH_MISMATCH );
	SystemModuleInformationPoint = (PSYSTEM_MODULE_INFORMATION)Buffer;
	ULONG_PTR ModuleCount = SystemModuleInformationPoint->Count;

	ULONG_PTR Address = NULL;
	//遍历所有的模块
	int i = 0;
	for(i=0; i<ModuleCount;i++ )
	{
		if(_stricmp(SystemModuleInformationPoint->Module[i].ImageName+SystemModuleInformationPoint->Module[i].ModuleNameOffset,"win32k.sys")==0 )
		{
			Address=(ULONG_PTR)SystemModuleInformationPoint->Module[i].Base;
			break;
		}
	}
	free(Buffer);

	return Address;
}



ULONG_PTR HsGetWin32kImageBase(char *szFileName)
{
	PIMAGE_NT_HEADERS NtHeader;
	PIMAGE_DOS_HEADER DosHeader;
	ULONG_PTR ImageBaseAddr = 0;
	char* szNtosFileData=NULL;
	szNtosFileData = HsLoadDllContext(szFileName);
	DosHeader = (PIMAGE_DOS_HEADER)szNtosFileData;
	NtHeader  = (PIMAGE_NT_HEADERS)(szNtosFileData+DosHeader->e_lfanew);
	ImageBaseAddr=NtHeader->OptionalHeader.ImageBase;
	return ImageBaseAddr;
}
```

`arkProject/HeavenShadow/HeavenShadow/Common.h`:

```h
#pragma once

#include "stdafx.h"

#include <WinIoCtl.h>

typedef struct _COLUMNSTRUCT
{
	WCHAR*	szTitle;
	UINT    nWidth;
}COLUMNSTRUCT;


enum HS_ENUM_DLG_MSG	//子对话框、主对话框之间通信枚举
{
	HS_MESSAGE_STATUSDETAIL = 5425,	//修改状态栏详细信息
	HS_MESSAGE_STATUSTIP
};

enum HS_ENUM_IOCTL
{
	HS_IOCTL_PROC = 0x100,					//进程相关
	HS_IOCTL_PROC_SENDSELFPID,				//发送自己的PID到驱动层
	HS_IOCTL_PROC_PROCESSCOUNT,				//进程计数
	HS_IOCTL_PROC_PROCESSLIST,				//列举进程列表
	HS_IOCTL_PROC_PROTECTPROCESS,			//保护进程
	HS_IOCTL_PROC_KILLPROCESSBYFORCE,		//强制关闭进程
	HS_IOCTL_PROC_PROCESSTHREAD,			//线程
	HS_IOCTL_PROC_PROCESSTHREADMODULE,		//线程模块
	HS_IOCTL_PROC_PROCESSPRIVILEGE,			//列举进程权限
	HS_IOCTL_PROC_PRIVILEGE_ADJUST,			//改变进程权限
	HS_IOCTL_PROC_PROCESSHANDLE,			//句柄
	HS_IOCTL_PROC_PROCESSWINDOW,			//窗口
	HS_IOCTL_PROC_PROCESSMODULE,			//进程模块
	HS_IOCTL_PROC_PROCESSMEMORY,			//进程内存

	HS_IOCTL_MODU = 0x180,					//模块相关
	HS_IOCTL_MODU_MODULELIST,				//列举系统模块列表
	HS_IOCTL_MODU_REMOVEMODULE,				//卸载系统模块

	HS_IOCTL_KRNL = 0x200,					//内核钩子相关
	HS_IOCTL_KRNL_SSDTLIST,					//列举SSDT列表
	HS_IOCTL_KRNL_KISRVTAB,					//获取服务表
	HS_IOCTL_KRNL_RESUMESSDT,				//恢复SSDT函数
	HS_IOCTL_KRNL_SSSDTLIST,				//列举SSSDT列表
	HS_IOCTL_KRNL_WIN32KSERVICE,			//获取Win32k服务表
	HS_IOCTL_KRNL_KRNLFILE,					//获取内核文件		//具体哪个文件在InputBuffer的布尔型中确定
	HS_IOCTL_KRNL_KRNLIAT,					//获取内核导入表
	HS_IOCTL_KRNL_KRNLEAT,					//获取内核导出表

	HS_IOCTL_SYSK = 0x280,					//内核相关
	HS_IOCTL_SYSK_SYSTHREAD,				//内核线程
	HS_IOCTL_SYSK_IOTIMER,					//IOTIMER
	HS_IOCTL_SYSK_OPERIOTIMER,				//IOTIMER切换
	HS_IOCTL_SYSK_REMOVEIOTIMER,			//IOTIMER移除
	HS_IOCTL_SYSK_CALLBACKLIST,				//系统回调：驱动加载
	HS_IOCTL_SYSK_REMOVECALLBACK,			//删除系统回调
	HS_IOCTL_SYSK_DPCTIMER,					//DPCTimer
	HS_IOCTL_SYSK_REMOVEDPCTIMER,			//DPCTimer删除
	HS_IOCTL_SYSK_FILTERDRIVER,				//过滤驱动
	HS_IOCTL_SYSK_FILTERUNLOAD,				//卸载过滤驱动
};

enum HS_DLG_NUM
{
	HS_DIALOG_ABOUT = 1,		//关于对话框
	HS_DIALOG_PROCESS,			//进程对话框
	HS_DIALOG_MODULE,			//模块对话框
	HS_DIALOG_SYSTEM,			//内核对话框
	HS_DIALOG_KERNEL,			//内核钩子对话框
	HS_DIALOG_SERVICE,			//服务对话框
	HS_DIALOG_FILE,				//文件对话框
	HS_DIALOG_SETTING,			//设置对话框
	HS_DIALOG_TOOLS				//工具箱对话框
};

typedef enum _WIN_VERSION
{
	WindowsNT,
	Windows2000,
	WindowsXP,
	Windows2003,
	WindowsVista,
	Windows7,
	Windows8,
	Windows8_1,
	Windows10,
	WinUnknown
}WIN_VERSION;

//不支持符号链接用户相关性
#define HS_DEVICE_NAME                  L"\\Device\\HeavenShadowDevice"             // Driver Name
#define HS_LINK_NAME					L"\\\\.\\HeavenShadowLink"                  // Win32 Link Name

#define HS_EVENT_PROCESS_NAME			L"\\BaseNamedObjects\\HeavenShadowProcessEvent"

#define HS_DRIVER_NAME                  L"HeavenShadowDrv"
#define HS_DRIVER_PATH                  L"HeavenShadowDrv.sys"




#define HS_IOCTL(i)			 \
	CTL_CODE                 \
	(                        \
	FILE_DEVICE_UNKNOWN,     \
	i,						 \
	METHOD_NEITHER,          \
	FILE_ANY_ACCESS          \
	)

// HS_IOCTL(HS_IOCTL_PROC_PROCESSLIST)


//////////////////////////////////////////////////////////////////////////
//公有变量





//////////////////////////////////////////////////////////////////////////
//公有函数
HANDLE OpenDevice(LPCTSTR lpDevicePath);

BOOL HsIs64BitWindows();

VOID HsSendStatusDetail(LPCWSTR szBuffer);

VOID HsSendStatusTip(LPCWSTR szBuffer);

CString TrimPath(WCHAR * wzPath);

CString GetLongPath(CString szPath);

CHAR* HsLoadDllContext(char* szFileName);

DWORD FileLen(char* szFileName);

ULONG_PTR HsGetKernelBase(char* szNtosName);

char *Strcat(char *Str1, char *Str2);

int HsReloc(ULONG_PTR NewBase, ULONG_PTR OrigBase);

CHAR *HsGetTempNtdll();

CHAR* HsGetSystemDir();

DWORD HsGetSpecialIndex(char *FunctionName);

DWORD HsGetSSDTFunctionIndex(char *FunctionName);

CHAR* HsGetTempWin32k();

ULONG_PTR HsGetWin32kBase();

ULONG_PTR HsGetWin32kImageBase(char *szFileName);
```

`arkProject/HeavenShadow/HeavenShadow/DetailFunc.cpp`:

```cpp
#include "stdafx.h"
#include "DetailFunc.h"
#include "Common.h"

#include "resource.h"


extern WIN_VERSION GetWindowsVersion();
extern WIN_VERSION WinVersion;



COLUMNSTRUCT g_Column_ProcessDetail[] = 
{
	{	L"条目类别",				150	},
	{	L"条目描述",				440	}
};

WCHAR g_Item_ProcessDetail[][260] = 
{
	L"映像名称",
	L"进程ID",
	L"父进程ID",
	L"映像文件路径",
	L"EPROCESS",
	L"应用层访问",
	L"运行时间",
	L"创建时间",
	L"修改时间",
	L"访问时间",
	L"文件大小",
	L"文件版本",
	L"进程环境变量",
	L"进程命令行",
	L"进程当前目录",
	L"文件厂商",
	L"文件描述"
};

enum HS_PROCESS_DETAIL_ITEM
{
	HS_PROCESS_DETAIL_ITEM_FILENAME = 0,
	HS_PROCESS_DETAIL_ITEM_PID,
	HS_PROCESS_DETAIL_ITEM_PPID,
	HS_PROCESS_DETAIL_ITEM_PATH,
	HS_PROCESS_DETAIL_ITEM_EPROCESS,
	HS_PROCESS_DETAIL_ITEM_USERACCESS,
	HS_PROCESS_DETAIL_ITEM_RUNTIME,
	HS_PROCESS_DETAIL_ITEM_CREATETIME,
	HS_PROCESS_DETAIL_ITEM_MOTIFITIME,
	HS_PROCESS_DETAIL_ITEM_ACCESSTIME,
	HS_PROCESS_DETAIL_ITEM_FILESIZE,
	HS_PROCESS_DETAIL_ITEM_FILEVERSION,
	HS_PROCESS_DETAIL_ITEM_PEB,
	HS_PROCESS_DETAIL_ITEM_CMD,
	HS_PROCESS_DETAIL_ITEM_CURDIR,
	HS_PROCESS_DETAIL_ITEM_COMPANY,
	HS_PROCESS_DETAIL_ITEM_DESCRIPTOR
};


UINT g_Column_ProcessDetail_Count  = 2;	  //进程列表列数

UINT g_Item_ProcessDetail_Count = 17;



typedef long (__fastcall *pfnRtlAdjustPrivilege64)(ULONG,ULONG,ULONG,PVOID);
pfnRtlAdjustPrivilege64 RtlAdjustPrivilege;

typedef 
	NTSTATUS 
	(WINAPI *pfnNtQueryInformationProcess)(HANDLE,
	UINT,
	PVOID,
	ULONG,
	PULONG
	);

pfnNtQueryInformationProcess NtQueryInformationProcessAddress = NULL;

extern int dpix;
extern int dpiy;		


VOID HsInitProcessDetailList(CMyList *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_ProcessDetail_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_ProcessDetail[i].szTitle,LVCFMT_LEFT,(int)(g_Column_ProcessDetail[i].nWidth*(dpix/96.0)));
	}
}



VOID HsLoadProcessDetailList(PHSPROCESSINFO ProcessInfo, CMyList *m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	UINT i;
	for (i = 0;i<g_Item_ProcessDetail_Count;i++)
	{
		m_ListCtrl->InsertItem(i,g_Item_ProcessDetail[i]);
	}

	WCHAR Temp[20] = {0};

	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_FILENAME,1,ProcessInfo->Name);

	swprintf_s(Temp,L"%d",ProcessInfo->Pid);
	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_PID,1,Temp);
	ZeroMemory(Temp,sizeof(WCHAR)*20);

	swprintf_s(Temp,L"%d",ProcessInfo->PPid);
	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_PPID,1,Temp);
	ZeroMemory(Temp,sizeof(WCHAR)*20);

	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_PATH,1,ProcessInfo->Path);

	swprintf_s(Temp,L"0x%p",ProcessInfo->Eprocess);
	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_EPROCESS,1,Temp);
	ZeroMemory(Temp,sizeof(WCHAR)*20);

	if (ProcessInfo->UserAccess == FALSE)
	{
		m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_USERACCESS,1,L"拒绝");
	}
	else
	{
		m_ListCtrl->SetItemText(5,1,L"允许");
	}

	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_RUNTIME,1,L"1970/01/01 00:00:00");

	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_COMPANY,1,ProcessInfo->CompanyName);

	CString Detail = ProcessInfo->Path;
	Detail = HsGetFileDescription(Detail);
	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_DESCRIPTOR,1,Detail.GetBuffer());

	CFileStatus Status;
	if(CFile::GetStatus(ProcessInfo->Path, Status))
	{
		CTime CreateTime = Status.m_ctime;
		CTime ModifyTime = Status.m_mtime;
		CTime AccessTime = Status.m_atime;

		CString strCreateTime;
		strCreateTime.Format(
			L"%04d/%02d/%02d %02d:%02d:%02d", 
			CreateTime.GetYear(),
			CreateTime.GetMonth(),
			CreateTime.GetDay(),
			CreateTime.GetHour(),
			CreateTime.GetMinute(),
			CreateTime.GetSecond());

		CString strModifyTime;
		strModifyTime.Format(
			L"%04d/%02d/%02d %02d:%02d:%02d", 
			ModifyTime.GetYear(),
			ModifyTime.GetMonth(),
			ModifyTime.GetDay(),
			ModifyTime.GetHour(),
			ModifyTime.GetMinute(),
			ModifyTime.GetSecond());

		CString strAccessTime;
		strAccessTime.Format(
			L"%04d/%02d/%02d %02d:%02d:%02d", 
			AccessTime.GetYear(),
			AccessTime.GetMonth(),
			AccessTime.GetDay(),
			AccessTime.GetHour(),
			AccessTime.GetMinute(),
			AccessTime.GetSecond());

		m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_CREATETIME, 1,strCreateTime.GetBuffer());
		m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_MOTIFITIME,1,strModifyTime.GetBuffer());
		m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_ACCESSTIME,1,strAccessTime.GetBuffer());
	}
	else
	{

	}

	
	HANDLE hFile = CreateFile(
		ProcessInfo->Path, 
		GENERIC_READ, 
		FILE_SHARE_READ | FILE_SHARE_DELETE | FILE_SHARE_WRITE, 
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CString strFileSize;
		LARGE_INTEGER FileSize;
		if (GetFileSizeEx( hFile, &FileSize))
		{
			strFileSize.Format(L"%d KB", FileSize.QuadPart / 1024);
		}
		CloseHandle(hFile);

		m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_FILESIZE, 1,strFileSize.GetBuffer());
	}
	else
	{
	}



	//////////////////////////////////////////////////////////////////////////
	//版本

	TCHAR szVersionBuffer[8192] = _T("");
	DWORD dwVerSize = 0;   
	DWORD dwHandle = 0;   
	QWORD dwVersion = 0;

	dwVerSize = GetFileVersionInfoSize(ProcessInfo->Path, &dwHandle);   

	if (dwVerSize)
	{
		if (GetFileVersionInfo(ProcessInfo->Path, dwHandle, dwVerSize, szVersionBuffer))   
		{   
			VS_FIXEDFILEINFO* Infor;   
			unsigned int nInfoLen;   
			if (VerQueryValue(szVersionBuffer, _T("\\"), (void**)&Infor, &nInfoLen))
			{	
				dwVersion = Infor->dwFileVersionMS;
				dwVersion = dwVersion << 32;
				dwVersion |= Infor->dwFileVersionLS;
			}   
		}  
	} 	

	if (dwVersion)
	{
		CString strFileVersion;
		DWORD dwV1,dwV2,dwV3,dwV4;
		QWORD dwStackVersion = dwVersion;

		dwV1 = (DWORD)(dwStackVersion & 0xffff);
		dwStackVersion >>= 16;
		dwV2 = (DWORD)(dwStackVersion & 0xffff);
		dwStackVersion >>= 16;
		dwV3 = (DWORD)(dwStackVersion & 0xffff);
		dwStackVersion >>= 16;
		dwV4 = (DWORD)(dwStackVersion & 0xffff);

		strFileVersion.Format(L"%d.%d.%d.%d", dwV4, dwV3, dwV2, dwV1);

		m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_FILEVERSION,1,strFileVersion.GetBuffer());

	}
	else
	{
	}


	//////////////////////////////////////////////////////////////////////////
	//PEB

	CString strPEB;

	strPEB = HsGetProcessPebAddress((DWORD)ProcessInfo->Pid);

	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_PEB,1,strPEB.GetBuffer());


	//////////////////////////////////////////////////////////////////////////
	//命令行

	CString strCmdLine;

	strCmdLine = HsGetProcessCmdLine((DWORD)ProcessInfo->Pid);

	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_CMD,1,strCmdLine.GetBuffer());


	//////////////////////////////////////////////////////////////////////////
	//当前目录

	CString strCurDir;

	strCurDir = HsGetProcessCurrentDirectory((DWORD)ProcessInfo->Pid);

	m_ListCtrl->SetItemText(HS_PROCESS_DETAIL_ITEM_CURDIR,1,strCurDir.GetBuffer());
}



CString HsGetProcessPebAddress(DWORD dwPid)
{
	CString szRet = L"";
	LONG                      Status;
	HANDLE                    hProcess = NULL;
	BOOL                      bRet = FALSE;
	LPTHREAD_START_ROUTINE    FuncAddress = NULL;
	DWORD                     dwRetVal = 0;


	WinVersion = GetWindowsVersion();

	switch(WinVersion)
	{
	case Windows7:   //注意我们这里针对的是64位的Win7
		{
			PROCESS_BASIC_INFORMATION64 pbi;

#ifdef _UNICODE
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif	
			if (FuncAddress==NULL)
			{
				bRet = FALSE;

				break;
			}

			NtQueryInformationProcessAddress=(pfnNtQueryInformationProcess)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"NtQueryInformationProcess");

			if (NtQueryInformationProcessAddress==NULL)
			{
				bRet = FALSE;

				break;
			}


			RtlAdjustPrivilege=(pfnRtlAdjustPrivilege64)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"RtlAdjustPrivilege");

			if (RtlAdjustPrivilege==NULL)
			{
				bRet = FALSE;

				break;
			}
			RtlAdjustPrivilege(20,1,0,&dwRetVal);

			hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);

			if (!hProcess)
			{
				bRet = FALSE;

				break;
			}

			Status = NtQueryInformationProcessAddress(hProcess,
				ProcessBasicInformation,
				(PVOID)&pbi,
				sizeof(PROCESS_BASIC_INFORMATION64),
				NULL
				);

			if (Status)
			{

				bRet = FALSE;

				break;
			}

			else
			{
				szRet.Format(L"0x%p",pbi.PebBaseAddress);

				bRet = TRUE;
			}


			break;
		}

	case WindowsXP:  //这里是针对的32位的XP
		{


			PROCESS_BASIC_INFORMATION32 pbi;


#ifdef _UNICODE
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif	
			if (FuncAddress==NULL)
			{
				bRet = FALSE;

				break;
			}

			NtQueryInformationProcessAddress=(pfnNtQueryInformationProcess)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"NtQueryInformationProcess");

			if (NtQueryInformationProcessAddress==NULL)
			{
				bRet = FALSE;

				break;
			}
			HsDebugPrivilege(SE_DEBUG_NAME, TRUE);
			hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);
			HsDebugPrivilege(SE_DEBUG_NAME, FALSE);
			if (!hProcess)
			{
				bRet = FALSE;

				break;;
			}


			Status = NtQueryInformationProcessAddress(hProcess,
				ProcessBasicInformation,
				(PVOID)&pbi,
				sizeof(PROCESS_BASIC_INFORMATION32),
				NULL
				);

			if (Status)
			{

				bRet = FALSE;

				break;
			}

			else
			{
				szRet.Format(L"0x%x",pbi.PebBaseAddress);

				bRet = TRUE;
			}


			break;
		}
	}


	if (hProcess)
	{
		CloseHandle(hProcess);
	}
	if (bRet==FALSE)
	{
		szRet.Empty();
	}

	return szRet;
}





CString HsGetFileDescription(CString strPath)
{
	CString strDescription; 

	if (!strPath.IsEmpty() && PathFileExists(strPath))
	{
		LPWSTR lpstrFilename = (LPWSTR)(LPCWSTR)strPath;
		DWORD  dwSize = GetFileVersionInfoSize(lpstrFilename, NULL); 

		if (dwSize)
		{
			LPVOID Buffer = malloc(sizeof(char)*dwSize); 
			if (Buffer)
			{
				if (GetFileVersionInfo(lpstrFilename, 0, dwSize, Buffer))
				{
					char* VerValue = NULL; 
					UINT  nSize = 0; 
					if (VerQueryValue(Buffer, L"\\VarFileInfo\\Translation", (LPVOID*)&VerValue, &nSize))
					{
						CString strSubBlock, strTranslation;
						strDescription.Format(L"000%x", *((unsigned short int *)VerValue)); 
						strTranslation = strDescription.Right(4); 
						strDescription.Format(L"000%x", *((unsigned short int *)&VerValue[2])); 
						strTranslation += strDescription.Right(4); 

						strSubBlock.Format(L"\\StringFileInfo\\%s\\FileDescription", strTranslation); 
						if (VerQueryValue(Buffer, strSubBlock.GetBufferSetLength(256), (LPVOID*)&VerValue, &nSize))
						{
							strSubBlock.ReleaseBuffer(); 
							strDescription.Format(L"%s", VerValue); 
						}
					}
				}

				free(Buffer);
			}
		}
	}

	return strDescription;
}





CString HsGetProcessCmdLine(DWORD dwPid)
{
	CString m_CmdLine;
	LPTHREAD_START_ROUTINE FuncAddress = NULL;
	DWORD                  dwRetVal  = 0;
	HANDLE                 hProcess  = NULL;
	LONG                   Status;


	PVOID		CmdBuffer = NULL;
	SIZE_T      dwReturn = 0;

	DWORD                     dwSize = 0;
	LPVOID                    lpAddress = NULL;
	BOOL                      bRet = FALSE;

	switch(WinVersion)
	{
	case Windows7:   //注意我们这里针对的是64位的Win7
		{

			_PEB64        Peb;
			PROCESS_BASIC_INFORMATION64 pbi;
			PROCESS_PARAMETERS64        ProcParam;
#ifdef _UNICODE
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif	
			if (FuncAddress==NULL)
			{
				bRet = FALSE;

				break;
			}

			NtQueryInformationProcessAddress=(pfnNtQueryInformationProcess)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"NtQueryInformationProcess");

			if (NtQueryInformationProcessAddress==NULL)
			{
				bRet = FALSE;

				break;
			}


			RtlAdjustPrivilege=(pfnRtlAdjustPrivilege64)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"RtlAdjustPrivilege");

			if (RtlAdjustPrivilege==NULL)
			{
				bRet = FALSE;

				break;
			}
			RtlAdjustPrivilege(20,1,0,&dwRetVal);

			hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);

			if (!hProcess)
			{
				bRet = FALSE;

				break;
			}


			Status = NtQueryInformationProcessAddress(hProcess,
				ProcessBasicInformation,
				(PVOID)&pbi,
				sizeof(PROCESS_BASIC_INFORMATION64),
				NULL
				);

			if (Status)
			{
				bRet = FALSE;

				break;
			}

			if (!ReadProcessMemory( hProcess,
				(PVOID)pbi.PebBaseAddress,
				&Peb,
				sizeof(_PEB64),
				&dwReturn))
			{
				bRet = FALSE;

				break;
			}



			if (!ReadProcessMemory( hProcess,
				Peb.ProcessParameters,
				&ProcParam,
				sizeof(PROCESS_PARAMETERS64),
				&dwReturn
				)
				)
			{
				bRet = FALSE;

				break;
			}

			lpAddress = ProcParam.CommandLine.Buffer;
			dwSize = ProcParam.CommandLine.Length;

			CmdBuffer = malloc(dwSize + sizeof(WCHAR));
			if (!CmdBuffer)
			{
				bRet = FALSE;

				break;
			}

			memset(CmdBuffer, 0, dwSize + sizeof(WCHAR));
			if (!ReadProcessMemory( hProcess,
				lpAddress,
				CmdBuffer,
				dwSize,
				&dwReturn))
			{
				bRet = FALSE;

				break;
			}
			bRet = TRUE;
			m_CmdLine = (WCHAR*)CmdBuffer;


			break;
		}

	case WindowsXP:  //这里是针对的32位的XP
		{

			_PEB32        Peb;
			PROCESS_BASIC_INFORMATION32 pbi;
			PROCESS_PARAMETERS32        ProcParam;

#ifdef _UNICODE
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif	
			if (FuncAddress==NULL)
			{
				bRet = FALSE;

				break;
			}

			NtQueryInformationProcessAddress=(pfnNtQueryInformationProcess)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"NtQueryInformationProcess");

			if (NtQueryInformationProcessAddress==NULL)
			{
				bRet = FALSE;

				break;
			}
			HsDebugPrivilege(SE_DEBUG_NAME,TRUE);
			hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);
			HsDebugPrivilege(SE_DEBUG_NAME,FALSE);
			if (!hProcess)
			{
				bRet = FALSE;

				break;;
			}


			Status = NtQueryInformationProcessAddress(hProcess,
				ProcessBasicInformation,
				(PVOID)&pbi,
				sizeof(PROCESS_BASIC_INFORMATION32),
				NULL
				);

			if (Status)
			{
				bRet = FALSE;

				break;;
			}

			if (!ReadProcessMemory( hProcess,
				(PVOID)pbi.PebBaseAddress,
				&Peb,
				sizeof(_PEB32),
				&dwReturn))
			{
				bRet = FALSE;

				break;;
			}



			if (!ReadProcessMemory( hProcess,
				Peb.ProcessParameters,
				&ProcParam,
				sizeof(PROCESS_PARAMETERS32),
				&dwReturn
				)
				)
			{
				bRet = FALSE;

				break;
			}

			lpAddress = ProcParam.CommandLine.Buffer;
			dwSize = ProcParam.CommandLine.Length;

			CmdBuffer = malloc(dwSize + sizeof(WCHAR));
			if (!CmdBuffer)
			{
				bRet = FALSE;

				break;
			}

			memset(CmdBuffer, 0, dwSize + sizeof(WCHAR));
			if (!ReadProcessMemory( hProcess,
				lpAddress,
				CmdBuffer,
				dwSize,
				&dwReturn))
			{
				bRet = FALSE;

				break;
			}
			bRet = TRUE;
			m_CmdLine = (WCHAR*)CmdBuffer;

			break;
		}
	}




	if (hProcess!=NULL)
	{
		CloseHandle(hProcess);
	}

	if (CmdBuffer)
	{
		free(CmdBuffer);
		CmdBuffer = NULL;
	}

	if (bRet==FALSE)
	{
		m_CmdLine.Empty();
	}


	return m_CmdLine;
} 



CString HsGetProcessCurrentDirectory(DWORD dwPid)
{
	CString                   m_Dir;
	BOOL                      bRet = FALSE;
	LPTHREAD_START_ROUTINE    FuncAddress = NULL;
	DWORD                     dwRetVal = 0;
	SIZE_T                    dwReturn = 0;
	HANDLE                    hProcess = NULL;
	NTSTATUS                  Status;
	PVOID                     lpAddress = NULL;
	ULONG                     ulSize = 0;
	WCHAR*                    CmdBuffer = NULL;
	switch(WinVersion)
	{
	case Windows7:   //注意我们这里针对的是64位的Win7
		{

			_PEB64        Peb;
			PROCESS_BASIC_INFORMATION64 pbi;
			PROCESS_PARAMETERS64        ProcParam;

#ifdef _UNICODE
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif	
			if (FuncAddress==NULL)
			{
				bRet = FALSE;

				break;
			}

			NtQueryInformationProcessAddress=(pfnNtQueryInformationProcess)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"NtQueryInformationProcess");

			if (NtQueryInformationProcessAddress==NULL)
			{
				bRet = FALSE;

				break;
			}


			RtlAdjustPrivilege=(pfnRtlAdjustPrivilege64)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"RtlAdjustPrivilege");

			if (RtlAdjustPrivilege==NULL)
			{
				bRet = FALSE;

				break;
			}
			RtlAdjustPrivilege(20,1,0,&dwRetVal);

			hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);

			if (!hProcess)
			{
				bRet = FALSE;

				break;
			}

			Status = NtQueryInformationProcessAddress(hProcess,
				ProcessBasicInformation,
				(PVOID)&pbi,
				sizeof(PROCESS_BASIC_INFORMATION64),
				NULL
				);

			if (Status)
			{
				bRet = FALSE;

				break;
			}

			if (!ReadProcessMemory( hProcess,
				(PVOID)pbi.PebBaseAddress,
				&Peb,
				sizeof(_PEB64),
				&dwReturn))
			{
				bRet = FALSE;

				break;
			}



			if (!ReadProcessMemory( hProcess,
				Peb.ProcessParameters,
				&ProcParam,
				sizeof(PROCESS_PARAMETERS64),
				&dwReturn
				)
				)
			{
				bRet = FALSE;

				break;
			}


			lpAddress = ProcParam.CurrentDirectory.Buffer;
			ulSize = ProcParam.CurrentDirectory.Length;

			CmdBuffer = (WCHAR*)malloc(ulSize + sizeof(WCHAR));
			if (!CmdBuffer)
			{
				bRet = FALSE;

				break;
			}

			memset(CmdBuffer, 0, ulSize + sizeof(WCHAR));
			if (!ReadProcessMemory(hProcess,
				lpAddress,
				CmdBuffer,
				ulSize,
				&dwReturn))
			{
				bRet = FALSE;

				break;
			}


			m_Dir = (WCHAR*)CmdBuffer;
			bRet = TRUE;

			break;
		}

	case WindowsXP:  //这里是针对的32位的XP
		{
			_PEB32                      Peb = {0};
			PROCESS_PARAMETERS32        ProcParam = {0};
			PROCESS_BASIC_INFORMATION32 pbi;


#ifdef _UNICODE
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
			FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif	
			if (FuncAddress==NULL)
			{
				bRet = FALSE;

				break;
			}

			NtQueryInformationProcessAddress=(pfnNtQueryInformationProcess)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"NtQueryInformationProcess");

			if (NtQueryInformationProcessAddress==NULL)
			{
				bRet = FALSE;

				break;
			}
			HsDebugPrivilege(SE_DEBUG_NAME,TRUE);
			hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);
			HsDebugPrivilege(SE_DEBUG_NAME,FALSE);
			if (!hProcess)
			{
				bRet = FALSE;

				break;
			}

			Status = NtQueryInformationProcessAddress(hProcess,
				ProcessBasicInformation,
				(PVOID)&pbi,
				sizeof(PROCESS_BASIC_INFORMATION32),
				NULL
				);

			if (Status)
			{
				bRet = FALSE;

				break;;
			}

			if (!ReadProcessMemory( hProcess,
				(PVOID)pbi.PebBaseAddress,
				&Peb,
				sizeof(_PEB32),
				&dwReturn))
			{
				bRet = FALSE;

				break;;
			}



			if (!ReadProcessMemory( hProcess,
				Peb.ProcessParameters,
				&ProcParam,
				sizeof(PROCESS_PARAMETERS32),
				&dwReturn
				)
				)
			{
				bRet = FALSE;

				break;
			}

			lpAddress = ProcParam.CurrentDirectory.Buffer;
			ulSize = ProcParam.CurrentDirectory.Length;

			CmdBuffer = (WCHAR*)malloc(ulSize + sizeof(WCHAR));
			if (!CmdBuffer)
			{
				bRet = FALSE;

				break;
			}

			memset(CmdBuffer, 0, ulSize + sizeof(WCHAR));
			if (!ReadProcessMemory(hProcess,
				lpAddress,
				CmdBuffer,
				ulSize,
				&dwReturn))
			{
				bRet = FALSE;

				break;
			}


			m_Dir = (WCHAR*)CmdBuffer;
			bRet = TRUE;

			break;
		}
	}


	if (hProcess)
	{
		CloseHandle(hProcess);
	}

	if (CmdBuffer)
	{
		free(CmdBuffer);
		CmdBuffer = NULL;
	}

	if (bRet==FALSE)
	{
		m_Dir.Empty();
	}

	return m_Dir;
}




```

`arkProject/HeavenShadow/HeavenShadow/DetailFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"


#include "ProcessFunc.h"


#define ProcessBasicInformation 0




typedef LONG NTSTATUS;

typedef struct
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct  PROCESS_PARAMETERS32
{
	ULONG          AllocationSize;
	ULONG          ActualSize;
	ULONG          Flags;
	ULONG          Unknown1;
	UNICODE_STRING Unknown2;
	HANDLE         InputHandle;
	HANDLE         OutputHandle;
	HANDLE         ErrorHandle;
	UNICODE_STRING CurrentDirectory;
	HANDLE         CurrentDirectoryHandle;
	UNICODE_STRING SearchPaths;
	UNICODE_STRING ApplicationName;
	UNICODE_STRING CommandLine;
	PVOID          EnvironmentBlock;
	ULONG          Unknown[9];
	UNICODE_STRING Unknown3;
	UNICODE_STRING Unknown4;
	UNICODE_STRING Unknown5;
	UNICODE_STRING Unknown6;
} PROCESS_PARAMETERS32, *PPROCESS_PARAMETERS32;

typedef struct PROCESS_PARAMETERS64
{
	ULONG          AllocationSize;
	ULONG          ActualSize;
	ULONG          Flags;
	ULONG          Unknown1;
	PVOID64        ConsoleHandle;
	ULONG          ConsoleFlags;
	PVOID64        InputHandle;
	PVOID64		   OutputHandle;
	PVOID64        ErrorHandle;
	UNICODE_STRING CurrentDirectory;
	HANDLE         CurrentDirectoryHandle;
	UNICODE_STRING SearchPaths;
	UNICODE_STRING ApplicationName;
	UNICODE_STRING CommandLine;
	PVOID64        EnvironmentBlock;
	ULONG          Unknown[9];
	UNICODE_STRING Unknown3;
	UNICODE_STRING Unknown4;
	UNICODE_STRING Unknown5;
	UNICODE_STRING Unknown6;
}PROCESS_PARAMETERS64,*PPROCESS_PARAMETERS64;






typedef struct _PEB32 {
	BOOLEAN InheritedAddressSpace; 
	BOOLEAN ReadImageFileExecOptions;   
	BOOLEAN BeingDebugged;             
	union {
		BOOLEAN BitField;            
		struct {
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN SpareBits : 7;
		};
	};
	LONG Mutant;
	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
}_PEB32, *_PPEB32;



typedef struct _PEB64 {
	BOOLEAN InheritedAddressSpace; 
	BOOLEAN ReadImageFileExecOptions;   
	BOOLEAN BeingDebugged;             
	union {
		BOOLEAN BitField;            
		struct {
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN SpareBits : 7;
		};
	};
	LONG_PTR Mutant;
	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
}_PEB64, *_PPEB64;


typedef struct _PROCESS_BASIC_INFORMATION32 {
	NTSTATUS ExitStatus;
	ULONG32 PebBaseAddress;
	ULONG32 AffinityMask;
	ULONG BasePriority;
	ULONG32 UniqueProcessId;
	ULONG32 InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION32;





typedef struct _PROCESS_BASIC_INFORMATION64 {
	NTSTATUS ExitStatus;
	ULONG32 Pad1;
	ULONG64 PebBaseAddress;
	ULONG64 AffinityMask;
	ULONG   BasePriority;
	ULONG32 Pad2;
	ULONG64 UniqueProcessId;
	ULONG64 InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION64;


VOID HsInitProcessDetailList(CMyList *m_ListCtrl);

VOID HsLoadProcessDetailList(PHSPROCESSINFO ProcessInfo, CMyList *m_ListCtrl);

CString HsGetProcessPebAddress(DWORD dwPid);

CString HsGetFileDescription(CString strPath);

CString HsGetProcessCmdLine(DWORD dwPid);

CString HsGetProcessCurrentDirectory(DWORD dwPid);
```

`arkProject/HeavenShadow/HeavenShadow/DpcTimerFunc.cpp`:

```cpp
#include "stdafx.h"
#include "DpcTimerFunc.h"
#include "SSDTFunc.h"
#include "ModuleFunc.h"
#include "ProcessFunc.h"
#include "Common.h"
#include <vector>

using namespace std;


vector<DPC_TIMER> m_DPCTimerVector;
ULONG             m_ulDPCCount;
extern HANDLE g_hDevice;
extern WIN_VERSION WinVersion;
extern BOOL bIsChecking;
extern vector<DRIVER_INFO> m_DriverList;



COLUMNSTRUCT g_Column_DPCTimer[] = 
{
	{	L"定时器对象",			125	},
	{	L"设备对象",				125	},
	{	L"触发周期",				70	},
	{	L"函数入口",				125	},
	{	L"模块文件",				155	},
	{	L"出品厂商",				125	}
};


UINT g_Column_DPCTimer_Count = 6;

extern int dpix;
extern int dpiy;


VOID HsInitDPCTimerList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_DPCTimer_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_DPCTimer[i].szTitle,LVCFMT_LEFT,(int)(g_Column_DPCTimer[i].nWidth*(dpix/96.0)));
	}
}



VOID HsLoadDPCTimerList(CListCtrl *m_ListCtrl)
{
	if (bIsChecking == TRUE)
	{
		return;
	}

	// 	while(bIsChecking == TRUE)
	// 	{
	// 		Sleep(10);
	// 	}

	bIsChecking = TRUE;

	HsSendStatusDetail(L"DPCTimer正在加载...");
	HsSendStatusTip(L"DPCTimer");

	HsQueryDPCTimerList(m_ListCtrl);

	bIsChecking = FALSE;
}



VOID HsQueryDPCTimerList(CListCtrl *m_ListCtrl)
{
	BOOL bRet = FALSE;

	m_ListCtrl->DeleteAllItems();
	m_DPCTimerVector.clear();

	bRet = EnumDriver();
	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"驱动模块初始化失败。");
		return;
	}

	bRet = HsGetDPCTimerList();
	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"DPCTimer初始化失败。");
		return;
	}

	HsInsertDPCTimerItem(m_ListCtrl);
}


BOOL HsGetDPCTimerList()
{
	ULONG_PTR ulCnt = 100;
	PDPC_TIMER_INFOR TimerInfor = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;


	do 
	{
		ULONG_PTR ulSize = sizeof(DPC_TIMER_INFOR) + ulCnt * sizeof(DPC_TIMER);

		if (TimerInfor)
		{
			free(TimerInfor);
			TimerInfor = NULL;
		}

		TimerInfor = (PDPC_TIMER_INFOR)malloc(ulSize);

		if (TimerInfor)
		{
			memset(TimerInfor, 0, ulSize);
			TimerInfor->ulCnt = (ULONG)ulCnt;		
			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_DPCTIMER),
				NULL,
				0,
				TimerInfor,
				(DWORD)ulSize,
				&ulReturnSize,
				NULL);
		}

		ulCnt =TimerInfor->ulCnt + 10;

	} while (!bRet && TimerInfor->ulRetCnt > TimerInfor->ulCnt);

	if (bRet &&
		TimerInfor->ulCnt >= TimerInfor->ulRetCnt)
	{
		for (ULONG i = 0; i < TimerInfor->ulRetCnt; i++)
		{
			m_DPCTimerVector.push_back(TimerInfor->DpcTimer[i]);
		}
	}

	if (TimerInfor)
	{
		free(TimerInfor);
		TimerInfor = NULL;
	}

	return bRet;
}



VOID HsInsertDPCTimerItem(CListCtrl* m_ListCtrl)
{
	m_ulDPCCount = 0;
	for (vector<DPC_TIMER>::iterator itor = m_DPCTimerVector.begin(); itor != m_DPCTimerVector.end(); itor++)
	{
		CString strTimerObject, strPeriod, strDispatch, strPath, strDpc;

		strTimerObject.Format(L"0x%p", itor->TimerObject);
		strPeriod.Format(L"%d", itor->Period / 1000);
		strDispatch.Format(L"0x%p", itor->TimeDispatch);
		strPath = GetDriverPath(itor->TimeDispatch);
		strDpc.Format(L"0x%p", itor->Dpc);

		int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strTimerObject);
		m_ListCtrl->SetItemText(n, 1, strDpc);
		m_ListCtrl->SetItemText(n, 2, strPeriod);
		m_ListCtrl->SetItemText(n, 3, strDispatch);
		m_ListCtrl->SetItemText(n, 4, strPath);
		m_ListCtrl->SetItemText(n, 5, HsGetFileCompanyName(strPath));


		m_ulDPCCount++;

		CString StatusBarContext;
		StatusBarContext.Format(L"DPCTimer正在加载。 定时器数：%d",m_ulDPCCount);
		HsSendStatusDetail(StatusBarContext);

	}

	CString StatusBarContext;
	StatusBarContext.Format(L"DPCTimer加载完成。 定时器数：%d",m_ulDPCCount);
	HsSendStatusDetail(StatusBarContext);

}




VOID HsRemoveDPCTimerItem(CListCtrl* m_ListCtrl)
{
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;
	int Index = m_ListCtrl->GetSelectionMark();

	if (Index<0)
	{
		return;
	}

	CString Temp = m_ListCtrl->GetItemText(Index,0);

	REMOVE_DPCTIMER  RemoveDPCTimer;

	for ( vector <DPC_TIMER>::iterator Iter = m_DPCTimerVector.begin( ); Iter != m_DPCTimerVector.end( ); Iter++ )
	{
		CString strTimerObject;
		strTimerObject.Format(L"0x%08p", Iter->TimerObject);
		if (!strTimerObject.CompareNoCase(Temp))
		{

			RemoveDPCTimer.TimerObject = Iter->TimerObject;
			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_REMOVEDPCTIMER),
				&RemoveDPCTimer,
				sizeof(REMOVE_DPCTIMER),
				NULL,
				0,
				&ulReturnSize,
				NULL);


			break;
		}	
	}

	m_ulDPCCount--;
	m_ListCtrl->DeleteItem(Index);

	CString StatusBarContext;
	StatusBarContext.Format(L"DPCTimer加载完成。 定时器数：%d",m_ulDPCCount);
	HsSendStatusDetail(StatusBarContext);


	bIsChecking = FALSE;
}
```

`arkProject/HeavenShadow/HeavenShadow/DpcTimerFunc.h`:

```h
#pragma once
#include "stdafx.h"



typedef struct _REMOVE_DPCTIMER
{
	ULONG_PTR     TimerObject;
}REMOVE_DPCTIMER,*PREMOVE_DPCTIMER;

typedef struct _DPC_TIMER_
{
	ULONG_PTR TimerObject;
	ULONG_PTR Period;			// 周期
	ULONG_PTR TimeDispatch;
	ULONG_PTR Dpc;
}DPC_TIMER, *PDPC_TIMER;

typedef struct _DPC_TIMER_INFOR_
{
	ULONG ulCnt;
	ULONG ulRetCnt;
	DPC_TIMER DpcTimer[1];
}DPC_TIMER_INFOR, *PDPC_TIMER_INFOR;


VOID HsInitDPCTimerList(CListCtrl *m_ListCtrl);

VOID HsLoadDPCTimerList(CListCtrl *m_ListCtrl);

VOID HsQueryDPCTimerList(CListCtrl *m_ListCtrl);

BOOL HsGetDPCTimerList();

VOID HsInsertDPCTimerItem(CListCtrl* m_ListCtrl);

VOID HsRemoveDPCTimerItem(CListCtrl* m_ListCtrl);



```

`arkProject/HeavenShadow/HeavenShadow/FileDlg.cpp`:

```cpp
// FileDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "FileDlg.h"
#include "afxdialogex.h"
#include "HeavenShadowDlg.h"
#include "Common.h"

#include "FileFunc.h"


HICON m_hIcon;
CImageList m_pImageList_Large;
CImageList m_pImageList_Small;

WCHAR  DriveString[MAX_PATH] = {0};

// CFileDlg 对话框

IMPLEMENT_DYNAMIC(CFileDlg, CDialog)

CFileDlg::CFileDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CFileDlg::IDD, pParent)
{
	HRESULT hresut=CoInitialize(NULL);

	SHFILEINFO	sfi;
	SHGetFileInfo
		(
		L"\\\\",                   //随便传递两个字节
		FILE_ATTRIBUTE_NORMAL, 
		&sfi,
		sizeof(SHFILEINFO), 
		SHGFI_ICON | SHGFI_USEFILEATTRIBUTES | SHGFI_PIDL
		);
	m_hIcon = sfi.hIcon;

	WCHAR Temp[100] = {0};

	HIMAGELIST hImageList;
	// 加载系统图标列表
	hImageList = (HIMAGELIST)SHGetFileInfoW
		(
		Temp,
		FILE_ATTRIBUTE_NORMAL,
		&sfi,
		sizeof(SHFILEINFO),
		SHGFI_LARGEICON | SHGFI_SYSICONINDEX | SHGFI_PIDL
		);
	m_pImageList_Large.Attach(hImageList);

	// 加载系统图标列表
	hImageList = (HIMAGELIST)SHGetFileInfoW
		(
		Temp,
		FILE_ATTRIBUTE_NORMAL,
		&sfi,
		sizeof(SHFILEINFO),
		SHGFI_SMALLICON | SHGFI_SYSICONINDEX | SHGFI_PIDL
		);
	m_pImageList_Small.Attach(hImageList);

	m_wParent = pParent;
}

CFileDlg::~CFileDlg()
{
}

void CFileDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_FILELIST, m_fileList);
	DDX_Control(pDX, IDC_COMBOBOX_FILEPATH, m_filePath);
	DDX_Control(pDX, IDC_TREE_FILEDIRECTORY, m_dirTree);
}


BEGIN_MESSAGE_MAP(CFileDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
	ON_NOTIFY(NM_RCLICK, IDC_TREE_FILEDIRECTORY, &CFileDlg::OnRclickTreeFiledirectory)
END_MESSAGE_MAP()


// CFileDlg 消息处理程序


void CFileDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()
 
 	CRect   rect;
 	GetClientRect(rect);
// 	dc.FillSolidRect(rect,RGB(255,255,255));

	CClientDC aDC(this); //CClientDC的构造函数需要一个参数，这个参数是指向绘图窗口的指针，我们用this指针就可以了

	CPoint startPoint;
	CPoint endPoint;

	startPoint.x = -1;
	startPoint.y = 38;
	endPoint.x = rect.Width()+1;
	endPoint.y = 38;

	COLORREF m_Color(RGB(160,160,255));

	CPen pen(PS_SOLID,1,m_Color); ////建立一个画笔类对象，构造时设置画笔属性
	aDC.SelectObject(&pen);
	aDC.MoveTo(startPoint);
	aDC.LineTo(endPoint);

	startPoint.x = -1;
	startPoint.y = 40;
	endPoint.x = rect.Width()+1;
	endPoint.y = 40;

	COLORREF m_Color3(RGB(255,255,255));

	CPen pen3(PS_SOLID,2,m_Color3); ////建立一个画笔类对象，构造时设置画笔属性
	aDC.SelectObject(&pen3);
	aDC.MoveTo(startPoint);
	aDC.LineTo(endPoint);



	startPoint.x = 218;
	startPoint.y = 38;
	endPoint.x = 218;
	endPoint.y = rect.Height()+2;


	COLORREF m_Color2(RGB(190,190,190));

	CPen pen2(PS_SOLID,1,m_Color2);
	aDC.SelectObject(&pen2);
	aDC.MoveTo(startPoint);
	aDC.LineTo(endPoint);
}


BOOL CFileDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	//////////////////////////////////////////////////////////////////////////
	//主工具栏
	if (!m_wndToolBar.Create(this, WS_CHILD |
		WS_VISIBLE | CBRS_ALIGN_ANY | CBRS_TOOLTIPS | CBRS_FLYBY, IDR_TOOLBAR_FILETOOLBAR) 
		||!m_wndToolBar.LoadToolBar(IDR_TOOLBAR_FILETOOLBAR))
	{

		return -1;
	}
	m_wndToolBar.ModifyStyle(0, TBSTYLE_FLAT);    //Fix for WinXP
	m_wndToolBar.LoadTrueColorToolBar
		(
		24,    //加载真彩工具条 
		IDB_BITMAP_FILETOOLBAR,
		IDB_BITMAP_FILETOOLBAR,
		IDB_BITMAP_FILETOOLBAR
		);
	// 添加下拉按钮
	m_wndToolBar.AddDropDownButton(this, ID_BUTTON_FILE_VIEW, IDR_MENU_FILE_VIEW);

	m_wndToolBar.MoveWindow(0, 0, 300, 36);	//640
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//主工具栏
	if (!m_wndToolBar_goto.Create(this, WS_CHILD |
		WS_VISIBLE | CBRS_ALIGN_ANY | CBRS_TOOLTIPS | CBRS_FLYBY, IDR_TOOLBAR_FILETOOLBARGOTO) 
		||!m_wndToolBar_goto.LoadToolBar(IDR_TOOLBAR_FILETOOLBARGOTO))
	{

		return -1;
	}
	m_wndToolBar_goto.ModifyStyle(0, TBSTYLE_FLAT);    //Fix for WinXP
	m_wndToolBar_goto.LoadTrueColorToolBar
		(
		24,    //加载真彩工具条 
		IDB_BITMAP_FILETOOLBARGOTO,
		IDB_BITMAP_FILETOOLBARGOTO,
		IDB_BITMAP_FILETOOLBARGOTO
		);

	m_wndToolBar_goto.MoveWindow(829, 0, 300, 36);	//640
	//////////////////////////////////////////////////////////////////////////




	m_filePath.SendMessage(CB_SETITEMHEIGHT,-1,18); ///设置Combobox高度



	

 	// 为列表视图设置ImageList
 	m_fileList.SetImageList(&m_pImageList_Large, LVSIL_NORMAL);
 	m_fileList.SetImageList(&m_pImageList_Small, LVSIL_SMALL);



	m_dirTree.SetImageList(&m_pImageList_Small, LVSIL_NORMAL);


	CoInitialize(NULL);


	


	
	CloseHandle(CreateThread(NULL, 0, 
		(LPTHREAD_START_ROUTINE)HsLoadFileTreeList,this, 0, NULL));


	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CFileDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码
	if (bShow == TRUE)
	{
		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_FILE;

		((CHeavenShadowDlg*)m_wParent)->m_btnFile.EnableWindow(FALSE);

		HsSendStatusDetail(L"管理你的磁盘文件。");
		HsSendStatusTip(L"文件");

	}
}


BOOL CFileDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


// 初始化文件树和列表
void HsLoadFileTreeList(CFileDlg *cFleDlg)
{

	WCHAR* pDrive = NULL;

	HTREEITEM hRoot;     // 树的根节点的句柄   
	HTREEITEM hDriverItem; // 可表示任一磁盘节点的句柄   
	HTREEITEM hFolderItem;  // 可表示任一目录节点的句柄

	HIMAGELIST hImageListLarge = NULL;
	HIMAGELIST hImageListSmall = NULL;
	Shell_GetImageLists(&hImageListLarge, &hImageListSmall);
	ListView_SetImageList(cFleDlg->m_fileList.m_hWnd, hImageListLarge, LVSIL_NORMAL);
	ListView_SetImageList(cFleDlg->m_fileList.m_hWnd, hImageListSmall, LVSIL_SMALL);


	HsInitDriveList(&cFleDlg->m_fileList);


	cFleDlg->m_fileList.DeleteAllItems();
	cFleDlg->m_dirTree.DeleteAllItems();


	LPITEMIDLIST ppidl = {0};
	SHGetSpecialFolderLocation(NULL,CSIDL_DRIVES,&ppidl);
	//SHGetPathFromIDList(ppidl,TempPath);

	SHFILEINFO	sfi;

	SHGetFileInfoW
		(
		(LPCWSTR)ppidl,
		0, 
		&sfi,
		sizeof(SHFILEINFO), 
		SHGFI_SYSICONINDEX | SHGFI_PIDL 
		);

	hRoot = cFleDlg->m_dirTree.InsertItem(_T("计算机"),sfi.iIcon,sfi.iIcon,0,0);

	GetLogicalDriveStrings(sizeof(DriveString), DriveString);


	pDrive = DriveString;

	CString DriveName;

	WCHAR	FileSystem[MAX_PATH];
	unsigned __int64	HDAmount = 0;
	unsigned __int64	HDFreeSpace = 0;
	unsigned long		AmntMB = 0; // 总大小
	unsigned long		FreeMB = 0; // 剩余空间


	cFleDlg->m_dirTree.Expand(hRoot,TVE_EXPAND);

	for (int i = 0; *pDrive != '\0'; i++, pDrive += lstrlen(pDrive) + 1)
	{
		

		// 得到磁盘相关信息
		memset(FileSystem, 0, sizeof(FileSystem));
		// 得到文件系统信息及大小
		GetVolumeInformation(pDrive, NULL, 0, NULL, NULL, NULL, FileSystem, MAX_PATH);

		int	nFileSystemLen = lstrlen(FileSystem) + 1;
		if (GetDiskFreeSpaceEx(pDrive, (PULARGE_INTEGER)&HDFreeSpace, (PULARGE_INTEGER)&HDAmount, NULL))
		{	
			AmntMB = (ULONG)(HDAmount / 1024 / 1024);
			FreeMB = (ULONG)(HDFreeSpace / 1024 / 1024);
		}
		else
		{
			AmntMB = 0;
			FreeMB = 0;
		}

		//获得磁盘类别
		SHFILEINFO	sfi;
		SHGetFileInfo(pDrive, FILE_ATTRIBUTE_NORMAL, &sfi,sizeof(SHFILEINFO), SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES);

		DriveName = sfi.szTypeName;

		DriveName += L" (";
		DriveName += pDrive;

		DriveName.Delete(DriveName.GetLength()-1);

		DriveName += L")";

		

		int icon = GetIconIndex(pDrive,GetFileAttributes(pDrive));

		int	nItem = cFleDlg->m_fileList.InsertItem(i, DriveName, icon);		//插入列表框
		cFleDlg->m_fileList.SetItemData(nItem, (DWORD_PTR)pDrive);

		hDriverItem = cFleDlg->m_dirTree.InsertItem(DriveName,icon,icon,hRoot,0);	//插入树形列表
		cFleDlg->m_dirTree.SetItemData(hDriverItem, (DWORD_PTR)pDrive);

		cFleDlg->m_dirTree.Expand(hRoot,TVE_EXPAND);

		cFleDlg->m_fileList.SetItemText(nItem, 1, sfi.szTypeName);	//插入磁盘类别

		CString	str;
		str.Format(L"%10.1f GB", (float)AmntMB / 1024);
		cFleDlg->m_fileList.SetItemText(nItem, 2, str);
		str.Format(L"%10.1f GB", (float)FreeMB / 1024);
		cFleDlg->m_fileList.SetItemText(nItem, 3, str);
	}
	// 重置本地当前路径

	cFleDlg->m_filePath.ResetContent();




	cFleDlg->m_filePath.SetWindowTextW(L"计算机");

}





int GetIconIndex(LPCWSTR lpFileName, DWORD dwFileAttributes)
{
	SHFILEINFO	sfi;
	if (dwFileAttributes == INVALID_FILE_ATTRIBUTES)
		dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
	else
		dwFileAttributes |= FILE_ATTRIBUTE_NORMAL;

	SHGetFileInfo
		(
		lpFileName,
		dwFileAttributes, 
		&sfi,
		sizeof(SHFILEINFO), 
		SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES
		);

	return sfi.iIcon;
}

















void CFileDlg::OnRclickTreeFiledirectory(NMHDR *pNMHDR, LRESULT *pResult)
{
	// TODO: 在此添加控件通知处理程序代码

	// 选中当前右键点击的节点
	POINT pos ;
	if(!GetCursorPos(&pos))
		return ;
	m_dirTree.ScreenToClient(&pos);

	UINT uFlags;
	HTREEITEM hItem = m_dirTree.HitTest(pos, &uFlags);
	if ((hItem != NULL) && (TVHT_ONITEM & uFlags))
	{
		m_dirTree.Select(hItem, TVGN_CARET);
	}



// 	// 显示菜单
// 	CRect rect ;
// 	this->GetClientRect(&rect) ;
// 	ClientToScreen(&rect) ;
// 	m_dirTree.ClientToScreen(&pos);
// 
// 	int iCode= rect.PtInRect(pos) ;
// 
// 	CMenu m_Menu,*p_Menu=NULL ;
// 	if(iCode)
// 	{
// 		m_Menu.LoadMenu( IDR_MENU_REG) ; 
// 		p_Menu = (CMenu*) m_Menu.GetSubMenu(0);
// 		if( p_Menu != NULL)
// 			p_Menu->TrackPopupMenu( TPM_RIGHTBUTTON|TPM_LEFTALIGN, pos.x, pos.y, this);
// 		p_Menu = NULL;
// 		//mouse_event(MOUSEEVENTF_RIGHTUP, pos.x, pos.y, 0, NULL);
// 	}




	*pResult = 0;
}

```

`arkProject/HeavenShadow/HeavenShadow/FileDlg.h`:

```h
#pragma once
#include "afxcmn.h"
#include "afxshelltreectrl.h"

#include "MyList.h"
#include "TrueColorToolBar.h"

// CFileDlg 对话框

class CFileDlg : public CDialog
{
	DECLARE_DYNAMIC(CFileDlg)

public:
	CFileDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CFileDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_FILE };

	CTrueColorToolBar m_wndToolBar; //工具栏
	CTrueColorToolBar m_wndToolBar_goto; //工具栏

	CWnd* m_wParent;

	

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	CListCtrl m_fileList;
	CComboBoxEx m_filePath;
	CTreeCtrl m_dirTree;
	// 初始化文件树和列表

	afx_msg void OnRclickTreeFiledirectory(NMHDR *pNMHDR, LRESULT *pResult);
};



void HsLoadFileTreeList(CFileDlg *cFleDlg);
```

`arkProject/HeavenShadow/HeavenShadow/FileFunc.cpp`:

```cpp
#include "stdafx.h"
#include "FileFunc.h"
#include "Common.h"



COLUMNSTRUCT g_Column_Drive[] = 
{
	{	L"名称",			150	},
	{	L"类型",			150	},
	{	L"总大小",			150	},
	{	L"可用空间",		150	}
};

UINT g_Column_Drive_Count  = 4;	  //进程列表列数


COLUMNSTRUCT g_Column_File[] = 
{
	{	L"文件名称",		130	},
	{	L"大小",			100	},
	{	L"文件类型",		125	},
	{	L"创建时间",		125	},
	{	L"修改时间",		125	}
};

UINT g_Column_File_Count  = 5;	  //进程列表列数

extern int dpix;
extern int dpiy;


void HsInitDriveList(CListCtrl *m_ListCtrl)
{
	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	while(m_ListCtrl->DeleteColumn(0));

	UINT i;
	for (i = 0;i<g_Column_Drive_Count;i++)
	{
		if (i == 0 || i == 1)
		{
			m_ListCtrl->InsertColumn(i, g_Column_Drive[i].szTitle,LVCFMT_LEFT,(int)(g_Column_Drive[i].nWidth*(dpix/96.0)));
		}
		else
		{
			m_ListCtrl->InsertColumn(i, g_Column_Drive[i].szTitle,LVCFMT_RIGHT,(int)(g_Column_Drive[i].nWidth*(dpix/96.0)));
		}
		
	}
}





```

`arkProject/HeavenShadow/HeavenShadow/FileFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"




void HsInitDriveList(CListCtrl *m_ListCtrl);

int GetIconIndex(LPCWSTR lpFileName, DWORD dwFileAttributes);
```

`arkProject/HeavenShadow/HeavenShadow/FilterDriverFunc.cpp`:

```cpp
#include "stdafx.h"
#include "FilterDriverFunc.h"
#include "ProcessFunc.h"
#include "Common.h"
#include <vector>

#include "ProcessFunc.h"

using namespace std;


vector<FILTER_INFO> m_FilterInfor;
extern HANDLE g_hDevice;
extern WIN_VERSION WinVersion;
extern BOOL bIsChecking;

COLUMNSTRUCT g_Column_FilterDriver[] = 
{
	{	L"类型",					80	},
	{	L"过滤设备对象",			125	},
	{	L"过滤驱动名称",			125	},
	{	L"宿主驱动名称",			125	},
	{	L"所属驱动路径",			220	},
	{	L"出品厂商",				125	}
};

WCHAR szFilterType[][260] = {
	L"Unkonw",
	L"File",
	L"Disk",
	L"Volume",
	L"Keyboard",
	L"Mouse",
	L"I8042prt",
	L"Tcpip",
	L"NDIS",
	L"PnpManager"
	L"Tdx",
	L"RAW"
};


UINT g_Column_FilterDriver_Count = 6;

extern int dpix;
extern int dpiy;


VOID HsInitFilterDriverList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_FilterDriver_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_FilterDriver[i].szTitle,LVCFMT_LEFT,(int)(g_Column_FilterDriver[i].nWidth*(dpix/96.0)));
	}
}



VOID HsLoadFilterDriverList(CListCtrl *m_ListCtrl)
{
	if (bIsChecking == TRUE)
	{
		return;
	}

	// 	while(bIsChecking == TRUE)
	// 	{
	// 		Sleep(10);
	// 	}

	bIsChecking = TRUE;

	HsSendStatusDetail(L"过滤驱动正在加载...");
	HsSendStatusTip(L"过滤驱动");

	HsQueryFilterDriverList(m_ListCtrl);

	bIsChecking = FALSE;
}



VOID HsQueryFilterDriverList(CListCtrl *m_ListCtrl)
{
	ULONG_PTR ulCnt = 100;
	PFILTER_DRIVER FilterDriver = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	m_ListCtrl->DeleteAllItems();
	m_FilterInfor.clear();

	do 
	{
		ULONG_PTR ulSize = sizeof(FILTER_DRIVER) + ulCnt * sizeof(FILTER_INFO);

		if (FilterDriver)
		{
			free(FilterDriver);
			FilterDriver = NULL;
		}

		FilterDriver = (PFILTER_DRIVER)malloc(ulSize);

		if (FilterDriver)
		{
			memset(FilterDriver, 0, ulSize);
			FilterDriver->ulCnt = ulCnt;		

			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_FILTERDRIVER),
				NULL,
				0,
				FilterDriver,
				(DWORD)ulSize,
				&ulReturnSize,
				NULL);
		}

		ulCnt =FilterDriver->ulCnt + 10;

	} while (!bRet && FilterDriver->ulRetCnt > FilterDriver->ulCnt);

	if (bRet &&
		FilterDriver->ulCnt >= FilterDriver->ulRetCnt)
	{
		for (ULONG i = 0; i < FilterDriver->ulRetCnt; i++)
		{
			m_FilterInfor.push_back(FilterDriver->Filter[i]);
		}
	}

	if (FilterDriver)
	{
		free(FilterDriver);
		FilterDriver = NULL;
	}

	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"过滤驱动加载失败。");

		return;
	}

	HsInsertFilterDriverItem(m_ListCtrl);
}



void HsInsertFilterDriverItem(CListCtrl* m_ListCtrl)
{
	ULONG_PTR ulFilterDriver = 0;

	for (vector<FILTER_INFO>::iterator itor = m_FilterInfor.begin(); itor != m_FilterInfor.end(); itor++)
	{
		CString strFileterDeviceObject, strType;


		switch(itor->Type)
		{
		case Disk:
			{
				CString strTemp("Disk");
				strType = strTemp;
				break;
			}
		case Volume:
			{
				CString strTemp("Volume");
				strType = strTemp;
				break;
			}
		case File:
			{
				CString strTemp("File");
				strType = strTemp;
				break;
			}
		case Keyboard:
			{
				CString strTemp("Keyboard");
				strType = strTemp;
				break;
			}
		case Mouse:
			{
				CString strTemp("Mouse");
				strType = strTemp;
				break;
			}
		case I8042prt:
			{
				CString strTemp("I8042prt");
				strType = strTemp;
				break;
			}
		case Tcpip:
			{
				CString strTemp("TCP/IP");
				strType = strTemp;
				break;
			}
		case NDIS:
			{
				CString strTemp("NDIS");
				strType = strTemp;
				break;
			}
		case PnpManager:
			{
				CString strTemp("PnpManager");
				strType = strTemp;
				break;
			}
		case Tdx:
			{
				CString strTemp("Tdx");
				strType = strTemp;
				break;
			}
		case RAW:
			{
				CString strTemp("RAW");
				strType = strTemp;
				break;
			}
		default:
			{
				CString strTemp("Unknow");
				strType = strTemp;
				break;
			}
		}


		int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strType);
		strFileterDeviceObject.Format(L"0x%08p", itor->FileterDeviceObject);
		m_ListCtrl->SetItemText(n, 1, strFileterDeviceObject);
		CString strFilterDriverName(itor->wzFilterDriverName);
		m_ListCtrl->SetItemText(n, 2, strFilterDriverName);

		CString strAttachedDriverName(itor->wzAttachedDriverName);
		m_ListCtrl->SetItemText(n, 3, strAttachedDriverName);

		CString strPath(itor->wzPath);
		if (wcsstr(strPath,L"SystemRoot")!=NULL)
		{
			WCHAR wzTempDir[260] = {0};
			GetEnvironmentVariableW(L"windir",wzTempDir,MAX_PATH);
			WCHAR* Temp = strPath.LockBuffer()+wcslen(L"\\SystemRoot");
			if (wzTempDir[lstrlen(wzTempDir)-1]=='\\')
			{
				Temp = Temp + 1;
			}
			wcscat_s(wzTempDir,Temp);
			strPath.UnlockBuffer();
			strPath = wzTempDir;
		}
		else if (wcsstr(strPath,L"\\??\\")!=NULL)
		{
			WCHAR* Temp = strPath.LockBuffer()+wcslen(L"\\??\\");
			strPath = Temp;
		}
		m_ListCtrl->SetItemText(n, 4, strPath);

		CString strFileCorp = HsGetFileCompanyName(strPath);

		m_ListCtrl->SetItemText(n, 5, strFileCorp);

		ulFilterDriver++;

		CString StatusBarContext;
		StatusBarContext.Format(L"过滤驱动正在加载。 驱动数：%d",ulFilterDriver);
		HsSendStatusDetail(StatusBarContext);
	}

	CString StatusBarContext;
	StatusBarContext.Format(L"过滤驱动加载完成。 驱动数：%d",ulFilterDriver);
	HsSendStatusDetail(StatusBarContext);

}


VOID HsRemoveFilterDriverItem(CListCtrl* m_ListCtrl)
{
	UNLOAD_FILTER UnloadFilter;

	int Index = m_ListCtrl->GetSelectionMark();

	if (Index<0)
	{
		return;
	}

	CString Temp = m_ListCtrl->GetItemText(Index,1);

	swscanf_s(Temp.GetBuffer()+2,L"%p",&UnloadFilter.DeviceObject);

	Temp = m_ListCtrl->GetItemText(Index,0);

	int nFilterType = 0;

	for (nFilterType = 0; nFilterType < 10; nFilterType++)
	{
		if (_wcsicmp(szFilterType[nFilterType],Temp)==0)
		{
			break;
		}
	}

	UnloadFilter.Type = (FILTER_TYPE)nFilterType;
	

	BOOL dwRet = FALSE;

	DWORD dwReturnSize = 0;
	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_FILTERUNLOAD),
		&UnloadFilter,
		sizeof(UNLOAD_FILTER),
		NULL,
		0,
		&dwReturnSize,
		NULL);

	if (dwRet)
	{
		HsQueryFilterDriverList(m_ListCtrl);
	}

	bIsChecking = FALSE;
}



```

`arkProject/HeavenShadow/HeavenShadow/FilterDriverFunc.h`:

```h
#pragma once
#include "stdafx.h"


typedef enum _FILTER_TYPE_
{
	Unkonw,
	File,
	Disk,
	Volume,
	Keyboard,
	Mouse,
	I8042prt,
	Tcpip,
	NDIS,
	PnpManager,
	Tdx,
	RAW
}FILTER_TYPE;

typedef struct _FILTER_INFO_
{
	FILTER_TYPE Type;
	ULONG_PTR FileterDeviceObject;
	WCHAR wzFilterDriverName[100];
	WCHAR wzAttachedDriverName[100];
	WCHAR wzPath[MAX_PATH];
}FILTER_INFO, *PFILTER_INFO;

typedef struct _FILTER_DRIVER_
{
	ULONG_PTR ulCnt;
	ULONG_PTR ulRetCnt;
	FILTER_INFO Filter[1];
}FILTER_DRIVER, *PFILTER_DRIVER;

typedef struct _UNLOAD_FILTER_
{
	FILTER_TYPE Type;
	ULONG_PTR   DeviceObject;
}UNLOAD_FILTER, *PUNLOAD_FILTER;


VOID HsInitFilterDriverList(CListCtrl *m_ListCtrl);

VOID HsLoadFilterDriverList(CListCtrl *m_ListCtrl);

VOID HsQueryFilterDriverList(CListCtrl *m_ListCtrl);

void HsInsertFilterDriverItem(CListCtrl* m_ListCtrl);

VOID HsRemoveFilterDriverItem(CListCtrl* m_ListCtrl);







```

`arkProject/HeavenShadow/HeavenShadow/HandleFunc.cpp`:

```cpp
#include "stdafx.h"
#include "HandleFunc.h"
#include "Common.h"

#include "resource.h"


extern ULONG_PTR g_ulProcessId;
extern HANDLE g_hDevice;

vector<HANDLE_INFO> m_HandleVector;

COLUMNSTRUCT g_Column_ProcessHandle[] = 
{
	{	L"句柄",					60	},
	{	L"句柄名称",				205	},
	{	L"句柄对象",				130	},
	{	L"句柄类型",				125	},
	{	L"引用计数",				70	}
};


enum HS_HANDLE_COLUMN
{
	HS_HANDLE_COLUMN_HANDLEVALUE,
	HS_HANDLE_COLUMN_OBJECTNAME,
	HS_HANDLE_COLUMN_OBJECT,
	HS_HANDLE_COLUMN_TYPENAME,
	HS_HANDLE_COLUMN_HANDLECOUNT
};

UINT g_Column_ProcessHandle_Count  = 5;	  //进程列表列数

extern int dpix;
extern int dpiy;


VOID HsInitProcessHandleList(CMyList *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_ProcessHandle_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_ProcessHandle[i].szTitle,LVCFMT_LEFT,(int)(g_Column_ProcessHandle[i].nWidth*(dpix/96.0)));
	}
}




VOID HsQueryProcessHandle(CMyList *m_ListCtrl)
{
	ULONG_PTR  ProcessID = g_ulProcessId;

	if (ProcessID <= 4)
	{
		return;
	}

	m_ListCtrl->DeleteAllItems();
	m_HandleVector.clear();

	BOOL bOk = FALSE;

	ULONG_PTR ulCount = 0x1000;
	PALL_HANDLES Handles= NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	do 
	{
		ULONG_PTR ulSize = 0;

		if (Handles)
		{
			free(Handles);
			Handles = NULL;
		}

		ulSize = sizeof(ALL_HANDLES) + ulCount * sizeof(HANDLE_INFO);

		Handles = (PALL_HANDLES)malloc(ulSize);
		if (!Handles)
		{
			break;
		}

		memset(Handles,0,ulSize);


		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSHANDLE),
			&ProcessID,
			sizeof(ULONG),
			Handles,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);


		ulCount = Handles->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && Handles)
	{
		for (ULONG i = 0; i < Handles->ulCount; i++)
		{
			m_HandleVector.push_back(Handles->Handles[i]);
		}

		bOk = TRUE;
	}

	if (Handles)
	{
		free(Handles);
		Handles = NULL;
	}

	if (m_HandleVector.empty())
	{
		return;
	}

	for (vector <HANDLE_INFO>::iterator Iter = m_HandleVector.begin( ); 
		Iter != m_HandleVector.end( ); 
		Iter++ )
	{
		CString strHandle, strObject, strReferenceCount;

		strHandle.Format(L"0x%04X", ((HANDLE_INFO)*Iter).Handle);
		strObject.Format(L"0x%08p", ((HANDLE_INFO)*Iter).Object);
		strReferenceCount.Format(L"%d", ((HANDLE_INFO)*Iter).ReferenceCount);

		int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strHandle);
		m_ListCtrl->SetItemText(n, 1, ((HANDLE_INFO)*Iter).HandleName);
		m_ListCtrl->SetItemText(n, 2, strObject);
		m_ListCtrl->SetItemText(n, 3, ((HANDLE_INFO)*Iter).ObjectName);
		m_ListCtrl->SetItemText(n, 4, strReferenceCount);
	}

// 	ULONG dwReturnSize = 0;
// 	ULONG dwRet = 0;
// 
// 	ULONG nSize = 0x100000;
// 
// 	PHSHANDLE pHandleInfo = NULL;
// 
// 	if (ProcessID == 0)
// 	{
// 		return;
// 	}
// 
// 
// 	pHandleInfo = (PHSHANDLE)VirtualAlloc(0, nSize,MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
// 
// 	ZeroMemory(pHandleInfo,nSize);
// 
// 
// 	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSHANDLE),
// 		&ProcessID,
// 		sizeof(ULONG_PTR),
// 		pHandleInfo,
// 		nSize,
// 		&dwReturnSize,
// 		NULL);
// 
// 	if (dwRet == 0)
// 	{
// 		return;
// 	}
// 
// 	for (int i = 0; i < (int)pHandleInfo->NumberOfHandles; i++)
// 	{
// 		CString Temp;
// 		Temp.Format(L"0x%08X",pHandleInfo->Handles[i].HandleValue);
// 		m_ListCtrl->InsertItem(i,Temp);
// 		Temp.Empty();
// 
// 		Temp.Format(L"0x%p",pHandleInfo->Handles[i].Object);
// 		m_ListCtrl->SetItemText(i,HS_HANDLE_COLUMN_OBJECT,Temp);
// 		Temp.Empty();
// 
// 		Temp.Format(L"%d",pHandleInfo->Handles[i].ObjectTypeIndex);
// 		m_ListCtrl->SetItemText(i,HS_HANDLE_COLUMN_TYPEINDEX,Temp);
// 		Temp.Empty();
// 	}
}
```

`arkProject/HeavenShadow/HeavenShadow/HandleFunc.h`:

```h
#pragma once
#include "stdafx.h"
#include <vector>
#include <afxtempl.h>
#include "MyList.h"
using namespace std;

#include "ProcessFunc.h"



#define MAX_OBJECT_NAME  50
#define MAX_PATH2        500


typedef struct _HANDLE_INFO_
{
	ULONG_PTR Handle;
	ULONG_PTR Object;
	ULONG_PTR ReferenceCount;
	WCHAR ObjectName[MAX_OBJECT_NAME];
	WCHAR HandleName[MAX_PATH2];
}HANDLE_INFO, *PHANDLE_INFO;

typedef struct _PROCESS_HANDLES_
{
	ULONG_PTR ulCount;
	HANDLE_INFO Handles[1];
}ALL_HANDLES, *PALL_HANDLES;




VOID HsInitProcessHandleList(CMyList *m_ListCtrl);

VOID HsQueryProcessHandle(CMyList *m_ListCtrl);

```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadow.cpp`:

```cpp

// HeavenShadow.cpp : 定义应用程序的类行为。
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "HeavenShadowDlg.h"


//////////////////////////////////////////////////////////////////////////
#include "LoadSys.h"

#include "WzdSplash.h"

#define HS_ONLY_ONE_PROCESS L"HS_ONLY_ONE_PROCESS"

extern HANDLE g_hDevice;
BOOL bDriverIsOK = FALSE;
//////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CHeavenShadowApp

BEGIN_MESSAGE_MAP(CHeavenShadowApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CHeavenShadowApp 构造

CHeavenShadowApp::CHeavenShadowApp()
{
	// 支持重新启动管理器
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: 在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的一个 CHeavenShadowApp 对象

CHeavenShadowApp theApp;


// CHeavenShadowApp 初始化

BOOL CHeavenShadowApp::InitInstance()
{
	//////////////////////////////////////////////////////////////////////////


	HANDLE hMutex = ::CreateMutexW(NULL,TRUE,HS_ONLY_ONE_PROCESS);
	if (GetLastError() == ERROR_ALREADY_EXISTS)
	{
		::MessageBox(
			NULL,
			L"您已经运行了天影卫士！",
			L"天影卫士",
			0
			);	//弹出对话框确认不能运行第二个实例。

		CloseHandle(hMutex);
		ExitProcess(0);
	}

	if (HsIs64BitWindows() == TRUE && sizeof(ULONG_PTR) == sizeof(ULONG32))
	{
		::MessageBox(
			NULL,
			L"您在使用 64 位的 Windows 操作系统。运行天影卫士 32 位版\r\n可能会造成不可预料的后果。敬请选择天影卫士 64 位版。",
			L"天影卫士",
			0
			);
		ExitProcess(0);
	}

	//////////////////显示Splash，2010-10-15///////////////////////////////////
	CWzdSplash wndSplash;                 //创建启动窗口类的实例
	wndSplash.Create(IDB_BITMAP_WZDSPLASH);
	wndSplash.CenterWindow();
	wndSplash.UpdateWindow();          //send WM_PAINT


	//////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////

	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T("天影卫士"));


	//////////////////////////////////////////////////////////////////////////

	// 	WCHAR *Temp = AfxGetApp()->m_lpCmdLine;
	// 
	// 	BOOL bIsHideWnd = FALSE;
	// 
	// 	if (wcslen(Temp))
	// 	{
	// 		WCHAR* p = Temp;
	// 
	// 		for (int i = 0; i< wcslen(Temp); i++)
	// 		{
	// 			if (_wcsnicmp(p,L"-HideWnd",wcslen(L"-HideWnd"))==0)
	// 			{
	// 				bIsHideWnd = TRUE;
	// 			}
	// 			p++;
	// 		}
	// 	}

	// 	CHeavenShadowDlg* dlg = new CHeavenShadowDlg();
	// 
	// 	m_pMainWnd = dlg;
	// 
	// 	INT_PTR nResponse = dlg->Create(IDD_HEAVENSHADOW_DIALOG);
	// 
	// 	dlg->ShowWindow(SW_HIDE);
	// 
	// 	return FALSE;


	//////////////////////////////////////////////////////////////////////////

	//加载驱动
	//ExtractFile();
	//////////////////////////////////////////////////////////////////////////
	WCHAR wzSysPath[260] = {0};
	WCHAR *p;
	CString SysPath;
	HMODULE module = GetModuleHandle(0);
	GetModuleFileName(module,wzSysPath,sizeof(wzSysPath));
	p = wcsrchr(wzSysPath,L'\\');
	*p = 0;
	SysPath = wzSysPath;
	if (HsIs64BitWindows()) 
		SysPath += L"\\sys\\x64\\HeavenShadowDrv.sys";
	else 
		SysPath += L"\\sys\\x86\\HeavenShadowDrv.sys";

	HsLoadNTDriver(HS_DRIVER_NAME,SysPath.GetBuffer());
	//////////////////////////////////////////////////////////////////////////


	g_hDevice = CreateFileW(HS_LINK_NAME,
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL );


	if (g_hDevice != INVALID_HANDLE_VALUE)
	{
		ULONG_PTR ulCurrentPid = GetCurrentProcessId();
		ULONG_PTR ulRetCode = 0;
		DWORD dwReturnSize = 0;

		BOOL dwRet = DeviceIoControl(g_hDevice,
			HS_IOCTL(HS_IOCTL_PROC_SENDSELFPID),
			&ulCurrentPid,
			sizeof(ULONG_PTR),
			&ulRetCode,
			sizeof(ULONG_PTR),
			&dwReturnSize,
			NULL);

		if (dwRet && ulRetCode)
		{
			bDriverIsOK = TRUE;
		}
	}

	//////////////////////////////////////////////////////////////////////////

	
	



	CHeavenShadowDlg dlg;
	m_pMainWnd = &dlg;
	wndSplash.DestroyWindow();
	INT_PTR nResponse = dlg.DoModal();


	//////////////////////////////////////////////////////////////////////////

	CloseHandle(hMutex);

	CloseHandle(g_hDevice);

	HsUnloadNTDriver(HS_DRIVER_NAME);	//卸载驱动
	
	//////////////////////////////////////////////////////////////////////////


	if (nResponse == IDOK)
	{
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	}

	// 删除上面创建的 shell 管理器。
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}
 
// 	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
// 	//  而不是启动应用程序的消息泵。
 	return FALSE;
}


```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadow.h`:

```h

// HeavenShadow.h : PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
	#error "在包含此文件之前包含“stdafx.h”以生成 PCH 文件"
#endif

#include "resource.h"		// 主符号


// CHeavenShadowApp:
// 有关此类的实现，请参阅 HeavenShadow.cpp
//

class CHeavenShadowApp : public CWinApp
{
public:
	CHeavenShadowApp();

// 重写
public:
	virtual BOOL InitInstance();

// 实现

	DECLARE_MESSAGE_MAP()
};

extern CHeavenShadowApp theApp;



```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadow.idc`:

```idc
<Configurations active="默认"><Configuration name="默认"><GuestCommandRemote val="project command through a shared folder"></GuestCommandRemote><ShareFoldersRemote val="共享文件夹=E:\"></ShareFoldersRemote><RemoteDebugMonitor val="D:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\IDE\Remote Debugger\x86\msvsmon.exe"></RemoteDebugMonitor><MonitorName val="VMDebug"></MonitorName><RemoteVM val="U:\虚拟机\开发\Windows 7 X64\Windows 7 x64.vmx"></RemoteVM><StartMode val="No"></StartMode><TerminationModeRemote val="No operation"></TerminationModeRemote><CopyFilesRemote val=""></CopyFilesRemote><PreRemoteCommandLine val=""></PreRemoteCommandLine><PostRemoteCommandLine val=""></PostRemoteCommandLine><RecordingToReplay val=""></RecordingToReplay><ReplayVM val=""></ReplayVM><BaseSnapshotForRecording val=""></BaseSnapshotForRecording><CopyFilesRecord val=""></CopyFilesRecord><PreRecordCommandLine val=""></PreRecordCommandLine><PostRecordCommandLine val=""></PostRecordCommandLine><TerminationModeRecord val="No operation"></TerminationModeRecord><InstanceToDebug val=""></InstanceToDebug><GuestCommandReplay val="project command through a shared folder"></GuestCommandReplay><ShareFoldersRecord val=""></ShareFoldersRecord><RemoteReplayFlag val=""></RemoteReplayFlag><RemoteMachine val=""></RemoteMachine><RemoteReplayVM val=""></RemoteReplayVM><RemoteRecordingToReplay val=""></RemoteRecordingToReplay><RemoteReplayPasscode val=""></RemoteReplayPasscode><HostSearchPath val=""></HostSearchPath></Configuration></Configurations>

```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadow.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\HeavenShadow.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\HeavenShadow.ico"
IDI_ICON_LITTLE         ICON                    "res\\HeavenShadowLittle.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 天影卫士"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "天影卫士 HeavenShadow，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2014",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_HEAVENSHADOW_DIALOG DIALOGEX 0, 0, 499, 298
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CAPTION "天影卫士 Technical Preview"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_TAB_MAIN,"SysTabControl32",0x0,0,55,498,242
    CONTROL         145,IDC_STATIC_MODULE,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,80,0,40,54
    CONTROL         146,IDC_STATIC_SERVICE,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,200,0,40,54
    CONTROL         144,IDC_STATIC_PROCESS,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,40,0,40,54
    CONTROL         152,IDC_STATIC_LOGO,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,0,0,40,54
    CONTROL         164,IDC_STATIC_FILE,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,240,0,40,54
    CONTROL         191,IDC_STATIC_SYSTEM,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,120,0,40,54
    CONTROL         193,IDC_STATIC_SETTING,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,320,0,40,54
    CONTROL         196,IDC_STATIC_TOOLS,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,280,0,40,54
    CONTROL         198,IDC_STATIC_MANMENUBTN,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,482,4,11,11
    CONTROL         204,IDC_STATIC_KERNEL,"Static",SS_BITMAP | SS_NOTIFY | WS_TABSTOP,160,0,40,54
END

IDD_DIALOG_PROCESS DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
EXSTYLE WS_EX_TRANSPARENT
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST_PROCESSLIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | WS_TABSTOP,0,0,437,220
END

IDD_DIALOG_SERVICE DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    PUSHBUTTON      "服务",IDC_BUTTON_TEST2,42,26,50,45,BS_ICON
END

IDD_DIALOG_MODULE DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST_MODULELIST,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | WS_TABSTOP,0,0,310,197
END

IDD_DIALOG_ABOUT DIALOGEX 0, 0, 580, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         137,IDC_STATIC,"Static",SS_BITMAP | NOT WS_VISIBLE,5,5,153,58
    CONTROL         206,IDC_STATIC_CHECK_ALT,"Static",SS_BITMAP,443,39,11,10
    LTEXT           "程序与内核层通讯",IDC_TEXT_CHECK_ALT,457,40,107,8
    CONTROL         206,IDC_STATIC_SYS_BIT,"Static",SS_BITMAP,443,24,11,10
    LTEXT           "操作系统位数版本",IDC_TEXT_SYS_BIT,457,25,107,8
    CONTROL         206,IDC_STATIC_SOFT_BIT,"Static",SS_BITMAP,443,9,11,10
    LTEXT           "天影卫士程序位数",IDC_TEXT_SOFT_BIT,457,10,107,8
    CONTROL         208,IDC_STATIC_HOMECHECK,"Static",SS_BITMAP | SS_NOTIFY,175,80,87,80
END

IDD_DIALOG_ALERT DIALOGEX 0, 0, 153, 115
STYLE DS_SYSMODAL | DS_SETFONT | DS_NOIDLEMSG | DS_SETFOREGROUND | DS_FIXEDSYS | WS_POPUP
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    LTEXT           "天影卫士",IDC_STATIC_ALERT_TITLE,7,4,48,8
    LTEXT           "检测到可疑进程“MySpy.exe”正在试图访问系统文件。允许此操作可能会造成您的计算机数据的损失。是否阻止？",IDC_STATIC_ALERT_CONTEXT,7,20,138,41
    LTEXT           "将执行阻止操作： 17 秒",IDC_STATIC_TIMERTIP,7,66,138,8
    CONTROL         163,IDC_STATIC_BTN_PREVENT,"Static",SS_BITMAP | SS_NOTIFY,7,82,67,16
    CONTROL         162,IDC_STATIC_BTN_ALLOW,"Static",SS_BITMAP | SS_NOTIFY,78,82,67,16
END

IDD_DIALOG_PROCESS_VIEW DIALOGEX 0, 0, 463, 241
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST_PROCESS_VIEW,"SysListView32",LVS_REPORT | LVS_SINGLESEL | LVS_ALIGNLEFT | WS_TABSTOP,51,0,412,241
    LISTBOX         IDC_LIST_PROCESSVIEWTYPE,1,1,47,83,LBS_SORT | LBS_NOINTEGRALHEIGHT | NOT WS_BORDER | WS_VSCROLL | WS_TABSTOP
    ICON            IDI_ICON_LITTLE,IDC_STATIC_VIEWICON,13,209,20,20
END

IDD_DIALOG_FILE DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_LIST_FILELIST,"SysListView32",LVS_REPORT | WS_TABSTOP,146,24,334,147
    CONTROL         "",IDC_COMBOBOX_FILEPATH,"ComboBoxEx32",CBS_DROPDOWN | CBS_SORT | WS_VSCROLL | WS_TABSTOP,152,4,304,30
    CONTROL         "",IDC_TREE_FILEDIRECTORY,"SysTreeView32",TVS_HASLINES | TVS_SHOWSELALWAYS | WS_HSCROLL | WS_TABSTOP,0,25,145,146
END

IDD_DIALOG_SYSTEM DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    LISTBOX         IDC_LIST_SYSTEM,1,1,78,186,LBS_SORT | LBS_NOINTEGRALHEIGHT | NOT WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL         "",IDC_LIST_SYSTEM_CTRL,"SysListView32",LVS_REPORT | LVS_SINGLESEL | WS_TABSTOP,81,0,317,171
END

IDD_DIALOG_SETTING DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
END

IDD_DIALOG_TOOLS DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
END

IDD_DIALOG_KERNEL DIALOGEX 0, 0, 497, 271
STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_SYSMENU
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    LISTBOX         IDC_LIST_KERNEL,1,1,78,186,LBS_SORT | LBS_NOINTEGRALHEIGHT | NOT WS_BORDER | WS_VSCROLL | WS_TABSTOP
    CONTROL         "",IDC_LIST_KERNEL_CTRL,"SysListView32",LVS_REPORT | LVS_SINGLESEL | WS_TABSTOP,81,0,317,171
    LISTBOX         IDC_LIST_KRNLNAME,1,189,72,82,LBS_SORT | LBS_NOINTEGRALHEIGHT | NOT WS_VISIBLE | NOT WS_BORDER | WS_VSCROLL | WS_TABSTOP
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,2
 PRODUCTVERSION 1,0,0,2
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404b0"
        BEGIN
            VALUE "CompanyName", "HS GROUP."
            VALUE "FileDescription", "天影卫士"
            VALUE "FileVersion", "1.0.0.2"
            VALUE "InternalName", "HeavenShadow.exe"
            VALUE "LegalCopyright", "HS GROUP (C) 2014。保留所有权利。"
            VALUE "OriginalFilename", "HeavenShadow.exe"
            VALUE "ProductName", "天影卫士"
            VALUE "ProductVersion", "1.0.0.2"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_HEAVENSHADOW_DIALOG, DIALOG
    BEGIN
        RIGHTMARGIN, 498
        BOTTOMMARGIN, 297
    END

    IDD_DIALOG_PROCESS, DIALOG
    BEGIN
        BOTTOMMARGIN, 270
    END

    IDD_DIALOG_SERVICE, DIALOG
    BEGIN
    END

    IDD_DIALOG_MODULE, DIALOG
    BEGIN
    END

    IDD_DIALOG_ABOUT, DIALOG
    BEGIN
    END

    IDD_DIALOG_ALERT, DIALOG
    BEGIN
    END

    IDD_DIALOG_PROCESS_VIEW, DIALOG
    BEGIN
    END

    IDD_DIALOG_FILE, DIALOG
    BEGIN
    END

    IDD_DIALOG_SYSTEM, DIALOG
    BEGIN
    END

    IDD_DIALOG_SETTING, DIALOG
    BEGIN
    END

    IDD_DIALOG_TOOLS, DIALOG
    BEGIN
    END

    IDD_DIALOG_KERNEL, DIALOG
    BEGIN
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDB_BITMAP_LOGO         BITMAP                  "res\\LOGO.bmp"
IDB_BITMAP_PROCESS      BITMAP                  "res\\toolbar_process.bmp"
IDB_BITMAP_MODULE       BITMAP                  "res\\toolbar_module.bmp"
IDB_BITMAP_SERVICE      BITMAP                  "res\\toolbar_service.bmp"
IDB_BITMAP_PROCESS_NOW  BITMAP                  "res\\toolbar_process_now.bmp"
IDB_BITMAP_MODULE_NOW   BITMAP                  "res\\toolbar_module_now.bmp"
IDB_BITMAP_SERVICE_NOW  BITMAP                  "res\\toolbar_service_now.bmp"
IDB_BITMAP_LOGOBAR      BITMAP                  "res\\toolbar_logo.bmp"
IDB_BITMAP_LOGOBAR_NOW  BITMAP                  "res\\toolbar_logo_now.bmp"
IDB_BITMAP_ALERTBTNEXIT BITMAP                  "res\\alert_btnexit.bmp"
IDB_BITMAP_BTN_ALLOW    BITMAP                  "res\\alert_btn_allow.bmp"
IDB_BITMAP_BTN_PREVENT  BITMAP                  "res\\alert_btn_prevent.bmp"
IDB_BITMAP_FILE         BITMAP                  "res\\toolbar_file.bmp"
IDB_BITMAP_FILE_NOW     BITMAP                  "res\\toolbar_file_now.bmp"
IDB_BITMAP_FILETOOLBAR  BITMAP                  "res\\file_toolbar.bmp"
IDR_TOOLBAR_FILETOOLBAR BITMAP                  "res\\toolbar1.bmp"
IDB_BITMAP_FILETOOLBARGOTO BITMAP                  "res\\file_toolbar_goto.bmp"
IDR_TOOLBAR_FILETOOLBARGOTO BITMAP                  "res\\bmp00001.bmp"
IDB_BITMAP_BTN_ALLOW_C  BITMAP                  "res\\alert_btn_allow_clicked.bmp"
IDB_BITMAP_BTN_PREVENT_C BITMAP                  "res\\alert_btn_prevent_clicked.bmp"
IDB_BITMAP_SYSTEM       BITMAP                  "res\\toolbar_system.bmp"
IDB_BITMAP_SYSTEM_NOW   BITMAP                  "res\\toolbar_system_now.bmp"
IDB_BITMAP_SETTING      BITMAP                  "res\\toolbar_setting.bmp"
IDB_BITMAP_SETTING_NOW  BITMAP                  "res\\toolbar_setting_now.bmp"
IDB_BITMAP_TOOLS        BITMAP                  "res\\toolbar_tools.bmp"
IDB_BITMAP_TOOLS_NOW    BITMAP                  "res\\toolbar_tools_now.bmp"
IDB_BITMAP_MAINMENU_BTN BITMAP                  "res\\mainmenu_button.bmp"
IDB_BITMAP_KERNEL       BITMAP                  "res\\toolbar_kernel.bmp"
IDB_BITMAP_KERNEL_NOW   BITMAP                  "res\\toolbar_kernel_now.bmp"
IDB_BITMAP_CHECK_ALT_V  BITMAP                  "res\\check_alt_v.bmp"
IDB_BITMAP_CHECK_ALT_X  BITMAP                  "res\\check_alt_x.bmp"
IDB_BITMAP_HOMECHECK_BTN BITMAP                  "res\\HomeCheckBtn.bmp"
IDB_BITMAP_HOMECHECK_BTN_HOVER BITMAP                  "res\\HomeCheckBtn_hover.bmp"
IDB_BITMAP_HOMECHECK_BTN_CLICK BITMAP                  "res\\HomeCheckBtn_click.bmp"
IDB_BITMAP_WZDSPLASH    BITMAP                  "res\\WzdSplash.bmp"

/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU_MAIN MENU
BEGIN
    POPUP "主菜单"
    BEGIN
        MENUITEM "设置(&S)...",                   ID_MENU_MAIN_SETTING
        MENUITEM SEPARATOR
        MENUITEM "退出(&X)",                      ID_MENU_EXIT
    END
END

IDR_MENU_PROCESS MENU
BEGIN
    POPUP "进程"
    BEGIN
        MENUITEM "打开文件位置(&O)",                  ID_MENU_PROCESS_LOCATIONFILE
        MENUITEM SEPARATOR
        POPUP "查看进程信息(&V)"
        BEGIN
            MENUITEM "查看进程映像(&D)",                  ID_MENU_PROCESS_DETAIL
            MENUITEM SEPARATOR
            MENUITEM "查看进程线程(&T)",                  ID_MENU_PROCESS_PROCESSTHREAD
            MENUITEM "查看进程权限(&P)",                  ID_MENU_PROCESS_PROCESSPRIVILEGE
            MENUITEM "查看进程句柄(&H)",                  ID_MENU_PROCESS_PROCESSHANDLE
            MENUITEM "查看进程窗口(&W)",                  ID_MENU_PROCESS_PROCESSWINDOW
            MENUITEM "查看进程模块(&D)",                  ID_MENU_PROCESS_PROCESSMODULE
            MENUITEM SEPARATOR
            MENUITEM "查看进程内存(&M)",                  ID_MENU_PROCESS_MEMORY
        END
        MENUITEM SEPARATOR
        MENUITEM "刷新列表(&F)",                    ID_MENU_PROCESS_REFRESH
        MENUITEM "复制信息(&P)",                    ID_MENU_PROCESS_COPYINFO
        POPUP "导出信息(&X)"
        BEGIN
            MENUITEM "导出为文本文件(&T)",                 ID_MENU_PROCESS_EXPORTTXT
            MENUITEM "导出为Excel文件(&E)",              ID_MENU_PROCESS_EXPORTEXCEL
        END
        MENUITEM SEPARATOR
        MENUITEM "进程挂起(&S)",                    ID_MENU_PROCESS_SUSPEND
        MENUITEM "进程恢复(&R)",                    ID_MENU_PROCESS_RECOVERY
        POPUP "进程注入(&J)"
        BEGIN
            MENUITEM "远程线程注入(&R)",                  ID_MENU_PROCESS_INJECTDLL
            MENUITEM "全局钩子注入(&H)",                  ID_MENU_PROCES_OVERALLHOOK
        END
        MENUITEM SEPARATOR
        MENUITEM "结束进程(&E)",                    ID_MENU_PROCESS_KILLPROCESS
        MENUITEM "强制关闭进程(&K)",                  ID_MENU_PROCESS_KILLMUST
        MENUITEM SEPARATOR
        MENUITEM "新建任务(&N)...",                 ID_MENU_PROCESS_NEWRUN
        MENUITEM SEPARATOR
        MENUITEM "文件属性(&R)",                    ID_MENU_PROCESS_ATTRIBUTE
    END
END

IDR_MENU_FILE_VIEW MENU
BEGIN
    POPUP "查看"
    BEGIN
        MENUITEM "大图标",                         IDM_FILE_VIEW_BIGICON
        MENUITEM "小图标",                         IDM_FILE_VIEW_SMALLICON
        MENUITEM "列表",                          IDM_FILE_VIEW_LIST
        MENUITEM "详细信息",                        IDM_FILE_VIEW_REPORT
    END
END

IDR_MENU_PROCESS_PRIVILEGE MENU
BEGIN
    POPUP "权限"
    BEGIN
        MENUITEM "刷新(&F)",                      ID_MENU_PROCESSPRIVILEGE_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "启用 (&E)",                     ID_MENU_PROCESSPRIVILEGE_ENABLE
        MENUITEM "禁用 (&D)",                     ID_MENU_PROCESSPRIVILEGE_DISABLE
    END
END

IDR_MENU_ICONNOTIFY MENU
BEGIN
    POPUP "图标通知"
    BEGIN
        MENUITEM "打开界面(&S)",                    ID_MENU_SHOWMAIN
        MENUITEM "隐藏界面(&H)",                    ID_MENU_HIDEMAIN
        MENUITEM "设置(&S)...",                   ID_MENU_MAIN_SETTING
        MENUITEM SEPARATOR
        MENUITEM "退出程序(&X)",                    ID_MENU_EXIT
    END
END

IDR_MENU_PROCESS_THREAD MENU
BEGIN
    POPUP "线程"
    BEGIN
        MENUITEM "刷新(&R)",                      ID_MENU_PROCESSTHREAD_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "结束线程(&C)",                    ID_MENU_PROCESSTHREAD_CLOSETHREAD
    END
END

IDR_MENU_KERNEL_SSDT MENU
BEGIN
    POPUP "SSDT"
    BEGIN
        MENUITEM "刷新(&F)",                      ID_MENU_SSDT_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "恢复(&R)",                      ID_MENU_SSDT_RESUME
    END
END

IDR_MENU_MODULE MENU
BEGIN
    POPUP "MODULE"
    BEGIN
        MENUITEM "刷新列表(&R)",                    ID_MENU_MODULE_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "卸载模块(&U)",                    ID_MENU_MODULE_REMOVEMODULE
    END
END

IDR_MENU_SYSK_IOTIMER MENU
BEGIN
    POPUP "SYSK_IOTIMER"
    BEGIN
        MENUITEM "刷新(&F)",                      ID_MENU_SYSK_IOTIMER_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "运行/停止(&S)",                   ID_MENU_SYSK_IOTIMER_OPER
        MENUITEM SEPARATOR
        MENUITEM "删除(&R)",                      ID_MENU_SYSK_IOTIMER_REMOVE
    END
END

IDR_MENU_SYSK_CALLBACK MENU
BEGIN
    POPUP "SYSK_CALLBACK"
    BEGIN
        MENUITEM "刷新(&F)",                      ID_MENU_SYSK_CALLBACK_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "删除(&R)",                      ID_MENU_SYSK_CALLBACK_REMOVE
    END
END

IDR_MENU_SYSK_DPCTIMER MENU
BEGIN
    POPUP "SYSK_DPCTIMER"
    BEGIN
        MENUITEM "刷新(&F)",                      ID_MENU_SYSK_DPCTIMER_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "删除(&R)",                      ID_MENU_SYSK_DPCTIMER_REMOVE
    END
END

IDR_MENU_SYSK_FILTERDRIVER MENU
BEGIN
    POPUP "SYSK_FILTERDRIVER"
    BEGIN
        MENUITEM "刷新(&F)",                      ID_MENU_SYSK_FILTER_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "卸载(&U)",                      ID_MENU_SYSK_FILTER_REMOVEFILTER
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// WAVE
//

IDR_WAVE_SYSTEM_ALERT   WAVE                    "res\\SYSTEM_ALERT.WAV"

/////////////////////////////////////////////////////////////////////////////
//
// Toolbar
//

IDR_TOOLBAR_FILETOOLBAR TOOLBAR 24, 24
BEGIN
    BUTTON      ID_BUTTON_FILE_PREV
    SEPARATOR
    BUTTON      ID_BUTTON_FILE_FIND
    BUTTON      ID_BUTTON_FILE_DELETE
    BUTTON      ID_BUTTON_FILE_NEWFOLDER
    SEPARATOR
    BUTTON      ID_BUTTON_FILE_VIEW
    BUTTON      ID_BUTTON_FILE_REFRESH
END

IDR_TOOLBAR_FILETOOLBARGOTO TOOLBAR 24, 24
BEGIN
    BUTTON      ID_BUTTON_FILE_GOTO
END


/////////////////////////////////////////////////////////////////////////////
//
// SYSDRIVER
//

IDR_SYSDRIVER64         SYSDRIVER               "res\\drivers\\HeavenShadowDrv64.sys"
IDR_SYSDRIVER32         SYSDRIVER               "res\\drivers\\HeavenShadowDrv32.sys"

/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 天影卫士(&A)..."
    IDS_STATUSDETAIL        "--"
    IDS_STATUSTIP           "--"
END

STRINGTABLE
BEGIN
    ID_MENU_PROCESS_NEWRUN  "创建新的任务。"
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\HeavenShadow.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadow.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A8649B59-9CD1-4E45-A2EE-C390FFFCB8A0}</ProjectGuid>
    <RootNamespace>HeavenShadow</RootNamespace>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Lib\odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>user32.lib</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <UACUIAccess>true</UACUIAccess>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\alert_btnexit.bmp" />
    <None Include="res\alert_btn_allow.bmp" />
    <None Include="res\alert_btn_allow_clicked.bmp" />
    <None Include="res\alert_btn_prevent.bmp" />
    <None Include="res\alert_btn_prevent_clicked.bmp" />
    <None Include="res\bitmap1.bmp" />
    <None Include="res\bmp00001.bmp" />
    <None Include="res\check_alt_v.bmp" />
    <None Include="res\check_alt_x.bmp" />
    <None Include="res\drivers\HeavenShadowSys32.sys" />
    <None Include="res\drivers\HeavenShadowSys64.sys" />
    <None Include="res\file_toolbar.bmp" />
    <None Include="res\file_toolbar_goto.bmp" />
    <None Include="res\HeavenShadow.ico" />
    <None Include="res\HeavenShadow.rc2" />
    <None Include="res\HeavenShadowLittle.ico" />
    <None Include="res\HomeCheckBtn.bmp" />
    <None Include="res\HomeCheckBtn_click.bmp" />
    <None Include="res\HomeCheckBtn_hover.bmp" />
    <None Include="res\LOGO.bmp" />
    <None Include="res\mainmenu_button.bmp" />
    <None Include="res\SYSTEM_ALERT.WAV" />
    <None Include="res\toolbar1.bmp" />
    <None Include="res\toolbar_file.bmp" />
    <None Include="res\toolbar_file_now.bmp" />
    <None Include="res\toolbar_kernel.bmp" />
    <None Include="res\toolbar_kernel_now.bmp" />
    <None Include="res\toolbar_logo.bmp" />
    <None Include="res\toolbar_logo_now.bmp" />
    <None Include="res\toolbar_module.bmp" />
    <None Include="res\toolbar_module_now.bmp" />
    <None Include="res\toolbar_process.bmp" />
    <None Include="res\toolbar_process_now.bmp" />
    <None Include="res\toolbar_service.bmp" />
    <None Include="res\toolbar_service_now.bmp" />
    <None Include="res\toolbar_setting.bmp" />
    <None Include="res\toolbar_setting_now.bmp" />
    <None Include="res\toolbar_system.bmp" />
    <None Include="res\toolbar_system_now.bmp" />
    <None Include="res\toolbar_tools.bmp" />
    <None Include="res\toolbar_tools_now.bmp" />
    <None Include="res\WzdSplash.bmp" />
    <None Include="res\WzdSplash.png" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AlertWnd.h" />
    <ClInclude Include="CallbackFunc.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="DpcTimerFunc.h" />
    <ClInclude Include="FilterDriverFunc.h" />
    <ClInclude Include="InjectFunc.h" />
    <ClInclude Include="IoTimerFunc.h" />
    <ClInclude Include="KernelFunc.h" />
    <ClInclude Include="ModuleFunc.h" />
    <ClInclude Include="MyCheckBtn.h" />
    <ClInclude Include="MyText2.h" />
    <ClInclude Include="PModuleFunc.h" />
    <ClInclude Include="SSDTFunc.h" />
    <ClInclude Include="DetailFunc.h" />
    <ClInclude Include="FileDlg.h" />
    <ClInclude Include="FileFunc.h" />
    <ClInclude Include="HandleFunc.h" />
    <ClInclude Include="HeavenShadow.h" />
    <ClInclude Include="HeavenShadowDlg.h" />
    <ClInclude Include="HsAboutDlg.h" />
    <ClInclude Include="KernelDlg.h" />
    <ClInclude Include="LoadSys.h" />
    <ClInclude Include="MemoryFunc.h" />
    <ClInclude Include="ModuleDlg.h" />
    <ClInclude Include="MyEdit.h" />
    <ClInclude Include="MyList.h" />
    <ClInclude Include="MyPicButton.h" />
    <ClInclude Include="MyText.h" />
    <ClInclude Include="PrivilegeFunc.h" />
    <ClInclude Include="ProcessDlg.h" />
    <ClInclude Include="ProcessFunc.h" />
    <ClInclude Include="ProcessViewDlg.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="ServiceDlg.h" />
    <ClInclude Include="SettingDlg.h" />
    <ClInclude Include="SSSDTFunc.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="SystemDlg.h" />
    <ClInclude Include="SysThread.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="ThreadFunc.h" />
    <ClInclude Include="ToolsDlg.h" />
    <ClInclude Include="TrueColorToolBar.h" />
    <ClInclude Include="WindowFunc.h" />
    <ClInclude Include="WzdSplash.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AlertWnd.cpp" />
    <ClCompile Include="ButtonNotify.cpp" />
    <ClCompile Include="CallbackFunc.cpp" />
    <ClCompile Include="Common.cpp" />
    <ClCompile Include="DpcTimerFunc.cpp" />
    <ClCompile Include="FilterDriverFunc.cpp" />
    <ClCompile Include="InjectFunc.cpp" />
    <ClCompile Include="IoTimerFunc.cpp" />
    <ClCompile Include="KernelFunc.cpp" />
    <ClCompile Include="ModuleFunc.cpp" />
    <ClCompile Include="MyCheckBtn.cpp" />
    <ClCompile Include="MyText2.cpp" />
    <ClCompile Include="PModuleFunc.cpp" />
    <ClCompile Include="SSDTFunc.cpp" />
    <ClCompile Include="DetailFunc.cpp" />
    <ClCompile Include="FileDlg.cpp" />
    <ClCompile Include="FileFunc.cpp" />
    <ClCompile Include="HandleFunc.cpp" />
    <ClCompile Include="HeavenShadow.cpp" />
    <ClCompile Include="HeavenShadowDlg.cpp" />
    <ClCompile Include="HsAboutDlg.cpp" />
    <ClCompile Include="KernelDlg.cpp" />
    <ClCompile Include="LoadSys.cpp" />
    <ClCompile Include="MemoryFunc.cpp" />
    <ClCompile Include="ModuleDlg.cpp" />
    <ClCompile Include="MyEdit.cpp" />
    <ClCompile Include="MyList.cpp" />
    <ClCompile Include="MyPicButton.cpp" />
    <ClCompile Include="MyText.cpp" />
    <ClCompile Include="PrivilegeFunc.cpp" />
    <ClCompile Include="ProcessDlg.cpp" />
    <ClCompile Include="ProcessFunc.cpp" />
    <ClCompile Include="ProcessViewDlg.cpp" />
    <ClCompile Include="ServiceDlg.cpp" />
    <ClCompile Include="SettingDlg.cpp" />
    <ClCompile Include="SSSDTFunc.cpp" />
    <ClCompile Include="SSSDTName.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="SystemDlg.cpp" />
    <ClCompile Include="SysThread.cpp" />
    <ClCompile Include="ThreadFunc.cpp" />
    <ClCompile Include="ToolsDlg.cpp" />
    <ClCompile Include="TrueColorToolBar.cpp" />
    <ClCompile Include="WindowFunc.cpp" />
    <ClCompile Include="WzdSplash.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="HeavenShadow.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="HeavenShadow.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadow.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="主对话框">
      <UniqueIdentifier>{e8967836-3339-4be5-85e8-5e93c5666e2c}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：进程">
      <UniqueIdentifier>{7c6e02d8-cff1-488b-bbc6-381abd7ac141}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：服务">
      <UniqueIdentifier>{ac2bdd48-ac02-4c4e-815c-31f32d87b798}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：模块">
      <UniqueIdentifier>{66bcb5e6-0155-4fe4-9639-c4f7f951951a}</UniqueIdentifier>
    </Filter>
    <Filter Include="通用文件">
      <UniqueIdentifier>{7232feb3-998d-49d1-be1b-a5c82b99cee5}</UniqueIdentifier>
    </Filter>
    <Filter Include="主对话框\MyListCtrl">
      <UniqueIdentifier>{bfef2f38-76fc-456e-a17c-0806c7fe8035}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：警告">
      <UniqueIdentifier>{62837207-1a9f-40d8-b27c-43bec063184c}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：进程\对话框：进程查看">
      <UniqueIdentifier>{409a277b-e935-4a16-8bcb-2f39c93c89b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：文件">
      <UniqueIdentifier>{cd12a9fa-1165-48fa-bc9d-fda5a44e8666}</UniqueIdentifier>
    </Filter>
    <Filter Include="主对话框\TrueColorToolBar">
      <UniqueIdentifier>{0081ba72-8dbb-4756-a9cc-c43662828415}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：进程\对话框：进程查看\MyEdit">
      <UniqueIdentifier>{978d8f23-085b-40d2-95de-d6d4b920c852}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：设置">
      <UniqueIdentifier>{187136f8-b929-42ba-a89f-85f468755d7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：工具箱">
      <UniqueIdentifier>{4c8702ed-28cc-44f6-9ba1-4b9a1a537cf0}</UniqueIdentifier>
    </Filter>
    <Filter Include="主对话框\MyPicButton">
      <UniqueIdentifier>{faa3185b-3234-47e4-9a3e-f7eb02439c1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：欢迎页">
      <UniqueIdentifier>{4d019f13-de81-43ff-9ad4-7f6e593befaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="主对话框\MyText">
      <UniqueIdentifier>{865ad5bf-b6ad-4c9b-9f86-fdb75d6a8073}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核钩子">
      <UniqueIdentifier>{c89dcef6-342d-4d73-bf67-65e6175be83b}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核钩子\ShadowSSDT">
      <UniqueIdentifier>{b178911c-d483-491c-a173-7de48768a193}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核钩子\内核函数">
      <UniqueIdentifier>{f94994a2-fa95-42bb-815a-fed46e72980d}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核钩子\SSDT">
      <UniqueIdentifier>{57c54be0-e34c-41bc-b694-9d1da9995439}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核">
      <UniqueIdentifier>{92468187-99be-4395-9a84-8b3b4e0d342c}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核\内核线程">
      <UniqueIdentifier>{8e1feaf3-f326-47c0-8c9f-595c65d56d60}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核\IOTimer">
      <UniqueIdentifier>{a6695778-8cd1-4060-bf9e-0eb611019311}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核\系统回调">
      <UniqueIdentifier>{824241e3-5aca-4e13-8c31-fee1b1aca203}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核\DPCTimer">
      <UniqueIdentifier>{36b65559-1511-4b10-857d-f9bc104688de}</UniqueIdentifier>
    </Filter>
    <Filter Include="对话框：内核\过滤驱动">
      <UniqueIdentifier>{df342808-8375-4b69-9c1e-e76b704a12f3}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="res\HeavenShadow.rc2">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\HeavenShadow.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar1.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\LOGO.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_process.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_module.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_service.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_process_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_module_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_service_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_logo.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_logo_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\alert_btnexit.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\SYSTEM_ALERT.WAV">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\alert_btn_allow.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\alert_btn_prevent.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_file.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_file_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\file_toolbar.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\file_toolbar_goto.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\alert_btn_allow_clicked.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\alert_btn_prevent_clicked.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\bmp00001.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\drivers\HeavenShadowSys32.sys">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\drivers\HeavenShadowSys64.sys">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_system.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_system_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_setting.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_setting_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_tools.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_tools_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\mainmenu_button.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\HeavenShadowLittle.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_kernel.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\toolbar_kernel_now.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\check_alt_v.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\check_alt_x.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\HomeCheckBtn.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\bitmap1.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\HomeCheckBtn_hover.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\HomeCheckBtn_click.bmp">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\WzdSplash.png">
      <Filter>资源文件</Filter>
    </None>
    <None Include="res\WzdSplash.bmp">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HeavenShadowDlg.h">
      <Filter>主对话框</Filter>
    </ClInclude>
    <ClInclude Include="HeavenShadow.h">
      <Filter>主对话框</Filter>
    </ClInclude>
    <ClInclude Include="ProcessDlg.h">
      <Filter>对话框：进程</Filter>
    </ClInclude>
    <ClInclude Include="ServiceDlg.h">
      <Filter>对话框：服务</Filter>
    </ClInclude>
    <ClInclude Include="ModuleDlg.h">
      <Filter>对话框：模块</Filter>
    </ClInclude>
    <ClInclude Include="ProcessFunc.h">
      <Filter>对话框：进程</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="MyList.h">
      <Filter>主对话框\MyListCtrl</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="HsAboutDlg.h">
      <Filter>对话框：欢迎页</Filter>
    </ClInclude>
    <ClInclude Include="AlertWnd.h">
      <Filter>对话框：警告</Filter>
    </ClInclude>
    <ClInclude Include="ThreadFunc.h">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClInclude>
    <ClInclude Include="LoadSys.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="FileDlg.h">
      <Filter>对话框：文件</Filter>
    </ClInclude>
    <ClInclude Include="FileFunc.h">
      <Filter>对话框：文件</Filter>
    </ClInclude>
    <ClInclude Include="TrueColorToolBar.h">
      <Filter>主对话框\TrueColorToolBar</Filter>
    </ClInclude>
    <ClInclude Include="PrivilegeFunc.h">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClInclude>
    <ClInclude Include="DetailFunc.h">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClInclude>
    <ClInclude Include="HandleFunc.h">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClInclude>
    <ClInclude Include="MyEdit.h">
      <Filter>对话框：进程\对话框：进程查看\MyEdit</Filter>
    </ClInclude>
    <ClInclude Include="SystemDlg.h">
      <Filter>对话框：内核</Filter>
    </ClInclude>
    <ClInclude Include="ToolsDlg.h">
      <Filter>对话框：工具箱</Filter>
    </ClInclude>
    <ClInclude Include="SettingDlg.h">
      <Filter>对话框：设置</Filter>
    </ClInclude>
    <ClInclude Include="MyPicButton.h">
      <Filter>主对话框\MyPicButton</Filter>
    </ClInclude>
    <ClInclude Include="MemoryFunc.h">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClInclude>
    <ClInclude Include="MyText.h">
      <Filter>主对话框\MyText</Filter>
    </ClInclude>
    <ClInclude Include="KernelDlg.h">
      <Filter>对话框：内核钩子</Filter>
    </ClInclude>
    <ClInclude Include="SSDTFunc.h">
      <Filter>对话框：内核钩子\SSDT</Filter>
    </ClInclude>
    <ClInclude Include="InjectFunc.h">
      <Filter>对话框：进程</Filter>
    </ClInclude>
    <ClInclude Include="MyText2.h">
      <Filter>对话框：欢迎页</Filter>
    </ClInclude>
    <ClInclude Include="MyCheckBtn.h">
      <Filter>对话框：欢迎页</Filter>
    </ClInclude>
    <ClInclude Include="WindowFunc.h">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClInclude>
    <ClInclude Include="PModuleFunc.h">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClInclude>
    <ClInclude Include="ModuleFunc.h">
      <Filter>对话框：模块</Filter>
    </ClInclude>
    <ClInclude Include="ProcessViewDlg.h">
      <Filter>对话框：进程</Filter>
    </ClInclude>
    <ClInclude Include="WzdSplash.h" />
    <ClInclude Include="SSSDTFunc.h">
      <Filter>对话框：内核钩子\ShadowSSDT</Filter>
    </ClInclude>
    <ClInclude Include="KernelFunc.h">
      <Filter>对话框：内核钩子\内核函数</Filter>
    </ClInclude>
    <ClInclude Include="SysThread.h">
      <Filter>对话框：内核\内核线程</Filter>
    </ClInclude>
    <ClInclude Include="IoTimerFunc.h">
      <Filter>对话框：内核\IOTimer</Filter>
    </ClInclude>
    <ClInclude Include="CallbackFunc.h">
      <Filter>对话框：内核\系统回调</Filter>
    </ClInclude>
    <ClInclude Include="DpcTimerFunc.h">
      <Filter>对话框：内核\DPCTimer</Filter>
    </ClInclude>
    <ClInclude Include="FilterDriverFunc.h">
      <Filter>对话框：内核\过滤驱动</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HeavenShadow.cpp">
      <Filter>主对话框</Filter>
    </ClCompile>
    <ClCompile Include="HeavenShadowDlg.cpp">
      <Filter>主对话框</Filter>
    </ClCompile>
    <ClCompile Include="ProcessDlg.cpp">
      <Filter>对话框：进程</Filter>
    </ClCompile>
    <ClCompile Include="ServiceDlg.cpp">
      <Filter>对话框：服务</Filter>
    </ClCompile>
    <ClCompile Include="ModuleDlg.cpp">
      <Filter>对话框：模块</Filter>
    </ClCompile>
    <ClCompile Include="ProcessFunc.cpp">
      <Filter>对话框：进程</Filter>
    </ClCompile>
    <ClCompile Include="Common.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="MyList.cpp">
      <Filter>主对话框\MyListCtrl</Filter>
    </ClCompile>
    <ClCompile Include="HsAboutDlg.cpp">
      <Filter>对话框：欢迎页</Filter>
    </ClCompile>
    <ClCompile Include="AlertWnd.cpp">
      <Filter>对话框：警告</Filter>
    </ClCompile>
    <ClCompile Include="ThreadFunc.cpp">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClCompile>
    <ClCompile Include="LoadSys.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="FileDlg.cpp">
      <Filter>对话框：文件</Filter>
    </ClCompile>
    <ClCompile Include="FileFunc.cpp">
      <Filter>对话框：文件</Filter>
    </ClCompile>
    <ClCompile Include="TrueColorToolBar.cpp">
      <Filter>主对话框\TrueColorToolBar</Filter>
    </ClCompile>
    <ClCompile Include="PrivilegeFunc.cpp">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClCompile>
    <ClCompile Include="DetailFunc.cpp">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClCompile>
    <ClCompile Include="HandleFunc.cpp">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClCompile>
    <ClCompile Include="MyEdit.cpp">
      <Filter>对话框：进程\对话框：进程查看\MyEdit</Filter>
    </ClCompile>
    <ClCompile Include="SystemDlg.cpp">
      <Filter>对话框：内核</Filter>
    </ClCompile>
    <ClCompile Include="ToolsDlg.cpp">
      <Filter>对话框：工具箱</Filter>
    </ClCompile>
    <ClCompile Include="SettingDlg.cpp">
      <Filter>对话框：设置</Filter>
    </ClCompile>
    <ClCompile Include="MyPicButton.cpp">
      <Filter>主对话框\MyPicButton</Filter>
    </ClCompile>
    <ClCompile Include="MemoryFunc.cpp">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClCompile>
    <ClCompile Include="MyText.cpp">
      <Filter>主对话框\MyText</Filter>
    </ClCompile>
    <ClCompile Include="KernelDlg.cpp">
      <Filter>对话框：内核钩子</Filter>
    </ClCompile>
    <ClCompile Include="SSDTFunc.cpp">
      <Filter>对话框：内核钩子\SSDT</Filter>
    </ClCompile>
    <ClCompile Include="ButtonNotify.cpp">
      <Filter>主对话框</Filter>
    </ClCompile>
    <ClCompile Include="InjectFunc.cpp">
      <Filter>对话框：进程</Filter>
    </ClCompile>
    <ClCompile Include="MyText2.cpp">
      <Filter>对话框：欢迎页</Filter>
    </ClCompile>
    <ClCompile Include="MyCheckBtn.cpp">
      <Filter>对话框：欢迎页</Filter>
    </ClCompile>
    <ClCompile Include="WindowFunc.cpp">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClCompile>
    <ClCompile Include="PModuleFunc.cpp">
      <Filter>对话框：进程\对话框：进程查看</Filter>
    </ClCompile>
    <ClCompile Include="ModuleFunc.cpp">
      <Filter>对话框：模块</Filter>
    </ClCompile>
    <ClCompile Include="ProcessViewDlg.cpp">
      <Filter>对话框：进程</Filter>
    </ClCompile>
    <ClCompile Include="WzdSplash.cpp" />
    <ClCompile Include="SSSDTFunc.cpp">
      <Filter>对话框：内核钩子\ShadowSSDT</Filter>
    </ClCompile>
    <ClCompile Include="SSSDTName.cpp">
      <Filter>对话框：内核钩子\ShadowSSDT</Filter>
    </ClCompile>
    <ClCompile Include="KernelFunc.cpp">
      <Filter>对话框：内核钩子\内核函数</Filter>
    </ClCompile>
    <ClCompile Include="SysThread.cpp">
      <Filter>对话框：内核\内核线程</Filter>
    </ClCompile>
    <ClCompile Include="IoTimerFunc.cpp">
      <Filter>对话框：内核\IOTimer</Filter>
    </ClCompile>
    <ClCompile Include="CallbackFunc.cpp">
      <Filter>对话框：内核\系统回调</Filter>
    </ClCompile>
    <ClCompile Include="DpcTimerFunc.cpp">
      <Filter>对话框：内核\DPCTimer</Filter>
    </ClCompile>
    <ClCompile Include="FilterDriverFunc.cpp">
      <Filter>对话框：内核\过滤驱动</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="HeavenShadow.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadow.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadowDlg.cpp`:

```cpp

// HeavenShadowDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "HeavenShadowDlg.h"
#include "afxdialogex.h"

#include "WzdSplash.h"

extern HANDLE g_hDevice;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CWnd* g_wParent  = NULL;
BOOL bIsChecking = FALSE; //当前的检查状态


extern CWnd* g_process;

int dpix = 0;
int dpiy = 0;

enum
{
	UM_ICONNOTIFY= WM_USER+0x100
};


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CHeavenShadowDlg 对话框




CHeavenShadowDlg::CHeavenShadowDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CHeavenShadowDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIconW(IDR_MAINFRAME);

	m_processDlg = NULL;
	m_moduleDlg = NULL;
	m_serviceDlg = NULL;
	m_fileDlg = NULL;
	m_aboutDlg = NULL;
	m_systemDlg = NULL;
	m_settingDlg = NULL;
	m_toolsDlg = NULL;
	m_kernelDlg = NULL;


	m_bHideWnd = TRUE;

}

CHeavenShadowDlg::~CHeavenShadowDlg()
{
}

void CHeavenShadowDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_TAB_MAIN, m_mainTab);
	DDX_Control(pDX, IDC_STATIC_PROCESS, m_btnProc);
	DDX_Control(pDX, IDC_STATIC_MODULE, m_btnModu);
	DDX_Control(pDX, IDC_STATIC_SERVICE, m_btnServ);
	DDX_Control(pDX, IDC_STATIC_LOGO, m_btnAbou);
	DDX_Control(pDX, IDC_STATIC_FILE, m_btnFile);
	DDX_Control(pDX, IDC_STATIC_SYSTEM, m_btnSys);
	DDX_Control(pDX, IDC_STATIC_SETTING, m_btnSet);
	DDX_Control(pDX, IDC_STATIC_TOOLS, m_btnTool);
	DDX_Control(pDX, IDC_STATIC_MANMENUBTN, m_btnMenu);
	DDX_Control(pDX, IDC_STATIC_KERNEL, m_btnKrnl);
}

BEGIN_MESSAGE_MAP(CHeavenShadowDlg, CDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()

	ON_MESSAGE(HS_MESSAGE_STATUSDETAIL,HsSetStatusDetail)
	ON_MESSAGE(HS_MESSAGE_STATUSTIP,HsSetStatusTip)

	ON_STN_CLICKED(IDC_STATIC_MODULE, &CHeavenShadowDlg::OnClickedStaticModule)
	ON_STN_CLICKED(IDC_STATIC_PROCESS, &CHeavenShadowDlg::OnClickedStaticProcess)
	ON_STN_CLICKED(IDC_STATIC_SERVICE, &CHeavenShadowDlg::OnClickedStaticService)
	ON_STN_DISABLE(IDC_STATIC_PROCESS, &CHeavenShadowDlg::OnDisableStaticProcess)
	ON_STN_ENABLE(IDC_STATIC_PROCESS, &CHeavenShadowDlg::OnEnableStaticProcess)
	ON_STN_ENABLE(IDC_STATIC_MODULE, &CHeavenShadowDlg::OnEnableStaticModule)
	ON_STN_DISABLE(IDC_STATIC_MODULE, &CHeavenShadowDlg::OnDisableStaticModule)
	ON_STN_ENABLE(IDC_STATIC_SERVICE, &CHeavenShadowDlg::OnEnableStaticService)
	ON_STN_DISABLE(IDC_STATIC_SERVICE, &CHeavenShadowDlg::OnDisableStaticService)
	ON_STN_CLICKED(IDC_STATIC_LOGO, &CHeavenShadowDlg::OnClickedStaticLogo)
	ON_STN_ENABLE(IDC_STATIC_LOGO, &CHeavenShadowDlg::OnEnableStaticLogo)
	ON_STN_DISABLE(IDC_STATIC_LOGO, &CHeavenShadowDlg::OnDisableStaticLogo)
	ON_STN_CLICKED(IDC_STATIC_FILE, &CHeavenShadowDlg::OnClickedStaticFile)
	ON_STN_ENABLE(IDC_STATIC_FILE, &CHeavenShadowDlg::OnEnableStaticFile)
	ON_STN_DISABLE(IDC_STATIC_FILE, &CHeavenShadowDlg::OnDisableStaticFile)
	ON_WM_HELPINFO()
	ON_STN_CLICKED(IDC_STATIC_SYSTEM, &CHeavenShadowDlg::OnClickedStaticSystem)
	ON_STN_ENABLE(IDC_STATIC_SYSTEM, &CHeavenShadowDlg::OnEnableStaticSystem)
	ON_STN_DISABLE(IDC_STATIC_SYSTEM, &CHeavenShadowDlg::OnDisableStaticSystem)
	ON_STN_CLICKED(IDC_STATIC_SETTING, &CHeavenShadowDlg::OnClickedStaticSetting)
	ON_STN_ENABLE(IDC_STATIC_SETTING, &CHeavenShadowDlg::OnEnableStaticSetting)
	ON_STN_DISABLE(IDC_STATIC_SETTING, &CHeavenShadowDlg::OnDisableStaticSetting)
	ON_STN_CLICKED(IDC_STATIC_TOOLS, &CHeavenShadowDlg::OnClickedStaticTools)
	ON_STN_ENABLE(IDC_STATIC_TOOLS, &CHeavenShadowDlg::OnEnableStaticTools)
	ON_STN_DISABLE(IDC_STATIC_TOOLS, &CHeavenShadowDlg::OnDisableStaticTools)

	ON_STN_CLICKED(IDC_STATIC_MANMENUBTN, &CHeavenShadowDlg::OnClickedStaticManmenubtn)
	ON_MESSAGE(UM_ICONNOTIFY, (LRESULT (__thiscall CWnd::* )(WPARAM,LPARAM))OnIconNotify)
	ON_WM_CLOSE()
	ON_COMMAND(ID_MENU_EXIT, &CHeavenShadowDlg::OnMenuExit)
	ON_COMMAND(ID_MENU_SHOWMAIN, &CHeavenShadowDlg::OnMenuShowmain)
	ON_COMMAND(ID_MENU_HIDEMAIN, &CHeavenShadowDlg::OnMenuHidemain)
	ON_WM_SHOWWINDOW()
	ON_STN_CLICKED(IDC_STATIC_KERNEL, &CHeavenShadowDlg::OnClickedStaticKernel)
	ON_STN_ENABLE(IDC_STATIC_KERNEL, &CHeavenShadowDlg::OnEnableStaticKernel)
	ON_STN_DISABLE(IDC_STATIC_KERNEL, &CHeavenShadowDlg::OnDisableStaticKernel)
	ON_WM_CREATE()
END_MESSAGE_MAP()


// CHeavenShadowDlg 消息处理程序

BOOL CHeavenShadowDlg::OnInitDialog()
{
	CDialog::OnInitDialog();


	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
// 		if (!strAboutMenu.IsEmpty())
// 		{
// 			pSysMenu->AppendMenu(MF_SEPARATOR);
// 			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
// 		}
	}

	// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码


	if (g_hDevice == INVALID_HANDLE_VALUE)
	{

	}

	HsInitTray(&m_NotifyIcon);


	CString TempToolTip = L"菜单";
	m_btnMenu.SetToolTipText(TempToolTip);

	//////////////////////////////////////////////////////////////////////////

	g_wParent = this;

	CRect rect;

	GetWindowRect(&rect);

	CPaintDC dc(this);
	dpix = GetDeviceCaps(dc.m_hDC,LOGPIXELSX);
	dpiy = GetDeviceCaps(dc.m_hDC,LOGPIXELSY);
	rect.bottom += (LONG)(1+21*(dpiy/96.0));

	MoveWindow(&rect);

	//////////////////////////////////////////////////////////////////////////
	//添加状态栏
	m_StatusBar = new CStatusBarCtrl;

	m_StatusBar->Create(WS_CHILD|WS_VISIBLE|SBT_OWNERDRAW,CRect(0,0,0,0),this,0);

	int strPartDim[3] = {745,850,0};

	//strPartDim[0] = (int)((double)strPartDim[0]*dpix/96.0);

	GetClientRect(&rect);

	strPartDim[1] = rect.right - (int)(1+21*(dpix/96.0));
	strPartDim[0] = strPartDim[1] - (int)(120*(dpix/96.0));

	m_StatusBar->SetParts(3,strPartDim);

	m_StatusBar->SetText(L"准备就绪。",0,0);
	m_StatusBar->SetText(L"",1,0);


	//////////////////////////////////////////////////////////////////////////
	//加载工具栏

	int leftpos = 5;

	m_btnAbou.MoveWindow(leftpos+(70*0), 0, 70, 94);
	m_btnProc.MoveWindow(leftpos+(70*1), 0, 70, 94);
	m_btnModu.MoveWindow(leftpos+(70*2), 0, 70, 94);
	m_btnSys.MoveWindow(leftpos+(70*3), 0, 70, 94);
	m_btnKrnl.MoveWindow(leftpos+(70*4), 0, 70, 94);
	m_btnServ.MoveWindow(leftpos+(70*5), 0, 70, 94);
	m_btnFile.MoveWindow(leftpos+(70*6), 0, 70, 94);	//m_btnSys
	m_btnTool.MoveWindow(leftpos+(70*7), 0, 70, 94);
	m_btnSet.MoveWindow(leftpos+(70*8), 0, 70, 94);

	CRect menubtnrect;
	m_btnMenu.GetWindowRect(&menubtnrect);
	int menubtnwidth = menubtnrect.Width();
	menubtnrect.left = rect.right - 80;
	menubtnrect.top = rect.top - 20;
	menubtnrect.bottom = menubtnrect.top + menubtnwidth;
	menubtnrect.right = menubtnrect.left + menubtnwidth;

	//////////////////////////////////////////////////////////////////////////
	//初始化子对话框功能类
	
	GetClientRect(&rect);
	rect.top = 94+2;
	rect.bottom -= (LONG)(1+21*(dpiy/96.0));
	m_mainTab.MoveWindow(rect);


	//////////////////////////////////////////////////////////////////////////

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CHeavenShadowDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
// 		CAboutDlg dlgAbout;
// 		dlgAbout.DoModal();
//		//关于对话框

		if (m_bNowWindow != HS_DIALOG_ABOUT)
		{
			OnClickedStaticLogo();
		}
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CHeavenShadowDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CPaintDC dc(this);
		CRect rect;
		GetClientRect(rect);
		dc.FillSolidRect(rect,RGB(255,255,255));

		int ddd = GetDeviceCaps(dc.m_hDC,LOGPIXELSX);

		GetWindowRect(rect);

		CPoint startPoint;
		startPoint.x = -1;
		startPoint.y = 95;
		CPoint endPoint;
		endPoint.x = rect.Width();
		endPoint.y = 95;


		COLORREF m_Color(RGB(55,173,255));

		CClientDC aDC(this); //CClientDC的构造函数需要一个参数，这个参数是指向绘图窗口的指针，我们用this指针就可以了
		CPen pen(PS_SOLID,2,m_Color); ////建立一个画笔类对象，构造时设置画笔属性
		aDC.SelectObject(&pen);
		aDC.MoveTo(startPoint);
		aDC.LineTo(endPoint);

		CDialog::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CHeavenShadowDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



void CHeavenShadowDlg::HsEnableNowButton()
{
	switch(m_bNowWindow)
	{
	case HS_DIALOG_PROCESS:
		{
			m_btnProc.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_MODULE:
		{
			m_btnModu.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_KERNEL:
		{
			m_btnKrnl.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_SERVICE:
		{
			m_btnServ.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_FILE:
		{
			m_btnFile.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_SYSTEM:
		{
			m_btnSys.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_TOOLS:
		{
			m_btnTool.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_SETTING:
		{
			m_btnSet.EnableWindow(TRUE);
			break;
		}
	case HS_DIALOG_ABOUT:
		{
			m_btnAbou.EnableWindow(TRUE);
			break;
		}
	default:
		{

		}
	}
}


//////////////////////////////////////////////////////////////////////////

void CHeavenShadowDlg::HsSelectWindow(UINT CurSel)
{
	switch(CurSel)
	{
	case HS_DIALOG_PROCESS:
		{

			if (m_processDlg == NULL)
			{
				m_processDlg  = new CProcessDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_processDlg->Create(IDD_DIALOG_PROCESS,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_processDlg->MoveWindow(&rs);
			}
			if (m_processDlg) m_processDlg->ShowWindow(true);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}
	case HS_DIALOG_SERVICE:
		{
			if (m_serviceDlg == NULL)
			{
				m_serviceDlg  = new CServiceDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_serviceDlg->Create(IDD_DIALOG_SERVICE,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_serviceDlg->MoveWindow(&rs);
			}
			if (m_serviceDlg) m_serviceDlg->ShowWindow(true);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}
	case HS_DIALOG_MODULE:
		{
			if (m_moduleDlg == NULL)
			{
				m_moduleDlg  = new CModuleDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_moduleDlg->Create(IDD_DIALOG_MODULE,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_moduleDlg->MoveWindow(&rs);
			}
			if (m_moduleDlg) m_moduleDlg->ShowWindow(true);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}

	case HS_DIALOG_FILE:
		{
			if (m_fileDlg == NULL)
			{
				m_fileDlg  = new CFileDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_fileDlg->Create(IDD_DIALOG_FILE,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_fileDlg->MoveWindow(&rs);
			}
			if (m_fileDlg) m_fileDlg->ShowWindow(true);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}
	case HS_DIALOG_SYSTEM:
		{

			if (m_systemDlg == NULL)
			{
				m_systemDlg  = new CSystemDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_systemDlg->Create(IDD_DIALOG_SYSTEM,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_systemDlg->MoveWindow(&rs);
			}
			if (m_systemDlg) m_systemDlg->ShowWindow(true);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}
	case HS_DIALOG_KERNEL:
		{

			if (m_kernelDlg == NULL)
			{
				m_kernelDlg  = new CKernelDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_kernelDlg->Create(IDD_DIALOG_KERNEL,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_kernelDlg->MoveWindow(&rs);
			}
			if (m_kernelDlg) m_kernelDlg->ShowWindow(true);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			break;
		}
	case HS_DIALOG_TOOLS:
		{

			if (m_toolsDlg == NULL)
			{
				m_toolsDlg  = new CToolsDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_toolsDlg->Create(IDD_DIALOG_TOOLS,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_toolsDlg->MoveWindow(&rs);
			}
			if (m_toolsDlg) m_toolsDlg->ShowWindow(true);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}
	case HS_DIALOG_SETTING:
		{

			if (m_settingDlg == NULL)
			{
				m_settingDlg  = new CSettingDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_settingDlg->Create(IDD_DIALOG_SETTING,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_settingDlg->MoveWindow(&rs);
			}
			if (m_settingDlg) m_settingDlg->ShowWindow(true);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_aboutDlg) m_aboutDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}
	case HS_DIALOG_ABOUT:
		{
			if (m_aboutDlg == NULL)
			{
				m_aboutDlg  = new CHsAboutDlg(this);
				//////////////////////////////////////////////////////////////////////////
				//绑定对话框
				m_aboutDlg->Create(IDD_DIALOG_ABOUT,GetDlgItem(IDC_TAB_MAIN));
				//////////////////////////////////////////////////////////////////////////
				//移动窗口位置
				CRect rs;
				m_mainTab.GetClientRect(&rs);
				//设置子对话框尺寸并移动到指定位置
				m_aboutDlg->MoveWindow(&rs);
			}
			if (m_aboutDlg) m_aboutDlg->ShowWindow(true);
			if (m_processDlg) m_processDlg->ShowWindow(false);
			if (m_serviceDlg) m_serviceDlg->ShowWindow(false);
			if (m_moduleDlg) m_moduleDlg->ShowWindow(false);
			if (m_fileDlg) m_fileDlg->ShowWindow(false);
			if (m_systemDlg) m_systemDlg->ShowWindow(false);
			if (m_settingDlg) m_settingDlg->ShowWindow(false);
			if (m_toolsDlg) m_toolsDlg->ShowWindow(false);
			if (m_kernelDlg) m_kernelDlg->ShowWindow(false);
			break;
		}
	}
}

//状态栏消息响应。

LRESULT CHeavenShadowDlg::HsSetStatusDetail(WPARAM wParam, LPARAM lParam)
{

	CString recvstr = (LPCTSTR)lParam;

	m_StatusBar->SetText(recvstr.GetBuffer(),0,0);

	return TRUE;
}

LRESULT CHeavenShadowDlg::HsSetStatusTip(WPARAM wParam, LPARAM lParam)
{
	CString recvstr = (LPCTSTR)lParam;

	m_StatusBar->SetText(recvstr.GetBuffer(),1,0);

	return TRUE;
}




BOOL CHeavenShadowDlg::HsInitChildDialog(void)
{
	HsSelectWindow(HS_DIALOG_ABOUT);

	return TRUE;
}



BOOL CHeavenShadowDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN &&
		(pMsg->wParam==VK_RETURN ||
		pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}




BOOL CHeavenShadowDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	return TRUE;

	//return CDialog::OnHelpInfo(pHelpInfo);
}





void CHeavenShadowDlg::HsInitTray(PNOTIFYICONDATA nid)
{
	nid->cbSize = sizeof(NOTIFYICONDATA);				//大小赋值
	nid->hWnd = m_hWnd;									//父窗口
	nid->uID = IDR_MAINFRAME;							//icon  ID
	nid->uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;		//托盘所拥有的状态
	nid->uCallbackMessage = UM_ICONNOTIFY;				//回调消息

	HICON hIcon = AfxGetApp()->LoadIconW(IDI_ICON_LITTLE);
	nid->hIcon = hIcon;									//icon 变量

	CString str=L"天影卫士";							//气泡提示
	lstrcpyn(nid->szTip, str, sizeof(nid->szTip) / sizeof(nid->szTip[0]));
	Shell_NotifyIcon(NIM_ADD, nid);						//显示托盘

}

void CHeavenShadowDlg::OnClose()
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	//if (m_bHideWnd == TRUE)
	{
		//ShowWindow(SW_HIDE);
	}
	//else
	{
		Shell_NotifyIcon(NIM_DELETE, &m_NotifyIcon);
		CDialog::OnClose();
	}


	//ShowWindow(SW_HIDE);
}


void CHeavenShadowDlg::OnIconNotify(WPARAM wParam, LPARAM lParam)
{
	switch ((UINT)lParam)
	{
	case WM_LBUTTONDOWN:
//	case WM_LBUTTONDBLCLK:
// 		if (!IsWindowVisible())
// 			ShowWindow(SW_SHOWNORMAL);
// 		else
// 			ShowWindow(SW_HIDE);
// 		break;
	case WM_RBUTTONDOWN: 
		CMenu menu;
		menu.LoadMenu(IDR_MENU_ICONNOTIFY);

		if (!IsWindowVisible()) 
			menu.DeleteMenu(ID_MENU_HIDEMAIN,MF_BYCOMMAND);
		else
			menu.DeleteMenu(ID_MENU_SHOWMAIN,MF_BYCOMMAND);

		CPoint point;
		GetCursorPos(&point);
		SetForegroundWindow();   //设置当前窗口
		menu.GetSubMenu(0)->TrackPopupMenu(
			TPM_LEFTBUTTON|TPM_RIGHTBUTTON, 
			point.x, point.y, this, NULL); 
		PostMessage(WM_USER, 0, 0);
		break;
	}
}



void CHeavenShadowDlg::OnClickedStaticManmenubtn()
{
	// TODO: 在此添加控件通知处理程序代码
	CMenu	popup;

	popup.LoadMenu(IDR_MENU_MAIN);		//加载菜单资源
	CMenu*	pM = popup.GetSubMenu(0);	//获得菜单的子项
	CPoint	p;

	CRect rect;
	m_btnMenu.GetWindowRect(&rect);

	p.SetPoint(rect.left,rect.top+20);

	int	count = pM->GetMenuItemCount();
	
	pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);
	

}





void CHeavenShadowDlg::OnMenuExit()
{
	// TODO: 在此添加命令处理程序代码
	m_bHideWnd = FALSE;
	SendMessage(WM_CLOSE);
}


void CHeavenShadowDlg::OnMenuShowmain()
{
	// TODO: 在此添加命令处理程序代码
	ShowWindow(SW_SHOWNORMAL);
}


void CHeavenShadowDlg::OnMenuHidemain()
{
	// TODO: 在此添加命令处理程序代码
	ShowWindow(SW_HIDE);
}


void CHeavenShadowDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	if (bShow)
	{
		if (!bIsChecking && m_bNowWindow != 1)
		{
			HsEnableNowButton();
			HsInitChildDialog();
		}
	}
}





int CHeavenShadowDlg::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO:  在此添加您专用的创建代码

	return 0;
}

```

`arkProject/HeavenShadow/HeavenShadow/HeavenShadowDlg.h`:

```h

// HeavenShadowDlg.h : 头文件
//

#pragma once

#include "afxwin.h"
#include "afxcmn.h"

#include "ProcessDlg.h"
#include "ServiceDlg.h"
#include "ModuleDlg.h"
#include "HsAboutDlg.h"
#include "FileDlg.h"
#include "SystemDlg.h"
#include "SettingDlg.h"
#include "ToolsDlg.h"
#include "KernelDlg.h"

#include "MyPicButton.h"




// CHeavenShadowDlg 对话框
class CHeavenShadowDlg : public CDialog
{
// 构造
public:
	CHeavenShadowDlg(CWnd* pParent = NULL);	// 标准构造函数
	virtual ~CHeavenShadowDlg();


// 对话框数据
	enum { IDD = IDD_HEAVENSHADOW_DIALOG };

	//////////////////////////////////////////////////////////////////////////
	/// 函数
	//////////////////////////////////////////////////////////////////////////
	

	//////////////////////////////////////////////////////////////////////////
	void HsSelectWindow(UINT CurSel);
	LRESULT HsSetStatusDetail(WPARAM wParam, LPARAM lParam);
	LRESULT HsSetStatusTip(WPARAM wParam, LPARAM lParam);
	BOOL HsLoadToolBar(void);
	BOOL HsInitChildDialog(void);
	void HsEnableNowButton(void);

	// 工具条
	CStatusBarCtrl*   m_StatusBar;

	CWnd* m_pHndWnd;


	BOOL m_bHideWnd; //判断是否显示界面

	//任务栏图标
	NOTIFYICONDATA m_NotifyIcon; //系统托盘结构
	void HsInitTray(PNOTIFYICONDATA nid);
	void OnIconNotify(WPARAM wParam, LPARAM lParam);

	//////////////////////////////////////////////////////////////////////////
	BOOL m_bNowWindow;
	//////////////////////////////////////////////////////////////////////////
	//子对话框类成员对象

	CProcessDlg* m_processDlg;
	CServiceDlg* m_serviceDlg;
	CModuleDlg*  m_moduleDlg;
	CHsAboutDlg* m_aboutDlg;
	CFileDlg*    m_fileDlg;
	CSystemDlg*  m_systemDlg;
	CSettingDlg* m_settingDlg;
	CToolsDlg*   m_toolsDlg;
	CKernelDlg*  m_kernelDlg;

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	CTabCtrl m_mainTab;

	afx_msg void OnClickedStaticModule();
	CMyPicButton m_btnProc;
	CMyPicButton m_btnModu;
	CMyPicButton m_btnServ;
	CMyPicButton m_btnAbou;
	CMyPicButton m_btnFile;
	CMyPicButton m_btnSys;
	CMyPicButton m_btnSet;
	CMyPicButton m_btnTool;
	CMyPicButton m_btnMenu;
	CMyPicButton m_btnKrnl;

	afx_msg void OnClickedStaticProcess();
	afx_msg void OnClickedStaticService();
	afx_msg void OnEnableStaticProcess();
	afx_msg void OnDisableStaticProcess();
	afx_msg void OnEnableStaticModule();
	afx_msg void OnDisableStaticModule();
	afx_msg void OnEnableStaticService();
	afx_msg void OnDisableStaticService();
	afx_msg void OnClickedStaticLogo();
	afx_msg void OnEnableStaticLogo();
	afx_msg void OnDisableStaticLogo();
	
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnClickedStaticFile();
	afx_msg void OnEnableStaticFile();
	afx_msg void OnDisableStaticFile();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnClickedStaticSystem();
	afx_msg void OnEnableStaticSystem();
	afx_msg void OnDisableStaticSystem();
	afx_msg void OnClickedStaticSetting();
	afx_msg void OnEnableStaticSetting();
	afx_msg void OnDisableStaticSetting();
	afx_msg void OnClickedStaticTools();
	afx_msg void OnEnableStaticTools();
	afx_msg void OnDisableStaticTools();
	afx_msg void OnClickedStaticManmenubtn();
	afx_msg void OnClose();
	afx_msg void OnMenuExit();
	afx_msg void OnMenuShowmain();
	afx_msg void OnMenuHidemain();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnClickedStaticKernel();
	afx_msg void OnEnableStaticKernel();
	afx_msg void OnDisableStaticKernel();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
};

```

`arkProject/HeavenShadow/HeavenShadow/HsAboutDlg.cpp`:

```cpp
// HsAboutDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "HsAboutDlg.h"
#include "afxdialogex.h"

#include "HeavenShadowDlg.h"


extern BOOL bDriverIsOK;
extern WIN_VERSION GetWindowsVersion();
extern WIN_VERSION WinVersion;

extern int dpix;
extern int dpiy;



// CHsAboutDlg 对话框

IMPLEMENT_DYNAMIC(CHsAboutDlg, CDialog)

CHsAboutDlg::CHsAboutDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CHsAboutDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CHsAboutDlg::~CHsAboutDlg()
{
}

void CHsAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_TEXT_CHECK_ALT, m_TextCheckAlt);
	DDX_Control(pDX, IDC_STATIC_CHECK_ALT, m_PicCheckAlt);
	DDX_Control(pDX, IDC_STATIC_SYS_BIT, m_PicSysBit);
	DDX_Control(pDX, IDC_TEXT_SYS_BIT, m_TextSysBit);
	DDX_Control(pDX, IDC_TEXT_SOFT_BIT, m_TextSoftBit);
	DDX_Control(pDX, IDC_STATIC_HOMECHECK, m_CheckBtn);
}


BEGIN_MESSAGE_MAP(CHsAboutDlg, CDialog)
	ON_WM_SHOWWINDOW()
	ON_WM_PAINT()
	ON_WM_CTLCOLOR()
	ON_STN_CLICKED(IDC_STATIC_HOMECHECK, &CHsAboutDlg::OnClickedStaticHomecheck)
END_MESSAGE_MAP()


// CHsAboutDlg 消息处理程序


BOOL CHsAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CHsAboutDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码


	if (bShow == TRUE)
	{
		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_ABOUT;

		((CHeavenShadowDlg*)m_wParent)->m_btnAbou.EnableWindow(FALSE);

		HsSendStatusDetail(L"天影卫士安全防护工具。");

		HsSendStatusTip(L"天影卫士");


		if (sizeof(ULONG_PTR) == sizeof(ULONG32))
		{
			m_TextSoftBit.SetWindowTextW(L"天影卫士 32位版。");
		}
		else
		{
			m_TextSoftBit.SetWindowTextW(L"天影卫士 64位版。");
		}

		CString SysBit;

		WinVersion = GetWindowsVersion();

		switch(WinVersion)
		{
		case Windows7:
			{
				SysBit += L"Windows7";
				break;
			}
		case WindowsXP:
			{
				SysBit += L"WindowsXP";
				break;
			}
		default:
			{
				SysBit += L"Other";
			}
		}

		if (HsIs64BitWindows())
		{
			SysBit += L" 64位操作系统。";
		}
		else
		{
			SysBit += L" 32位操作系统。";
		}

		m_TextSysBit.SetWindowTextW(SysBit.GetBuffer());

		if (bDriverIsOK)
		{
			HINSTANCE hIns_proc = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_CHECK_ALT_V),RT_GROUP_ICON);
			HBITMAP   hBmp_proc = ::LoadBitmap(hIns_proc, MAKEINTRESOURCE(IDB_BITMAP_CHECK_ALT_V));
			m_PicCheckAlt.SetBitmap(hBmp_proc);

			m_TextCheckAlt.SetWindowTextW(L"程序与内核层通讯正常。");
		}
		else
		{
			HINSTANCE hIns_proc = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_CHECK_ALT_X),RT_GROUP_ICON);
			HBITMAP   hBmp_proc = ::LoadBitmap(hIns_proc, MAKEINTRESOURCE(IDB_BITMAP_CHECK_ALT_X));
			m_PicCheckAlt.SetBitmap(hBmp_proc);

			m_TextCheckAlt.SetWindowTextW(L"程序与内核层通讯异常。");
		}

	}
}


void CHsAboutDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()

	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(255,255,255));

	ClientToScreen(&rect);

	CRect picrect;
	m_PicSysBit.GetWindowRect(&picrect);
	picrect.left = picrect.left - rect.left;

	CPoint startPoint;
	startPoint.x = (LONG)(picrect.left-(20)*(dpix/96.0));
	startPoint.y = 13;
	CPoint endPoint;
	endPoint.x = (LONG)(picrect.left-(20)*(dpix/96.0));
	endPoint.y = rect.Height()-13;


	COLORREF m_Color(RGB(225,225,255));

	CClientDC aDC(this); //CClientDC的构造函数需要一个参数，这个参数是指向绘图窗口的指针，我们用this指针就可以了
	CPen pen(PS_SOLID,1,m_Color); ////建立一个画笔类对象，构造时设置画笔属性
	aDC.SelectObject(&pen);
	aDC.MoveTo(startPoint);
	aDC.LineTo(endPoint);
}


BOOL CHsAboutDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


HBRUSH CHsAboutDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

	// TODO:  在此更改 DC 的任何特性


	// TODO:  如果默认的不是所需画笔，则返回另一个画笔
	return hbr;
}


void CHsAboutDlg::OnClickedStaticHomecheck()
{
	// TODO: 在此添加控件通知处理程序代码

	HINSTANCE hIns_proc = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_HOMECHECK_BTN_CLICK),RT_GROUP_ICON);
	HBITMAP   hBmp_proc = ::LoadBitmap(hIns_proc, MAKEINTRESOURCE(IDB_BITMAP_HOMECHECK_BTN_CLICK));
	m_CheckBtn.SetBitmap(hBmp_proc);

	Sleep(100);
	((CHeavenShadowDlg*)m_wParent)->OnClickedStaticProcess();
}

```

`arkProject/HeavenShadow/HeavenShadow/HsAboutDlg.h`:

```h
#pragma once
#include "afxwin.h"
#include "MyCheckBtn.h"
#include "MyText2.h"

// CHsAboutDlg 对话框

class CHsAboutDlg : public CDialog
{
	DECLARE_DYNAMIC(CHsAboutDlg)

public:
	CHsAboutDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CHsAboutDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_ABOUT };

	CWnd* m_wParent;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnPaint();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	CMyText2 m_TextCheckAlt;
	CMyText2 m_TextSysBit;
	CMyText2 m_TextSoftBit;
	CStatic  m_PicCheckAlt;
	CStatic m_PicSysBit;
	CMyCheckBtn m_CheckBtn;
	afx_msg void OnClickedStaticHomecheck();
};

```

`arkProject/HeavenShadow/HeavenShadow/InjectFunc.cpp`:

```cpp
#include "stdafx.h"
#include "InjectFunc.h"
#include "Common.h"
#include "ProcessFunc.h"

WIN_VERSION  GetWindowsVersion();
WIN_VERSION  WinVersion = WinUnknown;

typedef long (__fastcall *pfnRtlAdjustPrivilege64)(ULONG,ULONG,ULONG,PVOID);
typedef long (__fastcall *pfnRtlAdjustPrivilege32)(ULONG,ULONG,ULONG,PVOID);
pfnRtlAdjustPrivilege64 RtlAdjustPrivilege64;
pfnRtlAdjustPrivilege32 RtlAdjustPrivilege32;

DWORD WINAPI HsRemoteThreadInjectDll(CListCtrl *m_ListCtrl)
{
	CString ProcessPath;
	ULONG_PTR ProcessId = 0;
	CString CmdLine;

	POSITION pos = m_ListCtrl->GetFirstSelectedItemPosition();

	while(pos)
	{
		int nItem = m_ListCtrl->GetNextSelectedItem(pos);

		ProcessPath = m_ListCtrl->GetItemText(nItem,HS_PROCESS_COLUMN_PATH);
		ProcessId = _ttoi(m_ListCtrl->GetItemText(nItem,HS_PROCESS_COLUMN_PID));

		CmdLine += L"-d ";
		CmdLine += m_ListCtrl->GetItemText(nItem,HS_PROCESS_COLUMN_PID);
		CmdLine += L" -p ";
		CmdLine += ProcessPath;
	}
	
	


	if (ProcessId<=4)
	{
		return FALSE;
	}

	if (HsIs32BitFile(ProcessPath.GetBuffer())==TRUE)
	{
		WinVersion = GetWindowsVersion();

		if (WinVersion >= WindowsVista)
		{
			WCHAR wzInjectPath[260] = {0};
			WCHAR* p = NULL;
			CString InjectPath;
			HMODULE module = GetModuleHandle(0);
			GetModuleFileName(module,wzInjectPath,sizeof(wzInjectPath));
			p = wcsrchr(wzInjectPath,L'\\');
			*p = 0;
			InjectPath = wzInjectPath;
			InjectPath += L"\\injectdll32.exe";

			SHELLEXECUTEINFO sei = {sizeof(SHELLEXECUTEINFO)};
			sei.lpVerb = L"runas";
			sei.lpFile = InjectPath.GetBuffer();
			sei.hwnd = GetDesktopWindow();
			sei.nShow = SW_NORMAL;
			sei.lpParameters = CmdLine.GetBuffer();

			if (!ShellExecuteEx(&sei))
			{
				MessageBox(NULL,L"注入失败",L"注入失败",0);
			}
		}
		else
		{
			ShellExecuteW(NULL,
				L"open",
				L"injectdll32.exe",
				CmdLine.GetBuffer(),
				L"",
				SW_SHOWMAXIMIZED);
		}

	}
	else
	{
		if (WinVersion >= WindowsVista)
		{
			WCHAR wzInjectPath[260] = {0};
			WCHAR* p = NULL;
			CString InjectPath;
			HMODULE module = GetModuleHandle(0);
			GetModuleFileName(module,wzInjectPath,sizeof(wzInjectPath));
			p = wcsrchr(wzInjectPath,L'\\');
			*p = 0;
			InjectPath = wzInjectPath;
			InjectPath += L"\\injectdll64.exe";

			SHELLEXECUTEINFO sei = {sizeof(SHELLEXECUTEINFO)};
			sei.lpVerb = L"runas";
			sei.lpFile = InjectPath.GetBuffer();
			sei.hwnd = GetDesktopWindow();
			sei.nShow = SW_NORMAL;
			sei.lpParameters = CmdLine.GetBuffer();

			if (!ShellExecuteEx(&sei))
			{
				MessageBox(NULL,L"注入失败",L"注入失败",0);
			}

		}
		else
		{
			ShellExecuteW(NULL,
				L"open",
				L"injectdll64.exe",
				CmdLine.GetBuffer(),
				L"",
				SW_SHOWMAXIMIZED);
		}
	}


	
	return TRUE;

	WCHAR wzFileFilter[] = L"应用程序扩展 (*.dll)\0*.dll\0所有文件 (*.*)\0*.*\0";
	WCHAR wzFileChoose[] = L"打开文件";


	CFileDialog FileDlg(TRUE);
	FileDlg.m_ofn.lpstrTitle  = wzFileChoose;
	FileDlg.m_ofn.lpstrFilter = wzFileFilter;

	if (IDOK != FileDlg.DoModal())
	{
		return FALSE;
	}

	

	CString strDllPath = FileDlg.GetPathName();

	BOOL bResult = FALSE;

	if (PathFileExists(strDllPath) && ProcessId > 4)   //注意这里的判断如果是要选择64位的Dll就要编译成64位
	{
		if (HsIs32BitFile(ProcessPath.GetBuffer())==TRUE &&
			HsIs32BitFile(strDllPath.GetBuffer())==TRUE)
		{
			bResult = HsInjectDll(TRUE,&strDllPath,ProcessId);
		}
		else if (HsIs32BitFile(ProcessPath.GetBuffer())==FALSE &&
			HsIs32BitFile(strDllPath.GetBuffer())==FALSE)
		{
			bResult = HsInjectDll(FALSE,&strDllPath,ProcessId);
		}
	}

	if (bResult == FALSE)
	{
		::MessageBox(NULL,L"远程线程注入失败。",L"天影卫士",0);

	}
	else
	{
		::MessageBox(NULL,L"远程线程注入成功。",L"天影卫士",0);
	}

	return bResult;
}


//改程序编译成64位可以注入64位 编译成32位可以注入32位

BOOL HsInjectDll(BOOL Is32Bit, CString* strDllPath, ULONG_PTR ProcessID)
{
	BOOL bResult = FALSE;

	if (ProcessID <= 0)
	{
		return FALSE;
	}


	if (PathFileExists(*strDllPath))
	{
		WinVersion = GetWindowsVersion();

		switch(WinVersion)
		{
		case Windows7:   //注意我们这里针对的是64位的Win7
			{

				WCHAR wzPath[MAX_PATH] = {0};
				wcscpy_s(wzPath, strDllPath->GetBuffer());
				strDllPath->ReleaseBuffer();

				bResult = HsInjectDllByRemoteThreadWin7(wzPath,ProcessID,Is32Bit);

				break;
			}

		case WindowsXP:  //这里是针对的32位的XP
			{
				WCHAR wzPath[MAX_PATH] = {0};
				wcscpy_s(wzPath, strDllPath->GetBuffer());

				strDllPath->ReleaseBuffer();

				bResult = HsInjectDllByRemoteThreadWinXP(wzPath,ProcessID);

				break;
			}
		}
	}
	return bResult;
}


BOOL HsInjectDllByRemoteThreadWin7(const TCHAR* wzDllFile, ULONG_PTR ProcessId, BOOL Is32Bit)
{
	if (NULL == wzDllFile || 0 == ::_tcslen(wzDllFile) || ProcessId == 0 || -1 == _taccess(wzDllFile, 0))
	{
		return FALSE;
	}
	HANDLE                 hProcess = NULL;
	HANDLE                 hThread  = NULL;
	DWORD                  dwRetVal    = 0;
	LPTHREAD_START_ROUTINE FuncAddress = NULL;
	DWORD  dwSize = 0;
	TCHAR* VirtualAddress = NULL;

#ifdef _UNICODE
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif

	if (FuncAddress==NULL)
	{
		return FALSE;
	}

	if (Is32Bit == FALSE)
	{
		RtlAdjustPrivilege64=(pfnRtlAdjustPrivilege64)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"RtlAdjustPrivilege");

		if (RtlAdjustPrivilege64==NULL)
		{
			return FALSE;
		}
		RtlAdjustPrivilege64(20,1,0,&dwRetVal);  //19
	}
	else
	{
		RtlAdjustPrivilege32=(pfnRtlAdjustPrivilege32)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"RtlAdjustPrivilege");

		if (RtlAdjustPrivilege32==NULL)
		{
			return FALSE;
		}
		RtlAdjustPrivilege32(20,1,0,&dwRetVal);  //19
	}


	hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE, (DWORD)ProcessId);

	if (NULL == hProcess)
	{
		printf("Open Process Fail\r\n");
		return FALSE;
	}

	// 在目标进程中分配内存空间
	dwSize = (DWORD)::_tcslen(wzDllFile) + 1;
	VirtualAddress = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE);  
	if (NULL == VirtualAddress)
	{

		printf("Virtual Process Memory Fail\r\n");
		CloseHandle(hProcess);
		return FALSE;
	}

	// 在目标进程的内存空间中写入所需参数(模块名)
	if (FALSE == ::WriteProcessMemory(hProcess, VirtualAddress, (LPVOID)wzDllFile, dwSize * sizeof(TCHAR), NULL))
	{
		printf("Write Data Fail\r\n");
		VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
		CloseHandle(hProcess);
		return FALSE;
	}

	hThread = ::CreateRemoteThread(hProcess, NULL, 0, FuncAddress, VirtualAddress, 0, NULL);
	if (NULL == hThread)
	{
		printf("CreateRemoteThread Fail\r\n");

		VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
		CloseHandle(hProcess);
		return FALSE;
	}


	// 等待远程线程结束
	WaitForSingleObject(hThread, INFINITE);
	// 清理
	VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
	CloseHandle(hThread);
	CloseHandle(hProcess);

	return TRUE;

}




BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId)
{
	//提高本进程的权限

	if (!HsInjectUpPrivilige())  //提权
	{
		printf("Up Privilige Is Error\n");
		return FALSE;
	}

	CStringA *Dll = new CStringA(wzDllFile);


	//我们就要打开想要打开的进程
	HANDLE hProcess = NULL;
	HANDLE hThread  = NULL;

	hProcess = OpenProcess(PROCESS_ALL_ACCESS,false,(DWORD)ProcessId);  //explorer.exe  hProcess
	if (hProcess==NULL)
	{
		printf("Open Process Is Error\n");

		return FALSE;
	}

	char* szDllName = NULL;

	szDllName = (char*)VirtualAllocEx(hProcess,
		NULL,Dll->GetLength()+1,MEM_COMMIT,PAGE_READWRITE);   

	if (szDllName==NULL)
	{

		CloseHandle(hProcess);
		printf("Apply Memory Is Error\n");

		return FALSE;
	}

	//然后将完整的路径直接写入内存

	if (!WriteProcessMemory(hProcess,szDllName,Dll->GetBuffer(),Dll->GetLength()+1,NULL))
	{

		CloseHandle(hProcess);

		printf("Write Memory Is Error\n");

		return FALSE;
	}

	LPTHREAD_START_ROUTINE StartRoutine = NULL;

	StartRoutine = 
		(LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")),
		"LoadLibraryA");

	if(StartRoutine == NULL)
	{
		printf("Get ProcAddress Error\n");
		return FALSE;
	}

	hThread = CreateRemoteThread(hProcess,NULL,0,StartRoutine,szDllName,0,NULL);

	if (hThread==NULL)
	{
		CloseHandle(hProcess);

		printf("Create Remote Thread Is Error\n");

		return FALSE;
	}

	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);
	VirtualFreeEx(hProcess,szDllName,0,MEM_RELEASE);
	CloseHandle(hProcess);

	return TRUE;
}


BOOL HsInjectUpPrivilige()	//XP
{

	HANDLE hToken = NULL;

	_TOKEN_PRIVILEGES tp = {0};

	LUID luid={0};


	if (!OpenProcessToken(GetCurrentProcess(),TOKEN_ALL_ACCESS,&hToken))
	{
		printf("OpenProcess Is Error\n");

		return FALSE;
	}

	if (!LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&luid))
	{

		printf("Lookup Is Error\n");

		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


	if (!AdjustTokenPrivileges(hToken,FALSE,&tp,sizeof(TOKEN_PRIVILEGES),NULL,NULL))
	{
		printf("Adjust Is Error\n");

		return FALSE;
	}

	return TRUE;
}


/*
BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId)
{
// 参数无效
if (NULL == wzDllFile || 0 == ::_tcslen(wzDllFile) || ProcessId == 0 || -1 == _taccess(wzDllFile, 0))
{

return FALSE;
}

HANDLE hProcess = NULL;
HANDLE hThread  = NULL;
DWORD dwSize = 0;
TCHAR* VirtualAddress = NULL;
LPTHREAD_START_ROUTINE FuncAddress = NULL;

// 获取目标进程句柄
hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, (DWORD)ProcessId);
if (NULL == hProcess)
{
printf("Open Process Fail\r\n");
return FALSE;
}

// 在目标进程中分配内存空间
dwSize = (DWORD)::_tcslen(wzDllFile) + 1;
VirtualAddress = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE);
if (NULL == VirtualAddress)
{

printf("Virtual Process Memory Fail\r\n");
CloseHandle(hProcess);
return FALSE;
}

// 在目标进程的内存空间中写入所需参数(模块名)
if (FALSE == ::WriteProcessMemory(hProcess, VirtualAddress, (LPVOID)wzDllFile, dwSize * sizeof(TCHAR), NULL))
{
printf("Write Data Fail\r\n");
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return FALSE;
}

// 从 Kernel32.dll 中获取 LoadLibrary 函数地址
#ifdef _UNICODE
FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif

if (NULL == FuncAddress)
{
printf("Get LoadLibrary Fail\r\n");
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return false;
}

// 创建远程线程调用 LoadLibrary
hThread = ::CreateRemoteThread(hProcess, NULL, 0, FuncAddress, VirtualAddress, 0, NULL);
if (NULL == hThread)
{
printf("CreateRemoteThread Fail\r\n");

VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return FALSE;
}

// 等待远程线程结束
WaitForSingleObject(hThread, INFINITE);
// 清理
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hThread);
CloseHandle(hProcess);

return TRUE;
}


*/




WIN_VERSION  GetWindowsVersion()
{
	OSVERSIONINFOEX	OsVerInfoEx;
	OsVerInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx((OSVERSIONINFO *)&OsVerInfoEx); // 注意转换类型

	switch (OsVerInfoEx.dwPlatformId)
	{
	case VER_PLATFORM_WIN32_NT:
		{
			if (OsVerInfoEx.dwMajorVersion <= 4 )
			{
				return WindowsNT;
			}
			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 0)
			{
				return Windows2000;
			}

			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 1)
			{
				return WindowsXP;
			}
			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 2)
			{
				return Windows2003;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 0)
			{
				return WindowsVista;
			}

			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 1)
			{
				return Windows7;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 2 )
			{
				return Windows8;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 3 )
			{
				return Windows8_1;
			}
			if (OsVerInfoEx.dwMajorVersion == 10 && OsVerInfoEx.dwMinorVersion == 0 )
			{
				return Windows10;
			}

			break;
		}

	default:
		{
			return WinUnknown;
		}
	}

	return WinUnknown;
}




```

`arkProject/HeavenShadow/HeavenShadow/InjectFunc.h`:

```h
#pragma once
#include "stdafx.h"





BOOL HsInjectDll(BOOL Is32Bit, CString* strDllPath, ULONG_PTR ProcessID);


BOOL HsInjectDllByRemoteThreadWin7(const TCHAR* wzDllFile, ULONG_PTR ProcessId, BOOL Is32Bit);





BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId);

BOOL HsInjectUpPrivilige();

DWORD WINAPI HsRemoteThreadInjectDll(CListCtrl *m_ListCtrl);
```

`arkProject/HeavenShadow/HeavenShadow/IoTimerFunc.cpp`:

```cpp
#include "stdafx.h"
#include "IoTimerFunc.h"
#include "Common.h"
#include "ModuleFunc.h"
#include "ThreadFunc.h"
#include "SSDTFunc.h"
#include <vector>

#include "ProcessFunc.h"

using namespace std;

typedef struct _PCOMMUNICATE_IO_TIMER_  
{
	PLIST_ENTRY     TimerEntry;
	ULONG_PTR       DeviceObject;
	BOOLEAN         bStart;
}COMMUNICATE_IO_TIMER,*PCOMMUNICATE_IO_TIMER;
typedef struct _IO_TIMERS_
{
	ULONG_PTR TimerObject;
	ULONG_PTR DeviceObject;
	ULONG_PTR TimeDispatch;
	ULONG_PTR TimerEntry;
	ULONG     Status;
}IO_TIMERS, *PIO_TIMERS;

typedef struct _IO_TIMER_INFOR_
{
	ULONG ulCnt;
	ULONG ulRetCnt;
	IO_TIMERS IoTimer[1];
}IO_TIMER_INFOR, *PIO_TIMER_INFOR;

vector<IO_TIMERS> m_IOTimerVector;
extern HANDLE g_hDevice;
extern WIN_VERSION WinVersion;
extern BOOL bIsChecking;

COLUMNSTRUCT g_Column_IOTimer[] = 
{
	{	L"定时器对象",			125	},
	{	L"设备对象",				125	},
	{	L"状态",					45	},
	{	L"函数入口",				125	},
	{	L"模块路径",				180	},
	{	L"出品厂商",				125	}
};

ULONG_PTR m_ulIOTimerCount = 0;

UINT g_Column_IOTimer_Count = 6;

extern int dpix;
extern int dpiy;


VOID HsInitIOTimerList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_IOTimer_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_IOTimer[i].szTitle,LVCFMT_LEFT,(int)(g_Column_IOTimer[i].nWidth*(dpix/96.0)));
	}
}



VOID HsLoadIOTimerList(CListCtrl *m_ListCtrl)
{
	if (bIsChecking == TRUE)
	{
		return;
	}

	// 	while(bIsChecking == TRUE)
	// 	{
	// 		Sleep(10);
	// 	}

	bIsChecking = TRUE;

	HsSendStatusDetail(L"IOTimer正在加载...");
	HsSendStatusTip(L"IOTimer");

	HsQueryIOTimerList(m_ListCtrl);

	bIsChecking = FALSE;
}



VOID HsQueryIOTimerList(CListCtrl *m_ListCtrl)
{
	BOOL bRet = FALSE;

	bRet = EnumDriver();
	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"驱动模块初始化失败...");
		return;
	}

	ULONG_PTR ulCnt = 100;
	PIO_TIMER_INFOR IOTimerInfor = NULL;
	DWORD ulReturnSize = 0;

	m_ListCtrl->DeleteAllItems();
	m_IOTimerVector.clear();

	do 
	{
		ULONG_PTR ulSize = sizeof(IO_TIMER_INFOR) + ulCnt * sizeof(IO_TIMERS);

		if (IOTimerInfor)
		{
			free(IOTimerInfor);
			IOTimerInfor = NULL;
		}

		IOTimerInfor = (PIO_TIMER_INFOR)malloc(ulSize);

		if (IOTimerInfor)
		{
			memset(IOTimerInfor, 0, ulSize);
			IOTimerInfor->ulCnt = (ULONG)ulCnt;		
			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_IOTIMER),
				NULL,
				0,
				IOTimerInfor,
				(DWORD)ulSize,
				&ulReturnSize,
				NULL);
		}

		ulCnt =IOTimerInfor->ulCnt + 10;


	} while (!bRet && IOTimerInfor->ulRetCnt > IOTimerInfor->ulCnt);

	if (!bRet)
	{
		HsSendStatusDetail(L"IOTimer加载失败。");
		return;
	}

	if (bRet &&
		IOTimerInfor->ulCnt >= IOTimerInfor->ulRetCnt)
	{
		for (ULONG i = 0; i < IOTimerInfor->ulRetCnt; i++)
		{
			m_IOTimerVector.push_back(IOTimerInfor->IoTimer[i]);
		}
	}

	if (IOTimerInfor)
	{
		free(IOTimerInfor);
		IOTimerInfor = NULL;
	}

	//////////////////////////////////////////////////////////////////////////

	m_ulIOTimerCount = 0;

	for (vector<IO_TIMERS>::iterator itor = m_IOTimerVector.begin(); itor != m_IOTimerVector.end(); itor++)
	{
		CString strTimer, strDeviceObject, strPath, strStatus, strDispatch;

		strTimer.Format(L"0x%p", itor->TimerObject);
		strDeviceObject.Format(L"0x%p", itor->DeviceObject);
		strDispatch.Format(L"0x%p", itor->TimeDispatch);
		strPath = GetDriverPath(itor->TimeDispatch);

		if (itor->Status)
		{
			strStatus = L"运行";
		}
		else
		{
			strStatus = L"停止";
		}


		int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strTimer);
		m_ListCtrl->SetItemText(n, 1, strDeviceObject);
		m_ListCtrl->SetItemText(n, 2, strStatus);
		m_ListCtrl->SetItemText(n, 3, strDispatch);
		m_ListCtrl->SetItemText(n, 4, strPath);
		m_ListCtrl->SetItemText(n, 5, HsGetFileCompanyName(strPath));

		m_ListCtrl->SetItemData(n, itor->TimerEntry);

		m_ulIOTimerCount++;

		CString StatusBarContext;
		StatusBarContext.Format(L"IOTimer正在加载。 定时器数：%d",m_ulIOTimerCount);
		HsSendStatusDetail(StatusBarContext);
	}

	CString StatusBarContext;
	StatusBarContext.Format(L"IOTimer加载完成。 定时器数：%d",m_ulIOTimerCount);
	HsSendStatusDetail(StatusBarContext);

}



VOID HsOperIOTimer(CListCtrl* m_ListCtrl)
{
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;
	int Index = m_ListCtrl->GetSelectionMark();

	if (Index<0)
	{
		return;
	}

	CString Temp = m_ListCtrl->GetItemText(Index,1);

	COMMUNICATE_IO_TIMER  IOTimer;

	for ( vector <IO_TIMERS>::iterator Iter = m_IOTimerVector.begin( ); Iter != m_IOTimerVector.end( ); Iter++ )
	{
		CString strObject;
		strObject.Format(L"0x%p", Iter->DeviceObject);
		if (!strObject.CompareNoCase(Temp))
		{

			IOTimer.DeviceObject = Iter->DeviceObject;

			if (Iter->Status)
			{

				IOTimer.bStart = 0;
			}
			else
			{

				IOTimer.bStart = 1;
			}


			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_OPERIOTIMER),
				&IOTimer,
				sizeof(COMMUNICATE_IO_TIMER),
				NULL,
				0,
				&ulReturnSize,
				NULL);

			break;
		}	
	}

	if (bRet == TRUE)
	{
		HsQueryIOTimerList(m_ListCtrl);
	}

	bIsChecking = FALSE;
}




VOID HsRemoveIOTimerItem(CListCtrl* m_ListCtrl)
{
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;
	int Index = m_ListCtrl->GetSelectionMark();

	if (Index<0)
	{
		return;
	}

	CString Temp = m_ListCtrl->GetItemText(Index,3);

	COMMUNICATE_IO_TIMER  IOTimer;

	for ( vector <IO_TIMERS>::iterator Iter = m_IOTimerVector.begin( ); Iter != m_IOTimerVector.end( ); Iter++ )
	{

		if (m_ListCtrl->GetItemData(Index)==Iter->TimerEntry)
		{

			IOTimer.TimerEntry = (PLIST_ENTRY)Iter->TimerEntry;


			bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_REMOVEIOTIMER),
				&IOTimer,
				sizeof(COMMUNICATE_IO_TIMER),
				NULL,
				0,
				&ulReturnSize,
				NULL);


			break;
		}	
	}
	

	if (bRet)
	{
		HsQueryIOTimerList(m_ListCtrl);
	}


	bIsChecking = FALSE;
}
```

`arkProject/HeavenShadow/HeavenShadow/IoTimerFunc.h`:

```h
#pragma once
#include "stdafx.h"




VOID HsInitIOTimerList(CListCtrl *m_ListCtrl);

VOID HsLoadIOTimerList(CListCtrl *m_ListCtrl);

VOID HsQueryIOTimerList(CListCtrl *m_ListCtrl);

VOID HsOperIOTimer(CListCtrl* m_ListCtrl);

VOID HsRemoveIOTimerItem(CListCtrl* m_ListCtrl);














```

`arkProject/HeavenShadow/HeavenShadow/KernelDlg.cpp`:

```cpp
// KernelDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "KernelDlg.h"
#include "afxdialogex.h"

#include "SSDTFunc.h"
#include "SSSDTFunc.h"
#include "SysThread.h"

#include "KernelFunc.h"

#include "HeavenShadowDlg.h"

// CKernelDlg 对话框


enum HS_KERNEL_LIST
{
	HS_KERNEL_SSDT,
	HS_KERNEL_SSSDT,
	HS_KERNEL_KRNLFUNC,
	HS_KERNEL_KRNLIAT,
	HS_KERNEL_KRNLEAT,
};

extern int dpix;
extern int dpiy;

extern BOOL bIsChecking;

BOOL bNowKernelSel = 255;


IMPLEMENT_DYNAMIC(CKernelDlg, CDialog)

CKernelDlg::CKernelDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CKernelDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CKernelDlg::~CKernelDlg()
{
}

void CKernelDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_KERNEL, m_ListKernel);
	DDX_Control(pDX, IDC_LIST_KERNEL_CTRL, m_ListKernelCtrl);
	DDX_Control(pDX, IDC_LIST_KRNLNAME, m_KernelNameList);
}


BEGIN_MESSAGE_MAP(CKernelDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
	ON_LBN_SELCHANGE(IDC_LIST_KERNEL, &CKernelDlg::OnSelchangeListKernel)
	ON_NOTIFY(NM_CUSTOMDRAW, IDC_LIST_KERNEL_CTRL, &CKernelDlg::OnNMCustomdrawListKernelCtrl)
	ON_COMMAND(ID_MENU_SSDT_REFRESH, &CKernelDlg::OnMenuSsdtRefresh)
	ON_NOTIFY(NM_RCLICK, IDC_LIST_KERNEL_CTRL, &CKernelDlg::OnNMRClickListKernelCtrl)
	ON_COMMAND(ID_MENU_SSDT_RESUME, &CKernelDlg::OnMenuSsdtResume)
	ON_LBN_SELCHANGE(IDC_LIST_KRNLNAME, &CKernelDlg::OnLbnSelchangeListKrnlname)
END_MESSAGE_MAP()


// CKernelDlg 消息处理程序


BOOL CKernelDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


BOOL CKernelDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	InitKernelList();

	UINT uIconSize = 20;

	uIconSize *= (UINT)(dpix/96.0);

	m_TreeKernelImageList.Create(1, uIconSize, ILC_COLOR32 | ILC_MASK, 2, 2);

	ListView_SetImageList(m_ListKernelCtrl.m_hWnd, m_TreeKernelImageList.GetSafeHandle(), LVSIL_SMALL);

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CKernelDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()
 
 	CRect   rect;
 	GetClientRect(rect);
 	dc.FillSolidRect(rect,RGB(255,255,255));

	CRect KernelListRect;
	CRect KernelNameRect;
	CRect KernelCtrlRect;

	//m_ListKernel.GetClientRect(KernelListRect);
	m_ListKernel.GetWindowRect(&KernelListRect);
	ClientToScreen(&rect);
	KernelListRect.left -= rect.left;
	KernelListRect.right -= rect.left;
	KernelListRect.top -= rect.top;
	KernelListRect.bottom -= rect.top;
	KernelListRect.bottom = rect.Height() - 2;
	//m_ListKernel.MoveWindow(&KernelListRect);

	CPoint startPoint;
	startPoint.x = (LONG)(KernelListRect.right)+2;
	startPoint.y = -1;
	CPoint endPoint;
	endPoint.x = (LONG)(KernelListRect.right)+2;
	endPoint.y = rect.Height()+2;

	KernelCtrlRect.left = startPoint.x+1;
	KernelCtrlRect.right = rect.Width();
	KernelCtrlRect.top = 0;
	KernelCtrlRect.bottom = rect.Height();
	m_ListKernelCtrl.MoveWindow(KernelCtrlRect);

// 	CPoint startPoint;
// 	startPoint.x = (UINT)(98*(dpix/96.0))+2;
// 	startPoint.y = -1;
// 	CPoint endPoint;
// 	endPoint.x = (UINT)(98*(dpix/96.0))+2;
// 	endPoint.y = rect.Height()+2;


	COLORREF m_Color(RGB(190,190,190));

	CClientDC aDC(this);			//CClientDC的构造函数需要一个参数，这个参数是指向绘图窗口的指针，我们用this指针就可以了
	CPen pen(PS_SOLID,1,m_Color);	//建立一个画笔类对象，构造时设置画笔属性
	aDC.SelectObject(&pen);
	aDC.MoveTo(startPoint);
	aDC.LineTo(endPoint);

	

	if (m_KernelNameList.IsWindowVisible())
	{
		KernelListRect.bottom = rect.Height()/2;

		startPoint.x = -1;
		startPoint.y = (LONG)(KernelListRect.bottom) + 2;
		endPoint.x = (LONG)(KernelListRect.right) + 2;
		endPoint.y = (LONG)(KernelListRect.bottom) + 2;

		m_KernelNameList.MoveWindow(
			KernelListRect.left,
			KernelListRect.bottom+5,
			KernelListRect.Width(),
			rect.Height()-KernelListRect.bottom-7
			);

		CPen pen2(PS_SOLID,1,m_Color);	//建立一个画笔类对象，构造时设置画笔属性
		aDC.SelectObject(&pen2);
		aDC.MoveTo(startPoint);
		aDC.LineTo(endPoint);
	}

	m_ListKernel.MoveWindow(&KernelListRect);

}


void CKernelDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	if (bShow == TRUE)
	{
		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_KERNEL;

		((CHeavenShadowDlg*)m_wParent)->m_btnKrnl.EnableWindow(FALSE);

		HsSendStatusDetail(L"操作系统内核信息。");
		HsSendStatusTip(L"内核");

		m_ListKernel.SetCurSel(HS_KERNEL_SSDT);
		
		bNowKernelSel = 255;

		OnSelchangeListKernel();

		m_ListKernelCtrl.SetFocus();

	}
}


void CKernelDlg::InitKernelList(void)
{
	m_ListKernel.AddString(L"SSDT");
	m_ListKernel.InsertString(HS_KERNEL_SSSDT,L"ShadowSSDT");
	m_ListKernel.InsertString(HS_KERNEL_KRNLFUNC,L"内核函数");
 	m_ListKernel.InsertString(HS_KERNEL_KRNLIAT,L"内核导入表");
 	m_ListKernel.InsertString(HS_KERNEL_KRNLEAT,L"内核导出表");

	m_ListKernel.SetItemHeight(-1,(UINT)(16*(dpiy/96.0)));
	m_KernelNameList.SetItemHeight(-1,(UINT)(16*(dpiy/96.0)));
}


void CKernelDlg::OnSelchangeListKernel()
{
	// TODO: 在此添加控件通知处理程序代码

	int nCurSel = m_ListKernel.GetCurSel();

	switch(nCurSel)
	{
	case HS_KERNEL_SSDT:
		{
			if (bIsChecking == TRUE || bNowKernelSel == HS_KERNEL_SSDT)	//
			{
				m_ListKernel.SetCurSel(bNowKernelSel);
				m_ListKernelCtrl.SetFocus();
				return;
			}

			bNowKernelSel = nCurSel;
			bIsChecking = TRUE;

			m_KernelNameList.ShowWindow(FALSE);

			HsInitSSDTList(&m_ListKernelCtrl);

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsLoadSSDTList,&m_ListKernelCtrl, 0,NULL)
				);
			//HsLoadSSDTList(&m_ListKernelCtrl);
			break;
		}
	case HS_KERNEL_SSSDT:
		{
			if (bIsChecking == TRUE || bNowKernelSel == HS_KERNEL_SSSDT)	//
			{
				m_ListKernel.SetCurSel(bNowKernelSel);
				m_ListKernelCtrl.SetFocus();
				return;
			}

			bNowKernelSel = nCurSel;
			bIsChecking = TRUE;

			m_KernelNameList.ShowWindow(FALSE);

			HsInitSSSDTList(&m_ListKernelCtrl);

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsLoadSSSDTList,&m_ListKernelCtrl, 0,NULL)
				);
			//HsLoadSSSDTList(&m_ListKernelCtrl);
			break;
		}

	case HS_KERNEL_KRNLFUNC:
		{
			if (bIsChecking == TRUE || bNowKernelSel == HS_KERNEL_KRNLFUNC)	//
			{
				m_ListKernel.SetCurSel(bNowKernelSel);
				m_ListKernelCtrl.SetFocus();
				Sleep(50);
				return;
			}

			bNowKernelSel = nCurSel;

			m_KernelNameList.ShowWindow(TRUE);

			HsSendStatusDetail(L"内核函数正在加载...");

			HsInitKernelFuncList(&m_KernelNameList, &m_ListKernelCtrl);

			m_KernelNameList.SetCurSel(0);

			OnLbnSelchangeListKrnlname();

			break;
		}

	case HS_KERNEL_KRNLIAT:
		{
			if (bIsChecking == TRUE || bNowKernelSel == HS_KERNEL_KRNLIAT)	//
			{
				m_ListKernel.SetCurSel(bNowKernelSel);
				m_ListKernelCtrl.SetFocus();
				Sleep(50);
				return;
			}

			bNowKernelSel = nCurSel;

			m_KernelNameList.ShowWindow(TRUE);

			HsSendStatusDetail(L"内核导入表正在加载...");

			HsInitKernelFileList(&m_KernelNameList, &m_ListKernelCtrl);

// 			m_KernelNameList.SetCurSel(0);
// 
// 			OnLbnSelchangeListKrnlname();

			break;
		}
	case HS_KERNEL_KRNLEAT:
		{
			if (bIsChecking == TRUE || bNowKernelSel == HS_KERNEL_KRNLEAT)	//
			{
				m_ListKernel.SetCurSel(bNowKernelSel);
				m_ListKernelCtrl.SetFocus();
				Sleep(50);
				return;
			}

			bNowKernelSel = nCurSel;

			m_KernelNameList.ShowWindow(TRUE);

			HsSendStatusDetail(L"内核导入表正在加载...");

			HsInitKernelFileList(&m_KernelNameList, &m_ListKernelCtrl);

// 			m_KernelNameList.SetCurSel(0);
// 
// 			OnLbnSelchangeListKrnlname();

			break;
		}
	default:
		{

		}
	}

	m_ListKernelCtrl.SetFocus();
}


void CKernelDlg::OnNMCustomdrawListKernelCtrl(NMHDR *pNMHDR, LRESULT *pResult)
{
	NMLVCUSTOMDRAW* pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>( pNMHDR );
	// TODO: 在此添加控件通知处理程序代码

	*pResult = CDRF_DODEFAULT;

	if ( CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage )
	{
		*pResult = CDRF_NOTIFYITEMDRAW;
	}
	else if ( CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage )
	{
		*pResult = CDRF_NOTIFYSUBITEMDRAW;
	}
	else if ( (CDDS_ITEMPREPAINT | CDDS_SUBITEM) == pLVCD->nmcd.dwDrawStage )
	{
		COLORREF clrNewTextColor, clrNewBkColor;
		int bHooked = 0;
		int nItem = static_cast<int>( pLVCD->nmcd.dwItemSpec );

		clrNewTextColor = RGB( 0, 0, 0 );
		clrNewBkColor = RGB( 255, 255, 255 );

		bHooked = (int)m_ListKernelCtrl.GetItemData(nItem); 		
		if (bHooked == 1)
		{
			clrNewTextColor = RGB( 255, 0, 0 );
		}

		pLVCD->clrText = clrNewTextColor;
		pLVCD->clrTextBk = clrNewBkColor;

		*pResult = CDRF_DODEFAULT;
	}

}




void CKernelDlg::OnNMRClickListKernelCtrl(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	CMenu	popup;
	CPoint	p;

	switch(bNowKernelSel)
	{
	case HS_KERNEL_SSDT:
		{
			popup.LoadMenu(IDR_MENU_KERNEL_SSDT);			//加载菜单资源
			CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项

			GetCursorPos(&p);
			int	count = pM->GetMenuItemCount();
			if (m_ListKernelCtrl.GetSelectedCount() == 0)		//如果没有选中
			{ 
				for (int i = 0;i<count;i++)
				{
					pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}

			POSITION pos = m_ListKernelCtrl.GetFirstSelectedItemPosition();

			while (pos)
			{
				int nItem = m_ListKernelCtrl.GetNextSelectedItem(pos);

				if (_wcsnicmp(L"正常",m_ListKernelCtrl.GetItemText(nItem,5),wcslen(L"正常"))==0)
				{
					pM->EnableMenuItem(ID_MENU_SSDT_RESUME, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}

			pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);
			break;
		}
	case HS_KERNEL_SSSDT:
		{
			popup.LoadMenu(IDR_MENU_KERNEL_SSDT);			//加载菜单资源
			CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项

			GetCursorPos(&p);
			int	count = pM->GetMenuItemCount();
			if (m_ListKernelCtrl.GetSelectedCount() == 0)		//如果没有选中
			{ 
				for (int i = 0;i<count;i++)
				{
					pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}

			}

			POSITION pos = m_ListKernelCtrl.GetFirstSelectedItemPosition();

			while (pos)
			{
				int nItem = m_ListKernelCtrl.GetNextSelectedItem(pos);

				if (_wcsnicmp(L"正常",m_ListKernelCtrl.GetItemText(nItem,5),wcslen(L"正常"))==0)
				{
					pM->EnableMenuItem(ID_MENU_SSDT_RESUME, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}

			pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);
			break;
		}
	default:
		{

		}
	}


	*pResult = 0;
}



//////////////////////////////////////////////////////////////////////////


void CKernelDlg::OnMenuSsdtRefresh()
{
	// TODO: 在此添加命令处理程序代码

	switch(bNowKernelSel)
	{
	case HS_KERNEL_SSDT:
		{
			bNowKernelSel = 255;

			m_ListKernel.SetCurSel(HS_KERNEL_SSDT);

			OnSelchangeListKernel();
			break;
		}
	case HS_KERNEL_SSSDT:
		{
			bNowKernelSel = 255;

			m_ListKernel.SetCurSel(HS_KERNEL_SSSDT);

			OnSelchangeListKernel();
			break;
		}
	}


}

void CKernelDlg::OnMenuSsdtResume()
{
	// TODO: 在此添加命令处理程序代码

	switch(bNowKernelSel)
	{
	case HS_KERNEL_SSDT:
		{
			HsResumeSSDTHook(&m_ListKernelCtrl);
			break;
		}
	case HS_KERNEL_SSSDT:
		{
			break;
		}
	}
}


void CKernelDlg::OnLbnSelchangeListKrnlname()
{
	// TODO: 在此添加控件通知处理程序代码

	switch(bNowKernelSel)
	{
	case HS_KERNEL_KRNLFUNC:
		{
			SelchangeListKrnlFunc(&m_KernelNameList, &m_ListKernelCtrl);
			break;
		}
	case HS_KERNEL_KRNLIAT:
		{
			SelchangeListKrnlIAT(&m_KernelNameList, &m_ListKernelCtrl);
			break;
		}
	case HS_KERNEL_KRNLEAT:
		{
			SelchangeListKrnlEAT(&m_KernelNameList, &m_ListKernelCtrl);
			break;
		}
	default:
		{

		}
	}

	m_ListKernelCtrl.SetFocus();
}

```

`arkProject/HeavenShadow/HeavenShadow/KernelDlg.h`:

```h
#pragma once
#include "afxwin.h"
#include "afxcmn.h"

// CKernelDlg 对话框

class CKernelDlg : public CDialog
{
	DECLARE_DYNAMIC(CKernelDlg)

public:
	CKernelDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CKernelDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_KERNEL };

	CWnd* m_wParent;

	CImageList m_TreeKernelImageList;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	void InitKernelList(void);
	CListBox m_ListKernel;
	CListCtrl m_ListKernelCtrl;
	afx_msg void OnSelchangeListKernel();
	afx_msg void OnNMCustomdrawListKernelCtrl(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuSsdtRefresh();
	afx_msg void OnNMRClickListKernelCtrl(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuSsdtResume();
	CListBox m_KernelNameList;
	afx_msg void OnLbnSelchangeListKrnlname();
};

```

`arkProject/HeavenShadow/HeavenShadow/KernelFunc.cpp`:

```cpp
#include "stdafx.h"
#include "KernelFunc.h"
#include "Common.h"
#include "SSDTFunc.h"
#include "ProcessFunc.h"
#include "ModuleFunc.h"
#include <vector>

using namespace std;

BOOL bNowSelKernelFile = 255;

extern BOOL bIsChecking;

extern HANDLE g_hDevice;
extern vector<DRIVER_INFO> m_DriverList;


COLUMNSTRUCT g_Column_KernelFunc[] = 
{
	{	L"序号",					50	},
	{	L"函数名称",				205	},
	{	L"函数当前地址",			135	},
	{	L"函数原地址",			135	},
	{	L"模块文件",				115	},
	{	L"状态",					85	}
};

UINT g_Column_KernelFunc_Count  = 6;	  //进程列表列数

extern int dpix;
extern int dpiy;


void HsInitKernelFuncList(CListBox* m_ListBox, CListCtrl* m_ListCtrl)
{
	if (m_ListBox->GetCount())
	{
		while(m_ListBox->DeleteString(0));
	}
	

	m_ListBox->AddString(L"ntoskrnl.exe [IAT]");
	m_ListBox->InsertString(HS_KERNEL_KERNELFILE_NTOSKRNL_EAT,L"ntoskrnl.exe [EAT]");
	m_ListBox->InsertString(HS_KERNEL_KERNELFILE_WIN32K_IAT,L"win32k.sys [IAT]");
	m_ListBox->InsertString(HS_KERNEL_KERNELFILE_WIN32K_EAT,L"win32k.sys [EAT]");
	m_ListBox->InsertString(HS_KERNEL_KERNELFILE_HALDLL_IAT,L"hal.dll [IAT]");
	m_ListBox->InsertString(HS_KERNEL_KERNELFILE_HALDLL_EAT,L"hal.dll [EAT]");

	m_ListCtrl->DeleteAllItems();
	while(m_ListCtrl->DeleteColumn(0));

	//////////////////////////////////////////////////////////////////////////

	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_KernelFunc_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_KernelFunc[i].szTitle,LVCFMT_LEFT,(int)(g_Column_KernelFunc[i].nWidth*(dpix/96.0)));
	}

	bNowSelKernelFile = 255;
}


void HsInitKernelFileList(CListBox* m_ListBox, CListCtrl* m_ListCtrl)
{
	if (m_ListBox->GetCount())
	{
		while(m_ListBox->DeleteString(0));
	}

	m_ListCtrl->DeleteAllItems();
	while(m_ListCtrl->DeleteColumn(0));

	//////////////////////////////////////////////////////////////////////////

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_KernelFunc_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_KernelFunc[i].szTitle,LVCFMT_LEFT,(int)(g_Column_KernelFunc[i].nWidth*(dpix/96.0)));
	}

	//////////////////////////////////////////////////////////////////////////

	m_DriverList.clear();

	BOOL bRet = FALSE;

	bRet = EnumDriver();

	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"内核导入表加载失败。");
		return;
	}


	i = 0;

	CString ModuleName;

	for (vector<DRIVER_INFO>::iterator itor = m_DriverList.begin(); 
		itor != m_DriverList.end(); 
		itor++)
	{
		ModuleName = wcsrchr(itor->wzDriverPath,L'\\');

		ModuleName = ModuleName.GetBuffer()+1;

		if (i==0)
		{
			m_ListBox->AddString(ModuleName);
		}
		else if (wcslen(itor->wzDriverPath)>0)
		{
			m_ListBox->InsertString(i,ModuleName);
		}
		i++;
		
	}

	bNowSelKernelFile = 255;
}


void SelchangeListKrnlIAT(CListBox* m_ListBox,  CListCtrl* m_ListCtrl)
{
	HsSendStatusTip(L"内核函数");

	int nCurSel = m_ListBox->GetCurSel();

	if (bIsChecking == TRUE || bNowSelKernelFile == nCurSel)	//
	{
		m_ListBox->SetCurSel(bNowSelKernelFile);
		m_ListCtrl->SetFocus();
		return;
	}

	bIsChecking = TRUE;

	bNowSelKernelFile = nCurSel;

	CString ModuleFile;

	m_ListBox->GetText(m_ListBox->GetCurSel(), ModuleFile);

	CString DetailContext;
	DetailContext.Format(L"%s的IAT正在加载...",ModuleFile.GetBuffer());

	HsSendStatusDetail(DetailContext);

	//////////////////////////////////////////////////////////////////////////

	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_IAT IAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	do 
	{
		ULONG_PTR ulSize = 0;

		if (IAT)
		{
			free(IAT);
			IAT = NULL;
		}

		ulSize = sizeof(MODULE_IAT) + ulCount * sizeof(IAT_INFO);

		IAT = (PMODULE_IAT)malloc(ulSize);
		if (!IAT)
		{
			break;
		}

		memset(IAT,0,ulSize);

		CStringA ModuleFileA(ModuleFile);

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLIAT),
			ModuleFileA.GetBuffer(),
			ModuleFileA.GetLength(),
			IAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);


		ulCount = IAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && IAT)
	{
		for (ULONG i = 0; i < IAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(IAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",IAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",IAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(IAT->Data[i].szModuleName);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (IAT->Data[i].CurFuncAddress == IAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"%s的IAT正在加载。 IAT函数：%d",ModuleFile,i);
			HsSendStatusDetail(StatusBarContext);
		}

		CString StatusBarContext;
		StatusBarContext.Format(L"%s的IAT加载完成。 IAT函数：%d",ModuleFile,IAT->ulCount);
		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		CString StatusBarContext;
		StatusBarContext.Format(L"%s的IAT加载失败。",ModuleFile);
		HsSendStatusDetail(ModuleFile);
	}

	if (IAT)
	{
		free(IAT);
		IAT = NULL;
	}

	bIsChecking = FALSE;

}


void SelchangeListKrnlEAT(CListBox* m_ListBox,  CListCtrl* m_ListCtrl)
{
	HsSendStatusTip(L"内核函数");

	int nCurSel = m_ListBox->GetCurSel();

	if (bIsChecking == TRUE || bNowSelKernelFile == nCurSel)	//
	{
		m_ListBox->SetCurSel(bNowSelKernelFile);
		m_ListCtrl->SetFocus();
		return;
	}

	bIsChecking = TRUE;

	bNowSelKernelFile = nCurSel;

	CString ModuleFile;

	m_ListBox->GetText(m_ListBox->GetCurSel(), ModuleFile);

	CString DetailContext;
	DetailContext.Format(L"%s的EAT正在加载...",ModuleFile.GetBuffer());

	HsSendStatusDetail(DetailContext);

	//////////////////////////////////////////////////////////////////////////

	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_EAT EAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	do 
	{
		ULONG_PTR ulSize = 0;

		if (EAT)
		{
			free(EAT);
			EAT = NULL;
		}

		ulSize = sizeof(MODULE_EAT) + ulCount * sizeof(EAT_INFO);

		EAT = (PMODULE_EAT)malloc(ulSize);
		if (!EAT)
		{
			break;
		}

		memset(EAT,0,ulSize);

		CStringA ModuleFileA(ModuleFile);

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLEAT),
			ModuleFileA.GetBuffer(),
			ModuleFileA.GetLength(),
			EAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);


		ulCount = EAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && EAT)
	{
		for (ULONG i = 0; i < EAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(EAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",EAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",EAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(ModuleFile);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (EAT->Data[i].CurFuncAddress == EAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"%s的EAT正在加载。 EAT函数：%d",ModuleFile,i);
			HsSendStatusDetail(StatusBarContext);
		}

		CString StatusBarContext;
		StatusBarContext.Format(L"%s的EAT加载完成。 EAT函数：%d",ModuleFile,EAT->ulCount);
		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		CString StatusBarContext;
		StatusBarContext.Format(L"%s的EAT加载失败。",ModuleFile);
		HsSendStatusDetail(ModuleFile);
	}

	if (EAT)
	{
		free(EAT);
		EAT = NULL;
	}

	bIsChecking = FALSE;

}


void SelchangeListKrnlFunc(CListBox* m_ListBox, CListCtrl* m_ListCtrl)
{
	HsSendStatusTip(L"内核函数");

	int nCurSel = m_ListBox->GetCurSel();

	switch (nCurSel)
	{
	case HS_KERNEL_KERNELFILE_NTOSKRNL_IAT:
		{
			if (bIsChecking == TRUE || bNowSelKernelFile == HS_KERNEL_KERNELFILE_NTOSKRNL_IAT)	//
			{
				m_ListBox->SetCurSel(bNowSelKernelFile);
				m_ListCtrl->SetFocus();
				return;
			}

			bIsChecking = TRUE;

			bNowSelKernelFile = nCurSel;

			//////////////////////////////////////////////////////////////////////////

			HsSendStatusDetail(L"ntoskrnl.exe的IAT正在加载...");

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsEnumKernelFuncNameNtoskrnlIAT,m_ListCtrl, 0,NULL)
				);

			//HsEnumKernelFuncNameNtoskrnlIAT(m_ListCtrl);

			break;
		}
	case HS_KERNEL_KERNELFILE_NTOSKRNL_EAT:
		{
			if (bIsChecking == TRUE || bNowSelKernelFile == HS_KERNEL_KERNELFILE_NTOSKRNL_EAT)	//
			{
				m_ListBox->SetCurSel(bNowSelKernelFile);
				m_ListCtrl->SetFocus();
				return;
			}

			bIsChecking = TRUE;

			bNowSelKernelFile = nCurSel;

			//////////////////////////////////////////////////////////////////////////

			HsSendStatusDetail(L"ntoskrnl.exe的EAT正在加载...");

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsEnumKernelFuncNameNtoskrnlEAT,m_ListCtrl, 0,NULL)
				);

			//HsEnumKernelFuncNameNtoskrnlEAT(m_ListCtrl);

			break;
		}
	case HS_KERNEL_KERNELFILE_WIN32K_IAT:
		{
			if (bIsChecking == TRUE || bNowSelKernelFile == HS_KERNEL_KERNELFILE_WIN32K_IAT)	//
			{
				m_ListBox->SetCurSel(bNowSelKernelFile);
				m_ListCtrl->SetFocus();
				return;
			}

			bIsChecking = TRUE;

			bNowSelKernelFile = nCurSel;

			//////////////////////////////////////////////////////////////////////////

			HsSendStatusDetail(L"ntoskrnl.exe的IAT正在加载...");

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsEnumKernelFuncNameWin32kIAT,m_ListCtrl, 0,NULL)
				);

			//HsEnumKernelFuncNameWin32kIAT(m_ListCtrl);

			break;
		}
	case HS_KERNEL_KERNELFILE_WIN32K_EAT:
		{
			if (bIsChecking == TRUE || bNowSelKernelFile == HS_KERNEL_KERNELFILE_WIN32K_EAT)	//
			{
				m_ListBox->SetCurSel(bNowSelKernelFile);
				m_ListCtrl->SetFocus();
				return;
			}

			bIsChecking = TRUE;

			bNowSelKernelFile = nCurSel;

			//////////////////////////////////////////////////////////////////////////

			HsSendStatusDetail(L"ntoskrnl.exe的EAT正在加载...");

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsEnumKernelFuncNameWin32kEAT,m_ListCtrl, 0,NULL)
				);

			//HsEnumKernelFuncNameWin32kEAT(m_ListCtrl);

			break;
		}
	case HS_KERNEL_KERNELFILE_HALDLL_IAT:
		{
			if (bIsChecking == TRUE || bNowSelKernelFile == HS_KERNEL_KERNELFILE_HALDLL_IAT)	//
			{
				m_ListBox->SetCurSel(bNowSelKernelFile);
				m_ListCtrl->SetFocus();
				return;
			}

			bIsChecking = TRUE;

			bNowSelKernelFile = nCurSel;

			//////////////////////////////////////////////////////////////////////////

			HsSendStatusDetail(L"hal.dll的IAT正在加载...");

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsEnumKernelFuncNameHaldllIAT,m_ListCtrl, 0,NULL)
				);

			//HsEnumKernelFuncNameHaldllIAT(m_ListCtrl);

			break;
		}
	case HS_KERNEL_KERNELFILE_HALDLL_EAT:
		{
			if (bIsChecking == TRUE || bNowSelKernelFile == HS_KERNEL_KERNELFILE_HALDLL_EAT)	//
			{
				m_ListBox->SetCurSel(bNowSelKernelFile);
				m_ListCtrl->SetFocus();
				return;
			}

			bIsChecking = TRUE;

			bNowSelKernelFile = nCurSel;

			//////////////////////////////////////////////////////////////////////////

			HsSendStatusDetail(L"hal.dll的EAT正在加载...");

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsEnumKernelFuncNameHaldllEAT,m_ListCtrl, 0,NULL)
				);

			//HsEnumKernelFuncNameHaldllEAT(m_ListCtrl);

			break;
		}
	}

}



void HsEnumKernelFuncNameNtoskrnlIAT(CListCtrl* m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_IAT IAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	do 
	{
		ULONG_PTR ulSize = 0;

		if (IAT)
		{
			free(IAT);
			IAT = NULL;
		}

		ulSize = sizeof(MODULE_IAT) + ulCount * sizeof(IAT_INFO);

		IAT = (PMODULE_IAT)malloc(ulSize);
		if (!IAT)
		{
			break;
		}

		memset(IAT,0,ulSize);

		int KernelFile = HS_KERNEL_KERNELFILE_NTOSKRNL_IAT;

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLFILE),
			&KernelFile,
			sizeof(int),
			IAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);


		ulCount = IAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && IAT)
	{
		for (ULONG i = 0; i < IAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(IAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",IAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",IAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(IAT->Data[i].szModuleName);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (IAT->Data[i].CurFuncAddress == IAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"ntoskrnl.exe的IAT正在加载。 IAT函数：%d",i);

			HsSendStatusDetail(StatusBarContext);
		}

		CString StatusBarContext;
		StatusBarContext.Format(L"ntoskrnl.exe的IAT加载完成。 IAT函数：%d",IAT->ulCount);

		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		HsSendStatusDetail(L"ntoskrnl.exe的IAT加载失败。");
	}
	//m_strIATCount.Format(L"%d",IAT->ulCount);
	if (IAT)
	{
		free(IAT);
		IAT = NULL;
	}

	
	bIsChecking = FALSE;
}


void HsEnumKernelFuncNameNtoskrnlEAT(CListCtrl* m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_EAT EAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	CString ModuleFile(L"ntoskrnl.exe");

	do 
	{
		ULONG_PTR ulSize = 0;

		if (EAT)
		{
			free(EAT);
			EAT = NULL;
		}

		ulSize = sizeof(MODULE_EAT) + ulCount * sizeof(EAT_INFO);

		EAT = (PMODULE_EAT)malloc(ulSize);
		if (!EAT)
		{
			break;
		}

		memset(EAT,0,ulSize);

		int KernelFile = HS_KERNEL_KERNELFILE_NTOSKRNL_EAT;

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLFILE),
			&KernelFile,
			sizeof(int),
			EAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);

		ulCount = EAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && EAT)
	{
		for (ULONG i = 0; i < EAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(EAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",EAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",EAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(ModuleFile);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (EAT->Data[i].CurFuncAddress == EAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"ntoskrnl.exe的EAT正在加载。 EAT函数：%d",i);

			HsSendStatusDetail(StatusBarContext);
		}

		CString StatusBarContext;
		StatusBarContext.Format(L"ntoskrnl.exe的EAT加载完成。 EAT函数：%d",EAT->ulCount);

		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		HsSendStatusDetail(L"ntoskrnl.exe的EAT加载失败。");
	}
	//m_strEATCount.Format(L"%d",EAT->ulCount);
	if (EAT)
	{
		free(EAT);
		EAT = NULL;
	}

	
	bIsChecking = FALSE;
}


void HsEnumKernelFuncNameWin32kIAT(CListCtrl* m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_IAT IAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	do 
	{
		ULONG_PTR ulSize = 0;

		if (IAT)
		{
			free(IAT);
			IAT = NULL;
		}

		ulSize = sizeof(MODULE_IAT) + ulCount * sizeof(IAT_INFO);

		IAT = (PMODULE_IAT)malloc(ulSize);
		if (!IAT)
		{
			break;
		}

		memset(IAT,0,ulSize);

		int KernelFile = HS_KERNEL_KERNELFILE_WIN32K_IAT;

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLFILE),
			&KernelFile,
			sizeof(int),
			IAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);


		ulCount = IAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && IAT)
	{
		for (ULONG i = 0; i < IAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(IAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",IAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",IAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(IAT->Data[i].szModuleName);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (IAT->Data[i].CurFuncAddress == IAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"win32k.sys的IAT正在加载。 IAT函数：%d",i);

			HsSendStatusDetail(StatusBarContext);

		}

		CString StatusBarContext;
		StatusBarContext.Format(L"win32k.sys的IAT加载完成。 IAT函数：%d",IAT->ulCount);

		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		HsSendStatusDetail(L"win32k.sys的IAT加载失败。");
	}
	//m_strIATCount.Format(L"%d",IAT->ulCount);
	if (IAT)
	{
		free(IAT);
		IAT = NULL;
	}

	
	bIsChecking = FALSE;
}


void HsEnumKernelFuncNameWin32kEAT(CListCtrl* m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_EAT EAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	CString ModuleFile(L"win32k.sys");

	do 
	{
		ULONG_PTR ulSize = 0;

		if (EAT)
		{
			free(EAT);
			EAT = NULL;
		}

		ulSize = sizeof(MODULE_EAT) + ulCount * sizeof(EAT_INFO);

		EAT = (PMODULE_EAT)malloc(ulSize);
		if (!EAT)
		{
			break;
		}

		memset(EAT,0,ulSize);

		int KernelFile = HS_KERNEL_KERNELFILE_WIN32K_EAT;

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLFILE),
			&KernelFile,
			sizeof(int),
			EAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);

		ulCount = EAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && EAT)
	{
		for (ULONG i = 0; i < EAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(EAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",EAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",EAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(ModuleFile);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (EAT->Data[i].CurFuncAddress == EAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"win32k.sys的EAT正在加载。 EAT函数：%d",i);

			HsSendStatusDetail(StatusBarContext);
		}

		CString StatusBarContext;
		StatusBarContext.Format(L"win32k.sys的EAT加载完成。 EAT函数：%d",EAT->ulCount);

		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		HsSendStatusDetail(L"win32k.sys的EAT加载失败。");
	}

	if (EAT)
	{
		free(EAT);
		EAT = NULL;
	}

	bIsChecking = FALSE;
}

void HsEnumKernelFuncNameHaldllIAT(CListCtrl* m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_IAT IAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	do 
	{
		ULONG_PTR ulSize = 0;

		if (IAT)
		{
			free(IAT);
			IAT = NULL;
		}

		ulSize = sizeof(MODULE_IAT) + ulCount * sizeof(IAT_INFO);

		IAT = (PMODULE_IAT)malloc(ulSize);
		if (!IAT)
		{
			break;
		}

		memset(IAT,0,ulSize);

		int KernelFile = HS_KERNEL_KERNELFILE_HALDLL_IAT;

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLFILE),
			&KernelFile,
			sizeof(int),
			IAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);


		ulCount = IAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && IAT)
	{
		for (ULONG i = 0; i < IAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(IAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",IAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",IAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(IAT->Data[i].szModuleName);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (IAT->Data[i].CurFuncAddress == IAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"hal.dll的IAT正在加载。 IAT函数：%d",i);

			HsSendStatusDetail(StatusBarContext);

		}

		CString StatusBarContext;
		StatusBarContext.Format(L"hal.dll的IAT加载完成。 IAT函数：%d",IAT->ulCount);

		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		HsSendStatusDetail(L"hal.dll的IAT加载失败。");
	}
	//m_strIATCount.Format(L"%d",IAT->ulCount);
	if (IAT)
	{
		free(IAT);
		IAT = NULL;
	}


	bIsChecking = FALSE;
}

void HsEnumKernelFuncNameHaldllEAT(CListCtrl* m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	BOOL bOk = FALSE;

	ULONG_PTR   ulCount = 0x1000;
	PMODULE_EAT EAT = NULL;
	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	CString ModuleFile(L"hal.dll");

	do 
	{
		ULONG_PTR ulSize = 0;

		if (EAT)
		{
			free(EAT);
			EAT = NULL;
		}

		ulSize = sizeof(MODULE_EAT) + ulCount * sizeof(EAT_INFO);

		EAT = (PMODULE_EAT)malloc(ulSize);
		if (!EAT)
		{
			break;
		}

		memset(EAT,0,ulSize);

		int KernelFile = HS_KERNEL_KERNELFILE_HALDLL_EAT;

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_KRNLFILE),
			&KernelFile,
			sizeof(int),
			EAT,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);

		ulCount = EAT->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && EAT)
	{
		for (ULONG i = 0; i < EAT->ulCount; i++)
		{
			CString strIndex;
			strIndex.Format(L"%d",i+1);
			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(), strIndex);

			CString strFuncName(EAT->Data[i].szFunctionName);
			m_ListCtrl->SetItemText(n, 1, strFuncName);

			CString strCurFuncAddress;
			strCurFuncAddress.Format(L"0x%p",EAT->Data[i].CurFuncAddress);
			m_ListCtrl->SetItemText(n, 2, strCurFuncAddress);

			CString strOriFuncAddress;
			strOriFuncAddress.Format(L"0x%p",EAT->Data[i].OriFuncAddress);
			m_ListCtrl->SetItemText(n, 3, strOriFuncAddress);

			CString strModuleName(ModuleFile);
			m_ListCtrl->SetItemText(n, 4, strModuleName);

			CString strFuncStatus;
			if (EAT->Data[i].CurFuncAddress == EAT->Data[i].OriFuncAddress)
			{
				strFuncStatus = L"正常";
			}
			else
			{
				strFuncStatus = L"Hooked";
				m_ListCtrl->SetItemData(n,1);
			}
			m_ListCtrl->SetItemText(n, 5, strFuncStatus);

			CString StatusBarContext;
			StatusBarContext.Format(L"hal.dll的EAT正在加载。 EAT函数：%d",i);

			HsSendStatusDetail(StatusBarContext);
		}

		CString StatusBarContext;
		StatusBarContext.Format(L"hal.dll的EAT加载完成。 EAT函数：%d",EAT->ulCount);

		HsSendStatusDetail(StatusBarContext);

		bOk = TRUE;
	}
	else
	{
		HsSendStatusDetail(L"hal.dll的EAT加载失败。");
	}

	if (EAT)
	{
		free(EAT);
		EAT = NULL;
	}

	bIsChecking = FALSE;
}

```

`arkProject/HeavenShadow/HeavenShadow/KernelFunc.h`:

```h
#pragma once
#include "stdafx.h"


//////////////////////////////////////////////////////////////////////////

enum HS_KERNEL_KERNELFILE
{
	HS_KERNEL_KERNELFILE_NTOSKRNL_IAT,
	HS_KERNEL_KERNELFILE_NTOSKRNL_EAT,
	HS_KERNEL_KERNELFILE_WIN32K_IAT,
	HS_KERNEL_KERNELFILE_WIN32K_EAT,
	HS_KERNEL_KERNELFILE_HALDLL_IAT,
	HS_KERNEL_KERNELFILE_HALDLL_EAT,
};

//////////////////////////////////////////////////////////////////////////

#define MAX_NAME 60

typedef struct _IAT_INFO_
{
	ULONG_PTR CurFuncAddress;
	ULONG_PTR OriFuncAddress;
	CHAR  szFunctionName[MAX_NAME];
	CHAR  szModuleName[MAX_NAME];
}IAT_INFO, *PIAT_INFO;

typedef struct _MODULE_IAT_
{
	ULONG_PTR ulCount;
	IAT_INFO  Data[1];
}MODULE_IAT, *PMODULE_IAT;

typedef struct _EAT_INFO_
{
	ULONG_PTR CurFuncAddress;
	ULONG_PTR OriFuncAddress;
	CHAR  szFunctionName[MAX_NAME];
}EAT_INFO, *PEAT_INFO;

typedef struct _MODULE_EAT_
{
	ULONG_PTR ulCount;
	EAT_INFO  Data[1];
}MODULE_EAT, *PMODULE_EAT;



void HsInitKernelFuncList(CListBox* m_ListBox, CListCtrl* m_ListCtrl);

void HsInitKernelFileList(CListBox* m_ListBox, CListCtrl* m_ListCtrl);

void SelchangeListKrnlFunc(CListBox* m_ListBox,  CListCtrl* m_ListCtrl);

void SelchangeListKrnlIAT(CListBox* m_ListBox,  CListCtrl* m_ListCtrl);
void SelchangeListKrnlEAT(CListBox* m_ListBox,  CListCtrl* m_ListCtrl);

void HsEnumKernelFuncNameNtoskrnlIAT(CListCtrl* m_ListCtrl);

void HsEnumKernelFuncNameWin32kIAT(CListCtrl* m_ListCtrl);

void HsEnumKernelFuncNameHaldllIAT(CListCtrl* m_ListCtrl);

//////////////////////////////////////////////////////////////////////////

void HsEnumKernelFuncNameNtoskrnlEAT(CListCtrl* m_ListCtrl);

void HsEnumKernelFuncNameWin32kEAT(CListCtrl* m_ListCtrl);

void HsEnumKernelFuncNameHaldllEAT(CListCtrl* m_ListCtrl);









```

`arkProject/HeavenShadow/HeavenShadow/LoadSys.cpp`:

```cpp
#include "stdafx.h"
#include "LoadSys.h"
#include <windows.h>
#include <winsvc.h>

#include "resource.h"

#include "Common.h"

BOOL ExtractFile(void)
{
	HMODULE hLibrary;
	HRSRC hResource;

	HGLOBAL hResourceLoaded;

	LPBYTE lpBuffer;

	WCHAR wzTempDir[MAX_PATH] = {0};

	CString SysFilePath;

	GetEnvironmentVariableW(L"TEMP",wzTempDir,MAX_PATH);

	SysFilePath = wzTempDir;

	SysFilePath += L"\\HeavenShadowDrv.sys";


	if (HsIs64BitWindows())
	{
		hResource = ::FindResourceW(AfxGetResourceHandle(), MAKEINTRESOURCE(IDR_SYSDRIVER64),L"SYSDRIVER");
	}
	else
	{
		hResource = ::FindResourceW(AfxGetResourceHandle(), MAKEINTRESOURCE(IDR_SYSDRIVER32),L"SYSDRIVER");
	}



	if (NULL != hResource)
	{
		hResourceLoaded = LoadResource(NULL,hResource);

		if (NULL != hResourceLoaded)
		{
			lpBuffer = (LPBYTE)LockResource(hResourceLoaded);

			if (NULL != lpBuffer)
			{
				DWORD dwFileSize, dwBytesWritten;

				HANDLE hFile;

				dwFileSize = SizeofResource(NULL,hResource);

				hFile = CreateFile(SysFilePath.GetBuffer(),GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);

				if (INVALID_HANDLE_VALUE != hFile)
				{
					WriteFile(hFile,lpBuffer,dwFileSize,&dwBytesWritten,NULL);

					CloseHandle(hFile);

					HsLoadNTDriver(HS_DRIVER_NAME,SysFilePath.GetBuffer());

					DeleteFile(SysFilePath.GetBuffer());

					return TRUE;
				}
			}
		}
	}
	return FALSE;
}


//装载NT驱动程序
BOOL HsLoadNTDriver(WCHAR* lpszDriverName,WCHAR* lpszDriverPath)
{

	WCHAR szDriverImagePath[256];

	//得到完整的驱动路径
	GetFullPathNameW(lpszDriverPath, 256, szDriverImagePath, NULL);

	BOOL bRet = FALSE;
	SC_HANDLE hServiceMgr=NULL;//SCM管理器的句柄
	SC_HANDLE hServiceDDK=NULL;//NT驱动程序的服务句柄

	//打开服务控制管理器
	hServiceMgr = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

	if( hServiceMgr == NULL )
	{
		//OpenSCManager失败
		printf( "OpenSCManager() Faild %d ! \n", GetLastError() );
		bRet = FALSE;
		goto BeforeLeave;
	}
	else
	{
		////OpenSCManager成功
		printf( "OpenSCManager() ok ! \n" );
	}

	//创建驱动所对应的服务
	hServiceDDK = CreateServiceW( hServiceMgr,
		lpszDriverName,        // 驱动程序的在注册表中的名字
		lpszDriverName,        // 注册表驱动程序的 DisplayName 值
		SERVICE_ALL_ACCESS,    // 加载驱动程序的访问权限
		SERVICE_KERNEL_DRIVER, // 表示加载的服务是驱动程序
		SERVICE_DEMAND_START,  // 注册表驱动程序的 Start 值
		SERVICE_ERROR_IGNORE,  // 注册表驱动程序的 ErrorControl 值
		szDriverImagePath,     // 注册表驱动程序的 ImagePath 值
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);

	DWORD dwRtn;

	//判断服务是否失败
	if( hServiceDDK == NULL )
	{
		dwRtn = GetLastError();
		if( dwRtn != ERROR_IO_PENDING && dwRtn != ERROR_SERVICE_EXISTS )
		{
			//由于其他原因创建服务失败
			printf( "CrateService() Faild %d ! \n", dwRtn );
			bRet = FALSE;
			goto BeforeLeave;
		}
		else
		{
			//服务创建失败，是由于服务已经创立过
			printf( "CrateService() Faild Service is ERROR_IO_PENDING or ERROR_SERVICE_EXISTS! \n" );
		}

		// 驱动程序已经加载，只需要打开
		hServiceDDK = OpenService( hServiceMgr, lpszDriverName, SERVICE_ALL_ACCESS );

		if( hServiceDDK == NULL )
		{
			//如果打开服务也失败，则意味错误
			dwRtn = GetLastError();
			printf( "OpenService() Faild %d ! \n", dwRtn );
			bRet = FALSE;
			goto BeforeLeave;

		}
		else 
		{
			printf( "OpenService() ok ! \n" );
		}
	}
	else
	{
		printf( "CrateService() ok ! \n" );
	}

	//开启此项服务
	bRet= StartService( hServiceDDK, NULL, NULL );

	if( !bRet )
	{
		DWORD dwRtn = GetLastError();

		if( dwRtn != ERROR_IO_PENDING && dwRtn != ERROR_SERVICE_ALREADY_RUNNING )
		{
			printf( "StartService() Faild %d ! \n", dwRtn );
			bRet = FALSE;
			goto BeforeLeave;
		}
		else
		{
			if( dwRtn == ERROR_IO_PENDING )
			{
				//设备被挂住
				printf( "StartService() Faild ERROR_IO_PENDING ! \n");
				bRet = FALSE;
				goto BeforeLeave;
			}
			else
			{
				//服务已经开启
				printf( "StartService() Faild ERROR_SERVICE_ALREADY_RUNNING ! \n");
				bRet = TRUE;
				goto BeforeLeave;
			}
		}
	}

	bRet = TRUE;

	//离开前关闭句柄
BeforeLeave:

	if(hServiceDDK)
	{
		CloseServiceHandle(hServiceDDK);
	}
	if(hServiceMgr)
	{
		CloseServiceHandle(hServiceMgr);
	}

	return bRet;

}



//卸载驱动程序
BOOL HsUnloadNTDriver( WCHAR* szSvrName )
{

	BOOL bRet = FALSE;
	SC_HANDLE hServiceMgr=NULL;//SCM管理器的句柄
	SC_HANDLE hServiceDDK=NULL;//NT驱动程序的服务句柄

	SERVICE_STATUS SvrSta;

	//打开SCM管理器
	hServiceMgr = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

	if( hServiceMgr == NULL )
	{

		//带开SCM管理器失败
		printf( "OpenSCManager() Faild %d ! \n", GetLastError() );
		bRet = FALSE;
		goto BeforeLeave;

	}
	else
	{

		//带开SCM管理器失败成功
		printf( "OpenSCManager() ok ! \n" );
	}

	//打开驱动所对应的服务
	hServiceDDK = OpenService( hServiceMgr, szSvrName, SERVICE_ALL_ACCESS );

	if( hServiceDDK == NULL )
	{
		//打开驱动所对应的服务失败
		printf( "OpenService() Faild %d ! \n", GetLastError() );
		bRet = FALSE;
		goto BeforeLeave;
	}
	else
	{
		printf( "OpenService() ok ! \n" );
	}

	//停止驱动程序，如果停止失败，只有重新启动才能，再动态加载。
	if( !ControlService( hServiceDDK, SERVICE_CONTROL_STOP , &SvrSta ) )
	{
		printf( "ControlService() Faild %d !\n", GetLastError() );
	}
	else
	{
		//打开驱动所对应的失败
		printf( "ControlService() ok !\n" );
	}

	//动态卸载驱动程序。
	if( !DeleteService( hServiceDDK ) )
	{
		//卸载失败
		printf( "DeleteSrevice() Faild %d !\n", GetLastError() );
	}
	else
	{
		//卸载成功
		printf( "DelServer:eleteSrevice() ok !\n" );
	}

	bRet = TRUE;

BeforeLeave:

	//离开前关闭打开的句柄
	if(hServiceDDK)
	{
		CloseServiceHandle(hServiceDDK);
	}
	if(hServiceMgr)
	{
		CloseServiceHandle(hServiceMgr);
	}

	return bRet;    

} 
```

`arkProject/HeavenShadow/HeavenShadow/LoadSys.h`:

```h
#pragma once
#include "stdafx.h"
#include "afxcmn.h"

BOOL ExtractFile(void);

BOOL HsLoadNTDriver(WCHAR* lpszDriverName,WCHAR* lpszDriverPath);

BOOL HsUnloadNTDriver(WCHAR* szSvrName);
```

`arkProject/HeavenShadow/HeavenShadow/MemoryFunc.cpp`:

```cpp
#include "stdafx.h"
#include "MemoryFunc.h"
#include "Common.h"
#include <vector>
#include "resource.h"

using namespace std;

typedef struct _MODULE_INFO_
{
	ULONG_PTR Base;
	ULONG_PTR Size;
	WCHAR Path[MAX_PATH]; 
}MODULE_INFO, *PMODULE_INFO;

typedef struct _ALL_MODULES_
{
	ULONG_PTR   ulCount;
	MODULE_INFO Modules[1];
}ALL_MODULES, *PALL_MODULES;


vector<PROTECT> m_vectorProtectType;
vector<MODULE_INFO> m_vectorModules;

extern ULONG_PTR g_ulProcessId;
extern HANDLE g_hDevice;
CMyList* g_ListCtrl; 

COLUMNSTRUCT g_Column_Memory[] = 
{
	{	L"内存地址",			125	},
	{	L"内存大小",			80	},
	{	L"属性",				100	},
	{	L"状态",				80	},
	{	L"类型",				80	},
	{	L"模块名",			125	}
};

UINT g_Column_Memory_Count  = 6;	  //进程列表列数

extern int dpix;
extern int dpiy;



void HsInitMemoryList(CMyList *m_ListCtrl)
{
	g_ListCtrl = m_ListCtrl;

	InitMemoryProtect();

	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_Memory_Count;i++)
	{
		if (i == 1)
		{
			m_ListCtrl->InsertColumn(i, g_Column_Memory[i].szTitle,LVCFMT_RIGHT,(int)(g_Column_Memory[i].nWidth*(dpix/96.0)));
		}
		else
		{
			m_ListCtrl->InsertColumn(i, g_Column_Memory[i].szTitle,LVCFMT_LEFT,(int)(g_Column_Memory[i].nWidth*(dpix/96.0)));
		}
		
	}
}



BOOL HsQueryProcessMemory(CMyList *m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	if (g_ulProcessId==0)
	{
		return FALSE;
	}

	SendIoControlCodeModule(g_ulProcessId);
	SendIoControlCodeMemory(g_ulProcessId);

	return TRUE;
}


BOOL SendIoControlCodeModule(ULONG_PTR ProcessID)
{
	ULONG ulReturnSize = 0;
	BOOL  bRet = 0;
	ULONG ulCount = 0x10;
	PALL_MODULES AllModules = NULL;

	do 
	{

		ULONG ulSize = 0;

		if (AllModules)
		{
			free(AllModules);
			AllModules = NULL;
		}

		ulSize = sizeof(ALL_MODULES) + ulCount * sizeof(MODULE_INFO);

		AllModules = (PALL_MODULES)malloc(ulSize);
		if (!AllModules)
		{
			break;
		}

		memset(AllModules,0,ulSize);


		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSMODULE),
			&ProcessID,
			sizeof(ULONG_PTR),
			AllModules,
			ulSize,
			&ulReturnSize,
			NULL);


		ulCount = (ULONG)AllModules->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);


	if (bRet==0)
	{


		return bRet;
	}

	if (bRet && AllModules->ulCount > 0)
	{

		for (ULONG i=0;i<AllModules->ulCount;i++)
		{
			MODULE_INFO Temp;

			Temp.Base = AllModules->Modules[i].Base;
			Temp.Size = AllModules->Modules[i].Size;
			CString szPath = TrimPath(AllModules->Modules[i].Path);

			wcsncpy_s(Temp.Path, MAX_PATH, szPath.GetBuffer(), szPath.GetLength());
			szPath.ReleaseBuffer();

			m_vectorModules.push_back(Temp);

		}
	}


	if (AllModules!=NULL)
	{
		free(AllModules);
		AllModules = NULL;
	}
	return bRet;
}













BOOL SendIoControlCodeMemory(ULONG_PTR ProcessID)
{
	ULONG ulReturnSize = 0;
	BOOL  bRet = 0;
	ULONG ulCount = 0x10;
	PALL_MEMORYS Memorys = NULL;

	do 
	{

		ULONG ulSize = 0;

		if (Memorys)
		{
			free(Memorys);
			Memorys = NULL;
		}

		ulSize = sizeof(ALL_MEMORYS) + ulCount * sizeof(MEMORY_INFO);

		Memorys = (PALL_MEMORYS)malloc(ulSize);
		if (!Memorys)
		{
			break;
		}

		memset(Memorys,0,ulSize);


		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSMEMORY),
			&ProcessID,
			sizeof(ULONG_PTR),
			Memorys,
			ulSize,
			&ulReturnSize,
			NULL);


		ulCount = (ULONG)Memorys->ulCount + 1000;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);


	if (bRet==0)
	{


		return bRet;
	}

	if (bRet && Memorys->ulCount > 0)
	{

		for (ULONG i=0;i<Memorys->ulCount;i++)
		{
			CString strBase, strSize, strProtect, strType, strImageName, strState;

			strBase.Format(L"0x%08p", Memorys->Memorys[i].ulBase);
			strSize.Format(L"0x%X",  Memorys->Memorys[i].ulSize);
			strProtect = GetMemoryProtect(Memorys->Memorys[i].ulProtect);
			strType = GetMemoryType(Memorys->Memorys[i].ulType);
			strState = GetMemoryState(Memorys->Memorys[i].ulState);

			if (Memorys->Memorys[i].ulType == MEM_IMAGE)
			{
				strImageName = GetModuleImageName( Memorys->Memorys[i].ulBase);  //在我们的另一个数据结构中查找模块的名称
			}

			int n = g_ListCtrl->GetItemCount();
			int j = g_ListCtrl->InsertItem(n, strBase);
			g_ListCtrl->SetItemText(j, MemorySize, strSize);
			g_ListCtrl->SetItemText(j, MemoryProtect, strProtect);
			g_ListCtrl->SetItemText(j, MemoryState, strState);
			g_ListCtrl->SetItemText(j, MemoryType, strType);
			g_ListCtrl->SetItemText(j, MmeoryModuleName, strImageName);

			g_ListCtrl->SetItemData(j,j);

		}
	}


	if (Memorys!=NULL)
	{
		free(Memorys);
		Memorys = NULL;
	}


	m_vectorProtectType.clear();
	m_vectorModules.clear();
	return bRet;
}


CString GetModuleImageName(ULONG_PTR ulBase)
{
	CString strImageName = L"";

	for ( vector <MODULE_INFO>::iterator Iter = m_vectorModules.begin( ); Iter != m_vectorModules.end( ); Iter++)
	{	
		MODULE_INFO entry = *Iter;

		if (ulBase >= entry.Base && ulBase <= (entry.Base + entry.Size))
		{
			CString strPath = entry.Path;
			strImageName = strPath.Right(strPath.GetLength() - strPath.ReverseFind('\\') - 1);
			break;
		}
	}

	return strImageName;
}



CString GetMemoryState(ULONG State)
{
	CString szState = L"";

	if (State == MEM_COMMIT)
	{
		szState = L"Commit";
	}
	else if (State == MEM_FREE)
	{
		szState = L"Free";
	}
	else if (State == MEM_RESERVE)
	{
		szState = L"Reserve";
	}
	else if (State == MEM_DECOMMIT)
	{
		szState = L"Decommit";
	}
	else if (State == MEM_RELEASE)
	{
		szState = L"Release";
	}

	return szState;
}


CString GetMemoryType(ULONG Type)
{
	CString szType = L"";

	if (Type == MEM_PRIVATE)
	{
		szType = L"Private";
	}
	else if (Type == MEM_MAPPED)
	{
		szType = L"Map";
	}
	else if (Type == MEM_IMAGE)
	{
		szType = L"Image";
	}

	return szType;
}




VOID InitMemoryProtect()
{
	PROTECT protect;

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_NOACCESS;
	wcsncpy_s(protect.szTypeName, L"No Access", wcslen(L"No Access"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_READONLY;
	wcsncpy_s(protect.szTypeName, L"Read", wcslen(L"Read"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_READWRITE;
	wcsncpy_s(protect.szTypeName, L"ReadWrite", wcslen(L"ReadWrite"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_WRITECOPY;
	wcsncpy_s(protect.szTypeName, L"WriteCopy", wcslen(L"WriteCopy"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_EXECUTE;
	wcsncpy_s(protect.szTypeName, L"Execute", wcslen(L"Execute"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_EXECUTE_READ;
	wcsncpy_s(protect.szTypeName, L"ReadExecute", wcslen(L"ReadExecute"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_EXECUTE_READWRITE;
	wcsncpy_s(protect.szTypeName, L"ReadWriteExecute", wcslen(L"ReadWriteExecute"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_EXECUTE_WRITECOPY;
	wcsncpy_s(protect.szTypeName, L"WriteCopyExecute", wcslen(L"WriteCopyExecute"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_GUARD;
	wcsncpy_s(protect.szTypeName, L"Guard", wcslen(L"Guard"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_NOCACHE;
	wcsncpy_s(protect.szTypeName, L"No Cache", wcslen(L"No Cache"));
	m_vectorProtectType.push_back(protect);

	memset(&protect, 0, sizeof(PROTECT));
	protect.uType = PAGE_WRITECOMBINE;
	wcsncpy_s(protect.szTypeName, L"WriteCombine", wcslen(L"WriteCombine"));
	m_vectorProtectType.push_back(protect);
}



CString GetMemoryProtect(ULONG Protect)
{
	BOOL bFirst = TRUE;
	CString strProtect = L"";

	for ( vector <PROTECT>::iterator Iter = m_vectorProtectType.begin( ); 
		Iter != m_vectorProtectType.end( ); 
		Iter++ )
	{
		PROTECT item = *Iter;
		if (item.uType & Protect)
		{
			if (bFirst == TRUE)
			{
				strProtect = item.szTypeName;
				bFirst = FALSE;
			}
			else
			{
				strProtect += L" & ";
				strProtect += item.szTypeName;
			}
		}
	}

	return strProtect;
}

```

`arkProject/HeavenShadow/HeavenShadow/MemoryFunc.h`:

```h
#pragma once

#include "stdafx.h"

#include "MyList.h"


typedef struct _PROTECT_
{
	ULONG uType;
	WCHAR szTypeName[50];
}PROTECT, *PPROTECT;





typedef struct _MEMORY_INFO_
{
	ULONG_PTR ulBase;
	ULONG_PTR ulSize;
	ULONG ulProtect;
	ULONG ulState;
	ULONG ulType;
}MEMORY_INFO, *PMEMORY_INFO;

typedef struct _ALL_MEMORYS_
{
	ULONG_PTR ulCount;
	MEMORY_INFO Memorys[1];
}ALL_MEMORYS, *PALL_MEMORYS;

typedef enum _MEMORY_HEADER_INDEX
{
	MemoryBase,
	MemorySize,
	MemoryProtect,
	MemoryState,
	MemoryType,
	MmeoryModuleName,
}MEMORY_HEADER_INDEX;


void HsInitMemoryList(CMyList *m_ListCtrl);

BOOL HsQueryProcessMemory(CMyList *m_ListCtrl);

BOOL SendIoControlCodeModule(ULONG_PTR ProcessID);

BOOL SendIoControlCodeMemory(ULONG_PTR ProcessID);

CString TrimPath(WCHAR * wzPath);

CString GetMemoryProtect(ULONG Protect);

VOID InitMemoryProtect();

CString GetMemoryType(ULONG Type);

CString GetMemoryState(ULONG State);

CString GetModuleImageName(ULONG_PTR ulBase);

BOOL SendIoControlCodeMemory(ULONG_PTR ProcessID);


```

`arkProject/HeavenShadow/HeavenShadow/ModuleDlg.cpp`:

```cpp
// ModuleDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "ModuleDlg.h"
#include "afxdialogex.h"

#include "HeavenShadowDlg.h"
#include "Common.h"

#include "ModuleFunc.h"

// CModuleDlg 对话框

extern int ResizeX;
extern int ResizeY;

extern int dpix;
extern int dpiy;

//////////////////////////////////////////////////////////////////////////
//排序

UINT module_sort_column;		//记录点击的列
BOOL module_method = TRUE;		//记录比较方法

//////////////////////////////////////////////////////////////////////////

extern CImageList m_TreeModuleImageList;

extern BOOL bIsChecking;

IMPLEMENT_DYNAMIC(CModuleDlg, CDialog)

CModuleDlg::CModuleDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CModuleDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CModuleDlg::~CModuleDlg()
{
}

void CModuleDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_MODULELIST, m_ModuleList);
}


BEGIN_MESSAGE_MAP(CModuleDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
	ON_WM_SIZE()
	ON_NOTIFY(NM_CUSTOMDRAW, IDC_LIST_MODULELIST, &CModuleDlg::OnNMCustomdrawListModulelist)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_MODULELIST, &CModuleDlg::OnLvnColumnclickListModulelist)
	ON_COMMAND(ID_MENU_MODULE_REMOVEMODULE, &CModuleDlg::OnMenuModuleRemovemodule)
	ON_NOTIFY(NM_RCLICK, IDC_LIST_MODULELIST, &CModuleDlg::OnRclickListModulelist)
	ON_COMMAND(ID_MENU_MODULE_REFRESH, &CModuleDlg::OnMenuModuleRefresh)
END_MESSAGE_MAP()


// CModuleDlg 消息处理程序


void CModuleDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()

	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(255,255,255));
}


void CModuleDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	if (bShow == TRUE)
	{
		m_ModuleList.MoveWindow(0,0,ResizeX,ResizeY);

		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_MODULE;

		((CHeavenShadowDlg*)m_wParent)->m_btnModu.EnableWindow(FALSE);

		HsLoadModuleList();

		HsSendStatusTip(L"驱动模块");

		m_ModuleList.SetFocus();
	}
}


BOOL CModuleDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


BOOL CModuleDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	HsInitModuleList((CMyList*)&m_ModuleList);

	UINT uIconSize = 20;

	uIconSize *= (UINT)(dpix/96.0);

	m_TreeModuleImageList.Create(uIconSize, uIconSize, ILC_COLOR32 | ILC_MASK, 2, 2);

	ListView_SetImageList(m_ModuleList.m_hWnd, m_TreeModuleImageList.GetSafeHandle(), LVSIL_SMALL);

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CModuleDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	// TODO: 在此处添加消息处理程序代码

	ResizeX = cx;
	ResizeY = cy;
}


void CModuleDlg::HsLoadModuleList(void)
{
	if (bIsChecking == TRUE)
	{
		return;
	}

	bIsChecking = TRUE;

	m_ModuleList.DeleteAllItems();

	m_ModuleList.SetSelectedColumn(-1);

	HsSendStatusDetail(L"进程列表正在加载。");

	CloseHandle(
		CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsQueryModuleFunction,&m_ModuleList, 0,NULL)
		);
}




void CModuleDlg::OnNMCustomdrawListModulelist(NMHDR *pNMHDR, LRESULT *pResult)
{
	NMLVCUSTOMDRAW* pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>( pNMHDR );
	// TODO: 在此添加控件通知处理程序代码

	*pResult = CDRF_DODEFAULT;

	if ( CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage )
	{
		*pResult = CDRF_NOTIFYITEMDRAW;
	}
	else if ( CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage )
	{
		*pResult = CDRF_NOTIFYSUBITEMDRAW;
	}
	else if ( (CDDS_ITEMPREPAINT | CDDS_SUBITEM) == pLVCD->nmcd.dwDrawStage )
	{
		COLORREF clrNewTextColor, clrNewBkColor;
		int bHooked = 0;
		int nItem = static_cast<int>( pLVCD->nmcd.dwItemSpec );

		clrNewTextColor = RGB( 0, 0, 0 );
		clrNewBkColor = RGB( 255, 255, 255 );

		bHooked = (int)m_ModuleList.GetItemData(nItem); 		
		if (bHooked == 1)
		{
			clrNewTextColor = RGB( 0, 0, 255 );
		}

		pLVCD->clrText = clrNewTextColor;
		pLVCD->clrTextBk = clrNewBkColor;

		*pResult = CDRF_DODEFAULT;
	}
}


void CModuleDlg::OnLvnColumnclickListModulelist(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	int nItemCount;

	nItemCount = m_ModuleList.GetItemCount();

	module_sort_column=pNMLV->iSubItem;//点击的列

	m_ModuleList.SetSelectedColumn(module_sort_column);

	for(int i=0;i<nItemCount;i++) m_ModuleList.SetItemData(i,i);//每行的比较关键字，此处为列序号（点击的列号），可以设置为其他 比较函数的第一二个参数

	m_ModuleList.SortItems(HsModuleListCompareProc,(DWORD_PTR)&m_ModuleList);//排序 第二个参数是比较函数的第三个参数

	if (module_method)
	{
		module_method = FALSE;
	}
	else
	{
		module_method = TRUE;
	}

	for (int i = 0; i < nItemCount; i++)
	{
		if (_wcsnicmp(
			m_ModuleList.GetItemText(i,8),
			L"Microsoft Corporation",
			wcslen(L"Microsoft Corporation"))==0
			)
		{
			m_ModuleList.SetItemData(i,1);
		}
	}

	*pResult = 0;
}




//////////////////////////////////////////////////////////////////////////

//排序比较函数
static int CALLBACK HsModuleListCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{

	//从参数中提取所需比较lc的两行数据

	int row1=(int) lParam1;
	int row2=(int) lParam2;

	CListCtrl*lc=(CListCtrl*)lParamSort;

	CString lp1=lc->GetItemText(row1,module_sort_column);
	CString lp2=lc->GetItemText(row2,module_sort_column);


	//比较，对不同的列，不同比较，注意记录前一次排序方向，下一次要相反排序

	if (module_sort_column == 7)
	{
		// int型比较
		if (module_method)
			return _ttoi(lp1)-_ttoi(lp2);
		else
			return _ttoi(lp2)-_ttoi(lp1);
	}
	else if (module_sort_column == 1 ||module_sort_column == 2 ||module_sort_column == 3 ||module_sort_column == 6)
	{
		ULONG_PTR nlp1 = 0, nlp2 = 0;

		if (lp1.GetLength()>1)
		{
			lp1 = lp1.GetBuffer()+2;
			swscanf_s(lp1.GetBuffer(),L"%P",&nlp1);
		}
		else
		{
			nlp1 = 0;
		}

		if (lp2.GetLength()>1)
		{
			lp2 = lp2.GetBuffer()+2;
			swscanf_s(lp2.GetBuffer(),L"%P",&nlp2);
		}
		else
		{
			nlp2 = 0;
		}

		if (module_method)
		{
			return (int)(nlp1 - nlp2);
		}
		else
		{
			return (int)(nlp2 - nlp1);
		}
	}
	else
	{
		// 文字型比较
		if(module_method)
			return lp1.CompareNoCase(lp2);
		else
			return lp2.CompareNoCase(lp1);
	}

	return 0;
}


void CModuleDlg::OnMenuModuleRemovemodule()
{
	// TODO: 在此添加命令处理程序代码

	BOOL bRet = MessageBox(L"卸载模块操作极可能会造成系统异常或崩溃，\r\n请在确认后继续。",L"天影卫士",MB_ICONWARNING | MB_OKCANCEL);

	if (bRet == IDCANCEL)
	{
		return;
	}

	if (bIsChecking == TRUE)
	{
		return;
	}

	bIsChecking = TRUE;

 	CloseHandle(
 		CreateThread(NULL,0, 
 		(LPTHREAD_START_ROUTINE)HsRemoveDriverModule,&m_ModuleList, 0,NULL)
 		);
	//HsRemoveDriverModule(&m_ListSystemCtrl);
}


void CModuleDlg::OnRclickListModulelist(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	CMenu	popup;
	CPoint	p;

	popup.LoadMenu(IDR_MENU_MODULE);				//加载菜单资源
	CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项

	GetCursorPos(&p);
	int	count = pM->GetMenuItemCount();
	if (m_ModuleList.GetSelectedCount() == 0)		//如果没有选中
	{ 
		for (int i = 0;i<count;i++)
		{
			pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
		}
	}

	int Index = m_ModuleList.GetSelectionMark();

	if (Index>=0)
	{
		if (_wcsicmp(L"-",m_ModuleList.GetItemText(Index,3))==0)
		{
			pM->EnableMenuItem(ID_MENU_MODULE_REMOVEMODULE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		}
	}

	pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);

	*pResult = 0;
}


void CModuleDlg::OnMenuModuleRefresh()
{
	// TODO: 在此添加命令处理程序代码

	HsLoadModuleList();
}

```

`arkProject/HeavenShadow/HeavenShadow/ModuleDlg.h`:

```h
#pragma once
#include "afxcmn.h"


// CModuleDlg 对话框

class CModuleDlg : public CDialog
{
	DECLARE_DYNAMIC(CModuleDlg)

public:
	CModuleDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CModuleDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_MODULE };

	CWnd* m_wParent;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnPaint();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnInitDialog();
	CListCtrl m_ModuleList;
	afx_msg void OnSize(UINT nType, int cx, int cy);
	void HsLoadModuleList(void);
	afx_msg void OnNMCustomdrawListModulelist(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnLvnColumnclickListModulelist(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuModuleRemovemodule();
	afx_msg void OnRclickListModulelist(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuModuleRefresh();
};


static int CALLBACK HsModuleListCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
```

`arkProject/HeavenShadow/HeavenShadow/ModuleFunc.cpp`:

```cpp
#include "stdafx.h"
#include "ModuleFunc.h"
#include "Common.h"

#include "ProcessFunc.h"
#include <WinVer.h>

extern BOOL bIsChecking;
extern HANDLE g_hDevice;

ULONG_PTR m_DriverObject;

CListCtrl* g_ListCtrl_Module;

vector<DRIVER_INFO> m_DriverList;
CImageList m_TreeModuleImageList;

COLUMNSTRUCT g_Column_Module[] = 
{
	{	L"驱动名",		130	},
	{	L"基地址",		125	},
	{	L"大小",			70	},
	{	L"驱动对象",		125	},
	{	L"驱动路径",		200	},
	{	L"服务名称",		80	},
	{	L"启动入口",		125	},
	{	L"加载顺序",		65	},
	{	L"文件厂商",		120	}
};

UINT g_Column_Module_Count  = 9;	  //进程列表列数

extern int dpix;
extern int dpiy;



void HsInitModuleList(CListCtrl *m_ListCtrl)
{
	g_ListCtrl_Module = m_ListCtrl;

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_Module_Count;i++)
	{
		if (i == 2)
		{
			m_ListCtrl->InsertColumn(i, g_Column_Module[i].szTitle,LVCFMT_RIGHT,(int)(g_Column_Module[i].nWidth*(dpix/96.0)));
		}
		else
		{
			m_ListCtrl->InsertColumn(i, g_Column_Module[i].szTitle,LVCFMT_LEFT,(int)(g_Column_Module[i].nWidth*(dpix/96.0)));
		}
	}
}


DWORD WINAPI HsQueryModuleFunction(CListCtrl *m_ListCtrl)
{
	bIsChecking = TRUE;

	HsQueryModuleList(m_ListCtrl);

	bIsChecking = FALSE;
	return 0;
}

void HsQueryModuleList(CListCtrl *m_ListCtrl)
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;
	int ModuleCount = 0;

	while (m_TreeModuleImageList.Remove(0));
	m_ListCtrl->DeleteAllItems();

	ULONG ulReturnSize = 0;
	BOOL bRet = FALSE;


	m_DriverList.clear();

	ULONG ulCount = 1000;
	PALL_DRIVERS Drivers = NULL;

	do 
	{
		ULONG ulSize = 0;

		if (Drivers)
		{
			free(Drivers);
			Drivers = NULL;
		}

		ulSize = sizeof(ALL_DRIVERS) + ulCount * sizeof(DRIVER_INFO);

		Drivers = (PALL_DRIVERS)malloc(ulSize);
		if (!Drivers)
		{
			break;
		}

		memset(Drivers,0,ulSize);


		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_MODU_MODULELIST),
			NULL,
			0,
			Drivers,
			ulSize,
			&ulReturnSize,
			NULL);

		ulCount = (ULONG)Drivers->ulCount + 100;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && Drivers->ulCount > 0)
	{
		for (ULONG i = 0;i<Drivers->ulCount; i++)
		{
			FixDriverPath(&Drivers->Drivers[i]);
			m_DriverList.push_back(Drivers->Drivers[i]);
		}
	}

	if (Drivers)
	{
		free(Drivers);
		Drivers = NULL;
	}

	//////////////////////////////////////////////////////////////////////////

	if (m_DriverList.empty())
	{
		return;
	}


	for (vector <DRIVER_INFO>::iterator Iter = m_DriverList.begin( ); 
		Iter != m_DriverList.end( ); 
		Iter++ )
	{
		DRIVER_INFO DriverInfor = *Iter;

		WCHAR wzDriverName[MAX_PATH] = {0};
		WCHAR szWindowsText[MAX_PATH] = {0};


		CString  strDriverName;
		CString  strBase;
		CString  strSize;
		CString  strObject;
		CString  strLoadCount;
		CString  strComp;
		CString  strDriverStart;


		//获得系统中全部服务信息
		//GetServiceKeys();


		wcsncpy_s(wzDriverName, DriverInfor.wzDriverPath,wcslen(DriverInfor.wzDriverPath));


		//
		// 获得驱动名
		//
		WCHAR* Temp = wcsrchr(wzDriverName, '\\');

		


		strBase.Format(L"0x%p",DriverInfor.Base);
		strSize.Format(L"0x%X",DriverInfor.Size);
		if (DriverInfor.DriverObject)
		{
			strObject.Format(L"0x%p",DriverInfor.DriverObject);
		}
		else
		{
			strObject = L"-";
		}
		strLoadCount.Format(L"%d",DriverInfor.LodeOrder);
		if (DriverInfor.DriverObject)
		{
			strDriverStart.Format(L"0x%p",DriverInfor.DirverStartAddress);
		}
		else
		{
			strDriverStart = L"-";
		}
		
		int n = g_ListCtrl_Module->GetItemCount();

		int j = 0;

		LPCTSTR lpModuleName;

		if (Temp!=NULL)
		{
			lpModuleName = Temp+1;
		}
		else if (wcslen(DriverInfor.wzDriverPath)>0)
		{
			lpModuleName = DriverInfor.wzDriverPath;
			
		} else
		{
			continue;
		}


		AddModuleFileIcon(DriverInfor.wzDriverPath);
		int nImageCount = m_TreeModuleImageList.GetImageCount()-1;
		j = g_ListCtrl_Module->InsertItem(n,lpModuleName, nImageCount);

		
		
		ModuleCount++;
		CString CSStatusDetail;
		CSStatusDetail.Format( L"驱动模块正在加载。 驱动数：%d",ModuleCount);
		HsSendStatusDetail(CSStatusDetail.GetBuffer());
		


		//获得文件厂商
		if (PathFileExists(DriverInfor.wzDriverPath))
		{
			strComp = HsGetFileCompanyName(DriverInfor.wzDriverPath);
		}

		else
		{
			strComp = L"文件不存在";
		}


		g_ListCtrl_Module->SetItemText(j, 1, strBase);
		g_ListCtrl_Module->SetItemText(j, 2, strSize);
		g_ListCtrl_Module->SetItemText(j, 3, strObject);
		g_ListCtrl_Module->SetItemText(j, 4, DriverInfor.wzDriverPath);
		g_ListCtrl_Module->SetItemText(j, 5, DriverInfor.wzKeyName);
		g_ListCtrl_Module->SetItemText(j, 6, strDriverStart);
		g_ListCtrl_Module->SetItemText(j, 7, strLoadCount);
		g_ListCtrl_Module->SetItemText(j, 8, strComp);
		//g_ListCtrl_Module->SetItemData(j,j);
		if (_wcsnicmp(strComp,L"Microsoft Corporation", wcslen(L"Microsoft Corporation"))==0)
		{
			g_ListCtrl_Module->SetItemData(j,1);
		}
	}

	CString CSStatusDetail;
	CSStatusDetail.Format( L"驱动模块加载完成。 驱动数：%d",ModuleCount);
	HsSendStatusDetail(CSStatusDetail.GetBuffer());
}




void FixDriverPath(PDRIVER_INFO DriverInfor)
{
	if (!DriverInfor || wcslen(DriverInfor->wzDriverPath) == 0)
	{
		return;
	}

	WCHAR wzWindowsDirectory[MAX_PATH] = {0};
	WCHAR wzDriverDirectory[MAX_PATH] = {0};	
	WCHAR wzDriver[] = L"\\System32\\Drivers\\";

	GetWindowsDirectory(wzWindowsDirectory, MAX_PATH - 1);
	wcscpy_s(wzDriverDirectory, wzWindowsDirectory);
	wcscat_s(wzDriverDirectory, wzDriver);

	WCHAR* wzOriginPath = DriverInfor->wzDriverPath;
	WCHAR  wzPath[MAX_PATH] = {0};
	WCHAR* wzTemp = wcschr(wzOriginPath, L'\\');

	// 没有目录信息，只有一个驱动名字的，直接拼接Driver目录。
	if (!wzTemp)
	{
		wcscpy_s(wzPath, wzDriverDirectory);
		wcscat_s(wzPath, wzOriginPath);
		wcscpy_s(DriverInfor->wzDriverPath, wzPath);

		wzOriginPath[wcslen(wzPath)] = L'\0';
	}
	else
	{
		WCHAR wzUnknow[] = L"\\??\\";
		WCHAR wzSystemRoot[] = L"\\SystemRoot";
		WCHAR wzWindows[] = L"\\Windows";
		WCHAR wzWinnt[] = L"\\Winnt";
		size_t nOrigin = wcslen(wzOriginPath);

		if ( nOrigin >= wcslen(wzUnknow) && !_wcsnicmp(wzOriginPath, wzUnknow, wcslen(wzUnknow)) )
		{
			wcscpy_s(wzPath, wzOriginPath + wcslen(wzUnknow));
			wcscpy_s(DriverInfor->wzDriverPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
		else if (nOrigin >= wcslen(wzSystemRoot) && !_wcsnicmp(wzOriginPath, wzSystemRoot, wcslen(wzSystemRoot)))
		{
			wcscpy_s(wzPath, wzWindowsDirectory);
			wcscat_s(wzPath, wzOriginPath + wcslen(wzSystemRoot));
			wcscpy_s(DriverInfor->wzDriverPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
		else if (nOrigin >= wcslen(wzWindows) && !_wcsnicmp(wzOriginPath, wzWindows, wcslen(wzWindows)))
		{
			wcscpy_s(wzPath, wzWindowsDirectory);
			wcscat_s(wzPath, wzOriginPath + wcslen(wzWindows));
			wcscpy_s(DriverInfor->wzDriverPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
		else if (nOrigin >= wcslen(wzWinnt) && !_wcsnicmp(wzOriginPath, wzWinnt, wcslen(wzWinnt)))
		{
			wcscpy_s(wzPath, wzWindowsDirectory);
			wcscat_s(wzPath, wzOriginPath + wcslen(wzWinnt));
			wcscpy_s(DriverInfor->wzDriverPath, wzPath);
			wzOriginPath[wcslen(wzPath)] = L'\0';
		}
	}

	// 如果是短文件名
	if (wcschr(wzOriginPath, '~'))
	{
		WCHAR wzLongPath[MAX_PATH] = {0};
		DWORD nRet = GetLongPathName(wzOriginPath, wzLongPath, MAX_PATH);
		if ( !(nRet >= MAX_PATH || nRet == 0) )
		{
			wcscpy_s(DriverInfor->wzDriverPath, wzLongPath);
			wzOriginPath[wcslen(wzLongPath)] = L'\0';
		}
	}
}



void AddModuleFileIcon(WCHAR* ModulePath)
{
	SHFILEINFO shInfo;
	memset(&shInfo, 0, sizeof(shInfo));
	CString CSmPath = ModulePath;
	SHGetFileInfo(CSmPath, FILE_ATTRIBUTE_NORMAL, 
		&shInfo, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_USEFILEATTRIBUTES);

	HICON  hIcon = shInfo.hIcon;

	m_TreeModuleImageList.Add(hIcon);
}



void HsRemoveDriverModule(CListCtrl* m_ListCtrl)
{
	m_DriverObject = 0;

	int Index = m_ListCtrl->GetSelectionMark();

	if (Index<0)
	{
		return;
	}

	CString Temp = m_ListCtrl->GetItemText(Index,3);

	swscanf_s(Temp.GetBuffer()+2,L"%p",&m_DriverObject);

	if (m_DriverObject==0)
	{
		return;
	}

	if (SendIoControlUnloadDriver())
	{
		HsQueryModuleList(m_ListCtrl);
	}

	bIsChecking = FALSE;
}


BOOL SendIoControlUnloadDriver()
{
	ULONG ulReturnSize = 0;
	BOOL bRet = FALSE;

	bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_MODU_REMOVEMODULE),
		&m_DriverObject,
		sizeof(ULONG_PTR),
		NULL,
		0,
		&ulReturnSize,
		NULL);

	return bRet;
}
```

`arkProject/HeavenShadow/HeavenShadow/ModuleFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"

#include <afxtempl.h>
#include <vector>
#include <Strsafe.h>

#pragma comment(lib,"Version.lib")
using namespace std;

typedef struct _DRIVER_INFO_
{
	ULONG_PTR LodeOrder;
	ULONG_PTR Base;
	ULONG_PTR Size;
	ULONG_PTR DriverObject;
	ULONG_PTR DirverStartAddress;
	WCHAR wzDriverPath[MAX_PATH];
	WCHAR wzKeyName[MAX_PATH];
}DRIVER_INFO, *PDRIVER_INFO;

typedef struct _ALL_DRIVERS_
{
	ULONG_PTR ulCount;
	DRIVER_INFO Drivers[1];
}ALL_DRIVERS, *PALL_DRIVERS;



//////////////////////////////////////////////////////////////////////////

void HsInitModuleList(CListCtrl *m_ListCtrl);

DWORD WINAPI HsQueryModuleFunction(CListCtrl *m_ListCtrl);

void HsQueryModuleList(CListCtrl *m_ListCtrl);

void FixDriverPath(PDRIVER_INFO DriverInfor);

void AddModuleFileIcon(WCHAR* ModulePath);

void HsRemoveDriverModule(CListCtrl* m_ListCtrl);

BOOL SendIoControlUnloadDriver();





```

`arkProject/HeavenShadow/HeavenShadow/MyCheckBtn.cpp`:

```cpp
// MyCheckBtn.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "MyCheckBtn.h"


// CMyCheckBtn

IMPLEMENT_DYNAMIC(CMyCheckBtn, CStatic)

CMyCheckBtn::CMyCheckBtn()
{

}

CMyCheckBtn::~CMyCheckBtn()
{
}


BEGIN_MESSAGE_MAP(CMyCheckBtn, CStatic)
	ON_WM_MOUSEMOVE()
	ON_WM_MOUSELEAVE()
	ON_WM_MOUSEHOVER()
	ON_WM_SETCURSOR()
END_MESSAGE_MAP()



// CMyCheckBtn 消息处理程序




void CMyCheckBtn::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	TRACKMOUSEEVENT csTME;
	csTME.cbSize = sizeof (csTME);
	csTME.dwFlags = TME_LEAVE|TME_HOVER;
	csTME.hwndTrack = m_hWnd;		// 指定要 追踪 的窗口 
	csTME.dwHoverTime = 50;			// 鼠标在按钮上停留超过 50ms ，才认为状态为 HOVER
	::_TrackMouseEvent (&csTME);	// 开启 Windows 的 WM_MOUSELEAVE ， WM_MOUSEHOVER 事件支持
	CStatic::OnMouseMove(nFlags, point);
}


void CMyCheckBtn::OnMouseLeave()
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_HOMECHECK_BTN),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_HOMECHECK_BTN));

	SetBitmap(hBmp);

	CStatic::OnMouseLeave();
}


void CMyCheckBtn::OnMouseHover(UINT nFlags, CPoint point)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	HINSTANCE hIns = AfxFindResourceHandle(MAKEINTRESOURCE(IDB_BITMAP_HOMECHECK_BTN_HOVER),RT_GROUP_ICON);

	HBITMAP   hBmp = ::LoadBitmap(hIns, MAKEINTRESOURCE(IDB_BITMAP_HOMECHECK_BTN_HOVER));

	SetBitmap(hBmp);

	CStatic::OnMouseHover(nFlags, point);
}


BOOL CMyCheckBtn::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	// 使用自己的鼠标绘制函数。
	::SetCursor(::LoadCursorW(NULL,IDC_HAND));

	return TRUE;
}

```

`arkProject/HeavenShadow/HeavenShadow/MyCheckBtn.h`:

```h
#pragma once


// CMyCheckBtn

class CMyCheckBtn : public CStatic
{
	DECLARE_DYNAMIC(CMyCheckBtn)

public:
	CMyCheckBtn();
	virtual ~CMyCheckBtn();

protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnMouseLeave();
	afx_msg void OnMouseHover(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
};



```

`arkProject/HeavenShadow/HeavenShadow/MyEdit.cpp`:

```cpp
// MyEdit.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "MyEdit.h"


// CMyEdit

IMPLEMENT_DYNAMIC(CMyEdit, CEdit)

CMyEdit::CMyEdit()
{

}

CMyEdit::~CMyEdit()
{
}


BEGIN_MESSAGE_MAP(CMyEdit, CEdit)
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()



// CMyEdit 消息处理程序




void CMyEdit::OnContextMenu(CWnd* /*pWnd*/, CPoint /*point*/)
{
	// TODO: 在此处添加消息处理程序代码
}

```

`arkProject/HeavenShadow/HeavenShadow/MyEdit.h`:

```h
#pragma once


// CMyEdit

class CMyEdit : public CEdit
{
	DECLARE_DYNAMIC(CMyEdit)

public:
	CMyEdit();
	virtual ~CMyEdit();

protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnContextMenu(CWnd* /*pWnd*/, CPoint /*point*/);
};



```

`arkProject/HeavenShadow/HeavenShadow/MyList.cpp`:

```cpp
// MyList.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "MyList.h"


// CMyList

IMPLEMENT_DYNAMIC(CMyList, CListCtrl)

CMyList::CMyList()
{

}

CMyList::~CMyList()
{
}

CMap<DWORD , DWORD& , COLORREF , COLORREF&> MapItemColor;
int CMyList::InsertItem(int nItem,LPCTSTR lpText,COLORREF fontcolor)
{
	const int IDX = CListCtrl::InsertItem(nItem, lpText);
	//改变颜色
	DWORD iItem=(DWORD)nItem;
	MapItemColor.SetAt(iItem, fontcolor);
	CListCtrl::RedrawItems(iItem,iItem);
	CListCtrl::Update(iItem);
	return IDX;
}



BEGIN_MESSAGE_MAP(CMyList, CListCtrl)
END_MESSAGE_MAP()



// CMyList 消息处理程序



```

`arkProject/HeavenShadow/HeavenShadow/MyList.h`:

```h
#pragma once


// CMyList

class CMyList : public CListCtrl
{
	DECLARE_DYNAMIC(CMyList)

public:
	CMyList();
	virtual ~CMyList();

	//插入数据，可设置字体颜色
	int InsertItem(int nItem,LPCTSTR lpText,COLORREF fontcolor=RGB(0,0,0));

protected:
	DECLARE_MESSAGE_MAP()
};



```

`arkProject/HeavenShadow/HeavenShadow/MyPicButton.cpp`:

```cpp
// MyPicButton.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "MyPicButton.h"

#include "Common.h"


extern CWnd* g_wParent;

// CMyPicButton

IMPLEMENT_DYNAMIC(CMyPicButton, CStatic)

CMyPicButton::CMyPicButton()
{
}

CMyPicButton::~CMyPicButton()
{
}


BEGIN_MESSAGE_MAP(CMyPicButton, CStatic)
	ON_WM_SETCURSOR()
END_MESSAGE_MAP()



// CMyPicButton 消息处理程序



BOOL CMyPicButton::PreTranslateMessage(MSG* pMsg)
{
	m_toolTip.RelayEvent(pMsg);

	return CStatic::PreTranslateMessage(pMsg);
}


void CMyPicButton::PreSubclassWindow()
{
	CRect rect;
	GetClientRect(rect);
	m_toolTip.Create(this);
	m_toolTip.AddTool(this, m_szToolTipText, rect, GetDlgCtrlID());
	m_toolTip.Activate(TRUE);
	EnableToolTips(TRUE);

	CStatic::PreSubclassWindow();
}

void CMyPicButton::SetToolTipText(const CString &szTip)
{
	m_szToolTipText = szTip;
	UpdateToolTipText();
	return;
}

void CMyPicButton::UpdateToolTipText()
{
	if (::IsWindow(GetSafeHwnd()))
	{
		m_toolTip.UpdateTipText(m_szToolTipText, this, GetDlgCtrlID());
	}
	return;
}


INT_PTR CMyPicButton::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	pTI->hwnd = m_hWnd;
	pTI->uId = (UINT)m_hWnd;
	pTI->uFlags |= TTF_IDISHWND;
	pTI->lpszText = LPSTR_TEXTCALLBACK;
	return GetDlgCtrlID();

	//return CStatic::OnToolHitTest(point, pTI);
}



BOOL CMyPicButton::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	// 使用自己的鼠标绘制函数。
	::SetCursor(::LoadCursorW(NULL,IDC_HAND));

	return TRUE;
}

```

`arkProject/HeavenShadow/HeavenShadow/MyPicButton.h`:

```h
#pragma once


// CMyPicButton

class CMyPicButton : public CStatic
{
	DECLARE_DYNAMIC(CMyPicButton)

public:
	CMyPicButton();
	virtual ~CMyPicButton();

	BOOL m_bIsHand;

protected:
	DECLARE_MESSAGE_MAP()
public:
	//afx_msg void OnMouseMove(UINT nFlags, CPoint point);

public:
	CString m_szToolTipText;
	CToolTipCtrl m_toolTip;
	void SetToolTipText(const CString &szTip);
	void UpdateToolTipText();

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void PreSubclassWindow();
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
};



```

`arkProject/HeavenShadow/HeavenShadow/MyText.cpp`:

```cpp
// MyText.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "MyText.h"


// CMyText

IMPLEMENT_DYNAMIC(CMyText, CStatic)

CMyText::CMyText()
{

}

CMyText::~CMyText()
{
}


BEGIN_MESSAGE_MAP(CMyText, CStatic)
	ON_WM_CTLCOLOR_REFLECT()
END_MESSAGE_MAP()



// CMyText 消息处理程序



HBRUSH CMyText::CtlColor(CDC* pDC, UINT nCtlColor)
{
	pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(RGB(255,255,255));

	return (HBRUSH)::GetStockObject(NULL_BRUSH);
}


LRESULT CMyText::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// TODO: 在此添加专用代码和/或调用基类

	if (message == WM_SETTEXT)
	{
		CRect rect;

		GetWindowRect(&rect);

		CWnd* pParent = GetParent();

		if (pParent)
		{
			pParent->ScreenToClient(&rect);
			pParent->InvalidateRect(&rect);
		}
	}

	return CStatic::DefWindowProc(message, wParam, lParam);
}


```

`arkProject/HeavenShadow/HeavenShadow/MyText.h`:

```h
#pragma once


// CMyText

class CMyText : public CStatic
{
	DECLARE_DYNAMIC(CMyText)

public:
	CMyText();
	virtual ~CMyText();

protected:
	DECLARE_MESSAGE_MAP()
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
public:
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);
};



```

`arkProject/HeavenShadow/HeavenShadow/MyText2.cpp`:

```cpp
// MyText2.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "MyText2.h"


// CMyText2

IMPLEMENT_DYNAMIC(CMyText2, CStatic)

CMyText2::CMyText2()
{

}

CMyText2::~CMyText2()
{
}


BEGIN_MESSAGE_MAP(CMyText2, CStatic)
	ON_WM_CTLCOLOR_REFLECT()
END_MESSAGE_MAP()



// CMyText2 消息处理程序



HBRUSH CMyText2::CtlColor(CDC* pDC, UINT nCtlColor)
{
	pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(RGB(75,75,75));

	return (HBRUSH)::GetStockObject(NULL_BRUSH);
}


LRESULT CMyText2::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// TODO: 在此添加专用代码和/或调用基类

	if (message == WM_SETTEXT)
	{
		CRect rect;

		GetWindowRect(&rect);

		CWnd* pParent = GetParent();

		if (pParent)
		{
			pParent->ScreenToClient(&rect);
			pParent->InvalidateRect(&rect);
		}
	}

	return CStatic::DefWindowProc(message, wParam, lParam);
}


```

`arkProject/HeavenShadow/HeavenShadow/MyText2.h`:

```h
#pragma once


// CMyText2

class CMyText2 : public CStatic
{
	DECLARE_DYNAMIC(CMyText2)

public:
	CMyText2();
	virtual ~CMyText2();
protected:
	DECLARE_MESSAGE_MAP()
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
public:
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);
};



```

`arkProject/HeavenShadow/HeavenShadow/PModuleFunc.cpp`:

```cpp
#include "stdafx.h"
#include "PModuleFunc.h"
#include "Common.h"

#include <Psapi.h>
#include "resource.h"


#pragma comment(lib,"psapi.lib")

extern WIN_VERSION GetWindowsVersion();
extern WIN_VERSION WinVersion;

extern ULONG_PTR g_ulProcessId;



COLUMNSTRUCT g_Column_ProcessModule[] = 
{
	{	L"地址",					125	},
	{	L"大小",					70	},
	{	L"入口地址",				125	},
	{	L"模块名称",				270	}
};

UINT g_Column_ProcessModule_Count  = 4;	  //进程列表列数



extern int dpix;
extern int dpiy;




VOID HsInitPModuleDetailList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_ProcessModule_Count;i++)
	{
		if (i==1)
		{
			m_ListCtrl->InsertColumn(i, g_Column_ProcessModule[i].szTitle,LVCFMT_RIGHT,(int)(g_Column_ProcessModule[i].nWidth*(dpix/96.0)));
		}
		else
		{
			m_ListCtrl->InsertColumn(i, g_Column_ProcessModule[i].szTitle,LVCFMT_LEFT,(int)(g_Column_ProcessModule[i].nWidth*(dpix/96.0)));
		}
	}


	if (HsIs64BitWindows())
	{
		EnableDebugPri64();
	}
	else
	{
		EnableDebugPri32();
	}
}

VOID HsLoadPModuleDetailList(CListCtrl *m_ListCtrl)
{
	PROCESSMODULE_INFO mi[1024] = {0};

	m_ListCtrl->DeleteAllItems();


	ULONG_PTR ulCount = EnumProcessModule(mi);

	CString  strBase;
	CString  strSize;
	CString  strEntryPoint;


	if (ulCount>0)
	{
		UINT i = 0;
		for (i=0;i<ulCount;i++)
		{


			strBase.Format(L"0x%p",mi[i].ulBase);
			strSize.Format(L"0x%X",mi[i].ulSize);
			strEntryPoint.Format(L"0x%p",mi[i].ulEntryPoint);
			CString  strPathName(mi[i].szPath);


			int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strBase);
			m_ListCtrl->SetItemText(n,1,strSize);
			m_ListCtrl->SetItemText(n,2,strEntryPoint);
			m_ListCtrl->SetItemText(n,3,strPathName);

		}
	}

}

BOOL EnableDebugPri64()
{
	typedef long (__fastcall *pfnRtlAdjustPrivilege64)(ULONG,ULONG,ULONG,PVOID);
	pfnRtlAdjustPrivilege64 RtlAdjustPrivilege;

	DWORD                  dwRetVal    = 0;
	LPTHREAD_START_ROUTINE FuncAddress = NULL;
#ifdef _UNICODE
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif

	if (FuncAddress==NULL)
	{
		return FALSE;
	}


	RtlAdjustPrivilege=(pfnRtlAdjustPrivilege64)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"RtlAdjustPrivilege");

	if (RtlAdjustPrivilege==NULL)
	{
		return FALSE;
	}
	RtlAdjustPrivilege(20,1,0,&dwRetVal);

	return TRUE;
}



BOOL EnableDebugPri32()
{

	HANDLE hToken;
	TOKEN_PRIVILEGES pTP;
	LUID uID;

	if (!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,&hToken))
	{
		printf("OpenProcessToken is Error\n");

		return FALSE;
	}

	if (!LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&uID))
	{
		printf("LookupPrivilegeValue is Error\n");

		return FALSE;
	}


	pTP.PrivilegeCount = 1;
	pTP.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	pTP.Privileges[0].Luid = uID;


	//在这里我们进行调整权限
	if (!AdjustTokenPrivileges(hToken,false,&pTP,sizeof(TOKEN_PRIVILEGES),NULL,NULL))
	{
		printf("AdjuestTokenPrivileges is Error\n");
		return  FALSE;
	}


	return TRUE;

}





ULONG_PTR EnumProcessModule(_PROCESSMODULE_INFO* mi)
{

	MODULEINFO ModInfor;
	char szModName[MAX_PATH];
	HMODULE hMods[1024];
	DWORD cbNeeded,i;
	HANDLE hProcess;
	hProcess = OpenProcess(PROCESS_ALL_ACCESS,0,(DWORD)g_ulProcessId);
	if (hProcess==0)
	{
		return 0;
	}
	if(EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
	{
		for (i=0; i<=cbNeeded/sizeof(HMODULE); i++ )
		{
			GetModuleInformation(hProcess, hMods[i], &ModInfor, sizeof(MODULEINFO));
			GetModuleFileNameExA(hProcess, hMods[i], szModName, 260);
			mi[i].ulBase=(ULONG_PTR)(ModInfor.lpBaseOfDll);
			mi[i].ulSize=(ULONG_PTR)(ModInfor.SizeOfImage);
			mi[i].ulEntryPoint=(ULONG_PTR)(ModInfor.EntryPoint);
			strcpy_s(mi[i].szPath,szModName);
		}
		CloseHandle(hProcess);
		return cbNeeded/sizeof(HMODULE);
	}
	else
	{
		CloseHandle(hProcess);
		return 0;
	}
}

```

`arkProject/HeavenShadow/HeavenShadow/PModuleFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"

#include "ProcessFunc.h"

typedef struct _PROCESSMODULE_INFO
{
	ULONG_PTR	ulBase;
	ULONG_PTR	ulSize;
	ULONG_PTR	ulEntryPoint;
	CHAR	    szPath[264];
} PROCESSMODULE_INFO,*PPROCESSMODULE_INFO;


VOID HsInitPModuleDetailList(CListCtrl *m_ListCtrl);


BOOL EnableDebugPri64();


BOOL EnableDebugPri32();


ULONG_PTR EnumProcessModule(_PROCESSMODULE_INFO* mi);


VOID HsLoadPModuleDetailList(CListCtrl *m_ListCtrl);

```

`arkProject/HeavenShadow/HeavenShadow/PrivilegeFunc.cpp`:

```cpp
#include "stdafx.h"
#include "PrivilegeFunc.h"
#include "Common.h"

#include "resource.h"

extern HANDLE g_hDevice;

extern ULONG_PTR g_ulProcessId;

typedef struct _PRIVILEGE_DATA_
{
	ULONG_PTR  ProcessID;
	TOKEN_PRIVILEGES TokenPrivileges;
}PRIVILEGEDATA, *PPRIVILEGEDATA;



COLUMNSTRUCT g_Column_Privilege[] = 
{
	{	L"权限名称",			170	},
	{	L"权限描述",			200	},
	{	L"权限状态",			150	}
};

UINT g_Column_Privilege_Count  = 3;	  //进程列表列数



extern int dpix;
extern int dpiy;



void HsInitPrivilegeList(CMyList *m_ListCtrl)
{

	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_Privilege_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_Privilege[i].szTitle,LVCFMT_LEFT,(int)(g_Column_Privilege[i].nWidth*(dpix/96.0)));
	}
}




VOID
HsQueryProcessPrivilege(CMyList *m_ListCtrl)
{

	ULONG_PTR  ProcessID = g_ulProcessId;

	ULONG dwReturnSize = 0;
	ULONG dwRet = 0;

	PVOID Temp = NULL;
	ULONG nSize = 1000;

	if (ProcessID == 0)
	{
		return;
	}

	m_ListCtrl->DeleteAllItems();

	Temp = (PTOKEN_PRIVILEGES)malloc(sizeof(char)*nSize);
	if (!Temp)
	{
		return;
	}

	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSPRIVILEGE),
		&ProcessID,
		sizeof(ULONG_PTR),
		Temp,
		nSize,
		&dwReturnSize,
		NULL);

	if (dwRet && ((PTOKEN_PRIVILEGES)Temp)->PrivilegeCount > 0)
	{
		for (ULONG i = 0; i <((PTOKEN_PRIVILEGES)Temp)->PrivilegeCount;i++)
		{
			WCHAR PrivilegeName[MAX_PATH] = {0};
			WCHAR DisplayName[MAX_PATH] = {0};
			DWORD LanguageId = 0;
			DWORD dwRet1 = MAX_PATH;
			DWORD dwRet2 = MAX_PATH;

			LookupPrivilegeName(NULL, &((PTOKEN_PRIVILEGES)Temp)->Privileges[i].Luid, PrivilegeName, &dwRet1);
			LookupPrivilegeDisplayName(NULL,PrivilegeName,DisplayName,&dwRet2,&LanguageId);


			printf("%S\r\n",PrivilegeName);
			wprintf(L"%s",DisplayName);

			if (wcslen(PrivilegeName) == 0)
			{
				break;
			}

			m_ListCtrl->InsertItem(i, PrivilegeName);

			m_ListCtrl->SetItemText(i,1,DisplayName);

			if (((PTOKEN_PRIVILEGES)Temp)->Privileges[i].Attributes & 1)
			{
				//printf("\t\tDefault Enabled");
				m_ListCtrl->SetItemText(i,2,L"Default Enabled");
			}
			else if ( ((PTOKEN_PRIVILEGES)Temp)->Privileges[i].Attributes & 2 )
			{
				//printf("\t\tEnabled");
				m_ListCtrl->SetItemText(i,2,L"Enabled");
			}
			else
			{
				//printf("\t\tDisabled");
				m_ListCtrl->SetItemText(i,2,L"Disabled");
			}
		}
	}


	//发送IO 控制码

	if (dwRet==0)
	{
		//cout<<"Send IoCode Error"<<endl;
	}
	if (Temp!=NULL)
	{
		free(Temp);
	}

	return;
}



//权限界面弹出菜单
VOID HsProcessPrivilegePopupMenu(CMyList *m_ListCtrl, CWnd* parent)
{
	CMenu	popup;
	popup.LoadMenu(IDR_MENU_PROCESS_PRIVILEGE);		//加载菜单资源
	CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项
	CPoint	p;
	GetCursorPos(&p);
	int	count = pM->GetMenuItemCount();
	if (m_ListCtrl->GetSelectedCount() == 0)		//如果没有选中
	{ 
		for (int i = 0;i<count;i++)
		{
			pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
		}
	}
	else
	{
		POSITION pos = m_ListCtrl->GetFirstSelectedItemPosition();

		while(pos)
		{
			int iItem = m_ListCtrl->GetNextSelectedItem(pos);

			if (_wcsnicmp(m_ListCtrl->GetItemText(iItem,2),L"Default Enabled",15) == 0)
			{
				for (int i = 1;i<count;i++)
				{
					pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}
			else if (_wcsnicmp(m_ListCtrl->GetItemText(iItem,2),L"Enabled",7) == 0)
			{
				pM->CheckMenuRadioItem(2,3,2, MF_BYPOSITION | MF_CHECKED);
			}
			else
			{
				pM->CheckMenuRadioItem(2,3,3, MF_BYPOSITION | MF_CHECKED);
			}
		}
	}
	pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, parent);
}



BOOL HsAdjustPrivilege(ULONG_PTR ProcessID, WCHAR* PrivilegeName, BOOL bIsEnable)
{

	PRIVILEGEDATA PrivilegeData = {0};
	TOKEN_PRIVILEGES TokenPrivileges;
	TokenPrivileges.PrivilegeCount = 1;


	if (LookupPrivilegeValueW(NULL, PrivilegeName, &TokenPrivileges.Privileges[0].Luid))
	{
		if (bIsEnable)
		{
			TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
		}
		else
		{

			TokenPrivileges.Privileges[0].Attributes = 0;
		}


		//向驱动发送消息

		PrivilegeData.ProcessID = ProcessID;
		PrivilegeData.TokenPrivileges = TokenPrivileges;


		if (g_hDevice==NULL)
		{
			return FALSE;
		}

		ULONG dwReturnSize = 0;
		ULONG dwRet = 0;

		BOOL bFeedback = FALSE;


		dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PRIVILEGE_ADJUST),
			&PrivilegeData,
			sizeof(PRIVILEGEDATA),
			&bFeedback,
			sizeof(BOOL),
			&dwReturnSize,
			NULL);

		//发送IO 控制码


		return bFeedback;
	}

	return FALSE;
}



```

`arkProject/HeavenShadow/HeavenShadow/PrivilegeFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"






VOID HsInitPrivilegeList(CMyList *m_ListCtrl);


//查询进程权限
VOID HsQueryProcessPrivilege(CMyList *m_ListCtrl);

VOID HsProcessPrivilegePopupMenu(CMyList *m_ListCtrl, CWnd* parent);

//设置启用权限
BOOL HsAdjustPrivilege(ULONG_PTR ProcessID, WCHAR* PrivilegeName, BOOL bIsEnable);
```

`arkProject/HeavenShadow/HeavenShadow/ProcessDlg.cpp`:

```cpp
// ProcessDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "ProcessDlg.h"
#include "afxdialogex.h"
#include "ProcessFunc.h"

#include "HeavenShadowDlg.h"
#include "Common.h"

#include "ProcessViewDlg.h"
#include "InjectFunc.h"

#include <afxdb.h>             //注意这里的文件声明
#include <odbcinst.h>


CWnd* g_process = NULL;


extern HANDLE g_hDevice;
extern BOOL bIsChecking;

extern enum HS_ENUM_PROCVIEW_TYPE;


int ResizeX = 0;
int ResizeY = 0;

extern int dpix;
extern int dpiy;

//////////////////////////////////////////////////////////////////////////
//排序

UINT sort_column;		//记录点击的列
BOOL method = TRUE;		//记录比较方法

//////////////////////////////////////////////////////////////////////////


// CProcessDlg 对话框

IMPLEMENT_DYNAMIC(CProcessDlg, CDialog)

CProcessDlg::CProcessDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CProcessDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CProcessDlg::~CProcessDlg()
{
}

void CProcessDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_PROCESSLIST, m_ProcessList);
}


BEGIN_MESSAGE_MAP(CProcessDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
	ON_MESSAGE(HS_PROCESSDIG_SEND_INSERT,HsProcessDlgSendInsert)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_PROCESSLIST, &CProcessDlg::OnColumnclickListProcesslist)
	ON_NOTIFY(NM_RCLICK, IDC_LIST_PROCESSLIST, &CProcessDlg::OnRclickListProcesslist)
	ON_COMMAND(ID_MENU_PROCESS_REFRESH, &CProcessDlg::OnMenuProcessRefresh)
	ON_COMMAND(ID_MENU_PROCESS_KILLPROCESS, &CProcessDlg::OnMenuProcessKillprocess)
	ON_COMMAND(ID_MENU_PROCESS_PROCESSTHREAD, &CProcessDlg::OnMenuProcessProcessthread)
	ON_COMMAND(ID_MENU_PROCESS_COPYINFO, &CProcessDlg::OnMenuProcessCopyinfo)
	ON_COMMAND(ID_MENU_PROCESS_ATTRIBUTE, &CProcessDlg::OnMenuProcessAttribute)
	ON_COMMAND(ID_MENU_PROCESS_LOCATIONFILE, &CProcessDlg::OnMenuProcessLocationfile)
	ON_COMMAND(ID_MENU_PROCESS_EXPORTTXT, &CProcessDlg::OnMenuProcessExporttxt)
	ON_COMMAND(ID_MENU_PROCESS_EXPORTEXCEL, &CProcessDlg::OnMenuProcessExportexcel)
	ON_COMMAND(ID_MENU_PROCESS_PROCESSPRIVILEGE, &CProcessDlg::OnMenuProcessProcessprivilege)
	ON_COMMAND(ID_MENU_PROCESS_INJECTDLL, &CProcessDlg::OnMenuProcessInjectdll)
	ON_COMMAND(ID_MENU_PROCESS_KILLMUST, &CProcessDlg::OnMenuProcessKillmust)
	ON_COMMAND(ID_MENU_PROCESS_DETAIL, &CProcessDlg::OnMenuProcessDetail)
	ON_COMMAND(ID_MENU_PROCESS_PROCESSHANDLE, &CProcessDlg::OnMenuProcessProcesshandle)
	ON_COMMAND(ID_MENU_PROCESS_MEMORY, &CProcessDlg::OnMenuProcessMemory)
	ON_COMMAND(ID_MENU_PROCESS_NEWRUN, &CProcessDlg::OnMenuProcessNewrun)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_PROCESSLIST, &CProcessDlg::OnDblclkListProcesslist)
	ON_COMMAND(ID_MENU_PROCESS_PROCESSWINDOW, &CProcessDlg::OnMenuProcessProcesswindow)
	ON_COMMAND(ID_MENU_PROCESS_SUSPEND, &CProcessDlg::OnMenuProcessSuspend)
	ON_COMMAND(ID_MENU_PROCESS_RECOVERY, &CProcessDlg::OnMenuProcessRecovery)
	ON_COMMAND(ID_MENU_PROCESS_PROCESSMODULE, &CProcessDlg::OnMenuProcessProcessmodule)
	ON_WM_SIZE()
	ON_NOTIFY(NM_CUSTOMDRAW, IDC_LIST_PROCESSLIST, &CProcessDlg::OnNMCustomdrawListProcesslist)
END_MESSAGE_MAP()


// CProcessDlg 消息处理程序


void CProcessDlg::OnBnClickedButtonTest()
{
	// TODO: 在此添加控件通知处理程序代码
	MessageBox(L"进程对话框",L"进程对话框");
}


void CProcessDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()

	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(255,255,255));
}


BOOL CProcessDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	g_process = this;

	UINT uIconSize = 20;

	uIconSize *= (UINT)(dpix/96.0);

	m_TreeImageList.Create(uIconSize, uIconSize, ILC_COLOR32 | ILC_MASK, 2, 2);
	
	ListView_SetImageList(m_ProcessList.m_hWnd, m_TreeImageList.GetSafeHandle(), LVSIL_SMALL); 
	
	//m_ProcessList.SetImageList(&m_TreeImageList, LVSIL_SMALL);

	HsInitList();

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}



void CProcessDlg::HsInitList(void)
{
	HsInitProcessList((CMyList*)&m_ProcessList);
	
	//m_ProcessList.SetSelectedColumn(1);
}

void CProcessDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	//////////////////////////////////////////////////////////////////////////
	
	if (bShow == TRUE)
	{
		m_ProcessList.MoveWindow(0,0,ResizeX,ResizeY);

		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_PROCESS;

		((CHeavenShadowDlg*)m_wParent)->m_btnProc.EnableWindow(FALSE);

		HsLoadProcessList();

		HsSendStatusTip(L"进程");

		m_ProcessList.SetFocus();
	}
}



void CProcessDlg::OnColumnclickListProcesslist(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	int nItemCount;
	
	nItemCount = m_ProcessList.GetItemCount();

	sort_column=pNMLV->iSubItem;//点击的列

	m_ProcessList.SetSelectedColumn(sort_column);

	for(int i=0;i<nItemCount;i++) m_ProcessList.SetItemData(i,i);//每行的比较关键字，此处为列序号（点击的列号），可以设置为其他 比较函数的第一二个参数

	m_ProcessList.SortItems(HsProcessListCompareProc,(DWORD_PTR)&m_ProcessList);//排序 第二个参数是比较函数的第三个参数

	if (method)
	{
		method = FALSE;
	}
	else
	{
		method = TRUE;
	}

	for (int i = 0; i < nItemCount; i++)
	{
		if (_wcsnicmp(
			m_ProcessList.GetItemText(i,HS_PROCESS_COLUMN_COMPANY),
			L"Microsoft Corporation",
			wcslen(L"Microsoft Corporation"))==0
			)
		{
			m_ProcessList.SetItemData(i,1);
		}
	}

	*pResult = 0;
}


void CProcessDlg::HsLoadProcessList(void) //加载列表
{

	if (bIsChecking == FALSE)
	{
		bIsChecking = TRUE;

		while(m_TreeImageList.Remove(0));

		m_ProcessList.DeleteAllItems();

		m_ProcessList.SetSelectedColumn(-1);

		HsSendStatusDetail(L"进程列表正在加载。");
		
		CloseHandle(
 			CreateThread(NULL,0, 
 			(LPTHREAD_START_ROUTINE)HsQueryProcessFunction,&m_ProcessList, 0,NULL)
			);
	}
}







void CProcessDlg::OnRclickListProcesslist(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	CMenu	popup;
	popup.LoadMenu(IDR_MENU_PROCESS);				//加载菜单资源
	CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项
	CPoint	p;
	GetCursorPos(&p);
	int	count = pM->GetMenuItemCount();
	if (m_ProcessList.GetSelectedCount() == 0)		//如果没有选中
	{ 
		for (int i = 0;i<count;i++)
		{
			pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
		}

		pM->EnableMenuItem(ID_MENU_PROCESS_REFRESH, MF_BYCOMMAND | MF_ENABLED);
	}

	pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);

	*pResult = 0;
}


void CProcessDlg::OnMenuProcessRefresh()
{
	// TODO: 在此添加命令处理程序代码
	HsLoadProcessList();
}





void CProcessDlg::OnMenuProcessKillprocess()
{
	// TODO: 在此添加命令处理程序代码

	if (bIsChecking)
	{
		return;
	}

	if (MessageBox(L"确定要结束该进程吗？",L"天影卫士",MB_YESNO) == IDYES)
	{
		bIsChecking = TRUE;

		POSITION pos = m_ProcessList.GetFirstSelectedItemPosition();

		while (pos)
		{
			int nItem = m_ProcessList.GetNextSelectedItem(pos);

			DWORD_PTR ulPid = _ttoi(m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_PID).GetBuffer());

			if (ulPid == 0 || ulPid == 4)
			{
				MessageBox(L"进程关闭失败。",L"天影卫士",0);
				return;
			}

			HsDebugPrivilege(SE_DEBUG_NAME, TRUE);

			HANDLE hProcess = OpenProcess(PROCESS_TERMINATE | PROCESS_VM_OPERATION, TRUE, (DWORD)ulPid);

			BOOL bIsSuccess = TerminateProcess(hProcess,0);

			HsDebugPrivilege(SE_DEBUG_NAME, FALSE);

			if (bIsSuccess == FALSE)
			{
				MessageBox(L"关闭进程失败。",L"天影卫士",0);
			}
			else
			{
				m_ProcessList.DeleteItem(nItem);
			}

			CloseHandle(hProcess);
		}
		
		bIsChecking = FALSE;
	}

}



// void CProcessDlg::HsQuaryProcessThread(ULONG_PTR ulPid)
// {
// 	DWORD dwReturnSize = 0;
// 	DWORD dwRet = 0;
// 	//发送IO 控制码
// 
// 
// 
// 	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSTHREAD),
// 		(PVOID)&ulPid,
// 		sizeof(ULONG_PTR),
// 		NULL,
// 		0,
// 		&dwReturnSize,
// 		NULL);
// 
// 	if (dwRet==0)
// 	{
// 		WCHAR *temp = L"与内核层通信异常。";
// 		::SendMessageW(m_wParent->m_hWnd,HS_MESSAGE_STATUSDETAIL,NULL,(LPARAM)temp);
// 
// 		return;
// 	}
// }



BOOL CProcessDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	if (pMsg->message==WM_KEYDOWN && pMsg->wParam==VK_F5)
	{
		OnMenuProcessRefresh();
	}
	return CDialog::PreTranslateMessage(pMsg);
}


void CProcessDlg::OnMenuProcessCopyinfo()
{
	// TODO: 在此添加命令处理程序代码
	POSITION pos = m_ProcessList.GetFirstSelectedItemPosition();

	while(pos)
	{
		int iItem = m_ProcessList.GetNextSelectedItem(pos);

		CStringA(csProcInfo);
		csProcInfo = "映像名称: ";
		csProcInfo += m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_NAME);
		csProcInfo += "  进程ID: ";
		csProcInfo += m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_PID);
		csProcInfo += "  父进程ID: ";
		csProcInfo += m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_PPID);
		csProcInfo += "  映像路径: ";
		csProcInfo += m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_PATH);
		csProcInfo += "  EPROCESS: ";
		csProcInfo += m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_EPROCESS);
		csProcInfo += "  应用层访问: ";
		csProcInfo += m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_USERACCESS);
		csProcInfo += "  文件厂商: ";
		if (m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_COMPANY).GetLength()>0)
		{
			csProcInfo += m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_COMPANY);
		}

		if(::OpenClipboard(NULL))
		{
			HGLOBAL hmem=GlobalAlloc(GHND,csProcInfo.GetLength()+1);
			char *pmem=(char*)GlobalLock(hmem);

			EmptyClipboard();
			memcpy(pmem,csProcInfo.GetBuffer(),csProcInfo.GetLength()+1);
			SetClipboardData(CF_TEXT,hmem);
			CloseClipboard();
			GlobalFree(hmem); 
		}
	}
}



void CProcessDlg::OnMenuProcessAttribute()
{
	// TODO: 在此添加命令处理程序代码

	POSITION pos = m_ProcessList.GetFirstSelectedItemPosition();

	while(pos)
	{
		int iItem = m_ProcessList.GetNextSelectedItem(pos);

		CString csFilePath = m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_PATH);

		HsCheckAttribute(csFilePath);
	}
}


void CProcessDlg::OnMenuProcessLocationfile()
{
	// TODO: 在此添加命令处理程序代码
	POSITION pos = m_ProcessList.GetFirstSelectedItemPosition();

	while(pos)
	{
		int iItem = m_ProcessList.GetNextSelectedItem(pos);

		CString csFilePath = m_ProcessList.GetItemText(iItem,HS_PROCESS_COLUMN_PATH);

		HsLocationExplorer(csFilePath);
	}
}


void CProcessDlg::OnMenuProcessExporttxt()
{
	// TODO: 在此添加命令处理程序代码
	
	if (m_ProcessList.GetItemCount () > 0) 
	{ 
		CString strFile; 

		if (!HsGetDefaultTextFileName(strFile))
			return;

		CFile File;

		TRY
		{
			if (File.Open(strFile, CFile::modeCreate | CFile::modeWrite | CFile::modeNoTruncate, NULL))
			{
				int i = 0;
				LVCOLUMN columnData;
				CString  columnName;
				int      columnNum = 0;
				CString  strCloumn;
				CHAR  szColumn[0x1000] = {0};
				WCHAR wzColumn[0x1000] = {0};

				columnData.mask = LVCF_TEXT;
				columnData.cchTextMax = 100;
				columnData.pszText = columnName.GetBuffer(100);

				for(i = 0;m_ProcessList.GetColumn(i,&columnData); i++)
				{
					strCloumn = strCloumn + columnData.pszText + L"  |  ";
				}

				strCloumn += "\r\n";
				ULONG  nLenTemp = strCloumn.GetLength();
				wcsncpy_s(wzColumn,0x1000,strCloumn.GetBuffer(),nLenTemp);
				strCloumn.ReleaseBuffer();
				WideCharToMultiByte(CP_ACP,0,wzColumn,-1,szColumn,0x1000,NULL,NULL);
				File.Write(szColumn,(UINT)strlen(szColumn));  

				columnName.ReleaseBuffer();
				columnNum = i;

				//上面是取出ShowList 的标题


				for (int nItemIndex = 0; nItemIndex <m_ProcessList.GetItemCount(); nItemIndex++)
				{
					CHAR  szColumn[0x1000]  = {0};
					WCHAR wzColumn[0x1000] = {0};
					CString strItem;

					for( i = 0; i < columnNum; i++)
					{
						strItem = strItem + m_ProcessList.GetItemText(nItemIndex,i) + L"  |  ";
					}

					strItem += "\r\n";
					nLenTemp = strItem.GetLength();
					wcsncpy_s(wzColumn,0x1000,strItem.GetBuffer(),nLenTemp);
					strItem.ReleaseBuffer();
					WideCharToMultiByte(CP_ACP,0,wzColumn,-1,szColumn,0x1000,NULL,NULL);
					File.Write(szColumn, (UINT)strlen(szColumn));  
				}

				File.Close();
			}
		}
		CATCH_ALL(e)
		{
			File.Abort();  
		}
		END_CATCH_ALL


		if ( PathFileExists(strFile))
		{
			ShellExecuteW(NULL, L"open", strFile, NULL, NULL, SW_SHOW);
		}
		else
		{
			::MessageBox(NULL, L"导出到文本文件失败。", L"天影卫士", MB_OK | MB_ICONERROR);
		}
	}
}


void CProcessDlg::OnMenuProcessExportexcel()
{
// 	// TODO: 在此添加命令处理程序代码
// 
// 	BOOL bOk = FALSE;
// 
// 	CString strEnd = L"枚举完毕";
// 
// 	if (m_ProcessList.GetItemCount () > 0) 
// 	{ 
// 		CDatabase DataBase;
// 		CString   strDriver;
// 		CString   strExcelFile; 
// 		CString   strSql;
// 		CString   TableName = L"HeavenShadow";
// 		strDriver = HsGetExcelDriver();
// 		if (strDriver.IsEmpty())
// 		{
// 			::MessageBox(NULL, L"没有安装Excel!\n请先安装Excel软件才能使用导出功能!", L"导出", MB_OK | MB_ICONERROR);
// 			return;
// 		}
//
// 		if (!HsGetDefaultExcelFileName(strExcelFile))
// 		{
// 			return;
// 		}
// 
// 		strSql.Format(L"DRIVER={%s};DSN='';FIRSTROWHASNAMES=1;READONLY=FALSE;CREATE_DB=\"%s\";DBQ=%s", strDriver, strExcelFile, strExcelFile);
// 
// 		if(DataBase.OpenEx(strSql, CDatabase::noOdbcDialog))
// 		{
// 			int i;
// 			LVCOLUMN columnData;
// 			CString columnName;
// 			int columnNum = 0;
// 			CString strH;
// 			CString strV;
// 
// 			strSql = L"";
// 			strH = L"";
// 			columnData.mask = LVCF_TEXT;
// 			columnData.cchTextMax = 100;
// 			columnData.pszText = columnName.GetBuffer(100);
// 
// 			for(i = 0; m_ProcessList.GetColumn(i, &columnData); i++)
// 			{
// 				if (i != 0)
// 				{
// 					strSql = strSql + L", " ;
// 					strH = strH + L", " ;
// 				}
// 
// 				strSql = strSql + L" " + L"[" + columnData.pszText + L"]" + L" TEXT";
// 				strH = strH + L" " + L"[" + columnData.pszText + L"]" + L" ";
// 			}
// 
// 			columnName.ReleaseBuffer();
// 			columnNum = i;
// 
// 			strSql = L"CREATE TABLE " +TableName + L" ( " + strSql +   L" ) ";
// 			DataBase.ExecuteSQL(strSql);
// 
// 			for (int nItemIndex = 0; nItemIndex < m_ProcessList.GetItemCount(); nItemIndex++)
// 			{
// 				strV = L"";
// 				for( i = 0; i < columnNum; i++)
// 				{
// 					if (i != 0)
// 					{
// 						strV = strV + L", " ;
// 					}
// 
// 					strV = strV + L" '" + m_ProcessList.GetItemText(nItemIndex, i) + L"' ";
// 				}
// 
// 				strSql = L"INSERT INTO "+ TableName + L" ("+ strH + L")" + L" VALUES("+ strV + L")";
// 				DataBase.ExecuteSQL(strSql);
// 			}
// 
// 			strV = L"";
// 			for( i = 0; i < columnNum; i++)
// 			{
// 				if (i != 0)
// 				{
// 					strV = strV + L", " ;
// 				}
// 
// 				strV = strV + L" '" + L" " + L"' ";
// 			}
// 
// 			strSql = L"INSERT INTO "+ TableName + L" ("+ strH + L")" + L" VALUES("+ strV + L")";
// 			DataBase.ExecuteSQL(strSql);
// 
// 			strV = L" ";
// 			strV = strV + L" '" + strEnd + L"' ";
// 
// 			for( i = 1; i < columnNum; i++)
// 			{
// 				strV = strV + L", " ;
// 				strV = strV + L" '" + L" " + L"' ";
// 			}
// 
// 			strSql = L"INSERT INTO "+ TableName + L" ("+ strH + L")" + L" VALUES("+ strV + L")";
// 			DataBase.ExecuteSQL(strSql);
// 
// 			bOk = TRUE;
// 		}      
// 
// 		DataBase.Close();
// 
// 		if ( bOk && PathFileExists(strExcelFile) )
// 		{
// 			ShellExecuteW(NULL,L"open",strExcelFile,NULL,NULL,SW_SHOW);
// 		}
// 		else
// 		{
// 			::MessageBox(NULL,L"导出到Excel文件失败。",L"天影卫士",MB_OK | MB_ICONERROR);
// 		}
// 	}
}






//排序比较函数
static int CALLBACK HsProcessListCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{

	//从参数中提取所需比较lc的两行数据

	int row1=(int) lParam1;
	int row2=(int) lParam2;

	CListCtrl*lc=(CListCtrl*)lParamSort;

	CString lp1=lc->GetItemText(row1,sort_column);
	CString lp2=lc->GetItemText(row2,sort_column);


	//比较，对不同的列，不同比较，注意记录前一次排序方向，下一次要相反排序

	if (sort_column == HS_PROCESS_COLUMN_PID ||
		sort_column == HS_PROCESS_COLUMN_PPID)
	{
		// int型比较
		if (method)
			return _ttoi(lp1)-_ttoi(lp2);
		else
			return _ttoi(lp2)-_ttoi(lp1);
	}
	else if (sort_column == HS_PROCESS_COLUMN_EPROCESS)
	{
		if (method)
		{
			ULONG_PTR nlp1 = 0, nlp2 = 0;

			lp1 = lp1.GetBuffer()+2;
			lp2 = lp2.GetBuffer()+2;

			swscanf_s(lp1.GetBuffer(),L"%P",&nlp1);
			swscanf_s(lp2.GetBuffer(),L"%P",&nlp2);
			return (int)(nlp1 - nlp2);
		}
		else
		{
			int nlp1 = 0, nlp2 = 0;
			lp1 = lp1.GetBuffer()+2;
			lp2 = lp2.GetBuffer()+2;
			swscanf_s(lp1.GetBuffer(),L"%X",&nlp1);
			swscanf_s(lp2.GetBuffer(),L"%X",&nlp2);
			return nlp2 - nlp1;
		}
	}
	else
	{
		// 文字型比较
		if(method)
			return lp1.CompareNoCase(lp2);
		else
			return lp2.CompareNoCase(lp1);
	}

	return 0;
}


void CProcessDlg::OnMenuProcessInjectdll()
{
	// TODO: 在此添加命令处理程序代码

	CloseHandle(
		CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsRemoteThreadInjectDll,&m_ProcessList, 0,NULL)
		);

}


void CProcessDlg::OnMenuProcessKillmust()
{
	// TODO: 在此添加命令处理程序代码

	if (bIsChecking)
	{
		return;
	}

	if (MessageBox(L"强制关闭进程的操作有风险，请谨慎操作。\r\n确定要结束该进程吗？",L"天影卫士",MB_YESNO) == IDNO)
	{
		return;
	}

// 	CreateThread(NULL,0, 
// 		(LPTHREAD_START_ROUTINE)HsKillProcessByForce,(CMyList*)&m_ProcessList, 0,NULL);

	bIsChecking = TRUE;

	HsKillProcessByForce((CMyList*)&m_ProcessList);

	bIsChecking = FALSE;

}






void CProcessDlg::OnMenuProcessProcessthread()
{
	// TODO: 在此添加命令处理程序代码

	//HsQuaryProcessThread(ulPid);

	HsOpenProcessViewDlg(HS_PROCVIEW_TYPE_THREAD);

}

void CProcessDlg::OnMenuProcessProcessprivilege()
{
	// TODO: 在此添加命令处理程序代码
	HsOpenProcessViewDlg(HS_PROCVIEW_TYPE_PRIVILEGE);
}


void CProcessDlg::OnMenuProcessDetail()
{
	// TODO: 在此添加命令处理程序代码
	HsOpenProcessViewDlg(HS_PROCVIEW_TYPE_DETAIL);
}


void CProcessDlg::HsOpenProcessViewDlg(int nViewType)
{
	POSITION pos = m_ProcessList.GetFirstSelectedItemPosition();

	while(pos)
	{
		int nItem = m_ProcessList.GetNextSelectedItem(pos);

		ULONG_PTR ulPid = _ttoi(m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_PID).GetBuffer());
		ULONG_PTR ulPPid = _ttoi(m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_PPID).GetBuffer());

		CString ProcessEProcess = m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_EPROCESS);

		ProcessEProcess = ProcessEProcess.GetBuffer()+2;

		ULONG_PTR ulEProcess = 0;

		swscanf_s(ProcessEProcess.GetBuffer(),L"%P",&ulEProcess);


		HSPROCESSINFO hsProcInfo = {0};

		hsProcInfo.Pid = ulPid;
		hsProcInfo.PPid = ulPPid;
		hsProcInfo.Eprocess = ulEProcess;

		if (_wcsnicmp(m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_COMPANY).GetBuffer(),L"拒绝",wcslen(L"拒绝")) == 0)
		{
			hsProcInfo.UserAccess = FALSE;
		}
		else
		{
			hsProcInfo.UserAccess = TRUE;
		}

		StringCchCopyW(hsProcInfo.CompanyName,
			m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_COMPANY).GetLength()+1,
			m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_COMPANY).GetBuffer());
		StringCchCopyW(hsProcInfo.Name,
			m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_NAME).GetLength()+1,
			m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_NAME).GetBuffer());
		StringCchCopyW(hsProcInfo.Path,
			m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_PATH).GetLength()+1,
			m_ProcessList.GetItemText(nItem,HS_PROCESS_COLUMN_PATH).GetBuffer());

		CProcessViewDlg* dlg = new CProcessViewDlg(nViewType,&hsProcInfo,this);
		dlg->DoModal();
	}
}



LRESULT CProcessDlg::HsProcessDlgSendInsert(WPARAM wParam, LPARAM lParam)
{
	PHSPROCESSINFO* hsProcItem = (PHSPROCESSINFO*)lParam;

	CString Name = NULL;
	CString Pid = NULL;
	CString PPid = NULL;
	CString Path = NULL;
	CString EProcess = NULL;
	CString UserAccess = NULL;
	CString CompanyName = NULL;

	ULONG ulItem = m_ProcessList.GetItemCount();

	WCHAR tempdir[100];
	GetEnvironmentVariableW(L"windir",tempdir,100);


	Name = (*hsProcItem)->Name;
	Pid.Format(L"%d",(*hsProcItem)->Pid);

	if ((*hsProcItem)->PPid == 0xffffffff)
	{
		PPid = L"-";
	}
	else
	{
		PPid.Format(L"%d",(*hsProcItem)->PPid);
	}

	Path = (*hsProcItem)->Path;

	EProcess.Format(L"0x%p",(*hsProcItem)->Eprocess);

	if ((*hsProcItem)->UserAccess == TRUE)
	{
		UserAccess = L"允许";
	}
	else
	{
		UserAccess = L"拒绝";
	}

	CompanyName = (*hsProcItem)->CompanyName;

	AddProcessFileIcon(Path.GetBuffer());

	m_ProcessList.InsertItem(ulItem,Name,ulItem);
	m_ProcessList.SetItemText(ulItem,HS_PROCESS_COLUMN_PID,Pid);
	m_ProcessList.SetItemText(ulItem,HS_PROCESS_COLUMN_PPID,PPid);
	m_ProcessList.SetItemText(ulItem,HS_PROCESS_COLUMN_PATH,Path);
	m_ProcessList.SetItemText(ulItem,HS_PROCESS_COLUMN_EPROCESS,EProcess);
	m_ProcessList.SetItemText(ulItem,HS_PROCESS_COLUMN_USERACCESS,UserAccess);
	m_ProcessList.SetItemText(ulItem,HS_PROCESS_COLUMN_COMPANY,CompanyName);

	if (_wcsnicmp(CompanyName,L"Microsoft Corporation", wcslen(L"Microsoft Corporation"))==0)
	{
		m_ProcessList.SetItemData(ulItem,1);
	}


	CToolTipCtrl ToolTipCtrl;

	ToolTipCtrl.Create(this);
	m_ProcessList.SetToolTips(&ToolTipCtrl);


	return TRUE;
}



void CProcessDlg::OnMenuProcessProcesshandle()
{
	// TODO: 在此添加命令处理程序代码
	HsOpenProcessViewDlg(HS_PROCVIEW_TYPE_HANDLE);
}

void CProcessDlg::OnMenuProcessProcesswindow()
{
	// TODO: 在此添加命令处理程序代码
	HsOpenProcessViewDlg(HS_PROCVIEW_TYPE_WINDOW);
}


void CProcessDlg::OnMenuProcessProcessmodule()
{
	// TODO: 在此添加命令处理程序代码
	HsOpenProcessViewDlg(HS_PROCVIEW_TYPE_MODULE);
}

void CProcessDlg::OnMenuProcessMemory()
{
	// TODO: 在此添加命令处理程序代码

	HsOpenProcessViewDlg(HS_PROCVIEW_TYPE_MEMORY);
}


void CProcessDlg::OnMenuProcessNewrun()
{
	// TODO: 在此添加命令处理程序代码

	WCHAR wzFileFilter[] = L"应用程序 (*.exe)\0*.exe\0";
	WCHAR wzFileChoose[] = L"打开文件";


	CFileDialog FileDlg(TRUE);
	FileDlg.m_ofn.lpstrTitle  = wzFileChoose;
	FileDlg.m_ofn.lpstrFilter = wzFileFilter;

	if (IDOK != FileDlg.DoModal())
	{
		return;
	}

	CString ExePath = FileDlg.GetPathName();

	ShellExecuteW(NULL, L"open", ExePath, L"", L"", SW_SHOW);
}



void CProcessDlg::AddProcessFileIcon(WCHAR* ProcessPath)
{
	SHFILEINFO shInfo;
	memset(&shInfo, 0, sizeof(shInfo));
	SHGetFileInfo(ProcessPath, FILE_ATTRIBUTE_NORMAL, 
		&shInfo, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_USEFILEATTRIBUTES);

	HICON  hIcon = shInfo.hIcon;

	m_TreeImageList.Add(hIcon);
}

void CProcessDlg::OnDblclkListProcesslist(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	OnMenuProcessDetail();

	*pResult = 0;
}





void CProcessDlg::OnMenuProcessSuspend()
{
	// TODO: 在此添加命令处理程序代码
}


void CProcessDlg::OnMenuProcessRecovery()
{
	// TODO: 在此添加命令处理程序代码
}




void CProcessDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	// TODO: 在此处添加消息处理程序代码

	ResizeX = cx;
	ResizeY = cy;
}


void CProcessDlg::OnNMCustomdrawListProcesslist(NMHDR *pNMHDR, LRESULT *pResult)
{
	NMLVCUSTOMDRAW* pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>( pNMHDR );
	// TODO: 在此添加控件通知处理程序代码

	*pResult = CDRF_DODEFAULT;

	if ( CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage )
	{
		*pResult = CDRF_NOTIFYITEMDRAW;
	}
	else if ( CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage )
	{
		*pResult = CDRF_NOTIFYSUBITEMDRAW;
	}
	else if ( (CDDS_ITEMPREPAINT | CDDS_SUBITEM) == pLVCD->nmcd.dwDrawStage )
	{
		COLORREF clrNewTextColor, clrNewBkColor;
		int bHooked = 0;
		int nItem = static_cast<int>( pLVCD->nmcd.dwItemSpec );

		clrNewTextColor = RGB( 0, 0, 0 );
		clrNewBkColor = RGB( 255, 255, 255 );

		bHooked = (int)m_ProcessList.GetItemData(nItem); 		
		if (bHooked == 1)
		{
			clrNewTextColor = RGB( 0, 0, 255 );
		}

		pLVCD->clrText = clrNewTextColor;
		pLVCD->clrTextBk = clrNewBkColor;

		*pResult = CDRF_DODEFAULT;
	}

}

```

`arkProject/HeavenShadow/HeavenShadow/ProcessDlg.h`:

```h
#pragma once

#include "Common.h"
#include "afxcmn.h"

#include "MyList.h"


// CProcessDlg 对话框

class CProcessDlg : public CDialog
{
	DECLARE_DYNAMIC(CProcessDlg)

public:
	CProcessDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CProcessDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_PROCESS };


	//////////////////////////////////////////////////////////////////////////
	void HsLoadProcessList(void);
	void HsQuaryProcessThread(ULONG_PTR ProcessId);
	void AddProcessFileIcon(WCHAR* ProcessPath);
	LRESULT HsProcessDlgSendInsert(WPARAM wParam, LPARAM lParam);

	CWnd* m_wParent;
	CImageList m_TreeImageList;

	CListCtrl m_ProcessList;

	void CProcessDlg::HsInitList(void);

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持


	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedButtonTest();
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnColumnclickListProcesslist(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnRclickListProcesslist(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuProcessRefresh();
	afx_msg void OnMenuProcessKillprocess();
	afx_msg void OnMenuProcessProcessthread();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnMenuProcessCopyinfo();
	afx_msg void OnMenuProcessAttribute();
	afx_msg void OnMenuProcessLocationfile();
	afx_msg void OnMenuProcessExporttxt();
	afx_msg void OnMenuProcessExportexcel();
	afx_msg void OnMenuProcessProcessprivilege();
	afx_msg void OnMenuProcessInjectdll();
	afx_msg void OnMenuProcessKillmust();
	void HsOpenProcessViewDlg(int nViewType);
	afx_msg void OnMenuProcessDetail();

	afx_msg void OnMenuProcessProcesshandle();
	afx_msg void OnMenuProcessMemory();
	afx_msg void OnMenuProcessNewrun();
	afx_msg void OnDblclkListProcesslist(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuProcessProcesswindow();
	afx_msg void OnMenuProcessSuspend();
	afx_msg void OnMenuProcessRecovery();
	afx_msg void OnMenuProcessProcessmodule();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnNMCustomdrawListProcesslist(NMHDR *pNMHDR, LRESULT *pResult);
};

```

`arkProject/HeavenShadow/HeavenShadow/ProcessFunc.cpp`:

```cpp
#include "stdafx.h"
#include "ProcessFunc.h"
#include "Common.h"



#include <afxdb.h>
#include <odbcinst.h>

#include <WinVer.h>

#pragma comment(lib, "version.lib")

extern BOOL bIsChecking;
extern HANDLE g_hDevice;
extern CWnd* g_process;
extern CWnd* g_wParent;



extern UINT sort_column;
extern BOOL method;

extern enum HS_PROCESSDIG_SEND_TYPE;

int nProcCount = 0;


COLUMNSTRUCT g_Column_Process[] = 
{
	{	L"映像名称",			160	},
	{	L"进程ID",			65	},
	{	L"父进程ID",			65	},
	{	L"映像路径",			230	},
	{	L"EPROCESS",		125	},
	{	L"应用层访问",		75	},
	{	L"文件厂商",			122	}
};

UINT g_Column_Process_Count  = 7;	  //进程列表列数

extern int dpix;
extern int dpiy;


//自定函数
//////////////////////////////////////////////////////////////////////////


void HsInitProcessList(CMyList *m_ListCtrl)
{
	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_Process_Count;i++)
	{
		if (i == HS_PROCESS_COLUMN_USERACCESS)
		{
			m_ListCtrl->InsertColumn(i, g_Column_Process[i].szTitle,LVCFMT_CENTER,(int)(g_Column_Process[i].nWidth*(dpix/96.0)));
		}
		else
		{
			m_ListCtrl->InsertColumn(i, g_Column_Process[i].szTitle,LVCFMT_LEFT,(int)(g_Column_Process[i].nWidth*(dpix/96.0)));
		}
	}

}



ULONG_PTR
HsQuerySystemProcessCount(CMyList *m_ListCtrl)
{

	ULONG_PTR dwReturnSize = 0;
	ULONG_PTR dwRet = 0;

	ULONG_PTR ulProcessCount = 0;

	dwRet = DeviceIoControl(g_hDevice,
		HS_IOCTL(HS_IOCTL_PROC_PROCESSCOUNT),
		NULL,
		0,
		&ulProcessCount,
		sizeof(ULONG_PTR),
		(LPDWORD)&dwReturnSize,
		NULL);

	//发送IO 控制码

	if (dwRet==0)
	{
		//cout<<"Send IoCode Error"<<endl;
	}

	return ulProcessCount;
}





DWORD WINAPI HsQueryProcessFunction(CMyList *m_ListCtrl)
{
	bIsChecking = TRUE;

	HsQueryProcessList(m_ListCtrl);

	bIsChecking = FALSE;
	return 0;
}


void HsQueryProcessList(CMyList *m_ListCtrl)
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	//发送IO 控制码
	//PVOID hProcessList = NULL;

	int ulItem = 0;	//进程计数

	ULONG_PTR ulPid = 0;

	ulItem = 0;


	//ULONG_PTR ulProcessCount = HsQuerySystemProcessCount(m_ListCtrl);

	while(1)
	{
		TRY 
		{
			HSPROCESSINFO hsProcItem = {0};


			dwRet = DeviceIoControl(g_hDevice,
				HS_IOCTL(HS_IOCTL_PROC_PROCESSLIST),
				&ulPid,
				sizeof(ULONG_PTR),
				&hsProcItem,
				sizeof(HSPROCESSINFO),
				&dwReturnSize,
				NULL);

			if (dwReturnSize==0)
			{
				break;
			}
			else
			{
				//发送状态栏消息响应
				CString csStatusMsg;
				csStatusMsg.Format(L"进程列表正在加载。 进程数：%d",ulItem);

				HsSendStatusDetail(csStatusMsg.GetBuffer());
			}

			if (hsProcItem.Eprocess == 0||hsProcItem.Eprocess == NULL) 
			{
				break;
			}

			if ((_wcsnicmp(hsProcItem.Path,L"UnKnow",wcslen(L"UnKnow"))==0&&hsProcItem.Pid>4))
			{
				goto CONTINUE;
			}

			if (hsProcItem.Pid == 0)
			{
				StringCchCopyW(hsProcItem.Name,wcslen(L"System Idle Process")+1,L"System Idle Process");
				StringCchCopyW(hsProcItem.Path,wcslen(L"System Idle Process")+1,L"System Idle Process");
				hsProcItem.UserAccess = FALSE;
				hsProcItem.PPid = 0xffffffff;
				StringCchCopyW(hsProcItem.CompanyName,wcslen(L" ")+1,L" ");

			}
			else if (hsProcItem.Pid == 4)	//System进程
			{
				StringCchCopyW(hsProcItem.Name,wcslen(L"System")+1,L"System");

				WCHAR wzTempDir[260] = {0};
				CString Temp;
				GetEnvironmentVariableW(L"windir",wzTempDir,MAX_PATH);

				Temp = wzTempDir;
				Temp += L"\\System32\\ntoskrnl.exe";


				StringCchCopyW(hsProcItem.Path,Temp.GetLength()+1,Temp.GetBuffer());
				hsProcItem.UserAccess = FALSE;
				hsProcItem.PPid = 0xffffffff;
				StringCchCopyW(hsProcItem.CompanyName,
					HsGetFileCompanyName(hsProcItem.Path).GetLength()+1,
					HsGetFileCompanyName(hsProcItem.Path).GetBuffer());
			}
			else
			{
				WCHAR* szImageFileName = NULL;
				szImageFileName = wcsrchr(hsProcItem.Path,'\\');
				szImageFileName++;

				StringCchCopyW(hsProcItem.Name,wcslen(szImageFileName)+1,szImageFileName);

				hsProcItem.PPid = hsProcItem.PPid;

				if (HsR3CanOpenProcess((DWORD)hsProcItem.Pid)==TRUE)
				{
					hsProcItem.UserAccess = TRUE;
				}
				else
				{
					hsProcItem.UserAccess = FALSE;
				}
				
				CString Path, CompanyName;
				Path = hsProcItem.Path;
				CompanyName = HsGetFileCompanyName(Path);
				if (CompanyName.GetLength() == 0)
				{
					CompanyName = L" ";
				}

				StringCchCopyW(hsProcItem.CompanyName,CompanyName.GetLength()+1,CompanyName.GetBuffer());

				if (HsIs64BitWindows())
				{
					if (HsIs32BitFile(hsProcItem.Path) == TRUE)
					{
						CString Name;
						Name = hsProcItem.Name;
						Name += L" *32";
						StringCchCopyW(hsProcItem.Name,Name.GetLength()+1,Name.GetBuffer());
					}
				}
			}

			hsProcItem.Pid = hsProcItem.Pid;

			hsProcItem.Eprocess = hsProcItem.Eprocess;

			//////////////////////////////////////////////////////////////////////////
			// 开始插入列表

			PHSPROCESSINFO pHsProcessInfo = &hsProcItem;

			::SendMessageW(g_process->m_hWnd,HS_PROCESSDIG_SEND_INSERT,sizeof(HSPROCESSINFO),(LPARAM)&pHsProcessInfo);

			//插入列表结束
			//////////////////////////////////////////////////////////////////////////

CONTINUE:


			ulPid = hsProcItem.Pid + 4;

			ulItem = ulItem + 1;

		}
		CATCH (CMemoryException, e)
		{
			
		}
		END_CATCH
		
	}
	

	bIsChecking = FALSE;

	CString csStatusMsg;
	csStatusMsg.Format(L"进程列表加载完成。 进程数：%d",ulItem);

	HsSendStatusDetail(csStatusMsg.GetBuffer());

	nProcCount = (int)ulItem;
}





CString HsGetFileCompanyName(CString strPath)
{
	CString strCompanyName = 0;;

	if (strPath.IsEmpty())
	{
		return NULL;
	}

	if (!strPath.CompareNoCase(L"Idle") || !strPath.CompareNoCase(L"System"))
	{
		return NULL;
	}

	struct LANGANDCODEPAGE {
		WORD wLanguage;
		WORD wCodePage;
	} *lpTranslate;

	LPWSTR lpstrFilename = (LPWSTR)(LPCWSTR)strPath;
	DWORD dwHandle = 0;
	DWORD dwVerInfoSize = GetFileVersionInfoSize(lpstrFilename, &dwHandle);

	if (dwVerInfoSize)
	{
		LPVOID Buffer = malloc(sizeof(char)*dwVerInfoSize);

		if (Buffer)
		{
			if (GetFileVersionInfo(lpstrFilename, dwHandle, dwVerInfoSize, Buffer))
			{
				UINT cbTranslate = 0;

				if ( VerQueryValue(Buffer, L"\\VarFileInfo\\Translation", (LPVOID*) &lpTranslate, &cbTranslate))
				{                
					LPCWSTR lpwszBlock = 0;          
					UINT    cbSizeBuf  = 0;
					WCHAR   wzSubBlock[MAX_PATH] = {0};

					if ((cbTranslate/sizeof(struct LANGANDCODEPAGE)) > 0)   
					{
						StringCchPrintf(wzSubBlock, sizeof(wzSubBlock)/sizeof(WCHAR), 
							L"\\StringFileInfo\\%04x%04x\\CompanyName", lpTranslate[0].wLanguage, lpTranslate[0].wCodePage); 
					}

					if ( VerQueryValue(Buffer, wzSubBlock, (LPVOID*)&lpwszBlock, &cbSizeBuf))
					{
						WCHAR wzCompanyName[MAX_PATH] = {0};

						StringCchCopy(wzCompanyName, MAX_PATH/sizeof(WCHAR), (LPCWSTR)lpwszBlock);   //将系统中内存的数据拷贝到我们自己内存当中
						strCompanyName = wzCompanyName;
					}
				}
			}

			free(Buffer);
		}
	}

	return strCompanyName;
}



BOOL __stdcall HsIs32BitFile(const WCHAR * pwszFullPath)
{
	FILE * peFile = NULL;
	_wfopen_s(&peFile, pwszFullPath, L"rb");
	if (peFile == NULL)
	{
		fclose(peFile);
		return -1;
	}

	IMAGE_DOS_HEADER imageDosHeader;
	fread(&imageDosHeader, sizeof(IMAGE_DOS_HEADER), 1, peFile);
	if (imageDosHeader.e_magic != IMAGE_DOS_SIGNATURE)
	{
		fclose(peFile);
		return FALSE;
	}

	IMAGE_NT_HEADERS imageNtHeaders;
	fseek(peFile, imageDosHeader.e_lfanew, SEEK_SET);
	fread(&imageNtHeaders, sizeof(IMAGE_NT_HEADERS), 1, peFile);
	fclose(peFile);
	if (imageNtHeaders.Signature != IMAGE_NT_SIGNATURE)
	{
		return FALSE;
	}

	if (imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
	{
		return TRUE;
	}
// 	if (imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_IA64 ||
// 		imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
// 	{
// 		return FALSE;	//64BIT
// 	}

	return FALSE;
}



BOOL HsR3CanOpenProcess(DWORD dwPid)
{
	BOOL bOpen = TRUE;

	HsDebugPrivilege(SE_DEBUG_NAME, TRUE);

	HANDLE hProcess = OpenProcess(PROCESS_TERMINATE | PROCESS_VM_OPERATION, TRUE, dwPid);

	HsDebugPrivilege(SE_DEBUG_NAME, FALSE);
	if (hProcess)
	{
		CloseHandle(hProcess);
	}
	else
	{
		bOpen = FALSE;
	}

	return bOpen;
}



VOID HsCheckAttribute(CString strPath)
{

	if (!strPath.IsEmpty())
	{
		SHELLEXECUTEINFO ExecInfor ;
		memset(&ExecInfor, 0, sizeof(ExecInfor)) ;
		ExecInfor.fMask = SEE_MASK_INVOKEIDLIST ;
		ExecInfor.cbSize = sizeof(ExecInfor) ;
		ExecInfor.hwnd = NULL ;
		ExecInfor.lpVerb = _T( "properties" );
		ExecInfor.lpFile = strPath ;
		ExecInfor.lpParameters = NULL ;
		ExecInfor.lpDirectory = NULL ;
		ExecInfor.nShow = SW_SHOWNORMAL ;
		ExecInfor.hProcess = NULL ;
		ExecInfor.lpIDList = 0 ;
		ExecInfor.hInstApp = 0 ;
		ShellExecuteEx(&ExecInfor) ;
	}
	else
	{
		MessageBox(NULL,L"文件路径错误", NULL, MB_OK | MB_ICONWARNING);
	}
}



VOID HsLocationExplorer(CString strPath)
{
	if (!strPath.IsEmpty() && PathFileExists(strPath))
	{
		CString strCmd;
		strCmd.Format(L"/select,%s", strPath);
		ShellExecuteW(NULL, L"open", L"explorer.exe", strCmd, NULL, SW_SHOW);
	}
	else
	{
		MessageBox(NULL,L"文件路径错误", NULL, MB_OK | MB_ICONWARNING);
	}
}




BOOL HsGetDefaultTextFileName(CString& strFile)
{
	CString strTime;
	CTime Time = CTime::GetCurrentTime();
	int FileNameDay, FileNameMonth, FileNameYear, FileHour, FileMin, FileSec;

	FileNameDay = Time.GetDay();
	FileNameMonth = Time.GetMonth();
	FileNameYear = Time.GetYear();
	FileHour = Time.GetHour();
	FileMin = Time.GetMinute();
	FileSec = Time.GetSecond();
	strTime.Format(L"%04d%02d%02d%02d%02d%02d", FileNameYear, FileNameMonth, FileNameDay, FileHour, FileMin, FileSec);

	strFile = strTime + L".txt";

	CFileDialog FileDlg(
		FALSE, 
		0, 
		strFile, 
		0, 
		L"文本文件 (*.txt)|*.txt|所有文件 (*.*)|*.*||",
		0
		);

	if (IDOK == FileDlg.DoModal())
	{
		strFile = FileDlg.GetFileName();   //可以获得文件路径 并且修改

		CString strTemp = strFile.Right((int)wcslen(L".txt"));

		if (strTemp.CompareNoCase(L".txt") != 0)
		{
			strFile += L".txt";
		}

		if (!PathFileExists(strFile))
		{
			return TRUE;
		}
		else if	(PathFileExists(strFile) && MessageBox(NULL, L"文件已经存在，是否覆盖？", L"天影卫士", MB_YESNO | MB_ICONQUESTION) == IDYES)
		{
			if(!DeleteFile(strFile))
			{
				MessageBox(NULL, L"覆盖文件失败。", L"天影卫士", MB_OK | MB_ICONERROR);
				return FALSE;
			}

			return TRUE;
		}
	}

	return FALSE;
}



// CString HsGetExcelDriver()
// {
// 	WCHAR wzBuffer[0x1000] = {0};
// 	WORD  cbBufferMax = 0x1000;
// 	WORD  cbBufferOut;
// 	WCHAR *pwzBuffer = wzBuffer;
// 	CString strDriver;
// 
// 	if (!SQLGetInstalledDrivers(wzBuffer, cbBufferMax, &cbBufferOut))
// 	{
// 		return NULL;
// 	}
// 
// 	do
// 	{
// 		if (wcsstr(pwzBuffer, L"Excel") != 0)
// 		{
// 			strDriver = CString(pwzBuffer);
// 			break;
// 		}
// 
// 		pwzBuffer = wcschr(pwzBuffer, L'\0') + 1;
// 	}
// 	while (pwzBuffer[1] != L'\0');
// 
// 	return strDriver;
// }




// BOOL HsGetDefaultExcelFileName(CString& strExcelFile)
// {
// 	CString strTime;
// 	CTime Time = CTime::GetCurrentTime();
// 	int FileNameDay, FileNameMonth, FileNameYear, FileHour, FileMin, FileSec;
// 
// 	FileNameDay = Time.GetDay();
// 	FileNameMonth = Time.GetMonth();
// 	FileNameYear = Time.GetYear();
// 	FileHour = Time.GetHour();
// 	FileMin = Time.GetMinute();
// 	FileSec = Time.GetSecond();
// 	strTime.Format(L"%04d%02d%02d%02d%02d%02d", FileNameDay, FileNameMonth, FileNameYear, FileHour, FileMin, FileSec);
// 
// 	strExcelFile = strTime + L".xls";
// 
// 	CFileDialog FileDlg(
// 		FALSE, 
// 		0, 
// 		strExcelFile, 
// 		0, 
// 		L"Excel Files (*.xls)|*.xls|All Files (*.*)|*.*||",
// 		0
// 		);
// 
// 	if (IDOK == FileDlg.DoModal())
// 	{
// 		strExcelFile = FileDlg.GetFileName();
// 
// 		CString szTemp = strExcelFile.Right((int)wcslen(L".xls"));
// 
// 		if (szTemp.CompareNoCase(L".xls") != 0)
// 		{
// 			strExcelFile += L".xls";
// 		}
// 
// 		if ( !PathFileExists(strExcelFile) )
// 		{
// 			return TRUE;
// 		}
// 		else if	(PathFileExists(strExcelFile) && MessageBox(NULL, L"文件已经存在，是否覆盖？", L"导出", MB_YESNO | MB_ICONQUESTION) == IDYES)
// 		{
// 			if(!DeleteFile(strExcelFile))
// 			{
// 				MessageBox(NULL, L"覆盖文件失败！", L"导出", MB_OK | MB_ICONERROR);
// 				return FALSE;
// 			}
// 
// 			return TRUE;
// 		}
// 	}
// 
// 	return FALSE;
// }






BOOL HsDebugPrivilege(const WCHAR *pName, BOOL bEnable)
{
	BOOL              bResult = TRUE;
	HANDLE            hToken;
	TOKEN_PRIVILEGES  TokenPrivileges;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken))
	{
		bResult = FALSE;
		return bResult;
	}
	TokenPrivileges.PrivilegeCount = 1;
	TokenPrivileges.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	LookupPrivilegeValue(NULL, pName, &TokenPrivileges.Privileges[0].Luid);
	AdjustTokenPrivileges(hToken, FALSE, &TokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL);
	if (GetLastError() != ERROR_SUCCESS)
	{
		bResult = FALSE;
	}

	CloseHandle(hToken);
	return bResult;	
}







BOOL HsKillProcessByForce(CMyList* m_ListCtrl)
{
	POSITION pos = m_ListCtrl->GetFirstSelectedItemPosition();

	ULONG_PTR ulProcessId = 0;

	int nItem = 0;

	while(pos)
	{
		nItem = m_ListCtrl->GetNextSelectedItem(pos);

		ulProcessId = _ttoi(m_ListCtrl->GetItemText(nItem,HS_PROCESS_COLUMN_PID).GetBuffer());

		if (ulProcessId <= 4)
		{
			return FALSE;
		}

	} 

	if (g_hDevice==NULL)
	{
		return FALSE;
	}

	ULONG dwReturnSize = 0;
	ULONG dwRet = 0;

	BOOL bFeedback = FALSE;

	    
	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_KILLPROCESSBYFORCE),
		&ulProcessId,
		sizeof(ULONG_PTR),
		&bFeedback,
		sizeof(BOOL),
		&dwReturnSize,
		NULL);

	//发送IO 控制码

	if (bFeedback = TRUE)
	{
		m_ListCtrl->DeleteItem(nItem);
	}
	else
	{
		MessageBox(NULL,L"关闭进程失败。",L"天影卫士",0);
	}

	bIsChecking = FALSE;

	return bFeedback;

}





```

`arkProject/HeavenShadow/HeavenShadow/ProcessFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"


enum HS_ENUM_PROC_COLUMN	//进程列表列枚举
{
	HS_PROCESS_COLUMN_NAME = 0,
	HS_PROCESS_COLUMN_PID,
	HS_PROCESS_COLUMN_PPID,
	HS_PROCESS_COLUMN_PATH,
	HS_PROCESS_COLUMN_EPROCESS,
	HS_PROCESS_COLUMN_USERACCESS,
	HS_PROCESS_COLUMN_COMPANY
};



enum HS_PROCESSDIG_SEND_TYPE
{
	HS_PROCESSDIG_SEND_INSERT = 555,	//插入条目
	HS_PROCESSDIG_SEND_DELETE			//删除条目
};


//结构体//////////////////////////////////////////////////////////////////

typedef struct HS_PROCESSINFO
{

	WCHAR     Name[100];
	WCHAR     Path[260];
	WCHAR     CompanyName[100];
	BOOL      UserAccess;
	ULONG_PTR Pid;
	ULONG_PTR PPid;
	ULONG_PTR Eprocess;
	LONGLONG  CreateTime;

}HSPROCESSINFO, *PHSPROCESSINFO;



//函数////////////////////////////////////////////////////////////////////

void HsInitProcessList(CMyList *m_ListCtrl);

DWORD WINAPI HsQueryProcessFunction(CMyList *m_ListCtrl);



void HsQueryProcessList(CMyList *m_ListCtrl);

BOOL HsR3CanOpenProcess(DWORD dwPid);

CString HsGetFileCompanyName(CString strPath);

//查看文件属性
VOID HsCheckAttribute(CString strPath);

//定位文件位置
VOID HsLocationExplorer(CString strPath);





BOOL HsGetDefaultTextFileName(CString& strFile);

CString HsGetExcelDriver();
BOOL HsGetDefaultExcelFileName(CString& strExcelFile);

BOOL __stdcall HsIs32BitFile(const WCHAR * pwszFullPath);


//获取权限
BOOL HsDebugPrivilege(const WCHAR *pName, BOOL bEnable);


//排序比较函数
static int CALLBACK HsProcessListCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);


BOOL HsKillProcessByForce(CMyList* m_ListCtrl);


ULONG_PTR
HsQuerySystemProcessCount(CMyList *m_ListCtrl);
```

`arkProject/HeavenShadow/HeavenShadow/ProcessViewDlg.cpp`:

```cpp
// ProcessViewDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "ProcessViewDlg.h"
#include "afxdialogex.h"

#include "ThreadFunc.h"
#include "PrivilegeFunc.h"
#include "DetailFunc.h"
#include "HandleFunc.h"
#include "WindowFunc.h"
#include "MemoryFunc.h"
#include "PModuleFunc.h"

#include "Common.h"




ULONG_PTR g_ulProcessId = 0;

extern int dpix;
extern int dpiy;


UINT nowType = 999;


// CProcessViewDlg 对话框

IMPLEMENT_DYNAMIC(CProcessViewDlg, CDialog)

CProcessViewDlg::CProcessViewDlg(ULONG_PTR ulViewType, PHSPROCESSINFO piProcInfo, CWnd* pParent /*=NULL*/)
	: CDialog(CProcessViewDlg::IDD, pParent)
{
	m_wParent = pParent;
	m_piProcInfo = piProcInfo;
	m_ulViewType = ulViewType;

	g_ulProcessId = m_piProcInfo->Pid;
}

CProcessViewDlg::~CProcessViewDlg()
{
}

void CProcessViewDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_PROCESS_VIEW, m_viewList);
	DDX_Control(pDX, IDC_LIST_PROCESSVIEWTYPE, m_typeList);
	DDX_Control(pDX, IDC_STATIC_VIEWICON, m_ViewIcon);
}


BEGIN_MESSAGE_MAP(CProcessViewDlg, CDialog)
	ON_NOTIFY(NM_RCLICK, IDC_LIST_PROCESS_VIEW, &CProcessViewDlg::OnRclickListProcessView)
	ON_COMMAND(ID_MENU_PROCESSPRIVILEGE_REFRESH, &CProcessViewDlg::OnMenuProcessprivilegeRefresh)
	ON_COMMAND(ID_MENU_PROCESSPRIVILEGE_ENABLE, &CProcessViewDlg::OnMenuProcessprivilegeEnable)
	ON_COMMAND(ID_MENU_PROCESSPRIVILEGE_DISABLE, &CProcessViewDlg::OnMenuProcessprivilegeDisable)
	ON_WM_PAINT()
	ON_LBN_SELCHANGE(IDC_LIST_PROCESSVIEWTYPE, &CProcessViewDlg::OnSelchangeListProcessviewtype)
	ON_WM_CTLCOLOR()
	ON_COMMAND(ID_MENU_PROCESSTHREAD_REFRESH, &CProcessViewDlg::OnMenuProcessthreadRefresh)
	ON_COMMAND(ID_MENU_PROCESSTHREAD_CLOSETHREAD, &CProcessViewDlg::OnMenuProcessthreadClosethread)
END_MESSAGE_MAP()


// CProcessViewDlg 消息处理程序


BOOL CProcessViewDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	nowType = 999;

	SHFILEINFO shInfo;
	memset(&shInfo, 0, sizeof(shInfo));
	SHGetFileInfo(m_piProcInfo->Path, FILE_ATTRIBUTE_NORMAL, 
		&shInfo, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_USEFILEATTRIBUTES);

	m_hIcon = shInfo.hIcon;

	SetIcon(m_hIcon,TRUE);
	SetIcon(m_hIcon,FALSE);


	m_ViewIcon.SetIcon(m_hIcon);

	m_typeList.InsertString(HS_PROCVIEW_TYPE_DETAIL,L"进程映像");
	m_typeList.InsertString(HS_PROCVIEW_TYPE_THREAD,L"进程线程");
	m_typeList.InsertString(HS_PROCVIEW_TYPE_PRIVILEGE,L"进程权限");
	m_typeList.InsertString(HS_PROCVIEW_TYPE_HANDLE,L"进程句柄");
	m_typeList.InsertString(HS_PROCVIEW_TYPE_WINDOW,L"进程窗口");
	m_typeList.InsertString(HS_PROCVIEW_TYPE_MODULE,L"进程模块");
	m_typeList.InsertString(HS_PROCVIEW_TYPE_MEMORY,L"进程内存");

	m_typeList.SetItemHeight(-1,(UINT)(16*(dpiy/96.0)));

	m_typeList.SetCurSel((int)m_ulViewType);

	OnSelchangeListProcessviewtype();

	UINT uIconSize = 20;

	uIconSize *= (UINT)(dpix/96.0);

	m_TreeKernelImageList.Create(1, uIconSize, ILC_COLOR32 | ILC_MASK, 2, 2);

	ListView_SetImageList(m_viewList.m_hWnd, m_TreeKernelImageList.GetSafeHandle(), LVSIL_SMALL);


	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CProcessViewDlg::OnRclickListProcessView(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	switch (m_ulViewType)
	{
	case HS_PROCVIEW_TYPE_PRIVILEGE:
		{
			HsProcessPrivilegePopupMenu(&m_viewList,this);
			break;
		}
	case HS_PROCVIEW_TYPE_THREAD:
		{
			HsProcessThreadPopupMenu(&m_viewList,this);
			break;
		}
	case HS_PROCVIEW_TYPE_WINDOW:
		{
			HsProcessWindowPopupMenu(&m_viewList,this);
			break;
		}
	}

	*pResult = 0;
}


void CProcessViewDlg::OnMenuProcessprivilegeRefresh()
{
	// TODO: 在此添加命令处理程序代码

 	CloseHandle(CreateThread(NULL, 0, 
 		(LPTHREAD_START_ROUTINE)HsQueryProcessPrivilege,&m_viewList, 0, NULL));

	//HsQueryProcessPrivilege(&m_viewList);
}


void CProcessViewDlg::OnMenuProcessprivilegeEnable()
{
	// TODO: 在此添加命令处理程序代码

	POSITION pos = m_viewList.GetFirstSelectedItemPosition();

	while (pos)
	{
		int nItem = m_viewList.GetNextSelectedItem(pos);

		WCHAR PrivilegeName[60] = {0};
		
		StringCchCopyW(PrivilegeName,m_viewList.GetItemText(nItem,0).GetLength()+1,m_viewList.GetItemText(nItem,0).GetBuffer());

		BOOL bFeedBack = HsAdjustPrivilege(m_piProcInfo->Pid,PrivilegeName,TRUE);

		if (bFeedBack == TRUE)
		{
			m_viewList.SetItemText(nItem,2,L"Enabled");
		}
	}
}


void CProcessViewDlg::OnMenuProcessprivilegeDisable()
{
	// TODO: 在此添加命令处理程序代码

	POSITION pos = m_viewList.GetFirstSelectedItemPosition();

	

	while (pos)
	{
		int nItem = m_viewList.GetNextSelectedItem(pos);

		WCHAR PrivilegeName[60];

		StringCchCopyW(PrivilegeName,m_viewList.GetItemText(nItem,0).GetLength()+1,m_viewList.GetItemText(nItem,0).GetBuffer());

		BOOL bFeedBack = HsAdjustPrivilege(m_piProcInfo->Pid,PrivilegeName,FALSE);

		if (bFeedBack == TRUE)
		{
			m_viewList.SetItemText(nItem,2,L"Disabled");
		}
	}
}


void CProcessViewDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()
 
 	CRect   rect;
 	GetClientRect(&rect);
	dc.FillSolidRect(rect,RGB(255,255,255));

	CRect leftlistrect;
	CRect rightlistrect;

	m_typeList.GetClientRect(leftlistrect);

	CPoint startPoint;
	startPoint.x = (LONG)(leftlistrect.right)+4;
	startPoint.y = -1;
	CPoint endPoint;
	endPoint.x = (LONG)(leftlistrect.right)+4;
	endPoint.y = rect.Height()+2;

	rightlistrect.left = startPoint.x+1;
	rightlistrect.right = rect.Width();
	rightlistrect.top = 0;
	rightlistrect.bottom = rect.Height();
	m_viewList.MoveWindow(rightlistrect);



	COLORREF m_Color(RGB(190,190,190));

	CClientDC aDC(this); //CClientDC的构造函数需要一个参数，这个参数是指向绘图窗口的指针，我们用this指针就可以了
	CPen pen(PS_SOLID,1,m_Color); ////建立一个画笔类对象，构造时设置画笔属性
	aDC.SelectObject(&pen);
	aDC.MoveTo(startPoint);
	aDC.LineTo(endPoint);

	if (IsIconic())
	{
		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;
		dc.DrawIcon(32,32,m_hIcon);
	}
}


void CProcessViewDlg::OnSelchangeListProcessviewtype()
{
	// TODO: 在此添加控件通知处理程序代码

	int nItem = m_typeList.GetCurSel();

	m_ulViewType = nItem;

	switch(m_ulViewType)
	{
	case HS_PROCVIEW_TYPE_DETAIL:
		{
			if (nowType == HS_PROCVIEW_TYPE_DETAIL)
			{
				return;
			}
			nowType = HS_PROCVIEW_TYPE_DETAIL;

			CString Temp;
			Temp.Format(L"进程映像 - %s", m_piProcInfo->Name);

			SetWindowText(Temp.GetBuffer());

			HsInitProcessDetailList(&m_viewList);

			HsLoadProcessDetailList(m_piProcInfo,&m_viewList);

			break;
		}
	case HS_PROCVIEW_TYPE_THREAD:
		{
			if (nowType == HS_PROCVIEW_TYPE_THREAD)
			{
				return;
			}
			nowType = HS_PROCVIEW_TYPE_THREAD;

			CString Temp;

			Temp.Format(L"进程线程 - %s", m_piProcInfo->Name);

			SetWindowText(Temp.GetBuffer());

			HsInitThreadList(&m_viewList);

			//CloseHandle(CreateThread(NULL, 0,
			//	(LPTHREAD_START_ROUTINE)HsQueryProcessThread,&m_viewList, 0, NULL));

			HsQueryProcessThread(&m_viewList);

			break;
		}
	case HS_PROCVIEW_TYPE_PRIVILEGE:
		{
			if (nowType == HS_PROCVIEW_TYPE_PRIVILEGE)
			{
				return;
			}
			nowType = HS_PROCVIEW_TYPE_PRIVILEGE;

			CString Temp;
			Temp.Format(L"进程权限 - %s", m_piProcInfo->Name);

			SetWindowText(Temp.GetBuffer());

			HsInitPrivilegeList(&m_viewList);

			//CloseHandle(CreateThread(NULL, 0,
			//	(LPTHREAD_START_ROUTINE)HsQueryProcessPrivilege,&m_viewList, 0, NULL));

			HsQueryProcessPrivilege(&m_viewList);

			break;
		}
	case HS_PROCVIEW_TYPE_HANDLE:
		{
			if (nowType == HS_PROCVIEW_TYPE_HANDLE)
			{
				return;
			}
			nowType = HS_PROCVIEW_TYPE_HANDLE;

			CString Temp;
			Temp.Format(L"进程句柄 - %s", m_piProcInfo->Name);

			SetWindowText(Temp.GetBuffer());

			HsInitProcessHandleList(&m_viewList);

			//CloseHandle(CreateThread(NULL, 0,
			//	(LPTHREAD_START_ROUTINE)HsQueryProcessHandle,&m_viewList, 0, NULL));

			HsQueryProcessHandle(&m_viewList);

			break;
		}
	case HS_PROCVIEW_TYPE_WINDOW:
		{
			if (nowType == HS_PROCVIEW_TYPE_WINDOW)
			{
				return;
			}
			nowType = HS_PROCVIEW_TYPE_WINDOW;


			CString Temp;
			Temp.Format(L"进程窗口 - %s", m_piProcInfo->Name);

			SetWindowText(Temp.GetBuffer());

			HsInitWindowList(&m_viewList);

			//CloseHandle(CreateThread(NULL, 0,
			//	(LPTHREAD_START_ROUTINE)HsQueryProcessWindow,&m_viewList, 0, NULL));

			HsQueryProcessWindow(&m_viewList);

			break;
		}
	case HS_PROCVIEW_TYPE_MODULE:
		{
			if (nowType == HS_PROCVIEW_TYPE_MODULE)
			{
				return;
			}
			nowType = HS_PROCVIEW_TYPE_MODULE;

			CString Temp;
			Temp.Format(L"进程模块 - %s", m_piProcInfo->Name);

			SetWindowText(Temp.GetBuffer());

			HsInitPModuleDetailList(&m_viewList);

			HsLoadPModuleDetailList(&m_viewList);

			break;
		}
	case HS_PROCVIEW_TYPE_MEMORY:
		{
			if (nowType == HS_PROCVIEW_TYPE_MEMORY)
			{
				return;
			}
			nowType = HS_PROCVIEW_TYPE_MEMORY;

			CString Temp;
			Temp.Format(L"进程内存 - %s", m_piProcInfo->Name);

			SetWindowText(Temp.GetBuffer());

			HsInitMemoryList(&m_viewList);

			HsQueryProcessMemory(&m_viewList);

			break;
		}
	}

	m_viewList.SetFocus();
}


BOOL CProcessViewDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


HBRUSH CProcessViewDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

	// TODO:  在此更改 DC 的任何特性

// 	if ( nCtlColor == CTLCOLOR_STATIC)
// 	{
// 		pDC->SetBkMode(TRANSPARENT);
// 		pDC->SetBkColor(RGB(255,255,255));
// 
// 		return (HBRUSH)::GetStockObject(NULL_BRUSH);
// 
// 	}


// 	if (nCtlColor == CTLCOLOR_LISTBOX)
// 	{
// 		pDC->SetBkMode(TRANSPARENT);
// 		return (HBRUSH)::GetStockObject(NULL_BRUSH);
// 	}

	// TODO:  如果默认的不是所需画笔，则返回另一个画笔
	return hbr;
}


void CProcessViewDlg::OnMenuProcessthreadRefresh()
{
	// TODO: 在此添加命令处理程序代码
	CloseHandle(CreateThread(NULL, 0, 
		(LPTHREAD_START_ROUTINE)HsQueryProcessThread,&m_viewList, 0, NULL));
}


void CProcessViewDlg::OnMenuProcessthreadClosethread()
{
	// TODO: 在此添加命令处理程序代码
	POSITION pos = m_viewList.GetFirstSelectedItemPosition();

	while (pos)
	{
		UINT nItem = m_viewList.GetNextSelectedItem(pos);

		ULONG ulThreadId = _ttoi(m_viewList.GetItemText(nItem,0));

		HANDLE hThread = OpenThread(THREAD_TERMINATE,FALSE,ulThreadId);

		BOOL bRet = TerminateThread(hThread,0);

		if (bRet)
		{
			m_viewList.DeleteItem(nItem);
		}
	}
}

```

`arkProject/HeavenShadow/HeavenShadow/ProcessViewDlg.h`:

```h
#pragma once

#include "ProcessFunc.h"
#include "MyList.h"
#include "afxwin.h"



enum HS_ENUM_PROCVIEW_TYPE
{
	HS_PROCVIEW_TYPE_DETAIL,
	HS_PROCVIEW_TYPE_THREAD,
	HS_PROCVIEW_TYPE_PRIVILEGE,
	HS_PROCVIEW_TYPE_HANDLE,
	HS_PROCVIEW_TYPE_WINDOW,
	HS_PROCVIEW_TYPE_MODULE,
	HS_PROCVIEW_TYPE_MEMORY
};



// CProcessViewDlg 对话框

class CProcessViewDlg : public CDialog
{
	DECLARE_DYNAMIC(CProcessViewDlg)

public:
	CProcessViewDlg(ULONG_PTR ulViewType, PHSPROCESSINFO piProcInfo, CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CProcessViewDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_PROCESS_VIEW };

	// 所属进程信息
	PHSPROCESSINFO m_piProcInfo;

	// 父窗口指针
	CWnd* m_wParent;

	HICON m_hIcon;

	// 窗口显示类型
	ULONG_PTR m_ulViewType;

	CImageList m_TreeKernelImageList;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	CMyList m_viewList;
	virtual BOOL OnInitDialog();
	afx_msg void OnRclickListProcessView(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuProcessprivilegeRefresh();
	afx_msg void OnMenuProcessprivilegeEnable();
	afx_msg void OnMenuProcessprivilegeDisable();
	afx_msg void OnPaint();
	CListBox m_typeList;
	afx_msg void OnSelchangeListProcessviewtype();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	CStatic m_ViewIcon;
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnMenuProcessthreadRefresh();
	afx_msg void OnMenuProcessthreadClosethread();
};

```

`arkProject/HeavenShadow/HeavenShadow/ReadMe.txt`:

```txt
================================================================================
MICROSOFT 基础类库: HeavenShadow 项目概述
===============================================================================

应用程序向导已为您创建了这个 HeavenShadow 应用程序。此应用程序不仅演示 Microsoft 基础类的基本使用方法，还可作为您编写应用程序的起点。

本文件概要介绍组成 HeavenShadow 应用程序的每个文件的内容。

HeavenShadow.vcxproj
这是使用应用程序向导生成的 VC++ 项目的主项目文件。 
它包含生成该文件的 Visual C++ 的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

HeavenShadow.vcxproj.filters
    这是使用“应用程序向导”生成的 VC++ 项目筛选器文件。
    它包含有关项目文件与筛选器之间的关联信息。在 IDE 中，通过这种关联，在特定节点下以分组形式显示具有相似扩展名的文件。例如，“.cpp”文件与“源文件”筛选器关联。

HeavenShadow.h
这是应用程序的主要头文件。它包括其他项目特定的头文件(包括 Resource.h)，并声明 CHeavenShadowApp 应用程序类。

HeavenShadow.cpp
这是包含应用程序类 CHeavenShadowApp 的主要应用程序源文件。

HeavenShadow.rc
这是程序使用的所有 Microsoft Windows 资源的列表。它包括 RES 子目录中存储的图标、位图和光标。此文件可以直接在 Microsoft Visual C++ 中进行编辑。项目资源位于 2052 中。

res\HeavenShadow.ico
这是用作应用程序图标的图标文件。此图标包括在主要资源文件 HeavenShadow.rc 中。

res\HeavenShadow.rc2
此文件包含不在 Microsoft Visual C++ 中进行编辑的资源。您应该将不可由资源编辑器编辑的所有资源放在此文件中。


/////////////////////////////////////////////////////////////////////////////

应用程序向导创建一个对话框类:

HeavenShadowDlg.h，HeavenShadowDlg.cpp - 对话框
这些文件包含 CHeavenShadowDlg 类。该类定义应用程序主对话框的行为。该对话框的模板位于 HeavenShadow.rc 中，该文件可以在 Microsoft Visual C++ 中进行编辑。


/////////////////////////////////////////////////////////////////////////////

其他功能:

ActiveX 控件
应用程序包括对使用 ActiveX 控件的支持。

/////////////////////////////////////////////////////////////////////////////

其他标准文件:

StdAfx.h，StdAfx.cpp
这些文件用于生成名为 HeavenShadow.pch 的预编译头 (PCH) 文件和名为 StdAfx.obj 的预编译类型文件。

Resource.h
这是标准头文件，它定义新的资源 ID。
Microsoft Visual C++ 读取并更新此文件。

HeavenShadow.manifest
	应用程序清单文件供 Windows XP 用来描述应用程序
	对特定版本并行程序集的依赖性。加载程序使用此
	信息从程序集缓存加载适当的程序集或
	从应用程序加载私有信息。应用程序清单可能为了重新分发而作为
	与应用程序可执行文件安装在相同文件夹中的外部 .manifest 文件包括，
	也可能以资源的形式包括在该可执行文件中。 
/////////////////////////////////////////////////////////////////////////////

其他注释:

应用程序向导使用“TODO:”指示应添加或自定义的源代码部分。

如果应用程序在共享的 DLL 中使用 MFC，则需要重新发布这些 MFC DLL；如果应用程序所用的语言与操作系统的当前区域设置不同，则还需要重新发布对应的本地化资源 MFC100XXX.DLL。有关这两个主题的更多信息，请参见 MSDN 文档中有关 Redistributing Visual C++ applications (重新发布 Visual C++ 应用程序)的章节。

/////////////////////////////////////////////////////////////////////////////

```

`arkProject/HeavenShadow/HeavenShadow/SSDTFunc.cpp`:

```cpp
#include "stdafx.h"
#include "SSDTFunc.h"
#include "ModuleFunc.h"
#include "Common.h"
#include <vector>
#include <Strsafe.h>

using namespace std;

extern vector<DRIVER_INFO> m_DriverList;
extern HANDLE g_hDevice;
extern WIN_VERSION WinVersion;
extern BOOL bIsChecking;

COLUMNSTRUCT g_Column_SSDT[] = 
{
	{	L"序号",					50	},
	{	L"函数名称",				145	},
	{	L"函数当前地址",			125	},
	{	L"函数原地址",			125	},
	{	L"模块文件",				195	},
	{	L"状态",					85	}
};

UINT g_Column_SSDT_Count  = 6;	  //进程列表列数

ULONG_PTR m_KiServiceTable = 0;
ULONG_PTR m_SSDTFuncCount = 0;
ULONG_PTR m_HookFuncCount = 0;
CHAR  m_szNtosName[512];
CHAR  m_szTempNtosName[512];
ULONG_PTR m_NtosImageBase;
ULONG_PTR m_NtosBase;
ULONG_PTR m_TempNtosBase;
BOOL  m_bSSDTOk = FALSE;

extern int dpix;
extern int dpiy;


VOID HsInitSSDTList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_SSDT_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_SSDT[i].szTitle,LVCFMT_LEFT,(int)(g_Column_SSDT[i].nWidth*(dpix/96.0)));
	}

}

VOID HsLoadSSDTList(CListCtrl *m_ListCtrl)
{
// 	if (bIsChecking == TRUE)
// 	{
// 		return;
// 	}

// 	while(bIsChecking == TRUE)
// 	{
// 		Sleep(10);
// 	}


	HsSendStatusDetail(L"SSDT正在加载...");
	HsSendStatusTip(L"SSDT");

	HsQuerySSDTList(m_ListCtrl);

	
	bIsChecking = FALSE;
}


VOID HsQuerySSDTList(CListCtrl *m_ListCtrl)
{


	SSDT_INFO si[0x1000] = {0};

	m_KiServiceTable = 0;
	m_HookFuncCount = 0;
	m_SSDTFuncCount = 0;

	m_DriverList.clear();

	BOOL bRet = FALSE;

	InitDataOfSSDT();

	bRet = EnumSSDT(si);

	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"SSDT加载失败。");
		return;
	}

	bRet = EnumDriver();

	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"SSDT加载失败。");
		return;
	}

	CString strIndex;

	int i = 0;
	int j = 0;
	for (i=0;i<m_SSDTFuncCount;i++)
	{

		strIndex.Format(L"%d",si[i].Id);
		int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strIndex);

		CString strFuncName(si[i].szFuncName);
		m_ListCtrl->SetItemText(n,1,strFuncName);

		CString strCurAddr;
		strCurAddr.Format(L"0x%p",si[i].CurAddr);
		m_ListCtrl->SetItemText(n,2,strCurAddr);

		CString strOrigAddr;
		strOrigAddr.Format(L"0x%p",si[i].OriAddr);
		m_ListCtrl->SetItemText(n,3,strOrigAddr);


		CString strType;
		if (si[i].OriAddr!=si[i].CurAddr)
		{
			m_ListCtrl->SetItemData(n,1);

			strType = L"SSDTHook";
		}
		else
		{
			strType = L"正常";
		}


		m_ListCtrl->SetItemText(n,5,strType);

		CString strPath;

		strPath = GetDriverPath(si[i].CurAddr);
		m_ListCtrl->SetItemText(n,4,strPath);

		if (_wcsnicmp(L"正常",strType,wcslen(L"正常"))!=0)
		{
			j+=1;
		}

		CString StatusBarContext;
		StatusBarContext.Format(L"SSDT正在加载。 SSDT函数：%d，挂钩函数：%d",i+1,j);

		HsSendStatusDetail(StatusBarContext);
	}

	CString StatusBarContext;
	StatusBarContext.Format(L"SSDT加载完成。 SSDT函数：%d，挂钩函数：%d",m_SSDTFuncCount,m_HookFuncCount);

	HsSendStatusDetail(StatusBarContext);
}

CString GetDriverPath(ULONG_PTR Address)
{
	CString strPath;

	for (vector<DRIVER_INFO>::iterator itor = m_DriverList.begin(); 
		itor != m_DriverList.end(); 
		itor++)
	{
		ULONG_PTR ulBase = itor->Base;
		ULONG_PTR ulEnd = itor->Base + itor->Size;

		if (Address >= ulBase && Address <= ulEnd)
		{
			strPath = itor->wzDriverPath;
			break;
		}
	}

	return strPath;
}


BOOL EnumSSDT(SSDT_INFO* si)
{
	DWORD i=0,SSDTFuncCount = 0;


	CHAR* szTempNtdll = NULL;
	DWORD dwLen = 0;
	DWORD dwStart = 0;
	DWORD dwEnd = 0;
	ULONG_PTR SSDTOriAddr = 0;
	ULONG_PTR SSDTCurAddr = 0;
	szTempNtdll=HsGetTempNtdll();

	if(!CopyFileA(Strcat(HsGetSystemDir(),"ntdll.dll"),szTempNtdll,0))
	{
		return FALSE;
	}

	dwLen = FileLen(szTempNtdll);

	char szFuncStart[]="ZwAcceptConnectPort", szFuncEnd[]="ZwYieldExecution"; //每个函数名之间隔着\0

	char* szNtdll = HsLoadDllContext(szTempNtdll);
	char* szTemp  = szNtdll;
	for(i=0; i<dwLen; i++)
	{
		if(memcmp(szTemp+i,szFuncStart,strlen(szFuncStart))==0)
		{
			dwStart = i;
		}
		if(memcmp(szTemp+i,szFuncEnd,strlen(szFuncEnd))==0)
		{
			dwEnd = i;
			break;
		}
	}
	szTemp =szTemp+dwStart;
	//这里不能显示到最后一个函数
	while(strcmp(szTemp,szFuncEnd)!=0)
	{
		DWORD dwFuncIndex = HsGetSSDTFunctionIndex(szTemp);
		if(dwFuncIndex<0x1000)
		{
			SSDTOriAddr = HsGetFunctionOriginalAddress(dwFuncIndex);

			SendIoCodeSSDT(dwFuncIndex,&SSDTCurAddr);


			if (SSDTCurAddr!=SSDTOriAddr)
			{
				m_HookFuncCount++;
			}

			szTemp[0]='N';
			szTemp[1]='t';		//寻找的是Zw***，但是应该显示Nt***
		}
		else
		{

			dwFuncIndex = HsGetSpecialIndex(szTemp);
			SSDTOriAddr=HsGetFunctionOriginalAddress(dwFuncIndex);
			SendIoCodeSSDT(dwFuncIndex,&SSDTCurAddr);

			if (SSDTCurAddr!=SSDTOriAddr)
			{
				m_HookFuncCount++;
			}
			szTemp[0]='N';
			szTemp[1]='t';
		}
		si[SSDTFuncCount].Id = dwFuncIndex;
		si[SSDTFuncCount].CurAddr = SSDTCurAddr;
		si[SSDTFuncCount].OriAddr = SSDTOriAddr;
		strcpy_s(si[SSDTFuncCount].szFuncName,szTemp);
		szTemp=szTemp+strlen(szTemp)+1;
		SSDTFuncCount++;
		dwFuncIndex=0;
	}
	//显示完最后一个函数
	DWORD dwFuncIndex = HsGetSSDTFunctionIndex(szTemp);
	SSDTOriAddr = HsGetFunctionOriginalAddress(dwFuncIndex);
	SendIoCodeSSDT(dwFuncIndex,&SSDTCurAddr);

	if (SSDTCurAddr!=SSDTOriAddr)
	{
		m_HookFuncCount++;
	}
	szTemp[0]='N';
	szTemp[1]='t';
	si[SSDTFuncCount].Id = dwFuncIndex;
	si[SSDTFuncCount].CurAddr = SSDTCurAddr;
	si[SSDTFuncCount].OriAddr = SSDTOriAddr;
	strcpy_s(si[SSDTFuncCount].szFuncName,szTemp);
	SSDTFuncCount++;

	m_SSDTFuncCount = SSDTFuncCount;
	DeleteFileA(szTempNtdll);
	DeleteFileA(m_szTempNtosName);
	free(szNtdll);

	return TRUE;
}


BOOL SendIoCodeSSDT(DWORD dwFuncIndex,PULONG_PTR SSDTCurAddr)
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	//发送IO 控制码
	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_SSDTLIST),
		&dwFuncIndex,
		sizeof(DWORD),
		SSDTCurAddr,
		sizeof(ULONG_PTR),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{
		return FALSE;
	}

	return TRUE;
}




ULONG_PTR HsGetFunctionOriginalAddress(ULONG_PTR dwIndex)	//通过INDEX获得函数原始地址
{
	ULONG_PTR RVA = m_KiServiceTable - m_NtosBase;
	ULONG_PTR Temp=*(PULONG_PTR)(m_TempNtosBase+RVA+sizeof(ULONG_PTR)*(ULONG_PTR)dwIndex);
	return Temp;
}


BOOL InitDataOfSSDT()
{
	BOOL b1=FALSE,b2=FALSE;
	BOOL bOk = FALSE;
	b1 = GetNtosNameAndBase();
	b2 = GetNtosImageBase();

	m_TempNtosBase = (ULONG_PTR)LoadLibraryExA(m_szTempNtosName,0, DONT_RESOLVE_DLL_REFERENCES);

	if (m_bSSDTOk==FALSE)
	{
		HsReloc((ULONG_PTR)m_TempNtosBase,m_NtosBase);
		m_bSSDTOk = TRUE;
	}

	if (GetKiServiceTable()==FALSE)
	{
		return FALSE;
	}

	if(b1 && b2)
	{
		bOk = TRUE;
	}	
	else
	{
		bOk = FALSE;
	}

	return bOk;
}



BOOL GetNtosImageBase()
{
	PIMAGE_NT_HEADERS NtHeader;
	PIMAGE_DOS_HEADER DosHeader;
	char* szNtosFileData=NULL;
	szNtosFileData = HsLoadDllContext(m_szTempNtosName);
	if(szNtosFileData==NULL)
	{
		return FALSE;
	}
	DosHeader = (PIMAGE_DOS_HEADER)szNtosFileData;
	NtHeader  = (PIMAGE_NT_HEADERS)(szNtosFileData+DosHeader->e_lfanew);
	m_NtosImageBase = NtHeader->OptionalHeader.ImageBase;
	return TRUE;
}

BOOL GetNtosNameAndBase()    //获得Ntos的路径和加载地址
{
	char szFileName[260]= {0},*szFullName;
	m_NtosBase = HsGetKernelBase(szFileName);
	szFullName = Strcat(HsGetSystemDir(),szFileName);
	strcpy_s(m_szNtosName,szFullName);
	return GetTempNtosName();
}



BOOL GetTempNtosName()   //根据Ntos的路径 进行拷贝构建ntosxxxx.exe
{
	char *szPath;
	szPath=(char *)malloc(260);
	memset(szPath,0,260);
	GetTempPathA(260,szPath);
	szPath = Strcat(szPath,"ntosxxxx.exe");
	strcpy_s(m_szTempNtosName,szPath);

	if(CopyFileA(m_szNtosName,m_szTempNtosName,0))
	{
		free(szPath);
		return TRUE;
	}
	else
	{
		free(szPath);
		return FALSE;
	}
}




BOOL GetKiServiceTable()
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	if (g_hDevice==NULL)
	{
		return FALSE;
	}

	dwRet = DeviceIoControl(
		g_hDevice,
		HS_IOCTL(HS_IOCTL_KRNL_KISRVTAB),
		NULL,
		0,
		&m_KiServiceTable,
		sizeof(ULONG_PTR),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{
		return FALSE;
	}

	return TRUE;
}





BOOL EnumDriver()
{
	ULONG ulReturnSize = 0;
	BOOL bRet = FALSE;

	m_DriverList.clear();

	ULONG ulCount = 1000;
	PALL_DRIVERS Drivers = NULL;

	if (g_hDevice==NULL)
	{
		MessageBox(NULL,L"设备获取失败",L"Error",0);
		return FALSE;
	}

	do 
	{
		ULONG ulSize = 0;

		if (Drivers)
		{
			free(Drivers);
			Drivers = NULL;
		}

		ulSize = sizeof(ALL_DRIVERS) + ulCount * sizeof(DRIVER_INFO);

		Drivers = (PALL_DRIVERS)malloc(ulSize);
		if (!Drivers)
		{
			break;
		}

		memset(Drivers,0,ulSize);


		bRet = DeviceIoControl(
			g_hDevice,
			HS_IOCTL(HS_IOCTL_MODU_MODULELIST),
			NULL,
			0,
			Drivers,
			ulSize,
			&ulReturnSize,
			NULL);

		ulCount = (ULONG)Drivers->ulCount + 100;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && Drivers->ulCount > 0)
	{
		for (ULONG i = 0;i<Drivers->ulCount; i++)
		{
			FixDriverPath(&Drivers->Drivers[i]);
			m_DriverList.push_back(Drivers->Drivers[i]);
		}
	}

	if (Drivers)
	{
		free(Drivers);
		Drivers = NULL;
	}

	return bRet;
}


void HsResumeSSDTHook(CListCtrl* m_ListCtrl)
{

	int Index = m_ListCtrl->GetSelectionMark();

	if (Index<0)
	{
		return;
	}

	CString Temp = m_ListCtrl->GetItemText(Index,0);

	RESUME_DATA  Data = {0};  

	swscanf_s(Temp.GetBuffer(),L"%d",&Data.ulIndex);

	Temp  = m_ListCtrl->GetItemText(Index,3);
	swscanf_s(Temp.GetBuffer()+2,L"%p",&Data.ulFuncAddress);

	BOOL dwRet = FALSE;

	if (g_hDevice==NULL)
	{
		return;
	}

	DWORD dwReturnSize = 0;


	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_RESUMESSDT),
		&Data,
		sizeof(Data),
		NULL,
		0,
		&dwReturnSize,
		NULL);

	if (dwRet==0)
	{
		return;
	}

	m_ListCtrl->SetItemText(Index,5,L"正常");
	m_ListCtrl->SetItemData(Index,0);

}
```

`arkProject/HeavenShadow/HeavenShadow/SSDTFunc.h`:

```h
#pragma once
#include "stdafx.h"

typedef struct _SSDT_INFO
{
	ULONG_PTR	Id;
	ULONG_PTR	CurAddr;
	ULONG_PTR	OriAddr;
	CHAR	    szFuncName[80];
}SSDT_INFO, *PSSDT_INFO;

typedef struct _RESUME_DATA_ 
{
	ULONG ulIndex;
	ULONG_PTR ulFuncAddress;
}RESUME_DATA,*PRESUME_DATA;

VOID HsInitSSDTList(CListCtrl *m_ListCtrl);

VOID HsLoadSSDTList(CListCtrl *m_ListCtrl);

VOID HsQuerySSDTList(CListCtrl *m_ListCtrl);

BOOL GetNtosImageBase();

BOOL GetNtosNameAndBase();

BOOL GetTempNtosName();

BOOL GetKiServiceTable();


BOOL InitDataOfSSDT();

BOOL EnumSSDT(SSDT_INFO* si);

ULONG_PTR HsGetFunctionOriginalAddress(ULONG_PTR dwIndex);

BOOL SendIoCodeSSDT(DWORD dwFuncIndex,PULONG_PTR SSDTCurAddr);

BOOL EnumDriver();

CString GetDriverPath(ULONG_PTR Address);

void HsResumeSSDTHook(CListCtrl* m_ListCtrl);
```

`arkProject/HeavenShadow/HeavenShadow/SSSDTFunc.cpp`:

```cpp
#include "stdafx.h"
#include "SSDTFunc.h"
#include "SSSDTFunc.h"
#include "ModuleFunc.h"
#include "Common.h"
#include <vector>
#include <Strsafe.h>

using namespace std;

extern vector<DRIVER_INFO> m_DriverList;
extern HANDLE g_hDevice;
extern WIN_VERSION WinVersion;
extern BOOL bIsChecking;
extern CHAR XPProcName[667][100];
extern CHAR WIN7ProcName[827][100];

char* m_szTempWin32k;
ULONG_PTR m_Win32kServiceTable = 0;
ULONG_PTR m_Win32kBase = 0;
ULONG_PTR m_Win32kImageBase = 0;
ULONG_PTR m_TempWin32kBase = 0;
BOOL      m_bSSSDTOk = FALSE;

COLUMNSTRUCT g_Column_SSSDT[] = 
{
	{	L"序号",					50	},
	{	L"函数名称",				145	},
	{	L"函数当前地址",			125	},
	{	L"函数原地址",			125	},
	{	L"模块文件",				195	},
	{	L"状态",					85	}
};


UINT g_Column_SSSDT_Count  = 6;	  //进程列表列数

extern int dpix;
extern int dpiy;


VOID HsInitSSSDTList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_SSSDT_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_SSSDT[i].szTitle,LVCFMT_LEFT,(int)(g_Column_SSSDT[i].nWidth*(dpix/96.0)));
	}

}

VOID HsLoadSSSDTList(CListCtrl *m_ListCtrl)
{
// 	if (bIsChecking == TRUE)
// 	{
// 		return;
// 	}

// 	while(bIsChecking == TRUE)
// 	{
// 		Sleep(10);
// 	}


	HsSendStatusDetail(L"ShadowSSDT正在加载...");
	HsSendStatusTip(L"ShadowSSDT");

	HsQuerySSSDTList(m_ListCtrl);

	
	bIsChecking = FALSE;
}


VOID HsQuerySSSDTList(CListCtrl *m_ListCtrl)
{
	SSSDT_INFO si[0x1000];

	if(EnumDriver()==FALSE)
	{
		return;
	}

	EnumSSSDT(si,m_ListCtrl);
}




BOOL EnumSSSDT(SSSDT_INFO* si, CListCtrl* m_ListCtrl)
{

	m_ListCtrl->DeleteAllItems();
	ULONG_PTR SSSDTFuncCount = 0;
	ULONG_PTR HookFuncCount = 0;


	ULONG_PTR SSSDTOriAddr = 0;
	ULONG_PTR SSSDTCurAddr = 0;

	switch(WinVersion)
	{
	case Windows7:
		{

			int i = 0;
			int j = 0;
			for (i=0;i<sizeof(WIN7ProcName)/100;i++)
			{


				SendIoCodeSSSDT(i,&SSSDTCurAddr);
				SSSDTOriAddr = GetOriSSSDTAddress(i);


				si[SSSDTFuncCount].Id = i;
				si[SSSDTFuncCount].CurAddr = SSSDTCurAddr;
				si[SSSDTFuncCount].OriAddr = SSSDTOriAddr;
				strcpy_s(si[SSSDTFuncCount].szFuncName,WIN7ProcName[i]);


				if (SSSDTCurAddr!=SSSDTOriAddr)
				{
					HookFuncCount++;
				}

				SSSDTFuncCount++;
			}

			CString strIndex;
			for (i=0;i<SSSDTFuncCount;i++)
			{

				strIndex.Format(L"%d",si[i].Id);
				int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strIndex);

				CString strFuncName(si[i].szFuncName);
				m_ListCtrl->SetItemText(n,1,strFuncName);

				CString strCurAddr;
				strCurAddr.Format(L"0x%p",si[i].CurAddr);
				m_ListCtrl->SetItemText(n,2,strCurAddr);

				CString strOrigAddr;
				strOrigAddr.Format(L"0x%p",si[i].OriAddr);
				m_ListCtrl->SetItemText(n,3,strOrigAddr);


				CString strPath;

				strPath = GetDriverPath(si[i].CurAddr);
				m_ListCtrl->SetItemText(n,4,strPath);

				CString strType;
				if (si[i].OriAddr!=si[i].CurAddr)
				{
					m_ListCtrl->SetItemData(n,1);

					strType = L"SSSDTHook";
				}
				else
				{
					strType = L"正常";
				}


				m_ListCtrl->SetItemText(n,5,strType);

				if (_wcsnicmp(L"正常",strType,wcslen(L"正常"))!=0)
				{
					j+=1;
				}

				CString StatusBarContext;
				StatusBarContext.Format(L"ShadowSSDT正在加载。 ShadowSSDT函数：%d，挂钩函数：%d",i+1,j);

				HsSendStatusDetail(StatusBarContext);



			}

			CString StatusBarContext;
			StatusBarContext.Format(L"ShadowSSDT加载完成。 ShadowSSDT函数：%d，挂钩函数：%d",SSSDTFuncCount,HookFuncCount);

			HsSendStatusDetail(StatusBarContext);

			break;
		}

	case WindowsXP:
		{

			int i = 0;
			int j = 0;
			for (i=0;i<sizeof(XPProcName)/100;i++)
			{


				SendIoCodeSSSDT(i,&SSSDTCurAddr);
				SSSDTOriAddr = GetOriSSSDTAddress(i);


				si[SSSDTFuncCount].Id = i;
				si[SSSDTFuncCount].CurAddr = SSSDTCurAddr;
				si[SSSDTFuncCount].OriAddr = SSSDTOriAddr;
				strcpy_s(si[SSSDTFuncCount].szFuncName,XPProcName[i]);


				if (SSSDTCurAddr!=SSSDTOriAddr)
				{
					HookFuncCount++;
				}

				SSSDTFuncCount++;

			}

			CString strIndex;
			for (i=0;i<SSSDTFuncCount;i++)
			{

				strIndex.Format(L"%d",si[i].Id);
				int n = m_ListCtrl->InsertItem(m_ListCtrl->GetItemCount(),strIndex);

				CString strFuncName(si[i].szFuncName);
				m_ListCtrl->SetItemText(n,1,strFuncName);

				CString strCurAddr;
				strCurAddr.Format(L"0x%p",si[i].CurAddr);
				m_ListCtrl->SetItemText(n,2,strCurAddr);

				CString strOrigAddr;
				strOrigAddr.Format(L"0x%p",si[i].OriAddr);
				m_ListCtrl->SetItemText(n,3,strOrigAddr);


				CString strPath;



				strPath = GetDriverPath(si[i].CurAddr);
				m_ListCtrl->SetItemText(n,4,strPath);


				CString strType;
				if (si[i].OriAddr!=si[i].CurAddr)
				{
					m_ListCtrl->SetItemData(n,1);

					strType = L"SSSDTHook";
				}
				else
				{
					strType = L"正常";
				}

				m_ListCtrl->SetItemText(n,5,strType);


				if (_wcsnicmp(L"正常",strType,wcslen(L"正常"))!=0)
				{
					j+=1;
				}

				CString StatusBarContext;
				StatusBarContext.Format(L"ShadowSSDT正在加载。 ShadowSSDT函数：%d，挂钩函数：%d",i+1,j);

				HsSendStatusDetail(StatusBarContext);

			}

			CString StatusBarContext;
			StatusBarContext.Format(L"ShadowSSDT加载完成。 ShadowSSDT函数：%d，挂钩函数：%d",SSSDTFuncCount,HookFuncCount);

			HsSendStatusDetail(StatusBarContext);

			break;
		}
	}

	return TRUE;
}



VOID SendIoCodeSSSDT(DWORD dwFuncIndex,PULONG_PTR SSSDTCurAddr)
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	//发送IO 控制码
	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_SSSDTLIST),
		&dwFuncIndex,
		sizeof(DWORD),
		SSSDTCurAddr,
		sizeof(ULONG_PTR),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{
		return;
	}

	return;
}


ULONG_PTR GetOriSSSDTAddress(ULONG_PTR Index)
{

	m_szTempWin32k = HsGetTempWin32k();

	if(m_Win32kServiceTable==0 )
	{
		SendIoCodeWin32kServiceTable();
	}

	if(m_Win32kBase==0 )
	{
		m_Win32kBase = HsGetWin32kBase();
	}
	if(m_Win32kImageBase==0)
	{
		if(!CopyFileA(Strcat(HsGetSystemDir(),"win32k.sys"),m_szTempWin32k,0))
		{
			return 0;
		}
		m_Win32kImageBase = HsGetWin32kImageBase(m_szTempWin32k);
	}
	if( m_TempWin32kBase==0 )
	{
		m_TempWin32kBase = (ULONG_PTR)LoadLibraryExA(m_szTempWin32k,0, DONT_RESOLVE_DLL_REFERENCES);
	}


	if (m_bSSSDTOk==FALSE)
	{
		if(!HsReloc(m_TempWin32kBase,m_Win32kBase))
		{
			return 0;
		}

		m_bSSSDTOk = TRUE;
	}

	ULONG_PTR RVA = m_Win32kServiceTable - m_Win32kBase;
	ULONG_PTR Address = *(ULONG_PTR*)(m_TempWin32kBase+RVA+sizeof(ULONG_PTR)*Index);



	return Address;
}



VOID SendIoCodeWin32kServiceTable()
{
	DWORD dwReturnSize = 0;
	DWORD dwRet = 0;

	//发送IO 控制码
	dwRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_KRNL_WIN32KSERVICE),   //
		NULL,
		0,
		&m_Win32kServiceTable,
		sizeof(ULONG_PTR),
		&dwReturnSize,
		NULL);


	if (dwRet==0)
	{
		return;
	}

	return;
}


//////////////////////////////////////////////////////////////////////////



```

`arkProject/HeavenShadow/HeavenShadow/SSSDTFunc.h`:

```h
#pragma once
#include "stdafx.h"

typedef struct _SSSDT_INFO
{
	ULONG_PTR	Id;
	ULONG_PTR	CurAddr;
	ULONG_PTR	OriAddr;
	CHAR	    szFuncName[100];
}SSSDT_INFO, *PSSSDT_INFO;


VOID HsInitSSSDTList(CListCtrl *m_ListCtrl);

VOID HsLoadSSSDTList(CListCtrl *m_ListCtrl);

VOID HsQuerySSSDTList(CListCtrl *m_ListCtrl);

BOOL EnumSSSDT(SSSDT_INFO* si, CListCtrl* m_ListCtrl);

VOID SendIoCodeSSSDT(DWORD dwFuncIndex,PULONG_PTR SSSDTCurAddr);

ULONG_PTR GetOriSSSDTAddress(ULONG_PTR Index);

VOID SendIoCodeWin32kServiceTable();





```

`arkProject/HeavenShadow/HeavenShadow/SSSDTName.cpp`:

```cpp
#include "stdafx.h"



CHAR XPProcName[667][100]=
{
	"NtGdiAbortDoc"
	,"NtGdiAbortPath"
	,"NtGdiAddFontResourceW"
	,"NtGdiAddRemoteFontToDC"
	,"NtGdiAddFontMemResourceEx"
	,"NtGdiRemoveMergeFont"
	,"NtGdiAddRemoteMMInstanceToDC"
	,"NtGdiAlphaBlend"
	,"NtGdiAngleArc"
	,"NtGdiAnyLinkedFonts"
	,"NtGdiFontIsLinked"
	,"NtGdiArcInternal"
	,"NtGdiBeginPath"
	,"NtGdiBitBlt"
	,"NtGdiCancelDC"
	,"NtGdiCheckBitmapBits"
	,"NtGdiCloseFigure"
	,"NtGdiClearBitmapAttributes"
	,"NtGdiClearBrushAttributes"
	,"NtGdiColorCorrectPalette"
	,"NtGdiCombineRgn"
	,"NtGdiCombineTransform"
	,"NtGdiComputeXformCoefficients"
	,"NtGdiConsoleTextOut"
	,"NtGdiConvertMetafileRect"
	,"NtGdiCreateBitmap"
	,"NtGdiCreateClientObj"
	,"NtGdiCreateColorSpace"
	,"NtGdiCreateColorTransform"
	,"NtGdiCreateCompatibleBitmap"
	,"NtGdiCreateCompatibleDC"
	,"NtGdiCreateDIBBrush"
	,"NtGdiCreateDIBitmapInternal"
	,"NtGdiCreateDIBSection"
	,"NtGdiCreateEllipticRgn"
	,"NtGdiCreateHalftonePalette"
	,"NtGdiCreateHatchBrushInternal"
	,"NtGdiCreateMetafileDC"
	,"NtGdiCreatePaletteInternal"
	,"NtGdiCreatePatternBrushInternal"
	,"NtGdiCreatePen"
	,"NtGdiCreateRectRgn"
	,"NtGdiCreateRoundRectRgn"
	,"NtGdiCreateServerMetaFile"
	,"NtGdiCreateSolidBrush"
	,"NtGdiD3dContextCreate"
	,"NtGdiD3dContextDestroy"
	,"NtGdiD3dContextDestroyAll"
	,"NtGdiD3dValidateTextureStageState"
	,"NtGdiD3dDrawPrimitives2"
	,"NtGdiDdGetDriverState"
	,"NtGdiDdAddAttachedSurface"
	,"NtGdiDdAlphaBlt"
	,"NtGdiDdAttachSurface"
	,"NtGdiDdBeginMoCompFrame"
	,"NtGdiDdBlt"
	,"NtGdiDdCanCreateSurface"
	,"NtGdiDdCanCreateD3DBuffer"
	,"NtGdiDdColorControl"
	,"NtGdiDdCreateDirectDrawObject"
	,"NtGdiDdCreateSurface"
	,"NtGdiDdCreateD3DBuffer"
	,"NtGdiDdCreateMoComp"
	,"NtGdiDdCreateSurfaceObject"
	,"NtGdiDdDeleteDirectDrawObject"
	,"NtGdiDdDeleteSurfaceObject"
	,"NtGdiDdDestroyMoComp"
	,"NtGdiDdDestroySurface"
	,"NtGdiDdDestroyD3DBuffer"
	,"NtGdiDdEndMoCompFrame"
	,"NtGdiDdFlip"
	,"NtGdiDdFlipToGDISurface"
	,"NtGdiDdGetAvailDriverMemory"
	,"NtGdiDdGetBltStatus"
	,"NtGdiDdGetDC"
	,"NtGdiDdGetDriverInfo"
	,"NtGdiDdGetDxHandle"
	,"NtGdiDdGetFlipStatus"
	,"NtGdiDdGetInternalMoCompInfo"
	,"NtGdiDdGetMoCompBuffInfo"
	,"NtGdiDdGetMoCompGuids"
	,"NtGdiDdGetMoCompFormats"
	,"NtGdiDdGetScanLine"
	,"NtGdiDdLock"
	,"NtGdiDdLockD3D"
	,"NtGdiDdQueryDirectDrawObject"
	,"NtGdiDdQueryMoCompStatus"
	,"NtGdiDdReenableDirectDrawObject"
	,"NtGdiDdReleaseDC"
	,"NtGdiDdRenderMoComp"
	,"NtGdiDdResetVisrgn"
	,"NtGdiDdSetColorKey"
	,"NtGdiDdSetExclusiveMode"
	,"NtGdiDdSetGammaRamp"
	,"NtGdiDdCreateSurfaceEx"
	,"NtGdiDdSetOverlayPosition"
	,"NtGdiDdUnattachSurface"
	,"NtGdiDdUnlock"
	,"NtGdiDdUnlockD3D"
	,"NtGdiDdUpdateOverlay"
	,"NtGdiDdWaitForVerticalBlank"
	,"NtGdiDvpCanCreateVideoPort"
	,"NtGdiDvpColorControl"
	,"NtGdiDvpCreateVideoPort"
	,"NtGdiDvpDestroyVideoPort"
	,"NtGdiDvpFlipVideoPort"
	,"NtGdiDvpGetVideoPortBandwidth"
	,"NtGdiDvpGetVideoPortField"
	,"NtGdiDvpGetVideoPortFlipStatus"
	,"NtGdiDvpGetVideoPortInputFormats"
	,"NtGdiDvpGetVideoPortLine"
	,"NtGdiDvpGetVideoPortOutputFormats"
	,"NtGdiDvpGetVideoPortConnectInfo"
	,"NtGdiDvpGetVideoSignalStatus"
	,"NtGdiDvpUpdateVideoPort"
	,"NtGdiDvpWaitForVideoPortSync"
	,"NtGdiDvpAcquireNotification"
	,"NtGdiDvpReleaseNotification"
	,"NtGdiDxgGenericThunk"
	,"NtGdiDeleteClientObj"
	,"NtGdiDeleteColorSpace"
	,"NtGdiDeleteColorTransform"
	,"NtGdiDeleteObjectApp"
	,"NtGdiDescribePixelFormat"
	,"NtGdiGetPerBandInfo"
	,"NtGdiDoBanding"
	,"NtGdiDoPalette"
	,"NtGdiDrawEscape"
	,"NtGdiEllipse"
	,"NtGdiEnableEudc"
	,"NtGdiEndDoc"
	,"NtGdiEndPage"
	,"NtGdiEndPath"
	,"NtGdiEnumFontChunk"
	,"NtGdiEnumFontClose"
	,"NtGdiEnumFontOpen"
	,"NtGdiEnumObjects"
	,"NtGdiEqualRgn"
	,"NtGdiEudcLoadUnloadLink"
	,"NtGdiExcludeClipRect"
	,"NtGdiExtCreatePen"
	,"NtGdiExtCreateRegion"
	,"NtGdiExtEscape"
	,"NtGdiExtFloodFill"
	,"NtGdiExtGetObjectW"
	,"NtGdiExtSelectClipRgn"
	,"NtGdiExtTextOutW"
	,"NtGdiFillPath"
	,"NtGdiFillRgn"
	,"NtGdiFlattenPath"
	,"NtGdiFlushUserBatch"
	,"NtGdiFlush"
	,"NtGdiForceUFIMapping"
	,"NtGdiFrameRgn"
	,"NtGdiFullscreenControl"
	,"NtGdiGetAndSetDCDword"
	,"NtGdiGetAppClipBox"
	,"NtGdiGetBitmapBits"
	,"NtGdiGetBitmapDimension"
	,"NtGdiGetBoundsRect"
	,"NtGdiGetCharABCWidthsW"
	,"NtGdiGetCharacterPlacementW"
	,"NtGdiGetCharSet"
	,"NtGdiGetCharWidthW"
	,"NtGdiGetCharWidthInfo"
	,"NtGdiGetColorAdjustment"
	,"NtGdiGetColorSpaceforBitmap"
	,"NtGdiGetDCDword"
	,"NtGdiGetDCforBitmap"
	,"NtGdiGetDCObject"
	,"NtGdiGetDCPoint"
	,"NtGdiGetDeviceCaps"
	,"NtGdiGetDeviceGammaRamp"
	,"NtGdiGetDeviceCapsAll"
	,"NtGdiGetDIBitsInternal"
	,"NtGdiGetETM"
	,"NtGdiGetEudcTimeStampEx"
	,"NtGdiGetFontData"
	,"NtGdiGetFontResourceInfoInternalW"
	,"NtGdiGetGlyphIndicesW"
	,"NtGdiGetGlyphIndicesWInternal"
	,"NtGdiGetGlyphOutline"
	,"NtGdiGetKerningPairs"
	,"NtGdiGetLinkedUFIs"
	,"NtGdiGetMiterLimit"
	,"NtGdiGetMonitorID"
	,"NtGdiGetNearestColor"
	,"NtGdiGetNearestPaletteIndex"
	,"NtGdiGetObjectBitmapHandle"
	,"NtGdiGetOutlineTextMetricsInternalW"
	,"NtGdiGetPath"
	,"NtGdiGetPixel"
	,"NtGdiGetRandomRgn"
	,"NtGdiGetRasterizerCaps"
	,"NtGdiGetRealizationInfo"
	,"NtGdiGetRegionData"
	,"NtGdiGetRgnBox"
	,"NtGdiGetServerMetaFileBits"
	,"NtGdiGetSpoolMessage"
	,"NtGdiGetStats"
	,"NtGdiGetStockObject"
	,"NtGdiGetStringBitmapW"
	,"NtGdiGetSystemPaletteUse"
	,"NtGdiGetTextCharsetInfo"
	,"NtGdiGetTextExtent"
	,"NtGdiGetTextExtentExW"
	,"NtGdiGetTextFaceW"
	,"NtGdiGetTextMetricsW"
	,"NtGdiGetTransform"
	,"NtGdiGetUFI"
	,"NtGdiGetEmbUFI"
	,"NtGdiGetUFIPathname"
	,"NtGdiGetEmbedFonts"
	,"NtGdiChangeGhostFont"
	,"NtGdiAddEmbFontToDC"
	,"NtGdiGetFontUnicodeRanges"
	,"NtGdiGetWidthTable"
	,"NtGdiGradientFill"
	,"NtGdiHfontCreate"
	,"NtGdiIcmBrushInfo"
	,"NtGdiInit"
	,"NtGdiInitSpool"
	,"NtGdiIntersectClipRect"
	,"NtGdiInvertRgn"
	,"NtGdiLineTo"
	,"NtGdiMakeFontDir"
	,"NtGdiMakeInfoDC"
	,"NtGdiMaskBlt"
	,"NtGdiModifyWorldTransform"
	,"NtGdiMonoBitmap"
	,"NtGdiMoveTo"
	,"NtGdiOffsetClipRgn"
	,"NtGdiOffsetRgn"
	,"NtGdiOpenDCW"
	,"NtGdiPatBlt"
	,"NtGdiPolyPatBlt"
	,"NtGdiPathToRegion"
	,"NtGdiPlgBlt"
	,"NtGdiPolyDraw"
	,"NtGdiPolyPolyDraw"
	,"NtGdiPolyTextOutW"
	,"NtGdiPtInRegion"
	,"NtGdiPtVisible"
	,"NtGdiQueryFonts"
	,"NtGdiQueryFontAssocInfo"
	,"NtGdiRectangle"
	,"NtGdiRectInRegion"
	,"NtGdiRectVisible"
	,"NtGdiRemoveFontResourceW"
	,"NtGdiRemoveFontMemResourceEx"
	,"NtGdiResetDC"
	,"NtGdiResizePalette"
	,"NtGdiRestoreDC"
	,"NtGdiRoundRect"
	,"NtGdiSaveDC"
	,"NtGdiScaleViewportExtEx"
	,"NtGdiScaleWindowExtEx"
	,"NtGdiSelectBitmap"
	,"NtGdiSelectBrush"
	,"NtGdiSelectClipPath"
	,"NtGdiSelectFont"
	,"NtGdiSelectPen"
	,"NtGdiSetBitmapAttributes"
	,"NtGdiSetBitmapBits"
	,"NtGdiSetBitmapDimension"
	,"NtGdiSetBoundsRect"
	,"NtGdiSetBrushAttributes"
	,"NtGdiSetBrushOrg"
	,"NtGdiSetColorAdjustment"
	,"NtGdiSetColorSpace"
	,"NtGdiSetDeviceGammaRamp"
	,"NtGdiSetDIBitsToDeviceInternal"
	,"NtGdiSetFontEnumeration"
	,"NtGdiSetFontXform"
	,"NtGdiSetIcmMode"
	,"NtGdiSetLinkedUFIs"
	,"NtGdiSetMagicColors"
	,"NtGdiSetMetaRgn"
	,"NtGdiSetMiterLimit"
	,"NtGdiGetDeviceWidth"
	,"NtGdiMirrorWindowOrg"
	,"NtGdiSetLayout"
	,"NtGdiSetPixel"
	,"NtGdiSetPixelFormat"
	,"NtGdiSetRectRgn"
	,"NtGdiSetSystemPaletteUse"
	,"NtGdiSetTextJustification"
	,"NtGdiSetupPublicCFONT"
	,"NtGdiSetVirtualResolution"
	,"NtGdiSetSizeDevice"
	,"NtGdiStartDoc"
	,"NtGdiStartPage"
	,"NtGdiStretchBlt"
	,"NtGdiStretchDIBitsInternal"
	,"NtGdiStrokeAndFillPath"
	,"NtGdiStrokePath"
	,"NtGdiSwapBuffers"
	,"NtGdiTransformPoints"
	,"NtGdiTransparentBlt"
	,"NtGdiUnloadPrinterDriver"
	,"NtGdiUnmapMemFont"
	,"NtGdiUnrealizeObject"
	,"NtGdiUpdateColors"
	,"NtGdiWidenPath"
	,"NtUserActivateKeyboardLayout"
	,"NtUserAlterWindowStyle"
	,"NtUserAssociateInputContext"
	,"NtUserAttachThreadInput"
	,"NtUserBeginPaint"
	,"NtUserBitBltSysBmp"
	,"NtUserBlockInput"
	,"NtUserBuildHimcList"
	,"NtUserBuildHwndList"
	,"NtUserBuildNameList"
	,"NtUserBuildPropList"
	,"NtUserCallHwnd"
	,"NtUserCallHwndLock"
	,"NtUserCallHwndOpt"
	,"NtUserCallHwndParam"
	,"NtUserCallHwndParamLock"
	,"NtUserCallMsgFilter"
	,"NtUserCallNextHookEx"
	,"NtUserCallNoParam"
	,"NtUserCallOneParam"
	,"NtUserCallTwoParam"
	,"NtUserChangeClipboardChain"
	,"NtUserChangeDisplaySettings"
	,"NtUserCheckImeHotKey"
	,"NtUserCheckMenuItem"
	,"NtUserChildWindowFromPointEx"
	,"NtUserClipCursor"
	,"NtUserCloseClipboard"
	,"NtUserCloseDesktop"
	,"NtUserCloseWindowStation"
	,"NtUserConsoleControl"
	,"NtUserConvertMemHandle"
	,"NtUserCopyAcceleratorTable"
	,"NtUserCountClipboardFormats"
	,"NtUserCreateAcceleratorTable"
	,"NtUserCreateCaret"
	,"NtUserCreateDesktop"
	,"NtUserCreateInputContext"
	,"NtUserCreateLocalMemHandle"
	,"NtUserCreateWindowEx"
	,"NtUserCreateWindowStation"
	,"NtUserDdeGetQualityOfService"
	,"NtUserDdeInitialize"
	,"NtUserDdeSetQualityOfService"
	,"NtUserDeferWindowPos"
	,"NtUserDefSetText"
	,"NtUserDeleteMenu"
	,"NtUserDestroyAcceleratorTable"
	,"NtUserDestroyCursor"
	,"NtUserDestroyInputContext"
	,"NtUserDestroyMenu"
	,"NtUserDestroyWindow"
	,"NtUserDisableThreadIme"
	,"NtUserDispatchMessage"
	,"NtUserDragDetect"
	,"NtUserDragObject"
	,"NtUserDrawAnimatedRects"
	,"NtUserDrawCaption"
	,"NtUserDrawCaptionTemp"
	,"NtUserDrawIconEx"
	,"NtUserDrawMenuBarTemp"
	,"NtUserEmptyClipboard"
	,"NtUserEnableMenuItem"
	,"NtUserEnableScrollBar"
	,"NtUserEndDeferWindowPosEx"
	,"NtUserEndMenu"
	,"NtUserEndPaint"
	,"NtUserEnumDisplayDevices"
	,"NtUserEnumDisplayMonitors"
	,"NtUserEnumDisplaySettings"
	,"NtUserEvent"
	,"NtUserExcludeUpdateRgn"
	,"NtUserFillWindow"
	,"NtUserFindExistingCursorIcon"
	,"NtUserFindWindowEx"
	,"NtUserFlashWindowEx"
	,"NtUserGetAltTabInfo"
	,"NtUserGetAncestor"
	,"NtUserGetAppImeLevel"
	,"NtUserGetAsyncKeyState"
	,"NtUserGetAtomName"
	,"NtUserGetCaretBlinkTime"
	,"NtUserGetCaretPos"
	,"NtUserGetClassInfo"
	,"NtUserGetClassName"
	,"NtUserGetClipboardData"
	,"NtUserGetClipboardFormatName"
	,"NtUserGetClipboardOwner"
	,"NtUserGetClipboardSequenceNumber"
	,"NtUserGetClipboardViewer"
	,"NtUserGetClipCursor"
	,"NtUserGetComboBoxInfo"
	,"NtUserGetControlBrush"
	,"NtUserGetControlColor"
	,"NtUserGetCPD"
	,"NtUserGetCursorFrameInfo"
	,"NtUserGetCursorInfo"
	,"NtUserGetDC"
	,"NtUserGetDCEx"
	,"NtUserGetDoubleClickTime"
	,"NtUserGetForegroundWindow"
	,"NtUserGetGuiResources"
	,"NtUserGetGUIThreadInfo"
	,"NtUserGetIconInfo"
	,"NtUserGetIconSize"
	,"NtUserGetImeHotKey"
	,"NtUserGetImeInfoEx"
	,"NtUserGetInternalWindowPos"
	,"NtUserGetKeyboardLayoutList"
	,"NtUserGetKeyboardLayoutName"
	,"NtUserGetKeyboardState"
	,"NtUserGetKeyNameText"
	,"NtUserGetKeyState"
	,"NtUserGetListBoxInfo"
	,"NtUserGetMenuBarInfo"
	,"NtUserGetMenuIndex"
	,"NtUserGetMenuItemRect"
	,"NtUserGetMessage"
	,"NtUserGetMouseMovePointsEx"
	,"NtUserGetObjectInformation"
	,"NtUserGetOpenClipboardWindow"
	,"NtUserGetPriorityClipboardFormat"
	,"NtUserGetProcessWindowStation"
	,"NtUserGetRawInputBuffer"
	,"NtUserGetRawInputData"
	,"NtUserGetRawInputDeviceInfo"
	,"NtUserGetRawInputDeviceList"
	,"NtUserGetRegisteredRawInputDevices"
	,"NtUserGetScrollBarInfo"
	,"NtUserGetSystemMenu"
	,"NtUserGetThreadDesktop"
	,"NtUserGetThreadState"
	,"NtUserGetTitleBarInfo"
	,"NtUserGetUpdateRect"
	,"NtUserGetUpdateRgn"
	,"NtUserGetWindowDC"
	,"NtUserGetWindowPlacement"
	,"NtUserGetWOWClass"
	,"NtUserHardErrorControl"
	,"NtUserHideCaret"
	,"NtUserHiliteMenuItem"
	,"NtUserImpersonateDdeClientWindow"
	,"NtUserInitialize"
	,"NtUserInitializeClientPfnArrays"
	,"NtUserInitTask"
	,"NtUserInternalGetWindowText"
	,"NtUserInvalidateRect"
	,"NtUserInvalidateRgn"
	,"NtUserIsClipboardFormatAvailable"
	,"NtUserKillTimer"
	,"NtUserLoadKeyboardLayoutEx"
	,"NtUserLockWindowStation"
	,"NtUserLockWindowUpdate"
	,"NtUserLockWorkStation"
	,"NtUserMapVirtualKeyEx"
	,"NtUserMenuItemFromPoint"
	,"NtUserMessageCall"
	,"NtUserMinMaximize"
	,"NtUserMNDragLeave"
	,"NtUserMNDragOver"
	,"NtUserModifyUserStartupInfoFlags"
	,"NtUserMoveWindow"
	,"NtUserNotifyIMEStatus"
	,"NtUserNotifyProcessCreate"
	,"NtUserNotifyWinEvent"
	,"NtUserOpenClipboard"
	,"NtUserOpenDesktop"
	,"NtUserOpenInputDesktop"
	,"NtUserOpenWindowStation"
	,"NtUserPaintDesktop"
	,"NtUserPeekMessage"
	,"NtUserPostMessage"
	,"NtUserPostThreadMessage"
	,"NtUserPrintWindow"
	,"NtUserProcessConnect"
	,"NtUserQueryInformationThread"
	,"NtUserQueryInputContext"
	,"NtUserQuerySendMessage"
	,"NtUserQueryUserCounters"
	,"NtUserQueryWindow"
	,"NtUserRealChildWindowFromPoint"
	,"NtUserRealInternalGetMessage"
	,"NtUserRealWaitMessageEx"
	,"NtUserRedrawWindow"
	,"NtUserRegisterClassExWOW"
	,"NtUserRegisterUserApiHook"
	,"NtUserRegisterHotKey"
	,"NtUserRegisterRawInputDevices"
	,"NtUserRegisterTasklist"
	,"NtUserRegisterWindowMessage"
	,"NtUserRemoveMenu"
	,"NtUserRemoveProp"
	,"NtUserResolveDesktop"
	,"NtUserResolveDesktopForWOW"
	,"NtUserSBGetParms"
	,"NtUserScrollDC"
	,"NtUserScrollWindowEx"
	,"NtUserSelectPalette"
	,"NtUserSendInput"
	,"NtUserSetActiveWindow"
	,"NtUserSetAppImeLevel"
	,"NtUserSetCapture"
	,"NtUserSetClassLong"
	,"NtUserSetClassWord"
	,"NtUserSetClipboardData"
	,"NtUserSetClipboardViewer"
	,"NtUserSetConsoleReserveKeys"
	,"NtUserSetCursor"
	,"NtUserSetCursorContents"
	,"NtUserSetCursorIconData"
	,"NtUserSetDbgTag"
	,"NtUserSetFocus"
	,"NtUserSetImeHotKey"
	,"NtUserSetImeInfoEx"
	,"NtUserSetImeOwnerWindow"
	,"NtUserSetInformationProcess"
	,"NtUserSetInformationThread"
	,"NtUserSetInternalWindowPos"
	,"NtUserSetKeyboardState"
	,"NtUserSetLogonNotifyWindow"
	,"NtUserSetMenu"
	,"NtUserSetMenuContextHelpId"
	,"NtUserSetMenuDefaultItem"
	,"NtUserSetMenuFlagRtoL"
	,"NtUserSetObjectInformation"
	,"NtUserSetParent"
	,"NtUserSetProcessWindowStation"
	,"NtUserSetProp"
	,"NtUserSetRipFlags"
	,"NtUserSetScrollInfo"
	,"NtUserSetShellWindowEx"
	,"NtUserSetSysColors"
	,"NtUserSetSystemCursor"
	,"NtUserSetSystemMenu"
	,"NtUserSetSystemTimer"
	,"NtUserSetThreadDesktop"
	,"NtUserSetThreadLayoutHandles"
	,"NtUserSetThreadState"
	,"NtUserSetTimer"
	,"NtUserSetWindowFNID"
	,"NtUserSetWindowLong"
	,"NtUserSetWindowPlacement"
	,"NtUserSetWindowPos"
	,"NtUserSetWindowRgn"
	,"NtUserSetWindowsHookAW"
	,"NtUserSetWindowsHookEx"
	,"NtUserSetWindowStationUser"
	,"NtUserSetWindowWord"
	,"NtUserSetWinEventHook"
	,"NtUserShowCaret"
	,"NtUserShowScrollBar"
	,"NtUserShowWindow"
	,"NtUserShowWindowAsync"
	,"NtUserSoundSentry"
	,"NtUserSwitchDesktop"
	,"NtUserSystemParametersInfo"
	,"NtUserTestForInteractiveUser"
	,"NtUserThunkedMenuInfo"
	,"NtUserThunkedMenuItemInfo"
	,"NtUserToUnicodeEx"
	,"NtUserTrackMouseEvent"
	,"NtUserTrackPopupMenuEx"
	,"NtUserCalcMenuBar"
	,"NtUserPaintMenuBar"
	,"NtUserTranslateAccelerator"
	,"NtUserTranslateMessage"
	,"NtUserUnhookWindowsHookEx"
	,"NtUserUnhookWinEvent"
	,"NtUserUnloadKeyboardLayout"
	,"NtUserUnlockWindowStation"
	,"NtUserUnregisterClass"
	,"NtUserUnregisterUserApiHook"
	,"NtUserUnregisterHotKey"
	,"NtUserUpdateInputContext"
	,"NtUserUpdateInstance"
	,"NtUserUpdateLayeredWindow"
	,"NtUserGetLayeredWindowAttributes"
	,"NtUserSetLayeredWindowAttributes"
	,"NtUserUpdatePerUserSystemParameters"
	,"NtUserUserHandleGrantAccess"
	,"NtUserValidateHandleSecure"
	,"NtUserValidateRect"
	,"NtUserValidateTimerCallback"
	,"NtUserVkKeyScanEx"
	,"NtUserWaitForInputIdle"
	,"NtUserWaitForMsgAndEvent"
	,"NtUserWaitMessage"
	,"NtUserWin32PoolAllocationStats"
	,"NtUserWindowFromPoint"
	,"NtUserYieldTask"
	,"NtUserRemoteConnect"
	,"NtUserRemoteRedrawRectangle"
	,"NtUserRemoteRedrawScreen"
	,"NtUserRemoteStopScreenUpdates"
	,"NtUserCtxDisplayIOCtl"
	,"NtGdiEngAssociateSurface"
	,"NtGdiEngCreateBitmap"
	,"NtGdiEngCreateDeviceSurface"
	,"NtGdiEngCreateDeviceBitmap"
	,"NtGdiEngCreatePalette"
	,"NtGdiEngComputeGlyphSet"
	,"NtGdiEngCopyBits"
	,"NtGdiEngDeletePalette"
	,"NtGdiEngDeleteSurface"
	,"NtGdiEngEraseSurface"
	,"NtGdiEngUnlockSurface"
	,"NtGdiEngLockSurface"
	,"NtGdiEngBitBlt"
	,"NtGdiEngStretchBlt"
	,"NtGdiEngPlgBlt"
	,"NtGdiEngMarkBandingSurface"
	,"NtGdiEngStrokePath"
	,"NtGdiEngFillPath"
	,"NtGdiEngStrokeAndFillPath"
	,"NtGdiEngPaint"
	,"NtGdiEngLineTo"
	,"NtGdiEngAlphaBlend"
	,"NtGdiEngGradientFill"
	,"NtGdiEngTransparentBlt"
	,"NtGdiEngTextOut"
	,"NtGdiEngStretchBltROP"
	,"NtGdiXLATEOBJ_cGetPalette"
	,"NtGdiXLATEOBJ_iXlate"
	,"NtGdiXLATEOBJ_hGetColorTransform"
	,"NtGdiCLIPOBJ_bEnum"
	,"NtGdiCLIPOBJ_cEnumStart"
	,"NtGdiCLIPOBJ_ppoGetPath"
	,"NtGdiEngDeletePath"
	,"NtGdiEngCreateClip"
	,"NtGdiEngDeleteClip"
	,"NtGdiBRUSHOBJ_ulGetBrushColor"
	,"NtGdiBRUSHOBJ_pvAllocRbrush"
	,"NtGdiBRUSHOBJ_pvGetRbrush"
	,"NtGdiBRUSHOBJ_hGetColorTransform"
	,"NtGdiXFORMOBJ_bApplyXform"
	,"NtGdiXFORMOBJ_iGetXform"
	,"NtGdiFONTOBJ_vGetInfo"
	,"NtGdiFONTOBJ_pxoGetXform"
	,"NtGdiFONTOBJ_cGetGlyphs"
	,"NtGdiFONTOBJ_pifi"
	,"NtGdiFONTOBJ_pfdg"
	,"NtGdiFONTOBJ_pQueryGlyphAttrs"
	,"NtGdiFONTOBJ_pvTrueTypeFontFile"
	,"NtGdiFONTOBJ_cGetAllGlyphHandles"
	,"NtGdiSTROBJ_bEnum"
	,"NtGdiSTROBJ_bEnumPositionsOnly"
	,"NtGdiSTROBJ_bGetAdvanceWidths"
	,"NtGdiSTROBJ_vEnumStart"
	,"NtGdiSTROBJ_dwGetCodePage"
	,"NtGdiPATHOBJ_vGetBounds"
	,"NtGdiPATHOBJ_bEnum"
	,"NtGdiPATHOBJ_vEnumStart"
	,"NtGdiPATHOBJ_vEnumStartClipLines"
	,"NtGdiPATHOBJ_bEnumClipLines"
	,"NtGdiGetDhpdev"
	,"NtGdiEngCheckAbort"
	,"NtGdiHT_Get8BPPFormatPalette"
	,"NtGdiHT_Get8BPPMaskPalette"
	,"NtGdiUpdateTransform"
	,"NtGdiSetPUMPDOBJ"
	,"NtGdiBRUSHOBJ_DeleteRbrush"
	,"NtGdiUnmapMemFont"
	,"NtGdiDrawStream"
};





CHAR WIN7ProcName[827][100]=
{
	"NtUserGetThreadState"          //0
	,"NtUserPeekMessage"            //1
	,"NtUserCallOneParam"           //2
	,"NtUserGetKeyState"            //3
	,"NtUserInvalidateRect"         //4
	,"NtUserCallNoParam"            //5
	,"NtUserGetMessage"             //6
	,"NtUserMessageCall"            //7
	,"NtGdiBitBlt"                  //8
	,"NtGdiGetCharSet"              //9
	,"NtUserGetDC"                  //10 
	,"NtGdiSelectBitmap"			//11
	,"NtUserWaitMessage"			//12
	,"NtUserTranslateMessage"		//13
	,"NtUserGetProp"			    //14
	,"NtUserPostMessage"            //15
	,"NtUserQueryWindow"            //16
	,"NtUserTranslateAccelerator"   //17
	,"NtGdiFlush"                   //18
	,"NtUserRedrawWindow"           //19
	,"NtUserWindowFromPoint"        //20
	,"NtUserCallMsgFilter"          //21
	,"NtUserValidateTimerCallback"  //22
	,"NtUserBeginPaint"             //23
	,"NtUserSetTimer"               //24
	,"NtUserEndPaint"               //25
	,"NtUserSetCursor"              //26
	,"NtUserKillTimer"              //27
	,"NtUserBuildHwndList"          //28
	,"NtUserSelectPalette"          //29
	,"NtUserCallNextHookEx"         //30 
	,"NtUserHideCaret"              //31 
	,"NtGdiIntersectClipRect"       //32
	,"NtUserCallHwndLock"           //33 
	,"NtUserGetProcessWindowStation"//34
	,"NtGdiDeleteObjectApp"         //35
	,"NtUserSetWindowPos"           //36
	,"NtUserShowCaret"              //37
	,"NtUserEndDeferWindowPosEx"    //38
	,"NtUserCallHwndParamLock"      //39
	,"NtUserVkKeyScanEx"            //40
	,"NtGdiSetDIBitsToDeviceInternal"//41
	,"NtUserCallTwoParam"           //42   
	,"NtGdiGetRandomRgn"            //43
	,"NtUserCopyAcceleratorTable"   //44
	,"NtUserNotifyWinEvent"         //45 
	,"NtGdiExtSelectClipRgn"        //46 
	,"NtUserIsClipboardFormatAvailable"//47
	,"NtUserSetScrollInfo"          //48
	,"NtGdiStretchBlt"              //49
	,"NtUserCreateCaret"            //50
	,"NtGdiRectVisible"             //51
	,"NtGdiCombineRgn"              //52
	,"NtGdiGetDCObject"             //53
	,"NtUserDispatchMessage"        //54
	,"NtUserRegisterWindowMessage"  //55
	,"NtGdiExtTextOutW"             //56
	,"NtGdiSelectFont"              //57
	,"NtGdiRestoreDC"               //58
	,"NtGdiSaveDC"                  //59
	,"NtUserGetForegroundWindow"    //60  
	,"NtUserShowScrollBar"          //61
	,"NtUserFindExistingCursorIcon" //62
	,"NtGdiGetDCDword"				//63
	,"NtGdiGetRegionData"			//64	
	,"NtGdiLineTo"					//65	
	,"NtUserSystemParametersInfo"	//66
	,"NtGdiGetAppClipBox"			//67
	,"NtUserGetAsyncKeyState"		//68	
	,"NtUserGetCPD"					//69
	,"NtUserRemoveProp"				//70
	,"NtGdiDoPalette"				//71
	,"NtGdiPolyPolyDraw"            //72
	,"NtUserSetCapture"				//73
	,"NtUserEnumDisplayMonitors"    //74
	,"NtGdiCreateCompatibleBitmap"  //75
	,"NtUserSetProp"				//76
	,"NtGdiGetTextCharsetInfo"		//77
	,"NtUserSBGetParms"				//78
	,"NtUserGetIconInfo"			//79	
	,"NtUserExcludeUpdateRgn"		//80
	,"NtUserSetFocus"				//81
	,"NtGdiExtGetObjectW"			//82
	,"NtUserDeferWindowPos"         //83
	,"NtUserGetUpdateRect"			//84
	,"NtGdiCreateCompatibleDC"		//85
	,"NtUserGetClipboardSequenceNumber"//86
	,"NtGdiCreatePen"				//87
	,"NtUserShowWindow"				//88
	,"NtUserGetKeyboardLayoutList"	//89	
	,"NtGdiPatBlt"                  //90
	,"NtUserMapVirtualKeyEx"		//91
	,"NtUserSetWindowLong"			//92
	,"NtGdiHfontCreate"				//93
	,"NtUserMoveWindow"				//94
	,"NtUserPostThreadMessage"      //95
	,"NtUserDrawIconEx"				//96
	,"NtUserGetSystemMenu"			//97
	,"NtGdiDrawStream"				//98
	,"NtUserInternalGetWindowText"	//99
	,"NtUserGetWindowDC"			//100
	,"NtGdiD3dDrawPrimitives2"	    //101
	,"NtGdiInvertRgn"				//102
	,"NtGdiGetRgnBox"				//103
	,"NtGdiGetAndSetDCDword"		//104
	,"NtGdiMaskBlt"					//105
	,"NtGdiGetWidthTable"			//106
	,"NtUserScrollDC"				//107
	,"NtUserGetObjectInformation"	//108
	,"NtGdiCreateBitmap"			//109
	,"NtUserFindWindowEx"			//110
	,"NtGdiPolyPatBlt"				//111
	,"NtUserUnhookWindowsHookEx"	//112	
	,"NtGdiGetNearestColor"			//113
	,"NtGdiTransformPoints"			//114
	,"NtGdiGetDCPoint"				//115
	,"NtGdiCreateDIBBrush"			//116
	,"NtGdiGetTextMetricsW"         //117 
	,"NtUserCreateWindowEx"			//118
	,"NtUserSetParent"				//119
	,"NtUserGetKeyboardState"		//120	
	,"NtUserToUnicodeEx"			//121
	,"NtUserGetControlBrush"		//122
	,"NtUserGetClassName"			//123
	,"NtGdiAlphaBlend"				//124
	,"NtGdiDdBlt"			        //125
	,"NtGdiOffsetRgn"				//126
	,"NtUserDefSetText"				//127
	,"NtGdiGetTextFaceW"			//128
	,"NtGdiStretchDIBitsInternal"	//129	
	,"NtUserSendInput"				//130
	,"NtUserGetThreadDesktop"		//131
	,"NtGdiCreateRectRgn"			//132
	,"NtGdiGetDIBitsInternal"		//133
	,"NtUserGetUpdateRgn"			//134
	,"NtGdiDeleteClientObj"			//135
	,"NtUserGetIconSize"			//136
	,"NtUserFillWindow"				//137
	,"NtGdiExtCreateRegion"			//138
	,"NtGdiComputeXformCoefficients"//139
	,"NtUserSetWindowsHookEx"		//140
	,"NtUserNotifyProcessCreate"	//141	
	,"NtGdiUnrealizeObject"			//142
	,"NtUserGetTitleBarInfo"		//143
	,"NtGdiRectangle"				//144
	,"NtUserSetThreadDesktop"		//145	
	,"NtUserGetDCEx"				//146
	,"NtUserGetScrollBarInfo"       //147
	,"NtGdiGetTextExtent"			//148
	,"NtUserSetWindowFNID"			//149
	,"NtGdiSetLayout"				//150
	,"NtUserCalcMenuBar"			//151
	,"NtUserThunkedMenuItemInfo"	//152	
	,"NtGdiExcludeClipRect"			//153
	,"NtGdiCreateDIBSection"		//154
	,"NtGdiGetDCforBitmap"			//155
	,"NtUserDestroyCursor"			//156
	,"NtUserDestroyWindow"			//157
	,"NtUserCallHwndParam"          //158
	,"NtGdiCreateDIBitmapInternal"  //159 
	,"NtUserOpenWindowStation"      //160
	,"NtGdiDdDeleteSurfaceObject"   //161
	,"NtGdiDdCanCreateSurface"      //162  
	,"NtGdiDdCreateSurface"         //163
	,"NtUserSetCursorIconData"      //164
	,"NtGdiDdDestroySurface"        //165
	,"NtUserCloseDesktop"			//166
	,"NtUserOpenDesktop"            //167 
	,"NtUserSetProcessWindowStation"//168             
	,"NtUserGetAtomName"            //169
	,"NtGdiDdResetVisrgn"           //170
	,"NtGdiExtCreatePen"            //171   
	,"NtGdiCreatePaletteInternal"   //172 
	,"NtGdiSetBrushOrg"             //173
	,"NtUserBuildNameList"          //174
	,"NtGdiSetPixel"                //175
	,"NtUserRegisterClassExWOW"     //176              
	,"NtGdiCreatePatternBrushInternal"//177
	,"NtUserGetAncestor"            //178
	,"NtGdiGetOutlineTextMetricsInternalW"//179
	,"NtGdiSetBitmapBits"           //180
	,"NtUserCloseWindowStation"     //181 
	,"NtUserGetDoubleClickTime"     //182
	,"NtUserEnableScrollBar"        //183
	,"NtGdiCreateSolidBrush"        //184 
	,"NtUserGetClassInfoEx"         //185
	,"NtGdiCreateClientObj"		    //186	
	,"NtUserUnregisterClass"        //187
	,"NtUserDeleteMenu"			    //188	
	,"NtGdiRectInRegion"			//189
	,"NtUserScrollWindowEx"			//190
	,"NtGdiGetPixel"                //191
	,"NtUserSetClassLong"           //192 
	,"NtUserGetMenuBarInfo"         //193
	,"NtGdiDdCreateSurfaceEx"       //195
	,"NtGdiDdCreateSurfaceObject"   //195
	,"NtGdiGetNearestPaletteIndex"  //196
	,"NtGdiDdLockD3D"               //197
	,"NtGdiDdUnlockD3D"             //198
	,"NtGdiGetCharWidthW"           //199
	,"NtUserInvalidateRgn"          //200
	,"NtUserGetClipboardOwner"      //201 
	,"NtUserSetWindowRgn"           //202 
	,"NtUserBitBltSysBmp"           //203
	,"NtGdiGetCharWidthInfo"        //204  
	,"NtUserValidateRect"           //205 
	,"NtUserCloseClipboard"         //206
	,"NtUserOpenClipboard"          //207
	,"NtGdiGetStockObject"          //208 
	,"NtUserSetClipboardData"       //209
	,"NtUserEnableMenuItem"         //210
	,"NtUserAlterWindowStyle"       //211
	,"NtGdiFillRgn"                 //212
	,"NtUserGetWindowPlacement"     //213 
	,"NtGdiModifyWorldTransform"    //214
	,"NtGdiGetFontData"             //215
	,"NtUserGetOpenClipboardWindow" //216
	,"NtUserSetThreadState"         //217
	,"NtGdiOpenDCW"                 //218
	,"NtUserTrackMouseEvent"        //219  
	,"NtGdiGetTransform"            //220
	,"NtUserDestroyMenu"            //221
	,"NtGdiGetBitmapBits"           //222
	,"NtUserConsoleControl"         //223  
	,"NtUserSetActiveWindow"        //224
	,"NtUserSetInformationThread"   //225
	,"NtUserSetWindowPlacement"     //226 
	,"NtUserGetControlColor"        //227
	,"NtGdiSetMetaRgn"              //228
	,"NtGdiSetMiterLimit"           //229
	,"NtGdiSetVirtualResolution"    //230
	,"NtGdiGetRasterizerCaps"       //231
	,"NtUserSetWindowWord"          //232
	,"NtUserGetClipboardFormatName" //233
	,"NtUserRealInternalGetMessage" //234 
	,"NtUserCreateLocalMemHandle"   //235
	,"NtUserAttachThreadInput"      //236
	,"NtGdiCreateHalftonePalette"   //237
	,"NtUserPaintMenuBar"           //238
	,"NtUserSetKeyboardState"       //239
	,"NtGdiCombineTransform"        //240 
	,"NtUserCreateAcceleratorTable" //241
	,"NtUserGetCursorFrameInfo"     //242
	,"NtUserGetAltTabInfo"          //243
	,"NtUserGetCaretBlinkTime"      //244
	,"NtGdiQueryFontAssocInfo"      //245
	,"NtUserProcessConnect"         //246
	,"NtUserEnumDisplayDevices"     //247 
	,"NtUserEmptyClipboard"         //248
	,"NtUserGetClipboardData"       //249
	,"NtUserRemoveMenu"             //250
	,"NtGdiSetBoundsRect"           //251
	,"NtGdiGetBitmapDimension"      //252
	,"NtUserConvertMemHandle"       //253
	,"NtUserDestroyAcceleratorTable"//254 
	,"NtUserGetGUIThreadInfo"       //255
	,"NtGdiCloseFigure"             //256
	,"NtUserSetWindowsHookAW"       //257 
	,"NtUserSetMenuDefaultItem"     //258 
	,"NtUserCheckMenuItem"          //259
	,"NtUserSetWinEventHook"        //260
	,"NtUserUnhookWinEvent"         //261
	,"NtUserLockWindowUpdate"       //262 
	,"NtUserSetSystemMenu"          //263
	,"NtUserThunkedMenuInfo"        //264
	,"NtGdiBeginPath"               //265
	,"NtGdiEndPath"                 //266
	,"NtGdiFillPath"                //267
	,"NtUserCallHwnd"               //268
	,"NtUserDdeInitialize"          //269
	,"NtUserModifyUserStartupInfoFlags"//270 
	,"NtUserCountClipboardFormats"  //271 
	,"NtGdiAddFontMemResourceEx"    //272
	,"NtGdiEqualRgn"                //273
	,"NtGdiGetSystemPaletteUse"     //274
	,"NtGdiRemoveFontMemResourceEx" //275 
	,"NtUserEnumDisplaySettings"    //276
	,"NtUserPaintDesktop"           //277 
	,"NtGdiExtEscape"               //278
	,"NtGdiSetBitmapDimension"      //279 
	,"NtGdiSetFontEnumeration"      //280
	,"NtUserChangeClipboardChain"   //281
	,"NtUserSetClipboardViewer"     //282
	,"NtUserShowWindowAsync"        //283
	,"NtGdiCreateColorSpace"        //284
	,"NtGdiDeleteColorSpace"        //285
	,"NtUserActivateKeyboardLayout" //286 
	,"NtGdiAbortDoc"                //287 
	,"NtGdiAbortPath"               //288
	,"NtGdiAddEmbFontToDC"          //289
	,"NtGdiAddFontResourceW"        //290 
	,"NtGdiAddRemoteFontToDC"       //291
	,"NtGdiAddRemoteMMInstanceToDC" //292
	,"NtGdiAngleArc"                //293
	,"NtGdiAnyLinkedFonts"          //294 
	,"NtGdiArcInternal"             //295
	,"NtGdiBRUSHOBJ_DeleteRbrush"   //296
	,"NtGdiBRUSHOBJ_hGetColorTransform"//297 
	,"NtGdiBRUSHOBJ_pvAllocRbrush"  //298 
	,"NtGdiBRUSHOBJ_pvGetRbrush"    //299
	,"NtGdiBRUSHOBJ_ulGetBrushColor"//300
	,"NtGdiBeginGdiRendering"       //301
	,"NtGdiCLIPOBJ_bEnum"           //302    
	,"NtGdiCLIPOBJ_cEnumStart"      //303
	,"NtGdiCLIPOBJ_ppoGetPath"      //304 
	,"NtGdiCancelDC"                //305
	,"NtGdiChangeGhostFont"         //306
	,"NtGdiCheckBitmapBits"         //307
	,"NtGdiClearBitmapAttributes"   //308
	,"NtGdiClearBrushAttributes"    //309
	,"NtGdiColorCorrectPalette"     //310
	,"NtGdiConfigureOPMProtectedOutput"//311
	,"NtGdiConvertMetafileRect"     //312 
	,"NtGdiCreateBitmapFromDxSurface"//313
	,"NtGdiCreateColorTransform"     //314
	,"NtGdiCreateEllipticRgn"        //315 
	,"NtGdiCreateHatchBrushInternal" //316
	,"NtGdiCreateMetafileDC"         //317
	,"NtGdiCreateOPMProtectedOutputs"//318 
	,"NtGdiCreateRoundRectRgn"       //319
	,"NtGdiCreateServerMetaFile"     //320
	,"NtGdiD3dContextCreate"         //321
	,"NtGdiD3dContextDestroy"        //322
	,"NtGdiD3dContextDestroyAll"     //323 
	,"NtGdiD3dValidateTextureStageState"//324 
	,"NtGdiDDCCIGetCapabilitiesString"//325
	,"NtGdiDDCCIGetCapabilitiesStringLength"//326
	,"NtGdiDDCCIGetTimingReport"     //327
	,"NtGdiDDCCIGetVCPFeature"       //328
	,"NtGdiDDCCISaveCurrentSettings" //329
	,"NtGdiDDCCISetVCPFeature"       //330
	,"NtGdiDdAddAttachedSurface"     //331
	,"NtGdiDdAlphaBlt"               //332
	,"NtGdiDdAttachSurface"          //333
	,"NtGdiDdBeginMoCompFrame"       //334
	,"NtGdiDdCanCreateD3DBuffer"     //335
	,"NtGdiDdColorControl"           //336
	,"NtGdiDdCreateD3DBuffer"        //337
	,"NtGdiDdCreateDirectDrawObject" //338
	,"NtGdiDdCreateFullscreenSprite" //339 
	,"NtGdiDdCreateMoComp"           //340
	,"NtGdiDdDDIAcquireKeyedMutex"   //341
	,"NtGdiDdDDICheckExclusiveOwnership"//342
	,"NtGdiDdDDICheckMonitorPowerState"//343 
	,"NtGdiDdDDICheckOcclusion"      //344
	,"NtGdiDdDDICheckSharedResourceAccess"//345
	,"NtGdiDdDDICheckVidPnExclusiveOwnership"//346
	,"NtGdiDdDDICloseAdapter"        //347
	,"NtGdiDdDDIConfigureSharedResource"//348
	,"NtGdiDdDDICreateAllocation"    //349
	,"NtGdiDdDDICreateContext"       //350
	,"NtGdiDdDDICreateDCFromMemory"  //351
	,"NtGdiDdDDICreateDevice"        //352
	,"NtGdiDdDDICreateKeyedMutex"    //353
	,"NtGdiDdDDICreateOverlay"       //354
	,"NtGdiDdDDICreateSynchronizationObject"//355
	,"NtGdiDdDDIDestroyAllocation"   //356
	,"NtGdiDdDDIDestroyContext"      //357
	,"NtGdiDdDDIDestroyDCFromMemory" //358
	,"NtGdiDdDDIDestroyDevice"       //359
	,"NtGdiDdDDIDestroyKeyedMutex"   //360
	,"NtGdiDdDDIDestroyOverlay"      //361 
	,"NtGdiDdDDIDestroySynchronizationObject"//362
	,"NtGdiDdDDIEscape"				 //363
	,"NtGdiDdDDIFlipOverlay"         //364
	,"NtGdiDdDDIGetContextSchedulingPriority"//365
	,"NtGdiDdDDIGetDeviceState"      //366
	,"NtGdiDdDDIGetDisplayModeList"  //357
	,"NtGdiDdDDIGetMultisampleMethodList"//368
	,"NtGdiDdDDIGetOverlayState"     //369
	,"NtGdiDdDDIGetPresentHistory"   //370
	,"NtGdiDdDDIGetPresentQueueEvent"//371
	,"NtGdiDdDDIGetProcessSchedulingPriorityClass"//372
	,"NtGdiDdDDIGetRuntimeData"      //373
	,"NtGdiDdDDIGetScanLine"         //374
	,"NtGdiDdDDIGetSharedPrimaryHandle"//375
	,"NtGdiDdDDIInvalidateActiveVidPn"//376 
	,"NtGdiDdDDILock"                //377
	,"NtGdiDdDDIOpenAdapterFromDeviceName"//378
	,"NtGdiDdDDIOpenAdapterFromHdc"  //379
	,"NtGdiDdDDIOpenKeyedMutex"      //380
	,"NtGdiDdDDIOpenResource"        //381
	,"NtGdiDdDDIOpenSynchronizationObject"//382
	,"NtGdiDdDDIPollDisplayChildren" //383
	,"NtGdiDdDDIPresent"             //384
	,"NtGdiDdDDIQueryAdapterInfo"    //385 
	,"NtGdiDdDDIQueryAllocationResidency"//386
	,"NtGdiDdDDIQueryResourceInfo"    //387
	,"NtGdiDdDDIQueryStatistics"      //388
	,"NtGdiDdDDIReleaseKeyedMutex"	  //389
	,"NtGdiDdDDIReleaseProcessVidPnSourceOwners"//390
	,"NtGdiDdDDIRender"		          //391
	,"NtGdiDdDDISetAllocationPriority"//392
	,"NtGdiDdDDISetContextSchedulingPriority"//393
	,"NtGdiDdDDISetDisplayMode"		  //394
	,"NtGdiDdDDISetDisplayPrivateDriverFormat"//395
	,"NtGdiDdDDISetGammaRamp"		  //396
	,"NtGdiDdDDISetProcessSchedulingPriorityClass"//397
	,"NtGdiDdDDISetQueuedLimit"		  //398
	,"NtGdiDdDDISetVidPnSourceOwner"  //399
	,"NtGdiDdDDISharedPrimaryLockNotification"//400
	,"NtGdiDdDDISharedPrimaryUnLockNotification"//401
	,"NtGdiDdDDISignalSynchronizationObject"//402
	,"NtGdiDdDDIUnlock"		         //403
	,"NtGdiDdDDIUpdateOverlay"		 //404
	,"NtGdiDdDDIWaitForIdle"		 //405
	,"NtGdiDdDDIWaitForSynchronizationObject"//406
	,"NtGdiDdDDIWaitForVerticalBlankEvent"//407
	,"NtGdiDdDeleteDirectDrawObject" //408
	,"NtGdiDdDestroyD3DBuffer"		 //409
	,"NtGdiDdDestroyFullscreenSprite"//410
	,"NtGdiDdDestroyMoComp"		     //411
	,"NtGdiDdEndMoCompFrame"		 //412
	,"NtGdiDdFlip"		             //413
	,"NtGdiDdFlipToGDISurface"		 //414
	,"NtGdiDdGetAvailDriverMemory"	 //415
	,"NtGdiDdGetBltStatus"		     //416
	,"NtGdiDdGetDC"		             //417
	,"NtGdiDdGetDriverInfo"		     //418
	,"NtGdiDdGetDriverState"		 //419
	,"NtGdiDdGetDxHandle"		     //420
	,"NtGdiDdGetFlipStatus"		     //421
	,"NtGdiDdGetInternalMoCompInfo"	 //422
	,"NtGdiDdGetMoCompBuffInfo"		 //423
	,"NtGdiDdGetMoCompFormats"		 //424
	,"NtGdiDdGetMoCompGuids"		 //425
	,"NtGdiDdGetScanLine"		     //426
	,"NtGdiDdLock"		             //427
	,"NtGdiDdNotifyFullscreenSpriteUpdate"//428
	,"NtGdiDdQueryDirectDrawObject"	 //429
	,"NtGdiDdQueryMoCompStatus"		 //430
	,"NtGdiDdQueryVisRgnUniqueness"	 //431
	,"NtGdiDdReenableDirectDrawObject"//432
	,"NtGdiDdReleaseDC"		         //433
	,"NtGdiDdRenderMoComp"			 //434
	,"NtGdiDdSetColorKey"			 //435
	,"NtGdiDdSetExclusiveMode"		 //436
	,"NtGdiDdSetGammaRamp"			 //437
	,"NtGdiDdSetOverlayPosition"	 //438
	,"NtGdiDdUnattachSurface"		 //439
	,"NtGdiDdUnlock"			     //440
	,"NtGdiDdUpdateOverlay"			 //441
	,"NtGdiDdWaitForVerticalBlank"	 //442
	,"NtGdiDeleteColorTransform"	 //443
	,"NtGdiDescribePixelFormat"		 //444
	,"NtGdiDestroyOPMProtectedOutput"//445
	,"NtGdiDestroyPhysicalMonitor"	 //446
	,"NtGdiDoBanding"				 //447
	,"NtGdiDrawEscape"				 //448
	,"NtGdiDvpAcquireNotification"	 //449
	,"NtGdiDvpCanCreateVideoPort"	 //450
	,"NtGdiDvpColorControl"			 //451
	,"NtGdiDvpCreateVideoPort"		 //452
	,"NtGdiDvpDestroyVideoPort"		 //453
	,"NtGdiDvpFlipVideoPort"		 //454
	,"NtGdiDvpGetVideoPortBandwidth" //455
	,"NtGdiDvpGetVideoPortConnectInfo"//456
	,"NtGdiDvpGetVideoPortField"	 //457
	,"NtGdiDvpGetVideoPortFlipStatus"//458
	,"NtGdiDvpGetVideoPortInputFormats"//459
	,"NtGdiDvpGetVideoPortLine"		 //460
	,"NtGdiDvpGetVideoPortOutputFormats"//461
	,"NtGdiDvpGetVideoSignalStatus"	 //462
	,"NtGdiDvpReleaseNotification"	 //463
	,"NtGdiDvpUpdateVideoPort"		 //464
	,"NtGdiDvpWaitForVideoPortSync"	 //465
	,"NtGdiDxgGenericThunk"		     //466
	,"NtGdiEllipse"					 //467
	,"NtGdiEnableEudc"				 //468
	,"NtGdiEndDoc"				     //469
	,"NtGdiEndGdiRendering"			 //470
	,"NtGdiEndPage"					 //471
	,"NtGdiEngAlphaBlend"			 //472
	,"NtGdiEngAssociateSurface"		 //473
	,"NtGdiEngBitBlt"				 //474
	,"NtGdiEngCheckAbort"		     //475
	,"NtGdiEngComputeGlyphSet"		 //476
	,"NtGdiEngCopyBits"				 //477
	,"NtGdiEngCreateBitmap"			 //478
	,"NtGdiEngCreateClip"			 //479
	,"NtGdiEngCreateDeviceBitmap"	 //480
	,"NtGdiEngCreateDeviceSurface"	 //481
	,"NtGdiEngCreatePalette"		 //482
	,"NtGdiEngDeleteClip"			 //483
	,"NtGdiEngDeletePalette"		 //484
	,"NtGdiEngDeletePath"			 //485
	,"NtGdiEngDeleteSurface"		 //486
	,"NtGdiEngEraseSurface"			 //487
	,"NtGdiEngFillPath"				 //488
	,"NtGdiEngGradientFill"			 //489
	,"NtGdiEngLineTo"				 //490
	,"NtGdiEngLockSurface"			 //491
	,"NtGdiEngMarkBandingSurface"	 //492
	,"NtGdiEngPaint"				 //493
	,"NtGdiEngPlgBlt"				 //494
	,"NtGdiEngStretchBlt"			 //495
	,"NtGdiEngStretchBltROP"		 //496
	,"NtGdiEngStrokeAndFillPath"	 //497
	,"NtGdiEngStrokePath"			 //498
	,"NtGdiEngTextOut"				 //499
	,"NtGdiEngTransparentBlt"		 //500
	,"NtGdiEngUnlockSurface"		 //501
	,"NtGdiEnumFonts"				 //502
	,"NtGdiEnumObjects"				 //503
	,"NtGdiEudcLoadUnloadLink"		 //504
	,"NtGdiExtFloodFill"			 //505
	,"NtGdiFONTOBJ_cGetAllGlyphHandles"	//506
	,"NtGdiFONTOBJ_cGetGlyphs"		 //507
	,"NtGdiFONTOBJ_pQueryGlyphAttrs" //508
	,"NtGdiFONTOBJ_pfdg"			 //509
	,"NtGdiFONTOBJ_pifi"			 //510
	,"NtGdiFONTOBJ_pvTrueTypeFontFile"//511
	,"NtGdiFONTOBJ_pxoGetXform"		 //512
	,"NtGdiFONTOBJ_vGetInfo"		 //513
	,"NtGdiFlattenPath"				 //514
	,"NtGdiFontIsLinked"			 //515
	,"NtGdiForceUFIMapping"		     //516
	,"NtGdiFrameRgn"		         //517
	,"NtGdiFullscreenControl"		 //518
	,"NtGdiGetBoundsRect"		     //519
	,"NtGdiGetCOPPCompatibleOPMInformation"//520
	,"NtGdiGetCertificate"			 //521
	,"NtGdiGetCertificateSize"		 //522
	,"NtGdiGetCharABCWidthsW"		 //523
	,"NtGdiGetCharacterPlacementW"	 //524
	,"NtGdiGetColorAdjustment"		 //525
	,"NtGdiGetColorSpaceforBitmap"	 //526
	,"NtGdiGetDeviceCaps"			 //527
	,"NtGdiGetDeviceCapsAll"		 //528
	,"NtGdiGetDeviceGammaRamp"		 //529
	,"NtGdiGetDeviceWidth"			 //530
	,"NtGdiGetDhpdev"				 //531
	,"NtGdiGetETM"					 //532
	,"NtGdiGetEmbUFI"				 //533
	,"NtGdiGetEmbedFonts"			 //534
	,"NtGdiGetEudcTimeStampEx"		 //535
	,"NtGdiGetFontFileData"			 //536
	,"NtGdiGetFontFileInfo"			 //537
	,"NtGdiGetFontResourceInfoInternalW"//538
	,"NtGdiGetFontUnicodeRanges"	 //539
	,"NtGdiGetGlyphIndicesW"		 //540
	,"NtGdiGetGlyphIndicesWInternal" //541
	,"NtGdiGetGlyphOutline"			 //542
	,"NtGdiGetKerningPairs"			 //543
	,"NtGdiGetLinkedUFIs"			 //544
	,"NtGdiGetMiterLimit"			 //545
	,"NtGdiGetMonitorID"			 //546
	,"NtGdiGetNumberOfPhysicalMonitors"	//547
	,"NtGdiGetOPMInformation"		 //548
	,"NtGdiGetOPMRandomNumber"		 //549
	,"NtGdiGetObjectBitmapHandle"	 //550
	,"NtGdiGetPath"					 //551
	,"NtGdiGetPerBandInfo"			 //552
	,"NtGdiGetPhysicalMonitorDescription"//553
	,"NtGdiGetPhysicalMonitors"		 //554
	,"NtGdiGetRealizationInfo"		 //555
	,"NtGdiGetServerMetaFileBits"	 //556
	,"DxgStubAlphaBlt"				 //557
	,"NtGdiGetStats"				 //558
	,"NtGdiGetStringBitmapW"		 //559
	,"NtGdiGetSuggestedOPMProtectedOutputArraySize"//560
	,"NtGdiGetTextExtentExW"		 //561
	,"NtGdiGetUFI"					 //562
	,"NtGdiGetUFIPathname"			 //563
	,"NtGdiGradientFill"			 //564
	,"NtGdiHLSurfGetInformation"	 //565
	,"NtGdiHLSurfSetInformation"	 //566
	,"NtGdiHT_Get8BPPFormatPalette"	 //567
	,"NtGdiHT_Get8BPPMaskPalette"	 //568
	,"NtGdiIcmBrushInfo"			 //569
	,"EngRestoreFloatingPointState"	 //570
	,"NtGdiInitSpool"				 //571
	,"NtGdiMakeFontDir"				 //572
	,"NtGdiMakeInfoDC"				 //573
	,"NtGdiMakeObjectUnXferable"	 //574
	,"NtGdiMakeObjectXferable"		 //575
	,"NtGdiMirrorWindowOrg"			 //576
	,"NtGdiMonoBitmap"				 //577
	,"NtGdiMoveTo"					 //578
	,"NtGdiOffsetClipRgn"			 //579
	,"NtGdiPATHOBJ_bEnum"			 //580
	,"NtGdiPATHOBJ_bEnumClipLines"	 //581
	,"NtGdiPATHOBJ_vEnumStart"		 //582
	,"NtGdiPATHOBJ_vEnumStartClipLines"//583
	,"NtGdiPATHOBJ_vGetBounds"		 //584
	,"NtGdiPathToRegion"			 //585
	,"NtGdiPlgBlt"					 //586
	,"NtGdiPolyDraw"				 //587
	,"NtGdiPolyTextOutW"			 //588
	,"NtGdiPtInRegion"				 //589
	,"NtGdiPtVisible"				 //590
	,"NtGdiQueryFonts"				 //591
	,"NtGdiRemoveFontResourceW"		 //592
	,"NtGdiRemoveMergeFont"			 //593
	,"NtGdiResetDC"					 //594
	,"NtGdiResizePalette"			 //595
	,"NtGdiRoundRect"				 //596
	,"NtGdiSTROBJ_bEnum"			 //597
	,"NtGdiSTROBJ_bEnumPositionsOnly"//598
	,"NtGdiSTROBJ_bGetAdvanceWidths" //599
	,"NtGdiSTROBJ_dwGetCodePage"	 //600
	,"NtGdiSTROBJ_vEnumStart"		 //601
	,"NtGdiScaleViewportExtEx"		 //602
	,"NtGdiScaleWindowExtEx"		 //603
	,"NtGdiSelectBrush"				 //604
	,"NtGdiSelectClipPath"			 //605
	,"NtGdiSelectPen"				 //606
	,"NtGdiSetBitmapAttributes"		 //607
	,"NtGdiSetBrushAttributes"		 //608
	,"NtGdiSetColorAdjustment"		 //609
	,"NtGdiSetColorSpace"			 //610
	,"NtGdiSetDeviceGammaRamp"		 //611
	,"NtGdiSetFontXform"			 //612
	,"NtGdiSetIcmMode"				 //613
	,"NtGdiSetLinkedUFIs"			 //614
	,"NtGdiSetMagicColors"			 //615
	,"NtGdiSetOPMSigningKeyAndSequenceNumbers"//616
	,"NtGdiSetPUMPDOBJ"				 //617
	,"NtGdiSetPixelFormat"			 //618
	,"NtGdiSetRectRgn"				 //619
	,"NtGdiSetSizeDevice"			 //620
	,"NtGdiSetSystemPaletteUse"		 //621
	,"NtGdiSetTextJustification"	 //622
	,"NtGdiSfmGetNotificationTokens" //623
	,"NtGdiStartDoc"				 //624
	,"NtGdiStartPage"				 //625
	,"NtGdiStrokeAndFillPath"		 //626
	,"NtGdiStrokePath"				 //627
	,"NtGdiSwapBuffers"				 //628
	,"NtGdiTransparentBlt"			 //629
	,"NtGdiUMPDEngFreeUserMem"		 //630
	,"DxgStubAlphaBlt"				 //631
	,"EngRestoreFloatingPointState"	 //632
	,"NtGdiUpdateColors"			 //633
	,"NtGdiUpdateTransform"			 //634
	,"NtGdiWidenPath"				 //635
	,"NtGdiXFORMOBJ_bApplyXform"	 //636
	,"NtGdiXFORMOBJ_iGetXform"		 //637
	,"NtGdiXLATEOBJ_cGetPalette"	 //638
	,"NtGdiXLATEOBJ_hGetColorTransform"//639
	,"NtGdiXLATEOBJ_iXlate"			 //640
	,"NtUserAddClipboardFormatListener"//641
	,"NtUserAssociateInputContext"	 //642
	,"NtUserBlockInput"				 //643
	,"NtUserBuildHimcList"			 //644
	,"NtUserBuildPropList"			 //645
	,"NtUserCalculatePopupWindowPosition"//646
	,"NtUserCallHwndOpt"			 //647
	,"NtUserChangeDisplaySettings"	 //648
	,"NtUserChangeWindowMessageFilterEx"//649
	,"NtUserCheckAccessForIntegrityLevel"//650
	,"NtUserCheckDesktopByThreadId"	 //651
	,"NtUserCheckWindowThreadDesktop"//652
	,"NtUserChildWindowFromPointEx"	 //653
	,"NtUserClipCursor"				 //654
	,"NtUserCreateDesktopEx"	     //655
	,"NtUserCreateInputContext"		 //656
	,"NtUserCreateWindowStation"	 //657
	,"NtUserCtxDisplayIOCtl"		 //658
	,"NtUserDestroyInputContext"	 //659
	,"NtUserDisableThreadIme"		 //660
	,"NtUserDisplayConfigGetDeviceInfo"//661
	,"NtUserDisplayConfigSetDeviceInfo"//662
	,"NtUserDoSoundConnect"			 //663
	,"NtUserDoSoundDisconnect"		 //664
	,"NtUserDragDetect"				 //665
	,"NtUserDragObject"				 //666
	,"NtUserDrawAnimatedRects"		 //667
	,"NtUserDrawCaption"			 //668
	,"NtUserDrawCaptionTemp"		 //669
	,"NtUserDrawMenuBarTemp"		 //670
	,"NtUserDwmStartRedirection"	 //671
	,"NtUserDwmStopRedirection"		 //672
	,"NtUserEndMenu"				 //673
	,"NtUserEndTouchOperation"		 //674
	,"NtUserEvent"					 //675
	,"NtUserFlashWindowEx"		     //676
	,"NtUserFrostCrashedWindow"		 //677
	,"NtUserGetAppImeLevel"			 //678
	,"NtUserGetCaretPos"			 //679
	,"NtUserGetClipCursor"			 //680
	,"NtUserGetClipboardViewer"		 //681
	,"NtUserGetComboBoxInfo"		 //682
	,"NtUserGetCursorInfo"			 //683
	,"NtUserGetDisplayConfigBufferSizes"//684
	,"NtUserGetGestureConfig"		 //685
	,"NtUserGetGestureExtArgs"		 //686
	,"NtUserGetGestureInfo"			 //687
	,"NtUserGetGuiResources"		 //688
	,"NtUserGetImeHotKey"			 //689
	,"NtUserGetImeInfoEx"			 //690
	,"NtUserGetInputLocaleInfo"		 //691
	,"NtUserGetInternalWindowPos"	 //692
	,"NtUserGetKeyNameText"			 //693
	,"NtUserGetKeyboardLayoutName"	 //694
	,"NtUserGetLayeredWindowAttributes"//695
	,"NtUserGetListBoxInfo"			 //696
	,"NtUserGetMenuIndex"			 //697
	,"NtUserGetMenuItemRect"		 //698
	,"NtUserGetMouseMovePointsEx"	 //699
	,"NtUserGetPriorityClipboardFormat"//700
	,"NtUserGetRawInputBuffer"		 //701
	,"NtUserGetRawInputData"		 //702
	,"NtUserGetRawInputDeviceInfo"	 //703
	,"NtUserGetRawInputDeviceList"	 //704
	,"NtUserGetRegisteredRawInputDevices"//705
	,"NtUserGetTopLevelWindow"		 //706
	,"NtUserGetTouchInputInfo"		 //707
	,"NtUserGetUpdatedClipboardFormats"//708
	,"NtUserGetWOWClass"			 //709
	,"NtUserGetWindowCompositionAttribute"//710
	,"NtUserGetWindowCompositionInfo"//711
	,"NtUserGetWindowDisplayAffinity"//712
	,"NtUserGetWindowMinimizeRect"	 //713
	,"NtUserGetWindowRgnEx"			 //714
	,"NtUserGhostWindowFromHungWindow"//715
	,"NtUserHardErrorControl"		 //716
	,"NtUserHiliteMenuItem"			 //717
	,"NtUserHungWindowFromGhostWindow"//718
	,"NtUserHwndQueryRedirectionInfo"//719
	,"NtUserHwndSetRedirectionInfo"	 //720
	,"NtUserImpersonateDdeClientWindow"//721
	,"NtUserInitTask"				 //722
	,"NtUserInitialize"			     //723
	,"NtUserInitializeClientPfnArrays"//724
	,"NtUserInjectGesture"			 //725
	,"NtUserInternalGetWindowIcon"	 //726
	,"NtUserIsTopLevelWindow"		 //727
	,"NtUserIsTouchWindow"			 //728
	,"NtUserLoadKeyboardLayoutEx"	 //729
	,"NtUserLockWindowStation"		 //730
	,"NtUserLockWorkStation"		 //731
	,"NtUserLogicalToPhysicalPoint"	 //732
	,"NtUserMNDragLeave"			 //733
	,"NtUserMNDragOver"				 //734
	,"NtUserMagControl"				 //735
	,"NtUserMagGetContextInformation"//736
	,"NtUserMagSetContextInformation"//737
	,"NtUserManageGestureHandlerWindow"//738
	,"NtUserMenuItemFromPoint"		 //739
	,"NtUserMinMaximize"			 //740
	,"NtUserModifyWindowTouchCapability"//741
	,"NtUserNotifyIMEStatus"		 //742
	,"NtUserOpenInputDesktop"		 //743
	,"NtUserOpenThreadDesktop"		 //744
	,"NtUserPaintMonitor"			 //745
	,"NtUserPhysicalToLogicalPoint"	 //746
	,"NtUserPrintWindow"			 //747
	,"NtUserQueryDisplayConfig"		 //748
	,"NtUserQueryInformationThread"	 //749
	,"NtUserQueryInputContext"		 //750
	,"NtUserQuerySendMessage"		 //751
	,"NtUserRealChildWindowFromPoint"//752
	,"NtUserRealWaitMessageEx"		 //753
	,"NtUserRegisterErrorReportingDialog"//754
	,"NtUserRegisterHotKey"			 //755
	,"NtUserRegisterRawInputDevices" //756
	,"NtUserRegisterServicesProcess" //757
	,"NtUserRegisterSessionPort"	 //758
	,"NtUserRegisterTasklist"		 //759
	,"NtUserRegisterUserApiHook"	 //760
	,"NtUserRemoteConnect"			 //761
	,"NtUserRemoteRedrawRectangle"	 //762
	,"NtUserRemoteRedrawScreen"		 //763
	,"NtUserRemoteStopScreenUpdates" //764
	,"NtUserRemoveClipboardFormatListener"//765
	,"NtUserResolveDesktopForWOW"	 //766
	,"NtUserSendTouchInput"			 //767
	,"NtUserSetAppImeLevel"			 //768
	,"NtUserSetChildWindowNoActivate"//769
	,"NtUserSetClassWord"			 //770
	,"NtUserSetCursorContents"		 //771
	,"NtUserSetDisplayConfig"		 //772
	,"NtUserSetGestureConfig"		 //773
	,"NtUserSetImeHotKey"			 //774
	,"NtUserSetImeInfoEx"			 //775
	,"NtUserSetImeOwnerWindow"		 //776
	,"NtUserSetInternalWindowPos"	 //777
	,"NtUserSetLayeredWindowAttributes"	//778
	,"NtUserSetMenu"				 //779
	,"NtUserSetMenuContextHelpId"	 //780
	,"NtUserSetMenuFlagRtoL"		 //781
	,"NtUserSetMirrorRendering"		 //782
	,"NtUserSetObjectInformation"	 //783
	,"NtUserSetProcessDPIAware"		 //784
	,"NtUserSetShellWindowEx"		 //785
	,"NtUserSetSysColors"			 //786
	,"NtUserSetSystemCursor"		 //787
	,"NtUserSetSystemTimer"			 //788
	,"NtUserSetThreadLayoutHandles"	 //789
	,"NtUserSetWindowCompositionAttribute"//790
	,"NtUserSetWindowDisplayAffinity"//791
	,"NtUserSetWindowRgnEx"			 //792
	,"NtUserSetWindowStationUser"	 //793
	,"NtUserSfmDestroyLogicalSurfaceBinding"//794
	,"NtUserSfmDxBindSwapChain"		 //795
	,"NtUserSfmDxGetSwapChainStats"	 //796
	,"NtUserSfmDxOpenSwapChain"		 //797
	,"NtUserSfmDxQuerySwapChainBindingStatus"//798
	,"NtUserSfmDxReleaseSwapChain"	 //799
	,"NtUserSfmDxReportPendingBindingsToDwm"//800
	,"NtUserSfmDxSetSwapChainBindingStatus"//801
	,"NtUserSfmDxSetSwapChainStats"	 //802
	,"NtUserSfmGetLogicalSurfaceBinding"//803
	,"NtUserShowSystemCursor"		 //804
	,"NtUserSoundSentry"			 //805
	,"NtUserSwitchDesktop"			 //806
	,"NtUserTestForInteractiveUser"	 //807
	,"NtUserTrackPopupMenuEx"		 //808
	,"NtUserUnloadKeyboardLayout"	 //809
	,"NtUserUnlockWindowStation"	 //810
	,"NtUserUnregisterHotKey"		 //811
	,"NtUserUnregisterSessionPort"	 //812
	,"NtUserUnregisterUserApiHook"	 //813
	,"NtUserUpdateInputContext"		 //814
	,"NtUserUpdateInstance"			 //815
	,"NtUserUpdateLayeredWindow"	 //816
	,"NtUserUpdatePerUserSystemParameters"//817
	,"NtUserUpdateWindowTransform"	 //818
	,"NtUserUserHandleGrantAccess"	 //819
	,"NtUserValidateHandleSecure"	 //820
	,"NtUserWaitForInputIdle"		 //821
	,"NtUserWaitForMsgAndEvent"		 //822
	,"NtUserWindowFromPhysicalPoint" //823
	,"NtUserYieldTask"				 //824
	,"NtUserSetClassLongPtr"		 //825
	,"NtUserSetWindowLongPtr"		 //826
};
```

`arkProject/HeavenShadow/HeavenShadow/ServiceDlg.cpp`:

```cpp
// ServiceDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "ServiceDlg.h"
#include "afxdialogex.h"
#include "HeavenShadowDlg.h"
#include "Common.h"

#include "AlertWnd.h"


// CServiceDlg 对话框

IMPLEMENT_DYNAMIC(CServiceDlg, CDialog)

CServiceDlg::CServiceDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CServiceDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CServiceDlg::~CServiceDlg()
{
}

void CServiceDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_BUTTON_TEST2, m_demoBtn);
}


BEGIN_MESSAGE_MAP(CServiceDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
	ON_BN_CLICKED(IDC_BUTTON_TEST2, &CServiceDlg::OnBnClickedButtonTest2)
END_MESSAGE_MAP()


// CServiceDlg 消息处理程序



void CServiceDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()

	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(255,255,255));
}


BOOL CServiceDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CServiceDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	if (bShow == TRUE)
	{
		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_SERVICE;

		((CHeavenShadowDlg*)m_wParent)->m_btnServ.EnableWindow(FALSE);

		HsSendStatusDetail(L"系统服务正在加载。");
		HsSendStatusTip(L"服务");

	}

	
}


BOOL CServiceDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


void CServiceDlg::OnBnClickedButtonTest2()
{
	// TODO: 在此添加控件通知处理程序代码

	CAlertWnd *dlg = new CAlertWnd(this);

	dlg->Create(IDD_DIALOG_ALERT,GetDesktopWindow());

	dlg->ShowWindow(SW_SHOW);
}

```

`arkProject/HeavenShadow/HeavenShadow/ServiceDlg.h`:

```h
#pragma once
#include "afxwin.h"


// CServiceDlg 对话框

class CServiceDlg : public CDialog
{
	DECLARE_DYNAMIC(CServiceDlg)

public:
	CServiceDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CServiceDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_SERVICE };


	CWnd* m_wParent;



protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnPaint();
	CButton m_demoBtn;
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnBnClickedButtonTest2();
};

```

`arkProject/HeavenShadow/HeavenShadow/SettingDlg.cpp`:

```cpp
// SettingDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "SettingDlg.h"
#include "afxdialogex.h"

#include "HeavenShadowDlg.h"


// CSettingDlg 对话框

IMPLEMENT_DYNAMIC(CSettingDlg, CDialog)

CSettingDlg::CSettingDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSettingDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CSettingDlg::~CSettingDlg()
{
}

void CSettingDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CSettingDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
END_MESSAGE_MAP()


// CSettingDlg 消息处理程序


void CSettingDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()

	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(255,255,255));
}


BOOL CSettingDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


BOOL CSettingDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CSettingDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	if (bShow == TRUE)
	{
		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_SETTING;

		((CHeavenShadowDlg*)m_wParent)->m_btnSet.EnableWindow(FALSE);



		HsSendStatusDetail(L"对天影卫士进行详细设置。");
		HsSendStatusTip(L"设置");
	}
}

```

`arkProject/HeavenShadow/HeavenShadow/SettingDlg.h`:

```h
#pragma once


// CSettingDlg 对话框

class CSettingDlg : public CDialog
{
	DECLARE_DYNAMIC(CSettingDlg)

public:
	CSettingDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CSettingDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_SETTING };

	CWnd* m_wParent;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnPaint();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
};

```

`arkProject/HeavenShadow/HeavenShadow/SysThread.cpp`:

```cpp
#include "stdafx.h"
#include "SysThread.h"
#include "Common.h"
#include "ModuleFunc.h"
#include "ThreadFunc.h"
#include "SSDTFunc.h"
#include <vector>

#include "ProcessFunc.h"

using namespace std;


extern HANDLE g_hDevice;
extern WIN_VERSION WinVersion;
extern BOOL bIsChecking;

COLUMNSTRUCT g_Column_SysThread[] = 
{
	{	L"线程ID",				50	},
	{	L"线程对象",				125	},
	{	L"Peb",					35	},
	{	L"优先级",				55	},
	{	L"线程入口",				125	},
	{	L"切换次数",				65	},
	{	L"线程状态",				100	},
	{	L"模块文件",				190	},
	{	L"出品厂商",				125	}
};

extern vector<THREAD_INFO> m_vectorThread;
extern vector<DRIVER_INFO> m_DriverList;
ULONG_PTR m_ulSYSThreadCount = 0;

UINT g_Column_SysThread_Count = 9;


extern int dpix;
extern int dpiy;


VOID HsInitSysThreadList(CListCtrl *m_ListCtrl)
{
	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_SysThread_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_SysThread[i].szTitle,LVCFMT_LEFT,(int)(g_Column_SysThread[i].nWidth*(dpix/96.0)));
	}
}



VOID HsLoadSysThreadList(CListCtrl *m_ListCtrl)
{
	if (bIsChecking == TRUE)
	{
		return;
	}

	// 	while(bIsChecking == TRUE)
	// 	{
	// 		Sleep(10);
	// 	}

	bIsChecking = TRUE;

	HsSendStatusDetail(L"内核线程正在加载...");
	HsSendStatusTip(L"内核线程");

	HsQuerySysThreadList(m_ListCtrl);

	bIsChecking = FALSE;
}



VOID HsQuerySysThreadList(CListCtrl *m_ListCtrl)
{
	m_ulSYSThreadCount = 0;

	m_vectorThread.clear();
	m_DriverList.clear();

	BOOL bRet = FALSE;

	bRet = EnumDriver();

	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"驱动模块加载失败。");
		return;
	}

	bRet = HsGetSYSThread(m_ListCtrl);

	if (bRet == FALSE)
	{
		HsSendStatusDetail(L"内核线程加载失败。");
		return;
	}

	for (vector <THREAD_INFO>::iterator Iter = m_vectorThread.begin( ); 
		Iter != m_vectorThread.end( ); 
		Iter++ )
	{
		THREAD_INFO ThreadInfor = *Iter;

		if (ThreadInfor.State == Terminated)
		{
			return;
		}

		CString strTid, strEThread, strTeb, strPriority, strWin32StartAddress, strContextSwitches, strState, strModule;

		strTid.Format(L"%d", ThreadInfor.Tid);
		strEThread.Format(L"0x%08p", ThreadInfor.Thread);
		if (ThreadInfor.Teb == 0)
		{
			strTeb = L"-";
		}
		else
		{
			strTeb.Format(L"0x%08p", ThreadInfor.Teb);
		}

		strPriority.Format(L"%d", ThreadInfor.Priority);
		strWin32StartAddress.Format(L"0x%08p", ThreadInfor.Win32StartAddress);
		strContextSwitches.Format(L"%d", ThreadInfor.ContextSwitches);

		strModule = GetDriverPath(ThreadInfor.Win32StartAddress);

		switch (ThreadInfor.State)
		{
		case Initialized:
			{
				strState = L"Initialized";
				break;
			}
		case Ready:
			{
				strState = L"Ready";
				break;
			}
		case Running:
			{
				strState = L"Running";
				break;

			}
		case Standby:
			{
				strState = L"Standby";
				break;

			}
		case Terminated:
			{
				strState = L"Terminated";
				break;

			}
		case Waiting:
			{
				strState = L"Waiting";
				break;

			}
		case Transition:
			{
				strState = L"Transition";
				break;
			}

		case DeferredReady:
			{
				strState = L"Deferred Ready";
				break;

			}
		case GateWait:
			{
				strState = L"Gate Wait";
				break;

			}
		default:
			{
				strState = L"UnKnown";
				break;
			}
		}

		int n = m_ListCtrl->GetItemCount();
		int j = m_ListCtrl->InsertItem(n,strTid);
		m_ListCtrl->SetItemText(j, ThreadObject, strEThread);
		m_ListCtrl->SetItemText(j, ThreadTeb, strTeb);
		m_ListCtrl->SetItemText(j, ThreadPriority, strPriority);
		m_ListCtrl->SetItemText(j, ThreadStartAddress, strWin32StartAddress);
		m_ListCtrl->SetItemText(j, ThreadSwitchTimes, strContextSwitches);
		m_ListCtrl->SetItemText(j, ThreadStatus, strState);
		m_ListCtrl->SetItemText(j, ThreadStartModule, strModule);


		CString strComp;
		strComp = HsGetFileCompanyName(strModule);

		m_ListCtrl->SetItemText(j,ThreadComp, strComp);
		m_ListCtrl->SetItemData(j,j);

		m_ulSYSThreadCount++;

		CString StatusBarContext;
		StatusBarContext.Format(L"内核线程正在加载。 线程数：%d",m_ulSYSThreadCount);

		HsSendStatusDetail(StatusBarContext);
	}

	CString StatusBarContext;
	StatusBarContext.Format(L"内核线程加载完成。 线程数：%d",m_ulSYSThreadCount);

	HsSendStatusDetail(StatusBarContext);

}


BOOL HsGetSYSThread(CListCtrl *m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	m_vectorThread.clear();


	BOOL bRet = FALSE;
	DWORD ulReturnSize = 0;

	ULONG_PTR ulCnt = 1000;
	PALL_THREADS AllThreads = NULL;
	do 
	{
		ULONG_PTR ulSize = 0;

		if (AllThreads)
		{
			free(AllThreads);
			AllThreads = NULL;
		}

		ulSize = sizeof(ALL_THREADS) + ulCnt * sizeof(THREAD_INFO);

		AllThreads = (PALL_THREADS)malloc(ulSize);
		if (!AllThreads)
		{
			break;
		}

		memset(AllThreads, 0, ulSize);

		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_SYSK_SYSTHREAD),
			NULL,
			0,
			AllThreads,
			(DWORD)ulSize,
			&ulReturnSize,
			NULL);

		ulCnt = AllThreads->nCnt + 100;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && AllThreads->nCnt > 0)
	{
		for (ULONG i = 0; i < AllThreads->nCnt; i++)
		{
			m_vectorThread.push_back(AllThreads->Threads[i]);
		}
	}

	if (AllThreads)
	{
		free(AllThreads);
		AllThreads = NULL;
	}

	if (!m_vectorThread.empty())
	{
		return TRUE;
	}

	return FALSE;
}
```

`arkProject/HeavenShadow/HeavenShadow/SysThread.h`:

```h
#pragma once
#include "stdafx.h"




VOID HsInitSysThreadList(CListCtrl *m_ListCtrl);

VOID HsLoadSysThreadList(CListCtrl *m_ListCtrl);

VOID HsQuerySysThreadList(CListCtrl *m_ListCtrl);

BOOL HsGetSYSThread(CListCtrl *m_ListCtrl);

```

`arkProject/HeavenShadow/HeavenShadow/SystemDlg.cpp`:

```cpp
// SystemDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "SystemDlg.h"
#include "afxdialogex.h"

#include "SysThread.h"
#include "IoTimerFunc.h"
#include "CallbackFunc.h"
#include "DpcTimerFunc.h"
#include "FilterDriverFunc.h"

#include "HeavenShadowDlg.h"

enum HS_SYSK_LIST
{
	HS_SYSK_CALLBACK,
	HS_SYSK_IOTIMER,
	HS_SYSK_DPCTIMER,
	HS_SYSK_FILTERDRIVER,
	HS_SYSK_SYSTHREAD,
};

extern int dpix;
extern int dpiy;

extern BOOL bIsChecking;

BOOL bNowSystemSel = 255;


// CSystemDlg 对话框

IMPLEMENT_DYNAMIC(CSystemDlg, CDialog)

CSystemDlg::CSystemDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSystemDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CSystemDlg::~CSystemDlg()
{
}

void CSystemDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_SYSTEM, m_ListSystem);
	DDX_Control(pDX, IDC_LIST_SYSTEM_CTRL, m_ListSystemCtrl);
}


BEGIN_MESSAGE_MAP(CSystemDlg, CDialog)
	ON_WM_SHOWWINDOW()
	ON_WM_PAINT()
	ON_LBN_SELCHANGE(IDC_LIST_SYSTEM, &CSystemDlg::OnSelchangeListSystem)
	ON_NOTIFY(NM_RCLICK, IDC_LIST_SYSTEM_CTRL, &CSystemDlg::OnRclickListSystemCtrl)
	ON_COMMAND(ID_MENU_SYSK_IOTIMER_REFRESH, &CSystemDlg::OnMenuSyskIoTimerRefresh)
	ON_COMMAND(ID_MENU_SYSK_IOTIMER_OPER, &CSystemDlg::OnMenuSyskOperiotimer)
	ON_COMMAND(ID_MENU_SYSK_CALLBACK_REFRESH, &CSystemDlg::OnMenuSyskCallbackRefresh)
	ON_COMMAND(ID_MENU_SYSK_CALLBACK_REMOVE, &CSystemDlg::OnMenuSyskCallbackRemove)
	ON_COMMAND(ID_MENU_SYSK_IOTIMER_REMOVE, &CSystemDlg::OnMenuSyskRemoveiotimer)
	ON_COMMAND(ID_MENU_SYSK_DPCTIMER_REFRESH, &CSystemDlg::OnMenuSyskDpctimerRefresh)
	ON_COMMAND(ID_MENU_SYSK_DPCTIMER_REMOVE, &CSystemDlg::OnMenuSyskDpctimerRemove)
	ON_COMMAND(ID_MENU_SYSK_FILTER_REFRESH, &CSystemDlg::OnMenuSyskFilterRefresh)
	ON_COMMAND(ID_MENU_SYSK_FILTER_REMOVEFILTER, &CSystemDlg::OnMenuSyskFilterRemovefilter)
END_MESSAGE_MAP()


// CSystemDlg 消息处理程序


BOOL CSystemDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


BOOL CSystemDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	InitSystemList();

	UINT uIconSize = 20;

	uIconSize *= (UINT)(dpix/96.0);

	m_TreeSystemImageList.Create(1, uIconSize, ILC_COLOR32 | ILC_MASK, 2, 2);

	ListView_SetImageList(m_ListSystemCtrl.m_hWnd, m_TreeSystemImageList.GetSafeHandle(), LVSIL_SMALL);

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


void CSystemDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	// TODO: 在此处添加消息处理程序代码

	if (bShow == TRUE)
	{
		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_SYSTEM;

		((CHeavenShadowDlg*)m_wParent)->m_btnSys.EnableWindow(FALSE);

		HsSendStatusDetail(L"显示操作系统内核相关信息。");
		HsSendStatusTip(L"内核");

		m_ListSystem.SetCurSel(0);

		bNowSystemSel = 255;

		OnSelchangeListSystem();

		m_ListSystemCtrl.SetFocus();
	}
}


void CSystemDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()


	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(255,255,255));

	CRect SystemListRect;
	CRect SystemCtrlRect;

	//m_ListKernel.GetClientRect(KernelListRect);
	m_ListSystem.GetWindowRect(&SystemListRect);
	ClientToScreen(&rect);
	SystemListRect.left -= rect.left;
	SystemListRect.right -= rect.left;
	SystemListRect.top -= rect.top;
	SystemListRect.bottom -= rect.top;
	SystemListRect.bottom = rect.Height() - 2;
	//m_ListKernel.MoveWindow(&KernelListRect);

	CPoint startPoint;
	startPoint.x = (LONG)(SystemListRect.right)+2;
	startPoint.y = -1;
	CPoint endPoint;
	endPoint.x = (LONG)(SystemListRect.right)+2;
	endPoint.y = rect.Height()+2;

	SystemCtrlRect.left = startPoint.x+1;
	SystemCtrlRect.right = rect.Width();
	SystemCtrlRect.top = 0;
	SystemCtrlRect.bottom = rect.Height();
	m_ListSystemCtrl.MoveWindow(SystemCtrlRect);

	// 	CPoint startPoint;
	// 	startPoint.x = (UINT)(98*(dpix/96.0))+2;
	// 	startPoint.y = -1;
	// 	CPoint endPoint;
	// 	endPoint.x = (UINT)(98*(dpix/96.0))+2;
	// 	endPoint.y = rect.Height()+2;


	COLORREF m_Color(RGB(190,190,190));

	CClientDC aDC(this);			//CClientDC的构造函数需要一个参数，这个参数是指向绘图窗口的指针，我们用this指针就可以了
	CPen pen(PS_SOLID,1,m_Color);	//建立一个画笔类对象，构造时设置画笔属性
	aDC.SelectObject(&pen);
	aDC.MoveTo(startPoint);
	aDC.LineTo(endPoint);
}




void CSystemDlg::InitSystemList(void)
{
	m_ListSystem.AddString(L"系统回调");
	m_ListSystem.InsertString(HS_SYSK_IOTIMER,L"IOPTimer");
	m_ListSystem.InsertString(HS_SYSK_DPCTIMER,L"DPCTimer");
	m_ListSystem.InsertString(HS_SYSK_FILTERDRIVER,L"过滤驱动");
	m_ListSystem.InsertString(HS_SYSK_SYSTHREAD,L"内核线程");
	
	m_ListSystem.SetItemHeight(-1,(UINT)(16*(dpiy/96.0)));
}

void CSystemDlg::OnSelchangeListSystem()
{
	// TODO: 在此添加控件通知处理程序代码

	int nCurSel = m_ListSystem.GetCurSel();

	switch(nCurSel)
	{
	case HS_SYSK_CALLBACK:
		{
			if (bIsChecking == TRUE || bNowSystemSel == HS_SYSK_CALLBACK)	//
			{
				m_ListSystem.SetCurSel(bNowSystemSel);
				m_ListSystemCtrl.SetFocus();
				return;
			}

			bNowSystemSel = nCurSel;

			HsInitCallBackList(&m_ListSystemCtrl);

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsLoadCallBackList,&m_ListSystemCtrl, 0,NULL)
				);
			//HsLoadCallBackList(&m_ListSystemCtrl);

			break;
		}
	case HS_SYSK_IOTIMER:
		{
			if (bIsChecking == TRUE || bNowSystemSel == HS_SYSK_IOTIMER)	//
			{
				m_ListSystem.SetCurSel(bNowSystemSel);
				m_ListSystemCtrl.SetFocus();
				return;
			}

			bNowSystemSel = nCurSel;

			HsInitIOTimerList(&m_ListSystemCtrl);

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsLoadIOTimerList,&m_ListSystemCtrl, 0,NULL)
				);
			//HsLoadIOTimerList(&m_ListSystemCtrl);

			break;
		}
	case HS_SYSK_DPCTIMER:
		{
			if (bIsChecking == TRUE || bNowSystemSel == HS_SYSK_DPCTIMER)	//
			{
				m_ListSystem.SetCurSel(bNowSystemSel);
				m_ListSystemCtrl.SetFocus();
				return;
			}

			bNowSystemSel = nCurSel;

			HsInitDPCTimerList(&m_ListSystemCtrl);

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsLoadDPCTimerList,&m_ListSystemCtrl, 0,NULL)
				);
			//HsLoadDPCTimerList(&m_ListSystemCtrl);

			break;
		}
	case HS_SYSK_FILTERDRIVER:
		{
			if (bIsChecking == TRUE || bNowSystemSel == HS_SYSK_FILTERDRIVER)	//
			{
				m_ListSystem.SetCurSel(bNowSystemSel);
				m_ListSystemCtrl.SetFocus();
				return;
			}

			bNowSystemSel = nCurSel;

			HsInitFilterDriverList(&m_ListSystemCtrl);

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsLoadFilterDriverList,&m_ListSystemCtrl, 0,NULL)
				);
			//HsLoadFilterDriverList(&m_ListSystemCtrl);

			break;
		}
	case HS_SYSK_SYSTHREAD:
		{
			if (bIsChecking == TRUE || bNowSystemSel == HS_SYSK_SYSTHREAD)	//
			{
				m_ListSystem.SetCurSel(bNowSystemSel);
				m_ListSystemCtrl.SetFocus();
				return;
			}

			bNowSystemSel = nCurSel;

			HsInitSysThreadList(&m_ListSystemCtrl);

			CloseHandle(
				CreateThread(NULL,0, 
				(LPTHREAD_START_ROUTINE)HsLoadSysThreadList,&m_ListSystemCtrl, 0,NULL)
				);
			//HsLoadSysThreadList(&m_ListSystemCtrl);

			break;
		}
	default:
		{

		}
	}

	m_ListSystemCtrl.SetFocus();
}


void CSystemDlg::OnRclickListSystemCtrl(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码

	CMenu	popup;
	CPoint	p;

	switch(bNowSystemSel)
	{
	case HS_SYSK_IOTIMER:
		{
			popup.LoadMenu(IDR_MENU_SYSK_IOTIMER);			//加载菜单资源
			CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项

			GetCursorPos(&p);
			int	count = pM->GetMenuItemCount();
			if (m_ListSystemCtrl.GetSelectedCount() == 0)		//如果没有选中
			{ 
				for (int i = 1;i<count;i++)
				{
					pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}

			POSITION pos = m_ListSystemCtrl.GetFirstSelectedItemPosition();

			while (pos)
			{
				int nItem = m_ListSystemCtrl.GetNextSelectedItem(pos);

				if (_wcsnicmp(L"运行",m_ListSystemCtrl.GetItemText(nItem,2),wcslen(L"运行"))==0)
				{
					pM->ModifyMenuW(ID_MENU_SYSK_IOTIMER_OPER,MF_BYCOMMAND,ID_MENU_SYSK_IOTIMER_OPER,L"停止(&S)");
				}
				else if (_wcsnicmp(L"停止",m_ListSystemCtrl.GetItemText(nItem,2),wcslen(L"停止"))==0)
				{
					pM->ModifyMenuW(ID_MENU_SYSK_IOTIMER_OPER,MF_BYCOMMAND,ID_MENU_SYSK_IOTIMER_OPER,L"运行(&S)");
				}
			}

			pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);
			break;
		}
	case HS_SYSK_CALLBACK:
		{
			popup.LoadMenu(IDR_MENU_SYSK_CALLBACK);			//加载菜单资源
			CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项

			GetCursorPos(&p);
			int	count = pM->GetMenuItemCount();
			if (m_ListSystemCtrl.GetSelectedCount() == 0)		//如果没有选中
			{ 
				for (int i = 1;i<count;i++)
				{
					pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}

			pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);
			break;
		}
	case HS_SYSK_DPCTIMER:
		{
			popup.LoadMenu(IDR_MENU_SYSK_DPCTIMER);			//加载菜单资源
			CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项

			GetCursorPos(&p);
			int	count = pM->GetMenuItemCount();
			if (m_ListSystemCtrl.GetSelectedCount() == 0)		//如果没有选中
			{ 
				for (int i = 1;i<count;i++)
				{
					pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}

			pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);
			break;
		}
	case HS_SYSK_FILTERDRIVER:
		{
			popup.LoadMenu(IDR_MENU_SYSK_FILTERDRIVER);		//加载菜单资源
			CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项

			GetCursorPos(&p);
			int	count = pM->GetMenuItemCount();
			if (m_ListSystemCtrl.GetSelectedCount() == 0)		//如果没有选中
			{ 
				for (int i = 1;i<count;i++)
				{
					pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
				}
			}

			pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, this);
			break;
		}
	default:
		{

		}
	}


	*pResult = 0;
}


void CSystemDlg::OnMenuSyskIoTimerRefresh()
{
	// TODO: 在此添加命令处理程序代码
	m_ListSystem.SetCurSel(HS_SYSK_IOTIMER);
	bNowSystemSel = 255;
	OnSelchangeListSystem();
}


void CSystemDlg::OnMenuSyskOperiotimer()
{
	// TODO: 在此添加命令处理程序代码
	if (bIsChecking)
	{
		return;
	}

	bIsChecking = TRUE;

	CloseHandle(
		CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsOperIOTimer,&m_ListSystemCtrl, 0,NULL)
		);
	//HsOperIOTimer(&m_ListSystemCtrl);
}


void CSystemDlg::OnMenuSyskCallbackRefresh()
{
	// TODO: 在此添加命令处理程序代码
	m_ListSystem.SetCurSel(HS_SYSK_CALLBACK);
	bNowSystemSel = 255;
	OnSelchangeListSystem();
}


void CSystemDlg::OnMenuSyskCallbackRemove()
{
	// TODO: 在此添加命令处理程序代码
	if (bIsChecking)
	{
		return;
	}

	bIsChecking = TRUE;

	CloseHandle(
		CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsRemoveCallBackItem,&m_ListSystemCtrl, 0,NULL)
		);
	//HsRemoveCallBackItem(&m_ListSystemCtrl);
}


void CSystemDlg::OnMenuSyskRemoveiotimer()
{
	// TODO: 在此添加命令处理程序代码

	BOOL bRet = MessageBox(L"删除IOTimer操作可能会造成系统异常或崩溃，\r\n请在确认后继续。",L"天影卫士",MB_ICONWARNING | MB_OKCANCEL);

	if (bRet == IDCANCEL)
	{
		return;
	}

	if (bIsChecking == TRUE)
	{
		return;
	}

	bIsChecking = TRUE;

	CloseHandle(
		CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsRemoveIOTimerItem,&m_ListSystemCtrl, 0,NULL)
		);
	//HsRemoveIOTimerItem(&m_ListSystemCtrl);
}


void CSystemDlg::OnMenuSyskDpctimerRefresh()
{
	// TODO: 在此添加命令处理程序代码
	m_ListSystem.SetCurSel(HS_SYSK_DPCTIMER);
	bNowSystemSel = 255;
	OnSelchangeListSystem();
}


void CSystemDlg::OnMenuSyskDpctimerRemove()
{
	// TODO: 在此添加命令处理程序代码
	BOOL bRet = MessageBox(L"删除DPCTimer操作可能会造成系统异常或崩溃，\r\n请在确认后继续。",L"天影卫士",MB_ICONWARNING | MB_OKCANCEL);

	if (bRet == IDCANCEL)
	{
		return;
	}

	if (bIsChecking == TRUE)
	{
		return;
	}

	bIsChecking = TRUE;

	CloseHandle(
		CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsRemoveDPCTimerItem,&m_ListSystemCtrl, 0,NULL)
		);
	//HsRemoveDPCTimerItem(&m_ListSystemCtrl);
}


void CSystemDlg::OnMenuSyskFilterRefresh()
{
	// TODO: 在此添加命令处理程序代码
	m_ListSystem.SetCurSel(HS_SYSK_FILTERDRIVER);
	bNowSystemSel = 255;
	OnSelchangeListSystem();
}


void CSystemDlg::OnMenuSyskFilterRemovefilter()
{
	// TODO: 在此添加命令处理程序代码
	BOOL bRet = MessageBox(L"卸载过滤驱动操作可能会造成系统异常或崩溃，\r\n请在确认后继续。",L"天影卫士",MB_ICONWARNING | MB_OKCANCEL);

	if (bRet == IDCANCEL)
	{
		return;
	}

	if (bIsChecking == TRUE)
	{
		return;
	}

	bIsChecking = TRUE;

	CloseHandle(
		CreateThread(NULL,0, 
		(LPTHREAD_START_ROUTINE)HsRemoveFilterDriverItem,&m_ListSystemCtrl, 0,NULL)
		);
	//HsRemoveFilterDriverItem(&m_ListSystemCtrl);
}

```

`arkProject/HeavenShadow/HeavenShadow/SystemDlg.h`:

```h
#pragma once
#include "afxwin.h"
#include "afxcmn.h"


// CSystemDlg 对话框

class CSystemDlg : public CDialog
{
	DECLARE_DYNAMIC(CSystemDlg)

public:
	CSystemDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CSystemDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_SYSTEM };

	CWnd* m_wParent;

	void InitSystemList(void);

	CImageList m_TreeSystemImageList;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnPaint();
	CXTPEditListBox m_ListSystem;
	CListCtrl m_ListSystemCtrl;
	afx_msg void OnSelchangeListSystem();
	afx_msg void OnRclickListSystemCtrl(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuSyskIoTimerRefresh();
	afx_msg void OnMenuSyskOperiotimer();
	afx_msg void OnMenuSyskCallbackRefresh();
	afx_msg void OnMenuSyskCallbackRemove();
	afx_msg void OnMenuSyskRemoveiotimer();
	afx_msg void OnMenuSyskDpctimerRefresh();
	afx_msg void OnMenuSyskDpctimerRemove();
	afx_msg void OnMenuSyskFilterRefresh();
	afx_msg void OnMenuSyskFilterRemovefilter();
};

```

`arkProject/HeavenShadow/HeavenShadow/ThreadFunc.cpp`:

```cpp
#include "stdafx.h"
#include "ThreadFunc.h"
#include "Common.h"
#include "resource.h"

#include <stdio.h>
#include <vector>

using namespace std;


vector<THREAD_INFO> m_vectorThread;
vector<MODULE_INFO> m_vectorModule;
extern ULONG_PTR g_ulProcessId;
extern HANDLE g_hDevice;

COLUMNSTRUCT g_Column_Thread[] = 
{
	{	L"线程ID",			50	},
	{	L"ETHREAD",			125	},
	{	L"Teb",				125	},
	{	L"优先级",			54	},
	{	L"线程入口",			125	},
	{	L"模块",				90	},
	{	L"切换次数",			68	},
	{	L"状态",				50	}
};

UINT g_Column_Thread_Count  = 8;	  //进程列表列数

extern int dpix;
extern int dpiy;



void HsInitThreadList(CMyList *m_ListCtrl)
{

	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_Thread_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_Thread[i].szTitle,LVCFMT_LEFT,(int)(g_Column_Thread[i].nWidth*(dpix/96.0)));
	}
}


BOOL HsQueryProcessThread(CMyList *m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();
	m_vectorThread.clear();

	ULONG ulReturnSize = 0;
	BOOL bRet = FALSE;

	UINT m_Pid = (UINT)g_ulProcessId;

	

	if (m_Pid == 0)
	{
		return bRet;
	}

	m_vectorThread.clear();

	ULONG ulCount = 1000;
	PALL_THREADS Threads = NULL;

	do 
	{
		ULONG ulSize = 0;

		if (Threads)
		{
			free(Threads);
			Threads = NULL;
		}

		ulSize = sizeof(ALL_THREADS) + ulCount * sizeof(THREAD_INFO);

		Threads = (PALL_THREADS)malloc(ulSize);
		if (!Threads)
		{
			break;
		}

		memset(Threads,0,ulSize);


		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSTHREAD),
			&m_Pid,
			sizeof(ULONG),
			Threads,
			ulSize,
			&ulReturnSize,
			NULL);

		ulCount = (ULONG)(Threads->nCnt + 100);

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && Threads->nCnt > 0)
	{
		for (ULONG i = 0;i<Threads->nCnt; i++)
		{
			m_vectorThread.push_back(Threads->Threads[i]);
		}
	}

	if (Threads)
	{
		free(Threads);
		Threads = NULL;
	}

	if (m_vectorThread.empty())
	{
		return FALSE;
	}

	//////////////////////////////////////////////////////////////////////////

	ulCount = 0x10;
	PALL_MODULES AllModules = NULL;

	do 
	{

		ULONG ulSize = 0;

		if (AllModules)
		{
			free(AllModules);
			AllModules = NULL;
		}

		ulSize = sizeof(ALL_MODULES) + ulCount * sizeof(MODULE_INFO);

		AllModules = (PALL_MODULES)malloc(ulSize);
		if (!AllModules)
		{
			break;
		}

		memset(AllModules,0,ulSize);


		bRet = DeviceIoControl(g_hDevice,HS_IOCTL(HS_IOCTL_PROC_PROCESSTHREADMODULE),
			&m_Pid,
			sizeof(ULONG_PTR),
			AllModules,
			ulSize,
			&ulReturnSize,
			NULL);


		ulCount = (ULONG)(AllModules->ulCount + 1000);

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);


	if (bRet && AllModules->ulCount > 0)
	{

		for (ULONG i=0;i<AllModules->ulCount;i++)
		{
			MODULE_INFO Temp;

			Temp.Base = AllModules->Modules[i].Base;
			Temp.Size = AllModules->Modules[i].Size;
			CString szPath = TrimPath(AllModules->Modules[i].Path);

			wcsncpy_s(Temp.Path, MAX_PATH, szPath.GetBuffer(), szPath.GetLength());
			szPath.ReleaseBuffer();

			m_vectorModule.push_back(Temp);

		}
	}


	if (AllModules!=NULL)
	{
		free(AllModules);
		AllModules = NULL;
	}

	//////////////////////////////////////////////////////////////////////////

	for (vector <THREAD_INFO>::iterator Iter = m_vectorThread.begin( ); 
		Iter != m_vectorThread.end( ); 
		Iter++ )
	{
		THREAD_INFO ThreadInfor = (THREAD_INFO)*Iter;
		if (ThreadInfor.State == Terminated)
		{
			return FALSE;
		}

		CString strTid, strEThread, strTeb, strPriority, strWin32StartAddress, strContextSwitches, strState, strModule;

		strTid.Format(L"%d", ThreadInfor.Tid);
		strEThread.Format(L"0x%08p", ThreadInfor.Thread);
		if (ThreadInfor.Teb == 0)
		{
			strTeb = L"-";
		}
		else
		{
			strTeb.Format(L"0x%08p", ThreadInfor.Teb);
		}

		strPriority.Format(L"%d", ThreadInfor.Priority);
		strWin32StartAddress.Format(L"0x%08p", ThreadInfor.Win32StartAddress);
		strContextSwitches.Format(L"%d", ThreadInfor.ContextSwitches);

		strModule = GetModulePathByThreadStartAddress(ThreadInfor.Win32StartAddress);

		if (strModule.GetLength()<=1)
		{
			strModule = L"\\ ";
		}

		WCHAR* Temp = NULL;

		Temp = wcsrchr(strModule.GetBuffer(),L'\\');

		if (Temp != NULL)
		{
			Temp++;
		}

		strModule = Temp;

		switch (ThreadInfor.State)
		{
		case Initialized:
			{
				strState = L"预置";
				break;
			}
		case Ready:
			{
				strState = L"就绪";
				break;
			}
		case Running:
			{
				strState = L"运行";
				break;

			}
		case Standby:
			{
				strState = L"备用";
				break;

			}
		case Terminated:
			{
				strState = L"终止";
				break;

			}
		case Waiting:
			{
				strState = L"等待";
				break;

			}
		case Transition:
			{
				strState = L"过度";
				break;
			}

		case DeferredReady:
			{
				strState = L"延迟就绪";
				break;

			}
		case GateWait:
			{
				strState = L"门等待";
				break;

			}
		default:
			{
				strState = L"未知";
				break;
			}
		}

		int n = m_ListCtrl->GetItemCount();
		int j = m_ListCtrl->InsertItem(n,strTid);
		m_ListCtrl->SetItemText(j, HS_THREAD_COLUMN_ETHREAD, strEThread);
		m_ListCtrl->SetItemText(j, HS_THREAD_COLUMN_TEB, strTeb);
		m_ListCtrl->SetItemText(j, HS_THREAD_COLUMN_PRIORITY, strPriority);
		m_ListCtrl->SetItemText(j, HS_THREAD_COLUMN_ENTRANCE, strWin32StartAddress);
		m_ListCtrl->SetItemText(j, HS_THREAD_COLUMN_COUNTER, strContextSwitches);
		m_ListCtrl->SetItemText(j, HS_THREAD_COLUMN_STATUS, strState);
		m_ListCtrl->SetItemText(j, HS_THREAD_COLUMN_MODULE, strModule);
		m_ListCtrl->SetItemData(j,j);

	}

	return bRet;
}



CString GetModulePathByThreadStartAddress(ULONG_PTR ulBase)
{
	CString szRet = L"";


	for ( vector <MODULE_INFO>::iterator Iter = m_vectorModule.begin( ); 
		Iter != m_vectorModule.end( ); 
		Iter++)
	{	
		MODULE_INFO entry = *Iter;
		if (ulBase >= entry.Base && ulBase <= (entry.Base + entry.Size))
		{
			szRet = entry.Path;
		}
	}




	//如果不进入循环 就说明是内核模块
	return szRet;
}






//权限界面弹出菜单
VOID HsProcessThreadPopupMenu(CMyList *m_ListCtrl, CWnd* parent)
{
	CMenu	popup;
	popup.LoadMenu(IDR_MENU_PROCESS_THREAD);		//加载菜单资源
	CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项
	CPoint	p;
	GetCursorPos(&p);
	int	count = pM->GetMenuItemCount();
	if (m_ListCtrl->GetSelectedCount() == 0)		//如果没有选中
	{ 
		for (int i = 0;i<count;i++)
		{
			pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
		}
	}

	pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, parent);
}

```

`arkProject/HeavenShadow/HeavenShadow/ThreadFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"

enum HS_THREAD_COLUMN
{
	HS_THREAD_COLUMN_TID = 0,
	HS_THREAD_COLUMN_ETHREAD,
	HS_THREAD_COLUMN_TEB,
	HS_THREAD_COLUMN_PRIORITY,
	HS_THREAD_COLUMN_ENTRANCE,
	HS_THREAD_COLUMN_MODULE,
	HS_THREAD_COLUMN_COUNTER,
	HS_THREAD_COLUMN_STATUS
};

typedef struct _THREAD_INFO_
{
	ULONG_PTR Thread;
	ULONG_PTR Tid;
	ULONG_PTR Teb;
	UCHAR Priority;
	ULONG_PTR Win32StartAddress;
	ULONG ContextSwitches;
	UCHAR State;
}THREAD_INFO, *PTHREAD_INFO;

typedef struct _ALL_THREADS_
{
	ULONG_PTR    nCnt;
	THREAD_INFO Threads[1];
}ALL_THREADS, *PALL_THREADS;



typedef enum _KTHREAD_STATE
{
	Initialized,
	Ready,
	Running,
	Standby,
	Terminated,
	Waiting,
	Transition,
	DeferredReady,
	GateWait
} KTHREAD_STATE, *PKTHREAD_STATE;




typedef enum _THREAD_HEADER_INDEX_
{
	ThreadId,
	ThreadObject,
	ThreadTeb,
	ThreadPriority,
	ThreadStartAddress,
	ThreadSwitchTimes,
	ThreadStatus,
	ThreadStartModule,
	ThreadComp
}THREAD_HEADER_INDEX;





typedef struct _MODULE_INFO_
{
	ULONG_PTR Base;
	ULONG_PTR Size;
	WCHAR Path[MAX_PATH]; 
}MODULE_INFO, *PMODULE_INFO;

typedef struct _ALL_MODULES_
{
	ULONG_PTR   ulCount;
	MODULE_INFO Modules[1];
}ALL_MODULES, *PALL_MODULES;




void HsInitThreadList(CMyList *m_ListCtrl);

BOOL HsQueryProcessThread(CMyList *m_ListCtrl);

CString GetModulePathByThreadStartAddress(ULONG_PTR ulBase);

VOID HsProcessThreadPopupMenu(CMyList *m_ListCtrl, CWnd* parent);
```

`arkProject/HeavenShadow/HeavenShadow/ToolsDlg.cpp`:

```cpp
// ToolsDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "HeavenShadow.h"
#include "ToolsDlg.h"
#include "afxdialogex.h"

#include "HeavenShadowDlg.h"

// CToolsDlg 对话框

IMPLEMENT_DYNAMIC(CToolsDlg, CDialog)

CToolsDlg::CToolsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CToolsDlg::IDD, pParent)
{
	m_wParent = pParent;
}

CToolsDlg::~CToolsDlg()
{
}

void CToolsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CToolsDlg, CDialog)
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
END_MESSAGE_MAP()


// CToolsDlg 消息处理程序


BOOL CToolsDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO:  在此添加额外的初始化

	return TRUE;  // return TRUE unless you set the focus to a control
	// 异常: OCX 属性页应返回 FALSE
}


BOOL CToolsDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: 在此添加专用代码和/或调用基类
	if (pMsg->message==WM_KEYDOWN && (pMsg->wParam==VK_RETURN ||pMsg->wParam==VK_ESCAPE))
	{
		return TRUE;
	}
	return CDialog::PreTranslateMessage(pMsg);
}


void CToolsDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CDialog::OnPaint()

	CRect   rect;
	GetClientRect(rect);
	dc.FillSolidRect(rect,RGB(255,255,255));
}


void CToolsDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	if (bShow == TRUE)
	{
		((CHeavenShadowDlg*)m_wParent)->m_bNowWindow = HS_DIALOG_TOOLS;

		((CHeavenShadowDlg*)m_wParent)->m_btnTool.EnableWindow(FALSE);

		HsSendStatusDetail(L"系统工具集合。");
		HsSendStatusTip(L"工具箱");
	}
	// TODO: 在此处添加消息处理程序代码
}

```

`arkProject/HeavenShadow/HeavenShadow/ToolsDlg.h`:

```h
#pragma once


// CToolsDlg 对话框

class CToolsDlg : public CDialog
{
	DECLARE_DYNAMIC(CToolsDlg)

public:
	CToolsDlg(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~CToolsDlg();

// 对话框数据
	enum { IDD = IDD_DIALOG_TOOLS };

	CWnd* m_wParent;

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL OnInitDialog();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnPaint();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
};

```

`arkProject/HeavenShadow/HeavenShadow/TrueColorToolBar.cpp`:

```cpp
/***=========================================================================
====                                                                     ====
====                          D C U t i l i t y                          ====
====                                                                     ====
=============================================================================
====                                                                     ====
====    File name           :  TrueColorToolBar.cpp                      ====
====    Project name        :  Tester                                    ====
====    Project number      :  ---                                       ====
====    Creation date       :  13/1/2003                                 ====
====    Author(s)           :  Dany Cantin                               ====
====                                                                     ====
====                  Copyright ?DCUtility  2003                        ====
====                                                                     ====
=============================================================================
===========================================================================*/

#include "stdafx.h"
#include "TrueColorToolBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__; 
#endif 

/////////////////////////////////////////////////////////////////////////////
// CTrueColorToolBar

CTrueColorToolBar::CTrueColorToolBar()
{
	m_bDropDown = FALSE;
}

CTrueColorToolBar::~CTrueColorToolBar()
{
}


BEGIN_MESSAGE_MAP(CTrueColorToolBar, CToolBar)
	//{{AFX_MSG_MAP(CTrueColorToolBar)
	ON_NOTIFY_REFLECT(TBN_DROPDOWN, OnToolbarDropDown)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTrueColorToolBar message handlers
BOOL CTrueColorToolBar::LoadTrueColorToolBar(int  nBtnWidth,
											 UINT uToolBar,
											 UINT uToolBarHot,
											 UINT uToolBarDisabled)
{
	if (!SetTrueColorToolBar(TB_SETIMAGELIST, uToolBar, nBtnWidth))
		return FALSE;
	
	if (uToolBarHot) {
		if (!SetTrueColorToolBar(TB_SETHOTIMAGELIST, uToolBarHot, nBtnWidth))
			return FALSE;
	}

	if (uToolBarDisabled) {
		if (!SetTrueColorToolBar(TB_SETDISABLEDIMAGELIST, uToolBarDisabled, nBtnWidth))
			return FALSE;
	}

	return TRUE;
}


BOOL CTrueColorToolBar::SetTrueColorToolBar(UINT uToolBarType, 
							     	        UINT uToolBar,
										    int  nBtnWidth)
{
	CImageList	cImageList;
	CBitmap		cBitmap;
	BITMAP		bmBitmap;
	
	if (!cBitmap.Attach(LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(uToolBar),
								  IMAGE_BITMAP, 0, 0,
								  LR_DEFAULTSIZE|LR_CREATEDIBSECTION)) ||
	    !cBitmap.GetBitmap(&bmBitmap))
		return FALSE;

	CSize		cSize(bmBitmap.bmWidth, bmBitmap.bmHeight); 
	int			nNbBtn	= cSize.cx/nBtnWidth;
	RGBTRIPLE*	rgb		= (RGBTRIPLE*)(bmBitmap.bmBits);
	COLORREF	rgbMask	= RGB(rgb[0].rgbtRed, rgb[0].rgbtGreen, rgb[0].rgbtBlue);
	
	if (!cImageList.Create(nBtnWidth, cSize.cy, ILC_COLOR24|ILC_MASK, nNbBtn, 0))
		return FALSE;
	
	if (cImageList.Add(&cBitmap, rgbMask) == -1)
		return FALSE;

	SendMessage(uToolBarType, 0, (LPARAM)cImageList.m_hImageList);
	cImageList.Detach(); 
	cBitmap.Detach();
	
	return TRUE;
}

void CTrueColorToolBar::AddDropDownButton(CWnd* pParent, UINT uButtonID, UINT uMenuID)
{
	if (!m_bDropDown) {
		GetToolBarCtrl().SendMessage(TB_SETEXTENDEDSTYLE, 0, (LPARAM)TBSTYLE_EX_DRAWDDARROWS);
		m_bDropDown = TRUE;
	}

	SetButtonStyle(CommandToIndex(uButtonID), TBSTYLE_DROPDOWN);

	stDropDownInfo DropDownInfo;
	DropDownInfo.pParent	= pParent;
	DropDownInfo.uButtonID	= uButtonID;
	DropDownInfo.uMenuID	= uMenuID;
	m_lstDropDownButton.Add(DropDownInfo);
}

void CTrueColorToolBar::OnToolbarDropDown(NMHDR * pnmtb, LRESULT *plr)
{
	NMTOOLBARA * pnmtbb=(NMTOOLBARA *)pnmtb;

	for (int i = 0; i < m_lstDropDownButton.GetSize(); i++) {

		stDropDownInfo DropDownInfo = m_lstDropDownButton.GetAt(i);

		if (DropDownInfo.uButtonID == UINT(pnmtbb->iItem)) {

			CMenu menu;
			menu.LoadMenu(DropDownInfo.uMenuID);
			CMenu* pPopup = menu.GetSubMenu(0);

			CRect rc;
			SendMessage(TB_GETRECT, (WPARAM)pnmtbb->iItem, (LPARAM)&rc);
			ClientToScreen(&rc);

			pPopup->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_VERTICAL,
				rc.left, rc.bottom, DropDownInfo.pParent, &rc);
			break;
		}
	}
}
```

`arkProject/HeavenShadow/HeavenShadow/TrueColorToolBar.h`:

```h
/***=========================================================================
====                                                                     ====
====                          D C U t i l i t y                          ====
====                                                                     ====
=============================================================================
====                                                                     ====
====    File name           :  TrueColorToolBar.h                        ====
====    Project name        :  Tester                                    ====
====    Project number      :  ---                                       ====
====    Creation date       :  13/1/2003                                 ====
====    Author(s)           :  Dany Cantin                               ====
====                                                                     ====
====                  Copyright ?DCUtility  2003                        ====
====                                                                     ====
=============================================================================
===========================================================================*/


#ifndef TRUECOLORTOOLBAR_H_
#define TRUECOLORTOOLBAR_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <afxtempl.h>

/////////////////////////////////////////////////////////////////////////////
// CTrueColorToolBar

class CTrueColorToolBar : public CToolBar
{
// Construction
public:
	CTrueColorToolBar();

// Attributes
private:
	BOOL m_bDropDown;

	struct stDropDownInfo {
	public:
		UINT  uButtonID;
		UINT  uMenuID;
		CWnd* pParent;
	};
	
	CArray <stDropDownInfo, stDropDownInfo&> m_lstDropDownButton;
	
// Operations
public:
	BOOL LoadTrueColorToolBar(int  nBtnWidth,
							  UINT uToolBar,
							  UINT uToolBarHot		= 0,
							  UINT uToolBarDisabled = 0);

	void AddDropDownButton(CWnd* pParent, UINT uButtonID, UINT uMenuID);

private:
	BOOL SetTrueColorToolBar(UINT uToolBarType,
		                     UINT uToolBar,
						     int  nBtnWidth);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTrueColorToolBar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTrueColorToolBar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CTrueColorToolBar)
	afx_msg void OnToolbarDropDown(NMHDR * pnmh, LRESULT* plRes);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // TRUECOLORTOOLBAR_H_

```

`arkProject/HeavenShadow/HeavenShadow/WindowFunc.cpp`:

```cpp
#include "stdafx.h"
#include "WindowFunc.h"
#include "Common.h"
#include "resource.h"

#include <vector>

using namespace std;

vector<WND_INFO> m_vectorWnds;

extern ULONG_PTR g_ulProcessId;
extern HANDLE g_hDevice;

COLUMNSTRUCT g_Column_Window[] = 
{
	{	L"窗口句柄",			80	},
	{	L"窗口标题",			140	},
	{	L"窗口类名",			140	},
	{	L"窗口可见性",		90	},
	{	L"线程ID",			70	},
	{	L"进程ID",			70	}
};

UINT g_Column_Window_Count  = 6;	  //进程列表列数

extern int dpix;
extern int dpiy;


void HsInitWindowList(CMyList *m_ListCtrl)
{

	while(m_ListCtrl->DeleteColumn(0));
	m_ListCtrl->DeleteAllItems();

	m_ListCtrl->SetExtendedStyle(LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES|LVS_EX_HEADERDRAGDROP);

	UINT i;
	for (i = 0;i<g_Column_Window_Count;i++)
	{
		m_ListCtrl->InsertColumn(i, g_Column_Window[i].szTitle,LVCFMT_LEFT,(int)(g_Column_Window[i].nWidth*(dpix/96.0)));
	}
}



VOID HsQueryProcessWindow(CMyList *m_ListCtrl)
{
	m_ListCtrl->DeleteAllItems();

	BOOL bRet = FALSE;
	ULONG ulReturnSize = 0;
	m_vectorWnds.clear();

	PALL_WNDS WndInfo = NULL;
	ULONG ulCount = 1000;

	if (g_ulProcessId <= 4)
	{
		return;
	}

	do 
	{
		ULONG ulSize = sizeof(ALL_WNDS) + ulCount * sizeof(WND_INFO);

		if (WndInfo)
		{
			free(WndInfo);
			WndInfo = NULL;
		}

		WndInfo = (PALL_WNDS)malloc(ulSize);
		if (!WndInfo)
		{
			break;
		}

		memset(WndInfo,0,ulSize);


		bRet = DeviceIoControl(g_hDevice,
			HS_IOCTL(HS_IOCTL_PROC_PROCESSWINDOW),
			&g_ulProcessId,
			sizeof(ULONG),
			WndInfo,
			ulSize,
			&ulReturnSize,
			NULL);

		ulCount = WndInfo->nCnt + 100;

	} while (bRet == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

	if (bRet && WndInfo->nCnt > 0)
	{
		for (ULONG i = 0;i<WndInfo->nCnt; i++)
		{
			m_vectorWnds.push_back(WndInfo->WndInfo[i]);
		}
	}

	if (WndInfo)
	{
		free(WndInfo);
		WndInfo = NULL;
	}



	if (m_vectorWnds.empty())
	{
		return;
	}


	//////////////////////////////////////////////////////////////////////////

	for (vector <WND_INFO>::iterator Iter = m_vectorWnds.begin( ); 
		Iter != m_vectorWnds.end( ); 
		Iter++ )
	{
		HsAddWndItem(*Iter,FALSE,m_ListCtrl);
	}
}


void HsAddWndItem(WND_INFO WndInfor,BOOL bAll,CMyList *m_ListCtrl)
{


	WCHAR szClassName[MAX_PATH] = {0};
	WCHAR szWindowsText[MAX_PATH] = {0};

	CString  strhWnd;
	CString  strTid;
	CString  strPid;
	CString  strVisable;

	::GetClassName(WndInfor.hWnd,  szClassName, MAX_PATH);
	::GetWindowText(WndInfor.hWnd, szWindowsText, MAX_PATH);


	if (::IsWindowVisible(WndInfor.hWnd))
	{
		strVisable = L"可见";
	}
	else
	{
		strVisable = L"-";
	}


	if (bAll==TRUE)
	{

	}
	else
	{
		if (WndInfor.uPid!=g_ulProcessId)
		{
			return;
		}
	}





	strhWnd.Format(L"0x%08X",WndInfor.hWnd);
	strTid.Format(L"%d",WndInfor.uTid);
	strPid.Format(L"%d",WndInfor.uPid);
	int n = m_ListCtrl->GetItemCount();
	int j = m_ListCtrl->InsertItem(n,strhWnd);
	m_ListCtrl->SetItemText(j, 1, szWindowsText);
	m_ListCtrl->SetItemText(j, 2, szClassName);
	m_ListCtrl->SetItemText(j, 3, strVisable);
	m_ListCtrl->SetItemText(j, 4, strTid);
	m_ListCtrl->SetItemText(j, 5, strPid);

	m_ListCtrl->SetItemData(j,j);


}



//权限界面弹出菜单
VOID HsProcessWindowPopupMenu(CMyList *m_ListCtrl, CWnd* parent)
{
// 	CMenu	popup;
// 	popup.LoadMenu(IDR_MENU_PROCESS_THREAD);		//加载菜单资源
// 	CMenu*	pM = popup.GetSubMenu(0);				//获得菜单的子项
// 	CPoint	p;
// 	GetCursorPos(&p);
// 	int	count = pM->GetMenuItemCount();
// 	if (m_ListCtrl->GetSelectedCount() == 0)		//如果没有选中
// 	{ 
// 		for (int i = 0;i<count;i++)
// 		{
// 			pM->EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED); //菜单全部变灰
// 		}
// 	}
// 
// 	pM->TrackPopupMenu(TPM_LEFTALIGN, p.x, p.y, parent);
}
```

`arkProject/HeavenShadow/HeavenShadow/WindowFunc.h`:

```h
#pragma once
#include "stdafx.h"

#include "MyList.h"


typedef struct _WND_INFO_
{
	HWND  hWnd;
	ULONG uPid;
	ULONG uTid;
}WND_INFO, *PWND_INFO;

typedef struct _ALL_WNDS_
{
	ULONG nCnt;
	WND_INFO WndInfo[1];
}ALL_WNDS, *PALL_WNDS;



void HsInitWindowList(CMyList *m_ListCtrl);

VOID HsQueryProcessWindow(CMyList *m_ListCtrl);

void HsAddWndItem(WND_INFO WndInfor,BOOL bAll,CMyList *m_ListCtrl);


//权限界面弹出菜单
VOID HsProcessWindowPopupMenu(CMyList *m_ListCtrl, CWnd* parent);
```

`arkProject/HeavenShadow/HeavenShadow/WzdSplash.cpp`:

```cpp
// WzdSplash.cpp : 实现文件
//
#include "stdafx.h"
#include "HeavenShadow.h"
#include "WzdSplash.h"
// CWzdSplash
IMPLEMENT_DYNAMIC(CWzdSplash, CWnd)
	CWzdSplash::CWzdSplash()
{
}
CWzdSplash::~CWzdSplash()
{
}
BEGIN_MESSAGE_MAP(CWzdSplash, CWnd)
	ON_WM_PAINT()
	ON_WM_TIMER()
END_MESSAGE_MAP()
// CWzdSplash 消息处理程序
void CWzdSplash::Create(UINT nBitmapID)
{
	m_bitmap.LoadBitmap(nBitmapID);
	BITMAP bitmap;
	m_bitmap.GetBitmap(&bitmap);
	//CreateEx(0,AfxRegisterWndClass(0),"",WS_POPUP|WS_VISIBLE|WS_BORDER,0,0,bitmap.bmWidth,bitmap.bmHeight,NULL,0);
	CreateEx(0,
		AfxRegisterWndClass(0, AfxGetApp()->LoadStandardCursor(IDC_ARROW)),
		NULL, WS_POPUP | WS_VISIBLE, 0, 0, bitmap.bmWidth, bitmap.bmHeight, NULL , NULL);

	::SetWindowPos(m_hWnd,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);

	//SetTimer(0,1200,NULL);
}
void CWzdSplash::OnPaint()
{
	// TODO: 在此处添加消息处理程序代码
	// 不为绘图消息调用 CWnd::OnPaint()
	CPaintDC dc(this); // device context forpainting
	BITMAP bitmap;
	m_bitmap.GetBitmap(&bitmap);
	CDC dcComp;
	dcComp.CreateCompatibleDC(&dc);
	dcComp.SelectObject(&m_bitmap);
	// draw bitmap
	dc.BitBlt(0,0,bitmap.bmWidth,bitmap.bmHeight,&dcComp,0,0,SRCCOPY);
}
void CWzdSplash::OnTimer(UINT_PTR nIDEvent)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	//CWnd::OnTimer(nIDEvent);
	DestroyWindow(); //销毁初始画面窗口
}

```

`arkProject/HeavenShadow/HeavenShadow/WzdSplash.h`:

```h
#pragma once
// CWzdSplash
class CWzdSplash : public CWnd
{
	DECLARE_DYNAMIC(CWzdSplash)
public:
	CWzdSplash();
	virtual ~CWzdSplash();
protected:
	DECLARE_MESSAGE_MAP()
public:
	CBitmap m_bitmap;
//	void Create(void);
	void Create(UINT nBitmapID);
	afx_msg void OnPaint();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
};


```

`arkProject/HeavenShadow/HeavenShadow/res/HeavenShadow.rc2`:

```rc2
//
// HeavenShadow.RC2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`arkProject/HeavenShadow/HeavenShadow/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by HeavenShadow.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_HEAVENSHADOW_DIALOG         102
#define IDS_STATUSDETAIL                102
#define IDS_STATUSTIP                   103
#define IDR_MAINFRAME                   128
#define IDB_BITMAP_LOGO                 137
#define IDD_DIALOG_PROCESS              138
#define IDD_DIALOG_SERVICE              139
#define IDD_DIALOG_MODULE               140
#define IDR_MENU_MAIN                   141
#define IDB_BITMAP_PROCESS              144
#define IDB_BITMAP_MODULE               145
#define IDB_BITMAP_SERVICE              146
#define IDB_BITMAP_PROCESS_NOW          148
#define IDB_BITMAP_MODULE_NOW           149
#define IDB_BITMAP_SERVICE_NOW          150
#define IDR_MENU_PROCESS                151
#define IDB_BITMAP_LOGOBAR              152
#define IDD_DIALOG_ABOUT                153
#define IDB_BITMAP_LOGOBAR_NOW          154
#define IDD_DIALOG_ALERT                155
#define IDB_BITMAP_ALERTBTNEXIT         158
#define IDD_DIALOG_PROCESS_VIEW         159
#define IDR_WAVE_SYSTEM_ALERT           161
#define IDB_BITMAP_BTN_ALLOW            162
#define IDB_BITMAP_BTN_PREVENT          163
#define IDB_BITMAP_FILE                 164
#define IDB_BITMAP_FILE_NOW             165
#define IDD_DIALOG_FILE                 166
#define IDD_DIALOG_SYSTEM               168
#define IDB_BITMAP_FILETOOLBAR          169
#define IDD_DIALOG_SETTING              169
#define IDR_TOOLBAR_FILETOOLBAR         170
#define IDD_DIALOG_TOOLS                170
#define IDD_DIALOG_KERNEL               171
#define IDR_MENU_FILE_VIEW              172
#define IDB_BITMAP_FILETOOLBARGOTO      174
#define IDR_TOOLBAR_FILETOOLBARGOTO     175
#define IDB_BITMAP_BTN_ALLOW_C          184
#define IDB_BITMAP_BTN_PREVENT_C        185
#define IDR_MENU_PROCESS_PRIVILEGE      186
#define IDR_SYSDRIVER64                 187
#define IDR_SYSDRIVER32                 189
#define IDB_BITMAP_SYSTEM               191
#define IDB_BITMAP_SYSTEM_NOW           192
#define IDB_BITMAP_SETTING              193
#define IDB_BITMAP_SETTING_NOW          194
#define IDB_BITMAP_TOOLS                196
#define IDB_BITMAP_TOOLS_NOW            197
#define IDB_BITMAP_MAINMENU_BTN         198
#define IDI_ICON_LITTLE                 200
#define IDR_MENU_ICONNOTIFY             201
#define IDB_BITMAP_KERNEL               204
#define IDB_BITMAP_KERNEL_NOW           205
#define IDB_BITMAP_CHECK_ALT_V          206
#define IDB_BITMAP_CHECK_ALT_X          207
#define IDB_BITMAP_HOMECHECK_BTN        208
#define IDB_BITMAP_HOMECHECK_BTN_HOVER  210
#define IDB_BITMAP_HOMECHECK_BTN_CLICK  211
#define IDR_MENU_PROCESS_THREAD         212
#define IDB_BITMAP_WZDSPLASH            216
#define IDR_MENU_KERNEL_SSDT            217
#define IDR_MENU_MODULE                 218
#define IDR_MENU_SYSK_IOTIMER           219
#define IDR_MENU_SYSK_CALLBACK          220
#define IDR_MENU_SYSK_DPCTIMER          222
#define IDR_MENU_SYSK_FILTERDRIVER      223
#define IDC_BUTTON_TEST2                1006
#define IDC_TAB_MAIN                    1013
#define IDC_LIST_PROCESSLIST            1014
#define IDC_BUTTON_PROCESS              1015
#define IDC_BUTTON_SERVICE              1017
#define IDC_STATIC_MODULE               1020
#define IDC_STATIC_SERVICE              1021
#define IDC_STATIC_PROCESS              1022
#define IDC_STATIC_LOGO                 1023
#define IDC_STATIC_KERNEL               1024
#define IDC_STATIC_ALERTBTNEXIT         1026
#define IDC_LIST_PROCESS_VIEW           1027
#define IDC_STATIC_TIMERTIP             1028
#define IDC_STATIC_BTN_PREVENT          1029
#define IDC_STATIC_BTN_ALLOW            1030
#define IDC_STATIC_FILE                 1031
#define IDC_TREE_FILEDIRECTORY          1032
#define IDC_STATIC_SYSTEM               1032
#define IDC_LIST_FILELIST               1033
#define IDC_STATIC_SETTING              1033
#define IDC_STATIC_TOOLS                1034
#define IDC_COMBOBOX_FILEPATH           1048
#define IDC_LIST_PROCESSVIEWTYPE        1051
#define IDC_STATIC_MANMENUBTN           1060
#define IDC_STATIC_ALERT_CONTEXT        1062
#define IDC_STATIC_ALERT_TITLE          1063
#define IDC_LIST_KERNEL                 1065
#define IDC_LIST_KERNEL_CTRL            1066
#define IDC_STATIC_CHECK_ALT            1067
#define IDC_LIST_KRNLNAME               1067
#define IDC_TEXT_CHECK_ALT              1068
#define IDC_STATIC_SYS_BIT              1069
#define IDC_TEXT_SYS_BIT                1070
#define IDC_STATIC_SOFT_BIT             1071
#define IDC_TEXT_SOFT_BIT               1072
#define IDC_STATIC_HOMECHECK            1073
#define IDC_STATIC_VIEWICON             1074
#define IDC_LIST_MODULELIST             1077
#define IDC_LIST_SYSTEM                 1078
#define IDC_LIST_SYSTEM_CTRL            1079
#define ID_MENU_PROCESS_REFRESH         32777
#define ID_MENU_PROCESS_KILLPROCESS     32779
#define ID_MENU_PROCESS_PROCESSTHREAD   32781
#define ID_MENU_PROCESS_COPYINFO        32784
#define ID_MENU_PROCESS_ATTRIBUTE       32786
#define ID_MENU_PROCESS_EXPORTTXT       32790
#define ID_MENU_PROCESS_EXPORTEXCEL     32791
#define ID_MENU_PROCESS_LOCATIONFILE    32793
#define ID_MENU_PROCESS_PROCVIEW        32796
#define ID_MENU_PROCESS_PROCTHREAD      32797
#define ID_BUTTON_FILE_PREV             32798
#define ID_BUTTON_FILE_FIND             32799
#define ID_BUTTON_FILE_DELETE           32800
#define ID_BUTTON_FILE_NEWFOLDER        32801
#define ID_BUTTON_FILE_VIEW             32802
#define ID_BUTTON_FILE_REFRESH          32803
#define IDM_FILE_VIEW_BIGICON           32809
#define IDM_FILE_VIEW_SMALLICON         32810
#define IDM_FILE_VIEW_LIST              32811
#define IDM_FILE_VIEW_REPORT            32812
#define ID_BUTTON_FILE_GOTO             32813
#define ID_MENU_PROCESS_PROCESSPRIVILEGE 32815
#define ID_MENU_PROCESSPRIVILEGE_ENABLE 32819
#define ID_MENU_PROCESSPRIVILEGE_DISABLE 32820
#define ID_MENU_PROCESSPRIVILEGE_REFRESH 32821
#define ID_MENU_PROCESS_INJECTDLL       32823
#define ID_MENU_PROCESS_INJECT          32825
#define ID_MENU_PROCESS_KILLMUST        32827
#define ID_MENU_PROCESS_DETAIL          32829
#define ID_MENU_PROCES_OVERALLHOOK      32831
#define ID_MENU_PROCESS_PROCESSHANDLE   32833
#define ID_MENU_PROCESS_MEMORY          32836
#define ID_MENU_MAIN_SETTING            32839
#define ID_MENU_SHOWMAIN                32845
#define ID_MENU_HIDEMAIN                32846
#define ID_MENU_EXIT                    32848
#define ID_MENU_PROCESS_NEWRUN          32851
#define ID_MENU_PROCESSTHREAD_REFRESH   32854
#define ID_MENU_PROCESSTHREAD_CLOSETHREAD 32856
#define ID_MENU_PROCESS_PROCESSWINDOW   32858
#define ID_MENU_PROCESS_SUSPEND         32861
#define ID_MENU_PROCESS_RECOVERY        32862
#define ID_MENU_PROCESS_PROCESSMODULE   32864
#define ID_MENU_SSDT_REFRESH            32867
#define ID_MENU_SSDT_RESUME             32869
#define ID_MENU_SYSK_IOTIMER_REMOVE     32874
#define ID_MENU_SYSK_IOTIMER_OPER       32875
#define ID_MENU_SYSK_IOTIMER_REFRESH    32877
#define ID_MENU_MODULE_REMOVEMODULE     32880
#define ID_MENU_MODULE_REFRESH          32882
#define ID_MENU_SYSK_CALLBACK_REFRESH   32886
#define ID_MENU_SYSK_CALLBACK_REMOVE    32887
#define ID_MENU_SYSK_DPCTIMER_REFRESH   32891
#define ID_MENU_SYSK_DPCTIMER_REMOVE    32892
#define ID_MENU_SYSK_FILTER_REMOVEFILTER 32895
#define ID_MENU_SYSK_FILTER_REFRESH     32897

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        224
#define _APS_NEXT_COMMAND_VALUE         32898
#define _APS_NEXT_CONTROL_VALUE         1080
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`arkProject/HeavenShadow/HeavenShadow/stdafx.cpp`:

```cpp

// stdafx.cpp : 只包括标准包含文件的源文件
// HeavenShadow.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"



```

`arkProject/HeavenShadow/HeavenShadow/stdafx.h`:

```h

// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件

#pragma once

#ifndef _SECURE_ATL
#define _SECURE_ATL 1
#endif

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类

#include <strsafe.h>


#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // 功能区和控件条的 MFC 支持



// Lets help compiler to skip some headers
#define _XTP_EXCLUDE_CALENDAR
#define _XTP_EXCLUDE_SYNTAXEDIT
#define _XTP_EXCLUDE_REPORTCONTROL



#include <XTToolkitPro.h>   // Codejock Software Components





#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`arkProject/HeavenShadow/HeavenShadow/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义最高版本的可用 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`arkProject/HeavenShadow/injectdll32/InjectFunc32.cpp`:

```cpp
#include "stdafx.h"

#include "InjectFunc32.h"

WIN_VERSION  GetWindowsVersion();
WIN_VERSION  WinVersion = WinUnknown;

typedef long (__fastcall *pfnRtlAdjustPrivilege64)(ULONG,ULONG,ULONG,PVOID);
typedef long (__fastcall *pfnRtlAdjustPrivilege32)(ULONG,ULONG,ULONG,PVOID);
pfnRtlAdjustPrivilege64 RtlAdjustPrivilege64;
pfnRtlAdjustPrivilege32 RtlAdjustPrivilege32;

static OPENFILENAME ofn ;

DWORD HsRemoteThreadInjectDll32(WCHAR* ProcessInfo)
{
	ULONG_PTR ProcessId = 0;
	WCHAR*    ProcessPath = NULL;
	WCHAR wzFileFilter[] = L"应用程序扩展 (*.dll)\0*.dll\0所有文件 (*.*)\0*.*\0";
	WCHAR wzFileChoose[] = L"打开文件";

	int i;
	int j;

	WCHAR szPid[10] = {0};

	for (i = 0; _wcsnicmp(ProcessInfo+i,L"-d ",wcslen(L"-d "))!=0 && i<=10 ;i++);

	if (i == 10)
	{
		return FALSE;
	}

	WCHAR* PidTemp = ProcessInfo + i + wcslen(L"-d ");

	j = i;

	for ( ; _wcsnicmp(ProcessInfo + j,L" -p ",wcslen(L" -p "))!=0 && j-i<=10 ;j++);

	if (j-i==10)
	{
		return FALSE;
	}

	memcpy(szPid,PidTemp,j-i);

	ProcessId   = _ttoi(szPid);

	ProcessPath = ProcessInfo + j + wcslen(L" -p ");

	static TCHAR szFileName[MAX_PATH], szTitleName[MAX_PATH] ;
	HWND hwnd;
	hwnd=GetForegroundWindow(); //获取前台窗口句柄。本程序中的前台窗口就是控制台窗口。 
	PopFileInitialize (hwnd);   //初始化ofn
	PopFileOpenDlg(hwnd, szFileName, szTitleName);//打开文件对话框

	CString strDllPath = szFileName;

	BOOL bResult = FALSE;

	if (PathFileExists(strDllPath))
	{
		if (HsIs32BitFile(ProcessPath)==TRUE &&
			HsIs32BitFile(strDllPath.GetBuffer())==TRUE)
		{
			bResult = HsInjectDll(TRUE,&strDllPath,ProcessId);
		}
	}

	if (bResult == FALSE)
	{
		::MessageBox(NULL,L"远程线程注入失败。",L"天影卫士",MB_SYSTEMMODAL|MB_OK);

	}
	else
	{
		::MessageBox(NULL,L"远程线程注入成功。",L"天影卫士",MB_SYSTEMMODAL|MB_OK);
	}

	return bResult;
}





BOOL __stdcall HsIs32BitFile(const WCHAR * pwszFullPath)
{
	FILE * peFile = NULL;
	_wfopen_s(&peFile, pwszFullPath, L"rb");
	if (peFile == NULL)
	{
		fclose(peFile);
		return -1;
	}

	IMAGE_DOS_HEADER imageDosHeader;
	fread(&imageDosHeader, sizeof(IMAGE_DOS_HEADER), 1, peFile);
	if (imageDosHeader.e_magic != IMAGE_DOS_SIGNATURE)
	{
		fclose(peFile);
		return FALSE;
	}

	IMAGE_NT_HEADERS imageNtHeaders;
	fseek(peFile, imageDosHeader.e_lfanew, SEEK_SET);
	fread(&imageNtHeaders, sizeof(IMAGE_NT_HEADERS), 1, peFile);
	fclose(peFile);
	if (imageNtHeaders.Signature != IMAGE_NT_SIGNATURE)
	{
		return FALSE;
	}

	if (imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
	{
		return TRUE;
	}
	// 	if (imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_IA64 ||
	// 		imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
	// 	{
	// 		return FALSE;	//64BIT
	// 	}

	return FALSE;
}





//改程序编译成64位可以注入64位 编译成32位可以注入32位

BOOL HsInjectDll(BOOL Is32Bit, CString* strDllPath, ULONG_PTR ProcessID)
{
	BOOL bResult = FALSE;

	if (ProcessID <= 0)
	{
		return FALSE;
	}


	if (PathFileExists(*strDllPath))
	{
		WinVersion = GetWindowsVersion();

		switch(WinVersion)
		{
		case Windows7:   //注意我们这里针对的是64位的Win7
			{

				WCHAR wzPath[MAX_PATH] = {0};
				wcscpy_s(wzPath, strDllPath->GetBuffer());
				strDllPath->ReleaseBuffer();

				HsDebugPrivilege(SE_DEBUG_NAME, TRUE);
				bResult = HsInjectDllByRemoteThreadWin7(wzPath,ProcessID,Is32Bit);
				HsDebugPrivilege(SE_DEBUG_NAME, FALSE);

				break;
			}

		case WindowsXP:  //这里是针对的32位的XP
			{
				WCHAR wzPath[MAX_PATH] = {0};
				wcscpy_s(wzPath, strDllPath->GetBuffer());

				strDllPath->ReleaseBuffer();

				bResult = HsInjectDllByRemoteThreadWinXP(wzPath,ProcessID);

				break;
			}
		}
	}
	return bResult;
}


BOOL HsInjectDllByRemoteThreadWin7(const TCHAR* wzDllFile, ULONG_PTR ProcessId, BOOL Is32Bit)
{
	if (NULL == wzDllFile || 0 == ::_tcslen(wzDllFile) || ProcessId == 0 || -1 == _taccess(wzDllFile, 0))
	{
		return FALSE;
	}
	HANDLE                 hProcess = NULL;
	HANDLE                 hThread  = NULL;
	DWORD                  dwRetVal    = 0;
	LPTHREAD_START_ROUTINE FuncAddress = NULL;
	DWORD  dwSize = 0;
	TCHAR* VirtualAddress = NULL;

#ifdef _UNICODE
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif

	if (FuncAddress==NULL)
	{
		return FALSE;
	}

	hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE, (DWORD)ProcessId);

	if (NULL == hProcess)
	{
		printf("Open Process Fail\r\n");
		return FALSE;
	}

	// 在目标进程中分配内存空间
	dwSize = (DWORD)::_tcslen(wzDllFile) + 1;
	VirtualAddress = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE);  
	if (NULL == VirtualAddress)
	{

		printf("Virtual Process Memory Fail\r\n");
		CloseHandle(hProcess);
		return FALSE;
	}

	// 在目标进程的内存空间中写入所需参数(模块名)
	if (FALSE == ::WriteProcessMemory(hProcess, VirtualAddress, (LPVOID)wzDllFile, dwSize * sizeof(TCHAR), NULL))
	{
		printf("Write Data Fail\r\n");
		VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
		CloseHandle(hProcess);
		return FALSE;
	}

	hThread = ::CreateRemoteThread(hProcess, NULL, 0, FuncAddress, VirtualAddress, 0, NULL);
	if (NULL == hThread)
	{
		printf("CreateRemoteThread Fail\r\n");

		VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
		CloseHandle(hProcess);
		return FALSE;
	}


	// 等待远程线程结束
	WaitForSingleObject(hThread, INFINITE);
	// 清理
	VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
	CloseHandle(hThread);
	CloseHandle(hProcess);

	return TRUE;

}




BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId)
{
	//提高本进程的权限

	if (!HsInjectUpPrivilige())  //提权
	{
		printf("Up Privilige Is Error\n");
		return FALSE;
	}

	CStringA *Dll = new CStringA(wzDllFile);


	//我们就要打开想要打开的进程
	HANDLE hProcess = NULL;
	HANDLE hThread  = NULL;

	hProcess = OpenProcess(PROCESS_ALL_ACCESS,false,(DWORD)ProcessId);  //explorer.exe  hProcess
	if (hProcess==NULL)
	{
		printf("Open Process Is Error\n");

		return FALSE;
	}

	char* szDllName = NULL;

	szDllName = (char*)VirtualAllocEx(hProcess,
		NULL,Dll->GetLength()+1,MEM_COMMIT,PAGE_READWRITE);   

	if (szDllName==NULL)
	{

		CloseHandle(hProcess);
		printf("Apply Memory Is Error\n");

		return FALSE;
	}

	//然后将完整的路径直接写入内存

	if (!WriteProcessMemory(hProcess,szDllName,Dll->GetBuffer(),Dll->GetLength()+1,NULL))
	{

		CloseHandle(hProcess);

		printf("Write Memory Is Error\n");

		return FALSE;
	}

	LPTHREAD_START_ROUTINE StartRoutine = NULL;

	StartRoutine = 
		(LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")),
		"LoadLibraryA");

	if(StartRoutine == NULL)
	{
		printf("Get ProcAddress Error\n");
		return FALSE;
	}

	hThread = CreateRemoteThread(hProcess,NULL,0,StartRoutine,szDllName,0,NULL);

	if (hThread==NULL)
	{
		CloseHandle(hProcess);

		printf("Create Remote Thread Is Error\n");

		return FALSE;
	}

	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);
	VirtualFreeEx(hProcess,szDllName,0,MEM_RELEASE);
	CloseHandle(hProcess);

	return TRUE;
}


BOOL HsInjectUpPrivilige()	//XP
{

	HANDLE hToken = NULL;

	_TOKEN_PRIVILEGES tp = {0};

	LUID luid={0};


	if (!OpenProcessToken(GetCurrentProcess(),TOKEN_ALL_ACCESS,&hToken))
	{
		printf("OpenProcess Is Error\n");

		return FALSE;
	}

	if (!LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&luid))
	{

		printf("Lookup Is Error\n");

		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


	if (!AdjustTokenPrivileges(hToken,FALSE,&tp,sizeof(TOKEN_PRIVILEGES),NULL,NULL))
	{
		printf("Adjust Is Error\n");

		return FALSE;
	}

	return TRUE;
}


/*
BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId)
{
// 参数无效
if (NULL == wzDllFile || 0 == ::_tcslen(wzDllFile) || ProcessId == 0 || -1 == _taccess(wzDllFile, 0))
{

return FALSE;
}

HANDLE hProcess = NULL;
HANDLE hThread  = NULL;
DWORD dwSize = 0;
TCHAR* VirtualAddress = NULL;
LPTHREAD_START_ROUTINE FuncAddress = NULL;

// 获取目标进程句柄
hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, (DWORD)ProcessId);
if (NULL == hProcess)
{
printf("Open Process Fail\r\n");
return FALSE;
}

// 在目标进程中分配内存空间
dwSize = (DWORD)::_tcslen(wzDllFile) + 1;
VirtualAddress = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE);
if (NULL == VirtualAddress)
{

printf("Virtual Process Memory Fail\r\n");
CloseHandle(hProcess);
return FALSE;
}

// 在目标进程的内存空间中写入所需参数(模块名)
if (FALSE == ::WriteProcessMemory(hProcess, VirtualAddress, (LPVOID)wzDllFile, dwSize * sizeof(TCHAR), NULL))
{
printf("Write Data Fail\r\n");
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return FALSE;
}

// 从 Kernel32.dll 中获取 LoadLibrary 函数地址
#ifdef _UNICODE
FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif

if (NULL == FuncAddress)
{
printf("Get LoadLibrary Fail\r\n");
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return false;
}

// 创建远程线程调用 LoadLibrary
hThread = ::CreateRemoteThread(hProcess, NULL, 0, FuncAddress, VirtualAddress, 0, NULL);
if (NULL == hThread)
{
printf("CreateRemoteThread Fail\r\n");

VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return FALSE;
}

// 等待远程线程结束
WaitForSingleObject(hThread, INFINITE);
// 清理
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hThread);
CloseHandle(hProcess);

return TRUE;
}


*/




WIN_VERSION  GetWindowsVersion()
{
	OSVERSIONINFOEX	OsVerInfoEx;
	OsVerInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx((OSVERSIONINFO *)&OsVerInfoEx); // 注意转换类型

	switch (OsVerInfoEx.dwPlatformId)
	{
	case VER_PLATFORM_WIN32_NT:
		{
			if (OsVerInfoEx.dwMajorVersion <= 4 )
			{
				return WindowsNT;
			}
			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 0)
			{
				return Windows2000;
			}

			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 1)
			{
				return WindowsXP;
			}
			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 2)
			{
				return Windows2003;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 0)
			{
				return WindowsVista;
			}

			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 1)
			{
				return Windows7;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 2 )
			{
				return Windows8;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 3 )
			{
				return Windows8_1;
			}
			if (OsVerInfoEx.dwMajorVersion == 10 && OsVerInfoEx.dwMinorVersion == 0 )
			{
				return Windows10;
			}

			break;
		}

	default:
		{
			return WinUnknown;
		}
	}

	return WinUnknown;
}









BOOL HsDebugPrivilege(const WCHAR *pName, BOOL bEnable)
{
	BOOL              bResult = TRUE;
	HANDLE            hToken;
	TOKEN_PRIVILEGES  TokenPrivileges;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken))
	{
		bResult = FALSE;
		return bResult;
	}
	TokenPrivileges.PrivilegeCount = 1;
	TokenPrivileges.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	LookupPrivilegeValue(NULL, pName, &TokenPrivileges.Privileges[0].Luid);
	AdjustTokenPrivileges(hToken, FALSE, &TokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL);
	if (GetLastError() != ERROR_SUCCESS)
	{
		bResult = FALSE;
	}

	CloseHandle(hToken);
	return bResult;	
}


void PopFileInitialize (HWND hwnd)
{
	static TCHAR szFilter[] = TEXT ("应用程序扩展 (*.dll)\0*.dll\0\0");

	ofn.lStructSize       = sizeof (OPENFILENAME) ;
	ofn.hwndOwner         = hwnd ;
	ofn.hInstance         = NULL ;
	ofn.lpstrFilter       = szFilter ;
	ofn.lpstrCustomFilter = NULL ;
	ofn.nMaxCustFilter    = 0 ;
	ofn.nFilterIndex      = 0 ;
	ofn.lpstrFile         = NULL ;          // Set in Open and Close functions
	ofn.nMaxFile          = MAX_PATH ;
	ofn.lpstrFileTitle    = NULL ;          // Set in Open and Close functions
	ofn.nMaxFileTitle     = MAX_PATH ;
	ofn.lpstrInitialDir   = NULL ;
	ofn.lpstrTitle        = NULL ;
	ofn.Flags             = 0 ;             // Set in Open and Close functions
	ofn.nFileOffset       = 0 ;
	ofn.nFileExtension    = 0 ;
	ofn.lpstrDefExt       = TEXT ("dll") ;
	ofn.lCustData         = 0L ;
	ofn.lpfnHook          = NULL ;
	ofn.lpTemplateName    = NULL ;
}

BOOL PopFileOpenDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName)
{
	ofn.hwndOwner         = hwnd ;
	ofn.lpstrFile         = pstrFileName ;
	ofn.lpstrFileTitle    = pstrTitleName ;
	ofn.Flags             = OFN_HIDEREADONLY | OFN_CREATEPROMPT ;

	return GetOpenFileName (&ofn) ;
}

```

`arkProject/HeavenShadow/injectdll32/InjectFunc32.h`:

```h
#pragma once
#include "stdafx.h"
#include <atlstr.h>

typedef enum _WIN_VERSION
{
	WindowsNT,
	Windows2000,
	WindowsXP,
	Windows2003,
	WindowsVista,
	Windows7,
	Windows8,
	Windows8_1,
	Windows10,
	WinUnknown
}WIN_VERSION;

DWORD HsRemoteThreadInjectDll32(WCHAR* ProcessInfo);
BOOL __stdcall HsIs32BitFile(const WCHAR * pwszFullPath);

WIN_VERSION  GetWindowsVersion();
BOOL HsInjectUpPrivilige();	//XP
BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId);
BOOL HsInjectDllByRemoteThreadWin7(const TCHAR* wzDllFile, ULONG_PTR ProcessId, BOOL Is32Bit);
BOOL HsInjectDll(BOOL Is32Bit, CString* strDllPath, ULONG_PTR ProcessID);
BOOL HsDebugPrivilege(const WCHAR *pName, BOOL bEnable);

void PopFileInitialize (HWND hwnd);
BOOL PopFileOpenDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName);
```

`arkProject/HeavenShadow/injectdll32/ReadMe.txt`:

```txt
========================================================================
    WIN32 应用程序：injectdll32 项目概述
========================================================================

应用程序向导已为您创建了此 injectdll32 应用程序。

本文件概要介绍组成 injectdll32 应用程序的每个文件的内容。


injectdll32.vcxproj
    这是使用应用程序向导生成的 VC++ 项目的主项目文件，
    其中包含生成该文件的 Visual C++ 
    的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

injectdll32.vcxproj.filters
    这是使用“应用程序向导”生成的 VC++ 项目筛选器文件。 
    它包含有关项目文件与筛选器之间的关联信息。 在 IDE 
    中，通过这种关联，在特定节点下以分组形式显示具有相似扩展名的文件。
    例如，“.cpp”文件与“源文件”筛选器关联。

injectdll32.cpp
    这是主应用程序源文件。

/////////////////////////////////////////////////////////////////////////////
应用程序向导创建了下列资源：

injectdll32.rc
    这是程序使用的所有 Microsoft Windows 资源的列表。  它包括 RES 
    子目录中存储的图标、位图和光标。  此文件可以直接在 Microsoft Visual C++ 
    中进行编辑。

Resource.h
    这是标准头文件，可用于定义新的资源 ID。
    Microsoft Visual C++ 将读取并更新此文件。

injectdll32.ico
    这是用作应用程序图标 (32x32) 的图标文件。
    此图标包括在主资源文件 injectdll32.rc 中。

small.ico
    这是一个图标文件，其中包含应用程序的图标的较小版本 (16x16)。 
    此图标包括在主资源文件 injectdll32.rc 中。

/////////////////////////////////////////////////////////////////////////////
其他标准文件：

StdAfx.h，StdAfx.cpp
    这些文件用于生成名为 injectdll32.pch 的预编译头 (PCH) 文件和
    名为 StdAfx.obj 的预编译类型文件。

/////////////////////////////////////////////////////////////////////////////
其他注释：

应用程序向导使用“TODO:”注释来指示应添加或自定义的源代码部分。

/////////////////////////////////////////////////////////////////////////////

```

`arkProject/HeavenShadow/injectdll32/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by injectdll32.rc
//

#define IDS_APP_TITLE			103

#define IDR_MAINFRAME			128
#define IDD_INJECTDLL32_DIALOG	102
#define IDD_ABOUTBOX			103
#define IDM_ABOUT				104
#define IDM_EXIT				105
#define IDI_INJECTDLL32			107
#define IDI_SMALL				108
#define IDC_INJECTDLL32			109
#define IDC_MYICON				2
#ifndef IDC_STATIC
#define IDC_STATIC				-1
#endif
// 新对象的下一组默认值
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NO_MFC					130
#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_COMMAND_VALUE		32771
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		110
#endif
#endif

```

`arkProject/HeavenShadow/injectdll32/injectdll32.cpp`:

```cpp
// injectdll32.cpp : 定义应用程序的入口点。
//

#include "stdafx.h"
#include "injectdll32.h"

#include "InjectFunc32.h"

#define MAX_LOADSTRING 100

// 全局变量:
HINSTANCE hInst;								// 当前实例
TCHAR szTitle[MAX_LOADSTRING];					// 标题栏文本
TCHAR szWindowClass[MAX_LOADSTRING];			// 主窗口类名

// 此代码模块中包含的函数的前向声明:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

LPTSTR m_lpCmdLine = NULL;

int APIENTRY _tWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR    lpCmdLine,
                     int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

 	// TODO: 在此放置代码。

	HACCEL hAccelTable;

	// 初始化全局字符串
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_INJECTDLL32, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	m_lpCmdLine = lpCmdLine;

	// 执行应用程序初始化:
	if (!InitInstance (hInstance, nCmdShow))
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_INJECTDLL32));

	// 主消息循环:
// 	while (GetMessage(&msg, NULL, 0, 0))
// 	{
// 		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
// 		{
// 			TranslateMessage(&msg);
// 			DispatchMessage(&msg);
// 		}
// 	}

	return FALSE;
}



//
//  函数: MyRegisterClass()
//
//  目的: 注册窗口类。
//
//  注释:
//
//    仅当希望
//    此代码与添加到 Windows 95 中的“RegisterClassEx”
//    函数之前的 Win32 系统兼容时，才需要此函数及其用法。调用此函数十分重要，
//    这样应用程序就可以获得关联的
//    “格式正确的”小图标。
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_INJECTDLL32));
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_INJECTDLL32);
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	return RegisterClassEx(&wcex);
}

//
//   函数: InitInstance(HINSTANCE, int)
//
//   目的: 保存实例句柄并创建主窗口
//
//   注释:
//
//        在此函数中，我们在全局变量中保存实例句柄并
//        创建和显示主程序窗口。
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	WCHAR* Temp = m_lpCmdLine;

	if (wcslen(Temp) > 0)
	{
		HsRemoteThreadInjectDll32(Temp);
	}

	return TRUE;
}

//
//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  目的: 处理主窗口的消息。
//
//  WM_COMMAND	- 处理应用程序菜单
//  WM_PAINT	- 绘制主窗口
//  WM_DESTROY	- 发送退出消息并返回
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;

	switch (message)
	{
	case WM_COMMAND:
		wmId    = LOWORD(wParam);
		wmEvent = HIWORD(wParam);
		// 分析菜单选择:
		switch (wmId)
		{
		case IDM_ABOUT:
			DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
			break;
		case IDM_EXIT:
			DestroyWindow(hWnd);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
		break;
	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);
		// TODO: 在此添加任意绘图代码...
		EndPaint(hWnd, &ps);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

// “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	switch (message)
	{
	case WM_INITDIALOG:
		return (INT_PTR)TRUE;

	case WM_COMMAND:
		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
		{
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR)TRUE;
		}
		break;
	}
	return (INT_PTR)FALSE;
}

```

`arkProject/HeavenShadow/injectdll32/injectdll32.h`:

```h
#pragma once

#include "resource.h"

```

`arkProject/HeavenShadow/injectdll32/injectdll32.rc`:

```rc
//Microsoft Visual C++ 生成的资源脚本。
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 2 资源生成。
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2

/////////////////////////////////////////////////////////////////////////////
//
// 图标
//

// ID 值最低的图标放在最前面，以确保应用程序图标
// 在所有系统中保持一致。

IDI_INJECTDLL32       ICON         "injectdll32.ico"
IDI_SMALL               ICON         "small.ico"

/////////////////////////////////////////////////////////////////////////////
//
// 菜单
//

IDC_INJECTDLL32 MENU
BEGIN
    POPUP "文件(&F)"
    BEGIN
        MENUITEM "退出(&X)",                IDM_EXIT
    END
    POPUP "帮助(&H)"
    BEGIN
        MENUITEM "关于(&A) ...",           IDM_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// 快捷键
//

IDC_INJECTDLL32 ACCELERATORS
BEGIN
    "?",            IDM_ABOUT,              ASCII,  ALT
    "/",            IDM_ABOUT,              ASCII,  ALT
END


/////////////////////////////////////////////////////////////////////////////
//
// 对话框
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 injectdll32"
FONT 9, "MS Shell Dlg"
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "injectdll32，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2014",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END
END
#endif    // APSTUDIO_INVOKED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""windows.h""\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// 字符串表
//

STRINGTABLE
BEGIN
   IDC_INJECTDLL32   "INJECTDLL32"
   IDS_APP_TITLE       "injectdll32"
END

#endif
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 3 资源生成。
//

/////////////////////////////////////////////////////////////////////////////
#endif    // 不是 APSTUDIO_INVOKED

```

`arkProject/HeavenShadow/injectdll32/injectdll32.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{53E8A28F-7458-42B6-9AFA-200CBCC48221}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>injectdll32</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="injectdll32.ico" />
    <None Include="ReadMe.txt" />
    <None Include="small.ico" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="injectdll32.h" />
    <ClInclude Include="InjectFunc32.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="injectdll32.cpp" />
    <ClCompile Include="InjectFunc32.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="injectdll32.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`arkProject/HeavenShadow/injectdll32/injectdll32.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="注入函数">
      <UniqueIdentifier>{c3207227-e44d-441a-b01b-b0de98727eaf}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="small.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="injectdll32.ico">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="injectdll32.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="InjectFunc32.h">
      <Filter>注入函数</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="injectdll32.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="InjectFunc32.cpp">
      <Filter>注入函数</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="injectdll32.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`arkProject/HeavenShadow/injectdll32/injectdll32.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`arkProject/HeavenShadow/injectdll32/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// injectdll32.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中
// 引用任何所需的附加头文件，而不是在此文件中引用

```

`arkProject/HeavenShadow/injectdll32/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             //  从 Windows 头文件中排除极少使用的信息
// Windows 头文件:
#include <windows.h>

// C 运行时头文件
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <Windows.h>
#include <CommDlg.h>


// TODO: 在此处引用程序需要的其他头文件

```

`arkProject/HeavenShadow/injectdll32/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`arkProject/HeavenShadow/injectdll64/InjectFunc64.cpp`:

```cpp
#include "stdafx.h"

#include "InjectFunc64.h"

WIN_VERSION  GetWindowsVersion();
WIN_VERSION  WinVersion = WinUnknown;

typedef long (__fastcall *pfnRtlAdjustPrivilege64)(ULONG,ULONG,ULONG,PVOID);
typedef long (__fastcall *pfnRtlAdjustPrivilege32)(ULONG,ULONG,ULONG,PVOID);
pfnRtlAdjustPrivilege64 RtlAdjustPrivilege64;
pfnRtlAdjustPrivilege32 RtlAdjustPrivilege32;

static OPENFILENAME ofn ;

DWORD HsRemoteThreadInjectDll64(WCHAR* ProcessInfo)
{
	ULONG_PTR ProcessId = 0;
	WCHAR*    ProcessPath = NULL;
	WCHAR wzFileFilter[] = L"应用程序扩展 (*.dll)\0*.dll\0所有文件 (*.*)\0*.*\0";
	WCHAR wzFileChoose[] = L"打开文件";

	int i;
	int j;

	WCHAR szPid[10] = {0};

	for (i = 0; _wcsnicmp(ProcessInfo+i,L"-d ",wcslen(L"-d "))!=0 && i<=10 ;i++);

	if (i == 10)
	{
		return FALSE;
	}

	WCHAR* PidTemp = ProcessInfo + i + wcslen(L"-d ");

	j = i;

	for ( ; _wcsnicmp(ProcessInfo + j,L" -p ",wcslen(L" -p "))!=0 && j-i<=10 ;j++);

	if (j-i==10)
	{
		return FALSE;
	}

	memcpy(szPid,PidTemp,j-i);

	ProcessId   = _ttoi(szPid);

	ProcessPath = ProcessInfo + j + wcslen(L" -p ");

	static TCHAR szFileName[MAX_PATH], szTitleName[MAX_PATH] ;
	HWND hwnd;
	hwnd=GetForegroundWindow(); //获取前台窗口句柄。本程序中的前台窗口就是控制台窗口。 
	PopFileInitialize (hwnd);   //初始化ofn
	PopFileOpenDlg(hwnd, szFileName, szTitleName);//打开文件对话框
	
	CString strDllPath = szFileName;

	BOOL bResult = FALSE;

	if (PathFileExists(strDllPath))
	{
		if (HsIs32BitFile(ProcessPath)==FALSE &&
			HsIs32BitFile(strDllPath.GetBuffer())==FALSE)
		{
			bResult = HsInjectDll(FALSE,&strDllPath,ProcessId);
		}
	}

	if (bResult == FALSE)
	{
		::MessageBox(NULL,L"远程线程注入失败。",L"天影卫士",MB_SYSTEMMODAL|MB_OK);

	}
	else
	{
		::MessageBox(NULL,L"远程线程注入成功。",L"天影卫士",MB_SYSTEMMODAL|MB_OK);
	}

	return bResult;
}





BOOL __stdcall HsIs32BitFile(const WCHAR * pwszFullPath)
{
	FILE * peFile = NULL;
	_wfopen_s(&peFile, pwszFullPath, L"rb");
	if (peFile == NULL)
	{
		fclose(peFile);
		return -1;
	}

	IMAGE_DOS_HEADER imageDosHeader;
	fread(&imageDosHeader, sizeof(IMAGE_DOS_HEADER), 1, peFile);
	if (imageDosHeader.e_magic != IMAGE_DOS_SIGNATURE)
	{
		fclose(peFile);
		return FALSE;
	}

	IMAGE_NT_HEADERS imageNtHeaders;
	fseek(peFile, imageDosHeader.e_lfanew, SEEK_SET);
	fread(&imageNtHeaders, sizeof(IMAGE_NT_HEADERS), 1, peFile);
	fclose(peFile);
	if (imageNtHeaders.Signature != IMAGE_NT_SIGNATURE)
	{
		return FALSE;
	}

	if (imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
	{
		return TRUE;
	}
	// 	if (imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_IA64 ||
	// 		imageNtHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
	// 	{
	// 		return FALSE;	//64BIT
	// 	}

	return FALSE;
}





//改程序编译成64位可以注入64位 编译成32位可以注入32位

BOOL HsInjectDll(BOOL Is32Bit, CString* strDllPath, ULONG_PTR ProcessID)
{
	BOOL bResult = FALSE;

	if (ProcessID <= 0)
	{
		return FALSE;
	}


	if (PathFileExists(*strDllPath))
	{
		WinVersion = GetWindowsVersion();

		switch(WinVersion)
		{
		case Windows7:   //注意我们这里针对的是64位的Win7
			{

				WCHAR wzPath[MAX_PATH] = {0};
				wcscpy_s(wzPath, strDllPath->GetBuffer());
				strDllPath->ReleaseBuffer();

				bResult = HsInjectDllByRemoteThreadWin7(wzPath,ProcessID,Is32Bit);

				break;
			}

		case WindowsXP:  //这里是针对的32位的XP
			{
				WCHAR wzPath[MAX_PATH] = {0};
				wcscpy_s(wzPath, strDllPath->GetBuffer());

				strDllPath->ReleaseBuffer();

				bResult = HsInjectDllByRemoteThreadWinXP(wzPath,ProcessID);

				break;
			}
		}
	}
	return bResult;
}


BOOL HsInjectDllByRemoteThreadWin7(const TCHAR* wzDllFile, ULONG_PTR ProcessId, BOOL Is32Bit)
{
	if (NULL == wzDllFile || 0 == ::_tcslen(wzDllFile) || ProcessId == 0 || -1 == _taccess(wzDllFile, 0))
	{
		return FALSE;
	}
	HANDLE                 hProcess = NULL;
	HANDLE                 hThread  = NULL;
	DWORD                  dwRetVal    = 0;
	LPTHREAD_START_ROUTINE FuncAddress = NULL;
	DWORD  dwSize = 0;
	TCHAR* VirtualAddress = NULL;

#ifdef _UNICODE
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
	FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif

	if (FuncAddress==NULL)
	{
		return FALSE;
	}


	RtlAdjustPrivilege64=(pfnRtlAdjustPrivilege64)GetProcAddress((HMODULE)(FuncAddress(L"ntdll.dll")),"RtlAdjustPrivilege");

	if (RtlAdjustPrivilege64==NULL)
	{
		return FALSE;
	}
	RtlAdjustPrivilege64(20,1,0,&dwRetVal);  //19


	hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE, (DWORD)ProcessId);

	if (NULL == hProcess)
	{
		printf("Open Process Fail\r\n");
		return FALSE;
	}

	// 在目标进程中分配内存空间
	dwSize = (DWORD)::_tcslen(wzDllFile) + 1;
	VirtualAddress = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE);  
	if (NULL == VirtualAddress)
	{

		printf("Virtual Process Memory Fail\r\n");
		CloseHandle(hProcess);
		return FALSE;
	}

	// 在目标进程的内存空间中写入所需参数(模块名)
	if (FALSE == ::WriteProcessMemory(hProcess, VirtualAddress, (LPVOID)wzDllFile, dwSize * sizeof(TCHAR), NULL))
	{
		printf("Write Data Fail\r\n");
		VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
		CloseHandle(hProcess);
		return FALSE;
	}

	hThread = ::CreateRemoteThread(hProcess, NULL, 0, FuncAddress, VirtualAddress, 0, NULL);
	if (NULL == hThread)
	{
		printf("CreateRemoteThread Fail\r\n");

		VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
		CloseHandle(hProcess);
		return FALSE;
	}


	// 等待远程线程结束
	WaitForSingleObject(hThread, INFINITE);
	// 清理
	VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
	CloseHandle(hThread);
	CloseHandle(hProcess);

	return TRUE;

}




BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId)
{
	//提高本进程的权限

	if (!HsInjectUpPrivilige())  //提权
	{
		printf("Up Privilige Is Error\n");
		return FALSE;
	}

	CStringA *Dll = new CStringA(wzDllFile);


	//我们就要打开想要打开的进程
	HANDLE hProcess = NULL;
	HANDLE hThread  = NULL;

	hProcess = OpenProcess(PROCESS_ALL_ACCESS,false,(DWORD)ProcessId);  //explorer.exe  hProcess
	if (hProcess==NULL)
	{
		printf("Open Process Is Error\n");

		return FALSE;
	}

	char* szDllName = NULL;

	szDllName = (char*)VirtualAllocEx(hProcess,
		NULL,Dll->GetLength()+1,MEM_COMMIT,PAGE_READWRITE);   

	if (szDllName==NULL)
	{

		CloseHandle(hProcess);
		printf("Apply Memory Is Error\n");

		return FALSE;
	}

	//然后将完整的路径直接写入内存

	if (!WriteProcessMemory(hProcess,szDllName,Dll->GetBuffer(),Dll->GetLength()+1,NULL))
	{

		CloseHandle(hProcess);

		printf("Write Memory Is Error\n");

		return FALSE;
	}

	LPTHREAD_START_ROUTINE StartRoutine = NULL;

	StartRoutine = 
		(LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")),
		"LoadLibraryA");

	if(StartRoutine == NULL)
	{
		printf("Get ProcAddress Error\n");
		return FALSE;
	}

	hThread = CreateRemoteThread(hProcess,NULL,0,StartRoutine,szDllName,0,NULL);

	if (hThread==NULL)
	{
		CloseHandle(hProcess);

		printf("Create Remote Thread Is Error\n");

		return FALSE;
	}

	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);
	VirtualFreeEx(hProcess,szDllName,0,MEM_RELEASE);
	CloseHandle(hProcess);

	return TRUE;
}


BOOL HsInjectUpPrivilige()	//XP
{

	HANDLE hToken = NULL;

	_TOKEN_PRIVILEGES tp = {0};

	LUID luid={0};


	if (!OpenProcessToken(GetCurrentProcess(),TOKEN_ALL_ACCESS,&hToken))
	{
		printf("OpenProcess Is Error\n");

		return FALSE;
	}

	if (!LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&luid))
	{

		printf("Lookup Is Error\n");

		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


	if (!AdjustTokenPrivileges(hToken,FALSE,&tp,sizeof(TOKEN_PRIVILEGES),NULL,NULL))
	{
		printf("Adjust Is Error\n");

		return FALSE;
	}

	return TRUE;
}


/*
BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId)
{
// 参数无效
if (NULL == wzDllFile || 0 == ::_tcslen(wzDllFile) || ProcessId == 0 || -1 == _taccess(wzDllFile, 0))
{

return FALSE;
}

HANDLE hProcess = NULL;
HANDLE hThread  = NULL;
DWORD dwSize = 0;
TCHAR* VirtualAddress = NULL;
LPTHREAD_START_ROUTINE FuncAddress = NULL;

// 获取目标进程句柄
hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, (DWORD)ProcessId);
if (NULL == hProcess)
{
printf("Open Process Fail\r\n");
return FALSE;
}

// 在目标进程中分配内存空间
dwSize = (DWORD)::_tcslen(wzDllFile) + 1;
VirtualAddress = (TCHAR*)::VirtualAllocEx(hProcess, NULL, dwSize * sizeof(TCHAR), MEM_COMMIT, PAGE_READWRITE);
if (NULL == VirtualAddress)
{

printf("Virtual Process Memory Fail\r\n");
CloseHandle(hProcess);
return FALSE;
}

// 在目标进程的内存空间中写入所需参数(模块名)
if (FALSE == ::WriteProcessMemory(hProcess, VirtualAddress, (LPVOID)wzDllFile, dwSize * sizeof(TCHAR), NULL))
{
printf("Write Data Fail\r\n");
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return FALSE;
}

// 从 Kernel32.dll 中获取 LoadLibrary 函数地址
#ifdef _UNICODE
FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryW");
#else
FuncAddress = (PTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandle(_T("Kernel32")), "LoadLibraryA");
#endif

if (NULL == FuncAddress)
{
printf("Get LoadLibrary Fail\r\n");
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return false;
}

// 创建远程线程调用 LoadLibrary
hThread = ::CreateRemoteThread(hProcess, NULL, 0, FuncAddress, VirtualAddress, 0, NULL);
if (NULL == hThread)
{
printf("CreateRemoteThread Fail\r\n");

VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hProcess);
return FALSE;
}

// 等待远程线程结束
WaitForSingleObject(hThread, INFINITE);
// 清理
VirtualFreeEx(hProcess, VirtualAddress, dwSize, MEM_DECOMMIT);
CloseHandle(hThread);
CloseHandle(hProcess);

return TRUE;
}


*/




WIN_VERSION  GetWindowsVersion()
{
	OSVERSIONINFOEX	OsVerInfoEx;
	OsVerInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx((OSVERSIONINFO *)&OsVerInfoEx); // 注意转换类型

	switch (OsVerInfoEx.dwPlatformId)
	{
	case VER_PLATFORM_WIN32_NT:
		{
			if (OsVerInfoEx.dwMajorVersion <= 4 )
			{
				return WindowsNT;
			}
			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 0)
			{
				return Windows2000;
			}

			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 1)
			{
				return WindowsXP;
			}
			if (OsVerInfoEx.dwMajorVersion == 5 && OsVerInfoEx.dwMinorVersion == 2)
			{
				return Windows2003;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 0)
			{
				return WindowsVista;
			}

			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 1)
			{
				return Windows7;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 2 )
			{
				return Windows8;
			}
			if (OsVerInfoEx.dwMajorVersion == 6 && OsVerInfoEx.dwMinorVersion == 3 )
			{
				return Windows8_1;
			}
			if (OsVerInfoEx.dwMajorVersion == 10 && OsVerInfoEx.dwMinorVersion == 0 )
			{
				return Windows10;
			}

			break;
		}

	default:
		{
			return WinUnknown;
		}
	}

	return WinUnknown;
}




void PopFileInitialize (HWND hwnd)
{
	static TCHAR szFilter[] = TEXT ("应用程序扩展 (*.dll)\0*.dll\0\0");

	ofn.lStructSize       = sizeof (OPENFILENAME) ;
	ofn.hwndOwner         = hwnd ;
	ofn.hInstance         = NULL ;
	ofn.lpstrFilter       = szFilter ;
	ofn.lpstrCustomFilter = NULL ;
	ofn.nMaxCustFilter    = 0 ;
	ofn.nFilterIndex      = 0 ;
	ofn.lpstrFile         = NULL ;          // Set in Open and Close functions
	ofn.nMaxFile          = MAX_PATH ;
	ofn.lpstrFileTitle    = NULL ;          // Set in Open and Close functions
	ofn.nMaxFileTitle     = MAX_PATH ;
	ofn.lpstrInitialDir   = NULL ;
	ofn.lpstrTitle        = NULL ;
	ofn.Flags             = 0 ;             // Set in Open and Close functions
	ofn.nFileOffset       = 0 ;
	ofn.nFileExtension    = 0 ;
	ofn.lpstrDefExt       = TEXT ("dll") ;
	ofn.lCustData         = 0L ;
	ofn.lpfnHook          = NULL ;
	ofn.lpTemplateName    = NULL ;
}

BOOL PopFileOpenDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName)
{
	ofn.hwndOwner         = hwnd ;
	ofn.lpstrFile         = pstrFileName ;
	ofn.lpstrFileTitle    = pstrTitleName ;
	ofn.Flags             = OFN_HIDEREADONLY | OFN_CREATEPROMPT ;

	return GetOpenFileName (&ofn) ;
}

```

`arkProject/HeavenShadow/injectdll64/InjectFunc64.h`:

```h
#pragma once
#include "stdafx.h"
#include <atlstr.h>

typedef enum _WIN_VERSION
{
	WindowsNT,
	Windows2000,
	WindowsXP,
	Windows2003,
	WindowsVista,
	Windows7,
	Windows8,
	Windows8_1,
	Windows10,
	WinUnknown
}WIN_VERSION;

DWORD HsRemoteThreadInjectDll64(WCHAR* ProcessInfo);
BOOL __stdcall HsIs32BitFile(const WCHAR * pwszFullPath);

WIN_VERSION  GetWindowsVersion();
BOOL HsInjectUpPrivilige();	//XP
BOOL HsInjectDllByRemoteThreadWinXP(const TCHAR* wzDllFile, ULONG_PTR ProcessId);
BOOL HsInjectDllByRemoteThreadWin7(const TCHAR* wzDllFile, ULONG_PTR ProcessId, BOOL Is32Bit);
BOOL HsInjectDll(BOOL Is32Bit, CString* strDllPath, ULONG_PTR ProcessID);

void PopFileInitialize (HWND hwnd);
BOOL PopFileOpenDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName);
```

`arkProject/HeavenShadow/injectdll64/ReadMe.txt`:

```txt
========================================================================
    WIN32 应用程序：injectdll64 项目概述
========================================================================

应用程序向导已为您创建了此 injectdll64 应用程序。

本文件概要介绍组成 injectdll64 应用程序的每个文件的内容。


injectdll64.vcxproj
    这是使用应用程序向导生成的 VC++ 项目的主项目文件，
    其中包含生成该文件的 Visual C++ 
    的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

injectdll64.vcxproj.filters
    这是使用“应用程序向导”生成的 VC++ 项目筛选器文件。 
    它包含有关项目文件与筛选器之间的关联信息。 在 IDE 
    中，通过这种关联，在特定节点下以分组形式显示具有相似扩展名的文件。
    例如，“.cpp”文件与“源文件”筛选器关联。

injectdll64.cpp
    这是主应用程序源文件。

/////////////////////////////////////////////////////////////////////////////
应用程序向导创建了下列资源：

injectdll64.rc
    这是程序使用的所有 Microsoft Windows 资源的列表。  它包括 RES 
    子目录中存储的图标、位图和光标。  此文件可以直接在 Microsoft Visual C++ 
    中进行编辑。

Resource.h
    这是标准头文件，可用于定义新的资源 ID。
    Microsoft Visual C++ 将读取并更新此文件。

injectdll64.ico
    这是用作应用程序图标 (32x32) 的图标文件。
    此图标包括在主资源文件 injectdll64.rc 中。

small.ico
    这是一个图标文件，其中包含应用程序的图标的较小版本 (16x16)。 
    此图标包括在主资源文件 injectdll64.rc 中。

/////////////////////////////////////////////////////////////////////////////
其他标准文件：

StdAfx.h，StdAfx.cpp
    这些文件用于生成名为 injectdll64.pch 的预编译头 (PCH) 文件和
    名为 StdAfx.obj 的预编译类型文件。

/////////////////////////////////////////////////////////////////////////////
其他注释：

应用程序向导使用“TODO:”注释来指示应添加或自定义的源代码部分。

/////////////////////////////////////////////////////////////////////////////

```

`arkProject/HeavenShadow/injectdll64/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by injectdll64.rc
//

#define IDS_APP_TITLE			103

#define IDR_MAINFRAME			128
#define IDD_INJECTDLL64_DIALOG	102
#define IDD_ABOUTBOX			103
#define IDM_ABOUT				104
#define IDM_EXIT				105
#define IDI_INJECTDLL64			107
#define IDI_SMALL				108
#define IDC_INJECTDLL64			109
#define IDC_MYICON				2
#ifndef IDC_STATIC
#define IDC_STATIC				-1
#endif
// 新对象的下一组默认值
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NO_MFC					130
#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_COMMAND_VALUE		32771
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		110
#endif
#endif

```

`arkProject/HeavenShadow/injectdll64/injectdll64.cpp`:

```cpp
// injectdll64.cpp : 定义应用程序的入口点。
//

#include "stdafx.h"
#include "injectdll64.h"

#include "InjectFunc64.h"

#define MAX_LOADSTRING 100

// 全局变量:
HINSTANCE hInst;								// 当前实例
TCHAR szTitle[MAX_LOADSTRING];					// 标题栏文本
TCHAR szWindowClass[MAX_LOADSTRING];			// 主窗口类名

// 此代码模块中包含的函数的前向声明:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

LPTSTR m_lpCmdLine = NULL;

int APIENTRY _tWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR    lpCmdLine,
                     int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

 	// TODO: 在此放置代码。

	HACCEL hAccelTable;

	// 初始化全局字符串
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_INJECTDLL64, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	m_lpCmdLine = lpCmdLine;

	// 执行应用程序初始化:
	if (!InitInstance (hInstance, nCmdShow))
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_INJECTDLL64));

	// 主消息循环:
// 	while (GetMessage(&msg, NULL, 0, 0))
// 	{
// 		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
// 		{
// 			TranslateMessage(&msg);
// 			DispatchMessage(&msg);
// 		}
// 	}

	return FALSE;
}



//
//  函数: MyRegisterClass()
//
//  目的: 注册窗口类。
//
//  注释:
//
//    仅当希望
//    此代码与添加到 Windows 95 中的“RegisterClassEx”
//    函数之前的 Win32 系统兼容时，才需要此函数及其用法。调用此函数十分重要，
//    这样应用程序就可以获得关联的
//    “格式正确的”小图标。
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_INJECTDLL64));
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_INJECTDLL64);
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	return RegisterClassEx(&wcex);
}

//
//   函数: InitInstance(HINSTANCE, int)
//
//   目的: 保存实例句柄并创建主窗口
//
//   注释:
//
//        在此函数中，我们在全局变量中保存实例句柄并
//        创建和显示主程序窗口。
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	WCHAR* Temp = m_lpCmdLine;

	if (wcslen(Temp) > 0)
	{
		HsRemoteThreadInjectDll64(Temp);
	}
	
	return TRUE;
}

//
//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  目的: 处理主窗口的消息。
//
//  WM_COMMAND	- 处理应用程序菜单
//  WM_PAINT	- 绘制主窗口
//  WM_DESTROY	- 发送退出消息并返回
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;

	switch (message)
	{
	case WM_COMMAND:
		wmId    = LOWORD(wParam);
		wmEvent = HIWORD(wParam);
		// 分析菜单选择:
		switch (wmId)
		{
		case IDM_ABOUT:
			DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
			break;
		case IDM_EXIT:
			DestroyWindow(hWnd);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
		break;
	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);
		// TODO: 在此添加任意绘图代码...
		EndPaint(hWnd, &ps);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

// “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	switch (message)
	{
	case WM_INITDIALOG:
		return (INT_PTR)TRUE;

	case WM_COMMAND:
		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
		{
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR)TRUE;
		}
		break;
	}
	return (INT_PTR)FALSE;
}




```

`arkProject/HeavenShadow/injectdll64/injectdll64.h`:

```h
#pragma once

#include "resource.h"

```

`arkProject/HeavenShadow/injectdll64/injectdll64.rc`:

```rc
//Microsoft Visual C++ 生成的资源脚本。
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 2 资源生成。
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2

/////////////////////////////////////////////////////////////////////////////
//
// 图标
//

// ID 值最低的图标放在最前面，以确保应用程序图标
// 在所有系统中保持一致。

IDI_INJECTDLL64       ICON         "injectdll64.ico"
IDI_SMALL               ICON         "small.ico"

/////////////////////////////////////////////////////////////////////////////
//
// 菜单
//

IDC_INJECTDLL64 MENU
BEGIN
    POPUP "文件(&F)"
    BEGIN
        MENUITEM "退出(&X)",                IDM_EXIT
    END
    POPUP "帮助(&H)"
    BEGIN
        MENUITEM "关于(&A) ...",           IDM_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// 快捷键
//

IDC_INJECTDLL64 ACCELERATORS
BEGIN
    "?",            IDM_ABOUT,              ASCII,  ALT
    "/",            IDM_ABOUT,              ASCII,  ALT
END


/////////////////////////////////////////////////////////////////////////////
//
// 对话框
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 injectdll64"
FONT 9, "MS Shell Dlg"
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "injectdll64，1.0 版",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2014",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END
END
#endif    // APSTUDIO_INVOKED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""windows.h""\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// 字符串表
//

STRINGTABLE
BEGIN
   IDC_INJECTDLL64   "INJECTDLL64"
   IDS_APP_TITLE       "injectdll64"
END

#endif
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// 从 TEXTINCLUDE 3 资源生成。
//

/////////////////////////////////////////////////////////////////////////////
#endif    // 不是 APSTUDIO_INVOKED

```

`arkProject/HeavenShadow/injectdll64/injectdll64.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F7C83834-3D4A-4362-9E7B-5EE1F4D68C89}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>injectdll64</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="injectdll64.ico" />
    <None Include="ReadMe.txt" />
    <None Include="small.ico" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="injectdll64.h" />
    <ClInclude Include="InjectFunc64.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="injectdll64.cpp" />
    <ClCompile Include="InjectFunc64.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="injectdll64.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`arkProject/HeavenShadow/injectdll64/injectdll64.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="注入函数">
      <UniqueIdentifier>{c54db13b-b85e-48e1-b87f-c04eb9a9214a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
    <None Include="small.ico">
      <Filter>资源文件</Filter>
    </None>
    <None Include="injectdll64.ico">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="injectdll64.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="InjectFunc64.h">
      <Filter>注入函数</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="injectdll64.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="InjectFunc64.cpp">
      <Filter>注入函数</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="injectdll64.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`arkProject/HeavenShadow/injectdll64/injectdll64.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`arkProject/HeavenShadow/injectdll64/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// injectdll64.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中
// 引用任何所需的附加头文件，而不是在此文件中引用

```

`arkProject/HeavenShadow/injectdll64/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             //  从 Windows 头文件中排除极少使用的信息
// Windows 头文件:
#include <windows.h>

// C 运行时头文件
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <Windows.h>
#include <CommDlg.h>

// TODO: 在此处引用程序需要的其他头文件

```

`arkProject/HeavenShadow/injectdll64/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HeavenShadowDrv", "HeavenShadowDrv\HeavenShadowDrv.vcxproj", "{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Debug|Win32.ActiveCfg = Debug|Win32
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Debug|Win32.Build.0 = Debug|Win32
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Debug|x64.ActiveCfg = Debug|x64
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Debug|x64.Build.0 = Debug|x64
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Release|Win32.ActiveCfg = Release|Win32
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Release|Win32.Build.0 = Release|Win32
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Release|x64.ActiveCfg = Release|x64
		{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/HeavenShadowDrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9CE3B5BD-26EB-448B-B7C2-B70BBB649328}</ProjectGuid>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup>
    <IncludePath>$(IncludePath)</IncludePath>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</GenerateManifest>
    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</GenerateManifest>
    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</GenerateManifest>
    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateManifest>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">.sys</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">.sys</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.sys</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|x64'">.sys</TargetExt>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)Build\$(ProjectName)\DbgX86\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)Build\$(ProjectName)\DbgX64\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)Build\$(ProjectName)\RlsX86\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)Build\$(ProjectName)\RlsX64\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)Build\$(ProjectName)\DbgX86\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)Build\$(ProjectName)\DbgX64\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)Build\$(ProjectName)\RlsX86\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)Build\$(ProjectName)\RlsX64\</IntDir>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)</TargetName>
    <CustomBuildAfterTargets Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    </CustomBuildAfterTargets>
    <CustomBuildAfterTargets Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CustomBuildAfterTargets Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CustomBuildAfterTargets Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CustomBuildBeforeTargets Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    </CustomBuildBeforeTargets>
    <CustomBuildBeforeTargets Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CustomBuildBeforeTargets Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CustomBuildBeforeTargets Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName);$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc;%(AdditionalIncludeDirectori</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_CONSOLE;_X86_;_DDK_;_DEBUG;DBG=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <AdditionalLibraryDirectories>$(WLHBASE)\lib\win7\i386;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;ntstrsafe.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName);$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc;%(AdditionalIncludeDirectori</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN64;_CONSOLE;_AMD64_;_DDK_;_DEBUG;DBG=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <AdditionalLibraryDirectories>$(WLHBASE)\lib\win7\amd64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;ntstrsafe.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
    <PreBuildEvent>
      <Command>if exist "$(SolutionDir)$(SolutionName).suo" (
attrib -h "$(SolutionDir)$(SolutionName).suo"
del "$(SolutionDir)$(SolutionName).suo")
</Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>"$(ProjectDir)Signature.bat" "$(TargetPath)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName);$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc;%(AdditionalIncludeDirectori</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_CONSOLE;_X86_;_DDK_;_NDEBUG;DBG=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(WLHBASE)\lib\win7\i386;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;ntstrsafe.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName);$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc;%(AdditionalIncludeDirectori</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN64;_CONSOLE;_AMD64_;_DDK_;_NDEBUG;DBG=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(WLHBASE)\lib\win7\amd64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;ntstrsafe.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
    <PreBuildEvent>
      <Command>if exist "$(SolutionDir)$(SolutionName).suo" (
attrib -h "$(SolutionDir)$(SolutionName).suo"
del "$(SolutionDir)$(SolutionName).suo")
</Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>"$(ProjectDir)Signature.bat" "$(TargetPath)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Source\CallBack.h" />
    <ClInclude Include="Source\common.h" />
    <ClInclude Include="Source\DpcTimer.h" />
    <ClInclude Include="Source\FilterDriver.h" />
    <ClInclude Include="Source\GetFuncAddress.h" />
    <ClInclude Include="Source\GetSSSDTFuncAddress.h" />
    <ClInclude Include="Source\Handle.h" />
    <ClInclude Include="Source\HeavenShadowDrv.h" />
    <ClInclude Include="Source\IoTimer.h" />
    <ClInclude Include="Source\Kernel.h" />
    <ClInclude Include="Source\KrnlFile.h" />
    <ClInclude Include="Source\Memory.h" />
    <ClInclude Include="Source\Module.h" />
    <ClInclude Include="Source\Privilege.h" />
    <ClInclude Include="Source\Process.h" />
    <ClInclude Include="Source\System.h" />
    <ClInclude Include="Source\SysThread.h" />
    <ClInclude Include="Source\Thread.h" />
    <ClInclude Include="Source\Window.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\CallBack.c" />
    <ClCompile Include="Source\common.c" />
    <ClCompile Include="Source\DpcTimer.c" />
    <ClCompile Include="Source\FilterDriver.c" />
    <ClCompile Include="Source\GetFuncAddress.c" />
    <ClCompile Include="Source\GetSSSDTFuncAddress.c" />
    <ClCompile Include="Source\Handle.c" />
    <ClCompile Include="Source\HeavenShadowDrv.c" />
    <ClCompile Include="Source\IoTimer.c" />
    <ClCompile Include="Source\Kernel.c" />
    <ClCompile Include="Source\KrnlFile.c" />
    <ClCompile Include="Source\Memory.c" />
    <ClCompile Include="Source\Module.c" />
    <ClCompile Include="Source\Privilege.c" />
    <ClCompile Include="Source\Process.c" />
    <ClCompile Include="Source\System.c" />
    <ClCompile Include="Source\SysThread.c" />
    <ClCompile Include="Source\Thread.c" />
    <ClCompile Include="Source\Window.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/HeavenShadowDrv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="主要文件">
      <UniqueIdentifier>{bad0c572-5768-45b3-8fad-cd53d570d7fa}</UniqueIdentifier>
      <Extensions>hpp;h</Extensions>
    </Filter>
    <Filter Include="源码文件">
      <UniqueIdentifier>{b1de6577-e8f0-441c-a634-bbdff67996a8}</UniqueIdentifier>
      <Extensions>cpp;c;def</Extensions>
    </Filter>
    <Filter Include="源码文件\进程">
      <UniqueIdentifier>{0b59cd14-c3b3-4f18-905c-9dd96064bb7e}</UniqueIdentifier>
    </Filter>
    <Filter Include="源码文件\模块">
      <UniqueIdentifier>{a354b1b6-0408-4505-a6ca-f894ee1cc5b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="源码文件\内核">
      <UniqueIdentifier>{cf9b4149-a063-4ef4-a736-da90f4c361d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="源码文件\钩子">
      <UniqueIdentifier>{9d1b22be-ff73-4cd4-a9d7-62e52ddfc61c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Source\HeavenShadowDrv.h">
      <Filter>主要文件</Filter>
    </ClInclude>
    <ClInclude Include="Source\Process.h">
      <Filter>源码文件\进程</Filter>
    </ClInclude>
    <ClInclude Include="Source\Thread.h">
      <Filter>源码文件\进程</Filter>
    </ClInclude>
    <ClInclude Include="Source\Window.h">
      <Filter>源码文件\进程</Filter>
    </ClInclude>
    <ClInclude Include="Source\Privilege.h">
      <Filter>源码文件\进程</Filter>
    </ClInclude>
    <ClInclude Include="Source\Handle.h">
      <Filter>源码文件\进程</Filter>
    </ClInclude>
    <ClInclude Include="Source\Memory.h">
      <Filter>源码文件\进程</Filter>
    </ClInclude>
    <ClInclude Include="Source\Module.h">
      <Filter>源码文件\模块</Filter>
    </ClInclude>
    <ClInclude Include="Source\CallBack.h">
      <Filter>源码文件\内核</Filter>
    </ClInclude>
    <ClInclude Include="Source\DpcTimer.h">
      <Filter>源码文件\内核</Filter>
    </ClInclude>
    <ClInclude Include="Source\FilterDriver.h">
      <Filter>源码文件\内核</Filter>
    </ClInclude>
    <ClInclude Include="Source\IoTimer.h">
      <Filter>源码文件\内核</Filter>
    </ClInclude>
    <ClInclude Include="Source\SysThread.h">
      <Filter>源码文件\内核</Filter>
    </ClInclude>
    <ClInclude Include="Source\System.h">
      <Filter>源码文件\内核</Filter>
    </ClInclude>
    <ClInclude Include="Source\GetSSSDTFuncAddress.h">
      <Filter>主要文件</Filter>
    </ClInclude>
    <ClInclude Include="Source\common.h">
      <Filter>主要文件</Filter>
    </ClInclude>
    <ClInclude Include="Source\GetFuncAddress.h">
      <Filter>主要文件</Filter>
    </ClInclude>
    <ClInclude Include="Source\Kernel.h">
      <Filter>源码文件\钩子</Filter>
    </ClInclude>
    <ClInclude Include="Source\KrnlFile.h">
      <Filter>源码文件\钩子</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\HeavenShadowDrv.c">
      <Filter>主要文件</Filter>
    </ClCompile>
    <ClCompile Include="Source\Process.c">
      <Filter>源码文件\进程</Filter>
    </ClCompile>
    <ClCompile Include="Source\Thread.c">
      <Filter>源码文件\进程</Filter>
    </ClCompile>
    <ClCompile Include="Source\Window.c">
      <Filter>源码文件\进程</Filter>
    </ClCompile>
    <ClCompile Include="Source\Privilege.c">
      <Filter>源码文件\进程</Filter>
    </ClCompile>
    <ClCompile Include="Source\Handle.c">
      <Filter>源码文件\进程</Filter>
    </ClCompile>
    <ClCompile Include="Source\Memory.c">
      <Filter>源码文件\进程</Filter>
    </ClCompile>
    <ClCompile Include="Source\Module.c">
      <Filter>源码文件\模块</Filter>
    </ClCompile>
    <ClCompile Include="Source\CallBack.c">
      <Filter>源码文件\内核</Filter>
    </ClCompile>
    <ClCompile Include="Source\DpcTimer.c">
      <Filter>源码文件\内核</Filter>
    </ClCompile>
    <ClCompile Include="Source\FilterDriver.c">
      <Filter>源码文件\内核</Filter>
    </ClCompile>
    <ClCompile Include="Source\IoTimer.c">
      <Filter>源码文件\内核</Filter>
    </ClCompile>
    <ClCompile Include="Source\SysThread.c">
      <Filter>源码文件\内核</Filter>
    </ClCompile>
    <ClCompile Include="Source\System.c">
      <Filter>源码文件\内核</Filter>
    </ClCompile>
    <ClCompile Include="Source\common.c">
      <Filter>主要文件</Filter>
    </ClCompile>
    <ClCompile Include="Source\GetFuncAddress.c">
      <Filter>主要文件</Filter>
    </ClCompile>
    <ClCompile Include="Source\GetSSSDTFuncAddress.c">
      <Filter>主要文件</Filter>
    </ClCompile>
    <ClCompile Include="Source\Kernel.c">
      <Filter>源码文件\钩子</Filter>
    </ClCompile>
    <ClCompile Include="Source\KrnlFile.c">
      <Filter>源码文件\钩子</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/HeavenShadowDrv.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Signature.bat`:

```bat
rem 该批处理为64位驱动签名
rem @echo off

set iPath=%1
set iDate=%date:~0,10%

echo 尝试进行驱动签名...

if exist "C:\Windows\CSignTool.exe" goto SIGN

echo 未找到签名工具，放弃签名！
goto END

:SIGN
echo.

echo 修改系统日期为 2011/11/11
date 2011/11/11

CSignTool.exe sign /r iDriverSign /f %iPath% /ac

echo 恢复系统日期到 %iDate%
date %iDate%

:END

	









```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/CallBack.c`:

```c
#include "CallBack.h"



//////////////////////////////////////////////////////////////////////////
extern     PDEVICE_OBJECT g_DeviceObject;
extern     PDRIVER_OBJECT g_DriverObject;
//////////////////////////////////////////////////////////////////////////

extern  PVOID        Ntoskrnl_KLDR_DATA_TABLE_ENTRY;
extern  ULONG_PTR    SYSTEM_ADDRESS_START;
extern  WIN_VERSION  WinVersion;

pfnPsSetLoadImageNotifyRoutine PsSetLoadImageNotifyRoutineAddress = NULL;
pfnCmUnRegisterCallback CmUnRegisterCallbackAddress = NULL;
ULONG_PTR      PspLoadImageNotifyRoutineAddress = NULL;
ULONG_PTR      CallBackList = 0;  
pfnKeRegisterBugCheckReasonCallback KeRegisterBugCheckReasonCallbackAddress = NULL;
ULONG_PTR KeBugCheckReasonCallbackListHead = NULL;
pfnKeRegisterBugCheckCallback KeRegisterBugCheckCallbackAddress = NULL;
ULONG_PTR KeBugCheckCallbackListHead = NULL;
pfnIoRegisterShutdownNotification   IoRegisterShutdownNotificationAddress = NULL;
ULONG_PTR IopNotifyShutdownQueueHead = NULL;
pfnPsSetCreateThreadNotifyRoutine   PsSetCreateThreadNotifyRoutineAddress = NULL;
ULONG_PTR PspCreateThreadNotifyRoutineAddress = NULL;


NTSTATUS HsEnumCallBackList(int InputBuffer, PVOID OutputBuffer)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	Status = GetAllCallbackNotify(OutputBuffer);

// 	switch(InputBuffer)
// 	{
// 	case NotifyLoadImage:
// 		{
// 			Status = HsGetCallbackLoadImage(OutputBuffer);
// 		}
// 	case NotifyCreateProcess:
// 		{
// 
// 		}
// 	case NotifyCreateThread:
// 		{
// 
// 		}
// 	case NotifyShutdown:
// 		{
// 
// 		}
// 	default:
// 		{
// 			Status = STATUS_UNSUCCESSFUL;
// 		}
// 	}

	return Status;
}





NTSTATUS GetAllCallbackNotify(PVOID OutBuffer)
{
	NTSTATUS Status = STATUS_SUCCESS;
	BOOLEAN  bRet = FALSE;
	PGET_CALLBACK GetCallback = (PGET_CALLBACK)OutBuffer;

	DbgPrint("GetAllCallbackNotify\r\n");


	bRet = GetLoadImageCallbackNotify(GetCallback);
	bRet = GetRegisterCallbackNotify(GetCallback);
	bRet = GetBugCheckCallbackNotify(GetCallback);
	bRet = GetBugCheckReasonCallbackNotify(GetCallback);
	bRet = GetShutDownCallbackNotify(GetCallback);
	bRet = GetCreateThreadCallbackNotify(GetCallback);


	if (GetCallback->ulRetCnt > GetCallback->ulCnt)
	{
		DbgPrint("STATUS_BUFFER_TOO_SMALL\r\n");
		Status = STATUS_BUFFER_TOO_SMALL;
	}

	return Status;
}




NTSTATUS RemoveCallbackNotify(PVOID InBuffer)
{	
	NTSTATUS Status = STATUS_SUCCESS;
	PREMOVE_CALLBACK Temp = (PREMOVE_CALLBACK)InBuffer;

	ULONG_PTR CallbackAddress  = Temp->CallbackAddress;
	CALLBACK_TYPE CallBackType = Temp->NotifyType;

	if (!CallbackAddress ||
		!MmIsAddressValid((PVOID)CallbackAddress))
	{
		return STATUS_UNSUCCESSFUL;
	}

	DbgPrint("CallBackType: %d\r\n",CallBackType);
	switch(CallBackType)
	{
	case NotifyLoadImage:
		{
			DbgPrint("Remove NotifyLoadImage\r\n");
			Status = PsRemoveLoadImageNotifyRoutine((PLOAD_IMAGE_NOTIFY_ROUTINE)CallbackAddress);
			break;
		}
	case NotifyCmCallBack:
		{
			LARGE_INTEGER Cookie;
			ULONG_PTR Note = Temp->Note;
			Cookie.QuadPart = 0;

			DbgPrint("Remove NotifyCmCallBack\r\n");

			if (WinVersion == WINDOWS_XP)
			{
				Cookie = XpGetRegisterCallbackCookie(Note);
			}

			if (WinVersion==WINDOWS_7)
			{
				Cookie.QuadPart = Note;
			}

			if (Cookie.LowPart == 0 && Cookie.HighPart == 0)
			{
				return STATUS_UNSUCCESSFUL;
			}

			Status = CmUnRegisterCallback(Cookie);

			break;
		}
	case NotifyKeBugCheckReason:
		{
			PREMOVE_CALLBACK Temp = (PREMOVE_CALLBACK)InBuffer;

			ULONG_PTR Note = Temp->Note;


			if (Note!=NULL&&MmIsAddressValid((PVOID)Note))
			{
				KeDeregisterBugCheckReasonCallback((PKBUGCHECK_REASON_CALLBACK_RECORD)Note);
			}

			break;
		}
	case NotifyShutdown:
		{
			LARGE_INTEGER Cookie;

			PREMOVE_CALLBACK Temp = (PREMOVE_CALLBACK)InBuffer;

			ULONG_PTR Note = Temp->Note;


			if (Note!=NULL&&MmIsAddressValid((PVOID)Note))
			{
				IoUnregisterShutdownNotification((PDEVICE_OBJECT)Note);
			}

			break;
		}
	case NotifyCreateThread:
		{
			NTSTATUS Status = STATUS_SUCCESS;
			PREMOVE_CALLBACK Temp = (PREMOVE_CALLBACK)InBuffer;

			ULONG_PTR CallbackAddress = Temp->CallbackAddress;

			if (!CallbackAddress ||
				!MmIsAddressValid((PVOID)CallbackAddress)||!PsRemoveCreateThreadNotifyRoutine)
			{
				return STATUS_UNSUCCESSFUL;
			}

			Status = PsRemoveCreateThreadNotifyRoutine((PCREATE_THREAD_NOTIFY_ROUTINE)CallbackAddress);

			break;
		}
	default:
		{
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	return Status;
}


BOOLEAN GetLoadImageCallbackNotify(PGET_CALLBACK GetCallback)
{

	PsSetLoadImageNotifyRoutineAddress = 
		(pfnPsSetLoadImageNotifyRoutine)HsGetFunctionAddressByName(L"PsSetLoadImageNotifyRoutine");
	DbgPrint("%p\r\n",PsSetLoadImageNotifyRoutineAddress);
	PspLoadImageNotifyRoutineAddress = 
		FindPspLoadImageNotifyRoutine((ULONG_PTR)PsSetLoadImageNotifyRoutineAddress);
	DbgPrint("%p\r\n",PspLoadImageNotifyRoutineAddress);


	if (!PspLoadImageNotifyRoutineAddress)
	{
		DbgPrint("PspLoadImageNotifyRoutineAddress NULL\r\n");
		return FALSE;
	}

	else
	{
		ULONG i = 0;

		switch(WinVersion)
		{
		case WINDOWS_7:
			{
				SYSTEM_ADDRESS_START = 0x80000000000;

				for ( i = 0; i < 64; i++ )
				{
					ULONG64 NotifyItem = 0, CallBackAddress = 0;

					DbgPrint("i = %d\r\n",i);

					if (!MmIsAddressValid( (PVOID)(PspLoadImageNotifyRoutineAddress + i * sizeof(ULONG64))) )
					{
						break;
					}

					NotifyItem = *(PULONG64)(PspLoadImageNotifyRoutineAddress + i * sizeof(ULONG64));

					DbgPrint("NotifyItem: %p\r\n",NotifyItem);

					if (!(NotifyItem > SYSTEM_ADDRESS_START && MmIsAddressValid((PVOID)(NotifyItem & 0xfffffffffffffff8))) )
					{
						break;
					}

					CallBackAddress = *((PULONG64)(NotifyItem & 0xfffffffffffffff8));

					DbgPrint("CallBackAddress: %p\r\n",CallBackAddress);

					if (CallBackAddress && MmIsAddressValid((PVOID)CallBackAddress))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyLoadImage;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = CallBackAddress;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = NotifyItem;

							DbgPrint("GetCallback->ulCnt > GetCallback->ulRetCnt\r\n");
						}

						GetCallback->ulRetCnt++;
					}

				}
				break;
			}

		case WINDOWS_XP:
			{
				SYSTEM_ADDRESS_START = 0x80000000;
				for ( i = 0; i < 64; i++ )
				{
					ULONG32 NotifyItem = 0, CallBackAddress = 0;

					if (!MmIsAddressValid( (PVOID)(PspLoadImageNotifyRoutineAddress + i * sizeof(ULONG32))) )
					{
						break;
					}

					NotifyItem = *(PULONG32)(PspLoadImageNotifyRoutineAddress + i * sizeof(ULONG32));
					if (!(NotifyItem > SYSTEM_ADDRESS_START && MmIsAddressValid((PVOID)(NotifyItem & 0xFFFFFFF8 + sizeof(ULONG32)))) )
					{
						break;
					}

					CallBackAddress = *(PULONG32)(NotifyItem & 0xFFFFFFF8 + sizeof(ULONG));

					if (CallBackAddress && MmIsAddressValid((PVOID)CallBackAddress))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyLoadImage;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = CallBackAddress;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = NotifyItem;
						}

						GetCallback->ulRetCnt++;
					}
				}
				break;
			}
		}
	}

	return TRUE;
}


BOOLEAN GetRegisterCallbackNotify(PGET_CALLBACK GetCallback)
{
	CmUnRegisterCallbackAddress = 
		(pfnCmUnRegisterCallback)HsGetFunctionAddressByName(L"CmUnRegisterCallback");
	DbgPrint("%p\r\n",CmUnRegisterCallbackAddress);
	CallBackList = 
		CmpCallBackVector((ULONG_PTR)CmUnRegisterCallbackAddress);
	DbgPrint("%p\r\n",CallBackList);

	//DbgPrint("%02x\r\n",*(char*)((char*)CmUnRegisterCallbackAddress+0xe));

	if (!CallBackList)
	{
		return FALSE;
	}

	else
	{

		ULONG i = 0;
		switch(WinVersion)
		{
		case WINDOWS_7:   //这是个List
			{
				PCM_NOTIFY_ENTRY	Notify = NULL;
				PLIST_ENTRY			NotifyList = (LIST_ENTRY*)(*(ULONG_PTR*)CallBackList);
				SYSTEM_ADDRESS_START = 0x80000000000;  

				do
				{		
					Notify = (CM_NOTIFY_ENTRY *)NotifyList;
					if (MmIsAddressValid(Notify))
					{
						if (MmIsAddressValid((PVOID)(Notify->Function)) && Notify->Function > SYSTEM_ADDRESS_START)
						{
							if (GetCallback->ulCnt > GetCallback->ulRetCnt)
							{
								GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyCmCallBack;
								GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = Notify->Function;
								GetCallback->Callbacks[GetCallback->ulRetCnt].Note = Notify->Cookie.QuadPart;
							}

							GetCallback->ulRetCnt++;
						}
					}
					NotifyList = NotifyList->Flink;
				}while ( NotifyList != ((LIST_ENTRY*)(*(ULONG_PTR*)CallBackList)) );
				break;
			}

		case WINDOWS_XP:
			{

				SYSTEM_ADDRESS_START = 0x80000000;
				for ( i = 0; i < 64; i++ )
				{
					ULONG32 NotifyItem = 0, CallBackAddress = 0;
					ULONG   Temp = 0;

					if (!MmIsAddressValid( (PVOID)(CallBackList + i * sizeof(ULONG32))) )
					{
						break;
					}


					NotifyItem = *(PULONG32)(CallBackList + i * sizeof(ULONG32));
					if (!(NotifyItem > SYSTEM_ADDRESS_START && MmIsAddressValid((PVOID)(NotifyItem & 0xFFFFFFF8 + sizeof(ULONG32)))) )
					{
						break;
					}

					CallBackAddress = *(PULONG32)(NotifyItem & 0xFFFFFFF8 + sizeof(ULONG));
					if (CallBackAddress && MmIsAddressValid((PVOID)CallBackAddress))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{

							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyCmCallBack;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = CallBackAddress;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = NotifyItem;

						}

						GetCallback->ulRetCnt++;
					}
				}
				break;
			}
		}

	}

}


BOOLEAN GetBugCheckReasonCallbackNotify(PGET_CALLBACK GetCallback)
{

	KeRegisterBugCheckReasonCallbackAddress = 
		(pfnKeRegisterBugCheckReasonCallback)HsGetFunctionAddressByName(L"KeRegisterBugCheckReasonCallback");
	DbgPrint("%p\r\n",KeRegisterBugCheckReasonCallbackAddress);
	KeBugCheckReasonCallbackListHead = 
		FindKeBugCheckReasonCallbackListHeadNotifyRoutine((ULONG_PTR)KeRegisterBugCheckReasonCallbackAddress);
	DbgPrint("%p\r\n",KeBugCheckReasonCallbackListHead);


	if (!KeBugCheckReasonCallbackListHead)
	{
		return FALSE;
	}

	else
	{

		PLIST_ENTRY Entry = NULL;
		ULONG_PTR   Dispatch = 0;

		switch(WinVersion)
		{
		case WINDOWS_7:
			{
				Entry = ((PLIST_ENTRY)KeBugCheckReasonCallbackListHead)->Flink;
				do
				{
					Dispatch = *(ULONG64*)((ULONG64)Entry+sizeof(LIST_ENTRY));
					if(Dispatch&&MmIsAddressValid((PVOID)Dispatch))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyKeBugCheckReason;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = Dispatch;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = (PVOID)Entry;
						}

						GetCallback->ulRetCnt++;

					}
					Entry = Entry->Flink;

				}
				while(Entry != (PLIST_ENTRY)KeBugCheckReasonCallbackListHead);

				break;
			}

		case WINDOWS_XP:
			{
				//在Wrk中搜索 _KBUGCHECK_CALLBACK_RECORD 结构
				Entry = ((PLIST_ENTRY)KeBugCheckReasonCallbackListHead)->Flink;
				do
				{
					Dispatch = *(ULONG32*)((ULONG32)Entry+sizeof(LIST_ENTRY));
					if(Dispatch&&MmIsAddressValid((PVOID)Dispatch))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyKeBugCheckReason;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = Dispatch;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = (PVOID)Entry;;
						}

						GetCallback->ulRetCnt++;

					}
					Entry = Entry->Flink;

				}
				while(Entry != (PLIST_ENTRY)KeBugCheckReasonCallbackListHead);
				break;
			}
		}

	}

}


BOOLEAN GetBugCheckCallbackNotify(PGET_CALLBACK GetCallback)
{

	KeRegisterBugCheckCallbackAddress = 
		(pfnKeRegisterBugCheckCallback)HsGetFunctionAddressByName(L"KeRegisterBugCheckCallback");
	DbgPrint("%p\r\n",KeRegisterBugCheckCallbackAddress);
	KeBugCheckCallbackListHead = 
		FindKeBugCheckReasonCallbackListHeadNotifyRoutine((ULONG_PTR)KeRegisterBugCheckCallbackAddress);
	DbgPrint("%p\r\n",KeBugCheckCallbackListHead);


	if (!KeBugCheckCallbackListHead)
	{
		return FALSE;
	}

	else
	{

		PLIST_ENTRY Entry = NULL;
		ULONG_PTR   Dispatch = 0;

		switch(WinVersion)
		{
		case WINDOWS_7:
			{
				Entry = ((PLIST_ENTRY)KeBugCheckCallbackListHead)->Flink;
				do
				{
					Dispatch = *(ULONG64*)((ULONG64)Entry+sizeof(LIST_ENTRY));
					if(Dispatch&&MmIsAddressValid((PVOID)Dispatch))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyKeBugCheck;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = Dispatch;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = (PVOID)Entry;
						}

						GetCallback->ulRetCnt++;

					}
					Entry = Entry->Flink;

				}
				while(Entry != (PLIST_ENTRY)KeBugCheckCallbackListHead);

				break;
			}

		case WINDOWS_XP:
			{
				//在Wrk中搜索 _KBUGCHECK_CALLBACK_RECORD 结构
				Entry = ((PLIST_ENTRY)KeBugCheckCallbackListHead)->Flink;
				do
				{
					Dispatch = *(ULONG32*)((ULONG32)Entry+sizeof(LIST_ENTRY));
					if(Dispatch&&MmIsAddressValid((PVOID)Dispatch))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyKeBugCheck;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = Dispatch;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = (PVOID)Entry;;
						}

						GetCallback->ulRetCnt++;

					}
					Entry = Entry->Flink;

				}
				while(Entry != (PLIST_ENTRY)KeBugCheckCallbackListHead);
				break;
			}
		}

	}

}


BOOLEAN GetShutDownCallbackNotify(PGET_CALLBACK GetCallback)
{

	IoRegisterShutdownNotificationAddress = 
		(pfnIoRegisterShutdownNotification)HsGetFunctionAddressByName(L"IoRegisterShutdownNotification");
	DbgPrint("%p\r\n",IoRegisterShutdownNotificationAddress);
	IopNotifyShutdownQueueHead = 
		FindIopNotifyShutdownQueueHeadNotifyRoutine((ULONG_PTR)IoRegisterShutdownNotificationAddress);
	DbgPrint("%p\r\n",IopNotifyShutdownQueueHead);


	if (!IopNotifyShutdownQueueHead)
	{
		return FALSE;
	}
	else
	{
		ULONG i = 0;

		switch(WinVersion)
		{
		case WINDOWS_7:
			{

				SYSTEM_ADDRESS_START = 0x80000000000;

				if (IopNotifyShutdownQueueHead && MmIsAddressValid((PVOID)IopNotifyShutdownQueueHead))
				{
					PLIST_ENTRY Entry = ((PLIST_ENTRY)IopNotifyShutdownQueueHead)->Flink;
					while (MmIsAddressValid(Entry) && Entry != (PLIST_ENTRY)IopNotifyShutdownQueueHead)
					{
						ULONG64 ValidAddress = (ULONG64)Entry + sizeof(LIST_ENTRY);

						if (ValidAddress && 
							MmIsAddressValid((PVOID)ValidAddress))
						{
							ULONG64 DeviceObject = *(PULONG64)ValidAddress;

							if (DeviceObject && 
								MmIsAddressValid((PVOID)DeviceObject))
							{
								if (GetCallback->ulCnt > GetCallback->ulRetCnt)
								{
									GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyShutdown;
									GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = GetShutdownDispatch((PDEVICE_OBJECT)DeviceObject);
									GetCallback->Callbacks[GetCallback->ulRetCnt].Note = DeviceObject;
								}

								GetCallback->ulRetCnt++;
							}
						}

						Entry = Entry->Flink;
					}
				}
				break;
			}

		case WINDOWS_XP:
			{

				SYSTEM_ADDRESS_START = 0x80000000;
				if (IopNotifyShutdownQueueHead && MmIsAddressValid((PVOID)IopNotifyShutdownQueueHead))
				{
					PLIST_ENTRY Entry = ((PLIST_ENTRY)IopNotifyShutdownQueueHead)->Flink;
					while (MmIsAddressValid(Entry) && Entry != (PLIST_ENTRY)IopNotifyShutdownQueueHead)
					{
						ULONG ValidAddress = (ULONG)Entry + sizeof(LIST_ENTRY);

						if (ValidAddress && 
							MmIsAddressValid((PVOID)ValidAddress))
						{
							ULONG DeviceObject = *(PULONG)ValidAddress;

							if (DeviceObject && 
								MmIsAddressValid((PVOID)DeviceObject))
							{
								if (GetCallback->ulCnt > GetCallback->ulRetCnt)
								{
									GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyShutdown;
									GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = GetShutdownDispatch((PDEVICE_OBJECT)DeviceObject);
									GetCallback->Callbacks[GetCallback->ulRetCnt].Note = DeviceObject;
								}

								GetCallback->ulRetCnt++;
							}
						}

						Entry = Entry->Flink;
					}
				}
				break;
			}
		}

	}

}


BOOLEAN GetCreateThreadCallbackNotify(PGET_CALLBACK GetCallback)
{
	PsSetCreateThreadNotifyRoutineAddress = 
		(pfnPsSetCreateThreadNotifyRoutine)HsGetFunctionAddressByName(L"PsSetCreateThreadNotifyRoutine");
	DbgPrint("%p\r\n",PsSetCreateThreadNotifyRoutineAddress);
	PspCreateThreadNotifyRoutineAddress = 
		FindPspCreateThreadNotifyRoutine((ULONG_PTR)PsSetCreateThreadNotifyRoutineAddress);
	DbgPrint("%p\r\n",PspCreateThreadNotifyRoutineAddress);


	if (!PspCreateThreadNotifyRoutineAddress)
	{
		return FALSE;
	}

	else
	{

		ULONG i = 0;


		switch(WinVersion)
		{
		case WINDOWS_7:
			{

				SYSTEM_ADDRESS_START = 0x80000000000;

				for ( i = 0; i < 64; i++ )
				{
					ULONG64 NotifyItem = 0, CallBackAddress = 0;

					if (!MmIsAddressValid( (PVOID)(PspCreateThreadNotifyRoutineAddress + i * sizeof(ULONG64))) )
					{
						break;
					}

					NotifyItem = *(PULONG64)(PspCreateThreadNotifyRoutineAddress + i * sizeof(ULONG64));

					if (!(NotifyItem > SYSTEM_ADDRESS_START && MmIsAddressValid((PVOID)(NotifyItem & 0xfffffffffffffff8))) )
					{
						break;
					}

					CallBackAddress = *((PULONG64)(NotifyItem & 0xfffffffffffffff8));

					if (CallBackAddress && MmIsAddressValid((PVOID)CallBackAddress))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyCreateThread;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = CallBackAddress;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = NotifyItem;
						}

						GetCallback->ulRetCnt++;
					}



				}
				break;
			}

		case WINDOWS_XP:
			{

				SYSTEM_ADDRESS_START = 0x80000000;
				for ( i = 0; i < 64; i++ )
				{
					ULONG32 NotifyItem = 0, CallBackAddress = 0;

					if (!MmIsAddressValid( (PVOID)(PspCreateThreadNotifyRoutineAddress + i * sizeof(ULONG32))) )
					{
						break;
					}

					NotifyItem = *(PULONG32)(PspCreateThreadNotifyRoutineAddress + i * sizeof(ULONG32));
					if (!(NotifyItem > SYSTEM_ADDRESS_START && MmIsAddressValid((PVOID)(NotifyItem & 0xFFFFFFF8 + sizeof(ULONG32)))) )
					{
						break;
					}

					CallBackAddress = *(PULONG32)(NotifyItem & 0xFFFFFFF8 + sizeof(ULONG));

					if (CallBackAddress && MmIsAddressValid((PVOID)CallBackAddress))
					{
						if (GetCallback->ulCnt > GetCallback->ulRetCnt)
						{
							GetCallback->Callbacks[GetCallback->ulRetCnt].Type = NotifyCreateThread;
							GetCallback->Callbacks[GetCallback->ulRetCnt].CallbackAddress = CallBackAddress;
							GetCallback->Callbacks[GetCallback->ulRetCnt].Note = NotifyItem;
						}

						GetCallback->ulRetCnt++;
					}
				}
				break;
			}
		}

	}

}




//////////////////////////////////////////////////////////////////////////


ULONG_PTR CmpCallBackVector(ULONG_PTR Address)
{
	ULONG_PTR i = 0;

	/*
	XP:
	kd> u CmUnRegisterCallback l 20
	nt!CmUnRegisterCallback:
	8061ce6f 8bff            mov     edi,edi
	8061ce71 55              push    ebp
	8061ce72 8bec            mov     ebp,esp
	8061ce74 51              push    ecx
	8061ce75 8365fc00        and     dword ptr [ebp-4],0
	8061ce79 53              push    ebx
	8061ce7a 56              push    esi
	8061ce7b 57              push    edi
	8061ce7c bba0135680      mov     ebx,offset nt!CmpCallBackVector (805613a0)
	8061ce81 53              push    ebx

	kd> u 805613a0
	nt!CmpCallBackVector:
	805613a0 0000            add     byte ptr [eax],al
	805613a2 0000            add     byte ptr [eax],al
	805613a4 0000            add     byte ptr [eax],al
	805613a6 0000            add     byte ptr [eax],al
	805613a8 0000            add     byte ptr [eax],al
	805613aa 0000            add     byte ptr [eax],al
	805613ac 0000            add     byte ptr [eax],al
	805613ae 0000            add     byte ptr [eax],al


	Win7

	kd> u CmUnRegisterCallback l 50
	nt!CmUnRegisterCallback:
	fffff800`0430f790 48894c2408      mov     qword ptr [rsp+8],rcx
	fffff800`0430f795 53              push    rbx
	fffff800`0430f796 56              push    rsi
	fffff800`0430f797 57              push    rdi
	fffff800`0430f798 4154            push    r12
	fffff800`0430f79a 4155            push    r13
	fffff800`0430f79c 4156            push    r14
	fffff800`0430f79e 4157            push    r15
	fffff800`0430f7a0 4883ec60        sub     rsp,60h
	fffff800`0430f7a4 41bc0d0000c0    mov     r12d,0C000000Dh
	fffff800`0430f7aa 4489a424b0000000 mov     dword ptr [rsp+0B0h],r12d
	fffff800`0430f7b2 33db            xor     ebx,ebx
	fffff800`0430f7b4 48895c2448      mov     qword ptr [rsp+48h],rbx
	fffff800`0430f7b9 33c0            xor     eax,eax
	fffff800`0430f7bb 4889442450      mov     qword ptr [rsp+50h],rax
	fffff800`0430f7c0 4889442458      mov     qword ptr [rsp+58h],rax
	fffff800`0430f7c5 448d6b01        lea     r13d,[rbx+1]
	fffff800`0430f7c9 458afd          mov     r15b,r13b
	fffff800`0430f7cc 4488ac24a8000000 mov     byte ptr [rsp+0A8h],r13b
	fffff800`0430f7d4 440f20c7        mov     rdi,cr8
	fffff800`0430f7d8 450f22c5        mov     cr8,r13
	fffff800`0430f7dc f00fba351b6adcff00 lock btr dword ptr [nt!CallbackUnregisterLock (fffff800`040d6200)],0
	fffff800`0430f7e5 720c            jb      nt!CmUnRegisterCallback+0x63 (fffff800`0430f7f3)
	fffff800`0430f7e7 488d0d126adcff  lea     rcx,[nt!CallbackUnregisterLock (fffff800`040d6200)]
	fffff800`0430f7ee e85db7b9ff      call    nt!KiAcquireFastMutex (fffff800`03eaaf50)
	fffff800`0430f7f3 65488b042588010000 mov   rax,qword ptr gs:[188h]
	fffff800`0430f7fc 488905056adcff  mov     qword ptr [nt!CallbackUnregisterLock+0x8 (fffff800`040d6208)],rax
	fffff800`0430f803 400fb6c7        movzx   eax,dil
	fffff800`0430f807 8905236adcff    mov     dword ptr [nt!CallbackUnregisterLock+0x30 (fffff800`040d6230)],eax
	fffff800`0430f80d 48c78424b80000009cffffff mov qword ptr [rsp+0B8h],0FFFFFFFFFFFFFF9Ch
	fffff800`0430f819 48895c2420      mov     qword ptr [rsp+20h],rbx
	fffff800`0430f81e 65488b042588010000 mov   rax,qword ptr gs:[188h]
	fffff800`0430f827 4183ceff        or      r14d,0FFFFFFFFh
	fffff800`0430f82b 664401b0c4010000 add     word ptr [rax+1C4h],r14w
	fffff800`0430f833 f0480fba2dab69dcff00 lock bts qword ptr [nt!CallbackListLock (fffff800`040d61e8)],0
	fffff800`0430f83d 730c            jae     nt!CmUnRegisterCallback+0xbb (fffff800`0430f84b)
	fffff800`0430f83f 488d0da269dcff  lea     rcx,[nt!CallbackListLock (fffff800`040d61e8)]
	fffff800`0430f846 e875aabbff      call    nt!ExfAcquirePushLockExclusive (fffff800`03eca2c0)
	fffff800`0430f84b 418af5          mov     sil,r13b
	fffff800`0430f84e 4c8b9424a0000000 mov     r10,qword ptr [rsp+0A0h]
	fffff800`0430f856 4533c0          xor     r8d,r8d
	fffff800`0430f859 488d542420      lea     rdx,[rsp+20h]
	fffff800`0430f85e 488d0d6b69dcff  lea     rcx,[nt!CallbackListHead (fffff800`040d61d0)]      //注意这里的地址   在Win7 中这里是个链表

	kd> u fffff800`040d61d0
	nt!CallbackListHead:
	fffff800`040d61d0 d0610d          shl     byte ptr [rcx+0Dh],1
	fffff800`040d61d3 0400            add     al,0
	fffff800`040d61d5 f8              clc
	fffff800`040d61d6 ff              ???
	fffff800`040d61d7 ffd0            call    rax
	fffff800`040d61d9 61              ???
	fffff800`040d61da 0d0400f8ff      or      eax,0FFF80004h
	fffff800`040d61df ff00            inc     dword ptr [rax]




	*/
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0x48 && *(PUCHAR)(i+1)==0x8d && *(PUCHAR)(i+2)==0x0d )
				{
					ULONG_PTR j = 0;
					j = i-5;
					if (*(PUCHAR)j==0x48 && *(PUCHAR)(j+1)==0x8d && *(PUCHAR)(j+2)==0x54)
					{
						LONG OffsetAddr = 0;
						
						memcpy(&OffsetAddr,(PVOID)(i+3),4);

						return OffsetAddr+7+i;
					}
				}
					
			}
			break;
		}

	case WINDOWS_XP:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0xbb && *(PUCHAR)(i-1)==0x57)	
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+1),4);
					return OffsetAddr;
				}
			}
			break;
		}
	}

	

	return 0;
}


LARGE_INTEGER XpGetRegisterCallbackCookie(ULONG Address)
{

	LARGE_INTEGER Cookie;
	ULONG Temp = 0;
	ULONG Item = 0;

	Cookie.QuadPart = 0;

	if (Address && MmIsAddressValid((PVOID)Address))
	{
		Item = Address & 0xFFFFFFF8;


		if (MmIsAddressValid((PVOID)Item) &&
			MmIsAddressValid((PVOID)(Item + 8)))
		{
			Temp = *(PULONG)(Item + 8);


			if (MmIsAddressValid((PVOID)Temp))
			{
				Cookie.LowPart = *(PULONG)Temp;
				Cookie.HighPart = *(PULONG)(Temp + sizeof(ULONG));
			}
		}
	}

	return Cookie;
}


ULONG_PTR FindPspLoadImageNotifyRoutine(ULONG_PTR Address)
{
	ULONG_PTR i = 0;

	/*
	XP:
	kd> u PsSetLoadImageNotifyRoutine l 20
	nt!PsSetLoadImageNotifyRoutine:
	805d0f90 8bff            mov     edi,edi
	805d0f92 55              push    ebp
	805d0f93 8bec            mov     ebp,esp
	805d0f95 53              push    ebx
	805d0f96 57              push    edi
	805d0f97 33ff            xor     edi,edi
	805d0f99 57              push    edi
	805d0f9a ff7508          push    dword ptr [ebp+8]
	805d0f9d e8faca0300      call    nt!ExAllocateCallBack (8060da9c)
	805d0fa2 8bd8            mov     ebx,eax
	805d0fa4 3bdf            cmp     ebx,edi
	805d0fa6 7507            jne     nt!PsSetLoadImageNotifyRoutine+0x1f (805d0faf)
	805d0fa8 b89a0000c0      mov     eax,0C000009Ah
	805d0fad eb2a            jmp     nt!PsSetLoadImageNotifyRoutine+0x49 (805d0fd9)
	805d0faf 56              push    esi
	805d0fb0 bee0495680      mov     esi,offset nt!PspLoadImageNotifyRoutine (805649e0)
	805d0fb5 6a00            push    0
	805d0fb7 53              push    ebx
	805d0fb8 56              push    esi
	805d0fb9 e80ecb0300      call    nt!ExCompareExchangeCallBack (8060dacc)
	805d0fbe 84c0            test    al,al
	805d0fc0 751d            jne     nt!PsSetLoadImageNotifyRoutine+0x4f (805d0fdf)
	805d0fc2 83c704          add     edi,4
	805d0fc5 83c604          add     esi,4
	805d0fc8 83ff20          cmp     edi,20h
	805d0fcb 72e8            jb      nt!PsSetLoadImageNotifyRoutine+0x25 (805d0fb5)
	805d0fcd 53              push    ebx
	805d0fce e83f1a0000      call    nt!RtlpFreeAtom (805d2a12)
	805d0fd3 b89a0000c0      mov     eax,0C000009Ah
	805d0fd8 5e              pop     esi
	805d0fd9 5f              pop     edi
	805d0fda 5b              pop     ebx
	kd> u 805649e0
	nt!PspLoadImageNotifyRoutine:
	805649e0 0000            add     byte ptr [eax],al
	805649e2 0000            add     byte ptr [eax],al
	805649e4 0000            add     byte ptr [eax],al
	805649e6 0000            add     byte ptr [eax],al
	805649e8 0000            add     byte ptr [eax],al
	805649ea 0000            add     byte ptr [eax],al
	805649ec 0000            add     byte ptr [eax],al
	805649ee 0000            add     byte ptr [eax],al

	Win7

	kd> u PsSetLoadImageNotifyRoutine l 20
	nt!PsSetLoadImageNotifyRoutine:
	fffff800`0429db60 48895c2408      mov     qword ptr [rsp+8],rbx
	fffff800`0429db65 57              push    rdi
	fffff800`0429db66 4883ec20        sub     rsp,20h
	fffff800`0429db6a 33d2            xor     edx,edx
	fffff800`0429db6c e8efaffeff      call    nt!ExAllocateCallBack (fffff800`04288b60)
	fffff800`0429db71 488bf8          mov     rdi,rax
	fffff800`0429db74 4885c0          test    rax,rax
	fffff800`0429db77 7507            jne     nt!PsSetLoadImageNotifyRoutine+0x20 (fffff800`0429db80)
	fffff800`0429db79 b89a0000c0      mov     eax,0C000009Ah
	fffff800`0429db7e eb4a            jmp     nt!PsSetLoadImageNotifyRoutine+0x6a (fffff800`0429dbca)
	fffff800`0429db80 33db            xor     ebx,ebx
	fffff800`0429db82 488d0d7799d9ff  lea     rcx,[nt!PspLoadImageNotifyRoutine (fffff800`04037500)]


	kd> u fffff800`04037500
	nt!PspLoadImageNotifyRoutine:
	fffff800`04037500 ff6014          jmp     qword ptr [rax+14h]
	fffff800`04037503 00a0f8ffff00    add     byte ptr [rax+0FFFFF8h],ah
	fffff800`04037509 0000            add     byte ptr [rax],al
	fffff800`0403750b 0000            add     byte ptr [rax],al
	fffff800`0403750d 0000            add     byte ptr [rax],al
	fffff800`0403750f 0000            add     byte ptr [rax],al
	fffff800`04037511 0000            add     byte ptr [rax],al
	fffff800`04037513 0000            add     byte ptr [rax],al



	*/
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0x48 && *(PUCHAR)(i+1)==0x8d && *(PUCHAR)(i+2)==0x0d)	//lea rcx,xxxx
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+3),4);
					return OffsetAddr+7+i;
				}
			}
			break;
		}

	case WINDOWS_XP:
		{
// 			UCHAR TempChar = *(UCHAR*)((UCHAR*)IoRegisterShutdownNotificationAddress+0xe);
// 
// 			DbgPrint("%x\r\n",TempChar);

			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0x56 && *(PUCHAR)(i+1)==0xbe)	//lea rcx,xxxx
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+2),4);
					return OffsetAddr;
				}
			}
			break;
		}
	}

	

	return 0;
}


ULONG_PTR FindKeBugCheckReasonCallbackListHeadNotifyRoutine(ULONG_PTR Address)
{
	ULONG_PTR i = 0;

	/*
	XP:
	kd> u KeRegisterBugCheckReasonCallback l 20
	nt!KeRegisterBugCheckReasonCallback:
	8050f0c1 8bff            mov     edi,edi
	8050f0c3 55              push    ebp
	8050f0c4 8bec            mov     ebp,esp
	8050f0c6 51              push    ecx
	8050f0c7 53              push    ebx
	8050f0c8 57              push    edi
	8050f0c9 b11f            mov     cl,1Fh
	8050f0cb ff152c904d80    call    dword ptr [nt!_imp_KfRaiseIrql (804d902c)]
	8050f0d1 bf6c355680      mov     edi,offset nt!KeBugCheckCallbackLock (8056356c)
	8050f0d6 8bcf            mov     ecx,edi
	8050f0d8 8845ff          mov     byte ptr [ebp-1],al
	8050f0db e86843fdff      call    nt!KiAcquireSpinLock (804e3448)
	8050f0e0 8b4508          mov     eax,dword ptr [ebp+8]
	8050f0e3 32db            xor     bl,bl
	8050f0e5 385818          cmp     byte ptr [eax+18h],bl
	8050f0e8 7538            jne     nt!KeRegisterBugCheckReasonCallback+0x61 (8050f122)
	8050f0ea 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]
	8050f0ed 8b5510          mov     edx,dword ptr [ebp+10h]
	8050f0f0 894808          mov     dword ptr [eax+8],ecx
	8050f0f3 56              push    esi
	8050f0f4 8b7514          mov     esi,dword ptr [ebp+14h]
	8050f0f7 03ca            add     ecx,edx
	8050f0f9 03ce            add     ecx,esi
	8050f0fb 89700c          mov     dword ptr [eax+0Ch],esi
	8050f0fe 895014          mov     dword ptr [eax+14h],edx
	8050f101 894810          mov     dword ptr [eax+10h],ecx
	8050f104 c6401801        mov     byte ptr [eax+18h],1
	8050f108 8b0d70355680    mov     ecx,dword ptr [nt!KeBugCheckReasonCallbackListHead (80563570)]



	kd> u 80563570
	nt!KeBugCheckReasonCallbackListHead:
	80563570 809afdba602bbb  sbb     byte ptr [edx+2B60BAFDh],0BBh
	80563577 ba38ca6589      mov     edx,8965CA38h
	8056357c c02071          shl     byte ptr [eax],71h
	8056357f 800000          add     byte ptr [eax],0
	80563582 0000            add     byte ptr [eax],al
	80563584 0000            add     byte ptr [eax],al
	80563586 0000            add     byte ptr [eax],al


	Win7

	kd> u KeRegisterBugCheckReasonCallback l 50
	nt!KeRegisterBugCheckReasonCallback:
	fffff800`03f3d390 48895c2418      mov     qword ptr [rsp+18h],rbx
	fffff800`03f3d395 4c894c2420      mov     qword ptr [rsp+20h],r9
	fffff800`03f3d39a 4889542410      mov     qword ptr [rsp+10h],rdx
	fffff800`03f3d39f 55              push    rbp
	fffff800`03f3d3a0 56              push    rsi
	fffff800`03f3d3a1 57              push    rdi
	fffff800`03f3d3a2 4154            push    r12
	fffff800`03f3d3a4 4155            push    r13
	fffff800`03f3d3a6 4156            push    r14
	fffff800`03f3d3a8 4157            push    r15
	fffff800`03f3d3aa 4883ec30        sub     rsp,30h
	fffff800`03f3d3ae bf01000000      mov     edi,1
	fffff800`03f3d3b3 4963e8          movsxd  rbp,r8d
	fffff800`03f3d3b6 488bd9          mov     rbx,rcx
	fffff800`03f3d3b9 448aef          mov     r13b,dil
	fffff800`03f3d3bc 440f20c0        mov     rax,cr8
	fffff800`03f3d3c0 4889442470      mov     qword ptr [rsp+70h],rax
	fffff800`03f3d3c5 8d470e          lea     eax,[rdi+0Eh]
	fffff800`03f3d3c8 440f22c0        mov     cr8,rax
	fffff800`03f3d3cc 65488b342520000000 mov   rsi,qword ptr gs:[20h]
	fffff800`03f3d3d5 4533c9          xor     r9d,r9d
	fffff800`03f3d3d8 0fba25a4120e0010 bt      dword ptr [nt!PerfGlobalGroupMask+0x4 (fffff800`0401e684)],10h
	fffff800`03f3d3e0 7318            jae     nt!KeRegisterBugCheckReasonCallback+0x6a (fffff800`03f3d3fa)
	fffff800`03f3d3e2 448ae7          mov     r12b,dil
	fffff800`03f3d3e5 0f31            rdtsc
	fffff800`03f3d3e7 448bbe00470000  mov     r15d,dword ptr [rsi+4700h]
	fffff800`03f3d3ee 48c1e220        shl     rdx,20h
	fffff800`03f3d3f2 480bc2          or      rax,rdx
	fffff800`03f3d3f5 4c8bf0          mov     r14,rax
	fffff800`03f3d3f8 eb0d            jmp     nt!KeRegisterBugCheckReasonCallback+0x77 (fffff800`03f3d407)
	fffff800`03f3d3fa 4c8b742470      mov     r14,qword ptr [rsp+70h]
	fffff800`03f3d3ff 448b7c2470      mov     r15d,dword ptr [rsp+70h]
	fffff800`03f3d404 4532e4          xor     r12b,r12b
	fffff800`03f3d407 01be004b0000    add     dword ptr [rsi+4B00h],edi
	fffff800`03f3d40d f0480fba2d3927150000 lock bts qword ptr [nt!KeBugCheckCallbackLock (fffff800`0408fb50)],0
	fffff800`03f3d417 731d            jae     nt!KeRegisterBugCheckReasonCallback+0xa6 (fffff800`03f3d436)
	fffff800`03f3d419 488d0d30271500  lea     rcx,[nt!KeBugCheckCallbackLock (fffff800`0408fb50)]
	fffff800`03f3d420 e8ab1ef4ff      call    nt!KxWaitForSpinLockAndAcquire (fffff800`03e7f2d0)
	fffff800`03f3d425 01be044b0000    add     dword ptr [rsi+4B04h],edi
	fffff800`03f3d42b 0186084b0000    add     dword ptr [rsi+4B08h],eax
	fffff800`03f3d431 448bc8          mov     r9d,eax
	fffff800`03f3d434 eb03            jmp     nt!KeRegisterBugCheckReasonCallback+0xa9 (fffff800`03f3d439)
	fffff800`03f3d436 0faee8          lfence
	fffff800`03f3d439 4584e4          test    r12b,r12b
	fffff800`03f3d43c 7428            je      nt!KeRegisterBugCheckReasonCallback+0xd6 (fffff800`03f3d466)
	fffff800`03f3d43e 0f31            rdtsc
	fffff800`03f3d440 48c1e220        shl     rdx,20h
	fffff800`03f3d444 488d0d05271500  lea     rcx,[nt!KeBugCheckCallbackLock (fffff800`0408fb50)]
	fffff800`03f3d44b c644242800      mov     byte ptr [rsp+28h],0
	fffff800`03f3d450 480bc2          or      rax,rdx
	fffff800`03f3d453 44897c2420      mov     dword ptr [rsp+20h],r15d
	fffff800`03f3d458 448bc0          mov     r8d,eax
	fffff800`03f3d45b 488bd0          mov     rdx,rax
	fffff800`03f3d45e 452bc6          sub     r8d,r14d
	fffff800`03f3d461 e86a66feff      call    nt!PerfLogSpinLockAcquire (fffff800`03f23ad0)
	fffff800`03f3d466 807b2c00        cmp     byte ptr [rbx+2Ch],0
	fffff800`03f3d46a 7570            jne     nt!KeRegisterBugCheckReasonCallback+0x14c (fffff800`03f3d4dc)
	fffff800`03f3d46c 488b542478      mov     rdx,qword ptr [rsp+78h]
	fffff800`03f3d471 488b8c2488000000 mov     rcx,qword ptr [rsp+88h]
	fffff800`03f3d479 896b28          mov     dword ptr [rbx+28h],ebp
	fffff800`03f3d47c 488d042a        lea     rax,[rdx+rbp]
	fffff800`03f3d480 48895310        mov     qword ptr [rbx+10h],rdx
	fffff800`03f3d484 48894b18        mov     qword ptr [rbx+18h],rcx
	fffff800`03f3d488 4803c1          add     rax,rcx
	fffff800`03f3d48b 40887b2c        mov     byte ptr [rbx+2Ch],dil
	fffff800`03f3d48f 48894320        mov     qword ptr [rbx+20h],rax
	fffff800`03f3d493 83fd04          cmp     ebp,4
	fffff800`03f3d496 7422            je      nt!KeRegisterBugCheckReasonCallback+0x12a (fffff800`03f3d4ba)
	fffff800`03f3d498 488b05d1261500  mov     rax,qword ptr [nt!KeBugCheckReasonCallbackListHead (fffff800`0408fb70)]
	fffff800`03f3d49f 488d0dca261500  lea     rcx,[nt!KeBugCheckReasonCallbackListHead (fffff800`0408fb70)]

	kd> u fffff800`0408fb70
	nt!KeBugCheckReasonCallbackListHead:
	fffff800`0408fb70 58              pop     rax
	fffff800`0408fb71 52              push    rdx
	fffff800`0408fb72 de18            ficomp  word ptr [rax]
	fffff800`0408fb74 80faff          cmp     dl,0FFh
	fffff800`0408fb77 ffe0            jmp     rax
	fffff800`0408fb79 011d0180f8ff    add     dword ptr [nt!KeNodeBlock+0x180 (fffff800`04017b80)],ebx
	fffff800`0408fb7f ffa0ce651980    jmp     qword ptr [rax-7FE69A32h]
	fffff800`0408fb85 fa              cli

	*/
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			for(i=Address;i<Address+0xFFF;i++)
			{
				if(*(PUCHAR)i==0x48 && *(PUCHAR)(i+1)==0x8b && *(PUCHAR)(i+2)==0x05)	
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+3),4);
					return OffsetAddr+7+i;
				}
			}
			break;
		}

	case WINDOWS_XP:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0x8b && *(PUCHAR)(i+1)==0x0d)	
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+2),4);
					return OffsetAddr;
				}
			}
			break;
		}
	}

	

	return 0;
}


ULONG_PTR FindIopNotifyShutdownQueueHeadNotifyRoutine(ULONG_PTR Address)
{
	ULONG_PTR i = 0;

	/*
	XP:
	kd> u IoRegisterShutdownNotification l 20
	nt!IoRegisterShutdownNotification:
	805b6b58 8bff            mov     edi,edi
	805b6b5a 55              push    ebp
	805b6b5b 8bec            mov     ebp,esp
	805b6b5d 57              push    edi
	805b6b5e 68496f5368      push    68536F49h
	805b6b63 6a0c            push    0Ch
	805b6b65 6a00            push    0
	805b6b67 e899b4f9ff      call    nt!ExAllocatePoolWithTag (80552005)
	805b6b6c 8bf8            mov     edi,eax
	805b6b6e 85ff            test    edi,edi
	805b6b70 0f84748d0300    je      nt!IoRegisterShutdownNotification+0x1a (805ef8ea)
	805b6b76 56              push    esi
	805b6b77 8b7508          mov     esi,dword ptr [ebp+8]
	805b6b7a 8bce            mov     ecx,esi
	805b6b7c 897708          mov     dword ptr [edi+8],esi
	805b6b7f e8df44f2ff      call    nt!ObfReferenceObject (804db063)
	805b6b84 8bd7            mov     edx,edi
	805b6b86 b9601e5680      mov     ecx,offset nt!IopNotifyShutdownQueueHead (80561e60)
	805b6b8b e83c5ff5ff      call    nt!IopInterlockedInsertHeadList (8050cacc)


	kd> u IoRegisterShutdownNotification l 20
	nt!IoRegisterShutdownNotification:
	8056ab64 8bff            mov     edi,edi
	8056ab66 55              push    ebp
	8056ab67 8bec            mov     ebp,esp
	8056ab69 57              push    edi
	8056ab6a 68496f5368      push    68536F49h
	8056ab6f 6a0c            push    0Ch
	8056ab71 6a00            push    0
	8056ab73 e808b3fdff      call    nt!ExAllocatePoolWithTag (80545e80)
	8056ab78 8bf8            mov     edi,eax
	8056ab7a 85ff            test    edi,edi
	8056ab7c 7507            jne     nt!IoRegisterShutdownNotification+0x21 (8056ab85)
	8056ab7e b89a0000c0      mov     eax,0C000009Ah
	8056ab83 eb21            jmp     nt!IoRegisterShutdownNotification+0x42 (8056aba6)
	8056ab85 56              push    esi
	8056ab86 8b7508          mov     esi,dword ptr [ebp+8]
	8056ab89 8bce            mov     ecx,esi
	8056ab8b 897708          mov     dword ptr [edi+8],esi
	8056ab8e e8bd8dfbff      call    nt!ObfReferenceObject (80523950)
	8056ab93 8bd7            mov     edx,edi
	8056ab95 b9e0285580      mov     ecx,offset nt!IopNotifyShutdownQueueHead (805528e0)
	8056ab9a e8d59bf8ff      call    nt!IopInterlockedInsertHeadList (804f4774)


	kd> dd 80561e60
	80561e60  89616ba8 897d8150 80561e68 80561e68
	80561e70  80561e70 80561e70 897d223c 897d223c
	80561e80  8958052c 8973b7b4 897041fc 897d35d4
	80561e90  895844d4 8981a5d4 00000000 00000000
	80561ea0  80561ba0 80561ee0 89806340 00000000
	80561eb0  00000000 00000000 00000000 00000000
	80561ec0  00000000 00000000 00000000 00000000
	80561ed0  00000000 00000000 00000000 00000000


	Win7

	kd> u IoRegisterShutdownNotification l 20
	nt!IoRegisterShutdownNotification:
	fffff800`0428bf20 48895c2408      mov     qword ptr [rsp+8],rbx
	fffff800`0428bf25 57              push    rdi
	fffff800`0428bf26 4883ec20        sub     rsp,20h
	fffff800`0428bf2a 488bd9          mov     rbx,rcx
	fffff800`0428bf2d ba18000000      mov     edx,18h
	fffff800`0428bf32 41b8496f5368    mov     r8d,68536F49h
	fffff800`0428bf38 33c9            xor     ecx,ecx
	fffff800`0428bf3a e8a111d3ff      call    nt!ExAllocatePoolWithTag (fffff800`03fbd0e0)
	fffff800`0428bf3f 488bf8          mov     rdi,rax
	fffff800`0428bf42 4885c0          test    rax,rax
	fffff800`0428bf45 7507            jne     nt!IoRegisterShutdownNotification+0x2e (fffff800`0428bf4e)
	fffff800`0428bf47 b89a0000c0      mov     eax,0C000009Ah
	fffff800`0428bf4c eb22            jmp     nt!IoRegisterShutdownNotification+0x50 (fffff800`0428bf70)
	fffff800`0428bf4e 488bcb          mov     rcx,rbx
	fffff800`0428bf51 48895810        mov     qword ptr [rax+10h],rbx
	fffff800`0428bf55 e8962fc1ff      call    nt!ObfReferenceObject (fffff800`03e9eef0)
	fffff800`0428bf5a 488d0d8f32e0ff  lea     rcx,[nt!IopNotifyShutdownQueueHead (fffff800`0408f1f0)]
	fffff800`0428bf61 488bd7          mov     rdx,rdi

	kd> dq fffff800`0408f1f0
	fffff800`0408f1f0  fffffa80`197d9170 fffffa80`18e1b280
	fffff800`0408f200  fffff800`0408f200 fffff800`0408f200
	fffff800`0408f210  fffff800`0408f210 fffff800`0408f210
	fffff800`0408f220  fffffa80`18d46e90 fffffa80`18d46e90
	fffff800`0408f230  fffffa80`191f0680 fffffa80`191f0680
	fffff800`0408f240  fffffa80`191067d0 fffffa80`18d460b0
	fffff800`0408f250  fffffa80`191077d0 fffffa80`18d452a0
	fffff800`0408f260  fffff800`0408ecc0 fffff800`0408f360

	*/
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0x48 && *(PUCHAR)(i+1)==0x8d && *(PUCHAR)(i+2)==0x0d)
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+3),4);
					return OffsetAddr+7+i;
				}
			}
			break;
		}

	case WINDOWS_XP:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0xb9 && *(PUCHAR)(i-1)==0xd7)
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+1),4);
					return OffsetAddr;
				}
			}
			break;
		}
	}

	return 0;
}


ULONG_PTR FindPspCreateThreadNotifyRoutine(ULONG_PTR Address)
{
	ULONG_PTR i = 0;

	/*
	XP:
	kd> u PsSetCreateThreadNotifyRoutine l 20
	nt!PsSetCreateThreadNotifyRoutine:
	8063622d 8bff            mov     edi,edi
	8063622f 55              push    ebp
	80636230 8bec            mov     ebp,esp
	80636232 53              push    ebx
	80636233 57              push    edi
	80636234 33ff            xor     edi,edi
	80636236 57              push    edi
	80636237 ff7508          push    dword ptr [ebp+8]
	8063623a e829760100      call    nt!ExAllocateCallBack (8064d868)
	8063623f 8bd8            mov     ebx,eax
	80636241 3bdf            cmp     ebx,edi
	80636243 7507            jne     nt!PsSetCreateThreadNotifyRoutine+0x1f (8063624c)
	80636245 b89a0000c0      mov     eax,0C000009Ah
	8063624a eb2a            jmp     nt!PsSetCreateThreadNotifyRoutine+0x49 (80636276)
	8063624c 56              push    esi
	8063624d bea0a75680      mov     esi,offset nt!PspCreateThreadNotifyRoutine (8056a7a0)

	kd> u 8056a7a0
	nt!PspCreateThreadNotifyRoutine:
	8056a7a0 0000            add     byte ptr [eax],al
	8056a7a2 0000            add     byte ptr [eax],al
	8056a7a4 0000            add     byte ptr [eax],al
	8056a7a6 0000            add     byte ptr [eax],al
	8056a7a8 0000            add     byte ptr [eax],al
	8056a7aa 0000            add     byte ptr [eax],al
	8056a7ac 0000            add     byte ptr [eax],al
	8056a7ae 0000            add     byte ptr [eax],al


	Win7

	kd>  u PsSetCreateThreadNotifyRoutine l 20
	nt!PsSetCreateThreadNotifyRoutine:
	fffff800`042ddbe0 48895c2408      mov     qword ptr [rsp+8],rbx
	fffff800`042ddbe5 57              push    rdi
	fffff800`042ddbe6 4883ec20        sub     rsp,20h
	fffff800`042ddbea 33d2            xor     edx,edx
	fffff800`042ddbec e86faffeff      call    nt!ExAllocateCallBack (fffff800`042c8b60)
	fffff800`042ddbf1 488bf8          mov     rdi,rax
	fffff800`042ddbf4 4885c0          test    rax,rax
	fffff800`042ddbf7 7507            jne     nt!PsSetCreateThreadNotifyRoutine+0x20 (fffff800`042ddc00)
	fffff800`042ddbf9 b89a0000c0      mov     eax,0C000009Ah
	fffff800`042ddbfe eb4a            jmp     nt!PsSetCreateThreadNotifyRoutine+0x6a (fffff800`042ddc4a)
	fffff800`042ddc00 33db            xor     ebx,ebx
	fffff800`042ddc02 488d0d5799d9ff  lea     rcx,[nt!PspCreateThreadNotifyRoutine (fffff800`04077560)]
	fffff800`042ddc09 4533c0          xor     r8d,r8d

	kd> u fffff800`04077560
	nt!PspCreateThreadNotifyRoutine:
	fffff800`04077560 0000            add     byte ptr [rax],al
	fffff800`04077562 0000            add     byte ptr [rax],al
	fffff800`04077564 0000            add     byte ptr [rax],al
	fffff800`04077566 0000            add     byte ptr [rax],al
	fffff800`04077568 0000            add     byte ptr [rax],al
	fffff800`0407756a 0000            add     byte ptr [rax],al
	fffff800`0407756c 0000            add     byte ptr [rax],al
	fffff800`0407756e 0000            add     byte ptr [rax],al




	*/
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0x48 && *(PUCHAR)(i+1)==0x8d && *(PUCHAR)(i+2)==0x0d)	
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+3),4);
					return OffsetAddr+7+i;
				}
			}
			break;
		}

	case WINDOWS_XP:
		{
			for(i=Address;i<Address+0xFF;i++)
			{
				if(*(PUCHAR)i==0xbe && *(PUCHAR)(i+1)==0xa0)	
				{
					LONG OffsetAddr = 0;
					memcpy(&OffsetAddr,(PUCHAR)(i+1),4);
					return OffsetAddr;
				}
			}
			break;
		}
	}

	

	return 0;
}


ULONG_PTR GetShutdownDispatch(PDEVICE_OBJECT DeviceObject)
{
	PDRIVER_OBJECT DriverObject = NULL;
	ULONG_PTR ShutdownDispatch = 0;


	if (DeviceObject && MmIsAddressValid((PVOID)DeviceObject))
	{
		DriverObject = DeviceObject->DriverObject;
		if (DriverObject && MmIsAddressValid((PVOID)DriverObject))
		{
			ShutdownDispatch = (ULONG_PTR)DriverObject->MajorFunction[IRP_MJ_SHUTDOWN];
		}
	}

	return ShutdownDispatch;
}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/CallBack.h`:

```h
#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"


typedef enum _CALLBACK_TYPE_
{
	NotifyCreateProcess,
	NotifyCreateThread,
	NotifyLoadImage,
	NotifyShutdown,
	NotifyCmCallBack,
	NotifyKeBugCheckReason,
	NotifyKeBugCheck
}CALLBACK_TYPE;

typedef struct _REMOVE_CALLBACK
{
	CALLBACK_TYPE NotifyType;
	ULONG_PTR     CallbackAddress;
	ULONG_PTR     Note;
}REMOVE_CALLBACK,*PREMOVE_CALLBACK;

typedef struct _CM_NOTIFY_ENTRY
{
	LIST_ENTRY		ListEntryHead;
	ULONG			UnKnown1;
	ULONG			UnKnown2;
	LARGE_INTEGER	Cookie;
	ULONG64			Context; 
	ULONG64			Function;
}CM_NOTIFY_ENTRY, *PCM_NOTIFY_ENTRY;

typedef struct _CALLBACK_INFO_
{
	CALLBACK_TYPE Type;
	ULONG_PTR     CallbackAddress;
	ULONG_PTR     Note;
}CALLBACK_INFO, *PCALLBACK_INFO;

typedef struct _GET_CALLBACK_
{
	ULONG_PTR ulCnt;
	ULONG_PTR ulRetCnt;
	CALLBACK_INFO Callbacks[1];
}GET_CALLBACK, *PGET_CALLBACK;


typedef
	NTSTATUS (*pfnPsSetLoadImageNotifyRoutine)(PVOID NotifyRoutine);

typedef
	NTSTATUS (*pfnCmUnRegisterCallback)(LARGE_INTEGER  Cookie);

typedef
	NTKERNELAPI
	BOOLEAN
	(*pfnKeRegisterBugCheckReasonCallback)(
	PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
	PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
	KBUGCHECK_CALLBACK_REASON Reason,
	PUCHAR Component);

typedef
	NTKERNELAPI
	NTSTATUS
	(*pfnKeRegisterBugCheckCallback)(
	PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
	PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
	PVOID Buffer,
	ULONG Length,
	PUCHAR Component
	);

typedef
	NTKERNELAPI
	NTSTATUS
	(*pfnIoRegisterShutdownNotification)(
	IN PDEVICE_OBJECT DeviceObject);

typedef
	NTKERNELAPI
	NTSTATUS
	(*pfnPsSetCreateThreadNotifyRoutine)(
	PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);




//////////////////////////////////////////////////////////////////////////

NTSTATUS HsEnumCallBackList(int InputBuffer, PVOID OutputBuffer);

ULONG_PTR FindPspLoadImageNotifyRoutine(ULONG_PTR Address);

ULONG_PTR FindKeBugCheckReasonCallbackListHeadNotifyRoutine(ULONG_PTR Address);

ULONG_PTR FindIopNotifyShutdownQueueHeadNotifyRoutine(ULONG_PTR Address);

ULONG_PTR FindPspCreateThreadNotifyRoutine(ULONG_PTR Address);

BOOLEAN GetLoadImageCallbackNotify(PGET_CALLBACK GetCallback);

BOOLEAN GetRegisterCallbackNotify(PGET_CALLBACK GetCallback);

BOOLEAN GetBugCheckReasonCallbackNotify(PGET_CALLBACK GetCallback);

BOOLEAN GetBugCheckCallbackNotify(PGET_CALLBACK GetCallback);

BOOLEAN GetShutDownCallbackNotify(PGET_CALLBACK GetCallback);

BOOLEAN GetCreateThreadCallbackNotify(PGET_CALLBACK GetCallback);

ULONG_PTR CmpCallBackVector(ULONG_PTR Address);

NTSTATUS GetAllCallbackNotify(PVOID OutBuffer);

NTSTATUS RemoveCallbackNotify(PVOID InBuffer);

LARGE_INTEGER XpGetRegisterCallbackCookie(ULONG Address);

ULONG_PTR GetShutdownDispatch(PDEVICE_OBJECT DeviceObject);





```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/DpcTimer.c`:

```c
#include "DpcTimer.h"
#include "Module.h"

extern ULONG_PTR		SYSTEM_ADDRESS_START;
extern PDRIVER_OBJECT	g_DriverObject;
extern WIN_VERSION		WinVersion;



NTSTATUS HsEnumDPCTimer(PVOID OutBuffer)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PDPC_TIMER_INFOR DpcTimerInfor = (PDPC_TIMER_INFOR)OutBuffer;

	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			ULONG KiTimerTableListHead = 0;

			KiTimerTableListHead = GetKiTimerTableListHeadXP();

			GetDpcTimerInformationWinXP((PLIST_ENTRY)KiTimerTableListHead,DpcTimerInfor);
			break;
		}

	case WINDOWS_7:
		{
			GetDpcTimerInformationWin7(DpcTimerInfor);
			break;
		}
	}


	if (DpcTimerInfor->ulCnt >= DpcTimerInfor->ulRetCnt)
	{
		Status = STATUS_SUCCESS;
	}

	return Status;
}



ULONG GetKiTimerTableListHeadXP()
{
	ULONG KiTimerTableListHead = 0;
	ULONG KeUpdateSystemTime = 0;
	UCHAR Temp = 0;

	KeUpdateSystemTime = (ULONG)HsGetFunctionAddressByName(L"KeUpdateSystemTime");

	DbgPrint("KeUpdateSystemTime: 0X%08x\n", KeUpdateSystemTime);

	if (KeUpdateSystemTime)
	{
		ULONG Start = KeUpdateSystemTime;
		ULONG End = KeUpdateSystemTime + PAGE_SIZE;

		for (;Start<End; Start++)
		{
			/*

			kd> u KeUpdateSystemTime l 50
			nt!KeUpdateSystemTime:
			804e35d8 b90000dfff      mov     ecx,0FFDF0000h
			804e35dd 8b7908          mov     edi,dword ptr [ecx+8]
			804e35e0 8b710c          mov     esi,dword ptr [ecx+0Ch]
			804e35e3 03f8            add     edi,eax
			804e35e5 83d600          adc     esi,0
			804e35e8 897110          mov     dword ptr [ecx+10h],esi
			804e35eb 897908          mov     dword ptr [ecx+8],edi
			804e35ee 89710c          mov     dword ptr [ecx+0Ch],esi
			804e35f1 290514b05580    sub     dword ptr [nt!KiTickOffset (8055b014)],eax
			804e35f7 a100b05580      mov     eax,dword ptr [nt!KeTickCount (8055b000)]
			804e35fc 8bd8            mov     ebx,eax
			804e35fe 0f8f84000000    jg      nt!KeUpdateSystemTime+0xb0 (804e3688)
			804e3604 bb0000dfff      mov     ebx,0FFDF0000h
			804e3609 8b4b14          mov     ecx,dword ptr [ebx+14h]
			804e360c 8b5318          mov     edx,dword ptr [ebx+18h]
			804e360f 030d10b05580    add     ecx,dword ptr [nt!KeTimeAdjustment (8055b010)]
			804e3615 83d200          adc     edx,0
			804e3618 89531c          mov     dword ptr [ebx+1Ch],edx
			804e361b 894b14          mov     dword ptr [ebx+14h],ecx
			804e361e 895318          mov     dword ptr [ebx+18h],edx
			804e3621 8bd8            mov     ebx,eax
			804e3623 8bc8            mov     ecx,eax
			804e3625 8b1504b05580    mov     edx,dword ptr [nt!KeTickCount+0x4 (8055b004)]
			804e362b 83c101          add     ecx,1
			804e362e 83d200          adc     edx,0
			804e3631 891508b05580    mov     dword ptr [nt!KeTickCount+0x8 (8055b008)],edx
			804e3637 890d00b05580    mov     dword ptr [nt!KeTickCount (8055b000)],ecx
			804e363d 891504b05580    mov     dword ptr [nt!KeTickCount+0x4 (8055b004)],edx
			804e3643 50              push    eax
			804e3644 a10000dfff      mov     eax,dword ptr ds:[FFDF0000h]
			804e3649 83c001          add     eax,1
			804e364c 7306            jae     nt!KeUpdateSystemTime+0x7c (804e3654)
			804e364e ff059c005680    inc     dword ptr [nt!ExpTickCountAdjustmentCount (8056009c)]
			804e3654 a198005680      mov     eax,dword ptr [nt!ExpTickCountAdjustment (80560098)]
			804e3659 0faf059c005680  imul    eax,dword ptr [nt!ExpTickCountAdjustmentCount (8056009c)]
			804e3660 03c1            add     eax,ecx
			804e3662 a30000dfff      mov     dword ptr ds:[FFDF0000h],eax
			804e3667 58              pop     eax
			804e3668 25ff000000      and     eax,0FFh
			804e366d 8d0cc5a0355680  lea     ecx,nt!KiTimerTableListHead (805635a0)[eax*8]

			*/

			Temp = *(PCHAR)Start;
			if (Temp == 0x8d)
			{
				KiTimerTableListHead = *(PULONG)(Start + 3);
				if (KiTimerTableListHead && MmIsAddressValid((PVOID)KiTimerTableListHead))
				{
					break;
				}
			}
		}
	}

	return KiTimerTableListHead;
}



NTSTATUS GetDpcTimerInformationWinXP(PLIST_ENTRY KiTimerTableListHead, PDPC_TIMER_INFOR DpcTimerInfor)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	ULONG TIMER_TABLE_SIZE = 0x100;     //查看Wrk代码是0x200 但 写成0x200 会蓝屏



	if (KiTimerTableListHead &&
		DpcTimerInfor &&
		TIMER_TABLE_SIZE && 
		MmIsAddressValid((PVOID)KiTimerTableListHead))
	{
		ULONG i = 0, n = 0;
		KIRQL OldIrql = KeRaiseIrqlToDpcLevel();

		for (i = 0; i < TIMER_TABLE_SIZE; i++)
		{
			PLIST_ENTRY NextEntry = (&KiTimerTableListHead[i])->Flink;

			while (MmIsAddressValid(NextEntry) && &KiTimerTableListHead[i] != NextEntry)
			{
				PKTIMER Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);

				if (Timer && 
					MmIsAddressValid(Timer) &&
					MmIsAddressValid(Timer->Dpc) &&
					MmIsAddressValid(Timer->Dpc->DeferredRoutine))
				{
					if (DpcTimerInfor->ulCnt > DpcTimerInfor->ulRetCnt)
					{
						PKDPC Dpc = Timer->Dpc;
						PVOID TimerDispatch = Dpc->DeferredRoutine;


						DpcTimerInfor->DpcTimer[n].Dpc = (ULONG)Dpc;
						DpcTimerInfor->DpcTimer[n].Period = Timer->Period;
						DpcTimerInfor->DpcTimer[n].TimeDispatch = (ULONG)TimerDispatch;
						DpcTimerInfor->DpcTimer[n].TimerObject = (ULONG)Timer;

						n++;
					}

					DpcTimerInfor->ulRetCnt++;
				}

				NextEntry = NextEntry->Flink;
			}
		}

		KeLowerIrql(OldIrql);
	}

	return Status;
}



NTSTATUS GetDpcTimerInformationWin7(PDPC_TIMER_INFOR DpcTimerInfor)
{
	ULONG CPUNumber = KeNumberProcessors;   //系统变量
	PUCHAR CurrentKPRCBAddress = NULL;             //CPU控制块
	PUCHAR CurrentTimerTableEntry = NULL;
	PLIST_ENTRY CurrentEntry = NULL;
	PLIST_ENTRY NextEntry = NULL;
	PULONG64    KiWaitAlways = NULL;
	PULONG64    KiWaitNever  = NULL;
	int i = 0;
	int j = 0;
	int n = 0;
	PKTIMER Timer;
	for(j=0; j<CPUNumber; j++)
	{
		KeSetSystemAffinityThread(j+1);   //使当前线程运行在第一个处理器上，因为只有第一个处理器的值才有效
		CurrentKPRCBAddress=(PUCHAR)__readmsr(0xC0000101) + 0x20;
		KeRevertToUserAffinityThread();   ////恢复线程运行的处理器
	
		CurrentTimerTableEntry=(PUCHAR)(*(ULONG64*)CurrentKPRCBAddress + 0x2200 + 0x200);
		/*
		kd> dt _Kprcb
		nt!_KPRCB
		+0x000 MxCsr            : Uint4B
		+0x004 LegacyNumber     : UChar
		+0x005 ReservedMustBeZero : UChar
		+0x006 InterruptRequest : UChar
		+0x21ec UnusedPad        : Uint4B
		+0x21f0 PrcbPad50        : [2] Uint8B
		+0x2200 TimerTable       : _KTIMER_TABLE


		kd> dt _KTIMER_TABLE
		nt!_KTIMER_TABLE
		+0x000 TimerExpiry      : [64] Ptr64 _KTIMER
		+0x200 TimerEntries     : [256] _KTIMER_TABLE_ENTRY


		kd> dt _KTIMER_TABLE_ENTRY
		nt!_KTIMER_TABLE_ENTRY
		+0x000 Lock             : Uint8B
		+0x008 Entry            : _LIST_ENTRY
		+0x018 Time             : _ULARGE_INTEGER
		*/

	
		FindKiWaitFunc(&KiWaitNever,&KiWaitAlways);
		for(i=0; i<0x100; i++)
		{
			typedef struct _KTIMER_TABLE_ENTRY
			{
				ULONG64			Lock;
				LIST_ENTRY		Entry;
				ULARGE_INTEGER	Time;
			} KTIMER_TABLE_ENTRY, *PKTIMER_TABLE_ENTRY;
			CurrentEntry = (PLIST_ENTRY)(CurrentTimerTableEntry + sizeof(KTIMER_TABLE_ENTRY) * i + 8);  //这里是个数组  + 8 过Lock
			NextEntry = CurrentEntry->Blink;
			if( MmIsAddressValid(CurrentEntry) && MmIsAddressValid(CurrentEntry) )
			{
				while( NextEntry != CurrentEntry )
				{
					PKDPC RealDpc;

					//获得首地址
					Timer = CONTAINING_RECORD(NextEntry,KTIMER,TimerListEntry);
					/*
					kd> dt _KTIMER
					nt!_KTIMER
					+0x000 Header           : _DISPATCHER_HEADER
					+0x018 DueTime          : _ULARGE_INTEGER
					+0x020 TimerListEntry   : _LIST_ENTRY
					+0x030 Dpc              : Ptr64 _KDPC
					+0x038 Processor        : Uint4B
					+0x03c Period           : Uint4B
					*/
					RealDpc=TransTimerDpcEx(Timer,*KiWaitNever,*KiWaitAlways);
					if( MmIsAddressValid(Timer)&&MmIsAddressValid(RealDpc)&&MmIsAddressValid(RealDpc->DeferredRoutine))
					{
				
						if (DpcTimerInfor->ulCnt > DpcTimerInfor->ulRetCnt)
						{
							DpcTimerInfor->DpcTimer[n].Dpc = (ULONG64)RealDpc;
							DpcTimerInfor->DpcTimer[n].Period = Timer->Period;
							DpcTimerInfor->DpcTimer[n].TimeDispatch = (ULONG64)RealDpc->DeferredRoutine;
							DpcTimerInfor->DpcTimer[n].TimerObject = (ULONG64)Timer;

							n++;
						}
					
						DpcTimerInfor->ulRetCnt++;
					
					}
					NextEntry = NextEntry->Blink;
				}
			}
		}
	}
}



VOID FindKiWaitFunc(PULONG64 *KiWaitNeverAddr, PULONG64 *KiWaitAlwaysAddr)
{
	/*
	kd> u kesettimer l 50
	nt!KeSetTimer:
	fffff800`03ef10a8 4883ec38        sub     rsp,38h
	fffff800`03ef10ac 4c89442420      mov     qword ptr [rsp+20h],r8
	fffff800`03ef10b1 4533c9          xor     r9d,r9d
	fffff800`03ef10b4 4533c0          xor     r8d,r8d
	fffff800`03ef10b7 e814000000      call    nt!KiSetTimerEx (fffff800`03ef10d0)
	fffff800`03ef10bc 4883c438        add     rsp,38h
	fffff800`03ef10c0 c3              ret
	fffff800`03ef10c1 90              nop
	fffff800`03ef10c2 90              nop
	fffff800`03ef10c3 90              nop
	fffff800`03ef10c4 90              nop
	fffff800`03ef10c5 90              nop
	fffff800`03ef10c6 90              nop
	fffff800`03ef10c7 90              nop
	nt!KxWaitForLockChainValid:
	fffff800`03ef10c8 90              nop
	fffff800`03ef10c9 90              nop
	fffff800`03ef10ca 90              nop
	fffff800`03ef10cb 90              nop
	fffff800`03ef10cc 90              nop
	fffff800`03ef10cd 90              nop
	fffff800`03ef10ce 90              nop
	fffff800`03ef10cf 90              nop
	nt!KiSetTimerEx:
	fffff800`03ef10d0 48895c2408      mov     qword ptr [rsp+8],rbx
	fffff800`03ef10d5 4889542410      mov     qword ptr [rsp+10h],rdx
	fffff800`03ef10da 55              push    rbp
	fffff800`03ef10db 56              push    rsi
	fffff800`03ef10dc 57              push    rdi
	fffff800`03ef10dd 4154            push    r12
	fffff800`03ef10df 4155            push    r13
	fffff800`03ef10e1 4156            push    r14
	fffff800`03ef10e3 4157            push    r15
	fffff800`03ef10e5 4883ec50        sub     rsp,50h
	fffff800`03ef10e9 488b0518502200  mov     rax,qword ptr [nt!KiWaitNever (fffff800`04116108)]
	fffff800`03ef10f0 488b1de9502200  mov     rbx,qword ptr [nt!KiWaitAlways (fffff800`041161e0)]
    */
	long Temp;
	PUCHAR StartAddress,i;
	UNICODE_STRING  uniFuncName;
	WCHAR wzFunName[] = L"KeSetTimer";
	RtlInitUnicodeString(&uniFuncName,wzFunName);
	StartAddress = (PUCHAR)MmGetSystemRoutineAddress(&uniFuncName);
	for(i=StartAddress; i<StartAddress+0xFF; i++)
	{
		if(*i==0x48 && *(i+1)==0x8B && *(i+2)==0x05)
		{
			memcpy(&Temp,i+3,4);
			*KiWaitNeverAddr=(PULONG64)((ULONGLONG)Temp + (ULONGLONG)i + 7);
			i=i+7;
			memcpy(&Temp,i+3,4);
			*KiWaitAlwaysAddr=(PULONG64)((ULONGLONG)Temp + (ULONGLONG)i + 7);
			return;
		}
	}
}




KDPC* TransTimerDpcEx(
	IN PKTIMER InTimer,
	IN ULONGLONG InKiWaitNever,
	IN ULONGLONG InKiWaitAlways)
{
	ULONGLONG			RDX = (ULONGLONG)InTimer->Dpc;
	RDX ^= InKiWaitNever;
	RDX = _rotl64(RDX, (UCHAR)(InKiWaitNever & 0xFF));
	RDX ^= (ULONGLONG)InTimer;
	RDX = _byteswap_uint64(RDX);
	RDX ^= InKiWaitAlways;
	return (KDPC*)RDX;
}






NTSTATUS RemoveDPCTimer(PVOID InBuffer)
{
	PREMOVE_DPCTIMER Temp = (PREMOVE_DPCTIMER)InBuffer;

	ULONG_PTR TimerObject = Temp->TimerObject;


	if (TimerObject&&MmIsAddressValid((PVOID)TimerObject))
	{

		if (KeCancelTimer((PKTIMER)TimerObject))
		{
			return STATUS_SUCCESS;
		}
	}

	return STATUS_UNSUCCESSFUL;
}
















```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/DpcTimer.h`:

```h
#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"




typedef struct _REMOVE_DPCTIMER
{
	ULONG_PTR     TimerObject;
}REMOVE_DPCTIMER,*PREMOVE_DPCTIMER;




typedef struct _DPC_TIMER_
{
	ULONG_PTR TimerObject;
	ULONG_PTR Period;			// 周期
	ULONG_PTR TimeDispatch;
	ULONG_PTR Dpc;
}DPC_TIMER, *PDPC_TIMER;


typedef struct _DPC_TIMER_INFOR_
{
	ULONG ulCnt;
	ULONG ulRetCnt;
	DPC_TIMER DpcTimer[1];
}DPC_TIMER_INFOR, *PDPC_TIMER_INFOR;




NTSTATUS HsEnumDPCTimer(PVOID OutBuffer);

ULONG GetKiTimerTableListHeadXP();

NTSTATUS GetDpcTimerInformationWinXP(PLIST_ENTRY KiTimerTableListHead, PDPC_TIMER_INFOR DpcTimerInfor);

NTSTATUS GetDpcTimerInformationWin7(PDPC_TIMER_INFOR DpcTimerInfor);

VOID FindKiWaitFunc(PULONG64 *KiWaitNeverAddr, PULONG64 *KiWaitAlwaysAddr);

KDPC* TransTimerDpcEx(
	IN PKTIMER InTimer,
	IN ULONGLONG InKiWaitNever,
	IN ULONGLONG InKiWaitAlways);

NTSTATUS RemoveDPCTimer(PVOID InBuffer);


















```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/FilterDriver.c`:

```c
#include "FilterDriver.h"
#include "Module.h"

extern ULONG_PTR		SYSTEM_ADDRESS_START;
extern PDRIVER_OBJECT	g_DriverObject;
extern WIN_VERSION		WinVersion;

ULONG_PTR ulVolumeStartCount = 0;
ULONG_PTR ulFileSystemStartCount = 0;

NTSTATUS HsEnumFilterDriver(PFILTER_DRIVER FilterDriverInfor)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	// 写上所有的驱动名。

	ulVolumeStartCount = 0;
	ulFileSystemStartCount = 0;

	Status = GetFilterDriverByDriverName(L"\\Driver\\Disk", FilterDriverInfor,Disk);
	Status = GetFilterDriverByDriverName(L"\\Driver\\volmgr", FilterDriverInfor,Volume);
	Status = GetFilterDriverByDriverName(L"\\FileSystem\\ntfs", FilterDriverInfor,File);
	Status = GetFilterDriverByDriverName(L"\\FileSystem\\fastfat", FilterDriverInfor,File);
	Status = GetFilterDriverByDriverName(L"\\FileSystem\\Raw", FilterDriverInfor,RAW);
	Status = GetFilterDriverByDriverName(L"\\driver\\kbdclass", FilterDriverInfor,Keyboard);
	Status = GetFilterDriverByDriverName(L"\\driver\\mouclass", FilterDriverInfor,Mouse);
	Status = GetFilterDriverByDriverName(L"\\driver\\i8042prt", FilterDriverInfor,I8042prt);
	Status = GetFilterDriverByDriverName(L"\\Driver\\tdx", FilterDriverInfor,Tdx);
	Status = GetFilterDriverByDriverName(L"\\Driver\\NDIS", FilterDriverInfor,NDIS);
	Status = GetFilterDriverByDriverName(L"\\Driver\\PnpManager", FilterDriverInfor,PnpManager);

	return Status;
}



NTSTATUS HsUnloadFilterDriver(PUNLOAD_FILTER UnloadFilter)
{
	NTSTATUS Status;

	DbgPrint("FilterType: %d\r\n",UnloadFilter->Type);
	DbgPrint("DeviceObject: %d\r\n",UnloadFilter->DeviceObject);

	switch(UnloadFilter->Type)
	{
	case Disk:
		{
			Status = ClearFilters(L"\\Driver\\Disk", UnloadFilter->DeviceObject);
			break;
		}
	default:
		{

		}
	}

	return Status;
}




NTSTATUS ClearFilters(WCHAR* wzDriverName,ULONG_PTR DeviceObject)
{
	UNICODE_STRING uniDriverName;
	PDRIVER_OBJECT DriverObject;
	PDEVICE_OBJECT CurrentDevice;
	NTSTATUS Status;


	RtlInitUnicodeString(&uniDriverName, wzDriverName);
	Status = ObReferenceObjectByName(&uniDriverName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		0,
		*IoDriverObjectType,
		KernelMode,
		NULL,
		(PVOID*)&DriverObject);

	if (!NT_SUCCESS(Status)) return ;
	if(!DriverObject) return ;
	CurrentDevice = DriverObject->DeviceObject;
	while(CurrentDevice != NULL )
	{
		if ((ULONG_PTR)CurrentDevice->AttachedDevice == DeviceObject)
		{

			CurrentDevice->AttachedDevice = ((PDEVICE_OBJECT)DeviceObject)->AttachedDevice;

		}
		CurrentDevice = CurrentDevice->NextDevice;
	}
	ObDereferenceObject(DriverObject);

	return Status;
}



NTSTATUS GetFilterDriverByDriverName(WCHAR *wzDriverName, PFILTER_DRIVER FilterDriverInfor, FILTER_TYPE Type)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	UNICODE_STRING uniDriverName;
	PDRIVER_OBJECT DriverObject = NULL;
	POBJECT_TYPE DriverObjectType = *IoDriverObjectType;


	if (!DriverObjectType)
	{
		return Status;
	}

	RtlInitUnicodeString(&uniDriverName, wzDriverName);

	Status = ObReferenceObjectByName(
		&uniDriverName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		0,
		DriverObjectType,
		KernelMode,
		NULL,
		(PVOID*)&DriverObject);

	if (NT_SUCCESS(Status) && DriverObject)
	{
		PDEVICE_OBJECT DeviceObject = NULL;

		for ( DeviceObject = DriverObject->DeviceObject;
			  DeviceObject;
			  DeviceObject = DeviceObject->NextDevice )
		{


			PDRIVER_OBJECT AttachedDriverObject = DeviceObject->DriverObject;
			PDEVICE_OBJECT AttachDeviceObject = NULL;

			for ( AttachDeviceObject = DeviceObject->AttachedDevice; 
				  AttachDeviceObject; 
				  AttachDeviceObject = AttachDeviceObject->AttachedDevice )
			{
				Status = AddFilterInfo( AttachDeviceObject, AttachedDriverObject, FilterDriverInfor, Type );
				AttachedDriverObject = AttachDeviceObject->DriverObject;
			}

		}

		ObfDereferenceObject(DriverObject);
	}

	return Status;
}




NTSTATUS AddFilterInfo(PDEVICE_OBJECT AttachDeviceObject, PDRIVER_OBJECT AttachedDriverObject, PFILTER_DRIVER FilterDriverInfor, FILTER_TYPE Type)
{
	if (AttachDeviceObject && AttachedDriverObject && FilterDriverInfor)
	{
		if (FilterDriverInfor->ulCnt > FilterDriverInfor->ulRetCnt)
		{
			ULONG_PTR ulRetCnt = FilterDriverInfor->ulRetCnt;
			PDRIVER_OBJECT   AttachDriverObject = AttachDeviceObject->DriverObject;
			PKLDR_DATA_TABLE_ENTRY Entry = NULL;

			BOOLEAN bIsExist = FALSE;
			ULONG_PTR i = 0;
			char Temp[260] = {0};


			if (Type == File || Type == RAW)
			{
				if (ulFileSystemStartCount == 0)
				{
					ulFileSystemStartCount = ulRetCnt;
				}
				for (i = ulFileSystemStartCount; i < ulRetCnt; i++)
				{
					if (_wcsnicmp(FilterDriverInfor->Filter[i].wzFilterDriverName,
						AttachDriverObject->DriverName.Buffer,
						wcslen(FilterDriverInfor->Filter[i].wzFilterDriverName))==0 && 
						_wcsnicmp(FilterDriverInfor->Filter[i].wzAttachedDriverName,
						AttachedDriverObject->DriverName.Buffer,
						wcslen(FilterDriverInfor->Filter[i].wzAttachedDriverName))==0)
					{
						return STATUS_SUCCESS;
					}
				}
			}
			if (Type == Volume)
			{
				if (ulVolumeStartCount == 0)
				{
					ulVolumeStartCount = ulRetCnt;
				}
				for (i = 0; i < ulRetCnt; i++)
				{
					if (_wcsnicmp(FilterDriverInfor->Filter[i].wzFilterDriverName,
						AttachDriverObject->DriverName.Buffer,
						wcslen(FilterDriverInfor->Filter[i].wzFilterDriverName))==0 && 
						_wcsnicmp(FilterDriverInfor->Filter[i].wzAttachedDriverName,
						AttachedDriverObject->DriverName.Buffer,
						wcslen(FilterDriverInfor->Filter[i].wzAttachedDriverName))==0)
					{
						return STATUS_SUCCESS;
					}
				}

			}
			

			FilterDriverInfor->Filter[ulRetCnt].FileterDeviceObject = (ULONG_PTR)AttachDeviceObject;
			FilterDriverInfor->Filter[ulRetCnt].Type = Type;

			if (IsUnicodeStringValid(&(AttachDriverObject->DriverName)))
			{
				RtlZeroMemory(FilterDriverInfor->Filter[ulRetCnt].wzAttachedDriverName,100);
				memcpy(
					FilterDriverInfor->Filter[ulRetCnt].wzFilterDriverName, 
					AttachDriverObject->DriverName.Buffer,
					AttachDriverObject->DriverName.Length);
			}

			if (IsUnicodeStringValid(&(AttachedDriverObject->DriverName)))
			{
				RtlZeroMemory(FilterDriverInfor->Filter[ulRetCnt].wzAttachedDriverName,100);
				memcpy(
					FilterDriverInfor->Filter[ulRetCnt].wzAttachedDriverName,
					AttachedDriverObject->DriverName.Buffer, 
					AttachedDriverObject->DriverName.Length);
			}

			Entry = (PKLDR_DATA_TABLE_ENTRY)AttachDriverObject->DriverSection;

			if ((ULONG_PTR)Entry > SYSTEM_ADDRESS_START)
			{
				if (IsUnicodeStringValid(&(Entry->FullDllName)))
				{

					memcpy(FilterDriverInfor->Filter[ulRetCnt].wzPath, Entry->FullDllName.Buffer,Entry->FullDllName.Length);
				}
				else if (IsUnicodeStringValid(&(Entry->BaseDllName)))
				{

					memcpy(FilterDriverInfor->Filter[ulRetCnt].wzPath, Entry->BaseDllName.Buffer, Entry->BaseDllName.Length);
				}
			}
		}

		else
		{

			return STATUS_BUFFER_TOO_SMALL;
		}

		FilterDriverInfor->ulRetCnt++;

		return STATUS_SUCCESS;
	}
}






```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/FilterDriver.h`:

```h
#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"


#define MAX_PATH 260

typedef enum _FILTER_TYPE_
{
	Unkonw,
	File,
	Disk,
	Volume,
	Keyboard,
	Mouse,
	I8042prt,
	Tcpip,
	NDIS,
	PnpManager,
	Tdx,
	RAW
}FILTER_TYPE;

typedef struct _FILTER_INFO_
{
	FILTER_TYPE Type;
	ULONG_PTR FileterDeviceObject;
	WCHAR wzFilterDriverName[100];
	WCHAR wzAttachedDriverName[100];
	WCHAR wzPath[MAX_PATH];
}FILTER_INFO, *PFILTER_INFO;

typedef struct _FILTER_DRIVER_
{
	ULONG_PTR ulCnt;
	ULONG_PTR ulRetCnt;
	FILTER_INFO Filter[1];
}FILTER_DRIVER, *PFILTER_DRIVER;

typedef struct _UNLOAD_FILTER_
{
	FILTER_TYPE Type;
	ULONG_PTR   DeviceObject;
}UNLOAD_FILTER, *PUNLOAD_FILTER;



extern
	POBJECT_TYPE* IoDriverObjectType;

typedef 
	NTSTATUS (*pfnRtlGetVersion)(OUT PRTL_OSVERSIONINFOW lpVersionInformation);

NTSTATUS 
	ObReferenceObjectByName( 
	IN PUNICODE_STRING ObjectName, 
	IN ULONG Attributes, 
	IN PACCESS_STATE AccessState OPTIONAL, 
	IN ACCESS_MASK DesiredAccess OPTIONAL, 
	IN POBJECT_TYPE ObjectType, 
	IN KPROCESSOR_MODE AccessMode, 
	IN OUT PVOID ParseContext OPTIONAL, 
	OUT PVOID *Object 
	);




NTSTATUS HsEnumFilterDriver(PFILTER_DRIVER FilterDriverInfor);

NTSTATUS GetFilterDriverByDriverName(WCHAR *wzDriverName, PFILTER_DRIVER FilterDriverInfor, FILTER_TYPE Type);

NTSTATUS AddFilterInfo(PDEVICE_OBJECT AttachDeviceObject, PDRIVER_OBJECT AttachedDriverObject, PFILTER_DRIVER FilterDriverInfor, FILTER_TYPE Type);

NTSTATUS HsUnloadFilterDriver(PUNLOAD_FILTER UnloadFilter);

NTSTATUS ClearFilters(WCHAR* wzDriverName,ULONG_PTR DeviceObject);









```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/GetFuncAddress.c`:

```c
#include "GetFuncAddress.h"
#include "common.h"


ULONG_PTR   IndexOffset = 0;

extern WIN_VERSION WinVersion;


ULONG_PTR  HsGetFuncAddress(char* szFuncAddress)
{

	ULONG_PTR SSDTDescriptor = 0;
	ULONG_PTR ulIndex = 0;
	ULONG_PTR SSDTFuncAddress = 0;

	switch(WinVersion)
	{
	case WINDOWS_7:
		{

			SSDTDescriptor = GetKeServiceDescriptorTable64();
			IndexOffset = 4;

			break;
		}

	case WINDOWS_XP:
		{
			SSDTDescriptor = (ULONG_PTR)HsGetFunctionAddressByName(L"KeServiceDescriptorTable");
			IndexOffset = 1;

			break;
		}
	}

	ulIndex = GetSSDTApiFunIndex(szFuncAddress);


	SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);


	return SSDTFuncAddress;
}



ULONG_PTR GetSSDTApiFunAddress(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor)
{
	ULONG_PTR  SSDTFuncAddress = 0;
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			SSDTFuncAddress = GetSSDTFunctionAddress64(ulIndex,SSDTDescriptor);
			break;
		}

	case WINDOWS_XP:
		{
			SSDTFuncAddress = GetSSDTFunctionAddress32(ulIndex,SSDTDescriptor);
			break;
		}
	}
}


ULONG_PTR GetSSDTFunctionAddress32(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor)
{
	ULONG_PTR ServiceTableBase= 0 ;
	PSYSTEM_SERVICE_TABLE32 SSDT = (PSYSTEM_SERVICE_TABLE32)SSDTDescriptor;

	ServiceTableBase=(ULONG_PTR)(SSDT ->ServiceTableBase);

	return (ULONG_PTR)(((ULONG*)ServiceTableBase)[(ULONG)ulIndex]);
}



ULONG_PTR GetSSDTFunctionAddress64(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor)
{
	LONG dwTemp=0;
	ULONG_PTR qwTemp=0;
	ULONG_PTR ServiceTableBase= 0 ;
	ULONG_PTR FuncAddress =0;
	PSYSTEM_SERVICE_TABLE64 SSDT = (PSYSTEM_SERVICE_TABLE64)SSDTDescriptor;
	ServiceTableBase=(ULONG_PTR)(SSDT ->ServiceTableBase);
	qwTemp = ServiceTableBase + 4 * ulIndex;
	dwTemp = *(PLONG)qwTemp;
	dwTemp = dwTemp>>4;
	FuncAddress = ServiceTableBase + (ULONG_PTR)dwTemp;
	return FuncAddress;
}


LONG GetSSDTApiFunIndex(IN LPSTR lpszFunName)
{
	LONG Index = -1;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PVOID    MapBase = NULL;
	PIMAGE_NT_HEADERS  NtHeader;
	PIMAGE_EXPORT_DIRECTORY ExportTable;
	ULONG*  FunctionAddresses;
	ULONG*  FunctionNames;
	USHORT* FunIndexs;
	ULONG   ulFunIndex;
	ULONG   i;
	CHAR*   FunName;
	SIZE_T  ViewSize=0;
	ULONG_PTR FunAddress;
	WCHAR wzNtdll[] = L"\\SystemRoot\\System32\\ntdll.dll";

	Status = MapFileInUserSpace(wzNtdll, NtCurrentProcess(), &MapBase, &ViewSize);
	if (!NT_SUCCESS(Status))
	{

		return STATUS_UNSUCCESSFUL;

	}
	else
	{
		__try{
			NtHeader = RtlImageNtHeader(MapBase);
			if (NtHeader && NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress){
				ExportTable =(IMAGE_EXPORT_DIRECTORY *)((ULONG_PTR)MapBase + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
				FunctionAddresses = (ULONG*)((ULONG_PTR)MapBase + ExportTable->AddressOfFunctions);
				FunctionNames = (ULONG*)((ULONG_PTR)MapBase + ExportTable->AddressOfNames);
				FunIndexs = (USHORT*)((ULONG_PTR)MapBase + ExportTable->AddressOfNameOrdinals);
				for(i = 0; i < ExportTable->NumberOfNames; i++)
				{
					FunName = (LPSTR)((ULONG_PTR)MapBase + FunctionNames[i]);
					if (_stricmp(FunName, lpszFunName) == 0) 
					{
						ulFunIndex = FunIndexs[i]; 
						FunAddress = (ULONG_PTR)((ULONG_PTR)MapBase + FunctionAddresses[ulFunIndex]);
						Index=*(ULONG*)(FunAddress+IndexOffset);
						break;
					}
				}
			}
		}__except(EXCEPTION_EXECUTE_HANDLER)
		{
			;
		}
	}

	if (Index == -1)
	{
		DbgPrint("%s Get Index Error\n", lpszFunName);
	}

	ZwUnmapViewOfSection(NtCurrentProcess(), MapBase);
	return Index;
}




ULONG_PTR GetKeServiceDescriptorTable64()
{
	PUCHAR StartSearchAddress = (PUCHAR)__readmsr(0xC0000082);
	PUCHAR EndSearchAddress = StartSearchAddress + 0x500;
	PUCHAR i = NULL;
	UCHAR b1=0,b2=0,b3=0;
	ULONG_PTR Temp = 0;
	ULONG_PTR Address = 0;
	for(i=StartSearchAddress;i<EndSearchAddress;i++)
	{
		if( MmIsAddressValid(i) && MmIsAddressValid(i+1) && MmIsAddressValid(i+2) )
		{
			b1=*i;
			b2=*(i+1);
			b3=*(i+2);
			if( b1==0x4c && b2==0x8d && b3==0x15 ) //4c8d15
			{
				memcpy(&Temp,i+3,4);
				Address = (ULONG_PTR)Temp + (ULONG_PTR)i + 7;
				return Address;
			}
		}
	}
	return 0;
}




NTSTATUS 
	MapFileInUserSpace(IN LPWSTR lpszFileName,IN HANDLE ProcessHandle OPTIONAL,
	OUT PVOID *BaseAddress,
	OUT PSIZE_T ViewSize OPTIONAL)
{
	NTSTATUS Status = STATUS_INVALID_PARAMETER;
	HANDLE   hFile = NULL;
	HANDLE   hSection = NULL;
	OBJECT_ATTRIBUTES oa;
	SIZE_T MapViewSize = 0;
	IO_STATUS_BLOCK Iosb;
	UNICODE_STRING uniFileName;

	if (!lpszFileName || !BaseAddress){
		return Status;
	}

	RtlInitUnicodeString(&uniFileName, lpszFileName);
	InitializeObjectAttributes(&oa,
		&uniFileName,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL,
		NULL
		);

	Status = IoCreateFile(&hFile,
		GENERIC_READ | SYNCHRONIZE,
		&oa,
		&Iosb,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ,
		FILE_OPEN,
		FILE_SYNCHRONOUS_IO_NONALERT,
		NULL,
		0,
		CreateFileTypeNone,
		NULL,
		IO_NO_PARAMETER_CHECKING
		);

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("ZwCreateFile Failed! Error=%08x\n",Status);
		return Status;
	}

	oa.ObjectName = NULL;
	Status = ZwCreateSection(&hSection,
		SECTION_QUERY | SECTION_MAP_READ,
		&oa,
		NULL,
		PAGE_WRITECOPY,
		SEC_IMAGE,
		hFile
		);
	ZwClose(hFile);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("ZwCreateSection Failed! Error=%08x\n",Status);
		return Status;

	}

	if (!ProcessHandle){
		ProcessHandle = NtCurrentProcess();
	}

	Status = ZwMapViewOfSection(hSection, 
		ProcessHandle, 
		BaseAddress, 
		0, 
		0, 
		0, 
		ViewSize ? ViewSize : &MapViewSize, 
		ViewUnmap, 
		0, 
		PAGE_WRITECOPY
		);
	ZwClose(hSection);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("ZwMapViewOfSection Failed! Error=%08x\n",Status);
		return Status;
	}

	return Status;
}

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/GetFuncAddress.h`:

```h
#ifndef _GETFUNCADDRESS_H 
#define _GETFUNCADDRESS_H



#include <ntifs.h>
#include <ntimage.h>


#define SEC_IMAGE 0x01000000

typedef struct _SYSTEM_SERVICE_TABLE64{
	PVOID  		ServiceTableBase; 
	PVOID  		ServiceCounterTableBase; 
	ULONG64  	NumberOfServices; 
	PVOID  		ParamTableBase; 
} SYSTEM_SERVICE_TABLE64, *PSYSTEM_SERVICE_TABLE64;

typedef struct _SYSTEM_SERVICE_TABLE32 {
	PVOID   ServiceTableBase;
	PVOID   ServiceCounterTableBase;
	ULONG32 NumberOfServices;
	PVOID   ParamTableBase;
} SYSTEM_SERVICE_TABLE32, *PSYSTEM_SERVICE_TABLE32;

NTSYSAPI
	PIMAGE_NT_HEADERS
	NTAPI
	RtlImageNtHeader(PVOID Base);

ULONG_PTR  HsGetFuncAddress(char* szFuncAddress);

LONG GetSSDTApiFunIndex(IN LPSTR lpszFunName);

NTSTATUS 
MapFileInUserSpace(IN LPWSTR lpszFileName,IN HANDLE ProcessHandle OPTIONAL,
	OUT PVOID *BaseAddress,
	OUT PSIZE_T ViewSize OPTIONAL);

ULONG_PTR GetSSDTApiFunAddress(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor);

ULONG_PTR GetSSDTFunctionAddress32(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor);
ULONG_PTR GetSSDTFunctionAddress64(ULONG_PTR ulIndex,ULONG_PTR SSDTDescriptor);
ULONG_PTR GetKeServiceDescriptorTable64();


#endif

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/GetSSSDTFuncAddress.c`:

```c
#include "GetSSSDTFuncAddress.h"
#include "common.h"


ULONG32	NtUserBuildHwndListIndex32WinXP = 312;
ULONG32	NtUserQueryWindowIndex32WinXP = 483;


ULONG64	NtUserQueryWindowIndex64Win7 = 0x1010;
ULONG64	NtUserBuildHwndListIndex64Win7 = 0x101C;

pfnNtUserBuildHwndList AddressNtUserBuildHwndList = 0;
pfnNtUserQueryWindow AddressNtUserQueryWindow = 0;

extern 
WIN_VERSION WinVersion;
extern
ULONG_PTR ulBuildNumber;

ULONG_PTR  GetSSSDTApi()
{
	ULONG_PTR       SSSDTDescriptor = 0;
	ULONG_PTR       SSSDTFuncAddress = 0;

	switch(WinVersion)
	{
	case WINDOWS_7:
		{

			SSSDTDescriptor = GetKeServiceDescriptorTableShadow64Win7();

			AddressNtUserBuildHwndList = (pfnNtUserBuildHwndList)GetSSSDTFunctionAddress64Win7(NtUserBuildHwndListIndex64Win7,SSSDTDescriptor);

			AddressNtUserQueryWindow = (pfnNtUserQueryWindow)GetSSSDTFunctionAddress64Win7(NtUserQueryWindowIndex64Win7,SSSDTDescriptor);
			break;
		}

	case WINDOWS_XP:
		{
			SSSDTDescriptor = GetKeServiceDescriptorTableShadow32WinXP();

			AddressNtUserBuildHwndList = (pfnNtUserBuildHwndList)GetSSSDTFunctionAddress32WinXP(NtUserBuildHwndListIndex32WinXP,SSSDTDescriptor);

			AddressNtUserQueryWindow = (pfnNtUserQueryWindow)GetSSSDTFunctionAddress32WinXP(NtUserQueryWindowIndex32WinXP,SSSDTDescriptor);
			break;
		}
	}


	return SSSDTFuncAddress;

}





ULONG_PTR GetKeServiceDescriptorTableShadow32WinXP()
{
	WCHAR szKeAddSystemServiceTable[] = L"KeAddSystemServiceTable";
	ULONG_PTR KeAddSystemServiceTableAddress = NULL;
	ULONG_PTR Temp = 0;
	ULONG_PTR Address = 0;
	int i = 0;
	PUCHAR StartSearchAddress;
	KeAddSystemServiceTableAddress = (ULONG_PTR)HsGetFunctionAddressByName(szKeAddSystemServiceTable);

	if (KeAddSystemServiceTableAddress==NULL)
	{
		return 0;
	}


	for (StartSearchAddress = (PUCHAR)KeAddSystemServiceTableAddress; 
			StartSearchAddress < (PUCHAR)KeAddSystemServiceTableAddress + PAGE_SIZE; 
			StartSearchAddress++)
		{
			if (ulBuildNumber < 8000)
			{
			
				if (*(unsigned short*)StartSearchAddress == 0x888d)
				{
					Temp = *(ULONG_PTR*)(StartSearchAddress+2);
			
					Address = Temp + 16;
				
				
					/*
					kd> dd 80553f60
					80553f60  80502b8c 00000000 0000011c 80503000    SSDT
					80553f70  bf999b80 00000000 0000029b bf99a890    ShadowSSDT  所以要加16
					80553f80  00000000 00000000 00000000 00000000
					80553f90  00000000 00000000 00000000 00000000
					80553fa0  80502b8c 00000000 0000011c 80503000
					80553fb0  00000000 00000000 00000000 00000000
					80553fc0  00000000 00000000 00000000 00000000
					80553fd0  00000000 00000000 00000000 00000000
					*/
					break;
				}
			}

			//其他版本
			else if (ulBuildNumber>=8000)
			{
				if (*(unsigned short*)StartSearchAddress==0xb983)
				{
					i++;
					if (i==1)
					{
					}

					if (i==2)
					{
						Temp = *(ULONG_PTR*)(StartSearchAddress+2);

						Address = Temp + 16;
						break;
					}
				}
			}
		}



	return Address;

}




ULONG_PTR GetKeServiceDescriptorTableShadow64Win7()
{
	PUCHAR StartSearchAddress = (PUCHAR)__readmsr(0xC0000082);
	PUCHAR EndSearchAddress = StartSearchAddress + 0x500;
	PUCHAR i = NULL;
	UCHAR b1=0,b2=0,b3=0;
	ULONG_PTR Temp = 0;
	ULONG_PTR Address = 0;
	for(i=StartSearchAddress;i<EndSearchAddress;i++)
	{
		if( MmIsAddressValid(i) && MmIsAddressValid(i+1) && MmIsAddressValid(i+2) )
		{
			b1=*i;
			b2=*(i+1);
			b3=*(i+2);
			if( b1==0x4c && b2==0x8d && b3==0x1d ) //4C8D1D
			{
				memcpy(&Temp,i+3,4);
				Address = (ULONG_PTR)Temp + (ULONG_PTR)i + 7;
				
				

				Address+=32;
				
				return Address;
			}
		}
	}
	return 0;
}



ULONG_PTR GetSSSDTFunctionAddress32WinXP(ULONG_PTR ulIndex,ULONG_PTR SSSDTDescriptor)
{
	ULONG_PTR ServiceTableBase= 0 ;
	PSYSTEM_SERVICE_TABLE_SSSDT32 SSSDT = (PSYSTEM_SERVICE_TABLE_SSSDT32)SSSDTDescriptor;

	ServiceTableBase=(ULONG_PTR)(SSSDT ->ServiceTableBase);

	return (ULONG_PTR)(((ULONG*)ServiceTableBase)[(ULONG)ulIndex]);
}



ULONG_PTR GetSSSDTFunctionAddress64Win7(ULONG_PTR ulIndex,ULONG_PTR SSSDTDescriptor)
{
	LONG dwTemp=0;
	ULONG_PTR qwTemp=0;
	ULONG_PTR ServiceTableBase= 0 ;
	ULONG_PTR FuncAddress =0;
	PSYSTEM_SERVICE_TABLE_SSSDT64 SSSDT = (PSYSTEM_SERVICE_TABLE_SSSDT64)SSSDTDescriptor;
	ServiceTableBase=(ULONG_PTR)(SSSDT ->ServiceTableBase);
	qwTemp = ServiceTableBase + 4 * (ulIndex-0x1000);
	dwTemp = *(PLONG)qwTemp;
	dwTemp = dwTemp>>4;
	FuncAddress = ServiceTableBase + (ULONG_PTR)dwTemp;
	return FuncAddress;
}

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/GetSSSDTFuncAddress.h`:

```h
#ifndef _GETSSSDTFUNCADDRESS_H 
#define _GETSSSDTFUNCADDRESS_H

#include <ntifs.h>
#include <windef.h>

#endif

typedef struct _SYSTEM_SERVICE_TABLE_SSSDT64{
	PVOID  		ServiceTableBase; 
	PVOID  		ServiceCounterTableBase; 
	ULONG64  	NumberOfServices; 
	PVOID  		ParamTableBase; 
} SYSTEM_SERVICE_TABLE_SSSDT64, *PSYSTEM_SERVICE_TABLE_SSSDT64;

typedef struct _SYSTEM_SERVICE_TABLE_SSSDT32 {
	PVOID   ServiceTableBase;
	PVOID   ServiceCounterTableBase;
	ULONG32 NumberOfServices;
	PVOID   ParamTableBase;
} SYSTEM_SERVICE_TABLE_SSSDT32, *PSYSTEM_SERVICE_TABLE_SSSDT32;




ULONG_PTR GetKeServiceDescriptorTableShadow32WinXP();
ULONG_PTR GetKeServiceDescriptorTableShadow64Win7();
ULONG_PTR GetSSSDTFunctionAddress32WinXP(ULONG_PTR ulIndex,ULONG_PTR SSSDTDescriptor);
ULONG_PTR GetSSSDTFunctionAddress64Win7(ULONG_PTR ulIndex,ULONG_PTR SSSDTDescriptor);
ULONG_PTR GetSSSDTApi();



typedef
	ULONG_PTR
	(*pfnNtUserQueryWindow)(
	HWND hWnd, 
	ULONG_PTR Index);


typedef
	NTSTATUS
	(*pfnNtUserBuildHwndList)(
	HDESK hDesktop,
	HWND hwndParent,
	BOOLEAN bChildren,
	ULONG dwThreadId,
	ULONG lParam,
	HWND* pWnd,
	ULONG* pBufSize);

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Handle.c`:

```c
#include "Handle.h"
#include "GetFuncAddress.h"
#include <ntimage.h>

pfnNtQueryObject  NtQueryObjectAddress = NULL;


#define SystemHandleInformation 16
#define SEC_IMAGE 0x01000000

extern
	WIN_VERSION  WinVersion;

extern ULONG_PTR ulBuildNumber;

extern ULONG_PTR ObjectHeaderSize;

extern ULONG_PTR PreviousModeOffsetOf_KTHREAD;
extern ULONG_PTR ObjectTypeOffsetOf_Object_Header;
extern ULONG_PTR ObjectTableOffsetOf_EPROCESS;



NTSTATUS HsEnumProcessHandle(PVOID InBuffer, ULONG_PTR InSize, PVOID OutBuffer, ULONG_PTR OutSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL, LookupStatus = STATUS_UNSUCCESSFUL;

	PEPROCESS EProcess = NULL;
	ULONG ulPid = 0;
	ULONG_PTR ulCount = (OutSize - sizeof(ALL_HANDLES)) / sizeof(HANDLE_INFO);

	HsInitHandleVariable();
	NtQueryObjectAddress = (pfnNtQueryObject)HsGetFuncAddress("NtQueryObject");


	if (!InBuffer ||
		!OutBuffer)
	{
		return STATUS_INVALID_PARAMETER;
	}

	ulPid = (ULONG)InBuffer;

	if (ulPid)
	{
		LookupStatus = PsLookupProcessByProcessId((HANDLE)ulPid, &EProcess);
		if (!NT_SUCCESS(LookupStatus) || !EProcess)
		{
			return STATUS_UNSUCCESSFUL;
		}
	}


	if (HsIsRealProcess(EProcess))
	{
		Status = HsGetHandles(ulPid, (ULONG_PTR)EProcess, (PALL_HANDLES)OutBuffer, ulCount);
	}

	if (NT_SUCCESS(LookupStatus))
	{
		ObfDereferenceObject(EProcess);
	}

	return Status;
}




NTSTATUS HsGetHandles(ULONG_PTR ulPid, ULONG_PTR EProcess, PALL_HANDLES OutHandles, ULONG_PTR ulCount)
{
	NTSTATUS  Status = STATUS_UNSUCCESSFUL;
	ULONG_PTR ulRet= 0x10000;
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;


	EThread = PsGetCurrentThread();
	PreMode = HsChangePreMode(EThread);

	do 
	{
		PVOID Buffer = ExAllocatePool(PagedPool,ulRet);
		if (Buffer)
		{
			memset(Buffer, 0, ulRet);
			Status = NtQuerySystemInformation(SystemHandleInformation, Buffer, ulRet, &ulRet);
			if (NT_SUCCESS(Status))
			{
				PSYSTEM_HANDLE_INFORMATION Handles = (PSYSTEM_HANDLE_INFORMATION)Buffer;
				ULONG i = 0;
				for (i = 0; i < Handles->NumberOfHandles; i++)
				{
					if (ulPid == Handles->Handles[i].UniqueProcessId)
					{
						if (ulCount > OutHandles->ulCount)
						{
							HsInsertHandleToList((PEPROCESS)EProcess, 
								(HANDLE)Handles->Handles[i].HandleValue, 
								(ULONG_PTR)Handles->Handles[i].Object, 
								OutHandles);
						}

						OutHandles->ulCount++;
					}
				}
			}

			ExFreePool(Buffer);
			ulRet *= 2;
		}
	} while (Status == STATUS_INFO_LENGTH_MISMATCH);

	HsRecoverPreMode(EThread, PreMode);

	if (NT_SUCCESS(Status))
	{
		if (ulCount >= OutHandles->ulCount)
		{
			Status = STATUS_SUCCESS;
		}
		else
		{
			Status = STATUS_BUFFER_TOO_SMALL;
		}
	}

	return Status;
}





VOID HsInsertHandleToList(PEPROCESS EProcess, HANDLE Handle, ULONG_PTR Object, PALL_HANDLES Handles)
{

	BOOLEAN bAttach = FALSE;
	KAPC_STATE as;
	PHANDLE_INFO Buffer = NULL;

	if (Object && 
		MmIsAddressValid((PVOID)Object) && 
		(Buffer = (PHANDLE_INFO)ExAllocatePool(NonPagedPool,sizeof(HANDLE_INFO))) != NULL)
	{
		memset(Buffer,0,sizeof(HANDLE_INFO));


		KeStackAttachProcess(EProcess, &as);
		bAttach = TRUE;


		Buffer->Handle = (ULONG_PTR)Handle;
		Buffer->Object = Object;
		if (MmIsAddressValid((PVOID)(Object - 0x18)))
		{
			Buffer->ReferenceCount = *(ULONG_PTR*)((ULONG_PTR)Object - ObjectHeaderSize);
		}
		else
		{
			Buffer->ReferenceCount = 0;
		}


		HsGetHandleObjectName((HANDLE)Handle,Buffer->HandleName);
		HsGetHandleTypeName((HANDLE)Handle, Object, Buffer->ObjectName);

		if (bAttach)
		{
			KeUnstackDetachProcess(&as);
			bAttach = FALSE;
		}

		memcpy(&Handles->Handles[Handles->ulCount],Buffer,sizeof(HANDLE_INFO));
		ExFreePool(Buffer);
		Buffer = NULL;
	}
}




VOID HsGetHandleObjectName(HANDLE hHandle,WCHAR* wzObjectName)
{
	PVOID HandleName = NULL;

	HandleName = ExAllocatePool(PagedPool,0x1000);
	if (HandleName)
	{
		ULONG uRet= 0;
		PETHREAD EThread = NULL;
		CHAR PreMode = 0;

		memset(HandleName, 0, 0x1000);

		EThread = PsGetCurrentThread();
		PreMode = HsChangePreMode(EThread);

		__try
		{
			if (NT_SUCCESS(NtQueryObjectAddress((HANDLE)hHandle, ObjectNameInfo, HandleName, 0x1000, &uRet)))
			{
				POBJECT_NAME_INFORMATION ObjectNameInformation = (POBJECT_NAME_INFORMATION)HandleName;
				if (ObjectNameInformation->Name.Buffer!=NULL)
				{


					if (HsIsUnicodeStringValid(&ObjectNameInformation->Name))
					{
						wcsncpy(wzObjectName,
							ObjectNameInformation->Name.Buffer,ObjectNameInformation->Name.Length);
					}


				}
			}
		}
		__except(1)
		{
			DbgPrint("GetHandleObjectName Catch __Except\r\n");
		}

		HsRecoverPreMode(EThread, PreMode);
		ExFreePool(HandleName);
	}
}


VOID HsGetHandleTypeName(HANDLE hHandle, ULONG_PTR Object,WCHAR* wzTypeName)
{
	PVOID HandleName = NULL;
	BOOLEAN bOk = FALSE;

	HandleName = ExAllocatePool(PagedPool,0x1000);
	if (HandleName)
	{
		ULONG uRet= 0;
		PETHREAD EThread = NULL;
		CHAR PreMode = 0;

		memset(HandleName, 0, 0x1000);

		EThread = PsGetCurrentThread();
		PreMode = HsChangePreMode(EThread);

		__try
		{
			if (NT_SUCCESS(NtQueryObjectAddress((HANDLE)hHandle, ObjectTypeInfo, HandleName, 0x1000, &uRet)))
			{
				POBJECT_NAME_INFORMATION ObjectNameInformation = (POBJECT_NAME_INFORMATION)HandleName;
				if (ObjectNameInformation->Name.Buffer!=NULL)
				{


					if (HsIsUnicodeStringValid(&ObjectNameInformation->Name))
					{
						wcsncpy(wzTypeName, ObjectNameInformation->Name.Buffer,ObjectNameInformation->Name.Length);
					}		

				}
			}
		}
		__except(1)
		{
			DbgPrint("GetHandleObjectName Catch __Except\r\n");
		}

		HsRecoverPreMode(EThread, PreMode);
		ExFreePool(HandleName);



	}
}




VOID HsInitHandleVariable()
{
	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			PreviousModeOffsetOf_KTHREAD = 0x140;
			ObjectHeaderSize = 0x18;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;
			break;
		}

	case WINDOWS_7:
		{
			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			ObjectHeaderSize = 0x30;
			break;
		}
	}
}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Handle.h`:

```h
#pragma once 



#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"

#include "Process.h"

typedef enum _SYSTEM_INFORMATION_CLASS {    
	SystemBasicInformation,    
	SystemProcessorInformation,    
	SystemPerformanceInformation,    
	SystemTimeOfDayInformation,    
	SystemNotImplemented1,    
	SystemProcessesInformation,    
	SystemCallCounts,    
	SystemConfigurationInformation,    
	SystemProcessorTimes,    
	SystemGlobalFlag,    
	SystemNotImplemented2,    
	SystemModuleInformation,    
	SystemLockInformation,    
	SystemNotImplemented3,    
	SystemNotImplemented4,    
	SystemNotImplemented5,    
	SystemHandleInformation, //枚举系统中的全部句柄 
	SystemObjectInformation,    
	SystemPagefileInformation,    
	SystemInstructionEmulationCounts,    
	SystemInvalidInfoClass1,    
	SystemCacheInformation,    
	SystemPoolTagInformation,    
	SystemProcessorStatistics,    
	SystemDpcInformation,    
	SystemNotImplemented6,    
	SystemLoadImage,    
	SystemUnloadImage,    
	SystemTimeAdjustment,    
	SystemNotImplemented7,    
	SystemNotImplemented8,    
	SystemNotImplemented9,    
	SystemCrashDumpInformation,    
	SystemExceptionInformation,    
	SystemCrashDumpStateInformation,    
	SystemKernelDebuggerInformation,    
	SystemContextSwitchInformation,    
	SystemRegistryQuotaInformation,    
	SystemLoadAndCallImage,    
	SystemPrioritySeparation,    
	SystemNotImplemented10,    
	SystemNotImplemented11,    
	SystemInvalidInfoClass2,    
	SystemInvalidInfoClass3,    
	SystemTimeZoneInformation,    
	SystemLookasideInformation,    
	SystemSetTimeSlipEvent,    
	SystemCreateSession,    
	SystemDeleteSession,    
	SystemInvalidInfoClass4,    
	SystemRangeStartInformation,    
	SystemVerifierInformation,    
	SystemAddVerifier,    
	SystemSessionProcessesInformation    
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;


typedef enum _OBJECT_INFO_CLASS {
	ObjectBasicInfo,
	ObjectNameInfo,
	ObjectTypeInfo,
	ObjectAllInfo,
	ObjectDataInfo
} OBJECT_INFO_CLASS, *POBJECT_INFO_CLASS;


#define MAX_OBJECT_NAME  50
#define MAX_PATH         500


typedef struct _HANDLE_INFO_
{
	ULONG_PTR Handle;
	ULONG_PTR Object;
	ULONG_PTR ReferenceCount;
	WCHAR ObjectName[MAX_OBJECT_NAME];
	WCHAR HandleName[MAX_PATH];
}HANDLE_INFO, *PHANDLE_INFO;

typedef struct _PROCESS_HANDLES_
{
	ULONG_PTR ulCount;
	HANDLE_INFO Handles[1];
}ALL_HANDLES, *PALL_HANDLES;




typedef
	NTSTATUS (NTAPI *pfnNtQueryObject)(HANDLE Handle,OBJECT_INFORMATION_CLASS ObjectInformationClass,
	PVOID ObjectInformation,
	ULONG ObjectInformationLength,
	PULONG ReturnLength);




NTSTATUS HsEnumProcessHandle(PVOID InBuffer, ULONG_PTR InSize, PVOID OutBuffer, ULONG_PTR OutSize);
NTSTATUS HsGetHandles(ULONG_PTR ulPid, ULONG_PTR EProcess, PALL_HANDLES OutHandles, ULONG_PTR ulCount);
VOID HsInsertHandleToList(PEPROCESS EProcess, HANDLE Handle, ULONG_PTR Object, PALL_HANDLES Handles);
VOID HsGetHandleObjectName(HANDLE hHandle,WCHAR* wzObjectName);
VOID HsGetHandleTypeName(HANDLE hHandle, ULONG_PTR Object,WCHAR* wzTypeName);
VOID HsInitHandleVariable();

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(PVOID Base);


extern 
	NTSTATUS 
	NtQuerySystemInformation(   
	IN ULONG SystemInformationClass,   
	IN PVOID SystemInformation,   
	IN ULONG SystemInformationLength,   
	OUT PULONG ReturnLength);

typedef 
ULONG_PTR 
(*pfnObGetObjectType)(PVOID pObject);





NTSTATUS 
	MapFileInUserSpace(IN LPWSTR lpszFileName,IN HANDLE ProcessHandle OPTIONAL,
	OUT PVOID *BaseAddress,
	OUT PSIZE_T ViewSize OPTIONAL);



```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/HeavenShadowDrv.c`:

```c
/***************************************************************************************
* AUTHOR : HeavenShadow
* DATE   : 2014-10-28
* MODULE : HeavenShadowDrv.C
* 
* Command: 
*	
*
* Description:
*		Demonstrates communications between USER and KERNEL.
*
****************************************************************************************
* Copyright (C) 2014 HeavenShadow.
****************************************************************************************/


#ifndef _HeavenShadowDrv_H
# include "HeavenShadowDrv.h"
#endif

#include "Process.h"
#include "Module.h"
#include "Kernel.h"
#include "System.h"

PDEVICE_OBJECT g_DeviceObject;
PDRIVER_OBJECT g_DriverObject;

WIN_VERSION  WinVersion = WINDOWS_UNKNOW;

PEPROCESS    SystemEProcess = NULL;

//////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegisterPath)
{
	ULONG i = 0;
	
	NTSTATUS Status;
	UNICODE_STRING DeviceName;
	UNICODE_STRING LinkName;
	PDEVICE_OBJECT DeviceObject;


	WinVersion =  HsGetWindowsVersion();

	//派遣历程
	for (i=0;i<IRP_MJ_MAXIMUM_FUNCTION;i++)
	{
		DriverObject->MajorFunction[i] = HsDispatchPass;
	}

	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = HsDispatchControl;

	DriverObject->DriverUnload = HsDriverUnload;

	//创建一个UniCode 名字的控制设备对象使用

	RtlInitUnicodeString(&DeviceName,HS_DEVICE_NAME);

	//创建一个控制设备对象 与应用层进行交互



	Status = IoCreateDevice(DriverObject,(ULONG)NULL,&DeviceName,
		FILE_DEVICE_UNKNOWN,0,FALSE,&DeviceObject);


	if (!NT_SUCCESS(Status))
	{
		return STATUS_SUCCESS;
	}



	//创建关联

	RtlInitUnicodeString(&LinkName,HS_LINK_NAME);


	Status = IoCreateSymbolicLink(&LinkName,&DeviceName);

	if (!NT_SUCCESS(Status))
	{
		IoDeleteDevice(DeviceObject);
		return STATUS_UNSUCCESSFUL;
	}

	g_DeviceObject = DeviceObject;
	g_DriverObject = DriverObject;

	SystemEProcess = PsGetCurrentProcess();


	return STATUS_SUCCESS;
}

VOID
HsDriverUnload(IN PDRIVER_OBJECT DriverObject)
{	
	UNICODE_STRING  uniLinkName;

	RtlInitUnicodeString(&uniLinkName,HS_LINK_NAME);

	IoDeleteSymbolicLink(&uniLinkName);

	if (DriverObject->DeviceObject!=NULL)
	{
		IoDeleteDevice(DriverObject->DeviceObject);
	}

	return;
}

NTSTATUS 
HsDispatchControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PIO_STACK_LOCATION  IrpSp;
	ULONG				ulIoControlCode  = 0;
	NTSTATUS			Status = STATUS_UNSUCCESSFUL;
	ULONG_PTR			ulRet = 0;
	PVOID               pvInputBuffer  = NULL;
	PVOID               pvOutputBuffer = NULL;
	ULONG_PTR			ulOutputLen    = 0;


	//////////////////////////////////////////////////////////////////////////
	ULONG  ulIoControlFunc = 0;	   //HS_IOCTL_编码
	//////////////////////////////////////////////////////////////////////////


	IrpSp = IoGetCurrentIrpStackLocation(Irp);

	pvOutputBuffer = Irp->UserBuffer;	//UserBuffer
	ulOutputLen    = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
	ProbeForWrite(pvOutputBuffer,ulOutputLen,sizeof(CHAR));

	ulRet = ulOutputLen;

	DbgPrint("Hello HeavenShadow!\r\n");

	ulIoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

	ulIoControlFunc = (ulIoControlCode>>2)&0x00000FFF&0xF80;
	DbgPrint("Major Func Code: %x\r\n",ulIoControlFunc);

	switch(ulIoControlFunc) //判断的是H_IOCTL_编码（自定义枚举）而不是传入的CTL_CODE
	{
	case HS_IOCTL_PROC:		//进程大功能
		{
			Status = HsDispatchControlForProcess(IrpSp, pvOutputBuffer, &ulRet);
			break;
		}
	case HS_IOCTL_MODU:		//模块大功能
		{
			Status = HsDispatchControlForModule(IrpSp, pvOutputBuffer, &ulRet);
			break;
		}
	case HS_IOCTL_KRNL:		//内核钩子大功能
		{
			Status = HsDispatchControlForKernel(IrpSp, pvOutputBuffer, &ulRet);
			break;
		}
	case HS_IOCTL_SYSK:		//内核大功能
		{
			Status = HsDispatchControlForSystem(IrpSp, pvOutputBuffer, &ulRet);
			break;
		}
	default:				//错误请求
		{
			Status = STATUS_UNSUCCESSFUL;
		}
	}


	
	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = ulRet;
	IoCompleteRequest(Irp,IO_NO_INCREMENT);

	return Status;
}



NTSTATUS
HsDispatchPass(PDEVICE_OBJECT DeviceObject,PIRP Irp)
{

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp,IO_NO_INCREMENT);

	return STATUS_SUCCESS;

}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/HeavenShadowDrv.h`:

```h
/***************************************************************************************
* AUTHOR : HeavenShadow
* DATE   : 2014-10-28
* MODULE : HeavenShadowDrv.H
*
* 天影 驱动程序主文件
*
* Description:
*		天影 驱动程序主文件
*
****************************************************************************************
* Copyright (C) 2015 HeavenShadow.
****************************************************************************************/


#ifndef _HeavenShadowDrv_H
#define _HeavenShadowDrv_H


#include <ntifs.h>
#include <devioctl.h>
#include "common.h"

#endif	//_HeavenShadowDrv_H


/***************************************************************************************
* NAME:			DriverEntry
*
* DESCRIPTION:	注册派遣例程
*					
* PARAMETERS:		DriverObject					IN		
*						被NT创建用于此驱动的DRIVER_OBJECT的地址
*					RegisterPath					IN		
*						代表了驱动相关的服务注册表项的UNICODE_STRING 	
*
* RETURNS:		NTSTATUS
****************************************************************************************/
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegisterPath);

/***************************************************************************************
* NAME:			HsDriverUnload
*
* DESCRIPTION:	动态卸载入口点的例程
*					
* PARAMETERS:		DriverObject					IN		DRIVER_OBJECT的地址
*
* RETURNS:		None
****************************************************************************************/
VOID HsDriverUnload(IN PDRIVER_OBJECT DriverObject);

/***************************************************************************************
* NAME:			HsDispatchControl
*
* DESCRIPTION:	IRP_MJ_DEVICE_CONTROL的派遣入口点
*					
* PARAMETERS:		DriverObject				IN		DRIVER_OBJECT的地址
*					Irp							IN		IRP的地址
*
* RETURNS:		NTSTATUS
*
* NOTES:			IRP_MJ_DEVICE_CONTROL
*					Parameters:
*					Parameters.DeviceIoControl.OutputBufferLength	OutBuffer的长度
*						字节计 (来自GUI的缓冲区长度)
*					Parameters.DeviceIoControl.InputBufferLength	InBuffer的长度
*						字节计 (来自DRIVER的缓冲区长度)
*					Parameters.DeviceIoControl.ControlCode			I/O 控制码
****************************************************************************************/
NTSTATUS HsDispatchControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);



NTSTATUS
HsDispatchPass(PDEVICE_OBJECT DeviceObject,PIRP Irp);




```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/IoTimer.c`:

```c
#include "IoTimer.h"
#include "Module.h"

extern ULONG_PTR		SYSTEM_ADDRESS_START;
extern PDRIVER_OBJECT	g_DriverObject;
extern WIN_VERSION		WinVersion;

pfnIoStartTimer  IoStartTimerAddress = NULL;
pfnIoStopTimer   IoStopTimerAddress = NULL;


NTSTATUS HsEnumIOTimer(PVOID OutBuffer)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PLIST_ENTRY IopTimerQueueHead = 0;
	PIO_TIMER_INFOR  IoTimerInfor = (PIO_TIMER_INFOR)OutBuffer;

	KIRQL OldIrql;


	IopTimerQueueHead = (PLIST_ENTRY)GetIopTimerQueueHead();
	OldIrql = KeRaiseIrqlToDpcLevel();

	if (IopTimerQueueHead && MmIsAddressValid((PVOID)IopTimerQueueHead))
	{
		PLIST_ENTRY CurrentEntry = IopTimerQueueHead->Flink;

		while (MmIsAddressValid(CurrentEntry) && CurrentEntry != (PLIST_ENTRY)IopTimerQueueHead)
		{
			PIO_TIMER Timer = CONTAINING_RECORD(CurrentEntry,IO_TIMER,TimerList);

			if (Timer && MmIsAddressValid(Timer))
			{

				if (IoTimerInfor->ulCnt > IoTimerInfor->ulRetCnt)
				{
					IoTimerInfor->IoTimer[IoTimerInfor->ulRetCnt].TimerObject = (ULONG_PTR)Timer;

					DbgPrint("%p\r\n",Timer);
					IoTimerInfor->IoTimer[IoTimerInfor->ulRetCnt].TimerEntry = (ULONG_PTR)CurrentEntry;
					IoTimerInfor->IoTimer[IoTimerInfor->ulRetCnt].DeviceObject = (ULONG_PTR)Timer->DeviceObject;
					IoTimerInfor->IoTimer[IoTimerInfor->ulRetCnt].TimeDispatch = (ULONG_PTR)Timer->TimerRoutine;
					IoTimerInfor->IoTimer[IoTimerInfor->ulRetCnt].Status = (ULONG_PTR)Timer->TimerFlag;
				}

				IoTimerInfor->ulRetCnt++;
			}

			CurrentEntry = CurrentEntry->Flink;
		}
	}

	KeLowerIrql(OldIrql);

	return Status;
}




ULONG_PTR GetIopTimerQueueHead()
{
	ULONG_PTR i = 0;
	ULONG_PTR IopTimerQueueHead = 0;
	ULONG_PTR IoInitializeTimer = 0;
	long Temp = 0;


	IoInitializeTimer = (ULONG_PTR)HsGetFunctionAddressByName(L"IoInitializeTimer");

	if (IoInitializeTimer)
	{

		switch(WinVersion)
		{
		case WINDOWS_7:
			{
				/*
				kd> u IoInitializeTimer l 50
				nt!IoInitializeTimer:
				fffff800`0427f3b0 48895c2408      mov     qword ptr [rsp+8],rbx
				fffff800`0427f3b5 48896c2410      mov     qword ptr [rsp+10h],rbp
				fffff800`0427f3ba 4889742418      mov     qword ptr [rsp+18h],rsi
				fffff800`0427f3bf 57              push    rdi
				fffff800`0427f3c0 4883ec20        sub     rsp,20h
				fffff800`0427f3c4 488b5928        mov     rbx,qword ptr [rcx+28h]
				fffff800`0427f3c8 498bf0          mov     rsi,r8
				fffff800`0427f3cb 488bea          mov     rbp,rdx
				fffff800`0427f3ce 488bf9          mov     rdi,rcx
				fffff800`0427f3d1 4885db          test    rbx,rbx
				fffff800`0427f3d4 753f            jne     nt!IoInitializeTimer+0x65 (fffff800`0427f415)
				fffff800`0427f3d6 8d5330          lea     edx,[rbx+30h]
				fffff800`0427f3d9 33c9            xor     ecx,ecx
				fffff800`0427f3db 41b8496f5469    mov     r8d,69546F49h
				fffff800`0427f3e1 e8fa2cd3ff      call    nt!ExAllocatePoolWithTag (fffff800`03fb20e0)
				fffff800`0427f3e6 488bd8          mov     rbx,rax
				fffff800`0427f3e9 4885c0          test    rax,rax
				fffff800`0427f3ec 7507            jne     nt!IoInitializeTimer+0x45 (fffff800`0427f3f5)
				fffff800`0427f3ee b89a0000c0      mov     eax,0C000009Ah
				fffff800`0427f3f3 eb41            jmp     nt!IoInitializeTimer+0x86 (fffff800`0427f436)
				fffff800`0427f3f5 33d2            xor     edx,edx
				fffff800`0427f3f7 488bc8          mov     rcx,rax
				fffff800`0427f3fa 448d4230        lea     r8d,[rdx+30h]
				fffff800`0427f3fe e88da4c0ff      call    nt!memset (fffff800`03e89890)
				fffff800`0427f403 41bb09000000    mov     r11d,9
				fffff800`0427f409 48897b28        mov     qword ptr [rbx+28h],rdi
				fffff800`0427f40d 6644891b        mov     word ptr [rbx],r11w
				fffff800`0427f411 48895f28        mov     qword ptr [rdi+28h],rbx
				fffff800`0427f415 488d5308        lea     rdx,[rbx+8]
				fffff800`0427f419 4c8d0520ade3ff  lea     r8,[nt!IopTimerLock (fffff800`040ba140)]
				fffff800`0427f420 488d0dd94ce0ff  lea     rcx,[nt!IopTimerQueueHead (fffff800`04084100)]

				*/

				for(i=IoInitializeTimer; i<IoInitializeTimer+0xff; i++)
				{
					if(*(PUCHAR)i==0x48 && *(PUCHAR)(i+1)==0x8D && *(PUCHAR)(i+2)==0x0D)	
					{
						memcpy(&Temp,(PUCHAR)i+3,4);
						IopTimerQueueHead = (ULONGLONG)Temp + (ULONGLONG)i + 7;

						break;
					}
				}
				break;
			}

		case WINDOWS_XP:
			{
				/*
				kd> u IoInitializeTimer l 20
				nt!IoInitializeTimer:
				805d3044 8bff            mov     edi,edi
				805d3046 55              push    ebp
				805d3047 8bec            mov     ebp,esp
				805d3049 56              push    esi
				805d304a 8b7508          mov     esi,dword ptr [ebp+8]
				805d304d 8b5618          mov     edx,dword ptr [esi+18h]
				805d3050 85d2            test    edx,edx
				805d3052 752d            jne     nt!IoInitializeTimer+0x40 (805d3081)
				805d3054 68496f5469      push    69546F49h
				805d3059 6a18            push    18h
				805d305b 52              push    edx
				805d305c e8a4eff7ff      call    nt!ExAllocatePoolWithTag (80552005)
				805d3061 8bd0            mov     edx,eax
				805d3063 85d2            test    edx,edx
				805d3065 0f84f4c70100    je      nt!IoInitializeTimer+0x23 (805ef85f)
				805d306b 57              push    edi
				805d306c 6a06            push    6
				805d306e 59              pop     ecx
				805d306f 33c0            xor     eax,eax
				805d3071 8bfa            mov     edi,edx
				805d3073 f3ab            rep stos dword ptr es:[edi]
				805d3075 66c7020900      mov     word ptr [edx],9
				805d307a 897214          mov     dword ptr [edx+14h],esi
				805d307d 895618          mov     dword ptr [esi+18h],edx
				805d3080 5f              pop     edi
				805d3081 8b450c          mov     eax,dword ptr [ebp+0Ch]
				805d3084 89420c          mov     dword ptr [edx+0Ch],eax
				805d3087 8b4510          mov     eax,dword ptr [ebp+10h]
				805d308a 894210          mov     dword ptr [edx+10h],eax
				805d308d 6880a65580      push    offset nt!IopTimerLock (8055a680)
				805d3092 83c204          add     edx,4
				805d3095 b9e01d5680      mov     ecx,offset nt!IopTimerQueueHead (80561de0)



				*/

				for(i=IoInitializeTimer;i<IoInitializeTimer+0xFF;i++)
				{
					if(*(PUCHAR)i==0xb9)	
					{
						IopTimerQueueHead = *(PULONG)(i + 1);
						if (IopTimerQueueHead && MmIsAddressValid((PVOID)IopTimerQueueHead))
						{
							break;
						}
					}
				}
				break;
			}
		}


	}
	
	return IopTimerQueueHead;
}





NTSTATUS HsOperIOTimer(PVOID InBuffer)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PCOMMUNICATE_IO_TIMER IoTimerInfor = (PCOMMUNICATE_IO_TIMER)InBuffer;
	PDEVICE_OBJECT DeviceObject = (PDEVICE_OBJECT)IoTimerInfor->DeviceObject;

	if (!DeviceObject ||
		!MmIsAddressValid(DeviceObject))
	{
		return Status;
	}

	if (IoTimerInfor->bStart)
	{
		IoStartTimerAddress = (pfnIoStartTimer)HsGetFunctionAddressByName(L"IoStartTimer");
		if (IoStartTimerAddress)
		{
			IoStartTimerAddress(DeviceObject);
			Status = STATUS_SUCCESS;
		}
	}
	else 
	{
		IoStopTimerAddress = (pfnIoStopTimer)HsGetFunctionAddressByName(L"IoStopTimer");
		IoStopTimerAddress(DeviceObject);
		Status = STATUS_SUCCESS;
	}

	return Status;
}






NTSTATUS RemoveIOTimer(PVOID InBuffer)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PLIST_ENTRY IopTimerQueueHead = 0;
	KIRQL OldIrql;
	PCOMMUNICATE_IO_TIMER IoTimerInfor = (PCOMMUNICATE_IO_TIMER)InBuffer;
	PLIST_ENTRY  TimerEntry = (PLIST_ENTRY)IoTimerInfor->TimerEntry;



	IopTimerQueueHead = (PLIST_ENTRY)GetIopTimerQueueHead();

	if (!TimerEntry ||
		!MmIsAddressValid(TimerEntry))
	{
		return Status;
	}



	OldIrql = KeRaiseIrqlToDpcLevel();

	if (IopTimerQueueHead && MmIsAddressValid((PVOID)IopTimerQueueHead))
	{
		PLIST_ENTRY Temp = IopTimerQueueHead->Flink;

		while (MmIsAddressValid(Temp) && Temp != IopTimerQueueHead)
		{
			if (Temp == TimerEntry)
			{
				PIO_TIMER Timer = CONTAINING_RECORD(Temp,IO_TIMER, TimerList);
				if (Timer && MmIsAddressValid(Timer))
				{
					RemoveEntryList(Temp);
					ExFreePoolWithTag(Timer,0);
					Status = STATUS_SUCCESS;
				}

				break;
			}

			Temp = Temp->Flink;
		}
	}

	KeLowerIrql(OldIrql);

	return Status;
}

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/IoTimer.h`:

```h
#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"

typedef struct _IO_TIMER64
{
	short		Type;
	short		TimerFlag;
	long		Unknown;
	LIST_ENTRY	TimerList;
	PVOID		TimerRoutine;
	PVOID		Context;
	PVOID		DeviceObject;
} IO_TIMER64,*PIO_TIMER64;


typedef struct _IO_TIMER32
{
	short		Type;
	short		TimerFlag;
	LIST_ENTRY	TimerList;
	PVOID		TimerRoutine;
	PVOID		Context;
	PVOID		DeviceObject;
} IO_TIMER32,*PIO_TIMER32;

#ifdef _WIN64
#define PIO_TIMER PIO_TIMER64
#define IO_TIMER  IO_TIMER64
#else
#define PIO_TIMER PIO_TIMER32
#define IO_TIMER  IO_TIMER32
#endif


typedef struct _IO_TIMERS_
{
	ULONG_PTR TimerObject;
	ULONG_PTR DeviceObject;
	ULONG_PTR TimeDispatch;
	ULONG_PTR TimerEntry;
	ULONG     Status;
}IO_TIMERS, *PIO_TIMERS;

typedef struct _IO_TIMER_INFOR_
{
	ULONG ulCnt;
	ULONG ulRetCnt;
	IO_TIMERS IoTimer[1];
}IO_TIMER_INFOR, *PIO_TIMER_INFOR;



typedef struct _PCOMMUNICATE_IO_TIMER_  
{
	PLIST_ENTRY     TimerEntry;
	PDEVICE_OBJECT  DeviceObject;
	BOOLEAN         bStart;
}COMMUNICATE_IO_TIMER,*PCOMMUNICATE_IO_TIMER;
typedef
	NTKERNELAPI
	VOID
	(*pfnIoStartTimer)(
	IN PDEVICE_OBJECT DeviceObject);

typedef
	NTKERNELAPI
	VOID
	(*pfnIoStopTimer)(
	IN PDEVICE_OBJECT DeviceObject);



NTSTATUS HsEnumIOTimer(PVOID OutBuffer);

ULONG_PTR GetIopTimerQueueHead();

NTSTATUS HsOperIOTimer(PVOID InBuffer);

NTSTATUS RemoveIOTimer(PVOID InBuffer);















```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Kernel.c`:

```c
#include "Kernel.h"
#include "KrnlFile.h"

#include "GetFuncAddress.h"
//////////////////////////////////////////////////////////////////////////
extern     PDEVICE_OBJECT g_DeviceObject;
extern     PDRIVER_OBJECT g_DriverObject;
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
extern POBJECT_TYPE *IoDriverObjectType;
extern POBJECT_TYPE *IoDeviceObjectType;
//////////////////////////////////////////////////////////////////////////

extern
	WIN_VERSION WinVersion;
extern
	ULONG_PTR PreviousModeOffsetOf_KTHREAD;
extern
	ULONG_PTR ObjectTableOffsetOf_EPROCESS;
extern
	ULONG_PTR SYSTEM_ADDRESS_START;
extern
	ULONG_PTR ObjectHeaderSize;
extern
	ULONG_PTR ObjectTypeOffsetOf_Object_Header;


extern ULONG_PTR
	ulBuildNumber;
//////////////////////////////////////////////////////////////////////////

ULONG_PTR KiServiceTable = 0;
KIRQL Irql;

NTSTATUS HsDispatchControlForKernel(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet)
{

	WCHAR* szOutputBuffer = (WCHAR*)OutputBuffer;
	ULONG				ulIoControlCode  = 0;
	NTSTATUS			Status = STATUS_UNSUCCESSFUL;
	PVOID               pvInputBuffer  = NULL;
	ULONG               ulInputLen     = 0;
	ULONG				ulOutputLen    = 0;


	ULONG     ulFuncIndex = 0;
	ULONG_PTR ulFuncAddr  = 0;
	ULONG_PTR IndexOffset = 0;


	pvInputBuffer   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
	ulInputLen      = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	ProbeForRead(pvInputBuffer,ulInputLen,sizeof(CHAR));

	ulOutputLen     = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	ProbeForWrite(OutputBuffer,ulOutputLen,sizeof(CHAR));

	ulIoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	ulIoControlCode = (ulIoControlCode>>2)&0x00000FFF;

	DbgPrint("%x\r\n",ulIoControlCode);

	HsInitKernelGlobalVariable();

	switch(ulIoControlCode)
	{
	case HS_IOCTL_KRNL_KISRVTAB:
		{
			DbgPrint("HS_IOCTL_KRNL_KISRVTAB\r\n");

			switch(WinVersion)
			{
			case WINDOWS_7:
				{
					KiServiceTable = *((ULONG_PTR*)GetKeServiceDescriptorTable64());
					break;
				}
			case WINDOWS_XP:
				{
					KiServiceTable = *((ULONG_PTR*)HsGetFunctionAddressByName(L"KeServiceDescriptorTable"));
					break;
				}

			}

			memcpy(OutputBuffer, &KiServiceTable,sizeof(KiServiceTable));	
			*ulRet = sizeof(ULONG_PTR);
			Status = STATUS_SUCCESS;

			break;
		}
	case HS_IOCTL_KRNL_SSDTLIST:
		{
			ULONG_PTR SSDTDescriptor = 0;

			DbgPrint("HS_IOCTL_KRNL_SSDTLIST\r\n");

			memcpy(&ulFuncIndex, pvInputBuffer,sizeof(ULONG));
			switch(WinVersion)
			{
			case WINDOWS_7:
				{
					SSDTDescriptor = GetKeServiceDescriptorTable64();
					IndexOffset = 4;

					break;
				}

			case WINDOWS_XP:
				{
					SSDTDescriptor = (ULONG_PTR)HsGetFunctionAddressByName(L"KeServiceDescriptorTable");
					IndexOffset = 1;

					break;
				}
			}

			ulFuncAddr =  GetSSDTApiFunAddress(ulFuncIndex,SSDTDescriptor);

			DbgPrint("%p\r\n",ulFuncAddr);

			memcpy(OutputBuffer, &ulFuncAddr,sizeof(ULONG_PTR));
			*ulRet = sizeof(ULONG_PTR);
			Status = STATUS_SUCCESS;

			break;
		}

	case HS_IOCTL_KRNL_WIN32KSERVICE:
		{
			DbgPrint("HS_IOCTL_KRNL_WIN32KSERVICE\r\n");

			switch(WinVersion)
			{
			case WINDOWS_7:
				{
					KiServiceTable = GetKeServiceDescriptorTableShadow64();

					KiServiceTable = (ULONG_PTR)((PSYSTEM_SERVICE_TABLE64)KiServiceTable)->ServiceTableBase;
					break;
				}

			case WINDOWS_XP:
				{
					KiServiceTable = GetKeServiceDescriptorTableShadow32();

					KiServiceTable = (ULONG_PTR)((PSYSTEM_SERVICE_TABLE32)KiServiceTable)->ServiceTableBase;
					break;
				}
			}
			memcpy(OutputBuffer, &KiServiceTable,sizeof(KiServiceTable));	

			*ulRet = sizeof(ULONG_PTR);
			Status = STATUS_SUCCESS;
			break;
		}
	case HS_IOCTL_KRNL_RESUMESSDT:
		{
			RESUME_DATA  Data = {0};

			DbgPrint("HS_IOCTL_KRNL_RESUMESSDT\r\n");

			memcpy(&Data, pvInputBuffer,sizeof(Data));

			HsUnHookSSDT(Data.ulIndex,Data.ulFuncAddress);

			*ulRet = sizeof(ULONG_PTR);
			Status = STATUS_SUCCESS;
			break;
		}
	case HS_IOCTL_KRNL_SSSDTLIST:
		{
			ULONG_PTR SSSDTFuncAddress = 0;

			DbgPrint("HS_IOCTL_KRNL_WIN32KSERVICE\r\n");

			memcpy(&ulFuncIndex,pvInputBuffer,4);
			switch(WinVersion)
			{
			case WINDOWS_7:
				{

					KiServiceTable = GetKeServiceDescriptorTableShadow64();

					KiServiceTable = (ULONG_PTR)((PSYSTEM_SERVICE_TABLE64)KiServiceTable)->ServiceTableBase;

					SSSDTFuncAddress = GetSSSDTFunctionAddress64(ulFuncIndex,KiServiceTable);

					break;
				}

			case WINDOWS_XP:
				{
					KiServiceTable = GetKeServiceDescriptorTableShadow32();

					KiServiceTable = (ULONG_PTR)((PSYSTEM_SERVICE_TABLE32)KiServiceTable)->ServiceTableBase;

					SSSDTFuncAddress = GetSSSDTFunctionAddress32(ulFuncIndex,KiServiceTable);
					break;
				}
			}


			memcpy(OutputBuffer, &SSSDTFuncAddress,sizeof(SSSDTFuncAddress));	

			*ulRet = sizeof(ULONG_PTR);
			Status = STATUS_SUCCESS;
			break;
		}

	case HS_IOCTL_KRNL_KRNLFILE:
		{
			DbgPrint("HS_IOCTL_KRNL_KRNLFILE\r\n");

			Status = HsEnumKernelFileFunc(*(int*)pvInputBuffer,OutputBuffer,ulOutputLen);
			*ulRet = sizeof(ULONG_PTR);
			break;
		}
	case HS_IOCTL_KRNL_KRNLIAT:
		{
			DbgPrint("HS_IOCTL_KRNL_KRNLIAT\r\n");
			DbgPrint("EAT: %s\r\n",pvInputBuffer);

			Status = HsQueryKernelFileFuncIAT(OutputBuffer,ulOutputLen,(char*)pvInputBuffer);
			
			*ulRet = sizeof(ULONG_PTR);
			break;
		}
	case HS_IOCTL_KRNL_KRNLEAT:
		{
			DbgPrint("HS_IOCTL_KRNL_KRNLEAT\r\n");
			DbgPrint("EAT: %s\r\n",pvInputBuffer);

			Status = HsQueryKernelFileFuncEAT(OutputBuffer,ulOutputLen,(char*)pvInputBuffer);

			*ulRet = sizeof(ULONG_PTR);
			break;
		}
	default:
		{
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	return Status;
}



VOID HsInitKernelGlobalVariable()
{
	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			PreviousModeOffsetOf_KTHREAD = 0x140;
			ObjectHeaderSize = 0x18;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;
			SYSTEM_ADDRESS_START = 0x80000000;
			break;
		}

	case WINDOWS_7:
		{
			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			ObjectHeaderSize = 0x30;
			SYSTEM_ADDRESS_START = 0x80000000000;
			break;
		}
	}
}



ULONG_PTR GetKeServiceDescriptorTableShadow64()
{
	PUCHAR StartSearchAddress = (PUCHAR)__readmsr(0xC0000082);
	PUCHAR EndSearchAddress = StartSearchAddress + 0x500;
	PUCHAR i = NULL;
	UCHAR b1=0,b2=0,b3=0;
	ULONG_PTR Temp = 0;
	ULONG_PTR Address = 0;
	for(i=StartSearchAddress;i<EndSearchAddress;i++)
	{
		if( MmIsAddressValid(i) && MmIsAddressValid(i+1) && MmIsAddressValid(i+2) )
		{
			b1=*i;
			b2=*(i+1);
			b3=*(i+2);
			if( b1==0x4c && b2==0x8d && b3==0x1d ) //4C8D1D
			{
				memcpy(&Temp,i+3,4);
				Address = (ULONG_PTR)Temp + (ULONG_PTR)i + 7;



				Address+=32;

				return Address;
			}
		}
	}
	return 0;
}

ULONG_PTR GetSSSDTFunctionAddress32(ULONG_PTR ulIndex,ULONG_PTR ServiceTableBase)
{

	return (ULONG_PTR)(((ULONG*)ServiceTableBase)[(ULONG)ulIndex]);
}


ULONG_PTR GetSSSDTFunctionAddress64(ULONG_PTR ulIndex,ULONG_PTR ServiceTableBase)
{
	LONG dwTemp=0;
	ULONG_PTR qwTemp=0;
	ULONG_PTR FuncAddress =0;
	qwTemp = ServiceTableBase + 4 * (ulIndex);
	dwTemp = *(PLONG)qwTemp;
	dwTemp = dwTemp>>4;
	FuncAddress = ServiceTableBase + (ULONG_PTR)dwTemp;
	return FuncAddress;
}



ULONG_PTR GetKeServiceDescriptorTableShadow32()
{
	WCHAR szKeAddSystemServiceTable[] = L"KeAddSystemServiceTable";
	ULONG_PTR KeAddSystemServiceTableAddress = NULL;
	ULONG_PTR Temp = 0;
	ULONG_PTR Address = 0;
	int i = 0;
	PUCHAR StartSearchAddress;
	KeAddSystemServiceTableAddress = (ULONG_PTR)HsGetFunctionAddressByName(szKeAddSystemServiceTable);

	if (KeAddSystemServiceTableAddress==NULL)
	{
		return 0;
	}


	for (StartSearchAddress = (PUCHAR)KeAddSystemServiceTableAddress; 
			StartSearchAddress < (PUCHAR)KeAddSystemServiceTableAddress + PAGE_SIZE; 
			StartSearchAddress++)
		{
			if (ulBuildNumber < 8000)
			{
			
				if (*(unsigned short*)StartSearchAddress == 0x888d)
				{
					Temp = *(ULONG_PTR*)(StartSearchAddress+2);
			
					Address = Temp + 16;
				
				
					/*
					kd> dd 80553f60
					80553f60  80502b8c 00000000 0000011c 80503000    SSDT
					80553f70  bf999b80 00000000 0000029b bf99a890    ShadowSSDT  所以要加16
					80553f80  00000000 00000000 00000000 00000000
					80553f90  00000000 00000000 00000000 00000000
					80553fa0  80502b8c 00000000 0000011c 80503000
					80553fb0  00000000 00000000 00000000 00000000
					80553fc0  00000000 00000000 00000000 00000000
					80553fd0  00000000 00000000 00000000 00000000
					*/
					break;
				}
			}

			//其他版本
			else if (ulBuildNumber>=8000)
			{
				if (*(unsigned short*)StartSearchAddress==0xb983)
				{
					i++;
					if (i==1)
					{
					}

					if (i==2)
					{
						Temp = *(ULONG_PTR*)(StartSearchAddress+2);

						Address = Temp + 16;
						break;
					}
				}
			}
		}



	return Address;

}


ULONG GetOffsetAddress(ULONG_PTR FuncAddr)
{
	ULONG dwTemp=0;
	dwTemp= (ULONG)(FuncAddr-(ULONG_PTR)KiServiceTable);
	return dwTemp<<4;
}


VOID HsUnHookSSDT(ULONG Index, ULONG_PTR FuncAddr)
{
	ULONG dwTemp;
	PULONG ServiceTableBase=NULL;

	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			dwTemp=GetOffsetAddress(FuncAddr);
			ServiceTableBase=(PULONG)KiServiceTable;
			WPOFF();
			ServiceTableBase[Index]=dwTemp;
			WPON();

			break;
		}

	case WINDOWS_XP:
		{
			ServiceTableBase=(PULONG)KiServiceTable;
			WPOFF();
			ServiceTableBase[Index]=FuncAddr;
			WPON();

			break;
		}
	}

}


VOID WPOFF()
{
	ULONG_PTR cr0 = 0;
	Irql = KeRaiseIrqlToDpcLevel();
	cr0 =__readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);
	//_disable();                      //这句话 屏蔽也没有啥

}

VOID WPON()
{

	ULONG_PTR cr0=__readcr0();
	cr0 |= 0x10000;
	//_enable();                      //这句话 屏蔽也没有啥
	__writecr0(cr0);
	KeLowerIrql(Irql);
}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Kernel.h`:

```h
/**************************************************************************************
* AUTHOR : HeavenShadow
* DATE   : 2014-10-28
* MODULE : Kernel.h
*
* Command: 
*	内核钩子大功能的主文件
*
* Description:
*	与内核钩子相关的所有功能集合文件
*
****************************************************************************************
* Copyright (C) 2015 HeavenShadow.
****************************************************************************************/


#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"

typedef struct _RESUME_DATA_ 
{
	ULONG ulIndex;
	ULONG_PTR ulFuncAddress;
}RESUME_DATA,*PRESUME_DATA;

#define MAX_PATH 260


NTSTATUS HsDispatchControlForKernel(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet);

VOID HsInitKernelGlobalVariable();

ULONG_PTR GetKeServiceDescriptorTableShadow64();

ULONG_PTR GetSSSDTFunctionAddress64(ULONG_PTR ulIndex,ULONG_PTR ServiceTableBase);

ULONG_PTR GetKeServiceDescriptorTableShadow32();

ULONG_PTR GetSSSDTFunctionAddress32(ULONG_PTR ulIndex,ULONG_PTR ServiceTableBase);

VOID HsUnHookSSDT(ULONG Index, ULONG_PTR FuncAddr);

ULONG GetOffsetAddress(ULONG_PTR FuncAddr);

VOID WPOFF();

VOID WPON();
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/KrnlFile.c`:

```c
#include "KrnlFile.h"

#include <stdlib.h>


FILE_INFOR	 FileInfor;
char szModuleFileFullName[256] = {0};
ULONG_PTR  ulKernelBase = 0;
ULONG_PTR  ulKernelSize = 0;

PSYSTEM_MODULE_INFORMATION ModuleInforBuffer = NULL;
ULONG_PTR ModuleInforNeedSize = 0;
PFILE_INFOR PFileInfor = NULL;

NTSTATUS HsEnumKernelFileFunc(int KernelFile, PVOID OutputBuffer, ULONG_PTR ulOutputLen)
{
	NTSTATUS Status = STATUS_SUCCESS;

	switch(KernelFile)
	{
	case HS_KERNEL_KERNELFILE_NTOSKRNL_IAT:
		{
			DbgPrint("HS_KERNEL_KERNELFILE_NTOSKRNL_IAT:%d\r\n",ulOutputLen);
			Status = HsQueryKernelFileFuncIAT(OutputBuffer,ulOutputLen,"ntoskrnl.exe");
			break;
		}
	case HS_KERNEL_KERNELFILE_NTOSKRNL_EAT:
		{
			DbgPrint("HS_KERNEL_KERNELFILE_NTOSKRNL_EAT\r\n");
			Status = HsQueryKernelFileFuncEAT(OutputBuffer,ulOutputLen,"ntoskrnl.exe");
			break;
		}
	case HS_KERNEL_KERNELFILE_WIN32K_IAT:
		{
			DbgPrint("HS_KERNEL_KERNELFILE_WIN32K_IAT\r\n");
			Status = HsQueryKernelFileFuncIAT(OutputBuffer,ulOutputLen,"win32k.sys");
			break;
		}
	case HS_KERNEL_KERNELFILE_WIN32K_EAT:
		{
			DbgPrint("HS_KERNEL_KERNELFILE_WIN32K_EAT\r\n");
			Status = HsQueryKernelFileFuncEAT(OutputBuffer,ulOutputLen,"win32k.sys");
			break;
		}
	case HS_KERNEL_KERNELFILE_HALDLL_IAT:
		{
			DbgPrint("HS_KERNEL_KERNELFILE_HALDLL_IAT\r\n");
			Status = HsQueryKernelFileFuncIAT(OutputBuffer,ulOutputLen,"hal.dll");
			break;
		}
	case HS_KERNEL_KERNELFILE_HALDLL_EAT:
		{
			DbgPrint("HS_KERNEL_KERNELFILE_HALDLL_EAT\r\n");
			Status = HsQueryKernelFileFuncEAT(OutputBuffer,ulOutputLen,"hal.dll");
			break;
		}
	default:
		{
			DbgPrint("HS_KERNEL_KERNELFILE_UNKNOWN\r\n");
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	return Status;
}



//////////////////////////////////////////////////////////////////////////

NTSTATUS HsQueryKernelFileFuncIAT(PVOID OutputBuffer, ULONG_PTR ulOutputLen, char* szModuleFile)
{

	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	SYSTEM_MODULE_INFORMATION_ENTRY  Temp;
	BOOLEAN bRet = FALSE;

	DbgPrint("GetModuleInforNtoskrnl now:::\r\n");

	if (GetModuleInforKernelFile(&ulKernelBase,&ulKernelSize,szModuleFileFullName,szModuleFile))
	{
		DbgPrint("GetModuleInforNtoskrnl success\r\n");
	}
	FileInfor.BaseAddress = (PVOID)ulKernelBase;
	FileInfor.Size = ulKernelSize;

// 	if (GetModuleInfor(szModuleFile,szModuleFileFullName,&Temp))
// 	{
// 		DbgPrint("GetModuleInforNtoskrnl success\r\n");
// 	}
// 	FileInfor.BaseAddress = (PVOID)Temp.Base;
// 	FileInfor.Size = Temp.Size;

	strcpy(FileInfor.szFileFullName,szModuleFileFullName);
	ReadFileData(&FileInfor);

	Status = HsEnumIATTable((PMODULE_IAT)OutputBuffer,ulOutputLen);

	if (FileInfor.szFileData!=NULL)
	{
		ExFreePool(FileInfor.szFileData);
	}

	Status = STATUS_SUCCESS;

	return Status;
}

NTSTATUS HsEnumIATTable(PMODULE_IAT OutBuffer, ULONG_PTR OutSize)
{

	NTSTATUS						 Status = STATUS_UNSUCCESSFUL;
	ULONG_PTR                        NeedSize = 0;
	PSYSTEM_MODULE_INFORMATION       Buffer = NULL;
	ULONG_PTR                        KernelModuleCount = 0;
	PIMAGE_IMPORT_DESCRIPTOR	     ImportTable = NULL;
	ULONG_PTR                        ImportSize  = 0;
	ULONG_PTR                        ImportDiff  = 0;

	PIMAGE_THUNK_DATA				 ImportFirstThunk  = NULL;
	ULONG_PTR						 IATSize     = 0;
	ULONG_PTR						 IATDiff     = 0;

	PSYSTEM_MODULE_INFORMATION       ModuleInfor = NULL;
	char                             szIATOriImageFile[60] = {0};
	PFILE_INFOR                      ModuleFile = NULL;
	ULONG_PTR                        OriginalFuncAddress      = 0;

	PIMAGE_IMPORT_DESCRIPTOR		 ImportDescArray[64];
	ULONG_PTR						 ImportDescIndex = 0;
	char*                            ImportModuleName         = NULL;
	ULONG_PTR                        Max = 0;
	PIMAGE_THUNK_DATA                ImportOriFirstThunk      = NULL;
	PIMAGE_IMPORT_BY_NAME            OrdinalName              = NULL;
	ULONG                            x = 0;
	ULONG_PTR                        ulCount = (OutSize - sizeof(MODULE_IAT)) / sizeof(IAT_INFO);

	if(FileInfor.BaseAddress!=0)
	{
		ImportTable = (PIMAGE_IMPORT_DESCRIPTOR)GetDirectoryAddr((PUCHAR)FileInfor.szFileData, 
			IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportSize, &ImportDiff, TRUE);	//文件内容

		ImportFirstThunk = (PIMAGE_THUNK_DATA)GetDirectoryAddr((PUCHAR)FileInfor.BaseAddress, 
			IMAGE_DIRECTORY_ENTRY_IAT, &IATSize, &IATDiff, FALSE);			//内存内容

		if (IATSize/sizeof(ULONG)> ulCount)
		{
			OutBuffer->ulCount = IATSize/sizeof(ULONG);

			Status = STATUS_BUFFER_TOO_SMALL;

			goto Exit;
		}

		if(!ImportFirstThunk || !ImportTable)
		{
			goto Exit;
		}

		while (ImportTable->Name)  //导入模块不为空  从自己的内存中获得所有的模块
		{
			ImportDescArray[ImportDescIndex] = ImportTable;

			ImportDescIndex++;
			ImportTable++;
		}

		if (ImportDescIndex==0)
		{
			goto Exit;  //该模块没有任何的导入模块
		}

		Max = ImportDescIndex;
		ImportDescIndex = 0;
		ImportTable = ImportDescArray[ImportDescIndex];
		ImportDescIndex++;

		ImportModuleName = MakePtr(char*,FileInfor.szFileData,ImportTable->Name - ImportDiff);  //文件内容

		if (!ImportModuleName)
		{
			goto Exit;
		}

		ImportOriFirstThunk = MakePtr(PIMAGE_THUNK_DATA,FileInfor.szFileData,
			ImportTable->OriginalFirstThunk - ImportDiff);//文件内容

		//通过导入的模块名找到导入模块

		while (ImportOriFirstThunk && ImportModuleName && //导入模块的函数名称  导入的模块名称 
			IATSize && ImportFirstThunk->u1.Function) 
		{

			if (_stricmp(szIATOriImageFile,ImportModuleName)!=0)
			{
				if (ModuleFile!=NULL && ModuleFile->szFileData != NULL && MmIsAddressValid(ModuleFile->szFileData))
				{
					DbgPrint("ExFreePool(ModuleFile->szFileData)\r\n");
					ExFreePool(ModuleFile->szFileData);
				}
				ModuleFile = CreateFileData(NULL,ImportModuleName);
				if (ModuleFile == NULL)
				{
					DbgPrint("CreateFileData Failed\r\n");
					goto Exit;
				}

				memset(szIATOriImageFile,0,60);
				strcpy(szIATOriImageFile,ImportModuleName);
			}

			strcpy(OutBuffer->Data[x].szModuleName,ImportModuleName);

			OrdinalName   = MakePtr(PIMAGE_IMPORT_BY_NAME, 
				FileInfor.szFileData, 
				(ULONG_PTR)ImportOriFirstThunk->u1.AddressOfData - ImportDiff);  //通过Original(文件)获得函数名称

			//DbgPrint("函数名称:%s   函数地址:0x%p\r\n",OrdinalName->Name,ImportFirstThunk->u1.Function);  //从First(内存)中获得函数地址

			if(GetAddrOfExportFuncAddr((PUCHAR)ModuleFile->szFileData,(CHAR*)OrdinalName->Name, &OriginalFuncAddress, 
				TRUE))//从导入的模块中获得函数地址
			{
				OriginalFuncAddress += (ULONG_PTR)ModuleFile->BaseAddress;
				DbgPrint("ExportFuncAddr: %p\r\n",OriginalFuncAddress);
			}


			strcpy(OutBuffer->Data[x].szFunctionName,(char*)OrdinalName->Name);
			OutBuffer->Data[x].CurFuncAddress = ImportFirstThunk->u1.Function;
			OutBuffer->Data[x].OriFuncAddress = OriginalFuncAddress;

			x++;

			ImportFirstThunk++;
			IATSize   -= sizeof(ULONG);
			ImportOriFirstThunk++;

			if (IATSize==0)
			{
				break;
			}

			if(ImportFirstThunk->u1.Function == 0)  //一个导入模块已经遍历完成
			{
				ImportFirstThunk++; 
				IATSize -= sizeof(ULONG);

				ImportTable = ImportDescArray[ImportDescIndex];  // 从数组中获得下一个导出模块

				if (ImportDescIndex==Max)
				{
					break;
				}

				ImportDescIndex++;

				ImportModuleName = MakePtr(char*,FileInfor.szFileData,ImportTable->Name - ImportDiff);
				ImportOriFirstThunk = MakePtr(PIMAGE_THUNK_DATA,FileInfor.szFileData,
					ImportTable->OriginalFirstThunk - ImportDiff);//文件内容

				if( ImportOriFirstThunk == NULL || 
					ImportModuleName	 == NULL || 
					(PULONG)ImportFirstThunk->u1.Function == NULL || 
					IATSize == 0)
				{
					break;
				}
			}
		}
	}

	OutBuffer->ulCount = x;

	Status = STATUS_SUCCESS;

Exit:

	if (ModuleFile!=NULL && ModuleFile->szFileData != NULL && MmIsAddressValid(ModuleFile->szFileData))
	{
		DbgPrint("ExFreePool(ModuleFile->szFileData)\r\n");
		ExFreePool(ModuleFile->szFileData);
	}

	return Status;
}



//////////////////////////////////////////////////////////////////////////

NTSTATUS HsQueryKernelFileFuncEAT(PVOID OutputBuffer, ULONG_PTR ulOutputLen, char* szModuleFile)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	DbgPrint("GetModuleInforNtoskrnl now:::\r\n");

	if (GetModuleInforKernelFile(&ulKernelBase,&ulKernelSize,szModuleFileFullName,szModuleFile))
	{
		DbgPrint("GetModuleInforNtoskrnl success\r\n");
	}

	Status = HsEnumEATTable((PVOID)ulKernelBase,(PMODULE_EAT)OutputBuffer,ulOutputLen,szModuleFile);

	return Status;
}


NTSTATUS HsEnumEATTable(PVOID  KernelBase,PMODULE_EAT OutBuffer, ULONG_PTR OutSize, char* szModuleFileName)
{
	PIMAGE_DOS_HEADER  DosHeader;
	PIMAGE_NT_HEADERS  NtHeader;
	IMAGE_OPTIONAL_HEADER  OptionHead;
	PIMAGE_EXPORT_DIRECTORY ExportTable;
	ULONG*             ArrayOfFunctionAddress;
	ULONG*             ArrayOfFunctionName;
	short*             ArrayOfFunctionOrdinals;
	ULONG_PTR          Base; 
	ULONG_PTR          x;
	char*              FunctionName;
	ULONG_PTR          FunctionOrdinals;
	ULONG_PTR          FunctionAddress;
	ULONG_PTR          ulCount = (OutSize - sizeof(MODULE_EAT)) / sizeof(EAT_INFO);

	PFILE_INFOR        ModuleFile = NULL;
	ULONG_PTR          OriginalFuncAddress      = 0;

	DosHeader = (PIMAGE_DOS_HEADER)KernelBase;

	if (DosHeader->e_magic!=IMAGE_DOS_SIGNATURE)
	{
		return STATUS_UNSUCCESSFUL;
	}

	NtHeader =  (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

	if (NtHeader->Signature!=IMAGE_NT_SIGNATURE)
	{

		return STATUS_UNSUCCESSFUL;
	}

	//////////////////////////////////////////////////////////////////////////
	ModuleFile = CreateFileData(NULL,szModuleFileName);

	if (ModuleFile == NULL)
	{
		DbgPrint("CreateFileData Failed\r\n");
		return STATUS_UNSUCCESSFUL;
	}
	//////////////////////////////////////////////////////////////////////////

	OptionHead = NtHeader->OptionalHeader;

	ExportTable = (PIMAGE_EXPORT_DIRECTORY)((ULONG_PTR)DosHeader + 
		OptionHead.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);  //获得导出表的RVA


	ArrayOfFunctionAddress = (ULONG*)((ULONG_PTR)DosHeader + ExportTable->AddressOfFunctions);
	ArrayOfFunctionName = (ULONG*)((ULONG_PTR)DosHeader+ExportTable->AddressOfNames);
	ArrayOfFunctionOrdinals = (short*)((ULONG_PTR)DosHeader+ExportTable->AddressOfNameOrdinals);

	Base = ExportTable->Base;


	if (ExportTable->NumberOfFunctions > ulCount)
	{
		OutBuffer->ulCount = ExportTable->NumberOfFunctions ;

		return STATUS_BUFFER_TOO_SMALL;
	}

	for (x=0;x<ExportTable->NumberOfFunctions;x++)
	{
		FunctionName = (char*)((ULONG_PTR)DosHeader+ArrayOfFunctionName[x]);
		FunctionOrdinals = ArrayOfFunctionOrdinals[x] + Base -1;
		FunctionAddress  = (ULONG_PTR)((ULONG_PTR)DosHeader +  
			ArrayOfFunctionAddress[FunctionOrdinals]);

		if(GetAddrOfExportFuncAddr((PUCHAR)ModuleFile->szFileData,(CHAR*)FunctionName, &OriginalFuncAddress, 
			TRUE))//从导入的模块中获得函数地址
		{
			OriginalFuncAddress += (ULONG_PTR)ModuleFile->BaseAddress;
			DbgPrint("OriFuncAddr: %p\r\n",OriginalFuncAddress);
		}

		//DbgPrint("%s    %p\r\n",FunctionName,FunctionAddress);
		OutBuffer->Data[x].CurFuncAddress = FunctionAddress;
		OutBuffer->Data[x].OriFuncAddress = OriginalFuncAddress;

		memcpy(OutBuffer->Data[x].szFunctionName,FunctionName,strlen(FunctionName));
	}
	OutBuffer->ulCount = ExportTable->NumberOfFunctions;

	//////////////////////////////////////////////////////////////////////////
	if (ModuleFile!=NULL && ModuleFile->szFileData != NULL && MmIsAddressValid(ModuleFile->szFileData))
	{
		DbgPrint("ExFreePool(ModuleFile->szFileData)\r\n");
		ExFreePool(ModuleFile->szFileData);
	}
	//////////////////////////////////////////////////////////////////////////

	return STATUS_SUCCESS;
}



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////



BOOLEAN  ReadFileData(PFILE_INFOR FileInfor)
{

	WCHAR     wzFileName[256];
	HANDLE    hFile  = NULL;
	IO_STATUS_BLOCK   iosb;
	OBJECT_ATTRIBUTES oa;
	UNICODE_STRING    uniFileName;
	NTSTATUS          Status;
	FILE_STANDARD_INFORMATION   FileStandardInfor;
	LARGE_INTEGER               Offset = {0,0};

	mbstowcs(wzFileName,FileInfor->szFileFullName,256);


	//DbgPrint("%S\r\n",uniFileName);

	RtlInitUnicodeString(&uniFileName,wzFileName);

	//初始化我们的对象属性

	InitializeObjectAttributes(&oa,&uniFileName,OBJ_CASE_INSENSITIVE,NULL,NULL);


	Status = ZwCreateFile(&hFile,GENERIC_READ,&oa,&iosb,NULL,
		FILE_ATTRIBUTE_NORMAL,FILE_SHARE_READ|FILE_SHARE_WRITE,FILE_OPEN,FILE_SYNCHRONOUS_IO_NONALERT,NULL,0);

	if(Status!=STATUS_SUCCESS)
	{

		return FALSE;
	}
	else
	{
		//	DbgPrint("Get File Success\n");
	}


	//获得文件信息

	Status = ZwQueryInformationFile(hFile,&iosb,&FileStandardInfor,sizeof(FILE_STANDARD_INFORMATION),
		FileStandardInformation);


	if (!NT_SUCCESS(Status))
	{
		ZwClose(hFile);

		return FALSE;
	}

	//动态申请内存

	if (FileStandardInfor.AllocationSize.u.LowPart == 0)
	{
		ZwClose(hFile);

		return FALSE;
	}

	FileInfor->szFileData = (char*)ExAllocatePool(PagedPool,FileStandardInfor.AllocationSize.u.LowPart);

	if (FileInfor->szFileData==NULL)
	{
		ZwClose(hFile);

		return FALSE;
	}


	//读取文件长度

	Status = ZwReadFile(hFile,
		NULL,
		NULL,
		NULL,
		&iosb,
		FileInfor->szFileData ,
		FileStandardInfor.AllocationSize.u.LowPart,
		&Offset,
		NULL);

	if (!NT_SUCCESS(Status))
	{
		//DbgPrint("Sys文件读取失败\r\n");
		ExFreePool(FileInfor->szFileData);
		ZwClose(hFile);
		return FALSE;
	}
	ZwClose(hFile);

	return TRUE;

}

PVOID
	GetDirectoryAddr(PUCHAR AddressBase,USHORT DirectoryIndex,
	ULONG_PTR* ulSize,ULONG_PTR* ulDiff,BOOLEAN IsFile)
{
	PIMAGE_DOS_HEADER  DosHeader = NULL;
	PIMAGE_NT_HEADERS  NtHeader  = NULL;
	PIMAGE_SECTION_HEADER  SectionHeader = NULL;
	PVOID			   DirAddr   = NULL;


	DosHeader = (PIMAGE_DOS_HEADER)AddressBase;

	if (!MmIsAddressValid(DosHeader))
	{
		return NULL;
	}

	if (DosHeader->e_magic!=IMAGE_DOS_SIGNATURE)
	{
		return NULL;
	}


	NtHeader = MakePtr(PIMAGE_NT_HEADERS,DosHeader,DosHeader->e_lfanew);


	if (!MmIsAddressValid(NtHeader))
	{
		return NULL;
	}

	if (NtHeader->Signature!=IMAGE_NT_SIGNATURE)
	{
		return NULL;
	}



	if (IsFile)  //这里判断是否是文件映射 还是将文件读入到内存的形式
	{


		//判断导入表属于那个节表中
		SectionHeader = GetSectionHeaderFromRva(NtHeader->OptionalHeader.DataDirectory[DirectoryIndex].VirtualAddress,
			NtHeader);   


		if (SectionHeader==NULL)
		{
			return NULL;
		}

		//  PointerToRawData == 0x200       VirtualAddress == 0x1000    
		//                                              RVA = 0x1030

		//	那么导出表在文件中的偏移就是0x230  返回	

		//节在内存中的RVA - 在文件中节的偏移 = 该节被提高了多少        
		*ulDiff = (int)(SectionHeader->VirtualAddress - SectionHeader->PointerToRawData);   
		//0x1000 - 0x200 = 0xE00	

	}

	else
	{
		*ulDiff = 0;
	}


	DirAddr = MakePtr(PVOID,DosHeader,NtHeader->OptionalHeader.DataDirectory[DirectoryIndex].VirtualAddress - *ulDiff); 


	if (DirAddr == (VOID*)NtHeader)
	{
		return NULL;
	}


	if (ulSize)
	{
		*ulSize = MakePtr(ULONG_PTR,DosHeader,NtHeader->OptionalHeader.DataDirectory[DirectoryIndex].Size); 


		if (ulSize)
		{
			*ulSize -= (ULONG_PTR)DosHeader; 
		}

	}


	return DirAddr;
}

PIMAGE_SECTION_HEADER
	GetSectionHeaderFromRva(ULONG RVA,PIMAGE_NT_HEADERS NtHeader)  //判断RVA是在那个节表当中
{
	ULONG   i = 0;
	PIMAGE_SECTION_HEADER  SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

	for (i=0;i<NtHeader->FileHeader.NumberOfSections;i++,SectionHeader++)
	{

		if ((RVA>=SectionHeader->VirtualAddress)&&
			(RVA<(SectionHeader->VirtualAddress + SectionHeader->Misc.VirtualSize)))
		{
			return SectionHeader;
		}
	}

	return NULL;	
}

//////////////////////////////////////////////////////////////////////////

BOOLEAN
	GetModuleInfor(char* szModuleName,char* szFullName, SYSTEM_MODULE_INFORMATION_ENTRY* Temp)
{
	ULONG_PTR  NeedSize;
	ULONG_PTR  KernelModuleCount = 0;
	SYSTEM_MODULE_INFORMATION_ENTRY* ModuleInfor;
	ULONG_PTR  i = 0;
	BOOLEAN    bOk = FALSE;
	//PSYSTEM_MODULE_INFORMATION Buffer = NULL;

	PETHREAD EThread = NULL;
	CHAR     PreMode = 0;

	EThread = PsGetCurrentThread();
	PreMode = HsChangePreMode(EThread);

	NtQuerySystemInformation(SystemModuleInformation,NULL, 
		0,&NeedSize);

	if (ModuleInforNeedSize != NeedSize && ModuleInforNeedSize > 0)	//如果大小有变，则清空缓冲区
	{
		ExFreePool(ModuleInforBuffer);
		DbgPrint("ExFreePool\r\n");
		ModuleInforBuffer = NULL;
		ModuleInforNeedSize = NeedSize;	//更新大小全局变量
	}
	if (ModuleInforBuffer == NULL)
	{
		DbgPrint("NeedSize: %d\r\n");
		ModuleInforBuffer = (PSYSTEM_MODULE_INFORMATION)ExAllocatePool(NonPagedPool,NeedSize);
	}
	if (ModuleInforBuffer == NULL)
	{
		DbgPrint("ModuleInforBuffer ExAllocatePool Failed");
	}

	if(NtQuerySystemInformation(SystemModuleInformation,ModuleInforBuffer,NeedSize,&NeedSize)
		==STATUS_SUCCESS)
	{
		char szKernelModuleName[60] = {0};

		KernelModuleCount = ModuleInforBuffer->ulCount;
		ModuleInfor = ModuleInforBuffer->smi;

		strcpy(szKernelModuleName, ModuleInfor->ImageName + ModuleInfor->ModuleNameOffset);

		for (i=0;i<KernelModuleCount;i++)
		{
			//DbgPrint("%s : %s\r\n",szModuleName,ModuleInfor->ImageName + ModuleInfor->ModuleNameOffset);

			if(_stricmp(szModuleName, ModuleInfor->ImageName + ModuleInfor->ModuleNameOffset) == 0 || 
				(_stricmp(szModuleName, "ntoskrnl.exe") == 0 && 
				 _stricmp(szKernelModuleName, ModuleInfor->ImageName + ModuleInfor->ModuleNameOffset) == 0 ))
			{
				//DbgPrint("%s\r\n",ModuleInfor->ImageName);  //这里是没有盘符的我在这里偷懒写死了

				//////////////////////////////////////////////////////////////////////////
				if (strstr(ModuleInfor->ImageName,"SystemRoot")==NULL)
				{
					Temp->Base = ModuleInfor->Base;
					Temp->Size = ModuleInfor->Size;
					strcpy(szFullName,ModuleInfor->ImageName);
				}
				else
				{
					CHAR ImageFull[260] = {0};

					Temp->Base = ModuleInfor->Base;
					Temp->Size = ModuleInfor->Size;

					strcpy(szFullName,"\\??\\C:");
					strcat(szFullName,ModuleInfor->ImageName);
				}

				//////////////////////////////////////////////////////////////////////////
				Temp->Base = ModuleInfor->Base;
				Temp->Size = ModuleInfor->Size;

				if (strnicmp(ModuleInfor->ImageName,"\\Windows\\",strlen("\\Windows\\"))==0)
				{
					char* Temp = NULL;
					strcpy(szFullName,"\\??\\C:\\");

					Temp = ModuleInfor->ImageName;

					strcat(szFullName,Temp);
				}
				else
				{
					strcpy(szFullName,ModuleInfor->ImageName);
				}

				DbgPrint("%s\r\n",szFullName);
				DbgPrint("%s\r\n",ModuleInfor->ImageName);

				bOk = TRUE;
				break;
			}
			ModuleInfor++;
		}
	}
	else
	{
		DbgPrint("NtQuerySystemInformation Failed\r\n");
	}

	HsRecoverPreMode(EThread, PreMode);

	return bOk;
}



//////////////////////////////////////////////////////////////////////////



PFILE_INFOR
	CreateFileData(SYSTEM_MODULE_INFORMATION_ENTRY* ModuleInfor,char* ModuleName)
{
	BOOLEAN        bOk     = FALSE;
	char           szFullName[256] = {0};

	SYSTEM_MODULE_INFORMATION_ENTRY  Temp;

	if (!ModuleInfor)  //通过文件名称获得文件全路径
	{

		bOk = GetModuleInfor(ModuleName,szFullName,&Temp);

		if (bOk==FALSE)
		{
			DbgPrint("GetModuleInfor Failed\r\n");
			return NULL;
		}
	}

	if (PFileInfor == NULL)
	{
		PFileInfor = (PFILE_INFOR)ExAllocatePool(PagedPool,sizeof(FILE_INFOR));
	}
 	if (PFileInfor == NULL)
 	{
 		DbgPrint("ExAllocatePool Failed\r\n");
 		return NULL;
 	}


	RtlZeroMemory(PFileInfor,sizeof(FILE_INFOR));

	if (ModuleInfor)
	{
		PFileInfor->BaseAddress = ModuleInfor->Base;
		PFileInfor->Size        = ModuleInfor->Size;
		strcpy(PFileInfor->szFileFullName,ModuleInfor->ImageName);


		//DbgPrint("%x    %d    %s\r\n",RvrFile->BaseAddress,RvrFile->Size,RvrFile->FileName);
	}

	else
	{
		PFileInfor->BaseAddress = (PVOID)Temp.Base;
		PFileInfor->Size        = Temp.Size;
		memcpy(PFileInfor->szFileFullName,szFullName,strlen(szFullName)+1);

	}
	//读取文件

	bOk = ReadFileData(PFileInfor);

	if (bOk==FALSE)
	{
		//ExFreePool(FileInfor);
		DbgPrint("ReadFileData Failed\r\n");
		return NULL;
	}

	return PFileInfor;

}




BOOLEAN GetAddrOfExportFuncAddr(
	UCHAR*  Base,				  
	CHAR*	FunctionName,	      
	ULONG_PTR*  AddrOfExportFuncAddr, BOOLEAN IsFile)
{
	PIMAGE_EXPORT_DIRECTORY 		ExportTable = NULL;
	ULONG*	    FuncName = NULL;
	ULONG*      FuncAddr = NULL;
	ULONG_PTR   j = 0;
	ULONG_PTR	ExportDiff;
	PSHORT		Ordinal;

	ExportTable = 
		(PIMAGE_EXPORT_DIRECTORY)GetDirectoryAddr(Base, 
		IMAGE_DIRECTORY_ENTRY_EXPORT, 
		NULL, &ExportDiff, IsFile);

	if(!ExportTable) 
	{
		return FALSE;
	}


	FuncName = MakePtr(PULONG, Base, ExportTable->AddressOfNames - ExportDiff);
	FuncAddr = MakePtr(PULONG, Base, ExportTable->AddressOfFunctions - ExportDiff);
	Ordinal  = MakePtr(PSHORT, Base, ExportTable->AddressOfNameOrdinals - ExportDiff);


	for(j = 0; j < ExportTable->NumberOfNames; j++, FuncName++){

		if (_stricmp(FunctionName, (CHAR*)Base + *FuncName - ExportDiff) == 0)
		{

			*AddrOfExportFuncAddr = *(FuncAddr + Ordinal[j]);
			return TRUE;
		}
	}


	return FALSE;   
}


//////////////////////////////////////////////////////////////////////////

BOOLEAN	GetModuleInforKernelFile(PULONG_PTR ulKernelBase,PULONG_PTR ulKernelSize,char* szModuleFileFullName, char* szModuleFile)
{
	NTSTATUS  Status;
	ULONG_PTR NeedSize = 0;
	PSYSTEM_MODULE_INFORMATION  ModuleList = NULL;

	int ModuleId = 0;

	PETHREAD EThread = NULL;
	CHAR     PreMode = 0;

	EThread = PsGetCurrentThread();
	PreMode = HsChangePreMode(EThread);

	Status = NtQuerySystemInformation(SystemModuleInformation,NULL,
		0,&NeedSize);  //不能被Hook


	if (Status!=STATUS_INFO_LENGTH_MISMATCH)
	{
		DbgPrint("STATUS_INFO_LENGTH_MISMATCH FAILED\r\n");
		return FALSE;
	}

	ModuleList = (PSYSTEM_MODULE_INFORMATION)ExAllocatePool(PagedPool,NeedSize);

	if (ModuleList==NULL)
	{
		DbgPrint("ModuleList==NULL\r\n");
		return FALSE;
	}

	Status = NtQuerySystemInformation(SystemModuleInformation,ModuleList,NeedSize,&NeedSize);

	if (!NT_SUCCESS(Status))
	{
		DbgPrint("NtQuerySystemInformation Failed\r\n");
		ExFreePool(ModuleList);
		return FALSE;
	}


	for (ModuleId = 0; ModuleId < ModuleList->ulCount; ModuleId++)
	{
		if (_stricmp(szModuleFile, "ntoskrnl.exe") == 0)
		{
			ModuleId = 0;
			DbgPrint("Win32k ModuleId: %d\r\n",ModuleId);
			break;
		}
		else if (_stricmp(
			ModuleList->smi[ModuleId].ImageName+ModuleList->smi[ModuleId].ModuleNameOffset,
			szModuleFile) == 0)
		{

			DbgPrint("Win32k ModuleId: %d\r\n",ModuleId);
			break;
		}
	}

	DbgPrint("%s\r\n",ModuleList->smi[ModuleId].ImageName);

	*ulKernelBase = ModuleList->smi[ModuleId].Base;
	*ulKernelSize = ModuleList->smi[ModuleId].Size;

	if (memcmp(ModuleList->smi[ModuleId].ImageName,"\\??\\",strlen("\\??\\"))==0)
	{
		strcpy(szModuleFileFullName,ModuleList->smi[ModuleId].ImageName);
	}
	else if (strnicmp(ModuleList->smi[ModuleId].ImageName,"\\SystemRoot\\",strlen("\\SystemRoot\\"))==0)
	{
		char* Temp = NULL;
		strcpy(szModuleFileFullName,"\\??\\C:\\Windows\\"); /*System32\\*/
		
		Temp = ModuleList->smi[ModuleId].ImageName + strlen("\\SystemRoot\\");

		strcat(szModuleFileFullName,Temp);
	}
	else if (strnicmp(ModuleList->smi[ModuleId].ImageName,"\\Windows\\",strlen("\\Windows\\"))==0)
	{
		char* Temp = NULL;
		strcpy(szModuleFileFullName,"\\??\\C:\\");

		Temp = ModuleList->smi[ModuleId].ImageName;

		strcat(szModuleFileFullName,Temp);
	}
	

	DbgPrint("szModuleFileFullName: %s\r\n",szModuleFileFullName);

	ExFreePool(ModuleList);

	HsRecoverPreMode(EThread, PreMode);

	return TRUE;

}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/KrnlFile.h`:

```h
#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include <ntimage.h>
#include "common.h"

#define MAX_PATH 60

//////////////////////////////////////////////////////////////////////////

enum HS_KERNEL_KERNELFILE
{
	HS_KERNEL_KERNELFILE_NTOSKRNL_IAT,
	HS_KERNEL_KERNELFILE_NTOSKRNL_EAT,
	HS_KERNEL_KERNELFILE_WIN32K_IAT,
	HS_KERNEL_KERNELFILE_WIN32K_EAT,
	HS_KERNEL_KERNELFILE_HALDLL_IAT,
	HS_KERNEL_KERNELFILE_HALDLL_EAT,
};

//////////////////////////////////////////////////////////////////////////


typedef struct _IAT_INFO_
{
	ULONG_PTR CurFuncAddress;
	ULONG_PTR OriFuncAddress;
	CHAR  szFunctionName[MAX_PATH];
	CHAR  szModuleName[MAX_PATH];
}IAT_INFO, *PIAT_INFO;

typedef struct _MODULE_IAT_
{
	ULONG_PTR ulCount;
	IAT_INFO  Data[1];
}MODULE_IAT, *PMODULE_IAT;

typedef struct _EAT_INFO_
{
	ULONG_PTR CurFuncAddress;
	ULONG_PTR OriFuncAddress;
	CHAR  szFunctionName[MAX_PATH];
}EAT_INFO, *PEAT_INFO;

typedef struct _MODULE_EAT_
{
	ULONG_PTR ulCount;
	EAT_INFO  Data[1];
}MODULE_EAT, *PMODULE_EAT;





#define MakePtr(a,b,c) ((a)((char*)b+c))

#define SystemModuleInformation 11

typedef struct  _FILE_INFOR_
{
	char  szFileFullName[512];
	char*  szFileData;
	PVOID BaseAddress;
	ULONG_PTR Size;
}FILE_INFOR,*PFILE_INFOR;


typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY64
{
	ULONG Reserved[4];  
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	char ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY64, *PSYSTEM_MODULE_INFORMATION_ENTRY64;



typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY32
{
	ULONG  Reserved[2];  
	ULONG  Base;        
	ULONG  Size;         
	ULONG  Flags;        
	USHORT Index;       
	USHORT Unknown;     
	USHORT LoadCount;   
	USHORT ModuleNameOffset;
	CHAR   ImageName[256];   
} SYSTEM_MODULE_INFORMATION_ENTRY32, *PSYSTEM_MODULE_INFORMATION_ENTRY32;



#ifdef _WIN64
#define SYSTEM_MODULE_INFORMATION_ENTRY SYSTEM_MODULE_INFORMATION_ENTRY64
#else
#define SYSTEM_MODULE_INFORMATION_ENTRY SYSTEM_MODULE_INFORMATION_ENTRY32
#endif


typedef struct _SYSTEM_MODULE_INFORMATION{          //模块链结构
	ULONG ulCount;
	SYSTEM_MODULE_INFORMATION_ENTRY smi[1];
}SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;


NTSYSAPI
	NTSTATUS
	NtQuerySystemInformation(IN ULONG SystemInformationClass,IN PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength);




BOOLEAN  ReadFileData(PFILE_INFOR FileInfor);

PVOID
	GetDirectoryAddr(PUCHAR AddressBase,USHORT DirectoryIndex,
	ULONG_PTR* ulSize,ULONG_PTR* ulDiff,BOOLEAN IsFile);

PIMAGE_SECTION_HEADER
	GetSectionHeaderFromRva(ULONG RVA,PIMAGE_NT_HEADERS NtHeader);  //判断RVA是在那个节表当中


NTSTATUS HsEnumKernelFileFunc(int KernelFile, PVOID OutputBuffer, ULONG_PTR ulOutputLen);

NTSTATUS HsQueryKernelFileFuncIAT(PVOID OutputBuffer, ULONG_PTR ulOutputLen, char* szModuleFile);

NTSTATUS HsQueryKernelFileFuncEAT(PVOID OutputBuffer, ULONG_PTR ulOutputLen, char* szModuleFile);

NTSTATUS HsEnumEATTable(PVOID  KernelBase,PMODULE_EAT OutBuffer, ULONG_PTR OutSize, char* szModuleFileName);

NTSTATUS HsEnumIATTable(PMODULE_IAT OutBuffer, ULONG_PTR OutSize);

BOOLEAN	GetModuleInforKernelFile(PULONG_PTR ulKernelBase,PULONG_PTR ulKernelSize,char* szWin32kFullName, char* szModuleFile);

BOOLEAN GetModuleInfor(char* szModuleName,char* szFullName, SYSTEM_MODULE_INFORMATION_ENTRY* Temp);

//////////////////////////////////////////////////////////////////////////


VOID HsInitKrnlFileGlobalVariable();

PFILE_INFOR CreateFileData(SYSTEM_MODULE_INFORMATION_ENTRY* ModuleInfor,char* ModuleName);

BOOLEAN GetAddrOfExportFuncAddr(
	UCHAR*  Base,				  
	CHAR*	FunctionName,	      
	ULONG_PTR*  AddrOfExportFuncAddr, BOOLEAN IsFile);



NTSYSAPI
	NTSTATUS
	NTAPI
	ZwQuerySystemInformation(
	IN ULONG_PTR SystemInformationClass,
	IN OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength OPTIONAL
	);



```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Memory.c`:

```c
#include "Memory.h"
#include "GetFuncAddress.h"
#include <ntimage.h>

//////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////

extern BOOLEAN IsModuleInList(ULONG_PTR Base, ULONG_PTR Size, PALL_MODULES AllModules, ULONG_PTR ulCount);
extern VOID WalkerModuleList64(PLIST_ENTRY64 ListEntry, ULONG nType, PALL_MODULES AllModules, ULONG ulCount);
extern VOID WalkerModuleList32(PLIST_ENTRY32 ListEntry, ULONG nType, PALL_MODULES AllModules, ULONG ulCount);
extern NTSTATUS EnumDllModuleByPeb( PEPROCESS EProcess, PALL_MODULES AllModules, ULONG_PTR ulCount);


extern WIN_VERSION  WinVersion;

extern ULONG_PTR    ObjectTableOffsetOf_EPROCESS;
extern ULONG_PTR    ObjectHeaderSize;
extern ULONG_PTR    ObjectTypeOffsetOf_Object_Header;
extern ULONG_PTR    PreviousModeOffsetOf_KTHREAD;
extern ULONG_PTR    IndexOffset;
ULONG_PTR    SSDTDescriptor;
ULONG_PTR    ulIndex;
ULONG_PTR    SSDTFuncAddress;

pfnNtQueryVirtualMemory  NtQueryVirtualMemoryAddress = NULL;

extern ULONG_PTR    SSDTDescriptor;


NTSTATUS
	HsEnumProcessesModule(ULONG ulProcessID,PVOID OutBuffer,ULONG_PTR ulOutSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PEPROCESS EProcess = NULL;

	ULONG ulCount = (ulOutSize - sizeof(ALL_MODULES)) / sizeof(MODULE_INFO);

	HsInitMemoryVariable();

	if (ulProcessID)
	{
		Status = PsLookupProcessByProcessId((HANDLE)ulProcessID, &EProcess);

		if (!NT_SUCCESS(Status))
		{
			return Status;
		}
	}

	DbgPrint("Enter EnumProcessModule\r\n");

	if (HsIsRealProcess(EProcess))
	{
		PALL_MODULES AllModules = (PALL_MODULES)ExAllocatePool(PagedPool,ulOutSize);
		if (AllModules)
		{
			memset(AllModules, 0, ulOutSize);

			Status = EnumDllModuleByPeb(EProcess, AllModules, ulCount);

			if (ulCount >= AllModules->ulCount)
			{
				RtlCopyMemory(OutBuffer, AllModules, ulOutSize);
				Status = STATUS_SUCCESS;
			}
			else
			{
				Status = STATUS_BUFFER_TOO_SMALL;
			}

			ExFreePool(AllModules, 0);
			AllModules = NULL;
		}
	}

	if (NT_SUCCESS(Status))
	{
		ObfDereferenceObject(EProcess);
	}

	return Status;
}





//////////////////////////////////////////////////////////////////////////
NTSTATUS
HsEnumProcessesMemory(ULONG ulProcessID,PVOID OutBuffer,ULONG_PTR ulOutSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PEPROCESS EProcess = NULL;

	HsInitMemoryVariable();

	if (!PsLookupProcessByProcessId || !ObfDereferenceObject)
	{
		return STATUS_UNSUCCESSFUL;
	}

	if (ulProcessID)
	{
		Status = PsLookupProcessByProcessId((HANDLE)ulProcessID, &EProcess);
		if (!NT_SUCCESS(Status))
		{
			return Status;
		}
	}

	if (HsIsRealProcess(EProcess))
	{
		ULONG_PTR  ulCount = (ulOutSize - sizeof(ALL_MEMORYS)) / sizeof(MEMORY_INFO);
		DbgPrint("EnumProcessMemory\r\n");
		Status = GetMemorys(EProcess, (PALL_MEMORYS)OutBuffer,ulCount);
		if (NT_SUCCESS(Status))
		{
			if (ulCount >= ((PALL_MEMORYS)OutBuffer)->ulCount)
			{
				DbgPrint("GetSuccess\r\n");
				Status = STATUS_SUCCESS;
			}
			else
			{
				Status = STATUS_BUFFER_TOO_SMALL;
			}
		}
	}

	if (NT_SUCCESS(Status))
	{
		ObfDereferenceObject(EProcess);
	}

	return Status;
}


NTSTATUS GetMemorys(PEPROCESS EProcess, PALL_MEMORYS Memorys, ULONG_PTR ulCount)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	HANDLE hProcess = NULL;



	Status = ObOpenObjectByPointer(EProcess, 
		OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 
		NULL, 
		GENERIC_ALL, 
		*PsProcessType, 
		KernelMode, 
		&hProcess
		);

	if (NT_SUCCESS(Status))
	{
		ULONG_PTR ulBase = 0;
		PETHREAD EThread = PsGetCurrentThread();
		CHAR PreMode = HsChangePreMode(EThread);

		while (ulBase < (ULONG_PTR)MM_HIGHEST_USER_ADDRESS)
		{
			MEMORY_BASIC_INFORMATION mbi;
			ULONG_PTR ulRet = 0;
			Status = NtQueryVirtualMemoryAddress(hProcess, 
				(PVOID)ulBase, 
				MemoryBasicInformation, 
				&mbi, 
				sizeof(MEMORY_BASIC_INFORMATION), 
				&ulRet);

			if (NT_SUCCESS(Status))
			{
				ULONG_PTR ulCurCnt = Memorys->ulCount;
				if (ulCount > ulCurCnt)
				{
					Memorys->Memorys[ulCurCnt].ulBase = ulBase;
					Memorys->Memorys[ulCurCnt].ulSize = mbi.RegionSize;
					Memorys->Memorys[ulCurCnt].ulProtect = mbi.Protect;
					Memorys->Memorys[ulCurCnt].ulState = mbi.State;
					Memorys->Memorys[ulCurCnt].ulType = mbi.Type;
				}

				Memorys->ulCount++;
				ulBase += mbi.RegionSize;
			}
			else
			{
				ulBase += PAGE_SIZE;
			}
		}

		NtClose(hProcess);
		HsRecoverPreMode(EThread,PreMode);
	}

	return Status;
}








VOID HsInitMemoryVariable()
{

	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			IndexOffset = 4;
			SSDTDescriptor = GetKeServiceDescriptorTable64();
			ulIndex = GetSSDTApiFunIndex("NtQueryVirtualMemory");
			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);

			NtQueryVirtualMemoryAddress  = (pfnNtQueryVirtualMemory)SSDTFuncAddress;
			break;
		}

	case WINDOWS_XP:
		{

			ObjectHeaderSize = 0x18;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;
			PreviousModeOffsetOf_KTHREAD = 0x140;


			IndexOffset = 1;
			SSDTDescriptor = (ULONG_PTR)HsGetFunctionAddressByName(L"KeServiceDescriptorTable");
			//获得NtQueryObject函数的地址
			ulIndex = GetSSDTApiFunIndex("NtQueryVirtualMemory");


			SSDTFuncAddress =  GetSSDTApiFunAddress(ulIndex,SSDTDescriptor);

			NtQueryVirtualMemoryAddress  = (pfnNtQueryVirtualMemory)SSDTFuncAddress;
			break;
		}
	}
}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Memory.h`:

```h
#pragma once 

#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"

#include "Process.h"

typedef struct _MEMORY_INFO_
{
	ULONG_PTR ulBase;
	ULONG_PTR ulSize;
	ULONG ulProtect;
	ULONG ulState;
	ULONG ulType;
}MEMORY_INFO, *PMEMORY_INFO;

typedef struct _ALL_MEMORYS_
{
	ULONG_PTR ulCount;
	MEMORY_INFO Memorys[1];
}ALL_MEMORYS, *PALL_MEMORYS;



typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetList,
	MemorySectionName
}MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_BASIC_INFORMATION {
	PVOID BaseAddress;
	PVOID AllocationBase;
	ULONG AllocationProtect;
	SIZE_T RegionSize;
	ULONG State;
	ULONG Protect;
	ULONG Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;








//////////////////////////////////////////////////////////////////////////

NTSYSAPI
	PIMAGE_NT_HEADERS
	NTAPI
	RtlImageNtHeader(PVOID Base);

extern
	PPEB
	PsGetProcessPeb(PEPROCESS Process);

typedef 
	ULONG_PTR 
	(*pfnObGetObjectType)(PVOID pObject);

typedef
	NTSTATUS
	(*pfnNtQueryVirtualMemory)(HANDLE ProcessHandle,PVOID BaseAddress,MEMORY_INFORMATION_CLASS MemoryInformationClass,
	PVOID MemoryInformation,
	SIZE_T MemoryInformationLength,
	PSIZE_T ReturnLength);


VOID HsInitMemoryVariable();

NTSTATUS
	HsEnumProcessesMemory(ULONG ulProcessID,PVOID OutBuffer,ULONG_PTR ulOutSize);

NTSTATUS
	HsEnumProcessesModule(ULONG ulProcessID,PVOID OutBuffer,ULONG_PTR ulOutSize);

NTSTATUS GetMemorys(PEPROCESS EProcess, PALL_MEMORYS Memorys, ULONG_PTR ulCount);






```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Module.c`:

```c
#include "Module.h"

#include "GetFuncAddress.h"
//////////////////////////////////////////////////////////////////////////
extern     PDEVICE_OBJECT g_DeviceObject;
extern     PDRIVER_OBJECT g_DriverObject;
//////////////////////////////////////////////////////////////////////////

extern
	ULONG_PTR    PreviousModeOffsetOf_KTHREAD;
extern
	ULONG_PTR    ObjectTableOffsetOf_EPROCESS;
extern
	ULONG_PTR ulBuildNumber;
extern
	WIN_VERSION  WinVersion;
extern
	ULONG_PTR SYSTEM_ADDRESS_START;
extern
	ULONG_PTR ObjectHeaderSize;
extern
	ULONG_PTR ObjectTypeOffsetOf_Object_Header;



PVOID
	Ntoskrnl_KLDR_DATA_TABLE_ENTRY = NULL;

pfnNtOpenDirectoryObject  NtOpenDirectoryObjectAddress = NULL;
POBJECT_TYPE DirectoryObjectType = NULL;

//////////////////////////////////////////////////////////////////////////
extern POBJECT_TYPE *IoDriverObjectType;
extern POBJECT_TYPE *IoDeviceObjectType;
//////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////


NTSTATUS HsDispatchControlForModule(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet)
{

	WCHAR* szOutputBuffer = (WCHAR*)OutputBuffer;
	ULONG				ulIoControlCode  = 0;
	NTSTATUS			Status = STATUS_UNSUCCESSFUL;
	PVOID               pvInputBuffer  = NULL;
	ULONG               ulInputLen     = 0;
	ULONG				ulOutputLen    = 0;


	pvInputBuffer   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
	ulInputLen      = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	ProbeForRead(pvInputBuffer,ulInputLen,sizeof(CHAR));

	ulOutputLen     = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	ProbeForWrite(OutputBuffer,ulOutputLen,sizeof(CHAR));

	ulIoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	ulIoControlCode = (ulIoControlCode>>2)&0x00000FFF;

	DbgPrint("%x\r\n",ulIoControlCode);

	HsInitModuleGlobalVariable();

	switch(ulIoControlCode)
	{
	case HS_IOCTL_MODU_MODULELIST:			//当前进程PID
		{
			DbgPrint("HS_IOCTL_MODU_MODULELIST\r\n");

			NtOpenDirectoryObjectAddress = (pfnNtOpenDirectoryObject)HsGetFuncAddress("NtOpenDirectoryObject");
			GetKernelLdrDataTableEntry(g_DriverObject);
			Status = HsEnumSystemModuleList(OutputBuffer,ulOutputLen);
			break;
		}
	case HS_IOCTL_MODU_REMOVEMODULE:
		{
			DbgPrint("HS_IOCTL_MODU_REMOVEMODULE\r\n");

			if (pvInputBuffer!=NULL&&ulInputLen==sizeof(ULONG_PTR))
			{
				Status = HsUnloadDriverModule(*(PULONG_PTR)pvInputBuffer,ulInputLen);
			}
			break;
		}
	default:
		{
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	return Status;
}



NTSTATUS HsEnumSystemModuleList(PVOID OutBuffer, ULONG OutSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PALL_DRIVERS DriversInfor = (PALL_DRIVERS)OutBuffer;
	ULONG ulCount = (OutSize - sizeof(ALL_DRIVERS)) / sizeof(DRIVER_INFO);

	// 检查参数
	if (!OutBuffer)
	{
		return STATUS_INVALID_PARAMETER;
	}

	EnumDriverByLdrDataTableEntry(DriversInfor,ulCount);
	EnumDriversByWalkerDirectoryObject(DriversInfor, ulCount);
	if (ulCount >= DriversInfor->ulCount)
	{
		Status = STATUS_SUCCESS;
	}
	else
	{
		Status = STATUS_BUFFER_TOO_SMALL;
	}

	return Status;
}





BOOLEAN GetKernelLdrDataTableEntry(PDRIVER_OBJECT DriverObject)
{
	BOOLEAN bRet = FALSE;
	if (DriverObject)
	{
		PKLDR_DATA_TABLE_ENTRY Entry = NULL, FirstEntry = NULL;
		WCHAR wzNtoskrnl[] = L"ntoskrnl.exe";
		int nLen = wcslen(wzNtoskrnl) * sizeof(WCHAR);

		FirstEntry = Entry = (PKLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;

		while((PKLDR_DATA_TABLE_ENTRY)Entry->InLoadOrderLinks.Flink != FirstEntry)
		{

			if (Entry->BaseDllName.Buffer								&& 
				nLen == Entry->BaseDllName.Length						&&
				MmIsAddressValid((PVOID)Entry->BaseDllName.Buffer)		&&
				!_wcsnicmp(wzNtoskrnl,(WCHAR*)Entry->BaseDllName.Buffer, nLen / sizeof(WCHAR)))
			{
				Ntoskrnl_KLDR_DATA_TABLE_ENTRY = (PVOID)Entry;
				bRet = TRUE;
				break;
			}

			Entry = (PKLDR_DATA_TABLE_ENTRY)Entry->InLoadOrderLinks.Flink;
		}

		// 如果实在没找到ntoskrnl,那么使用自己的
		if (!bRet)
		{
			Ntoskrnl_KLDR_DATA_TABLE_ENTRY = (PVOID)FirstEntry;
			bRet = TRUE;
		}
	}

	return bRet;
}



VOID EnumDriverByLdrDataTableEntry(PALL_DRIVERS DriversInfor, ULONG_PTR ulCount)
{
	PKLDR_DATA_TABLE_ENTRY Entry = NULL, FirstEntry = NULL;
	ULONG nMax = PAGE_SIZE;
	ULONG i = 0;
	KIRQL OldIrql;

	FirstEntry = Entry = (PKLDR_DATA_TABLE_ENTRY)Ntoskrnl_KLDR_DATA_TABLE_ENTRY;

	if (!FirstEntry || !DriversInfor)
	{
		return;
	}

	OldIrql = KeRaiseIrqlToDpcLevel();

	__try
	{
		do
		{
			if ((ULONG_PTR)Entry->DllBase > SYSTEM_ADDRESS_START && Entry->SizeOfImage > 0)
			{
				ULONG_PTR Temp = DriversInfor->ulCount;
				if (ulCount > Temp)
				{

					DriversInfor->Drivers[Temp].LodeOrder = ++i;
					DriversInfor->Drivers[Temp].Base = (ULONG_PTR)Entry->DllBase;
					DriversInfor->Drivers[Temp].Size = Entry->SizeOfImage;



					if (IsUnicodeStringValid(&(Entry->FullDllName)))
					{
						memcpy(DriversInfor->Drivers[Temp].wzDriverPath, (WCHAR*)Entry->FullDllName.Buffer, Entry->FullDllName.Length);


					}
					else if (IsUnicodeStringValid(&(Entry->BaseDllName)))
					{

						memcpy(DriversInfor->Drivers[Temp].wzDriverPath, (WCHAR*)Entry->BaseDllName.Buffer, Entry->BaseDllName.Length);

					}

				}

				DriversInfor->ulCount++;
			}

			Entry = (PKLDR_DATA_TABLE_ENTRY)Entry->InLoadOrderLinks.Flink;

		}while(Entry && Entry != FirstEntry && nMax--);	
	}
	__except(1)
	{}

	KeLowerIrql(OldIrql);
}





VOID EnumDriversByWalkerDirectoryObject(PALL_DRIVERS DriversInfor, ULONG_PTR ulCount)
{	
	NTSTATUS Status;
	OBJECT_ATTRIBUTES oa; 
	UNICODE_STRING uniDirectory; 
	HANDLE hDirectory;
	PVOID  DirectoryObject = NULL;
	WCHAR  wzDirectory[] = {L'\\', L'\0'};
	PETHREAD EThread = NULL;
	CHAR PreMode = 0;


	RtlInitUnicodeString(&uniDirectory, wzDirectory);
	InitializeObjectAttributes(&oa, &uniDirectory, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

	EThread =  PsGetCurrentThread();
	PreMode = HsChangePreMode(EThread);

	Status = NtOpenDirectoryObjectAddress(&hDirectory, 0, &oa);
	if (NT_SUCCESS(Status) )
	{
		Status = ObReferenceObjectByHandle(hDirectory, 0x10000000, 0, 0, &DirectoryObject, 0);
		if ( NT_SUCCESS(Status) )
		{

			DirectoryObjectType = KeGetObjectType(DirectoryObject);

			WalkerDirectoryObject(DriversInfor, DirectoryObject, ulCount);
			ObfDereferenceObject(DirectoryObject);
		}

		Status = NtClose(hDirectory);
	}

	HsRecoverPreMode(EThread, PreMode);
}



VOID WalkerDirectoryObject(PALL_DRIVERS DriversInfor, PVOID DirectoryObject, ULONG_PTR ulCount)
{


	if (DirectoryObject			    &&
		DriversInfor				&&
		MmIsAddressValid(DirectoryObject)
		)
	{
		ULONG i = 0;
		POBJECT_DIRECTORY ObjectDir = (POBJECT_DIRECTORY)DirectoryObject;
		KIRQL OldIrql = KeRaiseIrqlToDpcLevel();

		__try
		{
			for (i = 0; i < NUMBER_HASH_BUCKETS; i++)
			{
				POBJECT_DIRECTORY_ENTRY ObjectDirEntry = ObjectDir->HashBuckets[i];
				for (; (ULONG_PTR)ObjectDirEntry > SYSTEM_ADDRESS_START && MmIsAddressValid(ObjectDirEntry); ObjectDirEntry = ObjectDirEntry->ChainLink)
				{
					if (MmIsAddressValid(ObjectDirEntry->Object))
					{
						POBJECT_TYPE ObjectType = KeGetObjectType(ObjectDirEntry->Object);

						//
						// 如果是目录，那么继续递归遍历
						//
						if (ObjectType == DirectoryObjectType)
						{
							WalkerDirectoryObject(DriversInfor, ObjectDirEntry->Object, ulCount);
						}

						//
						// 如果是驱动对象
						//
						else if (ObjectType == *IoDriverObjectType)
						{
							PDEVICE_OBJECT DeviceObject = NULL;

							if (!IsDriverInList(DriversInfor,(PDRIVER_OBJECT)ObjectDirEntry->Object,ulCount))
							{
								InsertDriver(DriversInfor, (PDRIVER_OBJECT)ObjectDirEntry->Object,ulCount);
							}

							//
							// 遍历设备栈
							//
							for (DeviceObject = ((PDRIVER_OBJECT)ObjectDirEntry->Object)->DeviceObject; 
								DeviceObject && MmIsAddressValid(DeviceObject);
								DeviceObject = DeviceObject->AttachedDevice)
							{
								if (!IsDriverInList(DriversInfor, DeviceObject->DriverObject,ulCount))
								{
									InsertDriver(DriversInfor, DeviceObject->DriverObject,ulCount);
								}
							}
						}

						//
						// 如果是设备对象
						//
						else if (ObjectType == *IoDeviceObjectType)
						{
							PDEVICE_OBJECT DeviceObject = NULL;

							if (!IsDriverInList(DriversInfor,((PDEVICE_OBJECT)ObjectDirEntry->Object)->DriverObject,ulCount))
							{
								InsertDriver(DriversInfor, ((PDEVICE_OBJECT)ObjectDirEntry->Object)->DriverObject,ulCount);
							}

							//
							// 遍历设备栈
							//
							for (DeviceObject = ((PDEVICE_OBJECT)ObjectDirEntry->Object)->AttachedDevice; 
								DeviceObject && MmIsAddressValid(DeviceObject);
								DeviceObject = DeviceObject->AttachedDevice)
							{
								if (!IsDriverInList(DriversInfor, DeviceObject->DriverObject,ulCount))
								{
									InsertDriver(DriversInfor, DeviceObject->DriverObject, ulCount);
								}
							}
						}
					}
				}
			}
		}
		__except(1)
		{
		}

		KeLowerIrql(OldIrql);
	}
}





POBJECT_TYPE KeGetObjectType(PVOID Object)
{
	ULONG_PTR ObjectType = NULL;
	pfnObGetObjectType        ObGetObjectType = NULL;    

	if (!Object || !MmIsAddressValid(Object))
	{
		return NULL;
	}

	if (ulBuildNumber < 6000)
	{
		ULONG ObjectTypeAddress = 0;

		ObjectTypeAddress = (ULONG_PTR)Object - ObjectHeaderSize + ObjectTypeOffsetOf_Object_Header;

		if (MmIsAddressValid((PVOID)ObjectTypeAddress))
		{ 
			ObjectType = *(ULONG_PTR*)ObjectTypeAddress;
		}
	}
	else
	{
		ObGetObjectType = (pfnObGetObjectType)HsGetFunctionAddressByName(L"ObGetObjectType");


		if (ObGetObjectType)
		{
			ObjectType = ObGetObjectType(Object);
		}
	}

	return (POBJECT_TYPE)ObjectType;
}



BOOLEAN IsDriverInList(PALL_DRIVERS DriversInfor, PDRIVER_OBJECT DriverObject, ULONG_PTR ulCount)
{
	BOOLEAN bIn = TRUE, bFind = FALSE;

	if (!DriversInfor			|| 
		!DriverObject			|| 
		!MmIsAddressValid(DriverObject))
	{
		return TRUE;
	}

	__try
	{
		if (MmIsAddressValid(DriverObject))
		{
			PKLDR_DATA_TABLE_ENTRY Entry = (PKLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;

			if (Entry &&
				MmIsAddressValid(Entry) && 
				MmIsAddressValid((PVOID)Entry->DllBase) &&
				(ULONG_PTR)Entry->DllBase > SYSTEM_ADDRESS_START)
			{
				ULONG i = 0;
				ULONG Temp = ulCount > DriversInfor->ulCount ? DriversInfor->ulCount : ulCount;

				for (i = 0; i < Temp; i++)
				{
					if (DriversInfor->Drivers[i].Base == (ULONG_PTR)Entry->DllBase)
					{
						if (DriversInfor->Drivers[i].DriverObject == 0)
						{
							//获得驱动对象
							DriversInfor->Drivers[i].DriverObject = (ULONG_PTR)DriverObject;

							//获得驱动入口
							DriversInfor->Drivers[i].DirverStartAddress = (ULONG_PTR)Entry->EntryPoint;


							//获得服务名
							wcsncpy(DriversInfor->Drivers[i].wzKeyName,DriverObject->DriverExtension->ServiceKeyName.Buffer,DriverObject->DriverExtension->ServiceKeyName.Length);
						}

						bFind = TRUE;
						break;
					}
				}

				if (!bFind)
				{
					bIn = FALSE; 
				}
			}
		}
	}
	__except(1)
	{
		bIn = TRUE;
	}

	return bIn;
}



VOID InsertDriver(PALL_DRIVERS DriversInfor, PDRIVER_OBJECT DriverObject, ULONG_PTR ulCount)
{
	if (!DriversInfor || !DriverObject || !MmIsAddressValid(DriverObject))
	{
		return;
	}
	else
	{
		PKLDR_DATA_TABLE_ENTRY Entry = (PKLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;

		if (Entry &&
			MmIsAddressValid(Entry) && 
			MmIsAddressValid((PVOID)Entry->DllBase) &&
			(ULONG_PTR)Entry->DllBase > SYSTEM_ADDRESS_START)
		{
			ULONG Temp = DriversInfor->ulCount;
			if (ulCount > Temp)
			{
				DriversInfor->Drivers[Temp].Base = (ULONG_PTR)Entry->DllBase;
				DriversInfor->Drivers[Temp].Size = Entry->SizeOfImage;
				DriversInfor->Drivers[Temp].DriverObject = (ULONG_PTR)DriverObject;

				if (IsUnicodeStringValid(&(Entry->FullDllName)))
				{
					wcsncpy(DriversInfor->Drivers[Temp].wzDriverPath, (WCHAR*)(Entry->FullDllName.Buffer), Entry->FullDllName.Length);
				}
				else if (IsUnicodeStringValid(&(Entry->BaseDllName)))
				{
					wcsncpy(DriversInfor->Drivers[Temp].wzDriverPath, (WCHAR*)(Entry->BaseDllName.Buffer), Entry->BaseDllName.Length);
				}
			}
			DriversInfor->ulCount++;
		}
	}
}




BOOLEAN IsUnicodeStringValid(PUNICODE_STRING uniString)
{
	BOOLEAN bRet = FALSE;

	__try
	{
		if (uniString->Length > 0	&&
			uniString->Buffer		&&
			MmIsAddressValid(uniString->Buffer) &&
			MmIsAddressValid(&uniString->Buffer[uniString->Length / sizeof(WCHAR) - 1]))
		{
			bRet = TRUE;
		}

	}
	__except(1)
	{	
		bRet = FALSE;
	}

	return bRet;
}




VOID HsInitModuleGlobalVariable()
{
	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			PreviousModeOffsetOf_KTHREAD = 0x140;
			ObjectHeaderSize = 0x18;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;
			SYSTEM_ADDRESS_START	 = 0x80000000; 
			break;
		}

	case WINDOWS_7:
		{
			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			ObjectHeaderSize = 0x30;
			SYSTEM_ADDRESS_START =  0x80000000000;
			break;
		}
	}
}





NTSTATUS HsUnloadDriverModule(ULONG_PTR InBuffer, ULONG_PTR InSize)
{

	PDRIVER_OBJECT DriverObject = (PDRIVER_OBJECT)InBuffer;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	DbgPrint("g_DriverObject: %p\r\n",g_DriverObject);
	DbgPrint("  DriverObject: %p\r\n",  DriverObject);

	if ((ULONG_PTR)DriverObject > SYSTEM_ADDRESS_START &&
		MmIsAddressValid(DriverObject) &&
		g_DriverObject != DriverObject && 
		IsRealDriverObject(DriverObject) )
	{
		Status = PspUnloadDriver(DriverObject);
	}

	return Status;
}




//判断一个驱动是否为真的驱动对象
BOOLEAN IsRealDriverObject(PDRIVER_OBJECT DriverObject)
{
	BOOLEAN bRet = FALSE;
	if (!*IoDriverObjectType||
		!*IoDeviceObjectType)
	{
		return bRet;
	}

	__try
	{
		if (DriverObject->Type == 4 && 
			DriverObject->Size == sizeof(DRIVER_OBJECT) &&
			KeGetObjectType(DriverObject) == *IoDriverObjectType &&
			MmIsAddressValid(DriverObject->DriverSection) &&
			(ULONG_PTR)DriverObject->DriverSection > SYSTEM_ADDRESS_START &&
			!(DriverObject->DriverSize & 0x1F) &&
			DriverObject->DriverSize < SYSTEM_ADDRESS_START &&
			!((ULONG_PTR)(DriverObject->DriverStart) & 0xFFF) &&
			(ULONG_PTR)DriverObject->DriverStart > SYSTEM_ADDRESS_START
			)
		{
			PDEVICE_OBJECT DeviceObject = DriverObject->DeviceObject;
			if (DeviceObject)
			{
				if (MmIsAddressValid(DeviceObject) &&
					KeGetObjectType(DeviceObject) == *IoDeviceObjectType &&
					DeviceObject->Type == 3 && 
					DeviceObject->Size >= sizeof(DEVICE_OBJECT))
				{
					bRet = TRUE;
				}
			}
			else
			{
				bRet = TRUE;
			}
		}
	}
	__except(1)
	{
		bRet = FALSE;
	}

	return bRet;
}





NTSTATUS PspUnloadDriver(PDRIVER_OBJECT DriverObject)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;


	if (MmIsAddressValid(DriverObject))
	{
		BOOLEAN bDriverUnload = FALSE;
		HANDLE  hSystemThread = NULL;

		if (DriverObject->DriverUnload &&
			(ULONG_PTR)DriverObject->DriverUnload > SYSTEM_ADDRESS_START &&
			MmIsAddressValid(DriverObject->DriverUnload))
		{
			bDriverUnload = TRUE;
		}

		if (bDriverUnload)
		{
			Status = PsCreateSystemThread(&hSystemThread, 0, NULL, NULL, NULL,HaveDriverUnloadThread, DriverObject);  //如果存在卸载函数


			//卸载其他的驱动没有问题
			//卸载32位Xutre的驱动崩溃 不是我们的原因 Xutre的UnloadDriver没有处理好
		}
		else
		{
			Status = PsCreateSystemThread(&hSystemThread, 0, NULL, NULL, NULL,NotHaveDriverUnloadThread,DriverObject);
		}

		if (NT_SUCCESS(Status))
		{
			PETHREAD EThread = NULL, CurrentThread = NULL;
			CHAR PreMode = 0;

			Status = ObReferenceObjectByHandle(hSystemThread, 0, NULL, KernelMode, &EThread, NULL);
			if (NT_SUCCESS(Status))
			{
				LARGE_INTEGER TimeOut;
				TimeOut.QuadPart = -10 * 1000 * 1000 * 3;
				Status = KeWaitForSingleObject(EThread, Executive, KernelMode, TRUE, &TimeOut); // 等待3秒
				ObfDereferenceObject(EThread);
			}

			CurrentThread = PsGetCurrentThread();
			PreMode = HsChangePreMode(CurrentThread);
			NtClose(hSystemThread);
			HsRecoverPreMode(CurrentThread, PreMode);
		}
	}

	return Status;
}



VOID HaveDriverUnloadThread(PVOID lParam)
{

	PDRIVER_OBJECT DriverObject = (PDRIVER_OBJECT)lParam;

	if (DriverObject)
	{
		PDRIVER_UNLOAD DriverUnloadAddress = DriverObject->DriverUnload;

		if (DriverUnloadAddress)
		{
			DriverUnloadAddress(DriverObject);



			DriverObject->FastIoDispatch = NULL;
			memset(DriverObject->MajorFunction, 0, sizeof(DriverObject->MajorFunction));
			DriverObject->DriverUnload = NULL;

			ObMakeTemporaryObject(DriverObject);
			ObfDereferenceObject(DriverObject);
		}
	}

	PsTerminateSystemThread(STATUS_SUCCESS);
}


VOID NotHaveDriverUnloadThread(IN PVOID lParam)
{

	PDRIVER_OBJECT DriverObject = (PDRIVER_OBJECT)lParam;
	PDEVICE_OBJECT DeviceObject = NULL;

	if (DriverObject)
	{

		DriverObject->FastIoDispatch = NULL;
		memset(DriverObject->MajorFunction, 0, sizeof(DriverObject->MajorFunction));
		DriverObject->DriverUnload = NULL;

		DeviceObject = DriverObject->DeviceObject;

		while ( DeviceObject && MmIsAddressValid(DeviceObject) )
		{
			IoDeleteDevice(DeviceObject);
			DeviceObject = DeviceObject->NextDevice;
		}

		ObMakeTemporaryObject(DriverObject);
		ObfDereferenceObject(DriverObject);
	}

	PsTerminateSystemThread(STATUS_SUCCESS);
}

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Module.h`:

```h
/**************************************************************************************
* AUTHOR : HeavenShadow
* DATE   : 2014-10-28
* MODULE : Module.h
*
* Command: 
*	模块大功能的主文件
*
* Description:
*	与模块相关的所有功能集合文件
*
****************************************************************************************
* Copyright (C) 2015 HeavenShadow.
****************************************************************************************/


#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"


#define MAX_PATH 260


typedef struct _DRIVER_INFO_
{
	ULONG_PTR LodeOrder;
	ULONG_PTR Base;
	ULONG_PTR Size;
	ULONG_PTR DriverObject;
	ULONG_PTR DirverStartAddress;
	WCHAR wzDriverPath[MAX_PATH];
	WCHAR wzKeyName[MAX_PATH];
}DRIVER_INFO, *PDRIVER_INFO;

typedef struct _ALL_DRIVERS_
{
	ULONG_PTR ulCount;
	DRIVER_INFO Drivers[1];
}ALL_DRIVERS, *PALL_DRIVERS;



typedef struct _KLDR_DATA_TABLE_ENTRY64 {
	LIST_ENTRY64 InLoadOrderLinks;
	ULONG64 __Undefined1;
	ULONG64 __Undefined2;
	ULONG64 __Undefined3;
	ULONG64 NonPagedDebugInfo;
	ULONG64 DllBase;
	ULONG64 EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING64 FullDllName;
	UNICODE_STRING64 BaseDllName;
	ULONG   Flags;
	USHORT  LoadCount;
	USHORT  __Undefined5;
	ULONG64 __Undefined6;
	ULONG   CheckSum;
	ULONG   __padding1;
	ULONG   TimeDateStamp;
	ULONG   __padding2;
} KLDR_DATA_TABLE_ENTRY64, *PKLDR_DATA_TABLE_ENTRY64;




typedef struct _KLDR_DATA_TABLE_ENTRY32 {
	LIST_ENTRY32 InLoadOrderLinks;
	ULONG __Undefined1;
	ULONG __Undefined2;
	ULONG __Undefined3;
	ULONG NonPagedDebugInfo;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Undefined5;
	ULONG  __Undefined6;
	ULONG  CheckSum;
	ULONG  TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY32, *PKLDR_DATA_TABLE_ENTRY32;


#ifdef _WIN64
#define PKLDR_DATA_TABLE_ENTRY  PKLDR_DATA_TABLE_ENTRY64
#else
#define PKLDR_DATA_TABLE_ENTRY  PKLDR_DATA_TABLE_ENTRY32
#endif


#define NUMBER_HASH_BUCKETS 37
typedef struct _OBJECT_DIRECTORY_ENTRY
{
	struct _OBJECT_DIRECTORY_ENTRY *ChainLink;
	PVOID Object;
	ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _OBJECT_DIRECTORY
{
	struct _OBJECT_DIRECTORY_ENTRY *HashBuckets[NUMBER_HASH_BUCKETS];
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;



typedef
	NTSTATUS
	(*pfnNtOpenDirectoryObject)(PHANDLE  DirectoryHandle,ACCESS_MASK  DesiredAccess,POBJECT_ATTRIBUTES  ObjectAttributes);

typedef 
	ULONG_PTR 
	(*pfnObGetObjectType)(PVOID Object);

//////////////////////////////////////////////////////////////////////////

NTSTATUS HsDispatchControlForModule(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet);




// 枚举系统驱动模块列表
NTSTATUS HsEnumSystemModuleList(PVOID OutBuffer, ULONG OutSize);




VOID EnumDriverByLdrDataTableEntry(PALL_DRIVERS DriversInfor, ULONG_PTR ulCount);

BOOLEAN GetKernelLdrDataTableEntry(PDRIVER_OBJECT DriverObject);

VOID EnumDriversByWalkerDirectoryObject(PALL_DRIVERS DriversInfor, ULONG_PTR ulCount);

VOID WalkerDirectoryObject(PALL_DRIVERS DriversInfor, PVOID DirectoryObject, ULONG_PTR ulCount);

POBJECT_TYPE KeGetObjectType(PVOID Object);

BOOLEAN IsDriverInList(PALL_DRIVERS DriversInfor, PDRIVER_OBJECT DriverObject, ULONG_PTR ulCount);

VOID InsertDriver(PALL_DRIVERS DriversInfor, PDRIVER_OBJECT DriverObject, ULONG_PTR ulCount);

BOOLEAN IsUnicodeStringValid(PUNICODE_STRING uniString);



NTSTATUS HsUnloadDriverModule(ULONG_PTR InBuffer, ULONG_PTR InSize);

VOID HsInitModuleGlobalVariable();


//判断一个驱动是否为真的驱动对象
BOOLEAN IsRealDriverObject(PDRIVER_OBJECT DriverObject);

NTSTATUS PspUnloadDriver(PDRIVER_OBJECT DriverObject);

VOID HaveDriverUnloadThread(PVOID lParam);

VOID NotHaveDriverUnloadThread(IN PVOID lParam);








```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Privilege.c`:

```c
#include "Privilege.h"


extern WIN_VERSION  WinVersion;


extern ULONG_PTR    ObjectHeaderSize;
extern ULONG_PTR    ObjectTypeOffsetOf_Object_Header;
extern ULONG_PTR    ObjectTableOffsetOf_EPROCESS;
extern ULONG_PTR    PreviousModeOffsetOf_KTHREAD;


NTSTATUS HsEnumProcessPrivilege(WCHAR* szOutBuffer,ULONG_PTR ProcessID,ULONG_PTR ulOutSize)
{
	NTSTATUS  Status = STATUS_UNSUCCESSFUL;
	PEPROCESS EProcess = NULL;
	HANDLE    hProcess = NULL;
	HANDLE    hToken   = NULL;

	ULONG_PTR ulRet = 0;

	Status = PsLookupProcessByProcessId((HANDLE)ProcessID,&EProcess);


	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	if (!HsIsRealProcess(EProcess))
	{
		ObfDereferenceObject(EProcess);
		return Status;
	}


	Status = ObOpenObjectByPointer(EProcess, 
		OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, 
		NULL, 
		GENERIC_ALL, 
		*PsProcessType, 
		KernelMode, 
		&hProcess
		);

	if (NT_SUCCESS(Status))
	{
		PETHREAD EThread = NULL;
		CHAR     PreMode = 0;

		EThread = PsGetCurrentThread();
		PreMode = HsChangePreMode(EThread);

		Status = NtOpenProcessToken(hProcess, SACL_SECURITY_INFORMATION, &hToken);

		if (NT_SUCCESS(Status))
		{
			Status = NtQueryInformationToken(hToken, TokenPrivileges, szOutBuffer,ulOutSize, &ulRet);

			if (NT_SUCCESS(Status))
			{
				DbgPrint("NtQueryInformationToken Success\r\n");

			}
			else if (Status == STATUS_BUFFER_TOO_SMALL)
			{
				DbgPrint("Memory Too Small\r\n");
			}
		}

		if (hToken)
		{
			NtClose(hToken);
		}

		if (hProcess)
		{
			NtClose(hProcess);
		}

		HsRecoverPreMode(EThread, PreMode);
		ObfDereferenceObject(EProcess);

		Status = STATUS_SUCCESS;
	}
	return Status;
}







ULONG_PTR HsKeGetObjectType(PVOID Object)
{
	ULONG_PTR ObjectType = NULL;
	pfnObGetObjectType ObGetObjectType = NULL;


	if (!MmIsAddressValid ||!Object||!MmIsAddressValid(Object))
	{
		return NULL;
	}

	if (WinVersion < WINDOWS_7)
	{
		ULONG SizeOfObjectHeader = 0, ObjectTypeOffset = 0, ObjectTypeAddress = 0;

		ObjectTypeAddress = (ULONG_PTR)Object - ObjectHeaderSize + ObjectTypeOffsetOf_Object_Header;

		if (MmIsAddressValid((PVOID)ObjectTypeAddress))
		{ 
			ObjectType = *(ULONG_PTR*)ObjectTypeAddress;
		}
	}
	else
	{
		//高版本使用函数

		ObGetObjectType = (pfnObGetObjectType)HsGetFunctionAddressByName(L"ObGetObjectType");


		if (ObGetObjectType)
		{
			ObjectType = ObGetObjectType(Object);
		}
	}

	return ObjectType;
}



NTSTATUS HsAdjustProcessTokenPrivileges(PPRIVILEGEDATA PrivilegeData, int* bFeedBack)
{
	NTSTATUS  Status;
	PEPROCESS EProcess = NULL;
	HANDLE    hProcess = NULL;
	HANDLE    hToken   = NULL;

	if (PrivilegeData->ProcessID)
	{
		DbgPrint("PID: %d\r\n",PrivilegeData->ProcessID);
		DbgPrint("ATT: %d\r\n",PrivilegeData->TokenPrivileges.Privileges->Attributes);

		Status = PsLookupProcessByProcessId((HANDLE)PrivilegeData->ProcessID,&EProcess);


		if (!NT_SUCCESS(Status))
		{
			return Status;
		}
	}

	if (HsIsRealProcess(EProcess))
	{
		Status = ObOpenObjectByPointer(EProcess, OBJ_KERNEL_HANDLE, NULL, GENERIC_ALL, *PsProcessType, KernelMode, &hProcess);

		if (NT_SUCCESS(Status))
		{
			PETHREAD EThread = PsGetCurrentThread();
			CHAR PreMode = HsChangePreMode(EThread);

			Status = NtOpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &hToken);   //

			if (NT_SUCCESS(Status))
			{
				Status = NtAdjustPrivilegesToken(hToken, FALSE, 
					&PrivilegeData->TokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL);  

				if (NT_SUCCESS(Status))
				{
					DbgPrint("NtAdjustPrivilegesToken Success\r\n");
				}
			}

			if (hToken)
			{
				NtClose(hToken);
			}

			if (hProcess)
			{
				NtClose(hProcess);
			}

			HsRecoverPreMode(EThread, PreMode);
		}
	}

	if (NT_SUCCESS(Status))
	{

		*bFeedBack = 1;
		ObfDereferenceObject(EProcess);
	}

	return Status;
}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Privilege.h`:

```h
#pragma once 



#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"

#include "Process.h"


typedef struct _PRIVILEGE_DATA_ 
{
	ULONG_PTR  ProcessID;
	TOKEN_PRIVILEGES TokenPrivileges;   //宏
}PRIVILEGEDATA,*PPRIVILEGEDATA;


typedef 
ULONG_PTR (*pfnObGetObjectType)(PVOID pObject);


NTSTATUS HsEnumProcessPrivilege(WCHAR* szOutBuffer,ULONG_PTR ProcessID,ULONG_PTR ulOutSize);


ULONG_PTR HsKeGetObjectType(PVOID Object);


//修改权限的值
NTSTATUS HsAdjustProcessTokenPrivileges(PPRIVILEGEDATA PrivilegeData, int* bFeedBack);
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Process.c`:

```c
#include "Process.h"


#include "Thread.h"
#include "Handle.h"
#include "Window.h"
#include "Privilege.h"
#include "Memory.h"


ULONG_PTR ulCurrentProcessId = 1000000;				//重要
//////////////////////////////////////////////////////////////////////////
#define MAX_PROCESS_COUNT 100000
//////////////////////////////////////////////////////////////////////////
ULONG_PTR    ObjectTableOffsetOf_EPROCESS  = 0;		//句柄表偏移。
ULONG_PTR    PreviousModeOffsetOf_KTHREAD  = 0;		//权限相关的偏移。
ULONG_PTR    ImageFileNameOffset           = 0;		//文件名偏移。
ULONG_PTR    SectionObjectOffsetOfEProcess = 0;		//SectionObject
ULONG_PTR    ParentProcessIdOffset         = 0;		//父进程ID偏移InheritedFromUniqueProcessId


ULONG_PTR    ObjectHeaderSize = 0;
ULONG_PTR    ObjectTypeOffsetOf_Object_Header = 0;


//////////////////////////////////////////////////////////////////////////

//PEPROCESS  PsInitialSystemProcessAddress = NULL;


//////////////////////////////////////////////////////////////////////////
extern     PDEVICE_OBJECT g_DeviceObject;
//////////////////////////////////////////////////////////////////////////


extern WIN_VERSION  WinVersion;


//////////////////////////////////////////////////////////////////////////


NTSTATUS HsDispatchControlForProcess(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet)
{

	WCHAR* szOutputBuffer = (WCHAR*)OutputBuffer;
	ULONG				ulIoControlCode  = 0;
	NTSTATUS			Status = STATUS_UNSUCCESSFUL;
	PVOID               pvInputBuffer  = NULL;
	ULONG               ulInputLen     = 0;
	ULONG				ulOutputLen    = 0;

	pvInputBuffer   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
	ulInputLen      = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	ProbeForRead(pvInputBuffer,ulInputLen,sizeof(CHAR));

	ulOutputLen     = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	ProbeForWrite(OutputBuffer,ulOutputLen,sizeof(CHAR));

	ulIoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	ulIoControlCode = (ulIoControlCode>>2)&0x00000FFF;

	DbgPrint("%x\r\n",ulIoControlCode);

	HsInitProcessGlobalVariable();
	

	switch(ulIoControlCode)
	{
	case HS_IOCTL_PROC_SENDSELFPID:			//当前进程PID
		{
			DbgPrint("HS_IOCTL_PROC_SENDSELFPID\r\n");
			ulCurrentProcessId = *(ULONG_PTR*)pvInputBuffer;
			DbgPrint("CURRENTPID: %d\r\n",ulCurrentProcessId);
			*(ULONG_PTR*)OutputBuffer = 444;
			Status = STATUS_SUCCESS;
			break;
		}
	case HS_IOCTL_PROC_PROCESSCOUNT:		//进程计数
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSCOUNT\r\n");
			Status = HsGetSystemProcessCount((ULONG_PTR*)OutputBuffer);
			break;
		}
	case HS_IOCTL_PROC_PROCESSLIST:			//进程
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSLIST\r\n");
			Status = HsEnumSystemProcessList(*(ULONG_PTR*)pvInputBuffer,(PHSPROCESSINFO)OutputBuffer, ulRet);
			break;
		}
	case HS_IOCTL_PROC_PROCESSTHREAD:		//线程
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSTHREAD\r\n");
			//Status = HsEnumProcessThread(pvInputBuffer);
			Status = EnumProcessThread(pvInputBuffer,ulInputLen,OutputBuffer,ulOutputLen);
			break;
		}
	case HS_IOCTL_PROC_PROCESSTHREADMODULE://线程
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSTHREADMODULE\r\n");
			//Status = HsEnumProcessThread(pvInputBuffer);
			Status = EnumProcessThreadModule(*((ULONG_PTR*)pvInputBuffer),OutputBuffer,ulOutputLen);
			break;
		}
	case HS_IOCTL_PROC_PROCESSPRIVILEGE:	//权限
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSPRIVILEGE\r\n");
			Status = HsEnumProcessPrivilege((WCHAR*)OutputBuffer,*(ULONG_PTR*)pvInputBuffer,*ulRet);
			break;
		}
	case HS_IOCTL_PROC_PRIVILEGE_ADJUST:	//权限修改
		{
			DbgPrint("HS_IOCTL_PROC_PRIVILEGE_ADJUST\r\n");
			Status = HsAdjustProcessTokenPrivileges((PPRIVILEGEDATA)pvInputBuffer,(int*)OutputBuffer);
			break;
		}
	case HS_IOCTL_PROC_PROCESSHANDLE:		//进程句柄
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSHANDLE\r\n");
			Status = HsEnumProcessHandle((PVOID)*(PULONG)pvInputBuffer,ulInputLen,OutputBuffer,ulOutputLen);
			break;
		}

	case HS_IOCTL_PROC_KILLPROCESSBYFORCE:	//暴力杀死进程
		{
			DbgPrint("HS_IOCTL_PROC_KILLPROCESSBYFORCE\r\n");
			Status = HsKillProcessByZeroMemory(*((ULONG_PTR*)pvInputBuffer),(int*)OutputBuffer);
			break;
		}
	case HS_IOCTL_PROC_PROCESSWINDOW:		//窗口
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSWINDOW\r\n");
			Status = HsEnumProcessWindow(pvInputBuffer,ulInputLen,OutputBuffer,ulOutputLen);
			break;
		}
	case HS_IOCTL_PROC_PROCESSMODULE:		//进程模块
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSMODULE\r\n");
			Status = HsEnumProcessesModule(*((ULONG_PTR*)pvInputBuffer),OutputBuffer,ulOutputLen);
			break;
		}
	case HS_IOCTL_PROC_PROCESSMEMORY:		//进程内存
		{
			DbgPrint("HS_IOCTL_PROC_PROCESSMEMORY\r\n");
			Status = HsEnumProcessesMemory(*((ULONG_PTR*)pvInputBuffer),OutputBuffer,ulOutputLen);
			break;
		}
	default:
		{
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	return Status;
}


VOID HsInitProcessGlobalVariable()
{
	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			ImageFileNameOffset          = 0x2e0;
			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			ParentProcessIdOffset        = 0x290;
			break;
		}
	case WINDOWS_XP:
		{
			ImageFileNameOffset          = 0x174;
			PreviousModeOffsetOf_KTHREAD = 0x140;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;
			ParentProcessIdOffset        = 0x14c;
			ObjectHeaderSize             = 0x18;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			break;
		}
	}
}


//////////////////////////////////////////////////////////////////////////
// 进程
//////////////////////////////////////////////////////////////////////////



NTSTATUS HsGetSystemProcessCount(ULONG_PTR* ulRetCount)
{
	NTSTATUS            Status = STATUS_UNSUCCESSFUL;
	ULONG_PTR           iPid = 0;
	PEPROCESS           EProcess = NULL;


	//////////////////////////////////////////////////////////////////////////



	// 	EThread = PsGetCurrentThread();
	// 	PreMode = HsChangePreMode(EThread);


	for (iPid = 0; iPid < MAX_PROCESS_COUNT; iPid += 4)
	{

		//通过ID 得到 Handle

		if (!iPid)
		{
			(*ulRetCount) += 1;
			continue;
		}
		else if (ulCurrentProcessId == iPid)
		{
			(*ulRetCount) += 1;
			continue;
		}

		Status = PsLookupProcessByProcessId((HANDLE)iPid,&EProcess);   //System   Session  Native API   

		if (NT_SUCCESS(Status)&& !HsIsProcessDie(EProcess))
		{
			(*ulRetCount) += 1;
			ObDereferenceObject(EProcess);
		}
		//memset(&oa,0,sizeof(OBJECT_ATTRIBUTES));
	}

	return Status;
}



//内存清零法结束进程
NTSTATUS HsKillProcessByZeroMemory(ULONG_PTR ProcessID, int* bFeedBack)
{

	OBJECT_ATTRIBUTES oa = {0};
	CLIENT_ID         Cid = {0};
	NTSTATUS  Status;
	HANDLE hProcess = NULL;

	Cid.UniqueProcess = (HANDLE)ProcessID;
	Cid.UniqueThread = 0;


	Status = ZwOpenProcess(&hProcess,GENERIC_ALL,&oa,&Cid);




	if (!NT_SUCCESS(Status))
	{

		return FALSE;
	}

	ZwTerminateProcess(hProcess,0);   //Sys

	ZwClose(hProcess);

	*bFeedBack = TRUE;

 	return Status;
}



NTSTATUS HsEnumSystemProcessList(ULONG_PTR ulBasePid, PHSPROCESSINFO plProcessList, ULONG_PTR* ulRet)
{
	NTSTATUS            Status = STATUS_UNSUCCESSFUL;
	ULONG_PTR           iPid = 0;
	OBJECT_ATTRIBUTES   oa = {0};
	CLIENT_ID           Cid = {0};
	HANDLE              hProcess = NULL;
	PEPROCESS           EProcess = NULL;

	WCHAR				szImageFilePath[260] = {0};

	ULONG_PTR	        ulParentPid = 0;

	//////////////////////////////////////////////////////////////////////////

// 	EThread = PsGetCurrentThread();
// 	PreMode = HsChangePreMode(EThread);

	for (iPid = ulBasePid; iPid < MAX_PROCESS_COUNT; iPid += 4)
	{
		Cid.UniqueProcess = (HANDLE)iPid;
		Cid.UniqueThread = 0;

		//通过ID 得到 Handle

		if (!iPid)
		{
			plProcessList->Pid = iPid;
			plProcessList->PPid = 0;
			plProcessList->Eprocess = (ULONG_PTR)HsGetIdleEProcess();

			break;
		}

		if (ulCurrentProcessId == iPid)
		{
			EProcess = PsGetCurrentProcess();
			goto NEXT;
		}

		Status = ZwOpenProcess(&hProcess,GENERIC_ALL,&oa,&Cid);   //System   Session  Native API   

		if (NT_SUCCESS(Status))
		{
			DbgPrint("PID : %d\r\n",iPid);

			//转换 Handle  成 EProcess

			ObReferenceObjectByHandle(hProcess,GENERIC_ALL,NULL,KernelMode,(PVOID*)&EProcess,NULL);

NEXT:
			if(HsIsRealProcess(EProcess))	//判断是否僵尸进程
			{

				ulParentPid = HsGetParentProcessIdByEProcess(EProcess);

				plProcessList->Pid = iPid;

				plProcessList->PPid = ulParentPid;
				
				DbgPrint("NAME: %s\r\n",(char*)((ULONG_PTR)EProcess + ImageFileNameOffset));
				
				HsGetProcessPathBySectionObject(iPid,szImageFilePath);
				
				memcpy(plProcessList->Path,szImageFilePath,sizeof(szImageFilePath));

				memset(szImageFilePath,0,sizeof(szImageFilePath));

				DbgPrint("EPRO: 0x%x\r\n",(ULONG_PTR)EProcess);

				plProcessList->Eprocess = (ULONG_PTR)EProcess;

				ObDereferenceObject(EProcess);

				ZwClose(hProcess);

				break;
			}

			ObDereferenceObject(EProcess);

			ZwClose(hProcess);
		}
		memset(&oa,0,sizeof(OBJECT_ATTRIBUTES));
	}

	Status = STATUS_SUCCESS;

	if (iPid >= MAX_PROCESS_COUNT)
	{
		plProcessList->Eprocess = 0;
		plProcessList->PPid = 0;
		*ulRet = 0;
		Status = STATUS_UNSUCCESSFUL;
	}

	//HsRecoverPreMode(EThread, PreMode);

	return Status;
}



BOOLEAN HsIsRealProcess(PEPROCESS EProcess) 
{ 
	ULONG_PTR ObjectType; 
	ULONG_PTR    ObjectTypeAddress; 
	BOOLEAN bRet = FALSE;

	ULONG_PTR ProcessType = ((ULONG_PTR)*PsProcessType);

	if (ProcessType && MmIsAddressValid && EProcess && MmIsAddressValid((PVOID)(EProcess)))
	{ 
		ObjectType = HsKeGetObjectType((PVOID)EProcess);
		if (ObjectType && 
			ProcessType == ObjectType &&
			!HsIsProcessDie(EProcess))
		{
			bRet = TRUE; 
		}
	} 

	return bRet; 
} 


BOOLEAN HsIsProcessDie(PEPROCESS EProcess)
{
	BOOLEAN bDie = FALSE;

	if (MmIsAddressValid &&
		EProcess && 
		MmIsAddressValid(EProcess) &&
		MmIsAddressValid((PVOID)((ULONG_PTR)EProcess + ObjectTableOffsetOf_EPROCESS)))
	{
		PVOID ObjectTable = *(PVOID*)((ULONG_PTR)EProcess + ObjectTableOffsetOf_EPROCESS );

		if (!ObjectTable||!MmIsAddressValid(ObjectTable) )
		{
			DbgPrint("Process is Die\r\n");
			bDie = TRUE;
		}
	}
	else
	{
		DbgPrint("Process is Die2\r\n");
		bDie = TRUE;
	}
	return bDie;
}




CHAR HsChangePreMode(PETHREAD EThread)
{

	CHAR PreMode = *(PCHAR)((ULONG_PTR)EThread + PreviousModeOffsetOf_KTHREAD);
	*(PCHAR)((ULONG_PTR)EThread + PreviousModeOffsetOf_KTHREAD) = KernelMode;
	return PreMode;
}


VOID HsRecoverPreMode(PETHREAD EThread, CHAR PreMode)
{
	*(PCHAR)((ULONG_PTR)EThread + PreviousModeOffsetOf_KTHREAD) = PreMode;
}






BOOLEAN HsGetProcessPathBySectionObject(ULONG_PTR ulProcessID,WCHAR* wzProcessPath)
{
	PEPROCESS         EProcess = NULL;
	PSECTION_OBJECT   SectionObject   = NULL;
	PSECTION_OBJECT64 SectionObject64 = NULL;
	PSEGMENT        Segment   = NULL;
	PSEGMENT64      Segment64 = NULL;
	PCONTROL_AREA   ControlArea = NULL;
	PCONTROL_AREA64 ControlArea64 = NULL;
	PFILE_OBJECT    FileObject  = NULL;
	BOOLEAN         bGetPath = FALSE;

	if (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)ulProcessID, &EProcess)))
	{

		switch(WinVersion)
		{
		case WINDOWS_XP:
			{
				SectionObjectOffsetOfEProcess  = 0x138;

				if (SectionObjectOffsetOfEProcess!=0&&MmIsAddressValid((PVOID)((ULONG_PTR)EProcess + SectionObjectOffsetOfEProcess)))
				{
					SectionObject = *(PSECTION_OBJECT*)((ULONG_PTR)EProcess + SectionObjectOffsetOfEProcess);

					if (SectionObject && MmIsAddressValid(SectionObject))
					{

						Segment = (PSEGMENT)SectionObject->Segment;
						if (Segment && MmIsAddressValid(Segment))
						{
							ControlArea = Segment->ControlArea;
							if (ControlArea && MmIsAddressValid(ControlArea))
							{
								FileObject = ControlArea->FilePointer;

								if (FileObject&&MmIsAddressValid(FileObject))
								{
									bGetPath = HsGetPathByFileObject(FileObject, wzProcessPath);
									if (!bGetPath)
									{
										DbgPrint("SectionObject: 0x%08X, FileObject: 0x%08X\n", SectionObject, FileObject);
									}
								}
							}
						}
					}
				}
				break;
			}

		case WINDOWS_7:
			{
				SectionObjectOffsetOfEProcess = 0x268;


				if (SectionObjectOffsetOfEProcess!=0&&MmIsAddressValid((PVOID)((ULONG_PTR)EProcess + SectionObjectOffsetOfEProcess)))
				{
					SectionObject64 = *(PSECTION_OBJECT64*)((ULONG_PTR)EProcess + SectionObjectOffsetOfEProcess);



					if (SectionObject64 && MmIsAddressValid(SectionObject64))
					{

						Segment64 = (PSEGMENT64)(SectionObject64->Segment);
						if (Segment64 && MmIsAddressValid(Segment64))
						{
							ControlArea64 = (PCONTROL_AREA64)Segment64->ControlArea;
							if (ControlArea64 && MmIsAddressValid(ControlArea64))
							{
								FileObject = (PFILE_OBJECT)ControlArea64->FilePointer;

								if (FileObject&&MmIsAddressValid(FileObject))
								{
									FileObject = (PFILE_OBJECT)((ULONG_PTR)FileObject & 0xFFFFFFFFFFFFFFF0);
									bGetPath = HsGetPathByFileObject(FileObject, wzProcessPath);
									if (!bGetPath)
									{
										DbgPrint("SectionObject: 0x%08X, FileObject: 0x%08X\n", SectionObject, FileObject);
									}
								}
							}
						}
					}
				}
				break;
			}
		}
	}

	if (bGetPath==FALSE)
	{
		wcscpy(wzProcessPath,L"Unknow");
	}

	return bGetPath;
}


BOOLEAN HsGetPathByFileObject(PFILE_OBJECT FileObject, WCHAR* wzPath)
{
	BOOLEAN bGetPath = FALSE;
	CHAR szIoQueryFileDosDeviceName[] = "IoQueryFileDosDeviceName";
	CHAR szIoVolumeDeviceToDosName[] = "IoVolumeDeviceToDosName";
	CHAR szRtlVolumeDeviceToDosName[] = "RtlVolumeDeviceToDosName";

	POBJECT_NAME_INFORMATION ObjectNameInformation = NULL;
	__try
	{
		if (FileObject && MmIsAddressValid(FileObject) && wzPath)
		{

			if (NT_SUCCESS(IoQueryFileDosDeviceName(FileObject,&ObjectNameInformation)))   //注意该函数调用后要释放内存
			{
				wcsncpy(wzPath,ObjectNameInformation->Name.Buffer,ObjectNameInformation->Name.Length);

				bGetPath = TRUE;

				ExFreePool(ObjectNameInformation);
			}

			if (!bGetPath)
			{

				if (IoVolumeDeviceToDosName||RtlVolumeDeviceToDosName)
				{
					NTSTATUS  Status = STATUS_UNSUCCESSFUL;
					ULONG_PTR ulRet= 0;
					PVOID     Buffer = ExAllocatePool(PagedPool,0x1000);

					if (Buffer)
					{
						// ObQueryNameString : \Device\HarddiskVolume1\Program Files\VMware\VMware Tools\VMwareTray.exe
						memset(Buffer, 0, 0x1000);
						Status = ObQueryNameString(FileObject, (POBJECT_NAME_INFORMATION)Buffer, 0x1000, &ulRet);
						if (NT_SUCCESS(Status))
						{
							POBJECT_NAME_INFORMATION Temp = (POBJECT_NAME_INFORMATION)Buffer;

							WCHAR szHarddiskVolume[100] = L"\\Device\\HarddiskVolume";

							if (Temp->Name.Buffer!=NULL)
							{
								if (Temp->Name.Length / sizeof(WCHAR) > wcslen(szHarddiskVolume) &&
									!_wcsnicmp(Temp->Name.Buffer, szHarddiskVolume, wcslen(szHarddiskVolume)))
								{
									// 如果是以 "\\Device\\HarddiskVolume" 这样的形式存在的，那么再查询其卷名。
									UNICODE_STRING uniDosName;

									if (NT_SUCCESS(IoVolumeDeviceToDosName(FileObject->DeviceObject, &uniDosName)))
									{
										if (uniDosName.Buffer!=NULL)
										{

											wcsncpy(wzPath, uniDosName.Buffer, uniDosName.Length);
											wcsncat(wzPath, Temp->Name.Buffer + wcslen(szHarddiskVolume) + 1, Temp->Name.Length - (wcslen(szHarddiskVolume) + 1));
											bGetPath = TRUE;
										}	

										ExFreePool(uniDosName.Buffer);
									}

									else if (NT_SUCCESS(RtlVolumeDeviceToDosName(FileObject->DeviceObject, &uniDosName)))
									{
										if (uniDosName.Buffer!=NULL)
										{

											wcsncpy(wzPath, uniDosName.Buffer, uniDosName.Length);
											wcsncat(wzPath, Temp->Name.Buffer + wcslen(szHarddiskVolume) + 1, Temp->Name.Length - (wcslen(szHarddiskVolume) + 1));
											bGetPath = TRUE;
										}	

										ExFreePool(uniDosName.Buffer);
									}

								}
								else
								{
									// 如果不是以 "\\Device\\HarddiskVolume" 这样的形式开头的，那么直接复制名称。

									wcsncpy(wzPath, Temp->Name.Buffer, Temp->Name.Length);
									bGetPath = TRUE;
								}
							}
						}

						ExFreePool(Buffer);
					}
				}
			}
		}
	}
	__except(1)
	{
		DbgPrint("HsGetPathByFileObject Catch __Except\r\n");
		bGetPath = FALSE;
	}

	return bGetPath;
}


ULONG_PTR HsGetParentProcessIdByEProcess(PEPROCESS EProcess)
{
	if (MmIsAddressValid &&
		EProcess && 
		MmIsAddressValid(EProcess) &&
		MmIsAddressValid((PVOID)((ULONG_PTR)EProcess + ObjectTableOffsetOf_EPROCESS)))
	{
		ULONG_PTR ulParentPid = 0;

		ulParentPid = *(ULONG_PTR*)((ULONG_PTR)EProcess + ParentProcessIdOffset);
		
		return ulParentPid;
	}

	return 0;
}



PEPROCESS HsGetIdleEProcess()
{
	ULONG_PTR uIdleAddr = 0;
	ULONG_PTR PsInitialSystemProcessAddress = (ULONG_PTR)&PsInitialSystemProcess;


	DbgPrint("%x\r\n",PsInitialSystemProcessAddress);
	switch (WinVersion)
	{
	case WINDOWS_7:
		{
			if (PsInitialSystemProcessAddress && MmIsAddressValid((PVOID)((ULONG_PTR)PsInitialSystemProcessAddress + 0xA0)))
			{
				uIdleAddr = *(PULONG_PTR)((ULONG_PTR)PsInitialSystemProcessAddress + 0xA0);	//0xA0原来的

				if (uIdleAddr <=0xffff)
				{
					uIdleAddr = *(PULONG_PTR)((ULONG_PTR)PsInitialSystemProcessAddress + 0xB0);	//0xB0更新后的
				}
			}
			break;
		}
	case WINDOWS_XP:
		{
			if (PsInitialSystemProcessAddress && MmIsAddressValid((PVOID)((ULONG_PTR)PsInitialSystemProcessAddress - 0x78B4)))
			{
				uIdleAddr = (ULONG_PTR)((ULONG_PTR)PsInitialSystemProcessAddress - 0x78B4);
			}
			break;
		}
	}

	DbgPrint("IdleEProcess:%p\r\n",uIdleAddr);

	return (PEPROCESS)uIdleAddr;

}




BOOLEAN
HsGetProcessCreateTime(ULONG_PTR ProcessID,LONGLONG* OutputBuffer)
{

	NTSTATUS  Status;
	PEPROCESS EProcess = NULL;
	PETHREAD EThread = NULL;
	CHAR     PreMode = 0;

	Status = PsLookupProcessByProcessId((HANDLE)ProcessID,&EProcess);


	if (!NT_SUCCESS(Status))
	{
		return FALSE;
	}

	EThread = PsGetCurrentThread();
	PreMode = HsChangePreMode(EThread);

	*OutputBuffer = PsGetProcessCreateTimeQuadPart(EProcess);

	HsRecoverPreMode(EThread, PreMode);
	ObfDereferenceObject(EProcess);

	return TRUE;
}


```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Process.h`:

```h
/**************************************************************************************
* AUTHOR : HeavenShadow
* DATE   : 2014-10-28
* MODULE : Process.h
*
* Command: 
*	进程大功能的主文件
*
* Description:
*	与进程相关的所有功能集合文件
*
****************************************************************************************
* Copyright (C) 2015 HeavenShadow.
****************************************************************************************/

#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"



typedef struct HS_PROCESSINFO
{
	WCHAR       Name[100];
	WCHAR       Path[260];
	WCHAR       CompanyName[100];
	INT         UserAccess;
	ULONG_PTR   Pid;
	ULONG_PTR   PPid;
	ULONG_PTR   Eprocess;
	LONGLONG    CreateTime;
}HSPROCESSINFO, *PHSPROCESSINFO;



typedef struct _CONTROL_AREA64
{
	PVOID64 Segment;
	PVOID64 p1;
	PVOID64 p2;
	ULONG64 NumberOfSectionReferences;
	ULONG64 NumberOfPfnReferences;
	ULONG64 NumberOfMappedViews;
	ULONG64 NumberOfUserReferences;
	union
	{
		ULONG LongFlags;
		ULONG Flags;
	} u;
	PVOID64 FilePointer;
} CONTROL_AREA64, *PCONTROL_AREA64;



typedef struct _CONTROL_AREA
{
	PVOID Segment;
	LIST_ENTRY DereferenceList;
	ULONG NumberOfSectionReferences;
	ULONG NumberOfPfnReferences;
	ULONG NumberOfMappedViews;
	ULONG NumberOfSystemCacheViews;
	ULONG NumberOfUserReferences;
	union
	{
		ULONG LongFlags;
		ULONG Flags;
	} u;
	PFILE_OBJECT FilePointer;
} CONTROL_AREA, *PCONTROL_AREA;




typedef struct _SEGMENT64
{
	PVOID64 ControlArea;
	ULONG TotalNumberOfPtes;
	ULONG NonExtendedPtes;
	ULONG Spare0;
}SEGMENT64,*PSEGMENT64;


typedef struct _SEGMENT
{
	struct _CONTROL_AREA *ControlArea;
	ULONG TotalNumberOfPtes;
	ULONG NonExtendedPtes;
	ULONG Spare0;
} SEGMENT, *PSEGMENT;




typedef struct _SECTION_OBJECT
{
	PVOID StartingVa;
	PVOID EndingVa;
	PVOID Parent;
	PVOID LeftChild;
	PVOID RightChild;
	PSEGMENT Segment;
} SECTION_OBJECT, *PSECTION_OBJECT;


typedef struct _SECTION_OBJECT64
{
	PVOID64 StartingVa;
	PVOID64 EndingVa;
	PVOID64 Parent;
	PVOID64 LeftChild;
	PVOID64 RightChild;
	PVOID64 Segment;
} SECTION_OBJECT64, *PSECTION_OBJECT64;


//////////////////////////////////////////////////////////////////////////
//句柄结构
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;


typedef struct _HS_HANDLE_INFO{
	UCHAR  ObjectTypeIndex;
	USHORT HandleValue;
	WCHAR  HandleObjectName[100];
	WCHAR  HandleTypeName[100];
	PVOID  Object;
	ULONG_PTR HandleCount;
}HSHANDLEINFO, *PHSHANDLEINFO;

typedef struct _HS_HANDLE {
	ULONG NumberOfHandles;
	HSHANDLEINFO Handles[1];
}HSHANDLE, *PHSHANDLE;


//////////////////////////////////////////////////////////////////////////


typedef struct _MODULE_INFO_
{
	ULONG_PTR Base;
	ULONG_PTR Size;
	WCHAR Path[260]; 
}MODULE_INFO, *PMODULE_INFO;

typedef struct _ALL_MODULES_
{
	ULONG_PTR   ulCount;
	MODULE_INFO Modules[1];
}ALL_MODULES, *PALL_MODULES;

typedef struct _PEB_LDR_DATA32 
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _PEB_LDR_DATA64 
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY64 InLoadOrderModuleList;
	LIST_ENTRY64 InMemoryOrderModuleList;
	LIST_ENTRY64 InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN  ShutdownInProgress;
	PVOID    ShutdownThreadId;
} PEB_LDR_DATA64, *PPEB_LDR_DATA64;


typedef struct _LDR_DATA_TABLE_ENTRY64
{
	LIST_ENTRY64	InLoadOrderLinks;
	LIST_ENTRY64	InMemoryOrderLinks;
	LIST_ENTRY64	InInitializationOrderLinks;
	PVOID			DllBase;
	PVOID			EntryPoint;
	ULONG			SizeOfImage;
	UNICODE_STRING	FullDllName;
	UNICODE_STRING 	BaseDllName;
	ULONG			Flags;
	USHORT			LoadCount;
	USHORT			TlsIndex;
	PVOID			SectionPointer;
	ULONG			CheckSum;
	PVOID			LoadedImports;
	PVOID			EntryPointActivationContext;
	PVOID			PatchInformation;
	LIST_ENTRY64	ForwarderLinks;
	LIST_ENTRY64	ServiceTagLinks;
	LIST_ENTRY64	StaticLinks;
	PVOID			ContextInformation;
	ULONG64			OriginalBase;
	LARGE_INTEGER	LoadTime;
} LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;



typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union {
		LIST_ENTRY HashLinks;
		struct {
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union {
		struct {
			ULONG TimeDateStamp;
		};
		struct {
			PVOID LoadedImports;
		};
	};
} LDR_DATA_TABLE_ENTRY,*PLDR_DATA_TABLE_ENTRY;

//////////////////////////////////////////////////////////////////////////



NTKERNELAPI VOID NTAPI KeAttachProcess(PEPROCESS Process);
NTKERNELAPI VOID NTAPI KeDetachProcess();




/***************************************************************************************
* NAME:			HsDispatchControlForProcess
*
* DESCRIPTION:	自定义的进程大功能DispatchControl判断函数，由主DispatchControl调用
*					
* PARAMETERS:		IrpSp				IN		IrpSp栈的地址
*					OutputBuffer		IN		应用层UserBuffer的地址
*                   ulRet               Out     返回长度的值的地址
*
* RETURNS:		NTSTATUS
*
* NOTES:		在这个函数中，只传入上述两个参数，其他参数不传入。
				返回结果到主DIspatchControl函数中。
****************************************************************************************/
NTSTATUS HsDispatchControlForProcess(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet);


/***************************************************************************************
* NAME:			HsEnumSystemProcessList
*
* DESCRIPTION:	查询系统进程列表的例程。通过该函数将进城信息List写入应用层UserBuffer中。
*					
* PARAMETERS:		OutputBuffer		IN		应用层UserBuffer的地址
*
* RETURNS:		NTSTATUS
****************************************************************************************/
NTSTATUS HsEnumSystemProcessList(ULONG_PTR ulBasePid, PHSPROCESSINFO plProcessList, ULONG_PTR* ulRet);





VOID HsInitProcessGlobalVariable();


BOOLEAN HsGetProcessPathBySectionObject(ULONG_PTR ulProcessID,WCHAR* wzProcessPath);
BOOLEAN HsGetPathByFileObject(PFILE_OBJECT FileObject, WCHAR* wzPath);


BOOLEAN HsIsRealProcess(PEPROCESS EProcess);
BOOLEAN HsIsProcessDie(PEPROCESS EProcess);

ULONG_PTR HsGetParentProcessIdByEProcess(PEPROCESS EProcess);

PEPROCESS HsGetIdleEProcess();

NTSTATUS HsGetSystemProcessCount(ULONG_PTR* ulRetCount);



//内存清零法结束进程
NTSTATUS HsKillProcessByZeroMemory(ULONG_PTR ProcessID, int* bFeedBack);


//获取进程创建时间
BOOLEAN
HsGetProcessCreateTime(ULONG_PTR ProcessID,LONGLONG* OutputBuffer);
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/SysThread.c`:

```c
#include "SysThread.h"
#include "System.h"


extern PDRIVER_OBJECT	g_DriverObject;
extern WIN_VERSION		WinVersion;
extern ULONG_PTR		SYSTEM_ADDRESS_START;
extern ULONG_PTR		ObjectHeaderSize;
extern ULONG_PTR		ObjectTypeOffsetOf_Object_Header;
extern ULONG_PTR		ObjectTableOffsetOf_EPROCESS;
extern ULONG_PTR		TebOffset;
extern ULONG_PTR		PriorityOffset;
extern ULONG_PTR		ContextSwitchesOffset;
extern ULONG_PTR		StateOffset;
extern ULONG_PTR		Win32StartAddressOffset;
extern ULONG_PTR		StartAddressOffset;
extern ULONG_PTR		SameThreadApcFlags;
extern PVOID			Ntoskrnl_KLDR_DATA_TABLE_ENTRY;

extern PEPROCESS		SystemEProcess;

ULONG_PTR		ulOffset = 0;
ULONG_PTR		ulImageNameOffset = 0;
ULONG_PTR		ulPspCidTable = 0;






NTSTATUS HsEnumSysThread(PVOID OutBuffer, ULONG_PTR OutSize)
{
	NTSTATUS Status;
	PETHREAD EThread;
	CHAR PreMode;

	ULONG_PTR ulCnt = (OutSize - sizeof(ALL_THREADS)) / sizeof(THREAD_INFO);

	//////////////////////////////////////////////////////////////////////////
	
	EThread = PsGetCurrentThread();
	PreMode = HsChangePreMode(EThread);
	
	HsSetGolbalMemberSysThread();
	ulPspCidTable = HsGetPspCidTableValue();
	if ( ulPspCidTable == 0 )  
	{  
		return STATUS_UNSUCCESSFUL;
	}  

	HsRecoverPreMode(EThread, PreMode);

	//////////////////////////////////////////////////////////////////////////

	ScanHandleTableToFindThread(SystemEProcess, (PALL_THREADS)OutBuffer, ulCnt);
	if (ulCnt >= ((PALL_THREADS)OutBuffer)->nCnt)
	{
		Status = STATUS_SUCCESS;
	}
	else
	{
		Status = STATUS_BUFFER_TOO_SMALL;
	}

	return Status;
}



ULONG_PTR HsGetPspCidTableValue()  
{  
	PVOID PsLookupProcessByProcessIdAddress = NULL;  
	ULONG_PTR ulPspCidTableValue = 0;  
	UNICODE_STRING uniFuncName; 
	ULONG  uIndex = 0;
	int    Offset = 0;

	// 获取PsLookupProcessByProcessId的函数地址   
	RtlInitUnicodeString(&uniFuncName, L"PsLookupProcessByProcessId");    //从Ntos导出表中获得函数PsLookupProcessByProcessId地址
	PsLookupProcessByProcessIdAddress = MmGetSystemRoutineAddress(&uniFuncName);  
	if (PsLookupProcessByProcessIdAddress== NULL )  
	{  
		return ulPspCidTableValue;  
	}  
	DbgPrint("PsLookupProcessByProcessId->%08X",PsLookupProcessByProcessIdAddress);  

	switch(WinVersion)
	{
	case WINDOWS_7:
		{
			/*
			kd> u PsLookupProcessByProcessId l 20
			nt!PsLookupProcessByProcessId:
			fffff800`041a61fc 48895c2408      mov     qword ptr [rsp+8],rbx
			fffff800`041a6201 48896c2410      mov     qword ptr [rsp+10h],rbp
			fffff800`041a6206 4889742418      mov     qword ptr [rsp+18h],rsi
			fffff800`041a620b 57              push    rdi
			fffff800`041a620c 4154            push    r12
			fffff800`041a620e 4155            push    r13
			fffff800`041a6210 4883ec20        sub     rsp,20h
			fffff800`041a6214 65488b3c2588010000 mov   rdi,qword ptr gs:[188h]
			fffff800`041a621d 4533e4          xor     r12d,r12d
			fffff800`041a6220 488bea          mov     rbp,rdx
			fffff800`041a6223 66ff8fc4010000  dec     word ptr [rdi+1C4h]
			fffff800`041a622a 498bdc          mov     rbx,r12
			fffff800`041a622d 488bd1          mov     rdx,rcx
			fffff800`041a6230 488b0d9149edff  mov     rcx,qword ptr [nt!PspCidTable (fffff800`0407abc8)]
			fffff800`041a6237 e834480200      call    nt!ExMapHandleToPointer (fffff800`041caa70)
			*/
			for (uIndex=0;uIndex<0x1000;uIndex++ )  
			{  
				if (*((PUCHAR)((ULONG_PTR)PsLookupProcessByProcessIdAddress+ uIndex)) == 0x48 &&  
					*((PUCHAR)((ULONG_PTR)PsLookupProcessByProcessIdAddress+ uIndex + 1) ) == 0x8B &&  
					*((PUCHAR)((ULONG_PTR)PsLookupProcessByProcessIdAddress+ uIndex + 7) ) == 0xE8 )  
				{  
			
					memcpy(&Offset,(PUCHAR)((ULONG_PTR)PsLookupProcessByProcessIdAddress+ uIndex + 3),4);
					ulPspCidTableValue = (ULONG_PTR)PsLookupProcessByProcessIdAddress+uIndex+Offset+7; 

					DbgPrint("Found OK!!\r\n");
					break;  
				}  
			}  
			break;
		}

	case WINDOWS_XP:
		{
			/*
			kd> u PsLookupProcessByProcessId l 20
			nt!PsLookupProcessByProcessId:
			80582687 8bff            mov     edi,edi
			80582689 55              push    ebp
			8058268a 8bec            mov     ebp,esp
			8058268c 53              push    ebx
			8058268d 56              push    esi
			8058268e 64a124010000    mov     eax,dword ptr fs:[00000124h]
			80582694 ff7508          push    dword ptr [ebp+8]
			80582697 8bf0            mov     esi,eax
			80582699 ff8ed4000000    dec     dword ptr [esi+0D4h]
			8058269f ff3560a75680    push    dword ptr [nt!PspCidTable (8056a760)]

			*/
	    	for (uIndex = 0; uIndex < 0x1000; uIndex++ )  
			{  
				if ( *( (PUCHAR)((ULONG_PTR)PsLookupProcessByProcessIdAddress+ uIndex) ) == 0xFF &&  
					*( (PUCHAR)((ULONG_PTR)PsLookupProcessByProcessIdAddress+ uIndex + 1) ) == 0x35 &&  
					*( (PUCHAR)((ULONG_PTR)PsLookupProcessByProcessIdAddress+ uIndex + 6) ) == 0xE8 )  
				{  
					DbgPrint("Found OK!!\r\n");  
					ulPspCidTableValue = *((PULONG)((ULONG)PsLookupProcessByProcessIdAddress+ uIndex + 2) );  
					break;  
				}  
			}  
			break;
		}
	}

	return ulPspCidTableValue;  
}  




VOID ScanHandleTableToFindThread(PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt)
{
	PHANDLE_TABLE   HandleTable = NULL;    // 指向句柄表的指针   
	ULONG_PTR uTableCode = 0;  
	ULONG uFlag = 0;


	HandleTable = (PHANDLE_TABLE)(*(ULONG_PTR*)ulPspCidTable);  

	if (HandleTable && MmIsAddressValid((PVOID)HandleTable))
	{
		uTableCode = (ULONG_PTR)(HandleTable->TableCode) & 0xFFFFFFFFFFFFFFFC;  ;
		if (uTableCode && MmIsAddressValid((PVOID)uTableCode))
		{
			uFlag = (ULONG)(HandleTable->TableCode) & 0x03;    //00  01  10  

			switch (uFlag)
			{
			case 0:
				{
					EnumTable1(uTableCode, EProcess, AllThreads, ulCnt);
					break;
				}
			case 1:
				{
					EnumTable2(uTableCode, EProcess, AllThreads, ulCnt);
					break;
				}


			case 2:
				{
					EnumTable3(uTableCode, EProcess, AllThreads, ulCnt);
					break; 
				}


			default:
				KdPrint(("TableCode error\n"));
			} 			
		}
	}
}



NTSTATUS EnumTable1(ULONG_PTR uTableCode, PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt)
{


	PVOID  Object = NULL;
	PHANDLE_TABLE_ENTRY HandleTableEntry = NULL;  
	ULONG uIndex = 0;


	HandleTableEntry = (PHANDLE_TABLE_ENTRY)((ULONG_PTR)(*(ULONG_PTR*)uTableCode) + ulOffset);  

	for (uIndex = 0;uIndex<0x200; uIndex++ )  
	{  
		if (MmIsAddressValid((PVOID)&(HandleTableEntry->NextFreeTableEntry)))
		{
			if (HandleTableEntry->NextFreeTableEntry==0)
			{
				if (HandleTableEntry->Object != NULL )  
				{  

					if (MmIsAddressValid(HandleTableEntry->Object))
					{

						Object = (PVOID)(((ULONG_PTR)HandleTableEntry->Object)  & 0xFFFFFFFFFFFFFFF8);  
						InsertThread((PETHREAD)Object,EProcess,AllThreads, ulCnt);

					}

				}
			}

		}

		HandleTableEntry++;  

	}  
}



NTSTATUS EnumTable2(ULONG_PTR uTableCode, PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt)
{
	do   
	{  
		EnumTable1(uTableCode,EProcess,AllThreads,ulCnt);  
		uTableCode += sizeof(ULONG_PTR);  
	} while (*(PULONG_PTR)uTableCode != 0&&MmIsAddressValid((PVOID)*(PULONG_PTR)uTableCode));  

	return STATUS_SUCCESS;
}



NTSTATUS EnumTable3(ULONG_PTR uTableCode, PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt)
{
	do   
	{  
		EnumTable2(uTableCode,EProcess,AllThreads,ulCnt);  
		uTableCode += sizeof(ULONG_PTR);  
	} while (*(PULONG_PTR)uTableCode != 0);  

	return STATUS_SUCCESS;  
}


//////////////////////////////////////////////////////////////////////////

VOID HsSetGolbalMemberSysThread()
{
	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			ulOffset = 0x8;
			ulImageNameOffset = 0x174;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;
			ObjectHeaderSize = 0x18;
			SYSTEM_ADDRESS_START = 0x80000000;

			TebOffset = 0x020;
			PriorityOffset = 0x033;
			ContextSwitchesOffset = 0x04c;
			StateOffset = 0x02d;

			Win32StartAddressOffset = 0x228;
			StartAddressOffset = 0x224;
			SameThreadApcFlags = 0x250;
			break;
		}
	case WINDOWS_7:
		{
			ulOffset = 0x10;
			ulImageNameOffset = 0x2e0;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			ObjectHeaderSize = 0x30;
			SYSTEM_ADDRESS_START = 0x80000000000;
			TebOffset = 0x0b8;
			PriorityOffset = 0x07b;
			ContextSwitchesOffset = 0x134;
			StateOffset = 0x164;

			Win32StartAddressOffset = 0x410;
			StartAddressOffset = 0x388;
			SameThreadApcFlags = 0x450;
			break;
		}
	}
}
```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/SysThread.h`:

```h
#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"
#include "Thread.h"


typedef struct _HANDLE_TABLE64
{
	PVOID64 TableCode;
	PVOID64 QuotaProcess;
	PVOID64 UniqueProcessID;
	PVOID64 HandleLock;
	LIST_ENTRY HandleTableList;
	PVOID64    HandleContentionEvent;
	PVOID64    DebugInfo;
	ULONG      ExtraInfoPages;
	ULONG      Flags;
	ULONG      FirstFreeHandle;
	PVOID64    LastFreeHandleEntry;
	ULONG      HandleCount;
	ULONG      NextHandleNeedingPool;
	ULONG      HandleCountHighWatermark;
}HANDLE_TABLE64,*PHANDLE_TABLE64;



typedef struct _HANDLE_TABLE32
{
	PVOID TableCode;
	PVOID QuotaProcess;
	PVOID UniqueProcessID;
	ULONG HandleLock[4];
	LIST_ENTRY HandleTableList;
	PVOID    HandleContentionEvent;
	PVOID    DebugInfo;
	ULONG    ExtraInfoPages;
	ULONG    FirstFree;
	ULONG    LastFree;
	ULONG    NextHandleNeedingPool;
	ULONG    HandleCount;
	ULONG    Flags;
}HANDLE_TABLE32,*PHANDLE_TABLE32;

#ifdef _WIN64
#define PHANDLE_TABLE PHANDLE_TABLE64
#else
#define PHANDLE_TABLE PHANDLE_TABLE32
#endif

typedef struct _HANDLE_TABLE_ENTRY64 
{
	union {
		PVOID64 Object;
		ULONG ObAttributes;
		PVOID64 InfoTable;
		ULONG_PTR Value;
	};
	union {
		union {
			ULONG GrantedAccess;
			struct {
				USHORT GrantedAccessIndex;
				USHORT CreatorBackTraceIndex;
			};
		};
		ULONG NextFreeTableEntry;
	};

} HANDLE_TABLE_ENTRY64, *PHANDLE_TABLE_ENTRY64;


typedef struct _HANDLE_TABLE_ENTRY32 
{
	union {
		PVOID Object;
		ULONG ObAttributes;
		PVOID InfoTable;
		ULONG_PTR Value;
	};
	union {
		union {
			ULONG GrantedAccess;
			struct {
				USHORT GrantedAccessIndex;
				USHORT CreatorBackTraceIndex;
			};
		};
		ULONG NextFreeTableEntry;
	};

} HANDLE_TABLE_ENTRY32, *PHANDLE_TABLE_ENTRY32;


#ifdef _WIN64
#define PHANDLE_TABLE_ENTRY PHANDLE_TABLE_ENTRY64
#else
#define PHANDLE_TABLE_ENTRY PHANDLE_TABLE_ENTRY32
#endif



//////////////////////////////////////////////////////////////////////////


NTSTATUS HsEnumSysThread(PVOID OutBuffer, ULONG_PTR OutSize);

VOID HsSetGolbalMemberSysThread();

ULONG_PTR HsGetPspCidTableValue();

VOID ScanHandleTableToFindThread(PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt);

NTSTATUS EnumTable1(ULONG_PTR uTableCode, PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt);

NTSTATUS EnumTable2(ULONG_PTR uTableCode, PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt);

NTSTATUS EnumTable3(ULONG_PTR uTableCode, PEPROCESS EProcess, PALL_THREADS AllThreads, ULONG_PTR ulCnt);



```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/System.c`:

```c
#include "System.h"
#include "SysThread.h"
#include "IoTimer.h"
#include "CallBack.h"
#include "DpcTimer.h"
#include "FilterDriver.h"


#include "GetFuncAddress.h"
//////////////////////////////////////////////////////////////////////////
extern     PDEVICE_OBJECT g_DeviceObject;
extern     PDRIVER_OBJECT g_DriverObject;
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
extern POBJECT_TYPE *IoDriverObjectType;
extern POBJECT_TYPE *IoDeviceObjectType;
//////////////////////////////////////////////////////////////////////////

extern
	WIN_VERSION WinVersion;
extern
	ULONG_PTR PreviousModeOffsetOf_KTHREAD;
extern
	ULONG_PTR ObjectTableOffsetOf_EPROCESS;
extern
	ULONG_PTR SYSTEM_ADDRESS_START;
extern
	ULONG_PTR ObjectHeaderSize;
extern
	ULONG_PTR ObjectTypeOffsetOf_Object_Header;


extern ULONG_PTR
	ulBuildNumber;
//////////////////////////////////////////////////////////////////////////




NTSTATUS HsDispatchControlForSystem(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet)
{

	WCHAR* szOutputBuffer = (WCHAR*)OutputBuffer;
	ULONG				ulIoControlCode  = 0;
	NTSTATUS			Status = STATUS_UNSUCCESSFUL;
	PVOID               pvInputBuffer  = NULL;
	ULONG               ulInputLen     = 0;
	ULONG				ulOutputLen    = 0;

	pvInputBuffer   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
	ulInputLen      = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
	ProbeForRead(pvInputBuffer,ulInputLen,sizeof(CHAR));

	ulOutputLen     = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	ProbeForWrite(OutputBuffer,ulOutputLen,sizeof(CHAR));

	ulIoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	ulIoControlCode = (ulIoControlCode>>2)&0x00000FFF;

	DbgPrint("%x\r\n",ulIoControlCode);

	HsInitSystemGlobalVariable();

	switch(ulIoControlCode)
	{
	case HS_IOCTL_SYSK_SYSTHREAD:
		{
			DbgPrint("HS_IOCTL_SYSK_SYSTHREAD\r\n");

			Status = HsEnumSysThread(OutputBuffer, ulOutputLen);
			
			*ulRet = sizeof(ULONG_PTR);
			break;
		}
	case HS_IOCTL_SYSK_IOTIMER:		//枚举IOTIMER
		{
			DbgPrint("HS_IOCTL_SYSK_IOTIMER\r\n");

			Status = HsEnumIOTimer(OutputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_OPERIOTIMER:		//切换IOTIMER运行状态
		{
			DbgPrint("HS_IOCTL_SYSK_OPERIOTIMER\r\n");

			Status = HsOperIOTimer(pvInputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_REMOVEIOTIMER:
		{
			DbgPrint("HS_IOCTL_SYSK_REMOVEIOTIMER\r\n");

			Status =  RemoveIOTimer(pvInputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_DPCTIMER:		//枚举IOTIMER
		{
			DbgPrint("HS_IOCTL_SYSK_DPCTIMER\r\n");

			Status = HsEnumDPCTimer(OutputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_REMOVEDPCTIMER:
		{
			DbgPrint("HS_IOCTL_SYSK_REMOVEDPCTIMER\r\n");

			Status =  RemoveDPCTimer(pvInputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_CALLBACKLIST:
		{
			DbgPrint("HS_IOCTL_SYSK_CALLBACKLIST\r\n");

			Status = HsEnumCallBackList(*(int*)pvInputBuffer,OutputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_REMOVECALLBACK:
		{
			DbgPrint("HS_IOCTL_SYSK_REMOVECALLBACK\r\n");

			Status = RemoveCallbackNotify(pvInputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_FILTERDRIVER:
		{
			DbgPrint("HS_IOCTL_SYSK_FILTERDRIVER\r\n");

			Status = HsEnumFilterDriver((PFILTER_DRIVER)OutputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	case HS_IOCTL_SYSK_FILTERUNLOAD:
		{
			DbgPrint("HS_IOCTL_SYSK_FILTERUNLOAD\r\n");

			Status = HsUnloadFilterDriver((PUNLOAD_FILTER)pvInputBuffer);

			if (Status)
			{
				*ulRet = sizeof(ULONG_PTR);
			}
			break;
		}
	default:
		{
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	return Status;


}






//////////////////////////////////////////////////////////////////////////

VOID HsInitSystemGlobalVariable()
{
	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			PreviousModeOffsetOf_KTHREAD = 0x140;
			ObjectHeaderSize = 0x18;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;
			SYSTEM_ADDRESS_START = 0x80000000;
			break;
		}

	case WINDOWS_7:
		{
			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			ObjectHeaderSize = 0x30;
			SYSTEM_ADDRESS_START = 0x80000000000;
			break;
		}
	}
}



```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/System.h`:

```h
/**************************************************************************************
* AUTHOR : HeavenShadow
* DATE   : 2014-10-28
* MODULE : System.h
*
* Command: 
*	内核大功能的主文件
*
* Description:
*	与内核相关的所有功能集合文件
*
****************************************************************************************
* Copyright (C) 2015 HeavenShadow.
****************************************************************************************/


#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include "common.h"


#define MAX_PATH 260


NTSTATUS HsDispatchControlForSystem(PIO_STACK_LOCATION  IrpSp, PVOID OutputBuffer, ULONG_PTR* ulRet);

VOID HsInitSystemGlobalVariable();






```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Thread.c`:

```c
#include "Thread.h"



extern WIN_VERSION  WinVersion;

extern ULONG_PTR    ObjectHeaderSize;
extern ULONG_PTR    ObjectTypeOffsetOf_Object_Header;
extern ULONG_PTR    ObjectTableOffsetOf_EPROCESS;
extern ULONG_PTR    PreviousModeOffsetOf_KTHREAD;

extern ULONG_PTR    ulBuildNumber;

//////////////////////////////////////////////////////////////////////////
// 线程
//////////////////////////////////////////////////////////////////////////

//这是两个关于线程的链表
ULONG_PTR ThreadListHeadOffset = 0;
ULONG_PTR ThreadListEntryOffset = 0;
ULONG_PTR ThreadListHeadOffsetOther = 0;
ULONG_PTR ThreadListEntryOffsetOther =0;
ULONG_PTR ThreadsProcessOffset  = 0;
ULONG_PTR CidOffset = 0;
ULONG_PTR WinOffset = 0;
ULONG_PTR TebOffset = 0;
ULONG_PTR PriorityOffset = 0;
ULONG_PTR ContextSwitchesOffset = 0;
ULONG_PTR StateOffset = 0;
ULONG_PTR SystemRangeStart = 0;
ULONG_PTR Win32StartAddressOffset = 0;
ULONG_PTR StartAddressOffset = 0;
ULONG_PTR SameThreadApcFlags = 0;



NTSTATUS HsEnumProcessThread(PVOID ProcessId)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	PEPROCESS EProcess = NULL;

	PETHREAD            EThread = NULL;
	CHAR                PreMode = 0;

	DbgPrint("PID: %d\r\n",*((ULONG32*)ProcessId));



	status = PsLookupProcessByProcessId((HANDLE)*((ULONG*)ProcessId),&EProcess);

	if (status==STATUS_SUCCESS)
	{
		ObDereferenceObject(EProcess);
	}

	DbgPrint("%d\r\n",status);
	DbgPrint("%x\r\n",EProcess);


	HsEnumThreadByForce(EProcess);


	return STATUS_SUCCESS;
}



VOID
	HsEnumThreadByForce(PEPROCESS EProcess)
{
	NTSTATUS   Status;
	ULONG_PTR  i = 0;
	PEPROCESS  EProcessTemp;
	PETHREAD   EThread = NULL;

	for (i=0;i<100000;i+=4)
	{
		Status = PsLookupThreadByThreadId((HANDLE)i,&EThread);

		if (Status==STATUS_SUCCESS)
		{
			ObDereferenceObject(EThread);

			//通过线程体 获得进程体
			EProcessTemp = IoThreadToProcess(EThread);
			if (EProcessTemp==EProcess)
			{
				DbgPrint("[THREAD]ETHREAD=%p TID=%ld\n",
					EThread, 
					(ULONG)PsGetThreadId(EThread));
			}
		}
	}
}






VOID InitGlobalVariable()
{
	switch(WinVersion)
	{
	case WINDOWS_XP:
		{
			PreviousModeOffsetOf_KTHREAD = 0x140;
			ObjectHeaderSize = 0x18;
			ObjectTypeOffsetOf_Object_Header = 0x8;
			ObjectTableOffsetOf_EPROCESS = 0x0c4;


			Win32StartAddressOffset = 0x228;
			StartAddressOffset = 0x224;
			ThreadListHeadOffset = 0x050;
			ThreadListEntryOffset = 0x1b0;
			ThreadListHeadOffsetOther = 0x190;
			ThreadListEntryOffsetOther = 0x22c;
			ThreadsProcessOffset = 0x220;
			CidOffset  = 0x1ec;
			WinOffset = 4;
			TebOffset = 0x020;
			PriorityOffset = 0x033;
			ContextSwitchesOffset = 0x04c;
			StateOffset = 0x02d;
			SystemRangeStart = 0x80000000;
			SameThreadApcFlags = 0x250;
			break;
		}

	case WINDOWS_7:
		{
			PreviousModeOffsetOf_KTHREAD = 0x1f6;
			ObjectTableOffsetOf_EPROCESS = 0x200;
			ObjectHeaderSize = 0x30;
			SystemRangeStart = 0x80000000000;
			Win32StartAddressOffset = 0x410;	//0x410 0x418
			StartAddressOffset = 0x388;			//0x388 0x390
			ThreadListHeadOffset = 0x030;
			ThreadListEntryOffset = 0x2f8; 
			ThreadListHeadOffsetOther = 0x300;
			ThreadListEntryOffsetOther = 0x420;
			ThreadsProcessOffset = 0x210;
			CidOffset = 0x3b0;
			WinOffset = 8;
			TebOffset = 0x0b8;
			PriorityOffset = 0x07b;
			ContextSwitchesOffset = 0x134;
			StateOffset = 0x164;
			SameThreadApcFlags = 0x450;
			break;
		}
	}
}




NTSTATUS EnumProcessThread(PVOID InBuffer, ULONG InSize, PVOID OutBuffer, ULONG_PTR OutSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL, PsStatus = STATUS_UNSUCCESSFUL;

	PEPROCESS EProcess = NULL;
	ULONG_PTR ulPid = 0, ulCount = 0;

	ULONG_PTR  i = 0;
	PETHREAD   EThread = NULL;
	PEPROCESS  EProcessTemp;


	InitGlobalVariable();

	if (!InBuffer								||
		!OutBuffer								||
		InSize != sizeof(ULONG)					||
		OutSize < sizeof(ALL_THREADS))
	{
		return STATUS_INVALID_PARAMETER;
	}

	ulCount = (OutSize - sizeof(ALL_THREADS)) / sizeof(THREAD_INFO);

	ulPid = *(ULONG*)InBuffer;


	if (ulPid != 0)
	{
		PsStatus = PsLookupProcessByProcessId((HANDLE)ulPid, &EProcess);
		if (!NT_SUCCESS(PsStatus))
		{
			return STATUS_UNSUCCESSFUL;
		}
	}

	if (HsIsRealProcess(EProcess))
	{
		EnumThreads(EProcess, (PALL_THREADS)OutBuffer,ulCount);
		if (ulCount >= ((PALL_THREADS)OutBuffer)->nCnt)
		{
			Status = STATUS_SUCCESS;
		}
		else
		{
			Status = STATUS_BUFFER_TOO_SMALL;
		}
	}

	if (NT_SUCCESS(PsStatus))
	{
		ObfDereferenceObject(EProcess);
	}

	return Status;
}


VOID EnumThreads(PEPROCESS EProcess, PALL_THREADS ProcessThreads, ULONG_PTR ulCount)
{
	if (!EProcess || !ProcessThreads)
	{
		return;
	}

	EnumProcessThreadByList(EProcess,ProcessThreads,ulCount);
}



VOID EnumProcessThreadByList(PEPROCESS EProcess, PALL_THREADS ProcessThreads, ULONG_PTR ulCount)
{
// 	NTSTATUS Status = STATUS_UNSUCCESSFUL;
// 	ULONG_PTR  i = 0;
// 	PEPROCESS  EProcessTemp;
// 	PETHREAD   EThread = NULL;
// 	if (EProcess && MmIsAddressValid(EProcess))
// 	{
// 		for (i=0;i<100000;i+=4)
// 		{
// 			Status = PsLookupThreadByThreadId((HANDLE)i,&EThread);
// 
// 			if (Status==STATUS_SUCCESS)
// 			{
// 				ObDereferenceObject(EThread);
// 
// 				//通过线程体 获得进程体
// 				EProcessTemp = IoThreadToProcess(EThread);
// 				if (EProcessTemp==EProcess)
// 				{
// 
// 					DbgPrint("[THREAD]ETHREAD=%p TID=%ld\n",
// 						EThread, 
// 						(ULONG)PsGetThreadId(EThread));
// 
// 					InsertThread(EThread, EProcess, ProcessThreads, ulCount);
// 
// 				}
// 			}
// 		}
// 	}
	

	if (EProcess && MmIsAddressValid(EProcess))
	{
		PLIST_ENTRY  ListEntry = (PLIST_ENTRY)((ULONG_PTR)EProcess + ThreadListHeadOffset);
		if (ListEntry && MmIsAddressValid(ListEntry) && MmIsAddressValid(ListEntry->Flink))
		{
			KIRQL     OldIrql = KeRaiseIrqlToDpcLevel();
			ULONG_PTR nMaxCnt = PAGE_SIZE * 2;
			PLIST_ENTRY Temp = ListEntry->Flink;
			while (MmIsAddressValid(Temp) && Temp != ListEntry && nMaxCnt--)
			{
				PETHREAD EThread = (PETHREAD)((ULONG_PTR)Temp - ThreadListEntryOffset);
				InsertThread(EThread, EProcess, ProcessThreads, ulCount);
				Temp = Temp->Flink;
			}

			KeLowerIrql(OldIrql);
		}

		ListEntry = (PLIST_ENTRY)((ULONG)EProcess + ThreadListHeadOffsetOther);
		if (ListEntry && MmIsAddressValid(ListEntry) && MmIsAddressValid(ListEntry->Flink))
		{
			KIRQL     OldIrql = KeRaiseIrqlToDpcLevel();
			ULONG_PTR nMaxCnt = PAGE_SIZE * 2;
			PLIST_ENTRY Temp = ListEntry->Flink;
			while (MmIsAddressValid(Temp) && Temp != ListEntry && nMaxCnt--)
			{
				PETHREAD EThread = (PETHREAD)((ULONG_PTR)Temp - ThreadListEntryOffsetOther);
				InsertThread(EThread,EProcess, ProcessThreads,ulCount);
				Temp = Temp->Flink;
			}

			KeLowerIrql(OldIrql);
		}
	}
}




VOID InsertThread(PETHREAD EThread, PEPROCESS EProcess, PALL_THREADS ProcessThreads, ULONG ulCount)
{

	if (EThread && EProcess && MmIsAddressValid((PVOID)EThread))
	{ 

		PEPROCESS Temp = NULL;

		if (IoThreadToProcess)
		{
			Temp = IoThreadToProcess(EThread);
		}
		else
		{
			Temp = (PEPROCESS)(*(PULONG_PTR)(ULONG_PTR)EThread + ThreadsProcessOffset);
		}

		if (EProcess == Temp &&
			!IsThreadInList(EThread, ProcessThreads,ulCount) && 
			NT_SUCCESS(ObReferenceObjectByPointer(EThread, 0, NULL, KernelMode)))
		{
			ULONG_PTR nCurCnt = ProcessThreads->nCnt;
			if (ulCount > nCurCnt)
			{
				if (PsGetThreadId)
				{
					ProcessThreads->Threads[nCurCnt].Tid = (ULONG_PTR)PsGetThreadId(EThread);
				}
				else
				{
					ProcessThreads->Threads[nCurCnt].Tid = *(PULONG_PTR)((ULONG_PTR)EThread + CidOffset + WinOffset);
				}

				ProcessThreads->Threads[nCurCnt].Thread = (ULONG_PTR)EThread;
				ProcessThreads->Threads[nCurCnt].Win32StartAddress = GetThreadStartAddress(EThread);
				ProcessThreads->Threads[nCurCnt].Teb = *(PULONG_PTR)((ULONG_PTR)EThread + TebOffset);
				ProcessThreads->Threads[nCurCnt].Priority = *(PUCHAR)((ULONG_PTR)EThread + PriorityOffset);
				ProcessThreads->Threads[nCurCnt].ContextSwitches = *(PULONG)((ULONG_PTR)EThread + ContextSwitchesOffset);
				ProcessThreads->Threads[nCurCnt].State = *(PUCHAR)((ULONG_PTR)EThread + StateOffset);
			}

			ProcessThreads->nCnt++;
			ObfDereferenceObject(EThread);
		}
	} 
}



BOOLEAN IsThreadInList(PETHREAD EThread, PALL_THREADS ProcessThreads, ULONG ulCount)
{
	BOOLEAN bRet = FALSE;
	ULONG_PTR Temp = ulCount > ProcessThreads->nCnt ? ProcessThreads->nCnt : ulCount;
	ULONG_PTR i = 0;

	if (!EThread || !ProcessThreads)
	{
		return TRUE;
	}

	for (i = 0; i < Temp; i++)
	{
		if (ProcessThreads->Threads[i].Thread == (ULONG_PTR)EThread)
		{
			bRet = TRUE;
			break;
		}
	}

	return bRet; 
}




ULONG_PTR GetThreadStartAddress(PETHREAD EThread)
{


	ULONG_PTR ulStartAddress = 0;

	if (!EThread ||
		!MmIsAddressValid(EThread))
	{
		return ulStartAddress;
	}

	__try
	{
		ulStartAddress = *(PULONG_PTR)((ULONG_PTR)EThread + StartAddressOffset);

		if ( ulBuildNumber < 6000 )
		{
			if (ulStartAddress < (ULONG_PTR)SystemRangeStart)
			{
				ULONG_PTR Win32StartAddress = *(PULONG_PTR)((ULONG_PTR)EThread + Win32StartAddressOffset);
				if ( Win32StartAddress )
				{

					ulStartAddress = Win32StartAddress;

				}
			}
		}
		else
		{
			if (*(ULONG_PTR*)((ULONG_PTR)EThread + SameThreadApcFlags) & 2 )
			{
				ulStartAddress = *(ULONG_PTR*)((ULONG_PTR)EThread + Win32StartAddressOffset);
			}
			else
			{
				if (*(ULONG_PTR*)((ULONG_PTR)EThread + StartAddressOffset))
				{
					ulStartAddress = *(ULONG_PTR*)((ULONG_PTR)EThread + StartAddressOffset);
				}
			}

			if (ulStartAddress <= 0xf)
			{
				Win32StartAddressOffset = 0x418;	//0x410 0x418
				StartAddressOffset = 0x390;			//0x388 0x390
			}

			if (*(ULONG_PTR*)((ULONG_PTR)EThread + SameThreadApcFlags) & 2 )
			{
				ulStartAddress = *(ULONG_PTR*)((ULONG_PTR)EThread + Win32StartAddressOffset);
			}
			else
			{
				if (*(ULONG_PTR*)((ULONG_PTR)EThread + StartAddressOffset))
				{
					ulStartAddress = *(ULONG_PTR*)((ULONG_PTR)EThread + StartAddressOffset);
				}
			}
		}
	}
	__except(1)
	{}

	return ulStartAddress;
}



NTSTATUS
EnumProcessThreadModule(ULONG ulProcessID,PVOID OutBuffer,ULONG_PTR ulOutSize)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PEPROCESS EProcess = NULL;

	ULONG ulCount = (ulOutSize - sizeof(ALL_MODULES)) / sizeof(MODULE_INFO);

	if (ulProcessID)
	{
		Status = PsLookupProcessByProcessId((HANDLE)ulProcessID, &EProcess);

		if (!NT_SUCCESS(Status))
		{
			return Status;
		}
	}

	DbgPrint("Enter EnumProcessModule\r\n");

	if (HsIsRealProcess(EProcess))
	{
		PALL_MODULES AllModules = (PALL_MODULES)ExAllocatePool(PagedPool,ulOutSize);
		if (AllModules)
		{
			memset(AllModules, 0, ulOutSize);

			Status = EnumDllModuleByPeb(EProcess, AllModules, ulCount);

			if (ulCount >= AllModules->ulCount)
			{
				RtlCopyMemory(OutBuffer, AllModules, ulOutSize);
				Status = STATUS_SUCCESS;
			}
			else
			{
				Status = STATUS_BUFFER_TOO_SMALL;
			}

			ExFreePool(AllModules, 0);
			AllModules = NULL;
		}
	}

	if (NT_SUCCESS(Status))
	{
		ObfDereferenceObject(EProcess);
	}

	return Status;
}


NTSTATUS EnumDllModuleByPeb( PEPROCESS EProcess, PALL_MODULES AllModules, ULONG_PTR ulCount)
{

	BOOLEAN bAttach = FALSE;
	KAPC_STATE ApcState;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	ULONG_PTR LdrInPebOffset = 0;



	KeStackAttachProcess(EProcess, &ApcState);
	bAttach = TRUE;


	__try
	{
		ULONG_PTR Peb = 0;
		Peb = (ULONG_PTR)PsGetProcessPeb(EProcess);

		if ((ULONG)Peb > 0)
		{



			switch(WinVersion)
			{
			case WINDOWS_7:
				{
					PPEB_LDR_DATA64 LdrEntry = NULL;
					LdrInPebOffset = 0x18;


					LdrEntry = (PPEB_LDR_DATA64)(*(PULONG_PTR)((Peb + (ULONG_PTR)LdrInPebOffset)));
					ProbeForRead((PVOID)LdrEntry,8,8);

					if ((ULONG_PTR)LdrEntry>0)
					{
						WalkerModuleList64((PLIST_ENTRY64)&(LdrEntry->InLoadOrderModuleList), 1, AllModules, ulCount);
						WalkerModuleList64((PLIST_ENTRY64)&(LdrEntry->InMemoryOrderModuleList), 2, AllModules, ulCount);
						WalkerModuleList64((PLIST_ENTRY64)&(LdrEntry->InInitializationOrderModuleList), 3, AllModules, ulCount);

						Status = STATUS_SUCCESS;
					}

					break;
				}

			case WINDOWS_XP:
				{


					PPEB_LDR_DATA32 LdrEntry = NULL;
					LdrInPebOffset = 0x00c;


					LdrEntry = (PPEB_LDR_DATA32)(*(PULONG_PTR)((Peb + (ULONG_PTR)LdrInPebOffset)));
					ProbeForRead((PVOID)LdrEntry,4,4);

					if ((ULONG_PTR)LdrEntry>0)
					{
						WalkerModuleList32((PLIST_ENTRY32)&(LdrEntry->InLoadOrderModuleList), 1, AllModules, ulCount);
						WalkerModuleList32((PLIST_ENTRY32)&(LdrEntry->InMemoryOrderModuleList), 2, AllModules, ulCount);
						WalkerModuleList32((PLIST_ENTRY32)&(LdrEntry->InInitializationOrderModuleList), 3, AllModules, ulCount);

						Status = STATUS_SUCCESS;
					}

					break;
				}
			}



		}
	}
	__except(1)
	{
		DbgPrint("EnumDllModuleByPeb Catch __Except\r\n");
		Status = STATUS_UNSUCCESSFUL;
	}

	if (bAttach)
	{
		KeUnstackDetachProcess(&ApcState);
		bAttach = FALSE;
	}

	return Status;
}



VOID WalkerModuleList32(PLIST_ENTRY32 ListEntry, ULONG nType, PALL_MODULES AllModules, ULONG ulCount)
{
	PLIST_ENTRY32 Entry = NULL;
	PLDR_DATA_TABLE_ENTRY LdrEntry = NULL;
	Entry = (PLIST_ENTRY32)ListEntry->Flink;

	while ((ULONG_PTR)Entry > 0 && Entry != ListEntry)
	{


		switch (nType)
		{
		case 1:
			LdrEntry = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
			break;

		case 2:
			LdrEntry = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
			break;

		case 3:
			LdrEntry = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);
			break;
		}

		if ((ULONG)LdrEntry > 0)
		{
			__try
			{
				ProbeForRead(LdrEntry, sizeof(LDR_DATA_TABLE_ENTRY), 1);

				if (!IsModuleInList((ULONG_PTR)LdrEntry->DllBase, (ULONG_PTR)(LdrEntry->SizeOfImage), AllModules, ulCount))
				{
					if (ulCount > AllModules->ulCount)
					{


						AllModules->Modules[AllModules->ulCount].Base = (ULONG_PTR)LdrEntry->DllBase;
						AllModules->Modules[AllModules->ulCount].Size = LdrEntry->SizeOfImage;

						wcsncpy(AllModules->Modules[AllModules->ulCount].Path, LdrEntry->FullDllName.Buffer,LdrEntry->FullDllName.Length);
					}

					AllModules->ulCount++;
				}
			}
			__except(1)
			{
				DbgPrint("WalkerModuleList __Except(1)\r\n");
			}
		}

		Entry = (PLIST_ENTRY32)Entry->Flink;
	}
}



VOID WalkerModuleList64(PLIST_ENTRY64 ListEntry, ULONG nType, PALL_MODULES AllModules, ULONG ulCount)
{
	PLIST_ENTRY64 Entry = NULL;
	PLDR_DATA_TABLE_ENTRY64 LdrEntry = NULL;
	Entry = (PLIST_ENTRY64)ListEntry->Flink;

	while ((ULONG_PTR)Entry > 0 && Entry != ListEntry)
	{


		switch (nType)
		{
		case 1:
			LdrEntry = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY64, InLoadOrderLinks);
			break;

		case 2:
			LdrEntry = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY64, InMemoryOrderLinks);
			break;

		case 3:
			LdrEntry = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY64, InInitializationOrderLinks);
			break;
		}

		if ((ULONG)LdrEntry > 0)
		{
			__try
			{
				ProbeForRead(LdrEntry, sizeof(LDR_DATA_TABLE_ENTRY64), 8);

				if (!IsModuleInList((ULONG_PTR)LdrEntry->DllBase, (ULONG_PTR)(LdrEntry->SizeOfImage), AllModules, ulCount))
				{
					if (ulCount > AllModules->ulCount)
					{


						AllModules->Modules[AllModules->ulCount].Base = (ULONG_PTR)LdrEntry->DllBase;
						AllModules->Modules[AllModules->ulCount].Size = LdrEntry->SizeOfImage;

						wcsncpy(AllModules->Modules[AllModules->ulCount].Path, LdrEntry->FullDllName.Buffer,LdrEntry->FullDllName.Length);
					}

					AllModules->ulCount++;
				}
			}
			__except(1)
			{
				DbgPrint("WalkerModuleList __Except(1)\r\n");
			}
		}

		Entry = (PLIST_ENTRY64)Entry->Flink;
	}
}




BOOLEAN IsModuleInList(ULONG_PTR Base, ULONG_PTR Size, PALL_MODULES AllModules, ULONG_PTR ulCount)
{
	BOOLEAN bIn = FALSE;
	ULONG i = 0;
	ULONG ulTempCount = AllModules->ulCount > ulCount ? ulCount : AllModules->ulCount;

	for (i = 0; i < ulTempCount; i++)
	{
		if (Base == AllModules->Modules[i].Base && Size == AllModules->Modules[i].Size)
		{
			bIn = TRUE;
			break;
		}
	}

	return bIn;
}




```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Thread.h`:

```h
#pragma once 


#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include <ntimage.h>

#include "common.h"

#include "Process.h"



typedef struct _THREAD_INFO_
{
	ULONG_PTR Thread;
	ULONG_PTR Tid;
	ULONG_PTR Teb;
	UCHAR Priority;
	ULONG_PTR Win32StartAddress;
	ULONG ContextSwitches;
	UCHAR State;
}THREAD_INFO, *PTHREAD_INFO;

typedef struct _ALL_THREADS_
{
	ULONG_PTR    nCnt;
	THREAD_INFO Threads[1];
}ALL_THREADS, *PALL_THREADS;




NTSTATUS HsEnumProcessThread(PVOID ProcessId);
VOID HsEnumThreadByForce(PEPROCESS EProcess);




extern
	PPEB
	PsGetProcessPeb(PEPROCESS Process);


NTSTATUS EnumProcessThread(PVOID InBuffer, ULONG InSize, PVOID OutBuffer, ULONG_PTR OutSize);
VOID EnumThreads(PEPROCESS EProcess, PALL_THREADS ProcessThreads, ULONG_PTR ulCount);
VOID EnumProcessThreadByList(PEPROCESS EProcess, PALL_THREADS ProcessThreads, ULONG_PTR ulCount);
VOID InsertThread(PETHREAD EThread, PEPROCESS EProcess, PALL_THREADS ProcessThreads, ULONG ulCount);
BOOLEAN IsThreadInList(PETHREAD EThread, PALL_THREADS ProcessThreads, ULONG ulCount);
ULONG_PTR GetThreadStartAddress(PETHREAD EThread);
NTSTATUS EnumProcessThreadModule(ULONG ulProcessID,PVOID OutBuffer,ULONG_PTR ulOutSize);
NTSTATUS EnumDllModuleByPeb( PEPROCESS EProcess, PALL_MODULES AllModules, ULONG_PTR ulCount);
VOID WalkerModuleList64(PLIST_ENTRY64 ListEntry, ULONG nType, PALL_MODULES AllModules, ULONG ulCount);
VOID WalkerModuleList32(PLIST_ENTRY32 ListEntry, ULONG nType, PALL_MODULES AllModules, ULONG ulCount);
BOOLEAN IsModuleInList(ULONG_PTR Base, ULONG_PTR Size, PALL_MODULES AllModules, ULONG_PTR ulCount);





```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Window.c`:

```c
#include "Window.h"



extern
	WIN_VERSION  WinVersion;
extern       
	ULONG_PTR ulBuildNumber;

extern
	pfnNtUserBuildHwndList AddressNtUserBuildHwndList;
extern
	pfnNtUserQueryWindow AddressNtUserQueryWindow;




NTSTATUS HsEnumProcessWindow(PVOID InBuffer, ULONG_PTR InSize, PVOID OutBuffer, ULONG_PTR OutLen)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	GetSSSDTApi();

	if (!InBuffer || 
		!OutBuffer)
	{
		return STATUS_INVALID_PARAMETER;
	}


	if (AddressNtUserBuildHwndList==NULL)
	{
		return Status;
	}

	else
	{

		Status = AddressNtUserBuildHwndList(
			NULL,
			NULL,
			FALSE,
			0,
			(OutLen - sizeof(ALL_WNDS)) / sizeof(WND_INFO),
			(HWND*)((ULONG)OutBuffer + sizeof(ULONG)),
			(ULONG*)OutBuffer);
	}

	if (NT_SUCCESS(Status))
	{
		DWORD ulCount = *((DWORD*)OutBuffer);
		ULONG i = 0;
		HWND* hWndBuffer = (HWND*)ExAllocatePool(NonPagedPool,sizeof(HWND) * ulCount);



		if (hWndBuffer)
		{
			PALL_WNDS Wnds = (PALL_WNDS)OutBuffer;
			memcpy(hWndBuffer, (PVOID)((ULONG)OutBuffer + sizeof(ULONG)), sizeof(HWND) * ulCount);

			for (i = 0; i < ulCount; i++)
			{
				ULONG Tid = 0, Pid = 0;
				HWND hWnd = hWndBuffer[i];

				Pid = AddressNtUserQueryWindow(hWnd, 0);

				if (WinVersion == WINDOWS_7)
				{
					Tid = AddressNtUserQueryWindow(hWnd, 2);
				}
				else
				{
					Tid = AddressNtUserQueryWindow(hWnd, 1);
				}

				Wnds->WndInfo[i].hWnd = hWnd;
				Wnds->WndInfo[i].uPid = Pid;
				Wnds->WndInfo[i].uTid = Tid;
			}

			Wnds->nCnt = ulCount;

			ExFreePool(hWndBuffer,0);
		}
	}

	return Status;
}


```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/Window.h`:

```h
#pragma once 



#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#include <ntifs.h>
#include <WINDEF.H>
#include "GetSSSDTFuncAddress.h"
#include "common.h"
#include "Process.h"



typedef struct _WND_INFO_
{
	HWND  hWnd;
	ULONG uPid;
	ULONG uTid;
}WND_INFO, *PWND_INFO;

typedef struct _ALL_WNDS_
{
	ULONG nCnt;
	WND_INFO WndInfo[1];
}ALL_WNDS, *PALL_WNDS;



NTSTATUS 
	HsEnumProcessWindow(
	PVOID InBuffer, 
	ULONG_PTR InSize, 
	PVOID OutBuffer, 
	ULONG_PTR OutLen);

```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/common.c`:

```c
#include "common.h"


//////////////////////////////////////////////////////////////////////////
ULONG_PTR  ulBuildNumber = 0;	//GetWindowsVersion

ULONG_PTR    SYSTEM_ADDRESS_START = 0;

//////////////////////////////////////////////////////////////////////////


VOID HsWcharToChar(WCHAR *wzFuncName,CHAR *szFuncName)
{
	UNICODE_STRING UnicodeFuncName;
	ANSI_STRING AnsiFuncName;

	RtlInitUnicodeString(&UnicodeFuncName,wzFuncName);
	if (RtlUnicodeStringToAnsiString(&AnsiFuncName,&UnicodeFuncName,TRUE) == STATUS_SUCCESS){
		memcpy(szFuncName,AnsiFuncName.Buffer,AnsiFuncName.Length);
		RtlFreeAnsiString(&AnsiFuncName);
	}
}


//通过 函数名称 得到函数地址
PVOID 
HsGetFunctionAddressByName(WCHAR *szFunction)
{
	UNICODE_STRING uniFunction;  
	PVOID AddrBase = NULL;

	if (szFunction && wcslen(szFunction) > 0)
	{
		RtlInitUnicodeString(&uniFunction, szFunction);   //常量指针
		AddrBase = MmGetSystemRoutineAddress(&uniFunction);
	}

	return AddrBase;
}



WIN_VERSION HsGetWindowsVersion()
{


	RTL_OSVERSIONINFOEXW osverInfo = {sizeof(osverInfo)}; 
	pfnRtlGetVersion RtlGetVersion = NULL;
	WIN_VERSION WinVersion;
	WCHAR szRtlGetVersion[] = L"RtlGetVersion";


	RtlGetVersion = (pfnRtlGetVersion)HsGetFunctionAddressByName(szRtlGetVersion); 

	if (RtlGetVersion)
	{
		RtlGetVersion((PRTL_OSVERSIONINFOW)&osverInfo); 
	} 
	else 
	{
		PsGetVersion(&osverInfo.dwMajorVersion, &osverInfo.dwMinorVersion, &osverInfo.dwBuildNumber, NULL);
	}

	ulBuildNumber =  osverInfo.dwBuildNumber;

	if (osverInfo.dwMajorVersion == 5 && osverInfo.dwMinorVersion == 1) 
	{
		DbgPrint("WINDOWS_XP\r\n");
		WinVersion = WINDOWS_XP;
	}
	else if (osverInfo.dwMajorVersion == 6 && osverInfo.dwMinorVersion == 1)
	{
		DbgPrint("WINDOWS 7\r\n");
		WinVersion = WINDOWS_7;
	}
	else if (osverInfo.dwMajorVersion == 6 && 
		osverInfo.dwMinorVersion == 2 &&
		osverInfo.dwBuildNumber == 9200)
	{
		DbgPrint("WINDOWS 8\r\n");
		WinVersion = WINDOWS_8;
	}
	else if (osverInfo.dwMajorVersion == 6 && 
		osverInfo.dwMinorVersion == 3 && 
		osverInfo.dwBuildNumber == 9600)
	{
		DbgPrint("WINDOWS 8.1\r\n");
		WinVersion = WINDOWS_8_1;
	}
	else
	{
		DbgPrint("WINDOWS_UNKNOW\r\n");
		WinVersion = WINDOWS_UNKNOW;
	}

	return WinVersion;
}

NTSTATUS HsSafeCopyMemory(PVOID SrcAddr, PVOID DstAddr, ULONG SrcSize)
{
	PMDL SrcMdl, DstMdl;
	PUCHAR SrcAddress, DstAddress;
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	ULONG_PTR r;

	//为拷贝源创建一个MDL
	SrcMdl = IoAllocateMdl(SrcAddr, SrcSize, FALSE, FALSE, NULL);  
	if (MmIsAddressValid(SrcMdl))
	{
		MmBuildMdlForNonPagedPool(SrcMdl);
		SrcAddress = MmGetSystemAddressForMdlSafe(SrcMdl, NormalPagePriority);
		//系统为我们创建内存

		if (MmIsAddressValid(SrcAddress))
		{
			//为拷贝目标创建一个MDL
			DstMdl = IoAllocateMdl(DstAddr,SrcSize,FALSE,FALSE, NULL);
			if (MmIsAddressValid(DstMdl))
			{
				__try
				{
					MmProbeAndLockPages(DstMdl, KernelMode, IoWriteAccess);
					DstAddress = MmGetSystemAddressForMdlSafe(DstMdl, NormalPagePriority);
					if (MmIsAddressValid(DstAddress))
					{
						RtlZeroMemory(DstAddress,SrcSize);
						RtlCopyMemory(DstAddress, SrcAddress, SrcSize);
						Status = STATUS_SUCCESS;
					}
					MmUnlockPages(DstMdl);
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{                 
					if (DstMdl)
					{
						MmUnlockPages(DstMdl);
					}

					if (DstMdl)
					{
						IoFreeMdl(DstMdl);
					}

					if (SrcMdl)
					{
						IoFreeMdl(SrcMdl);
					}

					return GetExceptionCode();
				}
				IoFreeMdl(DstMdl);
			}
		}            
		IoFreeMdl(SrcMdl);
	}
	return Status;
}


BOOLEAN HsIsUnicodeStringValid(PUNICODE_STRING uniString)
{
	BOOLEAN bRet = FALSE;

	__try
	{
		if (uniString->Length > 0	&&
			uniString->Buffer		&&
			MmIsAddressValid(uniString->Buffer) &&
			MmIsAddressValid(&uniString->Buffer[uniString->Length / sizeof(WCHAR) - 1]))
		{
			bRet = TRUE;
		}

	}
	__except(1)
	{	
		bRet = FALSE;
	}

	return bRet;
}




```

`arkProject/HeavenShadowDrv/HeavenShadowDrv/Source/common.h`:

```h
/**************************************************************************************
* AUTHOR : HeavenShadow
* DATE   : 2014-10-28
* MODULE : common.h
*
* Command: 
*	IOCTRL 通用头文件
*
* Description:
*	驱动和应用程序的IoCtrl的通用数据
*
****************************************************************************************
* Copyright (C) 2015 HeavenShadow.
****************************************************************************************/

#pragma once 

#include <ntifs.h>

#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

//不支持符号链接用户相关性
#define HS_DEVICE_NAME                  L"\\Device\\HeavenShadowDevice"
#define HS_LINK_NAME                    L"\\DosDevices\\HeavenShadowLink"

#define HS_EVENT_PROCESS_NAME           L"\\BaseNamedObjects\\HeavenShadowProcessEvent"

#define HS_WIN32_LINK_NAME              "\\\\.\\HeavenShadowLink"

//支持符号链接用户相关性
#define SYMBOLIC_LINK_GLOBAL_NAME       L"\\DosDevices\\Global\\HeavenShadowDevice"

#define DATA_TO_APP                     "HeavenShadow"


enum HS_ENUM_IOCTL
{
	HS_IOCTL_PROC = 0x100,					//进程相关
	HS_IOCTL_PROC_SENDSELFPID,				//发送自己的PID到驱动层
	HS_IOCTL_PROC_PROCESSCOUNT,				//进程计数
	HS_IOCTL_PROC_PROCESSLIST,				//列举进程列表
	HS_IOCTL_PROC_PROTECTPROCESS,			//保护进程
	HS_IOCTL_PROC_KILLPROCESSBYFORCE,		//强制关闭进程
	HS_IOCTL_PROC_PROCESSTHREAD,			//线程
	HS_IOCTL_PROC_PROCESSTHREADMODULE,		//线程模块
	HS_IOCTL_PROC_PROCESSPRIVILEGE,			//列举进程权限
	HS_IOCTL_PROC_PRIVILEGE_ADJUST,			//改变进程权限
	HS_IOCTL_PROC_PROCESSHANDLE,			//句柄
	HS_IOCTL_PROC_PROCESSWINDOW,			//窗口
	HS_IOCTL_PROC_PROCESSMODULE,			//进程模块
	HS_IOCTL_PROC_PROCESSMEMORY,			//进程内存

	HS_IOCTL_MODU = 0x180,					//模块相关
	HS_IOCTL_MODU_MODULELIST,				//列举系统模块列表
	HS_IOCTL_MODU_REMOVEMODULE,				//卸载系统模块

	HS_IOCTL_KRNL = 0x200,					//内核钩子相关
	HS_IOCTL_KRNL_SSDTLIST,					//列举SSDT列表
	HS_IOCTL_KRNL_KISRVTAB,					//获取服务表
	HS_IOCTL_KRNL_RESUMESSDT,				//恢复SSDT函数
	HS_IOCTL_KRNL_SSSDTLIST,				//列举SSSDT列表
	HS_IOCTL_KRNL_WIN32KSERVICE,			//获取Win32k服务表
	HS_IOCTL_KRNL_KRNLFILE,					//获取内核文件		//具体哪个文件在InputBuffer的布尔型中确定
	HS_IOCTL_KRNL_KRNLIAT,					//获取内核导入表
	HS_IOCTL_KRNL_KRNLEAT,					//获取内核导出表

	HS_IOCTL_SYSK = 0x280,					//内核相关
	HS_IOCTL_SYSK_SYSTHREAD,				//内核线程
	HS_IOCTL_SYSK_IOTIMER,					//IOTIMER
	HS_IOCTL_SYSK_OPERIOTIMER,				//IOTIMER切换
	HS_IOCTL_SYSK_REMOVEIOTIMER,			//IOTIMER删除
	HS_IOCTL_SYSK_CALLBACKLIST,				//系统回调：驱动加载
	HS_IOCTL_SYSK_REMOVECALLBACK,			//删除系统回调
	HS_IOCTL_SYSK_DPCTIMER,					//DPCTimer
	HS_IOCTL_SYSK_REMOVEDPCTIMER,			//DPCTimer删除
	HS_IOCTL_SYSK_FILTERDRIVER,				//过滤驱动
	HS_IOCTL_SYSK_FILTERUNLOAD,				//卸载过滤驱动
};


#define HS_IOCTL(i)			 \
	CTL_CODE                 \
	(                        \
	FILE_DEVICE_UNKNOWN,     \
	i,						 \
	METHOD_BUFFERED,         \
	FILE_ANY_ACCESS          \
	)

// HS_IOCTL(HS_IOCTL_PROC_PROCESSLIST)




typedef 
NTSTATUS 
(*pfnRtlGetVersion)(OUT PRTL_OSVERSIONINFOW lpVersionInformation);

typedef enum WIN_VERSION {
	WINDOWS_UNKNOW,
	WINDOWS_XP,
	WINDOWS_7,
	WINDOWS_8,
	WINDOWS_8_1
} WIN_VERSION;

WIN_VERSION HsGetWindowsVersion();





//////////////////////////////////////////////////////////////////////////
///自定义函数
//////////////////////////////////////////////////////////////////////////


//通过 函数名称 得到函数地址
PVOID 
HsGetFunctionAddressByName(WCHAR *szFunction);

NTSTATUS HsSafeCopyMemory(PVOID SrcAddr, PVOID DstAddr, ULONG SrcSize);

VOID HsWcharToChar(WCHAR *wzFuncName,CHAR *szFuncName);


CHAR HsChangePreMode(PETHREAD EThread);
VOID HsRecoverPreMode(PETHREAD EThread, CHAR PreMode);

extern NTSTATUS PsLookupProcessByProcessId(PVOID ProcessID, PEPROCESS *Process);

BOOLEAN HsIsUnicodeStringValid(PUNICODE_STRING uniString);
```

`arkProject/ReadMe.md`:

```md
#Ark工具  ———— HeavenShadow

##关于
Windows下类似于PCHunter的ark工具

##文件结构
* bin - 可执行文件
* HeavenShadow - 应用层文件
* HeavenShadowDrv - 驱动文件

##实现功能
* 内核级进程，线程，内存，模块，窗口管理与注入功能
* 内核模块的管理
* SSDT与ShadowSSDT的hook与inline hook检测
* 关键内核模块的IAT,EAT的hook检测
* 系统IoTimer,DpcTimer和内核劳务线程的管理
* 系统内核回调的管理，例如CreateProcess、LoadImage、CreateThread等等

##开发环境
* Visual Studio 2010 + WDK 7600

##测试环境
* 本机：Windows7 x64 Ultimate SP1
* 虚拟机：VMWare + Windows7 x64 Ultimate SP1 / Windows XP SP3

##参考资料
* 《Windows内核情景分析》
* 《WindowsPE权威指南》
* 《加密与解密》
* 《Windows内核原理及实现》
* 《深入解析Windows操作系统》
*  [Windows x64驱动资料](http://bbs.pediy.com/showthread.php?t=187348)
*  [BlackBone](https://github.com/DarthTon/Blackbone)
*  wrk-v1.2源码
```

`hook_IDT/IDTHook/IDTHook.c`:

```c

#ifndef CXX_IDTHOOK_H
#	include "IDTHook.h"
#endif
#include <WINDEF.H>


ULONG_PTR g_OrigKiTrap03;
KIRQL  Irql;


_declspec(naked) void NewKiTrap03()
{

	__asm
	{
		//测试
		//jmp g_OrigKiTrap03

		//构建Trap03的异常帧
		//保存现场环境,和原始Trap03一样
		push    0   ;ErrorCode
		push    ebp
		push    ebx
		push    esi
		push    edi
		push    fs
		mov     ebx,30h
		mov     fs,bx
		mov     ebx,dword ptr fs:[0]
		push    ebx
		sub     esp,4
		push    eax
		push    ecx
		push    edx
		push    ds
		push    es
		push    gs

		sub     esp,30h    //esp此时就指向陷阱帧

		push    esp         //FilterExceptionInfo自己清理了

		call   FilterExceptionInfo   //过滤函数

		add     esp , 0x30
		pop		gs
		pop		es
		pop		ds
		pop		edx
		pop		ecx
		pop		eax
		add		esp , 4
		pop		ebx
		pop		fs
		pop		edi
		pop		esi
		pop		ebx
		pop		ebp
		add     esp , 0x4
		jmp     g_OrigKiTrap03
	}
}



VOID __stdcall FilterExceptionInfo(PX86_KTRAP_FRAME pTrapFrame)
{

	//eip的值减一过int3，汇编代码分析中dec， 
	DbgPrint("Eip:%x\r\n",(pTrapFrame->Eip)-1);
}


NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryString)
{
	NTSTATUS	Status = STATUS_SUCCESS;
	IDTR Idtr;
	PIDTENTRY pIdtArray = NULL;
	ULONG_PTR Index = 0;

	DriverObject->DriverUnload = UnloadDriver;
    __asm sidt Idtr
	//虚拟机是单核的，只用一个就可以了
	if(KeGetIdt(&pIdtArray))
	{
		DbgPrint("%x---%x\r\n",Idtr.base,Idtr.limit);
		for (Index =0;Index<(Idtr.limit+1)/sizeof(IDTENTRY);Index++) 		
		{
			DbgPrint("TrapHandle[%d]:%x\r\n",Index,MAKELONG(pIdtArray[Index].LowOffset,pIdtArray[Index].HiOffset));
		}

		g_OrigKiTrap03 = MAKELONG(pIdtArray[3].LowOffset,pIdtArray[3].HiOffset);

		WPOFF();
		pIdtArray[3].LowOffset = (ULONG_PTR)NewKiTrap03 & 0xFFFF;  //低16位
		pIdtArray[3].HiOffset =  (ULONG_PTR)NewKiTrap03 >> 16;     //高16位
		WPON();

	}
	
	//limit 0x7ff (包含0)  0x800  = 2048  Entry每项大小8字节，就2048/8 = 256 成员
	//!idt -a   0ff  = 256 

	//MAKELONG
	//#define MAKELONG(a, b)      ((LONG)(((WORD)(((DWORD_PTR)(a)) & 0xffff)) | ((DWORD)((WORD)(((DWORD_PTR)(b)) & 0xffff))) << 16))
	return Status;
}





BOOLEAN KeGetIdt(PIDTENTRY *pIdtArray)
{
	ULONG Index,Affinity,CurrentAffinity;
	pfnKESETAFFINITYTHREAD fnpKeSetAffinityThread;

	UNICODE_STRING usFuncName;
	PIDTENTRY pIdtEntry;

	RtlInitUnicodeString(&usFuncName,L"KeSetAffinityThread");
	fnpKeSetAffinityThread = (pfnKESETAFFINITYTHREAD)MmGetSystemRoutineAddress(&usFuncName);

	if (fnpKeSetAffinityThread==0)
	{
		return FALSE;
	}

	Affinity = KeQueryActiveProcessors();                    
	//KeQueryActiveProcessors获取处理器相关的位图
	//(这里的位图可以理解为个数，比如返回1代表一个处理器，返回3表示两个处理器，返回7表示三个处理器，依此类推。
	//也就是说从有多少个处理器，那么Affinity的值就会从低位到高位依此填充多少位)

	CurrentAffinity = 1;
	Index = 0;
	while(Affinity)
	{
		//下面只是个简单的算法，使当前线程运行到不同的处理器上
		Affinity &= ~CurrentAffinity;
		fnpKeSetAffinityThread(PsGetCurrentThread(),(KAFFINITY)CurrentAffinity);
		CurrentAffinity <<= 1;

		__asm{
			push        eax
			mov         eax,fs:[0x38]
			mov         pIdtEntry,eax
			pop         eax
		}
		//得到我们要的东西
		pIdtArray[Index] = pIdtEntry;
		Index++;
	}

	return TRUE;
}


VOID WPOFF()
{
	ULONG_PTR cr0 = 0;
	Irql = KeRaiseIrqlToDpcLevel();
	cr0 =__readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);

}





VOID WPON()
{

	ULONG_PTR cr0=__readcr0();
	cr0 |= 0x10000;
	__writecr0(cr0);
	KeLowerIrql(Irql);
}



VOID UnloadDriver(PDRIVER_OBJECT DriverObject)
{
	//恢复
	PIDTENTRY pIdtEntry;
	if (g_OrigKiTrap03 && KeGetIdt(&pIdtEntry))
	{
		WPOFF();
		pIdtEntry[3].LowOffset = g_OrigKiTrap03 & 0xFFFF;
		pIdtEntry[3].HiOffset = g_OrigKiTrap03 >> 16;
		WPON();
	}
}
```

`hook_IDT/IDTHook/IDTHook.h`:

```h


#ifndef CXX_IDTHOOK_H
#define CXX_IDTHOOK_H

#include <ntifs.h>
#include <devioctl.h>
#endif	

#pragma  pack(2)  //默认是4字节对齐
typedef struct _IDTR
{
	USHORT	limit;	//范围，所占内存大小
	ULONG	base;	//IDT表项起始地址
}IDTR,*PIDTR;
#pragma pack()

//占8字节
typedef struct _IDTENTRY
{
	unsigned short LowOffset;    //LowOffset和HiOffset组成一4字节的地址就是处理例程的地址
	unsigned short selector;
	unsigned char retention:5;
	unsigned char zero1:3;
	unsigned char gate_type:1;
	unsigned char zero2:1;
	unsigned char interrupt_gate_size:1;
	unsigned char zero3:1;
	unsigned char zero4:1;
	unsigned char DPL:2;
	unsigned char P:1;
	unsigned short HiOffset;
} IDTENTRY,*PIDTENTRY;


typedef struct _X86_KTRAP_FRAME {
	ULONG   DbgEbp;
	ULONG   DbgEip;
	ULONG   DbgArgMark;
	ULONG   DbgArgPointer;
	ULONG   TempSegCs;
	ULONG   TempEsp;
	ULONG   Dr0;
	ULONG   Dr1;
	ULONG   Dr2;
	ULONG   Dr3;
	ULONG   Dr6;
	ULONG   Dr7;
	ULONG   SegGs;
	ULONG   SegEs;
	ULONG   SegDs;
	ULONG   Edx;
	ULONG   Ecx;
	ULONG   Eax;
	ULONG   PreviousPreviousMode;
	ULONG   ExceptionList;
	ULONG   SegFs;
	ULONG   Edi;
	ULONG   Esi;
	ULONG   Ebx;
	ULONG   Ebp;
	ULONG   ErrCode;

	ULONG   Eip;
	ULONG   SegCs;
	ULONG   EFlags;
	ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
	ULONG   HardwareSegSs;  // that involve a ring transition.
	ULONG   V86Es;          // these will be present for all transitions from
	ULONG   V86Ds;          // V86 mode
	ULONG   V86Fs;
	ULONG   V86Gs;
} X86_KTRAP_FRAME, *PX86_KTRAP_FRAME;



VOID UnloadDriver(PDRIVER_OBJECT DriverObject);
VOID WPOFF();
VOID WPON();
VOID __stdcall FilterExceptionInfo(PX86_KTRAP_FRAME pTrapFrame);
BOOLEAN KeGetIdt(PIDTENTRY *pIdtArray);
typedef KAFFINITY (*pfnKESETAFFINITYTHREAD)(
	__inout PKTHREAD Thread,
	__in KAFFINITY Affinity
	);
```

`hook_IDT/IDTHook/IDTHook.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IDTHook", "IDTHook.vcxproj", "{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		WinDDK|Win32 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.ActiveCfg = WinDDK|Win32
		{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}.WinDDK|Win32.Build.0 = WinDDK|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`hook_IDT/IDTHook/IDTHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="WinDDK|Win32">
      <Configuration>WinDDK</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4EE67C57-BE79-4CD7-B3B0-94AECE62DB41}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>"IDTHook"</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <TargetExt>.sys</TargetExt>
    <GenerateManifest>false</GenerateManifest>
    <ExecutablePath>$(WLHBASE)\bin\x86\x86;$(WLHBASE)\bin\x86</ExecutablePath>
    <IncludePath>$(WLHBASE)\inc\api;$(WLHBASE)\inc\crt;$(WLHBASE)\inc\ddk;$(WLHBASE)\inc</IncludePath>
    <ReferencePath />
    <LibraryPath>$(WLHBASE)\lib\win7\i386</LibraryPath>
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='WinDDK|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG=1</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CallingConvention>StdCall</CallingConvention>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;hal.lib;wdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Native</SubSystem>
      <Driver>Driver</Driver>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include=".\IDTHook.c" />
    <ClCompile Include=".\IDTHook.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`hook_IDT/IDTHook/IDTHook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`hook_IDT/IDTHook/clean.bat`:

```bat
rem /////////////////
rem / Add by ChiChou
rem / 
rem / FileName:Clean.bat
rem / Description:Clean
rem /
rem ////////////////
rd .\bin /s /q
rd .\WinDDK /s /q
rd .\objchk_w2k_x86 /s /q
rd .\objchk_wxp_x86 /s /q
rd .\objchk_wnet_x86 /s /q
rd .\objchk_wlh_x86 /s /q
rd .\objfre_w2k_x86 /s /q
rd .\objfre_wxp_x86 /s /q
rd .\objfre_wnet_x86 /s /q
rd .\objfre_wlh_x86 /s /q
del .\*.log
del .\*.err
del .\*.xml
rem ***** del VS2005 file *****
del .\*.ncb
del .\*.user
del .\*.suo /A:H
rem ***** del VS6.0 file *****
del .\*.plg
del .\*.opt
exit
```

`hook_IDT/IDTHook/ddkbuild.cmd`:

```cmd
@echo off
@set VERSION=V7.3
@set OSR_DEBUG=off
@if "%OS%"=="Windows_NT" goto :Prerequisites
@echo This script requires Windows NT 4.0 or later to run properly!
goto :EOF
:Prerequisites
:: Check whether FINDSTR is available. It's used to show warnings etc.
findstr /? > NUL 2>&1 || echo "FINDSTR is a prerequisite but wasn't found!" && goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    $Id: ddkbuild.cmd 27 2008-09-06 12:02:06Z oliver $
::
::    This software is supplied for instructional purposes only.
::
::    OSR Open Systems Resources, Inc. (OSR) expressly disclaims any warranty
::    for this software.  THIS SOFTWARE IS PROVIDED  "AS IS" WITHOUT WARRANTY
::    OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
::    THE IMPLIED WARRANTIES OF MECHANTABILITY OR FITNESS FOR A PARTICULAR
::    PURPOSE.  THE ENTIRE RISK ARISING FROM THE USE OF THIS SOFTWARE REMAINS
::    WITH YOU.  OSR's entire liability and your exclusive remedy shall not
::    exceed the price paid for this material.  In no event shall OSR or its
::    suppliers be liable for any damages whatsoever (including, without
::    limitation, damages for loss of business profit, business interruption,
::    loss of business information, or any other pecuniary loss) arising out
::    of the use or inability to use this software, even if OSR has been
::    advised of the possibility of such damages.  Because some states/
::    jurisdictions do not allow the exclusion or limitation of liability for
::    consequential or incidental damages, the above limitation may not apply
::    to you.
::
::    OSR Open Systems Resources, Inc.
::    105 Route 101A Suite 19
::    Amherst, NH 03031  (603) 595-6500 FAX: (603) 595-6503
::    report bugs to <bugs@osr.com>
::    alternatively report them via <http://assarbad.net/contact/>
::
::
::    MODULE:
::
::      ddkbuild.cmd
::
::    ABSTRACT:
::
::      This script allows drivers to be built with Visual Studio 2002 through
::      Visual Studio 2008 and possibly future versions. It will also work fine
::      from the command line.
::      If you are interested in a project wizard that makes use of this script,
::      try DDKWizard from <http://ddkwizard.assarbad.net>.
::
::    AUTHOR(S):
::
::      - OSR Open Systems Resources, Inc.
::      - Oliver Schneider (ddkwizard.assarbad.net)
::
::    REQUIREMENTS:
::
::      Environment variables that must be set.
::        %NT4BASE%  - Set this up for "-NT4" builds (legacy, support not tested)
::        %W2KBASE%  - Set this up for "-W2K*" builds (legacy, support not tested)
::        %WXPBASE%  - Set this up for "-WXP*" builds
::        %WNETBASE% - Set this up for "-WNET*" builds
::        %WLHBASE%  - Set this up for "-WLH*" builds
::        %WDF_ROOT% - Must be set if attempting to do a WDF Build.
::
::      Examples:
::        NT4BASE : could be "D:\NT4DDK"
::        W2KBASE : could be "D:\Nt50DDK"
::        WXPBASE : could be "D:\WINDDK\2600"
::        WNETBASE: could be "D:\WINDDK\3790.1830" or "C:\WINDDK\3790"
::
::    COMMAND FORMAT:
::
::      Run the script without any parameters to get the whole help content!
::      Note: "-WDF" has been tested with the 01.00.5054 version of the framework
::
::    RETURN CODES AND THEIR MEANING:
::
::      001 == Unknown build type. Check the <platform> parameter
::      002 == No WDF_ROOT given using WDF build type.
::      003 == The DDK-specific base directory variable (NT4BASE, W2KBASE, WXPBASE,
::             WNETBASE) is not set at all and could not be auto-detected!
::      004 == BASEDIR variable is empty. Check to see that the DDK-specific
::             variable is set correctly (i.e. NT4BASE, W2KBASE, WXPBASE, WNETBASE)
::      005 == No mode (checked/free) was given. Check the respective parameter!
::      006 == No DIR or SOURCES file found in the given target directory.
::      007 == No target directory given.
::      008 == Given target directory does not exist.
::      009 == The SETENV script failed.
::
::      Note: If %OSR_ERRCODE% and %ERRORLEVEL% are equal, the return code stems
::            from one of the tools being called during the build process.
::
::    BROWSE FILES:
::
::      This procedure supports the building of BROWSE files to be used by
::      Visual Studio 6 and by Visual Studio.NET  However, the BSCfiles created
::      by bscmake for the two are not compatible. When this command procedure
::      runs, it selects the first bscmake.exe found in the path. So, make sure
::      that the correct bscmake.exe is in the path ...
::
::      Note that if using Visual Studio.NET the .BSC must be added to the project
::      in order for the project to be browsed.
::      Another alternative is the VS addon named "Visual Assist X" which will
::      parse the header files - no more need for browse files.
::
::    COMPILERS:
::
::      If you are building NT4 you should really be using the VC6 compiler.
::      Later versions of the DDK now contain the compiler and the linker. This
::      procedure should use the correct compiler.
::
::    GENERAL COMMENTS:
::
::      This procedure has been cleaned up to be modular and easy to understand.
::
::      As of the Server 2003 SP1 DDK DDKBUILD now clears the NO_BROWSE_FILE and
::      NO_BINPLACE environment variables so that users can use these features.
::
::      Starting with the Vista WDK, the output in the respective tool window
::      in VS is in Unicode by default. This garbles the output from DDKBUILD
::      and we therefore clear the environment variable VS_UNICODE_OUTPUT.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MAIN
:: Building "stack frame"
setlocal ENABLEEXTENSIONS & pushd .
:: Check whether the REG utility is available
reg /? > NUL 2>&1 && set OSR_REGAVAILABLE=1

:: This is set by client-side keyword substitution
set SVN_REVISION=$Revision: 27 $
:: Extract the revision number from the revision keyword
set SVN_REVISION=%SVN_REVISION:~0,-2%
set SVN_REVISION=%SVN_REVISION:~11%
:: This is set by client-side keyword substitution
set SVN_REVDATE=$Date: 2008-09-06 12:02:06 +0000 (Sat, 06 Sep 2008) $
:: Extract the date from the Date keyword
set SVN_REVDATE=%SVN_REVDATE:~7,10%
set VERSION=%VERSION%/r%SVN_REVISION%

:: Init some special variables
set OSR_VERSTR=OSR DDKBUILD.CMD %VERSION% (%SVN_REVDATE%) - OSR, Open Systems Resources, Inc.
set OSR_PREBUILD_SCRIPT=ddkprebld.cmd
set OSR_POSTBUILD_SCRIPT=ddkpostbld.cmd
set OSR_SETENV_SCRIPT=ddkbldenv.cmd
set OSR_ECHO=@echo DDKBLD:

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set error messages
:: Possible codes: 1
set ERR_UnknownBuildType=Unknown type of build. Please recheck parameters.
:: Possible codes: 2
set ERR_NoWdfRoot=WDF_ROOT is not defined, are you using 00.01.5054 or later?
:: Possible codes: 3
set ERR_BaseDirNotSet=To build using type %%OSR_TARGET%% you need to set the %%%%%%BASEDIRVAR%%%%%% environment variable to point to the %%BASEDIROS%% DDK base directory!
:: Possible codes: 4
set ERR_NoBASEDIR=NT4BASE, W2KBASE, WXPBASE and/or WNETBASE environment variable(s) not set. Environment variable(s) must be set by user according to DDK version(s) installed.
:: Possible codes: 5
set ERR_BadMode=^<build type^> must be 'checked', 'free', 'chk' or 'fre' (case-insensitive).
:: Possible codes: 6
set ERR_NoTarget=Target directory must contain a SOURCES or DIRS file.
:: Possible codes: 7, 8
set ERR_NoDir=The ^<directory^> parameter must be a valid directory.
:: Possible codes: 9
set ERR_SetEnvFailed=The SETENV script failed.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Clear the error code variable
set OSR_ERRCODE=0
set prefast_build=0

:: Turn on tracing, use %OSR_TRACE% instead of ECHO
if /i "%OSR_DEBUG%" == "on" (set OSR_TRACE=%OSR_ECHO% [TRACE]) else (set OSR_TRACE=rem)
:: Turn on echoing of current line if %OSR_DEBUG% is set to "on"
@echo %OSR_DEBUG%

:: Output version string
@echo %OSR_VERSTR%
%OSR_TRACE% ^(Current module: ^"%~f0^"^)
@echo.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Set the target platform variable
set OSR_TARGET=%~1
:: Remove any dashes in the variable
if not "%OSR_TARGET%" == "" set OSR_TARGET=%OSR_TARGET:-=%
:: Show help if the target parameter is empty after removal of the dashes
if "%OSR_TARGET%" == "" goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: In the build directory check for this script and call it if it exists.
:: This allows to override any global system variable setting, if desired.
if not "%3" == "" call :GetCustomEnvironment "%~f3"
if not "%OSR_ERRCODE%" == "0" goto :USAGE
:: Additional error handling for better usability
:: These subroutines will also attempt to locate the requested DDK!!!
set OSR_ERRCODE=3
%OSR_TRACE% Checking whether the environment variable for the build type was set
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Check > NUL 2>&1
:: If the BASEDIROS/BASEDIRVAR variable is not defined, it means the subroutine did not exist!
if not DEFINED BASEDIROS call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIROS)" & goto :USAGE
if not DEFINED BASEDIRVAR call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (BASEDIRVAR)" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BaseDirNotSet%" & goto :USAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
set BASEDIR=%%%BASEDIRVAR%%%
call :ResolveVar BASEDIR
call :MakeShort BASEDIR "%BASEDIR%"
:: Check for existing %BASEDIR%
if "%BASEDIR%" == "" call :ShowErrorMsg 4 "%ERR_NoBASEDIR%" & goto :USAGE
set PATH=%BASEDIR%\bin;%PATH%
%OSR_TRACE% Now jump to the initialization of the commandline
:: Calling as a subroutine has 2 advantages:
:: 1. the script does not quit if the label was not found
:: 2. we return to the line after the call and can check variables there
call :%OSR_TARGET%Build

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_TRACE% We returned from the variable initialization
if not DEFINED OSR_CMDLINE call :ShowErrorMsg 1 "%ERR_UnknownBuildType% (OSR_CMDLINE)" & goto :USAGE

%OSR_TRACE% Hurrah, all the variables have been initialized, continuing
:: Proceed with common build steps
goto :CommonBuild

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Check whether the parameter makes sense and try to
:: correct it if possible
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WLH64Check
:WLHA64Check
:WLHXP64Check
:WLHNET64Check
:WLHNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WLHCheck
:WLHX64Check
:WLHI64Check
:WLHNETX64Check
:WLHNETI64Check
:WLHXPCheck
:WLH2KCheck
:WLHNETCheck
set BASEDIROS=Windows Vista/Windows 2008 Server
set BASEDIRVAR=WLHBASE
:: Compatibility between BUILD and VS ... prevent pipes from being used
%OSR_ECHO% Clearing %%VS_UNICODE_OUTPUT%% ...
set VS_UNICODE_OUTPUT=
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "6001.18000 6000"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:WNETW2KCheck
:WNETA64Check
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WNET2KCheck
:WNETXPCheck
:WNETWXPCheck
:WNETXP64Check
:WNET64Check
:WNETI64Check
:WNETAMD64Check
:WNETX64Check
:WNETCheck
set BASEDIROS=Windows 2003 Server
set BASEDIRVAR=WNETBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "3790.1830 3790.1218 3790"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: These labels are for compatibility with the respective
:: modes supported by another flavor of DDKBUILD.
:XPCheck
:XP64Check
:XPW2KCheck
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:WXP64Check
:WXPI64Check
:WXPCheck
:WXP2KCheck
set BASEDIROS=Windows XP
set BASEDIRVAR=WXPBASE
:: Other flavor of DDKBUILD
if not DEFINED WXPBASE if DEFINED XPBASE set BASEDIRVAR=XPBASE
:: Return to caller if the BASEDIR is already defined (either customized or global)
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :DetectBaseDirTemp "2600.1106 2600"
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :CommonCheckSetVarWithReturn
goto :CommonCheckErrorNotDetectedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:W2K64Check
:W2KI64Check
:W2KCheck
set BASEDIROS=Windows 2000
set BASEDIRVAR=W2KBASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:NT4Check
set BASEDIROS=Windows NT4
set BASEDIRVAR=NT4BASE
:: Return to caller
if DEFINED %BASEDIRVAR% goto :CommonCheckNoErrorWithReturn
call :CommonCheckMsg2
goto :CommonCheckErrorNotSupportedWithReturn

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg1
echo.
%OSR_ECHO% WARNING: %%%BASEDIRVAR%%% NOT SET!
%OSR_ECHO%   Attempting to auto-detect the installation folder and set %%%BASEDIRVAR%%%.
%OSR_ECHO%   (If this fails *you* will have to set it!)
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckMsg2
echo.
%OSR_ECHO% WARNING:
%OSR_ECHO%   Auto-detection of the folder settings is not supported for the requested DDK.
%OSR_ECHO%   Please set %%%BASEDIRVAR%%% yourself!
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckSetVarWithReturn
%OSR_ECHO% Found!
echo.
set %BASEDIRVAR%=%BASEDIRTEMP%
set BASEDIRTEMP=
:: Tell the caller it was successful
:CommonCheckNoErrorWithReturn
set OSR_ERRCODE=0
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CommonCheckErrorNotDetectedWithReturn
echo.
%OSR_ECHO% None of the usual default paths works. Set %%%BASEDIRVAR%%% manually!
:CommonCheckErrorNotSupportedWithReturn
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Initialize variables specific to the respective platform
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: 
:: Valid parameters for setenv in different DDKs/WDKs:
::
:: 2600       - "setenv <directory> [fre|chk] [64] [hal]"
:: 2600.1106  - "setenv <directory> [fre|chk] [64] [hal] [WXP|W2K]"
:: 3790       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K]"
:: 3790.1830  - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WXP|WNET|W2K] [no_prefast] [bscmake]"
:: 6000       - "setenv <directory> [fre|chk] [64|AMD64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"
:: 6001.18000 - "setenv <directory> [fre|chk] [64|x64] [hal] [WLH|WXP|WNET|W2K] [bscmake]"

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: NT 4.0 build using NT4 DDK
:NT4Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% "%%MSDEVDIR%%"
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WXP DDK
:XPW2KBuild
:WXP2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\w2k\set2k.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 64bit (Intel) using W2K DDK
:W2K64Build
:W2KI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv64.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using W2K DDK
:W2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WXP DDK
:XP64Build
:WXP64Build
:WXPI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WXP DDK
:XPBuild
:WXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WNET DDK
:WNETW2KBuild
:WNET2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% W2K %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WNET DDK
:WNETXPBuild
:WNETWXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit using WNET DDK
:WNETXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WNET DDK
:WNET64Build
:WNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WNET DDK
:WNETA64Build
:WNETAMD64Build
:WNETX64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% AMD64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WNET DDK
:WNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%%
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 32bit using WLH DDK
:WLHBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (AMD) using WLH DDK
:WLHA64Build
:WLHX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WLH build for 64bit (Intel) using WLH DDK
:WLH64Build
:WLHI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WLH
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (AMD) using WLH DDK
:WLHNETA64Build
:WLHNETX64Build
call :DetectVistaWDK
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% %OSR_AMD64FLAG% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 64bit (Intel) using WLH DDK
:WLHNET64Build
:WLHNETI64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 32bit using WLH DDK
:WLHXPBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WXP build for 64bit (Intel) using WLH DDK
:WLHXP64Build
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% 64 WXP
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: W2K build for 32bit using WLH DDK
:WLH2KBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% W2K
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: WNET build for 32bit using WLH DDK
:WLHNETBuild
set OSR_CMDLINE="%%BASEDIR%%\bin\setenv.bat" %%BASEDIR%% %%BuildMode%% WNET
goto :EOF

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: All builds go here for the rest of the procedure. Now,
:: we are getting ready to call build. The big problem
:: here is to figure our the name of the buildxxx files
:: being generated for the different platforms.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:CommonBuild
:: Remove first command line arg
shift
call :SetMode %1
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_BadMode%" & goto :USAGE
set OSR_BUILDNAME=%OSR_TARGET% (%BuildMode%) using the %BASEDIROS% DDK and %%%BASEDIRVAR%%%

call :CheckTargets %2
if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :USAGE
if not "%OSR_ERRCODE%" == "0" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :USAGE

:: Resolve any variables in the command line string
call :ResolveVar OSR_CMDLINE

pushd .
set ERRORLEVEL=0
:: This external script prepares the build environment (e.g. setenv.bat)
call %OSR_CMDLINE%
:: Will only work with newer SETENV.BAT versions, but will be helpful in this case.
if not "%ERRORLEVEL%" == "0" call :ShowErrorMsg 9 "%ERR_SetEnvFailed%" & goto :USAGE
popd

:: ----------------------------------------------------------------------------
:: Setting global variables for the scope of this CMD session
set NO_BROWSER_FILE=
set NO_BINPLACE=
set buildDirectory=%~fs2
call :MakeShort buildDirectory "%buildDirectory%"
set buildDirectory_raw=%2
set buildDirectory_fname=%~n2
%OSR_TRACE% buildDirectory       == %buildDirectory%
%OSR_TRACE% buildDirectory_raw   == %buildDirectory_raw%
%OSR_TRACE% buildDirectory_fname == %buildDirectory_fname%

set mpFlag=-M
if "%BUILD_ALT_DIR%" == "" goto :NT4

:: W2K sets this!
set OSR_EXT=%BUILD_ALT_DIR%
set mpFlag=-MI

:NT4
if "%NUMBER_OF_PROCESSORS%" == "" set mpFlag=
if "%NUMBER_OF_PROCESSORS%" == "1" set mpFlag=

:: Set additional variables at this point or do whatever you please
@if exist "%buildDirectory%\%OSR_PREBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_PREBUILD_SCRIPT%" > "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_PREBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished pre-build steps [%OSR_PREBUILD_SCRIPT%] ...
)
:: Save the current directory (before changing into the build directory!)
:: AFTERPREBUILD
pushd .

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Determine the settings of flags, WDF and PREFAST in
:: other words what was set for %3 and beyond....
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%OSR_ECHO% %OSR_BUILDNAME%
set OSR_ARGS= + argument(s):
if not "%3" == "" set OSR_ARGS=%OSR_ARGS% %3
if not "%4" == "" set OSR_ARGS=%OSR_ARGS% %4
if not "%5" == "" set OSR_ARGS=%OSR_ARGS% %5
if /i "%OSR_ARGS%" == " + argument(s):" set OSR_ARGS=
%OSR_ECHO% Directory: %buildDirectory%%OSR_ARGS%
%OSR_ECHO% %BASEDIRVAR%: %BASEDIR%

cd /D %~s2
set bFlags=-Ze
set bscFlags=

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ContinueParsing
if "%3" == "" goto :DONE
if "%3" == "/a" goto :RebuildallFound
if /i "%3" == "-WDF" goto :WDFFound
if /i "%3" == "-PREFAST" goto :PrefastFound
set bscFlags=/n
set bFlags=%bFlags% %3
:: Remove next arg
shift
goto :ContinueParsing

:WDFFound
shift
:: Note, that the setwdf.bat is called from setenv.bat in the WDK,
:: therefore we skip it.
if /i "%BASEDIRVAR%" == "WLHBASE" goto :WDFOkay
if "%WDF_ROOT%" == "" call :ShowErrorMsg 2 "%ERR_NoWdfRoot%" & goto :USAGE
pushd .
if exist "%WDF_ROOT%\set_wdf_env.cmd" call "%WDF_ROOT%\set_wdf_env.cmd"
popd
:WDFOkay
goto :ContinueParsing

:PrefastFound
shift
set prefast_build=1
goto :ContinueParsing

:RebuildallFound
shift
set bscFlags=/n
set bFlags=%bFlags:-Ze=-cfeZ%
set bFlags=%bFlags: -cZ=%
goto :ContinueParsing
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:DONE
for %%x in (build%OSR_EXT%.err build%OSR_EXT%.wrn build%OSR_EXT%.log prefast%OSR_EXT%.log) do @(
  if exist "%%x"   del /f /q "%%x"
)

if not "%prefast_build%" == "0" goto :RunPrefastBuild
%OSR_ECHO% Run build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
pushd .
build %mpFlag% %bFlags%
popd
goto :BuildComplete

:RunPrefastBuild
%OSR_ECHO% Run prefast build %mpFlag% %bFlags% for %BuildMode% version in %buildDirectory_raw%
setlocal ENABLEEXTENSIONS & pushd .
set PREFASTLOG=PREfast_defects_%OSR_EXT%.xml
prefast /log=%PREFASTLOG% /reset build %mpFlag% %bFlags% > NUL 2>&1
if "%errorlevel%" GTR "0" set OSR_ERRCODE=%errorlevel%
prefast /log=%PREFASTLOG% list > prefast%OSR_EXT%.log
%OSR_ECHO% The PREfast logfile is ^"%prefastlog%^"!
popd & endlocal

:BuildComplete
if not "%errorlevel%" == "0" set OSR_ERRCODE=%errorlevel%

@echo %OSR_DEBUG%
:: Assume that the onscreen errors are complete!
setlocal
set WARNING_FILE_COUNT=0
if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+1
)
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% ================ Build warnings =======================
  if exist "build%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][DRCLU][0-9][0-9]* error[^.][DRCLU][0-9][0-9]*" "build%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set WARNING_FILE_COUNT_PRE=0
if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
  set /a WARNING_FILE_COUNT_PRE=%WARNING_FILE_COUNT_PRE%+1
)
:: Reset if this is no PREfast build
if "%prefast_build%" == "0" set WARNING_FILE_COUNT_PRE=0
if not "%WARNING_FILE_COUNT_PRE%" == "0" (
  %OSR_ECHO% =============== PREfast warnings ======================
  if exist "prefast%OSR_EXT%.log" for /f "tokens=*" %%x in ('findstr "warning[^.][CLU]*" "prefast%OSR_EXT%.log"') do @(
    @echo %%x
  )
)
set /a WARNING_FILE_COUNT=%WARNING_FILE_COUNT%+%WARNING_FILE_COUNT_PRE%
if not "%WARNING_FILE_COUNT%" == "0" (
  %OSR_ECHO% =======================================================
)
endlocal
@echo.
%OSR_ECHO% Build complete
%OSR_ECHO% Building browse information files
if exist "buildbrowse.cmd" call "buildbrowse.cmd" & goto :postBuildSteps
set sbrlist=sbrList.txt
if not exist sbrList%CPU%.txt goto :sbrDefault
set sbrlist=sbrList%CPU%.txt

:sbrDefault
if not exist %sbrlist% goto :postBuildSteps
:: Prepend blank space
if not "%bscFlags%" == "" set bscFlags= %bscFlags%
:: bscmake%bscFlags% prevents a double blank space ...
bscmake%bscFlags% @%sbrlist%

:: Perform whatever post-build steps
:postBuildSteps
:: Restore the current directory (after changing into the build directory!)
:: Search upwards for "AFTERPREBUILD" to find the corresponding PUSHD
popd
@if exist "%buildDirectory%\%OSR_POSTBUILD_SCRIPT%" @(
  %OSR_ECHO% ^>^> Performing post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
  pushd "%buildDirectory%"
  call "%OSR_POSTBUILD_SCRIPT%" > "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_POSTBUILD_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished post-build steps [%OSR_POSTBUILD_SCRIPT%] ...
)
goto :END
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MAIN function of the script
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / GetCustomEnvironment
::    First parameter is the "directory" that supposedly contains the SOURCES
::    or DIRS file (and the build scripts)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:GetCustomEnvironment
pushd .
call :CheckTargets "%~f1"
@if not "%OSR_ERRCODE%" == "0" @(
  echo.
  %OSR_ECHO% The target directory seemed to not contain a DIRS or SOURCES file
  %OSR_ECHO% when trying to set a custom environment! Quitting.
  set buildDirectory=%~f1
  if "%OSR_ERRCODE%" == "6" call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoTarget%" & goto :GetCustomEnvironment_ret
  call :ShowErrorMsg %OSR_ERRCODE% "%ERR_NoDir%" & goto :GetCustomEnvironment_ret
  goto :GetCustomEnvironment_ret
)
:: If the user provided a script to customize the environment, execute it.
@if exist "%~f1\%OSR_SETENV_SCRIPT%" @(
  %OSR_ECHO% ^>^> Setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
  pushd "%~f1"
  call "%OSR_SETENV_SCRIPT%" > "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  for /f "tokens=*" %%x in ('type "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"') do @(
    %OSR_ECHO% %%x
  )
  if exist "%TEMP%\%OSR_SETENV_SCRIPT%.tmp" del /f /q "%TEMP%\%OSR_SETENV_SCRIPT%.tmp"
  popd
  %OSR_ECHO% ^<^< Finished setting custom environment variables [%OSR_SETENV_SCRIPT%] ...
)
:GetCustomEnvironment_ret
popd
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ GetCustomEnvironment
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  / SetMode
::    Subroutine to validate the mode of the build passed in. It must be free,
::    FREE, fre, FRE or checked, CHECKED, chk, CHK. Anything else is an error.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetMode
set BuildMode=
if /i "%OSR_TARGET%" == "WLH2K" goto :SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=free
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=checked
goto :SetModeCommonEnd
:SetModeWLH2K
for %%f in (free fre) do if /i "%%f" == "%1" set BuildMode=f
for %%f in (checked chk) do if /i "%%f" == "%1" set BuildMode=c
:SetModeCommonEnd
%OSR_TRACE% Mode set to ^"%BuildMode%^"
if "%BuildMode%" == "" set OSR_ERRCODE=5
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  \ SetMode
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / CheckTargets subroutine
::   Subroutine to validate that the target directory exists and that there is
::   either a DIRS or SOURCES and MakeFile in it.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:CheckTargets
:: Building "stack frame"
setlocal & pushd . & set OSR_ERRCODE=0
set lTarget=%~1
if not "%lTarget%" == "" goto :CheckTargets1
set OSR_ERRCODE=7
goto :CheckTargets_ret
:CheckTargets1
if exist "%lTarget%" goto :CheckTargets2
set OSR_ERRCODE=8
goto :CheckTargets_ret
:CheckTargets2
if not exist "%lTarget%\DIRS" goto :CheckTargets3
set OSR_ERRCODE=0
goto :CheckTargets_ret
:CheckTargets3
if exist "%lTarget%\SOURCES" goto :CheckTargets4
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets4
if exist "%lTarget%\MAKEFILE" goto :CheckTargets5
set OSR_ERRCODE=6
goto :CheckTargets_ret
:CheckTargets5
set OSR_ERRCODE=0
:CheckTargets_ret
:: Cleaning "stack frame" and returning error code into global scope
popd & endlocal & set OSR_ERRCODE=%OSR_ERRCODE%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ CheckTargets subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ResolveVar subroutine
::   There is only one parameter, the name of the variable to be resolved!
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ResolveVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
set VAR_TEMPRET2=%%%VAR_NAME%%%
:ResolveVarLoop
set VAR_TEMPRET1=%VAR_TEMPRET2%
set VAR_TEMPRET2=%VAR_TEMPRET1%
for /f "tokens=*" %%i in ('echo %VAR_TEMPRET1%') do (
  set VAR_TEMPRET2=%%i
)
if not "%VAR_TEMPRET1%" == "%VAR_TEMPRET2%" goto :ResolveVarLoop
:: Re-export the variable out of the local scope
endlocal & set %VAR_NAME%=%VAR_TEMPRET1%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ResolveVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / MakeShort subroutine
::   Two parameters. First parameter is the variable name, second is the path
::   to convert into a short filename.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:MakeShort
setlocal ENABLEEXTENSIONS
:: Get the name of the variable we are working with and the path to convert
set VAR_NAME=%~1
set PATH_SHORT=%~dpns2
set PATH_EXTSHORT=%~xs2
if not "" == "%PATH_EXTSHORT%" set PATH_EXTSHORT=%PATH_EXTSHORT:~0,4%
set PATH_SHORT=%PATH_SHORT%%PATH_EXTSHORT%
endlocal & set %VAR_NAME%=%PATH_SHORT%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ MakeShort subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / ErrorWithUsage subroutine
::   This one will take the passed in parameters and build a nice error
::   message which is returned to the user along with the usage hints.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:ShowErrorMsg
@set OSR_ERRCODE=%~1
@set OSR_ERRMSG=%~2
@set OSR_ERRMSG=%OSR_ERRMSG:'="%
@set OSR_ERRMSG=ERROR #%OSR_ERRCODE%: %OSR_ERRMSG%
@echo.
%OSR_ECHO% %OSR_ERRMSG%
if DEFINED buildDirectory %OSR_ECHO% -^> Target directory: %buildDirectory%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ ErrorWithUsage subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / SetVar subroutine
::   Param1 == name of the variable, Param2 == value to be set for the variable
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:SetVar
:: Get the name of the variable we are working with
setlocal ENABLEEXTENSIONS & set VAR_NAME=%1
endlocal & set %VAR_NAME%=%~2
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ SetVar subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectVistaWDK subroutine
::   No parameters expected
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectVistaWDK
setlocal ENABLEEXTENSIONS
:: Newer flag (starting with W2K8) is default
set OSR_AMD64FLAG=x64
:: The Vista WDK accepted *only* "AMD64", the newer W2K8 WDK accepts only "x64"
:: We detect the older one by checking the setenv.bat for a certain string
findstr /C:"Windows Server Longhorn" "%BASEDIR%\bin\setenv.bat" > NUL 2>&1 && set OSR_AMD64FLAG=AMD64
endlocal & set OSR_AMD64FLAG=%OSR_AMD64FLAG%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectVistaWDK subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / DetectBaseDirTemp subroutine
::   The first parameter is the list of directory names to check, separated by
::   blank spaces.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:DetectBaseDirTemp
:: Get the name of the variable we are working with
if "%~1" == "" goto :EOF
setlocal ENABLEEXTENSIONS
call :CommonCheckMsg1
:: Try to find an installed DDK/WDK from the registry keys
if DEFINED OSR_REGAVAILABLE if not "%OSR_REGAVAILABLE%" == "0" (
  for %%i in (%~1) do @(
    call :RegTryBaseDirTemp "%%i"
  )
)
:: Try all the "default" locations
if not DEFINED BASEDIRTEMP (
  for %%i in (%~1) do @(
    for %%a in (WINDDK DDK) do @(
      call :BruteTryBaseDirTemp "%SystemDrive%\%%a\%%i"
      call :BruteTryBaseDirTemp "%ProgramFiles%\%%a\%%i"
    )
  )
)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP%
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ DetectBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTemp subroutine
::   Attempt to find the install key in the registry.
::   This functions tests old-style DDKs and new-style WDKs.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
call :RegTryBaseDirTempSingle "%~1" "LFNDirectory" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
call :RegTryBaseDirTempSingle "%~1\Setup" "BUILD" BASEDIRTEMP
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :RegTryBaseDirTemp_EOF
if not DEFINED BASEDIRTEMP (endlocal & goto :EOF)
:RegTryBaseDirTemp_EOF
%OSR_ECHO% Found directory (%BASEDIRTEMP%) from install key
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / RegTryBaseDirTempSingle subroutine
::   Attempt to find the install key in the registry.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:RegTryBaseDirTempSingle
setlocal ENABLEEXTENSIONS
set REGSUBKEY=%~1
set REGVALUE=%~2
set VARIABLETOSET=%~3
set REGMAINKEY=HKLM\SOFTWARE\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_WOW64
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_WOW64
set REGMAINKEY=HKLM\SOFTWARE\Wow6432Node\Microsoft\WINDDK
:: Test whether we can read the value below this key
reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%" > NUL 2>&1 || goto :RegTryBaseDirTempSingle_EOF
for /f "tokens=2*" %%i in ('reg query "%REGMAINKEY%\%REGSUBKEY%" /v "%REGVALUE%"^|findstr /C:"%REGVALUE%"') do @(
  call :SetVar _SETVARIABLE "%%j"
)
endlocal & set %VARIABLETOSET%=%_SETVARIABLE%
:RegTryBaseDirTempSingle_EOF
endlocal
goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ RegTryBaseDirTempSingle subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: / BruteTryBaseDirTemp subroutine
::   Brute-force test the given directory.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:BruteTryBaseDirTemp
if DEFINED BASEDIRTEMP if exist "%BASEDIRTEMP%" goto :EOF
setlocal ENABLEEXTENSIONS
:: We will not overwrite BASETEMPDIR if it has been set and is valid
:: Just try
set BASEDIRTEMP=%~1
%OSR_ECHO% Trying %BASEDIRTEMP% ...
if not exist "%BASEDIRTEMP%" (endlocal & goto :EOF)
endlocal & set BASEDIRTEMP=%BASEDIRTEMP% & goto :EOF
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: \ BruteTryBaseDirTemp subroutine
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Usage output
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:USAGE
@echo.
@echo USAGE:
@echo ======
@echo   %~n0 ^<target^> ^<build type^> ^<directory^> [flags] [-WDF] [-PREFAST]
@echo.
@echo Values for ^<target^>:
@echo    --------------------------------------------------------------------------
@echo     Target platform and OS   ^| Miscellaneous
@echo    --------------------------^|-----------------------------------------------
@echo     Target     ^| Windows     ^| CPU     ^| Base directory ^| Target alias(es)
@echo    ------------^|-------------^|---------^|----------------^|--------------------
@echo     -W2K       ^| 2000        ^| x86     ^| %%W2KBASE%%      ^|
@echo     -W2K64     ^| 2000        ^| Itanium ^| %%W2KBASE%%      ^| -W2KI64
@echo     -WXP       ^| XP          ^| x86     ^| %%WXPBASE%%      ^| -XP
@echo     -WXP64     ^| XP          ^| Itanium ^| %%WXPBASE%%      ^| -WXPI64, -XP64
@echo     -WXP2K     ^| 2000        ^| x86     ^| %%WXPBASE%%      ^| -XPW2K
@echo     -WNET      ^| 2003        ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNET64    ^| 2003        ^| Itanium ^| %%WNETBASE%%     ^| -WNETI64
@echo     -WNETXP    ^| XP          ^| x86     ^| %%WNETBASE%%     ^|
@echo     -WNETXP64  ^| XP          ^| Itanium ^| %%WNETBASE%%     ^|
@echo     -WNETAMD64 ^| 2003/XP x64 ^| x64     ^| %%WNETBASE%%     ^| -WNETX64, -WNETA64
@echo     -WNET2K    ^| 2000 SP3    ^| x86     ^| %%WNETBASE%%     ^| -WNETW2K
@echo     -WLH       ^| Vista/2008  ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLH2K     ^| 2000 SP4    ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP     ^| XP          ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHXP64   ^| XP          ^| Itanium ^| %%WLHBASE%%      ^|
@echo     -WLHNET    ^| 2003        ^| x86     ^| %%WLHBASE%%      ^|
@echo     -WLHNETI64 ^| 2003        ^| Itanium ^| %%WLHBASE%%      ^| -WLHNET64
@echo     -WLHNETX64 ^| 2003/XP x64 ^| x64     ^| %%WLHBASE%%      ^| -WLHNETA64
@echo     -WLHI64    ^| Vista/2008  ^| Itanium ^| %%WLHBASE%%      ^| -WLH64
@echo     -WLHX64    ^| Vista/2008  ^| x64     ^| %%WLHBASE%%      ^| -WLHA64
@echo     -NT4       ^| NT 4.0      ^| x86     ^| %%NT4BASE%%      ^|
@echo    --------------------------------------------------------------------------
@echo     Support for NT4 and W2K DDKs is deprecated and not checked anymore
@echo     in new versions. It may or may not work properly.
@echo    --------------------------------------------------------------------------
@echo.
@echo Values for ^<build type^>:
@echo       checked, chk     indicates a checked build
@echo       free, fre        indicates a free build
@echo.
@echo Remaining parameters ("opt!" = optional parameter):
@echo       ^<directory^>      path to build directory, try . (current directory)
@echo       [flags]    opt!  any flags you think should be passed to build (try /a
@echo                        for clean)
@echo       -WDF       opt!  performs a WDF build
@echo       -PREFAST   opt!  performs a PREFAST build
@echo.
@echo Special files:
@echo       The build target directory (where the DIRS or SOURCES file resides) can
@echo       contain the following files:
@echo       - %OSR_PREBUILD_SCRIPT%
@echo         Allows to include a step before the BUILD tool from the DDK is called
@echo         but after the environment for the respective DDK has been set!
@echo       - %OSR_POSTBUILD_SCRIPT%
@echo         Allows to include a step after the BUILD tool from the DDK is called,
@echo         so the environment is still available to the script.
@echo       - %OSR_SETENV_SCRIPT%
@echo         Allows to set (or override) _any_ environment variables that may exist
@echo         in the global environment. Thus you can set the base directory for the
@echo         DDK from inside this script, making your project more self-contained.
@echo.
@echo       DDKBUILD will only handle those files which exist, so you may choose to
@echo       use none, one or multiple of these script files.
@echo       (All scripts execute inside their current directory. Consider this!)
@echo.
@echo Examples:
@echo       ^"%~n0 -NT4 checked .^" (for NT4 BUILD)
@echo       ^"%~n0 -WXP64 chk .^"
@echo       ^"%~n0 -WXP chk c:\projects\myproject^"
@echo       ^"%~n0 -WNET64 chk .^"      (IA64 build)
@echo       ^"%~n0 -WNETAMD64 chk .^"   (AMD64/EM64T build)
@echo       ^"%~n0 -WNETXP chk . -cZ -WDF^"
@echo       ^"%~n0 -WNETXP chk . -cZ -PREFAST^"
@echo.
@echo       In order for this procedure to work correctly for each platform, it
@echo       requires an environment variable to be set up for certain platforms.
@echo       There is an auto-detection mechanism in this script, which will work best
@echo       if the DDK/WDK was installed using the normal installer (i.e. not just
@echo       copied). The auto-detection is based on the DDK/WDK for which you request
@echo       a build. Whenever you set the variable explicitly, this will take
@echo       precedence over the auto-detected path!
@echo       The environment variables are as follows:
@echo.
@echo       %%NT4BASE%%  - Set this up for ^"-NT4^" builds
@echo       %%W2KBASE%%  - Set this up for ^"-W2K^" and ^"-W2K64^" builds
@echo       %%WXPBASE%%  - Set this up for ^"-WXP^", ^"-WXP64^", ^"-WXP2K^" builds
@echo       %%WNETBASE%% - Set this up for ^"-WNET*^" builds
@echo       %%WLHBASE%%  - Set this up for ^"-WLH*^" builds
@echo.
@echo       %%WDF_ROOT%% must be set if attempting to do a WDF Build previous to the
@echo       Vista WDK (in later DDKs there is no need to set WDF_ROOT).
@echo.
@echo Path to this script:
@echo      %~f0
@echo.
@echo   %OSR_VERSTR%
@echo   -^> report any problems to ^<info@osr.com^> or ^<http://assarbad.net/contact/^>
@echo.

:END
popd & endlocal & exit /b %OSR_ERRCODE%
```

`hook_IDT/IDTHook/makefile`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

`hook_IDT/IDTHook/mybuild.bat`:

```bat
set WLHBASE=C:\WINDDK\7600.16385.0
set WDF_ROOT=C:\WINDDK\7600.16385.0
ddkbuild.cmd -WLH chk . -cZ -WDF
```

`hook_IDT/IDTHook/sources`:

```
TARGETNAME=IDTHook
#TARGETPATH=$(BASEDIR)\lib
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=.\

SOURCES=IDTHook.c


```

`hook_IDT/README.md`:

```md
##hook IDT
用WDK7600命令行可直接编译，会Hook系统的IDT中的3号中断，也就是INT 3断点的处理例程。

[http://www.cnblogs.com/lanrenxinxin/p/4360983.html](http://www.cnblogs.com/lanrenxinxin/p/4360983.html)
```