Project Path: arc_fdrechsler_mcp-server-idapro_zyok_l7o

Source Tree:

```txt
arc_fdrechsler_mcp-server-idapro_zyok_l7o
├── LICENSE
├── README.md
├── ida_remote_server.py
├── idaremoteclient.ts
├── image.png
├── index.ts
├── package-lock.json
├── package.json
└── tsconfig.json

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Florian Drechsler

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# IDA Pro MCP Server

A Model Context Protocol (MCP) server that enables AI assistants to interact with IDA Pro for reverse engineering and binary analysis tasks.

<a href="https://glama.ai/mcp/servers/@fdrechsler/mcp-server-idapro">
  <img width="380" height="200" src="https://glama.ai/mcp/servers/@fdrechsler/mcp-server-idapro/badge" alt="IDA Pro Server MCP server" />
</a>

## Overview

This project provides a bridge between AI assistants and IDA Pro, a popular disassembler and debugger used for reverse engineering software. It consists of three main components:

1. **IDA Pro Remote Control Plugin** (`ida_remote_server.py`): An IDA Pro plugin that creates an HTTP server to remotely control IDA Pro functions.
2. **IDA Remote Client** (`idaremoteclient.ts`): A TypeScript client for interacting with the IDA Pro Remote Control Server.
3. **MCP Server** (`index.ts`): A Model Context Protocol server that exposes IDA Pro functionality to AI assistants.

## Features

- Execute Python scripts in IDA Pro from AI assistants
- Retrieve information about binaries:
  - Strings
  - Imports
  - Exports
  - Functions
- Advanced binary analysis capabilities:
  - Search for immediate values in instructions
  - Search for text strings in the binary
  - Search for specific byte sequences
  - Get disassembly for address ranges
- Automate IDA Pro operations through a standardized interface
- Secure communication between components

## Prerequisites

- IDA Pro 8.3 or later
- Node.js 18 or later
- TypeScript

### Example usage ida_remote_server.py

```bash
curl -X POST -H "Content-Type: application/json" -d '{"script":"print(\"Script initialization...\")"}' http://127.0.0.1:9045/api/execute
{"success": true, "output": "Script initialization...\n"}
```

### Example usage MCP Server

![Roo Output](/image.png)

## Installation

### 1. Install the IDA Pro Remote Control Plugin

1. Copy `ida_remote_server.py` to your IDA Pro plugins directory:
   - Windows: `%PROGRAMFILES%\IDA Pro\plugins`
   - macOS: `/Applications/IDA Pro.app/Contents/MacOS/plugins`
   - Linux: `/opt/idapro/plugins`

2. Start IDA Pro and open a binary file.

3. The plugin will automatically start an HTTP server on `127.0.0.1:9045`.

### 2. Install the MCP Server

1. Clone this repository:
   ```bash
   git clone <repository-url>
   cd ida-server
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Build the project:
   ```bash
   npm run build
   ```

4. Configure the MCP server in your AI assistant's MCP settings file:
   ```json
   {
     "mcpServers": {
       "ida-pro": {
         "command": "node",
         "args": ["path/to/ida-server/dist/index.js"],
         "env": {}
       }
     }
   }
   ```

## Usage

Once installed and configured, the MCP server provides the following tool to AI assistants:

### run_ida_command

Executes an IDA Pro Python script.

**Parameters:**
- `scriptPath` (required): Absolute path to the script file to execute
- `outputPath` (optional): Absolute path to save the script's output to

**Example:**

```python
# Example IDA Pro script (save as /path/to/script.py)
import idautils

# Count functions
function_count = len(list(idautils.Functions()))
print(f"Binary has {function_count} functions")

# Get the first 5 function names
functions = list(idautils.Functions())[:5]
for func_ea in functions:
    print(f"Function: {ida_name.get_ea_name(func_ea)} at {hex(func_ea)}")

# Return data
return_value = function_count
```

The AI assistant can then use this script with:

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>run_ida_command</tool_name>
<arguments>
{
  "scriptPath": "/path/to/script.py"
}
</arguments>
</use_mcp_tool>
```

### search_immediate_value

Searches for immediate values in the binary's instructions.

**Parameters:**
- `value` (required): Value to search for (number or string)
- `radix` (optional): Radix for number conversion (default: 16)
- `startAddress` (optional): Start address for search
- `endAddress` (optional): End address for search

**Example:**

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>search_immediate_value</tool_name>
<arguments>
{
  "value": "42",
  "radix": 10
}
</arguments>
</use_mcp_tool>
```

### search_text

Searches for text strings in the binary.

**Parameters:**
- `text` (required): Text to search for
- `caseSensitive` (optional): Whether the search is case sensitive (default: false)
- `startAddress` (optional): Start address for search
- `endAddress` (optional): End address for search

**Example:**

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>search_text</tool_name>
<arguments>
{
  "text": "password",
  "caseSensitive": false
}
</arguments>
</use_mcp_tool>
```

### search_byte_sequence

Searches for a specific byte sequence in the binary.

**Parameters:**
- `bytes` (required): Byte sequence to search for (e.g., "90 90 90" for three NOPs)
- `startAddress` (optional): Start address for search
- `endAddress` (optional): End address for search

**Example:**

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>search_byte_sequence</tool_name>
<arguments>
{
  "bytes": "90 90 90"
}
</arguments>
</use_mcp_tool>
```

### get_disassembly

Gets disassembly for an address range.

**Parameters:**
- `startAddress` (required): Start address for disassembly
- `endAddress` (optional): End address for disassembly
- `count` (optional): Number of instructions to disassemble

**Example:**

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>get_disassembly</tool_name>
<arguments>
{
  "startAddress": "0x401000",
  "count": 10
}
</arguments>
</use_mcp_tool>
```

### get_functions

Gets the list of functions from the binary.

**Parameters:**
- None required

**Example:**

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>get_functions</tool_name>
<arguments>
{}
</arguments>
</use_mcp_tool>
```

### get_exports

Gets the list of exports from the binary.

**Parameters:**
- None required

**Example:**

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>get_exports</tool_name>
<arguments>
{}
</arguments>
</use_mcp_tool>
```

### get_strings

Gets the list of strings from the binary.

**Parameters:**
- None required

**Example:**

```
<use_mcp_tool>
<server_name>ida-pro</server_name>
<tool_name>get_strings</tool_name>
<arguments>
{}
</arguments>
</use_mcp_tool>
```

## IDA Pro Remote Control API

The IDA Pro Remote Control Plugin exposes the following HTTP endpoints:

- `GET /api/info`: Get plugin information
- `GET /api/strings`: Get strings from the binary
- `GET /api/exports`: Get exports from the binary
- `GET /api/imports`: Get imports from the binary
- `GET /api/functions`: Get function list
- `GET /api/search/immediate`: Search for immediate values in instructions
- `GET /api/search/text`: Search for text in the binary
- `GET /api/search/bytes`: Search for byte sequences in the binary
- `GET /api/disassembly`: Get disassembly for an address range
- `POST /api/execute`: Execute Python script (JSON/Form)
- `POST /api/executebypath`: Execute Python script from file path
- `POST /api/executebody`: Execute Python script from raw body

## Security Considerations

By default, the IDA Pro Remote Control Plugin only listens on `127.0.0.1` (localhost) for security reasons. This prevents remote access to your IDA Pro instance.

If you need to allow remote access, you can modify the `DEFAULT_HOST` variable in `ida_remote_server.py`, but be aware of the security implications.

## Development

### Building from Source

```bash
npm run build
```

### Running Tests

```bash
npm test
```

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Author

Florian Drechsler (@fdrechsler) fd@fdrechsler.com
```

`ida_remote_server.py`:

```py
"""
IDA Pro Remote Control Plugin

This plugin creates an HTTP server to remotely control certain IDA functions.
It exposes endpoints for executing scripts, getting strings, imports, exports, and functions.

Author: Florian Drechsler (@fdrechsler) fd@fdrechsler.com
"""

import idaapi
import idautils
import idc
import ida_funcs
import ida_bytes
import ida_nalt
import ida_name
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading
import socket
import ssl
import base64
import traceback
from urllib.parse import parse_qs, urlparse
import time

# Default settings
DEFAULT_HOST = "127.0.0.1"  # Localhost only for security
DEFAULT_PORT = 9045  
PLUGIN_NAME = "IDA Pro Remote Control"
PLUGIN_VERSION = "1.0.0"
AUTO_START = True  # Automatically start server on plugin load

# Global variables
g_server = None
g_server_thread = None

# Synchronization flags for execute_sync
MFF_FAST = 0x0  # Execute as soon as possible
MFF_READ = 0x1  # Wait for the database to be read-ready
MFF_WRITE = 0x2  # Wait for the database to be write-ready

class RemoteControlHandler(BaseHTTPRequestHandler):
    """HTTP request handler for the IDA Pro remote control plugin."""
    
    # Add timeout for HTTP requests
    timeout = 60  # 60-second timeout for HTTP requests
    
    def log_message(self, format, *args):
        """Override logging to use IDA's console."""
        print(f"[RemoteControl] {format % args}")
    
    def _send_response(self, status_code, content_type, content):
        """Helper method to send HTTP response."""
        try:
            self.send_response(status_code)
            self.send_header('Content-Type', content_type)
            self.send_header('Content-Length', len(content))
            self.end_headers()
            self.wfile.write(content)
        except (ConnectionResetError, BrokenPipeError, socket.error) as e:
            print(f"[RemoteControl] Connection error when sending response: {e}")
    
    def _send_json_response(self, data, status_code=200):
        """Helper method to send JSON response."""
        try:
            content = json.dumps(data).encode('utf-8')
            self._send_response(status_code, 'application/json', content)
        except Exception as e:
            print(f"[RemoteControl] Error preparing JSON response: {e}")
            # Try to send a simplified error response
            try:
                simple_error = json.dumps({'error': 'Internal server error'}).encode('utf-8')
                self._send_response(500, 'application/json', simple_error)
            except:
                # Silently fail if we can't even send the error
                pass
    
    def _send_error_response(self, message, status_code=400):
        """Helper method to send error response."""
        self._send_json_response({'error': message}, status_code)
    
    def _parse_post_data(self):
        """Parse POST data from request."""
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length).decode('utf-8')
        
        # Handle different content types
        content_type = self.headers.get('Content-Type', '')
        if 'application/json' in content_type:
            return json.loads(post_data)
        elif 'application/x-www-form-urlencoded' in content_type:
            parsed_data = parse_qs(post_data)
            # Convert lists to single values where appropriate
            return {k: v[0] if len(v) == 1 else v for k, v in parsed_data.items()}
        else:
            return {'raw_data': post_data}
    
    def do_GET(self):
        """Handle GET requests."""
        path = self.path.lower()
        
        try:
            if path == '/api/info':
                self._handle_info()
            elif path == '/api/strings':
                self._handle_get_strings()
            elif path == '/api/exports':
                self._handle_get_exports()
            elif path == '/api/imports':
                self._handle_get_imports()
            elif path == '/api/functions':
                self._handle_get_functions()
            elif path.startswith('/api/search/immediate'):
                self._handle_search_immediate()
            elif path.startswith('/api/search/text'):
                self._handle_search_text()
            elif path.startswith('/api/search/bytes'):
                self._handle_search_bytes()
            elif path.startswith('/api/search/names'):
                self._handle_search_in_names()
            elif path.startswith('/api/xrefs/to'):
                self._handle_get_xrefs_to()
            elif path.startswith('/api/xrefs/from'):
                self._handle_get_xrefs_from()
            elif path.startswith('/api/disassembly'):
                self._handle_get_disassembly()
            else:
                self._send_error_response('Endpoint not found', 404)
        except Exception as e:
            error_msg = f"Error processing request: {str(e)}\n{traceback.format_exc()}"
            print(f"[RemoteControl] {error_msg}")
            self._send_error_response(error_msg, 500)
    
    def do_POST(self):
        """Handle POST requests."""
        path = self.path.lower()
        
        try:
            if path == '/api/execute':
                self._handle_execute_script()
            elif path == '/api/executebypath':
                self._handle_execute_by_path()
            elif path == '/api/executebody':
                self._handle_execute_body()
            else:
                self._send_error_response('Endpoint not found', 404)
        except Exception as e:
            error_msg = f"Error processing request: {str(e)}\n{traceback.format_exc()}"
            print(f"[RemoteControl] {error_msg}")
            self._send_error_response(error_msg, 500)
    
    def _handle_info(self):
        """Handle info request."""
        result = self._execute_in_main_thread(self._get_info_impl)
        self._send_json_response(result)
    
    def _get_info_impl(self):
        """Implementation of getting info - runs in main thread."""
        info = {
            'plugin_name': PLUGIN_NAME,
            'plugin_version': PLUGIN_VERSION,
            'ida_version': idaapi.get_kernel_version(),
            'file_name': idaapi.get_input_file_path(),
            'endpoints': [
                {'path': '/api/info', 'method': 'GET', 'description': 'Get plugin information'},
                {'path': '/api/strings', 'method': 'GET', 'description': 'Get strings from binary'},
                {'path': '/api/exports', 'method': 'GET', 'description': 'Get exports from binary'},
                {'path': '/api/imports', 'method': 'GET', 'description': 'Get imports from binary'},
                {'path': '/api/functions', 'method': 'GET', 'description': 'Get function list'},
                {'path': '/api/search/immediate', 'method': 'GET', 'description': 'Search for immediate values'},
                {'path': '/api/search/text', 'method': 'GET', 'description': 'Search for text in binary'},
                {'path': '/api/search/bytes', 'method': 'GET', 'description': 'Search for byte sequence'},
                {'path': '/api/search/names', 'method': 'GET', 'description': 'Search for names/symbols in binary'},
                {'path': '/api/xrefs/to', 'method': 'GET', 'description': 'Get cross-references to an address'},
                {'path': '/api/xrefs/from', 'method': 'GET', 'description': 'Get cross-references from an address'},
                {'path': '/api/disassembly', 'method': 'GET', 'description': 'Get disassembly for an address range'},
                {'path': '/api/execute', 'method': 'POST', 'description': 'Execute Python script (JSON/Form)'},
                {'path': '/api/executebypath', 'method': 'POST', 'description': 'Execute Python script from file path'},
                {'path': '/api/executebody', 'method': 'POST', 'description': 'Execute Python script from raw body'},
            ]
        }
        return info
    
    def _handle_execute_script(self):
        """Handle script execution request."""
        post_data = self._parse_post_data()
        
        if 'script' not in post_data:
            self._send_error_response('No script provided')
            return
        
        script = post_data['script']
        
        # Execute script in the main thread
        result = self._execute_in_main_thread(self._execute_script_impl, script)
        
        if 'error' in result:
            self._send_error_response(result['error'], 500)
        else:
            self._send_json_response(result)
    
    def _handle_execute_by_path(self):
        """Handle script execution from a file path."""
        post_data = self._parse_post_data()
        
        if 'path' not in post_data:
            self._send_error_response('No script path provided')
            return
        
        script_path = post_data['path']
        
        try:
            # Use IDA's main thread to read the file
            def read_script_file():
                try:
                    with open(script_path, 'r') as f:
                        return {'script': f.read()}
                except Exception as e:
                    return {'error': f"Could not read script file: {str(e)}"}
            
            file_result = self._execute_in_main_thread(read_script_file)
            
            if 'error' in file_result:
                self._send_error_response(file_result['error'], 400)
                return
            
            script = file_result['script']
            
            # Execute the script using our existing method
            result = self._execute_in_main_thread(self._execute_script_impl, script)
            
            if 'error' in result:
                self._send_error_response(result['error'], 500)
            else:
                self._send_json_response(result)
        
        except Exception as e:
            error_msg = f"Error executing script from path: {str(e)}\n{traceback.format_exc()}"
            print(f"[RemoteControl] {error_msg}")
            self._send_error_response(error_msg, 500)
    
    def _handle_execute_body(self):
        """Handle script execution from raw body content."""
        try:
            # Read raw body content
            content_length = int(self.headers.get('Content-Length', 0))
            if content_length > 1000000:  # 1MB limit
                self._send_error_response('Script too large (>1MB)', 413)
                return
                
            script = self.rfile.read(content_length).decode('utf-8')
            
            # Execute the script using our existing method
            result = self._execute_in_main_thread(self._execute_script_impl, script)
            
            if 'error' in result:
                self._send_error_response(result['error'], 500)
            else:
                self._send_json_response(result)
        
        except Exception as e:
            error_msg = f"Error executing script from body: {str(e)}\n{traceback.format_exc()}"
            print(f"[RemoteControl] {error_msg}")
            self._send_error_response(error_msg, 500)
    
    def _execute_script_impl(self, script):
        """Implementation of script execution - runs in main thread with safety measures."""
        # Create a safe execution environment with IDA modules
        exec_globals = {
            'idaapi': idaapi,
            'idautils': idautils,
            'idc': idc,
            'ida_funcs': ida_funcs,
            'ida_bytes': ida_bytes,
            'ida_nalt': ida_nalt,
            'ida_name': ida_name,
        }
        
        # Redirect stdout to capture output
        import io
        import sys
        import signal
        
        original_stdout = sys.stdout
        captured_output = io.StringIO()
        sys.stdout = captured_output
        
        # Create hooks to automatically respond to IDA prompts
        original_funcs = {}
        
        # Store original functions we're going to override
        original_funcs['ask_yn'] = idaapi.ask_yn
        original_funcs['ask_buttons'] = idaapi.ask_buttons
        original_funcs['ask_text'] = idaapi.ask_text
        original_funcs['ask_str'] = idaapi.ask_str
        original_funcs['ask_file'] = idaapi.ask_file
        original_funcs['display_copyright_warning'] = idaapi.display_copyright_warning
        
        # Also handle lower-level IDA UI functions
        if hasattr(idaapi, "get_kernel_version") and idaapi.get_kernel_version() >= "7.0":
            # IDA 7+ has these functions
            if hasattr(idaapi, "warning"):
                original_funcs['warning'] = idaapi.warning
                idaapi.warning = lambda *args, **kwargs: print(f"[AUTO-CONFIRM] Warning suppressed: {args}")
                
            if hasattr(idaapi, "info"):
                original_funcs['info'] = idaapi.info
                idaapi.info = lambda *args, **kwargs: print(f"[AUTO-CONFIRM] Info suppressed: {args}")
            
            # For specific known dialogs like the "bad digit" dialog
            if hasattr(idc, "set_inf_attr"):
                # Suppress "bad digit" dialogs with this setting
                original_funcs['INFFL_ALLASM'] = idc.get_inf_attr(idc.INF_AF)
                idc.set_inf_attr(idc.INF_AF, idc.get_inf_attr(idc.INF_AF) | 0x2000)  # Set INFFL_ALLASM flag
                
        # Create a UI hook to capture any other dialogs
        class DialogHook(idaapi.UI_Hooks):
            def populating_widget_popup(self, widget, popup):
                # Just suppress all popups
                print("[AUTO-CONFIRM] Suppressing popup")
                return 1
                
            def finish_populating_widget_popup(self, widget, popup):
                # Also suppress here
                print("[AUTO-CONFIRM] Suppressing popup finish")
                return 1
                
            def ready_to_run(self):
                # Always continue
                return 1
                
            def updating_actions(self, ctx):
                # Always continue
                return 1
                
            def updated_actions(self):
                # Always continue
                return 1
                
            def ui_refresh(self, cnd):
                # Suppress UI refreshes
                return 1

        # Install UI hook
        ui_hook = DialogHook()
        ui_hook.hook()
        
        # Functions to automatically respond to various prompts
        def auto_yes_no(*args, **kwargs):
            print(f"[AUTO-CONFIRM] Prompt intercepted (Yes/No): {args}")
            return idaapi.ASKBTN_YES  # Always respond YES
            
        def auto_buttons(*args, **kwargs):
            print(f"[AUTO-CONFIRM] Prompt intercepted (Buttons): {args}")
            return 0  # Return first button (usually OK/Yes/Continue)
            
        def auto_text(*args, **kwargs):
            print(f"[AUTO-CONFIRM] Prompt intercepted (Text): {args}")
            return ""  # Return empty string
            
        def auto_file(*args, **kwargs):
            print(f"[AUTO-CONFIRM] Prompt intercepted (File): {args}")
            return ""  # Return empty string
            
        def auto_ignore(*args, **kwargs):
            print(f"[AUTO-CONFIRM] Warning intercepted: {args}")
            return 0  # Just return something
        
        # Override IDA's prompt functions with our auto-response versions
        idaapi.ask_yn = auto_yes_no
        idaapi.ask_buttons = auto_buttons
        idaapi.ask_text = auto_text
        idaapi.ask_str = auto_text
        idaapi.ask_file = auto_file
        idaapi.display_copyright_warning = auto_ignore
        
        # IMPORTANT: Also override searching functions with safer versions
        # The "Bad digit" dialog is often triggered by these
        if hasattr(idc, "find_binary"):
            original_funcs['find_binary'] = idc.find_binary
            def safe_find_binary(ea, flag, searchstr, radix=16):
                # Always treat as a string by adding quotes if not present
                if '"' not in searchstr and "'" not in searchstr:
                    searchstr = f'"{searchstr}"'
                print(f"[AUTO-CONFIRM] Making search safe: {searchstr}")
                return original_funcs['find_binary'](ea, flag, searchstr, radix)
            idc.find_binary = safe_find_binary
            
        # Set batch mode to minimize UI interactions (stronger settings)
        orig_batch = idaapi.set_script_timeout(1)  # Set script timeout to suppress dialogs
        
        # Additional batch mode settings
        orig_user_screen_ea = idaapi.get_screen_ea()
        
        # Save current IDA settings
        try:
            # Enable batch mode if available
            if hasattr(idaapi, "batch_mode_enabled"):
                original_funcs['batch_mode'] = idaapi.batch_mode_enabled()
                idaapi.enable_batch_mode(True)
            
            # Disable analysis wait box
            if hasattr(idaapi, "set_flag"):
                idaapi.set_flag(idaapi.SW_SHHID_ITEM, True)  # Hide wait dialogs
                idaapi.set_flag(idaapi.SW_HIDE_UNDEF, True)  # Hide undefined items
                idaapi.set_flag(idaapi.SW_HIDE_SEGADDRS, True)  # Hide segment addressing
                
            # For newer versions of IDA
            if hasattr(idc, "batch"):
                original_funcs['batch_mode_idc'] = idc.batch(1)  # Enable batch mode
        
        except Exception as e:
            print(f"[AUTO-CONFIRM] Error setting batch mode: {e}")
        
        # Script timeout handling
        class TimeoutException(Exception):
            pass
            
        def timeout_handler(signum, frame):
            raise TimeoutException("Script execution timed out")
        
        # Set timeout for script execution (10 seconds)
        old_handler = None
        try:
            # Only set alarm on platforms that support it (not Windows)
            if hasattr(signal, 'SIGALRM'):
                old_handler = signal.signal(signal.SIGALRM, timeout_handler)
                signal.alarm(10)  # 10 second timeout
        except (AttributeError, ValueError):
            # Signal module might not have SIGALRM on Windows
            pass
            
        try:
            # Execute the script with size limit to prevent memory issues
            if len(script) > 1000000:  # 1MB limit
                return {'error': 'Script too large (>1MB)'}
                
            # Execute the script
            exec(script, exec_globals)
            output = captured_output.getvalue()
            
            # Get return value if set
            return_value = exec_globals.get('return_value', None)
            
            response = {
                'success': True,
                'output': output[:1000000]  # Limit output size to 1MB
            }
            
            if return_value is not None:
                try:
                    # Try to serialize return_value to JSON with size limit
                    json_str = json.dumps(return_value)
                    if len(json_str) <= 1000000:  # 1MB limit
                        response['return_value'] = return_value
                    else:
                        response['return_value'] = str(return_value)[:1000000] + "... (truncated)"
                except (TypeError, OverflowError):
                    # If not JSON serializable, convert to string with limit
                    response['return_value'] = str(return_value)[:1000000] + (
                        "... (truncated)" if len(str(return_value)) > 1000000 else "")
            
            return response
            
        except TimeoutException:
            error_msg = "Script execution timed out (exceeded 10 seconds)"
            print(f"[RemoteControl] {error_msg}")
            return {'error': error_msg}
        except MemoryError:
            error_msg = "Script caused a memory error"
            print(f"[RemoteControl] {error_msg}")
            return {'error': error_msg}
        except Exception as e:
            error_msg = f"Script execution error: {str(e)}\n{traceback.format_exc()}"
            print(f"[RemoteControl] {error_msg}")
            return {'error': error_msg}
        finally:
            # Restore stdout
            sys.stdout = original_stdout
            
            # Restore original IDA functions
            for func_name, original_func in original_funcs.items():
                # Special case for INFFL_ALLASM flag
                if func_name == 'INFFL_ALLASM':
                    idc.set_inf_attr(idc.INF_AF, original_func)
                # Special case for batch mode
                elif func_name == 'batch_mode':
                    if hasattr(idaapi, "enable_batch_mode"):
                        idaapi.enable_batch_mode(original_func)
                elif func_name == 'batch_mode_idc':
                    if hasattr(idc, "batch"):
                        idc.batch(original_func)
                else:
                    # For all other functions
                    try:
                        if hasattr(idaapi, func_name):
                            setattr(idaapi, func_name, original_func)
                        elif hasattr(idc, func_name):
                            setattr(idc, func_name, original_func)
                    except:
                        print(f"[RemoteControl] Failed to restore {func_name}")
            
            # Restore screen position
            idaapi.jumpto(orig_user_screen_ea)
            
            # Unhook UI hooks
            ui_hook.unhook()
            
            # Restore original batch mode
            idaapi.set_script_timeout(orig_batch)
            
            # Cancel alarm if set (for non-Windows platforms)
            try:
                if hasattr(signal, 'SIGALRM'):
                    signal.alarm(0)
                    if old_handler is not None:
                        signal.signal(signal.SIGALRM, old_handler)
            except (AttributeError, ValueError, UnboundLocalError):
                pass
    
    def _handle_get_strings(self):
        """Handle get strings request."""
        result = self._execute_in_main_thread(self._get_strings_impl)
        self._send_json_response(result)
    
    def _get_strings_impl(self):
        """Implementation of getting strings - runs in main thread."""
        min_length = 4  # Minimum string length to include
        strings_list = []
        
        # Get all strings from binary
        for ea in idautils.Strings():
            if ea.length >= min_length:
                string_value = str(ea)
                string_address = ea.ea
                string_info = {
                    'address': f"0x{string_address:X}",
                    'value': string_value,
                    'length': ea.length,
                    'type': 'pascal' if ea.strtype == 1 else 'c'
                }
                strings_list.append(string_info)
        
        return {
            'count': len(strings_list),
            'strings': strings_list
        }
    
    def _handle_get_exports(self):
        """Handle get exports request."""
        result = self._execute_in_main_thread(self._get_exports_impl)
        self._send_json_response(result)
    
    def _get_exports_impl(self):
        """Implementation of getting exports - runs in main thread."""
        exports_list = []
        
        # Process exports
        for ordinal, ea, name in idautils.Entries():
            exports_list.append({
                'address': f"0x{ea:X}",
                'name': name,
                'ordinal': ordinal
            })
        
        return {
            'count': len(exports_list),
            'exports': exports_list
        }
    
    def _handle_get_imports(self):
        """Handle get imports request."""
        result = self._execute_in_main_thread(self._get_imports_impl)
        self._send_json_response(result)
    
    def _get_imports_impl(self):
        """Implementation of getting imports - runs in main thread."""
        imports_list = []
        
        # Process imports
        nimps = ida_nalt.get_import_module_qty()
        for i in range(0, nimps):
            name = ida_nalt.get_import_module_name(i)
            if not name:
                continue
            
            def imp_cb(ea, name, ordinal):
                if name:
                    imports_list.append({
                        'address': f"0x{ea:X}",
                        'name': name,
                        'ordinal': ordinal
                    })
                return True
            
            ida_nalt.enum_import_names(i, imp_cb)
        
        return {
            'count': len(imports_list),
            'imports': imports_list
        }
    
    def _handle_get_functions(self):
        """Handle get functions request."""
        result = self._execute_in_main_thread(self._get_functions_impl)
        self._send_json_response(result)
    
    def _get_functions_impl(self):
        """Implementation of getting functions - runs in main thread."""
        functions_list = []
        
        # Get all functions
        for ea in idautils.Functions():
            func = ida_funcs.get_func(ea)
            if func:
                func_name = ida_name.get_ea_name(ea)
                function_info = {
                    'address': f"0x{ea:X}",
                    'name': func_name,
                    'size': func.size(),
                    'start': f"0x{func.start_ea:X}",
                    'end': f"0x{func.end_ea:X}",
                    'flags': func.flags
                }
                functions_list.append(function_info)
        
        return {
            'count': len(functions_list),
            'functions': functions_list
        }
        
    def _handle_search_immediate(self):
        """Handle search for immediate value request."""
        # Parse query parameters
        parsed_url = urlparse(self.path)
        params = parse_qs(parsed_url.query)
        
        # Get parameters with defaults
        value = params.get('value', [''])[0]
        if not value:
            self._send_error_response('Missing required parameter: value')
            return
            
        # Optional parameters
        try:
            radix = int(params.get('radix', ['16'])[0])
        except ValueError:
            radix = 16
            
        try:
            start_ea = int(params.get('start', ['0'])[0], 0)
        except ValueError:
            start_ea = 0
            
        try:
            end_ea = int(params.get('end', ['0'])[0], 0)
        except ValueError:
            end_ea = idc.BADADDR
            
        # Execute search in main thread
        result = self._execute_in_main_thread(
            self._search_immediate_impl,
            value,
            radix,
            start_ea,
            end_ea
        )
        self._send_json_response(result)
    
    def _search_immediate_impl(self, value, radix, start_ea, end_ea):
        """Implementation of searching for immediate values - runs in main thread."""
        results = []
        
        try:
            # Convert value to integer if it's a number
            if isinstance(value, str) and value.isdigit():
                value = int(value, radix)
                
            # Search for immediate values
            for ea in idautils.Functions():
                func = ida_funcs.get_func(ea)
                if not func:
                    continue
                    
                # Skip if outside specified range
                if start_ea > 0 and func.start_ea < start_ea:
                    continue
                if end_ea > 0 and func.start_ea >= end_ea:
                    continue
                
                # Iterate through instructions in the function
                current_ea = func.start_ea
                while current_ea < func.end_ea:
                    insn = idaapi.insn_t()
                    insn_len = idaapi.decode_insn(insn, current_ea)
                    if insn_len > 0:
                        # Check operands for immediate values
                        for i in range(len(insn.ops)):
                            op = insn.ops[i]
                            if op.type == idaapi.o_imm:
                                # If searching for a specific value
                                if isinstance(value, int) and op.value == value:
                                    disasm = idc.generate_disasm_line(current_ea, 0)
                                    results.append({
                                        'address': f"0x{current_ea:X}",
                                        'instruction': disasm,
                                        'value': op.value,
                                        'operand_index': i
                                    })
                                # If searching for a string pattern in the disassembly
                                elif isinstance(value, str) and value in idc.generate_disasm_line(current_ea, 0):
                                    disasm = idc.generate_disasm_line(current_ea, 0)
                                    results.append({
                                        'address': f"0x{current_ea:X}",
                                        'instruction': disasm,
                                        'value': op.value,
                                        'operand_index': i
                                    })
                        current_ea += insn_len
                    else:
                        current_ea += 1
        except Exception as e:
            return {'error': f"Error searching for immediate values: {str(e)}"}
            
        return {
            'count': len(results),
            'results': results
        }
    
    def _handle_search_text(self):
        """Handle search for text request."""
        # Parse query parameters
        parsed_url = urlparse(self.path)
        params = parse_qs(parsed_url.query)
        
        # Get parameters with defaults
        text = params.get('text', [''])[0]
        if not text:
            self._send_error_response('Missing required parameter: text')
            return
            
        # Optional parameters
        try:
            start_ea = int(params.get('start', ['0'])[0], 0)
        except ValueError:
            start_ea = 0
            
        try:
            end_ea = int(params.get('end', ['0'])[0], 0)
        except ValueError:
            end_ea = idc.BADADDR
            
        case_sensitive = params.get('case_sensitive', ['false'])[0].lower() == 'true'
        
        # Execute search in main thread
        result = self._execute_in_main_thread(
            self._search_text_impl,
            text,
            case_sensitive,
            start_ea,
            end_ea
        )
        self._send_json_response(result)
    
    def _search_text_impl(self, text, case_sensitive, start_ea, end_ea):
        """Implementation of searching for text - runs in main thread."""
        results = []
        
        try:
            # Get all strings from binary
            for string_item in idautils.Strings():
                if string_item.ea < start_ea:
                    continue
                if end_ea > 0 and string_item.ea >= end_ea:
                    continue
                    
                string_value = str(string_item)
                
                # Check if text is in string
                if (case_sensitive and text in string_value) or \
                   (not case_sensitive and text.lower() in string_value.lower()):
                    results.append({
                        'address': f"0x{string_item.ea:X}",
                        'value': string_value,
                        'length': string_item.length,
                        'type': 'pascal' if string_item.strtype == 1 else 'c'
                    })
        except Exception as e:
            return {'error': f"Error searching for text: {str(e)}"}
            
        return {
            'count': len(results),
            'results': results
        }
    
    def _handle_search_bytes(self):
        """Handle search for byte sequence request."""
        # Parse query parameters
        parsed_url = urlparse(self.path)
        params = parse_qs(parsed_url.query)
        
        # Get parameters with defaults
        byte_str = params.get('bytes', [''])[0]
        if not byte_str:
            self._send_error_response('Missing required parameter: bytes')
            return
            
        # Optional parameters
        try:
            start_ea = int(params.get('start', ['0'])[0], 0)
        except ValueError:
            start_ea = 0
            
        try:
            end_ea = int(params.get('end', ['0'])[0], 0)
        except ValueError:
            end_ea = idc.BADADDR
            
        # Execute search in main thread
        result = self._execute_in_main_thread(
            self._search_bytes_impl,
            byte_str,
            start_ea,
            end_ea
        )
        self._send_json_response(result)
        
    def _handle_search_in_names(self):
        """Handle search for names/symbols in the binary."""
        # Parse query parameters
        parsed_url = urlparse(self.path)
        params = parse_qs(parsed_url.query)
        
        # Get parameters with defaults
        pattern = params.get('pattern', [''])[0]
        if not pattern:
            self._send_error_response('Missing required parameter: pattern')
            return
            
        # Optional parameters
        case_sensitive = params.get('case_sensitive', ['false'])[0].lower() == 'true'
        
        # Get name type if specified
        name_type = params.get('type', ['all'])[0].lower()
        
        # Execute search in main thread
        result = self._execute_in_main_thread(
            self._search_in_names_impl,
            pattern,
            case_sensitive,
            name_type
        )
        self._send_json_response(result)
    
    def _search_bytes_impl(self, byte_str, start_ea, end_ea):
        """Implementation of searching for byte sequence - runs in main thread."""
        results = []
        
        try:
            # Ensure byte_str is properly formatted for IDA's find_binary
            # IDA expects a string like "41 42 43" or "41 ?? 43" where ?? is a wildcard
            # Clean up the input to ensure it's in the right format
            byte_str = byte_str.strip()
            if not byte_str.startswith('"') and not byte_str.startswith("'"):
                byte_str = f'"{byte_str}"'
            
            # Start searching
            ea = start_ea
            while ea != idc.BADADDR:
                ea = idc.find_binary(ea, idc.SEARCH_DOWN | idc.SEARCH_NEXT, byte_str)
                if ea == idc.BADADDR or (end_ea > 0 and ea >= end_ea):
                    break
                    
                # Get some context around the found bytes
                disasm = idc.generate_disasm_line(ea, 0)
                
                # Add to results
                results.append({
                    'address': f"0x{ea:X}",
                    'disassembly': disasm,
                    'bytes': ' '.join([f"{idc.get_wide_byte(ea + i):02X}" for i in range(8)])  # Show 8 bytes
                })
                
                # Move to next byte to continue search
                ea += 1
        except Exception as e:
            return {'error': f"Error searching for byte sequence: {str(e)}"}
            
        return {
            'count': len(results),
            'results': results
        }
    
    def _search_in_names_impl(self, pattern, case_sensitive, name_type):
        """Implementation of searching in names/symbols - runs in main thread."""
        results = []
        
        try:
            # Prepare name type filters
            is_func = name_type in ['function', 'func', 'functions', 'all']
            is_data = name_type in ['data', 'variable', 'variables', 'all']
            is_import = name_type in ['import', 'imports', 'all']
            is_export = name_type in ['export', 'exports', 'all']
            is_label = name_type in ['label', 'labels', 'all']
            
            # Get all names in the database
            for ea, name in idautils.Names():
                # Skip null names
                if not name:
                    continue
                
                # Apply pattern matching based on case sensitivity
                if (case_sensitive and pattern in name) or \
                   (not case_sensitive and pattern.lower() in name.lower()):
                    # Determine the type of the name
                    name_info = {
                        'address': f"0x{ea:X}",
                        'name': name,
                        'type': 'unknown'
                    }
                    
                    # Check if it's a function
                    if is_func and ida_funcs.get_func(ea) is not None:
                        name_info['type'] = 'function'
                        if ida_funcs.get_func(ea).start_ea == ea:  # Function start
                            name_info['disassembly'] = idc.generate_disasm_line(ea, 0)
                            name_info['is_start'] = True
                    
                    # Check if it's part of imports (using IDA's import list)
                    elif is_import and ida_nalt.is_imported(ea):
                        name_info['type'] = 'import'
                    
                    # Check if it's an export
                    elif is_export and ida_nalt.is_exported(ea):
                        name_info['type'] = 'export'
                    
                    # Check if it's a data variable
                    elif is_data and ida_bytes.is_data(ida_bytes.get_flags(ea)):
                        name_info['type'] = 'data'
                        name_info['data_type'] = idc.get_type_name(ea)
                    
                    # Check if it's a label (non-function named location)
                    elif is_label and not ida_funcs.get_func(ea):
                        name_info['type'] = 'label'
                        name_info['disassembly'] = idc.generate_disasm_line(ea, 0)
                    
                    # Filter out if it doesn't match the requested type
                    if name_type != 'all' and name_info['type'] != name_type and \
                       not (name_type in ['function', 'func', 'functions'] and name_info['type'] == 'function') and \
                       not (name_type in ['import', 'imports'] and name_info['type'] == 'import') and \
                       not (name_type in ['export', 'exports'] and name_info['type'] == 'export') and \
                       not (name_type in ['data', 'variable', 'variables'] and name_info['type'] == 'data') and \
                       not (name_type in ['label', 'labels'] and name_info['type'] == 'label'):
                        continue
                    
                    # Add to results
                    results.append(name_info)
            
            # Sort results by address
            results.sort(key=lambda x: int(x['address'], 16))
            
        except Exception as e:
            return {'error': f"Error searching in names: {str(e)}\n{traceback.format_exc()}"}
            
        return {
            'count': len(results),
            'results': results
        }
    
    def _handle_get_disassembly(self):
        """Handle get disassembly request."""
        # Parse query parameters
        parsed_url = urlparse(self.path)
        params = parse_qs(parsed_url.query)
        
        # Get parameters with defaults
        try:
            start_ea = int(params.get('start', ['0'])[0], 0)
        except ValueError:
            self._send_error_response('Invalid start address')
            return
            
        # Optional parameters
        try:
            end_ea = int(params.get('end', ['0'])[0], 0)
        except ValueError:
            end_ea = 0
            
        try:
            count = int(params.get('count', ['10'])[0])
        except ValueError:
            count = 10
            
        # Execute in main thread
        result = self._execute_in_main_thread(
            self._get_disassembly_impl,
            start_ea,
            end_ea,
            count
        )
        self._send_json_response(result)
    
    def _get_disassembly_impl(self, start_ea, end_ea, count):
        """Implementation of getting disassembly - runs in main thread."""
        disassembly = []
        
        try:
            # If end_ea is specified, use it, otherwise use count
            if end_ea > 0:
                current_ea = start_ea
                while current_ea < end_ea:
                    disasm = idc.generate_disasm_line(current_ea, 0)
                    bytes_str = ' '.join([f"{idc.get_wide_byte(current_ea + i):02X}" for i in range(min(16, idc.get_item_size(current_ea)))])
                    
                    disassembly.append({
                        'address': f"0x{current_ea:X}",
                        'disassembly': disasm,
                        'bytes': bytes_str,
                        'size': idc.get_item_size(current_ea)
                    })
                    
                    current_ea += idc.get_item_size(current_ea)
                    if len(disassembly) >= 1000:  # Limit to 1000 instructions for safety
                        break
            else:
                # Use count to limit the number of instructions
                current_ea = start_ea
                for _ in range(min(count, 1000)):  # Limit to 1000 instructions for safety
                    disasm = idc.generate_disasm_line(current_ea, 0)
                    bytes_str = ' '.join([f"{idc.get_wide_byte(current_ea + i):02X}" for i in range(min(16, idc.get_item_size(current_ea)))])
                    
                    disassembly.append({
                        'address': f"0x{current_ea:X}",
                        'disassembly': disasm,
                        'bytes': bytes_str,
                        'size': idc.get_item_size(current_ea)
                    })
                    
                    current_ea += idc.get_item_size(current_ea)
                    if current_ea == idc.BADADDR:
                        break
        except Exception as e:
            return {'error': f"Error getting disassembly: {str(e)}"}
            
        return {
            'count': len(disassembly),
            'disassembly': disassembly,
            'start_address': f"0x{start_ea:X}",
            'end_address': f"0x{end_ea:X}" if end_ea > 0 else None
        }
    
    def _handle_get_xrefs_to(self):
        """Handle get xrefs to address request."""
        # Parse query parameters
        parsed_url = urlparse(self.path)
        params = parse_qs(parsed_url.query)
        
        # Get parameters with defaults
        try:
            address = int(params.get('address', ['0'])[0], 0)
        except ValueError:
            self._send_error_response('Invalid address')
            return
            
        # Optional parameters
        xref_type = params.get('type', ['all'])[0].lower()
        
        # Execute in main thread
        result = self._execute_in_main_thread(
            self._get_xrefs_to_impl,
            address,
            xref_type
        )
        self._send_json_response(result)
    
    def _get_xrefs_to_impl(self, address, xref_type):
        """Implementation of getting xrefs to address - runs in main thread."""
        xrefs = []
        
        try:
            # Get all cross-references to the specified address
            for xref in idautils.XrefsTo(address, 0):
                # Determine xref type
                xref_info = {
                    'from_address': f"0x{xref.frm:X}",
                    'to_address': f"0x{xref.to:X}",
                    'type': self._get_xref_type_name(xref.type),
                    'is_code': xref.iscode
                }
                
                # Filter by type if specified
                if xref_type != 'all':
                    if xref_type == 'code' and not xref.iscode:
                        continue
                    if xref_type == 'data' and xref.iscode:
                        continue
                
                # Get function name if available
                func = ida_funcs.get_func(xref.frm)
                if func:
                    xref_info['function_name'] = ida_name.get_ea_name(func.start_ea)
                    xref_info['function_address'] = f"0x{func.start_ea:X}"
                
                # Get disassembly for context
                xref_info['disassembly'] = idc.generate_disasm_line(xref.frm, 0)
                
                xrefs.append(xref_info)
            
            # Sort by address
            xrefs.sort(key=lambda x: int(x['from_address'], 16))
            
        except Exception as e:
            return {'error': f"Error getting xrefs to address: {str(e)}\n{traceback.format_exc()}"}
            
        return {
            'count': len(xrefs),
            'xrefs': xrefs,
            'address': f"0x{address:X}",
            'name': ida_name.get_ea_name(address)
        }
    
    def _handle_get_xrefs_from(self):
        """Handle get xrefs from address request."""
        # Parse query parameters
        parsed_url = urlparse(self.path)
        params = parse_qs(parsed_url.query)
        
        # Get parameters with defaults
        try:
            address = int(params.get('address', ['0'])[0], 0)
        except ValueError:
            self._send_error_response('Invalid address')
            return
            
        # Optional parameters
        xref_type = params.get('type', ['all'])[0].lower()
        
        # Execute in main thread
        result = self._execute_in_main_thread(
            self._get_xrefs_from_impl,
            address,
            xref_type
        )
        self._send_json_response(result)
    
    def _get_xrefs_from_impl(self, address, xref_type):
        """Implementation of getting xrefs from address - runs in main thread."""
        xrefs = []
        
        try:
            # Get all cross-references from the specified address
            for xref in idautils.XrefsFrom(address, 0):
                # Determine xref type
                xref_info = {
                    'from_address': f"0x{xref.frm:X}",
                    'to_address': f"0x{xref.to:X}",
                    'type': self._get_xref_type_name(xref.type),
                    'is_code': xref.iscode
                }
                
                # Filter by type if specified
                if xref_type != 'all':
                    if xref_type == 'code' and not xref.iscode:
                        continue
                    if xref_type == 'data' and xref.iscode:
                        continue
                
                # Get target name if available
                target_name = ida_name.get_ea_name(xref.to)
                if target_name:
                    xref_info['target_name'] = target_name
                
                # Check if target is a function
                func = ida_funcs.get_func(xref.to)
                if func and func.start_ea == xref.to:
                    xref_info['target_is_function'] = True
                    xref_info['target_function_name'] = ida_name.get_ea_name(func.start_ea)
                
                # Get disassembly for context
                xref_info['target_disassembly'] = idc.generate_disasm_line(xref.to, 0)
                
                xrefs.append(xref_info)
            
            # Sort by address
            xrefs.sort(key=lambda x: int(x['to_address'], 16))
            
        except Exception as e:
            return {'error': f"Error getting xrefs from address: {str(e)}\n{traceback.format_exc()}"}
            
        return {
            'count': len(xrefs),
            'xrefs': xrefs,
            'address': f"0x{address:X}",
            'name': ida_name.get_ea_name(address)
        }
    
    def _get_xref_type_name(self, xref_type):
        """Convert IDA xref type code to human-readable name."""
        # Code cross-reference types
        if xref_type == idaapi.fl_CF:
            return "call_far"
        elif xref_type == idaapi.fl_CN:
            return "call_near"
        elif xref_type == idaapi.fl_JF:
            return "jump_far"
        elif xref_type == idaapi.fl_JN:
            return "jump_near"
        # Data cross-reference types
        elif xref_type == idaapi.dr_O:
            return "data_offset"
        elif xref_type == idaapi.dr_W:
            return "data_write"
        elif xref_type == idaapi.dr_R:
            return "data_read"
        elif xref_type == idaapi.dr_T:
            return "data_text"
        elif xref_type == idaapi.dr_I:
            return "data_informational"
        else:
            return f"unknown_{xref_type}"
    
    def _execute_in_main_thread(self, func, *args, **kwargs):
        """Execute a function in the main thread with additional safeguards."""
        result_container = {}
        execution_done = threading.Event()
        
        def sync_wrapper():
            """Wrapper function to capture the result safely."""
            try:
                result_container['result'] = func(*args, **kwargs)
            except Exception as e:
                result_container['error'] = str(e)
                result_container['traceback'] = traceback.format_exc()
            finally:
                # Signal that execution has finished
                execution_done.set()
            return 0  # Must return an integer
        
        # Schedule execution in the main thread
        idaapi.execute_sync(sync_wrapper, MFF_READ)
        
        # Wait for the result with a timeout
        max_wait = 30  # Maximum wait time in seconds
        if not execution_done.wait(max_wait):
            error_msg = f"Operation timed out after {max_wait} seconds"
            print(f"[RemoteControl] {error_msg}")
            return {'error': error_msg}
        
        if 'error' in result_container:
            print(f"[RemoteControl] Error in main thread: {result_container['error']}")
            print(result_container.get('traceback', ''))
            return {'error': result_container['error']}
        
        return result_container.get('result', {'error': 'Unknown error occurred'})


class RemoteControlServer:
    """HTTP server for IDA Pro remote control."""
    
    def __init__(self, host=DEFAULT_HOST, port=DEFAULT_PORT):
        self.host = host
        self.port = port
        self.server = None
        self.server_thread = None
        self.running = False
    
    def start(self):
        """Start the HTTP server."""
        if self.running:
            print("[RemoteControl] Server is already running")
            return False
        
        try:
            self.server = HTTPServer((self.host, self.port), RemoteControlHandler)
            self.server_thread = threading.Thread(target=self.server.serve_forever)
            self.server_thread.daemon = True
            self.server_thread.start()
            self.running = True
            print(f"[RemoteControl] Server started on http://{self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"[RemoteControl] Failed to start server: {str(e)}")
            return False
    
    def stop(self):
        """Stop the HTTP server."""
        if not self.running:
            print("[RemoteControl] Server is not running")
            return False
        
        try:
            self.server.shutdown()
            self.server.server_close()
            self.server_thread.join()
            self.running = False
            print("[RemoteControl] Server stopped")
            return True
        except Exception as e:
            print(f"[RemoteControl] Failed to stop server: {str(e)}")
            return False
    
    def is_running(self):
        """Check if the server is running."""
        return self.running


class RemoteControlPlugin(idaapi.plugin_t):
    """IDA Pro plugin for remote control."""
    
    flags = idaapi.PLUGIN_KEEP
    comment = "Remote control for IDA through HTTP"
    help = "Provides HTTP endpoints to control IDA Pro remotely"
    wanted_name = PLUGIN_NAME
    wanted_hotkey = "Alt-R"
    
    def init(self):
        """Initialize the plugin."""
        print(f"[{PLUGIN_NAME}] Initializing...")
        
        # Auto-start server if configured
        if AUTO_START:
            global g_server
            g_server = RemoteControlServer(DEFAULT_HOST, DEFAULT_PORT)
            success = g_server.start()
            
            if success:
                print(f"[{PLUGIN_NAME}] Server auto-started on http://{DEFAULT_HOST}:{DEFAULT_PORT}")
                print(f"[{PLUGIN_NAME}] Available endpoints:")
           
            else:
                g_server = None
                print(f"[{PLUGIN_NAME}] Failed to auto-start server")
        
        return idaapi.PLUGIN_KEEP
    
    def run(self, arg):
        """Run the plugin when activated manually."""
        global g_server
        
        # Check if server is already running
        if g_server and g_server.is_running():
            response = idaapi.ask_yn(idaapi.ASKBTN_NO, 
                                     "Remote control server is already running.\nDo you want to stop it?")
            if response == idaapi.ASKBTN_YES:
                g_server.stop()
                g_server = None
            return
        
        # If AUTO_START is enabled but server isn't running, start with default settings
        if AUTO_START:
            g_server = RemoteControlServer(DEFAULT_HOST, DEFAULT_PORT)
            success = g_server.start()
            
            if success:
                print(f"[{PLUGIN_NAME}] Server started on http://{DEFAULT_HOST}:{DEFAULT_PORT}")
             
            else:
                g_server = None
                print(f"[{PLUGIN_NAME}] Failed to start server")
            return
        
        # Manual configuration if AUTO_START is disabled
        # Get host and port from user
        host = idaapi.ask_str(DEFAULT_HOST, 0, "Enter host address (e.g. 127.0.0.1):")
        if not host:
            host = DEFAULT_HOST
        
        port_str = idaapi.ask_str(str(DEFAULT_PORT), 0, "Enter port number:")
        try:
            port = int(port_str)
        except (ValueError, TypeError):
            port = DEFAULT_PORT
        
        # Start server
        g_server = RemoteControlServer(host, port)
        success = g_server.start()
        
        if success:
            print(f"[{PLUGIN_NAME}] Server started on http://{host}:{port}")
            print(f"[{PLUGIN_NAME}] Available endpoints:")
        
        else:
            g_server = None
            print(f"[{PLUGIN_NAME}] Failed to start server")
    
    def term(self):
        """Terminate the plugin."""
        global g_server
        
        if g_server and g_server.is_running():
            g_server.stop()
            g_server = None
        
        print(f"[{PLUGIN_NAME}] Plugin terminated")


# Register the plugin
def PLUGIN_ENTRY():
    """Return the plugin instance."""
    return RemoteControlPlugin()


# For testing/debugging in the script editor
if __name__ == "__main__":
    # This will only run when executed in the IDA script editor
    plugin = RemoteControlPlugin()
    plugin.run(0)
```

`idaremoteclient.ts`:

```ts
/**
 * IDA Pro Remote Control SDK
 * 
 * A TypeScript SDK for interacting with the IDA Pro Remote Control Server.
 * Provides type-safe methods for all endpoints of the IDA Pro Remote Control plugin.
 */

// Type definitions for responses

/**
 * Response from /api/info endpoint
 */
export interface InfoResponse {
    plugin_name: string;
    plugin_version: string;
    ida_version: string;
    file_name: string;
    endpoints: {
        path: string;
        method: string;
        description: string;
    }[];
}

/**
 * Response from /api/execute endpoint
 */
export interface ExecuteResponse {
    success: boolean;
    output: string;
    return_value?: any;
    error?: string;
}

/**
 * String information from /api/strings endpoint
 */
export interface StringInfo {
    address: string;
    value: string;
    length: number;
    type: 'c' | 'pascal';
}

/**
 * Response from /api/strings endpoint
 */
export interface StringsResponse {
    count: number;
    strings: StringInfo[];
}

/**
 * Immediate value search result from /api/search/immediate endpoint
 */
export interface ImmediateSearchResult {
    address: string;
    instruction: string;
    value: number;
    operand_index: number;
}

/**
 * Response from /api/search/immediate endpoint
 */
export interface ImmediateSearchResponse {
    count: number;
    results: ImmediateSearchResult[];
    error?: string;
}

/**
 * Text search result from /api/search/text endpoint
 */
export interface TextSearchResult {
    address: string;
    value: string;
    length: number;
    type: 'c' | 'pascal';
}

/**
 * Response from /api/search/text endpoint
 */
export interface TextSearchResponse {
    count: number;
    results: TextSearchResult[];
    error?: string;
}

/**
 * Byte sequence search result from /api/search/bytes endpoint
 */
export interface ByteSequenceSearchResult {
    address: string;
    disassembly: string;
    bytes: string;
}

/**
 * Response from /api/search/bytes endpoint
 */
export interface ByteSequenceSearchResponse {
    count: number;
    results: ByteSequenceSearchResult[];
    error?: string;
}

/**
 * Name search result from /api/search/names endpoint
 */
export interface NameSearchResult {
    address: string;
    name: string;
    type: string;
    disassembly?: string;
    data_type?: string;
    is_start?: boolean;
}

/**
 * Response from /api/search/names endpoint
 */
export interface NameSearchResponse {
    count: number;
    results: NameSearchResult[];
    error?: string;
}

/**
 * Cross-reference information from /api/xrefs endpoints
 */
export interface XrefInfo {
    from_address: string;
    to_address: string;
    type: string;
    is_code: boolean;
    function_name?: string;
    function_address?: string;
    disassembly?: string;
    target_name?: string;
    target_is_function?: boolean;
    target_function_name?: string;
    target_disassembly?: string;
}

/**
 * Response from /api/xrefs/to and /api/xrefs/from endpoints
 */
export interface XrefsResponse {
    count: number;
    xrefs: XrefInfo[];
    address: string;
    name: string;
    error?: string;
}

/**
 * Disassembly instruction from /api/disassembly endpoint
 */
export interface DisassemblyInstruction {
    address: string;
    disassembly: string;
    bytes: string;
    size: number;
}

/**
 * Response from /api/disassembly endpoint
 */
export interface DisassemblyResponse {
    count: number;
    disassembly: DisassemblyInstruction[];
    start_address: string;
    end_address?: string;
    error?: string;
}

/**
 * Export information from /api/exports endpoint
 */
export interface ExportInfo {
    address: string;
    name: string;
    ordinal: number;
}

/**
 * Response from /api/exports endpoint
 */
export interface ExportsResponse {
    count: number;
    exports: ExportInfo[];
}

/**
 * Import information from /api/imports endpoint
 */
export interface ImportInfo {
    address: string;
    name: string;
    ordinal: number;
}

/**
 * Response from /api/imports endpoint
 */
export interface ImportsResponse {
    count: number;
    imports: ImportInfo[];
}

/**
 * Function information from /api/functions endpoint
 */
export interface FunctionInfo {
    address: string;
    name: string;
    size: number;
    start: string;
    end: string;
    flags: number;
}

/**
 * Response from /api/functions endpoint
 */
export interface FunctionsResponse {
    count: number;
    functions: FunctionInfo[];
}

/**
 * Error response from any endpoint
 */
export interface ErrorResponse {
    error: string;
}

/**
 * Options for IDARemoteClient
 */
export interface IDARemoteClientOptions {
    /** Server host (default: 127.0.0.1) */
    host?: string;
    /** Server port (default: 9045) */
    port?: number;
    /** Request timeout in milliseconds (default: 30000) */
    timeout?: number;
}

/**
 * Client for IDA Pro Remote Control Server
 */
export class IDARemoteClient {
    private baseUrl: string;
    private timeout: number;

    /**
     * Create a new IDA Pro Remote Control client
     * @param options Configuration options
     */
    constructor(options: IDARemoteClientOptions = {}) {
        const host = options.host || '127.0.0.1';
        const port = options.port || 9045;
        this.timeout = options.timeout || 30000;
        this.baseUrl = `http://${host}:${port}/api`;
    }

    /**
     * Get information about the IDA Pro Remote Control server
     * @returns Server information
     */
    async getInfo(): Promise<InfoResponse> {
        return this.get<InfoResponse>('/info');
    }

    /**
     * Execute a Python script in IDA Pro
     * @param script Python script to execute
     * @returns Script execution results
     */
    async executeScript(script: string, logHTTP = false): Promise<ExecuteResponse> {

        return this.post<ExecuteResponse>('/execute', { script });
    }

    /**
 * Execute a Python script in IDA Pro
 * @param script Python script to execute
 * @returns Script execution results
 */
    async executeScriptByPath(path: string, logHTTP = false): Promise<ExecuteResponse> {

        return this.post<ExecuteResponse>('/executeByPath', { path });
    }

    /**
     * Get strings from the binary
     * @returns List of strings in the binary
     */
    async getStrings(): Promise<StringsResponse> {
        return this.get<StringsResponse>('/strings');
    }

    /**
     * Get exports from the binary
     * @returns List of exports in the binary
     */
    async getExports(): Promise<ExportsResponse> {
        return this.get<ExportsResponse>('/exports');
    }

    /**
     * Get imports from the binary
     * @returns List of imports in the binary
     */
    async getImports(): Promise<ImportsResponse> {
        return this.get<ImportsResponse>('/imports');
    }

    /**
     * Get functions from the binary
     * @returns List of functions in the binary
     */
    async getFunctions(): Promise<FunctionsResponse> {
        return this.get<FunctionsResponse>('/functions');
    }

    /**
     * Search for immediate values in the binary
     * @param value The value to search for (number or string)
     * @param options Optional search parameters
     * @returns Search results
     */
    async searchForImmediateValue(
        value: number | string,
        options: {
            radix?: number;
            startAddress?: number | string;
            endAddress?: number | string;
        } = {}
    ): Promise<ImmediateSearchResponse> {
        const params = new URLSearchParams();
        params.append('value', value.toString());
        
        if (options.radix !== undefined) {
            params.append('radix', options.radix.toString());
        }
        
        if (options.startAddress !== undefined) {
            const startAddr = typeof options.startAddress === 'string'
                ? options.startAddress
                : options.startAddress.toString();
            params.append('start', startAddr);
        }
        
        if (options.endAddress !== undefined) {
            const endAddr = typeof options.endAddress === 'string'
                ? options.endAddress
                : options.endAddress.toString();
            params.append('end', endAddr);
        }
        
        return this.get<ImmediateSearchResponse>(`/search/immediate?${params.toString()}`);
    }

    /**
     * Search for text in the binary
     * @param text The text to search for
     * @param options Optional search parameters
     * @returns Search results
     */
    async searchForText(
        text: string,
        options: {
            caseSensitive?: boolean;
            startAddress?: number | string;
            endAddress?: number | string;
        } = {}
    ): Promise<TextSearchResponse> {
        const params = new URLSearchParams();
        params.append('text', text);
        
        if (options.caseSensitive !== undefined) {
            params.append('case_sensitive', options.caseSensitive.toString());
        }
        
        if (options.startAddress !== undefined) {
            const startAddr = typeof options.startAddress === 'string'
                ? options.startAddress
                : options.startAddress.toString();
            params.append('start', startAddr);
        }
        
        if (options.endAddress !== undefined) {
            const endAddr = typeof options.endAddress === 'string'
                ? options.endAddress
                : options.endAddress.toString();
            params.append('end', endAddr);
        }
        
        return this.get<TextSearchResponse>(`/search/text?${params.toString()}`);
    }

    /**
     * Search for a byte sequence in the binary
     * @param byteSequence The byte sequence to search for (e.g., "90 90 90" for three NOPs)
     * @param options Optional search parameters
     * @returns Search results
     */
    async searchForByteSequence(
        byteSequence: string,
        options: {
            startAddress?: number | string;
            endAddress?: number | string;
        } = {}
    ): Promise<ByteSequenceSearchResponse> {
        const params = new URLSearchParams();
        params.append('bytes', byteSequence);
        
        if (options.startAddress !== undefined) {
            const startAddr = typeof options.startAddress === 'string'
                ? options.startAddress
                : options.startAddress.toString();
            params.append('start', startAddr);
        }
        
        if (options.endAddress !== undefined) {
            const endAddr = typeof options.endAddress === 'string'
                ? options.endAddress
                : options.endAddress.toString();
            params.append('end', endAddr);
        }
        
        return this.get<ByteSequenceSearchResponse>(`/search/bytes?${params.toString()}`);
    }

    /**
     * Search for names/symbols in the binary
     * @param pattern The pattern to search for in names
     * @param options Optional search parameters
     * @returns Search results
     */
    async searchInNames(
        pattern: string,
        options: {
            caseSensitive?: boolean;
            type?: 'function' | 'data' | 'import' | 'export' | 'label' | 'all';
        } = {}
    ): Promise<NameSearchResponse> {
        const params = new URLSearchParams();
        params.append('pattern', pattern);
        
        if (options.caseSensitive !== undefined) {
            params.append('case_sensitive', options.caseSensitive.toString());
        }
        
        if (options.type !== undefined) {
            params.append('type', options.type);
        }
        
        return this.get<NameSearchResponse>(`/search/names?${params.toString()}`);
    }

    /**
     * Get cross-references to an address
     * @param address The target address
     * @param options Optional parameters
     * @returns Cross-references information
     */
    async getXrefsTo(
        address: number | string,
        options: {
            type?: 'code' | 'data' | 'all';
        } = {}
    ): Promise<XrefsResponse> {
        const params = new URLSearchParams();
        
        const addr = typeof address === 'string'
            ? address
            : address.toString();
        params.append('address', addr);
        
        if (options.type !== undefined) {
            params.append('type', options.type);
        }
        
        return this.get<XrefsResponse>(`/xrefs/to?${params.toString()}`);
    }

    /**
     * Get cross-references from an address
     * @param address The source address
     * @param options Optional parameters
     * @returns Cross-references information
     */
    async getXrefsFrom(
        address: number | string,
        options: {
            type?: 'code' | 'data' | 'all';
        } = {}
    ): Promise<XrefsResponse> {
        const params = new URLSearchParams();
        
        const addr = typeof address === 'string'
            ? address
            : address.toString();
        params.append('address', addr);
        
        if (options.type !== undefined) {
            params.append('type', options.type);
        }
        
        return this.get<XrefsResponse>(`/xrefs/from?${params.toString()}`);
    }

    /**
     * Get disassembly for an address range
     * @param startAddress The starting address
     * @param options Optional parameters
     * @returns Disassembly instructions
     */
    async getDisassembly(
        startAddress: number | string,
        options: {
            endAddress?: number | string;
            count?: number;
        } = {}
    ): Promise<DisassemblyResponse> {
        const params = new URLSearchParams();
        
        const startAddr = typeof startAddress === 'string'
            ? startAddress
            : startAddress.toString();
        params.append('start', startAddr);
        
        if (options.endAddress !== undefined) {
            const endAddr = typeof options.endAddress === 'string'
                ? options.endAddress
                : options.endAddress.toString();
            params.append('end', endAddr);
        }
        
        if (options.count !== undefined) {
            params.append('count', options.count.toString());
        }
        
        return this.get<DisassemblyResponse>(`/disassembly?${params.toString()}`);
    }

    /**
     * Make a GET request to the server
     * @param endpoint API endpoint
     * @returns Response data
     */
    private async get<T>(endpoint: string): Promise<T> {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);

        try {
            const response = await fetch(`${this.baseUrl}${endpoint}`, {
                method: 'GET',
                signal: controller.signal,
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorData = await response.json() as ErrorResponse;
                throw new Error(errorData.error || `HTTP Error: ${response.status}`);
            }

            return await response.json() as T;
        } catch (error) {
            if (error instanceof DOMException && error.name === 'AbortError') {
                throw new Error(`Request to ${endpoint} timed out after ${this.timeout}ms`);
            }
            throw error;
        }
    }

    /**
     * Make a POST request to the server
     * @param endpoint API endpoint
     * @param data Request data
     * @returns Response data
     */
    private async post<T>(endpoint: string, data: any): Promise<T> {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);

        try {
            const response = await fetch(`${this.baseUrl}${endpoint}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data),
                signal: controller.signal,
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorData = await response.json() as ErrorResponse;
                throw new Error(errorData.error || `HTTP Error: ${response.status}`);
            }

            return await response.json() as T;
        } catch (error) {
            if (error instanceof DOMException && error.name === 'AbortError') {
                throw new Error(`Request to ${endpoint} timed out after ${this.timeout}ms`);
            }
            throw error;
        }
    }
}

// Example usage
/*
async function main() {
  const ida = new IDARemoteClient();
  
  try {
    // Get server info
    const info = await ida.getInfo();
    console.log('Connected to:', info.plugin_name, info.plugin_version);
    
    // Execute a script
    const scriptResult = await ida.executeScript(`
      import idautils
      
      # Count functions
      function_count = len(list(idautils.Functions()))
      print(f"Binary has {function_count} functions")
      
      # Return data
      return_value = function_count
    `);
    
    console.log('Script output:', scriptResult.output);
    console.log('Return value:', scriptResult.return_value);
    
    // Get functions
    const functions = await ida.getFunctions();
    console.log(`Retrieved ${functions.count} functions`);
    
    // Display first 5 functions
    functions.functions.slice(0, 5).forEach(func => {
      console.log(`${func.name} at ${func.address} (size: ${func.size})`);
    });
  } catch (error) {
    console.error('Error:', error.message);
  }
}
 
main();
*/
```

`index.ts`:

```ts
#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
    CallToolRequestSchema,
    ErrorCode,
    ListToolsRequestSchema,
    McpError,
} from '@modelcontextprotocol/sdk/types.js';
import { exec } from 'child_process';
import { promisify } from 'util';
import { join, dirname } from 'path';
import { existsSync, readFileSync, writeFileSync } from 'fs';
import { IDARemoteClient } from './idaremoteclient.js';
import { exists } from 'llamaindex';
const ida = new IDARemoteClient();
const execAsync = promisify(exec);
import { Collection, Document, MongoClient } from 'mongodb'
const url = 'mongodb://localhost:27017';
const client = new MongoClient(url);
const dbName = "strings"

let db
let collection: Collection<Document>


interface RunIdaCommandArgs {
    scriptPath: string;
    outputPath?: string;
}
interface RunIdaDirectCommandArgs {
    script: string;
}

interface SearchImmediateValueArgs {
    value: string | number;
    radix?: number;
    startAddress?: string | number;
    endAddress?: string | number;
}

interface SearchTextArgs {
    text: string;
    caseSensitive?: boolean;
    startAddress?: string | number;
    endAddress?: string | number;
}

interface SearchByteSequenceArgs {
    bytes: string;
    startAddress?: string | number;
    endAddress?: string | number;
}

interface GetDisassemblyArgs {
    startAddress: string | number;
    endAddress?: string | number;
    count?: number;
}

interface SearchInNamesArgs {
    pattern: string;
    caseSensitive?: boolean;
    type?: 'function' | 'data' | 'import' | 'export' | 'label' | 'all';
}

interface GetXrefsToArgs {
    address: string | number;
    type?: 'code' | 'data' | 'all';
}

interface GetXrefsFromArgs {
    address: string | number;
    type?: 'code' | 'data' | 'all';
}

interface GetFunctionsArgs {
    // No parameters required
}

interface GetExportsArgs {
    // No parameters required
}

interface GetStringsArgs {
    // No parameters required
}

const isValidRunIdaArgs = (args: any): args is RunIdaDirectCommandArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        (typeof args.script === 'string')
    );
};

const isValidSearchImmediateValueArgs = (args: any): args is SearchImmediateValueArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        (typeof args.value === 'string' || typeof args.value === 'number')
    );
};

const isValidSearchTextArgs = (args: any): args is SearchTextArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        typeof args.text === 'string'
    );
};

const isValidSearchByteSequenceArgs = (args: any): args is SearchByteSequenceArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        typeof args.bytes === 'string'
    );
};

const isValidGetDisassemblyArgs = (args: any): args is GetDisassemblyArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        (typeof args.startAddress === 'string' || typeof args.startAddress === 'number')
    );
};

const isValidSearchInNamesArgs = (args: any): args is SearchInNamesArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        typeof args.pattern === 'string'
    );
};

const isValidGetXrefsToArgs = (args: any): args is GetXrefsToArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        (typeof args.address === 'string' || typeof args.address === 'number')
    );
};

const isValidGetXrefsFromArgs = (args: any): args is GetXrefsFromArgs => {
    return (
        typeof args === 'object' &&
        args !== null &&
        (typeof args.address === 'string' || typeof args.address === 'number')
    );
};

const isValidGetFunctionsArgs = (args: any): args is GetFunctionsArgs => {
    return (
        typeof args === 'object' &&
        args !== null
    );
};

const isValidGetExportsArgs = (args: any): args is GetExportsArgs => {
    return (
        typeof args === 'object' &&
        args !== null
    );
};

const isValidGetStringsArgs = (args: any): args is GetStringsArgs => {
    return (
        typeof args === 'object' &&
        args !== null
    );
};

class IdaServer {
    private server: Server;

    constructor() {
        this.server = new Server(
            {
                name: 'ida-pro-server',
                version: '1.0.0',
            },
            {
                capabilities: {
                    tools: {}, // Will be populated in setup

                },
            }
        );

        this.setupToolHandlers();

        // Error handling
        this.server.onerror = (error) => console.error('[MCP Error]', error);
        process.on('SIGINT', async () => {
            await this.server.close();
            process.exit(0);
        });
    }

    private setupToolHandlers() {
        this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
            tools: [
                {
                    name: 'run_ida_command',
                    description: 'Execute an IDA Pro Script (IdaPython, Version IDA 8.3)',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            script: {
                                type: 'string',
                                description: 'script',
                            }
                        },
                        required: ['script'],
                    },
                },
                {
                    name: 'run_ida_command_filebased',
                    description: '(FOR IDE USAGE) Execute an IDA Pro Script (IdaPython, Version IDA 8.3)',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            scriptPath: {
                                type: 'string',
                                description: 'absolute Path to the script file to execute',
                            },
                            outputPath: {
                                type: 'string',
                                description: 'absolute Path to save the scripts output to',
                            },
                        },
                        required: ['scriptPath'],
                    },
                },
                {
                    name: 'search_immediate_value',
                    description: 'Search for immediate values in the binary',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            value: {
                                type: 'string',
                                description: 'Value to search for (number or string)',
                            },
                            radix: {
                                type: 'number',
                                description: 'Radix for number conversion (default: 16)',
                            },
                            startAddress: {
                                type: 'string',
                                description: 'Start address for search (optional)',
                            },
                            endAddress: {
                                type: 'string',
                                description: 'End address for search (optional)',
                            },
                        },
                        required: ['value'],
                    },
                },
                {
                    name: 'search_text',
                    description: 'Search for text in the binary',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            text: {
                                type: 'string',
                                description: 'Text to search for',
                            },
                            caseSensitive: {
                                type: 'boolean',
                                description: 'Whether the search is case sensitive (default: false)',
                            },
                            startAddress: {
                                type: 'string',
                                description: 'Start address for search (optional)',
                            },
                            endAddress: {
                                type: 'string',
                                description: 'End address for search (optional)',
                            },
                        },
                        required: ['text'],
                    },
                },
                {
                    name: 'search_byte_sequence',
                    description: 'Search for a byte sequence in the binary',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            bytes: {
                                type: 'string',
                                description: 'Byte sequence to search for (e.g., "90 90 90" for three NOPs)',
                            },
                            startAddress: {
                                type: 'string',
                                description: 'Start address for search (optional)',
                            },
                            endAddress: {
                                type: 'string',
                                description: 'End address for search (optional)',
                            },
                        },
                        required: ['bytes'],
                    },
                },
                {
                    name: 'get_disassembly',
                    description: 'Get disassembly for an address range',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            startAddress: {
                                type: 'string',
                                description: 'Start address for disassembly',
                            },
                            endAddress: {
                                type: 'string',
                                description: 'End address for disassembly (optional)',
                            },
                            count: {
                                type: 'number',
                                description: 'Number of instructions to disassemble (optional)',
                            },
                        },
                        required: ['startAddress'],
                    },
                },
                {
                    name: 'get_functions',
                    description: 'Get list of functions from the binary',
                    inputSchema: {
                        type: 'object',
                        properties: {},
                        required: [],
                    },
                },
                {
                    name: 'get_exports',
                    description: 'Get list of exports from the binary',
                    inputSchema: {
                        type: 'object',
                        properties: {},
                        required: [],
                    },
                },
                {
                    name: 'search_in_names',
                    description: 'Search for names/symbols in the binary',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            pattern: {
                                type: 'string',
                                description: 'Pattern to search for in names',
                            },
                            caseSensitive: {
                                type: 'boolean',
                                description: 'Whether the search is case sensitive (default: false)',
                            },
                            type: {
                                type: 'string',
                                description: 'Type of names to search for (function, data, import, export, label, all)',
                            },
                        },
                        required: ['pattern'],
                    },
                },
                {
                    name: 'get_xrefs_to',
                    description: 'Get cross-references to an address',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            address: {
                                type: 'string',
                                description: 'Target address to find references to',
                            },
                            type: {
                                type: 'string',
                                description: 'Type of references to find (code, data, all)',
                            },
                        },
                        required: ['address'],
                    },
                },
                {
                    name: 'get_xrefs_from',
                    description: 'Get cross-references from an address',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            address: {
                                type: 'string',
                                description: 'Source address to find references from',
                            },
                            type: {
                                type: 'string',
                                description: 'Type of references to find (code, data, all)',
                            },
                        },
                        required: ['address'],
                    },
                },
                {
                    name: 'get_strings',
                    description: 'Get list of strings from the binary',
                    inputSchema: {
                        type: 'object',
                        properties: {},
                        required: [],
                    },
                },
            ],
        }));



        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            // Handle different tool types based on the tool name
            switch (request.params.name) {
                case 'run_ida_command':
                    if (!isValidRunIdaArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid run IDA command arguments'
                        );
                    }

                    try {
                        const { script } = request.params.arguments;

                        let result = await ida.executeScript(script);

                        if (result.error) {
                            return {
                                content: [
                                    {
                                        type: 'text',
                                        text: `Error executing IDA Pro script: ${result.error}`,
                                    },
                                ],
                                isError: true,
                            };
                        }

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `IDA Pro Script Execution Results:\n\n${result.output}`,
                                },
                            ],
                        };


                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error executing IDA Pro command: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'search_immediate_value':
                    if (!isValidSearchImmediateValueArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid search immediate value arguments'
                        );
                    }

                    try {
                        const { value, radix, startAddress, endAddress } = request.params.arguments;

                        const result = await ida.searchForImmediateValue(value, {
                            radix,
                            startAddress,
                            endAddress
                        });

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Found ${result.count} occurrences of immediate value ${value}:\n\n${JSON.stringify(result.results, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error searching for immediate value: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'search_text':
                    if (!isValidSearchTextArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid search text arguments'
                        );
                    }

                    try {
                        const { text, caseSensitive, startAddress, endAddress } = request.params.arguments;

                        /*const result = await ida.searchForText(text, {
                            caseSensitive,
                            startAddress,
                            endAddress
                        });*/


                        await client.connect();
                        db = client.db(dbName); collection = db.collection("strings");
                        let searchFor = "lua";
                        let newRegex = new RegExp(text, "i");
                        collection = db.collection("strings");
                        let res = await collection.find({
                            "TEXT": newRegex
                        })

                        let result = await res.toArray()

                        let result_count = result.length;
                        let result_str = "";
                        for (let i = 0; i < result.length; i++) {
                            result_str += ` ${result[i].MEMORY_ADDR}  ${result[i].TEXT} \n`
                        }
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Found ${result_count} \n\n ${result_str}`,
                                },
                            ],
                        }

                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error searching for text: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }
                    break;
                case 'search_byte_sequence':
                    if (!isValidSearchByteSequenceArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid search byte sequence arguments'
                        );
                    }

                    try {
                        const { bytes, startAddress, endAddress } = request.params.arguments;

                        const result = await ida.searchForByteSequence(bytes, {
                            startAddress,
                            endAddress
                        });

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Found ${result.count} occurrences of byte sequence "${bytes}":\n\n${JSON.stringify(result.results, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error searching for byte sequence: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'get_disassembly':
                    if (!isValidGetDisassemblyArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid disassembly arguments'
                        );
                    }

                    try {
                        const { startAddress, endAddress, count } = request.params.arguments;

                        if (startAddress && typeof startAddress == 'string') {
                            startAddress.replace("00007", "0x7")
                        }
                        if (endAddress && typeof endAddress == 'string') {
                            endAddress.replace("00007", "0x7")
                        }


                        const result = await ida.getDisassembly(startAddress, {
                            endAddress,
                            count
                        });

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Disassembly from ${result.start_address}${result.end_address ? ` to ${result.end_address}` : ''}:\n\n${JSON.stringify(result.disassembly, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error getting disassembly: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'get_functions':
                    if (!isValidGetFunctionsArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid get functions arguments'
                        );
                    }

                    try {
                        const result = await ida.getFunctions();

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Retrieved ${result.count} functions from the binary:\n\n${JSON.stringify(result.functions, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error getting functions: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'get_exports':
                    if (!isValidGetExportsArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid get exports arguments'
                        );
                    }

                    try {
                        const result = await ida.getExports();

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Retrieved ${result.count} exports from the binary:\n\n${JSON.stringify(result.exports, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error getting exports: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'get_strings':
                    if (!isValidGetStringsArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid get strings arguments'
                        );
                    }

                    try {
                        const result = await ida.getStrings();

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Retrieved ${result.count} strings from the binary:\n\n${JSON.stringify(result.strings, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error getting strings: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'search_in_names':
                    if (!isValidSearchInNamesArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid search in names arguments'
                        );
                    }

                    try {
                        const { pattern, caseSensitive, type } = request.params.arguments;

                        const result = await ida.searchInNames(pattern, {
                            caseSensitive,
                            type: type as 'function' | 'data' | 'import' | 'export' | 'label' | 'all'
                        });

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Found ${result.count} names matching "${pattern}":\n\n${JSON.stringify(result.results, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error searching in names: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'get_xrefs_to':
                    if (!isValidGetXrefsToArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid get xrefs to arguments'
                        );
                    }

                    try {
                        const { address, type } = request.params.arguments;

                        const result = await ida.getXrefsTo(address, {
                            type: type as 'code' | 'data' | 'all'
                        });

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Found ${result.count} references to ${result.address} (${result.name}):\n\n${JSON.stringify(result.xrefs, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error getting xrefs to address: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                case 'get_xrefs_from':
                    if (!isValidGetXrefsFromArgs(request.params.arguments)) {
                        throw new McpError(
                            ErrorCode.InvalidParams,
                            'Invalid get xrefs from arguments'
                        );
                    }

                    try {
                        const { address, type } = request.params.arguments;

                        const result = await ida.getXrefsFrom(address, {
                            type: type as 'code' | 'data' | 'all'
                        });

                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Found ${result.count} references from ${result.address} (${result.name}):\n\n${JSON.stringify(result.xrefs, null, 2)
                                        }`,
                                },
                            ],
                        };
                    } catch (error: any) {
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: `Error getting xrefs from address: ${error.message || error}`,
                                },
                            ],
                            isError: true,
                        };
                    }

                default:
                    throw new McpError(
                        ErrorCode.MethodNotFound,
                        `Unknown tool: ${request.params.name}`
                    );
            }
        });
    }

    async run() {

        const transport = new StdioServerTransport();
        await this.server.connect(transport);
        console.error('IDA Pro MCP server running on stdio');
    }
}

const server = new IdaServer();
server.run().catch(console.error);
```

`package-lock.json`:

```json
{
  "name": "ida-server",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "ida-server",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "@modelcontextprotocol/sdk": "*",
        "diff": "^5.1.0",
        "glob": "^10.3.10",
        "minimatch": "^10.0.1",
        "mongodb": "^6.15.0",
        "zod-to-json-schema": "^3.23.5"
      },
      "devDependencies": {
        "@types/diff": "^5.0.9",
        "@types/minimatch": "^5.1.2",
        "@types/node": "^22",
        "shx": "^0.3.4",
        "typescript": "^5.3.3"
      }
    },
    "node_modules/@isaacs/cliui": {
      "version": "8.0.2",
      "license": "ISC",
      "dependencies": {
        "string-width": "^5.1.2",
        "string-width-cjs": "npm:string-width@^4.2.0",
        "strip-ansi": "^7.0.1",
        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
        "wrap-ansi": "^8.1.0",
        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
      "version": "6.1.0",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
      "version": "7.1.0",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/@modelcontextprotocol/sdk": {
      "version": "1.7.0",
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "cors": "^2.8.5",
        "eventsource": "^3.0.2",
        "express": "^5.0.1",
        "express-rate-limit": "^7.5.0",
        "pkce-challenge": "^4.1.0",
        "raw-body": "^3.0.0",
        "zod": "^3.23.8",
        "zod-to-json-schema": "^3.24.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@mongodb-js/saslprep": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@mongodb-js/saslprep/-/saslprep-1.2.0.tgz",
      "integrity": "sha512-+ywrb0AqkfaYuhHs6LxKWgqbh3I72EpEgESCw37o+9qPx9WTCkgDm2B+eMrwehGtHBWHFU4GXvnSCNiFhhausg==",
      "license": "MIT",
      "dependencies": {
        "sparse-bitfield": "^3.0.3"
      }
    },
    "node_modules/@pkgjs/parseargs": {
      "version": "0.11.0",
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@types/diff": {
      "version": "5.2.3",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/minimatch": {
      "version": "5.1.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "22.13.11",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.20.0"
      }
    },
    "node_modules/@types/webidl-conversions": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/@types/webidl-conversions/-/webidl-conversions-7.0.3.tgz",
      "integrity": "sha512-CiJJvcRtIgzadHCYXw7dqEnMNRjhGZlYK05Mj9OyktqV8uVT8fD2BFOB7S1uwBE3Kj2Z+4UyPmFw/Ixgw/LAlA==",
      "license": "MIT"
    },
    "node_modules/@types/whatwg-url": {
      "version": "11.0.5",
      "resolved": "https://registry.npmjs.org/@types/whatwg-url/-/whatwg-url-11.0.5.tgz",
      "integrity": "sha512-coYR071JRaHa+xoEvvYqvnIHaVqaYrLPbsufM9BF63HkwI5Lgmy2QR8Q5K/lYDYo5AK82wOvSOS0UsLTpTG7uQ==",
      "license": "MIT",
      "dependencies": {
        "@types/webidl-conversions": "*"
      }
    },
    "node_modules/accepts": {
      "version": "2.0.0",
      "license": "MIT",
      "dependencies": {
        "mime-types": "^3.0.0",
        "negotiator": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "license": "MIT"
    },
    "node_modules/body-parser": {
      "version": "2.1.0",
      "license": "MIT",
      "dependencies": {
        "bytes": "^3.1.2",
        "content-type": "^1.0.5",
        "debug": "^4.4.0",
        "http-errors": "^2.0.0",
        "iconv-lite": "^0.5.2",
        "on-finished": "^2.4.1",
        "qs": "^6.14.0",
        "raw-body": "^3.0.0",
        "type-is": "^2.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/body-parser/node_modules/iconv-lite": {
      "version": "0.5.2",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/body-parser/node_modules/qs": {
      "version": "6.14.0",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/brace-expansion": {
      "version": "2.0.1",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/bson": {
      "version": "6.10.3",
      "resolved": "https://registry.npmjs.org/bson/-/bson-6.10.3.tgz",
      "integrity": "sha512-MTxGsqgYTwfshYWTRdmZRC+M7FnG1b4y7RO7p2k3X24Wq0yv1m77Wsj0BzlPzd/IowgESfsruQCUToa7vbOpPQ==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=16.20.1"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "license": "MIT"
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/content-disposition": {
      "version": "1.0.0",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.1",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.2.2",
      "license": "MIT",
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/debug": {
      "version": "4.4.0",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/diff": {
      "version": "5.2.0",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/eastasianwidth": {
      "version": "0.2.0",
      "license": "MIT"
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "license": "MIT"
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/eventsource": {
      "version": "3.0.5",
      "license": "MIT",
      "dependencies": {
        "eventsource-parser": "^3.0.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/eventsource-parser": {
      "version": "3.0.0",
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/express": {
      "version": "5.0.1",
      "license": "MIT",
      "dependencies": {
        "accepts": "^2.0.0",
        "body-parser": "^2.0.1",
        "content-disposition": "^1.0.0",
        "content-type": "~1.0.4",
        "cookie": "0.7.1",
        "cookie-signature": "^1.2.1",
        "debug": "4.3.6",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "^2.0.0",
        "fresh": "2.0.0",
        "http-errors": "2.0.0",
        "merge-descriptors": "^2.0.0",
        "methods": "~1.1.2",
        "mime-types": "^3.0.0",
        "on-finished": "2.4.1",
        "once": "1.4.0",
        "parseurl": "~1.3.3",
        "proxy-addr": "~2.0.7",
        "qs": "6.13.0",
        "range-parser": "~1.2.1",
        "router": "^2.0.0",
        "safe-buffer": "5.2.1",
        "send": "^1.1.0",
        "serve-static": "^2.1.0",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "^2.0.0",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/express-rate-limit": {
      "version": "7.5.0",
      "license": "MIT",
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "url": "https://github.com/sponsors/express-rate-limit"
      },
      "peerDependencies": {
        "express": "^4.11 || 5 || ^5.0.0-beta.1"
      }
    },
    "node_modules/express/node_modules/debug": {
      "version": "4.3.6",
      "license": "MIT",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/express/node_modules/ms": {
      "version": "2.1.2",
      "license": "MIT"
    },
    "node_modules/finalhandler": {
      "version": "2.1.0",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "on-finished": "^2.4.1",
        "parseurl": "^1.3.3",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/foreground-child": {
      "version": "3.3.1",
      "license": "ISC",
      "dependencies": {
        "cross-spawn": "^7.0.6",
        "signal-exit": "^4.0.1"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "2.0.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob": {
      "version": "10.4.5",
      "license": "ISC",
      "dependencies": {
        "foreground-child": "^3.1.0",
        "jackspeak": "^3.1.2",
        "minimatch": "^9.0.4",
        "minipass": "^7.1.2",
        "package-json-from-dist": "^1.0.0",
        "path-scurry": "^1.11.1"
      },
      "bin": {
        "glob": "dist/esm/bin.mjs"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob/node_modules/minimatch": {
      "version": "9.0.5",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.6.3",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "license": "ISC"
    },
    "node_modules/interpret": {
      "version": "1.4.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-promise": {
      "version": "4.0.0",
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "license": "ISC"
    },
    "node_modules/jackspeak": {
      "version": "3.4.3",
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/cliui": "^8.0.2"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      },
      "optionalDependencies": {
        "@pkgjs/parseargs": "^0.11.0"
      }
    },
    "node_modules/lru-cache": {
      "version": "10.4.3",
      "license": "ISC"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "1.1.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/memory-pager": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/memory-pager/-/memory-pager-1.5.0.tgz",
      "integrity": "sha512-ZS4Bp4r/Zoeq6+NLJpP+0Zzm0pR8whtGPf1XExKLJBAczGMnSi3It14OiNCStjQjM6NU1okjQGSxgEZN8eBYKg==",
      "license": "MIT"
    },
    "node_modules/merge-descriptors": {
      "version": "2.0.0",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.54.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "3.0.0",
      "license": "MIT",
      "dependencies": {
        "mime-db": "^1.53.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "10.0.1",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": "20 || >=22"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/minipass": {
      "version": "7.1.2",
      "license": "ISC",
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/mongodb": {
      "version": "6.15.0",
      "resolved": "https://registry.npmjs.org/mongodb/-/mongodb-6.15.0.tgz",
      "integrity": "sha512-ifBhQ0rRzHDzqp9jAQP6OwHSH7dbYIQjD3SbJs9YYk9AikKEettW/9s/tbSFDTpXcRbF+u1aLrhHxDFaYtZpFQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@mongodb-js/saslprep": "^1.1.9",
        "bson": "^6.10.3",
        "mongodb-connection-string-url": "^3.0.0"
      },
      "engines": {
        "node": ">=16.20.1"
      },
      "peerDependencies": {
        "@aws-sdk/credential-providers": "^3.188.0",
        "@mongodb-js/zstd": "^1.1.0 || ^2.0.0",
        "gcp-metadata": "^5.2.0",
        "kerberos": "^2.0.1",
        "mongodb-client-encryption": ">=6.0.0 <7",
        "snappy": "^7.2.2",
        "socks": "^2.7.1"
      },
      "peerDependenciesMeta": {
        "@aws-sdk/credential-providers": {
          "optional": true
        },
        "@mongodb-js/zstd": {
          "optional": true
        },
        "gcp-metadata": {
          "optional": true
        },
        "kerberos": {
          "optional": true
        },
        "mongodb-client-encryption": {
          "optional": true
        },
        "snappy": {
          "optional": true
        },
        "socks": {
          "optional": true
        }
      }
    },
    "node_modules/mongodb-connection-string-url": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/mongodb-connection-string-url/-/mongodb-connection-string-url-3.0.2.tgz",
      "integrity": "sha512-rMO7CGo/9BFwyZABcKAWL8UJwH/Kc2x0g72uhDWzG48URRax5TCIcJ7Rc3RZqffZzO/Gwff/jyKwCU9TN8gehA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@types/whatwg-url": "^11.0.2",
        "whatwg-url": "^14.1.0 || ^13.0.0"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "license": "MIT"
    },
    "node_modules/negotiator": {
      "version": "1.0.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/package-json-from-dist": {
      "version": "1.0.1",
      "license": "BlueOak-1.0.0"
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/path-scurry": {
      "version": "1.11.1",
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "lru-cache": "^10.2.0",
        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
      },
      "engines": {
        "node": ">=16 || 14 >=14.18"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "8.2.0",
      "license": "MIT",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/pkce-challenge": {
      "version": "4.1.0",
      "license": "MIT",
      "engines": {
        "node": ">=16.20.0"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/qs": {
      "version": "6.13.0",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.0.6"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "3.0.0",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.6.3",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/rechoir": {
      "version": "0.6.2",
      "dev": true,
      "dependencies": {
        "resolve": "^1.1.6"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.10",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/router": {
      "version": "2.1.0",
      "license": "MIT",
      "dependencies": {
        "is-promise": "^4.0.0",
        "parseurl": "^1.3.3",
        "path-to-regexp": "^8.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "license": "MIT"
    },
    "node_modules/send": {
      "version": "1.1.0",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.3.5",
        "destroy": "^1.2.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "fresh": "^0.5.2",
        "http-errors": "^2.0.0",
        "mime-types": "^2.1.35",
        "ms": "^2.1.3",
        "on-finished": "^2.4.1",
        "range-parser": "^1.2.1",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/send/node_modules/fresh": {
      "version": "0.5.2",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/send/node_modules/mime-db": {
      "version": "1.52.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/send/node_modules/mime-types": {
      "version": "2.1.35",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/serve-static": {
      "version": "2.1.0",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "parseurl": "^1.3.3",
        "send": "^1.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "license": "ISC"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shelljs": {
      "version": "0.8.5",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "glob": "^7.0.0",
        "interpret": "^1.0.0",
        "rechoir": "^0.6.2"
      },
      "bin": {
        "shjs": "bin/shjs"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/shelljs/node_modules/brace-expansion": {
      "version": "1.1.11",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/shelljs/node_modules/glob": {
      "version": "7.2.3",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/shelljs/node_modules/minimatch": {
      "version": "3.1.2",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/shx": {
      "version": "0.3.4",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.3",
        "shelljs": "^0.8.5"
      },
      "bin": {
        "shx": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/signal-exit": {
      "version": "4.1.0",
      "license": "ISC",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/sparse-bitfield": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/sparse-bitfield/-/sparse-bitfield-3.0.3.tgz",
      "integrity": "sha512-kvzhi7vqKTfkh0PZU+2D2PIllw2ymqJKujUcyPMd9Y75Nv4nPbGJZXNhxsgdQab2BmlDct1YnfQCguEvHr7VsQ==",
      "license": "MIT",
      "dependencies": {
        "memory-pager": "^1.0.2"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/string-width": {
      "version": "5.1.2",
      "license": "MIT",
      "dependencies": {
        "eastasianwidth": "^0.2.0",
        "emoji-regex": "^9.2.2",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/string-width-cjs": {
      "name": "string-width",
      "version": "4.2.3",
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width/node_modules/ansi-regex": {
      "version": "6.1.0",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/string-width/node_modules/emoji-regex": {
      "version": "9.2.2",
      "license": "MIT"
    },
    "node_modules/string-width/node_modules/strip-ansi": {
      "version": "7.1.0",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi-cjs": {
      "name": "strip-ansi",
      "version": "6.0.1",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-5.1.0.tgz",
      "integrity": "sha512-IUWnUK7ADYR5Sl1fZlO1INDUhVhatWl7BtJWsIhwJ0UAK7ilzzIa8uIqOO/aYVWHZPJkKbEL+362wrzoeRF7bw==",
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/type-is": {
      "version": "2.0.0",
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "media-typer": "^1.1.0",
        "mime-types": "^3.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typescript": {
      "version": "5.8.2",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.20.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-7.0.0.tgz",
      "integrity": "sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/whatwg-url": {
      "version": "14.2.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-14.2.0.tgz",
      "integrity": "sha512-De72GdQZzNTUBBChsXueQUnPKDkg/5A5zp7pFDuQAj5UFoENpiACU0wlCvzpAGnTkj++ihpKwKyYewn/XNUbKw==",
      "license": "MIT",
      "dependencies": {
        "tr46": "^5.1.0",
        "webidl-conversions": "^7.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "8.1.0",
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^6.1.0",
        "string-width": "^5.0.1",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs": {
      "name": "wrap-ansi",
      "version": "7.0.0",
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
      "version": "4.2.3",
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi/node_modules/ansi-regex": {
      "version": "6.1.0",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/wrap-ansi/node_modules/ansi-styles": {
      "version": "6.2.1",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/wrap-ansi/node_modules/strip-ansi": {
      "version": "7.1.0",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "license": "ISC"
    },
    "node_modules/zod": {
      "version": "3.24.2",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-to-json-schema": {
      "version": "3.24.5",
      "license": "ISC",
      "peerDependencies": {
        "zod": "^3.24.1"
      }
    }
  }
}

```

`package.json`:

```json
{
  "name": "ida-server",
  "version": "1.0.0",
  "type": "module",
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@modelcontextprotocol/sdk": "*",
    "diff": "^5.1.0",
    "glob": "^10.3.10",
    "minimatch": "^10.0.1",
    "mongodb": "^6.15.0",
    "zod-to-json-schema": "^3.23.5"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsc && shx chmod +x dist/*.js"
  },
  "devDependencies": {
    "@types/diff": "^5.0.9",
    "@types/minimatch": "^5.1.2",
    "@types/node": "^22",
    "shx": "^0.3.4",
    "typescript": "^5.3.3"
  }
}

```

`tsconfig.json`:

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "Node16",
        "moduleResolution": "Node16",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "outDir": "./dist",
        "rootDir": "."
    },
    "include": [
        "src/**/*",
        "./**/*.ts"
, "test.cjs"    ],
    "exclude": [
        "node_modules"
    ]
}
```