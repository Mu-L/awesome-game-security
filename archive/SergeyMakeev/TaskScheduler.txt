Project Path: arc_SergeyMakeev_TaskScheduler_ttzq9qfw

Source Tree:

```txt
arc_SergeyMakeev_TaskScheduler_ttzq9qfw
├── README.md
├── Scheduler
│   ├── Doxygen
│   │   ├── Doxyfile
│   │   ├── doxygen.exe
│   │   └── style.css
│   ├── Include
│   │   ├── MTAppInterop.h
│   │   ├── MTArrayView.h
│   │   ├── MTAtomic.h
│   │   ├── MTColorTable.h
│   │   ├── MTConcurrentRingBuffer.h
│   │   ├── MTConfig.h
│   │   ├── MTDebug.h
│   │   ├── MTFiberContext.h
│   │   ├── MTFiberContext.inl
│   │   ├── MTGroupedTask.h
│   │   ├── MTPlatform.h
│   │   ├── MTProfilerEventListener.h
│   │   ├── MTQueueMPMC.h
│   │   ├── MTScheduler.h
│   │   ├── MTScheduler.inl
│   │   ├── MTStackRequirements.h
│   │   ├── MTStaticVector.h
│   │   ├── MTTaskBucket.h
│   │   ├── MTTaskDesc.h
│   │   ├── MTTaskGroup.h
│   │   ├── MTTaskPool.h
│   │   ├── MTTaskQueue.h
│   │   ├── MTThreadContext.h
│   │   ├── MTTools.h
│   │   ├── MTTypes.h
│   │   ├── Platform
│   │   │   ├── Common
│   │   │   │   ├── MTAtomic.h
│   │   │   │   ├── MTSpinWait.h
│   │   │   │   └── MTThread.h
│   │   │   ├── Posix
│   │   │   │   ├── MTAtomic.h
│   │   │   │   ├── MTCommon.h
│   │   │   │   ├── MTEvent.h
│   │   │   │   ├── MTFiber.h
│   │   │   │   ├── MTMemory.h
│   │   │   │   ├── MTMutex.h
│   │   │   │   ├── MTThread.h
│   │   │   │   └── MTUtils.h
│   │   │   └── Windows
│   │   │       ├── MTAtomic.h
│   │   │       ├── MTCommon.h
│   │   │       ├── MTEvent.h
│   │   │       ├── MTEventKernel.h
│   │   │       ├── MTEventUser.h
│   │   │       ├── MTFiber.h
│   │   │       ├── MTFiberDefault.h
│   │   │       ├── MTFiberOptimized.h
│   │   │       ├── MTMemory.h
│   │   │       ├── MTMutex.h
│   │   │       ├── MTThread.h
│   │   │       ├── MTUtils.h
│   │   │       ├── MicroWindows.cpp
│   │   │       └── MicroWindows.h
│   │   └── Scopes
│   │       └── MTScopes.h
│   └── Source
│       ├── MTDefaultAppInterop.cpp
│       ├── MTFiberContext.cpp
│       ├── MTScheduler.cpp
│       └── MTThreadContext.cpp
├── SchedulerTests
│   ├── Profiler
│   │   ├── Profiler.cpp
│   │   └── Profiler.h
│   ├── Tests
│   │   ├── AtomicTests.cpp
│   │   ├── CleanupTests.cpp
│   │   ├── DxtTests.cpp
│   │   ├── FiberTests.cpp
│   │   ├── FireAndForget.cpp
│   │   ├── FoundationTests.cpp
│   │   ├── GroupTests.cpp
│   │   ├── LenaDxt
│   │   │   ├── HeaderDDS.h
│   │   │   └── LenaColor.h
│   │   ├── PlatformTests.cpp
│   │   ├── PriorityTests.cpp
│   │   ├── ScopesTests.cpp
│   │   ├── SimpleTests.cpp
│   │   ├── StackSizeTests.cpp
│   │   ├── SubtasksTests.cpp
│   │   ├── Tests.cpp
│   │   ├── Tests.h
│   │   └── WaitTests.cpp
│   └── main.cpp
├── StripNdaCode.cmd
├── TaskScheduler.code-workspace
├── ThirdParty
│   ├── Boost.Context
│   │   ├── LICENSE_1_0.txt
│   │   ├── asm
│   │   │   ├── jump_arm64_aapcs_elf_gas.S
│   │   │   ├── jump_arm64_aapcs_macho_gas.S
│   │   │   ├── jump_arm_aapcs_elf_gas.S
│   │   │   ├── jump_arm_aapcs_macho_gas.S
│   │   │   ├── jump_arm_aapcs_pe_armasm.asm
│   │   │   ├── jump_combined_sysv_macho_gas.S
│   │   │   ├── jump_i386_ms_pe_gas.asm
│   │   │   ├── jump_i386_ms_pe_masm.asm
│   │   │   ├── jump_i386_sysv_elf_gas.S
│   │   │   ├── jump_i386_sysv_macho_gas.S
│   │   │   ├── jump_i386_x86_64_sysv_macho_gas.S
│   │   │   ├── jump_mips32_o32_elf_gas.S
│   │   │   ├── jump_ppc32_ppc64_sysv_macho_gas.S
│   │   │   ├── jump_ppc32_sysv_elf_gas.S
│   │   │   ├── jump_ppc32_sysv_macho_gas.S
│   │   │   ├── jump_ppc32_sysv_xcoff_gas.S
│   │   │   ├── jump_ppc64_sysv_elf_gas.S
│   │   │   ├── jump_ppc64_sysv_macho_gas.S
│   │   │   ├── jump_ppc64_sysv_xcoff_gas.S
│   │   │   ├── jump_sparc64_sysv_elf_gas.S
│   │   │   ├── jump_sparc_sysv_elf_gas.S
│   │   │   ├── jump_x86_64_ms_pe_gas.asm
│   │   │   ├── jump_x86_64_ms_pe_masm.asm
│   │   │   ├── jump_x86_64_sysv_elf_gas.S
│   │   │   ├── jump_x86_64_sysv_macho_gas.S
│   │   │   ├── make_arm64_aapcs_elf_gas.S
│   │   │   ├── make_arm64_aapcs_macho_gas.S
│   │   │   ├── make_arm_aapcs_elf_gas.S
│   │   │   ├── make_arm_aapcs_macho_gas.S
│   │   │   ├── make_arm_aapcs_pe_armasm.asm
│   │   │   ├── make_combined_sysv_macho_gas.S
│   │   │   ├── make_i386_ms_pe_gas.asm
│   │   │   ├── make_i386_ms_pe_masm.asm
│   │   │   ├── make_i386_sysv_elf_gas.S
│   │   │   ├── make_i386_sysv_macho_gas.S
│   │   │   ├── make_i386_x86_64_sysv_macho_gas.S
│   │   │   ├── make_mips32_o32_elf_gas.S
│   │   │   ├── make_ppc32_ppc64_sysv_macho_gas.S
│   │   │   ├── make_ppc32_sysv_elf_gas.S
│   │   │   ├── make_ppc32_sysv_macho_gas.S
│   │   │   ├── make_ppc32_sysv_xcoff_gas.S
│   │   │   ├── make_ppc64_sysv_elf_gas.S
│   │   │   ├── make_ppc64_sysv_macho_gas.S
│   │   │   ├── make_ppc64_sysv_xcoff_gas.S
│   │   │   ├── make_sparc64_sysv_elf_gas.S
│   │   │   ├── make_sparc_sysv_elf_gas.S
│   │   │   ├── make_x86_64_ms_pe_gas.asm
│   │   │   ├── make_x86_64_ms_pe_masm.asm
│   │   │   ├── make_x86_64_sysv_elf_gas.S
│   │   │   └── make_x86_64_sysv_macho_gas.S
│   │   └── fcontext.h
│   ├── Squish
│   │   ├── ChangeLog
│   │   ├── Doxyfile
│   │   ├── Makefile
│   │   ├── README
│   │   ├── alpha.cpp
│   │   ├── alpha.h
│   │   ├── clusterfit.cpp
│   │   ├── clusterfit.h
│   │   ├── colourblock.cpp
│   │   ├── colourblock.h
│   │   ├── colourfit.cpp
│   │   ├── colourfit.h
│   │   ├── colourset.cpp
│   │   ├── colourset.h
│   │   ├── config
│   │   ├── config.h
│   │   ├── maths.cpp
│   │   ├── maths.h
│   │   ├── rangefit.cpp
│   │   ├── rangefit.h
│   │   ├── simd.h
│   │   ├── simd_float.h
│   │   ├── simd_sse.h
│   │   ├── simd_ve.h
│   │   ├── singlecolourfit.cpp
│   │   ├── singlecolourfit.h
│   │   ├── singlecolourlookup.inl
│   │   ├── squish.cpp
│   │   ├── squish.h
│   │   └── texture_compression_s3tc.txt
│   └── UnitTest++
│       ├── AUTHORS
│       ├── CMakeLists.txt
│       ├── ChangeLog
│       ├── INSTALL
│       ├── LICENSE
│       ├── Makefile.am
│       ├── README.md
│       ├── UnitTest++
│       │   ├── AssertException.cpp
│       │   ├── AssertException.h
│       │   ├── CheckMacros.h
│       │   ├── Checks.cpp
│       │   ├── Checks.h
│       │   ├── CompositeTestReporter.cpp
│       │   ├── CompositeTestReporter.h
│       │   ├── Config.h
│       │   ├── CurrentTest.cpp
│       │   ├── CurrentTest.h
│       │   ├── DeferredTestReporter.cpp
│       │   ├── DeferredTestReporter.h
│       │   ├── DeferredTestResult.cpp
│       │   ├── DeferredTestResult.h
│       │   ├── ExceptionMacros.h
│       │   ├── ExecuteTest.h
│       │   ├── HelperMacros.h
│       │   ├── Makefile.am
│       │   ├── MemoryOutStream.cpp
│       │   ├── MemoryOutStream.h
│       │   ├── Posix
│       │   │   ├── SignalTranslator.cpp
│       │   │   ├── SignalTranslator.h
│       │   │   ├── TimeHelpers.cpp
│       │   │   └── TimeHelpers.h
│       │   ├── ReportAssert.cpp
│       │   ├── ReportAssert.h
│       │   ├── ReportAssertImpl.h
│       │   ├── Test.cpp
│       │   ├── Test.h
│       │   ├── TestDetails.cpp
│       │   ├── TestDetails.h
│       │   ├── TestList.cpp
│       │   ├── TestList.h
│       │   ├── TestMacros.h
│       │   ├── TestReporter.cpp
│       │   ├── TestReporter.h
│       │   ├── TestReporterStdout.cpp
│       │   ├── TestReporterStdout.h
│       │   ├── TestResults.cpp
│       │   ├── TestResults.h
│       │   ├── TestRunner.cpp
│       │   ├── TestRunner.h
│       │   ├── TestSuite.h
│       │   ├── TimeConstraint.cpp
│       │   ├── TimeConstraint.h
│       │   ├── TimeHelpers.h
│       │   ├── UnitTest++.h
│       │   ├── UnitTestPP.h
│       │   ├── UnitTestTimer.h
│       │   ├── Win32
│       │   │   ├── TimeHelpers.cpp
│       │   │   └── TimeHelpers.h
│       │   ├── XmlTestReporter.cpp
│       │   ├── XmlTestReporter.h
│       │   ├── unittestpp_vs2005.vcproj
│       │   ├── unittestpp_vs2008.vcproj
│       │   ├── unittestpp_vs2008.vcxproj
│       │   └── unittestpp_vs2008.vcxproj.filters
│       ├── builds
│       │   └── .gitignore
│       ├── configure.ac
│       └── tests
│           ├── Main.cpp
│           ├── RecordingReporter.h
│           ├── ScopedCurrentTest.h
│           ├── TestAssertHandler.cpp
│           ├── TestCheckMacros.cpp
│           ├── TestChecks.cpp
│           ├── TestCompositeTestReporter.cpp
│           ├── TestCurrentTest.cpp
│           ├── TestDeferredTestReporter.cpp
│           ├── TestExceptions.cpp
│           ├── TestMemoryOutStream.cpp
│           ├── TestTest.cpp
│           ├── TestTestList.cpp
│           ├── TestTestMacros.cpp
│           ├── TestTestResults.cpp
│           ├── TestTestRunner.cpp
│           ├── TestTestSuite.cpp
│           ├── TestTimeConstraint.cpp
│           ├── TestTimeConstraintMacro.cpp
│           ├── TestUnitTestPP.cpp
│           └── TestXmlTestReporter.cpp
├── appveyor.yml
├── license.txt
├── premake4.exe
├── premake4.lua
└── sunifdef.exe

```

`README.md`:

```md
## About

**Cross-platform, fiber-based, multi-threaded task scheduler designed for video games.**

**Written under the influence by great GDC talk "Parallelizing the Naughty Dog engine using fibers" by Christian Gyrling**

Compiled and worked on : **Clang 3.4, GCC 4.8.2, MSVC 2010/2012/2015/2017, XCODE 6.4**

## Commercial games using Task Scheduler

- Skyforge (PC, PS4, X1)

## Build status

Linux + OS X
![Travis build status](https://api.travis-ci.org/SergeyMakeev/TaskScheduler.svg?branch=master)

Windows
![Appveyor build status](https://ci.appveyor.com/api/projects/status/7o760ylay8mdplo6)

## Usage examples

Minimal example
```c++
#include <MTScheduler.h>

// Declare simple task
struct SimpleTask
{
  MT_DECLARE_TASK(SimpleTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

  void Do(MT::FiberContext&)
  {
    // ... do thing here ...
  }
};

int main()
{
  // Create scheduler
  MT::TaskScheduler scheduler;

  // Declare tasks
  static const int TASK_COUNT = 1000;
  SimpleTask tasks[TASK_COUNT];

  // Run everything
  scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));

  // Wait and help to execute unfinished tasks
  scheduler.WaitAll(1000)

  return 0;
}
```

You can find a lot of usage examples in the test folder:
https://github.com/SergeyMakeev/TaskScheduler/tree/master/SchedulerTests/Tests

## Useful reading (in random order):

Parallelizing the Naughty Dog engine using fibers by Christian Gyrling

http://www.swedishcoding.com/wp-content/uploads/2015/03/parallelizing_the_naughty_dog_engine_using_fibers.pdf

id Tech 5 Challenges
From Texture Virtualization to Massive Parallelization by J.M.P. van Waveren

http://s09.idav.ucdavis.edu/talks/05-JP_id_Tech_5_Challenges.pdf

Doom3 BFG Source Code Review: Multi-threading by Fabien Sanglard

http://fabiensanglard.net/doom3_bfg/threading.php

How Ubisoft Develops Games for Multicore - Before and After C++11 by Jeff Preshing

http://www.youtube.com/watch?v=X1T3IQ4N-3g

Killzone Shadow Fall: Threading the Entity Update on PS4 by Jorrit Rouwe

http://www.slideshare.net/jrouwe/killzone-shadow-fall-threading-the-entity-update-on-ps4

Killzone Shadow Fall Demo Postmortem by Michal Valient

http://www.guerrilla-games.com/presentations/Valient_Killzone_Shadow_Fall_Demo_Postmortem.pdf

Infamous Second Son : Engine Postmortem by Adrian Bentley

http://adruab.net/wp-images/GDC14_infamous_second_son_engine_postmortem.pdf

Multithreading the Entire Destiny Engine - GDC 2015 by Barry Genova

http://www.gdcvault.com/play/1022164/Multithreading-the-Entire-Destiny (members only)
http://chomikuj.pl/dexio21/GDC+2015/GDC+Vault+-+Multithreading+the+Entire+Destiny+Engine,4690817362.mp4%28video%29


Intel Threading Building Blocks - Scheduling Algorithm

https://www.threadingbuildingblocks.org/docs/help/reference/task_scheduler/scheduling_algorithm.htm

CILK/CILK++ and Reducers

http://www.slideshare.net/yunmingzhang/yunming-zhang-presentations

Task Scheduling Strategies by Dmitry Vyukov

http://www.1024cores.net/home/scalable-architecture/task-scheduling-strategies

Implementing a Work-Stealing Task Scheduler on the ARM11 MPCore

http://www.rtcgroup.com/arm/2007/presentations/211%20-%20Implementing%20a%20Work-Stealing%20Task%20Scheduler.pdf

Lost Planet graphics course for 3D game fan of Nishikawa Zenji

http://game.watch.impress.co.jp/docs/20070131/3dlp.htm

Dragged Kicking and Screaming: Source Multicore by Tom Leonard

http://www.valvesoftware.com/publications/2007/GDC2007_SourceMulticore.pdf

Games: Playing with Threads by Ben Nicholson

http://www2.epcc.ed.ac.uk/downloads/lectures/BenNicholson/BenNicholson.pdf

Work Stealing by Pablo Halpern 

https://github.com/CppCon/CppCon2015/tree/master/Presentations/Work%20Stealing

Enki Task Scheduler by Doug Binks

http://www.enkisoftware.com/devlogpost-20150822-1-Implementing_a_lightweight_task_scheduler.html

http://www.enkisoftware.com/devlogpost-20150905-1-Internals_of_a_lightweight_task_scheduler.html

Molecule Engine blog - Job System 2.0 by Stefan Reinalter

http://blog.molecular-matters.com/2015/08/24/job-system-2-0-lock-free-work-stealing-part-1-basics/

http://blog.molecular-matters.com/2015/09/08/job-system-2-0-lock-free-work-stealing-part-2-a-specialized-allocator/

http://blog.molecular-matters.com/2015/09/25/job-system-2-0-lock-free-work-stealing-part-3-going-lock-free/

Molecule Engine blog - Building a load-balanced task scheduler by Stefan Reinalter

http://blog.molecular-matters.com/2012/04/05/building-a-load-balanced-task-scheduler-part-1-basics/

http://blog.molecular-matters.com/2012/04/12/building-a-load-balanced-task-scheduler-part-2-task-model-relationships/

http://blog.molecular-matters.com/2012/04/25/building-a-load-balanced-task-scheduler-part-3-parent-child-relationships/

http://blog.molecular-matters.com/2012/07/09/building-a-load-balanced-task-scheduler-part-4-false-sharing/

Do-it-yourself Game Task Scheduling by Jerome Muffat-Meridol

https://software.intel.com/en-us/articles/do-it-yourself-game-task-scheduling

Acquire and Release Semantics by Jeff Preshing

http://preshing.com/20120913/acquire-and-release-semantics/

Lockless Programming Considerations for Xbox 360 and Microsoft Windows

https://msdn.microsoft.com/en-us/library/windows/desktop/ee418650(v=vs.85).aspx

C/C++11 mappings to processors by Peter Sewell

https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html 

Memory Ordering in Modern Microprocessors, Part I by Paul E. McKenney
http://www.linuxjournal.com/node/8211/print

Memory Ordering in Modern Microprocessors, Part II by Paul E. McKenney
http://www.linuxjournal.com/node/8212/print

Barrier Litmus Tests and Cookbook by ARM
https://developer.arm.com/documentation/genc007826/latest
https://documentation-service.arm.com/static/5ece8d6a56a54774bd17a1f4


```

`Scheduler/Doxygen/Doxyfile`:

```
# Doxyfile 1.8.9.1

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the config file
# that follow. The default is UTF-8 which is also the encoding used for all text
# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
# for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = "Multithreading Scheduler"

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         = 

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = 

# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
# in the documentation. The maximum height of the logo should not exceed 55
# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
# the logo to the output directory.

PROJECT_LOGO           = 

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       = ../Docs

# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
# directories (in 2 levels) under the output directory of each output format and
# will distribute the generated files over these directories. Enabling this
# option can be useful when feeding doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise causes
# performance problems for the file system.
# The default value is: NO.

CREATE_SUBDIRS         = NO

# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
# characters to appear in the names of generated files. If set to NO, non-ASCII
# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
# U+3044.
# The default value is: NO.

ALLOW_UNICODE_NAMES    = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
# Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       = "The $name class" \
                         "The $name widget" \
                         "The $name file" \
                         is \
                         provides \
                         specifies \
                         contains \
                         represents \
                         a \
                         an \
                         the

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        = 

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    = 

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
# less readable) file names. This can be useful is your file systems doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
# first line (until the first dot) of a Javadoc-style comment as the brief
# description. If set to NO, the Javadoc-style will behave just like regular Qt-
# style comments (thus requiring an explicit @brief command for a brief
# description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = NO

# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
# line (until the first dot) of a Qt-style comment as the brief description. If
# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
# requiring an explicit \brief command for a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
# page for each member. If set to NO, the documentation of a member will be part
# of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:\n"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". You can put \n's in the value part of an alias to insert
# newlines.

ALIASES                = 

# This tag can be used to specify a number of word-keyword mappings (TCL only).
# A mapping has the form "name=value". For example adding "class=itcl::class"
# will allow you to use the command class in the itcl::class meaning.

TCL_SUBST              = 

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
# Fortran. In the later case the parser tries to guess whether the code is fixed
# or free formatted code, this is the default for Fortran type files), VHDL. For
# instance to make doxygen treat .inc files as Fortran files (default is PHP),
# and .f files as C (default is Fortran), use: inc=Fortran f=C.
#
# Note: For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by doxygen.

EXTENSION_MAPPING      = 

# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See http://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by doxygen, so you can
# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# When enabled doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by putting a % sign in front of the word or
# globally by setting AUTOLINK_SUPPORT to NO.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also make the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
# will parse them like normal C++ but will assume all classes use public instead
# of private inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = NO

# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = NO

# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO,
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. If set to YES, local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO, only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO, these classes will be included in the various overviews. This option
# has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
# (class|struct|union) declarations. If set to NO, these declarations will be
# included in the documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO, these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
# names in lower-case letters. If set to YES, upper-case letters are also
# allowed. This is useful if you have classes or files whose names only differ
# in case and if your file system supports case sensitive file names. Windows
# and Mac users are advised to set this option to NO.
# The default value is: system dependent.

CASE_SENSE_NAMES       = NO

# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES, the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
# append additional text to a page's title, such as Class Reference. If set to
# YES the compound reference will be hidden.
# The default value is: NO.

HIDE_COMPOUND_REFERENCE= NO

# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
# list. This list is created by putting \todo commands in the documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
# list. This list is created by putting \test commands in the documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       = 

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES, the
# list will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    = 

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents doxygen's defaults, run doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file.
#
# Note that if you run doxygen from a directory containing a file called
# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            = 

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. See also \cite for info how to create references.

CITE_BIB_FILES         = 

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as not documenting some parameters
# in a documented function, or documenting parameters that don't exist or using
# markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO, doxygen will only warn about wrong or incomplete
# parameter documentation, but not about the absence of documentation.
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# The WARN_FORMAT tag determines the format of the warning messages that doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr).

WARN_LOGFILE           = 

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces.
# Note: If this tag is empty the current directory is searched.

INPUT                  = ../Include

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see: http://www.gnu.org/software/libiconv) for the list of
# possible encodings.
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank the
# following patterns are tested:*.c, *.cc, *.cxx, *.cpp, *.c++, *.java, *.ii,
# *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp,
# *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown,
# *.md, *.mm, *.dox, *.py, *.f90, *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf,
# *.qsf, *.as and *.js.

FILE_PATTERNS          = *.c \
                         *.cc \
                         *.cxx \
                         *.cpp \
                         *.c++ \
                         *.java \
                         *.ii \
                         *.ixx \
                         *.ipp \
                         *.i++ \
                         *.inl \
                         *.idl \
                         *.ddl \
                         *.odl \
                         *.h \
                         *.hh \
                         *.hxx \
                         *.hpp \
                         *.h++ \
                         *.cs \
                         *.d \
                         *.php \
                         *.php4 \
                         *.php5 \
                         *.phtml \
                         *.inc \
                         *.m \
                         *.markdown \
                         *.md \
                         *.mm \
                         *.dox \
                         *.py \
                         *.f90 \
                         *.f \
                         *.for \
                         *.tcl \
                         *.vhd \
                         *.vhdl \
                         *.ucf \
                         *.qsf \
                         *.as \
                         *.js

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                = 

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       = 

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# AClass::ANamespace, ANamespace::*Test
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories use the pattern */test/*

EXCLUDE_SYMBOLS        = 

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           = 

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             = 

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.

INPUT_FILTER           = 

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.

FILTER_PATTERNS        = 

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS = 

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the doxygen output.

USE_MDFILE_AS_MAINPAGE = 

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = NO

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# classes and enums directly into the documentation.
# The default value is: NO.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# function all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see http://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
# cost of reduced performance. This can be particularly helpful with template
# rich C++ code for which doxygen's built-in parser lacks the necessary type
# information.
# Note: The availability of this option depends on whether or not doxygen was
# compiled with the --with-libclang option.
# The default value is: NO.

CLANG_ASSISTED_PARSING = NO

# If clang assisted parsing is enabled you can provide the compiler with command
# line options that you would normally use when invoking the compiler. Note that
# the include paths will already be set by doxygen for the files and directories
# specified with INPUT and INCLUDE_PATH.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_OPTIONS          = 

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
# which the alphabetical index list will be split.
# Minimum value: 1, maximum value: 20, default value: 5.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all classes will
# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
# can be used to specify a prefix (or a list of prefixes) that should be ignored
# while generating the index headers.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          = 

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            = 

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            = 

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        = 

# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# cascading style sheets that are included after the standard style sheets
# created by doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefore more robust against future updates.
# Doxygen will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list). For an example see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  = style.css

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       = 

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the style sheet and background images according to
# this color. Hue is specified as an angle on a colorwheel, see
# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use grayscales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
# page will contain the date and time when the page was generated. Setting this
# to NO can help when comparing the output of multiple runs.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_TIMESTAMP         = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see: http://developer.apple.com/tools/xcode/), introduced with
# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
# Makefile in the HTML output directory. Running make will produce the docset in
# that directory and running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
# for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
# Windows.
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               = 

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler (hhc.exe). If non-empty,
# doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           = 

# The GENERATE_CHI flag controls if a separate .chi index file is generated
# (YES) or that it should be included in the master .chm file (NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     = 

# The BINARY_TOC flag controls whether a binary table of contents is generated
# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
# enables the Previous and Next buttons.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               = 

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
# folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   = 

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  = 

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  = 

# The QHG_LOCATION tag can be used to specify the location of Qt's
# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
# generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           = 

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
# further fine-tune the look of the index. As an example, the default style
# sheet generated by doxygen has an example that shows how to put an image at
# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
# the same information as the tab index, you could consider setting
# DISABLE_INDEX to YES when enabling this option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = NO

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 4

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# Use the FORMULA_TRANPARENT tag to determine whether or not the images
# generated for formulas are transparent PNGs. Transparent PNGs are not
# supported properly for IE 6.0, but are supported on all modern browsers.
#
# Note that when changing this option you need to delete any form_*.png files in
# the HTML output directory before the changes have effect.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_TRANSPARENT    = YES

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# http://www.mathjax.org) which uses client side Javascript for the rendering
# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. See the MathJax site (see:
# http://docs.mathjax.org/en/latest/output.html) for more details.
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility), NativeMML (i.e. MathML) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. The destination directory
# should contain the MathJax.js script. For instance, if the mathjax directory
# is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
# Content Delivery Network so you can quickly see the result without installing
# MathJax. However, it is strongly recommended to install a local copy of
# MathJax from http://www.mathjax.org before deployment.
# The default value is: http://cdn.mathjax.org/mathjax/latest.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     = 

# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
# of code that will be used on startup of the MathJax code. See the MathJax site
# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
# example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       = 

# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
# the HTML output. The underlying search engine uses javascript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the javascript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using Javascript. There
# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
# setting. When disabled, doxygen will generate a PHP script for searching and
# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
# and searching needs to be provided by external tools. See the section
# "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: http://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: http://xapian.org/). See the section "External Indexing and
# Searching" for details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       = 

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     = 

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  = 

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = NO

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when enabling USE_PDFLATEX this option is only used for generating
# bitmaps for formulas in the HTML output, but not in the Makefile that is
# written to the output directory.
# The default file is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. To get the times font for
# instance you can specify
# EXTRA_PACKAGES=times
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         = 

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
# generated LaTeX document. The header should contain everything until the first
# chapter. If it is left blank doxygen will generate a standard header. See
# section "Doxygen usage" for information on how to let doxygen write the
# default header to a separate file.
#
# Note: Only use a user-defined header if you know what you are doing! The
# following commands have a special meaning inside the header: $title,
# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
# string, for the replacement values of the other commands the user is referred
# to HTML_HEADER.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           = 

# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
# generated LaTeX document. The footer should contain everything after the last
# chapter. If it is left blank doxygen will generate a standard footer. See
# LATEX_HEADER for more information on how to generate a default footer and what
# special commands can be used inside the footer.
#
# Note: Only use a user-defined footer if you know what you are doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           = 

# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# LaTeX style sheets that are included after the standard style sheets created
# by doxygen. Using this option one can overrule certain style aspects. Doxygen
# will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_STYLESHEET = 

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      = 

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
# the PDF file directly from the LaTeX files. Set this option to YES, to get a
# higher quality PDF documentation.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
# command to the generated LaTeX files. This will instruct LaTeX to keep running
# if errors occur, instead of asking the user for help. This option is also used
# when generating formulas in HTML.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
# code with syntax highlighting in the LaTeX output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_SOURCE_CODE      = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plain.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plain

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's config
# file, i.e. a series of assignments. You only have to provide replacements,
# missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    = 

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to doxygen's config file. A template extensions file can be generated
# using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    = 

# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
# with syntax highlighting in the RTF output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_SOURCE_CODE        = NO

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# The MAN_SUBDIR tag determines the name of the directory created within
# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
# MAN_EXTENSION with the initial . removed.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_SUBDIR             = 

# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
# program listings (including syntax highlighting and cross-referencing
# information) to the DOCBOOK output. Note that enabling this will significantly
# increase the size of the DOCBOOK output.
# The default value is: NO.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_PROGRAMLISTING = NO

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
# AutoGen Definitions (see http://autogen.sf.net) file that captures the
# structure of the code including all documentation. Note that this feature is
# still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO, the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX = 

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
# in the source code. If set to NO, only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES, the include files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           = 

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  = 

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             = 

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      = 

# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
# remove all references to function-like macros that are alone on a line, have
# an all uppercase name, and do not end with a semicolon. Such function macros
# are typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have a unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               = 

# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       = 

# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
# the class index. If set to NO, only the inherited external classes will be
# listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
# in the modules index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

# The PERL_PATH should be the absolute path and name of the perl script
# interpreter (i.e. the result of 'which perl').
# The default file (with absolute path) is: /usr/bin/perl.

PERL_PATH              = /usr/bin/perl

#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
# NO turns the diagrams off. Note that this option also works with HAVE_DOT
# disabled, but it is recommended to install and use dot, since it yields more
# powerful graphs.
# The default value is: YES.

CLASS_DIAGRAMS         = NO

# You can define message sequence charts within doxygen comments using the \msc
# command. Doxygen will then run the mscgen tool (see:
# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
# documentation. The MSCGEN_PATH tag allows you to specify the directory where
# the mscgen tool resides. If left empty the tool is assumed to be found in the
# default search path.

MSCGEN_PATH            = 

# You can include diagrams made with dia in doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               = 

# If set to YES the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
# to run in parallel. When set to 0 doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 32, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 0

# When you want a differently looking font in the dot files that doxygen
# generates you can specify the font name using DOT_FONTNAME. You need to make
# sure dot is able to find the font, which can be done by putting it in a
# standard location or by setting the DOTFONTPATH environment variable or by
# setting DOT_FONTPATH to the directory containing the font.
# The default value is: Helvetica.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTNAME           = Helvetica

# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
# dot graphs.
# Minimum value: 4, maximum value: 24, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTSIZE           = 10

# By default doxygen will tell dot to use the default font as specified with
# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
# the path where dot can find it using this tag.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           = 

# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
# each documented class showing the direct and indirect inheritance relations.
# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
# groups, showing the direct groups dependencies.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = NO

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = YES

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = NO

# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot.
# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
# to make the SVG files visible in IE 9+ (other browsers do not have this
# requirement).
# Possible values are: png, jpg, gif and svg.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
# the SVG files visible. Older versions of IE do not have SVG support.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = NO

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               = 

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           = 

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           = 

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           = 

# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
# path where java can find the plantuml.jar file. If left blank, it is assumed
# PlantUML is not used or called during a preprocessing step. Doxygen will
# generate a warning when it encounters a \startuml command in this case and
# will not generate output for the diagram.

PLANTUML_JAR_PATH      = 

# When using plantuml, the specified paths are searched for files specified by
# the !include statement in a plantuml block.

PLANTUML_INCLUDE_PATH  = 

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that doxygen if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
# background. This is disabled by default, because dot on Windows does not seem
# to support this out of the box.
#
# Warning: Depending on the platform used, enabling this option may lead to
# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
# read).
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
# files that are used to generate the various graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_CLEANUP            = YES

```

`Scheduler/Doxygen/style.css`:

```css
body, table, div, p, dl {
  font: 400 13px/1.3 Verdana,DejaVu Sans,Geneva,sans-serif;
}

/* @group Heading Levels */

h1.groupheader {
  font-size: 16px;
}

.title {
  font: 700 18px Verdana,DejaVu Sans,Geneva,sans-serif;  
  margin: 10px 2px;
}

h2.groupheader {
  border: 0;
  color: #363534;
  font-size: 16px;
  font-weight: 600;
}

h3.groupheader {
  font-size: 13px;
}

h1, h2, h3, h4, h5, h6 {
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
  transition: none;
}

h1.glow, h2.glow, h3.glow, h4.glow, h5.glow, h6.glow {
  text-shadow: none;
}

dt {
}

div.multicol {
}

p.startli, p.startdd {
}

p.starttd {
}

p.endli {
}

p.enddd {
}

p.endtd {
}

/* @end */

caption {
}

span.legend {
}

h3.version {
}

div.qindex, div.navtab {
  background-color: #F6F6F6;
  border: 1px solid #E6E6E6;
}

div.qindex, div.navpath {
  line-height: 1.5;
}

div.navtab {
}

/* @group Link Styling */

a {
  color: #002F73;
}

.contents a:visited {
  color: #002F73;
}

a:hover {
  text-decoration: none;
}

a.qindex {
}

a.qindexHL {
}

.contents a.qindexHL:visited {
}

a.el {
  font-weight: normal;
}

a.elRef {
}

a.code, a.code:visited, a.line, a.line:visited {
  color: #002F73; 
}

a.codeRef, a.codeRef:visited, a.lineRef, a.lineRef:visited {
  color: #002F73; 
}

/* @end */

dl.el {
}

pre.fragment {
}

div.fragment {
}

div.line {
  -webkit-transition-duration: 0;
  -moz-transition-duration: 0;
  -ms-transition-duration: 0;
  -o-transition-duration: 0;
  transition-duration: 0;
}

div.line.glow {
  background-color: auto;
  box-shadow: none;
}

span.lineno {
}

span.lineno a {
}

span.lineno a:hover {
}

div.ah {
  background: none;
  background-color: #F6F6F6;
  color: #66666E;
  border: 1px solid #E6E6E6;
  border-radius: 7px;
  -webkit-border-radius: 7px;
  -moz-border-radius: 7px;
  box-shadow: none;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
}

div.groupHeader {
}

div.groupText {
}

body {
  color: #363534;
}

div.contents {
}

td.indexkey {
}

td.indexvalue {
}

tr.memlist {
}

p.formulaDsp {
}

img.formulaDsp {
}

img.formulaInl {
}

div.center {
}

div.center img {
}

address.footer {
}

img.footer {
  display: none;
}

/* addition */
.footer a:before {
  content: "Doxygen";
}
/* --- */

/* @group Code Colorization */

span.keyword {
}

span.keywordtype {
}

span.keywordflow {
}

span.comment {
}

span.preprocessor {
}

span.stringliteral {
}

span.charliteral {
}

span.vhdldigit { 
}

span.vhdlchar { 
}

span.vhdlkeyword { 
}

span.vhdllogic { 
}

blockquote {
}

/* @end */

.search {
}

form.search {
}

input.search {
}

td.tiny {
}

.dirtab {
}

th.dirtab {
}

hr {
  border-top: 1px solid #E6E6E6;
  margin: 10px 8px 0 12px;
}

hr.footer {
}

/* @group Member Descriptions */

table.memberdecls {
  font-size: 13px;
}

/* addition */

table.memberdecls a {
  font-weight: 600;  
}

table.memberdecls .memItemLeft {
  border: solid #E6E6E6;
  border-width: 0 0 0 1px;
}

table.memberdecls .memItemRight {
  border: solid #E6E6E6;
  border-width: 0 1px 0 0;
}

table.memberdecls tr:nth-child(2) .memItemLeft {
  border-top-width: 1px;
  border-top-left-radius: 7px;
  padding-top: 6px;
}

table.memberdecls tr:nth-child(2) .memItemRight {
  border-top-width: 1px;
  border-top-right-radius: 7px;
  padding-top: 6px;
}

table.memberdecls tr:nth-last-child(2) .memItemLeft {
  border-bottom-width: 1px;
  border-bottom-left-radius: 7px;
  padding-bottom: 6px;
}

table.memberdecls tr:nth-last-child(2) .memItemRight {
  border-bottom-width: 1px;
  border-bottom-right-radius: 7px;
  padding-bottom: 6px;
}

/* --- */

.memberdecls td, .fieldtable tr {
  -webkit-transition-duration: 0;
  -moz-transition-duration: 0;
  -ms-transition-duration: 0;
  -o-transition-duration: 0;
  transition-duration: 0;
}

.memberdecls td.glow, .fieldtable tr.glow {
  background-color: auto;
  box-shadow: 0;
}

.mdescLeft, .mdescRight,
.memItemLeft, .memItemRight,
.memTemplItemLeft, .memTemplItemRight, .memTemplParams {
  width: auto;
  background-color: #F6F6F6;
}

.mdescLeft, .mdescRight {
}

/* addition */
.mdescLeft {
  padding: 3px 10px 3px 15px;
}

.mdescRight {
  padding: 3px 15px 3px 10px;
}
/* --- */

.memSeparator {
  display: none;
}

.memItemLeft, .memTemplItemLeft {
}

.memItemRight {
  padding-right: 8px;
}

.memTemplParams {
}

/* @end */

/* @group Member Details */

/* Styles for detailed member documentation */

.memtemplate {
}

.memnav {
}

.mempage {
}

.memitem {
  margin-bottom: 20px;
  -webkit-transition-duration: 0;
  -moz-transition-duration: 0;
  -ms-transition-duration: 0;
  -o-transition-duration: 0;
  transition-duration: 0;
}

.memitem.glow {
  box-shadow: none;
}

.memname {
  font-size: 13px;
}

.memname td {
}

.memproto, dl.reflist dt {
  border: 1px solid #E6E6E6;
  padding: 5px 10px;
  color: #363534;
  text-shadow: none;
  background: none;
  background-color: #F6F6F6;
  box-shadow: none;
  border-radius: 7px;
  -moz-box-shadow: none;
  -moz-border-radius: 7px;
  -webkit-box-shadow: none;
  -webkit-border-radius: 7px;
}

/* additional */
.memproto .memname {
  font-weight: bold;
}

.memproto .memname a {
  font-weight: bold;  
}
/* --- */

.memdoc, dl.reflist dd {
  border: 0;      
  padding: 0;
  background: none;
  border-radius: 0;
  box-shadow: none;
  -moz-border-radius: 0;
  -moz-box-shadow: none;
  -webkit-border-radius: 0;
  -webkit-box-shadow: none;
}

dl.reflist dt {
}

dl.reflist dd {
}

.paramkey {
}

.paramtype {
}

.paramname {
  color: #363534;
}

.paramname em {
}

.paramname code {
}

.params, .retval, .exception, .tparams {
}       

.params .paramname, .retval .paramname {
}
        
.params .paramtype {
}       
        
.params .paramdir {
}

.mlabels {
}

td.mlabels-left {
}

td.mlabels-right {
}

span.mlabels {
}

span.mlabel {
  background-color: #E6E6E6;
  border: 0;
  color: #66666E;
  padding: 4px 5px;
  border-radius: 4px;
  font-size: 11px;
}

/* @end */

/* these are for tree view when not used as main index */

div.directory {
  border: none;
}

.directory table {
}

.directory td {
}

.directory td.entry {
}

.directory td.entry a {
  font-weight: bold;
}

.directory td.entry a img {
}

.directory td.desc {
  border-color: #E6E6E6;
}

.directory tr.even {
  background: none;
}

.directory img {
  vertical-align: -30%;
}

.directory .levels {
}

.directory .levels span {
}

div.dynheader {
}

address {
}

table.doxtable {
}

table.doxtable td, table.doxtable th {
  border: 1px solid #E6E6E6;
}

table.doxtable th {
  background-color: #F6F6F6;
  color: #66666E;
  font-size: 13px;
}

table.fieldtable {
  padding: 5px 10px;
  border: 1px solid #E6E6E6;
  background-color: #F6F6F6;
  box-shadow: none;
  border-radius: 7px;
  -moz-box-shadow: none;
  -moz-border-radius: 7px;
  -webkit-box-shadow: none;
  -webkit-border-radius: 7px;
}

.fieldtable td, .fieldtable th {
}

.fieldtable td.fieldtype, .fieldtable td.fieldname {
  border: 0;
}

.fieldtable td.fieldname {
  font-size: 13px;
}

/* additional */
.fieldtable td.fieldname em {
  font-style: normal;
}
/* --- */

.fieldtable td.fielddoc {
  border: 0;
  font-size: 13px;
}

/* additional */
.fieldtable td.fielddoc * {
  font-size: 13px;
}
/* --- */

.fieldtable td.fielddoc p:first-child {
  margin: auto;
}       
        
.fieldtable td.fielddoc p:last-child {
  margin: auto;
}

.fieldtable tr:last-child td {
}

.fieldtable th {
  background: none;
  background-color: #E6E6E6;
  font-size: 13px;
  font-weight: normal;
  color: #363534;
  border-radius: 0;
  -moz-border-radius: 0;
  -webkit-border-radius: 0;
  border: 0;
}

.tabsearch {
}

.navpath ul {
  background: none;
  background-color: #E6E6E6;
  color: #363534;
  border: 0;
  font-size: 13px;
}

.navpath li {
  color: #363534;
}

.navpath li.navelem a {
  color: #363534;
}

.navpath li.navelem a:hover {
  color: #363534;
}

.navpath li.footer {
  color: #363534;
  font-size: 13px;
}

div.summary {
  margin: 20px;
  width: auto;
  display: inline-block;
  text-align: left;
  color: transparent;
  line-height: 0;
  padding: 15px 25px;      
  border: 1px solid #E6E6E6;
  background-color: #F6F6F6;
  border-radius: 7px;
  -moz-border-radius: 7px;
  -webkit-border-radius: 7px;
  font-size: 13px;
}

div.summary a {
  display: block;  
  line-height: 1.5;
}

div.ingroups {
}

div.ingroups a {
}

div.header {
  background: none;
  border: 0;
}

div.headertitle {
}

dl {
}

/* dl.note, dl.warning, dl.attention, dl.pre, dl.post, dl.invariant, dl.deprecated, dl.todo, dl.test, dl.bug */
dl.section {
}

dl.note {
}

dl.warning, dl.attention {
}

dl.pre, dl.post, dl.invariant {
}

dl.deprecated {
}

dl.todo {
}

dl.test {
}

dl.bug {
}

dl.section dd {
}

#projectlogo {
}
 
#projectlogo img { 
}

#projectname {
  font: 24px Verdana,DejaVu Sans,Geneva,sans-serif;  
  font-weight: bold;
  display: inline;
}

#projectbrief {
  font: 16px Verdana,DejaVu Sans,Geneva,sans-serif;  
  display: inline;
}

#projectnumber {
  font: 16px Verdana,DejaVu Sans,Geneva,sans-serif;  
  display: inline;
}

#titlearea {
  border: 0;
  background-color: #E6E6E6;
}

.image {
}

.dotgraph {
}

.mscgraph {
}

.diagraph {
}

.caption {
}

div.zoom {
}

dl.citelist {
}

dl.citelist dt {
}

dl.citelist dd {
}

div.toc {
}

div.toc li {
}

div.toc h3 {
}

div.toc ul {
}       

div.toc li.level1 {
}

div.toc li.level2 {
}

div.toc li.level3 {
}

div.toc li.level4 {
}

.inherit_header {
}

.inherit_header td {
}

.inherit {
}

tr.heading h2 {
}

/* tooltip related style info */

.ttc {
}

#powerTip {
}

#powerTip div.ttdoc {
}

#powerTip div.ttname a {
}

#powerTip div.ttname {
}

#powerTip div.ttdeci {
}

#powerTip div {
  font: 13px/1.3 Verdana,DejaVu Sans,Geneva,sans-serif;
  color: #363534;
}

#powerTip:before, #powerTip:after {
}

#powerTip.n:after,  #powerTip.n:before,
#powerTip.s:after,  #powerTip.s:before,
#powerTip.w:after,  #powerTip.w:before,
#powerTip.e:after,  #powerTip.e:before,
#powerTip.ne:after, #powerTip.ne:before,
#powerTip.se:after, #powerTip.se:before,
#powerTip.nw:after, #powerTip.nw:before,
#powerTip.sw:after, #powerTip.sw:before {
}

#powerTip.n:after,  #powerTip.s:after,
#powerTip.w:after,  #powerTip.e:after,
#powerTip.nw:after, #powerTip.ne:after,
#powerTip.sw:after, #powerTip.se:after {
}

#powerTip.n:before,  #powerTip.s:before,
#powerTip.w:before,  #powerTip.e:before,
#powerTip.nw:before, #powerTip.ne:before,
#powerTip.sw:before, #powerTip.se:before {
}

#powerTip.n:after,  #powerTip.n:before,
#powerTip.ne:after, #powerTip.ne:before,
#powerTip.nw:after, #powerTip.nw:before {
}

#powerTip.n:after, #powerTip.ne:after, #powerTip.nw:after {
}
#powerTip.n:before {
}
#powerTip.n:after, #powerTip.n:before {
}

#powerTip.nw:after, #powerTip.nw:before {
}

#powerTip.ne:after, #powerTip.ne:before {
}

#powerTip.s:after,  #powerTip.s:before,
#powerTip.se:after, #powerTip.se:before,
#powerTip.sw:after, #powerTip.sw:before {
}

#powerTip.s:after, #powerTip.se:after, #powerTip.sw:after {
}

#powerTip.s:before, #powerTip.se:before, #powerTip.sw:before {
}

#powerTip.s:after, #powerTip.s:before {
}

#powerTip.sw:after, #powerTip.sw:before {
}

#powerTip.se:after, #powerTip.se:before {
}

#powerTip.e:after, #powerTip.e:before {
}

#powerTip.e:after {
}

#powerTip.e:before {
}

#powerTip.w:after, #powerTip.w:before {
}

#powerTip.w:after {
}

#powerTip.w:before {
}

/* tabs.css */

.tabs, .tabs2, .tabs3 {
  background: none;
  background-color: #F6F6F6;
  font: 13px Verdana,DejaVu Sans,Geneva,sans-serif;
  border-bottom: 1px solid #E6E6E6;
}

.tabs2 {
  font-size: 13px;
}
.tabs3 {
  font-size: 13px;
}

.tablist {
}

.tablist li {
  background: none;
  line-height: 1.5;
}

.tablist a {
  padding: 0 10px;
  font-weight: normal;
  background: none;
  color: #002F73;
  text-shadow: none;
}

.tabs3 .tablist a {
}

.tablist a:hover {
  background: none;
  color: #002F73;
  text-shadow: none;
}

.tablist li.current a {
  background: none;
  color: #002F73;
  text-shadow: none;
}

/* navtree.css */

#nav-tree .children_ul {
}

#nav-tree ul {
}

#nav-tree li {
}

#nav-tree .plus {
}

#nav-tree .selected {
  background: none;
  background-color: #E6E6E6;
  color: #002F73;
  text-shadow: none;
}

#nav-tree img {
}

#nav-tree a {
}

#nav-tree .label {
  font: 12px Verdana,DejaVu Sans,Geneva,sans-serif;
}

#nav-tree .label a {
}

#nav-tree .selected a {
  color: #002F73;
}

#nav-tree .children_ul {
}

#nav-tree .item {
}

#nav-tree {
  background-color: #F6F6F6; 
}

#doc-content {
}

#side-nav {
}

.ui-resizable .ui-resizable-handle {
}

.ui-resizable-e {
  background: none;
  background-color: #E6E6E6;
}

.ui-resizable-handle {
}

#nav-tree-contents {
}

#nav-tree {
  background: none;
  background-color: #F6F6F6;
}

#nav-sync {
}

#nav-sync img {
}

#nav-sync img:hover {
}


```

`Scheduler/Include/MTAppInterop.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTConfig.h>

#if MT_MSVC_COMPILER_FAMILY
#include <crtdefs.h>
#elif MT_GCC_COMPILER_FAMILY
#include <sys/types.h>
#include <stddef.h>
#else
#error Compiler is not supported
#endif

#if MT_MSVC_COMPILER_FAMILY
#define MT_NORETURN 
#elif MT_GCC_COMPILER_FAMILY
#define MT_NORETURN // [[ noreturn ]] 
#else
#error Can not define MT_NORETURN. Unknown platform.
#endif



#define MT_DEFAULT_ALIGN (16)

namespace MT
{
	// Memory allocator interface.
	//////////////////////////////////////////////////////////////////////////
	struct Memory
	{
		struct StackDesc
		{
			void* stackBottom;
			void* stackTop;

			char* stackMemory;
			size_t stackMemoryBytesCount;


			StackDesc()
				: stackBottom(nullptr)
				, stackTop(nullptr)
				, stackMemory(nullptr)
				, stackMemoryBytesCount(0)
			{
			}

			size_t GetStackSize()
			{
				return (char*)stackTop - (char*)stackBottom;
			}
		};


		static void* Alloc(size_t size, size_t align = MT_DEFAULT_ALIGN);
		static void Free(void* p);

		static StackDesc AllocStack(size_t size);
		static void FreeStack(const StackDesc & desc);
	};


	struct Diagnostic
	{
		MT_NORETURN static void ReportAssert(const char* condition, const char* description, const char* sourceFile, int sourceLine);
	};


}

```

`Scheduler/Include/MTArrayView.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once


namespace MT
{


	/// \class ArrayView
	/// \brief Simple wrapper to work with raw memory as an array. Includes array bounds checking.
	template<class T>
	class ArrayView
	{
		T* data;
		size_t count;

	public:

		ArrayView()
		{
			data = nullptr;
			count = 0;
		}

		ArrayView(void* memoryChunk, size_t instanceCount)
			: data((T*)memoryChunk)
			, count(instanceCount)
		{
			MT_ASSERT(count == 0 || data, "Invalid data array");
		}

		~ArrayView()
		{
			data = nullptr;
			count = 0;
		}

		const T &operator[]( size_t i ) const
		{
			MT_ASSERT( i < Size(), "bad index" );
			return data[i];
		}

		T &operator[]( size_t i )
		{
			MT_ASSERT( i < Size(), "bad index" );
			return data[i];
		}

		size_t Size() const
		{
			return count;
		}

		bool IsEmpty() const
		{
			return count == 0;
		}

		T* GetRawData()
		{
			return data;
		}

		const T* GetRawData() const
		{
			return data;
		}

	};


}

```

`Scheduler/Include/MTAtomic.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_ATOMIC_MAIN__
#define __MT_ATOMIC_MAIN__

#include <MTTypes.h>
#include <MTDebug.h>
#include <Platform/Common/MTAtomic.h>


#endif

```

`Scheduler/Include/MTColorTable.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTTypes.h>

namespace MT
{

	// Source: http://msdn.microsoft.com/en-us/library/system.windows.media.colors(v=vs.110).aspx
	// Image:  http://i.msdn.microsoft.com/dynimg/IC24340.png
	// Format: ARGB
	namespace Color
	{
		enum Type
		{
			Null = 0x00000000,
			AliceBlue = 0xFFF0F8FF,
			AntiqueWhite = 0xFFFAEBD7,
			Aqua = 0xFF00FFFF,
			Aquamarine = 0xFF7FFFD4,
			Azure = 0xFFF0FFFF,
			Beige = 0xFFF5F5DC,
			Bisque = 0xFFFFE4C4,
			Black = 0xFF000000,
			BlanchedAlmond = 0xFFFFEBCD,
			Blue = 0xFF0000FF,
			BlueViolet = 0xFF8A2BE2,
			Brown = 0xFFA52A2A,
			BurlyWood = 0xFFDEB887,
			CadetBlue = 0xFF5F9EA0,
			Chartreuse = 0xFF7FFF00,
			Chocolate = 0xFFD2691E,
			Coral = 0xFFFF7F50,
			CornflowerBlue = 0xFF6495ED,
			Cornsilk = 0xFFFFF8DC,
			Crimson = 0xFFDC143C,
			Cyan = 0xFF00FFFF,
			DarkBlue = 0xFF00008B,
			DarkCyan = 0xFF008B8B,
			DarkGoldenRod = 0xFFB8860B,
			DarkGray = 0xFFA9A9A9,
			DarkGreen = 0xFF006400,
			DarkKhaki = 0xFFBDB76B,
			DarkMagenta = 0xFF8B008B,
			DarkOliveGreen = 0xFF556B2F,
			DarkOrange = 0xFFFF8C00,
			DarkOrchid = 0xFF9932CC,
			DarkRed = 0xFF8B0000,
			DarkSalmon = 0xFFE9967A,
			DarkSeaGreen = 0xFF8FBC8F,
			DarkSlateBlue = 0xFF483D8B,
			DarkSlateGray = 0xFF2F4F4F,
			DarkTurquoise = 0xFF00CED1,
			DarkViolet = 0xFF9400D3,
			DeepPink = 0xFFFF1493,
			DeepSkyBlue = 0xFF00BFFF,
			DimGray = 0xFF696969,
			DodgerBlue = 0xFF1E90FF,
			FireBrick = 0xFFB22222,
			FloralWhite = 0xFFFFFAF0,
			ForestGreen = 0xFF228B22,
			Fuchsia = 0xFFFF00FF,
			Gainsboro = 0xFFDCDCDC,
			GhostWhite = 0xFFF8F8FF,
			Gold = 0xFFFFD700,
			GoldenRod = 0xFFDAA520,
			Gray = 0xFF808080,
			Green = 0xFF008000,
			GreenYellow = 0xFFADFF2F,
			HoneyDew = 0xFFF0FFF0,
			HotPink = 0xFFFF69B4,
			IndianRed = 0xFFCD5C5C,
			Indigo = 0xFF4B0082,
			Ivory = 0xFFFFFFF0,
			Khaki = 0xFFF0E68C,
			Lavender = 0xFFE6E6FA,
			LavenderBlush = 0xFFFFF0F5,
			LawnGreen = 0xFF7CFC00,
			LemonChiffon = 0xFFFFFACD,
			LightBlue = 0xFFADD8E6,
			LightCoral = 0xFFF08080,
			LightCyan = 0xFFE0FFFF,
			LightGoldenRodYellow = 0xFFFAFAD2,
			LightGray = 0xFFD3D3D3,
			LightGreen = 0xFF90EE90,
			LightPink = 0xFFFFB6C1,
			LightSalmon = 0xFFFFA07A,
			LightSeaGreen = 0xFF20B2AA,
			LightSkyBlue = 0xFF87CEFA,
			LightSlateGray = 0xFF778899,
			LightSteelBlue = 0xFFB0C4DE,
			LightYellow = 0xFFFFFFE0,
			Lime = 0xFF00FF00,
			LimeGreen = 0xFF32CD32,
			Linen = 0xFFFAF0E6,
			Magenta = 0xFFFF00FF,
			Maroon = 0xFF800000,
			MediumAquaMarine = 0xFF66CDAA,
			MediumBlue = 0xFF0000CD,
			MediumOrchid = 0xFFBA55D3,
			MediumPurple = 0xFF9370DB,
			MediumSeaGreen = 0xFF3CB371,
			MediumSlateBlue = 0xFF7B68EE,
			MediumSpringGreen = 0xFF00FA9A,
			MediumTurquoise = 0xFF48D1CC,
			MediumVioletRed = 0xFFC71585,
			MidnightBlue = 0xFF191970,
			MintCream = 0xFFF5FFFA,
			MistyRose = 0xFFFFE4E1,
			Moccasin = 0xFFFFE4B5,
			NavajoWhite = 0xFFFFDEAD,
			Navy = 0xFF000080,
			OldLace = 0xFFFDF5E6,
			Olive = 0xFF808000,
			OliveDrab = 0xFF6B8E23,
			Orange = 0xFFFFA500,
			OrangeRed = 0xFFFF4500,
			Orchid = 0xFFDA70D6,
			PaleGoldenRod = 0xFFEEE8AA,
			PaleGreen = 0xFF98FB98,
			PaleTurquoise = 0xFFAFEEEE,
			PaleVioletRed = 0xFFDB7093,
			PapayaWhip = 0xFFFFEFD5,
			PeachPuff = 0xFFFFDAB9,
			Peru = 0xFFCD853F,
			Pink = 0xFFFFC0CB,
			Plum = 0xFFDDA0DD,
			PowderBlue = 0xFFB0E0E6,
			Purple = 0xFF800080,
			Red = 0xFFFF0000,
			RosyBrown = 0xFFBC8F8F,
			RoyalBlue = 0xFF4169E1,
			SaddleBrown = 0xFF8B4513,
			Salmon = 0xFFFA8072,
			SandyBrown = 0xFFF4A460,
			SeaGreen = 0xFF2E8B57,
			SeaShell = 0xFFFFF5EE,
			Sienna = 0xFFA0522D,
			Silver = 0xFFC0C0C0,
			SkyBlue = 0xFF87CEEB,
			SlateBlue = 0xFF6A5ACD,
			SlateGray = 0xFF708090,
			Snow = 0xFFFFFAFA,
			SpringGreen = 0xFF00FF7F,
			SteelBlue = 0xFF4682B4,
			Tan = 0xFFD2B48C,
			Teal = 0xFF008080,
			Thistle = 0xFFD8BFD8,
			Tomato = 0xFFFF6347,
			Turquoise = 0xFF40E0D0,
			Violet = 0xFFEE82EE,
			Wheat = 0xFFF5DEB3,
			White = 0xFFFFFFFF,
			WhiteSmoke = 0xFFF5F5F5,
			Yellow = 0xFFFFFF00,
			YellowGreen = 0xFF9ACD32,
		};

		inline uint32 ConvertToABGR(Color::Type _color)
		{
			uint32 color = _color;

			uint8 r = (color >> 16) & 0xFF;
			uint8 b = (color) & 0xFF;

			uint32 result = (color & 0xFF00FF00);
			result |= r;
			result |= (b << 16);

			return result;
		}

	}

}
```

`Scheduler/Include/MTConcurrentRingBuffer.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTPlatform.h>
#include <MTTools.h>
#include <MTAppInterop.h>

namespace MT
{
	template<int N>
	struct is_power_of_two
	{
		enum {value = N && !(N & (N - 1))};
	};


	/// \class ConcurrentRingBuffer
	/// \brief Very naive implementation of thread safe ring buffer. When ring buffer is full and a subsequent write is performed, then it starts overwriting the oldest data. 
	template<typename T, size_t numElements>
	class ConcurrentRingBuffer
	{
		static const int32 ALIGNMENT = 16;

		MT::Mutex mutex;

		void* data;

		size_t writeIndex;
		size_t readIndex;
		size_t size;

		inline T* Buffer()
		{
			return (T*)(data);
		}

		inline void MoveCtor(T* element, T && val)
		{
			new(element) T(std::move(val));
		}

		inline void Dtor(T* element)
		{
			MT_UNUSED(element);
			element->~T();
		}

		size_t NextIndex(size_t index)
		{
			size_t ret = index + 1;
			size_t mask = (numElements - 1);
			return (ret & mask);
		}

	public:

		MT_NOCOPYABLE(ConcurrentRingBuffer);

		ConcurrentRingBuffer()
			: writeIndex(0)
			, readIndex(0)
			, size(0)
		{
			data = Memory::Alloc(sizeof(T) * numElements, ALIGNMENT);

			static_assert(is_power_of_two<numElements>::value == true, "NumElements used in MT::ConcurrentRingBuffer must be power of two");
		}

		~ConcurrentRingBuffer()
		{
			Memory::Free(data);
			data = nullptr;
		}

		void Push(T && item)
		{
			MT::ScopedGuard guard(mutex);

			if (size >= numElements)
			{
				// RingBuffer is full. Overwrite old data.
				Dtor(Buffer() + readIndex);
				readIndex = NextIndex(readIndex);
			} else
			{
				size++;
			}

			MoveCtor(Buffer() + writeIndex, std::move(item));
			writeIndex = NextIndex(writeIndex);
		}

		size_t PopAll(T * dstBuffer, size_t dstBufferSize)
		{
			MT::ScopedGuard guard(mutex);

			size_t elementsCount = size;
			elementsCount = MT::Min(elementsCount, dstBufferSize);

			for (size_t i = 0; i < elementsCount; i++)
			{
				dstBuffer[i] = std::move(Buffer()[readIndex]);
				Dtor(Buffer() + readIndex);
				readIndex = NextIndex(readIndex);
			}

			size -= elementsCount;
			return elementsCount;
		}




	};

}

```

`Scheduler/Include/MTConfig.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once


// Target Platform
////////////////////////////////////////////////////////////////////////
#if   _WIN32

#define MT_PLATFORM_WINDOWS (1)

#elif __APPLE_CC__

#define MT_PLATFORM_OSX (1)

#else

#define MT_PLATFORM_POSIX (1)

#endif


// Compiler support for SSE intrinsics
////////////////////////////////////////////////////////////////////////
#if (defined(__SSE__) || defined(_M_IX86) || defined(_M_X64))

#define MT_SSE_INTRINSICS_SUPPORTED (1)

#endif


// Compiler support for C++11
////////////////////////////////////////////////////////////////////////

#if __STDC_VERSION__ >= 201112L

#define MT_CPP11_SUPPORTED (1)

#endif


// Compiler family
////////////////////////////////////////////////////////////////////////

#ifdef __clang__

#define MT_CLANG_COMPILER_FAMILY (1)
#define MT_GCC_COMPILER_FAMILY (1)

#elif __GNUC__

#define MT_GCC_COMPILER_FAMILY (1)

#elif defined(_MSC_VER)

#define MT_MSVC_COMPILER_FAMILY (1)

#endif


// Debug / Release
////////////////////////////////////////////////////////////////////////

#if defined(_DEBUG) || defined(DEBUG)

#define MT_DEBUG (1)

#else

#define MT_RELEASE (1)

#endif


// x64 / x86
////////////////////////////////////////////////////////////////////////
#if defined(_M_X64)

#define MT_PTR64 (1)

#endif



//
// x86-64 CPU has strong memory model, so we don't need to define acquire/release fences here
// 

//
// Acquire semantics is a property which can only apply to operations which read from shared memory,
// whether they are read-modify-write operations or plain loads. The operation is then considered a read-acquire.
// Acquire semantics prevent memory reordering of the read-acquire with any read or write operation which follows it in program order.
//
// Acquire fence is a fence which does not permit subsequent memory operations to be advanced before it.
//

#if MT_MSVC_COMPILER_FAMILY
// MSVC compiler barrier
#define mt_acquire_fence() _ReadWriteBarrier()
#elif MT_GCC_COMPILER_FAMILY
// GCC compiler barrier
#define mt_acquire_fence() asm volatile("" ::: "memory")
#else
#error Platform is not supported!
#endif


	
//
// Release semantics is a property which can only apply to operations which write to shared memory,
// whether they are read-modify-write operations or plain stores. The operation is then considered a write-release.
// Release semantics prevent memory reordering of the write-release with any read or write operation which precedes it in program order.
//
// Release fence is a fence which does not permit preceding memory operations to be delayed past it.
//

#if MT_MSVC_COMPILER_FAMILY
// MSVC compiler barrier
#define mt_release_fence() _ReadWriteBarrier()
#elif MT_GCC_COMPILER_FAMILY
// GCC compiler barrier
#define mt_release_fence() asm volatile("" ::: "memory")
#else
#error Platform is not supported!
#endif



//
// mt_forceinline
//
#if MT_MSVC_COMPILER_FAMILY
#define mt_forceinline __forceinline
#elif MT_GCC_COMPILER_FAMILY
#define mt_forceinline __attribute__((always_inline)) inline
#else
#error Can not define mt_forceinline. Unknown platform.
#endif


// Enable Windows XP support (disable conditional variables)
//#if !MT_PTR64 && MT_PLATFORM_WINDOWS
//#define MT_ENABLE_LEGACY_WINDOWSXP_SUPPORT (1)
//#endif


```

`Scheduler/Include/MTDebug.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once
#include <MTConfig.h>
#include <MTAppInterop.h>


#if defined(MT_DEBUG) || defined(MT_INSTRUMENTED_BUILD)

#define MT_REPORT_ASSERT_IMPL( condition, description, file, line ) MT::Diagnostic::ReportAssert(#condition, description, file, line);

#ifndef MT_REPORT_ASSERT
#define MT_REPORT_ASSERT( description ) { MT_REPORT_ASSERT_IMPL( "always", description, __FILE__, __LINE__ ) }
#endif

#ifndef MT_ASSERT
#define MT_ASSERT( condition, description ) { if ( !(condition) ) { MT_REPORT_ASSERT_IMPL( #condition, description, __FILE__, __LINE__ ) } }
#endif

#ifndef MT_VERIFY
#define MT_VERIFY( condition, description, operation ) { if ( !(condition) ) { { MT_REPORT_ASSERT_IMPL( #condition, description, __FILE__, __LINE__ ) }; operation; } }
#endif

#else

#ifndef MT_REPORT_ASSERT
#define MT_REPORT_ASSERT( description )
#endif

#ifndef MT_ASSERT
#define MT_ASSERT( condition, description )
#endif

#ifndef MT_VERIFY
#define MT_VERIFY( condition, description, operation ) { if ( !(condition) ) { operation; } }
#endif

#endif

```

`Scheduler/Include/MTFiberContext.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTTools.h>
#include <MTPlatform.h>
#include <MTTaskBucket.h>

#ifdef Yield
	#undef Yield
#endif


namespace MT
{
	class TaskHandle;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Fiber task status
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Task can be completed for several reasons.
	// For example task was done or someone call Yield from the Task body.
	namespace FiberTaskStatus
	{
		enum Type
		{
			UNKNOWN = 0,
			RUNNED = 1,
			FINISHED = 2,
			YIELDED = 3,
			AWAITING_CHILD = 4,
		};
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Fiber context
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Context passed to fiber main function
	class FiberContext
	{
	private:

		void RunSubtasksAndYieldImpl(ArrayView<internal::TaskBucket>& buckets);

	public:

		FiberContext();

		template<class TTask>
		void RunSubtasksAndYield(TaskGroup taskGroup, const TTask* taskArray, size_t taskCount);

		template<class TTask>
		void RunAsync(TaskGroup taskGroup, const TTask* taskArray, size_t taskCount);

		//
		void RunAsync(TaskGroup taskGroup, const TaskHandle* taskHandleArray, uint32 taskHandleCount);
		void RunSubtasksAndYield(TaskGroup taskGroup, const TaskHandle* taskHandleArray, uint32 taskHandleCount);

		//
		void Yield();

		void Reset();

		void SetThreadContext(internal::ThreadContext * _threadContext);
		internal::ThreadContext* GetThreadContext();

		void SetStatus(FiberTaskStatus::Type _taskStatus);
		FiberTaskStatus::Type GetStatus() const;

	private:

		// Active thread context (null if fiber context is not executing now)
		internal::ThreadContext * threadContext;

		// Active task status
		FiberTaskStatus::Type taskStatus;

	public:

		// Active task attached to this fiber
		internal::TaskDesc currentTask;

		// Active task group
		TaskGroup currentGroup;

		// Requirements for stack
		StackRequirements::Type stackRequirements;

		// Number of children fibers
		Atomic32<int32> childrenFibersCount;

		// Parent fiber
		FiberContext* parentFiber;

		// System fiber
		Fiber fiber;

		//Fiber index in pool
		uint32 fiberIndex;

		// Prevent false sharing between threads
		uint8 cacheline[64];
	};


}

```

`Scheduler/Include/MTFiberContext.inl`:

```inl
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

namespace MT
{

	template<class TTask>
	void FiberContext::RunSubtasksAndYield(TaskGroup taskGroup, const TTask* taskArray, size_t taskCount)
	{
		MT_ASSERT(taskCount < (internal::TASK_BUFFER_CAPACITY - 1), "Too many tasks per one Run.");
		MT_ASSERT(threadContext, "ThreadContext is nullptr");

		TaskScheduler& scheduler = *(threadContext->taskScheduler);

		ArrayView<internal::GroupedTask> buffer(threadContext->descBuffer, taskCount);

		size_t bucketCount = MT::Min((size_t)scheduler.GetWorkersCount(), taskCount);
		ArrayView<internal::TaskBucket> buckets(MT_ALLOCATE_ON_STACK(sizeof(internal::TaskBucket) * bucketCount), bucketCount);

		internal::DistibuteDescriptions(taskGroup, taskArray, buffer, buckets);
		RunSubtasksAndYieldImpl(buckets);
	}

	template<class TTask>
	void FiberContext::RunAsync(TaskGroup taskGroup, const TTask* taskArray, size_t taskCount)
	{
		MT_ASSERT(taskCount < (internal::TASK_BUFFER_CAPACITY - 1), "Too many tasks per one Run.");

		MT_ASSERT(threadContext, "ThreadContext is nullptr");
		MT_ASSERT(threadContext->taskScheduler->IsWorkerThread(), "Can't use RunAsync outside Task. Use TaskScheduler.RunAsync() instead.");

		TaskScheduler& scheduler = *(threadContext->taskScheduler);

		ArrayView<internal::GroupedTask> buffer(threadContext->descBuffer, taskCount);

		size_t bucketCount = MT::Min((size_t)scheduler.GetWorkersCount(), taskCount);
		ArrayView<internal::TaskBucket>	buckets(MT_ALLOCATE_ON_STACK(sizeof(internal::TaskBucket) * bucketCount), bucketCount);

		internal::DistibuteDescriptions(taskGroup, taskArray, buffer, buckets);
		scheduler.RunTasksImpl(buckets, nullptr, false);
	}




}

```

`Scheduler/Include/MTGroupedTask.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTTools.h>
#include <MTPlatform.h>
#include <MTTaskGroup.h>
#include <MTTaskDesc.h>

namespace MT
{
	class FiberContext;

	namespace internal
	{
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		struct GroupedTask
		{
			FiberContext* awaitingFiber;
			FiberContext* parentFiber;
			TaskGroup group;
			TaskDesc desc;

			GroupedTask()
				: awaitingFiber(nullptr)
				, parentFiber(nullptr)
			{}

			GroupedTask(const TaskDesc& _desc, TaskGroup _group)
				: awaitingFiber(nullptr)
				, parentFiber(nullptr)
				, group(_group)
				, desc(_desc)
			{}
		};
	}
}

```

`Scheduler/Include/MTPlatform.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once
#include <MTConfig.h>
#include <MTTypes.h>
#include <MTDebug.h>

typedef void (*TThreadEntryPoint)(void* userData);

#define MT_ARRAY_SIZE( arr ) ( sizeof( arr ) / sizeof( (arr)[0] ) )

namespace MT
{
	namespace EventReset
	{
		enum Type
		{
			AUTOMATIC = 0,
			MANUAL = 1,
		};
	}
}



#if MT_PLATFORM_WINDOWS 
	#include <Platform/Windows/MTCommon.h>
#elif MT_PLATFORM_POSIX || MT_PLATFORM_OSX
	#include <Platform/Posix/MTCommon.h>
#else
	#error Platfrom is not supported
#endif

#include <Platform/Common/MTAtomic.h>
#include <Platform/Common/MTSpinWait.h>

namespace MT
{
	//
	//
	//
	class ScopedGuard
	{
		MT::Mutex & mutex;

		ScopedGuard( const ScopedGuard & );
		void operator=( const ScopedGuard &);

	public:

		ScopedGuard(MT::Mutex & _mutex) : mutex(_mutex)
		{
			mutex.Lock();
		}

		~ScopedGuard()
		{
			mutex.Unlock();
		}
	};

	//
	// Simple Linear congruential generator
	//
	class LcgRandom
	{
		uint32 state;

	public:

		LcgRandom()
			: state(2578432553)
		{
		}

		void SetSeed(uint32 seed)
		{
			state = seed;
		}

		uint16 Get()
		{
			state = 214013 * state + 2531011;
			uint16 rnd = (state >> 16);
			return rnd;
		}


	};

}


#if MT_CPP11_SUPPORTED
#define mt_thread_local _Thread_local
#elif MT_GCC_COMPILER_FAMILY
#define mt_thread_local __thread
#elif MT_MSVC_COMPILER_FAMILY
#define mt_thread_local __declspec(thread)
#else
#error Can not define mt_thread_local. Unknown platform.
#endif



```

`Scheduler/Include/MTProfilerEventListener.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once


#ifdef MT_INSTRUMENTED_BUILD


namespace MT
{

	class IProfilerEventListener
	{

	public:

		IProfilerEventListener() {};
		virtual ~IProfilerEventListener() {};

		// Called from main scheduler thread when all fibers has created (notify about fibers count)
		virtual void OnFibersCreated(uint32 fibersCount) = 0;

		// Called from main scheduler thread when all threads has created (notify about threads count)
		virtual void OnThreadsCreated(uint32 threadsCount) = 0;

		// Called from worker thread context when worker thread created 
		virtual void OnThreadCreated(uint32 workerIndex) = 0;

		// Called from worker thread context when worker thread started
		virtual void OnThreadStarted(uint32 workerIndex) = 0;

		// Called from worker thread context when worker thread stopped
		virtual void OnThreadStoped(uint32 workerIndex) = 0;

		// Called from worker thread context when worker thread start to idle
		virtual void OnThreadIdleStarted(uint32 workerIndex) = 0;

		// Called from worker thread context when worker thread return to work from idle
		virtual void OnThreadIdleFinished(uint32 workerIndex) = 0;

		// Called from thread when thread is waiting for group
		virtual void OnThreadWaitStarted() = 0;

		// Called from thread when thread is finished waiting for group
		virtual void OnThreadWaitFinished() = 0;

		// Called from thread when waiting thread temporary convert to worker
		virtual void OnTemporaryWorkerThreadJoin() = 0;

		// Called from thread when temporary worker leave
		virtual void OnTemporaryWorkerThreadLeave() = 0;

		// Called from the worker thread that has change the task execution state
		virtual void OnTaskExecuteStateChanged(MT::Color::Type debugColor, const mt_char* debugID, TaskExecuteState::Type type, int32 fiberIndex) = 0;
	};

}


#endif

```

`Scheduler/Include/MTQueueMPMC.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTTools.h>
#include <utility>

namespace MT
{
	/// \class ConcurrentQueueLIFO
	/// \brief Lock-Free Multi-Producer Multi-Consumer Queue with fixed capacity.
	///
	/// based on Bounded MPMC queue article by Dmitry Vyukov
	/// http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue
	///
	template<typename T, uint32 CAPACITY>
	class LockFreeQueueMPMC
	{
		static const int32 ALIGNMENT = 16;
		static const int32 ALIGNMENT_MASK = (ALIGNMENT-1);
		static const uint32 MASK = (CAPACITY - 1);

		struct Cell
		{
			Atomic32<uint32> sequence;
			T data;
		};

		// Raw memory buffer
		byte rawMemory[ sizeof(Cell) * CAPACITY + ALIGNMENT ];

		// Prevent false sharing between threads
		uint8 cacheline0[64];

		Cell* const buffer;

		// Prevent false sharing between threads
		uint8 cacheline1[64];

		Atomic32<uint32> enqueuePos;

		// Prevent false sharing between threads
		uint8 cacheline2[64];

		Atomic32<uint32> dequeuePos;

		inline void MoveCtor(T* element, T && val)
		{
			new(element) T(std::move(val));
		}


	public:

		MT_NOCOPYABLE(LockFreeQueueMPMC);

		LockFreeQueueMPMC()
			: buffer( (Cell*)( ( (uintptr_t)&rawMemory[0] + ALIGNMENT_MASK ) & ~(uintptr_t)ALIGNMENT_MASK ) )
		{
			static_assert( MT::StaticIsPow2<CAPACITY>::result, "LockFreeQueueMPMC capacity must be power of 2");

			for (uint32 i = 0; i < CAPACITY; i++)
			{
				buffer[i].sequence.StoreRelaxed(i);
			}

			enqueuePos.StoreRelaxed(0);
			dequeuePos.StoreRelaxed(0);
		}

		bool TryPush(T && data)
		{
			Cell* cell = nullptr;

			uint32 pos = enqueuePos.LoadRelaxed();
			for(;;)
			{
				cell = &buffer[pos & MASK];

				uint32 seq = cell->sequence.Load();
				int32 dif = (int32)seq - (int32)pos;

				if (dif == 0)
				{
					uint32 nowPos = enqueuePos.CompareAndSwap(pos, pos + 1);
					if (nowPos == pos)
					{
						break;
					} else
					{
						pos = nowPos;
					}
				} else
				{
					if (dif < 0)
					{
						return false;
					} else
					{
						pos = enqueuePos.LoadRelaxed();
					}
				}
			}

			// successfully found a cell
			MoveCtor( &cell->data, std::move(data) );
			cell->sequence.Store(pos + 1);
			return true;
		}


		bool TryPop(T& data)
		{
			Cell* cell = nullptr;
			uint32 pos = dequeuePos.LoadRelaxed();

			for (;;)
			{
				cell = &buffer[pos & MASK];

				uint32 seq = cell->sequence.Load();
				int32 dif = (int32)seq - (int32)(pos + 1);

				if (dif == 0)
				{
					uint32 nowPos = dequeuePos.CompareAndSwap(pos, pos + 1);
					if (nowPos == pos)
					{
						break;
					} else
					{
						pos = nowPos;
					}
				} else
				{
					if (dif < 0)
					{
						return false;
					} else
					{
						pos = dequeuePos.LoadRelaxed();
					}
				}
			}

			// successfully found a cell
			MoveCtor( &data, std::move(cell->data) );
			cell->sequence.Store(pos + MASK + 1);
			return true;
		}

	};


}
```

`Scheduler/Include/MTScheduler.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTConfig.h>
#include <MTColorTable.h>
#include <MTTools.h>
#include <MTPlatform.h>
#include <MTQueueMPMC.h>
#include <MTArrayView.h>
#include <MTThreadContext.h>
#include <MTFiberContext.h>
#include <MTAppInterop.h>
#include <MTTaskPool.h>
#include <MTStackRequirements.h>
#include <Scopes/MTScopes.h>

/*
	You can inject some profiler code right into the task scope using this macro.
*/
#ifndef MT_SCHEDULER_PROFILER_TASK_SCOPE_CODE_INJECTION
#define MT_SCHEDULER_PROFILER_TASK_SCOPE_CODE_INJECTION( TYPE, DEBUG_COLOR, SRC_FILE, SRC_LINE)
#endif

namespace MT
{

	template<typename CLASS_TYPE, typename MACRO_TYPE>
	struct CheckType
	{
		static_assert(std::is_same<CLASS_TYPE, MACRO_TYPE>::value, "Invalid type in MT_DECLARE_TASK macro. See CheckType template instantiation params to details.");
	};

	struct TypeChecker
	{
		template <typename T>
		static T QueryThisType(T thisPtr)
		{
			MT_UNUSED(thisPtr);
			return (T)nullptr;
		}
	};


	template <typename T>
	inline void CallDtor(T* p)
	{
		MT_UNUSED(p);
		p->~T();
	}

}

#if MT_MSVC_COMPILER_FAMILY

// Visual Studio compile time check
#define MT_COMPILE_TIME_TYPE_CHECK(TYPE) \
	void CompileTimeCheckMethod() \
	{ \
		MT::CheckType< typename std::remove_pointer< decltype(MT::TypeChecker::QueryThisType(this)) >::type, typename TYPE > compileTypeTypesCheck; \
		compileTypeTypesCheck; \
	}

#elif MT_GCC_COMPILER_FAMILY

// GCC, Clang and other compilers compile time check
#define MT_COMPILE_TIME_TYPE_CHECK(TYPE) \
	void CompileTimeCheckMethod() \
	{ \
		/* query this pointer type */ \
		typedef decltype(MT::TypeChecker::QueryThisType(this)) THIS_PTR_TYPE; \
		/* query class type from this pointer type */ \
		typedef typename std::remove_pointer<THIS_PTR_TYPE>::type CPP_TYPE; \
		/* define macro type */ \
		typedef TYPE MACRO_TYPE; \
		/* compile time checking that is same types */ \
		MT::CheckType< CPP_TYPE, MACRO_TYPE > compileTypeTypesCheck; \
		/* remove unused variable warning */ \
		MT_UNUSED(compileTypeTypesCheck); \
	}

#else

#error Platform is not supported.

#endif


#define MT_DECLARE_TASK_IMPL(TYPE, STACK_REQUIREMENTS, TASK_PRIORITY, DEBUG_COLOR) \
	\
	MT_COMPILE_TIME_TYPE_CHECK(TYPE) \
	\
	static void TaskEntryPoint(MT::FiberContext& fiberContext, const void* userData) \
	{ \
		MT_SCHEDULER_PROFILER_TASK_SCOPE_CODE_INJECTION(TYPE, DEBUG_COLOR, __FILE__, __LINE__); \
		/* C style cast */ \
		TYPE * task = (TYPE *)(userData); \
		task->Do(fiberContext); \
	} \
	\
	static void PoolTaskDestroy(const void* userData) \
	{ \
		/* C style cast */ \
		TYPE * task = (TYPE *)(userData); \
		MT::CallDtor( task ); \
		/* Find task pool header */ \
		MT::PoolElementHeader * poolHeader = (MT::PoolElementHeader *)((char*)userData - sizeof(MT::PoolElementHeader)); \
		/* Fixup pool header, mark task as unused */ \
		poolHeader->id.Store(MT::TaskID::UNUSED); \
	} \
	\
	static MT::StackRequirements::Type GetStackRequirements() \
	{ \
		return STACK_REQUIREMENTS; \
	} \
	static MT::TaskPriority::Type GetTaskPriority() \
	{ \
		return TASK_PRIORITY; \
	} \



#ifdef MT_INSTRUMENTED_BUILD
#include <MTProfilerEventListener.h>

#define MT_DECLARE_TASK(TYPE, STACK_REQUIREMENTS, TASK_PRIORITY, DEBUG_COLOR) \
	static const mt_char* GetDebugID() \
	{ \
		return MT_TEXT( #TYPE ); \
	} \
	\
	static MT::Color::Type GetDebugColor() \
	{ \
		return DEBUG_COLOR; \
	} \
	\
	MT_DECLARE_TASK_IMPL(TYPE, STACK_REQUIREMENTS, TASK_PRIORITY, DEBUG_COLOR);

#else

#define MT_DECLARE_TASK(TYPE, STACK_REQUIREMENTS, TASK_PRIORITY, DEBUG_COLOR) \
	MT_DECLARE_TASK_IMPL(TYPE, STACK_REQUIREMENTS, TASK_PRIORITY, DEBUG_COLOR);

#endif




#if defined(MT_DEBUG) || defined(MT_INSTRUMENTED_BUILD)
#define MT_GROUP_DEBUG (1)
#endif



namespace MT
{
	const uint32 MT_MAX_THREAD_COUNT = 64;
	const uint32 MT_SCHEDULER_STACK_SIZE = 1048576; // 1Mb

	const uint32 MT_MAX_STANDART_FIBERS_COUNT = 256;
	const uint32 MT_STANDART_FIBER_STACK_SIZE = 32768; //32Kb

	const uint32 MT_MAX_EXTENDED_FIBERS_COUNT = 8;
	const uint32 MT_EXTENDED_FIBER_STACK_SIZE = 1048576; // 1Mb

	namespace internal
	{
		struct ThreadContext;
	}

	namespace TaskStealingMode
	{
		enum Type
		{
			DISABLED = 0,
			ENABLED = 1,
		};
	}

	struct WorkerThreadParams
	{
		uint32 core;
		ThreadPriority::Type priority;

		WorkerThreadParams()
			: core(MT_CPUCORE_ANY)
			, priority(ThreadPriority::DEFAULT)
		{
		}
	};

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Task scheduler
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class TaskScheduler
	{
		friend class FiberContext;
		friend struct internal::ThreadContext;



		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Task group description
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Application can assign task group to task and later wait until group was finished.
		class TaskGroupDescription
		{
			Atomic32<int32> inProgressTaskCount;

#if MT_GROUP_DEBUG
			bool debugIsFree;
#endif

		public:

			MT_NOCOPYABLE(TaskGroupDescription);

			TaskGroupDescription()
			{
				inProgressTaskCount.Store(0);
#if MT_GROUP_DEBUG
				debugIsFree = true;
#endif
			}

			int32 GetTaskCount() const
			{
				return inProgressTaskCount.Load();
			}

			int32 Dec()
			{
				return inProgressTaskCount.DecFetch();
			}

			int32 Inc()
			{
				return inProgressTaskCount.IncFetch();
			}

			int32 Add(int sum)
			{
				return inProgressTaskCount.AddFetch(sum);
			}

			Atomic32<int32>* GetWaitCounter()
			{
				return &inProgressTaskCount;
			}

#if MT_GROUP_DEBUG
			void SetDebugIsFree(bool _debugIsFree)
			{
				debugIsFree = _debugIsFree;
			}

			bool GetDebugIsFree() const
			{
				return debugIsFree;
			}
#endif
		};


		struct WaitContext
		{
			Atomic32<int32>* waitCounter;
			internal::ThreadContext* threadContext;
			uint32 waitTimeMs;
			uint32 exitCode;
		};


		// Thread index for new task
		Atomic32<int32> roundRobinThreadIndex;

		// Started threads count
		Atomic32<int32> startedThreadsCount;

		std::array<ThreadId, 4 > waitingThreads;
		Atomic32<int32> nextWaitingThreadSlotIndex;

		// Threads created by task manager
		Atomic32<int32> threadsCount;

		internal::ThreadContext threadContext[MT_MAX_THREAD_COUNT];

		// All groups task statistic
		TaskGroupDescription allGroups;

		// Groups pool
		LockFreeQueueMPMC<TaskGroup, TaskGroup::MT_MAX_GROUPS_COUNT * 2> availableGroups;

		//
		TaskGroupDescription groupStats[TaskGroup::MT_MAX_GROUPS_COUNT];

		// Fibers context
		FiberContext standartFiberContexts[MT_MAX_STANDART_FIBERS_COUNT];
		FiberContext extendedFiberContexts[MT_MAX_EXTENDED_FIBERS_COUNT];

		// Fibers pool
		LockFreeQueueMPMC<FiberContext*, MT_MAX_STANDART_FIBERS_COUNT * 2> standartFibersAvailable;
		LockFreeQueueMPMC<FiberContext*, MT_MAX_EXTENDED_FIBERS_COUNT * 2> extendedFibersAvailable;

#ifdef MT_INSTRUMENTED_BUILD
		IProfilerEventListener * profilerEventListener;
#endif

		bool taskStealingDisabled;

		FiberContext* RequestFiberContext(internal::GroupedTask& task);
		void ReleaseFiberContext(FiberContext*&& fiberExecutionContext);
		void RunTasksImpl(ArrayView<internal::TaskBucket>& buckets, FiberContext * parentFiber, bool restoredFromAwaitState);
		TaskGroupDescription & GetGroupDesc(TaskGroup group);

		static void WorkerThreadMain( void* userData );
		static void SchedulerFiberMain( void* userData );
		static void SchedulerFiberWait( void* userData );
		static bool SchedulerFiberStep( internal::ThreadContext& context, bool disableTaskStealing);
		static void SchedulerFiberProcessTask( internal::ThreadContext& context, internal::GroupedTask& task );
		static void FiberMain( void* userData );
		static bool TryStealTask(internal::ThreadContext& threadContext, internal::GroupedTask & task);

		static FiberContext* ExecuteTask (internal::ThreadContext& threadContext, FiberContext* fiberContext);

	public:

		/// \brief Initializes a new instance of the TaskScheduler class.
		/// \param workerThreadsCount Worker threads count. Automatically determines the required number of threads if workerThreadsCount set to 0
#ifdef MT_INSTRUMENTED_BUILD
		TaskScheduler(uint32 workerThreadsCount = 0, WorkerThreadParams* workerParameters = nullptr, IProfilerEventListener* listener = nullptr, TaskStealingMode::Type stealMode = TaskStealingMode::ENABLED);
#else
		TaskScheduler(uint32 workerThreadsCount = 0, WorkerThreadParams* workerParameters = nullptr, TaskStealingMode::Type stealMode = TaskStealingMode::ENABLED);
#endif


		~TaskScheduler();

		void JoinWorkerThreads();

		template<class TTask>
		void RunAsync(TaskGroup group, const TTask* taskArray, uint32 taskCount);

		void RunAsync(TaskGroup group, const TaskHandle* taskHandleArray, uint32 taskHandleCount);

		/// \brief Wait while no more tasks in specific group.
		/// \return true - if no more tasks in specific group. false - if timeout in milliseconds has reached and group still has some tasks.
		bool WaitGroup(TaskGroup group, uint32 milliseconds);

		bool WaitAll(uint32 milliseconds);

		TaskGroup CreateGroup();
		void ReleaseGroup(TaskGroup group);

		int32 GetWorkersCount() const;

		bool IsTaskStealingDisabled(uint32 minWorkersCount = 1) const;

		bool IsWorkerThread() const;

#ifdef MT_INSTRUMENTED_BUILD

		inline IProfilerEventListener* GetProfilerEventListener()
		{
			return profilerEventListener;
		}		

		void NotifyFibersCreated(uint32 fibersCount);
		void NotifyThreadsCreated(uint32 threadsCount);


#endif
	};
}

#include "MTScheduler.inl"
#include "MTFiberContext.inl"

```

`Scheduler/Include/MTScheduler.inl`:

```inl
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

namespace MT
{

	namespace internal
	{
		//generic template
		template<class T>
		inline internal::GroupedTask GetGroupedTask(TaskGroup group, const T * src)
		{
			internal::TaskDesc desc(T::TaskEntryPoint, src, T::GetStackRequirements(), T::GetTaskPriority() );
#ifdef MT_INSTRUMENTED_BUILD
			desc.debugID = T::GetDebugID();
			desc.debugColor = T::GetDebugColor();
#endif
			return internal::GroupedTask( desc, group );
		}

		//template specialization for FiberContext*
		template<>
		inline internal::GroupedTask GetGroupedTask(TaskGroup group, FiberContext* const * src)
		{
			MT_USED_IN_ASSERT(group);
			MT_ASSERT(group == TaskGroup::ASSIGN_FROM_CONTEXT, "Group must be assigned from context");
			FiberContext* fiberContext = *src;
			MT_ASSERT(fiberContext->currentTask.stackRequirements == fiberContext->stackRequirements, "Sanity check failed");
			internal::GroupedTask groupedTask( fiberContext->currentTask, fiberContext->currentGroup );
			groupedTask.awaitingFiber = fiberContext;
			return groupedTask;
		}

		//template specialization for TaskHandle
		template<>
		inline internal::GroupedTask GetGroupedTask(TaskGroup group, const MT::TaskHandle * src)
		{
			MT_ASSERT(src->IsValid(), "Invalid task handle!");
			const internal::TaskDesc & desc = src->GetDesc();
			return internal::GroupedTask( desc, group );
		}



		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Distributes task to threads:
		// | Task1 | Task2 | Task3 | Task4 | Task5 | Task6 |
		// ThreadCount = 4
		// Thread0: Task1, Task5
		// Thread1: Task2, Task6
		// Thread2: Task3
		// Thread3: Task4
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		template<class TTask>
		inline bool DistibuteDescriptions(TaskGroup group, TTask* taskArray, ArrayView<internal::GroupedTask>& descriptions, ArrayView<internal::TaskBucket>& buckets)
		{
			size_t index = 0;

			for (size_t bucketIndex = 0; (bucketIndex < buckets.Size()) && (index < descriptions.Size()); ++bucketIndex)
			{
				size_t bucketStartIndex = index;

				for (size_t i = bucketIndex; i < descriptions.Size(); i += buckets.Size())
				{
					descriptions[index] = GetGroupedTask(group, &taskArray[i]);
					index++;
				}

				buckets[bucketIndex] = internal::TaskBucket(&descriptions[bucketStartIndex], index - bucketStartIndex);
			}

			MT_ASSERT(index == descriptions.Size(), "Sanity check");
			return index > 0;
		}

	}





	template<class TTask>
	void TaskScheduler::RunAsync(TaskGroup group, const TTask* taskArray, uint32 taskCount)
	{
		MT_ASSERT(taskCount < (internal::TASK_BUFFER_CAPACITY - 1), "Too many tasks per one Run.");
		MT_ASSERT(!IsWorkerThread(), "Can't use RunAsync inside Task. Use FiberContext.RunAsync() instead.");

		uint32 bytesCountForGroupedTasks = sizeof(internal::GroupedTask) * taskCount;
		ArrayView<internal::GroupedTask> buffer( MT_ALLOCATE_ON_STACK( bytesCountForGroupedTasks ), taskCount );

		uint32 bucketCount = MT::Min((uint32)GetWorkersCount(), taskCount);
		uint32 bytesCountForTaskBuckets = sizeof(internal::TaskBucket) * bucketCount;
		ArrayView<internal::TaskBucket> buckets( MT_ALLOCATE_ON_STACK( bytesCountForTaskBuckets ), bucketCount );

		internal::DistibuteDescriptions(group, taskArray, buffer, buckets);
		RunTasksImpl(buckets, nullptr, false);
	}

}

```

`Scheduler/Include/MTStackRequirements.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once


namespace MT
{
	namespace StackRequirements
	{
		enum Type
		{
			INVALID,

			STANDARD,
			EXTENDED
		};
	}
}

```

`Scheduler/Include/MTStaticVector.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once


namespace MT
{

	/// \class Static vector
	/// \brief A variable-size array container with fixed capacity.
	template<class T, size_t CAPACITY>
	class StaticVector
	{
		static const int32 ALIGNMENT = 16;
		static const int32 ALIGNMENT_MASK = (ALIGNMENT-1);

		uint32 count;

		byte rawMemory_[sizeof(T) * CAPACITY + ALIGNMENT];

		inline T* IndexToObject(int32 index)
		{
			byte* alignedMemory = (byte*)( ( (uintptr_t)&rawMemory_[0] + ALIGNMENT_MASK ) & ~(uintptr_t)ALIGNMENT_MASK );
			T* pObjectMemory = (T*)(alignedMemory + index * sizeof(T));
			return pObjectMemory;
		}

		inline void CopyCtor(T* element, const T & val)
		{
			new(element) T(val);
		}

		inline void MoveCtor(T* element, T && val)
		{
			new(element) T(std::move(val));
		}

		inline void Dtor(T* element)
		{
			MT_UNUSED(element);
			element->~T();
		}

	public:

		MT_NOCOPYABLE(StaticVector);

		inline StaticVector()
			: count(0)
		{
		}

		inline StaticVector(uint32 _count, const T & defaultElement = T())
			: count(_count)
		{
			MT_ASSERT(count <= CAPACITY, "Too big size");
			for (uint32 i = 0; i < count; i++)
			{
				CopyCtor(Begin() + i, defaultElement);
			}
		}

		inline ~StaticVector()
		{
			for (uint32 i = 0; i < count; i++)
			{
				Dtor(Begin() + i);
			}
		}

		inline const T &operator[]( uint32 i ) const
		{
			MT_ASSERT( i < Size(), "bad index" );
			return *IndexToObject(i);
		}

		inline T &operator[]( uint32 i )
		{
			MT_ASSERT( i < Size(), "bad index" );
			return *IndexToObject(i);
		}

		inline void PushBack(T && val)
		{
			MT_ASSERT(count < CAPACITY, "Can't add element");
			uint32 lastElementIndex = count;
			count++;
			MoveCtor( IndexToObject(lastElementIndex), std::move(val) );
		}

		inline size_t Size() const
		{
			return count;
		}

		inline bool IsEmpty() const
		{
			return count == 0;
		}

		inline T* Begin()
		{
			return IndexToObject(0);
		}
	};



}


```

`Scheduler/Include/MTTaskBucket.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTTools.h>
#include <MTPlatform.h>
#include <MTArrayView.h>


namespace MT
{
	namespace internal
	{
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		struct TaskBucket
		{
			GroupedTask* tasks;
			size_t count;
			TaskBucket(GroupedTask* _tasks, size_t _count)
				: tasks(_tasks)
				, count(_count)
			{
			}
		};
	}
}

```

`Scheduler/Include/MTTaskDesc.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTTools.h>
#include <MTPlatform.h>
#include <MTArrayView.h>
#include <MTColorTable.h>
#include <MTStackRequirements.h>


namespace MT
{
	class FiberContext;
	typedef void (*TTaskEntryPoint)(FiberContext & context, const void* userData);
	typedef void (*TPoolTaskDestroy)(const void* userData);


	namespace internal
	{
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Task description
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		struct TaskDesc
		{
			//Task entry point
			TTaskEntryPoint taskFunc;

			//Task destroy func from pool (dtor call)
			TPoolTaskDestroy poolDestroyFunc;

			//Task user data (task data context)
			const void* userData;

			//Stack requirements for task
			MT::StackRequirements::Type stackRequirements;

			//Priority for task
			MT::TaskPriority::Type priority;

#ifdef MT_INSTRUMENTED_BUILD
			const mt_char* debugID;
			MT::Color::Type debugColor;
#endif

			TaskDesc()
				: taskFunc(nullptr)
				, poolDestroyFunc(nullptr)
				, userData(nullptr)
				, stackRequirements(MT::StackRequirements::INVALID)
				, priority(MT::TaskPriority::INVALID)
			{
#ifdef MT_INSTRUMENTED_BUILD
				debugID = nullptr;
				debugColor = MT::Color::Blue;
#endif
			}

			TaskDesc(TTaskEntryPoint _taskFunc, const void* _userData, MT::StackRequirements::Type _stackRequirements, MT::TaskPriority::Type _priority)
				: taskFunc(_taskFunc)
				, poolDestroyFunc(nullptr)
				, userData(_userData)
				, stackRequirements(_stackRequirements)
				, priority(_priority)
			{
#ifdef MT_INSTRUMENTED_BUILD
				debugID = nullptr;
				debugColor = MT::Color::Blue;
#endif
			}

			TaskDesc(TTaskEntryPoint _taskFunc, TPoolTaskDestroy _poolDestroyFunc, const void* _userData, MT::StackRequirements::Type _stackRequirements)
				: taskFunc(_taskFunc)
				, poolDestroyFunc(_poolDestroyFunc)
				, userData(_userData)
				, stackRequirements(_stackRequirements)
				, priority(MT::TaskPriority::INVALID)
			{
#ifdef MT_INSTRUMENTED_BUILD
				debugID = nullptr;
				debugColor = MT::Color::Blue;
#endif
			}

			bool IsValid()
			{
				return (taskFunc != nullptr);
			}
		};
	}

}

```

`Scheduler/Include/MTTaskGroup.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once


namespace MT
{
	//Task group ID
	class TaskGroup
	{
		int16 id;

	public:

		static const int16 MT_MAX_GROUPS_COUNT = 256;

		enum PredefinedValues
		{
			DEFAULT = 0,
			INVALID = -1,
			ASSIGN_FROM_CONTEXT = -2
		};


		TaskGroup()
		{
			id = INVALID;
		}

		explicit TaskGroup(PredefinedValues v)
		{
			id = (int16)v;
		}

		explicit TaskGroup(int16 _id)
		{
			id = _id;
		}

		static TaskGroup Default()
		{
			return TaskGroup(DEFAULT);
		}

		TaskGroup & operator= (const PredefinedValues & v)
		{
			id = (int16)v;
			return *this;
		}

		bool operator== (const PredefinedValues & v) const
		{
			return (id == v);
		}

		bool operator== (const TaskGroup & other) const
		{
			return (id == other.id);
		}

		bool operator!= (const TaskGroup & other) const
		{
			return (id != other.id);
		}

		int GetValidIndex() const
		{
			MT_ASSERT(IsValid(), "Try to get invalid index");

			return id;
		}

		bool IsValid() const
		{
			if (id == INVALID)
				return false;

			if (id == ASSIGN_FROM_CONTEXT)
				return false;

			return (id >= 0 && id < MT_MAX_GROUPS_COUNT);
		}



	};



}

```

`Scheduler/Include/MTTaskPool.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTConfig.h>


namespace MT
{

	namespace TaskID
	{
		//unused_id is any odd number, valid_id should be always only even numbers
		static const int UNUSED = 1;
	}


	//forward declaration
	class TaskHandle;


	/// \class PoolElementHeader
	/// \brief 
	//////////////////////////////////////////////////////////////////////////
	struct PoolElementHeader
	{
		//Task id (timestamp)
		Atomic32<int32> id;

		internal::TaskDesc desc;

	public:

		PoolElementHeader(int _id)
			: id(_id)
		{
		}

		static bool DestoryByHandle(const MT::TaskHandle & handle);
	};


	/// \class TaskPoolElement
	/// \brief 
	//////////////////////////////////////////////////////////////////////////
	template<typename T>
	class PoolElement : public PoolElementHeader
	{
	public:

		// Storage for task
		T task;

		PoolElement(int _id, T && _task)
			: PoolElementHeader(_id)
			, task( std::move(_task) )
		{

#if MT_CLANG_COMPILER_FAMILY
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
#endif
			static_assert( offsetof(PoolElement<T>, task) == sizeof(PoolElementHeader), "Invalid offset for task in PoolElement");
#if MT_CLANG_COMPILER_FAMILY
#pragma clang diagnostic pop
#endif
			
			desc.poolDestroyFunc = T::PoolTaskDestroy;
			desc.taskFunc = T::TaskEntryPoint;
			desc.stackRequirements = T::GetStackRequirements();
			desc.priority = T::GetTaskPriority();
			desc.userData = &task;

#ifdef MT_INSTRUMENTED_BUILD
			desc.debugID = T::GetDebugID();
			desc.debugColor = T::GetDebugColor();
#endif
		}

	};


	/// \class TaskHandle
	/// \brief 
	//////////////////////////////////////////////////////////////////////////
	class TaskHandle
	{
		int32 check_id;

	protected:

		friend struct PoolElementHeader;

		PoolElementHeader* task;

	public:

		//default ctor
		TaskHandle()
			: check_id(TaskID::UNUSED)
			, task(nullptr)
		{

		}

		//ctor
		TaskHandle(int _id, PoolElementHeader* _task)
			: check_id(_id)
			, task(_task)
		{
		}

		//copy ctor
		TaskHandle(const TaskHandle & other)
			: check_id(other.check_id)
			, task(other.task)
		{
		}

		//move ctor
		TaskHandle(TaskHandle && other)
			: check_id(other.check_id)
			, task(other.task)
		{
			other.check_id = TaskID::UNUSED;
			other.task = nullptr;
		}

		~TaskHandle()
		{
		}

		bool IsValid() const
		{
			if (task == nullptr)
			{
				return false;
			}

			if (check_id != task->id.Load())
			{
				return false;
			}

			return true;
		}


		// assignment operator
		TaskHandle & operator= (const TaskHandle & other)
		{
			check_id = other.check_id;
			task = other.task;

			return *this;
		}

		// move assignment operator
		TaskHandle & operator= (TaskHandle && other)
		{
			check_id = other.check_id;
			task = other.task;

			other.check_id = TaskID::UNUSED;
			other.task = nullptr;

			return *this;
		}

		const internal::TaskDesc & GetDesc() const
		{
			MT_ASSERT(IsValid(), "Task handle is invalid");
			return task->desc;
		}


	};




	//////////////////////////////////////////////////////////////////////////
	inline bool PoolElementHeader::DestoryByHandle(const MT::TaskHandle & handle)
	{
		if (!handle.IsValid())
		{
			return false;
		}

		if (handle.task->desc.poolDestroyFunc == nullptr)
		{
			return false;
		}

		if (handle.task->desc.userData == nullptr)
		{
			return false;
		}

		//call destroy func
		handle.task->desc.poolDestroyFunc(handle.task->desc.userData);
		return true;
	}

	



	/// \class TaskPool
	/// \brief 
	//////////////////////////////////////////////////////////////////////////
	template<typename T, size_t N>
	class TaskPool
	{
		static const int32 ALIGNMENT = 16;

		typedef PoolElement<T> PoolItem;

		//
		static const size_t MASK = (N - 1);

		void* data;
		Atomic32<int32> idGenerator;
		Atomic32<int32> index;

		inline PoolItem* Buffer()
		{
			return (PoolItem*)(data);
		}

		inline void MoveCtor(PoolItem* element, int id, T && val)
		{
			new(element) PoolItem(id, std::move(val));
		}

	public:

		MT_NOCOPYABLE(TaskPool);

		TaskPool()
			: idGenerator(0)
			, index(0)
		{
			static_assert( MT::StaticIsPow2<N>::result, "Task pool capacity must be power of 2");

			size_t bytesCount = sizeof(PoolItem) * N;
			data = Memory::Alloc(bytesCount, ALIGNMENT);

			for(size_t idx = 0; idx < N; idx++)
			{
				PoolItem* pElement = Buffer() + idx;
				pElement->id.Store(TaskID::UNUSED);
			}
		}

		~TaskPool()
		{
			if (data != nullptr)
			{

				for(size_t idx = 0; idx < N; idx++)
				{
					PoolItem* pElement = Buffer() + idx;

					int preValue = pElement->id.Exchange(TaskID::UNUSED);
					if (preValue != TaskID::UNUSED)
					{
						pElement->task.~T();
					}
				}

				Memory::Free(data);
				data = nullptr;
			}
		}

		TaskHandle TryAlloc(T && task)
		{
			int idx = index.IncFetch() - 1;

			int clampedIdx = (idx & MASK);

			PoolItem* pElement = Buffer() + clampedIdx;

			bool isUnused = ((pElement->id.Load() & 1 ) != 0);

			if (isUnused == false)
			{
				//Can't allocate more, next element in circular buffer is already used
				return TaskHandle();
			}

			//generate next even number for id
			int id = idGenerator.AddFetch(2);
			MoveCtor( pElement, id, std::move(task) );
			return TaskHandle(id, pElement);
		}


		TaskHandle Alloc(T && task)
		{
			TaskHandle res = TryAlloc(std::move(task));
			MT_ASSERT(res.IsValid(), "Pool allocation failed");
			return res;
		}

	};

}

```

`Scheduler/Include/MTTaskQueue.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <vector>

#include <MTPlatform.h>
#include <MTTools.h>
#include <MTAppInterop.h>


namespace MT
{
	namespace TaskPriority
	{
		enum Type
		{
			HIGH = 0,
			NORMAL = 1,
			LOW = 2,

			COUNT,

			INVALID
		};
	}

	namespace DummyQueueFlag
	{
		enum Type
		{
			IS_DUMMY_QUEUE = 1
		};
	}


	/// \class TaskQueue
	/// \brief thread safe task queue
	///
	template<typename T, uint32 CAPACITY>
	class TaskQueue
	{
		//////////////////////////////////////////////////////////////////////////
		class Queue
		{
			static const int32 ALIGNMENT = 16;
			static const unsigned int MASK = CAPACITY - 1u;

			void* data;
			size_t begin;
			size_t end;

			inline T* Buffer()
			{
				return (T*)(data);
			}

			inline void CopyCtor(T* element, const T & val)
			{
				new(element) T(val);
			}

			inline void MoveCtor(T* element, T && val)
			{
				new(element) T(std::move(val));
			}

			inline void Dtor(T* element)
			{
				MT_UNUSED(element);
				element->~T();
			}

			inline size_t Size() const
			{
				if (IsEmpty())
				{
					return 0;
				}

				size_t count = ((end & MASK) - (begin & MASK)) & MASK;
				return count;
			}

			inline void Clear()
			{
				size_t queueSize = Size();
				for (size_t i = 0; i < queueSize; i++)
				{
					T* pElement = Buffer() + ((begin + i) & MASK);
					Dtor(pElement);
				}

				begin = 0;
				end = 0;
			}

		public:

			Queue()
				: data(nullptr)
				, begin(0)
				, end(0)
			{
			}

			// Queue is just dummy until you call the Create
			void Create()
			{
				size_t bytesCount = sizeof(T) * CAPACITY;
				data = Memory::Alloc(bytesCount, ALIGNMENT);
			}


			~Queue()
			{
				if (data != nullptr)
				{
					Memory::Free(data);
					data = nullptr;
				}
			}

			inline bool HasSpace(size_t itemCount)
			{
				if ((Size() + itemCount) >= CAPACITY)
				{
					return false;
				}

				return true;
			}

			inline bool Add(const T& item)
			{
				MT_VERIFY(data, "Can't add items to dummy queue", return false; );

				if ((Size() + 1) >= CAPACITY)
				{
					return false;
				}

				size_t index = (end & MASK);
				T* pElement = Buffer() + index;
				CopyCtor( pElement, item );
				end++;

				return true;
			}


			inline bool TryPopOldest(T & item)
			{
				if (IsEmpty())
				{
					return false;
				}

				MT_VERIFY(data, "Can't pop items from dummy queue", return false; );

				size_t index = (begin & MASK);
				T* pElement = Buffer() + index;
				begin++;
				item = *pElement;
				Dtor(pElement);
				return true;
			}

			inline bool TryPopNewest(T & item)
			{
				if (IsEmpty())
				{
					return false;
				}

				MT_VERIFY(data, "Can't pop items from dummy queue", return false; );

				end--;
				size_t index = (end & MASK);
				T* pElement = Buffer() + index;
				item = *pElement;
				Dtor(pElement);
				return true;
			}

			inline bool IsEmpty() const
			{
				return (begin == end);
			}
		};
		//////////////////////////////////////////////////////////////////////////

		MT::Mutex mutex;
		Queue queues[TaskPriority::COUNT];

	public:

		MT_NOCOPYABLE(TaskQueue);

		TaskQueue()
		{
			for(uint32 i = 0; i < MT_ARRAY_SIZE(queues); i++)
			{
				queues[i].Create();
			}
		}

		TaskQueue(DummyQueueFlag::Type)
		{
			// Create dummy queue.
		}

		~TaskQueue()
		{
		}

		bool Add(const T* itemArray, size_t count)
		{
			MT::ScopedGuard guard(mutex);

			// Check for space for all queues.
			// At the moment it is not known exactly in what queue items will be added.
			for(size_t i = 0; i < MT_ARRAY_SIZE(queues); i++)
			{
				Queue& queue = queues[i];
				if (!queue.HasSpace(count))
				{
					return false;
				}
			}

			// Adding the tasks into the appropriate queue
			for(size_t i = 0; i < count; i++)
			{
				const T& item = itemArray[i];

				uint32 queueIndex = (uint32)item.desc.priority;
				MT_ASSERT(queueIndex < MT_ARRAY_SIZE(queues), "Invalid task priority");

				Queue& queue = queues[queueIndex];
				bool res = queue.Add(itemArray[i]);
				MT_USED_IN_ASSERT(res);
				MT_ASSERT(res == true, "Sanity check failed");
			}

			return true;
		}


		bool TryPopOldest(T & item)
		{
			MT::ScopedGuard guard(mutex);
			for(uint32 queueIndex = 0; queueIndex < TaskPriority::COUNT; queueIndex++)
			{
				Queue& queue = queues[queueIndex];
				if (queue.TryPopOldest(item))
				{
					return true;
				}
			}
			return false;
		}

		bool TryPopNewest(T & item)
		{
			MT::ScopedGuard guard(mutex);
			for(uint32 queueIndex = 0; queueIndex < TaskPriority::COUNT; queueIndex++)
			{
				Queue& queue = queues[queueIndex];
				if (queue.TryPopNewest(item))
				{
					return true;
				}
			}
			return false;
		}


	};
}

```

`Scheduler/Include/MTThreadContext.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTTools.h>
#include <MTPlatform.h>
#include <MTTaskQueue.h>
#include <MTConcurrentRingBuffer.h>
#include <MTGroupedTask.h>


#ifdef MT_INSTRUMENTED_BUILD

#define MT_SYSTEM_TASK_COLOR (MT::Color::Yellow)
#define MT_SYSTEM_TASK_NAME "SchedulerTask"
#define MT_SYSTEM_TASK_FIBER_NAME "IdleFiber"
#define MT_SYSTEM_FIBER_INDEX (int32)(-1)

#endif


namespace MT
{
	class FiberContext;
	class TaskScheduler;


#ifdef MT_INSTRUMENTED_BUILD
	namespace TaskExecuteState
	{
		enum Type
		{
			START = 0,
			STOP = 1,
			RESUME = 2,
			SUSPEND = 3,
		};
	}

#endif

	namespace internal
	{
		static const size_t TASK_BUFFER_CAPACITY = 4096;


		namespace ThreadState
		{
			const uint32 ALIVE = 0;
			const uint32 EXIT = 1;
		};

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Thread (Scheduler fiber) context
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		struct ThreadContext
		{
			FiberContext* lastActiveFiberContext;

			// pointer to task manager
			TaskScheduler* taskScheduler;

			// thread
			Thread thread;

			// thread Id
			ThreadId threadId;

			// scheduler fiber
			Fiber schedulerFiber;

			// task queue awaiting execution
			TaskQueue<internal::GroupedTask, TASK_BUFFER_CAPACITY> queue;

			// new task has arrived to queue event
			Event hasNewTasksEvent;

			// thread is alive or not
			Atomic32<int32> state;

			// Temporary buffer, fixed size = TASK_BUFFER_CAPACITY
			void* descBuffer;

			// Thread index
			uint32 workerIndex;

			// Thread random number generator
			LcgRandom random;

			bool isExternalDescBuffer;

			// prevent false cache sharing between threads
			uint8 cacheline[64];

			ThreadContext();
			ThreadContext(void* externalDescBuffer);
			~ThreadContext();

			void SetThreadIndex(uint32 threadIndex);

#ifdef MT_INSTRUMENTED_BUILD
			
			void NotifyThreadCreated(uint32 threadIndex);
			void NotifyThreadStarted(uint32 threadIndex);
			void NotifyThreadStoped(uint32 threadIndex);

			void NotifyTaskExecuteStateChanged(MT::Color::Type debugColor, const mt_char* debugID, TaskExecuteState::Type type, int32 fiberIndex);

			void NotifyThreadIdleStarted(uint32 threadIndex);
			void NotifyThreadIdleFinished(uint32 threadIndex);

			void NotifyWaitStarted();
			void NotifyWaitFinished();

			void NotifyTemporaryWorkerThreadJoin();
			void NotifyTemporaryWorkerThreadLeave();

#endif

			static size_t GetMemoryRequrementInBytesForDescBuffer();
		};

	}

}

```

`Scheduler/Include/MTTools.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once
#include <MTTypes.h>
#include <MTPlatform.h>

namespace MT
{
	template<class T>
	T Min(T a, T b)
	{
		return a < b ? a : b;
	}

	template<class T>
	T Max(T a, T b)
	{
		return a < b ? b : a;
	}

	template<class T>
	T Clamp(T val, T min, T max)
	{
		return Min(max, Max(min, val));
	}


	//////////////////////////////////////////////////////////////////////////
	class Timer
	{
		uint64 startMicroSeconds;
	public:
		Timer() : startMicroSeconds(MT::GetTimeMicroSeconds())
		{
		}

		uint32 GetPastMicroSeconds() const
		{
			return (uint32)(MT::GetTimeMicroSeconds() - startMicroSeconds);
		}

		uint32 GetPastMilliSeconds() const
		{
			return (uint32)((MT::GetTimeMicroSeconds() - startMicroSeconds) / 1000);
		}
	};



	//Compile time pow2 check
	//////////////////////////////////////////////////////////////////////////
	template< size_t N, size_t C = 1 >
	struct IsPow2Recurse
	{
		enum
		{
			result = IsPow2Recurse< N / 2, C * 2 >::result
		};
	};

	template< size_t C >
	struct IsPow2Recurse< 0, C >
	{
		enum
		{
			result = C
		};
	};


	template< size_t N >
	struct StaticIsPow2
	{
		enum
		{
			result = IsPow2Recurse< N - 1 >::result == N ? 1 : 0
		};
	};
	


}


```

`Scheduler/Include/MTTypes.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTConfig.h>
#include <stdint.h>

#define MT_USED_IN_ASSERT(x) (void)(x)

#define MT_UNUSED(x) (void)(x)

#define MT_NOCOPYABLE(TYPE) \
	private: \
		TYPE (const TYPE &); \
		void operator= (const TYPE &); \
	public: \



#ifdef MT_UNICODE

typedef wchar_t mt_char;
#define MT_TEXT(quote) L##quote

#else

typedef char mt_char;
#define MT_TEXT(quote) quote

#endif


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef signed char int8;
typedef unsigned char uint8;
typedef unsigned char byte;
typedef int16_t int16;
typedef uint16_t uint16;
typedef int32_t int32;
typedef uint32_t uint32;


#if MT_MSVC_COMPILER_FAMILY

typedef __int64 int64;
typedef unsigned __int64 uint64;

#elif MT_GCC_COMPILER_FAMILY

typedef int64_t int64;
typedef uint64_t uint64;

#else

#error Compiler is not supported

#endif



static_assert( sizeof(int8) == 1, "Invalid type size, int8" );
static_assert( sizeof(uint8) == 1, "Invalid type size, uint8" );
static_assert( sizeof(byte) == 1, "Invalid type size, byte" );
static_assert( sizeof(int16) == 2, "Invalid type size, int16" );
static_assert( sizeof(uint16) == 2, "Invalid type size, uint16" );
static_assert( sizeof(int32) == 4, "Invalid type size, int32" );
static_assert( sizeof(uint32) == 4, "Invalid type size, uint32" );
static_assert( sizeof(int64) == 8, "Invalid type size, int64" );
static_assert( sizeof(uint64) == 8, "Invalid type size, uint64" );

```

`Scheduler/Include/Platform/Common/MTAtomic.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#include <MTConfig.h>

#if MT_MSVC_COMPILER_FAMILY 
#include <Platform/Windows/MTAtomic.h>
#elif MT_PLATFORM_POSIX || MT_PLATFORM_OSX
#include <Platform/Posix/MTAtomic.h>
#else
#endif



namespace MT
{
	inline bool IsPointerAligned( const volatile void* p, const uint32 align )
	{
		return !((uintptr_t)p & (align - 1));
	}


	//
	// Atomic int (type with constructor)
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	class Atomic32 : public Atomic32Base<T>
	{

	public:

		Atomic32()
		{
			static_assert(sizeof(Atomic32<T>) == sizeof(T), "Invalid atomic type size");
			MT_ASSERT(IsPointerAligned(this, __alignof(T)), "Invalid atomic alignment");

			Atomic32Base<T>::Store(0);
		}

		explicit Atomic32(T v)
		{
			static_assert(sizeof(Atomic32<T>) == sizeof(T), "Invalid atomic type size");
			MT_ASSERT(IsPointerAligned(this, __alignof(T)), "Invalid atomic alignment");

			Atomic32Base<T>::Store(v);
		}
	};


	//
	// Atomic pointer (type with constructor)
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	class AtomicPtr : public AtomicPtrBase<T>
	{
	public:
		AtomicPtr()			
		{
			static_assert(sizeof(AtomicPtr<T>) == sizeof(T*), "Invalid atomic type size");
			MT_ASSERT(IsPointerAligned(this, sizeof(T*)), "Invalid atomic ptr alignment");

			AtomicPtrBase<T>::Store(nullptr);
		}

		explicit AtomicPtr(T* v)
		{
			static_assert(sizeof(AtomicPtr<T>) == sizeof(T*), "Invalid atomic type size");
			MT_ASSERT(IsPointerAligned(this, sizeof(T*)), "Invalid atomic ptr alignment");

			AtomicPtrBase<T>::Store(v);
		}

	};
}
```

`Scheduler/Include/Platform/Common/MTSpinWait.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once


namespace MT
{

	// Hybrid spin wait
	//
	// http://www.1024cores.net/home/lock-free-algorithms/tricks/spinning
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class SpinWait
	{
		int32 iteration;

	public:

		static const int32 YIELD_CPU_THRESHOLD = 10;
		static const int32 YIELD_CPU_THRESHOLD2 = 20;
		static const int32 YIELD_THREAD_THRESHOLD = 40;
		static const int32 YIELD_SLEEP0_THRESHOLD = 200;


		SpinWait()
			: iteration(0)
		{
		}

		void Reset()
		{
			iteration = 0;
		}

		bool IsActive() const
		{
			return (iteration != 0);
		}

		int32 SpinOnce()
		{
			if (iteration <= YIELD_CPU_THRESHOLD)
			{
				MT::YieldProcessor();
			} else
			{
				if (iteration <= YIELD_CPU_THRESHOLD2)
				{
					for (int32 i = 0; i < 50; i++)
					{
						MT::YieldProcessor();
					}
				} else
				{
					if (iteration <= YIELD_THREAD_THRESHOLD)
					{
						MT::YieldThread();
					} else
					{
						if (iteration <= YIELD_SLEEP0_THRESHOLD)
						{
							MT::Thread::Sleep(0);
						} else
						{
							MT::Thread::Sleep(1);
						}
					}
				}
			}

			int32 retValue = iteration;
			if (iteration < INT_MAX)
			{
				iteration++;
			}
			return retValue;
		}
	};


	/*

	Brute force spin wait.  For testing purposes only!
	
	*/
	inline void SpinSleepMicroSeconds(uint32 microseconds)
	{
		int64 desiredTime = GetTimeMicroSeconds() + microseconds;
		for(;;)
		{
			int64 timeNow = GetTimeMicroSeconds();
			if (timeNow > desiredTime)
			{
				break;
			}
			YieldProcessor();
		}
	}

	/*

	Brute force spin wait. For testing purposes only!
	
	*/
	inline void SpinSleepMilliSeconds(uint32 milliseconds)
	{
		SpinSleepMicroSeconds(milliseconds * 1000);
	}

}

```

`Scheduler/Include/Platform/Common/MTThread.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#define MT_CPUCORE_ANY (0xffffffff)

#include <Platform/Common/MTAtomic.h>

namespace MT
{
	namespace ThreadPriority
	{
		enum Type
		{
			HIGH = 0,
			DEFAULT = 1,
			LOW = 2
		};
	}


	class ThreadBase
	{
	protected:
		void * funcData;
		TThreadEntryPoint func;
	public:

		MT_NOCOPYABLE(ThreadBase);

		ThreadBase()
			: funcData(nullptr)
			, func(nullptr)
		{
		}

	};
}



```

`Scheduler/Include/Platform/Posix/MTAtomic.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_ATOMIC__
#define __MT_ATOMIC__

#include <MTConfig.h>

#include <type_traits>

#if MT_SSE_INTRINSICS_SUPPORTED
#include <xmmintrin.h>
#else
#include <unistd.h>
#endif



#define MT_ATOMIC_COMPILE_TIME_CHECK \
	static_assert(std::is_pod< Atomic32Base<T> >::value == true, "Atomic32Base must be a POD (plain old data type)"); \
	static_assert(sizeof(T) == sizeof(int32), "Atomic32Base, type T must be equal size as int32"); \

#define MT_ATOMICPTR_COMPILE_TIME_CHECK \
	static_assert(std::is_pod< AtomicPtrBase<T> >::value == true, "AtomicPtrBase must be a POD (plain old data type)");


namespace MT
{
	//
	// Full memory barrier
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline void HardwareFullMemoryBarrier()
	{
		__sync_synchronize();
	}

	//
	// Signals to the processor to give resources to threads that are waiting for them.
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline void YieldProcessor()
	{
#if MT_SSE_INTRINSICS_SUPPORTED
		_mm_pause();
#else
		usleep(0);
#endif
	}


	//
	// Atomic int (pod type)
	// The operation is ordered in a sequentially consistent manner except for functions marked as relaxed.
	//
	// Note: You must use this type when you need to declare static variable instead of Atomic32
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	struct Atomic32Base
	{
		T _value;

		// The function returns the resulting added value.
		T AddFetch(T sum)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = __sync_add_and_fetch(&_value, sum);
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the resulting incremented value.
		T IncFetch()
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = __sync_add_and_fetch(&_value, 1);
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the resulting decremented value.
		T DecFetch()
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = __sync_sub_and_fetch(&_value, 1);
			mt_acquire_fence();
			return tmp;
		}

		T Load() const
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			T tmp = LoadRelaxed();
			mt_acquire_fence();
			return tmp;
		}

		void Store(T val)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			StoreRelaxed(val);
		}

		// The function returns the initial value.
		T Exchange(T val)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = __sync_lock_test_and_set(&_value, val);
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the initial value.
		T CompareAndSwap(T compareValue, T newValue)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = __sync_val_compare_and_swap(&_value, compareValue, newValue);
			mt_acquire_fence();
			return tmp;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		T LoadRelaxed() const
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			return _value;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		void StoreRelaxed(T val)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			_value = val;
		}

	};





	//
	// Atomic pointer (pod type)
	//
	// You must use this type when you need to declare static variable instead of AtomicPtr
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	struct AtomicPtrBase
	{
		T* _value;
	
		T* Load() const
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			T* tmp = LoadRelaxed();
			mt_acquire_fence();
			return tmp;
		}

		void Store(const T* val)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			mt_release_fence();
			StoreRelaxed(val);
		}

		// The function returns the initial value.
		T* Exchange(const T* val)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			mt_release_fence();
			T* tmp = (T*)__sync_lock_test_and_set((void**)&_value, (void*)val);
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the initial value.
		T* CompareAndSwap(const T* compareValue, const T* newValue)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			mt_release_fence();
			T* tmp = (T*)__sync_val_compare_and_swap((void**)&_value, (void*)compareValue, (void*)newValue);
			mt_acquire_fence();
			return tmp;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		T* LoadRelaxed() const
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			return _value;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		void StoreRelaxed(const T* val)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			_value = (T*)val;
		}

	};



}


#undef MT_ATOMIC_COMPILE_TIME_CHECK


#endif

```

`Scheduler/Include/Platform/Posix/MTCommon.h`:

```h
#pragma once

#ifndef __MT_COMMON__
#define __MT_COMMON__

#include "MTUtils.h"
#include "MTThread.h"
#include "MTMutex.h"
#include "MTAtomic.h"
#include "MTEvent.h"
#include "MTFiber.h"
#include "MTMemory.h"


#endif

```

`Scheduler/Include/Platform/Posix/MTEvent.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_EVENT__
#define __MT_EVENT__

#include <sys/time.h>
#include <sched.h>
#include <errno.h>


namespace MT
{
	//
	//
	//
	class Event
	{
		static const int NOT_SIGNALED = 0;
		static const int SIGNALED = 1;


		pthread_mutex_t	mutex;
		pthread_cond_t	condition;

		EventReset::Type resetType;

		volatile uint32 numOfWaitingThreads;
		volatile int32 value;
		volatile bool isInitialized;

	private:

		void AutoResetIfNeed()
		{
			if (resetType == EventReset::MANUAL)
			{
				return;
			}
			value = NOT_SIGNALED;
		}

	public:

		MT_NOCOPYABLE(Event);


		Event()
			: numOfWaitingThreads(0)
			, isInitialized(false)
		{
		}

		Event(EventReset::Type resetType, bool initialState)
			: numOfWaitingThreads(0)
			, isInitialized(false)
		{
			Create(resetType, initialState);
		}

		~Event()
		{
			if (isInitialized)
			{
				int res = pthread_cond_destroy( &condition );
				MT_USED_IN_ASSERT(res);
				MT_ASSERT(res == 0, "pthread_cond_destroy - failed");

				res = pthread_mutex_destroy( &mutex );
				MT_USED_IN_ASSERT(res);
				MT_ASSERT(res == 0, "pthread_mutex_destroy - failed");
			}
		}

		void Create(EventReset::Type _resetType, bool initialState)
		{
			MT_ASSERT (!isInitialized, "Event already initialized");

			resetType = _resetType;

			int res = pthread_mutex_init( &mutex, nullptr );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_init - failed");

			res = pthread_cond_init( &condition, nullptr );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_cond_init - failed");

			value = initialState ? SIGNALED : NOT_SIGNALED;
			isInitialized = true;
			numOfWaitingThreads = 0;
		}

		void Signal()
		{
			MT_ASSERT (isInitialized, "Event not initialized");

			int res = pthread_mutex_lock( &mutex );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_lock - failed");

			value = SIGNALED;
			if (numOfWaitingThreads > 0)
			{
				if (resetType == EventReset::MANUAL)
				{
					res = pthread_cond_broadcast( &condition );
					MT_USED_IN_ASSERT(res);
					MT_ASSERT(res == 0, "pthread_cond_broadcast - failed");
				} else
				{
					res = pthread_cond_signal( &condition );
					MT_USED_IN_ASSERT(res);
					MT_ASSERT(res == 0, "pthread_cond_signal - failed");
				}
			}

			res = pthread_mutex_unlock( &mutex );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_unlock - failed");
		}

		void Reset()
		{
			MT_ASSERT (isInitialized, "Event not initialized");
			MT_ASSERT(resetType == EventReset::MANUAL, "Can't reset, auto reset event");

			int res = pthread_mutex_lock( &mutex );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_lock - failed");

			value = NOT_SIGNALED;

			res = pthread_mutex_unlock( &mutex );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_unlock - failed");

		}

		bool Wait(uint32 milliseconds)
		{
			MT_ASSERT (isInitialized, "Event not initialized");

			int res = pthread_mutex_lock( &mutex );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_lock - failed");

			// early exit if event already signaled
			if ( value != NOT_SIGNALED )
			{
				AutoResetIfNeed();
				res = pthread_mutex_unlock( &mutex );
				MT_USED_IN_ASSERT(res);
				MT_ASSERT(res == 0, "pthread_mutex_unlock - failed");
				return true;
			}

			numOfWaitingThreads++;

			//convert milliseconds to global posix time
			struct timespec ts;

			struct timeval tv;
			gettimeofday(&tv, NULL);

			uint64_t nanoseconds = ((uint64_t) tv.tv_sec) * 1000 * 1000 * 1000 + (uint64_t)milliseconds * 1000 * 1000 + ((uint64_t) tv.tv_usec) * 1000;

			ts.tv_sec = (time_t)(nanoseconds / 1000 / 1000 / 1000);
			ts.tv_nsec = (long)(nanoseconds - ((uint64_t) ts.tv_sec) * 1000 * 1000 * 1000);

			int ret = 0;
			while(true)
			{
				ret = pthread_cond_timedwait( &condition, &mutex, &ts );
				MT_ASSERT(ret == 0 || ret == ETIMEDOUT || ret == EINTR, "Unexpected return value");

				/*
				
				http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_cond_timedwait.html

				It is important to note that when pthread_cond_wait() and pthread_cond_timedwait() return without error, the associated predicate may still be false.
				Similarly, when pthread_cond_timedwait() returns with the timeout error, the associated predicate may be true due to an unavoidable race between
				the expiration of the timeout and the predicate state change.
				
				*/
				if (value == SIGNALED || ret == ETIMEDOUT)
				{
					break;
				}
			}

			numOfWaitingThreads--;
			bool isSignaled = (value == SIGNALED);
			
			if (isSignaled)
			{
				AutoResetIfNeed();
			}

			res = pthread_mutex_unlock( &mutex );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_unlock - failed");

			return isSignaled;
		}

	};

}


#endif

```

`Scheduler/Include/Platform/Posix/MTFiber.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_FIBER__
#define __MT_FIBER__

//#define MT_USE_BOOST_CONTEXT (1)



#if MT_USE_BOOST_CONTEXT

#include <fcontext.h>

//TODO

#else


#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE
#endif

#include <ucontext.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/mman.h>

#ifndef MAP_ANONYMOUS
    #define MAP_ANONYMOUS MAP_ANON
#endif

#ifndef MAP_STACK
    #define MAP_STACK (0)
#endif

#include <MTAppInterop.h>
#include "MTAtomic.h"

#endif


namespace MT
{

	//
	//
	//
	class Fiber
	{
		void* funcData;
		TThreadEntryPoint func;

		Memory::StackDesc stackDesc;

		ucontext_t fiberContext;
		bool isInitialized;
        
		static void FiberFuncInternal(void* pFiber)
		{
			MT_ASSERT(pFiber != nullptr, "Invalid fiber");
			Fiber* self = (Fiber*)pFiber;

			MT_ASSERT(self->isInitialized == true, "Using non initialized fiber");

			MT_ASSERT(self->func != nullptr, "Invalid fiber func");
			self->func(self->funcData);
		}
        
		void CleanUp()
		{
			if (isInitialized)
			{
				// if func != null than we have stack memory ownership
				if (func != nullptr)
				{
					Memory::FreeStack(stackDesc);
				}

				isInitialized = false;
			}
		}

	public:

		MT_NOCOPYABLE(Fiber);

		Fiber()
			: funcData(nullptr)
			, func(nullptr)
			, isInitialized(false)
		{
			memset(&fiberContext, 0, sizeof(ucontext_t));
		}

		~Fiber()
		{
			CleanUp();
		}


		void CreateFromCurrentThreadAndRun(TThreadEntryPoint entryPoint, void *userData)
		{
			MT_ASSERT(!isInitialized, "Already initialized");
            
            func = nullptr;
            funcData = nullptr;
            
			// get execution context
			int res = getcontext(&fiberContext);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "getcontext - failed");
            
            isInitialized = true;
            
            entryPoint(userData);
            

			CleanUp();
		}


		void Create(size_t stackSize, TThreadEntryPoint entryPoint, void *userData)
		{
			MT_ASSERT(!isInitialized, "Already initialized");
			MT_ASSERT(stackSize >= PTHREAD_STACK_MIN, "Stack to small");

			func = entryPoint;
			funcData = userData;

			int res = getcontext(&fiberContext);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "getcontext - failed");

			stackDesc = Memory::AllocStack(stackSize);

			fiberContext.uc_link = nullptr;
			fiberContext.uc_stack.ss_sp = stackDesc.stackBottom;
			fiberContext.uc_stack.ss_size = stackDesc.GetStackSize();
			fiberContext.uc_stack.ss_flags = 0;

			makecontext(&fiberContext, (void(*)())&FiberFuncInternal, 1, (void *)this);

			isInitialized = true;
		}

#ifdef MT_INSTRUMENTED_BUILD
		void SetName(const char* fiberName)
		{
			MT_UNUSED(fiberName);
		}
#endif

		static void SwitchTo(Fiber & from, Fiber & to)
		{
			HardwareFullMemoryBarrier();

			MT_ASSERT(from.isInitialized, "Invalid from fiber");
			MT_ASSERT(to.isInitialized, "Invalid to fiber");

			int res = swapcontext(&from.fiberContext, &to.fiberContext);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "setcontext - failed");

		}



	};


}


#endif

```

`Scheduler/Include/Platform/Posix/MTMemory.h`:

```h
#pragma once

#ifndef __MT_MEMORY__
#define __MT_MEMORY__


#include <alloca.h>

#define MT_ALLOCATE_ON_STACK(BYTES_COUNT) alloca(BYTES_COUNT)

#endif

```

`Scheduler/Include/Platform/Posix/MTMutex.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_MUTEX__
#define __MT_MUTEX__

#include <pthread.h>


namespace MT
{
	class ScopedGuard;

	//
	//
	//
	class Mutex
	{
		pthread_mutexattr_t mutexAttr;
		pthread_mutex_t mutex;

	public:

		MT_NOCOPYABLE(Mutex);

		Mutex()
		{
			int res = pthread_mutexattr_init(&mutexAttr);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutexattr_init - failed");

			res = pthread_mutexattr_settype(&mutexAttr, PTHREAD_MUTEX_RECURSIVE);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutexattr_settype - failed");

			res = pthread_mutex_init(&mutex, &mutexAttr);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_init - failed");
		}

		~Mutex()
		{
			int res = pthread_mutex_destroy(&mutex);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_destroy - failed");

			res = pthread_mutexattr_destroy(&mutexAttr);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutexattr_destroy - failed");
		}

		friend class MT::ScopedGuard;

	private:

		void Lock()
		{
			int res = pthread_mutex_lock(&mutex);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_lock - failed");
		}
		void Unlock()
		{
			int res = pthread_mutex_unlock(&mutex);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == 0, "pthread_mutex_unlock - failed");
		}

	};


}


#endif

```

`Scheduler/Include/Platform/Posix/MTThread.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_THREAD__
#define __MT_THREAD__

#include <MTConfig.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include <limits.h>
#include <stdlib.h>
#include <sched.h>

#if MT_PLATFORM_OSX
#include <thread>
#endif

#include <sys/mman.h>

#ifndef MAP_ANONYMOUS
    #define MAP_ANONYMOUS MAP_ANON
#endif

#ifndef MAP_STACK
    #define MAP_STACK (0)
#endif

#include <Platform/Common/MTThread.h>
#include <MTAppInterop.h>

namespace MT
{
	//
	// Signals the calling thread to yield execution to another thread that is ready to run.
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline void YieldThread()
	{
		int err = sched_yield();
		MT_USED_IN_ASSERT(err);
		MT_ASSERT(err == 0, "pthread_yield - error");
	}


	class ThreadId
	{
	protected:
		pthread_t id;
		Atomic32<uint32> isInitialized;

		void Assign(const ThreadId& other)
		{
			id = other.id;
			isInitialized.Store(other.isInitialized.Load());
		}

	public:

		ThreadId()
		{
			isInitialized.Store(0);
		}

		mt_forceinline ThreadId(const ThreadId& other)
		{
			Assign(other);
		}

		mt_forceinline ThreadId& operator=(const ThreadId& other)
		{
			Assign(other);
			return *this;
		}

		mt_forceinline static ThreadId Self()
		{
			ThreadId selfThread;
			selfThread.id = pthread_self();
			selfThread.isInitialized.Store(1);
			return selfThread;
		}

		mt_forceinline bool IsValid() const
		{
			return (isInitialized.Load() != 0);
		}

		mt_forceinline bool IsEqual(const ThreadId& other) const
		{
			if (isInitialized.Load() != other.isInitialized.Load())
			{
				return false;
			}
			if (pthread_equal(id, other.id) == false)
			{
				return false;
			}
			return true;
		}

		mt_forceinline uint64 AsUInt64() const
		{
			if (isInitialized.Load() == 0)
			{
				return (uint64)-1;
			}

			return (uint64)id;
		}
	};



	class Thread : public ThreadBase
	{
		pthread_t thread;
		pthread_attr_t threadAttr;

		Memory::StackDesc stackDesc;

		size_t stackSize;

		bool isStarted;

		static void* ThreadFuncInternal(void* pThread)
		{
			Thread* self = (Thread *)pThread;
			self->func(self->funcData);
			return nullptr;
		}

#if MT_PLATFORM_OSX
		//TODO: support OSX priority and bind to processors
#else
		static void GetAffinityMask(cpu_set_t & cpu_mask, uint32 cpuCore)
		{
			CPU_ZERO(&cpu_mask);

			if (cpuCore == MT_CPUCORE_ANY)
			{
				uint32 threadsCount = (uint32)GetNumberOfHardwareThreads();
				for(uint32 i = 0; i < threadsCount; i++)
				{
					CPU_SET(i, &cpu_mask);
				}
			} else
			{
				CPU_SET(cpuCore, &cpu_mask);
			}
		}


		static int GetPriority(ThreadPriority::Type priority)
		{
			int min_prio = sched_get_priority_min (SCHED_FIFO);
			int max_prio = sched_get_priority_max (SCHED_FIFO);
			int default_prio = (max_prio - min_prio) / 2;

			switch(priority)
			{
			case ThreadPriority::DEFAULT:
				return default_prio;
			case ThreadPriority::HIGH:
				return max_prio;
			case ThreadPriority::LOW:
				return min_prio;
			default:
				MT_REPORT_ASSERT("Invalid thread priority");
			}

			return default_prio;
		}
#endif


	public:

		Thread()
			: stackSize(0)
			, isStarted(false)
		{
		}

		void* GetStackBottom()
		{
			return stackDesc.stackBottom;
		}

		size_t GetStackSize()
		{
			return stackSize;
		}


		void Start(size_t _stackSize, TThreadEntryPoint entryPoint, void* userData, uint32 cpuCore = MT_CPUCORE_ANY, ThreadPriority::Type priority = ThreadPriority::DEFAULT)
		{
			MT_ASSERT(!isStarted, "Thread already stared");

			MT_ASSERT(func == nullptr, "Thread already started");

			func = entryPoint;
			funcData = userData;

			stackDesc = Memory::AllocStack(_stackSize);
			stackSize = stackDesc.GetStackSize();

			MT_ASSERT(stackSize >= PTHREAD_STACK_MIN, "Thread stack to small");

			int err = pthread_attr_init(&threadAttr);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_attr_init - error");

			err = pthread_attr_setstack(&threadAttr, stackDesc.stackBottom, stackSize);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_attr_setstack - error");

			err = pthread_attr_setdetachstate(&threadAttr, PTHREAD_CREATE_JOINABLE);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_attr_setdetachstate - error");

#if MT_PLATFORM_OSX
			MT_UNUSED(cpuCore);
			MT_UNUSED(priority);

			//TODO: support OSX priority and bind to processors
#else
			err = pthread_attr_setinheritsched(&threadAttr, PTHREAD_EXPLICIT_SCHED);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_attr_setinheritsched - error");

			cpu_set_t cpu_mask;
			GetAffinityMask(cpu_mask, cpuCore);
			err = pthread_attr_setaffinity_np(&threadAttr, sizeof(cpu_mask), &cpu_mask);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_attr_setaffinity_np - error");

			struct sched_param params;
			params.sched_priority = GetPriority(priority);
			err = pthread_attr_setschedparam(&threadAttr, &params);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_attr_setschedparam - error");
#endif

			isStarted = true;

			err = pthread_create(&thread, &threadAttr, ThreadFuncInternal, this);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_create - error");
		}

		void Join()
		{
			MT_ASSERT(isStarted, "Thread is not started");

			if (func == nullptr)
			{
				return;
			}

			void *threadStatus = nullptr;
			int err = pthread_join(thread, &threadStatus);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_join - error");

			err = pthread_attr_destroy(&threadAttr);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_attr_destroy - error");

			func = nullptr;
			funcData = nullptr;

			if (stackDesc.stackMemory != nullptr)
			{
				Memory::FreeStack(stackDesc);
			}

			stackSize = 0;
			isStarted = false;
		}


		static int GetNumberOfHardwareThreads()
		{
#if MT_PLATFORM_OSX
            return std::thread::hardware_concurrency();
#else
			long numberOfProcessors = sysconf( _SC_NPROCESSORS_ONLN );
			return (int)numberOfProcessors;
#endif
		}

#ifdef MT_INSTRUMENTED_BUILD
		static void SetThreadName(const char* threadName)
		{
			pthread_t callThread = pthread_self();
			pthread_setname_np(callThread, threadName);
		}
#endif

		static void SetThreadSchedulingPolicy(uint32 cpuCore, ThreadPriority::Type priority = ThreadPriority::DEFAULT)
		{
#if MT_PLATFORM_OSX
			MT_UNUSED(cpuCore);
			MT_UNUSED(priority);

			//TODO: support OSX priority and bind to processors
#else
			pthread_t callThread = pthread_self();

			int sched_priority = GetPriority(priority);
			int err = pthread_setschedprio(callThread, sched_priority);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_setschedprio - error");

			cpu_set_t cpu_mask;
			GetAffinityMask(cpu_mask, cpuCore);
			err = pthread_setaffinity_np(callThread, sizeof(cpu_mask), &cpu_mask);
			MT_USED_IN_ASSERT(err);
			MT_ASSERT(err == 0, "pthread_setaffinity_np - error");
#endif
		}


		static void Sleep(uint32 milliseconds)
		{
			struct timespec req;
			int sec = (int)(milliseconds / 1000);
			milliseconds = milliseconds - (sec*1000);
			req.tv_sec = sec;
			req.tv_nsec = milliseconds * 1000000L;
			while (nanosleep(&req,&req) == -1 )
			{
				continue;
			}
		}

	};


}


#endif

```

`Scheduler/Include/Platform/Posix/MTUtils.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_UTILS__
#define __MT_UTILS__


#include <sys/time.h>

namespace MT
{
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	__inline int64 GetTimeMicroSeconds()
	{
		struct timeval te;
		gettimeofday(&te, nullptr);
		return te.tv_sec * 1000000LL + te.tv_usec;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	__inline int64 GetTimeMilliSeconds()
	{
		return GetTimeMicroSeconds() / 1000;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	__inline int64 GetHighFrequencyTime()
	{
		return GetTimeMicroSeconds();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	__inline int64 GetFrequency()
	{
		return 1000000;
	}

}


#endif

```

`Scheduler/Include/Platform/Windows/MTAtomic.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_ATOMIC__
#define __MT_ATOMIC__

#include <MTConfig.h>
#include <intrin.h>
#include <cstdint>
#include <type_traits>
#include <xmmintrin.h>

#define MT_ATOMIC_COMPILE_TIME_CHECK \
	static_assert(std::is_pod< Atomic32Base<T> >::value == true, "Atomic32Base must be a POD (plain old data type)"); \
	static_assert(sizeof(T) == sizeof(int32), "Atomic32Base, type T must be equal size as int32"); \
	static_assert(sizeof(int32) == sizeof(long), "Incompatible types, Interlocked* will fail.");

#define MT_ATOMICPTR_COMPILE_TIME_CHECK \
	static_assert(std::is_pod< AtomicPtrBase<T> >::value == true, "AtomicPtrBase must be a POD (plain old data type)");

#ifdef YieldProcessor
	#undef YieldProcessor
#endif


namespace MT
{
	//
	// Full memory barrier
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline void HardwareFullMemoryBarrier()
	{
		_mm_mfence();
	}

	//
	// Signals to the processor to give resources to threads that are waiting for them.
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline void YieldProcessor()
	{
		_mm_pause();
	}


	//
	// Atomic int (pod type)
	// The operation is ordered in a sequentially consistent manner except for functions marked as relaxed.
	//
	// Note: You must use this type when you need to declare static variable instead of Atomic32
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	struct Atomic32Base
	{
		T _value;

		// The function returns the resulting added value.
		T AddFetch(T sum)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = _InterlockedExchangeAdd((volatile long*)&_value, sum) + sum;
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the resulting incremented value.
		T IncFetch()
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = _InterlockedIncrement((volatile long*)&_value);
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the resulting decremented value.
		T DecFetch()
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = _InterlockedDecrement((volatile long*)&_value);
			mt_acquire_fence();
			return tmp;
		}

		T Load() const
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			T tmp = LoadRelaxed();
			mt_acquire_fence();
			return tmp;
		}

		void Store(T val)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			StoreRelaxed(val);
		}

		// The function returns the initial value.
		T Exchange(T val)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = _InterlockedExchange((volatile long*)&_value, val); 
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the initial value.
		T CompareAndSwap(T compareValue, T newValue)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			mt_release_fence();
			T tmp = _InterlockedCompareExchange((volatile long*)&_value, newValue, compareValue);
			mt_acquire_fence();
			return tmp;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		T LoadRelaxed() const
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			return _value;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		void StoreRelaxed(T val)
		{ MT_ATOMIC_COMPILE_TIME_CHECK

			_value = val;
		}

	};





	//
	// Atomic pointer (pod type)
	//
	// You must use this type when you need to declare static variable instead of AtomicPtr
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	struct AtomicPtrBase
	{
		T* _value;
	
		T* Load() const
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			T* tmp = LoadRelaxed();
			mt_acquire_fence();
			return tmp;
		}

		void Store(const T* val)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			mt_release_fence();
			StoreRelaxed(val);
		}

		// The function returns the initial value.
		T* Exchange(const T* val)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			mt_release_fence();
#ifndef MT_PTR64
			static_assert(sizeof(long) == sizeof(void*), "Incompatible types, _InterlockedExchange will fail");
			T* tmp = (T*)_InterlockedExchange((volatile long*)&_value, (long)val); 
#else
			T* tmp = (T*)_InterlockedExchangePointer((void* volatile*)&_value, (void*)val); 
#endif
			mt_acquire_fence();
			return tmp;
		}

		// The function returns the initial value.
		T* CompareAndSwap(const T* compareValue, const T* newValue)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			mt_release_fence();
#ifndef MT_PTR64
			static_assert(sizeof(long) == sizeof(void*), "Incompatible types, _InterlockedCompareExchange will fail");
			T* tmp = (T*)_InterlockedCompareExchange((volatile long*)&_value, (long)newValue, (long)compareValue);
#else
			T* tmp = (T*)_InterlockedCompareExchangePointer((void* volatile*)&_value, (void*)newValue, (void*)compareValue);
#endif
			mt_acquire_fence();
			return tmp;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		T* LoadRelaxed() const
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			return _value;
		}

		// Relaxed operation: there are no synchronization or ordering constraints
		void StoreRelaxed(const T* val)
		{ MT_ATOMICPTR_COMPILE_TIME_CHECK

			_value = (T*)val;
		}

	};



}


#undef MT_ATOMIC_COMPILE_TIME_CHECK


#endif

```

`Scheduler/Include/Platform/Windows/MTCommon.h`:

```h
#pragma once

#ifndef __MT_COMMON__
#define __MT_COMMON__


#include "MTAtomic.h"

#include "MicroWindows.h"
      
#include "MTUtils.h"
#include "MTThread.h"
#include "MTMutex.h"
#include "MTEvent.h"
#include "MTFiber.h"
#include "MTMemory.h"


#endif

```

`Scheduler/Include/Platform/Windows/MTEvent.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_EVENT__
#define __MT_EVENT__

#include <MTConfig.h>



#if MT_ENABLE_LEGACY_WINDOWSXP_SUPPORT
// Windows XP: Conditional variables are not supported. Using kernel mode events.
#include "MTEventKernel.h"
#else
// Conditional variables are supported. Using user mode events.
#include "MTEventUser.h"
#endif


#endif

```

`Scheduler/Include/Platform/Windows/MTEventKernel.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_EVENT_KERNEL__
#define __MT_EVENT_KERNEL__


namespace MT
{
	//
	//
	//
	class Event
	{
		::MW_HANDLE eventHandle;

	public:

		MT_NOCOPYABLE(Event);

		Event()
		{
			static_assert(sizeof(Event) == sizeof(::MW_HANDLE), "sizeof(Event) is invalid");
			eventHandle = nullptr;
		}

		Event(EventReset::Type resetType, bool initialState)
		{
			eventHandle = nullptr;
			Create(resetType, initialState);
		}

		~Event()
		{
			CloseHandle(eventHandle);
			eventHandle = nullptr;
		}

		void Create(EventReset::Type resetType, bool initialState)
		{
			if (eventHandle != nullptr)
			{
				CloseHandle(eventHandle);
			}

			MW_BOOL bManualReset = (resetType == EventReset::AUTOMATIC) ? 0 : 1;
			MW_BOOL bInitialState = initialState ? 1 : 0;
			eventHandle = ::CreateEventW(nullptr, bManualReset, bInitialState, nullptr);
		}

		void Signal()
		{
			SetEvent(eventHandle);
		}

		void Reset()
		{
			ResetEvent(eventHandle);
		}

		bool Wait(uint32 milliseconds)
		{
			MW_DWORD res = WaitForSingleObject(eventHandle, milliseconds);
			return (res == MW_WAIT_OBJECT_0);
		}

	};

}


#endif

```

`Scheduler/Include/Platform/Windows/MTEventUser.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_EVENT_USER__
#define __MT_EVENT_USER__

namespace MT
{
	//
	//
	//
	class Event
	{
		static const int NOT_SIGNALED = 0;
		static const int SIGNALED = 1;

		::MW_CRITICAL_SECTION criticalSection;
		::MW_CONDITION_VARIABLE condition;

		EventReset::Type resetType;

		volatile uint32 numOfWaitingThreads;
		volatile int32 value;
		volatile bool isInitialized;

	private:

		void AutoResetIfNeed()
		{
			if (resetType == EventReset::MANUAL)
			{
				return;
			}
			value = NOT_SIGNALED;
		}


	public:

		MT_NOCOPYABLE(Event);

		Event()
			: numOfWaitingThreads(0)
			, isInitialized(false)
		{
		}

		Event(EventReset::Type resetType_, bool initialState)
			: numOfWaitingThreads(0)
			, isInitialized(false)
		{
			Create(resetType_, initialState);
		}

		~Event()
		{
			if (isInitialized)
			{
				::DeleteCriticalSection(&criticalSection);
				isInitialized = false;
			}
		}

		void Create(EventReset::Type resetType_, bool initialState)
		{
			MT_ASSERT (!isInitialized, "Event already initialized");
			resetType = resetType_;

			::InitializeCriticalSectionAndSpinCount( &criticalSection, 16 );
			::InitializeConditionVariable( &condition );

			value = initialState ? SIGNALED : NOT_SIGNALED;
			isInitialized = true;
			numOfWaitingThreads = 0;
		}

		void Signal()
		{
			MT_ASSERT (isInitialized, "Event not initialized");
			::EnterCriticalSection( &criticalSection );
			value = SIGNALED;
			if (numOfWaitingThreads > 0)
			{
				if (resetType == EventReset::MANUAL)
				{
					::WakeAllConditionVariable( &condition );
				} else
				{
					::WakeConditionVariable( &condition );
				}
			}
			::LeaveCriticalSection( &criticalSection );
		}

		void Reset()
		{
			MT_ASSERT (isInitialized, "Event not initialized");
			MT_ASSERT(resetType == EventReset::MANUAL, "Can't reset, auto reset event");

			::EnterCriticalSection( &criticalSection );
			value = NOT_SIGNALED;
			::LeaveCriticalSection( &criticalSection );
		}

		bool Wait(uint32 milliseconds)
		{
			MT_ASSERT (isInitialized, "Event not initialized");

			::EnterCriticalSection( &criticalSection );
			// early exit if event already signaled
			if ( value != NOT_SIGNALED )
			{
				AutoResetIfNeed();
				::LeaveCriticalSection( &criticalSection );
				return true;
			}

			numOfWaitingThreads++;

			for(;;)
			{
				MW_BOOL ret = ::SleepConditionVariableCS(&condition, &criticalSection, (MW_DWORD)milliseconds);

#if defined(MT_DEBUG) || defined(MT_INSTRUMENTED_BUILD)
				if (ret == 0)
				{
						MW_DWORD err = ::GetLastError();
						MT_USED_IN_ASSERT(err);
						MT_ASSERT(err == MW_ERROR_TIMEOUT, "Unexpected return value from SleepConditionVariable");
				}
#endif

				/*
					https://msdn.microsoft.com/en-us/library/windows/desktop/ms686301(v=vs.85).aspx

					Condition variables are subject to spurious wakeups (those not associated with an explicit wake) and stolen wakeups (another thread manages to run before the woken thread).
					Therefore, you should recheck a predicate (typically in a while loop) after a sleep operation returns.
				*/
				if (value == SIGNALED || ret == 0)
				{
					break;
				}
			}

			numOfWaitingThreads--;
			bool isSignaled = (value != NOT_SIGNALED);
			if (isSignaled)
			{
				AutoResetIfNeed();
			} 

			::LeaveCriticalSection( &criticalSection );
			return isSignaled;
		}

	};

}


#endif

```

`Scheduler/Include/Platform/Windows/MTFiber.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_FIBER__
#define __MT_FIBER__

#include <MTConfig.h>


#if MT_PTR64

#define ReadTeb(offset) __readgsqword(offset);
#define WriteTeb(offset, v) __writegsqword(offset, v)

#else

#define ReadTeb(offset) __readfsdword(offset);
#define WriteTeb(offset, v) __writefsdword(offset, v)

#endif


	#include "MTFiberOptimized.h"


#endif

```

`Scheduler/Include/Platform/Windows/MTFiberDefault.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_FIBER_DEFAULT__
#define __MT_FIBER_DEFAULT__

#include "MTAtomic.h"

namespace MT
{

	inline void* FiberGetSelf()
	{
		MW_BOOL isThreadAFiber = ::IsThreadAFiber();
		if  (isThreadAFiber == 0)
		{
			// GetCurrentFiber() return invalid values is current thread is not fiber.
			return nullptr;
		}

		//This function is equal to GetCurrentFiber() macro
		void* pFiber = (void*)ReadTeb(MW_CURRENT_FIBER_OFFSET);
		return pFiber;
	}


	//
	// Fibers implementation using system fibers
	// Beware! Windows Fibers are wasteful use of Virtual Memory space for the stack. ( 1Mb reserved for each Fiber )
	//
	class Fiber
	{
		void* funcData;
		TThreadEntryPoint func;

		void* fiber;

		static void __stdcall FiberFuncInternal(void* pFiber)
		{
			Fiber* self = (Fiber*)pFiber;
			self->func(self->funcData);
		}

		void CleanUp()
		{
			if (fiber)
			{
				// Do not destroy fibers created using ::ConvertThreadToFiberEx
				if (func != nullptr)
				{
					::DeleteFiber(fiber);
				}
				else 
				{
					::ConvertFiberToThread();
				}
				fiber = nullptr;
			}
		}

	public:

		MT_NOCOPYABLE(Fiber);

		Fiber()
			: fiber(nullptr)
		{
		}

		~Fiber()
		{
			CleanUp();
		}


		void CreateFromCurrentThreadAndRun(TThreadEntryPoint entryPoint, void *userData)
		{
			MT_ASSERT(fiber == nullptr, "Fiber already created");

			func = nullptr;
			funcData = nullptr;

			void* fiberSelf = FiberGetSelf();
			if (fiberSelf != nullptr)
			{
				fiber = fiberSelf;
			} else
			{
				fiber = ::ConvertThreadToFiberEx(nullptr, MW_FIBER_FLAG_FLOAT_SWITCH);
				MT_ASSERT(fiber != nullptr, "Can't create fiber");
			}

			entryPoint(userData);

			CleanUp();
		}


		void Create(size_t stackSize, TThreadEntryPoint entryPoint, void* userData)
		{
			MT_ASSERT(fiber == nullptr, "Fiber already created");

			func = entryPoint;
			funcData = userData;
			fiber = ::CreateFiber( stackSize, FiberFuncInternal, this );
			MT_ASSERT(fiber != nullptr, "Can't create fiber");
		}

#ifdef MT_INSTRUMENTED_BUILD
		void SetName(const char* fiberName)
		{
			MT_UNUSED(fiberName);
		}
#endif

		static void SwitchTo(Fiber & from, Fiber & to)
		{
			MT_USED_IN_ASSERT(from);

			HardwareFullMemoryBarrier();

			MT_ASSERT(from.fiber != nullptr, "Invalid from fiber");
			MT_ASSERT(to.fiber != nullptr, "Invalid to fiber");

			::SwitchToFiber( (void*)to.fiber );
		}


	};

}

#endif

```

`Scheduler/Include/Platform/Windows/MTFiberOptimized.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_FIBER_OPTIMIZED__
#define __MT_FIBER_OPTIMIZED__

#include <MTConfig.h>
#include <Platform/Common/MTAtomic.h>
#include <string>


namespace MT
{

	//
	// Windows fiber implementation through GetThreadContext / SetThreadContext
	// I don't use standard Windows Fibers since they are wasteful use of Virtual Memory space for the stack. ( 1Mb for each Fiber )
	//
	class Fiber
	{
		MW_CONTEXT fiberContext;

		void* funcData;
		TThreadEntryPoint func;

		Memory::StackDesc stackDesc;

		bool isInitialized;

#if MT_PTR64
		// https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention
		// The Microsoft x64 calling convention is followed on Microsoft Windows.
		// It uses registers RCX, RDX, R8, R9 for the first four integer or pointer arguments (in that order), and XMM0, XMM1, XMM2, XMM3 are used for floating point arguments.

		// Additional arguments are pushed onto the stack (right to left). 
		static void __stdcall FiberFuncInternal(long /*ecx*/, long /*edx*/, long /*r8*/, long /*r9*/, void *pFiber)
#else
		// https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall
		// The stdcall calling convention is a variation on the Pascal calling convention in which the callee is responsible for cleaning up the stack,
		// but the parameters are pushed onto the stack in right-to-left order, as in the _cdecl calling convention.
		static void __stdcall FiberFuncInternal(void *pFiber)
#endif
		{
			MT_ASSERT(pFiber != nullptr, "Invalid fiber");
			Fiber* self = (Fiber*)pFiber;

			MT_ASSERT(self->isInitialized == true, "Using non initialized fiber");

			MT_ASSERT(self->func != nullptr, "Invalid fiber func");
			self->func(self->funcData);
		}

		void CleanUp()
		{
			if (isInitialized)
			{
				// if func != null than we have stack memory ownership
				if (func != nullptr)
				{
					Memory::FreeStack(stackDesc);
				}

				isInitialized = false;
			}
		}


	public:

		MT_NOCOPYABLE(Fiber);

		Fiber()
			: funcData(nullptr)
			, func(nullptr)
			, isInitialized(false)
		{
#if MT_PTR64
			MT_ASSERT(IsPointerAligned( this, 16 ), "Fiber must be aligned by 16 bytes");
			MT_ASSERT(IsPointerAligned( &fiberContext, 16 ), "MW_CONTEXT must be aligned by 16 bytes");
#endif
			memset(&fiberContext, 0, sizeof(MW_CONTEXT));
		}

		~Fiber()
		{
			CleanUp();
		}

		void CreateFromCurrentThreadAndRun(TThreadEntryPoint entryPoint, void *userData)
		{
			MT_ASSERT(!isInitialized, "Already initialized");

			fiberContext.ContextFlags = MW_CONTEXT_FULL;
			MW_BOOL res = GetThreadContext( GetCurrentThread(), &fiberContext );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res != 0, "GetThreadContext - failed");

			func = nullptr;
			funcData = nullptr;

			//Get thread stack information from thread environment block.
			stackDesc.stackTop = (void*)ReadTeb( MW_STACK_BASE_OFFSET /*FIELD_OFFSET(NT_TIB, StackBase)*/ );
			stackDesc.stackBottom = (void*)ReadTeb( MW_STACK_STACK_LIMIT_OFFSET /*FIELD_OFFSET(NT_TIB, StackLimit)*/ );

			isInitialized = true;

			entryPoint(userData);

			CleanUp();
		}

		void Create(size_t stackSize, TThreadEntryPoint entryPoint, void* userData)
		{
			MT_ASSERT(!isInitialized, "Already initialized");

			func = entryPoint;
			funcData = userData;

			fiberContext.ContextFlags = MW_CONTEXT_FULL;
			MW_BOOL res = GetThreadContext( GetCurrentThread(), &fiberContext );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res != 0, "GetThreadContext - failed");

			stackDesc = Memory::AllocStack(stackSize);

			void (*pFunc)() = (void(*)())&FiberFuncInternal;

			char* sp  = (char *)stackDesc.stackTop;
			char * paramOnStack = nullptr;

			// setup function address and stack pointer
#if MT_PTR64

			// http://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx
			// Furthermore, space for the register parameters is reserved on the stack, in case the called function wants to spill them

			sp -= 16; // pointer size and stack alignment
			paramOnStack  = sp;
			sp -= 40; // reserve for register params
			fiberContext.Rsp = (unsigned long long)sp;
			MT_ASSERT(((unsigned long long)paramOnStack & 0xF) == 0, "Params on X64 stack must be alligned to 16 bytes");
			fiberContext.Rip = (unsigned long long) pFunc;

#else

			sp -= sizeof(void*); // reserve stack space for one pointer argument
			paramOnStack  = sp;
			sp -= sizeof(void*);
			fiberContext.Esp = (unsigned long long)sp;
			fiberContext.Eip = (unsigned long long) pFunc;

#endif

			//copy param to stack here
			*(void**)paramOnStack = (void *)this;

			fiberContext.ContextFlags = MW_CONTEXT_FULL;

			isInitialized = true;
		}

#ifdef MT_INSTRUMENTED_BUILD
		void SetName(const char* fiberName)
		{
			MT_UNUSED(fiberName);
		}
#endif

		static void SwitchTo(Fiber & from, Fiber & to)
		{
			HardwareFullMemoryBarrier();

			MT_ASSERT(from.isInitialized, "Invalid from fiber");
			MT_ASSERT(to.isInitialized, "Invalid to fiber");

			MW_HANDLE thread = GetCurrentThread();

			from.fiberContext.ContextFlags = MW_CONTEXT_FULL;
			MW_BOOL res = GetThreadContext(thread, &from.fiberContext );
			MT_ASSERT(res != 0, "GetThreadContext - failed");

			// Modify current stack information in TEB
			//
			// __chkstk function use TEB info and probe sampling to commit new stack pages
			// https://support.microsoft.com/en-us/kb/100775
			//
			WriteTeb(MW_STACK_BASE_OFFSET /*FIELD_OFFSET(NT_TIB, StackBase)*/ , (uint64)to.stackDesc.stackTop);
			WriteTeb(MW_STACK_STACK_LIMIT_OFFSET/*FIELD_OFFSET(NT_TIB, StackLimit)*/, (uint64)to.stackDesc.stackBottom);

			res = SetThreadContext(thread, &to.fiberContext );
			MT_ASSERT(res != 0, "SetThreadContext - failed");

			//Restore stack information
			WriteTeb(MW_STACK_BASE_OFFSET /*FIELD_OFFSET(NT_TIB, StackBase)*/, (uint64)from.stackDesc.stackTop);
			WriteTeb(MW_STACK_STACK_LIMIT_OFFSET /*FIELD_OFFSET(NT_TIB, StackLimit)*/, (uint64)from.stackDesc.stackBottom);
		}


	};


}

#undef ReadTeb
#undef WriteTeb


#endif

```

`Scheduler/Include/Platform/Windows/MTMemory.h`:

```h
#pragma once

#ifndef __MT_MEMORY__
#define __MT_MEMORY__

#define MT_ALLOCATE_ON_STACK(BYTES_COUNT) _alloca(BYTES_COUNT)


#endif

```

`Scheduler/Include/Platform/Windows/MTMutex.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.
#pragma once

#ifndef __MT_MUTEX__
#define __MT_MUTEX__


namespace MT
{
	class ScopedGuard;

	//
	// 
	//
	class Mutex
	{
		::MW_CRITICAL_SECTION criticalSection;

	public:

		MT_NOCOPYABLE(Mutex);

		Mutex()
		{
			::InitializeCriticalSectionAndSpinCount( &criticalSection, 16 );
		}

		~Mutex()
		{
			::DeleteCriticalSection( &criticalSection );
		}

		friend class MT::ScopedGuard;

	private:

		void Lock()
		{
			::EnterCriticalSection( &criticalSection );
		}
		void Unlock()
		{
			::LeaveCriticalSection( &criticalSection );
		}

	};


}


#endif

```

`Scheduler/Include/Platform/Windows/MTThread.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.
#pragma once

#ifndef __MT_THREAD__
#define __MT_THREAD__

#include <Platform/Common/MTThread.h>

namespace MT
{
	//
	// Signals the calling thread to yield execution to another thread that is ready to run.
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline void YieldThread()
	{
		::SwitchToThread ();
	}


	class ThreadId
	{
	protected:
		MW_DWORD id;
		Atomic32<uint32> isInitialized;

		void Assign(const ThreadId& other)
		{
			id = other.id;
			isInitialized.Store(other.isInitialized.Load());
		}

	public:

		ThreadId()
		{
			isInitialized.Store(0);
		}

		mt_forceinline ThreadId(const ThreadId& other)
		{
			Assign(other);
		}

		mt_forceinline ThreadId& operator=(const ThreadId& other)
		{
			Assign(other);
			return *this;
		}

		mt_forceinline static ThreadId Self()
		{
			ThreadId selfThread;
			selfThread.id = ::GetCurrentThreadId();
			selfThread.isInitialized.Store(1);
			return selfThread;
		}

		mt_forceinline bool IsValid() const
		{
			return (isInitialized.Load() != 0);
		}

		mt_forceinline bool IsEqual(const ThreadId& other) const
		{
			if (isInitialized.Load() != other.isInitialized.Load())
			{
				return false;
			}
			if (id != other.id)
			{
				return false;
			}
			return true;
		}

		mt_forceinline uint64 AsUInt64() const
		{
			if (isInitialized.Load() == 0)
			{
				return (uint64)-1;
			}

			return (uint64)id;
		}

	};


	class Thread : public ThreadBase
	{
		MW_HANDLE thread;

		static MW_DWORD __stdcall ThreadFuncInternal(void *pThread)
		{
			Thread* self = (Thread*)pThread;
			self->func(self->funcData);
			return 0;
		}



		static int GetPriority(ThreadPriority::Type priority)
		{
			switch(priority)
			{
			case ThreadPriority::DEFAULT:
				return MW_THREAD_PRIORITY_HIGHEST;
			case ThreadPriority::HIGH:
				return MW_THREAD_PRIORITY_NORMAL;
			case ThreadPriority::LOW:
				return MW_THREAD_PRIORITY_LOWEST;
			default:
				MT_REPORT_ASSERT("Invalid thread priority");
			}

			return MW_THREAD_PRIORITY_NORMAL;
		}


	public:

		Thread()
			: thread(nullptr)
		{
		}

		~Thread()
		{
			MT_ASSERT(thread == nullptr, "Thread is not stopped!");
		}

		void Start(size_t stackSize, TThreadEntryPoint entryPoint, void *userData, uint32 cpuCore = MT_CPUCORE_ANY, ThreadPriority::Type priority = ThreadPriority::DEFAULT)
		{
			MT_ASSERT(thread == nullptr, "Thread already started");

			func = entryPoint;
			funcData = userData;
			thread = ::CreateThread( nullptr, stackSize, ThreadFuncInternal, this, MW_CREATE_SUSPENDED, nullptr );
			MT_ASSERT(thread != nullptr, "Can't create thread");

			if (cpuCore == MT_CPUCORE_ANY)
			{
				cpuCore = MW_MAXIMUM_PROCESSORS;
			}
			MT_VERIFY((cpuCore < (uint32)GetNumberOfHardwareThreads()) || cpuCore == MW_MAXIMUM_PROCESSORS, "Invalid cpu core specified", cpuCore=MW_MAXIMUM_PROCESSORS);
			MW_DWORD res = ::SetThreadIdealProcessor(thread, cpuCore);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res != (MW_DWORD)-1, "SetThreadIdealProcessor failed!");

			int sched_priority = GetPriority(priority);

			MW_BOOL result = ::SetThreadPriority(thread, sched_priority);
			MT_USED_IN_ASSERT(result);
			MT_ASSERT(result != 0, "SetThreadPriority failed!");

			res = ::ResumeThread(thread);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res != (MW_DWORD)-1, "ResumeThread failed!");
		}

		void Join()
		{
			if (thread == nullptr)
			{
				return;
			}

			::WaitForSingleObject(thread, MW_INFINITE);
			MW_BOOL res = CloseHandle(thread);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res != 0, "Can't close thread handle");
			thread = nullptr;
		}

#ifdef MT_INSTRUMENTED_BUILD
		static void SetThreadName(const char* threadName)
		{
			const int MW_EXCEPTION_EXECUTE_HANDLER = 1;
			const MW_DWORD MW_MSVC_EXCEPTION = 0x406D1388;

#pragma pack(push,8)
			typedef struct tagTHREADNAME_INFO
			{
				MW_DWORD dwType; // Must be 0x1000.
				const char* szName; // Pointer to name (in user addr space).
				MW_DWORD dwThreadID; // Thread ID (-1=caller thread).
				MW_DWORD dwFlags; // Reserved for future use, must be zero.
			} THREADNAME_INFO;
#pragma pack(pop)

			THREADNAME_INFO info;
			info.dwType = 0x1000;
			info.szName = threadName;
			info.dwThreadID = ::GetCurrentThreadId();
			info.dwFlags = 0;

			__try
			{
				RaiseException(MW_MSVC_EXCEPTION, 0, sizeof(info) / sizeof(void*), (MW_ULONG_PTR*)&info);
			}
			__except (MW_EXCEPTION_EXECUTE_HANDLER)
			{
			}
		}
#endif

		static void SetThreadSchedulingPolicy(uint32 cpuCore, ThreadPriority::Type priority = ThreadPriority::DEFAULT)
		{
			if (cpuCore == MT_CPUCORE_ANY)
			{
				cpuCore = MW_MAXIMUM_PROCESSORS;
			}
			MT_VERIFY((cpuCore < (uint32)GetNumberOfHardwareThreads()) || cpuCore == MW_MAXIMUM_PROCESSORS, "Invalid cpu core specified", cpuCore=MW_MAXIMUM_PROCESSORS);
			MW_DWORD res = ::SetThreadIdealProcessor( ::GetCurrentThread(), cpuCore);
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res != (MW_DWORD)-1, "SetThreadIdealProcessor failed!");

			int sched_priority = GetPriority(priority);

			MW_BOOL result = ::SetThreadPriority( ::GetCurrentThread(), sched_priority );
			MT_USED_IN_ASSERT(result);
			MT_ASSERT(result != 0, "SetThreadPriority failed!");
		}

		static int GetNumberOfHardwareThreads()
		{
			MW_SYSTEM_INFO sysinfo;
			::GetSystemInfo( &sysinfo );
			return sysinfo.dwNumberOfProcessors;
		}

		static void Sleep(uint32 milliseconds)
		{
		  ::Sleep(milliseconds);
		}
	};


}


#endif

```

`Scheduler/Include/Platform/Windows/MTUtils.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.
#pragma once

#ifndef __MT_UTILS__
#define __MT_UTILS__

namespace MT
{

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline int64 GetHighFrequencyTime()
	{
		MW_LARGE_INTEGER largeInteger;
		QueryPerformanceCounter( &largeInteger );
		return largeInteger.QuadPart;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline int64 GetFrequency()
	{
		MW_LARGE_INTEGER frequency;
		QueryPerformanceFrequency(&frequency);
		return frequency.QuadPart;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline int64 GetTimeMilliSeconds()
	{
		MW_LARGE_INTEGER largeInteger;
		QueryPerformanceCounter( &largeInteger );
		return ( largeInteger.QuadPart * int64(1000) ) / GetFrequency();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline int64 GetTimeMicroSeconds()
	{
		MW_LARGE_INTEGER largeInteger;
		QueryPerformanceCounter( &largeInteger );
		return ( largeInteger.QuadPart * int64(1000000) ) / GetFrequency();
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}


#endif

```

`Scheduler/Include/Platform/Windows/MicroWindows.cpp`:

```cpp
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.


#include <MTConfig.h>

#if MT_PLATFORM_WINDOWS 

#include <type_traits>

#define MW_SKIP_FUNCTIONS
#include "MicroWindows.h"

#ifndef WIN32_LEAN_AND_MEAN
	#define WIN32_LEAN_AND_MEAN
#endif

#ifdef _WIN32_WINNT
	#undef _WIN32_WINNT
#endif


#define _WIN32_WINNT 0x0403
#include <windows.h>



//
// Here we will check that the MicroWindows.h is fully compatible with the standard Windows.h
//

// Check types
static_assert(sizeof(MW_DWORD) == sizeof(DWORD), "MW_DWORD != DWORD");
static_assert(sizeof(MW_DWORD) == sizeof(uint32), "MW_DWORD != uint32");
static_assert(sizeof(MW_WORD) == sizeof(WORD), "MW_WORD != WORD");
static_assert(sizeof(MW_WORD) == sizeof(uint16), "MW_WORD != uint16");
static_assert(sizeof(MW_DWORD64) == sizeof(DWORD64), "MW_DWORD64 != DWORD64");
static_assert(sizeof(MW_DWORD64) == sizeof(uint64), "MW_DWORD64 != uint64");
static_assert(sizeof(MW_BOOL) == sizeof(BOOL), "MW_BOOL != BOOL");
static_assert(sizeof(MW_HANDLE) == sizeof(HANDLE), "MW_HANDLE != HANDLE");
static_assert(sizeof(MW_LARGE_INTEGER) == sizeof(LARGE_INTEGER), "MW_LARGE_INTEGER != LARGE_INTEGER");
static_assert(sizeof(MW_SYSTEM_INFO) == sizeof(SYSTEM_INFO), "MW_SYSTEM_INFO != SYSTEM_INFO");
static_assert(sizeof(MW_CRITICAL_SECTION) == sizeof(CRITICAL_SECTION), "MW_CRITICAL_SECTION != CRITICAL_SECTION");
static_assert(sizeof(MW_CONDITION_VARIABLE) == sizeof(CONDITION_VARIABLE), "MW_CRITICAL_SECTION != CRITICAL_SECTION");
static_assert(sizeof(MW_CONTEXT) == sizeof(CONTEXT), "MW_CONTEXT != CONTEXT");

// Check defines and flags
static_assert(MW_ERROR_TIMEOUT == ERROR_TIMEOUT, "MW_ERROR_TIMEOUT != ERROR_TIMEOUT");
static_assert(MW_THREAD_PRIORITY_LOWEST == THREAD_PRIORITY_LOWEST, "MW_THREAD_PRIORITY_LOWEST != THREAD_PRIORITY_LOWEST");
static_assert(MW_THREAD_PRIORITY_NORMAL == THREAD_PRIORITY_NORMAL, "MW_THREAD_PRIORITY_NORMAL != THREAD_PRIORITY_NORMAL");
static_assert(MW_THREAD_PRIORITY_HIGHEST == THREAD_PRIORITY_HIGHEST, "MW_THREAD_PRIORITY_HIGHEST != THREAD_PRIORITY_HIGHEST");
static_assert(MW_CREATE_SUSPENDED == CREATE_SUSPENDED, "MW_CREATE_SUSPENDED != CREATE_SUSPENDED");
static_assert(MW_MAXIMUM_PROCESSORS == MAXIMUM_PROCESSORS, "MW_MAXIMUM_PROCESSORS != MAXIMUM_PROCESSORS");
static_assert(MW_INFINITE == INFINITE, "MW_INFINITE != INFINITE");
static_assert(MW_WAIT_OBJECT_0 == WAIT_OBJECT_0, "MW_WAIT_OBJECT_0 != WAIT_OBJECT_0");
static_assert(MW_CONTEXT_FULL == CONTEXT_FULL, "MW_CONTEXT_FULL != CONTEXT_FULL");
static_assert(MW_MEM_COMMIT == MEM_COMMIT, "MW_MEM_COMMIT != MEM_COMMIT");
static_assert(MW_PAGE_READWRITE == PAGE_READWRITE, "MW_PAGE_READWRITE != PAGE_READWRITE");
static_assert(MW_PAGE_NOACCESS == PAGE_NOACCESS, "MW_PAGE_NOACCESS != PAGE_NOACCESS");
static_assert(MW_MEM_RELEASE == MEM_RELEASE, "MW_MEM_RELEASE != MEM_RELEASE");
//static_assert(MW_FIBER_FLAG_FLOAT_SWITCH == FIBER_FLAG_FLOAT_SWITCH, "MW_FIBER_FLAG_FLOAT_SWITCH != FIBER_FLAG_FLOAT_SWITCH");


// Check offsets
static_assert(MW_CURRENT_FIBER_OFFSET == FIELD_OFFSET(NT_TIB, FiberData), "MW_STACK_BASE_OFFSET != FIELD_OFFSET(NT_TIB, StackBase)");
static_assert(MW_STACK_BASE_OFFSET == FIELD_OFFSET(NT_TIB, StackBase), "MW_STACK_BASE_OFFSET != FIELD_OFFSET(NT_TIB, StackBase)");
static_assert(MW_STACK_STACK_LIMIT_OFFSET == FIELD_OFFSET(NT_TIB, StackLimit), "MW_STACK_STACK_LIMIT_OFFSET != FIELD_OFFSET(NT_TIB, StackLimit)");
static_assert(FIELD_OFFSET(MW_SYSTEM_INFO, dwPageSize) == FIELD_OFFSET(SYSTEM_INFO, dwPageSize), "FIELD_OFFSET(MW_SYSTEM_INFO, dwPageSize) != FIELD_OFFSET(SYSTEM_INFO, dwPageSize)");
static_assert(FIELD_OFFSET(MW_SYSTEM_INFO, dwNumberOfProcessors) == FIELD_OFFSET(SYSTEM_INFO, dwNumberOfProcessors), "FIELD_OFFSET(MW_SYSTEM_INFO, dwNumberOfProcessors) != FIELD_OFFSET(SYSTEM_INFO, dwNumberOfProcessors)");
static_assert(FIELD_OFFSET(MW_CONTEXT, ContextFlags) == FIELD_OFFSET(CONTEXT, ContextFlags), "FIELD_OFFSET(MW_CONTEXT, ContextFlags) != FIELD_OFFSET(CONTEXT, ContextFlags)");

#if MT_PTR64

static_assert(FIELD_OFFSET(MW_CONTEXT, Rsp) == FIELD_OFFSET(CONTEXT, Rsp), "FIELD_OFFSET(MW_CONTEXT, Rsp) != FIELD_OFFSET(CONTEXT, Rsp)");
static_assert(FIELD_OFFSET(MW_CONTEXT, Rip) == FIELD_OFFSET(CONTEXT, Rip), "FIELD_OFFSET(MW_CONTEXT, Rip) != FIELD_OFFSET(CONTEXT, Rip)");

#else

static_assert(FIELD_OFFSET(MW_CONTEXT, Esp) == FIELD_OFFSET(CONTEXT, Esp), "FIELD_OFFSET(MW_CONTEXT, Esp) != FIELD_OFFSET(CONTEXT, Esp)");
static_assert(FIELD_OFFSET(MW_CONTEXT, Eip) == FIELD_OFFSET(CONTEXT, Eip), "FIELD_OFFSET(MW_CONTEXT, Eip) != FIELD_OFFSET(CONTEXT, Eip)");

#endif



void DummyAssignableCheck()
{
	// Visual Studio 2010 is not support std::is_same<>, but we just need a compile error when types are different
	// so dummy assignable check here

	TThreadStartFunc mw_func = nullptr;
	LPTHREAD_START_ROUTINE func = nullptr;
	
	//check TThreadStartFunc is equal to LPTHREAD_START_ROUTINE
	mw_func = func;
}

#endif

```

`Scheduler/Include/Platform/Windows/MicroWindows.h`:

```h
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.
#pragma once

#include <MTConfig.h>
#include <MTTypes.h>


//
// micro windows header is used to avoid including heavy windows header to MTPlatform.h
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#define MW_WINBASEAPI __declspec(dllimport)
#define MW_WINAPI __stdcall

#if defined(_WINDOWS_) || defined(_WINBASE_)

//
// if windows.h is already included simply create aliases to the MW_ types
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef LARGE_INTEGER MW_LARGE_INTEGER;
typedef BOOL MW_BOOL;
typedef HANDLE MW_HANDLE;

typedef DWORD MW_DWORD;
typedef WORD MW_WORD;
typedef DWORD64 MW_DWORD64;
typedef ULONG_PTR MW_ULONG_PTR;

typedef LPTHREAD_START_ROUTINE TThreadStartFunc;

typedef SYSTEM_INFO MW_SYSTEM_INFO;

typedef CRITICAL_SECTION MW_CRITICAL_SECTION;
typedef CONDITION_VARIABLE MW_CONDITION_VARIABLE;

typedef CONTEXT MW_CONTEXT;

#define MW_INFINITE (INFINITE)
#define MW_WAIT_OBJECT_0 (WAIT_OBJECT_0)
#define MW_MEM_COMMIT (MEM_COMMIT)
#define MW_PAGE_READWRITE (PAGE_READWRITE)
#define MW_PAGE_NOACCESS (PAGE_NOACCESS)
#define MW_MEM_RELEASE (MEM_RELEASE)
#define MW_ERROR_TIMEOUT (ERROR_TIMEOUT)

#define MW_CURRENT_FIBER_OFFSET (FIELD_OFFSET(NT_TIB, FiberData))
#define MW_STACK_BASE_OFFSET (FIELD_OFFSET(NT_TIB, StackBase))
#define MW_STACK_STACK_LIMIT_OFFSET (FIELD_OFFSET(NT_TIB, StackLimit))
#define MW_CONTEXT_FULL (CONTEXT_FULL)


#define MW_FIBER_FLAG_FLOAT_SWITCH (FIBER_FLAG_FLOAT_SWITCH)

#define MW_THREAD_PRIORITY_HIGHEST (THREAD_PRIORITY_HIGHEST) 
#define MW_THREAD_PRIORITY_NORMAL (THREAD_PRIORITY_NORMAL) 
#define MW_THREAD_PRIORITY_LOWEST (THREAD_PRIORITY_LOWEST) 

#define MW_CREATE_SUSPENDED (CREATE_SUSPENDED)

#define MW_MAXIMUM_PROCESSORS (MAXIMUM_PROCESSORS)

#else

// windows.h is not included, so declare types

//
// define types
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct MW_LARGE_INTEGER
{
	int64 QuadPart;
};

typedef int MW_BOOL;
typedef void* MW_HANDLE;

typedef unsigned long MW_DWORD;
typedef unsigned short MW_WORD;
typedef unsigned __int64 MW_DWORD64;

#if MT_PTR64
typedef unsigned __int64 MW_ULONG_PTR;
#else
typedef unsigned __int32 MW_ULONG_PTR;
#endif

//
// define thread function
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef MW_DWORD ( MW_WINAPI *TThreadStartFunc )(void* lpThreadParameter);

//
// define fiber function
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef void ( MW_WINAPI *TFiberStartFunc)(void* lpFiberParameter);




//
// system info structure, only used members are declared
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct MW_SYSTEM_INFO
{
	uint8 _unused_01[4];
	MW_DWORD dwPageSize;
	void* _unused_02[3];
	MW_DWORD dwNumberOfProcessors;
	uint8 _unused_03[12];
};


// Condition variable
typedef void* MW_CONDITION_VARIABLE;


#if MT_PTR64

//
// x64 critical section, only used members are declared
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct MW_CRITICAL_SECTION
{
	uint8 _unused[40];
};

//
// x64 machine context, only used members are declared
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct __declspec(align(16)) MW_CONTEXT
{
	uint8 _unused_01[48];
	MW_DWORD ContextFlags;
	uint8 _unused_02[100];
	MW_DWORD64 Rsp;
	uint8 _unused_03[88];
	MW_DWORD64 Rip;
	uint8 _unused_04[976];
};

static_assert(__alignof(MW_CONTEXT) == 16, "MW_CONTEXT align requirements must be 16 bytes");

#define MW_CURRENT_FIBER_OFFSET (32)
#define MW_STACK_BASE_OFFSET (8)
#define MW_STACK_STACK_LIMIT_OFFSET (16)
#define MW_CONTEXT_FULL (0x10000B)

#else

//
// x86 critical section, only used members are declared
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct MW_CRITICAL_SECTION
{
	uint8 _unused[24];
};

//
// x86 machine context, only used members are declared
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct MW_CONTEXT
{
	MW_DWORD ContextFlags;
	uint8 _unused_01[180];
	MW_DWORD   Eip;
	uint8 _unused_02[8];
	MW_DWORD   Esp;
	uint8 _unused_03[516];
};


#define MW_CURRENT_FIBER_OFFSET (16)
#define MW_STACK_BASE_OFFSET (4)
#define MW_STACK_STACK_LIMIT_OFFSET (8)
#define MW_CONTEXT_FULL (0x10007)


#endif


//
// defines and flags
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define MW_INFINITE (0xFFFFFFFF)
#define MW_WAIT_OBJECT_0 (0)
#define MW_MEM_COMMIT (0x1000)
#define MW_PAGE_READWRITE (0x04)
#define MW_PAGE_NOACCESS (0x01)
#define MW_MEM_RELEASE (0x8000)
#define MW_ERROR_TIMEOUT (1460L)

#define MW_THREAD_PRIORITY_HIGHEST (2) 
#define MW_THREAD_PRIORITY_NORMAL (0) 
#define MW_THREAD_PRIORITY_LOWEST (-2) 

#define MW_CREATE_SUSPENDED (0x00000004)


#if MT_PTR64
#define MW_MAXIMUM_PROCESSORS (64)
#define MW_FIBER_FLAG_FLOAT_SWITCH (0x1)
#else
#define MW_MAXIMUM_PROCESSORS (32)
#define MW_FIBER_FLAG_FLOAT_SWITCH (0x1)
#endif


#endif




#if !defined(MW_SKIP_FUNCTIONS) && !defined(_WINDOWS_)

//
// functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


extern "C" {

MW_WINBASEAPI MW_BOOL MW_WINAPI QueryPerformanceFrequency(MW_LARGE_INTEGER* lpFrequency);
MW_WINBASEAPI MW_BOOL MW_WINAPI QueryPerformanceCounter(MW_LARGE_INTEGER* lpPerformanceCount);

MW_WINBASEAPI MW_ULONG_PTR MW_WINAPI SetThreadAffinityMask(MW_HANDLE hThread, MW_ULONG_PTR dwThreadAffinityMask );
MW_WINBASEAPI MW_DWORD MW_WINAPI SetThreadIdealProcessor(MW_HANDLE hThread, MW_DWORD dwIdealProcessor );
MW_WINBASEAPI MW_BOOL MW_WINAPI SetThreadPriority(MW_HANDLE hThread, int nPriority );
MW_WINBASEAPI MW_HANDLE MW_WINAPI CreateThread(void* lpThreadAttributes, size_t dwStackSize, TThreadStartFunc lpStartAddress, void* lpParameter, MW_DWORD dwCreationFlags, MW_DWORD* lpThreadId);
MW_WINBASEAPI MW_BOOL MW_WINAPI CloseHandle(MW_HANDLE hObject);
MW_WINBASEAPI MW_HANDLE MW_WINAPI GetCurrentThread();
MW_WINBASEAPI MW_DWORD MW_WINAPI GetCurrentThreadId();
MW_WINBASEAPI MW_DWORD MW_WINAPI ResumeThread(MW_HANDLE hThread);
MW_WINBASEAPI MW_BOOL MW_WINAPI SwitchToThread();


MW_WINBASEAPI void MW_WINAPI GetSystemInfo(MW_SYSTEM_INFO* lpSystemInfo);

MW_WINBASEAPI void MW_WINAPI Sleep(MW_DWORD dwMilliseconds);
MW_WINBASEAPI MW_DWORD MW_WINAPI WaitForSingleObject(MW_HANDLE hHandle, MW_DWORD dwMilliseconds);

MW_WINBASEAPI	void MW_WINAPI InitializeConditionVariable (MW_CONDITION_VARIABLE* lpConditionVariable);
MW_WINBASEAPI	void MW_WINAPI WakeConditionVariable (MW_CONDITION_VARIABLE* lpConditionVariable);
MW_WINBASEAPI	void MW_WINAPI WakeAllConditionVariable (MW_CONDITION_VARIABLE* lpConditionVariable);
MW_WINBASEAPI	MW_BOOL	MW_WINAPI SleepConditionVariableCS (MW_CONDITION_VARIABLE* lpConditionVariable,	MW_CRITICAL_SECTION* lpCriticalSection, MW_DWORD dwMilliseconds);

MW_WINBASEAPI bool MW_WINAPI InitializeCriticalSectionAndSpinCount(MW_CRITICAL_SECTION* lpCriticalSection, MW_DWORD dwSpinCount );
MW_WINBASEAPI void MW_WINAPI DeleteCriticalSection(MW_CRITICAL_SECTION* lpCriticalSection );
MW_WINBASEAPI void MW_WINAPI EnterCriticalSection(MW_CRITICAL_SECTION* lpCriticalSection );
MW_WINBASEAPI void MW_WINAPI LeaveCriticalSection(MW_CRITICAL_SECTION* lpCriticalSection );

MW_WINBASEAPI MW_HANDLE MW_WINAPI CreateEventA(MW_CRITICAL_SECTION* lpEventAttributes, MW_BOOL bManualReset, MW_BOOL bInitialState, const char* lpName );
MW_WINBASEAPI MW_HANDLE MW_WINAPI CreateEventW(MW_CRITICAL_SECTION* lpEventAttributes, MW_BOOL bManualReset, MW_BOOL bInitialState, const wchar_t* lpName );
MW_WINBASEAPI MW_BOOL MW_WINAPI SetEvent( MW_HANDLE hEvent );
MW_WINBASEAPI MW_BOOL MW_WINAPI ResetEvent( MW_HANDLE hEvent );

MW_WINBASEAPI MW_BOOL MW_WINAPI GetThreadContext( MW_HANDLE hThread, MW_CONTEXT* lpContext );
MW_WINBASEAPI MW_BOOL MW_WINAPI SetThreadContext( MW_HANDLE hThread, const MW_CONTEXT* lpContext );

MW_WINBASEAPI void* MW_WINAPI VirtualAlloc( void* lpAddress, size_t dwSize, MW_DWORD flAllocationType, MW_DWORD flProtect );
MW_WINBASEAPI MW_BOOL MW_WINAPI VirtualProtect( void* lpAddress, size_t dwSize, MW_DWORD flNewProtect, MW_DWORD* lpflOldProtect );
MW_WINBASEAPI MW_BOOL MW_WINAPI VirtualFree( void* lpAddress, size_t dwSize, MW_DWORD dwFreeType );


MW_WINBASEAPI void MW_WINAPI DeleteFiber( void* lpFiber );
MW_WINBASEAPI void* MW_WINAPI ConvertThreadToFiberEx( void* lpParameter, MW_DWORD dwFlags );
MW_WINBASEAPI MW_BOOL MW_WINAPI ConvertFiberToThread();
MW_WINBASEAPI void* MW_WINAPI CreateFiber( size_t dwStackSize, TFiberStartFunc lpStartAddress, void* lpParameter );
MW_WINBASEAPI void MW_WINAPI SwitchToFiber( void* lpFiber );
MW_WINBASEAPI MW_BOOL MW_WINAPI IsThreadAFiber();

MW_WINBASEAPI void MW_WINAPI RaiseException(MW_DWORD dwExceptionCode, MW_DWORD dwExceptionFlags, MW_DWORD nNumberOfArguments, const MW_ULONG_PTR* lpArguments );

MW_WINBASEAPI MW_DWORD MW_WINAPI GetLastError();




}

#endif

```

`Scheduler/Include/Scopes/MTScopes.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

#ifndef __MT_STACK__
#define __MT_STACK__

#include <MTConfig.h>
#include <array>
#include <limits>

namespace MT
{
	static const int32 invalidStackId = 0;
	static const int32 invalidStorageId = 0;


	//
	// Scope descriptor
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class ScopeDesc
	{
	protected:

		//descriptor name
		const char* name;

		//descriptor declaration file/line
		const char* file;
		int32 line;

	public:

		ScopeDesc(const char* srcFile, int32 srcLine, const char* scopeName)
			: name(scopeName)
			, file(srcFile)
			, line(srcLine)
		{
		}

		const char* GetSourceFile() const
		{
			return file;
		}

		int32 GetSourceLine() const
		{
			return line;
		}

		const char* GetName() const
		{
			return name;
		}


	};


	//
	// Scope stack entry
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class ScopeStackEntry
	{
		int32 parentIndex;
		int32 descIndex;

	public:

		ScopeStackEntry(int32 _parentIndex, int32 _descIndex)
			: parentIndex(_parentIndex)
			, descIndex(_descIndex)
		{
		}

#if MT_DEBUG
		~ScopeStackEntry()
		{
			parentIndex = std::numeric_limits<int32>::lowest();
			descIndex = std::numeric_limits<int32>::lowest();
		}
#endif

		int32 GetParentId() const
		{
			return parentIndex;
		}

		int32 GetDescriptionId() const
		{
			return descIndex;
		}


	};


	//
	// Persistent scope descriptor storage
	//
	//   persistent storage used to store scope descriptors
	//   descriptors lifetime is equal to the storage lifetime    
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T, uint32 capacity>
	class PersistentScopeDescriptorStorage
	{
		static const int32 ALIGNMENT = 16;
		static const int32 ALIGNMENT_MASK = (ALIGNMENT-1);

		MT::Atomic32<int32> top;
		//additional bytes for alignment
		byte rawMemory_[ capacity * sizeof(T)  + ALIGNMENT];


		T* IndexToObject(int32 index)
		{
			byte* alignedMemory = (byte*)( ( (uintptr_t)&rawMemory_[0] + ALIGNMENT_MASK ) & ~(uintptr_t)ALIGNMENT_MASK );
			T* pObjectMemory = (T*)(alignedMemory + index * sizeof(T));
			return pObjectMemory;
		}


		T* AllocObject(int32 & id)
		{
			//new element index
			int32 index = top.IncFetch() - 1;
			MT_VERIFY(index < (int32)capacity, "Area allocator is full. Can't allocate more memory.", return nullptr);
			//get memory for object
			T* pObject = IndexToObject(index);
			id = (index + 1);
			return pObject;
		}


	public:

		PersistentScopeDescriptorStorage()
		{
			static_assert(std::is_base_of<MT::ScopeDesc, T>::value, "Type must be derived from MT::ScopeDesc");
			top.Store(0);
		}

		~PersistentScopeDescriptorStorage()
		{
			int32 count = top.Exchange(0);
			for (int32 i = 0; i < count; i++)
			{
				T* pObject = IndexToObject(i);
				MT_UNUSED(pObject);
				pObject->~T();
			}
		}

		int32 Alloc(const char* srcFile, int32 srcLine, const char* scopeName)
		{
			int32 id;
			T* pObject = AllocObject(id);
			if (pObject == nullptr)
				return invalidStorageId;

			//placement ctor
			new(pObject) T(srcFile, srcLine, scopeName);

			return id;
		}

		template<typename T1>
		int32 Alloc(const char* srcFile, int32 srcLine, const char* scopeName, const T1 & p1)
		{
			int32 id;
			T* pObject = AllocObject(id);
			if (pObject == nullptr)
				return invalidStorageId;

			//placement ctor
			new(pObject) T(srcFile, srcLine, scopeName, p1);
			return id;
		}

		template<typename T1, typename T2>
		int32 Alloc(const char* srcFile, int32 srcLine, const char* scopeName, const T1 & p1, const T1 & p2)
		{
			int32 id;
			T* pObject = AllocObject(id);
			if (pObject == nullptr)
				return invalidStorageId;

			//placement ctor
			new(pObject) T(srcFile, srcLine, scopeName, p1, p2);
			return id;
		}

		template<typename T1, typename T2>
		int32 Alloc(const char* srcFile, int32 srcLine, const char* scopeName, const T1 & p1, const T1 & p2, const T1 & p3)
		{
			int32 id;
			T* pObject = AllocObject(id);
			if (pObject == nullptr)
				return invalidStorageId;

			//placement ctor
			new(pObject) T(srcFile, srcLine, scopeName, p1, p2, p3);
			return id;
		}

		T* Get(int32 id)
		{
			MT_VERIFY(id > invalidStorageId, "Invalid ID", return nullptr );
			MT_VERIFY(id <= top.Load(), "Invalid ID", return nullptr );
			int32 index = ( id - 1);
			T* pObject = IndexToObject(index);
			return pObject;
		}

	};


	//
	// Weak scope stack
	//
	//  Weak stack, which means that any data from the stack become invalid after stack entry is popped from stack
	//  Weak stack uses a small amount of memory, but in the case of deferred use the stack entires you must copy this entries to extend lifetime.
	//
	//  Well suited as asset/resource names stack.
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T, uint32 capacity>
	class WeakScopeStack
	{
		static const int32 ALIGNMENT = 16;
		static const int32 ALIGNMENT_MASK = (ALIGNMENT-1);

		int32 top;
		byte rawMemory_[ capacity * sizeof(T)  + ALIGNMENT];

		T* IndexToObject(int32 index)
		{
			byte* alignedMemory = (byte*)( ( (uintptr_t)&rawMemory_[0] + ALIGNMENT_MASK ) & ~(uintptr_t)ALIGNMENT_MASK );
			T* pObjectMemory = (T*)(alignedMemory + index * sizeof(T));
			return pObjectMemory;
		}


		T* AllocObject()
		{
			int32 index = top;
			MT_VERIFY(index < (int32)capacity, "Stack allocator overflow. Can't allocate more memory.", return nullptr);
			top++;
			T* pObject = IndexToObject(index);
			return pObject;
		}

	public:

		WeakScopeStack()
		{
			static_assert(std::is_base_of<MT::ScopeStackEntry, T>::value, "Type must be derived from MT::ScopeStackEntry");
			top = invalidStackId;
		}

		~WeakScopeStack()
		{
			for(int32 i = 0; i < top; i++)
			{
				T* pObject = IndexToObject(i);
				MT_UNUSED(pObject);
				pObject->~T();
			}
			top = 0;
		}


		T* Get(int32 id)
		{
			MT_VERIFY(id > invalidStackId, "Invalid id", return nullptr);
			int32 index = (id - 1);
			return IndexToObject(index);
		}

		int32 Top()
		{
			int32 id = top;
			return id;
		}

		void Pop()
		{
			top--;
			int32 index = top;
			MT_ASSERT(index >= 0, "Stack already empty. Invalid call.");
			T* pObject = IndexToObject(index);
			MT_UNUSED(pObject);
			pObject->~T();
		}

		T* Push()
		{
			T* pObject = AllocObject();
			new(pObject) T();
			return pObject;
		}

		template<typename T1>
		T* Push(const T1 & p1)
		{
			T* pObject = AllocObject();
			new(pObject) T(p1);
			return pObject;
		}

		template<typename T1, typename T2>
		T* Push(const T1 & p1, const T2 & p2)
		{
			T* pObject = AllocObject();
			new(pObject) T(p1, p2);
			return pObject;
		}

		template<typename T1, typename T2, typename T3>
		T* Push(const T1 & p1, const T2 & p2, const T3 & p3)
		{
			T* pObject = AllocObject();
			new(pObject) T(p1, p2, p3);
			return pObject;
		}

		template<typename T1, typename T2, typename T3, typename T4>
		T* Push(const T1 & p1, const T2 & p2, const T3 & p3, const T4 & p4)
		{
			T* pObject = AllocObject();
			new(pObject) T(p1, p2, p3, p4);
			return pObject;
		}
	};


	//
	// Strong scope stack
	//
	//  Strong stack, which means that any data from the stack is always valid, until you call Reset();
	//  Strong stack uses a lot of memory, but in the case of deferred use of stack entires you can store single pointer to current stack entry.
	//
	//  Well suited as CPU profiler timings stack.
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T, uint32 capacity>
	class StrongScopeStack
	{
		static const int32 ALIGNMENT = 16;
		static const int32 ALIGNMENT_MASK = (ALIGNMENT-1);

		int32 count;
		int32 top;

		//max stack deep
		std::array<int32, 256> stackId;

		//additional bytes for alignment
		byte rawMemory_[ capacity * sizeof(T) + ALIGNMENT ];


		T* IndexToObject(int32 index)
		{
			byte* alignedMemory = (byte*)( ( (uintptr_t)&rawMemory_[0] + ALIGNMENT_MASK ) & ~(uintptr_t)ALIGNMENT_MASK );
			T* pObjectMemory = (T*)(alignedMemory + index * sizeof(T));
			return pObjectMemory;
		}

		T* AllocObject()
		{
			int32 stackIndex = top;
			MT_VERIFY(stackIndex < (int32)stackId.size(), "Stack is too deep.", return nullptr);
			top++;

			int32 index = count;
			MT_VERIFY(index < (int32)capacity, "Stack allocator overflow. Can't allocate more memory.", return nullptr);
			count++;
			T* pObject = IndexToObject(index);

			stackId[stackIndex] = (index + 1);

			return pObject;
		}


	public:

		StrongScopeStack()
		{
			static_assert(std::is_base_of<MT::ScopeStackEntry, T>::value, "Type must be derived from MT::ScopeStackEntry");
			top = invalidStackId;
			count = 0;
		}

		~StrongScopeStack()
		{
			Reset();
		}

		T* Get(int32 id)
		{
			MT_VERIFY(id > invalidStackId, "Invalid id", return nullptr);
			int32 index = (id - 1);
			return IndexToObject(index);
		}

		int32 Top()
		{
			if (top == invalidStackId)
			{
				return invalidStackId;
			}

			return stackId[top - 1];
		}

		void Pop()
		{
			top--;
			int32 index = top;
			MT_ASSERT(index >= 0, "Stack already empty. Invalid call.");

			stackId[index] = 0;
		}


		T* Push()
		{
			T* pObject = AllocObject();
			new(pObject) T();
			return pObject;
		}

		template<typename T1, typename T2>
		T* Push(T1 p1, T2 p2)
		{
			T* pObject = AllocObject();
			new(pObject) T(p1, p2);
			return pObject;
		}

		template<typename T1, typename T2, typename T3>
		T* Push(T1 p1, T2 p2, T3 p3)
		{
			T* pObject = AllocObject();
			new(pObject) T(p1, p2, p3);
			return pObject;
		}

		template<typename T1, typename T2, typename T3, typename T4>
		T* Push(T1 p1, T2 p2, T3 p3, T4 p4)
		{
			T* pObject = AllocObject();
			new(pObject) T(p1, p2, p3, p4);
			return pObject;
		}


		void Reset()
		{
			for(int32 i = 0; i < count; i++)
			{
				T* pObject = IndexToObject(i);
				MT_UNUSED(pObject);
				pObject->~T();
			}

#if MT_DEBUG
			int32 stackIdCount = (int32)stackId.size();
			for(int32 i = 0; i < stackIdCount; i++)
			{
				stackId[i] = std::numeric_limits<int32>::lowest();
			}
#endif
			count = 0;
			top = invalidStackId;
		}

	};

} //MT namespace


#define SCOPE_CONCAT_IMPL(x, y) x##y
#define SCOPE_CONCAT(x, y) SCOPE_CONCAT_IMPL(x, y)

#define MT_SCOPE_NOT_INITIALIZED (0)
#define MT_SCOPE_NOT_YET_INITIALIZED (-1)

#define DECLARE_SCOPE_DESCRIPTOR_IMPL_PRE( file, line, name, storagePointer, resultID ) \
	\
	static MT::Atomic32Base<int32> SCOPE_CONCAT(scope_descriptorIndex_, line) = { MT_SCOPE_NOT_INITIALIZED }; \
	static_assert(std::is_pod< MT::Atomic32Base<int32> >::value == true, "AtomicInt32Base type should be POD, to be placed in bss/data section"); \
	\
	int32 SCOPE_CONCAT(scope_descId_, line) = MT_SCOPE_NOT_INITIALIZED; \
	\
	int32 SCOPE_CONCAT(scope_state_, line) = SCOPE_CONCAT(scope_descriptorIndex_, line).CompareAndSwap(MT_SCOPE_NOT_INITIALIZED, MT_SCOPE_NOT_YET_INITIALIZED); \
	switch(SCOPE_CONCAT(scope_state_, line)) \
	{ \
		/* first time here, need to allocate descriptor*/ \
		case MT_SCOPE_NOT_INITIALIZED: \
		{ \
			MT_ASSERT( storagePointer != nullptr, "Scopes storage pointer was not initialized!"); \



#define DECLARE_SCOPE_DESCRIPTOR_IMPL_POST( file, line, name, storagePointer, resultID ) \
			SCOPE_CONCAT(scope_descriptorIndex_, line).Store( SCOPE_CONCAT(scope_descId_, line) );  \
			break; \
		} \
		\
		/* allocation in progress */ \
		/* wait until the allocation is finished */ \
		case MT_SCOPE_NOT_YET_INITIALIZED: \
		{ \
			for(;;) \
			{ \
				SCOPE_CONCAT(scope_descId_, line) = SCOPE_CONCAT(scope_descriptorIndex_, line).Load(); \
				if (SCOPE_CONCAT(scope_descId_, line) != MT_SCOPE_NOT_YET_INITIALIZED) \
				{ \
					break; \
				} \
				MT::YieldProcessor(); \
			} \
			break; \
		} \
		/* description already allocated */ \
		default: \
		{ \
			SCOPE_CONCAT(scope_descId_, line) = SCOPE_CONCAT(scope_state_, line); \
			break; \
		} \
	} \
	resultID = SCOPE_CONCAT(scope_descId_, line);




#define DECLARE_SCOPE_DESCRIPTOR_IMPL( file, line, name, storagePointer, resultID ) \
	DECLARE_SCOPE_DESCRIPTOR_IMPL_PRE(file, line, name, storagePointer, resultID); \
		SCOPE_CONCAT(scope_descId_, line) = storagePointer -> Alloc(file, line, name); \
	DECLARE_SCOPE_DESCRIPTOR_IMPL_POST(file, line, name, storagePointer, resultID); \


#define DECLARE_SCOPE_DESCRIPTOR_IMPL1( file, line, name, storagePointer, resultID, param1) \
	DECLARE_SCOPE_DESCRIPTOR_IMPL_PRE(file, line, name, storagePointer, resultID); \
		SCOPE_CONCAT(scope_descId_, line) = storagePointer -> Alloc(file, line, name, param1); \
	DECLARE_SCOPE_DESCRIPTOR_IMPL_POST(file, line, name, storagePointer, resultID); \

#define DECLARE_SCOPE_DESCRIPTOR_IMPL2( file, line, name, storagePointer, resultID, param1, param2) \
	DECLARE_SCOPE_DESCRIPTOR_IMPL_PRE(file, line, name, storagePointer, resultID); \
		SCOPE_CONCAT(scope_descId_, line) = storagePointer -> Alloc(file, line, name, param1, param2); \
	DECLARE_SCOPE_DESCRIPTOR_IMPL_POST(file, line, name, storagePointer, resultID); \



// declare scope descriptor for current scope.
#define DECLARE_SCOPE_DESCRIPTOR(name, storagePointer, resultID) DECLARE_SCOPE_DESCRIPTOR_IMPL(__FILE__, __LINE__, name, storagePointer, resultID)

#define DECLARE_SCOPE_DESCRIPTOR1(name, storagePointer, resultID, param1) DECLARE_SCOPE_DESCRIPTOR_IMPL1(__FILE__, __LINE__, name, storagePointer, resultID, param1)

#define DECLARE_SCOPE_DESCRIPTOR2(name, storagePointer, resultID, param1, param2) DECLARE_SCOPE_DESCRIPTOR_IMPL2(__FILE__, __LINE__, name, storagePointer, resultID, param1, param2)

// push new stack entry to stack
#define SCOPE_STACK_PUSH(scopeDescriptorId, stackPointer) \
	MT_ASSERT(stackPointer != nullptr, "Stack pointer is not initialized for current thread."); \
	int32 SCOPE_CONCAT(scope_stackParentId_, __LINE__) = stackPointer -> Top(); \
	MT_ASSERT(SCOPE_CONCAT(scope_stackParentId_, __LINE__) >= 0, "Invalid parent ID"); \
	stackPointer -> Push(SCOPE_CONCAT(scope_stackParentId_, __LINE__), scopeDescriptorId); \


// push new stack entry to stack
#define SCOPE_STACK_PUSH1(scopeDescriptorId, param1, stackPointer) \
	MT_ASSERT(stackPointer != nullptr, "Stack pointer is not initialized for current thread."); \
	int32 SCOPE_CONCAT(scope_stackParentId_, __LINE__) = stackPointer -> Top(); \
	MT_ASSERT(SCOPE_CONCAT(scope_stackParentId_, __LINE__) >= 0, "Invalid parent ID"); \
	stackPointer -> Push(SCOPE_CONCAT(scope_stackParentId_, __LINE__), scopeDescriptorId, param1); \

// push new stack entry to stack
#define SCOPE_STACK_PUSH2(scopeDescriptorId, param1, param2, stackPointer) \
	MT_ASSERT(stackPointer != nullptr, "Stack pointer is not initialized for current thread."); \
	int32 SCOPE_CONCAT(scope_stackParentId_, __LINE__) = stackPointer -> Top(); \
	MT_ASSERT(SCOPE_CONCAT(scope_stackParentId_, __LINE__) >= 0, "Invalid parent ID"); \
	stackPointer -> Push(SCOPE_CONCAT(scope_stackParentId_, __LINE__), scopeDescriptorId, param1, param2); \


// pop from the stack
#define SCOPE_STACK_POP(stackPointer) \
	MT_ASSERT(stackPointer != nullptr, "Stack pointer is not initialized for current thread."); \
	stackPointer -> Pop(); \

// get top of the stack
#define SCOPE_STACK_TOP(stackPointer) \
	stackPointer -> Get( stackPointer -> Top() )


#define SCOPE_STACK_GET_PARENT(stackEntry, stackPointer) \
	(stackEntry -> GetParentId() == MT::invalidStackId) ? nullptr : stackPointer -> Get( stackEntry -> GetParentId() )


#endif

```

`Scheduler/Source/MTDefaultAppInterop.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.
#include <MTConfig.h>
#include <MTAppInterop.h>
#include <MTTools.h>

#include <stdio.h>

#if MT_SSE_INTRINSICS_SUPPORTED
#include <xmmintrin.h>
#endif




#if MT_PLATFORM_WINDOWS 

inline void ThrowException()
{
	__debugbreak();
}

#elif MT_PLATFORM_POSIX

#include<signal.h>
inline void ThrowException()
{
	raise(SIGTRAP);
	// force access violation error
	char* pBadAddr = (char*)0x0;
	*pBadAddr = 0;
}

#elif MT_PLATFORM_OSX

inline void ThrowException()
{
	__builtin_trap();
}

#else

#error Platform is not supported!

#endif



namespace MT
{

	void* Memory::Alloc(size_t size, size_t align)
	{
		void* p = nullptr;
#if MT_SSE_INTRINSICS_SUPPORTED
		p = _mm_malloc(size, align);
#else
        if (posix_memalign(&p, size, align) != 0)
        {
            p = nullptr;
        }
#endif
		MT_ASSERT(p, "Can't allocate memory");
		return p;
	}

	void Memory::Free(void* p)
	{
#if MT_SSE_INTRINSICS_SUPPORTED
		_mm_free(p);
#else
		free(p);
#endif
	}

	Memory::StackDesc Memory::AllocStack(size_t size)
	{
		StackDesc desc;

#if MT_PLATFORM_WINDOWS 

		MW_SYSTEM_INFO systemInfo;
		GetSystemInfo(&systemInfo);

		size_t pageSize = systemInfo.dwPageSize;
		size_t pagesCount = size / pageSize;

		//need additional page for stack guard
		if ((size % pageSize) > 0)
		{
			pagesCount++;
		}

		//protected guard page
		pagesCount++;

		desc.stackMemoryBytesCount = pagesCount * pageSize;
		desc.stackMemory = (char*)VirtualAlloc(NULL, desc.stackMemoryBytesCount, MW_MEM_COMMIT, MW_PAGE_READWRITE);
		MT_ASSERT(desc.stackMemory != NULL, "Can't allocate memory");

		desc.stackBottom = desc.stackMemory + pageSize;
		desc.stackTop = desc.stackMemory + desc.stackMemoryBytesCount;

		MW_DWORD oldProtect = 0;
		MW_BOOL res = VirtualProtect(desc.stackMemory, pageSize, MW_PAGE_NOACCESS, &oldProtect);
		MT_USED_IN_ASSERT(res);
		MT_ASSERT(res != 0, "Can't protect memory");

#elif MT_PLATFORM_POSIX || MT_PLATFORM_OSX

		int pageSize = (int)sysconf(_SC_PAGE_SIZE);
		int pagesCount = (int)(size / pageSize);

		//need additional page for stack tail
		if ((size % pageSize) > 0)
		{
			pagesCount++;
		}

		//protected guard page
		pagesCount++;

		desc.stackMemoryBytesCount = pagesCount * pageSize;
		desc.stackMemory = (char*)mmap(NULL, desc.stackMemoryBytesCount, PROT_READ | PROT_WRITE,  MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);

		MT_ASSERT((void *)desc.stackMemory != (void *)-1, "Can't allocate memory");

		desc.stackBottom = desc.stackMemory + pageSize;
		desc.stackTop = desc.stackMemory + desc.stackMemoryBytesCount;

		int res = mprotect(desc.stackMemory, pageSize, PROT_NONE);
		MT_USED_IN_ASSERT(res);
		MT_ASSERT(res == 0, "Can't protect memory");
#else
		#error Platform is not supported!
#endif

		return desc;
	}

	void Memory::FreeStack(const Memory::StackDesc & desc)
	{
#if MT_PLATFORM_WINDOWS 

		int res = VirtualFree(desc.stackMemory, 0, MW_MEM_RELEASE);
		MT_USED_IN_ASSERT(res);
		MT_ASSERT(res != 0, "Can't free memory");

#elif MT_PLATFORM_POSIX || MT_PLATFORM_OSX

		int res = munmap(desc.stackMemory, desc.stackMemoryBytesCount);
		MT_USED_IN_ASSERT(res);
		MT_ASSERT(res == 0, "Can't free memory");
#else
		#error Platform is not supported!
#endif
	}

	void Diagnostic::ReportAssert(const char* condition, const char* description, const char* sourceFile, int sourceLine)
	{
		printf("Assertion failed : %s. File %s, line %d. Condition %s\n", description, sourceFile, sourceLine, condition);
		ThrowException();
	}




}

```

`Scheduler/Source/MTFiberContext.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include <MTScheduler.h>

namespace MT
{
	FiberContext::FiberContext()
		: threadContext(nullptr)
		, taskStatus(FiberTaskStatus::UNKNOWN)
		, stackRequirements(StackRequirements::INVALID)
		, childrenFibersCount(0)
		, parentFiber(nullptr)
		, fiberIndex(UINT_MAX)
	{
		
	}

	void FiberContext::SetStatus(FiberTaskStatus::Type _taskStatus)
	{
		MT_ASSERT(threadContext, "Sanity check failed");
		MT_ASSERT(threadContext->threadId.IsEqual(ThreadId::Self()), "You can change task status only from owner thread");
		taskStatus = _taskStatus;
	}

	FiberTaskStatus::Type FiberContext::GetStatus() const
	{
		return taskStatus;
	}

	void FiberContext::SetThreadContext(internal::ThreadContext * _threadContext)
	{
		if (_threadContext)
		{
			_threadContext->lastActiveFiberContext = this;
		} 

		threadContext = _threadContext;
	}

	internal::ThreadContext* FiberContext::GetThreadContext()
	{
		return threadContext;
	}

	void FiberContext::Reset()
	{
		MT_ASSERT(childrenFibersCount.Load() == 0, "Can't release fiber with active children fibers");
		currentTask = internal::TaskDesc();
		parentFiber = nullptr;
		threadContext = nullptr;
		stackRequirements = StackRequirements::INVALID;
	}

	void FiberContext::Yield()
	{
		taskStatus = FiberTaskStatus::YIELDED;

		Fiber & schedulerFiber = threadContext->schedulerFiber;

#ifdef MT_INSTRUMENTED_BUILD		
		threadContext->NotifyTaskExecuteStateChanged( currentTask.debugColor, currentTask.debugID, TaskExecuteState::SUSPEND, (int32)fiberIndex);
#endif

		// Yielding, so reset thread context
		threadContext = nullptr;

		//switch to scheduler
		Fiber::SwitchTo(fiber, schedulerFiber);

#ifdef MT_INSTRUMENTED_BUILD
		threadContext->NotifyTaskExecuteStateChanged( currentTask.debugColor, currentTask.debugID, TaskExecuteState::RESUME, (int32)fiberIndex);
#endif
	}

	void FiberContext::RunSubtasksAndYieldImpl(ArrayView<internal::TaskBucket>& buckets)
	{
		MT_ASSERT(threadContext, "Sanity check failed!");
		MT_ASSERT(threadContext->taskScheduler, "Sanity check failed!");
		MT_ASSERT(threadContext->taskScheduler->IsWorkerThread(), "Can't use RunSubtasksAndYield outside Task. Use TaskScheduler.WaitGroup() instead.");
		MT_ASSERT(threadContext->threadId.IsEqual(ThreadId::Self()), "Thread context sanity check failed");

		// add to scheduler
		threadContext->taskScheduler->RunTasksImpl(buckets, this, false);

		//
		MT_ASSERT(threadContext->threadId.IsEqual(ThreadId::Self()), "Thread context sanity check failed");

		// Change status
		taskStatus = FiberTaskStatus::AWAITING_CHILD;

		Fiber & schedulerFiber = threadContext->schedulerFiber;

#ifdef MT_INSTRUMENTED_BUILD
		threadContext->NotifyTaskExecuteStateChanged( currentTask.debugColor, currentTask.debugID, TaskExecuteState::SUSPEND, (int32)fiberIndex);
#endif

		// Yielding, so reset thread context
		threadContext = nullptr;

		//switch to scheduler
		Fiber::SwitchTo(fiber, schedulerFiber);

#ifdef MT_INSTRUMENTED_BUILD
		threadContext->NotifyTaskExecuteStateChanged( currentTask.debugColor, currentTask.debugID, TaskExecuteState::RESUME, (int32)fiberIndex);
#endif

	}


	void FiberContext::RunAsync(TaskGroup taskGroup, const TaskHandle* taskHandleArray, uint32 taskHandleCount)
	{
		MT_ASSERT(taskHandleCount < (internal::TASK_BUFFER_CAPACITY - 1), "Too many tasks per one Run.");
		MT_ASSERT(threadContext, "ThreadContext is nullptr");
		MT_ASSERT(threadContext->taskScheduler, "Sanity check failed!");
		MT_ASSERT(threadContext->taskScheduler->IsWorkerThread(), "Can't use RunAsync outside Task. Use TaskScheduler.RunAsync() instead.");

		TaskScheduler& scheduler = *(threadContext->taskScheduler);

		ArrayView<internal::GroupedTask> buffer(threadContext->descBuffer, taskHandleCount);

		uint32 bucketCount = MT::Min((uint32)scheduler.GetWorkersCount(), taskHandleCount);
		ArrayView<internal::TaskBucket>	buckets(MT_ALLOCATE_ON_STACK(sizeof(internal::TaskBucket) * bucketCount), bucketCount);

		internal::DistibuteDescriptions(taskGroup, taskHandleArray, buffer, buckets);
		scheduler.RunTasksImpl(buckets, nullptr, false);
	}


	void FiberContext::RunSubtasksAndYield(TaskGroup taskGroup, const TaskHandle* taskHandleArray, uint32 taskHandleCount)
	{
		MT_ASSERT(taskHandleCount < (internal::TASK_BUFFER_CAPACITY - 1), "Too many tasks per one Run.");
		MT_ASSERT(threadContext, "ThreadContext is nullptr");
		MT_ASSERT(threadContext->taskScheduler, "TaskScheduler is nullptr");

		TaskScheduler& scheduler = *(threadContext->taskScheduler);

		ArrayView<internal::GroupedTask> buffer(threadContext->descBuffer, taskHandleCount);

		uint32 bucketCount = MT::Min((uint32)scheduler.GetWorkersCount(), taskHandleCount);
		ArrayView<internal::TaskBucket> buckets(MT_ALLOCATE_ON_STACK(sizeof(internal::TaskBucket) * bucketCount), bucketCount);

		internal::DistibuteDescriptions(taskGroup, taskHandleArray, buffer, buckets);
		RunSubtasksAndYieldImpl(buckets);
	}



}

```

`Scheduler/Source/MTScheduler.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include <MTScheduler.h>
#include <MTStaticVector.h>
#include <string.h> // for memset


//  Enable low latency experimental wait code path.
//  Look like low latency hybrid wait is work better for PS4/X1, but a little worse on PC
//#define MT_LOW_LATENCY_EXPERIMENTAL_WAIT (1)


namespace MT
{
#ifdef MT_INSTRUMENTED_BUILD
	TaskScheduler::TaskScheduler(uint32 workerThreadsCount, WorkerThreadParams* workerParameters, IProfilerEventListener* listener, TaskStealingMode::Type stealMode)
#else
	TaskScheduler::TaskScheduler(uint32 workerThreadsCount, WorkerThreadParams* workerParameters, TaskStealingMode::Type stealMode)
#endif
		: roundRobinThreadIndex(0)
		, startedThreadsCount(0)
		, taskStealingDisabled(stealMode == TaskStealingMode::DISABLED)
	{

#ifdef MT_INSTRUMENTED_BUILD
		profilerEventListener = listener;
#endif

		if (workerThreadsCount != 0)
		{
			threadsCount.StoreRelaxed( MT::Clamp(workerThreadsCount, (uint32)1, (uint32)MT_MAX_THREAD_COUNT) );
		} else
		{
			//query number of processor
			threadsCount.StoreRelaxed( (uint32)MT::Clamp(Thread::GetNumberOfHardwareThreads() - 1, 1, (int)MT_MAX_THREAD_COUNT) );
		}

		uint32 fiberIndex = 0;

		// create fiber pool (fibers with standard stack size)
		for (uint32 i = 0; i < MT_MAX_STANDART_FIBERS_COUNT; i++)
		{
			FiberContext& context = standartFiberContexts[i];
			context.fiber.Create(MT_STANDART_FIBER_STACK_SIZE, FiberMain, &context);
			context.fiberIndex = fiberIndex;
			bool res = standartFibersAvailable.TryPush( &context );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == true, "Can't add fiber to storage");
			fiberIndex++;
		}

		// create fiber pool (fibers with extended stack size)
		for (uint32 i = 0; i < MT_MAX_EXTENDED_FIBERS_COUNT; i++)
		{
			FiberContext& context = extendedFiberContexts[i];
			context.fiber.Create(MT_EXTENDED_FIBER_STACK_SIZE, FiberMain, &context);
			context.fiberIndex = fiberIndex;
			bool res = extendedFibersAvailable.TryPush( &context );
			MT_USED_IN_ASSERT(res);
			MT_ASSERT(res == true, "Can't add fiber to storage");
			fiberIndex++;
		}

#ifdef MT_INSTRUMENTED_BUILD
		NotifyFibersCreated(MT_MAX_STANDART_FIBERS_COUNT + MT_MAX_EXTENDED_FIBERS_COUNT);
#endif

		for (int16 i = 0; i < TaskGroup::MT_MAX_GROUPS_COUNT; i++)
		{
			if (i != TaskGroup::DEFAULT)
			{
				bool res = availableGroups.TryPush( TaskGroup(i) );
				MT_USED_IN_ASSERT(res);
				MT_ASSERT(res == true, "Can't add group to storage");
			}
		}

#if MT_GROUP_DEBUG
		groupStats[TaskGroup::DEFAULT].SetDebugIsFree(false);
#endif

		// create worker thread pool
		int32 totalThreadsCount = GetWorkersCount();

#ifdef MT_INSTRUMENTED_BUILD
		NotifyThreadsCreated(totalThreadsCount);
#endif

		for (int32 i = 0; i < totalThreadsCount; i++)
		{
			threadContext[i].SetThreadIndex(i);
			threadContext[i].taskScheduler = this;

			uint32 threadCore = i;
			ThreadPriority::Type priority = ThreadPriority::DEFAULT;
			if (workerParameters != nullptr)
			{
				const WorkerThreadParams& params = workerParameters[i];

				threadCore = params.core;
				priority = params.priority;
			}

			threadContext[i].thread.Start( MT_SCHEDULER_STACK_SIZE, WorkerThreadMain, &threadContext[i], threadCore, priority);
		}
	}

	void TaskScheduler::JoinWorkerThreads()
	{
		int32 totalThreadsCount = GetWorkersCount();
		for (int32 i = 0; i < totalThreadsCount; i++)
		{
			threadContext[i].state.Store(internal::ThreadState::EXIT);
			threadContext[i].hasNewTasksEvent.Signal();
		}

		for (int32 i = 0; i < totalThreadsCount; i++)
		{
			threadContext[i].thread.Join();
		}
		threadsCount.Store(0);
	}

	TaskScheduler::~TaskScheduler()
	{
		if (GetWorkersCount() > 0)
		{
			JoinWorkerThreads();
		}
	}

	FiberContext* TaskScheduler::RequestFiberContext(internal::GroupedTask& task)
	{
		FiberContext *fiberContext = task.awaitingFiber;
		if (fiberContext)
		{
			task.awaitingFiber = nullptr;
			return fiberContext;
		}

		MT::StackRequirements::Type stackRequirements = task.desc.stackRequirements;

		fiberContext = nullptr;
		bool res = false;
		MT_USED_IN_ASSERT(res);
		switch(stackRequirements)
		{
		case MT::StackRequirements::STANDARD:
			res = standartFibersAvailable.TryPop(fiberContext);
            MT_USED_IN_ASSERT(res);
			MT_ASSERT(res, "Can't get more standard fibers!");
			break;
		case MT::StackRequirements::EXTENDED:
			res = extendedFibersAvailable.TryPop(fiberContext);
            MT_USED_IN_ASSERT(res);
			MT_ASSERT(res, "Can't get more extended fibers!");
			break;
		default:
			MT_REPORT_ASSERT("Unknown stack requrements");
		}

		MT_ASSERT(fiberContext != nullptr, "Can't get more fibers. Too many tasks in flight simultaneously?");

		fiberContext->currentTask = task.desc;
		fiberContext->currentGroup = task.group;
		fiberContext->parentFiber = task.parentFiber;
		fiberContext->stackRequirements = stackRequirements;
		return fiberContext;
	}

	void TaskScheduler::ReleaseFiberContext(FiberContext*&& fiberContext)
	{
		MT_ASSERT(fiberContext, "Can't release nullptr Fiber. fiberContext is nullptr");

		MT::StackRequirements::Type stackRequirements = fiberContext->stackRequirements;
		fiberContext->Reset();

		MT_ASSERT(fiberContext != nullptr, "Fiber context can't be nullptr");

		bool res = false;
		MT_USED_IN_ASSERT(res);
		switch(stackRequirements)
		{
		case MT::StackRequirements::STANDARD:
			res = standartFibersAvailable.TryPush(std::move(fiberContext));
			break;
		case MT::StackRequirements::EXTENDED:
			res = extendedFibersAvailable.TryPush(std::move(fiberContext));
			break;
		default:
			MT_REPORT_ASSERT("Unknown stack requrements");
		}

		MT_USED_IN_ASSERT(res);
		MT_ASSERT(res != false, "Can't return fiber to storage");
	}

	FiberContext* TaskScheduler::ExecuteTask(internal::ThreadContext& threadContext, FiberContext* fiberContext)
	{
		MT_ASSERT(threadContext.threadId.IsEqual(ThreadId::Self()), "Thread context sanity check failed");

		MT_ASSERT(fiberContext, "Invalid fiber context");
		MT_ASSERT(fiberContext->currentTask.IsValid(), "Invalid task");

		// Set actual thread context to fiber
		fiberContext->SetThreadContext(&threadContext);

		// Update task status
		fiberContext->SetStatus(FiberTaskStatus::RUNNED);

		MT_ASSERT(fiberContext->GetThreadContext()->threadId.IsEqual(ThreadId::Self()), "Thread context sanity check failed");

		const void* poolUserData = fiberContext->currentTask.userData;
		TPoolTaskDestroy poolDestroyFunc = fiberContext->currentTask.poolDestroyFunc;

#ifdef MT_INSTRUMENTED_BUILD
		threadContext.NotifyTaskExecuteStateChanged( MT_SYSTEM_TASK_COLOR, MT_SYSTEM_TASK_NAME, TaskExecuteState::STOP, MT_SYSTEM_FIBER_INDEX);
#endif

		// Run current task code
		Fiber::SwitchTo(threadContext.schedulerFiber, fiberContext->fiber);

#ifdef MT_INSTRUMENTED_BUILD
		threadContext.NotifyTaskExecuteStateChanged( MT_SYSTEM_TASK_COLOR, MT_SYSTEM_TASK_NAME, TaskExecuteState::START, MT_SYSTEM_FIBER_INDEX);
#endif

		// If task was done
		FiberTaskStatus::Type taskStatus = fiberContext->GetStatus();
		if (taskStatus == FiberTaskStatus::FINISHED)
		{
			//destroy task (call dtor) for "fire and forget" type of task from TaskPool
			if (poolDestroyFunc != nullptr)
			{
				poolDestroyFunc(poolUserData);
			}

			TaskGroup taskGroup = fiberContext->currentGroup;

			TaskScheduler::TaskGroupDescription  & groupDesc = threadContext.taskScheduler->GetGroupDesc(taskGroup);

			// Update group status
			int groupTaskCount = groupDesc.Dec();
			MT_ASSERT(groupTaskCount >= 0, "Sanity check failed!");
			if (groupTaskCount == 0)
			{
				fiberContext->currentGroup = TaskGroup::INVALID;
			}

			// Update total task count
			int allGroupTaskCount = threadContext.taskScheduler->allGroups.Dec();
			MT_USED_IN_ASSERT(allGroupTaskCount);
			MT_ASSERT(allGroupTaskCount >= 0, "Sanity check failed!");

			FiberContext* parentFiberContext = fiberContext->parentFiber;
			if (parentFiberContext != nullptr)
			{
				int childrenFibersCount = parentFiberContext->childrenFibersCount.DecFetch();
				MT_ASSERT(childrenFibersCount >= 0, "Sanity check failed!");

				if (childrenFibersCount == 0)
				{
					// This is a last subtask. Restore parent task
					MT_ASSERT(threadContext.threadId.IsEqual(ThreadId::Self()), "Thread context sanity check failed");
					MT_ASSERT(parentFiberContext->GetThreadContext() == nullptr, "Inactive parent should not have a valid thread context");

					// WARNING!! Thread context can changed here! Set actual current thread context.
					parentFiberContext->SetThreadContext(&threadContext);

					MT_ASSERT(parentFiberContext->GetThreadContext()->threadId.IsEqual(ThreadId::Self()), "Thread context sanity check failed");

					// All subtasks is done.
					// Exiting and return parent fiber to scheduler
					return parentFiberContext;
				} else
				{
					// Other subtasks still exist
					// Exiting
					return nullptr;
				}
			} else
			{
				// Task is finished and no parent task
				// Exiting
				return nullptr;
			}
		}

		MT_ASSERT(taskStatus != FiberTaskStatus::RUNNED, "Incorrect task status")
		return nullptr;
	}


	void TaskScheduler::FiberMain(void* userData)
	{
		FiberContext& fiberContext = *(FiberContext*)(userData);
		for(;;)
		{
			MT_ASSERT(fiberContext.currentTask.IsValid(), "Invalid task in fiber context");
			MT_ASSERT(fiberContext.GetThreadContext(), "Invalid thread context");
			MT_ASSERT(fiberContext.GetThreadContext()->threadId.IsEqual(ThreadId::Self()), "Thread context sanity check failed");

#ifdef MT_INSTRUMENTED_BUILD
			fiberContext.fiber.SetName( MT_SYSTEM_TASK_FIBER_NAME );
			fiberContext.GetThreadContext()->NotifyTaskExecuteStateChanged( fiberContext.currentTask.debugColor, fiberContext.currentTask.debugID, TaskExecuteState::START, (int32)fiberContext.fiberIndex);
#endif

			fiberContext.currentTask.taskFunc( fiberContext, fiberContext.currentTask.userData );
			fiberContext.SetStatus(FiberTaskStatus::FINISHED);

#ifdef MT_INSTRUMENTED_BUILD
			fiberContext.fiber.SetName( MT_SYSTEM_TASK_FIBER_NAME );
			fiberContext.GetThreadContext()->NotifyTaskExecuteStateChanged( fiberContext.currentTask.debugColor, fiberContext.currentTask.debugID, TaskExecuteState::STOP, (int32)fiberContext.fiberIndex);
#endif

			Fiber::SwitchTo(fiberContext.fiber, fiberContext.GetThreadContext()->schedulerFiber);
		}

	}


	bool TaskScheduler::TryStealTask(internal::ThreadContext& threadContext, internal::GroupedTask & task)
	{
		uint32 workersCount = threadContext.taskScheduler->GetWorkersCount();

		uint32 victimIndex = threadContext.random.Get();

		for (uint32 attempt = 0; attempt < workersCount; attempt++)
		{
			uint32 index = victimIndex % workersCount;
			if (index == threadContext.workerIndex)
			{
				victimIndex++;
				index = victimIndex % workersCount;
			}

			internal::ThreadContext& victimContext = threadContext.taskScheduler->threadContext[index];
			if (victimContext.queue.TryPopNewest(task))
			{
				return true;
			}

			victimIndex++;
		}
		return false;
	}

	void TaskScheduler::WorkerThreadMain( void* userData )
	{
		internal::ThreadContext& context = *(internal::ThreadContext*)(userData);
		MT_ASSERT(context.taskScheduler, "Task scheduler must be not null!");

		context.threadId = ThreadId::Self();

#ifdef MT_INSTRUMENTED_BUILD
		const char* threadNames[] = {"worker0","worker1","worker2","worker3","worker4","worker5","worker6","worker7","worker8","worker9","worker10","worker11","worker12"};
		if (context.workerIndex < MT_ARRAY_SIZE(threadNames))
		{
			Thread::SetThreadName(threadNames[context.workerIndex]);
		} else
		{
			Thread::SetThreadName("worker_thread");
		}
#endif

		context.schedulerFiber.CreateFromCurrentThreadAndRun(SchedulerFiberMain, userData);
	}


	void TaskScheduler::SchedulerFiberWait( void* userData )
	{
		WaitContext& waitContext = *(WaitContext*)(userData);
		internal::ThreadContext& context = *waitContext.threadContext;
		MT_ASSERT(context.taskScheduler, "Task scheduler must be not null!");
		MT_ASSERT(waitContext.waitCounter, "Wait counter must be not null!");

#ifdef MT_INSTRUMENTED_BUILD
		context.NotifyTemporaryWorkerThreadJoin();

		context.NotifyWaitStarted();
		context.NotifyTaskExecuteStateChanged( MT_SYSTEM_TASK_COLOR, MT_SYSTEM_TASK_NAME, TaskExecuteState::START, MT_SYSTEM_FIBER_INDEX);
#endif

		bool isTaskStealingDisabled = context.taskScheduler->IsTaskStealingDisabled(0);

		int64 timeOut = GetTimeMicroSeconds() + ((int64)waitContext.waitTimeMs * 1000);

		SpinWait spinWait;
		
		for(;;)
		{
			if ( SchedulerFiberStep(context, isTaskStealingDisabled) == false )
			{
				spinWait.SpinOnce();
			} else
			{
				spinWait.Reset();
			}

			int32 groupTaskCount = waitContext.waitCounter->Load();
			if (groupTaskCount == 0)
			{
				waitContext.exitCode = 0;
				break;
			}

			int64 timeNow = GetTimeMicroSeconds();
			if (timeNow >= timeOut)
			{
				waitContext.exitCode = 1;
				break;
			}
		}

#ifdef MT_INSTRUMENTED_BUILD
		context.NotifyTaskExecuteStateChanged( MT_SYSTEM_TASK_COLOR, MT_SYSTEM_TASK_NAME, TaskExecuteState::STOP, MT_SYSTEM_FIBER_INDEX);
		context.NotifyWaitFinished();

		context.NotifyTemporaryWorkerThreadLeave();
#endif
	}

	void TaskScheduler::SchedulerFiberMain( void* userData )
	{
		internal::ThreadContext& context = *(internal::ThreadContext*)(userData);
		MT_ASSERT(context.taskScheduler, "Task scheduler must be not null!");

#ifdef MT_INSTRUMENTED_BUILD
		context.NotifyThreadCreated(context.workerIndex);
#endif

		int32 totalThreadsCount = context.taskScheduler->threadsCount.LoadRelaxed();
		context.taskScheduler->startedThreadsCount.IncFetch();

		//Simple spinlock until all threads is started and initialized
		for(;;)
		{
			int32 initializedThreadsCount = context.taskScheduler->startedThreadsCount.Load();
			if (initializedThreadsCount == totalThreadsCount)
			{
				break;
			}

			// sleep some time until all other thread initialized
			Thread::Sleep(1);
		}

		HardwareFullMemoryBarrier();

#ifdef MT_INSTRUMENTED_BUILD
		context.NotifyThreadStarted(context.workerIndex);
		context.NotifyTaskExecuteStateChanged( MT_SYSTEM_TASK_COLOR, MT_SYSTEM_TASK_NAME, TaskExecuteState::START, MT_SYSTEM_FIBER_INDEX);
#endif
		bool isTaskStealingDisabled = context.taskScheduler->IsTaskStealingDisabled();

		while(context.state.Load() != internal::ThreadState::EXIT)
		{
			if ( SchedulerFiberStep(context, isTaskStealingDisabled) == false)
			{
#ifdef MT_INSTRUMENTED_BUILD
				context.NotifyThreadIdleStarted(context.workerIndex);
#endif

#if MT_LOW_LATENCY_EXPERIMENTAL_WAIT

				SpinWait spinWait;

				for(;;)
				{
					// Queue is empty and stealing attempt has failed.
					// Fast Spin Wait for new tasks
					if (spinWait.SpinOnce() >= SpinWait::YIELD_SLEEP0_THRESHOLD)
					{
						// Fast Spin wait for new tasks has failed.
						// Wait for new events using events
						context.hasNewTasksEvent.Wait(20000);

						spinWait.Reset();

#ifdef MT_INSTRUMENTED_BUILD
						context.NotifyThreadIdleFinished(context.workerIndex);
#endif

						break;
					}

					internal::GroupedTask task;
					if ( context.queue.TryPopOldest(task) )
					{
#ifdef MT_INSTRUMENTED_BUILD
						context.NotifyThreadIdleFinished(context.workerIndex);
#endif

						SchedulerFiberProcessTask(context, task);

						break;
					}

				}
#else
				// Queue is empty and stealing attempt has failed.
				// Wait for new events using events
				context.hasNewTasksEvent.Wait(20000);

#ifdef MT_INSTRUMENTED_BUILD
				context.NotifyThreadIdleFinished(context.workerIndex);
#endif

#endif

			}

		} // main thread loop

#ifdef MT_INSTRUMENTED_BUILD
		context.NotifyTaskExecuteStateChanged( MT_SYSTEM_TASK_COLOR, MT_SYSTEM_TASK_NAME, TaskExecuteState::STOP, MT_SYSTEM_FIBER_INDEX);
		context.NotifyThreadStoped(context.workerIndex);
#endif

	}

	void TaskScheduler::SchedulerFiberProcessTask( internal::ThreadContext& context, internal::GroupedTask& task )
	{
#ifdef MT_INSTRUMENTED_BUILD
		bool isNewTask = (task.awaitingFiber == nullptr);
#endif

		// There is a new task
		FiberContext* fiberContext = context.taskScheduler->RequestFiberContext(task);
		MT_ASSERT(fiberContext, "Can't get execution context from pool");
		MT_ASSERT(fiberContext->currentTask.IsValid(), "Sanity check failed");
		MT_ASSERT(fiberContext->stackRequirements == task.desc.stackRequirements, "Sanity check failed");

		while(fiberContext)
		{
#ifdef MT_INSTRUMENTED_BUILD
			if (isNewTask)
			{
				//TODO:
				isNewTask = false;
			}
#endif
			// prevent invalid fiber resume from child tasks, before ExecuteTask is done
			fiberContext->childrenFibersCount.IncFetch();

			FiberContext* parentFiber = ExecuteTask(context, fiberContext);

			FiberTaskStatus::Type taskStatus = fiberContext->GetStatus();

			//release guard
			int childrenFibersCount = fiberContext->childrenFibersCount.DecFetch();

			// Can drop fiber context - task is finished
			if (taskStatus == FiberTaskStatus::FINISHED)
			{
				MT_ASSERT( childrenFibersCount == 0, "Sanity check failed");
				context.taskScheduler->ReleaseFiberContext(std::move(fiberContext));

				// If parent fiber is exist transfer flow control to parent fiber, if parent fiber is null, exit
				fiberContext = parentFiber;
			} else
			{
				MT_ASSERT( childrenFibersCount >= 0, "Sanity check failed");

				// No subtasks here and status is not finished, this mean all subtasks already finished before parent return from ExecuteTask
				if (childrenFibersCount == 0)
				{
					MT_ASSERT(parentFiber == nullptr, "Sanity check failed");
				} else
				{
					// If subtasks still exist, drop current task execution. task will be resumed when last subtask finished
					break;
				}

				// If task is yielded execution, get another task from queue.
				if (taskStatus == FiberTaskStatus::YIELDED)
				{
					// Task is yielded, add to tasks queue
					ArrayView<internal::GroupedTask> buffer(context.descBuffer, 1);
					ArrayView<internal::TaskBucket> buckets( MT_ALLOCATE_ON_STACK(sizeof(internal::TaskBucket)), 1 );

					FiberContext* yieldedTask = fiberContext;
					StaticVector<FiberContext*, 1> yieldedTasksQueue(1, yieldedTask);
					internal::DistibuteDescriptions( TaskGroup(TaskGroup::ASSIGN_FROM_CONTEXT), yieldedTasksQueue.Begin(), buffer, buckets );

					// add yielded task to scheduler
					context.taskScheduler->RunTasksImpl(buckets, nullptr, true);

					// ATENTION! yielded task can be already completed at this point

					break;
				}
			}
		} //while(fiberContext)
	}

	bool TaskScheduler::SchedulerFiberStep( internal::ThreadContext& context, bool disableTaskStealing)
	{
		internal::GroupedTask task;
		if ( context.queue.TryPopOldest(task) || (disableTaskStealing == false && TryStealTask(context, task) ) )
		{
			SchedulerFiberProcessTask(context, task);
			return true;
		}

		return false;
	}

	void TaskScheduler::RunTasksImpl(ArrayView<internal::TaskBucket>& buckets, FiberContext * parentFiber, bool restoredFromAwaitState)
	{

#if MT_LOW_LATENCY_EXPERIMENTAL_WAIT
		// Early wakeup worker threads (worker thread spin wait for some time before sleep)
		int32 roundRobinIndex = roundRobinThreadIndex.LoadRelaxed();
		for (size_t i = 0; i < buckets.Size(); ++i)
		{
			int bucketIndex = ((roundRobinIndex + i) % threadsCount.LoadRelaxed());
			internal::ThreadContext & context = threadContext[bucketIndex];
			context.hasNewTasksEvent.Signal();
		}
#endif


		// This storage is necessary to calculate how many tasks we add to different groups
		int newTaskCountInGroup[TaskGroup::MT_MAX_GROUPS_COUNT];

		// Default value is 0
		memset(&newTaskCountInGroup[0], 0, sizeof(newTaskCountInGroup));

		// Set parent fiber pointer
		// Calculate the number of tasks per group
		// Calculate total number of tasks
		size_t count = 0;
		for (size_t i = 0; i < buckets.Size(); ++i)
		{
			internal::TaskBucket& bucket = buckets[i];
			for (size_t taskIndex = 0; taskIndex < bucket.count; taskIndex++)
			{
				internal::GroupedTask & task = bucket.tasks[taskIndex];

				task.parentFiber = parentFiber;

				int idx = task.group.GetValidIndex();
				MT_ASSERT(idx >= 0 && idx < TaskGroup::MT_MAX_GROUPS_COUNT, "Invalid index");
				newTaskCountInGroup[idx]++;
			}

			count += bucket.count;
		}

		// Increments child fibers count on parent fiber
		if (parentFiber)
		{
			parentFiber->childrenFibersCount.AddFetch((int)count);
		}

		if (restoredFromAwaitState == false)
		{
			// Increase the number of active tasks in the group using data from temporary storage
			for (size_t i = 0; i < TaskGroup::MT_MAX_GROUPS_COUNT; i++)
			{
				int groupNewTaskCount = newTaskCountInGroup[i];
				if (groupNewTaskCount > 0)
				{
					groupStats[i].Add((uint32)groupNewTaskCount);
				}
			}

			// Increments all task in progress counter
			allGroups.Add((uint32)count);
		} else
		{
			// If task's restored from await state, counters already in correct state
		}

		// Add to thread queue
		for (size_t i = 0; i < buckets.Size(); ++i)
		{
			int bucketIndex = roundRobinThreadIndex.IncFetch() % threadsCount.LoadRelaxed();
			internal::ThreadContext & context = threadContext[bucketIndex];

			internal::TaskBucket& bucket = buckets[i];

			for(;;)
			{
				MT_ASSERT(bucket.count < (internal::TASK_BUFFER_CAPACITY - 1), "Sanity check failed. Too many tasks per one bucket.");
				
				bool res = context.queue.Add(bucket.tasks, bucket.count);
				if (res == true)
				{
					break;
				}

				//Can't add new tasks onto the queue. Look like the job system is overloaded. Wait some time and try again.
				//TODO: implement waiting until workers done using events.
				Thread::Sleep(10);
			}
			
			context.hasNewTasksEvent.Signal();
		}
	}

	void TaskScheduler::RunAsync(TaskGroup group, const TaskHandle* taskHandleArray, uint32 taskHandleCount)
	{
		MT_ASSERT(!IsWorkerThread(), "Can't use RunAsync inside Task. Use FiberContext.RunAsync() instead.");

		ArrayView<internal::GroupedTask> buffer(MT_ALLOCATE_ON_STACK(sizeof(internal::GroupedTask) * taskHandleCount), taskHandleCount);

		uint32 bucketCount = MT::Min((uint32)GetWorkersCount(), taskHandleCount);
		ArrayView<internal::TaskBucket> buckets(MT_ALLOCATE_ON_STACK(sizeof(internal::TaskBucket) * bucketCount), bucketCount);

		internal::DistibuteDescriptions(group, taskHandleArray, buffer, buckets);
		RunTasksImpl(buckets, nullptr, false);
	}

	bool TaskScheduler::WaitGroup(TaskGroup group, uint32 milliseconds)
	{
		MT_VERIFY(IsWorkerThread() == false, "Can't use WaitGroup inside Task. Use FiberContext.WaitGroupAndYield() instead.", return false);

		TaskScheduler::TaskGroupDescription& groupDesc = GetGroupDesc(group);

		// Early exit if not tasks in group
		int32 taskCount = groupDesc.GetTaskCount();
		if (taskCount == 0)
		{
			return true;
		}

		size_t bytesCountForDescBuffer = internal::ThreadContext::GetMemoryRequrementInBytesForDescBuffer();
		void* descBuffer = MT_ALLOCATE_ON_STACK(bytesCountForDescBuffer);
		
		internal::ThreadContext context(descBuffer);
		context.taskScheduler = this;
		context.SetThreadIndex(0xFFFFFFFF);
		context.threadId = ThreadId::Self();

		WaitContext waitContext;
		waitContext.threadContext = &context;
		waitContext.waitCounter = groupDesc.GetWaitCounter();
		waitContext.waitTimeMs = milliseconds;
		waitContext.exitCode = 0;

		int32 waitingSlotIndex = nextWaitingThreadSlotIndex.IncFetch();
		waitingThreads[waitingSlotIndex % waitingThreads.size()] = ThreadId::Self();
		context.schedulerFiber.CreateFromCurrentThreadAndRun(SchedulerFiberWait, &waitContext);
		
		MT_ASSERT( waitingThreads[waitingSlotIndex % waitingThreads.size()].IsEqual(ThreadId::Self()), "waitingThreads array overflow");
		waitingThreads[waitingSlotIndex % waitingThreads.size()] = ThreadId();

		return (waitContext.exitCode == 0);
	}

	bool TaskScheduler::WaitAll(uint32 milliseconds)
	{
		MT_VERIFY(IsWorkerThread() == false, "Can't use WaitAll inside Task.", return false);

		// Early exit if not tasks in group
		int32 taskCount = allGroups.GetTaskCount();
		if (taskCount == 0)
		{
			return true;
		}

		size_t bytesCountForDescBuffer = internal::ThreadContext::GetMemoryRequrementInBytesForDescBuffer();
		void* descBuffer = MT_ALLOCATE_ON_STACK(bytesCountForDescBuffer);

		internal::ThreadContext context(descBuffer);
		context.taskScheduler = this;
		context.SetThreadIndex(0xFFFFFFFF);
		context.threadId = ThreadId::Self();

		WaitContext waitContext;
		waitContext.threadContext = &context;
		waitContext.waitCounter = allGroups.GetWaitCounter();
		waitContext.waitTimeMs = milliseconds;
		waitContext.exitCode = 0;

		int32 waitingSlotIndex = nextWaitingThreadSlotIndex.IncFetch();
		waitingThreads[waitingSlotIndex % waitingThreads.size()] = ThreadId::Self();

		context.schedulerFiber.CreateFromCurrentThreadAndRun(SchedulerFiberWait, &waitContext);

		MT_ASSERT( waitingThreads[waitingSlotIndex % waitingThreads.size()].IsEqual(ThreadId::Self()), "waitingThreads array overflow");
		waitingThreads[waitingSlotIndex % waitingThreads.size()] = ThreadId();

		return (waitContext.exitCode == 0);
	}

	bool TaskScheduler::IsTaskStealingDisabled(uint32 minWorkersCount) const
	{
		if (threadsCount.LoadRelaxed() <= (int32)minWorkersCount)
		{
			return true;
		}

		return taskStealingDisabled;
	}

	int32 TaskScheduler::GetWorkersCount() const
	{
		return threadsCount.LoadRelaxed();
	}


	bool TaskScheduler::IsWorkerThread() const
	{
		int32 threadsCount = GetWorkersCount();
		for (int32 i = 0; i < threadsCount; i++)
		{
			if (threadContext[i].threadId.IsEqual(ThreadId::Self()))
			{
				return true;
			}
		}
		for (uint32 i = 0; i < waitingThreads.size(); i++)
		{
			if (waitingThreads[i].IsEqual(ThreadId::Self()))
				return true;
		}

		return false;
	}

	TaskGroup TaskScheduler::CreateGroup()
	{
		MT_ASSERT(IsWorkerThread() == false, "Can't use CreateGroup inside Task.");

		TaskGroup group;
		if (!availableGroups.TryPop(group))
		{
			MT_REPORT_ASSERT("Group pool is empty");
		}

		int idx = group.GetValidIndex();
		MT_USED_IN_ASSERT(idx);
		MT_ASSERT(groupStats[idx].GetDebugIsFree() == true, "Bad logic!");
#if MT_GROUP_DEBUG
		groupStats[idx].SetDebugIsFree(false);
#endif

		return group;
	}

	void TaskScheduler::ReleaseGroup(TaskGroup group)
	{
		MT_ASSERT(IsWorkerThread() == false, "Can't use ReleaseGroup inside Task.");
		MT_ASSERT(group.IsValid(), "Invalid group ID");

		int idx = group.GetValidIndex();
		MT_USED_IN_ASSERT(idx);
		MT_ASSERT(groupStats[idx].GetDebugIsFree() == false, "Group already released");
#if MT_GROUP_DEBUG
		groupStats[idx].SetDebugIsFree(true);
#endif

		bool res = availableGroups.TryPush(std::move(group));
		MT_USED_IN_ASSERT(res);
		MT_ASSERT(res, "Can't return group to pool");
	}

	TaskScheduler::TaskGroupDescription& TaskScheduler::GetGroupDesc(TaskGroup group)
	{
		MT_ASSERT(group.IsValid(), "Invalid group ID");

		int idx = group.GetValidIndex();
		TaskScheduler::TaskGroupDescription & groupDesc = groupStats[idx];

		MT_ASSERT(groupDesc.GetDebugIsFree() == false, "Invalid group");
		return groupDesc;
	}


#ifdef MT_INSTRUMENTED_BUILD

	void TaskScheduler::NotifyFibersCreated(uint32 fibersCount)
	{
		if (IProfilerEventListener* eventListener = GetProfilerEventListener())
		{
			eventListener->OnFibersCreated(fibersCount);
		}
	}

	void TaskScheduler::NotifyThreadsCreated(uint32 threadsCount)
	{
		if (IProfilerEventListener* eventListener = GetProfilerEventListener())
		{
			eventListener->OnThreadsCreated(threadsCount);
		}
	}


#endif

}



```

`Scheduler/Source/MTThreadContext.cpp`:

```cpp
// The MIT License (MIT)
// 
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
// 
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
// 
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include <MTScheduler.h>

namespace MT
{
	namespace internal
	{
		// Prime numbers for linear congruential generator seed
		static const uint32 primeNumbers[] = {
			128473, 135349, 159499, 173839, 209213, 241603, 292709, 314723,
			343943, 389299, 419473, 465169, 518327, 649921, 748271, 851087,
			862171, 974551, 1002973, 1034639, 1096289, 1153123, 1251037, 1299269,
			1272941, 1252151, 1231091, 1206761, 1185469, 1169933, 1141351, 1011583 };

		uint32 GetPrimeNumber(uint32 index)
		{
			return primeNumbers[index % MT_ARRAY_SIZE(primeNumbers)];
		}



		ThreadContext::ThreadContext()
			: lastActiveFiberContext(nullptr)
			, taskScheduler(nullptr)
			, hasNewTasksEvent(EventReset::AUTOMATIC, true)
			, state(ThreadState::ALIVE)
			, workerIndex(0)
			, isExternalDescBuffer(false)
		{
			 descBuffer = Memory::Alloc( GetMemoryRequrementInBytesForDescBuffer() );
		}

		ThreadContext::ThreadContext(void* externalDescBuffer)
			: lastActiveFiberContext(nullptr)
			, taskScheduler(nullptr)
			, queue(DummyQueueFlag::IS_DUMMY_QUEUE)
			, state(ThreadState::ALIVE)
			, workerIndex(0)
			, isExternalDescBuffer(true)
		{
			descBuffer = externalDescBuffer;
		}

		ThreadContext::~ThreadContext()
		{
			if (isExternalDescBuffer == false)
			{
				Memory::Free(descBuffer);
			}
			descBuffer = nullptr;
		}

		size_t ThreadContext::GetMemoryRequrementInBytesForDescBuffer()
		{
			return sizeof(internal::GroupedTask) * TASK_BUFFER_CAPACITY;
		}

		void ThreadContext::SetThreadIndex(uint32 threadIndex)
		{
			workerIndex = threadIndex;
			random.SetSeed( GetPrimeNumber(threadIndex) );
		}

#ifdef MT_INSTRUMENTED_BUILD

		void ThreadContext::NotifyWaitStarted()
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnThreadWaitStarted();
			}
		}

		void ThreadContext::NotifyWaitFinished()
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnThreadWaitFinished();
			}
		}

		void ThreadContext::NotifyTemporaryWorkerThreadJoin()
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnTemporaryWorkerThreadJoin();
			}
		}

		void ThreadContext::NotifyTemporaryWorkerThreadLeave()
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnTemporaryWorkerThreadLeave();
			}
		}

		void ThreadContext::NotifyTaskExecuteStateChanged(MT::Color::Type debugColor, const mt_char* debugID, TaskExecuteState::Type type, int32 fiberIndex)
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnTaskExecuteStateChanged(debugColor, debugID, type, fiberIndex);
			}
		}

		void ThreadContext::NotifyThreadCreated(uint32 threadIndex)
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnThreadCreated(threadIndex);
			}
		}

		void ThreadContext::NotifyThreadStarted(uint32 threadIndex)
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnThreadStarted(threadIndex);
			}
		}

		void ThreadContext::NotifyThreadStoped(uint32 threadIndex)
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnThreadStoped(threadIndex);
			}
		}

		void ThreadContext::NotifyThreadIdleStarted(uint32 threadIndex)
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnThreadIdleStarted(threadIndex);
			}
		}

		void ThreadContext::NotifyThreadIdleFinished(uint32 threadIndex)
		{
			if (IProfilerEventListener* eventListener = taskScheduler->GetProfilerEventListener())
			{
				eventListener->OnThreadIdleFinished(threadIndex);
			}
		}

#endif

	}

}

```

`SchedulerTests/Profiler/Profiler.cpp`:

```cpp
#include <MTScheduler.h>
#include "Profiler.h"


#if defined(MT_INSTRUMENTED_BUILD) && defined(MT_ENABLE_BROFILER_SUPPORT)

#pragma comment( lib, "BrofilerCore.lib" )
#pragma comment( lib, "Advapi32.lib" )


const uint32 MAX_INSTRUMENTED_WORKERS = 8;
const char *g_WorkerNames[MAX_INSTRUMENTED_WORKERS] = {"worker0","worker1","worker2","worker3","worker4","worker5","worker6","worker7"};

class ProfilerEventListener : public MT::IProfilerEventListener
{
	Brofiler::EventStorage* fiberEventStorages[MT::MT_MAX_STANDART_FIBERS_COUNT + MT::MT_MAX_EXTENDED_FIBERS_COUNT];
	uint32 totalFibersCount;

	static mt_thread_local Brofiler::EventStorage* originalThreadStorage;
	static mt_thread_local Brofiler::EventStorage* activeThreadStorage;

public:

	ProfilerEventListener()
		: totalFibersCount(0)
	{
	}

	virtual void OnFibersCreated(uint32 fibersCount) override
	{
		totalFibersCount = fibersCount;
		MT_ASSERT(fibersCount <= MT_ARRAY_SIZE(fiberEventStorages), "Too many fibers!");
		for(uint32 fiberIndex = 0; fiberIndex < fibersCount; fiberIndex++)
		{
			Brofiler::RegisterFiber(fiberIndex, &fiberEventStorages[fiberIndex]);
		}
	}

	virtual void OnThreadsCreated(uint32 threadsCount) override
	{
		MT_UNUSED(threadsCount);
	}

	virtual void OnTemporaryWorkerThreadLeave() override
	{
		Brofiler::EventStorage** currentThreadStorageSlot = Brofiler::GetEventStorageSlotForCurrentThread();
		MT_ASSERT(currentThreadStorageSlot, "Sanity check failed");
		Brofiler::EventStorage* storage = *currentThreadStorageSlot;

		// if profile session is not active
		if (storage == nullptr)
		{
			return;
		}

		MT_ASSERT(IsFiberStorage(storage) == false, "Sanity check failed");
	}

	virtual void OnTemporaryWorkerThreadJoin() override
	{
		Brofiler::EventStorage** currentThreadStorageSlot = Brofiler::GetEventStorageSlotForCurrentThread();
		MT_ASSERT(currentThreadStorageSlot, "Sanity check failed");
		Brofiler::EventStorage* storage = *currentThreadStorageSlot;

		// if profile session is not active
		if (storage == nullptr)
		{
			return;
		}

		MT_ASSERT(IsFiberStorage(storage) == false, "Sanity check failed");
	}


	virtual void OnThreadCreated(uint32 workerIndex) override 
	{
		BROFILER_START_THREAD("Scheduler(Worker)");
		MT_UNUSED(workerIndex);
	}

	virtual void OnThreadStarted(uint32 workerIndex) override
	{
		MT_UNUSED(workerIndex);
	}

	virtual void OnThreadStoped(uint32 workerIndex) override
	{
		MT_UNUSED(workerIndex);
		BROFILER_STOP_THREAD();
	}

	virtual void OnThreadIdleStarted(uint32 workerIndex) override
	{
		MT_UNUSED(workerIndex);
	}

	virtual void OnThreadIdleFinished(uint32 workerIndex) override
	{
		MT_UNUSED(workerIndex);
	}

	virtual void OnThreadWaitStarted() override
	{
	}

	virtual void OnThreadWaitFinished() override
	{
	}

	virtual void OnTaskExecuteStateChanged(MT::Color::Type debugColor, const mt_char* debugID, MT::TaskExecuteState::Type type, int32 fiberIndex) override 
	{
		MT_UNUSED(debugColor);
		MT_UNUSED(debugID);
		//MT_UNUSED(type);

		MT_ASSERT(fiberIndex < (int32)totalFibersCount, "Sanity check failed");

		Brofiler::EventStorage** currentThreadStorageSlot = Brofiler::GetEventStorageSlotForCurrentThread();
		MT_ASSERT(currentThreadStorageSlot, "Sanity check failed");

		// if profile session is not active
		if (*currentThreadStorageSlot == nullptr)
		{
			return;
		}

		// if actual fiber is scheduler internal fiber (don't have event storage for internal scheduler fibers)
		if (fiberIndex < 0)
		{
			return;
		}

		switch(type)
		{
		case MT::TaskExecuteState::START:
		case MT::TaskExecuteState::RESUME:
			{
				MT_ASSERT(originalThreadStorage == nullptr, "Sanity check failed");

				originalThreadStorage = *currentThreadStorageSlot;

				MT_ASSERT(IsFiberStorage(originalThreadStorage) == false, "Sanity check failed");

				Brofiler::EventStorage* currentFiberStorage = nullptr;
				if (fiberIndex >= (int32)0)
				{
					currentFiberStorage = fiberEventStorages[fiberIndex];
				} 

				*currentThreadStorageSlot = currentFiberStorage;
				activeThreadStorage = currentFiberStorage;
				Brofiler::FiberSyncData::AttachToThread(currentFiberStorage, MT::ThreadId::Self().AsUInt64());
			}
			break;

		case MT::TaskExecuteState::STOP:
		case MT::TaskExecuteState::SUSPEND:
			{
				Brofiler::EventStorage* currentFiberStorage = *currentThreadStorageSlot;

				//////////////////////////////////////////////////////////////////////////
				Brofiler::EventStorage* checkFiberStorage = nullptr;
				if (fiberIndex >= (int32)0)
				{
					checkFiberStorage = fiberEventStorages[fiberIndex];
				}
				MT_ASSERT(checkFiberStorage == currentFiberStorage, "Sanity check failed");

				MT_ASSERT(activeThreadStorage == currentFiberStorage, "Sanity check failed");

				//////////////////////////////////////////////////////////////////////////

				MT_ASSERT(IsFiberStorage(currentFiberStorage) == true, "Sanity check failed");

				Brofiler::FiberSyncData::DetachFromThread(currentFiberStorage);

				*currentThreadStorageSlot = originalThreadStorage;
				originalThreadStorage = nullptr;
			}
			break;
		}
	}
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
mt_thread_local Brofiler::EventStorage* ProfilerEventListener::originalThreadStorage = nullptr;
mt_thread_local Brofiler::EventStorage* ProfilerEventListener::activeThreadStorage = 0;

#endif


MT::IProfilerEventListener* GetProfiler()
{
#if defined(MT_INSTRUMENTED_BUILD) && defined(MT_ENABLE_BROFILER_SUPPORT)
	static ProfilerEventListener profilerListener;
	return &profilerListener;
#else
	return nullptr;
#endif
}


```

`SchedulerTests/Profiler/Profiler.h`:

```h
#pragma once

// Additional Include Directories and Additional Library Directories must be configured to Brofiler
//#define MT_ENABLE_BROFILER_SUPPORT (1)

#if defined(MT_INSTRUMENTED_BUILD) && defined(MT_ENABLE_BROFILER_SUPPORT)
#include <Brofiler.h>

#define BROFILER_NEXT_FRAME() Brofiler::NextFrame();   \
                              BROFILER_EVENT("Frame") \


#else
#define PROFILE
#define BROFILER_INLINE_EVENT(NAME, CODE) { CODE; }
#define BROFILER_CATEGORY(NAME, COLOR)
#define BROFILER_FRAME(NAME)
#define BROFILER_THREAD(FRAME_NAME)
#define BROFILER_NEXT_FRAME()
#endif


namespace MT
{
	class IProfilerEventListener;
}


MT::IProfilerEventListener* GetProfiler();





```

`SchedulerTests/Tests/AtomicTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <math.h>
#include <UnitTest++.h>
#include <MTAtomic.h>
#include <MTScheduler.h>


SUITE(AtomicTests)
{
	static const int OLD_VALUE = 1;
	static const int VALUE = 13;
	static const int NEW_VALUE = 16;
	static const int RELAXED_VALUE = 27;

	void TestStatics()
	{
		// This variables must be placed to .data / .bss section
		//
		// From "Cpp Standard"
		//
		// 6.7 Declaration statement
		//
		// 4 The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage
		//   duration (3.7.2) is performed before any other initialization takes place.
		//   Constant initialization (3.6.2) of a block-scope entity with static storage duration, if applicable,
		//   is performed before its block is first entered.
		//
		static MT::Atomic32Base<int32> test = { 0 };
		static MT::AtomicPtrBase<void> pTest = { nullptr };

		test.Store(13);
		pTest.Store(nullptr);

		CHECK_EQUAL(13, test.Load());
		CHECK(pTest.Load() == nullptr);
	}

TEST(AtomicSimpleTest)
{
	TestStatics();

	MT::Atomic32<int32> test_relaxed;
	test_relaxed.StoreRelaxed(RELAXED_VALUE);
	CHECK(test_relaxed.Load() == RELAXED_VALUE);

	MT::Atomic32<int32> test;
	test.Store(OLD_VALUE);
	CHECK(test.Load() == OLD_VALUE);

	int prevValue = test.Exchange(VALUE);
	CHECK(test.Load() == VALUE);
	CHECK(prevValue == OLD_VALUE);

	int nowValue = test.IncFetch();
	CHECK(nowValue == (VALUE+1));

	nowValue = test.DecFetch();
	CHECK(nowValue == VALUE);

	nowValue = test.AddFetch(VALUE);
	CHECK(nowValue == (VALUE+VALUE));

	MT::Atomic32<int32> test2(VALUE);
	CHECK(test2.Load() == VALUE);

	int prevResult = test2.CompareAndSwap(NEW_VALUE, OLD_VALUE);
	CHECK(prevResult == VALUE);
	CHECK(test2.Load() == VALUE);

	prevResult = test2.CompareAndSwap(VALUE, NEW_VALUE);
	CHECK(prevResult == VALUE);
	CHECK(test2.Load() == NEW_VALUE);

	MT::Atomic32<uint32> test3(UINT32_MAX);
	CHECK_EQUAL(UINT32_MAX, test3.Load());

	//check for wraps
	uint32 uNowValue = test3.IncFetch();
	CHECK(uNowValue == 0);

	uNowValue = test3.DecFetch();
	CHECK(uNowValue == UINT32_MAX);


	char tempObject;
	char* testPtr = &tempObject;
	char* testPtrNew = testPtr + 1;


	MT::AtomicPtr<char> atomicPtrRelaxed;
	atomicPtrRelaxed.StoreRelaxed(testPtr);
	CHECK(atomicPtrRelaxed.Load() == testPtr);

	MT::AtomicPtr<char> atomicPtr;
	CHECK(atomicPtr.Load() == nullptr);

	atomicPtr.Store(testPtr);
	CHECK(atomicPtr.Load() == testPtr);

	char* prevPtr = atomicPtr.CompareAndSwap(nullptr, testPtrNew);
	CHECK(prevPtr == testPtr);
	CHECK(atomicPtr.Load() == testPtr);

	prevPtr = atomicPtr.CompareAndSwap(testPtr, testPtrNew);
	CHECK(prevPtr == testPtr);
	CHECK(atomicPtr.Load() == testPtrNew);

	char* prevPtr2 = atomicPtr.Exchange(nullptr);
	CHECK(prevPtr2 == testPtrNew);
	CHECK(atomicPtr.Load() == nullptr);
}


MT::Atomic32<uint32> isReady;
MT::Atomic32<uint32> a;
MT::Atomic32<uint32> b;

uint32 sharedValue = 0;

MT::Atomic32<uint32> simpleLock;

void ThreadFunc( void* userData )
{
	MT_UNUSED(userData);

	MT::SpinWait spinWait;

	while(isReady.LoadRelaxed() == 0)
	{
		spinWait.SpinOnce();
	}

	for(int iteration = 0; iteration < 10000000; iteration++)
	{
		uint32 prevA = a.AddFetch(1);
		uint32 prevB = b.AddFetch(1);

		// A should be less than B, but can also be a equal due to threads race 
		CHECK(prevA <= prevB);
		if (prevA > prevB)
		{
			printf("a = %d, b = %d\n", prevA, prevB);
			break;
		}
	}

	float res = 0.0f;
	uint32 randDelay = 1 + (rand() % 4);
	uint32 count = 0;
	while (count < 10000000)
    {
		res = 0.0f;
		for(uint32 i = 0; i < randDelay; i++)
		{
			res += sin((float)i);
		}

		if (simpleLock.CompareAndSwap(0, 1) == 0)
		{
			sharedValue++;
			simpleLock.Store(0);
			count++;
		}
	}

	//prevent compiler optimization
	printf("%3.2f\n", res);

	//
}

/*

Inspired by "This Is Why They Call It a Weakly-Ordered CPU" blog post by Jeff Preshing
http://preshing.com/20121019/this-is-why-they-call-it-a-weakly-ordered-cpu/

*/
TEST(AtomicOrderingTest)
{
	isReady.Store(0);

	a.Store(1);
	b.Store(2);

	sharedValue = 0;

	simpleLock.Store(0);


	MT::Thread threads[2];
	uint32 threadsCount = MT_ARRAY_SIZE(threads);

	printf("threads count %d\n", threadsCount);

	for(uint32 i = 0; i < threadsCount; i++)
	{
		threads[i].Start(16384, ThreadFunc, nullptr);
	}

	isReady.Store(1);

	for(uint32 i = 0; i < threadsCount; i++)
	{
		threads[i].Join();
	}

	uint32 expectedSharedValue = (10000000 * threadsCount);
	CHECK_EQUAL(sharedValue, expectedSharedValue);
	
	
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`SchedulerTests/Tests/CleanupTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>


SUITE(CleanupTests)
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct NotFinishedTaskDestroy
{
	MT_DECLARE_TASK(NotFinishedTaskDestroy, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	void Do(MT::FiberContext&)
	{
		MT::SpinSleepMilliSeconds(4);
	}
};

// Checks one simple task
TEST(NotFinishedTaskDestroy)
{
	MT::TaskScheduler scheduler;

	NotFinishedTaskDestroy tasks[1024];

	scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));

	CHECK(!scheduler.WaitAll(3));
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`SchedulerTests/Tests/DxtTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.


#include <MTConfig.h>


#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>
#include <MTStaticVector.h>

#include "../Profiler/Profiler.h"

#include <squish.h>
#include <string.h>
#include <math.h>



namespace EmbeddedImage
{
	#include "LenaDxt/LenaColor.h"
	#include "LenaDxt/HeaderDDS.h"
}


bool CompareImagesPSNR(uint8 * img1, uint8 * img2, uint32 bytesCount, double psnrThreshold)
{
	double mse = 0.0;

	for (uint32 i = 0; i < bytesCount; i++)
	{
		double error = (double)img1[0] - (double)img2[1];
		mse += (error * error);
	}

	mse = mse / (double)bytesCount;

	if (mse > 0.0)
	{
		double psnr = 10.0 * log10(255.0*255.0/mse);
		if (psnr < psnrThreshold)
		{
			return false;
		}
	}

	return true;
}



SUITE(DxtTests)
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct CompressDxtBlock
	{
		MT_DECLARE_TASK(CompressDxtBlock, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		MT::ArrayView<uint8> srcPixels;
		MT::ArrayView<uint8> dstBlocks;

		int srcX;
		int srcY;

		int stride;
		int dstBlockOffset;

		CompressDxtBlock(int _srcX, int _srcY, int _stride, const MT::ArrayView<uint8> & _srcPixels, const MT::ArrayView<uint8> & _dstBlocks, int _dstBlockOffset)
			: srcPixels(_srcPixels)
			, dstBlocks(_dstBlocks)
		{
				srcX = _srcX;
				srcY = _srcY;
				stride = _stride;
				dstBlockOffset = _dstBlockOffset;
		}

		CompressDxtBlock(CompressDxtBlock&& other)
			: srcPixels(other.srcPixels)
			, dstBlocks(other.dstBlocks)
			, srcX(other.srcX)
			, srcY(other.srcY)
			, stride(other.stride)
			, dstBlockOffset(other.dstBlockOffset)
		{
			other.srcX = -1;
			other.srcY = -1;
			other.stride = -1;
			other.dstBlockOffset = -1;
		}

		~CompressDxtBlock()
		{
			srcX = -1;
			srcY = -1;
			stride = -1;
			dstBlockOffset = -1;
		}

		void Do(MT::FiberContext&)
		{
			// 16 pixels of input
			uint32 pixels[4*4];

			// copy dxt1 block from image
			for (int y = 0; y < 4; y++)
			{
				for (int x = 0; x < 4; x++)
				{
					int posX = srcX + x;
					int posY = srcY + y;

					int index = posY * stride + (posX * 3);

					MT_ASSERT(index >= 0 && ((size_t)(index + 2) < MT_ARRAY_SIZE(EmbeddedImage::lenaColor)), "Invalid index");

					uint8 r = srcPixels[index + 0];
					uint8 g = srcPixels[index + 1];
					uint8 b = srcPixels[index + 2];

					uint32 color = 0xFF000000 | ((b << 16) | (g << 8) | (r));

					pixels[y * 4 + x] = color;
				}
			}

			// compress the 4x4 block using DXT1 compression
			squish::Compress( (squish::u8 *)&pixels[0], &dstBlocks[dstBlockOffset], squish::kDxt1 );
		}
	};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct CompressDxt
	{
		MT_DECLARE_TASK(CompressDxt, MT::StackRequirements::EXTENDED, MT::TaskPriority::NORMAL, MT::Color::Aqua);

		uint32 width;
		uint32 height;
		uint32 stride;

		uint32 blkWidth;
		uint32 blkHeight;

		uint32 passCount;

		MT::ArrayView<uint8> srcPixels;
		MT::ArrayView<uint8> dxtBlocks;
		MT::Atomic32<uint32>* pIsFinished;


		CompressDxt(uint32 _width, uint32 _height, uint32 _stride, const MT::ArrayView<uint8> & _srcPixels, MT::Atomic32<uint32>* _pIsFinished = nullptr, uint32 _passCount = 1)
			: srcPixels(_srcPixels)
			, pIsFinished(_pIsFinished)
		{
			passCount = _passCount;

			width = _width;
			height = _height;
			stride = _stride;

			blkWidth = width >> 2;
			blkHeight = height >> 2;

			int dxtBlocksTotalSizeInBytes = blkWidth * blkHeight * 8; // 8 bytes = 64 bits per block (dxt1)
			dxtBlocks = MT::ArrayView<uint8>( MT::Memory::Alloc( dxtBlocksTotalSizeInBytes ), dxtBlocksTotalSizeInBytes);
		}

		~CompressDxt()
		{
			void* pDxtBlocks = dxtBlocks.GetRawData();
			if (pDxtBlocks)
			{
				MT::Memory::Free(pDxtBlocks);
			}
		}


		void Do(MT::FiberContext& context)
		{
			for(uint32 i = 0; i < passCount; i++)
			{
				// use StaticVector as subtask container. beware stack overflow!
				MT::StaticVector<CompressDxtBlock, 1024> subTasks;

				for (uint32 blkY = 0; blkY < blkHeight; blkY++)
				{
					for (uint32 blkX = 0; blkX < blkWidth; blkX++)
					{
						uint32 blockIndex = blkY * blkWidth + blkX;
						subTasks.PushBack( CompressDxtBlock(blkX * 4, blkY * 4, stride, srcPixels, dxtBlocks, blockIndex * 8) );
					}
				}

				context.RunSubtasksAndYield(MT::TaskGroup::Default(), &subTasks[0], subTasks.Size());
			}


			if (pIsFinished != nullptr)
			{
				pIsFinished->Store(1);
			}
		}
	};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct DecompressDxtBlock
	{
		MT_DECLARE_TASK(DecompressDxtBlock, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Red);

		MT::ArrayView<uint8> srcBlocks;
		MT::ArrayView<uint8> dstPixels;

		int dstX;
		int dstY;

		int stride;
		int srcBlockOffset;

		DecompressDxtBlock(int _dstX, int _dstY, int _stride, const MT::ArrayView<uint8> & _dstPixels, const MT::ArrayView<uint8> & _srcBlocks, int _srcBlockOffset)
			: srcBlocks(_srcBlocks)
			, dstPixels(_dstPixels)
		{
			dstX = _dstX;
			dstY = _dstY;
			stride = _stride;
			srcBlockOffset = _srcBlockOffset;
		}

		DecompressDxtBlock(DecompressDxtBlock&& other)
			: srcBlocks(other.srcBlocks)
			, dstPixels(other.dstPixels)
			, dstX(other.dstX)
			, dstY(other.dstY)
			, stride(other.stride)
			, srcBlockOffset(other.srcBlockOffset)
		{
			other.dstX = -1;
			other.dstY = -1;
			other.stride = -1;
			other.srcBlockOffset = -1;
		}

		~DecompressDxtBlock()
		{
			dstX = -1;
			dstY = -1;
			stride = -1;
			srcBlockOffset = -1;
		}


		void Do(MT::FiberContext&)
		{
			// 16 pixels of output
			uint32 pixels[4*4];

			// copy dxt1 block from image
			for (int y = 0; y < 4; y++)
			{
				for (int x = 0; x < 4; x++)
				{
					squish::Decompress((squish::u8 *)&pixels[0], &srcBlocks[srcBlockOffset], squish::kDxt1);

					int posX = dstX + x;
					int posY = dstY + y;

					int index = posY * stride + (posX * 3);

					uint32 pixel = pixels[y * 4 + x];

					MT_ASSERT(index >= 0 && ((size_t)(index + 2) < MT_ARRAY_SIZE(EmbeddedImage::lenaColor)), "Invalid index");

					dstPixels[index + 0] = (pixel & 0xFF);
					dstPixels[index + 1] = (pixel >> 8 & 0xFF);
					dstPixels[index + 2] = (pixel >> 16 & 0xFF);
				}
			}

		}
	};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct DecompressDxt
	{
		MT_DECLARE_TASK(DecompressDxt, MT::StackRequirements::EXTENDED, MT::TaskPriority::NORMAL, MT::Color::Yellow);

		MT::ArrayView<uint8> dxtBlocks;
		MT::ArrayView<uint8> decompressedImage;

		uint32 blkWidth;
		uint32 blkHeight;


		DecompressDxt(const MT::ArrayView<uint8> & _dxtBlocks, uint32 dxtBlocksCountWidth, uint32 dxtBlocksCountHeight)
			: dxtBlocks(_dxtBlocks)
		{
			blkWidth = dxtBlocksCountWidth;
			blkHeight = dxtBlocksCountHeight;

			// dxt1 block = 16 rgb pixels = 48 bytes
			uint32 bytesCount = blkWidth * blkHeight * 48;
			decompressedImage = MT::ArrayView<uint8>( MT::Memory::Alloc(bytesCount), bytesCount);
		}

		~DecompressDxt()
		{
			void* pDxtBlocks = dxtBlocks.GetRawData();
			if (pDxtBlocks)
			{
				MT::Memory::Free(pDxtBlocks);
			}

			void* pDecompressedImage = decompressedImage.GetRawData();
			if (pDecompressedImage)
			{
				MT::Memory::Free(pDecompressedImage);
			}

		}

		void Do(MT::FiberContext& context)
		{
			// use StaticVector as subtask container. beware stack overflow!
			MT::StaticVector<DecompressDxtBlock, 1024> subTasks;

			int stride = blkWidth * 4 * 3;

			for (uint32 blkY = 0; blkY < blkHeight; blkY++)
			{
				for (uint32 blkX = 0; blkX < blkWidth; blkX++)
				{
					uint32 blockIndex = blkY * blkWidth + blkX;
					subTasks.PushBack( DecompressDxtBlock(blkX * 4, blkY * 4, stride, decompressedImage, dxtBlocks, blockIndex * 8) );
				}
			}

			context.RunSubtasksAndYield(MT::TaskGroup::Default(), &subTasks[0], subTasks.Size());
		}

	};


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Wait(MT::TaskScheduler & scheduler)
	{
		//emulate game loop
		for(;;)
		{
			bool waitDone = scheduler.WaitAll(33);
			if (waitDone)
			{
				break;
			}
		}
	}


/*
	// dxt compressor Hiload test (for profiling purposes)
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	TEST(HiloadDxtTest)
	{
		MT::Atomic32<uint32> isFinished1;
		MT::Atomic32<uint32> isFinished2;

		static_assert(MT_ARRAY_SIZE(EmbeddedImage::lenaColor) == 49152, "Image size is invalid");

		int stride = 384;

		MT::ArrayView<uint8> srcImage((void*)&EmbeddedImage::lenaColor[0], MT_ARRAY_SIZE(EmbeddedImage::lenaColor));

		CompressDxt compressTask1(128, 128, stride, srcImage, &isFinished1);
		MT_ASSERT ((compressTask1.width & 3) == 0 && (compressTask1.height & 3) == 0, "Image size must be a multiple of 4");

		CompressDxt compressTask2(128, 128, stride, srcImage, &isFinished2);
		MT_ASSERT ((compressTask2.width & 3) == 0 && (compressTask2.height & 3) == 0, "Image size must be a multiple of 4");

#ifdef MT_INSTRUMENTED_BUILD
		MT::TaskScheduler scheduler(0, nullptr, GetProfiler());
#else
		MT::TaskScheduler scheduler;
#endif

		int workersCount = (int)scheduler.GetWorkersCount();
		printf("Scheduler started, %d workers\n", workersCount);

		isFinished1.Store(0);
		isFinished2.Store(0);

		printf("HiloadDxtTest\n");
		scheduler.RunAsync(MT::TaskGroup::Default(), &compressTask1, 1);
		scheduler.RunAsync(MT::TaskGroup::Default(), &compressTask2, 1);

		for(;;)
		{
			if (isFinished1.Load() != 0)
			{
				isFinished1.Store(0);
				scheduler.RunAsync(MT::TaskGroup::Default(), &compressTask1, 1);
			}

			if (isFinished2.Load() != 0)
			{
				isFinished2.Store(0);
				scheduler.RunAsync(MT::TaskGroup::Default(), &compressTask2, 1);
			}

			MT::Thread::Sleep(1);
		}
	}
*/


/*
	// dxt compressor stress test (for profiling purposes)
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	TEST(DxtStressTest)
	{
		static_assert(MT_ARRAY_SIZE(EmbeddedImage::lenaColor) == 49152, "Image size is invalid");

		int stride = 384;

		MT::ArrayView<uint8> srcImage((void*)&EmbeddedImage::lenaColor[0], MT_ARRAY_SIZE(EmbeddedImage::lenaColor));

		uint32 passCount = 10;

		CompressDxt compressTask(128, 128, stride, srcImage, nullptr, passCount);
		MT_ASSERT ((compressTask.width & 3) == 0 && (compressTask.height & 3) == 0, "Image size must be a multiple of 4");

#ifdef MT_INSTRUMENTED_BUILD
		MT::TaskScheduler scheduler(0, nullptr, GetProfiler());
#else
		MT::TaskScheduler scheduler;
#endif

		int workersCount = (int)scheduler.GetWorkersCount();
		printf("Scheduler started, %d workers\n", workersCount);

		printf("DxtStressTest\n");
		scheduler.RunAsync(MT::TaskGroup::Default(), &compressTask, 1);

		CHECK(scheduler.WaitAll(10000000));
	}
*/

	// dxt compressor complex test
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	TEST(RunComplexDxtTest)
	{
		static_assert(MT_ARRAY_SIZE(EmbeddedImage::lenaColor) == 49152, "Image size is invalid");

		int stride = 384;

		MT::ArrayView<uint8> srcImage((void*)&EmbeddedImage::lenaColor[0], MT_ARRAY_SIZE(EmbeddedImage::lenaColor));

		CompressDxt compressTask(128, 128, stride, srcImage);
		MT_ASSERT ((compressTask.width & 3) == 0 && (compressTask.height & 3) == 0, "Image size must be a multiple of 4");

		MT::TaskScheduler scheduler;

		int workersCount = (int)scheduler.GetWorkersCount();
		printf("Scheduler started, %d workers\n", workersCount);

		printf("Compress image\n");
		scheduler.RunAsync(MT::TaskGroup::Default(), &compressTask, 1);

		Wait(scheduler);

		DecompressDxt decompressTask(compressTask.dxtBlocks, compressTask.blkWidth, compressTask.blkHeight);
		compressTask.dxtBlocks = MT::ArrayView<uint8>(); //transfer memory ownership to Decompress task

		printf("Decompress image\n");
		scheduler.RunAsync(MT::TaskGroup::Default(), &decompressTask, 1);

		Wait(scheduler);

/*
		//save compressed image
		{
			FILE * file = fopen("lena_dxt1.dds", "w+b");
			fwrite(&EmbeddedImage::ddsHeader[0], MT_ARRAY_SIZE(EmbeddedImage::ddsHeader), 1, file);
			fwrite(decompressTask.dxtBlocks, decompressTask.blkWidth * decompressTask.blkHeight * 8, 1, file);
			fclose(file);
		}

		//save uncompressed image
		{
			FILE * file = fopen("lena_rgb.raw", "w+b");
			fwrite(decompressTask.decompressedImage, decompressTask.blkWidth * decompressTask.blkHeight * 48, 1, file);
			fclose(file);
		}
*/

		printf("Compare images\n");
		bool imagesEqual = CompareImagesPSNR(&srcImage[0], &decompressTask.decompressedImage[0], MT_ARRAY_SIZE(EmbeddedImage::lenaColor), 8.0);
		CHECK_EQUAL(true, imagesEqual);

/*
#ifdef MT_INSTRUMENTED_BUILD
		// waiting for profiler attach
		printf("Press any key to continue\n");
		while(true)
		{
			if (_kbhit() != 0)
			{
				break;
			}
		}
#endif
*/
	}


}

```

`SchedulerTests/Tests/FiberTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>

#ifdef MT_THREAD_SANITIZER
	#define SMALLEST_STACK_SIZE (566656)
#else
	#define SMALLEST_STACK_SIZE (32768)
#endif

int64 startTime = 0;
int64 endTime = 0;


SUITE(FiberTests)
{
	MT::Atomic32<int32> counter(0);
	MT::Fiber* fiberMain = nullptr;

	void FiberFunc( void* userData )
	{
		CHECK_EQUAL(0, counter.Load());
		counter.IncFetch();

		MT::Fiber* currentFiber = (MT::Fiber*)userData;
		MT::Fiber::SwitchTo(*currentFiber, *fiberMain);

		CHECK_EQUAL(2, counter.Load());
		counter.IncFetch();

		MT::Fiber::SwitchTo(*currentFiber, *fiberMain);
	}

	void FiberMain(void* userData)
	{
		endTime = MT::GetTimeMicroSeconds();
		uint32 microsecondsFromThreadToFiber = (uint32)(endTime - startTime);
		printf("%d us to convert from thread to fiber\n", microsecondsFromThreadToFiber);

		MT_UNUSED(userData);

		MT::Fiber fiber1;

		fiber1.Create(SMALLEST_STACK_SIZE, FiberFunc, &fiber1);

		MT::Fiber::SwitchTo(*fiberMain, fiber1);

		CHECK_EQUAL(1, counter.Load());
		counter.IncFetch();

		MT::Fiber::SwitchTo(*fiberMain, fiber1);

		CHECK_EQUAL(3, counter.Load());

		fiberMain = nullptr;
        
        printf("FiberMain - done\n");
	}



TEST(FiberSimpleTest)
{
	// Two fibers from same thread
	MT::Fiber fiber1;
	fiberMain = &fiber1;
	counter.Store(0);
	startTime = MT::GetTimeMicroSeconds();
	fiberMain->CreateFromCurrentThreadAndRun(FiberMain, nullptr);

	// CreateFromCurrentThreadAndRun from same fiber called twice for same fiber
	fiberMain = &fiber1;
	counter.Store(0);
	startTime = MT::GetTimeMicroSeconds();
	fiberMain->CreateFromCurrentThreadAndRun(FiberMain, nullptr);


	MT::Fiber fiber2;
	fiberMain = &fiber2;
	counter.Store(0);
	startTime = MT::GetTimeMicroSeconds();
	fiberMain->CreateFromCurrentThreadAndRun(FiberMain, nullptr);
    
    printf("Fiber test done\n");
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`SchedulerTests/Tests/FireAndForget.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>



SUITE(FireAndForget)
{

struct SimpleTask;

typedef MT::TaskPool<SimpleTask, 512> TestPoolType;

struct SimpleTask
{
	MT_DECLARE_TASK(SimpleTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	MT::Atomic32<int32>* doCounter;
	MT::Atomic32<int32>* dtorCounter;
	TestPoolType* taskPool;

	SimpleTask()
		: doCounter(nullptr)
		, dtorCounter(nullptr)
		, taskPool(nullptr)
	{
	}

	SimpleTask(MT::Atomic32<int32>* _doCounter, MT::Atomic32<int32>* _dtorCounter, TestPoolType * _taskPool)
		: doCounter(_doCounter)
		, dtorCounter(_dtorCounter)
		, taskPool(_taskPool)
	{
	}

	SimpleTask(SimpleTask&& other)
		: doCounter(other.doCounter)
		, dtorCounter(other.dtorCounter)
		, taskPool(other.taskPool)
	{
		other.doCounter = nullptr;
		other.dtorCounter = nullptr;
		other.taskPool = nullptr;
	}

	~SimpleTask()
	{
		if (dtorCounter)
		{
			dtorCounter->IncFetch();
		}
	}

	void Do(MT::FiberContext& context)
	{
		if (doCounter)
		{
			doCounter->IncFetch();
		}

		if (taskPool)
		{
			MT::TaskHandle handle = taskPool->Alloc(SimpleTask(doCounter, dtorCounter, nullptr));

			context.RunSubtasksAndYield(MT::TaskGroup::Default(), &handle, 1);
		}
	}
};



TEST(SingleThreadPoolTest)
{
	MT::TaskPool<SimpleTask, 4> taskPool;

	MT::TaskHandle taskHandle0 = taskPool.Alloc(SimpleTask());
	CHECK_EQUAL(true, taskHandle0.IsValid());

	MT::TaskHandle taskHandle1 = taskPool.Alloc(SimpleTask());
	CHECK_EQUAL(true, taskHandle1.IsValid());

	MT::TaskHandle taskHandle2 = taskPool.Alloc(SimpleTask());
	CHECK_EQUAL(true, taskHandle2.IsValid());

	MT::TaskHandle taskHandle3 = taskPool.Alloc(SimpleTask());
	CHECK_EQUAL(true, taskHandle3.IsValid());

	CHECK_EQUAL(true, taskHandle0.IsValid());
	CHECK_EQUAL(true, taskHandle1.IsValid());
	CHECK_EQUAL(true, taskHandle2.IsValid());
	CHECK_EQUAL(true, taskHandle3.IsValid());


	// check for allocation fail
	MT::TaskHandle taskHandle4 = taskPool.TryAlloc(SimpleTask());
	CHECK_EQUAL(false, taskHandle4.IsValid());


	// check state
	CHECK_EQUAL(true, taskHandle0.IsValid());
	CHECK_EQUAL(true, taskHandle1.IsValid());
	CHECK_EQUAL(true, taskHandle2.IsValid());
	CHECK_EQUAL(true, taskHandle3.IsValid());
	CHECK_EQUAL(false, taskHandle4.IsValid());

	// destroy pool task by handle
	CHECK_EQUAL(true, MT::PoolElementHeader::DestoryByHandle(taskHandle0));
	CHECK_EQUAL(true, MT::PoolElementHeader::DestoryByHandle(taskHandle1));
	CHECK_EQUAL(true, MT::PoolElementHeader::DestoryByHandle(taskHandle2));
	CHECK_EQUAL(true, MT::PoolElementHeader::DestoryByHandle(taskHandle3));
	CHECK_EQUAL(false, MT::PoolElementHeader::DestoryByHandle(taskHandle4));

	// check for double destroy
	CHECK_EQUAL(false, MT::PoolElementHeader::DestoryByHandle(taskHandle0));
	CHECK_EQUAL(false, MT::PoolElementHeader::DestoryByHandle(taskHandle3));

	MT::TaskHandle taskHandle5 = taskPool.Alloc(SimpleTask());

	CHECK_EQUAL(false, taskHandle0.IsValid());
	CHECK_EQUAL(false, taskHandle1.IsValid());
	CHECK_EQUAL(false, taskHandle2.IsValid());
	CHECK_EQUAL(false, taskHandle3.IsValid());
	CHECK_EQUAL(false, taskHandle4.IsValid());
	CHECK_EQUAL(true, taskHandle5.IsValid());
}


struct ThreadTest
{
	MT_DECLARE_TASK(ThreadTest, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	TestPoolType * taskPool;

	void Do(MT::FiberContext&)
	{
		for (int i = 0; i < 20000; i++)
		{
			MT::TaskHandle handle = taskPool->TryAlloc(SimpleTask());
			if (handle.IsValid())
			{
				CHECK_EQUAL(true, MT::PoolElementHeader::DestoryByHandle(handle));
			} else
			{
				CHECK_EQUAL(false, MT::PoolElementHeader::DestoryByHandle(handle));
			}
		}
	}
};


TEST(MultiThreadPoolTest)
{
	TestPoolType taskPool;

	MT::TaskScheduler scheduler;

	ThreadTest tasks[8];
	for (size_t i = 0; i < MT_ARRAY_SIZE(tasks); ++i)
	{
		tasks[i].taskPool = &taskPool;
	}

	scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));

	int timeout = 20000;
	CHECK(scheduler.WaitGroup(MT::TaskGroup::Default(), timeout));
}


//
TEST(FireAndForgetSimple)
{
	MT::Atomic32<int32> doCounter(0);
	MT::Atomic32<int32> dtorCounter(0);

	MT::TaskScheduler scheduler;
	TestPoolType taskPool;

	for(int pass = 0; pass < 4; pass++)
	{
		printf("--- step %d ---\n", pass);

		doCounter.Store(0);
		dtorCounter.Store(0);

		MT::TaskHandle taskHandles[250];
		for (size_t i = 0; i < MT_ARRAY_SIZE(taskHandles); ++i)
		{
			taskHandles[i] = taskPool.Alloc(SimpleTask(&doCounter, &dtorCounter, &taskPool));
			CHECK_EQUAL(true, taskHandles[i].IsValid());
		}

		scheduler.RunAsync(MT::TaskGroup::Default(), &taskHandles[0], MT_ARRAY_SIZE(taskHandles));

		int timeout = 20000;
		CHECK(scheduler.WaitAll(timeout));

		CHECK_EQUAL(MT_ARRAY_SIZE(taskHandles) * 2, (size_t)doCounter.Load());
		CHECK_EQUAL(MT_ARRAY_SIZE(taskHandles) * 2, (size_t)dtorCounter.Load());
	}

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`SchedulerTests/Tests/FoundationTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>
#include <MTQueueMPMC.h>
#include <MTConcurrentRingBuffer.h>
#include <MTArrayView.h>
#include <MTStaticVector.h>

SUITE(FoundationTests)
{


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST(RingBufferTest)
{
	MT::ConcurrentRingBuffer<int, 32> ringBuffer;

	ringBuffer.Push(-1);
	ringBuffer.Push(1);

	int tempData[32];
	size_t elementsCount = ringBuffer.PopAll(tempData, MT_ARRAY_SIZE(tempData));
	CHECK_EQUAL(elementsCount, (size_t)2);

	CHECK_EQUAL(tempData[0], -1);
	CHECK_EQUAL(tempData[1], 1);

	int j;
	for(j = 0; j < 507; j++)
	{
		ringBuffer.Push(3 + j);
	}

	elementsCount = ringBuffer.PopAll(tempData, MT_ARRAY_SIZE(tempData));
	CHECK_EQUAL(elementsCount, (size_t)32);

	size_t i;
	for(i = 0; i < elementsCount; i++)
	{
		CHECK_EQUAL(tempData[i], (int)((507+3-32) + i));
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST(StackArrayTest)
{
	const int elementsCount = 128;

	MT::StaticVector<int, elementsCount> stackArray;

	CHECK(stackArray.IsEmpty() == true);

	stackArray.PushBack(200);
	CHECK(stackArray.IsEmpty() == false);
	CHECK_EQUAL(stackArray.Size(), (size_t)1);

	for(int i = 1; i < elementsCount; i++)
	{
		stackArray.PushBack(200 + i);
	}

	CHECK(stackArray.IsEmpty() == false);
	CHECK_EQUAL(stackArray.Size(), (size_t)elementsCount);

	for(int i = 0; i < elementsCount; i++)
	{
		CHECK_EQUAL(stackArray[i], (200 + i));
	}

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST(QueueMPMC_BasicTest)
{
	MT::LockFreeQueueMPMC<int, 32> queue;

	for(int i = 0; i < 64; i++)
	{
		bool res = queue.TryPush( std::move(77 + i) );
		if (i < 32)
		{
			CHECK_EQUAL(true, res);
		} else
		{
			CHECK_EQUAL(false, res);
		}
	}

	for(int i = 0; i < 64; i++)
	{
		int val;
		bool res = queue.TryPop(val);
		if (i < 32)
		{
			CHECK_EQUAL(true, res);
			CHECK_EQUAL(77 + i, val);
		} else
		{
			CHECK_EQUAL(false, res);
		}
	}


	CHECK_EQUAL(true, queue.TryPush( 113 ));
	CHECK_EQUAL(true, queue.TryPush( 114 ));
	CHECK_EQUAL(true, queue.TryPush( 115 ));

	int v;
	CHECK_EQUAL(true, queue.TryPop(v));
	CHECK_EQUAL(113, v);

	CHECK_EQUAL(true, queue.TryPush( 116 ));
	CHECK_EQUAL(true, queue.TryPush( 117 ));
	CHECK_EQUAL(true, queue.TryPush( 118 ));

	CHECK_EQUAL(true, queue.TryPop(v));
	CHECK_EQUAL(114, v);
	CHECK_EQUAL(true, queue.TryPop(v));
	CHECK_EQUAL(115, v);
	CHECK_EQUAL(true, queue.TryPop(v));
	CHECK_EQUAL(116, v);
	CHECK_EQUAL(true, queue.TryPop(v));
	CHECK_EQUAL(117, v);
	CHECK_EQUAL(true, queue.TryPop(v));
	CHECK_EQUAL(118, v);

	v = -133;
	CHECK_EQUAL(false, queue.TryPop(v));
	CHECK_EQUAL(-133, v);

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST(ArrayViewTest)
{

	MT::ArrayView<int> emptyArrayView(nullptr, 0);
	CHECK(emptyArrayView.IsEmpty() == true);

	const int elementsCount = 128;
	void* rawMemory = MT::Memory::Alloc(sizeof(int) * elementsCount);

	MT::ArrayView<int> arrayView(rawMemory, elementsCount);
	CHECK(arrayView.IsEmpty() == false);

	for (int i = 0; i < elementsCount; i++)
	{
		arrayView[i] = (100 + i);
	}
	
	const int* buffer = static_cast<const int*>(rawMemory);
	for (int i = 0; i < elementsCount; i++)
	{
		CHECK_EQUAL(buffer[i], arrayView[i]);
	}

	MT::Memory::Free(rawMemory);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

```

`SchedulerTests/Tests/GroupTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>
#include <math.h> // for sin/cos

SUITE(GroupTests)
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace SimpleWaitFromSubtask
{
	MT::Atomic32<int32> subtaskCount(0);
	MT::Atomic32<int32> animTaskCount(0);
	MT::Atomic32<int32> physTaskCount(0);


	struct DummySubTask
	{
		MT_DECLARE_TASK(DummySubTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		float tempData[64];

		void Do(MT::FiberContext& )
		{
			for (size_t i = 0; i < MT_ARRAY_SIZE(tempData); i++)
			{
				tempData[i] = cos((float)rand() / RAND_MAX) + sin((float)rand() / RAND_MAX);
			}

			subtaskCount.IncFetch();
		}
	};


	struct DummyAnimTask
	{
		MT_DECLARE_TASK(DummyAnimTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		float tempData[128];

		void Do(MT::FiberContext& ctx)
		{
			for (size_t i = 0; i < MT_ARRAY_SIZE(tempData); i++)
			{
				tempData[i] = cos((float)rand() / RAND_MAX);
			}

			DummySubTask subtasks[16];
			ctx.RunSubtasksAndYield(MT::TaskGroup::Default(), &subtasks[0], MT_ARRAY_SIZE(subtasks));

			animTaskCount.IncFetch();
		}
	};


	struct DummyPhysicTask
	{
		MT_DECLARE_TASK(DummyPhysicTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		float tempData[128];

		void Do(MT::FiberContext& ctx)
		{
			for (size_t i = 0; i < MT_ARRAY_SIZE(tempData); i++)
			{
				tempData[i] = sin((float)rand() / RAND_MAX);
			}

			DummySubTask subtasks[8];
			ctx.RunSubtasksAndYield(MT::TaskGroup::Default(), &subtasks[0], MT_ARRAY_SIZE(subtasks));

			physTaskCount.IncFetch();
		}
	};



	TEST(RunGroupTests)
	{
		static uint32 waitTime = 50000;

		subtaskCount.Store(0);
		animTaskCount.Store(0);
		physTaskCount.Store(0);

		MT::TaskScheduler scheduler;

		MT::TaskGroup groupEmpty = scheduler.CreateGroup();
		MT::TaskGroup groupAnim = scheduler.CreateGroup();


		bool emptyWaitRes0 = scheduler.WaitGroup(groupEmpty, 200);
		CHECK(emptyWaitRes0 == true);

		DummyAnimTask dummyAnim[4];
		scheduler.RunAsync(groupAnim, &dummyAnim[0], MT_ARRAY_SIZE(dummyAnim));

		MT::TaskGroup groupPhysic = scheduler.CreateGroup();
		DummyPhysicTask dummyPhysic[4];
		scheduler.RunAsync(groupPhysic, &dummyPhysic[0], MT_ARRAY_SIZE(dummyPhysic));

		bool emptyWaitRes1 = scheduler.WaitGroup(groupEmpty, 20);
		CHECK(emptyWaitRes1 == true);

		CHECK(scheduler.WaitGroup(groupAnim, waitTime));

		bool emptyWaitRes2 = scheduler.WaitGroup(groupEmpty, 200);
		CHECK(emptyWaitRes2 == true);


		CHECK_EQUAL(4, animTaskCount.Load());
		CHECK(subtaskCount.Load() >= 4 * 16);


		CHECK(scheduler.WaitGroup(groupPhysic, waitTime));

		CHECK_EQUAL(4, animTaskCount.Load());
		CHECK_EQUAL(4, physTaskCount.Load());
		CHECK_EQUAL(96, subtaskCount.Load());
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}


```

`SchedulerTests/Tests/LenaDxt/HeaderDDS.h`:

```h
/* Contents of file dds_header */
const unsigned char ddsHeader[128] = {
	0x44, 0x44, 0x53, 0x20, 0x7C, 0x00, 0x00, 0x00, 0x07, 0x10, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x44, 0x58, 0x54, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


```

`SchedulerTests/Tests/LenaDxt/LenaColor.h`:

```h

/* Contents of file lena_color */
const unsigned char lenaColor[49152] = {
	0xDF, 0x85, 0x7B, 0xDF, 0x84, 0x79, 0xDF, 0x85, 0x79, 0xDC, 0x80, 0x73, 0xDD, 0x81, 0x6F, 0xDE,
	0x7E, 0x69, 0xDA, 0x7A, 0x69, 0xDC, 0x7D, 0x6A, 0xE0, 0x80, 0x6C, 0xE0, 0x86, 0x71, 0xE5, 0x8D,
	0x72, 0xE6, 0x94, 0x77, 0xE7, 0x92, 0x70, 0xE5, 0x89, 0x6E, 0xDA, 0x75, 0x70, 0xBB, 0x50, 0x5E,
	0x9A, 0x39, 0x4F, 0x9B, 0x3F, 0x54, 0xA5, 0x43, 0x54, 0xAA, 0x43, 0x53, 0xAF, 0x46, 0x50, 0xAD,
	0x47, 0x53, 0xB1, 0x44, 0x54, 0xB3, 0x44, 0x52, 0xAE, 0x46, 0x52, 0xAD, 0x48, 0x4E, 0xB7, 0x4F,
	0x52, 0xBC, 0x4F, 0x54, 0xC2, 0x55, 0x55, 0xC4, 0x58, 0x57, 0xC8, 0x59, 0x58, 0xC9, 0x5D, 0x5A,
	0xCC, 0x61, 0x5C, 0xC7, 0x61, 0x61, 0xCA, 0x63, 0x5F, 0xCC, 0x61, 0x5C, 0xC9, 0x5F, 0x5B, 0xC9,
	0x5F, 0x5A, 0xC7, 0x5E, 0x5C, 0xC9, 0x62, 0x62, 0xCB, 0x61, 0x5C, 0xCF, 0x62, 0x5C, 0xD2, 0x63,
	0x5C, 0xCE, 0x63, 0x5D, 0xCD, 0x63, 0x5E, 0xCE, 0x62, 0x5C, 0xCB, 0x63, 0x5D, 0xC9, 0x62, 0x5E,
	0xCE, 0x62, 0x5D, 0xD4, 0x65, 0x5F, 0xD1, 0x65, 0x5E, 0xCC, 0x65, 0x62, 0xC7, 0x66, 0x66, 0xC7,
	0x60, 0x5F, 0xC9, 0x61, 0x5B, 0xCA, 0x61, 0x5D, 0xC7, 0x63, 0x63, 0xC9, 0x63, 0x62, 0xCD, 0x61,
	0x5F, 0xCE, 0x60, 0x5B, 0xD0, 0x64, 0x5C, 0xD1, 0x64, 0x5C, 0xCC, 0x60, 0x5B, 0xCD, 0x64, 0x64,
	0xCF, 0x68, 0x65, 0xC8, 0x5F, 0x5B, 0xC8, 0x60, 0x5E, 0xC9, 0x60, 0x5E, 0xC9, 0x5F, 0x5C, 0xC9,
	0x60, 0x62, 0xC8, 0x5F, 0x5E, 0xC6, 0x5E, 0x5E, 0xC7, 0x60, 0x5F, 0xC8, 0x5F, 0x5E, 0xC7, 0x5D,
	0x5C, 0xC2, 0x5D, 0x5D, 0xBE, 0x57, 0x5F, 0xBD, 0x55, 0x5E, 0xB2, 0x50, 0x57, 0xAC, 0x45, 0x4F,
	0xB6, 0x4A, 0x51, 0xCF, 0x63, 0x5B, 0xD8, 0x75, 0x68, 0xD9, 0x7D, 0x6C, 0xDD, 0x86, 0x6E, 0xD8,
	0x81, 0x6D, 0xDA, 0x78, 0x65, 0xDB, 0x7A, 0x67, 0xD9, 0x7B, 0x6B, 0xDB, 0x7E, 0x6E, 0xDE, 0x82,
	0x6E, 0xDC, 0x7B, 0x67, 0xDC, 0x7A, 0x66, 0xDD, 0x79, 0x64, 0xDE, 0x7B, 0x66, 0xDD, 0x7A, 0x62,
	0xDC, 0x7C, 0x67, 0xDC, 0x7D, 0x6A, 0xDB, 0x7E, 0x6C, 0xD8, 0x78, 0x6A, 0xE0, 0x87, 0x69, 0xF1,
	0xBD, 0x83, 0xF3, 0xCF, 0x98, 0xF3, 0xD1, 0xA5, 0xF6, 0xCE, 0x98, 0xD1, 0x85, 0x6F, 0xA1, 0x41,
	0x52, 0xA9, 0x46, 0x52, 0xB8, 0x54, 0x58, 0xBA, 0x57, 0x5C, 0xBB, 0x58, 0x5A, 0xBA, 0x59, 0x5B,
	0xBA, 0x5C, 0x5E, 0xBA, 0x58, 0x5E, 0xBD, 0x56, 0x58, 0xC0, 0x57, 0x56, 0xC2, 0x59, 0x5B, 0xBF,
	0x5C, 0x5F, 0xC0, 0x5D, 0x5E, 0xBF, 0x55, 0x59, 0xBF, 0x5A, 0x5E, 0xC2, 0x5D, 0x5F, 0xC2, 0x5E,
	0x5E, 0xBD, 0x58, 0x5C, 0xB7, 0x4F, 0x57, 0xBF, 0x57, 0x5C, 0xE6, 0x8B, 0x7A, 0xE2, 0x87, 0x70,
	0xDF, 0x83, 0x74, 0xDF, 0x81, 0x73, 0xE0, 0x83, 0x71, 0xDE, 0x7E, 0x6B, 0xDF, 0x7D, 0x6A, 0xDE,
	0x7C, 0x66, 0xDC, 0x7A, 0x68, 0xDC, 0x7B, 0x69, 0xDE, 0x7C, 0x69, 0xE0, 0x84, 0x6D, 0xE6, 0x8F,
	0x72, 0xE8, 0x94, 0x75, 0xE9, 0x93, 0x70, 0xE5, 0x88, 0x6C, 0xD8, 0x6F, 0x66, 0xBC, 0x4E, 0x59,
	0x9D, 0x39, 0x4E, 0x9B, 0x39, 0x4F, 0xA6, 0x3F, 0x51, 0xAD, 0x44, 0x52, 0xAF, 0x44, 0x4E, 0xAE,
	0x43, 0x4E, 0xAF, 0x43, 0x50, 0xB2, 0x43, 0x4E, 0xB0, 0x44, 0x4E, 0xAE, 0x46, 0x4F, 0xB4, 0x4B,
	0x52, 0xBC, 0x50, 0x55, 0xC4, 0x54, 0x56, 0xC6, 0x59, 0x56, 0xC7, 0x58, 0x55, 0xC8, 0x5A, 0x57,
	0xCA, 0x5F, 0x5C, 0xC9, 0x60, 0x5E, 0xCA, 0x61, 0x5D, 0xCA, 0x5F, 0x5C, 0xCB, 0x5F, 0x5C, 0xCB,
	0x60, 0x5B, 0xCA, 0x5F, 0x5B, 0xCC, 0x61, 0x5F, 0xCD, 0x62, 0x5E, 0xCF, 0x63, 0x5D, 0xD1, 0x63,
	0x5C, 0xD0, 0x63, 0x5D, 0xCF, 0x62, 0x5C, 0xCF, 0x61, 0x5C, 0xCB, 0x60, 0x5D, 0xCC, 0x61, 0x5D,
	0xCE, 0x62, 0x5D, 0xCE, 0x63, 0x5F, 0xCF, 0x63, 0x5D, 0xCA, 0x62, 0x61, 0xC7, 0x65, 0x65, 0xC8,
	0x61, 0x61, 0xC9, 0x5F, 0x5B, 0xCB, 0x5F, 0x5B, 0xC9, 0x62, 0x61, 0xC9, 0x62, 0x60, 0xCA, 0x5E,
	0x5A, 0xCB, 0x5F, 0x5A, 0xCD, 0x62, 0x5D, 0xCE, 0x61, 0x5C, 0xCD, 0x5E, 0x5A, 0xCD, 0x61, 0x5F,
	0xCE, 0x64, 0x61, 0xC9, 0x5F, 0x5B, 0xC8, 0x5E, 0x5B, 0xC8, 0x5E, 0x5E, 0xC8, 0x5E, 0x5D, 0xC7,
	0x5E, 0x5D, 0xC7, 0x5C, 0x5C, 0xC7, 0x5E, 0x5E, 0xC9, 0x5F, 0x5E, 0xC8, 0x5E, 0x5D, 0xC7, 0x5D,
	0x5D, 0xC5, 0x5B, 0x5B, 0xC0, 0x58, 0x5B, 0xBB, 0x56, 0x5D, 0xB3, 0x4E, 0x56, 0xAB, 0x45, 0x4F,
	0xB3, 0x49, 0x4F, 0xCA, 0x5F, 0x5B, 0xD5, 0x70, 0x68, 0xD9, 0x7A, 0x6D, 0xDB, 0x83, 0x71, 0xDB,
	0x81, 0x6D, 0xDB, 0x79, 0x66, 0xDA, 0x79, 0x66, 0xDB, 0x7A, 0x69, 0xDA, 0x7B, 0x6A, 0xDE, 0x7D,
	0x6A, 0xDE, 0x7C, 0x66, 0xDD, 0x7A, 0x64, 0xDD, 0x7A, 0x64, 0xDD, 0x7B, 0x67, 0xDD, 0x7A, 0x63,
	0xDD, 0x7B, 0x65, 0xDB, 0x7C, 0x6A, 0xDB, 0x7E, 0x6C, 0xDA, 0x79, 0x68, 0xDD, 0x7E, 0x68, 0xEE,
	0xB2, 0x7E, 0xF3, 0xCE, 0x95, 0xF2, 0xD0, 0xA3, 0xF6, 0xD1, 0x9A, 0xDE, 0x9D, 0x78, 0xA7, 0x4A,
	0x56, 0xA4, 0x43, 0x53, 0xB6, 0x52, 0x58, 0xBC, 0x56, 0x58, 0xBC, 0x57, 0x59, 0xBB, 0x58, 0x5B,
	0xBA, 0x5B, 0x5D, 0xBA, 0x59, 0x5D, 0xBB, 0x58, 0x59, 0xC0, 0x59, 0x58, 0xC2, 0x5B, 0x5B, 0xC0,
	0x5A, 0x5B, 0xC0, 0x5A, 0x5B, 0xC0, 0x57, 0x59, 0xC0, 0x59, 0x5B, 0xC5, 0x5C, 0x5D, 0xC4, 0x5D,
	0x5C, 0xC0, 0x5A, 0x5A, 0xBF, 0x56, 0x59, 0xC7, 0x5D, 0x5D, 0xC1, 0x60, 0x60, 0x99, 0x44, 0x53,
	0xE0, 0x7F, 0x6A, 0xDF, 0x7F, 0x6C, 0xE0, 0x81, 0x6B, 0xE0, 0x7F, 0x68, 0xE0, 0x7F, 0x69, 0xDE,
	0x7C, 0x67, 0xDE, 0x79, 0x66, 0xDE, 0x7A, 0x65, 0xDE, 0x7D, 0x66, 0xE4, 0x89, 0x6C, 0xE9, 0x8F,
	0x6F, 0xE9, 0x91, 0x6F, 0xEA, 0x91, 0x6E, 0xE5, 0x83, 0x66, 0xD7, 0x68, 0x5B, 0xBD, 0x4C, 0x52,
	0x9E, 0x37, 0x4B, 0x9B, 0x35, 0x4A, 0xA8, 0x3D, 0x4C, 0xAF, 0x41, 0x4D, 0xB1, 0x42, 0x4B, 0xB0,
	0x43, 0x4D, 0xB0, 0x43, 0x4D, 0xB1, 0x42, 0x4A, 0xAF, 0x41, 0x4B, 0xAF, 0x45, 0x4F, 0xB4, 0x49,
	0x51, 0xBB, 0x4F, 0x54, 0xC2, 0x55, 0x57, 0xC4, 0x58, 0x57, 0xC7, 0x57, 0x54, 0xC9, 0x59, 0x56,
	0xCA, 0x5B, 0x58, 0xCA, 0x5D, 0x59, 0xCA, 0x5E, 0x5A, 0xC9, 0x5F, 0x5D, 0xCD, 0x60, 0x5D, 0xCC,
	0x60, 0x5B, 0xCB, 0x5F, 0x59, 0xCE, 0x5F, 0x59, 0xCE, 0x5E, 0x5B, 0xCE, 0x62, 0x5D, 0xD1, 0x62,
	0x5C, 0xD1, 0x62, 0x5C, 0xD0, 0x61, 0x5C, 0xCE, 0x5F, 0x5C, 0xCD, 0x5F, 0x5E, 0xD0, 0x61, 0x5D,
	0xCE, 0x61, 0x5C, 0xCB, 0x60, 0x5D, 0xCD, 0x60, 0x5D, 0xCB, 0x5E, 0x5D, 0xCC, 0x61, 0x5E, 0xCB,
	0x61, 0x5F, 0xC9, 0x5D, 0x5B, 0xC9, 0x5C, 0x59, 0xC9, 0x60, 0x5F, 0xCA, 0x61, 0x5D, 0xC9, 0x5D,
	0x57, 0xCA, 0x5F, 0x5B, 0xCC, 0x61, 0x5D, 0xCD, 0x60, 0x5C, 0xCC, 0x5E, 0x5B, 0xCC, 0x5D, 0x5A,
	0xCB, 0x5E, 0x5C, 0xCC, 0x60, 0x5B, 0xCA, 0x5F, 0x5C, 0xC8, 0x5E, 0x5C, 0xC8, 0x5D, 0x59, 0xC8,
	0x5C, 0x5A, 0xC8, 0x5C, 0x5B, 0xC8, 0x5C, 0x5C, 0xC7, 0x5B, 0x5B, 0xC8, 0x5D, 0x59, 0xC7, 0x5E,
	0x5B, 0xC7, 0x5C, 0x5B, 0xC3, 0x58, 0x5A, 0xBA, 0x55, 0x5C, 0xB8, 0x4E, 0x57, 0xB0, 0x48, 0x51,
	0xAB, 0x44, 0x4F, 0xB8, 0x51, 0x58, 0xCE, 0x67, 0x65, 0xD8, 0x75, 0x6C, 0xDB, 0x7F, 0x71, 0xDF,
	0x82, 0x71, 0xDD, 0x7C, 0x6B, 0xDC, 0x7A, 0x68, 0xDF, 0x7C, 0x68, 0xDF, 0x7F, 0x68, 0xE0, 0x7F,
	0x68, 0xE0, 0x7F, 0x68, 0xDF, 0x7C, 0x65, 0xDE, 0x7A, 0x64, 0xDE, 0x7C, 0x67, 0xDE, 0x7B, 0x66,
	0xDD, 0x7A, 0x64, 0xDA, 0x7B, 0x68, 0xDA, 0x7C, 0x6C, 0xDB, 0x7B, 0x67, 0xD9, 0x75, 0x65, 0xE2,
	0x8F, 0x70, 0xF1, 0xC1, 0x8A, 0xF2, 0xCE, 0x9B, 0xF4, 0xD0, 0x9B, 0xF4, 0xC5, 0x8C, 0xC7, 0x75,
	0x67, 0xA2, 0x3E, 0x4F, 0xAE, 0x4A, 0x54, 0xB8, 0x51, 0x56, 0xBB, 0x55, 0x58, 0xBA, 0x57, 0x5B,
	0xBB, 0x57, 0x5A, 0xBB, 0x59, 0x5B, 0xBC, 0x57, 0x5A, 0xBE, 0x58, 0x5A, 0xBF, 0x5A, 0x5A, 0xC0,
	0x58, 0x59, 0xC3, 0x58, 0x58, 0xC3, 0x59, 0x58, 0xC2, 0x5A, 0x5A, 0xC6, 0x5B, 0x5A, 0xC5, 0x5B,
	0x5B, 0xCA, 0x62, 0x5F, 0xCF, 0x63, 0x5E, 0xA9, 0x45, 0x4F, 0x67, 0x16, 0x3C, 0x4E, 0x09, 0x39,
	0xDF, 0x7F, 0x6B, 0xDF, 0x7E, 0x68, 0xE0, 0x7E, 0x66, 0xE0, 0x81, 0x6B, 0xDF, 0x81, 0x6C, 0xE0,
	0x7D, 0x66, 0xDE, 0x7A, 0x65, 0xDF, 0x7D, 0x67, 0xE2, 0x85, 0x6B, 0xE6, 0x8E, 0x6F, 0xE7, 0x90,
	0x71, 0xE8, 0x8E, 0x6F, 0xE8, 0x8B, 0x6C, 0xE2, 0x7F, 0x66, 0xD7, 0x67, 0x5A, 0xBC, 0x4B, 0x50,
	0x9D, 0x37, 0x4A, 0x9C, 0x36, 0x48, 0xA8, 0x3D, 0x4B, 0xAF, 0x41, 0x4C, 0xB3, 0x44, 0x4D, 0xB1,
	0x47, 0x4F, 0xB0, 0x44, 0x4D, 0xB0, 0x42, 0x4B, 0xAF, 0x41, 0x49, 0xB1, 0x43, 0x4B, 0xB6, 0x4A,
	0x50, 0xBA, 0x4D, 0x52, 0xC1, 0x52, 0x54, 0xC4, 0x57, 0x5A, 0xC7, 0x58, 0x56, 0xCA, 0x5A, 0x55,
	0xCB, 0x5B, 0x55, 0xC9, 0x5C, 0x58, 0xCC, 0x5D, 0x59, 0xCB, 0x60, 0x5C, 0xCD, 0x60, 0x5B, 0xCD,
	0x5E, 0x5B, 0xCC, 0x5D, 0x5A, 0xCD, 0x5F, 0x59, 0xCE, 0x5F, 0x5C, 0xCF, 0x60, 0x5C, 0xD1, 0x62,
	0x5B, 0xD2, 0x62, 0x5D, 0xD0, 0x60, 0x5C, 0xCD, 0x5F, 0x5D, 0xCF, 0x60, 0x5D, 0xD0, 0x60, 0x5A,
	0xD0, 0x5E, 0x5B, 0xCD, 0x60, 0x5E, 0xCD, 0x60, 0x5D, 0xCE, 0x60, 0x5C, 0xCE, 0x60, 0x5C, 0xCD,
	0x5F, 0x5C, 0xCC, 0x5E, 0x5B, 0xCD, 0x5D, 0x58, 0xCB, 0x5F, 0x5B, 0xCC, 0x5F, 0x5B, 0xCB, 0x5E,
	0x59, 0xCD, 0x60, 0x5B, 0xD0, 0x63, 0x5C, 0xD0, 0x64, 0x5E, 0xCD, 0x60, 0x5C, 0xCC, 0x5E, 0x5A,
	0xC9, 0x5E, 0x5C, 0xCC, 0x60, 0x5C, 0xCC, 0x60, 0x5E, 0xC9, 0x5E, 0x5B, 0xC9, 0x5D, 0x59, 0xC8,
	0x5C, 0x5A, 0xC9, 0x5C, 0x5B, 0xC9, 0x5D, 0x5C, 0xC5, 0x5A, 0x59, 0xC8, 0x5D, 0x5B, 0xC9, 0x5F,
	0x5D, 0xC7, 0x5E, 0x5E, 0xC4, 0x5A, 0x5C, 0xBF, 0x56, 0x59, 0xB9, 0x4E, 0x58, 0xB3, 0x4E, 0x58,
	0xAA, 0x47, 0x53, 0xAA, 0x46, 0x54, 0xC4, 0x5E, 0x62, 0xD6, 0x72, 0x6B, 0xDA, 0x7B, 0x6F, 0xDF,
	0x83, 0x70, 0xE1, 0x83, 0x6D, 0xDF, 0x81, 0x6C, 0xE0, 0x82, 0x6C, 0xE3, 0x85, 0x6A, 0xE2, 0x86,
	0x6B, 0xE2, 0x83, 0x6A, 0xE1, 0x7F, 0x68, 0xE0, 0x7E, 0x67, 0xE0, 0x7C, 0x65, 0xDF, 0x7B, 0x64,
	0xDE, 0x7B, 0x63, 0xDB, 0x7A, 0x65, 0xDA, 0x7A, 0x69, 0xDA, 0x7B, 0x69, 0xD9, 0x78, 0x67, 0xD9,
	0x77, 0x67, 0xEA, 0xA6, 0x79, 0xF3, 0xCD, 0x93, 0xF2, 0xCF, 0xA0, 0xF6, 0xD4, 0xA0, 0xE9, 0xAF,
	0x82, 0xB2, 0x54, 0x57, 0xA4, 0x41, 0x51, 0xB4, 0x4D, 0x54, 0xBB, 0x51, 0x56, 0xB9, 0x54, 0x59,
	0xBD, 0x56, 0x58, 0xBE, 0x57, 0x59, 0xBC, 0x57, 0x58, 0xBB, 0x58, 0x5B, 0xBC, 0x58, 0x5B, 0xBF,
	0x58, 0x59, 0xC2, 0x59, 0x5A, 0xC3, 0x5A, 0x5A, 0xC5, 0x5B, 0x58, 0xC7, 0x5B, 0x59, 0xCD, 0x62,
	0x5F, 0xCF, 0x64, 0x5E, 0xA6, 0x41, 0x4C, 0x63, 0x17, 0x3E, 0x4F, 0x0C, 0x3A, 0x57, 0x12, 0x3B,
	0xDF, 0x7F, 0x6C, 0xDF, 0x7E, 0x68, 0xE0, 0x7D, 0x66, 0xE1, 0x80, 0x69, 0xE0, 0x7E, 0x68, 0xDF,
	0x7C, 0x68, 0xDD, 0x7B, 0x69, 0xE0, 0x82, 0x6C, 0xE4, 0x8B, 0x6F, 0xE6, 0x8E, 0x6F, 0xE6, 0x8D,
	0x6F, 0xE6, 0x8A, 0x6D, 0xE5, 0x88, 0x6B, 0xE1, 0x7C, 0x65, 0xD6, 0x69, 0x5E, 0xBC, 0x4F, 0x55,
	0x9E, 0x38, 0x4A, 0x9D, 0x34, 0x46, 0xA8, 0x3D, 0x49, 0xB1, 0x41, 0x4A, 0xB3, 0x44, 0x4C, 0xB2,
	0x46, 0x4F, 0xAF, 0x43, 0x4F, 0xAE, 0x42, 0x4C, 0xAF, 0x41, 0x49, 0xB1, 0x42, 0x4A, 0xB8, 0x4A,
	0x50, 0xBC, 0x4F, 0x53, 0xC3, 0x52, 0x53, 0xC6, 0x56, 0x57, 0xC6, 0x57, 0x56, 0xC8, 0x5A, 0x55,
	0xCA, 0x5C, 0x58, 0xCB, 0x5C, 0x5A, 0xCE, 0x5E, 0x5A, 0xCD, 0x5F, 0x5A, 0xCD, 0x5F, 0x5B, 0xCE,
	0x61, 0x5D, 0xCD, 0x5F, 0x5C, 0xCC, 0x5E, 0x5B, 0xCE, 0x60, 0x5D, 0xD0, 0x60, 0x5B, 0xD0, 0x61,
	0x5C, 0xD1, 0x62, 0x5E, 0xD0, 0x62, 0x5E, 0xD0, 0x60, 0x5C, 0xD1, 0x5F, 0x5B, 0xD1, 0x60, 0x5C,
	0xCF, 0x5E, 0x5C, 0xCE, 0x62, 0x5F, 0xCE, 0x62, 0x5D, 0xCE, 0x61, 0x5F, 0xCE, 0x61, 0x5F, 0xCF,
	0x61, 0x5D, 0xCE, 0x60, 0x5E, 0xCA, 0x5E, 0x5C, 0xCB, 0x60, 0x5B, 0xCB, 0x61, 0x5D, 0xC9, 0x5E,
	0x5B, 0xCC, 0x60, 0x5B, 0xD1, 0x64, 0x5E, 0xD2, 0x67, 0x61, 0xD0, 0x61, 0x5E, 0xCC, 0x5F, 0x5C,
	0xCB, 0x60, 0x5D, 0xCD, 0x60, 0x5E, 0xCC, 0x61, 0x5D, 0xCA, 0x5D, 0x5A, 0xCB, 0x5E, 0x5C, 0xC9,
	0x5D, 0x5C, 0xC9, 0x5A, 0x58, 0xC9, 0x5B, 0x5B, 0xC9, 0x5E, 0x5C, 0xCA, 0x5F, 0x5E, 0xCA, 0x5E,
	0x5C, 0xC9, 0x5D, 0x5D, 0xC3, 0x5C, 0x5F, 0xBF, 0x58, 0x5B, 0xBC, 0x50, 0x57, 0xB7, 0x4F, 0x59,
	0xB1, 0x49, 0x55, 0xAA, 0x41, 0x51, 0xB8, 0x53, 0x5C, 0xD1, 0x6C, 0x6A, 0xD8, 0x78, 0x6E, 0xDC,
	0x80, 0x6F, 0xE2, 0x87, 0x6F, 0xE1, 0x86, 0x70, 0xE1, 0x84, 0x6C, 0xE2, 0x87, 0x6F, 0xE3, 0x89,
	0x6D, 0xE3, 0x86, 0x6A, 0xE1, 0x82, 0x6B, 0xE1, 0x82, 0x6B, 0xE0, 0x7E, 0x6A, 0xDE, 0x7A, 0x65,
	0xDE, 0x7B, 0x66, 0xDB, 0x7A, 0x67, 0xDA, 0x7A, 0x67, 0xD9, 0x7A, 0x6A, 0xD9, 0x7A, 0x69, 0xD7,
	0x72, 0x64, 0xDF, 0x84, 0x6A, 0xF1, 0xBE, 0x86, 0xF3, 0xD1, 0x9E, 0xF3, 0xD1, 0xA5, 0xF7, 0xD0,
	0x98, 0xD2, 0x88, 0x6E, 0xA3, 0x41, 0x51, 0xAD, 0x48, 0x52, 0xB9, 0x50, 0x56, 0xB9, 0x52, 0x59,
	0xBE, 0x57, 0x58, 0xBF, 0x58, 0x59, 0xBE, 0x5B, 0x5A, 0xBC, 0x5A, 0x5C, 0xBB, 0x5A, 0x5C, 0xBF,
	0x5B, 0x5C, 0xC2, 0x5B, 0x5C, 0xC5, 0x5C, 0x5B, 0xCA, 0x5E, 0x5B, 0xD3, 0x66, 0x5E, 0xD4, 0x65,
	0x5D, 0x9C, 0x3B, 0x49, 0x5B, 0x11, 0x3A, 0x4F, 0x0E, 0x3C, 0x57, 0x11, 0x3C, 0x5A, 0x11, 0x39,
	0xDF, 0x7D, 0x69, 0xDF, 0x7D, 0x6A, 0xE1, 0x80, 0x69, 0xE1, 0x80, 0x69, 0xE1, 0x80, 0x6A, 0xDE,
	0x7D, 0x6A, 0xDD, 0x7C, 0x6A, 0xE1, 0x85, 0x6D, 0xE5, 0x8D, 0x6F, 0xE5, 0x8C, 0x6D, 0xE4, 0x8A,
	0x6D, 0xE2, 0x86, 0x6D, 0xE3, 0x84, 0x6A, 0xE1, 0x7E, 0x66, 0xD8, 0x6C, 0x63, 0xBD, 0x53, 0x5A,
	0x9C, 0x39, 0x4A, 0x9D, 0x36, 0x47, 0xAA, 0x3C, 0x47, 0xB0, 0x43, 0x4C, 0xB2, 0x45, 0x4D, 0xB0,
	0x42, 0x4B, 0xAF, 0x42, 0x4B, 0xAF, 0x41, 0x4A, 0xAF, 0x41, 0x49, 0xB1, 0x43, 0x4B, 0xB6, 0x49,
	0x50, 0xBC, 0x4D, 0x50, 0xC1, 0x53, 0x54, 0xC5, 0x55, 0x54, 0xC7, 0x56, 0x52, 0xC8, 0x58, 0x55,
	0xCA, 0x5B, 0x58, 0xCC, 0x5D, 0x5A, 0xCD, 0x5E, 0x5A, 0xCC, 0x5F, 0x5B, 0xCB, 0x5F, 0x5C, 0xCD,
	0x5F, 0x5D, 0xCC, 0x5E, 0x5C, 0xCB, 0x5D, 0x5B, 0xCD, 0x5E, 0x5A, 0xCE, 0x5E, 0x5B, 0xCF, 0x5F,
	0x5A, 0xD1, 0x62, 0x5D, 0xCE, 0x5F, 0x5C, 0xCF, 0x5E, 0x58, 0xCD, 0x5D, 0x5B, 0xCE, 0x5F, 0x5B,
	0xCE, 0x5F, 0x5C, 0xCF, 0x60, 0x5D, 0xD0, 0x5E, 0x59, 0xCF, 0x5D, 0x5B, 0xCD, 0x5E, 0x5D, 0xCC,
	0x5E, 0x5A, 0xCC, 0x5D, 0x5C, 0xC9, 0x5E, 0x5E, 0xCA, 0x5F, 0x5A, 0xC9, 0x5F, 0x5C, 0xC8, 0x5D,
	0x5A, 0xCA, 0x5D, 0x59, 0xCD, 0x60, 0x5D, 0xCE, 0x65, 0x62, 0xCD, 0x62, 0x63, 0xCC, 0x5E, 0x5C,
	0xCB, 0x5F, 0x5C, 0xCD, 0x60, 0x5E, 0xCB, 0x60, 0x5C, 0xC9, 0x5C, 0x5A, 0xCB, 0x5D, 0x5A, 0xCA,
	0x5C, 0x5A, 0xCA, 0x5A, 0x57, 0xC8, 0x5A, 0x58, 0xC9, 0x5B, 0x59, 0xCB, 0x5C, 0x58, 0xCB, 0x5B,
	0x57, 0xCA, 0x5D, 0x5A, 0xC3, 0x5B, 0x5C, 0xBD, 0x5A, 0x60, 0xBE, 0x55, 0x5B, 0xB7, 0x4C, 0x54,
	0xB1, 0x48, 0x55, 0xA9, 0x44, 0x52, 0xAF, 0x4C, 0x57, 0xCC, 0x64, 0x63, 0xD7, 0x77, 0x6E, 0xDA,
	0x7F, 0x71, 0xDF, 0x85, 0x75, 0xE0, 0x87, 0x74, 0xE2, 0x85, 0x6D, 0xE1, 0x85, 0x6D, 0xE2, 0x87,
	0x6E, 0xE2, 0x86, 0x6C, 0xE2, 0x84, 0x6A, 0xDF, 0x7E, 0x6A, 0xDF, 0x7D, 0x6B, 0xDE, 0x7C, 0x69,
	0xDB, 0x7B, 0x68, 0xDA, 0x7A, 0x68, 0xDA, 0x7A, 0x67, 0xDA, 0x7A, 0x68, 0xDA, 0x79, 0x69, 0xD8,
	0x76, 0x67, 0xD7, 0x6F, 0x63, 0xE7, 0x9C, 0x74, 0xF3, 0xCC, 0x92, 0xF2, 0xCF, 0x9F, 0xF5, 0xD3,
	0x9F, 0xEE, 0xBA, 0x86, 0xBC, 0x5E, 0x5A, 0xA7, 0x3F, 0x4D, 0xB5, 0x4D, 0x54, 0xBA, 0x54, 0x58,
	0xBB, 0x56, 0x58, 0xBC, 0x57, 0x59, 0xBD, 0x59, 0x5B, 0xBB, 0x57, 0x5A, 0xBB, 0x58, 0x5B, 0xBE,
	0x5D, 0x61, 0xC4, 0x5E, 0x61, 0xC8, 0x5F, 0x5F, 0xD3, 0x6A, 0x63, 0xD6, 0x69, 0x61, 0x9E, 0x3D,
	0x4E, 0x59, 0x12, 0x3C, 0x4D, 0x10, 0x3D, 0x57, 0x15, 0x40, 0x58, 0x11, 0x3B, 0x5D, 0x12, 0x3B,
	0xDF, 0x7C, 0x68, 0xDF, 0x7D, 0x6B, 0xE1, 0x81, 0x6A, 0xE2, 0x80, 0x69, 0xE1, 0x80, 0x6A, 0xDF,
	0x7E, 0x6B, 0xDF, 0x80, 0x6B, 0xE3, 0x89, 0x6F, 0xE5, 0x8E, 0x71, 0xE4, 0x8B, 0x6E, 0xE2, 0x86,
	0x6B, 0xE1, 0x84, 0x6C, 0xE2, 0x84, 0x6B, 0xE1, 0x7F, 0x66, 0xDA, 0x6B, 0x5D, 0xBE, 0x4B, 0x4F,
	0x9D, 0x33, 0x44, 0x99, 0x33, 0x43, 0xA8, 0x3B, 0x46, 0xB0, 0x41, 0x4B, 0xB2, 0x44, 0x4C, 0xB1,
	0x43, 0x4C, 0xB0, 0x43, 0x4C, 0xAF, 0x42, 0x4A, 0xAF, 0x40, 0x49, 0xB3, 0x43, 0x4B, 0xB5, 0x46,
	0x4D, 0xBB, 0x4C, 0x51, 0xC3, 0x54, 0x54, 0xC6, 0x55, 0x53, 0xC7, 0x56, 0x53, 0xC8, 0x5A, 0x59,
	0xCA, 0x5D, 0x59, 0xCA, 0x5C, 0x57, 0xCA, 0x5D, 0x58, 0xCB, 0x5D, 0x5A, 0xCB, 0x5D, 0x5B, 0xCC,
	0x5C, 0x5B, 0xCB, 0x5C, 0x5D, 0xCB, 0x5D, 0x5B, 0xCD, 0x5D, 0x5A, 0xCE, 0x5C, 0x59, 0xCE, 0x5D,
	0x58, 0xD1, 0x5F, 0x5C, 0xD1, 0x5D, 0x5B, 0xCE, 0x5B, 0x57, 0xCD, 0x5C, 0x5A, 0xCE, 0x60, 0x60,
	0xD0, 0x64, 0x61, 0xD0, 0x5F, 0x5D, 0xCF, 0x59, 0x58, 0xCD, 0x58, 0x54, 0xCC, 0x58, 0x54, 0xCB,
	0x59, 0x53, 0xCC, 0x5A, 0x57, 0xCC, 0x5C, 0x5A, 0xCA, 0x5B, 0x58, 0xC8, 0x5B, 0x57, 0xC8, 0x5B,
	0x58, 0xC9, 0x5B, 0x57, 0xCA, 0x5C, 0x5A, 0xCA, 0x5E, 0x5E, 0xCB, 0x5F, 0x5F, 0xCC, 0x5F, 0x5C,
	0xCB, 0x60, 0x5D, 0xCD, 0x61, 0x5D, 0xCA, 0x5E, 0x59, 0xC9, 0x5B, 0x58, 0xC9, 0x5B, 0x59, 0xC9,
	0x5A, 0x59, 0xC8, 0x59, 0x57, 0xC8, 0x5B, 0x57, 0xCA, 0x5C, 0x57, 0xCB, 0x59, 0x55, 0xCA, 0x5B,
	0x57, 0xCA, 0x5D, 0x59, 0xC4, 0x59, 0x5A, 0xBE, 0x58, 0x5E, 0xBF, 0x57, 0x5D, 0xB8, 0x4E, 0x55,
	0xB1, 0x48, 0x50, 0xAC, 0x45, 0x51, 0xB1, 0x4F, 0x5C, 0xC8, 0x60, 0x65, 0xD5, 0x73, 0x6E, 0xDA,
	0x80, 0x75, 0xDF, 0x85, 0x78, 0xE1, 0x87, 0x73, 0xE1, 0x88, 0x70, 0xE0, 0x84, 0x6D, 0xE0, 0x83,
	0x6C, 0xE0, 0x82, 0x6A, 0xE2, 0x84, 0x69, 0xDF, 0x7F, 0x69, 0xDE, 0x7C, 0x69, 0xE0, 0x7E, 0x69,
	0xDC, 0x7C, 0x69, 0xDB, 0x7A, 0x69, 0xDA, 0x7A, 0x6A, 0xDA, 0x7A, 0x68, 0xDA, 0x7A, 0x68, 0xD9,
	0x78, 0x68, 0xD5, 0x6D, 0x66, 0xDC, 0x7A, 0x67, 0xF0, 0xB8, 0x80, 0xF4, 0xD1, 0x9A, 0xF2, 0xD1,
	0xA5, 0xF7, 0xD3, 0x9C, 0xDE, 0x99, 0x74, 0xAB, 0x44, 0x4C, 0xAF, 0x44, 0x4C, 0xB9, 0x52, 0x55,
	0xBB, 0x57, 0x59, 0xBE, 0x58, 0x5B, 0xC0, 0x59, 0x59, 0xBE, 0x56, 0x58, 0xBC, 0x56, 0x5A, 0xBE,
	0x5A, 0x5D, 0xC3, 0x5C, 0x5D, 0xD0, 0x67, 0x62, 0xD6, 0x67, 0x5F, 0x9D, 0x38, 0x49, 0x5A, 0x14,
	0x40, 0x4E, 0x0F, 0x3E, 0x54, 0x0E, 0x38, 0x59, 0x0F, 0x38, 0x5F, 0x11, 0x37, 0x63, 0x16, 0x3C,
	0xE0, 0x80, 0x6B, 0xE1, 0x80, 0x6A, 0xE2, 0x81, 0x69, 0xE2, 0x82, 0x69, 0xE1, 0x83, 0x6A, 0xE1,
	0x82, 0x6D, 0xE3, 0x88, 0x6F, 0xE5, 0x8F, 0x71, 0xE6, 0x8F, 0x71, 0xE4, 0x89, 0x6D, 0xE1, 0x82,
	0x6A, 0xE0, 0x81, 0x6C, 0xE3, 0x87, 0x6C, 0xE3, 0x81, 0x66, 0xDB, 0x6A, 0x5A, 0xBE, 0x4A, 0x4D,
	0x9D, 0x33, 0x44, 0x99, 0x33, 0x44, 0xA8, 0x3C, 0x48, 0xAF, 0x41, 0x4B, 0xB1, 0x45, 0x4E, 0xB2,
	0x46, 0x4E, 0xAE, 0x43, 0x4D, 0xAE, 0x42, 0x4A, 0xAF, 0x41, 0x4B, 0xB2, 0x42, 0x4D, 0xB6, 0x46,
	0x4D, 0xBC, 0x4C, 0x50, 0xC3, 0x53, 0x53, 0xC4, 0x57, 0x55, 0xC6, 0x57, 0x56, 0xC8, 0x5A, 0x57,
	0xC8, 0x5C, 0x57, 0xC8, 0x5B, 0x58, 0xC9, 0x5C, 0x58, 0xC9, 0x5B, 0x58, 0xCB, 0x5A, 0x59, 0xCB,
	0x5C, 0x5B, 0xCB, 0x5D, 0x5E, 0xCB, 0x5E, 0x5E, 0xCD, 0x5D, 0x5D, 0xCE, 0x5E, 0x5B, 0xCD, 0x5E,
	0x5B, 0xCD, 0x5D, 0x5B, 0xCF, 0x5D, 0x5B, 0xCE, 0x5B, 0x5A, 0xCE, 0x5A, 0x5B, 0xCE, 0x5F, 0x5F,
	0xD0, 0x63, 0x61, 0xD0, 0x60, 0x5D, 0xCD, 0x5A, 0x59, 0xCB, 0x56, 0x53, 0xC8, 0x54, 0x51, 0xC7,
	0x55, 0x51, 0xC9, 0x57, 0x56, 0xCB, 0x5B, 0x59, 0xC9, 0x59, 0x59, 0xC9, 0x59, 0x57, 0xC9, 0x5A,
	0x57, 0xC9, 0x5A, 0x57, 0xCA, 0x5C, 0x5B, 0xCA, 0x5D, 0x5E, 0xCB, 0x5D, 0x5C, 0xCA, 0x5F, 0x5F,
	0xCB, 0x61, 0x5F, 0xCC, 0x60, 0x5D, 0xC8, 0x5C, 0x5A, 0xC8, 0x5A, 0x58, 0xC8, 0x5B, 0x5B, 0xC8,
	0x5D, 0x5C, 0xC9, 0x5A, 0x58, 0xC9, 0x5A, 0x58, 0xC8, 0x5B, 0x59, 0xCA, 0x59, 0x59, 0xCA, 0x5B,
	0x5B, 0xCA, 0x5C, 0x59, 0xC6, 0x5B, 0x5A, 0xC2, 0x56, 0x5C, 0xBF, 0x54, 0x5C, 0xBA, 0x50, 0x57,
	0xB6, 0x48, 0x50, 0xB2, 0x44, 0x52, 0xB6, 0x51, 0x5E, 0xC8, 0x61, 0x65, 0xD5, 0x6E, 0x6D, 0xD9,
	0x7C, 0x73, 0xDE, 0x81, 0x74, 0xE0, 0x85, 0x73, 0xDF, 0x85, 0x72, 0xDE, 0x81, 0x72, 0xDE, 0x81,
	0x6F, 0xDF, 0x82, 0x6B, 0xE2, 0x81, 0x68, 0xE1, 0x80, 0x68, 0xDF, 0x7D, 0x69, 0xDF, 0x7E, 0x6B,
	0xDE, 0x7C, 0x6A, 0xDC, 0x7C, 0x6B, 0xDB, 0x7E, 0x6D, 0xDC, 0x7B, 0x6A, 0xD9, 0x7A, 0x69, 0xD9,
	0x79, 0x6A, 0xD8, 0x73, 0x69, 0xD6, 0x6B, 0x62, 0xE5, 0x94, 0x6F, 0xF3, 0xC7, 0x8E, 0xF2, 0xCE,
	0x9E, 0xF4, 0xD2, 0xA2, 0xF4, 0xC9, 0x92, 0xC5, 0x73, 0x67, 0xA6, 0x41, 0x53, 0xB5, 0x4E, 0x55,
	0xBB, 0x53, 0x56, 0xBC, 0x58, 0x5B, 0xBE, 0x59, 0x5A, 0xBD, 0x57, 0x58, 0xBC, 0x59, 0x5B, 0xC1,
	0x5A, 0x5C, 0xCB, 0x62, 0x5F, 0xD1, 0x66, 0x61, 0x9D, 0x38, 0x4A, 0x57, 0x0B, 0x36, 0x50, 0x0C,
	0x3A, 0x56, 0x10, 0x3A, 0x58, 0x10, 0x3A, 0x60, 0x12, 0x38, 0x62, 0x11, 0x36, 0x61, 0x18, 0x3F,
	0xE1, 0x80, 0x6B, 0xE1, 0x81, 0x69, 0xE2, 0x83, 0x6A, 0xE2, 0x85, 0x6B, 0xE2, 0x86, 0x6D, 0xE3,
	0x89, 0x6E, 0xE6, 0x8E, 0x70, 0xE6, 0x8F, 0x70, 0xE6, 0x8E, 0x6F, 0xE5, 0x87, 0x6A, 0xE1, 0x82,
	0x68, 0xE1, 0x82, 0x6A, 0xE4, 0x86, 0x6B, 0xE2, 0x80, 0x66, 0xDA, 0x6A, 0x5A, 0xBE, 0x4B, 0x4E,
	0x9C, 0x35, 0x45, 0x9C, 0x36, 0x47, 0xA9, 0x3C, 0x49, 0xB0, 0x40, 0x4A, 0xB2, 0x45, 0x4D, 0xB0,
	0x44, 0x4D, 0xAE, 0x42, 0x4B, 0xAF, 0x40, 0x49, 0xAE, 0x40, 0x4A, 0xB1, 0x43, 0x4C, 0xB7, 0x48,
	0x4F, 0xBD, 0x4C, 0x51, 0xC3, 0x52, 0x52, 0xC6, 0x54, 0x55, 0xC6, 0x55, 0x54, 0xC7, 0x58, 0x56,
	0xC8, 0x5A, 0x56, 0xC9, 0x5D, 0x59, 0xCD, 0x5B, 0x59, 0xCB, 0x5C, 0x5A, 0xCB, 0x5A, 0x57, 0xCC,
	0x59, 0x58, 0xCC, 0x5A, 0x5A, 0xCC, 0x5D, 0x5D, 0xCE, 0x5D, 0x5D, 0xCE, 0x5C, 0x59, 0xCD, 0x5F,
	0x5C, 0xCB, 0x5D, 0x5E, 0xCC, 0x5C, 0x5E, 0xCE, 0x5C, 0x5E, 0xCE, 0x5A, 0x5A, 0xCD, 0x5D, 0x5C,
	0xCF, 0x60, 0x5F, 0xCE, 0x5C, 0x5C, 0xCD, 0x5A, 0x57, 0xCB, 0x57, 0x53, 0xC8, 0x56, 0x53, 0xC6,
	0x55, 0x53, 0xC6, 0x54, 0x53, 0xC8, 0x59, 0x57, 0xC8, 0x5B, 0x59, 0xC8, 0x58, 0x54, 0xC7, 0x57,
	0x54, 0xC6, 0x57, 0x55, 0xC9, 0x5B, 0x59, 0xCA, 0x5E, 0x5F, 0xCA, 0x5D, 0x5D, 0xCA, 0x5F, 0x5F,
	0xC9, 0x62, 0x63, 0xCA, 0x5F, 0x5F, 0xC8, 0x5D, 0x5C, 0xC8, 0x5C, 0x5B, 0xCA, 0x5C, 0x5B, 0xCA,
	0x5C, 0x5B, 0xCA, 0x59, 0x58, 0xC9, 0x59, 0x58, 0xC9, 0x5A, 0x5A, 0xCA, 0x59, 0x59, 0xCB, 0x5A,
	0x5A, 0xC9, 0x5B, 0x5C, 0xC7, 0x5B, 0x5C, 0xC7, 0x56, 0x5B, 0xC2, 0x51, 0x5A, 0xB9, 0x4D, 0x58,
	0xB4, 0x4A, 0x54, 0xB3, 0x46, 0x53, 0xB8, 0x50, 0x5B, 0xC8, 0x5E, 0x63, 0xD4, 0x69, 0x6A, 0xD8,
	0x76, 0x6F, 0xDB, 0x7D, 0x70, 0xDD, 0x81, 0x72, 0xDE, 0x82, 0x73, 0xDD, 0x7F, 0x71, 0xDE, 0x81,
	0x6D, 0xE1, 0x84, 0x6B, 0xE0, 0x81, 0x6B, 0xDF, 0x7E, 0x6A, 0xDD, 0x7E, 0x6B, 0xDE, 0x7E, 0x6D,
	0xE0, 0x7F, 0x6A, 0xDD, 0x7E, 0x6B, 0xDD, 0x7F, 0x6C, 0xDD, 0x7C, 0x6B, 0xDA, 0x7B, 0x6B, 0xD9,
	0x7A, 0x6C, 0xD9, 0x78, 0x6B, 0xD5, 0x6D, 0x65, 0xD8, 0x71, 0x62, 0xED, 0xAB, 0x7A, 0xF3, 0xCD,
	0x96, 0xF1, 0xCF, 0xA3, 0xF7, 0xD6, 0xA3, 0xE8, 0xB4, 0x8B, 0xAD, 0x57, 0x62, 0xA8, 0x42, 0x50,
	0xB9, 0x4D, 0x51, 0xBC, 0x52, 0x56, 0xBE, 0x58, 0x59, 0xBE, 0x59, 0x59, 0xBE, 0x5B, 0x5D, 0xCA,
	0x62, 0x62, 0xD0, 0x63, 0x5F, 0x9C, 0x39, 0x4A, 0x58, 0x0D, 0x38, 0x4E, 0x0B, 0x39, 0x59, 0x14,
	0x3F, 0x5D, 0x15, 0x3F, 0x61, 0x15, 0x3C, 0x62, 0x13, 0x39, 0x5F, 0x12, 0x3A, 0x61, 0x16, 0x3B,
	0xE0, 0x83, 0x6E, 0xE1, 0x84, 0x6A, 0xE2, 0x86, 0x6E, 0xE2, 0x86, 0x6D, 0xE3, 0x8A, 0x71, 0xE5,
	0x8E, 0x70, 0xE7, 0x8D, 0x6F, 0xE7, 0x8B, 0x6C, 0xE7, 0x89, 0x6B, 0xE3, 0x84, 0x69, 0xE1, 0x82,
	0x69, 0xE2, 0x84, 0x6A, 0xE3, 0x86, 0x6A, 0xE1, 0x7E, 0x65, 0xD9, 0x68, 0x59, 0xBD, 0x48, 0x4C,
	0x9A, 0x30, 0x42, 0x99, 0x33, 0x43, 0xA6, 0x3C, 0x48, 0xB0, 0x41, 0x4B, 0xB1, 0x42, 0x4A, 0xAD,
	0x40, 0x49, 0xAD, 0x40, 0x4A, 0xAE, 0x41, 0x4B, 0xAF, 0x41, 0x4B, 0xB1, 0x42, 0x4B, 0xB6, 0x49,
	0x4E, 0xBA, 0x4D, 0x51, 0xC1, 0x50, 0x53, 0xC4, 0x53, 0x55, 0xC4, 0x53, 0x54, 0xC4, 0x57, 0x57,
	0xC6, 0x58, 0x58, 0xC8, 0x5A, 0x56, 0xCA, 0x5A, 0x57, 0xCB, 0x5C, 0x5A, 0xCB, 0x59, 0x55, 0xCA,
	0x57, 0x56, 0xCA, 0x59, 0x59, 0xCD, 0x5B, 0x5A, 0xCF, 0x5B, 0x5B, 0xCE, 0x5B, 0x58, 0xCA, 0x5C,
	0x59, 0xCA, 0x5D, 0x5D, 0xCD, 0x5C, 0x5E, 0xCD, 0x5D, 0x61, 0xCD, 0x5C, 0x5B, 0xCE, 0x5B, 0x5A,
	0xCF, 0x5C, 0x5B, 0xCE, 0x59, 0x5A, 0xCD, 0x59, 0x58, 0xCC, 0x58, 0x57, 0xC8, 0x56, 0x55, 0xC7,
	0x55, 0x54, 0xC9, 0x54, 0x54, 0xC7, 0x55, 0x53, 0xC7, 0x55, 0x51, 0xC6, 0x51, 0x50, 0xC3, 0x52,
	0x52, 0xC4, 0x55, 0x55, 0xC7, 0x59, 0x57, 0xC9, 0x5C, 0x5B, 0xC9, 0x5D, 0x5F, 0xC9, 0x60, 0x62,
	0xC9, 0x61, 0x63, 0xC9, 0x5E, 0x5D, 0xC8, 0x5D, 0x5B, 0xC9, 0x5C, 0x5C, 0xCC, 0x5B, 0x5B, 0xCC,
	0x5A, 0x5A, 0xCA, 0x58, 0x58, 0xC8, 0x59, 0x57, 0xC9, 0x59, 0x59, 0xCB, 0x59, 0x58, 0xCB, 0x5A,
	0x56, 0xCA, 0x5A, 0x59, 0xC9, 0x59, 0x5B, 0xC8, 0x54, 0x59, 0xC1, 0x52, 0x58, 0xBA, 0x52, 0x5C,
	0xB8, 0x4D, 0x56, 0xB5, 0x46, 0x53, 0xB9, 0x4D, 0x59, 0xC7, 0x5C, 0x62, 0xD3, 0x68, 0x6B, 0xD7,
	0x73, 0x6E, 0xD9, 0x79, 0x6F, 0xD8, 0x7E, 0x70, 0xDB, 0x80, 0x72, 0xDD, 0x80, 0x70, 0xDD, 0x7F,
	0x6C, 0xE0, 0x80, 0x6A, 0xDF, 0x7F, 0x6B, 0xDE, 0x7E, 0x6B, 0xDE, 0x7E, 0x6A, 0xDD, 0x7C, 0x6A,
	0xDF, 0x7F, 0x6B, 0xDF, 0x7F, 0x6B, 0xDF, 0x7E, 0x6B, 0xDD, 0x7C, 0x6B, 0xDB, 0x7B, 0x6A, 0xDA,
	0x7A, 0x6A, 0xD9, 0x77, 0x69, 0xD6, 0x71, 0x65, 0xD4, 0x66, 0x5E, 0xE2, 0x8A, 0x6B, 0xF3, 0xC8,
	0x8E, 0xF2, 0xD1, 0xA3, 0xF1, 0xD3, 0xAB, 0xF6, 0xD2, 0x9B, 0xD2, 0x84, 0x69, 0xA5, 0x3B, 0x48,
	0xAE, 0x46, 0x50, 0xB9, 0x4D, 0x52, 0xBC, 0x54, 0x58, 0xBD, 0x5A, 0x5C, 0xC8, 0x62, 0x61, 0xCC,
	0x62, 0x60, 0x98, 0x36, 0x48, 0x58, 0x0C, 0x35, 0x4D, 0x0A, 0x36, 0x56, 0x10, 0x3B, 0x5E, 0x18,
	0x44, 0x63, 0x1A, 0x43, 0x62, 0x16, 0x3D, 0x5F, 0x13, 0x3B, 0x5E, 0x12, 0x3A, 0x5D, 0x11, 0x39,
	0xE2, 0x85, 0x6B, 0xE2, 0x85, 0x6B, 0xE2, 0x85, 0x6B, 0xE3, 0x88, 0x6D, 0xE5, 0x8F, 0x73, 0xE5,
	0x8C, 0x70, 0xE4, 0x84, 0x69, 0xE3, 0x82, 0x67, 0xE3, 0x81, 0x67, 0xE2, 0x83, 0x69, 0xE2, 0x83,
	0x6A, 0xE2, 0x84, 0x6A, 0xE3, 0x85, 0x6A, 0xE1, 0x7E, 0x66, 0xD7, 0x68, 0x59, 0xBB, 0x47, 0x4A,
	0x9A, 0x2E, 0x40, 0x99, 0x30, 0x44, 0xA6, 0x3C, 0x4A, 0xAF, 0x42, 0x4C, 0xB0, 0x41, 0x4A, 0xB0,
	0x41, 0x4A, 0xAF, 0x41, 0x4A, 0xAE, 0x41, 0x4A, 0xAE, 0x41, 0x4A, 0xB0, 0x41, 0x49, 0xB6, 0x46,
	0x4C, 0xBB, 0x4D, 0x52, 0xC2, 0x53, 0x54, 0xC4, 0x54, 0x54, 0xC5, 0x54, 0x56, 0xC4, 0x57, 0x58,
	0xC6, 0x57, 0x55, 0xC7, 0x57, 0x53, 0xC9, 0x5A, 0x58, 0xC7, 0x59, 0x59, 0xC8, 0x58, 0x56, 0xCB,
	0x58, 0x57, 0xCC, 0x59, 0x5B, 0xCE, 0x5A, 0x5C, 0xCE, 0x5A, 0x5A, 0xCC, 0x5A, 0x58, 0xCD, 0x5C,
	0x59, 0xCE, 0x5C, 0x5B, 0xCE, 0x5B, 0x5B, 0xCE, 0x5C, 0x5D, 0xCD, 0x5B, 0x5B, 0xCD, 0x5B, 0x5B,
	0xCE, 0x5B, 0x5C, 0xCE, 0x58, 0x58, 0xCE, 0x58, 0x57, 0xCE, 0x58, 0x57, 0xCC, 0x55, 0x54, 0xCC,
	0x54, 0x50, 0xC8, 0x51, 0x4F, 0xC4, 0x52, 0x52, 0xC4, 0x54, 0x54, 0xC3, 0x52, 0x52, 0xC1, 0x4E,
	0x4E, 0xBE, 0x4B, 0x4E, 0xC4, 0x4E, 0x4E, 0xC7, 0x55, 0x53, 0xC8, 0x59, 0x5B, 0xC9, 0x5F, 0x61,
	0xCB, 0x5E, 0x5F, 0xC9, 0x5B, 0x5C, 0xC9, 0x5C, 0x5B, 0xC9, 0x5A, 0x5C, 0xCB, 0x5A, 0x5C, 0xCB,
	0x5D, 0x5C, 0xCB, 0x58, 0x59, 0xCB, 0x5A, 0x5B, 0xC8, 0x5B, 0x5A, 0xC9, 0x5A, 0x55, 0xCB, 0x5A,
	0x56, 0xCC, 0x5A, 0x59, 0xC8, 0x58, 0x59, 0xC7, 0x55, 0x59, 0xBF, 0x50, 0x56, 0xBA, 0x4F, 0x58,
	0xB9, 0x4D, 0x57, 0xB5, 0x48, 0x53, 0xB9, 0x4C, 0x57, 0xC8, 0x59, 0x5F, 0xD3, 0x68, 0x67, 0xD6,
	0x71, 0x6B, 0xD7, 0x74, 0x6D, 0xD8, 0x7B, 0x70, 0xD9, 0x7D, 0x70, 0xDA, 0x80, 0x71, 0xDC, 0x7F,
	0x6D, 0xDE, 0x7D, 0x69, 0xDE, 0x7C, 0x6A, 0xDC, 0x7D, 0x6B, 0xDE, 0x7B, 0x68, 0xDE, 0x7A, 0x66,
	0xDD, 0x7C, 0x6A, 0xDF, 0x7E, 0x6B, 0xDF, 0x7D, 0x6A, 0xDE, 0x7B, 0x68, 0xDA, 0x79, 0x66, 0xD9,
	0x75, 0x66, 0xD8, 0x72, 0x65, 0xD7, 0x6E, 0x61, 0xD6, 0x69, 0x5D, 0xD8, 0x6E, 0x5D, 0xEC, 0xAB,
	0x79, 0xF4, 0xD1, 0x9B, 0xF1, 0xD1, 0xA8, 0xF4, 0xD5, 0xA7, 0xF0, 0xBC, 0x88, 0xB9, 0x5B, 0x55,
	0xA4, 0x3C, 0x4A, 0xB3, 0x48, 0x50, 0xB7, 0x4E, 0x55, 0xBF, 0x5C, 0x5E, 0xCC, 0x62, 0x5F, 0x9D,
	0x3A, 0x48, 0x58, 0x0D, 0x37, 0x4D, 0x0A, 0x37, 0x56, 0x10, 0x3B, 0x5C, 0x16, 0x3F, 0x64, 0x1C,
	0x42, 0x61, 0x19, 0x40, 0x5E, 0x15, 0x3F, 0x5E, 0x12, 0x3B, 0x5C, 0x0D, 0x36, 0x59, 0x0F, 0x38,
	0xE2, 0x86, 0x6C, 0xE2, 0x84, 0x6B, 0xE1, 0x84, 0x6B, 0xE5, 0x8D, 0x70, 0xE7, 0x8E, 0x70, 0xE2,
	0x82, 0x68, 0xDF, 0x7B, 0x62, 0xDF, 0x79, 0x60, 0xDF, 0x7B, 0x63, 0xE3, 0x84, 0x69, 0xE4, 0x86,
	0x6B, 0xE1, 0x83, 0x6B, 0xE4, 0x86, 0x6C, 0xE2, 0x7F, 0x67, 0xDA, 0x6A, 0x5C, 0xBB, 0x4A, 0x4F,
	0x9A, 0x32, 0x43, 0x9A, 0x32, 0x44, 0xA8, 0x3B, 0x49, 0xAE, 0x40, 0x4A, 0xB1, 0x41, 0x4C, 0xB2,
	0x43, 0x4D, 0xAF, 0x42, 0x4C, 0xAF, 0x41, 0x4B, 0xAE, 0x40, 0x49, 0xB2, 0x43, 0x4B, 0xB7, 0x48,
	0x50, 0xBB, 0x4C, 0x54, 0xC4, 0x52, 0x52, 0xC7, 0x54, 0x52, 0xC7, 0x56, 0x55, 0xC7, 0x58, 0x55,
	0xC7, 0x58, 0x54, 0xCA, 0x58, 0x56, 0xCA, 0x5A, 0x59, 0xC9, 0x58, 0x58, 0xCA, 0x58, 0x58, 0xCE,
	0x5C, 0x5A, 0xCD, 0x5B, 0x5E, 0xCD, 0x5B, 0x5E, 0xCD, 0x58, 0x5A, 0xCB, 0x58, 0x59, 0xCD, 0x5E,
	0x5C, 0xCF, 0x5D, 0x5C, 0xCD, 0x5D, 0x5F, 0xCE, 0x5B, 0x5C, 0xCF, 0x59, 0x59, 0xCF, 0x58, 0x58,
	0xCE, 0x5B, 0x5A, 0xCC, 0x59, 0x59, 0xCB, 0x5A, 0x5B, 0xCA, 0x60, 0x61, 0xC9, 0x65, 0x65, 0xC4,
	0x64, 0x67, 0xC3, 0x6F, 0x71, 0xC7, 0x82, 0x80, 0xC8, 0x8A, 0x86, 0xC6, 0x87, 0x84, 0xC8, 0x83,
	0x7F, 0xC6, 0x7C, 0x7B, 0xC3, 0x6A, 0x6B, 0xC1, 0x59, 0x5A, 0xC2, 0x4E, 0x51, 0xC2, 0x4E, 0x51,
	0xC6, 0x54, 0x57, 0xC9, 0x59, 0x5B, 0xCA, 0x5A, 0x5B, 0xCA, 0x5A, 0x5B, 0xCA, 0x5D, 0x5F, 0xCA,
	0x60, 0x61, 0xCB, 0x5D, 0x5F, 0xCB, 0x5A, 0x5C, 0xC9, 0x5A, 0x5A, 0xCC, 0x5B, 0x58, 0xCC, 0x5A,
	0x59, 0xCA, 0x59, 0x5A, 0xC9, 0x58, 0x58, 0xC6, 0x55, 0x58, 0xBE, 0x4F, 0x58, 0xBB, 0x4D, 0x57,
	0xB8, 0x4C, 0x55, 0xB5, 0x47, 0x4F, 0xB7, 0x4A, 0x56, 0xC4, 0x56, 0x5E, 0xD2, 0x67, 0x64, 0xD6,
	0x70, 0x69, 0xD6, 0x70, 0x6A, 0xD7, 0x75, 0x6D, 0xD7, 0x7A, 0x70, 0xD8, 0x7D, 0x6F, 0xDB, 0x7E,
	0x6E, 0xDC, 0x7C, 0x6A, 0xDC, 0x7A, 0x6A, 0xDA, 0x7B, 0x6B, 0xDC, 0x7B, 0x69, 0xE0, 0x7D, 0x67,
	0xE0, 0x7C, 0x67, 0xDE, 0x7B, 0x67, 0xDE, 0x7B, 0x66, 0xDC, 0x79, 0x64, 0xD9, 0x75, 0x65, 0xD6,
	0x71, 0x67, 0xD7, 0x6F, 0x63, 0xD7, 0x6E, 0x61, 0xD6, 0x6D, 0x61, 0xD5, 0x67, 0x5D, 0xE0, 0x85,
	0x69, 0xF2, 0xC4, 0x8D, 0xF3, 0xD2, 0xA2, 0xF1, 0xD2, 0xA9, 0xF7, 0xD4, 0x9F, 0xDB, 0x93, 0x70,
	0xA8, 0x42, 0x4C, 0xAB, 0x47, 0x52, 0xBA, 0x55, 0x5A, 0xC2, 0x5D, 0x5C, 0x99, 0x38, 0x48, 0x5B,
	0x0F, 0x37, 0x4F, 0x0B, 0x39, 0x56, 0x0F, 0x39, 0x5B, 0x13, 0x3D, 0x61, 0x1A, 0x41, 0x64, 0x1E,
	0x43, 0x60, 0x19, 0x42, 0x5E, 0x14, 0x3D, 0x5B, 0x0F, 0x38, 0x59, 0x0E, 0x37, 0x5A, 0x10, 0x38,
	0xE2, 0x85, 0x6D, 0xE1, 0x82, 0x6A, 0xE3, 0x87, 0x6D, 0xE8, 0x91, 0x72, 0xE6, 0x89, 0x6C, 0xDF,
	0x78, 0x60, 0xDB, 0x70, 0x5B, 0xDB, 0x6E, 0x5B, 0xDE, 0x79, 0x64, 0xE5, 0x88, 0x6B, 0xE3, 0x87,
	0x6C, 0xE2, 0x85, 0x6D, 0xE4, 0x88, 0x6C, 0xE3, 0x80, 0x66, 0xDC, 0x6B, 0x5C, 0xBF, 0x4B, 0x4F,
	0x9A, 0x32, 0x44, 0x9A, 0x32, 0x44, 0xA6, 0x39, 0x47, 0xAE, 0x3F, 0x4A, 0xB1, 0x43, 0x4E, 0xB0,
	0x43, 0x4D, 0xAE, 0x41, 0x4C, 0xB1, 0x42, 0x4A, 0xB0, 0x41, 0x49, 0xB6, 0x43, 0x4B, 0xBC, 0x4A,
	0x50, 0xBF, 0x4B, 0x51, 0xC5, 0x51, 0x52, 0xC7, 0x55, 0x54, 0xC7, 0x53, 0x52, 0xC8, 0x58, 0x53,
	0xCA, 0x59, 0x53, 0xCA, 0x58, 0x53, 0xC8, 0x5B, 0x58, 0xCA, 0x59, 0x58, 0xCD, 0x5A, 0x5B, 0xCE,
	0x5C, 0x5D, 0xCE, 0x5A, 0x5C, 0xD0, 0x5B, 0x5D, 0xCF, 0x5A, 0x5B, 0xCE, 0x5A, 0x5B, 0xCD, 0x5B,
	0x5B, 0xCE, 0x5C, 0x5B, 0xCF, 0x5C, 0x5B, 0xCF, 0x58, 0x5A, 0xD0, 0x56, 0x56, 0xCC, 0x59, 0x5A,
	0xC9, 0x68, 0x69, 0xC7, 0x74, 0x75, 0xC3, 0x77, 0x79, 0xC0, 0x7C, 0x7E, 0xBF, 0x7F, 0x80, 0xC5,
	0x8E, 0x8B, 0xCA, 0x96, 0x90, 0xCF, 0x9E, 0x95, 0xD1, 0xA7, 0x9E, 0xCE, 0xA6, 0x9D, 0xD4, 0xAA,
	0x9E, 0xD5, 0xAA, 0x9F, 0xD2, 0xA7, 0x9D, 0xCF, 0x9E, 0x96, 0xC9, 0x87, 0x84, 0xBF, 0x6B, 0x6E,
	0xBA, 0x54, 0x5A, 0xBF, 0x4C, 0x50, 0xC6, 0x52, 0x53, 0xC7, 0x58, 0x59, 0xC8, 0x5E, 0x61, 0xC9,
	0x60, 0x63, 0xCB, 0x5D, 0x60, 0xCA, 0x5A, 0x5C, 0xCA, 0x59, 0x59, 0xCB, 0x59, 0x58, 0xCB, 0x59,
	0x59, 0xC9, 0x59, 0x58, 0xC9, 0x56, 0x59, 0xC7, 0x52, 0x57, 0xBF, 0x51, 0x58, 0xBB, 0x4D, 0x54,
	0xB9, 0x4B, 0x53, 0xB4, 0x46, 0x51, 0xB6, 0x49, 0x54, 0xC3, 0x57, 0x5D, 0xD2, 0x66, 0x64, 0xD6,
	0x70, 0x69, 0xD5, 0x6F, 0x69, 0xD5, 0x71, 0x6C, 0xD7, 0x76, 0x6E, 0xD9, 0x7A, 0x6E, 0xDA, 0x7D,
	0x6D, 0xDB, 0x7C, 0x6C, 0xDB, 0x7A, 0x69, 0xDD, 0x7A, 0x6A, 0xDC, 0x7B, 0x69, 0xDF, 0x7C, 0x67,
	0xE0, 0x7C, 0x65, 0xDE, 0x79, 0x64, 0xDC, 0x77, 0x64, 0xDA, 0x74, 0x63, 0xD7, 0x70, 0x63, 0xD6,
	0x6F, 0x64, 0xD6, 0x6E, 0x62, 0xD7, 0x6D, 0x60, 0xD6, 0x6D, 0x61, 0xD5, 0x69, 0x5F, 0xD6, 0x6D,
	0x60, 0xE9, 0xA3, 0x79, 0xF4, 0xD0, 0x98, 0xF1, 0xD1, 0xA7, 0xF2, 0xD5, 0xAC, 0xF3, 0xC7, 0x93,
	0xC7, 0x6D, 0x5F, 0xB1, 0x48, 0x52, 0xC1, 0x5B, 0x5A, 0x98, 0x37, 0x47, 0x57, 0x0B, 0x35, 0x4D,
	0x09, 0x37, 0x55, 0x0D, 0x38, 0x59, 0x0F, 0x3A, 0x60, 0x16, 0x3F, 0x61, 0x18, 0x41, 0x61, 0x1B,
	0x42, 0x5E, 0x18, 0x40, 0x58, 0x0F, 0x37, 0x58, 0x0C, 0x34, 0x5C, 0x0E, 0x36, 0x5C, 0x0F, 0x38,
	0xE1, 0x81, 0x6A, 0xE3, 0x84, 0x6A, 0xE7, 0x8D, 0x6E, 0xEA, 0x8E, 0x6F, 0xE3, 0x82, 0x66, 0xDB,
	0x6D, 0x5A, 0xD7, 0x5F, 0x55, 0xD7, 0x64, 0x58, 0xDE, 0x79, 0x63, 0xE6, 0x89, 0x6B, 0xE4, 0x88,
	0x6C, 0xE4, 0x87, 0x6C, 0xE6, 0x8A, 0x6D, 0xE4, 0x81, 0x66, 0xDB, 0x6A, 0x5A, 0xBF, 0x48, 0x4C,
	0x99, 0x2E, 0x41, 0x99, 0x30, 0x42, 0xA6, 0x38, 0x45, 0xAC, 0x3D, 0x49, 0xB0, 0x41, 0x4B, 0xB0,
	0x40, 0x4A, 0xAE, 0x42, 0x4B, 0xB1, 0x42, 0x4B, 0xB2, 0x42, 0x4B, 0xB7, 0x42, 0x4A, 0xBC, 0x48,
	0x50, 0xC2, 0x4F, 0x53, 0xC8, 0x52, 0x51, 0xC9, 0x53, 0x53, 0xC8, 0x53, 0x53, 0xCC, 0x57, 0x54,
	0xCE, 0x59, 0x55, 0xCC, 0x58, 0x52, 0xCB, 0x59, 0x53, 0xCB, 0x5B, 0x58, 0xCE, 0x5C, 0x5C, 0xCD,
	0x5A, 0x5A, 0xCE, 0x59, 0x5A, 0xD1, 0x5B, 0x5C, 0xCF, 0x59, 0x57, 0xCD, 0x56, 0x54, 0xCC, 0x57,
	0x56, 0xCF, 0x5A, 0x58, 0xCF, 0x5B, 0x5A, 0xCB, 0x59, 0x5E, 0xC8, 0x60, 0x64, 0xC3, 0x71, 0x73,
	0xC0, 0x7B, 0x7E, 0xC5, 0x83, 0x82, 0xBE, 0x7B, 0x7D, 0xBD, 0x7A, 0x7B, 0xC4, 0x83, 0x80, 0xCB,
	0x91, 0x8A, 0xCC, 0x93, 0x8B, 0xCE, 0x98, 0x8E, 0xD2, 0xA3, 0x98, 0xD0, 0xA5, 0x9C, 0xCD, 0x9E,
	0x97, 0xCE, 0x9B, 0x92, 0xD2, 0xA4, 0x98, 0xD6, 0xAC, 0x9E, 0xD8, 0xB4, 0xA6, 0xD7, 0xB3, 0xA6,
	0xD1, 0x9F, 0x96, 0xC3, 0x75, 0x75, 0xBB, 0x4D, 0x54, 0xC0, 0x4B, 0x50, 0xC6, 0x57, 0x5A, 0xC7,
	0x5C, 0x60, 0xCA, 0x5B, 0x5F, 0xCA, 0x5C, 0x5F, 0xC9, 0x5A, 0x5C, 0xCA, 0x59, 0x5A, 0xC8, 0x58,
	0x59, 0xC8, 0x57, 0x58, 0xC7, 0x54, 0x59, 0xC4, 0x51, 0x58, 0xBD, 0x4E, 0x56, 0xB9, 0x4D, 0x55,
	0xB7, 0x4B, 0x55, 0xB1, 0x45, 0x52, 0xB6, 0x49, 0x53, 0xC5, 0x59, 0x5C, 0xD3, 0x69, 0x63, 0xD7,
	0x70, 0x67, 0xD5, 0x70, 0x69, 0xD5, 0x6F, 0x6A, 0xD8, 0x73, 0x6B, 0xD8, 0x77, 0x70, 0xD8, 0x7B,
	0x70, 0xDB, 0x7C, 0x6D, 0xDC, 0x7A, 0x69, 0xDC, 0x78, 0x68, 0xDC, 0x79, 0x68, 0xDB, 0x77, 0x65,
	0xDC, 0x77, 0x64, 0xDB, 0x74, 0x63, 0xD9, 0x70, 0x60, 0xD8, 0x6E, 0x61, 0xD8, 0x6F, 0x61, 0xD6,
	0x6B, 0x60, 0xD5, 0x6A, 0x5F, 0xD6, 0x6B, 0x60, 0xD6, 0x6C, 0x60, 0xD6, 0x6C, 0x5F, 0xD4, 0x67,
	0x5E, 0xDA, 0x77, 0x63, 0xF0, 0xBA, 0x83, 0xF3, 0xD3, 0xA3, 0xEE, 0xD3, 0xB1, 0xF4, 0xD9, 0xAE,
	0xE9, 0xB1, 0x85, 0xC5, 0x61, 0x5B, 0x9C, 0x38, 0x49, 0x5A, 0x0E, 0x37, 0x4B, 0x08, 0x37, 0x55,
	0x10, 0x3B, 0x59, 0x11, 0x3B, 0x5E, 0x14, 0x3E, 0x60, 0x17, 0x40, 0x60, 0x15, 0x3D, 0x5E, 0x13,
	0x3C, 0x58, 0x13, 0x3C, 0x59, 0x13, 0x3D, 0x5C, 0x10, 0x37, 0x5B, 0x0D, 0x35, 0x5A, 0x0D, 0x35,
	0xE2, 0x83, 0x6A, 0xE6, 0x8A, 0x6D, 0xEA, 0x91, 0x70, 0xE6, 0x88, 0x6B, 0xDF, 0x77, 0x60, 0xD4,
	0x5C, 0x52, 0xCC, 0x4E, 0x4D, 0xD5, 0x64, 0x5A, 0xE1, 0x7E, 0x66, 0xE8, 0x8A, 0x6A, 0xE7, 0x8A,
	0x6B, 0xE6, 0x89, 0x6C, 0xE6, 0x88, 0x6C, 0xE3, 0x81, 0x66, 0xDC, 0x6C, 0x5C, 0xBE, 0x48, 0x4C,
	0x97, 0x2A, 0x3F, 0x95, 0x2C, 0x41, 0xA2, 0x38, 0x47, 0xA9, 0x3B, 0x48, 0xAB, 0x3E, 0x49, 0xAF,
	0x3F, 0x48, 0xAF, 0x3E, 0x48, 0xAE, 0x3F, 0x49, 0xB1, 0x42, 0x4A, 0xB4, 0x44, 0x4C, 0xBA, 0x48,
	0x4F, 0xC0, 0x4E, 0x53, 0xC6, 0x50, 0x51, 0xC7, 0x51, 0x50, 0xC7, 0x53, 0x53, 0xC9, 0x55, 0x56,
	0xC9, 0x56, 0x55, 0xCA, 0x56, 0x55, 0xCA, 0x58, 0x54, 0xCB, 0x59, 0x56, 0xCD, 0x58, 0x57, 0xCD,
	0x58, 0x5A, 0xCE, 0x59, 0x5B, 0xCC, 0x55, 0x57, 0xCE, 0x57, 0x5A, 0xCC, 0x60, 0x60, 0xCB, 0x6C,
	0x6B, 0xC8, 0x72, 0x74, 0xC3, 0x69, 0x6D, 0xBB, 0x5A, 0x65, 0xBA, 0x67, 0x70, 0xC0, 0x75, 0x78,
	0xBE, 0x74, 0x77, 0xC3, 0x74, 0x75, 0xC3, 0x78, 0x77, 0xC3, 0x7D, 0x7B, 0xC4, 0x7E, 0x7C, 0xC4,
	0x82, 0x7F, 0xC7, 0x8B, 0x85, 0xCD, 0x93, 0x8A, 0xCE, 0x97, 0x8E, 0xCF, 0x9C, 0x93, 0xD0, 0x9E,
	0x94, 0xD1, 0x9D, 0x92, 0xD3, 0xA2, 0x95, 0xD5, 0xA8, 0x9A, 0xD6, 0xAB, 0x9E, 0xDC, 0xB5, 0xA4,
	0xE1, 0xC0, 0xAD, 0xDD, 0xBC, 0xAC, 0xCD, 0x97, 0x91, 0xBA, 0x5D, 0x63, 0xB7, 0x48, 0x51, 0xC2,
	0x53, 0x5B, 0xC6, 0x59, 0x60, 0xC6, 0x59, 0x60, 0xC6, 0x56, 0x5B, 0xC8, 0x57, 0x5C, 0xC7, 0x57,
	0x59, 0xC8, 0x55, 0x58, 0xC3, 0x52, 0x56, 0xBF, 0x4E, 0x53, 0xBD, 0x4B, 0x53, 0xB9, 0x4B, 0x53,
	0xB5, 0x48, 0x53, 0xAF, 0x45, 0x51, 0xB8, 0x4B, 0x53, 0xC9, 0x56, 0x5A, 0xD4, 0x68, 0x63, 0xD8,
	0x71, 0x67, 0xD7, 0x70, 0x68, 0xD5, 0x6F, 0x68, 0xD8, 0x72, 0x6A, 0xD8, 0x76, 0x6F, 0xD6, 0x77,
	0x73, 0xD9, 0x7B, 0x6E, 0xDC, 0x7B, 0x6A, 0xDB, 0x76, 0x66, 0xDA, 0x73, 0x63, 0xD9, 0x72, 0x62,
	0xD9, 0x70, 0x60, 0xD9, 0x70, 0x62, 0xD9, 0x6F, 0x60, 0xD8, 0x6D, 0x5F, 0xD8, 0x6D, 0x60, 0xD6,
	0x6B, 0x60, 0xD5, 0x69, 0x5E, 0xD6, 0x6A, 0x5D, 0xD6, 0x6B, 0x5E, 0xD7, 0x6C, 0x5E, 0xD6, 0x6B,
	0x5F, 0xD1, 0x60, 0x5A, 0xE3, 0x8F, 0x6B, 0xF4, 0xCE, 0x96, 0xF0, 0xD3, 0xAC, 0xEE, 0xD6, 0xB5,
	0xFB, 0xDD, 0xA9, 0xCB, 0x7D, 0x67, 0x5D, 0x0A, 0x35, 0x47, 0x07, 0x38, 0x53, 0x0F, 0x3B, 0x57,
	0x11, 0x3C, 0x5F, 0x16, 0x3E, 0x63, 0x16, 0x3E, 0x60, 0x16, 0x3E, 0x60, 0x15, 0x3D, 0x5A, 0x12,
	0x3C, 0x5A, 0x14, 0x3E, 0x5E, 0x15, 0x3F, 0x5A, 0x12, 0x3B, 0x58, 0x0E, 0x37, 0x5D, 0x0F, 0x36,
	0xE5, 0x89, 0x6D, 0xE9, 0x92, 0x70, 0xE9, 0x90, 0x6F, 0xE3, 0x80, 0x66, 0xDA, 0x68, 0x59, 0xBE,
	0x43, 0x49, 0xBB, 0x42, 0x49, 0xD7, 0x66, 0x5B, 0xE2, 0x80, 0x68, 0xE8, 0x8B, 0x6C, 0xE9, 0x8C,
	0x6C, 0xE7, 0x8A, 0x6B, 0xE8, 0x89, 0x6C, 0xE3, 0x82, 0x67, 0xDC, 0x6D, 0x5B, 0xBE, 0x49, 0x4D,
	0x95, 0x2B, 0x3F, 0x8F, 0x2A, 0x41, 0x9B, 0x35, 0x46, 0xA4, 0x39, 0x47, 0xA7, 0x3D, 0x4A, 0xA9,
	0x3C, 0x47, 0xAB, 0x3C, 0x47, 0xAD, 0x3E, 0x47, 0xAF, 0x41, 0x4A, 0xB2, 0x43, 0x4B, 0xB7, 0x47,
	0x4E, 0xBD, 0x4A, 0x51, 0xC3, 0x4F, 0x51, 0xC4, 0x4F, 0x52, 0xC5, 0x53, 0x55, 0xC6, 0x53, 0x52,
	0xC8, 0x54, 0x52, 0xC9, 0x56, 0x55, 0xC9, 0x56, 0x53, 0xCB, 0x57, 0x55, 0xCD, 0x57, 0x57, 0xCD,
	0x57, 0x59, 0xCD, 0x54, 0x57, 0xCF, 0x5D, 0x5C, 0xCF, 0x62, 0x62, 0xC9, 0x71, 0x71, 0xC3, 0x73,
	0x74, 0xBC, 0x6A, 0x6F, 0xBB, 0x5F, 0x66, 0xBA, 0x57, 0x62, 0xB8, 0x61, 0x6B, 0xBD, 0x6B, 0x71,
	0xBB, 0x67, 0x6E, 0xBD, 0x68, 0x6F, 0xC1, 0x71, 0x73, 0xC3, 0x75, 0x76, 0xC6, 0x7E, 0x7B, 0xC6,
	0x81, 0x7D, 0xCA, 0x8C, 0x85, 0xCC, 0x8F, 0x88, 0xCB, 0x91, 0x8A, 0xCD, 0x96, 0x8E, 0xD2, 0xA0,
	0x96, 0xD3, 0xA5, 0x9A, 0xD6, 0xA8, 0x9B, 0xD9, 0xAB, 0x9A, 0xD9, 0xAC, 0x9B, 0xDB, 0xB0, 0x9E,
	0xDC, 0xB3, 0xA2, 0xDD, 0xB8, 0xA9, 0xE0, 0xC5, 0xB1, 0xD5, 0xB1, 0xA4, 0xBD, 0x78, 0x7A, 0xB2,
	0x4A, 0x57, 0xBA, 0x44, 0x50, 0xC2, 0x51, 0x59, 0xC4, 0x54, 0x5A, 0xC4, 0x55, 0x5C, 0xC7, 0x54,
	0x58, 0xC7, 0x53, 0x59, 0xC1, 0x52, 0x57, 0xBF, 0x4E, 0x53, 0xBD, 0x4A, 0x51, 0xB6, 0x48, 0x52,
	0xB1, 0x45, 0x51, 0xAE, 0x41, 0x4C, 0xB7, 0x47, 0x4F, 0xCA, 0x55, 0x5A, 0xD6, 0x67, 0x62, 0xD9,
	0x72, 0x68, 0xD8, 0x71, 0x69, 0xD6, 0x6F, 0x65, 0xD7, 0x70, 0x68, 0xD7, 0x73, 0x6C, 0xD7, 0x73,
	0x6C, 0xD8, 0x77, 0x6D, 0xDB, 0x7A, 0x6C, 0xDC, 0x79, 0x6A, 0xD8, 0x70, 0x62, 0xD8, 0x6D, 0x60,
	0xD8, 0x6C, 0x5E, 0xD8, 0x6E, 0x60, 0xD8, 0x70, 0x62, 0xD8, 0x6E, 0x60, 0xD8, 0x6E, 0x61, 0xD7,
	0x6F, 0x62, 0xD6, 0x6B, 0x5F, 0xD7, 0x6B, 0x5E, 0xD7, 0x6B, 0x5D, 0xD7, 0x6D, 0x61, 0xD7, 0x6F,
	0x62, 0xD3, 0x65, 0x5D, 0xD7, 0x6C, 0x5E, 0xED, 0xAD, 0x7C, 0xF2, 0xD3, 0xA3, 0xF0, 0xDC, 0xBC,
	0xFF, 0xDF, 0xAC, 0xA6, 0x5C, 0x58, 0x3F, 0x00, 0x30, 0x4E, 0x0C, 0x3A, 0x58, 0x10, 0x3C, 0x5A,
	0x12, 0x3C, 0x60, 0x16, 0x3F, 0x62, 0x17, 0x3F, 0x60, 0x15, 0x3A, 0x59, 0x0F, 0x38, 0x59, 0x11,
	0x3B, 0x60, 0x16, 0x3F, 0x5A, 0x10, 0x3A, 0x56, 0x0F, 0x38, 0x5E, 0x11, 0x37, 0x64, 0x14, 0x38,
	0xE8, 0x90, 0x6F, 0xE9, 0x95, 0x70, 0xE6, 0x88, 0x6A, 0xE1, 0x76, 0x60, 0xCA, 0x53, 0x50, 0x9E,
	0x2D, 0x41, 0xB2, 0x3D, 0x47, 0xD8, 0x68, 0x5B, 0xE3, 0x82, 0x67, 0xE9, 0x8B, 0x6C, 0xE8, 0x8C,
	0x6D, 0xE7, 0x8A, 0x6C, 0xE9, 0x8A, 0x6C, 0xE4, 0x82, 0x66, 0xDC, 0x6A, 0x59, 0xBF, 0x48, 0x4B,
	0x92, 0x29, 0x3F, 0x8B, 0x27, 0x3E, 0x9A, 0x31, 0x43, 0xA1, 0x38, 0x46, 0xA6, 0x39, 0x46, 0xA7,
	0x3A, 0x46, 0xAA, 0x3C, 0x48, 0xAA, 0x3E, 0x49, 0xAD, 0x40, 0x4B, 0xB2, 0x42, 0x4A, 0xB4, 0x44,
	0x4C, 0xB8, 0x46, 0x4E, 0xC0, 0x4D, 0x51, 0xC1, 0x4E, 0x53, 0xC3, 0x4F, 0x52, 0xC5, 0x52, 0x52,
	0xC8, 0x57, 0x57, 0xC7, 0x56, 0x55, 0xC9, 0x56, 0x55, 0xCC, 0x56, 0x57, 0xCB, 0x57, 0x56, 0xCA,
	0x53, 0x53, 0xCF, 0x57, 0x58, 0xD4, 0x72, 0x65, 0xB9, 0x52, 0x57, 0xBB, 0x57, 0x5D, 0xBC, 0x5A,
	0x5E, 0xBA, 0x57, 0x5D, 0xBB, 0x59, 0x61, 0xB8, 0x58, 0x62, 0xBB, 0x62, 0x6A, 0xBF, 0x68, 0x6F,
	0xB7, 0x62, 0x6B, 0xB8, 0x66, 0x6E, 0xBE, 0x6E, 0x72, 0xC2, 0x6F, 0x72, 0xC1, 0x75, 0x76, 0xC3,
	0x7C, 0x7B, 0xC7, 0x86, 0x81, 0xC7, 0x88, 0x83, 0xCD, 0x96, 0x8D, 0xD1, 0x9D, 0x92, 0xD3, 0xA0,
	0x97, 0xD6, 0xAA, 0x9E, 0xD7, 0xAB, 0x9D, 0xD8, 0xA9, 0x99, 0xD9, 0xAC, 0x9C, 0xDA, 0xAD, 0x9C,
	0xDC, 0xAE, 0x9E, 0xDB, 0xB5, 0xA6, 0xDC, 0xBB, 0xAB, 0xDF, 0xC1, 0xAF, 0xDB, 0xBC, 0xAC, 0xC7,
	0x92, 0x8D, 0xB1, 0x54, 0x5C, 0xB1, 0x3E, 0x4A, 0xBA, 0x4D, 0x56, 0xBD, 0x50, 0x57, 0xC1, 0x50,
	0x55, 0xC3, 0x51, 0x56, 0xBF, 0x50, 0x56, 0xBC, 0x4D, 0x55, 0xBA, 0x49, 0x52, 0xB4, 0x47, 0x54,
	0xB0, 0x45, 0x51, 0xAC, 0x41, 0x4C, 0xB4, 0x45, 0x51, 0xC9, 0x57, 0x5B, 0xD8, 0x68, 0x62, 0xDC,
	0x74, 0x69, 0xDC, 0x75, 0x69, 0xD8, 0x71, 0x66, 0xD6, 0x6F, 0x69, 0xD6, 0x70, 0x6A, 0xD6, 0x71,
	0x69, 0xD7, 0x70, 0x6A, 0xD8, 0x74, 0x6B, 0xDC, 0x79, 0x6B, 0xD9, 0x72, 0x65, 0xD5, 0x6A, 0x60,
	0xD7, 0x6B, 0x5E, 0xD9, 0x6D, 0x5E, 0xD9, 0x70, 0x60, 0xD9, 0x6F, 0x60, 0xD7, 0x6E, 0x61, 0xD8,
	0x6E, 0x60, 0xD7, 0x6C, 0x5E, 0xD6, 0x6B, 0x5F, 0xD6, 0x6C, 0x61, 0xD7, 0x6F, 0x63, 0xD7, 0x6F,
	0x62, 0xD6, 0x6E, 0x63, 0xD4, 0x68, 0x61, 0xDF, 0x82, 0x6A, 0xF3, 0xCB, 0x99, 0xFF, 0xE4, 0xAE,
	0xD2, 0x8D, 0x71, 0x5B, 0x10, 0x37, 0x45, 0x07, 0x35, 0x52, 0x0F, 0x39, 0x5A, 0x11, 0x3B, 0x61,
	0x16, 0x3E, 0x62, 0x18, 0x3F, 0x64, 0x19, 0x3F, 0x5A, 0x11, 0x39, 0x56, 0x0E, 0x38, 0x5E, 0x14,
	0x3D, 0x5B, 0x12, 0x3B, 0x55, 0x0D, 0x38, 0x5C, 0x10, 0x38, 0x64, 0x16, 0x39, 0x53, 0x0A, 0x35,
	0xE9, 0x92, 0x72, 0xEA, 0x8E, 0x6E, 0xE3, 0x80, 0x66, 0xDA, 0x66, 0x59, 0xAD, 0x3A, 0x46, 0x8C,
	0x23, 0x3C, 0xB3, 0x40, 0x49, 0xD7, 0x67, 0x59, 0xE3, 0x80, 0x64, 0xE9, 0x8C, 0x6D, 0xE8, 0x8D,
	0x70, 0xE7, 0x8A, 0x6E, 0xE7, 0x88, 0x6C, 0xE1, 0x7D, 0x63, 0xDB, 0x66, 0x57, 0xBE, 0x47, 0x4B,
	0x90, 0x27, 0x3E, 0x8B, 0x27, 0x3E, 0x9B, 0x35, 0x45, 0xA0, 0x39, 0x49, 0xA6, 0x3D, 0x4D, 0xA8,
	0x40, 0x4F, 0xA9, 0x3E, 0x4C, 0xA9, 0x3E, 0x4B, 0xAB, 0x3F, 0x4C, 0xAD, 0x41, 0x4B, 0xB4, 0x45,
	0x4E, 0xB9, 0x48, 0x4F, 0xBD, 0x4B, 0x51, 0xBE, 0x4B, 0x51, 0xC1, 0x4D, 0x52, 0xC3, 0x51, 0x55,
	0xC5, 0x54, 0x56, 0xC7, 0x53, 0x54, 0xC9, 0x56, 0x55, 0xCB, 0x57, 0x56, 0xCB, 0x56, 0x55, 0xCB,
	0x53, 0x53, 0xCE, 0x5E, 0x59, 0xC2, 0x58, 0x57, 0xB4, 0x47, 0x53, 0xBE, 0x52, 0x58, 0xBC, 0x54,
	0x5A, 0xBB, 0x57, 0x60, 0xBB, 0x5A, 0x61, 0xB9, 0x58, 0x62, 0xBF, 0x61, 0x69, 0xC0, 0x66, 0x6B,
	0xB8, 0x63, 0x6B, 0xBC, 0x66, 0x6E, 0xC3, 0x6B, 0x6D, 0xC0, 0x69, 0x6B, 0xBD, 0x6F, 0x72, 0xC1,
	0x73, 0x74, 0xC6, 0x7D, 0x7A, 0xCB, 0x8B, 0x83, 0xD1, 0x98, 0x8E, 0xD3, 0x9E, 0x92, 0xD3, 0x9F,
	0x92, 0xD4, 0xA3, 0x97, 0xD4, 0xA5, 0x99, 0xD6, 0xA9, 0x9A, 0xD9, 0xAF, 0xA0, 0xDA, 0xB1, 0xA1,
	0xDC, 0xB1, 0xA1, 0xDD, 0xB7, 0xA5, 0xDC, 0xBB, 0xAA, 0xDC, 0xB9, 0xA9, 0xDC, 0xBB, 0xAC, 0xE1,
	0xC7, 0xB6, 0xD4, 0xB0, 0xA4, 0xB2, 0x62, 0x6A, 0xA2, 0x34, 0x45, 0xAB, 0x39, 0x44, 0xB6, 0x46,
	0x4E, 0xBC, 0x4D, 0x53, 0xBC, 0x4D, 0x54, 0xBA, 0x4A, 0x53, 0xB5, 0x48, 0x56, 0xB3, 0x47, 0x55,
	0xB2, 0x46, 0x52, 0xAC, 0x41, 0x4D, 0xB2, 0x44, 0x50, 0xC8, 0x56, 0x59, 0xD9, 0x6A, 0x63, 0xDE,
	0x78, 0x6B, 0xDE, 0x79, 0x6B, 0xDC, 0x75, 0x69, 0xD7, 0x73, 0x6A, 0xD5, 0x6E, 0x66, 0xD4, 0x6B,
	0x67, 0xD4, 0x69, 0x67, 0xD5, 0x6A, 0x63, 0xD9, 0x73, 0x67, 0xDA, 0x75, 0x67, 0xD7, 0x6D, 0x62,
	0xD8, 0x6C, 0x5E, 0xDA, 0x6E, 0x5F, 0xDA, 0x71, 0x62, 0xD9, 0x70, 0x61, 0xD7, 0x6D, 0x60, 0xD8,
	0x6C, 0x5F, 0xD7, 0x6C, 0x60, 0xD6, 0x6D, 0x63, 0xD7, 0x6F, 0x63, 0xD9, 0x6F, 0x61, 0xD9, 0x6F,
	0x62, 0xD8, 0x71, 0x65, 0xD7, 0x72, 0x67, 0xDC, 0x78, 0x69, 0xF5, 0xAD, 0x7E, 0xD4, 0x8C, 0x6B,
	0x69, 0x19, 0x3B, 0x46, 0x04, 0x36, 0x53, 0x10, 0x39, 0x56, 0x10, 0x39, 0x5D, 0x13, 0x3A, 0x61,
	0x15, 0x3C, 0x62, 0x16, 0x3C, 0x5C, 0x12, 0x3B, 0x58, 0x13, 0x3D, 0x60, 0x17, 0x3F, 0x5D, 0x15,
	0x3E, 0x54, 0x0F, 0x3A, 0x5C, 0x13, 0x3B, 0x6D, 0x20, 0x42, 0x55, 0x10, 0x39, 0x3F, 0x00, 0x33,
	0xEA, 0x91, 0x74, 0xE8, 0x88, 0x6A, 0xE0, 0x75, 0x5F, 0xC5, 0x4F, 0x4E, 0x93, 0x29, 0x3F, 0x8E,
	0x27, 0x3E, 0xB7, 0x45, 0x4C, 0xD6, 0x66, 0x59, 0xE3, 0x80, 0x65, 0xE9, 0x8D, 0x6C, 0xE8, 0x8C,
	0x6D, 0xE7, 0x8A, 0x6D, 0xE7, 0x88, 0x6B, 0xE1, 0x7D, 0x63, 0xDB, 0x67, 0x59, 0xBB, 0x46, 0x4A,
	0x8F, 0x24, 0x3D, 0x8D, 0x27, 0x3E, 0x9D, 0x35, 0x45, 0xA4, 0x3B, 0x4B, 0xA7, 0x3F, 0x4F, 0xA8,
	0x40, 0x50, 0xA9, 0x3F, 0x4D, 0xAA, 0x3D, 0x4A, 0xAA, 0x3D, 0x4B, 0xAD, 0x40, 0x4C, 0xB4, 0x47,
	0x4E, 0xB7, 0x48, 0x50, 0xBB, 0x4A, 0x51, 0xBE, 0x4D, 0x53, 0xBF, 0x4D, 0x53, 0xC3, 0x51, 0x54,
	0xC6, 0x51, 0x52, 0xC6, 0x51, 0x52, 0xC7, 0x55, 0x54, 0xCA, 0x56, 0x54, 0xCA, 0x51, 0x52, 0xD1,
	0x5F, 0x5C, 0xD0, 0x68, 0x5F, 0xBA, 0x49, 0x50, 0xBC, 0x4C, 0x52, 0xB9, 0x4A, 0x51, 0xB9, 0x4C,
	0x55, 0xBB, 0x54, 0x5B, 0xBD, 0x5B, 0x61, 0xC1, 0x5D, 0x61, 0xC0, 0x5F, 0x62, 0xBE, 0x61, 0x66,
	0xC1, 0x67, 0x6C, 0xC5, 0x6B, 0x6C, 0xC3, 0x6A, 0x6C, 0xC0, 0x6A, 0x6D, 0xC1, 0x6C, 0x6F, 0xC2,
	0x71, 0x74, 0xC2, 0x7B, 0x7A, 0xC8, 0x84, 0x7D, 0xCB, 0x8D, 0x85, 0xCF, 0x93, 0x8A, 0xD4, 0x9D,
	0x92, 0xD5, 0xA4, 0x9A, 0xD4, 0xA6, 0x9C, 0xD7, 0xAC, 0x9E, 0xDB, 0xB2, 0xA3, 0xDB, 0xB2, 0xA3,
	0xDB, 0xB4, 0xA5, 0xDD, 0xB8, 0xA9, 0xDD, 0xBA, 0xA8, 0xDC, 0xB8, 0xA6, 0xDA, 0xB7, 0xA9, 0xDB,
	0xB9, 0xAD, 0xE1, 0xC3, 0xB3, 0xD8, 0xB9, 0xAA, 0xB5, 0x77, 0x7D, 0xA1, 0x4D, 0x5B, 0xA2, 0x37,
	0x44, 0xB0, 0x42, 0x4D, 0xB7, 0x4B, 0x53, 0xB6, 0x48, 0x52, 0xB3, 0x44, 0x52, 0xB3, 0x45, 0x52,
	0xB2, 0x45, 0x51, 0xAB, 0x3F, 0x4E, 0xB1, 0x42, 0x50, 0xC7, 0x55, 0x5B, 0xDA, 0x6D, 0x69, 0xDF,
	0x79, 0x6A, 0xDF, 0x7C, 0x6B, 0xDE, 0x7B, 0x6D, 0xDC, 0x77, 0x6B, 0xD7, 0x6F, 0x65, 0xCF, 0x62,
	0x61, 0xC8, 0x5C, 0x5F, 0xCC, 0x5C, 0x5C, 0xD5, 0x69, 0x63, 0xDA, 0x76, 0x6A, 0xDB, 0x71, 0x63,
	0xDA, 0x6B, 0x5E, 0xDB, 0x6E, 0x61, 0xDB, 0x73, 0x64, 0xDA, 0x6F, 0x5F, 0xD8, 0x6C, 0x5F, 0xD8,
	0x6C, 0x5F, 0xD8, 0x6C, 0x62, 0xD8, 0x6E, 0x64, 0xD8, 0x6F, 0x63, 0xD9, 0x70, 0x63, 0xDA, 0x72,
	0x64, 0xDC, 0x75, 0x65, 0xDD, 0x79, 0x68, 0xE9, 0x84, 0x6D, 0xC9, 0x61, 0x59, 0x67, 0x14, 0x39,
	0x47, 0x05, 0x36, 0x52, 0x0E, 0x38, 0x56, 0x0F, 0x39, 0x5F, 0x15, 0x3E, 0x62, 0x17, 0x3D, 0x61,
	0x12, 0x39, 0x5B, 0x0E, 0x37, 0x56, 0x0E, 0x38, 0x61, 0x19, 0x3F, 0x5F, 0x18, 0x41, 0x55, 0x12,
	0x3D, 0x5A, 0x14, 0x3D, 0x6A, 0x21, 0x44, 0x60, 0x18, 0x3F, 0x42, 0x01, 0x32, 0x83, 0x38, 0x53,
	0xE8, 0x8C, 0x6E, 0xE3, 0x7F, 0x66, 0xD6, 0x61, 0x56, 0xAA, 0x38, 0x45, 0x8E, 0x2A, 0x41, 0x94,
	0x2D, 0x41, 0xB7, 0x45, 0x4D, 0xD8, 0x67, 0x5B, 0xE3, 0x81, 0x67, 0xE9, 0x8C, 0x6C, 0xE9, 0x8E,
	0x6E, 0xE8, 0x8B, 0x6C, 0xE7, 0x88, 0x6A, 0xE2, 0x7F, 0x65, 0xDC, 0x68, 0x5A, 0xBB, 0x45, 0x4A,
	0x90, 0x27, 0x3E, 0x8D, 0x29, 0x3E, 0x9E, 0x33, 0x44, 0xA5, 0x3C, 0x4C, 0xA8, 0x3F, 0x4D, 0xA9,
	0x3C, 0x4A, 0xA9, 0x3E, 0x4B, 0xAA, 0x3F, 0x4C, 0xAC, 0x3F, 0x4B, 0xAE, 0x41, 0x4C, 0xB3, 0x45,
	0x4D, 0xB6, 0x49, 0x50, 0xBA, 0x4D, 0x52, 0xC0, 0x4D, 0x53, 0xBE, 0x4B, 0x51, 0xC1, 0x51, 0x54,
	0xC6, 0x52, 0x55, 0xC6, 0x53, 0x56, 0xC7, 0x55, 0x56, 0xC8, 0x52, 0x55, 0xCB, 0x53, 0x55, 0xD6,
	0x67, 0x5D, 0xCB, 0x5C, 0x57, 0xB9, 0x45, 0x4C, 0xB4, 0x45, 0x4D, 0xB7, 0x48, 0x52, 0xBB, 0x50,
	0x57, 0xB9, 0x51, 0x56, 0xBD, 0x58, 0x5C, 0xC0, 0x5C, 0x60, 0xBF, 0x5B, 0x60, 0xBF, 0x61, 0x67,
	0xBF, 0x61, 0x66, 0xC4, 0x65, 0x67, 0xC3, 0x6B, 0x6D, 0xC2, 0x6B, 0x6E, 0xC0, 0x69, 0x6E, 0xC2,
	0x72, 0x73, 0xC7, 0x79, 0x76, 0xC7, 0x7E, 0x79, 0xC8, 0x88, 0x82, 0xCE, 0x95, 0x8C, 0xD6, 0xA3,
	0x98, 0xD8, 0xAA, 0x9D, 0xD8, 0xAB, 0x9E, 0xD8, 0xAA, 0x9C, 0xDA, 0xAD, 0x9E, 0xDB, 0xB1, 0xA2,
	0xDC, 0xB6, 0xA6, 0xDD, 0xB6, 0xA6, 0xDC, 0xB4, 0xA2, 0xD8, 0xB0, 0xA2, 0xD8, 0xB3, 0xA9, 0xDB,
	0xBB, 0xAF, 0xDE, 0xC2, 0xB4, 0xE6, 0xD0, 0xBD, 0xEB, 0xD9, 0xBF, 0xE0, 0xC8, 0xB2, 0xAC, 0x5F,
	0x66, 0x99, 0x2B, 0x3D, 0xAE, 0x45, 0x4F, 0xB1, 0x46, 0x50, 0xAE, 0x41, 0x4D, 0xB0, 0x42, 0x4E,
	0xAC, 0x43, 0x50, 0xA5, 0x3E, 0x50, 0xAE, 0x43, 0x53, 0xC5, 0x56, 0x5F, 0xDA, 0x6E, 0x68, 0xDF,
	0x7A, 0x69, 0xE0, 0x7E, 0x6B, 0xE0, 0x7E, 0x6C, 0xDF, 0x7B, 0x6C, 0xDB, 0x74, 0x67, 0xCD, 0x5D,
	0x5B, 0xB9, 0x49, 0x51, 0xB9, 0x49, 0x52, 0xCC, 0x5B, 0x5D, 0xD9, 0x6E, 0x67, 0xDC, 0x74, 0x68,
	0xDA, 0x6E, 0x62, 0xDB, 0x6D, 0x60, 0xDD, 0x72, 0x62, 0xDB, 0x6E, 0x5F, 0xD9, 0x6C, 0x5F, 0xD8,
	0x6D, 0x60, 0xD9, 0x6C, 0x63, 0xD8, 0x6E, 0x61, 0xD9, 0x6D, 0x60, 0xD9, 0x6E, 0x63, 0xDB, 0x71,
	0x65, 0xDD, 0x76, 0x68, 0xE6, 0x82, 0x6D, 0xDB, 0x71, 0x62, 0x79, 0x21, 0x41, 0x46, 0x06, 0x38,
	0x53, 0x0F, 0x39, 0x55, 0x0D, 0x38, 0x5B, 0x11, 0x3B, 0x62, 0x17, 0x3F, 0x64, 0x16, 0x3A, 0x5C,
	0x0E, 0x36, 0x56, 0x0D, 0x38, 0x61, 0x16, 0x3D, 0x61, 0x17, 0x3F, 0x56, 0x13, 0x3D, 0x57, 0x12,
	0x3C, 0x69, 0x22, 0x49, 0x6A, 0x23, 0x48, 0x44, 0x03, 0x34, 0x70, 0x28, 0x4C, 0xD7, 0x80, 0x75,
	0xE4, 0x85, 0x6A, 0xDF, 0x6F, 0x5F, 0xBF, 0x47, 0x4B, 0x95, 0x2B, 0x40, 0x92, 0x2D, 0x40, 0x97,
	0x2F, 0x41, 0xB6, 0x46, 0x4D, 0xD8, 0x68, 0x5B, 0xE3, 0x7F, 0x65, 0xE8, 0x8B, 0x6C, 0xE9, 0x8D,
	0x6D, 0xE9, 0x8D, 0x6D, 0xE6, 0x89, 0x6C, 0xE1, 0x7D, 0x65, 0xDB, 0x65, 0x58, 0xBB, 0x43, 0x49,
	0x90, 0x29, 0x3F, 0x8E, 0x29, 0x3F, 0x9E, 0x35, 0x45, 0xA5, 0x3A, 0x49, 0xA8, 0x3D, 0x4B, 0xA8,
	0x3D, 0x4B, 0xA9, 0x3D, 0x4A, 0xA9, 0x3F, 0x4D, 0xAA, 0x3F, 0x4C, 0xAD, 0x41, 0x4C, 0xB2, 0x45,
	0x4E, 0xB8, 0x4A, 0x51, 0xBB, 0x4D, 0x52, 0xBC, 0x4C, 0x52, 0xBF, 0x4D, 0x52, 0xC4, 0x53, 0x55,
	0xC6, 0x55, 0x58, 0xC7, 0x56, 0x58, 0xC7, 0x54, 0x55, 0xC8, 0x52, 0x54, 0xCF, 0x5A, 0x5A, 0xCC,
	0x58, 0x55, 0xBA, 0x46, 0x4D, 0xB6, 0x44, 0x4D, 0xB7, 0x4A, 0x54, 0xBB, 0x52, 0x5A, 0xBA, 0x54,
	0x5A, 0xBC, 0x53, 0x5A, 0xBF, 0x58, 0x5D, 0xBD, 0x58, 0x5E, 0xBB, 0x58, 0x5E, 0xBB, 0x5D, 0x63,
	0xBE, 0x5E, 0x64, 0xC1, 0x65, 0x6A, 0xC1, 0x68, 0x6C, 0xC2, 0x67, 0x6A, 0xC2, 0x69, 0x6B, 0xC4,
	0x70, 0x70, 0xC7, 0x6F, 0x6F, 0xCA, 0x7C, 0x79, 0xCB, 0x88, 0x81, 0xD2, 0x96, 0x8B, 0xD8, 0xA7,
	0x9A, 0xDA, 0xAC, 0x9D, 0xD9, 0xAD, 0x9E, 0xD8, 0xAD, 0x9F, 0xD9, 0xAF, 0x9F, 0xD9, 0xAD, 0x9E,
	0xD6, 0xA9, 0x9C, 0xD5, 0xA9, 0x9F, 0xD9, 0xB4, 0xA7, 0xDC, 0xBF, 0xB2, 0xE0, 0xC7, 0xB8, 0xE3,
	0xCB, 0xBB, 0xE3, 0xCB, 0xBC, 0xE2, 0xC9, 0xBA, 0xE8, 0xD0, 0xBA, 0xF9, 0xE8, 0xC1, 0xDA, 0xB8,
	0xA5, 0x92, 0x38, 0x4C, 0x99, 0x2E, 0x40, 0xAA, 0x42, 0x4F, 0xAC, 0x40, 0x4E, 0xAB, 0x3F, 0x4D,
	0xA9, 0x3F, 0x4F, 0xA4, 0x3D, 0x4F, 0xAB, 0x43, 0x53, 0xC2, 0x55, 0x5C, 0xD8, 0x6A, 0x65, 0xDF,
	0x78, 0x69, 0xE0, 0x7C, 0x69, 0xDF, 0x7B, 0x68, 0xDF, 0x7B, 0x6B, 0xDC, 0x76, 0x6A, 0xD2, 0x61,
	0x5C, 0xAD, 0x3E, 0x49, 0x96, 0x2E, 0x42, 0xB2, 0x43, 0x4F, 0xD3, 0x63, 0x62, 0xDC, 0x73, 0x6A,
	0xDC, 0x72, 0x65, 0xDA, 0x6C, 0x5F, 0xDD, 0x6F, 0x60, 0xDB, 0x6E, 0x60, 0xD8, 0x6C, 0x61, 0xD9,
	0x6D, 0x61, 0xDA, 0x6C, 0x62, 0xDA, 0x6E, 0x63, 0xD8, 0x6F, 0x63, 0xDB, 0x6F, 0x63, 0xDD, 0x72,
	0x65, 0xE1, 0x7B, 0x6B, 0xE5, 0x7B, 0x69, 0x96, 0x36, 0x48, 0x49, 0x06, 0x37, 0x4F, 0x0A, 0x37,
	0x57, 0x0D, 0x37, 0x5D, 0x12, 0x3A, 0x62, 0x16, 0x3D, 0x62, 0x15, 0x3C, 0x5F, 0x12, 0x3A, 0x56,
	0x0D, 0x37, 0x5F, 0x12, 0x3B, 0x64, 0x18, 0x3E, 0x56, 0x11, 0x3B, 0x54, 0x10, 0x3A, 0x60, 0x19,
	0x41, 0x70, 0x2B, 0x53, 0x5F, 0x1A, 0x46, 0x6E, 0x24, 0x49, 0xBD, 0x6C, 0x70, 0xE2, 0x8D, 0x78,
	0xE1, 0x76, 0x61, 0xCF, 0x58, 0x52, 0xA0, 0x32, 0x42, 0x94, 0x2E, 0x42, 0x9A, 0x32, 0x43, 0x99,
	0x30, 0x42, 0xB6, 0x45, 0x4C, 0xD7, 0x68, 0x59, 0xE3, 0x80, 0x65, 0xE9, 0x8B, 0x6C, 0xEA, 0x8D,
	0x6C, 0xE8, 0x8C, 0x6D, 0xE6, 0x89, 0x6C, 0xE0, 0x7B, 0x62, 0xD9, 0x63, 0x57, 0xB9, 0x45, 0x4B,
	0x91, 0x2C, 0x41, 0x90, 0x2A, 0x3F, 0x9E, 0x36, 0x44, 0xA4, 0x39, 0x47, 0xA9, 0x3D, 0x4A, 0xAB,
	0x3D, 0x4B, 0xAA, 0x3F, 0x4D, 0xAB, 0x42, 0x51, 0xA9, 0x3F, 0x4D, 0xAC, 0x40, 0x4D, 0xB3, 0x46,
	0x4D, 0xB7, 0x4A, 0x4F, 0xBC, 0x4C, 0x51, 0xBF, 0x4D, 0x51, 0xC2, 0x4E, 0x52, 0xC4, 0x52, 0x54,
	0xC6, 0x53, 0x53, 0xC7, 0x53, 0x53, 0xC8, 0x55, 0x55, 0xCC, 0x58, 0x56, 0xCC, 0x57, 0x56, 0xBA,
	0x47, 0x4E, 0xB2, 0x42, 0x4B, 0xB8, 0x49, 0x4F, 0xBC, 0x4F, 0x56, 0xBC, 0x54, 0x5C, 0xBD, 0x57,
	0x5C, 0xBF, 0x58, 0x5C, 0xBD, 0x56, 0x5C, 0xB8, 0x53, 0x5A, 0xB8, 0x54, 0x5B, 0xBF, 0x5D, 0x62,
	0xC3, 0x63, 0x67, 0xC5, 0x6A, 0x6B, 0xC7, 0x6A, 0x6B, 0xC6, 0x67, 0x6A, 0xC2, 0x6A, 0x6B, 0xC3,
	0x6E, 0x6F, 0xC7, 0x6D, 0x6F, 0xCC, 0x7B, 0x76, 0xCF, 0x87, 0x7E, 0xD3, 0x92, 0x88, 0xD7, 0xA2,
	0x95, 0xD8, 0xA7, 0x99, 0xDA, 0xAD, 0x9D, 0xDB, 0xB0, 0xA0, 0xD3, 0x9F, 0x92, 0xD1, 0x9F, 0x96,
	0xD5, 0xAF, 0xA8, 0xDC, 0xC0, 0xB4, 0xE2, 0xC8, 0xB7, 0xE3, 0xC9, 0xB7, 0xE3, 0xCA, 0xBA, 0xE3,
	0xC8, 0xB9, 0xE2, 0xC7, 0xB8, 0xE2, 0xC6, 0xB8, 0xE3, 0xC7, 0xB5, 0xE9, 0xD1, 0xB8, 0xF3, 0xE2,
	0xC1, 0xC1, 0x91, 0x8F, 0x8C, 0x28, 0x3F, 0x9B, 0x2F, 0x41, 0xA6, 0x3D, 0x4C, 0xA7, 0x3F, 0x4F,
	0xA5, 0x3F, 0x4F, 0xA3, 0x3A, 0x4C, 0xAC, 0x40, 0x4E, 0xC5, 0x53, 0x58, 0xD7, 0x68, 0x65, 0xDF,
	0x79, 0x6A, 0xE0, 0x7C, 0x69, 0xDF, 0x7A, 0x68, 0xDE, 0x7B, 0x6B, 0xDC, 0x73, 0x6B, 0xD4, 0x65,
	0x60, 0xA8, 0x3F, 0x4B, 0x73, 0x18, 0x38, 0x8D, 0x27, 0x3F, 0xC5, 0x52, 0x58, 0xD8, 0x6A, 0x68,
	0xDC, 0x73, 0x6A, 0xDB, 0x70, 0x63, 0xDC, 0x6F, 0x62, 0xDB, 0x6F, 0x63, 0xD9, 0x6C, 0x62, 0xD9,
	0x6C, 0x61, 0xDA, 0x6C, 0x61, 0xDC, 0x6E, 0x63, 0xD9, 0x6D, 0x62, 0xDB, 0x6D, 0x62, 0xDF, 0x75,
	0x67, 0xEA, 0x83, 0x6C, 0xB5, 0x4F, 0x52, 0x54, 0x09, 0x36, 0x4B, 0x05, 0x33, 0x56, 0x0A, 0x34,
	0x5F, 0x12, 0x3A, 0x64, 0x18, 0x3F, 0x64, 0x19, 0x3D, 0x60, 0x14, 0x3C, 0x54, 0x0E, 0x39, 0x5A,
	0x13, 0x3B, 0x63, 0x15, 0x3C, 0x58, 0x10, 0x3A, 0x57, 0x12, 0x3D, 0x5F, 0x1C, 0x47, 0x6A, 0x28,
	0x51, 0x69, 0x25, 0x50, 0x77, 0x2D, 0x52, 0xB4, 0x65, 0x6F, 0xD1, 0x80, 0x76, 0xD1, 0x7B, 0x70,
	0xD9, 0x60, 0x56, 0xB2, 0x3E, 0x46, 0x94, 0x2D, 0x41, 0x9B, 0x35, 0x45, 0x9D, 0x32, 0x43, 0x9A,
	0x30, 0x42, 0xB6, 0x44, 0x4C, 0xD8, 0x67, 0x5B, 0xE2, 0x7F, 0x66, 0xE8, 0x8B, 0x6C, 0xE9, 0x8E,
	0x6D, 0xE8, 0x8B, 0x6D, 0xE7, 0x89, 0x6B, 0xE0, 0x7B, 0x61, 0xD8, 0x63, 0x57, 0xBA, 0x44, 0x4A,
	0x92, 0x2A, 0x3F, 0x8F, 0x2A, 0x40, 0x9D, 0x37, 0x47, 0xA4, 0x3A, 0x49, 0xA9, 0x3B, 0x4A, 0xAB,
	0x3E, 0x4C, 0xAB, 0x40, 0x4E, 0xAC, 0x41, 0x4D, 0xAA, 0x3E, 0x4C, 0xAD, 0x41, 0x4C, 0xB5, 0x46,
	0x4D, 0xB6, 0x47, 0x4E, 0xBB, 0x4B, 0x50, 0xC1, 0x4E, 0x52, 0xC3, 0x4F, 0x52, 0xC5, 0x54, 0x54,
	0xC6, 0x53, 0x54, 0xC7, 0x53, 0x52, 0xC8, 0x57, 0x54, 0xC9, 0x58, 0x54, 0xBC, 0x49, 0x50, 0xB4,
	0x43, 0x4C, 0xB5, 0x47, 0x4F, 0xB8, 0x4B, 0x53, 0xBA, 0x50, 0x57, 0xBE, 0x54, 0x59, 0xBD, 0x55,
	0x59, 0xBA, 0x53, 0x59, 0xB5, 0x50, 0x59, 0xB9, 0x53, 0x59, 0xC0, 0x5A, 0x5E, 0xC2, 0x5E, 0x62,
	0xC2, 0x66, 0x6A, 0xC6, 0x6D, 0x6D, 0xC6, 0x6B, 0x69, 0xCA, 0x6A, 0x6B, 0xC9, 0x6F, 0x6F, 0xCB,
	0x71, 0x70, 0xCB, 0x73, 0x71, 0xCB, 0x78, 0x74, 0xCE, 0x80, 0x7A, 0xD1, 0x8E, 0x84, 0xD8, 0xA0,
	0x91, 0xDA, 0xA3, 0x95, 0xD4, 0x9B, 0x8F, 0xCE, 0x95, 0x8C, 0xD1, 0xA2, 0x9A, 0xDC, 0xBA, 0xAF,
	0xE3, 0xC9, 0xBA, 0xE3, 0xC9, 0xBA, 0xE2, 0xC7, 0xB8, 0xE1, 0xC3, 0xB3, 0xE3, 0xC6, 0xB6, 0xE2,
	0xC6, 0xB8, 0xE1, 0xC2, 0xB5, 0xE2, 0xC6, 0xB7, 0xE2, 0xC8, 0xB7, 0xE1, 0xC8, 0xB9, 0xED, 0xD7,
	0xBB, 0xF2, 0xDE, 0xBE, 0xB1, 0x71, 0x77, 0x86, 0x1C, 0x35, 0x96, 0x2F, 0x42, 0x9D, 0x3C, 0x4D,
	0x9D, 0x3D, 0x4F, 0x9D, 0x39, 0x4D, 0xAA, 0x3F, 0x4E, 0xC6, 0x53, 0x57, 0xD8, 0x69, 0x65, 0xDE,
	0x7A, 0x6C, 0xDF, 0x7D, 0x6A, 0xE0, 0x7A, 0x68, 0xDE, 0x79, 0x6B, 0xDD, 0x76, 0x6D, 0xD5, 0x68,
	0x66, 0xAE, 0x46, 0x51, 0x6A, 0x13, 0x36, 0x6A, 0x10, 0x34, 0xAA, 0x3B, 0x4A, 0xCF, 0x5B, 0x5F,
	0xDC, 0x70, 0x69, 0xDC, 0x74, 0x68, 0xDB, 0x6E, 0x62, 0xDB, 0x6E, 0x63, 0xD8, 0x6D, 0x62, 0xD9,
	0x6B, 0x62, 0xDA, 0x6C, 0x64, 0xDB, 0x6E, 0x63, 0xDA, 0x6C, 0x61, 0xDC, 0x6F, 0x65, 0xE7, 0x80,
	0x6C, 0xD2, 0x66, 0x5C, 0x6F, 0x1B, 0x3E, 0x4D, 0x10, 0x40, 0x56, 0x0E, 0x3A, 0x5B, 0x10, 0x39,
	0x64, 0x18, 0x3E, 0x64, 0x19, 0x3E, 0x62, 0x17, 0x3D, 0x58, 0x11, 0x3C, 0x57, 0x12, 0x3B, 0x64,
	0x19, 0x3E, 0x5C, 0x12, 0x3B, 0x56, 0x0F, 0x39, 0x5C, 0x17, 0x41, 0x64, 0x25, 0x53, 0x6A, 0x29,
	0x5B, 0x7D, 0x33, 0x5B, 0xAE, 0x61, 0x70, 0xD0, 0x83, 0x7A, 0xC7, 0x77, 0x70, 0xC5, 0x72, 0x6E,
	0xC3, 0x49, 0x4B, 0x9A, 0x31, 0x42, 0x99, 0x34, 0x45, 0x9F, 0x38, 0x45, 0x9A, 0x33, 0x43, 0x99,
	0x30, 0x41, 0xB6, 0x42, 0x4A, 0xD7, 0x66, 0x5A, 0xE0, 0x7D, 0x63, 0xE6, 0x89, 0x6C, 0xE9, 0x8E,
	0x6E, 0xE7, 0x8C, 0x6D, 0xE7, 0x88, 0x6B, 0xE1, 0x7D, 0x65, 0xD7, 0x64, 0x58, 0xBA, 0x43, 0x4A,
	0x90, 0x2A, 0x3F, 0x8A, 0x2D, 0x42, 0x9D, 0x3A, 0x4B, 0xA8, 0x3E, 0x4C, 0xA8, 0x3D, 0x4A, 0xA7,
	0x3D, 0x49, 0xAB, 0x3D, 0x4A, 0xAB, 0x3F, 0x4B, 0xAA, 0x3F, 0x4B, 0xAE, 0x42, 0x4D, 0xB3, 0x43,
	0x4C, 0xB7, 0x47, 0x4F, 0xBC, 0x4C, 0x53, 0xC0, 0x4F, 0x53, 0xC3, 0x4E, 0x50, 0xC6, 0x52, 0x52,
	0xC5, 0x54, 0x56, 0xC6, 0x55, 0x57, 0xC9, 0x5A, 0x57, 0xBE, 0x52, 0x53, 0xB3, 0x45, 0x4D, 0xBA,
	0x49, 0x50, 0xB9, 0x4C, 0x55, 0xB9, 0x4D, 0x58, 0xBC, 0x52, 0x5A, 0xBD, 0x52, 0x56, 0xB7, 0x4F,
	0x57, 0xB2, 0x4B, 0x57, 0xB4, 0x4E, 0x5A, 0xC0, 0x5C, 0x61, 0xC2, 0x60, 0x64, 0xC1, 0x60, 0x63,
	0xC6, 0x69, 0x69, 0xC8, 0x6D, 0x6C, 0xC8, 0x71, 0x6E, 0xCE, 0x73, 0x6F, 0xCF, 0x75, 0x71, 0xCA,
	0x6F, 0x6D, 0xC8, 0x6E, 0x6F, 0xCB, 0x73, 0x71, 0xCE, 0x7F, 0x79, 0xD5, 0x94, 0x88, 0xD7, 0x9A,
	0x8B, 0xCC, 0x89, 0x80, 0xC9, 0x8F, 0x8B, 0xD7, 0xB1, 0xA9, 0xE2, 0xC6, 0xB9, 0xE3, 0xC3, 0xB4,
	0xE1, 0xC2, 0xB3, 0xE1, 0xC5, 0xB7, 0xE1, 0xC4, 0xB6, 0xDF, 0xBF, 0xB1, 0xDE, 0xBD, 0xAF, 0xDF,
	0xC0, 0xB3, 0xE0, 0xC3, 0xB4, 0xE2, 0xC7, 0xB7, 0xE1, 0xC8, 0xB8, 0xE1, 0xC8, 0xBA, 0xE5, 0xCD,
	0xB8, 0xF2, 0xDD, 0xBD, 0xE6, 0xCB, 0xB2, 0x9B, 0x51, 0x5F, 0x7D, 0x1A, 0x36, 0x8C, 0x2A, 0x3F,
	0x96, 0x36, 0x48, 0x9A, 0x36, 0x4A, 0xA6, 0x3E, 0x4E, 0xC5, 0x54, 0x58, 0xDA, 0x6A, 0x63, 0xDF,
	0x79, 0x6C, 0xDF, 0x7D, 0x6C, 0xDF, 0x7B, 0x6A, 0xDE, 0x7B, 0x6D, 0xDB, 0x78, 0x6C, 0xD7, 0x6B,
	0x67, 0xB3, 0x48, 0x52, 0x6A, 0x13, 0x36, 0x51, 0x09, 0x36, 0x89, 0x2D, 0x47, 0xBF, 0x50, 0x57,
	0xD8, 0x66, 0x61, 0xDE, 0x72, 0x69, 0xDD, 0x73, 0x66, 0xDB, 0x6C, 0x62, 0xD9, 0x6B, 0x60, 0xDA,
	0x6B, 0x61, 0xDA, 0x6B, 0x64, 0xDB, 0x6C, 0x64, 0xDD, 0x6D, 0x63, 0xE2, 0x79, 0x6A, 0xE6, 0x7C,
	0x68, 0x90, 0x2F, 0x43, 0x47, 0x04, 0x35, 0x53, 0x12, 0x3D, 0x5A, 0x10, 0x3B, 0x62, 0x15, 0x3D,
	0x64, 0x16, 0x3C, 0x65, 0x16, 0x3C, 0x5B, 0x10, 0x38, 0x55, 0x0D, 0x38, 0x66, 0x19, 0x3D, 0x60,
	0x16, 0x3D, 0x57, 0x11, 0x3C, 0x5C, 0x14, 0x3E, 0x5E, 0x18, 0x41, 0x65, 0x24, 0x54, 0x7C, 0x38,
	0x62, 0xA9, 0x5E, 0x6F, 0xC7, 0x7C, 0x7A, 0xCA, 0x7B, 0x74, 0xC4, 0x74, 0x6F, 0xCC, 0x83, 0x76,
	0xA2, 0x36, 0x45, 0x96, 0x30, 0x43, 0x9F, 0x36, 0x46, 0xA1, 0x37, 0x47, 0x9D, 0x35, 0x44, 0x99,
	0x30, 0x42, 0xB4, 0x41, 0x4B, 0xD4, 0x63, 0x59, 0xE0, 0x7B, 0x62, 0xE7, 0x88, 0x6B, 0xE7, 0x8D,
	0x6F, 0xE6, 0x8C, 0x6E, 0xE6, 0x89, 0x6C, 0xE1, 0x7D, 0x67, 0xD7, 0x64, 0x5A, 0xB9, 0x46, 0x4C,
	0x92, 0x2B, 0x40, 0x8B, 0x2A, 0x3F, 0x9C, 0x36, 0x48, 0xA7, 0x3D, 0x4B, 0xA9, 0x3F, 0x4C, 0xAA,
	0x3E, 0x4B, 0xAA, 0x3D, 0x49, 0xA9, 0x3E, 0x4A, 0xAC, 0x41, 0x4C, 0xAF, 0x43, 0x4D, 0xB2, 0x43,
	0x4C, 0xB7, 0x46, 0x4E, 0xBF, 0x4C, 0x52, 0xC0, 0x51, 0x54, 0xC0, 0x4E, 0x51, 0xC6, 0x52, 0x52,
	0xC6, 0x53, 0x55, 0xCB, 0x59, 0x5B, 0xC8, 0x5A, 0x59, 0xBA, 0x4C, 0x52, 0xB9, 0x4D, 0x54, 0xB9,
	0x4C, 0x53, 0xB7, 0x4A, 0x51, 0xBA, 0x4F, 0x56, 0xBD, 0x52, 0x59, 0xBA, 0x4F, 0x57, 0xB8, 0x52,
	0x59, 0xB6, 0x52, 0x5B, 0xBB, 0x57, 0x5F, 0xC2, 0x5F, 0x63, 0xC0, 0x5E, 0x65, 0xC2, 0x64, 0x67,
	0xC9, 0x6A, 0x69, 0xC8, 0x68, 0x68, 0xCC, 0x6F, 0x6C, 0xD0, 0x72, 0x6D, 0xCA, 0x70, 0x6D, 0xC5,
	0x6A, 0x6C, 0xCA, 0x6B, 0x6D, 0xD0, 0x73, 0x70, 0xD2, 0x84, 0x7C, 0xD2, 0x8A, 0x80, 0xC4, 0x7D,
	0x79, 0xC8, 0x92, 0x8E, 0xDB, 0xB6, 0xA8, 0xE2, 0xC4, 0xB6, 0xE1, 0xC3, 0xB5, 0xE1, 0xC3, 0xB7,
	0xDF, 0xC1, 0xB3, 0xDE, 0xBF, 0xB1, 0xDD, 0xBC, 0xAD, 0xDC, 0xBC, 0xAD, 0xDE, 0xBF, 0xB1, 0xDE,
	0xBF, 0xB1, 0xDF, 0xC0, 0xB2, 0xE0, 0xC2, 0xB3, 0xE0, 0xC4, 0xB6, 0xE2, 0xC9, 0xB9, 0xE2, 0xC9,
	0xBA, 0xE2, 0xCA, 0xBA, 0xEC, 0xD7, 0xBE, 0xDE, 0xC3, 0xB1, 0xA9, 0x73, 0x7D, 0x82, 0x25, 0x40,
	0x8B, 0x24, 0x3A, 0x96, 0x32, 0x43, 0xA5, 0x3B, 0x49, 0xC5, 0x52, 0x56, 0xDA, 0x6A, 0x62, 0xDF,
	0x79, 0x6B, 0xDF, 0x7C, 0x6C, 0xDF, 0x7A, 0x6C, 0xDE, 0x7A, 0x6D, 0xDC, 0x7A, 0x6F, 0xD8, 0x6B,
	0x64, 0xB4, 0x45, 0x4D, 0x6E, 0x16, 0x37, 0x4B, 0x0B, 0x39, 0x68, 0x1A, 0x3F, 0xA4, 0x3C, 0x4B,
	0xCD, 0x5A, 0x5B, 0xDB, 0x6C, 0x65, 0xDF, 0x73, 0x67, 0xDC, 0x6D, 0x61, 0xD9, 0x6B, 0x5F, 0xDA,
	0x6A, 0x61, 0xDB, 0x6C, 0x64, 0xDC, 0x6D, 0x66, 0xDF, 0x73, 0x67, 0xEA, 0x81, 0x68, 0xB9, 0x4F,
	0x50, 0x57, 0x0A, 0x35, 0x48, 0x05, 0x33, 0x55, 0x0C, 0x36, 0x63, 0x15, 0x3E, 0x68, 0x1A, 0x41,
	0x64, 0x17, 0x3D, 0x5F, 0x11, 0x3A, 0x56, 0x0C, 0x36, 0x63, 0x15, 0x3C, 0x66, 0x17, 0x3E, 0x57,
	0x10, 0x3A, 0x5C, 0x15, 0x3E, 0x60, 0x18, 0x42, 0x5E, 0x19, 0x47, 0x6D, 0x27, 0x55, 0xA5, 0x5B,
	0x6F, 0xC7, 0x7C, 0x79, 0xCA, 0x7D, 0x77, 0xC1, 0x76, 0x73, 0xCC, 0x83, 0x77, 0xD3, 0x8D, 0x7B,
	0x93, 0x32, 0x47, 0x9C, 0x35, 0x45, 0xA1, 0x38, 0x46, 0xA1, 0x37, 0x46, 0x9D, 0x36, 0x47, 0x9A,
	0x31, 0x44, 0xB3, 0x43, 0x4B, 0xD3, 0x62, 0x59, 0xE0, 0x79, 0x64, 0xE6, 0x88, 0x6C, 0xE5, 0x8B,
	0x71, 0xE4, 0x8C, 0x72, 0xE5, 0x89, 0x6D, 0xE1, 0x7C, 0x65, 0xD8, 0x64, 0x5A, 0xBA, 0x47, 0x4D,
	0x93, 0x2B, 0x41, 0x8C, 0x26, 0x3D, 0x9C, 0x33, 0x44, 0xA4, 0x3B, 0x48, 0xA8, 0x3D, 0x4A, 0xAB,
	0x3E, 0x4B, 0xAA, 0x3E, 0x4B, 0xAA, 0x3D, 0x49, 0xAC, 0x40, 0x4C, 0xAE, 0x41, 0x4C, 0xB3, 0x44,
	0x4C, 0xB8, 0x47, 0x4D, 0xBD, 0x4A, 0x50, 0xBF, 0x50, 0x54, 0xC1, 0x51, 0x55, 0xC4, 0x52, 0x54,
	0xC5, 0x52, 0x54, 0xCF, 0x5E, 0x5A, 0xC1, 0x50, 0x52, 0xB3, 0x42, 0x4C, 0xBB, 0x4B, 0x51, 0xBC,
	0x4D, 0x54, 0xB7, 0x4A, 0x52, 0xBA, 0x4D, 0x53, 0xBB, 0x4F, 0x56, 0xBA, 0x50, 0x58, 0xBC, 0x54,
	0x59, 0xBC, 0x57, 0x5D, 0xC0, 0x60, 0x65, 0xC2, 0x61, 0x65, 0xC4, 0x62, 0x68, 0xC8, 0x6C, 0x6E,
	0xCB, 0x6E, 0x6D, 0xCB, 0x6D, 0x6C, 0xCA, 0x6E, 0x6E, 0xCB, 0x6C, 0x6D, 0xC7, 0x69, 0x6A, 0xC5,
	0x67, 0x6A, 0xC8, 0x6D, 0x6D, 0xC8, 0x6D, 0x6D, 0xC5, 0x6F, 0x70, 0xC6, 0x7D, 0x7A, 0xD1, 0xA2,
	0x99, 0xDE, 0xBE, 0xAF, 0xDE, 0xBA, 0xA9, 0xDD, 0xB8, 0xA9, 0xDD, 0xB8, 0xAB, 0xDF, 0xBE, 0xB0,
	0xDC, 0xBB, 0xB0, 0xDC, 0xBA, 0xAE, 0xDD, 0xBB, 0xAE, 0xDE, 0xBE, 0xB0, 0xE0, 0xC1, 0xB0, 0xE0,
	0xC1, 0xB2, 0xE1, 0xC3, 0xB7, 0xE1, 0xC4, 0xB8, 0xE2, 0xC7, 0xB8, 0xE2, 0xC7, 0xB7, 0xE2, 0xC9,
	0xB9, 0xE2, 0xC8, 0xB8, 0xE1, 0xC9, 0xB9, 0xED, 0xD8, 0xC0, 0xEF, 0xDE, 0xC2, 0xB7, 0x7F, 0x82,
	0x7B, 0x19, 0x38, 0x87, 0x23, 0x3B, 0xA1, 0x39, 0x47, 0xC3, 0x52, 0x54, 0xD7, 0x6A, 0x63, 0xDE,
	0x7A, 0x6D, 0xDE, 0x7B, 0x6D, 0xDF, 0x79, 0x6B, 0xDE, 0x7A, 0x6D, 0xDE, 0x7B, 0x70, 0xD7, 0x68,
	0x62, 0xB4, 0x46, 0x4D, 0x75, 0x1B, 0x3A, 0x51, 0x09, 0x35, 0x54, 0x07, 0x32, 0x7E, 0x1F, 0x3B,
	0xB7, 0x46, 0x4F, 0xD6, 0x63, 0x60, 0xDE, 0x72, 0x66, 0xDD, 0x71, 0x63, 0xD9, 0x6B, 0x5F, 0xD9,
	0x69, 0x5F, 0xDC, 0x6A, 0x62, 0xDD, 0x6F, 0x68, 0xE6, 0x7D, 0x6C, 0xD7, 0x68, 0x5C, 0x73, 0x18,
	0x39, 0x47, 0x03, 0x33, 0x53, 0x0C, 0x37, 0x5D, 0x11, 0x39, 0x67, 0x17, 0x3C, 0x67, 0x18, 0x3E,
	0x63, 0x18, 0x3E, 0x59, 0x10, 0x3A, 0x5C, 0x12, 0x3A, 0x66, 0x19, 0x3D, 0x5A, 0x12, 0x3C, 0x5B,
	0x14, 0x3E, 0x61, 0x17, 0x3F, 0x58, 0x14, 0x40, 0x61, 0x1D, 0x4F, 0x97, 0x4F, 0x6A, 0xC4, 0x78,
	0x77, 0xC7, 0x7A, 0x76, 0xC4, 0x77, 0x75, 0xCA, 0x82, 0x7A, 0xD3, 0x8E, 0x7D, 0xD2, 0x8C, 0x7C,
	0x97, 0x32, 0x45, 0x9F, 0x36, 0x47, 0xA0, 0x39, 0x47, 0x9F, 0x39, 0x46, 0x9D, 0x37, 0x46, 0x9C,
	0x34, 0x47, 0xB5, 0x46, 0x50, 0xD4, 0x64, 0x5B, 0xE0, 0x7A, 0x65, 0xE4, 0x87, 0x6D, 0xE5, 0x8A,
	0x70, 0xE5, 0x8B, 0x6F, 0xE5, 0x87, 0x6B, 0xE1, 0x7D, 0x66, 0xD9, 0x66, 0x5A, 0xB9, 0x47, 0x4E,
	0x91, 0x2D, 0x43, 0x8C, 0x28, 0x3F, 0x9B, 0x35, 0x46, 0xA3, 0x3A, 0x47, 0xA6, 0x3A, 0x47, 0xAA,
	0x3E, 0x4C, 0xAC, 0x3F, 0x4D, 0xAA, 0x3D, 0x49, 0xAB, 0x3E, 0x4A, 0xAD, 0x40, 0x49, 0xB2, 0x42,
	0x4A, 0xB8, 0x48, 0x4E, 0xBD, 0x4B, 0x51, 0xC0, 0x4F, 0x55, 0xC2, 0x51, 0x54, 0xBD, 0x47, 0x4E,
	0xCB, 0x63, 0x5D, 0xD1, 0x6A, 0x5E, 0xB2, 0x3E, 0x47, 0xAF, 0x41, 0x4D, 0xB5, 0x47, 0x50, 0xBC,
	0x4E, 0x54, 0xBB, 0x4B, 0x52, 0xBA, 0x4A, 0x51, 0xB8, 0x4C, 0x55, 0xB7, 0x4E, 0x56, 0xBB, 0x54,
	0x5B, 0xBF, 0x58, 0x5E, 0xC4, 0x60, 0x64, 0xC5, 0x66, 0x69, 0xCE, 0x70, 0x6F, 0xCC, 0x6E, 0x6D,
	0xC5, 0x67, 0x68, 0xCB, 0x70, 0x6E, 0xCB, 0x71, 0x71, 0xC8, 0x6B, 0x6E, 0xC4, 0x66, 0x6B, 0xC3,
	0x63, 0x66, 0xBF, 0x60, 0x64, 0xBB, 0x65, 0x6A, 0xC5, 0x85, 0x84, 0xD5, 0xA1, 0x95, 0xE1, 0xB9,
	0xA5, 0xDF, 0xBE, 0xAD, 0xDC, 0xB7, 0xA7, 0xDC, 0xB4, 0xA4, 0xD9, 0xB0, 0xA4, 0xD9, 0xAF, 0xA2,
	0xD9, 0xB1, 0xA6, 0xDC, 0xBA, 0xAE, 0xE0, 0xC1, 0xB5, 0xE1, 0xC2, 0xB5, 0xE1, 0xC2, 0xB3, 0xE1,
	0xC3, 0xB3, 0xE2, 0xC5, 0xB4, 0xE2, 0xC6, 0xB7, 0xE2, 0xC8, 0xB9, 0xE2, 0xC6, 0xB6, 0xE2, 0xC8,
	0xB8, 0xE1, 0xC5, 0xB7, 0xE1, 0xC7, 0xB8, 0xE1, 0xC9, 0xBA, 0xEA, 0xD4, 0xBF, 0xEB, 0xD5, 0xBC,
	0x95, 0x50, 0x61, 0x76, 0x0F, 0x30, 0x9C, 0x33, 0x43, 0xC0, 0x4F, 0x51, 0xD6, 0x68, 0x5F, 0xDE,
	0x78, 0x6A, 0xDF, 0x7B, 0x6A, 0xDF, 0x7B, 0x6B, 0xDE, 0x7A, 0x6E, 0xDE, 0x77, 0x6D, 0xD7, 0x67,
	0x62, 0xB6, 0x49, 0x4E, 0x77, 0x1D, 0x3A, 0x57, 0x0A, 0x34, 0x54, 0x08, 0x33, 0x5F, 0x0B, 0x32,
	0x91, 0x2A, 0x3F, 0xC7, 0x52, 0x53, 0xDA, 0x65, 0x5C, 0xDA, 0x6A, 0x5D, 0xD8, 0x64, 0x57, 0xDA,
	0x61, 0x56, 0xDB, 0x65, 0x5D, 0xE1, 0x74, 0x69, 0xE5, 0x79, 0x68, 0x97, 0x33, 0x45, 0x4C, 0x05,
	0x32, 0x51, 0x0C, 0x37, 0x5A, 0x10, 0x39, 0x65, 0x14, 0x3A, 0x65, 0x17, 0x3B, 0x64, 0x17, 0x3D,
	0x5E, 0x15, 0x3D, 0x5A, 0x12, 0x3B, 0x63, 0x18, 0x3E, 0x5B, 0x12, 0x3B, 0x5A, 0x12, 0x3B, 0x61,
	0x17, 0x3F, 0x58, 0x12, 0x3C, 0x56, 0x13, 0x43, 0x8A, 0x43, 0x63, 0xC7, 0x7B, 0x7B, 0xC7, 0x7B,
	0x76, 0xBA, 0x6E, 0x72, 0xC5, 0x7B, 0x77, 0xD2, 0x8C, 0x7C, 0xD3, 0x8E, 0x7D, 0xD2, 0x8D, 0x7C,
	0x9E, 0x36, 0x47, 0x9F, 0x38, 0x46, 0x9E, 0x38, 0x47, 0x9E, 0x38, 0x46, 0x9D, 0x36, 0x45, 0x99,
	0x32, 0x44, 0xB2, 0x43, 0x4E, 0xD4, 0x65, 0x5C, 0xE0, 0x7C, 0x66, 0xE4, 0x87, 0x6B, 0xE6, 0x8B,
	0x6D, 0xE5, 0x88, 0x6D, 0xE4, 0x89, 0x6E, 0xE3, 0x82, 0x6B, 0xD7, 0x67, 0x5E, 0xB9, 0x48, 0x4F,
	0x8F, 0x2D, 0x44, 0x8B, 0x2B, 0x42, 0x9B, 0x33, 0x46, 0xA3, 0x38, 0x46, 0xA7, 0x3B, 0x48, 0xAA,
	0x3D, 0x4A, 0xAB, 0x40, 0x4E, 0xAB, 0x40, 0x4D, 0xAC, 0x3F, 0x4A, 0xAE, 0x41, 0x4D, 0xB3, 0x45,
	0x4E, 0xB7, 0x49, 0x4E, 0xBE, 0x4C, 0x51, 0xBF, 0x4E, 0x53, 0xBB, 0x4B, 0x51, 0xB6, 0x44, 0x50,
	0xD9, 0x86, 0x6F, 0xCE, 0x6A, 0x5C, 0xAD, 0x37, 0x45, 0xB2, 0x45, 0x4F, 0xB5, 0x48, 0x51, 0xB8,
	0x49, 0x50, 0xBA, 0x49, 0x50, 0xBC, 0x4B, 0x51, 0xBD, 0x4F, 0x55, 0xBE, 0x52, 0x58, 0xC1, 0x58,
	0x5E, 0xC0, 0x5A, 0x61, 0xC3, 0x5F, 0x65, 0xCC, 0x6B, 0x6C, 0xCD, 0x6D, 0x6A, 0xC3, 0x65, 0x67,
	0xC1, 0x65, 0x68, 0xCA, 0x6E, 0x6F, 0xCE, 0x6F, 0x6F, 0xC7, 0x67, 0x69, 0xBC, 0x5C, 0x62, 0xB1,
	0x4E, 0x5A, 0xB8, 0x64, 0x6D, 0xCE, 0x8D, 0x85, 0xDF, 0xB3, 0x9E, 0xDF, 0xB6, 0xA5, 0xDD, 0xAB,
	0x9B, 0xDD, 0xB2, 0x9E, 0xDC, 0xB5, 0xA4, 0xD9, 0xAD, 0xA0, 0xD9, 0xAE, 0xA2, 0xDA, 0xB3, 0xA7,
	0xDA, 0xB6, 0xAA, 0xDD, 0xBC, 0xAF, 0xE0, 0xC1, 0xB4, 0xE2, 0xC5, 0xB8, 0xE1, 0xC3, 0xB5, 0xE0,
	0xC3, 0xB4, 0xE1, 0xC2, 0xB3, 0xE2, 0xC4, 0xB5, 0xDF, 0xC1, 0xB5, 0xE0, 0xC1, 0xB6, 0xE0, 0xC5,
	0xB8, 0xE0, 0xC4, 0xB7, 0xE1, 0xC6, 0xB8, 0xE2, 0xCA, 0xBA, 0xE2, 0xCA, 0xBA, 0xF3, 0xE0, 0xC0,
	0xD3, 0xAF, 0xA1, 0x82, 0x2C, 0x47, 0x89, 0x21, 0x39, 0xBB, 0x4B, 0x50, 0xD6, 0x67, 0x5F, 0xDD,
	0x76, 0x67, 0xDF, 0x7A, 0x6A, 0xDF, 0x7C, 0x6C, 0xDE, 0x7C, 0x70, 0xDE, 0x7A, 0x6F, 0xD7, 0x69,
	0x62, 0xB6, 0x47, 0x4F, 0x7A, 0x1F, 0x3E, 0x5B, 0x0C, 0x37, 0x5A, 0x0C, 0x34, 0x56, 0x07, 0x31,
	0x67, 0x0E, 0x33, 0x95, 0x26, 0x3A, 0xC0, 0x4F, 0x52, 0xD6, 0x7F, 0x77, 0xDB, 0x8C, 0x81, 0xD6,
	0x72, 0x6A, 0xD9, 0x71, 0x67, 0xE4, 0x77, 0x67, 0xB9, 0x4B, 0x4F, 0x5B, 0x0D, 0x36, 0x4E, 0x0C,
	0x37, 0x58, 0x10, 0x3B, 0x60, 0x13, 0x3C, 0x65, 0x15, 0x39, 0x64, 0x15, 0x3C, 0x62, 0x18, 0x41,
	0x5B, 0x12, 0x3D, 0x5F, 0x16, 0x3D, 0x60, 0x16, 0x3E, 0x5A, 0x12, 0x3D, 0x64, 0x19, 0x3F, 0x5C,
	0x13, 0x3A, 0x4A, 0x06, 0x35, 0x77, 0x32, 0x58, 0xC0, 0x75, 0x79, 0xCD, 0x7F, 0x78, 0xBC, 0x6F,
	0x71, 0xC1, 0x76, 0x74, 0xD0, 0x89, 0x7A, 0xD3, 0x8B, 0x7B, 0xD2, 0x89, 0x7A, 0xD2, 0x8A, 0x7A,
	0x9D, 0x38, 0x48, 0x9C, 0x39, 0x46, 0x9A, 0x38, 0x46, 0x9B, 0x36, 0x45, 0x98, 0x33, 0x43, 0x95,
	0x2E, 0x41, 0xAF, 0x40, 0x4A, 0xD5, 0x64, 0x5C, 0xE0, 0x7B, 0x66, 0xE5, 0x87, 0x6B, 0xE6, 0x8B,
	0x6D, 0xE4, 0x87, 0x6E, 0xE5, 0x8A, 0x70, 0xE3, 0x81, 0x6A, 0xD8, 0x66, 0x5C, 0xBA, 0x4A, 0x52,
	0x8F, 0x2E, 0x44, 0x8B, 0x28, 0x40, 0x9B, 0x34, 0x44, 0xA3, 0x38, 0x46, 0xA5, 0x37, 0x46, 0xA9,
	0x3B, 0x48, 0xAA, 0x3E, 0x4C, 0xA9, 0x3F, 0x4E, 0xA9, 0x3F, 0x4E, 0xAD, 0x46, 0x53, 0xB2, 0x47,
	0x50, 0xB6, 0x47, 0x4E, 0xBB, 0x4A, 0x51, 0xBE, 0x4C, 0x52, 0xB5, 0x3F, 0x4C, 0xBD, 0x5A, 0x5C,
	0xE7, 0xA2, 0x7B, 0xC0, 0x56, 0x55, 0xAB, 0x3C, 0x4D, 0xB0, 0x43, 0x4D, 0xB6, 0x47, 0x4E, 0xBA,
	0x4A, 0x51, 0xBC, 0x49, 0x50, 0xBA, 0x49, 0x50, 0xBD, 0x51, 0x56, 0xC1, 0x54, 0x5A, 0xC4, 0x59,
	0x5D, 0xC7, 0x61, 0x64, 0xC7, 0x66, 0x6A, 0xCC, 0x6A, 0x6A, 0xCB, 0x69, 0x68, 0xC6, 0x63, 0x64,
	0xC6, 0x69, 0x69, 0xCB, 0x6A, 0x6C, 0xC4, 0x63, 0x65, 0xBA, 0x56, 0x5F, 0xB0, 0x4F, 0x5D, 0xB8,
	0x66, 0x6F, 0xD3, 0x9A, 0x90, 0xE0, 0xB1, 0xA0, 0xDE, 0xAA, 0x94, 0xDC, 0xAA, 0x9B, 0xDB, 0xB0,
	0xA3, 0xD9, 0xA8, 0x9A, 0xD7, 0xA2, 0x94, 0xD6, 0xA7, 0x9C, 0xDB, 0xB3, 0xA7, 0xDD, 0xBC, 0xB0,
	0xDD, 0xBC, 0xAF, 0xDC, 0xB9, 0xAD, 0xDD, 0xBC, 0xAF, 0xE1, 0xC3, 0xB5, 0xE1, 0xC3, 0xB7, 0xDE,
	0xC0, 0xB4, 0xDF, 0xBF, 0xB4, 0xDF, 0xC0, 0xB3, 0xDD, 0xBE, 0xB2, 0xDD, 0xBE, 0xB3, 0xE1, 0xC6,
	0xB8, 0xE2, 0xCA, 0xBB, 0xE2, 0xC6, 0xB8, 0xE2, 0xC9, 0xB9, 0xE2, 0xCB, 0xBB, 0xE9, 0xD2, 0xB9,
	0xF7, 0xE6, 0xC2, 0xAB, 0x73, 0x79, 0x79, 0x14, 0x33, 0xB6, 0x47, 0x4F, 0xD7, 0x67, 0x60, 0xDD,
	0x76, 0x69, 0xDF, 0x78, 0x69, 0xDE, 0x7A, 0x6B, 0xDE, 0x7B, 0x6D, 0xDF, 0x7C, 0x70, 0xD9, 0x6A,
	0x65, 0xB5, 0x4A, 0x52, 0x79, 0x20, 0x3F, 0x5B, 0x0C, 0x37, 0x5C, 0x0D, 0x35, 0x53, 0x07, 0x31,
	0x42, 0x00, 0x27, 0x76, 0x2E, 0x4F, 0xCE, 0xA0, 0x99, 0xE4, 0xC7, 0xB3, 0xE1, 0xC6, 0xB6, 0xDC,
	0xB9, 0xAD, 0xE6, 0xC2, 0xAF, 0xD6, 0x93, 0x88, 0x6F, 0x18, 0x3C, 0x48, 0x06, 0x36, 0x56, 0x12,
	0x3C, 0x5C, 0x13, 0x3D, 0x63, 0x17, 0x3E, 0x63, 0x17, 0x3D, 0x63, 0x17, 0x40, 0x60, 0x19, 0x44,
	0x5F, 0x17, 0x3F, 0x60, 0x15, 0x3D, 0x5A, 0x13, 0x3D, 0x62, 0x19, 0x40, 0x5F, 0x13, 0x3B, 0x50,
	0x08, 0x36, 0x66, 0x1F, 0x4B, 0xAF, 0x65, 0x72, 0xCF, 0x82, 0x7A, 0xC1, 0x72, 0x72, 0xC0, 0x75,
	0x74, 0xD0, 0x88, 0x7B, 0xD3, 0x8C, 0x7B, 0xD1, 0x89, 0x7A, 0xD1, 0x87, 0x77, 0xD1, 0x87, 0x77,
	0x98, 0x38, 0x47, 0x99, 0x37, 0x46, 0x9A, 0x37, 0x45, 0x9C, 0x36, 0x44, 0x9B, 0x34, 0x44, 0x95,
	0x2E, 0x41, 0xAD, 0x3E, 0x48, 0xD3, 0x62, 0x5A, 0xE0, 0x7C, 0x67, 0xE4, 0x88, 0x6D, 0xE6, 0x8A,
	0x6E, 0xE4, 0x88, 0x6F, 0xE5, 0x89, 0x6E, 0xE2, 0x7F, 0x66, 0xD8, 0x66, 0x5B, 0xB8, 0x48, 0x4F,
	0x8C, 0x28, 0x40, 0x89, 0x25, 0x3D, 0x98, 0x32, 0x42, 0x9D, 0x35, 0x45, 0xA3, 0x38, 0x47, 0xA6,
	0x3A, 0x48, 0xA5, 0x3A, 0x47, 0xA5, 0x3B, 0x49, 0xA7, 0x3D, 0x4D, 0xAB, 0x41, 0x4E, 0xB1, 0x43,
	0x4E, 0xB4, 0x45, 0x4F, 0xB9, 0x48, 0x4F, 0xBA, 0x47, 0x4E, 0xAE, 0x37, 0x47, 0xCC, 0x7D, 0x6E,
	0xEC, 0xA3, 0x7A, 0xB9, 0x46, 0x4F, 0xAC, 0x3D, 0x4C, 0xB4, 0x44, 0x4E, 0xB6, 0x48, 0x51, 0xBC,
	0x4B, 0x52, 0xBF, 0x4B, 0x52, 0xBD, 0x4B, 0x54, 0xBB, 0x51, 0x59, 0xBE, 0x53, 0x5B, 0xC6, 0x5E,
	0x60, 0xCC, 0x64, 0x64, 0xCC, 0x68, 0x67, 0xC6, 0x62, 0x66, 0xC6, 0x62, 0x65, 0xCA, 0x65, 0x65,
	0xCC, 0x6A, 0x67, 0xC2, 0x5E, 0x5F, 0xAE, 0x48, 0x54, 0xB0, 0x51, 0x5F, 0xC2, 0x7A, 0x7D, 0xD7,
	0x9E, 0x93, 0xDD, 0xA6, 0x97, 0xDC, 0xAA, 0x9B, 0xD7, 0x9E, 0x92, 0xD4, 0x9C, 0x90, 0xD8, 0xA5,
	0x99, 0xD7, 0xA7, 0x9D, 0xD8, 0xA7, 0x9A, 0xDA, 0xAD, 0x9C, 0xDB, 0xB3, 0xA6, 0xDC, 0xB9, 0xAD,
	0xDB, 0xB8, 0xAC, 0xDD, 0xB8, 0xAD, 0xDC, 0xB9, 0xAD, 0xDC, 0xBB, 0xAF, 0xDC, 0xBB, 0xB0, 0xDB,
	0xB9, 0xB0, 0xDC, 0xBD, 0xB3, 0xE0, 0xC3, 0xB6, 0xE1, 0xC4, 0xB7, 0xE0, 0xC3, 0xB5, 0xE0, 0xC3,
	0xB5, 0xE2, 0xC8, 0xB9, 0xE2, 0xC9, 0xB9, 0xE1, 0xC7, 0xB9, 0xE1, 0xC6, 0xB9, 0xE2, 0xC9, 0xBA,
	0xF4, 0xE0, 0xC0, 0xD1, 0xB0, 0xA2, 0x80, 0x25, 0x42, 0xAA, 0x39, 0x44, 0xD6, 0x66, 0x60, 0xDE,
	0x76, 0x6A, 0xDE, 0x7A, 0x69, 0xDE, 0x7A, 0x68, 0xDF, 0x7B, 0x6B, 0xDF, 0x7C, 0x6F, 0xD8, 0x6B,
	0x65, 0xB5, 0x49, 0x4F, 0x77, 0x1F, 0x3C, 0x56, 0x0B, 0x36, 0x4D, 0x03, 0x30, 0x3F, 0x00, 0x2D,
	0x70, 0x3F, 0x61, 0xCF, 0xB3, 0xAA, 0xEA, 0xCF, 0xB6, 0xE0, 0xC1, 0xAF, 0xE2, 0xC8, 0xB5, 0xEB,
	0xD7, 0xBC, 0xF4, 0xE4, 0xC0, 0xE1, 0xC9, 0xB3, 0x67, 0x2F, 0x55, 0x42, 0x02, 0x34, 0x55, 0x11,
	0x3C, 0x5F, 0x16, 0x3D, 0x63, 0x18, 0x3E, 0x63, 0x18, 0x40, 0x61, 0x16, 0x40, 0x5D, 0x13, 0x3F,
	0x61, 0x16, 0x3E, 0x5B, 0x15, 0x3D, 0x5E, 0x16, 0x3E, 0x67, 0x1B, 0x3F, 0x54, 0x0D, 0x38, 0x56,
	0x0F, 0x3D, 0x9D, 0x54, 0x6B, 0xCE, 0x82, 0x7D, 0xC6, 0x77, 0x75, 0xC0, 0x73, 0x75, 0xCE, 0x86,
	0x7B, 0xD4, 0x8E, 0x7D, 0xD2, 0x8A, 0x7B, 0xD2, 0x88, 0x7A, 0xD0, 0x87, 0x77, 0xD0, 0x87, 0x76,
	0x9A, 0x36, 0x46, 0x9A, 0x37, 0x46, 0x9F, 0x37, 0x46, 0xA3, 0x38, 0x47, 0xA0, 0x37, 0x46, 0x99,
	0x30, 0x42, 0xB0, 0x3F, 0x48, 0xD2, 0x60, 0x58, 0xE0, 0x7A, 0x64, 0xE5, 0x89, 0x6D, 0xE7, 0x8D,
	0x70, 0xE6, 0x8B, 0x6E, 0xE5, 0x88, 0x6D, 0xE2, 0x7F, 0x67, 0xD9, 0x67, 0x5C, 0xB8, 0x44, 0x4B,
	0x8A, 0x26, 0x3E, 0x86, 0x22, 0x3C, 0x93, 0x2E, 0x41, 0x9F, 0x37, 0x46, 0xA6, 0x3B, 0x48, 0xAA,
	0x3D, 0x48, 0xAA, 0x3C, 0x48, 0xAB, 0x3D, 0x49, 0xAB, 0x3D, 0x4A, 0xAD, 0x3F, 0x4B, 0xB1, 0x42,
	0x4C, 0xB5, 0x43, 0x4B, 0xBB, 0x48, 0x4F, 0xB8, 0x48, 0x4F, 0xB0, 0x41, 0x4E, 0xDE, 0x9E, 0x7D,
	0xEA, 0x9A, 0x74, 0xB8, 0x44, 0x4D, 0xA9, 0x3C, 0x4B, 0xB4, 0x44, 0x4D, 0xB7, 0x48, 0x50, 0xBD,
	0x4E, 0x54, 0xBE, 0x4B, 0x51, 0xBF, 0x4E, 0x55, 0xBB, 0x52, 0x5A, 0xC1, 0x5B, 0x5F, 0xC9, 0x61,
	0x60, 0xC7, 0x5B, 0x5D, 0xBF, 0x57, 0x5D, 0xBB, 0x57, 0x5E, 0xC8, 0x62, 0x64, 0xCB, 0x66, 0x65,
	0xC4, 0x5B, 0x5B, 0xB3, 0x49, 0x53, 0xB3, 0x55, 0x61, 0xCA, 0x85, 0x80, 0xDC, 0xA4, 0x97, 0xDE,
	0xA2, 0x92, 0xD6, 0x91, 0x85, 0xD4, 0x98, 0x8C, 0xD5, 0xA0, 0x95, 0xD5, 0x9D, 0x92, 0xD5, 0x9B,
	0x90, 0xD8, 0xA3, 0x94, 0xDA, 0xAE, 0x9F, 0xD9, 0xAE, 0xA1, 0xDB, 0xB0, 0xA2, 0xDB, 0xB4, 0xA6,
	0xDC, 0xB7, 0xAC, 0xDC, 0xB7, 0xAB, 0xDA, 0xB1, 0xA4, 0xD8, 0xB1, 0xA6, 0xDB, 0xB7, 0xAD, 0xDE,
	0xBD, 0xB4, 0xDF, 0xBE, 0xB4, 0xE1, 0xC3, 0xB6, 0xDE, 0xC0, 0xB4, 0xDD, 0xBE, 0xB1, 0xDC, 0xBD,
	0xB0, 0xDF, 0xC2, 0xB4, 0xE2, 0xC8, 0xBA, 0xE0, 0xC5, 0xB9, 0xDF, 0xC4, 0xB8, 0xE1, 0xC7, 0xB9,
	0xE6, 0xCF, 0xBB, 0xEB, 0xD9, 0xBF, 0xA8, 0x6A, 0x75, 0x9E, 0x2B, 0x3C, 0xD3, 0x60, 0x5B, 0xDC,
	0x78, 0x6E, 0xDF, 0x7D, 0x6D, 0xE0, 0x7D, 0x69, 0xE0, 0x7D, 0x6A, 0xDE, 0x7B, 0x6D, 0xD6, 0x6B,
	0x63, 0xB1, 0x46, 0x4C, 0x6D, 0x16, 0x37, 0x3E, 0x00, 0x2B, 0x42, 0x04, 0x36, 0x8B, 0x61, 0x7A,
	0xDD, 0xBF, 0xB1, 0xE3, 0xBD, 0xA7, 0xDB, 0xB7, 0xA8, 0xE6, 0xCD, 0xB9, 0xEB, 0xD5, 0xBA, 0xEC,
	0xD5, 0xB7, 0xEE, 0xD7, 0xB7, 0xF8, 0xE3, 0xBF, 0x97, 0x6A, 0x78, 0x40, 0x01, 0x34, 0x54, 0x0E,
	0x3A, 0x5F, 0x15, 0x3E, 0x64, 0x18, 0x3F, 0x63, 0x16, 0x3D, 0x5D, 0x11, 0x3C, 0x5E, 0x12, 0x3A,
	0x5C, 0x12, 0x3B, 0x58, 0x13, 0x3D, 0x63, 0x18, 0x3F, 0x60, 0x14, 0x3E, 0x55, 0x0D, 0x3C, 0x82,
	0x3B, 0x5C, 0xC5, 0x7C, 0x7B, 0xCB, 0x7C, 0x78, 0xC0, 0x73, 0x75, 0xCC, 0x82, 0x7B, 0xD3, 0x8B,
	0x7B, 0xD2, 0x89, 0x7A, 0xD2, 0x89, 0x7B, 0xD1, 0x88, 0x7B, 0xD0, 0x87, 0x78, 0xD0, 0x86, 0x76,
	0x9D, 0x38, 0x49, 0x9E, 0x39, 0x46, 0xA3, 0x39, 0x46, 0xA6, 0x3A, 0x48, 0xA5, 0x39, 0x46, 0xA0,
	0x34, 0x43, 0xB1, 0x3F, 0x49, 0xD2, 0x60, 0x56, 0xE0, 0x78, 0x62, 0xE5, 0x8A, 0x6C, 0xE7, 0x8F,
	0x70, 0xE7, 0x8D, 0x6F, 0xE5, 0x89, 0x6D, 0xE2, 0x80, 0x67, 0xD9, 0x67, 0x5B, 0xB6, 0x43, 0x4B,
	0x8C, 0x28, 0x3F, 0x86, 0x25, 0x3D, 0x95, 0x2E, 0x41, 0xA2, 0x38, 0x48, 0xAA, 0x3D, 0x49, 0xAB,
	0x3E, 0x49, 0xAC, 0x3F, 0x49, 0xB0, 0x3F, 0x48, 0xAE, 0x3E, 0x48, 0xAE, 0x40, 0x49, 0xB2, 0x42,
	0x4B, 0xB8, 0x45, 0x4D, 0xBD, 0x4A, 0x4F, 0xB5, 0x46, 0x50, 0xB8, 0x51, 0x5A, 0xEB, 0xB3, 0x87,
	0xE5, 0x8E, 0x6C, 0xB1, 0x3C, 0x48, 0xA7, 0x3C, 0x4B, 0xB1, 0x44, 0x4E, 0xB9, 0x48, 0x4F, 0xB7,
	0x47, 0x4E, 0xB5, 0x47, 0x50, 0xBE, 0x50, 0x57, 0xC3, 0x58, 0x5C, 0xC8, 0x60, 0x61, 0xC1, 0x5A,
	0x5E, 0xBA, 0x51, 0x5B, 0xBF, 0x5A, 0x61, 0xC6, 0x61, 0x63, 0xC9, 0x60, 0x5F, 0xC2, 0x59, 0x5B,
	0xB3, 0x46, 0x50, 0xB7, 0x58, 0x62, 0xD4, 0x8E, 0x86, 0xDC, 0xA4, 0x93, 0xD8, 0x97, 0x8A, 0xD5,
	0x90, 0x85, 0xD4, 0x93, 0x8A, 0xD3, 0x98, 0x8E, 0xD6, 0x9D, 0x92, 0xDA, 0xA1, 0x93, 0xD9, 0xA4,
	0x95, 0xD7, 0xA1, 0x94, 0xDA, 0xAF, 0xA1, 0xDA, 0xB2, 0xA6, 0xD8, 0xAD, 0xA1, 0xDA, 0xAF, 0xA2,
	0xDB, 0xAE, 0xA0, 0xD7, 0xAC, 0xA0, 0xD9, 0xB3, 0xA8, 0xDD, 0xBB, 0xB0, 0xDE, 0xBA, 0xAE, 0xDD,
	0xBB, 0xAE, 0xDC, 0xB6, 0xA9, 0xDF, 0xBC, 0xB0, 0xDE, 0xBE, 0xB3, 0xDD, 0xBD, 0xB2, 0xDE, 0xC2,
	0xB6, 0xDF, 0xC3, 0xB6, 0xE0, 0xC4, 0xB5, 0xDF, 0xC4, 0xB7, 0xDF, 0xC6, 0xB8, 0xE0, 0xC5, 0xB8,
	0xE1, 0xC8, 0xB9, 0xEB, 0xD7, 0xC1, 0xD8, 0xBB, 0xAF, 0xA8, 0x49, 0x56, 0xC8, 0x4F, 0x4C, 0xDC,
	0x78, 0x6C, 0xDF, 0x7E, 0x6D, 0xE1, 0x7E, 0x69, 0xE1, 0x7F, 0x6B, 0xDE, 0x79, 0x6A, 0xD3, 0x66,
	0x5F, 0xA3, 0x37, 0x43, 0x4E, 0x00, 0x2A, 0x4A, 0x15, 0x43, 0xA8, 0x84, 0x8F, 0xE8, 0xC9, 0xB4,
	0xD9, 0xAD, 0x9E, 0xD7, 0xB4, 0xA9, 0xE9, 0xD2, 0xBA, 0xE7, 0xCF, 0xBA, 0xE2, 0xC9, 0xB8, 0xE2,
	0xC6, 0xB7, 0xE5, 0xCA, 0xB8, 0xF9, 0xE5, 0xC1, 0xB1, 0x88, 0x89, 0x47, 0x05, 0x38, 0x53, 0x0D,
	0x3B, 0x5D, 0x13, 0x3F, 0x62, 0x16, 0x3D, 0x60, 0x13, 0x3A, 0x5E, 0x10, 0x38, 0x5B, 0x0F, 0x36,
	0x55, 0x0E, 0x38, 0x5E, 0x14, 0x3E, 0x64, 0x19, 0x3E, 0x55, 0x0F, 0x3C, 0x6A, 0x22, 0x4C, 0xB7,
	0x6F, 0x78, 0xD2, 0x84, 0x7C, 0xC4, 0x74, 0x74, 0xC8, 0x7D, 0x7A, 0xD3, 0x8A, 0x7B, 0xD3, 0x87,
	0x77, 0xD2, 0x87, 0x77, 0xD2, 0x88, 0x77, 0xD1, 0x87, 0x78, 0xD0, 0x86, 0x77, 0xD1, 0x87, 0x76,
	0xA2, 0x39, 0x47, 0xA4, 0x3B, 0x47, 0xA7, 0x3D, 0x49, 0xAA, 0x3D, 0x48, 0xA9, 0x3B, 0x46, 0xA4,
	0x38, 0x46, 0xB3, 0x41, 0x4B, 0xD3, 0x60, 0x57, 0xE0, 0x78, 0x62, 0xE6, 0x8A, 0x6D, 0xE7, 0x90,
	0x71, 0xE6, 0x8E, 0x70, 0xE7, 0x8C, 0x6D, 0xE4, 0x83, 0x68, 0xD9, 0x6A, 0x5C, 0xB7, 0x46, 0x4D,
	0x90, 0x2B, 0x40, 0x8C, 0x28, 0x3E, 0x9B, 0x33, 0x44, 0xA4, 0x3A, 0x48, 0xAA, 0x3C, 0x49, 0xAC,
	0x3E, 0x4A, 0xAF, 0x3F, 0x4A, 0xB2, 0x3F, 0x48, 0xB0, 0x3E, 0x47, 0xB3, 0x42, 0x4B, 0xB7, 0x45,
	0x4D, 0xB9, 0x47, 0x4E, 0xBE, 0x4A, 0x4F, 0xB3, 0x3E, 0x49, 0xC0, 0x5F, 0x5F, 0xF1, 0xBE, 0x8C,
	0xDF, 0x81, 0x67, 0xB1, 0x3C, 0x48, 0xAA, 0x3D, 0x49, 0xB3, 0x43, 0x4E, 0xAE, 0x40, 0x4D, 0xB0,
	0x44, 0x51, 0xBD, 0x4E, 0x56, 0xC4, 0x56, 0x5A, 0xC7, 0x58, 0x5B, 0xC1, 0x55, 0x5C, 0xBA, 0x55,
	0x5D, 0xBE, 0x56, 0x5E, 0xCA, 0x65, 0x67, 0xCA, 0x68, 0x68, 0xC5, 0x5A, 0x5C, 0xB4, 0x48, 0x51,
	0xBB, 0x5B, 0x61, 0xD6, 0x8A, 0x81, 0xDE, 0x97, 0x88, 0xD6, 0x8F, 0x82, 0xD3, 0x8F, 0x86, 0xD3,
	0x8D, 0x83, 0xD6, 0x94, 0x89, 0xD9, 0xA0, 0x94, 0xDA, 0xA5, 0x99, 0xD7, 0xA0, 0x92, 0xD8, 0xA5,
	0x97, 0xDA, 0xAD, 0xA0, 0xD9, 0xA8, 0x9C, 0xD9, 0xAA, 0x9E, 0xD8, 0xAB, 0x9F, 0xD5, 0xA0, 0x96,
	0xD6, 0xA1, 0x96, 0xD8, 0xAB, 0xA0, 0xDB, 0xB4, 0xA6, 0xDE, 0xBE, 0xB0, 0xDD, 0xB9, 0xAD, 0xDC,
	0xB7, 0xAA, 0xDB, 0xB7, 0xAB, 0xDB, 0xB6, 0xAA, 0xDF, 0xBE, 0xB2, 0xDE, 0xC0, 0xB4, 0xDB, 0xB7,
	0xA9, 0xDB, 0xB8, 0xAD, 0xDC, 0xBC, 0xB0, 0xDE, 0xBF, 0xB3, 0xDE, 0xC0, 0xB6, 0xDD, 0xC1, 0xB6,
	0xE1, 0xC7, 0xB9, 0xE2, 0xC9, 0xBA, 0xE5, 0xD2, 0xC1, 0xCE, 0xA7, 0xA2, 0xC9, 0x66, 0x62, 0xDB,
	0x6B, 0x5A, 0xE0, 0x7C, 0x64, 0xE1, 0x7E, 0x66, 0xE1, 0x7E, 0x67, 0xDE, 0x75, 0x61, 0xC5, 0x4E,
	0x4C, 0x88, 0x23, 0x3D, 0x7B, 0x46, 0x64, 0xC4, 0xA4, 0xA4, 0xE9, 0xC7, 0xB0, 0xD9, 0xAF, 0xA2,
	0xD9, 0xBB, 0xAF, 0xE5, 0xD0, 0xBD, 0xE5, 0xCC, 0xBA, 0xDF, 0xC2, 0xB6, 0xDF, 0xBF, 0xB4, 0xE1,
	0xC4, 0xB8, 0xE3, 0xCB, 0xBA, 0xF9, 0xE5, 0xC1, 0xB2, 0x88, 0x88, 0x46, 0x03, 0x37, 0x54, 0x11,
	0x3E, 0x60, 0x19, 0x42, 0x60, 0x14, 0x3C, 0x5C, 0x0E, 0x36, 0x5D, 0x0D, 0x35, 0x59, 0x0E, 0x38,
	0x5D, 0x12, 0x3B, 0x64, 0x15, 0x3B, 0x53, 0x0C, 0x36, 0x50, 0x0A, 0x3B, 0x9B, 0x4F, 0x66, 0xD3,
	0x85, 0x7F, 0xCA, 0x79, 0x77, 0xC8, 0x7A, 0x78, 0xD1, 0x89, 0x7C, 0xD3, 0x89, 0x7A, 0xD2, 0x87,
	0x76, 0xD1, 0x87, 0x78, 0xD0, 0x87, 0x78, 0xD0, 0x85, 0x76, 0xCF, 0x82, 0x76, 0xD1, 0x86, 0x77,
	0xA8, 0x3D, 0x48, 0xA9, 0x3E, 0x48, 0xAC, 0x3F, 0x49, 0xAD, 0x3F, 0x48, 0xAB, 0x3A, 0x47, 0xA6,
	0x35, 0x45, 0xB4, 0x3F, 0x48, 0xD4, 0x60, 0x58, 0xE0, 0x7B, 0x65, 0xE5, 0x8A, 0x6E, 0xE6, 0x8F,
	0x71, 0xE6, 0x8D, 0x70, 0xE9, 0x8E, 0x6E, 0xE6, 0x85, 0x6A, 0xD9, 0x6D, 0x5F, 0xBA, 0x47, 0x4C,
	0x96, 0x29, 0x3F, 0x90, 0x29, 0x3F, 0x9D, 0x33, 0x44, 0xA6, 0x3A, 0x47, 0xAD, 0x3E, 0x4A, 0xAE,
	0x3E, 0x4A, 0xB1, 0x3F, 0x49, 0xB2, 0x42, 0x4A, 0xAF, 0x3E, 0x47, 0xB3, 0x40, 0x48, 0xB8, 0x46,
	0x4D, 0xBA, 0x47, 0x4E, 0xBE, 0x4B, 0x50, 0xB2, 0x3B, 0x48, 0xC9, 0x75, 0x6B, 0xF3, 0xBF, 0x8B,
	0xD5, 0x68, 0x59, 0xAF, 0x3D, 0x49, 0xA4, 0x3A, 0x47, 0xAE, 0x40, 0x4B, 0xB5, 0x44, 0x50, 0xBD,
	0x4C, 0x54, 0xBD, 0x4A, 0x51, 0xBD, 0x51, 0x55, 0xBE, 0x52, 0x57, 0xC0, 0x52, 0x5A, 0xC6, 0x5B,
	0x60, 0xC9, 0x5E, 0x61, 0xC4, 0x5C, 0x5E, 0xBF, 0x58, 0x5C, 0xB4, 0x4A, 0x55, 0xBA, 0x5D, 0x64,
	0xD7, 0x86, 0x7D, 0xDA, 0x87, 0x7C, 0xD3, 0x81, 0x77, 0xD1, 0x80, 0x7A, 0xD0, 0x8C, 0x84, 0xD4,
	0x91, 0x87, 0xD7, 0x96, 0x8B, 0xDC, 0x9F, 0x91, 0xDA, 0xA4, 0x98, 0xD8, 0xA7, 0x9B, 0xD6, 0xA0,
	0x94, 0xD6, 0xA2, 0x97, 0xD8, 0xAA, 0x9E, 0xD6, 0xA2, 0x97, 0xD2, 0x99, 0x8F, 0xD3, 0x9D, 0x95,
	0xD9, 0xA7, 0x9A, 0xDA, 0xB0, 0xA3, 0xD8, 0xAC, 0x9F, 0xDA, 0xB2, 0xA4, 0xDC, 0xB9, 0xAD, 0xDB,
	0xB6, 0xAB, 0xDB, 0xBA, 0xB0, 0xDC, 0xBE, 0xB2, 0xE0, 0xBF, 0xB1, 0xD7, 0xAA, 0x9F, 0xCE, 0x9B,
	0x92, 0xD9, 0xB4, 0xAB, 0xDC, 0xBF, 0xB6, 0xDE, 0xC0, 0xB6, 0xDE, 0xC0, 0xB6, 0xDC, 0xC0, 0xB6,
	0xDC, 0xBF, 0xB6, 0xDB, 0xBD, 0xB4, 0xDF, 0xC5, 0xB9, 0xE6, 0xD8, 0xC6, 0xDE, 0xB4, 0xA6, 0xDA,
	0x73, 0x60, 0xDF, 0x76, 0x5C, 0xDF, 0x7A, 0x61, 0xDF, 0x76, 0x5D, 0xD6, 0x64, 0x56, 0xBC, 0x60,
	0x65, 0xBA, 0x8A, 0x8C, 0xDF, 0xC2, 0xB0, 0xE5, 0xC0, 0xAD, 0xD8, 0xB2, 0xA8, 0xDE, 0xC5, 0xB8,
	0xE5, 0xCE, 0xBD, 0xE3, 0xC5, 0xB7, 0xDF, 0xC2, 0xB6, 0xDE, 0xBE, 0xB5, 0xE1, 0xC2, 0xB7, 0xE2,
	0xC9, 0xBA, 0xE4, 0xCD, 0xBA, 0xF9, 0xE3, 0xC0, 0xA7, 0x79, 0x7E, 0x46, 0x02, 0x34, 0x57, 0x11,
	0x3D, 0x5F, 0x16, 0x3F, 0x60, 0x17, 0x40, 0x5E, 0x12, 0x39, 0x5C, 0x0D, 0x36, 0x5C, 0x11, 0x3B,
	0x65, 0x18, 0x3D, 0x5F, 0x13, 0x37, 0x42, 0x00, 0x30, 0x71, 0x28, 0x4E, 0xC9, 0x7A, 0x7B, 0xD1,
	0x81, 0x7C, 0xC4, 0x77, 0x77, 0xCF, 0x85, 0x7B, 0xD3, 0x8B, 0x7C, 0xD2, 0x88, 0x79, 0xD2, 0x85,
	0x76, 0xCF, 0x85, 0x76, 0xD0, 0x85, 0x78, 0xD0, 0x84, 0x76, 0xCE, 0x82, 0x76, 0xCE, 0x83, 0x77,
	0xAA, 0x40, 0x4C, 0xAB, 0x3F, 0x4A, 0xAC, 0x3F, 0x49, 0xAB, 0x3F, 0x49, 0xAA, 0x3C, 0x4A, 0xA9,
	0x39, 0x47, 0xBC, 0x43, 0x49, 0xD7, 0x61, 0x57, 0xDF, 0x7A, 0x64, 0xE4, 0x86, 0x6B, 0xE7, 0x8E,
	0x6F, 0xE8, 0x8F, 0x6F, 0xEA, 0x8F, 0x6F, 0xE7, 0x86, 0x6A, 0xDA, 0x6D, 0x5F, 0xBC, 0x49, 0x4D,
	0x95, 0x28, 0x3E, 0x90, 0x29, 0x3E, 0x9C, 0x34, 0x43, 0xA5, 0x39, 0x47, 0xAC, 0x3E, 0x4B, 0xAF,
	0x3F, 0x4A, 0xB0, 0x3F, 0x49, 0xB0, 0x40, 0x49, 0xAF, 0x3D, 0x47, 0xB0, 0x3D, 0x46, 0xB5, 0x42,
	0x4A, 0xB9, 0x45, 0x4D, 0xBA, 0x47, 0x4E, 0xAB, 0x37, 0x47, 0xD0, 0x88, 0x76, 0xF0, 0xB1, 0x82,
	0xD1, 0x5E, 0x54, 0xB5, 0x46, 0x4F, 0xA8, 0x3E, 0x4C, 0xB1, 0x43, 0x4D, 0xB4, 0x43, 0x4D, 0xB0,
	0x3F, 0x4B, 0xB6, 0x45, 0x4E, 0xBB, 0x4D, 0x54, 0xBC, 0x4F, 0x57, 0xC9, 0x59, 0x5E, 0xC7, 0x59,
	0x5C, 0xC0, 0x55, 0x5A, 0xBC, 0x51, 0x57, 0xB3, 0x4B, 0x56, 0xBD, 0x5E, 0x65, 0xD7, 0x83, 0x79,
	0xD7, 0x82, 0x78, 0xD3, 0x77, 0x74, 0xCE, 0x77, 0x75, 0xC8, 0x79, 0x76, 0xCF, 0x81, 0x7B, 0xD9,
	0x95, 0x89, 0xD9, 0xA0, 0x93, 0xD9, 0x9D, 0x90, 0xD6, 0x98, 0x8F, 0xD6, 0x98, 0x8F, 0xD6, 0xA3,
	0x99, 0xD7, 0xA4, 0x9A, 0xD7, 0x9D, 0x92, 0xD2, 0x97, 0x90, 0xD3, 0x98, 0x90, 0xDA, 0xA8, 0x9A,
	0xDA, 0xA9, 0x9A, 0xD7, 0xA6, 0x9A, 0xD8, 0xA9, 0x9D, 0xD8, 0xA9, 0x9D, 0xD9, 0xAD, 0xA0, 0xDA,
	0xB6, 0xAA, 0xDE, 0xBC, 0xB0, 0xDE, 0xBE, 0xB2, 0xD7, 0xAC, 0xA1, 0xD2, 0x9F, 0x95, 0xD6, 0xAC,
	0xA1, 0xD9, 0xB7, 0xAC, 0xDB, 0xBB, 0xB2, 0xDC, 0xBC, 0xB2, 0xDD, 0xBD, 0xB2, 0xDC, 0xBD, 0xB4,
	0xDA, 0xBD, 0xB5, 0xD9, 0xBC, 0xB4, 0xDA, 0xBA, 0xB1, 0xDD, 0xC3, 0xB8, 0xE1, 0xCE, 0xC0, 0xDD,
	0x94, 0x82, 0xDF, 0x70, 0x55, 0xDD, 0x6E, 0x57, 0xD8, 0x71, 0x64, 0xD7, 0x93, 0x8C, 0xDC, 0xBA,
	0xAB, 0xE4, 0xC3, 0xAB, 0xDD, 0xB6, 0xA4, 0xDA, 0xB9, 0xAE, 0xE2, 0xCA, 0xBB, 0xE3, 0xC8, 0xB9,
	0xE0, 0xC0, 0xB4, 0xDE, 0xBE, 0xB3, 0xDF, 0xBF, 0xB4, 0xE1, 0xC1, 0xB6, 0xE2, 0xC8, 0xB9, 0xE1,
	0xCA, 0xBB, 0xE7, 0xD0, 0xBB, 0xF6, 0xDF, 0xBC, 0x90, 0x5C, 0x6C, 0x44, 0x02, 0x35, 0x59, 0x15,
	0x40, 0x5B, 0x12, 0x3D, 0x5D, 0x15, 0x3D, 0x5D, 0x12, 0x39, 0x57, 0x0C, 0x35, 0x5D, 0x11, 0x39,
	0x62, 0x15, 0x3A, 0x56, 0x0C, 0x37, 0x5E, 0x14, 0x3F, 0xAA, 0x5D, 0x6C, 0xD5, 0x86, 0x7E, 0xCA,
	0x79, 0x77, 0xCB, 0x7D, 0x79, 0xD3, 0x8A, 0x7B, 0xD2, 0x89, 0x7A, 0xD3, 0x86, 0x79, 0xD2, 0x85,
	0x76, 0xCF, 0x84, 0x76, 0xCF, 0x84, 0x78, 0xCF, 0x83, 0x77, 0xCE, 0x82, 0x75, 0xCF, 0x81, 0x74,
	0xAA, 0x3F, 0x4B, 0xAE, 0x3E, 0x47, 0xAB, 0x3E, 0x48, 0xAA, 0x3F, 0x4A, 0xAB, 0x3C, 0x49, 0xAB,
	0x3A, 0x45, 0xC0, 0x46, 0x4A, 0xD8, 0x63, 0x58, 0xE0, 0x7C, 0x68, 0xE6, 0x87, 0x6B, 0xE9, 0x8E,
	0x6D, 0xE9, 0x92, 0x6F, 0xEA, 0x93, 0x72, 0xE6, 0x8B, 0x6E, 0xDC, 0x6F, 0x5F, 0xBC, 0x48, 0x4C,
	0x93, 0x28, 0x3E, 0x8F, 0x2A, 0x40, 0x9C, 0x39, 0x48, 0xA5, 0x3A, 0x48, 0xAA, 0x3E, 0x4A, 0xAC,
	0x3E, 0x49, 0xAE, 0x3E, 0x48, 0xAF, 0x3E, 0x48, 0xAE, 0x3C, 0x48, 0xAD, 0x3E, 0x48, 0xB3, 0x42,
	0x4A, 0xB8, 0x44, 0x4B, 0xB4, 0x40, 0x49, 0xA9, 0x37, 0x48, 0xDB, 0x9A, 0x7D, 0xF0, 0xA9, 0x7D,
	0xD5, 0x63, 0x58, 0xBC, 0x4A, 0x4F, 0xAF, 0x41, 0x4E, 0xB1, 0x44, 0x50, 0xB0, 0x42, 0x4D, 0xAC,
	0x40, 0x4D, 0xB4, 0x46, 0x50, 0xB7, 0x49, 0x51, 0xC0, 0x51, 0x57, 0xC2, 0x54, 0x59, 0xBF, 0x54,
	0x59, 0xC1, 0x53, 0x5B, 0xBA, 0x4E, 0x5B, 0xC5, 0x68, 0x6C, 0xD7, 0x7B, 0x75, 0xD8, 0x76, 0x6E,
	0xD2, 0x76, 0x6F, 0xCB, 0x77, 0x74, 0xC6, 0x70, 0x71, 0xCF, 0x7B, 0x78, 0xD7, 0x8B, 0x83, 0xD5,
	0x90, 0x87, 0xD5, 0x9A, 0x8E, 0xD6, 0x97, 0x8B, 0xD3, 0x8F, 0x89, 0xD4, 0x97, 0x8E, 0xD9, 0xA3,
	0x95, 0xD5, 0x9A, 0x8E, 0xD1, 0x8B, 0x84, 0xD7, 0x9D, 0x93, 0xD6, 0xA0, 0x95, 0xD8, 0x9D, 0x93,
	0xD9, 0xA3, 0x95, 0xD6, 0xA0, 0x95, 0xD6, 0xA0, 0x95, 0xD6, 0xA2, 0x97, 0xD9, 0xAB, 0x9E, 0xDA,
	0xAE, 0xA1, 0xD8, 0xA1, 0x96, 0xD6, 0xA5, 0x9A, 0xD4, 0xA5, 0x9B, 0xD6, 0xA9, 0x9E, 0xD7, 0xAD,
	0xA2, 0xD6, 0xB1, 0xA6, 0xD9, 0xB6, 0xAC, 0xDA, 0xBB, 0xB1, 0xDA, 0xB7, 0xAD, 0xD9, 0xB2, 0xA7,
	0xD9, 0xB7, 0xAE, 0xD9, 0xB9, 0xB1, 0xD6, 0xB2, 0xA9, 0xD4, 0xB1, 0xA9, 0xD8, 0xBE, 0xB6, 0xDB,
	0xA8, 0x9D, 0xDB, 0x73, 0x62, 0xDA, 0x89, 0x7B, 0xDC, 0xAC, 0x9E, 0xE2, 0xC2, 0xAD, 0xE0, 0xBA,
	0xA5, 0xDA, 0xB2, 0xA5, 0xDD, 0xC1, 0xB5, 0xE3, 0xC8, 0xBB, 0xE0, 0xC2, 0xB7, 0xDE, 0xBE, 0xB4,
	0xDD, 0xBE, 0xB2, 0xE0, 0xC0, 0xB4, 0xE2, 0xC2, 0xB7, 0xE2, 0xC2, 0xB7, 0xE1, 0xC5, 0xB7, 0xE2,
	0xCA, 0xBA, 0xEC, 0xD6, 0xBB, 0xEE, 0xD4, 0xB6, 0x7A, 0x43, 0x5C, 0x45, 0x07, 0x3A, 0x5B, 0x19,
	0x43, 0x5E, 0x16, 0x3F, 0x5D, 0x12, 0x3C, 0x57, 0x0D, 0x36, 0x58, 0x0D, 0x37, 0x5F, 0x11, 0x3B,
	0x5F, 0x15, 0x3F, 0x65, 0x17, 0x40, 0x94, 0x41, 0x5A, 0xCB, 0x7C, 0x7B, 0xCE, 0x7C, 0x78, 0xC9,
	0x78, 0x77, 0xD1, 0x85, 0x7C, 0xD3, 0x89, 0x7B, 0xD2, 0x88, 0x7C, 0xD2, 0x86, 0x79, 0xD2, 0x86,
	0x77, 0xD2, 0x86, 0x77, 0xCE, 0x84, 0x76, 0xCC, 0x83, 0x76, 0xCD, 0x82, 0x75, 0xCD, 0x81, 0x76,
	0xAB, 0x3F, 0x4A, 0xAD, 0x3F, 0x49, 0xAC, 0x3E, 0x49, 0xAA, 0x3E, 0x49, 0xAE, 0x3E, 0x47, 0xAE,
	0x3A, 0x45, 0xBE, 0x45, 0x4A, 0xD5, 0x62, 0x56, 0xE1, 0x7E, 0x65, 0xE7, 0x8B, 0x6D, 0xE9, 0x91,
	0x6E, 0xE9, 0x96, 0x70, 0xEA, 0x96, 0x74, 0xE8, 0x8D, 0x70, 0xDE, 0x70, 0x5E, 0xBE, 0x48, 0x4C,
	0x93, 0x2A, 0x3F, 0x8E, 0x28, 0x3E, 0x9D, 0x36, 0x46, 0xA6, 0x38, 0x45, 0xA9, 0x3C, 0x47, 0xAA,
	0x3F, 0x4A, 0xAD, 0x3E, 0x48, 0xAD, 0x3B, 0x46, 0xAA, 0x3B, 0x47, 0xAC, 0x3F, 0x4A, 0xB2, 0x40,
	0x49, 0xB5, 0x43, 0x4A, 0xAE, 0x39, 0x44, 0xAD, 0x41, 0x4D, 0xE6, 0xB0, 0x88, 0xF0, 0xAC, 0x7C,
	0xD9, 0x6C, 0x5F, 0xC1, 0x4E, 0x50, 0xB1, 0x41, 0x4B, 0xB0, 0x44, 0x4F, 0xB2, 0x44, 0x4F, 0xB6,
	0x45, 0x4F, 0xBA, 0x49, 0x53, 0xBF, 0x4E, 0x55, 0xC2, 0x51, 0x57, 0xC2, 0x54, 0x5B, 0xC6, 0x59,
	0x5B, 0xBC, 0x50, 0x58, 0xC4, 0x63, 0x68, 0xD8, 0x7A, 0x76, 0xD8, 0x78, 0x73, 0xD3, 0x6E, 0x6B,
	0xCA, 0x6E, 0x6B, 0xC4, 0x6A, 0x6A, 0xCE, 0x74, 0x70, 0xD7, 0x86, 0x7F, 0xD4, 0x8D, 0x86, 0xD1,
	0x89, 0x81, 0xD2, 0x86, 0x81, 0xD6, 0x95, 0x8C, 0xD4, 0xA0, 0x96, 0xD5, 0x97, 0x8D, 0xD2, 0x8A,
	0x7F, 0xD1, 0x90, 0x86, 0xD8, 0x9A, 0x8F, 0xD8, 0x9A, 0x8E, 0xD5, 0x9C, 0x92, 0xD7, 0x9D, 0x93,
	0xD8, 0x98, 0x8E, 0xD7, 0x9A, 0x8F, 0xD6, 0xA2, 0x98, 0xD8, 0xAC, 0xA2, 0xD9, 0xAE, 0xA2, 0xD5,
	0xA0, 0x96, 0xD4, 0x9B, 0x92, 0xD7, 0xA6, 0x9A, 0xD7, 0xAE, 0xA3, 0xD4, 0xA9, 0x9F, 0xD7, 0xAF,
	0xA4, 0xD8, 0xB6, 0xAC, 0xD9, 0xB5, 0xAB, 0xD9, 0xB1, 0xA6, 0xD5, 0xAA, 0xA1, 0xD5, 0xAB, 0xA1,
	0xD6, 0xAF, 0xA5, 0xD5, 0xAF, 0xA6, 0xD1, 0xAB, 0xA3, 0xD0, 0xA6, 0x9F, 0xCF, 0xAA, 0xA4, 0xD7,
	0xB3, 0xAB, 0xDD, 0xA9, 0x9A, 0xE0, 0xBB, 0xA7, 0xDE, 0xBC, 0xA7, 0xDC, 0xB4, 0xA2, 0xDF, 0xBE,
	0xB0, 0xE2, 0xC5, 0xB7, 0xE2, 0xC4, 0xB8, 0xE0, 0xC0, 0xB5, 0xDD, 0xBB, 0xB0, 0xDD, 0xBC, 0xB2,
	0xDF, 0xC1, 0xB6, 0xE2, 0xC5, 0xB7, 0xE2, 0xC4, 0xB6, 0xDE, 0xBC, 0xB0, 0xDF, 0xC3, 0xB6, 0xE3,
	0xCC, 0xBA, 0xF3, 0xDE, 0xBE, 0xE1, 0xC2, 0xAA, 0x62, 0x26, 0x4B, 0x4A, 0x06, 0x36, 0x5C, 0x14,
	0x3C, 0x5F, 0x16, 0x3F, 0x5C, 0x13, 0x3C, 0x56, 0x0D, 0x37, 0x5D, 0x10, 0x38, 0x60, 0x13, 0x3D,
	0x63, 0x18, 0x46, 0x7E, 0x31, 0x56, 0xBD, 0x6A, 0x72, 0xD6, 0x7F, 0x7A, 0xC9, 0x77, 0x76, 0xCC,
	0x81, 0x7B, 0xD3, 0x8A, 0x7C, 0xD3, 0x89, 0x7B, 0xD3, 0x87, 0x7B, 0xD1, 0x87, 0x7A, 0xCF, 0x85,
	0x7A, 0xD0, 0x85, 0x77, 0xCE, 0x84, 0x76, 0xCD, 0x82, 0x75, 0xCC, 0x82, 0x76, 0xCC, 0x83, 0x76,
	0xA9, 0x40, 0x4D, 0xA9, 0x3D, 0x4A, 0xA9, 0x3E, 0x49, 0xA8, 0x3B, 0x47, 0xAB, 0x3C, 0x47, 0xAE,
	0x3B, 0x46, 0xBA, 0x44, 0x4A, 0xD1, 0x5F, 0x56, 0xE0, 0x7C, 0x64, 0xE8, 0x8D, 0x6E, 0xEA, 0x95,
	0x70, 0xE9, 0x96, 0x70, 0xEB, 0x94, 0x71, 0xE9, 0x8B, 0x6C, 0xDD, 0x6E, 0x5D, 0xBE, 0x49, 0x4C,
	0x94, 0x29, 0x3F, 0x8E, 0x25, 0x3C, 0x9D, 0x34, 0x43, 0xA6, 0x38, 0x46, 0xAB, 0x3A, 0x46, 0xAB,
	0x3D, 0x48, 0xAB, 0x3D, 0x49, 0xAC, 0x3C, 0x47, 0xAA, 0x3C, 0x48, 0xAC, 0x3C, 0x47, 0xB2, 0x3F,
	0x49, 0xB5, 0x43, 0x4A, 0xAA, 0x35, 0x42, 0xB4, 0x4E, 0x56, 0xED, 0xBC, 0x8E, 0xED, 0xA7, 0x78,
	0xDB, 0x73, 0x61, 0xCD, 0x5A, 0x57, 0xC2, 0x4F, 0x51, 0xB8, 0x48, 0x4D, 0xB1, 0x43, 0x4E, 0xB9,
	0x46, 0x4F, 0xBA, 0x46, 0x50, 0xBD, 0x4A, 0x51, 0xC4, 0x53, 0x59, 0xC5, 0x57, 0x5C, 0xBC, 0x50,
	0x59, 0xC1, 0x5D, 0x63, 0xD5, 0x79, 0x74, 0xD3, 0x70, 0x6E, 0xD2, 0x70, 0x6F, 0xCB, 0x6D, 0x6B,
	0xC5, 0x65, 0x67, 0xD1, 0x72, 0x70, 0xD4, 0x7D, 0x77, 0xCE, 0x7D, 0x78, 0xCE, 0x79, 0x75, 0xD4,
	0x82, 0x7C, 0xD6, 0x97, 0x8E, 0xD8, 0x9C, 0x91, 0xD5, 0x93, 0x88, 0xD3, 0x8A, 0x82, 0xD5, 0x90,
	0x86, 0xD8, 0x9A, 0x8B, 0xDA, 0x99, 0x8D, 0xD8, 0x99, 0x8E, 0xD6, 0x99, 0x8F, 0xD6, 0x9A, 0x8F,
	0xD6, 0x9C, 0x91, 0xD5, 0x95, 0x8D, 0xD6, 0x9A, 0x90, 0xD7, 0xA4, 0x98, 0xD7, 0xA7, 0x9B, 0xD8,
	0xA8, 0x9C, 0xD7, 0xA5, 0x99, 0xD5, 0xA3, 0x98, 0xD5, 0xA8, 0x9E, 0xD9, 0xB4, 0xAA, 0xD7, 0xB2,
	0xA8, 0xD7, 0xB0, 0xA5, 0xD5, 0xAA, 0xA0, 0xD3, 0xA1, 0x97, 0xD2, 0x9D, 0x95, 0xD3, 0xAA, 0xA1,
	0xD3, 0xAA, 0xA1, 0xCF, 0xA2, 0x99, 0xCB, 0x99, 0x93, 0xCA, 0x99, 0x94, 0xD4, 0xAE, 0xA3, 0xDA,
	0xB1, 0xA1, 0xDA, 0xB0, 0x9F, 0xDD, 0xB6, 0xA4, 0xDE, 0xBD, 0xB0, 0xE2, 0xC6, 0xB8, 0xE1, 0xC5,
	0xB6, 0xDD, 0xBC, 0xAF, 0xDD, 0xBD, 0xB3, 0xDD, 0xBC, 0xB1, 0xDC, 0xBA, 0xAE, 0xDE, 0xBD, 0xB2,
	0xE1, 0xC1, 0xB7, 0xE3, 0xC6, 0xB9, 0xDC, 0xB4, 0xA7, 0xD8, 0xAB, 0x9D, 0xE0, 0xC4, 0xB7, 0xE4,
	0xCD, 0xBC, 0xF6, 0xE2, 0xC2, 0xC4, 0x9C, 0x93, 0x4E, 0x09, 0x36, 0x50, 0x08, 0x33, 0x5B, 0x10,
	0x39, 0x5E, 0x15, 0x3E, 0x59, 0x13, 0x3C, 0x59, 0x0E, 0x38, 0x63, 0x16, 0x3B, 0x5B, 0x11, 0x3A,
	0x61, 0x17, 0x45, 0xA1, 0x56, 0x6C, 0xD4, 0x80, 0x7C, 0xD0, 0x77, 0x76, 0xCB, 0x7A, 0x77, 0xD2,
	0x89, 0x7D, 0xD2, 0x8A, 0x7C, 0xD2, 0x87, 0x7B, 0xD3, 0x87, 0x7B, 0xD2, 0x86, 0x7B, 0xD1, 0x87,
	0x7C, 0xD1, 0x87, 0x7A, 0xD0, 0x86, 0x79, 0xCF, 0x84, 0x79, 0xCF, 0x83, 0x79, 0xCF, 0x85, 0x76,
	0xA6, 0x3C, 0x49, 0xA7, 0x3D, 0x4A, 0xA8, 0x3E, 0x4A, 0xA9, 0x3B, 0x48, 0xA9, 0x3C, 0x47, 0xA8,
	0x39, 0x45, 0xB7, 0x43, 0x49, 0xD2, 0x60, 0x56, 0xE1, 0x7B, 0x64, 0xE8, 0x8E, 0x6D, 0xEA, 0x96,
	0x70, 0xE9, 0x94, 0x70, 0xEA, 0x93, 0x72, 0xE8, 0x8B, 0x6D, 0xDE, 0x6F, 0x5E, 0xBE, 0x4B, 0x4E,
	0x94, 0x2A, 0x3F, 0x90, 0x29, 0x3F, 0x9E, 0x37, 0x45, 0xA6, 0x39, 0x45, 0xAD, 0x3B, 0x46, 0xAE,
	0x3D, 0x48, 0xAC, 0x3C, 0x47, 0xAC, 0x3C, 0x47, 0xAC, 0x3B, 0x46, 0xAF, 0x3D, 0x47, 0xB2, 0x41,
	0x49, 0xB4, 0x42, 0x49, 0xA9, 0x35, 0x43, 0xB7, 0x55, 0x5A, 0xEF, 0xBC, 0x8E, 0xEB, 0xA3, 0x76,
	0xDD, 0x7B, 0x66, 0xD7, 0x68, 0x5E, 0xD1, 0x5E, 0x56, 0xC2, 0x4E, 0x4F, 0xB4, 0x42, 0x4B, 0xB2,
	0x42, 0x4E, 0xB2, 0x45, 0x52, 0xBC, 0x4E, 0x56, 0xBE, 0x4E, 0x54, 0xB2, 0x47, 0x54, 0xC2, 0x61,
	0x67, 0xD5, 0x6F, 0x6D, 0xD6, 0x71, 0x6E, 0xD0, 0x71, 0x6C, 0xC2, 0x67, 0x68, 0xC1, 0x5F, 0x65,
	0xD3, 0x71, 0x70, 0xD7, 0x7E, 0x79, 0xD2, 0x7F, 0x78, 0xCD, 0x6F, 0x6E, 0xD0, 0x71, 0x70, 0xD1,
	0x82, 0x7C, 0xD3, 0x95, 0x8A, 0xD3, 0x90, 0x86, 0xCF, 0x80, 0x7C, 0xD6, 0x93, 0x88, 0xD9, 0x9F,
	0x90, 0xD7, 0x91, 0x84, 0xD7, 0x8E, 0x82, 0xDA, 0x9A, 0x8E, 0xD9, 0x9E, 0x93, 0xD7, 0x96, 0x8D,
	0xD4, 0x92, 0x8B, 0xD4, 0x94, 0x8C, 0xD6, 0x93, 0x89, 0xD8, 0x96, 0x8A, 0xD8, 0x9F, 0x91, 0xD5,
	0x9E, 0x92, 0xD4, 0xA0, 0x97, 0xD6, 0xA9, 0x9F, 0xD6, 0xA4, 0x99, 0xD8, 0xAD, 0xA2, 0xD5, 0xAF,
	0xA6, 0xD4, 0xA1, 0x99, 0xD3, 0xA4, 0x9C, 0xD2, 0xA7, 0x9F, 0xD3, 0x9D, 0x95, 0xD3, 0x9F, 0x94,
	0xCF, 0x9E, 0x97, 0xC8, 0x91, 0x8D, 0xCE, 0x9E, 0x95, 0xD9, 0xAE, 0xA0, 0xDC, 0xB0, 0x9F, 0xD8,
	0xAB, 0x9E, 0xDA, 0xB4, 0xAA, 0xE0, 0xC1, 0xB5, 0xE1, 0xC2, 0xB6, 0xE0, 0xC1, 0xB1, 0xDC, 0xBB,
	0xAE, 0xDB, 0xBA, 0xB1, 0xDD, 0xBD, 0xB3, 0xDD, 0xBC, 0xB1, 0xDE, 0xBD, 0xB3, 0xE1, 0xC0, 0xB6,
	0xE3, 0xC6, 0xB9, 0xE0, 0xBC, 0xAE, 0xD1, 0x91, 0x87, 0xD3, 0x97, 0x8A, 0xDC, 0xB5, 0xA5, 0xE1,
	0xBE, 0xAF, 0xF3, 0xD7, 0xBC, 0x98, 0x63, 0x6F, 0x44, 0x00, 0x31, 0x56, 0x0E, 0x38, 0x5C, 0x11,
	0x3A, 0x5D, 0x16, 0x40, 0x58, 0x13, 0x3D, 0x5B, 0x0E, 0x36, 0x5F, 0x13, 0x3C, 0x55, 0x0E, 0x3B,
	0x73, 0x28, 0x4F, 0xC5, 0x74, 0x77, 0xD5, 0x80, 0x7A, 0xC8, 0x78, 0x78, 0xD0, 0x85, 0x7C, 0xD3,
	0x8A, 0x7D, 0xD2, 0x88, 0x7C, 0xD2, 0x87, 0x7B, 0xD2, 0x89, 0x7C, 0xD2, 0x87, 0x79, 0xD2, 0x88,
	0x7A, 0xD1, 0x88, 0x79, 0xD1, 0x86, 0x79, 0xD1, 0x86, 0x79, 0xD2, 0x86, 0x78, 0xD2, 0x85, 0x76,
	0xA7, 0x3B, 0x46, 0xA6, 0x3C, 0x49, 0xA5, 0x3B, 0x48, 0xA5, 0x3A, 0x47, 0xA8, 0x3B, 0x46, 0xA8,
	0x39, 0x46, 0xB8, 0x44, 0x4B, 0xD3, 0x64, 0x5A, 0xE2, 0x7F, 0x66, 0xE9, 0x8E, 0x6D, 0xE9, 0x93,
	0x72, 0xE8, 0x94, 0x71, 0xE8, 0x93, 0x73, 0xE7, 0x8A, 0x6D, 0xDF, 0x6F, 0x5F, 0xBD, 0x49, 0x4E,
	0x92, 0x2C, 0x3F, 0x8F, 0x2B, 0x40, 0x9F, 0x37, 0x46, 0xA7, 0x3A, 0x48, 0xAA, 0x3D, 0x49, 0xAB,
	0x3F, 0x49, 0xAC, 0x3C, 0x47, 0xAD, 0x3C, 0x47, 0xAC, 0x3B, 0x46, 0xAD, 0x3D, 0x47, 0xB0, 0x40,
	0x49, 0xB3, 0x40, 0x48, 0xA6, 0x33, 0x42, 0xB3, 0x57, 0x5C, 0xEE, 0xB8, 0x8A, 0xEB, 0x9D, 0x73,
	0xE1, 0x83, 0x69, 0xDC, 0x74, 0x62, 0xD8, 0x68, 0x5B, 0xCD, 0x59, 0x55, 0xB6, 0x43, 0x4B, 0xA6,
	0x38, 0x48, 0xB4, 0x44, 0x4E, 0xC0, 0x4D, 0x51, 0xB6, 0x48, 0x52, 0xBF, 0x5A, 0x63, 0xD6, 0x70,
	0x6C, 0xD3, 0x69, 0x67, 0xD0, 0x6E, 0x6C, 0xC0, 0x67, 0x69, 0xBC, 0x56, 0x60, 0xD2, 0x6E, 0x6D,
	0xD7, 0x7A, 0x75, 0xCD, 0x76, 0x73, 0xCF, 0x77, 0x73, 0xD2, 0x79, 0x75, 0xCE, 0x7E, 0x7B, 0xCC,
	0x79, 0x76, 0xCF, 0x79, 0x75, 0xD0, 0x7F, 0x79, 0xD9, 0x93, 0x89, 0xDB, 0x97, 0x8C, 0xD6, 0x8F,
	0x87, 0xD8, 0x93, 0x88, 0xD8, 0x93, 0x87, 0xD7, 0x8F, 0x85, 0xD7, 0x92, 0x87, 0xD6, 0x91, 0x87,
	0xD6, 0x8E, 0x84, 0xD4, 0x90, 0x85, 0xD1, 0x8E, 0x86, 0xCF, 0x8B, 0x82, 0xD1, 0x92, 0x8B, 0xD5,
	0x99, 0x90, 0xD7, 0x9A, 0x91, 0xD6, 0xA3, 0x99, 0xD7, 0xAC, 0xA1, 0xD4, 0xA3, 0x9B, 0xD3, 0x9F,
	0x98, 0xD3, 0x9B, 0x95, 0xD4, 0x9B, 0x95, 0xD6, 0xA8, 0xA0, 0xCF, 0x9B, 0x95, 0xC9, 0x89, 0x83,
	0xCD, 0x97, 0x90, 0xD4, 0xA6, 0x99, 0xDD, 0xAF, 0x9B, 0xDC, 0xAF, 0x9F, 0xDA, 0xB5, 0xAB, 0xDF,
	0xC0, 0xB4, 0xE2, 0xC1, 0xB0, 0xDF, 0xBC, 0xAC, 0xDA, 0xB5, 0xA8, 0xD9, 0xB5, 0xA8, 0xDB, 0xBA,
	0xAF, 0xDD, 0xBC, 0xB2, 0xDD, 0xBD, 0xB3, 0xDE, 0xBE, 0xB4, 0xE0, 0xC0, 0xB5, 0xE2, 0xC6, 0xB9,
	0xE3, 0xC8, 0xB7, 0xD4, 0x9D, 0x90, 0xCD, 0x88, 0x80, 0xD0, 0x93, 0x8A, 0xC9, 0x82, 0x7E, 0xDE,
	0xAD, 0x9F, 0xDD, 0xB7, 0xA5, 0x68, 0x26, 0x49, 0x49, 0x06, 0x37, 0x5D, 0x19, 0x42, 0x5F, 0x15,
	0x3D, 0x59, 0x10, 0x39, 0x5A, 0x0E, 0x36, 0x5C, 0x0D, 0x36, 0x59, 0x10, 0x3E, 0x6F, 0x25, 0x52,
	0xA9, 0x5A, 0x6B, 0xD8, 0x7E, 0x79, 0xCE, 0x77, 0x76, 0xCA, 0x7F, 0x7B, 0xD2, 0x8A, 0x7E, 0xD3,
	0x89, 0x7D, 0xD3, 0x87, 0x7C, 0xD3, 0x88, 0x7B, 0xD1, 0x89, 0x7C, 0xD1, 0x87, 0x79, 0xD0, 0x87,
	0x7A, 0xCF, 0x86, 0x79, 0xD0, 0x86, 0x78, 0xD1, 0x87, 0x79, 0xD0, 0x85, 0x76, 0xD1, 0x84, 0x78,
	0xA6, 0x3B, 0x47, 0xA3, 0x3A, 0x47, 0xA1, 0x3A, 0x47, 0xA4, 0x3A, 0x46, 0xA5, 0x39, 0x45, 0xA7,
	0x38, 0x46, 0xB8, 0x45, 0x4D, 0xD5, 0x66, 0x5C, 0xE3, 0x7F, 0x66, 0xE8, 0x8C, 0x6D, 0xE8, 0x93,
	0x72, 0xE7, 0x92, 0x71, 0xE9, 0x91, 0x70, 0xE8, 0x8B, 0x6B, 0xDF, 0x71, 0x5E, 0xBD, 0x4A, 0x4E,
	0x93, 0x2C, 0x41, 0x90, 0x29, 0x3F, 0x9F, 0x35, 0x45, 0xA6, 0x3C, 0x49, 0xA9, 0x3E, 0x4B, 0xAC,
	0x3D, 0x47, 0xAB, 0x3B, 0x46, 0xAA, 0x3B, 0x47, 0xAA, 0x3C, 0x47, 0xAC, 0x3D, 0x47, 0xB0, 0x3F,
	0x47, 0xAF, 0x3E, 0x46, 0x9F, 0x2D, 0x3F, 0xB5, 0x5C, 0x5E, 0xEE, 0xB5, 0x85, 0xE9, 0x99, 0x72,
	0xE2, 0x82, 0x69, 0xDC, 0x75, 0x61, 0xD8, 0x69, 0x5D, 0xD1, 0x5F, 0x58, 0xB7, 0x44, 0x4C, 0xAB,
	0x3E, 0x4B, 0xB3, 0x40, 0x4A, 0xB3, 0x43, 0x4E, 0xC3, 0x5F, 0x64, 0xD5, 0x6F, 0x6C, 0xCF, 0x65,
	0x65, 0xCD, 0x69, 0x67, 0xBF, 0x61, 0x65, 0xB8, 0x5A, 0x64, 0xCC, 0x69, 0x6B, 0xD6, 0x72, 0x6E,
	0xD3, 0x74, 0x70, 0xCC, 0x6E, 0x6D, 0xC8, 0x70, 0x6E, 0xCB, 0x79, 0x75, 0xD2, 0x7E, 0x7B, 0xD0,
	0x75, 0x74, 0xD1, 0x76, 0x74, 0xD7, 0x88, 0x80, 0xD5, 0x87, 0x7F, 0xD8, 0x86, 0x80, 0xDB, 0x91,
	0x87, 0xD7, 0x90, 0x85, 0xD9, 0x8D, 0x83, 0xD7, 0x8B, 0x81, 0xD7, 0x8B, 0x82, 0xD8, 0x8E, 0x84,
	0xD3, 0x87, 0x7E, 0xCE, 0x8B, 0x82, 0xCD, 0x8C, 0x85, 0xD0, 0x8D, 0x85, 0xD3, 0x92, 0x8A, 0xD7,
	0x99, 0x90, 0xD7, 0x96, 0x8D, 0xD4, 0x92, 0x8C, 0xD6, 0x9D, 0x94, 0xD4, 0x9A, 0x93, 0xD3, 0x97,
	0x91, 0xD3, 0x9B, 0x94, 0xCF, 0x92, 0x8D, 0xCC, 0x8F, 0x8B, 0xCA, 0x92, 0x8E, 0xD0, 0x9C, 0x90,
	0xDB, 0xA6, 0x91, 0xDA, 0xA7, 0x97, 0xDA, 0xAF, 0xA1, 0xDF, 0xBD, 0xAD, 0xE3, 0xC5, 0xB4, 0xE0,
	0xBE, 0xAE, 0xDB, 0xB5, 0xA7, 0xD9, 0xB3, 0xA6, 0xD9, 0xB4, 0xA7, 0xDA, 0xB6, 0xAB, 0xDC, 0xBB,
	0xB1, 0xDE, 0xBE, 0xB4, 0xDF, 0xBF, 0xB5, 0xDF, 0xBF, 0xB5, 0xE0, 0xC3, 0xB7, 0xE5, 0xCE, 0xBE,
	0xDC, 0xB3, 0xA4, 0xCD, 0x88, 0x82, 0xD1, 0x95, 0x8C, 0xC7, 0x81, 0x7C, 0xC7, 0x7C, 0x7D, 0xE8,
	0xBB, 0xA7, 0xB8, 0x8C, 0x89, 0x49, 0x04, 0x34, 0x51, 0x09, 0x36, 0x5D, 0x17, 0x40, 0x5C, 0x15,
	0x3E, 0x56, 0x0C, 0x35, 0x5E, 0x11, 0x38, 0x5B, 0x0F, 0x39, 0x60, 0x17, 0x47, 0x92, 0x47, 0x65,
	0xCE, 0x7C, 0x7A, 0xD4, 0x7A, 0x77, 0xC9, 0x78, 0x77, 0xCF, 0x86, 0x7D, 0xD3, 0x8A, 0x7E, 0xD2,
	0x89, 0x7D, 0xD2, 0x86, 0x7B, 0xD1, 0x86, 0x7B, 0xD1, 0x88, 0x7B, 0xD1, 0x89, 0x7B, 0xD0, 0x87,
	0x7A, 0xCF, 0x85, 0x78, 0xD0, 0x85, 0x78, 0xD1, 0x87, 0x79, 0xCF, 0x84, 0x77, 0xD0, 0x85, 0x79,
	0xA5, 0x3B, 0x49, 0xA5, 0x3B, 0x48, 0xA5, 0x3A, 0x45, 0xA5, 0x3A, 0x46, 0xA4, 0x37, 0x45, 0xA9,
	0x39, 0x46, 0xBD, 0x48, 0x4D, 0xD7, 0x66, 0x59, 0xE2, 0x80, 0x66, 0xE8, 0x8D, 0x6E, 0xE8, 0x93,
	0x70, 0xE8, 0x93, 0x71, 0xE9, 0x92, 0x70, 0xE8, 0x8C, 0x6D, 0xE0, 0x73, 0x62, 0xBE, 0x4D, 0x52,
	0x92, 0x2C, 0x43, 0x91, 0x2B, 0x40, 0x9F, 0x36, 0x45, 0xA7, 0x3B, 0x47, 0xAA, 0x3D, 0x49, 0xAA,
	0x3B, 0x48, 0xAC, 0x3A, 0x46, 0xAB, 0x3A, 0x45, 0xAA, 0x3C, 0x47, 0xAC, 0x3D, 0x47, 0xAE, 0x3D,
	0x46, 0xAC, 0x3D, 0x47, 0x9C, 0x29, 0x3E, 0xBF, 0x67, 0x61, 0xF2, 0xBC, 0x86, 0xEB, 0xA3, 0x75,
	0xE3, 0x8A, 0x6C, 0xDC, 0x77, 0x64, 0xD8, 0x6C, 0x5D, 0xD4, 0x62, 0x58, 0xC5, 0x4F, 0x52, 0xB3,
	0x43, 0x4C, 0xB0, 0x41, 0x4C, 0xC3, 0x5A, 0x5F, 0xD4, 0x6D, 0x6C, 0xD0, 0x69, 0x68, 0xC8, 0x67,
	0x69, 0xBB, 0x5A, 0x62, 0xBA, 0x56, 0x61, 0xCE, 0x6B, 0x6C, 0xD6, 0x76, 0x70, 0xD1, 0x71, 0x6E,
	0xCC, 0x69, 0x69, 0xC5, 0x66, 0x68, 0xCA, 0x6E, 0x6F, 0xD0, 0x79, 0x76, 0xCF, 0x70, 0x70, 0xD1,
	0x76, 0x75, 0xD9, 0x86, 0x80, 0xDB, 0x83, 0x7D, 0xD7, 0x84, 0x7E, 0xD7, 0x8B, 0x84, 0xD1, 0x8D,
	0x86, 0xC2, 0x84, 0x86, 0xC6, 0x7F, 0x84, 0xD4, 0x86, 0x7F, 0xD8, 0x8C, 0x7F, 0xD1, 0x84, 0x7E,
	0xCC, 0x82, 0x7D, 0xD2, 0x8C, 0x82, 0xD7, 0x90, 0x85, 0xD6, 0x8F, 0x86, 0xD4, 0x8E, 0x86, 0xD5,
	0x8E, 0x86, 0xD5, 0x92, 0x8B, 0xD7, 0x94, 0x8B, 0xD3, 0x8C, 0x84, 0xD2, 0x8C, 0x86, 0xD3, 0x92,
	0x8C, 0xCE, 0x8D, 0x88, 0xC7, 0x87, 0x86, 0xCC, 0x92, 0x8A, 0xD8, 0xA3, 0x93, 0xDB, 0xA7, 0x92,
	0xDD, 0xA9, 0x93, 0xDD, 0xB5, 0xA3, 0xE0, 0xBD, 0xA8, 0xE0, 0xB7, 0xA3, 0xDB, 0xB2, 0xA1, 0xD8,
	0xB2, 0xA5, 0xD8, 0xB3, 0xA8, 0xDB, 0xB7, 0xA9, 0xDB, 0xB9, 0xAB, 0xDE, 0xBD, 0xB1, 0xE0, 0xC1,
	0xB5, 0xE0, 0xC0, 0xB5, 0xDF, 0xBF, 0xB6, 0xE1, 0xC2, 0xB6, 0xE3, 0xCB, 0xBB, 0xE2, 0xC8, 0xB7,
	0xCF, 0x96, 0x8C, 0xCF, 0x8E, 0x87, 0xD0, 0x8E, 0x85, 0xC9, 0x7C, 0x78, 0xCD, 0x86, 0x83, 0xE9,
	0xC2, 0xAC, 0x8C, 0x59, 0x6A, 0x42, 0x00, 0x31, 0x58, 0x12, 0x3D, 0x5C, 0x13, 0x3D, 0x58, 0x15,
	0x40, 0x59, 0x16, 0x40, 0x60, 0x15, 0x3D, 0x58, 0x11, 0x3E, 0x6E, 0x27, 0x52, 0xB6, 0x68, 0x72,
	0xD7, 0x82, 0x7C, 0xCB, 0x76, 0x75, 0xCC, 0x7F, 0x7A, 0xD1, 0x89, 0x7D, 0xD2, 0x89, 0x7B, 0xD0,
	0x87, 0x7C, 0xD0, 0x83, 0x78, 0xD0, 0x84, 0x77, 0xD1, 0x86, 0x7B, 0xD0, 0x87, 0x7B, 0xCF, 0x86,
	0x79, 0xCE, 0x86, 0x77, 0xCE, 0x86, 0x77, 0xCF, 0x85, 0x78, 0xCE, 0x85, 0x78, 0xD0, 0x86, 0x77,
	0xA7, 0x3B, 0x48, 0xA8, 0x3C, 0x48, 0xA7, 0x3B, 0x47, 0xA4, 0x3A, 0x46, 0xA8, 0x3A, 0x46, 0xB0,
	0x3E, 0x48, 0xC3, 0x4A, 0x4D, 0xD8, 0x64, 0x59, 0xE1, 0x7F, 0x66, 0xE8, 0x8E, 0x6D, 0xE9, 0x93,
	0x6F, 0xE8, 0x93, 0x71, 0xE9, 0x92, 0x6F, 0xE9, 0x8B, 0x6C, 0xE1, 0x75, 0x63, 0xBE, 0x4E, 0x52,
	0x94, 0x29, 0x40, 0x8E, 0x25, 0x3D, 0x9B, 0x34, 0x44, 0xA4, 0x3B, 0x48, 0xA9, 0x3C, 0x49, 0xA9,
	0x39, 0x47, 0xA8, 0x38, 0x45, 0xAB, 0x3C, 0x46, 0xAA, 0x3C, 0x46, 0xAB, 0x3B, 0x46, 0xAD, 0x3C,
	0x46, 0xAC, 0x3B, 0x46, 0x99, 0x25, 0x3C, 0xC0, 0x6E, 0x66, 0xF5, 0xC7, 0x8F, 0xEC, 0xAD, 0x7E,
	0xE6, 0x95, 0x73, 0xE2, 0x84, 0x6A, 0xDC, 0x75, 0x62, 0xDC, 0x72, 0x60, 0xCF, 0x5B, 0x55, 0xB0,
	0x3B, 0x47, 0xBC, 0x50, 0x57, 0xD2, 0x68, 0x68, 0xCA, 0x61, 0x66, 0xC8, 0x67, 0x69, 0xBC, 0x5D,
	0x63, 0xB9, 0x57, 0x62, 0xCE, 0x69, 0x6A, 0xD6, 0x6E, 0x6B, 0xD4, 0x70, 0x6C, 0xCA, 0x6A, 0x6A,
	0xC0, 0x60, 0x68, 0xC4, 0x64, 0x6B, 0xD1, 0x78, 0x76, 0xCB, 0x6F, 0x6F, 0xCE, 0x6E, 0x6F, 0xDA,
	0x85, 0x7D, 0xD2, 0x7C, 0x7B, 0xC1, 0x6F, 0x76, 0xB9, 0x70, 0x7A, 0xBA, 0x7A, 0x81, 0xC1, 0x85,
	0x87, 0xB4, 0x78, 0x85, 0xB1, 0x70, 0x7C, 0xA6, 0x5E, 0x6E, 0xB1, 0x61, 0x6A, 0xD8, 0x8A, 0x7F,
	0xDD, 0x90, 0x82, 0xD9, 0x8E, 0x80, 0xCF, 0x89, 0x82, 0xD3, 0x88, 0x83, 0xDA, 0x8E, 0x86, 0xDC,
	0x8D, 0x85, 0xD8, 0x89, 0x82, 0xD0, 0x8A, 0x86, 0xD7, 0x8F, 0x88, 0xD0, 0x89, 0x83, 0xC6, 0x7E,
	0x7D, 0xC8, 0x86, 0x84, 0xD5, 0x9E, 0x90, 0xDC, 0xA5, 0x92, 0xD9, 0xA4, 0x94, 0xDB, 0xAE, 0x9F,
	0xE3, 0xBE, 0xA8, 0xE0, 0xBC, 0xA7, 0xDA, 0xB0, 0xA0, 0xD7, 0xAB, 0x9E, 0xD6, 0xAE, 0xA3, 0xDA,
	0xB5, 0xAA, 0xDB, 0xB8, 0xAC, 0xDC, 0xBA, 0xAE, 0xDE, 0xBD, 0xB2, 0xE0, 0xC0, 0xB5, 0xE1, 0xC2,
	0xB6, 0xE1, 0xC1, 0xB6, 0xE0, 0xC1, 0xB5, 0xE2, 0xC7, 0xB9, 0xE5, 0xD2, 0xC0, 0xD9, 0xB2, 0xA5,
	0xCD, 0x8D, 0x85, 0xC7, 0x7D, 0x75, 0xB3, 0x5D, 0x60, 0xAC, 0x50, 0x5C, 0xD4, 0x99, 0x92, 0xDD,
	0xBD, 0xAA, 0x5E, 0x1E, 0x44, 0x46, 0x02, 0x33, 0x5B, 0x15, 0x3F, 0x5C, 0x15, 0x40, 0x58, 0x15,
	0x40, 0x61, 0x1D, 0x45, 0x60, 0x17, 0x41, 0x59, 0x12, 0x42, 0x8D, 0x41, 0x5F, 0xD2, 0x7C, 0x79,
	0xD2, 0x7A, 0x76, 0xCA, 0x78, 0x75, 0xD1, 0x86, 0x7B, 0xD3, 0x89, 0x7C, 0xD3, 0x86, 0x79, 0xD0,
	0x85, 0x78, 0xD0, 0x83, 0x77, 0xCF, 0x83, 0x76, 0xD1, 0x84, 0x78, 0xD1, 0x86, 0x78, 0xCF, 0x85,
	0x77, 0xCE, 0x85, 0x75, 0xCD, 0x86, 0x76, 0xCD, 0x85, 0x79, 0xCE, 0x84, 0x78, 0xCC, 0x83, 0x77,
	0xA8, 0x3D, 0x49, 0xA7, 0x3C, 0x48, 0xA5, 0x3D, 0x4A, 0xA7, 0x3D, 0x49, 0xAC, 0x3D, 0x48, 0xB3,
	0x3F, 0x48, 0xC3, 0x49, 0x4E, 0xD7, 0x65, 0x59, 0xE2, 0x7E, 0x65, 0xE8, 0x8E, 0x6F, 0xE9, 0x93,
	0x6F, 0xE9, 0x93, 0x6F, 0xEA, 0x92, 0x6F, 0xE9, 0x8E, 0x6D, 0xE1, 0x76, 0x62, 0xBF, 0x4C, 0x4D,
	0x92, 0x28, 0x3E, 0x8C, 0x24, 0x3D, 0x9A, 0x33, 0x44, 0xA5, 0x3B, 0x49, 0xA9, 0x3C, 0x49, 0xA8,
	0x3A, 0x47, 0xA8, 0x39, 0x46, 0xAB, 0x3C, 0x47, 0xAC, 0x3B, 0x46, 0xAE, 0x3C, 0x46, 0xAF, 0x3D,
	0x46, 0xAB, 0x38, 0x45, 0x95, 0x23, 0x3A, 0xBD, 0x6B, 0x66, 0xF5, 0xCB, 0x96, 0xED, 0xB4, 0x84,
	0xE7, 0x97, 0x74, 0xE3, 0x85, 0x67, 0xDF, 0x7C, 0x66, 0xE1, 0x7B, 0x65, 0xD6, 0x66, 0x5A, 0xBE,
	0x4C, 0x53, 0xC5, 0x56, 0x5B, 0xCA, 0x5D, 0x61, 0xC7, 0x64, 0x68, 0xB8, 0x5A, 0x62, 0xB7, 0x54,
	0x5D, 0xCD, 0x69, 0x69, 0xD5, 0x6F, 0x6A, 0xD1, 0x68, 0x68, 0xC8, 0x62, 0x65, 0xBE, 0x5B, 0x61,
	0xC4, 0x66, 0x6B, 0xCC, 0x71, 0x72, 0xC8, 0x69, 0x6B, 0xCD, 0x70, 0x71, 0xD9, 0x7F, 0x7B, 0xC7,
	0x6D, 0x71, 0xA9, 0x5C, 0x6E, 0xB2, 0x68, 0x75, 0xAC, 0x5B, 0x6B, 0x9A, 0x4C, 0x65, 0x9B, 0x4B,
	0x65, 0xA2, 0x54, 0x6A, 0xC9, 0x83, 0x83, 0xC9, 0x82, 0x81, 0xA1, 0x60, 0x76, 0xAD, 0x6D, 0x81,
	0xBC, 0x76, 0x82, 0xC4, 0x79, 0x7B, 0xC6, 0x82, 0x81, 0xC2, 0x82, 0x88, 0xC0, 0x79, 0x80, 0xC5,
	0x7E, 0x81, 0xB3, 0x72, 0x80, 0x92, 0x4E, 0x6D, 0xA3, 0x5F, 0x70, 0xC6, 0x82, 0x81, 0xCB, 0x89,
	0x84, 0xD9, 0x9C, 0x8B, 0xD9, 0x9D, 0x89, 0xD9, 0xA5, 0x95, 0xDF, 0xB9, 0xAA, 0xE1, 0xBD, 0xAA,
	0xDE, 0xB8, 0xA5, 0xDA, 0xB3, 0xA4, 0xD9, 0xB2, 0xA5, 0xD8, 0xB4, 0xA8, 0xDA, 0xB8, 0xAD, 0xDC,
	0xBC, 0xB1, 0xDD, 0xBD, 0xB2, 0xDE, 0xBE, 0xB4, 0xE0, 0xC0, 0xB4, 0xE1, 0xC2, 0xB6, 0xE1, 0xC1,
	0xB5, 0xE2, 0xC1, 0xB6, 0xE3, 0xC7, 0xBB, 0xE7, 0xD5, 0xC3, 0xE6, 0xC7, 0xB4, 0xD1, 0x90, 0x87,
	0xB4, 0x61, 0x63, 0x98, 0x3B, 0x47, 0x93, 0x2C, 0x43, 0xB4, 0x68, 0x73, 0xF2, 0xD6, 0xBC, 0xAF,
	0x80, 0x7E, 0x42, 0x00, 0x2D, 0x51, 0x0A, 0x36, 0x5D, 0x13, 0x3A, 0x58, 0x0F, 0x39, 0x5A, 0x11,
	0x3A, 0x63, 0x17, 0x3D, 0x59, 0x13, 0x40, 0x67, 0x20, 0x4F, 0xB3, 0x63, 0x70, 0xD7, 0x7F, 0x78,
	0xCC, 0x76, 0x76, 0xCD, 0x80, 0x7A, 0xD2, 0x89, 0x7C, 0xD2, 0x87, 0x7B, 0xD2, 0x87, 0x79, 0xD3,
	0x86, 0x77, 0xCF, 0x85, 0x78, 0xCE, 0x85, 0x7A, 0xCF, 0x85, 0x78, 0xCE, 0x85, 0x78, 0xCD, 0x84,
	0x77, 0xCD, 0x84, 0x76, 0xCC, 0x84, 0x78, 0xCB, 0x84, 0x79, 0xCB, 0x81, 0x77, 0xCA, 0x81, 0x75,
	0xAA, 0x3E, 0x4A, 0xA9, 0x3E, 0x4A, 0xA4, 0x3F, 0x4C, 0xA8, 0x3E, 0x4C, 0xAD, 0x3F, 0x4A, 0xB4,
	0x3F, 0x48, 0xC8, 0x4C, 0x4E, 0xDA, 0x67, 0x59, 0xE3, 0x7F, 0x65, 0xE9, 0x8F, 0x6F, 0xE9, 0x95,
	0x70, 0xE9, 0x96, 0x71, 0xEA, 0x94, 0x71, 0xE9, 0x8D, 0x6D, 0xE1, 0x77, 0x61, 0xC0, 0x4C, 0x4E,
	0x91, 0x29, 0x3F, 0x8B, 0x24, 0x3D, 0x99, 0x31, 0x41, 0xA4, 0x39, 0x46, 0xA6, 0x3A, 0x47, 0xAA,
	0x3D, 0x49, 0xAE, 0x3D, 0x49, 0xAE, 0x3C, 0x48, 0xAF, 0x3C, 0x47, 0xAF, 0x3C, 0x47, 0xB1, 0x3E,
	0x46, 0xAB, 0x38, 0x44, 0x97, 0x22, 0x3A, 0xBC, 0x67, 0x65, 0xF5, 0xCB, 0x98, 0xEF, 0xB7, 0x84,
	0xEC, 0xA7, 0x79, 0xE4, 0x89, 0x69, 0xD9, 0x6C, 0x5D, 0xDE, 0x74, 0x61, 0xD7, 0x69, 0x5C, 0xBE,
	0x4C, 0x53, 0xBF, 0x51, 0x58, 0xC3, 0x58, 0x5D, 0xB8, 0x55, 0x5D, 0xB0, 0x4F, 0x5E, 0xC9, 0x64,
	0x68, 0xD6, 0x6C, 0x67, 0xD1, 0x69, 0x67, 0xC2, 0x5F, 0x66, 0xBB, 0x57, 0x60, 0xC5, 0x60, 0x64,
	0xC7, 0x68, 0x6B, 0xC5, 0x66, 0x6A, 0xCB, 0x69, 0x6C, 0xD4, 0x75, 0x73, 0xCA, 0x70, 0x74, 0xB3,
	0x64, 0x70, 0xBA, 0x6C, 0x74, 0xB2, 0x5F, 0x6C, 0xA4, 0x50, 0x65, 0x93, 0x41, 0x5C, 0x77, 0x29,
	0x54, 0x76, 0x3E, 0x6E, 0xC0, 0x8D, 0x95, 0xD2, 0x96, 0x95, 0xA2, 0x75, 0x94, 0x86, 0x59, 0x86,
	0x7C, 0x48, 0x7B, 0x80, 0x46, 0x73, 0x92, 0x53, 0x73, 0x8A, 0x4D, 0x6C, 0x7E, 0x3B, 0x60, 0x71,
	0x2B, 0x54, 0x64, 0x26, 0x52, 0x50, 0x12, 0x46, 0x5B, 0x20, 0x4E, 0xC6, 0x8F, 0x8C, 0xDC, 0x9C,
	0x8C, 0xD5, 0x94, 0x87, 0xD7, 0xA6, 0x9A, 0xDE, 0xB9, 0xA8, 0xE0, 0xBC, 0xA8, 0xDC, 0xB6, 0xA6,
	0xDB, 0xB7, 0xA6, 0xDB, 0xB8, 0xA8, 0xD9, 0xB5, 0xA7, 0xD8, 0xB4, 0xA9, 0xDB, 0xB9, 0xAD, 0xDD,
	0xBD, 0xB2, 0xDE, 0xBD, 0xB3, 0xDE, 0xBD, 0xB0, 0xE0, 0xBF, 0xB1, 0xE2, 0xC4, 0xB7, 0xE4, 0xCA,
	0xBC, 0xE8, 0xCE, 0xC0, 0xE6, 0xC8, 0xB7, 0xDA, 0xAD, 0x9B, 0xC2, 0x76, 0x70, 0xA5, 0x45, 0x4C,
	0x8E, 0x2B, 0x3C, 0x8F, 0x2B, 0x42, 0xB0, 0x59, 0x67, 0xEB, 0xC1, 0xAD, 0xE0, 0xC1, 0xAA, 0x63,
	0x20, 0x42, 0x46, 0x02, 0x31, 0x5B, 0x12, 0x3B, 0x59, 0x11, 0x39, 0x58, 0x0D, 0x35, 0x5F, 0x11,
	0x38, 0x5E, 0x14, 0x3C, 0x53, 0x0D, 0x3F, 0x89, 0x3F, 0x5F, 0xCC, 0x7C, 0x7A, 0xCC, 0x79, 0x76,
	0xC9, 0x7A, 0x78, 0xD1, 0x88, 0x7E, 0xD2, 0x8A, 0x7E, 0xD2, 0x88, 0x7C, 0xD2, 0x89, 0x7A, 0xD2,
	0x87, 0x7A, 0xCF, 0x84, 0x79, 0xCD, 0x85, 0x7A, 0xCE, 0x84, 0x7A, 0xCD, 0x83, 0x78, 0xCC, 0x84,
	0x77, 0xCA, 0x84, 0x77, 0xCA, 0x83, 0x78, 0xCA, 0x82, 0x77, 0xCA, 0x82, 0x77, 0xCC, 0x80, 0x73,
	0xAA, 0x3E, 0x4B, 0xAB, 0x41, 0x4D, 0xA9, 0x40, 0x4A, 0xA6, 0x3D, 0x49, 0xAE, 0x3F, 0x4A, 0xBC,
	0x43, 0x4B, 0xCB, 0x4E, 0x4E, 0xDA, 0x68, 0x59, 0xE3, 0x81, 0x66, 0xEA, 0x92, 0x6E, 0xEA, 0x94,
	0x6F, 0xE9, 0x94, 0x71, 0xE9, 0x96, 0x70, 0xE9, 0x8E, 0x6C, 0xE2, 0x77, 0x63, 0xC1, 0x4E, 0x50,
	0x90, 0x29, 0x3F, 0x8B, 0x26, 0x3D, 0x98, 0x32, 0x43, 0xA1, 0x3A, 0x48, 0xA5, 0x3C, 0x48, 0xAA,
	0x3C, 0x48, 0xAD, 0x3C, 0x48, 0xAE, 0x3D, 0x48, 0xAE, 0x3C, 0x47, 0xAE, 0x3C, 0x47, 0xB0, 0x3D,
	0x46, 0xAD, 0x3B, 0x45, 0x9D, 0x27, 0x3C, 0xB3, 0x53, 0x57, 0xF1, 0xC1, 0x90, 0xF1, 0xBD, 0x88,
	0xED, 0xB5, 0x85, 0xE6, 0x8F, 0x6B, 0xD0, 0x58, 0x51, 0xCE, 0x5D, 0x55, 0xC7, 0x5D, 0x5A, 0xB4,
	0x47, 0x54, 0xBE, 0x53, 0x5A, 0xB9, 0x52, 0x58, 0xAB, 0x47, 0x58, 0xC5, 0x5E, 0x66, 0xD2, 0x6A,
	0x69, 0xCE, 0x66, 0x65, 0xC4, 0x61, 0x62, 0xBF, 0x59, 0x62, 0xC5, 0x62, 0x67, 0xC7, 0x66, 0x6B,
	0xC2, 0x60, 0x65, 0xC6, 0x63, 0x68, 0xD7, 0x73, 0x71, 0xC8, 0x68, 0x6D, 0xAB, 0x59, 0x6A, 0xBE,
	0x6D, 0x73, 0xB7, 0x66, 0x70, 0xA5, 0x54, 0x68, 0xA2, 0x52, 0x67, 0x9E, 0x58, 0x6D, 0x85, 0x44,
	0x69, 0x76, 0x3E, 0x70, 0x8E, 0x5A, 0x7F, 0x95, 0x69, 0x8E, 0x82, 0x50, 0x7F, 0x6C, 0x2E, 0x5D,
	0x6C, 0x31, 0x63, 0x76, 0x41, 0x75, 0x67, 0x2F, 0x63, 0x61, 0x24, 0x56, 0x56, 0x14, 0x43, 0x48,
	0x05, 0x37, 0x3E, 0x00, 0x34, 0x58, 0x22, 0x4F, 0xA0, 0x6A, 0x78, 0xCD, 0x8C, 0x86, 0xD3, 0x9B,
	0x93, 0xDD, 0xB8, 0xAA, 0xE1, 0xC1, 0xAD, 0xDD, 0xBB, 0xA8, 0xDA, 0xB5, 0xA5, 0xDB, 0xB5, 0xA6,
	0xDC, 0xBA, 0xA7, 0xDB, 0xB8, 0xA7, 0xD9, 0xB4, 0xA6, 0xDA, 0xB6, 0xAA, 0xDC, 0xB9, 0xAC, 0xDC,
	0xBB, 0xB0, 0xDE, 0xBD, 0xB1, 0xDE, 0xBB, 0xAD, 0xE2, 0xC3, 0xB4, 0xE7, 0xCD, 0xBD, 0xE1, 0xBF,
	0xAF, 0xCC, 0x95, 0x8C, 0xB4, 0x65, 0x65, 0x9D, 0x40, 0x4A, 0x91, 0x2F, 0x42, 0x90, 0x2B, 0x3D,
	0x9B, 0x38, 0x4B, 0xB6, 0x5F, 0x6B, 0xE3, 0xAC, 0x9A, 0xED, 0xC6, 0xA7, 0x8C, 0x50, 0x61, 0x45,
	0x00, 0x31, 0x58, 0x0F, 0x3A, 0x5F, 0x13, 0x3D, 0x58, 0x13, 0x3C, 0x5A, 0x12, 0x3A, 0x64, 0x16,
	0x3B, 0x50, 0x0B, 0x39, 0x58, 0x13, 0x44, 0xB0, 0x60, 0x6D, 0xD0, 0x80, 0x7B, 0xC7, 0x76, 0x75,
	0xCE, 0x83, 0x7C, 0xD3, 0x8B, 0x81, 0xD2, 0x89, 0x7D, 0xD2, 0x89, 0x7D, 0xD2, 0x89, 0x7D, 0xD1,
	0x87, 0x7B, 0xD1, 0x86, 0x7B, 0xCE, 0x86, 0x7D, 0xCC, 0x83, 0x7B, 0xCC, 0x82, 0x79, 0xCB, 0x84,
	0x7A, 0xCA, 0x84, 0x78, 0xCB, 0x84, 0x78, 0xCB, 0x82, 0x77, 0xCA, 0x81, 0x76, 0xCD, 0x81, 0x74,
	0xAB, 0x40, 0x4D, 0xAD, 0x42, 0x4D, 0xAC, 0x40, 0x4A, 0xA7, 0x39, 0x45, 0xAE, 0x3E, 0x49, 0xBC,
	0x43, 0x4B, 0xCC, 0x4D, 0x4E, 0xDA, 0x67, 0x5A, 0xE3, 0x81, 0x67, 0xE9, 0x92, 0x70, 0xE9, 0x93,
	0x6F, 0xE9, 0x93, 0x6E, 0xE9, 0x95, 0x71, 0xE9, 0x8F, 0x6E, 0xE3, 0x77, 0x63, 0xC0, 0x4D, 0x4F,
	0x91, 0x28, 0x3E, 0x8B, 0x27, 0x3E, 0x9C, 0x34, 0x43, 0xA4, 0x3A, 0x48, 0xA8, 0x3B, 0x47, 0xAB,
	0x3C, 0x47, 0xAB, 0x3B, 0x47, 0xAE, 0x3E, 0x49, 0xAE, 0x3C, 0x48, 0xB0, 0x3D, 0x47, 0xAF, 0x3B,
	0x45, 0xAB, 0x39, 0x45, 0x9F, 0x2C, 0x3F, 0xA6, 0x3C, 0x4A, 0xE8, 0xB4, 0x8C, 0xF4, 0xC8, 0x8F,
	0xEF, 0xBB, 0x88, 0xE6, 0x92, 0x6F, 0xCD, 0x53, 0x50, 0xCA, 0x5E, 0x5D, 0xCC, 0x68, 0x65, 0xC3,
	0x58, 0x5D, 0xB5, 0x4D, 0x57, 0xAC, 0x46, 0x55, 0xBF, 0x57, 0x60, 0xD3, 0x6A, 0x6A, 0xD0, 0x6A,
	0x6A, 0xC0, 0x5E, 0x64, 0xBC, 0x55, 0x5D, 0xC7, 0x5E, 0x63, 0xC9, 0x67, 0x6C, 0xC2, 0x60, 0x67,
	0xC5, 0x5F, 0x64, 0xD3, 0x6B, 0x6D, 0xCB, 0x65, 0x6A, 0xAE, 0x5A, 0x6A, 0xBA, 0x66, 0x70, 0xC0,
	0x66, 0x6E, 0x9E, 0x5C, 0x74, 0x9E, 0x5C, 0x76, 0x8F, 0x4A, 0x6B, 0x7E, 0x3B, 0x5E, 0x6B, 0x28,
	0x55, 0x68, 0x1F, 0x4F, 0x75, 0x3A, 0x6E, 0x87, 0x58, 0x89, 0x7C, 0x44, 0x76, 0x79, 0x40, 0x6F,
	0x83, 0x4E, 0x7B, 0x73, 0x39, 0x67, 0x64, 0x27, 0x57, 0x6A, 0x31, 0x61, 0x4D, 0x10, 0x40, 0x38,
	0x00, 0x30, 0x5D, 0x28, 0x52, 0xB7, 0x7B, 0x7F, 0xD2, 0x85, 0x7D, 0xCF, 0x97, 0x8E, 0xDE, 0xB3,
	0xA1, 0xE1, 0xB9, 0xA6, 0xDD, 0xBA, 0xA9, 0xDB, 0xB6, 0xA7, 0xDA, 0xB3, 0xA3, 0xDA, 0xB2, 0xA3,
	0xDA, 0xB6, 0xA7, 0xDB, 0xB6, 0xA7, 0xDA, 0xB4, 0xA6, 0xD9, 0xB5, 0xA9, 0xDB, 0xB8, 0xAC, 0xDB,
	0xB9, 0xAE, 0xDF, 0xC0, 0xB5, 0xE5, 0xC8, 0xB8, 0xE7, 0xCA, 0xB6, 0xD2, 0xA1, 0x96, 0xA8, 0x55,
	0x5B, 0x92, 0x30, 0x41, 0x8B, 0x25, 0x3A, 0x8F, 0x2B, 0x41, 0x9E, 0x40, 0x53, 0xAD, 0x52, 0x60,
	0xC6, 0x77, 0x7A, 0xEF, 0xBC, 0xA3, 0xDE, 0xAF, 0x94, 0x7B, 0x35, 0x4A, 0x4C, 0x00, 0x2F, 0x56,
	0x0C, 0x39, 0x60, 0x14, 0x3E, 0x5E, 0x10, 0x39, 0x59, 0x11, 0x3B, 0x5F, 0x15, 0x3B, 0x63, 0x19,
	0x3E, 0x4B, 0x0B, 0x3D, 0x77, 0x30, 0x56, 0xC8, 0x77, 0x77, 0xCC, 0x7A, 0x77, 0xC9, 0x7C, 0x79,
	0xD2, 0x8A, 0x81, 0xD2, 0x8B, 0x7F, 0xD2, 0x89, 0x7C, 0xD2, 0x89, 0x7F, 0xD2, 0x8A, 0x7F, 0xD0,
	0x88, 0x7C, 0xCF, 0x87, 0x7D, 0xCF, 0x87, 0x7F, 0xCC, 0x86, 0x7E, 0xCB, 0x85, 0x7C, 0xCC, 0x84,
	0x7A, 0xCC, 0x83, 0x77, 0xCB, 0x84, 0x78, 0xCB, 0x83, 0x79, 0xCA, 0x81, 0x77, 0xCB, 0x82, 0x78,
	0xB0, 0x43, 0x50, 0xAF, 0x44, 0x4E, 0xAC, 0x40, 0x4B, 0xAB, 0x3C, 0x48, 0xAE, 0x3D, 0x47, 0xB8,
	0x41, 0x4A, 0xCA, 0x4D, 0x4E, 0xDA, 0x67, 0x59, 0xE1, 0x7E, 0x65, 0xE7, 0x90, 0x6F, 0xE8, 0x93,
	0x70, 0xE9, 0x92, 0x6E, 0xEA, 0x92, 0x6F, 0xE9, 0x8D, 0x6D, 0xE2, 0x78, 0x61, 0xC2, 0x4E, 0x4E,
	0x91, 0x2B, 0x41, 0x8A, 0x26, 0x3E, 0x9B, 0x33, 0x42, 0xA6, 0x38, 0x45, 0xA8, 0x3A, 0x46, 0xAA,
	0x3B, 0x46, 0xAB, 0x3B, 0x46, 0xAD, 0x3E, 0x48, 0xAC, 0x3B, 0x47, 0xAD, 0x3C, 0x47, 0xAF, 0x3D,
	0x46, 0xAD, 0x3B, 0x45, 0xA4, 0x36, 0x43, 0x98, 0x2B, 0x3F, 0xD8, 0x97, 0x7D, 0xF6, 0xCB, 0x92,
	0xEF, 0xB9, 0x84, 0xE7, 0x95, 0x6F, 0xD3, 0x5F, 0x57, 0xD1, 0x68, 0x66, 0xD8, 0x77, 0x6D, 0xC4,
	0x60, 0x61, 0xA9, 0x42, 0x55, 0xB8, 0x50, 0x5D, 0xCF, 0x65, 0x65, 0xD0, 0x69, 0x69, 0xC0, 0x5F,
	0x66, 0xBB, 0x57, 0x62, 0xC6, 0x5C, 0x62, 0xC8, 0x64, 0x67, 0xC1, 0x5E, 0x66, 0xC7, 0x5F, 0x65,
	0xD2, 0x6C, 0x6C, 0xD1, 0x68, 0x69, 0xB1, 0x56, 0x66, 0xB4, 0x62, 0x6F, 0xC7, 0x69, 0x6F, 0x9A,
	0x48, 0x63, 0x77, 0x3A, 0x67, 0x77, 0x3E, 0x6F, 0x6E, 0x2E, 0x5F, 0x5E, 0x15, 0x46, 0x59, 0x0D,
	0x3D, 0x6F, 0x2E, 0x5F, 0x8D, 0x5D, 0x8C, 0x7E, 0x47, 0x75, 0x63, 0x20, 0x50, 0x78, 0x3C, 0x6B,
	0x84, 0x4D, 0x7B, 0x75, 0x3B, 0x6A, 0x5E, 0x20, 0x50, 0x65, 0x2D, 0x5E, 0x3B, 0x01, 0x37, 0x6B,
	0x35, 0x58, 0xC2, 0x80, 0x80, 0xC8, 0x78, 0x77, 0xCE, 0x90, 0x8A, 0xE1, 0xB5, 0x9E, 0xDA, 0xA7,
	0x96, 0xD6, 0xA9, 0x9F, 0xD9, 0xB3, 0xA7, 0xDA, 0xB1, 0xA4, 0xDA, 0xAD, 0xA0, 0xD8, 0xAC, 0xA0,
	0xD9, 0xB1, 0xA5, 0xDA, 0xB2, 0xA5, 0xDA, 0xB4, 0xA6, 0xD9, 0xB5, 0xAA, 0xDA, 0xB9, 0xAF, 0xE3,
	0xC6, 0xB8, 0xE5, 0xC5, 0xB4, 0xCC, 0x9C, 0x93, 0xB0, 0x77, 0x7F, 0xA6, 0x63, 0x72, 0x9A, 0x3B,
	0x4D, 0x9A, 0x36, 0x49, 0xA2, 0x46, 0x56, 0xB5, 0x5E, 0x63, 0xCD, 0x76, 0x71, 0xDE, 0x87, 0x7A,
	0xEF, 0xB1, 0x96, 0xE3, 0xB5, 0x9A, 0x7B, 0x39, 0x51, 0x45, 0x00, 0x2E, 0x59, 0x0E, 0x38, 0x62,
	0x16, 0x3D, 0x62, 0x15, 0x3B, 0x59, 0x0E, 0x37, 0x58, 0x0D, 0x36, 0x66, 0x17, 0x3D, 0x5E, 0x1C,
	0x46, 0x59, 0x19, 0x49, 0xA2, 0x56, 0x69, 0xD2, 0x7F, 0x79, 0xC8, 0x76, 0x75, 0xCE, 0x85, 0x7C,
	0xD3, 0x8E, 0x81, 0xD2, 0x8A, 0x7F, 0xD2, 0x8A, 0x7E, 0xD1, 0x8A, 0x7F, 0xD2, 0x89, 0x7E, 0xD1,
	0x89, 0x7D, 0xD0, 0x87, 0x7E, 0xCE, 0x88, 0x80, 0xCE, 0x87, 0x7E, 0xCB, 0x84, 0x7C, 0xCD, 0x86,
	0x7A, 0xCC, 0x84, 0x78, 0xCA, 0x84, 0x78, 0xCB, 0x84, 0x79, 0xCB, 0x81, 0x78, 0xC9, 0x80, 0x78,
	0xB3, 0x45, 0x52, 0xB0, 0x43, 0x4F, 0xAF, 0x42, 0x4D, 0xAE, 0x40, 0x4B, 0xAD, 0x3D, 0x48, 0xB5,
	0x3E, 0x47, 0xC7, 0x4B, 0x4D, 0xD8, 0x67, 0x5A, 0xE3, 0x7F, 0x65, 0xE8, 0x8F, 0x6E, 0xE7, 0x94,
	0x71, 0xE8, 0x91, 0x6F, 0xEA, 0x90, 0x6E, 0xE9, 0x8D, 0x6D, 0xE2, 0x77, 0x61, 0xC2, 0x4F, 0x50,
	0x90, 0x2C, 0x41, 0x89, 0x26, 0x3E, 0x9B, 0x31, 0x43, 0xA3, 0x38, 0x45, 0xA6, 0x3A, 0x47, 0xAB,
	0x3B, 0x47, 0xAC, 0x3C, 0x47, 0xAD, 0x3D, 0x47, 0xAC, 0x3E, 0x49, 0xAA, 0x3C, 0x49, 0xAD, 0x3B,
	0x46, 0xB0, 0x3D, 0x46, 0xAB, 0x3D, 0x47, 0x95, 0x23, 0x39, 0xC1, 0x6D, 0x66, 0xF7, 0xCB, 0x94,
	0xEE, 0xB3, 0x80, 0xEC, 0xA9, 0x7A, 0xDA, 0x7E, 0x6A, 0xD0, 0x6A, 0x67, 0xD7, 0x71, 0x66, 0xB6,
	0x50, 0x57, 0xB4, 0x4B, 0x5A, 0xCF, 0x64, 0x66, 0xD1, 0x67, 0x67, 0xBF, 0x56, 0x60, 0xB6, 0x51,
	0x5E, 0xC2, 0x5E, 0x64, 0xC8, 0x61, 0x65, 0xC3, 0x5B, 0x62, 0xB9, 0x58, 0x63, 0xBE, 0x62, 0x6A,
	0xCA, 0x63, 0x68, 0xD6, 0x6D, 0x6E, 0xBA, 0x62, 0x6C, 0xAE, 0x57, 0x67, 0x86, 0x38, 0x5A, 0x69,
	0x26, 0x57, 0x70, 0x30, 0x61, 0x64, 0x23, 0x52, 0x5D, 0x18, 0x45, 0x59, 0x10, 0x3E, 0x5D, 0x18,
	0x48, 0x89, 0x54, 0x80, 0x8C, 0x51, 0x76, 0x5E, 0x15, 0x44, 0x66, 0x27, 0x56, 0x7D, 0x46, 0x76,
	0x73, 0x37, 0x69, 0x5C, 0x1D, 0x4C, 0x4E, 0x11, 0x43, 0x64, 0x2E, 0x63, 0x81, 0x49, 0x66, 0xC4,
	0x79, 0x74, 0xCC, 0x7A, 0x75, 0xD1, 0xA2, 0x99, 0xE0, 0xB7, 0xA5, 0xD8, 0xA6, 0x9A, 0xD3, 0xA4,
	0x9A, 0xD6, 0xAA, 0x9F, 0xD5, 0xA9, 0xA0, 0xD6, 0xAA, 0x9F, 0xD7, 0xA9, 0x9C, 0xD8, 0xAA, 0x9E,
	0xD9, 0xAF, 0xA3, 0xD9, 0xB1, 0xA3, 0xD9, 0xB4, 0xA7, 0xDD, 0xBC, 0xB0, 0xE6, 0xC7, 0xB5, 0xD1,
	0xA4, 0x98, 0xA3, 0x66, 0x71, 0x89, 0x40, 0x5F, 0x8A, 0x44, 0x66, 0xA8, 0x6D, 0x7D, 0xC6, 0x76,
	0x75, 0xD0, 0x74, 0x6C, 0xDA, 0x85, 0x74, 0xE4, 0x8E, 0x76, 0xE6, 0x8F, 0x7B, 0xF0, 0xAA, 0x8E,
	0xE4, 0xAF, 0x96, 0x7B, 0x39, 0x4F, 0x46, 0x00, 0x2D, 0x5A, 0x0F, 0x3A, 0x62, 0x18, 0x3E, 0x62,
	0x18, 0x3D, 0x60, 0x13, 0x3A, 0x58, 0x10, 0x3A, 0x5D, 0x10, 0x37, 0x64, 0x17, 0x3C, 0x53, 0x10,
	0x3E, 0x74, 0x2D, 0x54, 0xC4, 0x73, 0x76, 0xCE, 0x7B, 0x76, 0xC9, 0x78, 0x74, 0xD3, 0x8B, 0x7C,
	0xD2, 0x8B, 0x7E, 0xD2, 0x8B, 0x7E, 0xD2, 0x8D, 0x7F, 0xD2, 0x8A, 0x7E, 0xD2, 0x8A, 0x7F, 0xD1,
	0x89, 0x7F, 0xCF, 0x88, 0x7E, 0xCE, 0x88, 0x7E, 0xCE, 0x86, 0x7D, 0xCB, 0x84, 0x7B, 0xCB, 0x85,
	0x79, 0xCB, 0x84, 0x7A, 0xCB, 0x86, 0x7A, 0xCB, 0x85, 0x79, 0xCA, 0x81, 0x78, 0xC8, 0x7E, 0x77,
	0xB3, 0x46, 0x51, 0xB1, 0x43, 0x4D, 0xB0, 0x43, 0x4D, 0xAE, 0x40, 0x4C, 0xAE, 0x3E, 0x48, 0xB3,
	0x3E, 0x46, 0xC4, 0x48, 0x4C, 0xD8, 0x64, 0x58, 0xE3, 0x7F, 0x65, 0xE9, 0x90, 0x6D, 0xE8, 0x95,
	0x70, 0xE8, 0x92, 0x70, 0xEA, 0x91, 0x6F, 0xE9, 0x8D, 0x6D, 0xE2, 0x77, 0x62, 0xC3, 0x52, 0x52,
	0x91, 0x2B, 0x40, 0x8B, 0x26, 0x3E, 0x9D, 0x34, 0x45, 0xA2, 0x38, 0x46, 0xA4, 0x39, 0x47, 0xA9,
	0x39, 0x45, 0xAC, 0x3C, 0x48, 0xAB, 0x3E, 0x49, 0xA9, 0x3B, 0x48, 0xA8, 0x3C, 0x48, 0xAB, 0x3B,
	0x46, 0xB2, 0x3E, 0x46, 0xB2, 0x41, 0x48, 0x9D, 0x2C, 0x3F, 0xAC, 0x4A, 0x53, 0xEE, 0xBF, 0x93,
	0xF2, 0xC3, 0x8D, 0xEC, 0xAB, 0x7D, 0xE5, 0x95, 0x76, 0xE0, 0x87, 0x71, 0xC7, 0x5D, 0x58, 0xB2,
	0x45, 0x51, 0xC7, 0x5D, 0x63, 0xD3, 0x68, 0x67, 0xC5, 0x5D, 0x61, 0xAF, 0x4D, 0x5C, 0xC1, 0x58,
	0x5F, 0xC4, 0x5C, 0x62, 0xC0, 0x5A, 0x63, 0xBE, 0x57, 0x60, 0xC6, 0x64, 0x69, 0xC0, 0x64, 0x6C,
	0xA6, 0x4B, 0x5E, 0xB6, 0x57, 0x64, 0xAA, 0x52, 0x65, 0x74, 0x2D, 0x56, 0x65, 0x28, 0x5A, 0x70,
	0x31, 0x62, 0x63, 0x1F, 0x4E, 0x5C, 0x16, 0x44, 0x5C, 0x19, 0x45, 0x51, 0x08, 0x37, 0x72, 0x35,
	0x65, 0x7E, 0x41, 0x6D, 0x62, 0x15, 0x3F, 0x67, 0x24, 0x54, 0x86, 0x53, 0x81, 0x83, 0x51, 0x80,
	0x64, 0x28, 0x5A, 0x56, 0x19, 0x4C, 0x56, 0x21, 0x52, 0x9B, 0x68, 0x7D, 0xC8, 0x75, 0x70, 0xCB,
	0x78, 0x75, 0xD5, 0xA5, 0x99, 0xE2, 0xBF, 0xA8, 0xD7, 0xAA, 0x9E, 0xD1, 0xA1, 0x9B, 0xD4, 0xA7,
	0x9E, 0xD4, 0xA6, 0x9C, 0xD2, 0xA2, 0x9B, 0xD2, 0xA0, 0x98, 0xD3, 0xA1, 0x98, 0xD6, 0xAC, 0xA2,
	0xDA, 0xB1, 0xA5, 0xDB, 0xB2, 0xA3, 0xDC, 0xB7, 0xA8, 0xDB, 0xB5, 0xA5, 0xAD, 0x74, 0x74, 0x7B,
	0x30, 0x4D, 0x76, 0x2C, 0x53, 0x91, 0x55, 0x74, 0x94, 0x55, 0x71, 0xA7, 0x6B, 0x7A, 0xD7, 0x8C,
	0x84, 0xE9, 0x91, 0x79, 0xE8, 0x92, 0x73, 0xE7, 0x91, 0x76, 0xF1, 0xB0, 0x90, 0xE5, 0xB1, 0x93,
	0x84, 0x41, 0x55, 0x44, 0x00, 0x2D, 0x55, 0x0C, 0x37, 0x60, 0x14, 0x3B, 0x63, 0x17, 0x3D, 0x62,
	0x18, 0x3E, 0x5E, 0x12, 0x3A, 0x59, 0x0E, 0x36, 0x60, 0x14, 0x39, 0x5B, 0x15, 0x3B, 0x55, 0x11,
	0x40, 0x97, 0x4A, 0x62, 0xCF, 0x7E, 0x79, 0xC9, 0x75, 0x74, 0xCF, 0x82, 0x78, 0xD4, 0x8F, 0x7E,
	0xD2, 0x8D, 0x7D, 0xD2, 0x8C, 0x7D, 0xD2, 0x8E, 0x7D, 0xD2, 0x8A, 0x7C, 0xD2, 0x8A, 0x7E, 0xD1,
	0x89, 0x7D, 0xCF, 0x88, 0x7D, 0xD0, 0x88, 0x7D, 0xCD, 0x87, 0x7E, 0xCC, 0x86, 0x7C, 0xCC, 0x85,
	0x7A, 0xCA, 0x85, 0x7B, 0xCB, 0x85, 0x7C, 0xC9, 0x83, 0x7B, 0xC9, 0x82, 0x79, 0xC8, 0x7F, 0x78,
	0xB4, 0x46, 0x4F, 0xB1, 0x46, 0x50, 0xB1, 0x45, 0x4F, 0xAE, 0x40, 0x4B, 0xAD, 0x3D, 0x47, 0xAE,
	0x3D, 0x46, 0xC0, 0x46, 0x4A, 0xD7, 0x61, 0x56, 0xE2, 0x7F, 0x66, 0xE8, 0x90, 0x6F, 0xE8, 0x92,
	0x71, 0xE9, 0x91, 0x71, 0xEA, 0x93, 0x6F, 0xEA, 0x8F, 0x6E, 0xE2, 0x78, 0x65, 0xC6, 0x52, 0x51,
	0x92, 0x29, 0x3E, 0x89, 0x25, 0x3E, 0x9A, 0x32, 0x44, 0xA1, 0x37, 0x46, 0xA4, 0x39, 0x47, 0xA9,
	0x39, 0x46, 0xAA, 0x39, 0x46, 0xAA, 0x39, 0x46, 0xA9, 0x39, 0x45, 0xA9, 0x3A, 0x45, 0xAD, 0x3D,
	0x46, 0xB4, 0x41, 0x48, 0xB5, 0x42, 0x4A, 0xAC, 0x3C, 0x46, 0x9E, 0x2C, 0x3F, 0xD2, 0x8A, 0x77,
	0xF9, 0xD8, 0x9E, 0xE9, 0xAA, 0x80, 0xE3, 0x90, 0x75, 0xE4, 0x96, 0x77, 0xBB, 0x53, 0x56, 0xBF,
	0x53, 0x5C, 0xCB, 0x63, 0x68, 0xC2, 0x59, 0x61, 0xB5, 0x4E, 0x5B, 0xC0, 0x5C, 0x63, 0xC6, 0x5F,
	0x63, 0xBD, 0x56, 0x60, 0xBD, 0x55, 0x62, 0xC9, 0x5E, 0x66, 0xCE, 0x64, 0x68, 0xC4, 0x60, 0x69,
	0x93, 0x40, 0x5A, 0x78, 0x29, 0x50, 0x71, 0x2B, 0x59, 0x6B, 0x2E, 0x5F, 0x71, 0x35, 0x65, 0x61,
	0x21, 0x51, 0x5C, 0x19, 0x49, 0x76, 0x39, 0x65, 0x54, 0x11, 0x3E, 0x58, 0x14, 0x45, 0x7A, 0x3D,
	0x69, 0x60, 0x1A, 0x45, 0x5B, 0x0E, 0x3C, 0x6F, 0x29, 0x55, 0x74, 0x37, 0x66, 0x6A, 0x2F, 0x60,
	0x6C, 0x37, 0x65, 0x68, 0x37, 0x69, 0x77, 0x43, 0x69, 0xBA, 0x75, 0x7D, 0xC2, 0x76, 0x77, 0xD9,
	0xAC, 0x9F, 0xE2, 0xBE, 0xA9, 0xDC, 0xB1, 0xA2, 0xD3, 0xA8, 0xA0, 0xD1, 0xA3, 0x9C, 0xD2, 0xA8,
	0x9E, 0xD2, 0xA5, 0x9D, 0xCF, 0x9B, 0x93, 0xD0, 0x9E, 0x97, 0xD2, 0xA0, 0x9A, 0xD6, 0xAD, 0xA4,
	0xD8, 0xB4, 0xA9, 0xD9, 0xB0, 0xA2, 0xE0, 0xB4, 0xA3, 0xC5, 0x7C, 0x78, 0x77, 0x1C, 0x3B, 0x73,
	0x27, 0x4E, 0x8C, 0x42, 0x61, 0x97, 0x58, 0x72, 0xA0, 0x67, 0x7C, 0x9C, 0x5F, 0x74, 0xC1, 0x7A,
	0x7E, 0xE2, 0x88, 0x78, 0xEB, 0x99, 0x7B, 0xF7, 0xB5, 0x8C, 0xD2, 0x95, 0x7C, 0x79, 0x2F, 0x46,
	0x48, 0x00, 0x2F, 0x55, 0x0A, 0x34, 0x60, 0x12, 0x38, 0x62, 0x16, 0x3D, 0x65, 0x1A, 0x40, 0x63,
	0x18, 0x3E, 0x5B, 0x11, 0x3A, 0x5A, 0x0E, 0x36, 0x61, 0x12, 0x38, 0x59, 0x12, 0x3D, 0x6B, 0x23,
	0x4C, 0xAE, 0x5F, 0x6E, 0xC5, 0x73, 0x74, 0xC6, 0x74, 0x73, 0xD3, 0x8A, 0x7C, 0xD4, 0x8E, 0x7D,
	0xD2, 0x8F, 0x7D, 0xD2, 0x8C, 0x7D, 0xD2, 0x8B, 0x7D, 0xD2, 0x8A, 0x7D, 0xD2, 0x8A, 0x7D, 0xD2,
	0x8B, 0x7C, 0xD1, 0x89, 0x7D, 0xD0, 0x89, 0x7E, 0xCE, 0x88, 0x7E, 0xCD, 0x87, 0x7D, 0xCD, 0x88,
	0x7B, 0xCC, 0x87, 0x7B, 0xCB, 0x85, 0x7B, 0xCA, 0x82, 0x7A, 0xC9, 0x80, 0x78, 0xC9, 0x80, 0x79,
	0xB3, 0x47, 0x51, 0xB1, 0x47, 0x51, 0xB1, 0x45, 0x4F, 0xAD, 0x41, 0x4B, 0xAC, 0x3C, 0x48, 0xAB,
	0x38, 0x45, 0xBC, 0x41, 0x48, 0xD6, 0x60, 0x56, 0xE2, 0x7F, 0x66, 0xE7, 0x90, 0x70, 0xE8, 0x94,
	0x74, 0xE9, 0x94, 0x71, 0xEA, 0x95, 0x70, 0xEA, 0x8E, 0x6D, 0xE2, 0x77, 0x62, 0xC6, 0x4F, 0x50,
	0x91, 0x29, 0x3F, 0x88, 0x26, 0x3E, 0x98, 0x30, 0x42, 0xA0, 0x36, 0x45, 0xA5, 0x3A, 0x48, 0xA9,
	0x3C, 0x49, 0xAA, 0x3A, 0x47, 0xAC, 0x39, 0x47, 0xAD, 0x3C, 0x47, 0xAC, 0x3B, 0x47, 0xAF, 0x3E,
	0x48, 0xB4, 0x41, 0x49, 0xB5, 0x42, 0x4B, 0xB5, 0x43, 0x4A, 0xA4, 0x31, 0x41, 0xA9, 0x41, 0x4C,
	0xE8, 0xB5, 0x8E, 0xF1, 0xC1, 0x8B, 0xEA, 0xA9, 0x7D, 0xDF, 0x91, 0x72, 0xC5, 0x5D, 0x5A, 0xC9,
	0x5C, 0x5D, 0xC5, 0x5F, 0x66, 0xB7, 0x54, 0x62, 0xBA, 0x55, 0x61, 0xC7, 0x65, 0x6A, 0xBD, 0x66,
	0x6E, 0xB1, 0x5F, 0x6E, 0xB2, 0x62, 0x71, 0xBB, 0x64, 0x6F, 0xB8, 0x5C, 0x69, 0xA9, 0x4E, 0x60,
	0x91, 0x3E, 0x5A, 0x7D, 0x30, 0x58, 0x71, 0x30, 0x5E, 0x79, 0x3B, 0x67, 0x5D, 0x1D, 0x4C, 0x49,
	0x06, 0x38, 0x6D, 0x31, 0x60, 0x7A, 0x42, 0x6A, 0x4D, 0x06, 0x34, 0x65, 0x21, 0x50, 0x71, 0x2D,
	0x58, 0x60, 0x18, 0x43, 0x69, 0x1E, 0x4B, 0x61, 0x19, 0x47, 0x6A, 0x2B, 0x5D, 0x65, 0x2A, 0x5D,
	0x79, 0x47, 0x77, 0x91, 0x62, 0x88, 0x8F, 0x52, 0x75, 0xAA, 0x6C, 0x7C, 0xDA, 0xB0, 0xA1, 0xE2,
	0xBC, 0xA6, 0xDA, 0xB3, 0xA5, 0xD6, 0xAB, 0xA1, 0xD2, 0xA5, 0x9D, 0xD2, 0xA4, 0x9D, 0xD2, 0xA6,
	0x9E, 0xD0, 0x9E, 0x95, 0xCE, 0x99, 0x92, 0xD1, 0xA6, 0x9E, 0xD0, 0xA8, 0xA0, 0xD1, 0xAB, 0xA2,
	0xD5, 0xAA, 0x9F, 0xDC, 0xAB, 0x9E, 0xE6, 0xB6, 0xA5, 0xDA, 0x8C, 0x85, 0xA7, 0x3D, 0x4F, 0x84,
	0x36, 0x54, 0x8D, 0x4A, 0x69, 0x8F, 0x4A, 0x6A, 0xA2, 0x67, 0x79, 0x9F, 0x63, 0x77, 0xB6, 0x70,
	0x7A, 0xE5, 0x98, 0x86, 0xEF, 0xAE, 0x86, 0xC0, 0x7A, 0x6A, 0x66, 0x19, 0x3C, 0x47, 0x00, 0x2F,
	0x57, 0x0B, 0x35, 0x62, 0x13, 0x39, 0x63, 0x15, 0x3A, 0x62, 0x15, 0x3B, 0x66, 0x1B, 0x3E, 0x60,
	0x14, 0x3A, 0x57, 0x0E, 0x38, 0x5D, 0x10, 0x37, 0x5F, 0x15, 0x3C, 0x5B, 0x16, 0x43, 0x87, 0x3C,
	0x59, 0xB7, 0x6A, 0x71, 0xB4, 0x64, 0x6E, 0xC6, 0x7A, 0x78, 0xD4, 0x92, 0x80, 0xD3, 0x90, 0x7E,
	0xD2, 0x8C, 0x7D, 0xD2, 0x8B, 0x7D, 0xD2, 0x8A, 0x7D, 0xD2, 0x8A, 0x7D, 0xD2, 0x8A, 0x7D, 0xD2,
	0x8A, 0x7D, 0xD1, 0x8A, 0x7E, 0xD0, 0x8A, 0x7F, 0xCF, 0x88, 0x7E, 0xCF, 0x88, 0x7E, 0xCF, 0x89,
	0x7C, 0xCE, 0x87, 0x7C, 0xCA, 0x86, 0x7C, 0xC9, 0x84, 0x7B, 0xC9, 0x81, 0x79, 0xC9, 0x7F, 0x78,
	0xB4, 0x47, 0x50, 0xB3, 0x46, 0x51, 0xB0, 0x42, 0x4C, 0xAF, 0x41, 0x4B, 0xAC, 0x3E, 0x4A, 0xA6,
	0x36, 0x44, 0xB5, 0x3D, 0x48, 0xD3, 0x5F, 0x57, 0xE3, 0x7D, 0x66, 0xE8, 0x8F, 0x6F, 0xE8, 0x94,
	0x72, 0xE8, 0x94, 0x71, 0xE9, 0x96, 0x70, 0xEA, 0x8F, 0x6E, 0xE3, 0x79, 0x63, 0xC6, 0x52, 0x51,
	0x92, 0x29, 0x3F, 0x87, 0x22, 0x3C, 0x96, 0x2E, 0x40, 0x9E, 0x36, 0x44, 0xA6, 0x3A, 0x47, 0xA7,
	0x3A, 0x48, 0xA8, 0x39, 0x46, 0xAB, 0x3A, 0x46, 0xAB, 0x3C, 0x48, 0xAC, 0x3E, 0x49, 0xAF, 0x40,
	0x4A, 0xB6, 0x42, 0x4A, 0xBA, 0x46, 0x4D, 0xBA, 0x48, 0x4E, 0xB2, 0x41, 0x49, 0x9C, 0x28, 0x3D,
	0xC8, 0x7A, 0x6E, 0xF5, 0xCD, 0x99, 0xF0, 0xBF, 0x86, 0xDF, 0x92, 0x73, 0xCD, 0x5E, 0x5A, 0xC2,
	0x55, 0x59, 0xB3, 0x4B, 0x58, 0xB5, 0x53, 0x61, 0xC6, 0x63, 0x69, 0xBA, 0x5C, 0x68, 0xB0, 0x57,
	0x66, 0xB9, 0x60, 0x6D, 0xB8, 0x64, 0x70, 0xB3, 0x66, 0x73, 0xA5, 0x59, 0x6E, 0x7E, 0x2E, 0x54,
	0x74, 0x2A, 0x55, 0x7E, 0x32, 0x5B, 0x85, 0x43, 0x6B, 0x75, 0x38, 0x64, 0x59, 0x14, 0x43, 0x50,
	0x0D, 0x3E, 0x70, 0x32, 0x60, 0x71, 0x33, 0x5F, 0x5E, 0x18, 0x47, 0x64, 0x1E, 0x4A, 0x5C, 0x12,
	0x3D, 0x62, 0x1A, 0x46, 0x6B, 0x28, 0x53, 0x66, 0x25, 0x52, 0x68, 0x2B, 0x5D, 0x6E, 0x33, 0x67,
	0x79, 0x43, 0x76, 0x91, 0x60, 0x8C, 0x9C, 0x6D, 0x8D, 0xC6, 0x99, 0x96, 0xDF, 0xAC, 0x9B, 0xD8,
	0xA8, 0x9C, 0xD6, 0xAB, 0xA1, 0xD1, 0xA1, 0x98, 0xD1, 0x9F, 0x97, 0xD1, 0x9F, 0x98, 0xD2, 0x9E,
	0x96, 0xD2, 0x9C, 0x95, 0xD0, 0x9D, 0x96, 0xCE, 0xA4, 0x9D, 0xD2, 0xA9, 0xA1, 0xDC, 0xAE, 0xA2,
	0xE2, 0xAD, 0x9E, 0xE8, 0xB3, 0xA6, 0xEB, 0xBC, 0xAD, 0xE8, 0xAF, 0x9F, 0xD0, 0x68, 0x67, 0x96,
	0x2F, 0x46, 0x82, 0x3E, 0x5C, 0x87, 0x43, 0x66, 0x8D, 0x48, 0x64, 0xA8, 0x6F, 0x7B, 0xB8, 0x7B,
	0x81, 0xDD, 0x90, 0x81, 0xB3, 0x5B, 0x58, 0x5A, 0x08, 0x31, 0x4B, 0x04, 0x34, 0x56, 0x0F, 0x3A,
	0x5F, 0x10, 0x37, 0x67, 0x17, 0x3B, 0x65, 0x19, 0x3D, 0x63, 0x18, 0x3B, 0x65, 0x18, 0x3C, 0x5A,
	0x0F, 0x37, 0x5A, 0x0E, 0x37, 0x62, 0x13, 0x39, 0x5C, 0x13, 0x3D, 0x66, 0x1F, 0x4B, 0xA0, 0x55,
	0x68, 0xB6, 0x69, 0x70, 0xB1, 0x65, 0x6F, 0xCC, 0x86, 0x7D, 0xD4, 0x96, 0x82, 0xD2, 0x91, 0x80,
	0xD2, 0x8C, 0x7E, 0xD2, 0x8B, 0x7E, 0xD2, 0x8C, 0x7D, 0xD2, 0x8B, 0x7D, 0xD2, 0x8A, 0x7C, 0xD2,
	0x8A, 0x7D, 0xD1, 0x89, 0x7E, 0xD1, 0x89, 0x7D, 0xD0, 0x89, 0x7D, 0xD0, 0x89, 0x7E, 0xCE, 0x87,
	0x7B, 0xCD, 0x86, 0x7B, 0xCA, 0x87, 0x7B, 0xCA, 0x85, 0x7A, 0xC9, 0x82, 0x79, 0xC8, 0x80, 0x79,
	0xB3, 0x46, 0x50, 0xB3, 0x45, 0x4E, 0xB1, 0x43, 0x4D, 0xAF, 0x40, 0x4A, 0xAC, 0x3D, 0x47, 0xA2,
	0x34, 0x44, 0xAE, 0x3B, 0x47, 0xD1, 0x5D, 0x55, 0xE1, 0x7C, 0x65, 0xE6, 0x8E, 0x70, 0xE8, 0x94,
	0x71, 0xE7, 0x94, 0x71, 0xE8, 0x96, 0x72, 0xEA, 0x90, 0x70, 0xE4, 0x7A, 0x64, 0xC8, 0x53, 0x51,
	0x91, 0x28, 0x3F, 0x86, 0x22, 0x3C, 0x96, 0x2E, 0x42, 0x9E, 0x36, 0x46, 0xA7, 0x3A, 0x47, 0xAB,
	0x3B, 0x48, 0xAA, 0x3B, 0x49, 0xA8, 0x3A, 0x48, 0xAA, 0x3A, 0x47, 0xAB, 0x3C, 0x47, 0xB0, 0x3F,
	0x47, 0xB4, 0x42, 0x4A, 0xBB, 0x48, 0x4F, 0xBB, 0x4B, 0x51, 0xB7, 0x45, 0x4C, 0xA3, 0x2D, 0x3E,
	0xBD, 0x65, 0x64, 0xF4, 0xD1, 0xA3, 0xF4, 0xCA, 0x91, 0xE7, 0x9B, 0x74, 0xC9, 0x5A, 0x5B, 0xBD,
	0x54, 0x5F, 0xB2, 0x4C, 0x5B, 0xB9, 0x55, 0x61, 0xB9, 0x57, 0x64, 0xB8, 0x56, 0x63, 0xC7, 0x5D,
	0x64, 0xD1, 0x61, 0x65, 0xB8, 0x51, 0x5E, 0xB4, 0x53, 0x5F, 0x9C, 0x44, 0x5A, 0x6D, 0x27, 0x55,
	0x5E, 0x1C, 0x4F, 0x5F, 0x19, 0x48, 0x75, 0x33, 0x5F, 0x72, 0x31, 0x60, 0x65, 0x22, 0x51, 0x5C,
	0x1B, 0x4A, 0x63, 0x23, 0x52, 0x7B, 0x42, 0x72, 0x73, 0x35, 0x63, 0x53, 0x09, 0x33, 0x58, 0x0D,
	0x36, 0x5B, 0x13, 0x3C, 0x59, 0x15, 0x3D, 0x4A, 0x07, 0x36, 0x5E, 0x1E, 0x4C, 0x86, 0x3F, 0x62,
	0x76, 0x39, 0x69, 0x8A, 0x60, 0x8B, 0xB7, 0x8B, 0x95, 0xD4, 0x9D, 0x92, 0xD6, 0xA2, 0x98, 0xD4,
	0xA7, 0x9E, 0xD1, 0x9F, 0x98, 0xCC, 0x95, 0x8C, 0xCE, 0x9A, 0x93, 0xD1, 0x9F, 0x9A, 0xD0, 0x9C,
	0x95, 0xCE, 0x9A, 0x94, 0xCD, 0x99, 0x94, 0xD4, 0xA2, 0x99, 0xE5, 0xB3, 0xA6, 0xEA, 0xB7, 0xA9,
	0xEA, 0xB5, 0xA8, 0xEA, 0xB6, 0xAA, 0xEB, 0xB8, 0xAC, 0xE9, 0xB7, 0xA6, 0xE2, 0x86, 0x7A, 0xB4,
	0x3C, 0x46, 0x6F, 0x1B, 0x3F, 0x6D, 0x29, 0x51, 0x7F, 0x34, 0x59, 0x99, 0x5B, 0x70, 0xBA, 0x83,
	0x86, 0xCB, 0x76, 0x74, 0x90, 0x2D, 0x43, 0x4E, 0x04, 0x33, 0x52, 0x0B, 0x36, 0x5A, 0x0E, 0x38,
	0x64, 0x16, 0x3B, 0x66, 0x18, 0x3C, 0x67, 0x1A, 0x3D, 0x68, 0x1C, 0x3F, 0x62, 0x16, 0x3D, 0x57,
	0x0D, 0x36, 0x5A, 0x0C, 0x35, 0x60, 0x12, 0x39, 0x58, 0x10, 0x3F, 0x7D, 0x34, 0x58, 0xB4, 0x6B,
	0x71, 0xB1, 0x63, 0x6C, 0xB9, 0x6C, 0x72, 0xD1, 0x8B, 0x7E, 0xD4, 0x91, 0x7F, 0xD2, 0x8E, 0x7D,
	0xD2, 0x8C, 0x7E, 0xD1, 0x8D, 0x7D, 0xD2, 0x8B, 0x7C, 0xD2, 0x8B, 0x7D, 0xD2, 0x8C, 0x7D, 0xD2,
	0x8B, 0x7E, 0xD2, 0x89, 0x7D, 0xD2, 0x89, 0x7E, 0xD1, 0x8B, 0x7F, 0xD1, 0x89, 0x7E, 0xCE, 0x87,
	0x7A, 0xCE, 0x87, 0x7A, 0xCE, 0x87, 0x7A, 0xCC, 0x85, 0x79, 0xC9, 0x82, 0x78, 0xC8, 0x80, 0x78,
	0xAF, 0x45, 0x51, 0xB0, 0x44, 0x4F, 0xB0, 0x46, 0x50, 0xAC, 0x40, 0x4B, 0xAA, 0x3A, 0x46, 0xA0,
	0x32, 0x43, 0xAB, 0x3B, 0x47, 0xCF, 0x5C, 0x56, 0xE0, 0x7B, 0x66, 0xE7, 0x8E, 0x71, 0xE8, 0x95,
	0x71, 0xE8, 0x95, 0x72, 0xE9, 0x95, 0x73, 0xE9, 0x91, 0x70, 0xE3, 0x7B, 0x66, 0xC8, 0x53, 0x51,
	0x93, 0x29, 0x3E, 0x87, 0x23, 0x3C, 0x97, 0x32, 0x44, 0xA1, 0x38, 0x49, 0xA8, 0x3C, 0x49, 0xAC,
	0x3E, 0x4A, 0xAD, 0x3E, 0x4B, 0xAB, 0x3D, 0x4A, 0xAD, 0x3C, 0x48, 0xAC, 0x3B, 0x47, 0xB1, 0x3F,
	0x48, 0xB6, 0x43, 0x4B, 0xBD, 0x49, 0x4F, 0xBD, 0x4C, 0x51, 0xB9, 0x46, 0x4C, 0xA8, 0x30, 0x41,
	0xC2, 0x66, 0x62, 0xF6, 0xD4, 0xA1, 0xF6, 0xCC, 0x94, 0xD1, 0x70, 0x5C, 0xB7, 0x42, 0x4D, 0xBB,
	0x54, 0x5F, 0xBE, 0x57, 0x61, 0xB7, 0x51, 0x5E, 0xB4, 0x4D, 0x5D, 0xCC, 0x64, 0x68, 0xD6, 0x65,
	0x66, 0xCD, 0x62, 0x67, 0xA1, 0x46, 0x59, 0x73, 0x1C, 0x3D, 0x71, 0x23, 0x4A, 0x6D, 0x28, 0x54,
	0x55, 0x10, 0x3D, 0x4E, 0x0C, 0x3A, 0x65, 0x25, 0x53, 0x73, 0x33, 0x60, 0x70, 0x32, 0x61, 0x62,
	0x22, 0x52, 0x5B, 0x19, 0x49, 0x6E, 0x35, 0x68, 0x87, 0x56, 0x87, 0x63, 0x22, 0x4F, 0x5B, 0x15,
	0x3F, 0x55, 0x0E, 0x39, 0x47, 0x03, 0x32, 0x51, 0x11, 0x3F, 0x8B, 0x46, 0x62, 0x9F, 0x4E, 0x61,
	0x9B, 0x65, 0x81, 0xAF, 0x8A, 0x9A, 0xDA, 0xA5, 0x95, 0xDB, 0xA6, 0x98, 0xD7, 0xB0, 0xA5, 0xD4,
	0xAA, 0x9F, 0xCB, 0x93, 0x8C, 0xC9, 0x8D, 0x86, 0xCE, 0x9B, 0x94, 0xD1, 0xA5, 0x9E, 0xCA, 0x91,
	0x8C, 0xCE, 0x90, 0x8A, 0xDB, 0xA2, 0x95, 0xE5, 0xB0, 0xA0, 0xEA, 0xB7, 0xA9, 0xEA, 0xB9, 0xAB,
	0xEA, 0xB6, 0xAA, 0xEA, 0xB7, 0xAA, 0xEA, 0xBB, 0xAC, 0xEA, 0xBA, 0xA9, 0xE5, 0x94, 0x86, 0xC3,
	0x4A, 0x4E, 0x7B, 0x1B, 0x3A, 0x56, 0x0F, 0x3B, 0x74, 0x27, 0x4E, 0x8D, 0x49, 0x66, 0xBA, 0x84,
	0x87, 0xC9, 0x7A, 0x79, 0x82, 0x29, 0x44, 0x51, 0x0A, 0x36, 0x56, 0x0D, 0x38, 0x5D, 0x0E, 0x36,
	0x66, 0x16, 0x3A, 0x67, 0x1A, 0x3F, 0x69, 0x1D, 0x41, 0x6A, 0x1E, 0x42, 0x5F, 0x14, 0x3B, 0x59,
	0x0D, 0x36, 0x5D, 0x0E, 0x35, 0x5A, 0x0F, 0x38, 0x5A, 0x14, 0x43, 0x9A, 0x4F, 0x65, 0xBF, 0x72,
	0x72, 0xB3, 0x65, 0x6D, 0xC1, 0x79, 0x77, 0xCF, 0x89, 0x7B, 0xD2, 0x8D, 0x7C, 0xD3, 0x8D, 0x7C,
	0xD3, 0x8D, 0x7D, 0xD2, 0x8D, 0x7C, 0xD2, 0x8B, 0x7C, 0xD2, 0x8A, 0x7B, 0xD2, 0x8A, 0x7C, 0xD2,
	0x8B, 0x7D, 0xD2, 0x8A, 0x7B, 0xD2, 0x89, 0x7D, 0xD0, 0x89, 0x7E, 0xD1, 0x89, 0x7E, 0xD0, 0x89,
	0x7D, 0xCF, 0x88, 0x7C, 0xCE, 0x87, 0x7B, 0xCD, 0x86, 0x7A, 0xCC, 0x82, 0x76, 0xC8, 0x7D, 0x77,
	0xAC, 0x43, 0x4F, 0xAD, 0x45, 0x51, 0xAC, 0x44, 0x4F, 0xAC, 0x40, 0x4C, 0xA9, 0x3E, 0x49, 0xA1,
	0x36, 0x45, 0xAD, 0x3D, 0x48, 0xCF, 0x5E, 0x58, 0xE0, 0x7B, 0x67, 0xE6, 0x8E, 0x72, 0xE9, 0x94,
	0x72, 0xE8, 0x94, 0x72, 0xE9, 0x96, 0x74, 0xE9, 0x8F, 0x70, 0xE3, 0x7B, 0x67, 0xC7, 0x56, 0x55,
	0x93, 0x2C, 0x41, 0x89, 0x23, 0x3C, 0x97, 0x30, 0x42, 0xA2, 0x38, 0x48, 0xA9, 0x3B, 0x49, 0xAC,
	0x3D, 0x4A, 0xAF, 0x3E, 0x49, 0xAD, 0x3E, 0x4A, 0xAC, 0x3D, 0x49, 0xAE, 0x40, 0x4B, 0xB2, 0x40,
	0x4A, 0xB4, 0x41, 0x4B, 0xBB, 0x4A, 0x51, 0xC0, 0x4D, 0x51, 0xBF, 0x48, 0x4E, 0xAF, 0x36, 0x45,
	0xBC, 0x56, 0x57, 0xF3, 0xCE, 0x9F, 0xED, 0xB6, 0x88, 0xBA, 0x4A, 0x4C, 0xB1, 0x3F, 0x4A, 0xB8,
	0x4C, 0x55, 0xB7, 0x4F, 0x5C, 0xBA, 0x53, 0x5F, 0xC8, 0x5A, 0x60, 0xC0, 0x55, 0x5C, 0xB6, 0x4F,
	0x5C, 0xB8, 0x51, 0x5F, 0x8E, 0x3A, 0x53, 0x55, 0x0F, 0x3D, 0x6A, 0x26, 0x54, 0x5F, 0x17, 0x42,
	0x54, 0x0B, 0x36, 0x58, 0x11, 0x3C, 0x5A, 0x19, 0x46, 0x6C, 0x2C, 0x5A, 0x6F, 0x2D, 0x5C, 0x66,
	0x27, 0x57, 0x61, 0x21, 0x50, 0x57, 0x14, 0x45, 0x83, 0x53, 0x80, 0x7A, 0x40, 0x6A, 0x5F, 0x19,
	0x45, 0x42, 0x01, 0x30, 0x45, 0x08, 0x37, 0x9D, 0x52, 0x62, 0xB9, 0x60, 0x6C, 0xBF, 0x7C, 0x7E,
	0xC8, 0x8D, 0x8D, 0xA8, 0x82, 0x9A, 0xCD, 0xA2, 0x9D, 0xD9, 0xA9, 0x9C, 0xD9, 0xB0, 0xA4, 0xD1,
	0x9E, 0x95, 0xC7, 0x8D, 0x86, 0xC8, 0x92, 0x8C, 0xD0, 0xA2, 0x9A, 0xD2, 0x94, 0x8B, 0xD8, 0x88,
	0x81, 0xE0, 0x96, 0x8B, 0xE3, 0xAB, 0x9A, 0xE7, 0xB3, 0xA5, 0xE9, 0xB6, 0xA9, 0xEA, 0xB8, 0xAC,
	0xEA, 0xB7, 0xAA, 0xEA, 0xBC, 0xAE, 0xEA, 0xC3, 0xB3, 0xEB, 0xC5, 0xB3, 0xE8, 0xA8, 0x96, 0xCE,
	0x5B, 0x5B, 0x8B, 0x22, 0x3C, 0x4F, 0x08, 0x36, 0x62, 0x15, 0x41, 0x86, 0x3B, 0x5B, 0xBF, 0x8D,
	0x8E, 0xC3, 0x81, 0x81, 0x6D, 0x1C, 0x3F, 0x53, 0x0A, 0x36, 0x5C, 0x10, 0x38, 0x60, 0x11, 0x3A,
	0x64, 0x14, 0x3A, 0x66, 0x19, 0x3E, 0x6A, 0x20, 0x42, 0x68, 0x1C, 0x3F, 0x5A, 0x10, 0x37, 0x5A,
	0x0D, 0x35, 0x5F, 0x10, 0x36, 0x55, 0x0C, 0x39, 0x71, 0x28, 0x50, 0xB4, 0x69, 0x70, 0xBC, 0x70,
	0x6F, 0xBD, 0x72, 0x73, 0xC9, 0x82, 0x79, 0xC8, 0x7F, 0x76, 0xC9, 0x82, 0x7A, 0xCD, 0x88, 0x7D,
	0xD1, 0x8E, 0x7E, 0xD1, 0x8D, 0x7D, 0xD2, 0x8B, 0x7B, 0xD3, 0x8B, 0x7B, 0xD3, 0x89, 0x7D, 0xD2,
	0x8A, 0x7B, 0xD2, 0x8B, 0x7C, 0xD2, 0x8A, 0x7E, 0xD1, 0x89, 0x7C, 0xCF, 0x88, 0x7D, 0xCF, 0x88,
	0x7C, 0xCF, 0x87, 0x7B, 0xCE, 0x87, 0x7A, 0xCC, 0x85, 0x78, 0xCB, 0x82, 0x76, 0xC9, 0x7D, 0x76,
	0xAD, 0x41, 0x4C, 0xAD, 0x44, 0x50, 0xAD, 0x43, 0x4D, 0xAC, 0x40, 0x4A, 0xA9, 0x3F, 0x49, 0xA2,
	0x37, 0x46, 0xAC, 0x3C, 0x48, 0xCF, 0x5E, 0x58, 0xE1, 0x7C, 0x67, 0xE6, 0x8D, 0x6F, 0xE8, 0x93,
	0x72, 0xE9, 0x94, 0x75, 0xE9, 0x97, 0x74, 0xEA, 0x93, 0x6F, 0xE3, 0x7C, 0x66, 0xC9, 0x58, 0x57,
	0x96, 0x30, 0x44, 0x88, 0x23, 0x3C, 0x98, 0x2E, 0x40, 0xA1, 0x37, 0x45, 0xA9, 0x3D, 0x4B, 0xAC,
	0x40, 0x4D, 0xAE, 0x40, 0x4D, 0xB1, 0x41, 0x4B, 0xAE, 0x3F, 0x4B, 0xAC, 0x3F, 0x4B, 0xAE, 0x3C,
	0x48, 0xBD, 0x54, 0x56, 0xC5, 0x5C, 0x5B, 0xBF, 0x49, 0x50, 0xC1, 0x4A, 0x4F, 0xB9, 0x42, 0x4B,
	0xB2, 0x40, 0x4A, 0xE6, 0xB2, 0x91, 0xE5, 0xA7, 0x86, 0xBA, 0x43, 0x4B, 0xBC, 0x4E, 0x55, 0xB4,
	0x48, 0x53, 0xB8, 0x4E, 0x58, 0xCB, 0x61, 0x63, 0xC7, 0x5D, 0x63, 0xA2, 0x46, 0x5C, 0x88, 0x35,
	0x54, 0x7C, 0x26, 0x45, 0x70, 0x1C, 0x3F, 0x69, 0x21, 0x4D, 0x73, 0x30, 0x5B, 0x54, 0x0E, 0x3A,
	0x5E, 0x17, 0x43, 0x62, 0x18, 0x44, 0x58, 0x11, 0x3D, 0x5F, 0x17, 0x45, 0x63, 0x1F, 0x4D, 0x65,
	0x23, 0x52, 0x74, 0x3A, 0x6A, 0x66, 0x28, 0x58, 0x72, 0x39, 0x66, 0x68, 0x2B, 0x56, 0x42, 0x00,
	0x2C, 0x3F, 0x03, 0x35, 0x91, 0x4A, 0x5C, 0xCB, 0x6A, 0x6B, 0xCC, 0x7D, 0x7E, 0xDE, 0x9E, 0x91,
	0xD0, 0x8B, 0x87, 0xAB, 0x83, 0x9A, 0xBC, 0x98, 0x9F, 0xD4, 0xAA, 0xA1, 0xD6, 0xA8, 0x9F, 0xCF,
	0x97, 0x91, 0xCA, 0x97, 0x90, 0xCC, 0x98, 0x90, 0xD3, 0x8A, 0x82, 0xDD, 0x80, 0x79, 0xE3, 0x8F,
	0x85, 0xE2, 0xA2, 0x91, 0xE3, 0xAD, 0x9C, 0xE8, 0xB5, 0xA8, 0xEA, 0xB8, 0xAC, 0xEA, 0xB7, 0xAC,
	0xEA, 0xBA, 0xAB, 0xEA, 0xC2, 0xB2, 0xEA, 0xC3, 0xB7, 0xEB, 0xC7, 0xB6, 0xE9, 0xB8, 0xA4, 0xDB,
	0x73, 0x6D, 0xA2, 0x2C, 0x3F, 0x58, 0x0B, 0x35, 0x52, 0x0A, 0x37, 0x72, 0x22, 0x4A, 0xB2, 0x76,
	0x7F, 0xC7, 0x8B, 0x89, 0x70, 0x26, 0x49, 0x57, 0x0E, 0x39, 0x61, 0x13, 0x39, 0x66, 0x17, 0x3C,
	0x64, 0x19, 0x3F, 0x68, 0x1D, 0x41, 0x6E, 0x23, 0x44, 0x63, 0x17, 0x3C, 0x57, 0x0D, 0x36, 0x5F,
	0x12, 0x39, 0x5F, 0x13, 0x3A, 0x50, 0x0A, 0x3B, 0x8A, 0x40, 0x5D, 0xC3, 0x76, 0x75, 0xBA, 0x6C,
	0x6E, 0xC7, 0x80, 0x7A, 0xCE, 0x89, 0x7B, 0xC8, 0x80, 0x77, 0xC6, 0x7D, 0x79, 0xC6, 0x7D, 0x7B,
	0xC8, 0x81, 0x7A, 0xCA, 0x82, 0x7A, 0xCC, 0x85, 0x7A, 0xCF, 0x88, 0x7A, 0xD1, 0x89, 0x7B, 0xD2,
	0x8A, 0x7C, 0xD2, 0x8B, 0x7C, 0xD2, 0x8B, 0x7E, 0xD1, 0x8A, 0x7E, 0xCF, 0x88, 0x7D, 0xCE, 0x88,
	0x7C, 0xCD, 0x86, 0x78, 0xCC, 0x85, 0x77, 0xCD, 0x84, 0x78, 0xCB, 0x82, 0x79, 0xCA, 0x7E, 0x76,
	0xB2, 0x44, 0x4C, 0xB0, 0x44, 0x4D, 0xAD, 0x40, 0x4C, 0xAB, 0x3F, 0x4A, 0xA6, 0x3E, 0x49, 0xA1,
	0x36, 0x45, 0xAB, 0x3C, 0x47, 0xCE, 0x5B, 0x56, 0xE1, 0x7A, 0x66, 0xE5, 0x8E, 0x6F, 0xE7, 0x95,
	0x74, 0xE9, 0x95, 0x74, 0xE9, 0x96, 0x72, 0xE9, 0x93, 0x71, 0xE3, 0x7B, 0x65, 0xC7, 0x56, 0x57,
	0x95, 0x33, 0x49, 0x8A, 0x29, 0x41, 0x9A, 0x32, 0x46, 0xA4, 0x3B, 0x4B, 0xAC, 0x40, 0x4D, 0xAD,
	0x42, 0x4E, 0xB0, 0x42, 0x4D, 0xB0, 0x41, 0x4A, 0xAD, 0x3F, 0x48, 0xAD, 0x3E, 0x49, 0xB2, 0x41,
	0x4B, 0xC4, 0x57, 0x58, 0xC3, 0x53, 0x55, 0xC0, 0x4B, 0x52, 0xC4, 0x4E, 0x52, 0xC2, 0x4E, 0x51,
	0xB5, 0x3E, 0x49, 0xD0, 0x7D, 0x71, 0xE8, 0xAD, 0x8E, 0xC4, 0x50, 0x51, 0xBB, 0x47, 0x4E, 0xBF,
	0x50, 0x57, 0xC6, 0x57, 0x5B, 0xCB, 0x60, 0x64, 0xCA, 0x60, 0x66, 0xAC, 0x46, 0x58, 0x7C, 0x29,
	0x4A, 0x61, 0x18, 0x43, 0x53, 0x0C, 0x38, 0x5B, 0x18, 0x47, 0x6D, 0x2D, 0x5B, 0x5A, 0x14, 0x40,
	0x61, 0x1C, 0x48, 0x5E, 0x18, 0x45, 0x5D, 0x16, 0x42, 0x5C, 0x15, 0x43, 0x5A, 0x15, 0x43, 0x60,
	0x1A, 0x4B, 0x7D, 0x44, 0x74, 0x77, 0x3E, 0x6E, 0x78, 0x40, 0x6D, 0x73, 0x3E, 0x6A, 0x38, 0x00,
	0x2E, 0x83, 0x3E, 0x54, 0xCB, 0x6A, 0x6A, 0xCC, 0x7C, 0x7A, 0xDE, 0xA2, 0x91, 0xDC, 0xA3, 0x95,
	0xCD, 0x98, 0x95, 0xB4, 0x8B, 0x97, 0xCB, 0x97, 0x92, 0xDA, 0xB5, 0xAA, 0xD6, 0xAA, 0xA2, 0xCD,
	0x95, 0x8E, 0xCC, 0x91, 0x8A, 0xD4, 0x80, 0x7B, 0xDD, 0x7D, 0x76, 0xE3, 0x89, 0x83, 0xE1, 0x96,
	0x8A, 0xE2, 0xAA, 0x99, 0xE5, 0xB1, 0xA2, 0xE8, 0xB4, 0xA8, 0xEA, 0xB8, 0xAB, 0xEA, 0xBB, 0xAB,
	0xEA, 0xBE, 0xAC, 0xEA, 0xC3, 0xB4, 0xEA, 0xC3, 0xB6, 0xEB, 0xC6, 0xB5, 0xEB, 0xC2, 0xAE, 0xE2,
	0x87, 0x7C, 0xB1, 0x38, 0x44, 0x67, 0x11, 0x36, 0x47, 0x03, 0x31, 0x5F, 0x13, 0x41, 0xA0, 0x64,
	0x75, 0xCC, 0x8E, 0x8B, 0x7F, 0x31, 0x50, 0x55, 0x10, 0x3D, 0x60, 0x15, 0x3D, 0x65, 0x18, 0x3D,
	0x66, 0x1C, 0x3F, 0x6C, 0x21, 0x44, 0x6E, 0x22, 0x44, 0x60, 0x14, 0x3A, 0x58, 0x0D, 0x38, 0x63,
	0x14, 0x39, 0x59, 0x10, 0x39, 0x5B, 0x15, 0x44, 0xA6, 0x5C, 0x6C, 0xC3, 0x75, 0x72, 0xBE, 0x72,
	0x70, 0xCF, 0x8A, 0x7D, 0xD1, 0x8C, 0x7C, 0xCC, 0x86, 0x78, 0xC8, 0x82, 0x79, 0xC5, 0x7F, 0x79,
	0xC4, 0x7D, 0x78, 0xC4, 0x7B, 0x79, 0xC5, 0x7F, 0x79, 0xC5, 0x7E, 0x78, 0xC6, 0x7D, 0x78, 0xC9,
	0x81, 0x7A, 0xCC, 0x85, 0x79, 0xCF, 0x89, 0x7D, 0xD0, 0x8A, 0x7F, 0xCE, 0x89, 0x7D, 0xCB, 0x88,
	0x7B, 0xCA, 0x85, 0x78, 0xCB, 0x83, 0x76, 0xCB, 0x83, 0x78, 0xCB, 0x80, 0x76, 0xCA, 0x7B, 0x73,
	0xB1, 0x43, 0x4C, 0xAE, 0x42, 0x4D, 0xAA, 0x40, 0x4C, 0xAB, 0x3D, 0x4A, 0xA4, 0x3A, 0x46, 0xA0,
	0x33, 0x43, 0xAB, 0x3B, 0x47, 0xCD, 0x5B, 0x55, 0xE0, 0x79, 0x66, 0xE6, 0x8F, 0x73, 0xE7, 0x96,
	0x74, 0xE8, 0x97, 0x73, 0xE9, 0x97, 0x73, 0xE9, 0x91, 0x70, 0xE3, 0x7B, 0x67, 0xC6, 0x56, 0x57,
	0x94, 0x31, 0x47, 0x8B, 0x2D, 0x45, 0x9A, 0x38, 0x4B, 0xA4, 0x3B, 0x4C, 0xAA, 0x3E, 0x4C, 0xAD,
	0x40, 0x4C, 0xAF, 0x40, 0x4B, 0xB1, 0x41, 0x4C, 0xAF, 0x41, 0x4C, 0xB0, 0x41, 0x4B, 0xB5, 0x45,
	0x4C, 0xBE, 0x4D, 0x53, 0xBF, 0x4D, 0x53, 0xC4, 0x4F, 0x52, 0xC7, 0x51, 0x54, 0xC6, 0x52, 0x54,
	0xC0, 0x48, 0x4F, 0xC7, 0x57, 0x57, 0xE2, 0x91, 0x75, 0xC9, 0x5B, 0x55, 0xBF, 0x49, 0x4F, 0xD0,
	0x5E, 0x5E, 0xC9, 0x63, 0x68, 0xC4, 0x65, 0x6D, 0xAD, 0x44, 0x54, 0x79, 0x1F, 0x3F, 0x60, 0x1B,
	0x4A, 0x6B, 0x2C, 0x5B, 0x54, 0x12, 0x3F, 0x51, 0x0D, 0x3C, 0x6A, 0x28, 0x56, 0x64, 0x1E, 0x4B,
	0x61, 0x1E, 0x4C, 0x61, 0x1B, 0x47, 0x5A, 0x12, 0x3F, 0x5F, 0x1B, 0x49, 0x63, 0x1E, 0x4B, 0x5A,
	0x15, 0x45, 0x6C, 0x2B, 0x5B, 0x67, 0x24, 0x55, 0x5E, 0x22, 0x4F, 0x6F, 0x3E, 0x6D, 0x7D, 0x38,
	0x56, 0xC4, 0x63, 0x63, 0xC7, 0x6F, 0x72, 0xDA, 0x91, 0x83, 0xE2, 0x9F, 0x8C, 0xDB, 0xAF, 0xA0,
	0xCE, 0xA5, 0x9E, 0xAF, 0x80, 0x8C, 0xCB, 0x9A, 0x96, 0xDB, 0xB5, 0xA9, 0xCC, 0x98, 0x90, 0xCC,
	0x87, 0x80, 0xD6, 0x7E, 0x7A, 0xDE, 0x7F, 0x7A, 0xE2, 0x8A, 0x85, 0xE2, 0x8F, 0x89, 0xE1, 0x96,
	0x89, 0xE1, 0xA6, 0x95, 0xE6, 0xB3, 0xA4, 0xE9, 0xB4, 0xA8, 0xEA, 0xB7, 0xAA, 0xEA, 0xBE, 0xAC,
	0xEA, 0xBE, 0xAC, 0xEA, 0xC3, 0xB2, 0xEA, 0xC3, 0xB6, 0xEB, 0xC4, 0xB6, 0xEC, 0xC8, 0xB4, 0xE5,
	0x9A, 0x8C, 0xC1, 0x48, 0x4E, 0x7D, 0x1B, 0x39, 0x49, 0x09, 0x38, 0x53, 0x0C, 0x3C, 0x93, 0x4F,
	0x68, 0xCF, 0x8D, 0x8A, 0x88, 0x38, 0x52, 0x55, 0x0C, 0x39, 0x60, 0x15, 0x3E, 0x65, 0x1B, 0x41,
	0x66, 0x1C, 0x41, 0x6B, 0x1F, 0x41, 0x68, 0x1D, 0x40, 0x5D, 0x12, 0x3B, 0x5D, 0x11, 0x39, 0x63,
	0x15, 0x39, 0x52, 0x0A, 0x37, 0x76, 0x2F, 0x53, 0xC0, 0x74, 0x75, 0xBF, 0x72, 0x6F, 0xC2, 0x7D,
	0x76, 0xD3, 0x8F, 0x7E, 0xD2, 0x8D, 0x7D, 0xD1, 0x8B, 0x7D, 0xCB, 0x88, 0x7C, 0xC9, 0x87, 0x7C,
	0xC9, 0x85, 0x7B, 0xC8, 0x82, 0x7B, 0xC7, 0x82, 0x78, 0xC4, 0x7D, 0x77, 0xBE, 0x79, 0x79, 0xBD,
	0x79, 0x79, 0xBF, 0x7B, 0x78, 0xC2, 0x7E, 0x7C, 0xC5, 0x7F, 0x7C, 0xC9, 0x82, 0x7A, 0xCA, 0x83,
	0x77, 0xCA, 0x83, 0x79, 0xC9, 0x81, 0x76, 0xCB, 0x84, 0x77, 0xCB, 0x7F, 0x75, 0xCC, 0x7B, 0x72,
	0xAF, 0x41, 0x4B, 0xAD, 0x41, 0x4C, 0xA9, 0x41, 0x4C, 0xA9, 0x3C, 0x48, 0xA7, 0x3C, 0x47, 0xA1,
	0x34, 0x44, 0xAB, 0x3A, 0x47, 0xCE, 0x5D, 0x58, 0xDF, 0x7B, 0x6A, 0xE5, 0x90, 0x75, 0xE8, 0x97,
	0x75, 0xE9, 0x97, 0x74, 0xE9, 0x98, 0x73, 0xE9, 0x92, 0x6F, 0xE3, 0x7B, 0x68, 0xC7, 0x54, 0x54,
	0x96, 0x2E, 0x41, 0x8C, 0x2A, 0x41, 0x9A, 0x34, 0x48, 0xA3, 0x3A, 0x4B, 0xA9, 0x3F, 0x4D, 0xAD,
	0x40, 0x4C, 0xAF, 0x41, 0x4E, 0xB2, 0x43, 0x4E, 0xB1, 0x41, 0x4D, 0xB1, 0x41, 0x4B, 0xB5, 0x45,
	0x4C, 0xBC, 0x49, 0x50, 0xC3, 0x4E, 0x52, 0xC3, 0x4E, 0x50, 0xC1, 0x4D, 0x51, 0xBC, 0x48, 0x4E,
	0xC0, 0x4E, 0x50, 0xC5, 0x55, 0x54, 0xC1, 0x57, 0x54, 0xC4, 0x55, 0x54, 0xCF, 0x56, 0x59, 0xC5,
	0x6C, 0x74, 0xB2, 0x6E, 0x7C, 0xAB, 0x5A, 0x68, 0x77, 0x25, 0x48, 0x59, 0x19, 0x4A, 0x56, 0x18,
	0x49, 0x6C, 0x2F, 0x60, 0x5F, 0x1C, 0x4A, 0x55, 0x10, 0x3E, 0x5A, 0x14, 0x42, 0x71, 0x31, 0x5F,
	0x70, 0x2D, 0x59, 0x5A, 0x11, 0x3D, 0x57, 0x0F, 0x3C, 0x62, 0x1F, 0x4D, 0x66, 0x24, 0x52, 0x5C,
	0x18, 0x47, 0x61, 0x1F, 0x4E, 0x69, 0x2A, 0x59, 0x3A, 0x00, 0x2D, 0x67, 0x2E, 0x58, 0xB6, 0x63,
	0x6E, 0xC6, 0x6A, 0x6C, 0xD4, 0x8A, 0x80, 0xDA, 0x85, 0x78, 0xD8, 0x96, 0x8B, 0xD9, 0xB0, 0xA4,
	0xD2, 0xAB, 0xA1, 0xBE, 0x8F, 0x91, 0xCF, 0xA6, 0xA0, 0xD5, 0xA2, 0x98, 0xD0, 0x86, 0x80, 0xDB,
	0x83, 0x7F, 0xDF, 0x82, 0x80, 0xE2, 0x8A, 0x85, 0xE2, 0x90, 0x8B, 0xE1, 0x93, 0x8A, 0xDF, 0x97,
	0x8B, 0xE0, 0xA0, 0x92, 0xE4, 0xAF, 0x9F, 0xE9, 0xB5, 0xA9, 0xE9, 0xB6, 0xA9, 0xE9, 0xB6, 0xA8,
	0xEA, 0xB9, 0xAA, 0xEA, 0xC1, 0xAE, 0xEA, 0xC3, 0xB3, 0xEA, 0xC3, 0xB7, 0xEC, 0xC8, 0xB9, 0xEA,
	0xAD, 0x9E, 0xD0, 0x5B, 0x5B, 0x93, 0x27, 0x3E, 0x51, 0x0C, 0x39, 0x4B, 0x08, 0x38, 0x86, 0x3C,
	0x59, 0xCE, 0x8C, 0x89, 0x91, 0x44, 0x5B, 0x59, 0x0D, 0x39, 0x60, 0x16, 0x3F, 0x68, 0x1B, 0x40,
	0x6A, 0x1F, 0x43, 0x6B, 0x21, 0x43, 0x60, 0x17, 0x3D, 0x5B, 0x10, 0x3B, 0x61, 0x15, 0x3B, 0x5C,
	0x11, 0x37, 0x58, 0x10, 0x3F, 0x99, 0x51, 0x68, 0xC2, 0x75, 0x73, 0xBE, 0x6E, 0x6F, 0xCC, 0x85,
	0x79, 0xD3, 0x8E, 0x7D, 0xD2, 0x8A, 0x7D, 0xCF, 0x8B, 0x7E, 0xCD, 0x89, 0x7C, 0xD1, 0x8C, 0x7D,
	0xD2, 0x8D, 0x7F, 0xD1, 0x8C, 0x7F, 0xCD, 0x88, 0x7B, 0xCA, 0x85, 0x79, 0xC2, 0x7F, 0x7C, 0xBC,
	0x79, 0x7A, 0xBD, 0x7A, 0x79, 0xBB, 0x79, 0x79, 0xBB, 0x77, 0x79, 0xBE, 0x76, 0x76, 0xC2, 0x79,
	0x75, 0xC5, 0x7B, 0x77, 0xC8, 0x7E, 0x78, 0xCA, 0x81, 0x77, 0xCB, 0x7F, 0x75, 0xCC, 0x7F, 0x73,
	0xAE, 0x40, 0x4B, 0xAC, 0x40, 0x4B, 0xAA, 0x3E, 0x4A, 0xAB, 0x3B, 0x46, 0xA9, 0x3A, 0x47, 0xA1,
	0x35, 0x45, 0xA8, 0x3A, 0x48, 0xCD, 0x5C, 0x5A, 0xDF, 0x7C, 0x6D, 0xE4, 0x8F, 0x75, 0xE7, 0x95,
	0x76, 0xE9, 0x96, 0x74, 0xE8, 0x97, 0x75, 0xE9, 0x93, 0x71, 0xE3, 0x7A, 0x65, 0xC9, 0x54, 0x52,
	0x97, 0x2E, 0x43, 0x8B, 0x27, 0x3F, 0x99, 0x33, 0x46, 0xA3, 0x3A, 0x4B, 0xAA, 0x40, 0x4E, 0xAC,
	0x40, 0x4E, 0xAE, 0x41, 0x4F, 0xB0, 0x41, 0x4B, 0xB0, 0x40, 0x49, 0xB1, 0x41, 0x4B, 0xB6, 0x44,
	0x4C, 0xBD, 0x48, 0x4F, 0xC4, 0x4E, 0x50, 0xC7, 0x50, 0x50, 0xC6, 0x4E, 0x4F, 0xC3, 0x4E, 0x52,
	0xD2, 0x67, 0x60, 0xBF, 0x5C, 0x5A, 0xB7, 0x55, 0x55, 0xCC, 0x66, 0x60, 0xB6, 0x5C, 0x6A, 0xB1,
	0x69, 0x79, 0xC0, 0x61, 0x69, 0x9E, 0x3D, 0x4F, 0x67, 0x25, 0x54, 0x63, 0x2A, 0x5C, 0x50, 0x11,
	0x42, 0x74, 0x3C, 0x6C, 0x5A, 0x18, 0x47, 0x56, 0x10, 0x3E, 0x6C, 0x28, 0x57, 0x78, 0x38, 0x65,
	0x61, 0x1A, 0x44, 0x53, 0x0B, 0x37, 0x5C, 0x15, 0x43, 0x60, 0x1D, 0x4A, 0x5F, 0x1F, 0x4E, 0x68,
	0x2A, 0x5A, 0x67, 0x25, 0x54, 0x5C, 0x1F, 0x4F, 0x4F, 0x11, 0x3D, 0x99, 0x46, 0x56, 0xB3, 0x5E,
	0x67, 0xD1, 0x8E, 0x84, 0xDB, 0x96, 0x86, 0xD3, 0x89, 0x7F, 0xD2, 0x8F, 0x87, 0xD7, 0xAF, 0xA5,
	0xD6, 0xB3, 0xAA, 0xD3, 0xAE, 0xA4, 0xC4, 0x88, 0x83, 0xC3, 0x68, 0x69, 0xD6, 0x75, 0x76, 0xE4,
	0x88, 0x84, 0xE7, 0x90, 0x89, 0xE5, 0x94, 0x8C, 0xE0, 0x97, 0x8D, 0xDE, 0x98, 0x8D, 0xE1, 0x95,
	0x89, 0xE2, 0x99, 0x8C, 0xE1, 0xA7, 0x96, 0xE6, 0xB2, 0xA3, 0xE7, 0xB3, 0xA5, 0xE6, 0xB0, 0xA3,
	0xEA, 0xB7, 0xA8, 0xEA, 0xBC, 0xAA, 0xEA, 0xC1, 0xAE, 0xEA, 0xC5, 0xB7, 0xED, 0xCC, 0xB8, 0xEF,
	0xBB, 0xA4, 0xD5, 0x67, 0x63, 0x8F, 0x22, 0x3C, 0x53, 0x09, 0x35, 0x4B, 0x07, 0x35, 0x76, 0x2B,
	0x4E, 0xC6, 0x87, 0x89, 0xA1, 0x55, 0x65, 0x64, 0x15, 0x3E, 0x66, 0x1D, 0x46, 0x65, 0x1E, 0x43,
	0x6B, 0x22, 0x45, 0x6B, 0x21, 0x43, 0x5E, 0x14, 0x3B, 0x5B, 0x13, 0x3D, 0x61, 0x16, 0x3C, 0x54,
	0x0E, 0x39, 0x6A, 0x24, 0x4F, 0xB3, 0x68, 0x74, 0xBD, 0x6E, 0x70, 0xBF, 0x71, 0x72, 0xD1, 0x8A,
	0x7B, 0xD2, 0x8C, 0x7B, 0xD1, 0x8B, 0x7D, 0xCF, 0x89, 0x7D, 0xCD, 0x89, 0x7B, 0xD1, 0x8B, 0x7B,
	0xD3, 0x8F, 0x7E, 0xD2, 0x90, 0x82, 0xD0, 0x8C, 0x7F, 0xCD, 0x89, 0x7B, 0xC9, 0x85, 0x7B, 0xC4,
	0x7F, 0x7A, 0xC1, 0x7C, 0x79, 0xBC, 0x7A, 0x78, 0xBA, 0x78, 0x78, 0xBC, 0x76, 0x78, 0xBB, 0x76,
	0x79, 0xBC, 0x75, 0x77, 0xBD, 0x78, 0x78, 0xC3, 0x78, 0x78, 0xC7, 0x78, 0x72, 0xC9, 0x7D, 0x75,
	0xAD, 0x40, 0x4B, 0xAB, 0x3F, 0x4C, 0xAA, 0x3E, 0x4B, 0xAE, 0x3E, 0x48, 0xAC, 0x3C, 0x48, 0xA2,
	0x35, 0x45, 0xA8, 0x3A, 0x46, 0xCC, 0x5B, 0x58, 0xDF, 0x7B, 0x6B, 0xE4, 0x8D, 0x73, 0xE7, 0x96,
	0x77, 0xE9, 0x97, 0x78, 0xE9, 0x97, 0x75, 0xE9, 0x92, 0x70, 0xE3, 0x7D, 0x66, 0xCA, 0x55, 0x52,
	0x94, 0x2D, 0x44, 0x88, 0x29, 0x43, 0x99, 0x34, 0x49, 0xA2, 0x39, 0x49, 0xAA, 0x3F, 0x4D, 0xAE,
	0x42, 0x4E, 0xAC, 0x41, 0x4F, 0xAD, 0x41, 0x4D, 0xAE, 0x40, 0x4C, 0xB0, 0x41, 0x4B, 0xB5, 0x43,
	0x4B, 0xBF, 0x4A, 0x4E, 0xC5, 0x50, 0x50, 0xC7, 0x51, 0x51, 0xC5, 0x49, 0x4F, 0xD9, 0x7E, 0x71,
	0xD0, 0x7D, 0x6D, 0x7E, 0x22, 0x3C, 0x61, 0x10, 0x35, 0xA2, 0x57, 0x65, 0xC8, 0x8E, 0x8C, 0xC2,
	0x59, 0x5E, 0xAE, 0x3A, 0x46, 0x75, 0x21, 0x46, 0x70, 0x3B, 0x6D, 0x5A, 0x1D, 0x4E, 0x5E, 0x22,
	0x52, 0x7A, 0x46, 0x74, 0x51, 0x0C, 0x39, 0x5B, 0x13, 0x3F, 0x67, 0x20, 0x4E, 0x61, 0x19, 0x45,
	0x54, 0x0D, 0x38, 0x56, 0x11, 0x3C, 0x60, 0x1A, 0x47, 0x63, 0x21, 0x4F, 0x62, 0x22, 0x51, 0x6D,
	0x2F, 0x5F, 0x5F, 0x1F, 0x4F, 0x4A, 0x0C, 0x3E, 0x8C, 0x43, 0x56, 0xBE, 0x5D, 0x62, 0xCF, 0x85,
	0x7C, 0xE2, 0xA0, 0x8A, 0xDB, 0xA4, 0x94, 0xCF, 0x8A, 0x81, 0xD0, 0x8E, 0x88, 0xDB, 0xBB, 0xB1,
	0xDC, 0xBD, 0xB0, 0xC6, 0x83, 0x80, 0xAA, 0x46, 0x53, 0xAD, 0x40, 0x4F, 0xB1, 0x49, 0x57, 0xAF,
	0x4B, 0x59, 0xBF, 0x5B, 0x65, 0xD8, 0x7D, 0x7C, 0xE5, 0x99, 0x8E, 0xE1, 0x9D, 0x90, 0xE1, 0x95,
	0x8B, 0xE3, 0x94, 0x86, 0xE2, 0x9D, 0x8B, 0xE3, 0xAD, 0x9C, 0xE4, 0xAF, 0xA0, 0xE3, 0xAC, 0x9C,
	0xE5, 0xB0, 0xA0, 0xE9, 0xB6, 0xA8, 0xEC, 0xC3, 0xAD, 0xF0, 0xCE, 0xB2, 0xED, 0xBD, 0xA5, 0xE1,
	0x92, 0x7F, 0xB3, 0x47, 0x50, 0x6F, 0x12, 0x36, 0x54, 0x07, 0x32, 0x4F, 0x07, 0x35, 0x69, 0x1E,
	0x48, 0xBB, 0x80, 0x84, 0xB0, 0x68, 0x71, 0x67, 0x16, 0x40, 0x67, 0x1E, 0x46, 0x65, 0x1F, 0x44,
	0x6C, 0x24, 0x47, 0x68, 0x1E, 0x42, 0x5C, 0x11, 0x3A, 0x5D, 0x14, 0x3C, 0x60, 0x15, 0x3C, 0x53,
	0x0D, 0x3C, 0x82, 0x3A, 0x5B, 0xBE, 0x72, 0x75, 0xB9, 0x6B, 0x6E, 0xC5, 0x7B, 0x75, 0xD3, 0x8C,
	0x7C, 0xD0, 0x89, 0x79, 0xCF, 0x88, 0x79, 0xCF, 0x88, 0x79, 0xCD, 0x88, 0x78, 0xCD, 0x88, 0x79,
	0xCF, 0x8A, 0x7C, 0xD0, 0x8C, 0x7D, 0xD1, 0x8C, 0x7D, 0xCD, 0x88, 0x7A, 0xC9, 0x86, 0x79, 0xCA,
	0x86, 0x7A, 0xC6, 0x83, 0x7A, 0xC2, 0x80, 0x7B, 0xC1, 0x7E, 0x7C, 0xC1, 0x7C, 0x7D, 0xBC, 0x7B,
	0x7B, 0xB8, 0x77, 0x77, 0xB9, 0x76, 0x78, 0xBA, 0x75, 0x78, 0xBA, 0x73, 0x75, 0xBB, 0x72, 0x74,
	0xAE, 0x41, 0x4C, 0xAD, 0x41, 0x4E, 0xAD, 0x41, 0x4C, 0xAD, 0x40, 0x4B, 0xAD, 0x3E, 0x49, 0xA2,
	0x37, 0x46, 0xA7, 0x37, 0x46, 0xCC, 0x59, 0x56, 0xDF, 0x7A, 0x6A, 0xE6, 0x8F, 0x71, 0xE9, 0x97,
	0x75, 0xEA, 0x97, 0x7A, 0xEA, 0x98, 0x79, 0xEA, 0x93, 0x72, 0xE4, 0x7E, 0x66, 0xC8, 0x56, 0x53,
	0x93, 0x2E, 0x43, 0x8A, 0x2C, 0x45, 0x99, 0x35, 0x49, 0xA4, 0x3A, 0x4A, 0xAB, 0x3F, 0x4E, 0xAF,
	0x43, 0x4F, 0xAD, 0x40, 0x4C, 0xAC, 0x3F, 0x4C, 0xAE, 0x3F, 0x4C, 0xB1, 0x40, 0x49, 0xB4, 0x43,
	0x4B, 0xBC, 0x48, 0x4E, 0xC1, 0x4B, 0x4E, 0xC4, 0x50, 0x54, 0xCB, 0x5A, 0x5E, 0xE3, 0x81, 0x6D,
	0xB8, 0x5F, 0x5D, 0x51, 0x00, 0x30, 0x3F, 0x00, 0x36, 0xA2, 0x60, 0x6F, 0xD6, 0x7B, 0x70, 0xA5,
	0x3B, 0x49, 0x79, 0x1F, 0x3F, 0x69, 0x29, 0x59, 0x70, 0x37, 0x68, 0x56, 0x15, 0x47, 0x74, 0x3C,
	0x6C, 0x7A, 0x45, 0x71, 0x4E, 0x0C, 0x3A, 0x5C, 0x17, 0x45, 0x61, 0x1E, 0x4C, 0x61, 0x23, 0x50,
	0x61, 0x1D, 0x49, 0x54, 0x0C, 0x37, 0x52, 0x0D, 0x3A, 0x68, 0x2A, 0x59, 0x74, 0x3A, 0x69, 0x69,
	0x2B, 0x59, 0x48, 0x0A, 0x3E, 0x6D, 0x2A, 0x49, 0xBE, 0x64, 0x66, 0xC7, 0x78, 0x77, 0xDE, 0x9B,
	0x87, 0xDF, 0xAB, 0x99, 0xD8, 0xA7, 0x98, 0xCA, 0x84, 0x7F, 0xD6, 0xAD, 0xA4, 0xDC, 0xBA, 0xAC,
	0xD1, 0x80, 0x7A, 0xD0, 0x60, 0x62, 0xD5, 0x6E, 0x6E, 0xD6, 0x75, 0x73, 0xCB, 0x66, 0x68, 0xA7,
	0x3D, 0x4D, 0x8C, 0x25, 0x3D, 0x90, 0x2C, 0x42, 0xB3, 0x53, 0x5D, 0xDB, 0x86, 0x7E, 0xE3, 0x96,
	0x8A, 0xE3, 0x8F, 0x86, 0xE4, 0x97, 0x87, 0xE3, 0xAA, 0x97, 0xE2, 0xAD, 0x9D, 0xE2, 0xAB, 0x9A,
	0xE3, 0xAC, 0x9C, 0xE7, 0xB3, 0x9E, 0xE5, 0xAA, 0x93, 0xD1, 0x88, 0x78, 0xB8, 0x60, 0x63, 0xAB,
	0x47, 0x55, 0xA4, 0x3B, 0x4C, 0x8C, 0x25, 0x3D, 0x63, 0x0E, 0x33, 0x4F, 0x0A, 0x37, 0x5D, 0x14,
	0x40, 0xB0, 0x74, 0x7C, 0xBF, 0x79, 0x7D, 0x66, 0x19, 0x42, 0x66, 0x1C, 0x43, 0x70, 0x25, 0x47,
	0x6D, 0x21, 0x43, 0x60, 0x17, 0x3D, 0x5A, 0x12, 0x3C, 0x60, 0x15, 0x3C, 0x60, 0x17, 0x3E, 0x5B,
	0x13, 0x42, 0x98, 0x4E, 0x66, 0xBE, 0x73, 0x74, 0xB8, 0x6B, 0x70, 0xCD, 0x84, 0x79, 0xD4, 0x8D,
	0x7A, 0xD1, 0x88, 0x78, 0xCE, 0x87, 0x78, 0xCE, 0x87, 0x78, 0xCD, 0x85, 0x76, 0xCB, 0x85, 0x78,
	0xCB, 0x86, 0x79, 0xCC, 0x88, 0x7C, 0xCE, 0x8A, 0x7C, 0xCB, 0x87, 0x79, 0xC8, 0x84, 0x79, 0xC8,
	0x84, 0x78, 0xC8, 0x84, 0x78, 0xC8, 0x85, 0x7B, 0xC8, 0x87, 0x80, 0xC6, 0x85, 0x81, 0xC2, 0x81,
	0x7E, 0xBD, 0x7B, 0x7B, 0xBA, 0x78, 0x79, 0xB6, 0x75, 0x77, 0xB4, 0x6F, 0x77, 0xB3, 0x6C, 0x74,
	0xAD, 0x40, 0x4B, 0xAD, 0x42, 0x4F, 0xAE, 0x44, 0x51, 0xAD, 0x41, 0x4C, 0xAC, 0x3D, 0x47, 0xA0,
	0x33, 0x43, 0xA7, 0x36, 0x45, 0xCC, 0x58, 0x56, 0xDF, 0x78, 0x67, 0xE7, 0x8E, 0x70, 0xEA, 0x97,
	0x74, 0xE9, 0x95, 0x75, 0xEA, 0x98, 0x76, 0xE9, 0x95, 0x73, 0xE4, 0x7F, 0x69, 0xC9, 0x59, 0x56,
	0x96, 0x30, 0x43, 0x8B, 0x2A, 0x42, 0x9A, 0x35, 0x47, 0xA5, 0x3D, 0x4B, 0xAD, 0x42, 0x4F, 0xAF,
	0x42, 0x4D, 0xAE, 0x40, 0x4A, 0xAD, 0x3D, 0x49, 0xAD, 0x3C, 0x48, 0xB0, 0x3F, 0x48, 0xB3, 0x42,
	0x49, 0xB5, 0x3D, 0x48, 0xB5, 0x43, 0x50, 0xC9, 0x5F, 0x61, 0xDA, 0x7B, 0x73, 0xDE, 0x74, 0x68,
	0xCC, 0x73, 0x67, 0xA2, 0x59, 0x62, 0x89, 0x43, 0x5E, 0xAC, 0x55, 0x63, 0xAC, 0x42, 0x4E, 0x70,
	0x1E, 0x3F, 0x66, 0x20, 0x4C, 0x79, 0x41, 0x75, 0x6B, 0x2C, 0x5D, 0x6F, 0x32, 0x62, 0x66, 0x2C,
	0x5C, 0x6B, 0x30, 0x5E, 0x5D, 0x1E, 0x4E, 0x5F, 0x1C, 0x4A, 0x57, 0x13, 0x41, 0x61, 0x23, 0x52,
	0x74, 0x37, 0x63, 0x50, 0x06, 0x31, 0x52, 0x06, 0x2F, 0x58, 0x11, 0x3D, 0x6A, 0x2B, 0x58, 0x57,
	0x18, 0x49, 0x51, 0x0E, 0x3C, 0xA9, 0x54, 0x5D, 0xCD, 0x7C, 0x77, 0xDC, 0x9A, 0x89, 0xDE, 0xA1,
	0x8F, 0xDB, 0xB9, 0xAA, 0xD2, 0x9A, 0x91, 0xD6, 0xA0, 0x97, 0xD7, 0xB0, 0xA3, 0xC1, 0x66, 0x64,
	0xBF, 0x43, 0x4A, 0xC9, 0x55, 0x57, 0xBF, 0x52, 0x58, 0xB6, 0x51, 0x59, 0xCC, 0x66, 0x65, 0xB8,
	0x4A, 0x54, 0xB2, 0x44, 0x50, 0xA2, 0x37, 0x48, 0x9E, 0x2F, 0x43, 0xC4, 0x53, 0x5A, 0xDF, 0x80,
	0x7A, 0xE0, 0x87, 0x80, 0xE3, 0x8E, 0x83, 0xE3, 0xA6, 0x96, 0xE4, 0xB0, 0xA0, 0xE3, 0xAE, 0x9E,
	0xE5, 0xAE, 0x9D, 0xE5, 0x98, 0x8A, 0xC8, 0x65, 0x65, 0xA4, 0x3C, 0x4B, 0x96, 0x32, 0x47, 0xA0,
	0x3D, 0x4F, 0xB0, 0x43, 0x4F, 0x9F, 0x30, 0x41, 0x74, 0x1B, 0x3B, 0x51, 0x0C, 0x38, 0x59, 0x11,
	0x3F, 0xAB, 0x6B, 0x77, 0xC4, 0x7E, 0x7E, 0x70, 0x1F, 0x43, 0x60, 0x17, 0x41, 0x6F, 0x24, 0x48,
	0x6C, 0x20, 0x41, 0x5D, 0x13, 0x3B, 0x5D, 0x13, 0x3B, 0x61, 0x16, 0x3B, 0x5B, 0x13, 0x3C, 0x6B,
	0x22, 0x4C, 0xAC, 0x63, 0x70, 0xBB, 0x6E, 0x71, 0xC0, 0x71, 0x70, 0xD2, 0x8A, 0x7A, 0xD3, 0x8A,
	0x79, 0xD2, 0x86, 0x77, 0xD0, 0x86, 0x77, 0xCF, 0x86, 0x76, 0xCD, 0x83, 0x76, 0xCC, 0x83, 0x75,
	0xCB, 0x84, 0x76, 0xCD, 0x87, 0x78, 0xCE, 0x88, 0x78, 0xCB, 0x86, 0x76, 0xCB, 0x84, 0x76, 0xC9,
	0x82, 0x77, 0xC8, 0x82, 0x77, 0xC7, 0x85, 0x7A, 0xC9, 0x88, 0x7C, 0xC9, 0x89, 0x80, 0xC6, 0x85,
	0x80, 0xC3, 0x7E, 0x7D, 0xBF, 0x7E, 0x7C, 0xB8, 0x78, 0x7A, 0xB3, 0x71, 0x77, 0xB1, 0x6E, 0x77,
	0xAA, 0x40, 0x4B, 0xAB, 0x42, 0x4E, 0xAB, 0x41, 0x4F, 0xAA, 0x3E, 0x4A, 0xA8, 0x3C, 0x47, 0x9C,
	0x30, 0x41, 0xA4, 0x33, 0x43, 0xCC, 0x59, 0x55, 0xDF, 0x79, 0x68, 0xE7, 0x8E, 0x70, 0xE9, 0x97,
	0x72, 0xEA, 0x99, 0x74, 0xEA, 0x99, 0x74, 0xE8, 0x92, 0x72, 0xE3, 0x7F, 0x6A, 0xCC, 0x5B, 0x57,
	0x99, 0x30, 0x43, 0x8A, 0x25, 0x3D, 0x9A, 0x30, 0x42, 0xA2, 0x39, 0x48, 0xAB, 0x40, 0x4A, 0xB1,
	0x41, 0x4A, 0xB0, 0x3E, 0x47, 0xAF, 0x3D, 0x46, 0xAF, 0x3B, 0x46, 0xAD, 0x39, 0x44, 0xAB, 0x38,
	0x46, 0xB4, 0x58, 0x63, 0xC5, 0x76, 0x75, 0xD5, 0x71, 0x67, 0xDC, 0x7C, 0x6E, 0xDF, 0x7E, 0x70,
	0xDE, 0x81, 0x6C, 0xD4, 0x79, 0x6F, 0xB7, 0x60, 0x68, 0x70, 0x1B, 0x3C, 0x61, 0x19, 0x42, 0x64,
	0x2A, 0x5A, 0x79, 0x43, 0x75, 0x7F, 0x49, 0x7A, 0x6D, 0x2E, 0x60, 0x80, 0x49, 0x7A, 0x57, 0x1B,
	0x4B, 0x5E, 0x1E, 0x4C, 0x67, 0x26, 0x54, 0x64, 0x25, 0x53, 0x54, 0x10, 0x3E, 0x4D, 0x0A, 0x39,
	0x76, 0x3D, 0x6D, 0x6B, 0x30, 0x5E, 0x55, 0x0B, 0x34, 0x58, 0x09, 0x30, 0x50, 0x08, 0x34, 0x43,
	0x03, 0x35, 0x88, 0x3B, 0x52, 0xC9, 0x70, 0x70, 0xD4, 0x96, 0x86, 0xDD, 0x9E, 0x8A, 0xDF, 0xB4,
	0xA4, 0xDC, 0xBA, 0xAC, 0xDD, 0xAF, 0xA2, 0xD4, 0xA1, 0x94, 0xA4, 0x48, 0x53, 0x8D, 0x1C, 0x34,
	0x85, 0x21, 0x3B, 0x7C, 0x1C, 0x39, 0x71, 0x14, 0x34, 0x69, 0x10, 0x34, 0x6F, 0x12, 0x35, 0x61,
	0x08, 0x30, 0x87, 0x28, 0x43, 0xC3, 0x56, 0x5E, 0xD3, 0x5B, 0x5D, 0xCD, 0x53, 0x59, 0xD7, 0x68,
	0x6A, 0xDC, 0x7B, 0x74, 0xE0, 0x87, 0x7E, 0xE3, 0xA6, 0x98, 0xE8, 0xB5, 0xA8, 0xEA, 0xBA, 0xAA,
	0xE9, 0xA8, 0x93, 0xC2, 0x60, 0x63, 0x8F, 0x30, 0x46, 0x7A, 0x1C, 0x39, 0x6B, 0x10, 0x33, 0x70,
	0x16, 0x36, 0x77, 0x1C, 0x3B, 0x7E, 0x1F, 0x3C, 0x70, 0x19, 0x3B, 0x51, 0x09, 0x35, 0x5C, 0x11,
	0x3D, 0xA9, 0x65, 0x72, 0xC6, 0x81, 0x82, 0x7B, 0x2A, 0x4B, 0x63, 0x17, 0x40, 0x6E, 0x23, 0x46,
	0x64, 0x19, 0x3D, 0x5C, 0x10, 0x39, 0x5E, 0x12, 0x3B, 0x60, 0x16, 0x3D, 0x4F, 0x0A, 0x37, 0x7A,
	0x31, 0x52, 0xBD, 0x71, 0x74, 0xBB, 0x6B, 0x6D, 0xC7, 0x7B, 0x74, 0xD3, 0x8A, 0x7A, 0xD2, 0x88,
	0x79, 0xD1, 0x85, 0x76, 0xCD, 0x82, 0x74, 0xCE, 0x83, 0x74, 0xCE, 0x84, 0x75, 0xCD, 0x82, 0x74,
	0xCC, 0x84, 0x77, 0xCC, 0x85, 0x76, 0xCE, 0x87, 0x76, 0xCC, 0x84, 0x75, 0xCA, 0x82, 0x76, 0xC9,
	0x82, 0x76, 0xC8, 0x82, 0x77, 0xC6, 0x82, 0x7A, 0xC9, 0x85, 0x7C, 0xC9, 0x87, 0x7E, 0xC3, 0x84,
	0x7E, 0xBF, 0x7C, 0x7B, 0xBE, 0x7C, 0x7B, 0xBA, 0x7A, 0x7A, 0xB6, 0x76, 0x78, 0xB0, 0x71, 0x78,
	0xA6, 0x3C, 0x48, 0xA5, 0x3C, 0x48, 0xA5, 0x3A, 0x49, 0xA5, 0x38, 0x47, 0xA1, 0x37, 0x45, 0x94,
	0x2C, 0x40, 0x9B, 0x2D, 0x40, 0xC7, 0x54, 0x52, 0xE0, 0x79, 0x66, 0xE7, 0x8F, 0x71, 0xEA, 0x98,
	0x73, 0xEA, 0x99, 0x75, 0xEA, 0x99, 0x77, 0xE9, 0x91, 0x6F, 0xE3, 0x7B, 0x64, 0xCB, 0x58, 0x54,
	0x96, 0x2E, 0x42, 0x8A, 0x23, 0x3C, 0x9B, 0x2E, 0x41, 0xA1, 0x35, 0x44, 0xA8, 0x3A, 0x46, 0xAF,
	0x3D, 0x47, 0xAF, 0x39, 0x45, 0xAC, 0x39, 0x45, 0xA9, 0x37, 0x45, 0xA1, 0x2B, 0x3E, 0xB3, 0x51,
	0x5B, 0xE1, 0xAE, 0x91, 0xE4, 0x90, 0x72, 0xD7, 0x64, 0x58, 0xE0, 0x7A, 0x65, 0xDB, 0x79, 0x6D,
	0xC1, 0x66, 0x6D, 0x89, 0x32, 0x50, 0x65, 0x17, 0x3C, 0x47, 0x08, 0x39, 0x67, 0x34, 0x67, 0x76,
	0x3C, 0x6D, 0x74, 0x3C, 0x6B, 0x6D, 0x33, 0x62, 0x79, 0x40, 0x72, 0x82, 0x50, 0x80, 0x57, 0x1C,
	0x4C, 0x57, 0x15, 0x42, 0x5F, 0x1E, 0x4C, 0x6E, 0x34, 0x61, 0x5E, 0x1D, 0x49, 0x48, 0x02, 0x2E,
	0x5A, 0x1A, 0x49, 0x7C, 0x47, 0x78, 0x6B, 0x2C, 0x5A, 0x5E, 0x10, 0x39, 0x45, 0x00, 0x2E, 0x5E,
	0x1D, 0x42, 0xB6, 0x60, 0x64, 0xD3, 0x8C, 0x82, 0xE0, 0xA0, 0x87, 0xDA, 0xA1, 0x90, 0xDE, 0xBC,
	0xAE, 0xE1, 0xC1, 0xB0, 0xD4, 0xA5, 0x97, 0x9E, 0x42, 0x4F, 0x75, 0x0D, 0x2F, 0x64, 0x0D, 0x34,
	0x5F, 0x0D, 0x34, 0x5C, 0x0B, 0x33, 0x56, 0x06, 0x33, 0x72, 0x26, 0x4A, 0x9B, 0x5E, 0x70, 0x72,
	0x2B, 0x4B, 0x4B, 0x00, 0x2A, 0x8C, 0x2C, 0x45, 0xD3, 0x5E, 0x5F, 0xD7, 0x5B, 0x5E, 0xD9, 0x63,
	0x64, 0xDC, 0x70, 0x6D, 0xDF, 0x83, 0x7A, 0xE4, 0xA7, 0x99, 0xED, 0xC5, 0xB4, 0xEB, 0xBC, 0xA4,
	0xA9, 0x55, 0x5B, 0x61, 0x0F, 0x36, 0x5A, 0x11, 0x3E, 0x7D, 0x34, 0x54, 0x83, 0x35, 0x4F, 0x60,
	0x0D, 0x34, 0x63, 0x12, 0x37, 0x6E, 0x18, 0x3A, 0x64, 0x10, 0x36, 0x55, 0x09, 0x35, 0x5C, 0x0F,
	0x3A, 0xA5, 0x5F, 0x6C, 0xC7, 0x82, 0x81, 0x80, 0x2F, 0x4E, 0x69, 0x1D, 0x45, 0x6D, 0x22, 0x46,
	0x61, 0x14, 0x3A, 0x5B, 0x0E, 0x38, 0x5F, 0x13, 0x3B, 0x5C, 0x14, 0x3D, 0x52, 0x0D, 0x3C, 0x95,
	0x45, 0x5D, 0xC7, 0x76, 0x74, 0xBF, 0x71, 0x71, 0xCF, 0x86, 0x78, 0xD2, 0x89, 0x77, 0xCF, 0x86,
	0x77, 0xCD, 0x83, 0x75, 0xCB, 0x81, 0x74, 0xCC, 0x81, 0x75, 0xCD, 0x82, 0x74, 0xCC, 0x82, 0x75,
	0xCC, 0x82, 0x75, 0xCC, 0x85, 0x77, 0xCD, 0x85, 0x76, 0xCB, 0x82, 0x75, 0xC9, 0x81, 0x75, 0xCA,
	0x83, 0x77, 0xC8, 0x81, 0x78, 0xC6, 0x7F, 0x7A, 0xC5, 0x80, 0x7D, 0xC3, 0x80, 0x7C, 0xBF, 0x7C,
	0x7B, 0xBB, 0x79, 0x79, 0xB7, 0x76, 0x78, 0xB5, 0x74, 0x78, 0xB2, 0x73, 0x78, 0xB0, 0x6E, 0x77,
	0xA8, 0x3D, 0x49, 0xA4, 0x3C, 0x48, 0xA3, 0x3A, 0x47, 0xA3, 0x38, 0x46, 0x9B, 0x33, 0x43, 0x90,
	0x28, 0x3E, 0x97, 0x2A, 0x3F, 0xC6, 0x53, 0x51, 0xE1, 0x7B, 0x64, 0xE8, 0x92, 0x72, 0xE9, 0x99,
	0x77, 0xE9, 0x98, 0x76, 0xEA, 0x9B, 0x77, 0xE8, 0x96, 0x75, 0xE2, 0x7C, 0x65, 0xCB, 0x56, 0x52,
	0x98, 0x2E, 0x41, 0x8F, 0x24, 0x3C, 0xA0, 0x33, 0x44, 0xA7, 0x3B, 0x48, 0xAC, 0x3C, 0x47, 0xAC,
	0x3A, 0x47, 0xAD, 0x3B, 0x47, 0xAD, 0x3C, 0x48, 0xAC, 0x39, 0x46, 0x9B, 0x26, 0x3C, 0xAD, 0x55,
	0x5C, 0xE0, 0xA5, 0x87, 0xD6, 0x7E, 0x6F, 0xD7, 0x6B, 0x64, 0xE3, 0x7A, 0x65, 0xCE, 0x68, 0x65,
	0xAB, 0x4D, 0x5B, 0x62, 0x15, 0x3D, 0x4E, 0x0F, 0x41, 0x6B, 0x32, 0x63, 0x6A, 0x2D, 0x5B, 0x68,
	0x28, 0x57, 0x57, 0x16, 0x46, 0x5F, 0x22, 0x54, 0x89, 0x57, 0x87, 0x7C, 0x47, 0x75, 0x53, 0x14,
	0x41, 0x51, 0x0E, 0x39, 0x50, 0x0A, 0x38, 0x68, 0x2D, 0x5A, 0x70, 0x34, 0x5F, 0x54, 0x0A, 0x35,
	0x53, 0x0A, 0x35, 0x5B, 0x16, 0x3E, 0x60, 0x1F, 0x4A, 0x57, 0x16, 0x44, 0x4E, 0x0D, 0x3F, 0x93,
	0x43, 0x59, 0xC6, 0x76, 0x75, 0xD9, 0x9A, 0x89, 0xDB, 0x9A, 0x88, 0xDB, 0xB1, 0xA5, 0xE2, 0xC9,
	0xB9, 0xDA, 0xB5, 0xA3, 0xAF, 0x55, 0x5A, 0x8A, 0x1B, 0x34, 0x63, 0x0C, 0x32, 0x69, 0x14, 0x38,
	0x83, 0x2B, 0x46, 0x6E, 0x1F, 0x43, 0x63, 0x13, 0x3D, 0x82, 0x38, 0x58, 0xD9, 0xB9, 0xB1, 0xD2,
	0xAC, 0xA7, 0x8B, 0x38, 0x51, 0x90, 0x28, 0x40, 0xBD, 0x48, 0x50, 0xCD, 0x53, 0x59, 0xD5, 0x5D,
	0x61, 0xDA, 0x6A, 0x68, 0xDF, 0x80, 0x78, 0xE7, 0xAF, 0xA1, 0xF4, 0xD5, 0xB8, 0xC9, 0x81, 0x75,
	0x6B, 0x11, 0x37, 0x54, 0x0D, 0x3B, 0x68, 0x1C, 0x47, 0x99, 0x5E, 0x78, 0xC5, 0x81, 0x83, 0x81,
	0x24, 0x40, 0x5B, 0x08, 0x32, 0x63, 0x11, 0x37, 0x5F, 0x0F, 0x37, 0x59, 0x0E, 0x38, 0x5F, 0x13,
	0x3E, 0x9E, 0x5A, 0x6B, 0xC7, 0x83, 0x82, 0x88, 0x36, 0x53, 0x73, 0x28, 0x4D, 0x6D, 0x21, 0x45,
	0x60, 0x11, 0x38, 0x5D, 0x10, 0x37, 0x5E, 0x15, 0x3B, 0x54, 0x0E, 0x3A, 0x63, 0x1C, 0x48, 0xB1,
	0x61, 0x6D, 0xC8, 0x75, 0x73, 0xC4, 0x78, 0x74, 0xD2, 0x89, 0x79, 0xD0, 0x87, 0x77, 0xCF, 0x86,
	0x77, 0xCC, 0x83, 0x76, 0xCB, 0x80, 0x74, 0xCB, 0x80, 0x73, 0xCB, 0x80, 0x73, 0xCC, 0x80, 0x74,
	0xCB, 0x80, 0x75, 0xCA, 0x80, 0x75, 0xCB, 0x81, 0x75, 0xCA, 0x81, 0x75, 0xC9, 0x81, 0x75, 0xC9,
	0x81, 0x76, 0xC7, 0x7E, 0x77, 0xC3, 0x7B, 0x79, 0xC2, 0x7C, 0x7A, 0xBB, 0x7A, 0x7B, 0xB9, 0x78,
	0x78, 0xB6, 0x75, 0x76, 0xB2, 0x6F, 0x74, 0xAD, 0x6B, 0x76, 0xA7, 0x69, 0x78, 0xAA, 0x6C, 0x79,
	0xAB, 0x3F, 0x4B, 0xA6, 0x3D, 0x49, 0xA7, 0x3D, 0x48, 0xA1, 0x39, 0x47, 0x9A, 0x35, 0x43, 0x8E,
	0x26, 0x3D, 0x94, 0x27, 0x3E, 0xC6, 0x52, 0x51, 0xE0, 0x78, 0x65, 0xE7, 0x91, 0x72, 0xE9, 0x9A,
	0x76, 0xEA, 0x9A, 0x76, 0xEA, 0x9D, 0x79, 0xE9, 0x97, 0x79, 0xE2, 0x7E, 0x66, 0xCC, 0x56, 0x51,
	0x9E, 0x31, 0x43, 0x91, 0x28, 0x3E, 0xA3, 0x36, 0x45, 0xAE, 0x3F, 0x49, 0xB3, 0x40, 0x48, 0xB1,
	0x3F, 0x48, 0xB0, 0x40, 0x4B, 0xB8, 0x46, 0x4D, 0xA6, 0x39, 0x46, 0x76, 0x14, 0x35, 0x78, 0x2B,
	0x4B, 0xAB, 0x69, 0x75, 0xCF, 0x97, 0x8A, 0xFA, 0xC4, 0xA0, 0xD1, 0x78, 0x6E, 0x7F, 0x27, 0x43,
	0x5A, 0x0E, 0x35, 0x4B, 0x08, 0x3A, 0x71, 0x35, 0x65, 0x71, 0x30, 0x60, 0x5E, 0x1D, 0x4C, 0x69,
	0x2A, 0x5A, 0x62, 0x20, 0x51, 0x74, 0x3C, 0x6C, 0x8A, 0x5B, 0x89, 0x7F, 0x4B, 0x77, 0x55, 0x13,
	0x40, 0x55, 0x0F, 0x3A, 0x53, 0x0D, 0x3A, 0x5C, 0x1A, 0x48, 0x71, 0x30, 0x5C, 0x5B, 0x11, 0x3D,
	0x57, 0x0E, 0x38, 0x59, 0x0F, 0x35, 0x50, 0x08, 0x32, 0x43, 0x05, 0x37, 0x6C, 0x2A, 0x51, 0xA5,
	0x56, 0x67, 0xC4, 0x83, 0x82, 0xD4, 0x95, 0x87, 0xD6, 0xA7, 0x9D, 0xE0, 0xC6, 0xB9, 0xDC, 0xB9,
	0xA7, 0xBD, 0x69, 0x69, 0xB9, 0x45, 0x4F, 0xBA, 0x4C, 0x56, 0x8E, 0x2B, 0x43, 0x7B, 0x1A, 0x39,
	0xA8, 0x48, 0x58, 0x8C, 0x3F, 0x5A, 0x75, 0x2C, 0x52, 0x9E, 0x6F, 0x87, 0xE6, 0xD1, 0xC3, 0xF2,
	0xCA, 0xB8, 0xCF, 0x6D, 0x6E, 0xBB, 0x3F, 0x4A, 0xBF, 0x46, 0x4E, 0xC4, 0x4C, 0x55, 0xD1, 0x57,
	0x5D, 0xD9, 0x66, 0x67, 0xE0, 0x8A, 0x80, 0xEB, 0xC4, 0xAF, 0xEA, 0xC4, 0xA7, 0xB7, 0x53, 0x5A,
	0x95, 0x3F, 0x57, 0x80, 0x37, 0x56, 0x79, 0x2F, 0x56, 0xA3, 0x73, 0x86, 0xDB, 0x92, 0x8E, 0x98,
	0x30, 0x45, 0x5B, 0x06, 0x2F, 0x5E, 0x0B, 0x33, 0x5B, 0x0D, 0x35, 0x58, 0x0F, 0x39, 0x63, 0x18,
	0x44, 0x98, 0x53, 0x6A, 0xC8, 0x89, 0x87, 0x89, 0x3C, 0x5A, 0x7B, 0x2F, 0x54, 0x67, 0x1C, 0x41,
	0x5C, 0x11, 0x39, 0x5E, 0x14, 0x3B, 0x61, 0x16, 0x3A, 0x51, 0x0A, 0x36, 0x77, 0x2D, 0x50, 0xBE,
	0x71, 0x73, 0xC2, 0x73, 0x72, 0xC7, 0x7D, 0x76, 0xCF, 0x88, 0x77, 0xCF, 0x85, 0x76, 0xCD, 0x85,
	0x77, 0xCA, 0x81, 0x75, 0xCB, 0x7F, 0x73, 0xCA, 0x80, 0x74, 0xCA, 0x7F, 0x74, 0xCC, 0x7F, 0x74,
	0xCC, 0x7F, 0x74, 0xC9, 0x80, 0x73, 0xCA, 0x82, 0x75, 0xCA, 0x81, 0x74, 0xCA, 0x80, 0x74, 0xC6,
	0x7D, 0x75, 0xC5, 0x7B, 0x77, 0xC2, 0x79, 0x78, 0xBD, 0x78, 0x79, 0xB9, 0x75, 0x77, 0xB7, 0x73,
	0x75, 0xB0, 0x6B, 0x74, 0xA9, 0x67, 0x72, 0xAC, 0x6B, 0x74, 0xB7, 0x77, 0x7B, 0xC6, 0x8A, 0x81,
	0xAC, 0x40, 0x4C, 0xA9, 0x3E, 0x49, 0xA9, 0x3F, 0x49, 0xA4, 0x39, 0x47, 0x9C, 0x35, 0x44, 0x8E,
	0x26, 0x3D, 0x93, 0x27, 0x3E, 0xC5, 0x52, 0x51, 0xE0, 0x79, 0x65, 0xE7, 0x8F, 0x71, 0xEA, 0x9B,
	0x75, 0xEA, 0x9D, 0x77, 0xEA, 0x9E, 0x7D, 0xEA, 0x97, 0x77, 0xE3, 0x7F, 0x68, 0xCD, 0x58, 0x55,
	0xA1, 0x35, 0x45, 0x96, 0x2D, 0x42, 0xA8, 0x37, 0x45, 0xB2, 0x40, 0x49, 0xB8, 0x45, 0x4C, 0xBD,
	0x49, 0x4F, 0xB2, 0x47, 0x4F, 0x80, 0x1F, 0x39, 0x6E, 0x19, 0x3C, 0x87, 0x40, 0x5C, 0xAC, 0x67,
	0x72, 0xD4, 0x94, 0x8D, 0xE8, 0xB4, 0x99, 0xC7, 0x98, 0x85, 0x79, 0x38, 0x58, 0x52, 0x16, 0x4D,
	0x4E, 0x14, 0x48, 0x74, 0x3E, 0x6E, 0x7B, 0x43, 0x71, 0x57, 0x15, 0x44, 0x60, 0x22, 0x53, 0x71,
	0x36, 0x66, 0x72, 0x35, 0x66, 0x81, 0x4E, 0x7E, 0x89, 0x5B, 0x87, 0x88, 0x5A, 0x83, 0x67, 0x26,
	0x55, 0x59, 0x13, 0x3F, 0x54, 0x0D, 0x38, 0x56, 0x0D, 0x38, 0x5E, 0x15, 0x3F, 0x60, 0x15, 0x40,
	0x5B, 0x12, 0x3B, 0x5A, 0x12, 0x3A, 0x46, 0x02, 0x33, 0x53, 0x12, 0x3D, 0xA1, 0x4D, 0x5B, 0xC2,
	0x7B, 0x7D, 0xD7, 0x98, 0x8A, 0xD8, 0xA0, 0x93, 0xE1, 0xC5, 0xB8, 0xD8, 0xB5, 0xA8, 0xBE, 0x65,
	0x65, 0xC1, 0x4A, 0x53, 0xCF, 0x5A, 0x5E, 0xDB, 0x6B, 0x6B, 0xCF, 0x62, 0x67, 0xA7, 0x3F, 0x51,
	0xB1, 0x45, 0x54, 0xB7, 0x58, 0x64, 0xB3, 0x68, 0x76, 0xD5, 0xA0, 0x9C, 0xE4, 0xB6, 0xA6, 0xE1,
	0xA4, 0x98, 0xD9, 0x7D, 0x7C, 0xD2, 0x5E, 0x61, 0xCD, 0x53, 0x57, 0xC9, 0x51, 0x57, 0xD1, 0x56,
	0x5C, 0xD8, 0x62, 0x63, 0xE1, 0x8E, 0x86, 0xEE, 0xD1, 0xB8, 0xE4, 0xBA, 0xA4, 0xB9, 0x5A, 0x64,
	0xB8, 0x60, 0x6B, 0xAE, 0x63, 0x72, 0xAE, 0x72, 0x83, 0xCD, 0x9B, 0x99, 0xC7, 0x6A, 0x6C, 0x83,
	0x1E, 0x3B, 0x6C, 0x13, 0x36, 0x6C, 0x15, 0x37, 0x5C, 0x12, 0x3B, 0x5D, 0x17, 0x3F, 0x67, 0x19,
	0x45, 0x8E, 0x49, 0x63, 0xC8, 0x8F, 0x8D, 0x8D, 0x42, 0x60, 0x7B, 0x2D, 0x52, 0x64, 0x18, 0x40,
	0x58, 0x0F, 0x39, 0x5D, 0x12, 0x3A, 0x61, 0x15, 0x39, 0x58, 0x0F, 0x39, 0x8F, 0x43, 0x5D, 0xC2,
	0x74, 0x74, 0xBF, 0x73, 0x72, 0xCB, 0x84, 0x7A, 0xCE, 0x87, 0x76, 0xCD, 0x83, 0x74, 0xCB, 0x81,
	0x74, 0xC9, 0x80, 0x74, 0xC9, 0x7E, 0x74, 0xCB, 0x82, 0x76, 0xCB, 0x87, 0x7D, 0xCA, 0x81, 0x76,
	0xCB, 0x81, 0x75, 0xCA, 0x84, 0x76, 0xCA, 0x81, 0x74, 0xCA, 0x7E, 0x72, 0xC9, 0x7D, 0x73, 0xC4,
	0x7A, 0x72, 0xC3, 0x78, 0x74, 0xBD, 0x76, 0x76, 0xB7, 0x74, 0x76, 0xB6, 0x72, 0x73, 0xB2, 0x6C,
	0x71, 0xB2, 0x6D, 0x76, 0xBD, 0x7E, 0x7B, 0xCE, 0x90, 0x7D, 0xDB, 0x9D, 0x80, 0xE2, 0xAC, 0x87,
	0xB0, 0x43, 0x4D, 0xAC, 0x42, 0x4E, 0xA8, 0x41, 0x4B, 0xA3, 0x38, 0x46, 0x9B, 0x31, 0x43, 0x8F,
	0x27, 0x3E, 0x94, 0x26, 0x3D, 0xC5, 0x50, 0x50, 0xE1, 0x7A, 0x66, 0xE7, 0x90, 0x72, 0xE9, 0x99,
	0x77, 0xEA, 0x9F, 0x79, 0xEA, 0xA3, 0x7D, 0xEA, 0x9A, 0x77, 0xE5, 0x81, 0x6A, 0xCE, 0x5B, 0x55,
	0xA1, 0x34, 0x44, 0x99, 0x2D, 0x40, 0xA9, 0x3A, 0x46, 0xB4, 0x43, 0x4B, 0xBB, 0x48, 0x4F, 0xC4,
	0x4D, 0x51, 0xB0, 0x4E, 0x54, 0x68, 0x1C, 0x41, 0x99, 0x48, 0x5E, 0xCF, 0x88, 0x85, 0xC4, 0x7E,
	0x80, 0xC1, 0x7B, 0x7E, 0xA6, 0x65, 0x71, 0x5C, 0x15, 0x41, 0x49, 0x06, 0x3D, 0x75, 0x42, 0x72,
	0x83, 0x51, 0x7F, 0x81, 0x4C, 0x7B, 0x6C, 0x34, 0x65, 0x4A, 0x07, 0x38, 0x62, 0x27, 0x58, 0x74,
	0x3E, 0x6F, 0x6C, 0x30, 0x61, 0x78, 0x43, 0x75, 0x91, 0x67, 0x96, 0x92, 0x67, 0x91, 0x7E, 0x48,
	0x76, 0x5A, 0x18, 0x45, 0x51, 0x0B, 0x36, 0x55, 0x0E, 0x38, 0x5A, 0x0F, 0x39, 0x5C, 0x10, 0x3A,
	0x5C, 0x14, 0x3C, 0x53, 0x0B, 0x37, 0x3F, 0x00, 0x32, 0x83, 0x36, 0x4D, 0xC1, 0x62, 0x64, 0xD0,
	0x91, 0x89, 0xDC, 0x9D, 0x8C, 0xE0, 0xBB, 0xAB, 0xDB, 0xBB, 0xAB, 0xB4, 0x5C, 0x5F, 0xBB, 0x3F,
	0x4B, 0xD4, 0x60, 0x65, 0xD5, 0x66, 0x69, 0xD8, 0x6D, 0x6D, 0xDB, 0x71, 0x70, 0xD5, 0x6B, 0x6D,
	0xCA, 0x5D, 0x63, 0xC5, 0x51, 0x5A, 0xC9, 0x5C, 0x63, 0xCA, 0x67, 0x6A, 0xBE, 0x65, 0x6A, 0xCD,
	0x81, 0x82, 0xDA, 0x8E, 0x8A, 0xD6, 0x74, 0x75, 0xCC, 0x56, 0x5D, 0xCF, 0x57, 0x5D, 0xD2, 0x56,
	0x5D, 0xD6, 0x5D, 0x62, 0xDE, 0x85, 0x80, 0xEB, 0xCA, 0xB2, 0xE8, 0xC6, 0xB1, 0xD4, 0x86, 0x85,
	0xCF, 0x6D, 0x6F, 0xCD, 0x67, 0x6B, 0xC7, 0x68, 0x6D, 0xB2, 0x54, 0x5E, 0x8C, 0x27, 0x3F, 0x88,
	0x24, 0x3D, 0x8D, 0x29, 0x3F, 0x72, 0x16, 0x37, 0x5D, 0x0F, 0x38, 0x63, 0x1A, 0x41, 0x67, 0x19,
	0x44, 0x87, 0x40, 0x5B, 0xD0, 0x97, 0x91, 0x99, 0x51, 0x69, 0x78, 0x26, 0x49, 0x62, 0x16, 0x3C,
	0x58, 0x0F, 0x3A, 0x60, 0x14, 0x39, 0x5D, 0x13, 0x3B, 0x6B, 0x20, 0x47, 0xAB, 0x5F, 0x6D, 0xBD,
	0x70, 0x71, 0xC2, 0x75, 0x72, 0xD1, 0x88, 0x79, 0xCD, 0x86, 0x77, 0xCA, 0x83, 0x75, 0xCA, 0x81,
	0x74, 0xC8, 0x80, 0x77, 0xC6, 0x7E, 0x77, 0xCA, 0x80, 0x75, 0xCA, 0x84, 0x7B, 0xC9, 0x81, 0x77,
	0xCA, 0x80, 0x75, 0xCA, 0x82, 0x77, 0xCA, 0x80, 0x75, 0xC8, 0x7B, 0x73, 0xC4, 0x79, 0x73, 0xC0,
	0x76, 0x70, 0xBB, 0x73, 0x72, 0xB7, 0x72, 0x73, 0xB1, 0x6D, 0x74, 0xB3, 0x6F, 0x75, 0xC0, 0x7D,
	0x78, 0xD2, 0x93, 0x7D, 0xE1, 0xA6, 0x81, 0xE5, 0xAE, 0x83, 0xE5, 0xAE, 0x82, 0xE5, 0xB1, 0x86,
	0xAE, 0x42, 0x4C, 0xA8, 0x3F, 0x4D, 0xA2, 0x3D, 0x4B, 0x9B, 0x35, 0x45, 0x96, 0x2F, 0x41, 0x87,
	0x23, 0x3C, 0x8B, 0x21, 0x3B, 0xC2, 0x4C, 0x4E, 0xDF, 0x78, 0x67, 0xE6, 0x90, 0x76, 0xEA, 0x9A,
	0x77, 0xEA, 0x9F, 0x79, 0xEA, 0xA1, 0x7D, 0xEA, 0x9B, 0x7B, 0xE5, 0x83, 0x6C, 0xD2, 0x5C, 0x54,
	0xA4, 0x31, 0x41, 0x96, 0x2A, 0x3F, 0xA7, 0x3A, 0x45, 0xB4, 0x41, 0x49, 0xBB, 0x46, 0x4D, 0xBC,
	0x42, 0x49, 0xC1, 0x52, 0x56, 0xC4, 0x74, 0x75, 0xD3, 0x84, 0x82, 0xBD, 0x6D, 0x72, 0x7D, 0x36,
	0x56, 0x74, 0x32, 0x5C, 0x6D, 0x2A, 0x59, 0x4E, 0x0D, 0x40, 0x50, 0x0D, 0x3C, 0x61, 0x23, 0x52,
	0x89, 0x5C, 0x87, 0x8F, 0x64, 0x95, 0x7F, 0x4B, 0x7E, 0x58, 0x17, 0x46, 0x5B, 0x1C, 0x4D, 0x6F,
	0x33, 0x64, 0x75, 0x40, 0x73, 0x76, 0x3E, 0x72, 0x83, 0x52, 0x85, 0x93, 0x68, 0x95, 0x7C, 0x4A,
	0x76, 0x5A, 0x17, 0x45, 0x56, 0x10, 0x3A, 0x59, 0x10, 0x38, 0x5B, 0x0F, 0x39, 0x5C, 0x12, 0x3B,
	0x59, 0x11, 0x3A, 0x44, 0x01, 0x31, 0x5B, 0x1B, 0x42, 0xB7, 0x58, 0x5D, 0xC9, 0x73, 0x6F, 0xD7,
	0x9A, 0x8B, 0xDD, 0xB0, 0xA1, 0xDF, 0xC1, 0xB0, 0xAF, 0x5E, 0x64, 0xAB, 0x2E, 0x3C, 0xCF, 0x53,
	0x5A, 0xD8, 0x68, 0x6D, 0xD9, 0x75, 0x75, 0xD8, 0x77, 0x77, 0xD9, 0x75, 0x75, 0xDB, 0x77, 0x74,
	0xDA, 0x71, 0x70, 0xD5, 0x67, 0x6B, 0xD2, 0x66, 0x6A, 0xD1, 0x6B, 0x6F, 0xD0, 0x73, 0x77, 0xDA,
	0x80, 0x82, 0xDD, 0x84, 0x82, 0xD5, 0x77, 0x78, 0xCF, 0x5C, 0x63, 0xD6, 0x5F, 0x65, 0xD4, 0x59,
	0x5F, 0xD4, 0x58, 0x5F, 0xDE, 0x80, 0x7E, 0xEB, 0xC3, 0xAF, 0xE9, 0xCE, 0xB7, 0xDD, 0x9C, 0x94,
	0xD9, 0x79, 0x78, 0xD2, 0x66, 0x6B, 0xCC, 0x5C, 0x63, 0xBC, 0x4B, 0x56, 0xA6, 0x3A, 0x49, 0xAD,
	0x40, 0x4B, 0x9F, 0x34, 0x44, 0x74, 0x17, 0x37, 0x5D, 0x0C, 0x33, 0x65, 0x16, 0x3C, 0x65, 0x19,
	0x43, 0x82, 0x3B, 0x59, 0xD5, 0x9A, 0x92, 0xA0, 0x5C, 0x6D, 0x71, 0x21, 0x46, 0x60, 0x14, 0x3A,
	0x59, 0x10, 0x3A, 0x63, 0x17, 0x3B, 0x57, 0x0D, 0x36, 0x77, 0x2B, 0x4C, 0xBB, 0x6F, 0x71, 0xBC,
	0x6E, 0x6E, 0xC8, 0x7C, 0x75, 0xCF, 0x89, 0x79, 0xCB, 0x83, 0x77, 0xCA, 0x82, 0x77, 0xC9, 0x7F,
	0x74, 0xC9, 0x7F, 0x76, 0xC8, 0x80, 0x76, 0xC9, 0x7E, 0x74, 0xC8, 0x7C, 0x72, 0xC8, 0x7E, 0x74,
	0xC8, 0x7E, 0x76, 0xC7, 0x7F, 0x77, 0xC8, 0x7D, 0x74, 0xC6, 0x7A, 0x73, 0xBF, 0x78, 0x73, 0xBC,
	0x76, 0x73, 0xB7, 0x70, 0x71, 0xB2, 0x69, 0x70, 0xB8, 0x6F, 0x75, 0xCB, 0x8C, 0x7E, 0xDF, 0xA6,
	0x84, 0xE8, 0xB3, 0x83, 0xEB, 0xB5, 0x82, 0xE6, 0xB0, 0x83, 0xE3, 0xAC, 0x83, 0xE3, 0xAC, 0x82,
	0xA9, 0x3E, 0x4B, 0xA2, 0x37, 0x46, 0x9A, 0x36, 0x46, 0x96, 0x30, 0x41, 0x92, 0x2B, 0x40, 0x7E,
	0x1E, 0x3B, 0x80, 0x1C, 0x3A, 0xBD, 0x4A, 0x4D, 0xDF, 0x78, 0x67, 0xE5, 0x8E, 0x74, 0xE9, 0x9A,
	0x78, 0xEB, 0x9E, 0x79, 0xEA, 0xA0, 0x7D, 0xEA, 0x9B, 0x79, 0xE6, 0x84, 0x69, 0xD2, 0x5D, 0x54,
	0xA4, 0x32, 0x42, 0x97, 0x2A, 0x3F, 0xA7, 0x38, 0x44, 0xB3, 0x41, 0x48, 0xBA, 0x43, 0x4A, 0xBA,
	0x3F, 0x46, 0xBE, 0x49, 0x52, 0xC5, 0x6D, 0x72, 0xBF, 0x6C, 0x75, 0x98, 0x4D, 0x6A, 0x74, 0x3F,
	0x6E, 0x74, 0x38, 0x68, 0x5C, 0x18, 0x47, 0x54, 0x15, 0x46, 0x6B, 0x2D, 0x5E, 0x77, 0x3E, 0x71,
	0x7C, 0x48, 0x78, 0x7B, 0x47, 0x77, 0x73, 0x3B, 0x6B, 0x4D, 0x0B, 0x3B, 0x5B, 0x1B, 0x4C, 0x70,
	0x34, 0x67, 0x70, 0x38, 0x68, 0x88, 0x5B, 0x87, 0x7E, 0x4A, 0x7C, 0x83, 0x51, 0x7E, 0x78, 0x46,
	0x70, 0x55, 0x12, 0x40, 0x57, 0x0F, 0x39, 0x58, 0x0F, 0x39, 0x57, 0x0E, 0x38, 0x5A, 0x14, 0x3F,
	0x53, 0x12, 0x3F, 0x47, 0x0A, 0x3B, 0x95, 0x45, 0x54, 0xC4, 0x5F, 0x60, 0xD1, 0x8D, 0x83, 0xE1,
	0xB0, 0x9D, 0xE5, 0xC7, 0xB3, 0xB0, 0x6D, 0x72, 0x9B, 0x24, 0x38, 0xC3, 0x46, 0x4D, 0xD2, 0x59,
	0x5E, 0xD7, 0x68, 0x6B, 0xDA, 0x76, 0x75, 0xDB, 0x7E, 0x7E, 0xDF, 0x87, 0x83, 0xE0, 0x87, 0x82,
	0xDE, 0x85, 0x81, 0xDF, 0x83, 0x80, 0xE0, 0x85, 0x83, 0xE1, 0x8C, 0x87, 0xE3, 0x8F, 0x89, 0xE2,
	0x8F, 0x8A, 0xDF, 0x8C, 0x87, 0xD8, 0x73, 0x74, 0xD7, 0x63, 0x68, 0xD8, 0x63, 0x66, 0xD4, 0x59,
	0x5D, 0xD3, 0x56, 0x5C, 0xDC, 0x7D, 0x7C, 0xEA, 0xC0, 0xAE, 0xE9, 0xCF, 0xB9, 0xDD, 0xAD, 0x9E,
	0xDC, 0x8D, 0x88, 0xDA, 0x7B, 0x7B, 0xD6, 0x6C, 0x6D, 0xD4, 0x5C, 0x60, 0xCB, 0x54, 0x59, 0xBF,
	0x4E, 0x58, 0xA9, 0x3B, 0x4A, 0x7B, 0x1C, 0x3A, 0x60, 0x0E, 0x36, 0x6A, 0x19, 0x3D, 0x65, 0x17,
	0x3E, 0x7B, 0x36, 0x56, 0xD4, 0x9C, 0x94, 0xA4, 0x61, 0x70, 0x6A, 0x1B, 0x41, 0x60, 0x13, 0x3A,
	0x5A, 0x10, 0x38, 0x5E, 0x12, 0x37, 0x53, 0x0A, 0x35, 0x89, 0x3C, 0x54, 0xBC, 0x71, 0x71, 0xBC,
	0x70, 0x71, 0xCB, 0x83, 0x79, 0xCE, 0x87, 0x77, 0xCB, 0x83, 0x76, 0xC9, 0x80, 0x76, 0xC9, 0x80,
	0x75, 0xC7, 0x7F, 0x76, 0xC8, 0x81, 0x75, 0xC9, 0x7F, 0x75, 0xC8, 0x7D, 0x74, 0xC8, 0x7D, 0x74,
	0xC7, 0x7C, 0x75, 0xC3, 0x7B, 0x76, 0xC3, 0x7A, 0x75, 0xC2, 0x77, 0x72, 0xBE, 0x76, 0x71, 0xB8,
	0x73, 0x72, 0xB2, 0x69, 0x71, 0xB8, 0x71, 0x74, 0xD4, 0x98, 0x81, 0xE9, 0xB5, 0x87, 0xEC, 0xBB,
	0x87, 0xEC, 0xB7, 0x81, 0xEB, 0xB3, 0x80, 0xE6, 0xAE, 0x80, 0xE4, 0xAB, 0x80, 0xE5, 0xAF, 0x84,
	0xA2, 0x39, 0x47, 0x9C, 0x38, 0x47, 0x97, 0x33, 0x44, 0x94, 0x2D, 0x41, 0x8D, 0x28, 0x3F, 0x7B,
	0x1C, 0x3B, 0x80, 0x1D, 0x3B, 0xBB, 0x48, 0x4D, 0xDF, 0x76, 0x65, 0xE5, 0x8F, 0x73, 0xE8, 0x98,
	0x78, 0xEA, 0x9C, 0x78, 0xEA, 0xA1, 0x7B, 0xEB, 0x9B, 0x77, 0xE6, 0x85, 0x68, 0xD0, 0x5D, 0x55,
	0xA1, 0x32, 0x42, 0x95, 0x28, 0x3E, 0xA6, 0x35, 0x43, 0xB1, 0x3D, 0x47, 0xB7, 0x4A, 0x53, 0xB7,
	0x5B, 0x66, 0xAF, 0x67, 0x7A, 0xAB, 0x72, 0x86, 0xAC, 0x7A, 0x88, 0x8F, 0x63, 0x85, 0x88, 0x5D,
	0x86, 0x6B, 0x2E, 0x5E, 0x59, 0x15, 0x44, 0x6A, 0x2B, 0x5A, 0x7C, 0x44, 0x77, 0x87, 0x54, 0x8A,
	0x84, 0x52, 0x86, 0x7D, 0x47, 0x76, 0x5A, 0x1E, 0x4C, 0x46, 0x05, 0x34, 0x58, 0x18, 0x47, 0x75,
	0x3D, 0x6F, 0x79, 0x43, 0x75, 0x83, 0x53, 0x85, 0x8A, 0x5E, 0x8C, 0x88, 0x5E, 0x84, 0x80, 0x49,
	0x6A, 0x79, 0x2D, 0x4C, 0x61, 0x18, 0x3F, 0x55, 0x11, 0x3C, 0x56, 0x0F, 0x39, 0x55, 0x12, 0x3F,
	0x47, 0x0A, 0x3C, 0x6B, 0x29, 0x4C, 0xBA, 0x59, 0x5C, 0xC4, 0x6F, 0x71, 0xDD, 0xAA, 0x9B, 0xEA,
	0xC8, 0xB1, 0xB5, 0x83, 0x82, 0x7C, 0x17, 0x35, 0xAF, 0x36, 0x43, 0xCC, 0x52, 0x55, 0xD2, 0x59,
	0x5E, 0xD7, 0x64, 0x68, 0xDA, 0x72, 0x71, 0xDC, 0x7D, 0x7B, 0xE0, 0x8A, 0x84, 0xE3, 0x8E, 0x86,
	0xE2, 0x93, 0x8A, 0xE2, 0x92, 0x8A, 0xE2, 0x93, 0x8B, 0xE2, 0x92, 0x8C, 0xE1, 0x91, 0x8B, 0xE1,
	0x95, 0x8C, 0xDE, 0x87, 0x82, 0xD8, 0x71, 0x70, 0xD9, 0x6C, 0x6D, 0xD7, 0x63, 0x67, 0xD5, 0x59,
	0x5D, 0xD3, 0x54, 0x58, 0xDA, 0x70, 0x72, 0xE7, 0xB7, 0xA8, 0xEC, 0xD2, 0xBB, 0xE1, 0xAF, 0x9F,
	0xDE, 0x94, 0x8A, 0xDB, 0x7F, 0x7C, 0xD7, 0x6C, 0x6C, 0xD7, 0x61, 0x66, 0xD3, 0x5A, 0x61, 0xCB,
	0x54, 0x5A, 0xB1, 0x41, 0x4C, 0x79, 0x1C, 0x3A, 0x60, 0x10, 0x38, 0x70, 0x1C, 0x3E, 0x67, 0x14,
	0x39, 0x74, 0x2B, 0x4E, 0xD6, 0x9A, 0x92, 0xAD, 0x6B, 0x74, 0x64, 0x13, 0x39, 0x5D, 0x0F, 0x36,
	0x5C, 0x11, 0x38, 0x59, 0x0E, 0x36, 0x5E, 0x12, 0x3A, 0xA4, 0x53, 0x61, 0xBD, 0x71, 0x70, 0xC1,
	0x75, 0x72, 0xCF, 0x89, 0x7A, 0xCC, 0x85, 0x76, 0xCB, 0x82, 0x76, 0xCA, 0x81, 0x77, 0xC9, 0x82,
	0x77, 0xC7, 0x7F, 0x78, 0xC7, 0x80, 0x78, 0xC8, 0x81, 0x77, 0xC7, 0x7E, 0x75, 0xC5, 0x7C, 0x76,
	0xC4, 0x7A, 0x76, 0xC3, 0x79, 0x75, 0xC0, 0x78, 0x75, 0xBD, 0x75, 0x72, 0xBA, 0x73, 0x6F, 0xB3,
	0x6C, 0x70, 0xB8, 0x70, 0x74, 0xD4, 0x97, 0x7F, 0xEA, 0xB7, 0x87, 0xF0, 0xBD, 0x85, 0xEE, 0xBB,
	0x86, 0xEA, 0xB5, 0x83, 0xE8, 0xAE, 0x7F, 0xE6, 0xAD, 0x7F, 0xE8, 0xB1, 0x82, 0xE6, 0xB3, 0x87,
	0x98, 0x34, 0x48, 0x95, 0x36, 0x49, 0x93, 0x2D, 0x41, 0x92, 0x2D, 0x41, 0x8A, 0x27, 0x3E, 0x77,
	0x1A, 0x3A, 0x7D, 0x1C, 0x3A, 0xBA, 0x4A, 0x4E, 0xDE, 0x76, 0x66, 0xE6, 0x90, 0x74, 0xE9, 0x99,
	0x78, 0xEA, 0x9B, 0x77, 0xEA, 0xA0, 0x7B, 0xEB, 0x99, 0x78, 0xE6, 0x84, 0x69, 0xCF, 0x5D, 0x56,
	0xA0, 0x31, 0x41, 0x92, 0x27, 0x3D, 0xA4, 0x32, 0x42, 0xB2, 0x48, 0x54, 0xBB, 0x5E, 0x68, 0xBD,
	0x6C, 0x76, 0xB3, 0x79, 0x87, 0xAC, 0x70, 0x80, 0x86, 0x49, 0x69, 0x6B, 0x32, 0x61, 0x68, 0x28,
	0x5A, 0x5B, 0x19, 0x47, 0x66, 0x26, 0x56, 0x74, 0x3A, 0x6A, 0x7D, 0x48, 0x7A, 0x8B, 0x5D, 0x8D,
	0x8B, 0x5D, 0x8E, 0x6B, 0x2F, 0x5E, 0x51, 0x0F, 0x39, 0x51, 0x0F, 0x3B, 0x51, 0x0D, 0x3B, 0x58,
	0x19, 0x47, 0x71, 0x38, 0x68, 0x80, 0x47, 0x74, 0x70, 0x35, 0x5E, 0x52, 0x14, 0x42, 0x99, 0x50,
	0x64, 0xB3, 0x62, 0x6D, 0x68, 0x1E, 0x45, 0x4E, 0x0E, 0x3A, 0x55, 0x11, 0x3B, 0x4D, 0x0F, 0x3C,
	0x48, 0x0B, 0x3E, 0x9A, 0x4B, 0x5C, 0xC2, 0x63, 0x65, 0xCE, 0x8F, 0x87, 0xEB, 0xC4, 0xAD, 0xCA,
	0xA6, 0x9A, 0x66, 0x1A, 0x3C, 0x80, 0x17, 0x34, 0xBE, 0x47, 0x4E, 0xCD, 0x54, 0x57, 0xD2, 0x57,
	0x5C, 0xD8, 0x64, 0x67, 0xDB, 0x70, 0x6F, 0xDC, 0x7B, 0x75, 0xE0, 0x88, 0x81, 0xE3, 0x8E, 0x88,
	0xE1, 0x94, 0x8B, 0xDF, 0x97, 0x8D, 0xE0, 0x97, 0x8C, 0xE1, 0x96, 0x8B, 0xE0, 0x95, 0x8C, 0xE1,
	0x93, 0x8B, 0xE0, 0x86, 0x7F, 0xDA, 0x78, 0x73, 0xD9, 0x70, 0x6F, 0xD8, 0x66, 0x6A, 0xD6, 0x5C,
	0x60, 0xD4, 0x54, 0x59, 0xD8, 0x68, 0x6B, 0xE6, 0xAF, 0xA2, 0xED, 0xD5, 0xBD, 0xE4, 0xAF, 0xA2,
	0xE0, 0x8C, 0x85, 0xDE, 0x82, 0x7E, 0xD9, 0x6D, 0x6E, 0xD6, 0x60, 0x67, 0xD5, 0x5D, 0x64, 0xD2,
	0x59, 0x5C, 0xB5, 0x42, 0x4B, 0x74, 0x19, 0x39, 0x61, 0x13, 0x3A, 0x73, 0x21, 0x40, 0x66, 0x17,
	0x3C, 0x6C, 0x23, 0x49, 0xD1, 0x8E, 0x89, 0xB9, 0x77, 0x7A, 0x63, 0x15, 0x3B, 0x57, 0x08, 0x32,
	0x60, 0x11, 0x37, 0x56, 0x0B, 0x34, 0x6C, 0x1E, 0x40, 0xB7, 0x65, 0x69, 0xC2, 0x72, 0x6F, 0xC8,
	0x7C, 0x74, 0xD0, 0x8A, 0x7B, 0xCB, 0x84, 0x78, 0xCA, 0x82, 0x77, 0xC9, 0x82, 0x77, 0xC8, 0x80,
	0x79, 0xC6, 0x80, 0x79, 0xC7, 0x7D, 0x78, 0xC8, 0x7E, 0x77, 0xC5, 0x7C, 0x76, 0xC3, 0x79, 0x76,
	0xC1, 0x78, 0x76, 0xC0, 0x78, 0x76, 0xBE, 0x78, 0x76, 0xB8, 0x72, 0x72, 0xB2, 0x6A, 0x6F, 0xB5,
	0x6C, 0x72, 0xD1, 0x90, 0x7C, 0xE8, 0xB3, 0x86, 0xED, 0xBA, 0x85, 0xEE, 0xB9, 0x83, 0xED, 0xB8,
	0x83, 0xEC, 0xB6, 0x81, 0xE8, 0xB1, 0x81, 0xE7, 0xB2, 0x85, 0xE8, 0xB7, 0x8A, 0xE9, 0xBA, 0x8F,
	0x91, 0x2F, 0x44, 0x8D, 0x2C, 0x42, 0x8C, 0x28, 0x3E, 0x8B, 0x27, 0x3E, 0x84, 0x25, 0x3F, 0x74,
	0x1A, 0x3A, 0x79, 0x1B, 0x39, 0xB9, 0x48, 0x4E, 0xDE, 0x76, 0x66, 0xE5, 0x90, 0x72, 0xE9, 0x99,
	0x78, 0xEA, 0x9C, 0x79, 0xEA, 0x9D, 0x7B, 0xEA, 0x97, 0x78, 0xE6, 0x82, 0x6A, 0xD1, 0x5D, 0x57,
	0xA1, 0x32, 0x42, 0x91, 0x28, 0x3D, 0xA2, 0x35, 0x43, 0xB1, 0x47, 0x53, 0xBA, 0x4B, 0x54, 0xC5,
	0x4F, 0x55, 0xAE, 0x4D, 0x5D, 0x7F, 0x3E, 0x68, 0x76, 0x3F, 0x73, 0x7A, 0x3C, 0x6A, 0x74, 0x2D,
	0x58, 0x67, 0x26, 0x57, 0x76, 0x40, 0x72, 0x68, 0x2D, 0x5E, 0x82, 0x51, 0x80, 0x8C, 0x60, 0x8D,
	0x6E, 0x34, 0x64, 0x5C, 0x1B, 0x49, 0x55, 0x0E, 0x3A, 0x59, 0x13, 0x3E, 0x58, 0x14, 0x3F, 0x55,
	0x13, 0x3E, 0x5B, 0x19, 0x44, 0x67, 0x20, 0x45, 0x61, 0x14, 0x35, 0x4C, 0x05, 0x34, 0xA0, 0x4D,
	0x60, 0xBE, 0x73, 0x78, 0x78, 0x31, 0x50, 0x45, 0x03, 0x33, 0x4F, 0x0C, 0x38, 0x42, 0x03, 0x34,
	0x68, 0x26, 0x48, 0xBB, 0x5D, 0x62, 0xC7, 0x77, 0x78, 0xE2, 0xB8, 0xA5, 0xE1, 0xB9, 0xA6, 0x78,
	0x3F, 0x58, 0x4E, 0x00, 0x2C, 0x95, 0x2B, 0x40, 0xC5, 0x4C, 0x4F, 0xD0, 0x55, 0x57, 0xD2, 0x58,
	0x5D, 0xD7, 0x5F, 0x64, 0xDB, 0x6B, 0x6A, 0xDC, 0x73, 0x6F, 0xDE, 0x7F, 0x7A, 0xE2, 0x8C, 0x83,
	0xE2, 0x93, 0x89, 0xDF, 0x9B, 0x8F, 0xE0, 0x9D, 0x8F, 0xE2, 0x95, 0x89, 0xE2, 0x91, 0x87, 0xE2,
	0x8D, 0x81, 0xDE, 0x81, 0x76, 0xDB, 0x74, 0x6F, 0xDB, 0x70, 0x6E, 0xDA, 0x69, 0x69, 0xD4, 0x5B,
	0x5D, 0xD2, 0x55, 0x5B, 0xD8, 0x68, 0x6A, 0xE6, 0xA8, 0x9B, 0xED, 0xDA, 0xBD, 0xE4, 0xB5, 0xA3,
	0xDF, 0x88, 0x84, 0xDD, 0x82, 0x7F, 0xD8, 0x75, 0x73, 0xD7, 0x64, 0x69, 0xD5, 0x5B, 0x62, 0xD3,
	0x58, 0x5A, 0xAD, 0x3C, 0x48, 0x6D, 0x16, 0x38, 0x5D, 0x10, 0x39, 0x73, 0x20, 0x41, 0x6B, 0x1A,
	0x3D, 0x67, 0x1D, 0x42, 0xC8, 0x82, 0x82, 0xC6, 0x7F, 0x7E, 0x69, 0x1C, 0x3F, 0x54, 0x06, 0x31,
	0x66, 0x18, 0x3A, 0x56, 0x09, 0x33, 0x81, 0x2D, 0x48, 0xC2, 0x6E, 0x6B, 0xC5, 0x74, 0x70, 0xCF,
	0x86, 0x7A, 0xCF, 0x89, 0x7A, 0xCA, 0x82, 0x75, 0xCA, 0x83, 0x77, 0xC9, 0x82, 0x77, 0xC8, 0x7F,
	0x77, 0xC7, 0x7E, 0x76, 0xC7, 0x7D, 0x77, 0xC5, 0x7B, 0x78, 0xC4, 0x7A, 0x77, 0xC3, 0x79, 0x73,
	0xC1, 0x77, 0x74, 0xBE, 0x78, 0x77, 0xBA, 0x77, 0x76, 0xB7, 0x70, 0x70, 0xAF, 0x64, 0x6D, 0xC6,
	0x81, 0x77, 0xE7, 0xAF, 0x82, 0xEE, 0xB9, 0x82, 0xED, 0xB6, 0x80, 0xED, 0xB6, 0x80, 0xEC, 0xB6,
	0x80, 0xEC, 0xB6, 0x81, 0xE9, 0xB5, 0x87, 0xE9, 0xBA, 0x8E, 0xEB, 0xBF, 0x96, 0xEC, 0xC3, 0x9C,
	0x89, 0x2B, 0x41, 0x85, 0x28, 0x41, 0x85, 0x29, 0x40, 0x83, 0x27, 0x41, 0x7D, 0x23, 0x40, 0x71,
	0x18, 0x39, 0x79, 0x18, 0x37, 0xB9, 0x47, 0x4E, 0xDD, 0x76, 0x69, 0xE4, 0x8C, 0x73, 0xE8, 0x97,
	0x75, 0xE8, 0x98, 0x77, 0xE9, 0x98, 0x7A, 0xE9, 0x95, 0x75, 0xE5, 0x82, 0x68, 0xD1, 0x5E, 0x56,
	0x9F, 0x30, 0x42, 0x90, 0x29, 0x40, 0xA1, 0x3E, 0x4E, 0xAC, 0x3E, 0x49, 0xB6, 0x3C, 0x45, 0xBE,
	0x4D, 0x55, 0xA1, 0x54, 0x6E, 0x89, 0x5C, 0x84, 0x7F, 0x4C, 0x7A, 0x82, 0x46, 0x71, 0x85, 0x46,
	0x6D, 0x7C, 0x45, 0x77, 0x6B, 0x32, 0x62, 0x59, 0x19, 0x48, 0x74, 0x3F, 0x6D, 0x89, 0x5B, 0x8C,
	0x6A, 0x2D, 0x5F, 0x5A, 0x18, 0x45, 0x5B, 0x15, 0x42, 0x5B, 0x17, 0x41, 0x57, 0x14, 0x3E, 0x55,
	0x11, 0x3C, 0x55, 0x17, 0x44, 0x5E, 0x1C, 0x47, 0x5F, 0x12, 0x36, 0x5E, 0x11, 0x38, 0x91, 0x3F,
	0x5B, 0xB4, 0x63, 0x6B, 0xB2, 0x68, 0x6B, 0x5A, 0x1A, 0x42, 0x41, 0x02, 0x33, 0x48, 0x04, 0x34,
	0x99, 0x42, 0x4E, 0xC2, 0x5C, 0x5F, 0xD2, 0x9B, 0x94, 0xF1, 0xD5, 0xBC, 0xA3, 0x72, 0x7B, 0x44,
	0x03, 0x34, 0x61, 0x11, 0x3A, 0x95, 0x2B, 0x40, 0xC2, 0x49, 0x4E, 0xCE, 0x54, 0x57, 0xD5, 0x5A,
	0x5E, 0xD8, 0x60, 0x61, 0xDA, 0x69, 0x69, 0xDC, 0x71, 0x6E, 0xDD, 0x79, 0x71, 0xDF, 0x84, 0x7A,
	0xE3, 0x8E, 0x85, 0xE3, 0x96, 0x8A, 0xE1, 0x99, 0x8B, 0xE1, 0x92, 0x89, 0xE3, 0x8C, 0x84, 0xE1,
	0x89, 0x7B, 0xDD, 0x7B, 0x71, 0xDA, 0x6A, 0x6A, 0xD9, 0x68, 0x69, 0xD8, 0x64, 0x64, 0xD2, 0x57,
	0x58, 0xD2, 0x55, 0x59, 0xD8, 0x65, 0x69, 0xE1, 0x9A, 0x91, 0xED, 0xD7, 0xBB, 0xE5, 0xB9, 0xA6,
	0xDE, 0x86, 0x82, 0xDA, 0x7F, 0x7D, 0xD7, 0x76, 0x74, 0xD7, 0x67, 0x6B, 0xD5, 0x5D, 0x63, 0xD0,
	0x57, 0x59, 0xA1, 0x34, 0x46, 0x63, 0x13, 0x38, 0x5B, 0x0F, 0x37, 0x74, 0x1F, 0x3F, 0x6A, 0x17,
	0x3A, 0x5F, 0x12, 0x3C, 0xC1, 0x7E, 0x82, 0xCF, 0x88, 0x84, 0x77, 0x2D, 0x4C, 0x51, 0x07, 0x33,
	0x62, 0x1A, 0x3C, 0x5B, 0x0F, 0x38, 0x9A, 0x45, 0x55, 0xC3, 0x72, 0x6C, 0xC6, 0x7C, 0x75, 0xD3,
	0x91, 0x81, 0xCF, 0x87, 0x76, 0xCB, 0x84, 0x76, 0xCA, 0x84, 0x76, 0xC9, 0x82, 0x76, 0xC9, 0x7F,
	0x75, 0xC7, 0x7B, 0x74, 0xC4, 0x7A, 0x77, 0xC3, 0x7A, 0x78, 0xC2, 0x79, 0x75, 0xBF, 0x78, 0x72,
	0xBF, 0x77, 0x75, 0xBD, 0x77, 0x76, 0xB9, 0x73, 0x72, 0xB2, 0x67, 0x6D, 0xBA, 0x6F, 0x70, 0xDE,
	0xA0, 0x7F, 0xEF, 0xB9, 0x81, 0xEF, 0xB7, 0x7D, 0xED, 0xB5, 0x7D, 0xED, 0xB4, 0x7E, 0xEC, 0xB6,
	0x81, 0xEB, 0xB8, 0x88, 0xEB, 0xBE, 0x93, 0xED, 0xC2, 0x9A, 0xED, 0xC3, 0x9A, 0xEB, 0xC2, 0x9E,
	0x86, 0x2B, 0x42, 0x82, 0x2A, 0x44, 0x82, 0x2D, 0x46, 0x80, 0x29, 0x45, 0x7A, 0x22, 0x41, 0x69,
	0x15, 0x39, 0x74, 0x16, 0x37, 0xB9, 0x47, 0x4D, 0xDE, 0x74, 0x67, 0xE4, 0x8A, 0x71, 0xE7, 0x95,
	0x76, 0xE6, 0x94, 0x76, 0xE9, 0x98, 0x78, 0xEA, 0x94, 0x70, 0xE4, 0x7F, 0x66, 0xD1, 0x5D, 0x55,
	0x9D, 0x2E, 0x40, 0x8D, 0x28, 0x3F, 0xA4, 0x54, 0x67, 0xA7, 0x48, 0x59, 0xB7, 0x59, 0x63, 0xB9,
	0x79, 0x83, 0x9B, 0x63, 0x7B, 0x6B, 0x2D, 0x57, 0x7E, 0x46, 0x71, 0x94, 0x62, 0x87, 0x7C, 0x46,
	0x74, 0x62, 0x27, 0x55, 0x68, 0x2F, 0x60, 0x70, 0x36, 0x67, 0x7C, 0x4A, 0x78, 0x94, 0x69, 0x98,
	0x7B, 0x45, 0x70, 0x60, 0x1D, 0x4B, 0x63, 0x1F, 0x4C, 0x5C, 0x16, 0x41, 0x4C, 0x0B, 0x38, 0x4A,
	0x0A, 0x37, 0x63, 0x1B, 0x43, 0x7F, 0x2E, 0x4B, 0x67, 0x13, 0x36, 0x6E, 0x21, 0x48, 0xAF, 0x6F,
	0x7D, 0xAB, 0x54, 0x5E, 0xB6, 0x5C, 0x5D, 0x9A, 0x4F, 0x5B, 0x37, 0x00, 0x2E, 0x5F, 0x1C, 0x41,
	0xB6, 0x54, 0x59, 0xC3, 0x6D, 0x6F, 0xEC, 0xCE, 0xB9, 0xD4, 0xAD, 0xA1, 0x57, 0x18, 0x3E, 0x4B,
	0x06, 0x34, 0x71, 0x1B, 0x3B, 0x91, 0x27, 0x3E, 0xBC, 0x43, 0x4B, 0xCD, 0x53, 0x55, 0xD5, 0x5B,
	0x5B, 0xD8, 0x5F, 0x5E, 0xD9, 0x66, 0x68, 0xDC, 0x71, 0x6F, 0xDD, 0x7A, 0x74, 0xDE, 0x82, 0x7A,
	0xE1, 0x89, 0x7F, 0xE4, 0x8F, 0x84, 0xE3, 0x8E, 0x86, 0xE3, 0x8E, 0x86, 0xE3, 0x8C, 0x84, 0xE0,
	0x86, 0x7B, 0xDD, 0x77, 0x6E, 0xD8, 0x64, 0x64, 0xD7, 0x5F, 0x62, 0xD5, 0x5E, 0x5F, 0xD0, 0x55,
	0x55, 0xD0, 0x52, 0x55, 0xD6, 0x5F, 0x64, 0xE0, 0x91, 0x8C, 0xEC, 0xD2, 0xB9, 0xE7, 0xC0, 0xAC,
	0xDC, 0x85, 0x81, 0xDA, 0x7B, 0x78, 0xD8, 0x72, 0x71, 0xD6, 0x66, 0x6B, 0xD6, 0x5E, 0x64, 0xCE,
	0x55, 0x57, 0x90, 0x2A, 0x41, 0x55, 0x0E, 0x39, 0x61, 0x15, 0x3D, 0x7B, 0x25, 0x42, 0x6B, 0x19,
	0x3B, 0x57, 0x0C, 0x3A, 0xB8, 0x72, 0x79, 0xD0, 0x8B, 0x85, 0x84, 0x3C, 0x57, 0x50, 0x07, 0x35,
	0x58, 0x11, 0x3A, 0x63, 0x17, 0x3E, 0xB0, 0x5C, 0x60, 0xC5, 0x74, 0x6D, 0xC9, 0x80, 0x75, 0xD3,
	0x8C, 0x7A, 0xCF, 0x87, 0x75, 0xCB, 0x84, 0x75, 0xC9, 0x84, 0x76, 0xC9, 0x82, 0x76, 0xC8, 0x7F,
	0x76, 0xC5, 0x7C, 0x77, 0xC2, 0x79, 0x76, 0xC1, 0x79, 0x76, 0xBF, 0x78, 0x73, 0xBE, 0x77, 0x72,
	0xBE, 0x76, 0x74, 0xBB, 0x75, 0x74, 0xB6, 0x6F, 0x70, 0xB2, 0x67, 0x6B, 0xD0, 0x8B, 0x77, 0xED,
	0xB5, 0x80, 0xEF, 0xB8, 0x7F, 0xED, 0xB5, 0x7D, 0xED, 0xB4, 0x7C, 0xED, 0xB4, 0x7E, 0xED, 0xBB,
	0x8A, 0xED, 0xC1, 0x95, 0xEE, 0xC6, 0x9E, 0xEC, 0xC4, 0x9F, 0xED, 0xC1, 0x97, 0xED, 0xC2, 0x98,
	0x8B, 0x2E, 0x42, 0x84, 0x2C, 0x44, 0x80, 0x2B, 0x46, 0x7F, 0x28, 0x42, 0x78, 0x1F, 0x3E, 0x66,
	0x12, 0x37, 0x70, 0x14, 0x36, 0xB8, 0x46, 0x4D, 0xDE, 0x74, 0x67, 0xE4, 0x8C, 0x74, 0xE7, 0x95,
	0x78, 0xE7, 0x94, 0x76, 0xE9, 0x97, 0x74, 0xEA, 0x95, 0x70, 0xE4, 0x80, 0x67, 0xCF, 0x5D, 0x56,
	0x9D, 0x2D, 0x40, 0x8C, 0x20, 0x39, 0xA4, 0x48, 0x59, 0xB0, 0x68, 0x76, 0xAE, 0x70, 0x7F, 0xB1,
	0x71, 0x7E, 0x90, 0x42, 0x5C, 0x6B, 0x25, 0x52, 0x8F, 0x5B, 0x81, 0x85, 0x4D, 0x77, 0x70, 0x36,
	0x65, 0x61, 0x25, 0x55, 0x7B, 0x46, 0x7A, 0x80, 0x4C, 0x7D, 0x88, 0x5A, 0x8A, 0x92, 0x6A, 0x96,
	0x84, 0x53, 0x7D, 0x61, 0x21, 0x4E, 0x5A, 0x16, 0x42, 0x59, 0x12, 0x3C, 0x4A, 0x07, 0x35, 0x4D,
	0x0C, 0x3C, 0x7A, 0x2B, 0x4A, 0x9D, 0x3C, 0x49, 0x7A, 0x26, 0x46, 0x8D, 0x42, 0x62, 0xCC, 0x86,
	0x82, 0xBD, 0x77, 0x76, 0x7C, 0x25, 0x42, 0x77, 0x29, 0x44, 0x36, 0x00, 0x2D, 0x8A, 0x3C, 0x4E,
	0xC3, 0x5F, 0x61, 0xD6, 0xA0, 0x96, 0xE7, 0xCB, 0xB2, 0x7A, 0x3D, 0x56, 0x3A, 0x00, 0x2A, 0x5E,
	0x14, 0x3C, 0x7D, 0x22, 0x3F, 0x92, 0x25, 0x3D, 0xBB, 0x41, 0x49, 0xCD, 0x53, 0x54, 0xD4, 0x5A,
	0x5B, 0xD6, 0x5B, 0x5F, 0xD7, 0x62, 0x67, 0xDA, 0x6C, 0x6C, 0xDC, 0x74, 0x71, 0xDE, 0x7D, 0x76,
	0xDE, 0x83, 0x78, 0xDF, 0x85, 0x7D, 0xE1, 0x8A, 0x80, 0xE2, 0x8A, 0x80, 0xE1, 0x89, 0x7F, 0xE0,
	0x84, 0x79, 0xDC, 0x73, 0x6C, 0xD7, 0x61, 0x61, 0xD3, 0x5B, 0x5E, 0xD2, 0x5A, 0x5E, 0xCE, 0x53,
	0x56, 0xCD, 0x4F, 0x51, 0xD4, 0x5B, 0x60, 0xDE, 0x85, 0x83, 0xEB, 0xC6, 0xB1, 0xEB, 0xCD, 0xB3,
	0xDC, 0x89, 0x84, 0xD8, 0x78, 0x75, 0xD8, 0x72, 0x70, 0xD7, 0x66, 0x6B, 0xD6, 0x5E, 0x62, 0xC4,
	0x4D, 0x51, 0x78, 0x1E, 0x3D, 0x4D, 0x0B, 0x3A, 0x66, 0x19, 0x3E, 0x81, 0x29, 0x43, 0x6C, 0x1A,
	0x3C, 0x53, 0x08, 0x36, 0xAF, 0x66, 0x70, 0xD4, 0x91, 0x8A, 0x8B, 0x46, 0x5C, 0x4C, 0x06, 0x34,
	0x52, 0x09, 0x35, 0x77, 0x27, 0x46, 0xC0, 0x6B, 0x69, 0xC8, 0x72, 0x6F, 0xCD, 0x83, 0x76, 0xD2,
	0x89, 0x75, 0xCF, 0x83, 0x73, 0xCB, 0x7F, 0x72, 0xCB, 0x82, 0x74, 0xC9, 0x82, 0x77, 0xC8, 0x81,
	0x77, 0xC6, 0x7E, 0x76, 0xC4, 0x7A, 0x77, 0xC2, 0x7B, 0x77, 0xC0, 0x79, 0x74, 0xBF, 0x77, 0x74,
	0xBB, 0x75, 0x72, 0xB9, 0x74, 0x71, 0xB3, 0x6B, 0x6E, 0xBF, 0x74, 0x71, 0xE3, 0xA5, 0x7D, 0xF0,
	0xBA, 0x7F, 0xEE, 0xB6, 0x7D, 0xED, 0xB5, 0x7D, 0xEB, 0xB5, 0x80, 0xED, 0xBB, 0x89, 0xEE, 0xC2,
	0x96, 0xEE, 0xC4, 0x9A, 0xEC, 0xC5, 0x9F, 0xEB, 0xC3, 0x9F, 0xEC, 0xC2, 0x9A, 0xEC, 0xC2, 0x9C,
	0x8C, 0x2F, 0x43, 0x88, 0x2D, 0x43, 0x83, 0x2B, 0x44, 0x7F, 0x29, 0x43, 0x77, 0x1D, 0x3C, 0x62,
	0x0E, 0x33, 0x69, 0x10, 0x35, 0xB5, 0x42, 0x4A, 0xDD, 0x73, 0x65, 0xE3, 0x8C, 0x76, 0xE8, 0x95,
	0x79, 0xE9, 0x95, 0x78, 0xE9, 0x98, 0x78, 0xEA, 0x97, 0x75, 0xE6, 0x83, 0x67, 0xD1, 0x5D, 0x54,
	0x9E, 0x2D, 0x3F, 0x8A, 0x1D, 0x37, 0x9E, 0x37, 0x48, 0xB4, 0x5C, 0x68, 0xA5, 0x5C, 0x73, 0xAB,
	0x65, 0x77, 0x8E, 0x43, 0x62, 0x73, 0x30, 0x5F, 0x7E, 0x44, 0x71, 0x79, 0x43, 0x76, 0x72, 0x39,
	0x6A, 0x71, 0x36, 0x68, 0x7D, 0x48, 0x78, 0x77, 0x40, 0x70, 0x7C, 0x47, 0x7B, 0x92, 0x6C, 0x94,
	0x7F, 0x4C, 0x77, 0x5A, 0x1B, 0x4C, 0x4E, 0x0A, 0x37, 0x5C, 0x16, 0x41, 0x54, 0x0F, 0x3B, 0x55,
	0x0F, 0x3D, 0x72, 0x2C, 0x52, 0x87, 0x35, 0x51, 0xAD, 0x57, 0x62, 0xB4, 0x54, 0x5A, 0x98, 0x40,
	0x51, 0x88, 0x3F, 0x57, 0x57, 0x0C, 0x37, 0x45, 0x01, 0x33, 0x60, 0x1A, 0x41, 0xAD, 0x4B, 0x52,
	0xC2, 0x67, 0x6B, 0xE4, 0xB8, 0xA4, 0xA5, 0x6F, 0x74, 0x42, 0x00, 0x2F, 0x46, 0x02, 0x31, 0x64,
	0x19, 0x40, 0x88, 0x2C, 0x47, 0x93, 0x25, 0x3C, 0xB6, 0x3E, 0x47, 0xCB, 0x51, 0x53, 0xD1, 0x57,
	0x5B, 0xD6, 0x5C, 0x5D, 0xD8, 0x61, 0x63, 0xD9, 0x67, 0x69, 0xDC, 0x70, 0x6E, 0xDD, 0x76, 0x70,
	0xDD, 0x79, 0x71, 0xDD, 0x7E, 0x76, 0xDF, 0x85, 0x7C, 0xE0, 0x87, 0x7D, 0xE0, 0x87, 0x7B, 0xDD,
	0x7E, 0x74, 0xDA, 0x6B, 0x6A, 0xD0, 0x58, 0x5B, 0xCD, 0x54, 0x58, 0xD5, 0x5E, 0x61, 0xD3, 0x59,
	0x5C, 0xCE, 0x52, 0x55, 0xD3, 0x5C, 0x60, 0xDC, 0x7B, 0x7B, 0xE9, 0xBC, 0xA8, 0xED, 0xD7, 0xB9,
	0xDB, 0x8C, 0x84, 0xD6, 0x71, 0x70, 0xD8, 0x72, 0x71, 0xD7, 0x63, 0x67, 0xD3, 0x5D, 0x61, 0xAD,
	0x42, 0x4F, 0x5D, 0x11, 0x3A, 0x4D, 0x0D, 0x3B, 0x69, 0x1A, 0x3E, 0x81, 0x29, 0x42, 0x6C, 0x1A,
	0x3B, 0x51, 0x02, 0x31, 0xA3, 0x56, 0x66, 0xD7, 0x94, 0x8C, 0xA1, 0x59, 0x66, 0x51, 0x0B, 0x37,
	0x4B, 0x05, 0x34, 0x90, 0x3E, 0x52, 0xC9, 0x74, 0x6E, 0xC9, 0x75, 0x6F, 0xD0, 0x86, 0x77, 0xCF,
	0x87, 0x77, 0xCC, 0x82, 0x74, 0xCA, 0x7E, 0x72, 0xCA, 0x7F, 0x73, 0xC9, 0x80, 0x74, 0xC8, 0x80,
	0x77, 0xC7, 0x7E, 0x75, 0xC4, 0x7C, 0x77, 0xC3, 0x7B, 0x76, 0xC2, 0x79, 0x75, 0xBF, 0x78, 0x76,
	0xBC, 0x75, 0x72, 0xB6, 0x70, 0x6D, 0xB4, 0x6A, 0x6E, 0xD3, 0x8E, 0x7B, 0xEE, 0xB7, 0x82, 0xF0,
	0xB8, 0x7D, 0xED, 0xB4, 0x7D, 0xED, 0xB5, 0x7E, 0xED, 0xBB, 0x88, 0xEE, 0xC3, 0x98, 0xEF, 0xC6,
	0x9A, 0xEE, 0xC2, 0x96, 0xEC, 0xC2, 0x99, 0xEA, 0xC2, 0xA0, 0xEA, 0xC3, 0xA2, 0xEA, 0xC3, 0xA4,
	0x8F, 0x32, 0x47, 0x8B, 0x2E, 0x43, 0x88, 0x2D, 0x42, 0x82, 0x26, 0x40, 0x7A, 0x1C, 0x3B, 0x62,
	0x0E, 0x35, 0x65, 0x0D, 0x34, 0xB3, 0x41, 0x47, 0xDE, 0x72, 0x62, 0xE4, 0x8C, 0x75, 0xE8, 0x96,
	0x79, 0xE9, 0x95, 0x78, 0xEA, 0x99, 0x79, 0xEB, 0x98, 0x77, 0xE6, 0x84, 0x69, 0xD2, 0x5C, 0x54,
	0x9E, 0x30, 0x43, 0x91, 0x36, 0x4E, 0xAD, 0x57, 0x66, 0xB3, 0x51, 0x5F, 0xB1, 0x4D, 0x5D, 0xB2,
	0x56, 0x66, 0x7D, 0x32, 0x5A, 0x6C, 0x2E, 0x60, 0x80, 0x4B, 0x7C, 0x80, 0x4A, 0x7C, 0x6C, 0x2E,
	0x5E, 0x6F, 0x34, 0x65, 0x78, 0x43, 0x71, 0x64, 0x2B, 0x5B, 0x7B, 0x46, 0x7A, 0x8F, 0x66, 0x8C,
	0x7F, 0x4E, 0x75, 0x66, 0x2B, 0x59, 0x58, 0x17, 0x46, 0x5F, 0x1B, 0x45, 0x59, 0x13, 0x3C, 0x50,
	0x0A, 0x37, 0x74, 0x2B, 0x4E, 0x8B, 0x3E, 0x56, 0x8F, 0x38, 0x4B, 0xA6, 0x51, 0x5C, 0x78, 0x2A,
	0x4A, 0x4F, 0x07, 0x36, 0x43, 0x00, 0x2E, 0x5A, 0x1E, 0x47, 0xB9, 0x76, 0x7B, 0xC0, 0x70, 0x70,
	0xBD, 0x7B, 0x7E, 0xD3, 0x9A, 0x8D, 0x7D, 0x32, 0x4B, 0x45, 0x00, 0x2E, 0x4F, 0x06, 0x33, 0x68,
	0x1F, 0x42, 0x90, 0x33, 0x4A, 0x92, 0x24, 0x3C, 0xB6, 0x3F, 0x48, 0xCC, 0x52, 0x55, 0xD1, 0x57,
	0x5A, 0xD5, 0x5A, 0x5C, 0xD9, 0x61, 0x61, 0xDA, 0x67, 0x68, 0xDB, 0x6D, 0x6C, 0xDD, 0x74, 0x6E,
	0xDD, 0x75, 0x6F, 0xDD, 0x7C, 0x74, 0xDE, 0x81, 0x77, 0xDE, 0x84, 0x7A, 0xDE, 0x84, 0x7A, 0xDB,
	0x79, 0x73, 0xD7, 0x68, 0x69, 0xC7, 0x4D, 0x52, 0xCF, 0x54, 0x58, 0xDE, 0x68, 0x67, 0xDE, 0x6A,
	0x67, 0xD7, 0x5E, 0x5E, 0xD4, 0x56, 0x58, 0xDB, 0x76, 0x74, 0xE8, 0xB9, 0xA7, 0xEC, 0xD3, 0xB6,
	0xD9, 0x86, 0x7D, 0xD6, 0x6D, 0x6B, 0xD8, 0x6E, 0x6F, 0xD5, 0x60, 0x63, 0xCE, 0x59, 0x5B, 0x8A,
	0x2F, 0x48, 0x4A, 0x09, 0x37, 0x53, 0x0F, 0x3C, 0x6A, 0x1A, 0x3E, 0x7F, 0x28, 0x41, 0x6D, 0x18,
	0x39, 0x4F, 0x01, 0x2F, 0x8F, 0x46, 0x5D, 0xD6, 0x97, 0x8E, 0xB4, 0x69, 0x6F, 0x58, 0x11, 0x3B,
	0x48, 0x05, 0x35, 0xA8, 0x52, 0x5D, 0xD2, 0x7A, 0x6D, 0xCC, 0x7B, 0x70, 0xCF, 0x88, 0x78, 0xCC,
	0x86, 0x77, 0xCB, 0x83, 0x75, 0xC9, 0x7F, 0x73, 0xC9, 0x7D, 0x73, 0xC9, 0x7D, 0x72, 0xC7, 0x7E,
	0x75, 0xC6, 0x7D, 0x76, 0xC4, 0x7C, 0x79, 0xC6, 0x7B, 0x75, 0xC2, 0x7A, 0x74, 0xBF, 0x79, 0x75,
	0xBD, 0x75, 0x71, 0xB3, 0x69, 0x6B, 0xBE, 0x73, 0x71, 0xE4, 0xA6, 0x7F, 0xF1, 0xBC, 0x81, 0xEF,
	0xB7, 0x7D, 0xED, 0xB5, 0x7E, 0xEE, 0xB8, 0x82, 0xEF, 0xC1, 0x91, 0xEE, 0xC4, 0x9A, 0xEE, 0xC4,
	0x98, 0xEE, 0xC2, 0x94, 0xED, 0xC2, 0x97, 0xEA, 0xC3, 0xA3, 0xEA, 0xC4, 0xA6, 0xEA, 0xC4, 0xA6,
	0x90, 0x33, 0x47, 0x8C, 0x2D, 0x43, 0x8A, 0x2C, 0x41, 0x86, 0x26, 0x3F, 0x7E, 0x1F, 0x3D, 0x6A,
	0x13, 0x37, 0x72, 0x16, 0x36, 0xB9, 0x49, 0x4F, 0xDE, 0x74, 0x66, 0xE4, 0x8B, 0x73, 0xE7, 0x94,
	0x78, 0xE8, 0x95, 0x7A, 0xEA, 0x98, 0x7A, 0xEB, 0x97, 0x74, 0xE6, 0x84, 0x68, 0xD2, 0x60, 0x5A,
	0xA5, 0x3F, 0x54, 0x97, 0x3C, 0x52, 0xA4, 0x40, 0x50, 0xAC, 0x3B, 0x49, 0xB4, 0x4C, 0x58, 0xA6,
	0x54, 0x68, 0x78, 0x2E, 0x57, 0x71, 0x33, 0x63, 0x8F, 0x5F, 0x8A, 0x84, 0x4A, 0x76, 0x58, 0x16,
	0x47, 0x79, 0x48, 0x73, 0x7A, 0x45, 0x72, 0x5F, 0x21, 0x53, 0x78, 0x42, 0x78, 0x92, 0x68, 0x8F,
	0x8B, 0x5F, 0x7F, 0x73, 0x3F, 0x68, 0x5F, 0x22, 0x4E, 0x60, 0x17, 0x3F, 0x69, 0x1C, 0x40, 0x49,
	0x06, 0x35, 0x57, 0x15, 0x40, 0x62, 0x1A, 0x43, 0x6D, 0x2E, 0x55, 0x88, 0x47, 0x63, 0x56, 0x0D,
	0x37, 0x43, 0x01, 0x2F, 0x38, 0x00, 0x2B, 0x86, 0x4E, 0x65, 0xE4, 0xAE, 0x9C, 0xDF, 0xAD, 0x9D,
	0xDA, 0xA8, 0x9A, 0x99, 0x52, 0x5E, 0x52, 0x05, 0x2F, 0x4E, 0x05, 0x33, 0x55, 0x09, 0x33, 0x68,
	0x1D, 0x42, 0x93, 0x38, 0x4F, 0x9B, 0x2A, 0x3E, 0xB9, 0x40, 0x48, 0xCD, 0x51, 0x51, 0xD3, 0x56,
	0x54, 0xD6, 0x58, 0x5B, 0xD8, 0x5F, 0x60, 0xD9, 0x66, 0x66, 0xDA, 0x6B, 0x6A, 0xDD, 0x72, 0x6D,
	0xDD, 0x75, 0x70, 0xDD, 0x78, 0x72, 0xDD, 0x7F, 0x76, 0xDE, 0x83, 0x78, 0xDE, 0x82, 0x77, 0xDC,
	0x7A, 0x73, 0xD8, 0x6A, 0x6A, 0xCC, 0x54, 0x59, 0xD8, 0x5B, 0x58, 0xBC, 0x49, 0x4F, 0xA5, 0x3B,
	0x4A, 0xC2, 0x4B, 0x51, 0xCC, 0x4A, 0x4B, 0xD8, 0x5D, 0x5C, 0xE5, 0xA0, 0x94, 0xE6, 0xB4, 0xA0,
	0xD7, 0x7B, 0x75, 0xD8, 0x6F, 0x6E, 0xD8, 0x6B, 0x6C, 0xD6, 0x62, 0x64, 0xBA, 0x4B, 0x52, 0x63,
	0x15, 0x3C, 0x49, 0x0B, 0x3B, 0x58, 0x14, 0x3F, 0x6E, 0x1C, 0x3E, 0x7D, 0x24, 0x3E, 0x6E, 0x18,
	0x38, 0x51, 0x01, 0x2E, 0x7F, 0x37, 0x53, 0xD2, 0x92, 0x8C, 0xB9, 0x6D, 0x72, 0x5E, 0x17, 0x3E,
	0x5A, 0x11, 0x3B, 0xBB, 0x65, 0x65, 0xD3, 0x7A, 0x6E, 0xCD, 0x80, 0x74, 0xCD, 0x89, 0x79, 0xC9,
	0x84, 0x77, 0xC9, 0x80, 0x76, 0xC8, 0x7E, 0x75, 0xC9, 0x7D, 0x74, 0xC9, 0x7E, 0x75, 0xC7, 0x7F,
	0x77, 0xC4, 0x7B, 0x76, 0xC3, 0x7B, 0x76, 0xC4, 0x7B, 0x73, 0xC1, 0x78, 0x70, 0xBE, 0x78, 0x73,
	0xBA, 0x73, 0x71, 0xB3, 0x67, 0x6E, 0xCC, 0x83, 0x75, 0xEC, 0xB1, 0x7F, 0xF0, 0xB9, 0x7E, 0xEE,
	0xB6, 0x7D, 0xEE, 0xB7, 0x7D, 0xEF, 0xBE, 0x8B, 0xEE, 0xC3, 0x96, 0xED, 0xC2, 0x97, 0xEC, 0xC2,
	0x9B, 0xEC, 0xC2, 0x9D, 0xEB, 0xC3, 0xA0, 0xEA, 0xC5, 0xA7, 0xEA, 0xC5, 0xA7, 0xEA, 0xC3, 0xA4,
	0x8D, 0x2D, 0x42, 0x8E, 0x2B, 0x40, 0x8E, 0x29, 0x3F, 0x8A, 0x26, 0x3E, 0x80, 0x21, 0x3D, 0x79,
	0x1C, 0x3A, 0x8B, 0x26, 0x3E, 0xC4, 0x56, 0x5A, 0xDF, 0x7A, 0x6D, 0xE4, 0x8C, 0x72, 0xE7, 0x94,
	0x79, 0xE9, 0x95, 0x7A, 0xEA, 0x98, 0x7C, 0xEB, 0x98, 0x78, 0xE6, 0x85, 0x6A, 0xD4, 0x62, 0x5C,
	0xA4, 0x36, 0x49, 0x8C, 0x23, 0x3B, 0x9A, 0x31, 0x41, 0xAE, 0x3D, 0x48, 0xB7, 0x4F, 0x5B, 0x9E,
	0x4C, 0x63, 0x82, 0x33, 0x57, 0x76, 0x38, 0x67, 0x86, 0x4C, 0x74, 0x70, 0x2F, 0x59, 0x60, 0x24,
	0x57, 0x86, 0x59, 0x85, 0x75, 0x3C, 0x6D, 0x6A, 0x2D, 0x60, 0x76, 0x3F, 0x74, 0x8E, 0x61, 0x90,
	0x95, 0x6D, 0x90, 0x81, 0x51, 0x79, 0x59, 0x21, 0x4D, 0x53, 0x0C, 0x36, 0x82, 0x32, 0x4E, 0x73,
	0x28, 0x46, 0x40, 0x00, 0x30, 0x4F, 0x13, 0x45, 0x8D, 0x56, 0x7A, 0x6F, 0x2C, 0x50, 0x53, 0x0B,
	0x37, 0x5B, 0x13, 0x3D, 0x5E, 0x19, 0x43, 0xAA, 0x62, 0x6B, 0xD9, 0x94, 0x86, 0xE6, 0xB5, 0xA0,
	0xA8, 0x6D, 0x73, 0x4C, 0x00, 0x2E, 0x50, 0x0B, 0x37, 0x5A, 0x0E, 0x38, 0x57, 0x08, 0x32, 0x6B,
	0x21, 0x45, 0x9B, 0x3F, 0x54, 0xA6, 0x32, 0x43, 0xBE, 0x44, 0x4A, 0xCB, 0x4E, 0x4E, 0xD3, 0x54,
	0x52, 0xD6, 0x59, 0x58, 0xD7, 0x5D, 0x5F, 0xD9, 0x64, 0x65, 0xDB, 0x6B, 0x6A, 0xDC, 0x70, 0x6D,
	0xDD, 0x72, 0x6D, 0xDD, 0x75, 0x70, 0xDD, 0x7D, 0x74, 0xDE, 0x80, 0x75, 0xDE, 0x82, 0x78, 0xDE,
	0x7D, 0x75, 0xDD, 0x71, 0x6D, 0xD5, 0x61, 0x62, 0xD5, 0x56, 0x55, 0xBD, 0x45, 0x4C, 0xAF, 0x3E,
	0x4B, 0xBC, 0x41, 0x48, 0xBD, 0x40, 0x49, 0xCF, 0x56, 0x5A, 0xDE, 0x90, 0x88, 0xE2, 0x9A, 0x8E,
	0xDB, 0x7A, 0x77, 0xD7, 0x70, 0x70, 0xD8, 0x67, 0x6A, 0xD5, 0x60, 0x61, 0x93, 0x33, 0x48, 0x4F,
	0x0D, 0x3B, 0x50, 0x11, 0x3F, 0x5B, 0x15, 0x3F, 0x75, 0x21, 0x3F, 0x7F, 0x27, 0x3F, 0x70, 0x19,
	0x39, 0x57, 0x05, 0x2F, 0x71, 0x26, 0x48, 0xCB, 0x88, 0x85, 0xC0, 0x75, 0x77, 0x68, 0x1F, 0x45,
	0x7A, 0x29, 0x46, 0xCE, 0x74, 0x6A, 0xD2, 0x79, 0x6C, 0xCD, 0x83, 0x76, 0xCD, 0x88, 0x77, 0xCA,
	0x82, 0x76, 0xC9, 0x7E, 0x74, 0xC8, 0x7D, 0x74, 0xC7, 0x7D, 0x76, 0xC7, 0x7F, 0x77, 0xC6, 0x7F,
	0x77, 0xC4, 0x7B, 0x76, 0xC1, 0x79, 0x74, 0xC0, 0x77, 0x70, 0xC1, 0x77, 0x70, 0xBF, 0x77, 0x73,
	0xB7, 0x70, 0x70, 0xB7, 0x6A, 0x6E, 0xD9, 0x92, 0x78, 0xF0, 0xB7, 0x7E, 0xEF, 0xB8, 0x7E, 0xEF,
	0xB7, 0x7D, 0xF0, 0xBC, 0x86, 0xEE, 0xC3, 0x96, 0xED, 0xC3, 0x99, 0xEC, 0xC2, 0x9D, 0xEA, 0xC2,
	0x9F, 0xEC, 0xC5, 0xA4, 0xEB, 0xC5, 0xA6, 0xEA, 0xC4, 0xA5, 0xEB, 0xC3, 0xA2, 0xEA, 0xC3, 0xA3,
	0x8C, 0x2B, 0x40, 0x8D, 0x2A, 0x3F, 0x90, 0x29, 0x3E, 0x8B, 0x27, 0x3E, 0x80, 0x21, 0x3D, 0x82,
	0x24, 0x3E, 0x9E, 0x35, 0x47, 0xCA, 0x61, 0x62, 0xDD, 0x7F, 0x72, 0xE3, 0x8C, 0x74, 0xE6, 0x92,
	0x75, 0xE7, 0x92, 0x77, 0xEA, 0x98, 0x7A, 0xEB, 0x9B, 0x7A, 0xE6, 0x87, 0x6C, 0xD6, 0x61, 0x58,
	0xA4, 0x32, 0x42, 0x8C, 0x26, 0x3D, 0x9C, 0x35, 0x44, 0xAB, 0x3C, 0x49, 0xBB, 0x51, 0x5C, 0xAB,
	0x51, 0x65, 0x69, 0x21, 0x4C, 0x6C, 0x2E, 0x5E, 0x6B, 0x29, 0x59, 0x5E, 0x1F, 0x50, 0x7C, 0x48,
	0x75, 0x70, 0x36, 0x64, 0x6E, 0x33, 0x64, 0x73, 0x3A, 0x6C, 0x7F, 0x4B, 0x7F, 0x83, 0x51, 0x86,
	0x8F, 0x65, 0x8F, 0x98, 0x71, 0x98, 0x67, 0x33, 0x61, 0x41, 0x00, 0x2B, 0x93, 0x42, 0x57, 0xC2,
	0x6A, 0x67, 0x4E, 0x0B, 0x35, 0x4E, 0x17, 0x49, 0x72, 0x32, 0x5B, 0x63, 0x1C, 0x45, 0x83, 0x36,
	0x55, 0xAA, 0x63, 0x72, 0xB4, 0x6F, 0x75, 0xA9, 0x47, 0x53, 0xC8, 0x7A, 0x7A, 0xC2, 0x91, 0x8C,
	0x56, 0x14, 0x3C, 0x4B, 0x04, 0x33, 0x64, 0x1F, 0x47, 0x61, 0x17, 0x3E, 0x55, 0x06, 0x30, 0x6E,
	0x24, 0x49, 0x9F, 0x47, 0x59, 0xA7, 0x34, 0x44, 0xC2, 0x47, 0x4D, 0xCD, 0x51, 0x51, 0xD2, 0x54,
	0x53, 0xD5, 0x58, 0x57, 0xD6, 0x5C, 0x5F, 0xD8, 0x62, 0x63, 0xDB, 0x69, 0x67, 0xDB, 0x6D, 0x6B,
	0xDC, 0x6E, 0x6C, 0xDD, 0x73, 0x70, 0xDD, 0x79, 0x73, 0xDD, 0x7D, 0x74, 0xDE, 0x81, 0x79, 0xDD,
	0x7F, 0x77, 0xDC, 0x79, 0x73, 0xD9, 0x70, 0x6F, 0xD6, 0x63, 0x65, 0xD9, 0x5D, 0x5F, 0xE0, 0x67,
	0x62, 0xD9, 0x67, 0x64, 0xD3, 0x6C, 0x6E, 0xDC, 0x9D, 0x97, 0xE0, 0xAB, 0x9C, 0xE0, 0x8F, 0x86,
	0xD9, 0x79, 0x78, 0xD5, 0x6F, 0x70, 0xD7, 0x66, 0x6A, 0xC0, 0x54, 0x5B, 0x69, 0x1C, 0x41, 0x4E,
	0x0E, 0x3D, 0x52, 0x13, 0x41, 0x5E, 0x17, 0x41, 0x7B, 0x28, 0x45, 0x82, 0x2E, 0x46, 0x73, 0x1D,
	0x3B, 0x5C, 0x0A, 0x32, 0x65, 0x19, 0x41, 0xC1, 0x7E, 0x7E, 0xC2, 0x77, 0x78, 0x75, 0x27, 0x49,
	0x91, 0x3E, 0x51, 0xD6, 0x79, 0x6D, 0xD0, 0x79, 0x6C, 0xCD, 0x85, 0x76, 0xCC, 0x86, 0x76, 0xCB,
	0x82, 0x76, 0xC9, 0x7F, 0x74, 0xC9, 0x7E, 0x74, 0xC7, 0x7D, 0x75, 0xC5, 0x7D, 0x76, 0xC5, 0x7D,
	0x77, 0xC5, 0x7B, 0x74, 0xC3, 0x7A, 0x73, 0xBF, 0x79, 0x74, 0xBF, 0x77, 0x73, 0xBD, 0x76, 0x72,
	0xB4, 0x6C, 0x6D, 0xBC, 0x70, 0x6D, 0xE3, 0xA0, 0x7A, 0xF1, 0xBA, 0x7F, 0xEE, 0xB7, 0x7E, 0xF0,
	0xBA, 0x80, 0xF0, 0xC2, 0x90, 0xEE, 0xC5, 0x99, 0xEC, 0xC3, 0x9C, 0xEC, 0xC2, 0x9D, 0xED, 0xC3,
	0x9D, 0xED, 0xC7, 0xA3, 0xEC, 0xC5, 0xA4, 0xEB, 0xC3, 0xA1, 0xEA, 0xC2, 0xA1, 0xEB, 0xC6, 0xA9,
	0x8B, 0x2B, 0x41, 0x88, 0x28, 0x3F, 0x8E, 0x2B, 0x40, 0x8C, 0x29, 0x3F, 0x7D, 0x1E, 0x3C, 0x7D,
	0x21, 0x3D, 0xA1, 0x3E, 0x4F, 0xCD, 0x67, 0x69, 0xDE, 0x80, 0x75, 0xE2, 0x8B, 0x76, 0xE6, 0x91,
	0x72, 0xE8, 0x93, 0x74, 0xEA, 0x98, 0x79, 0xEB, 0x99, 0x79, 0xE6, 0x88, 0x6C, 0xD5, 0x64, 0x5A,
	0xA3, 0x35, 0x44, 0x8B, 0x28, 0x3F, 0x9A, 0x34, 0x46, 0xA7, 0x39, 0x48, 0xC0, 0x59, 0x62, 0xB9,
	0x68, 0x74, 0x65, 0x21, 0x4D, 0x62, 0x23, 0x56, 0x74, 0x38, 0x69, 0x85, 0x51, 0x7E, 0x6D, 0x32,
	0x5E, 0x53, 0x12, 0x42, 0x6A, 0x2B, 0x5B, 0x73, 0x3A, 0x6B, 0x80, 0x4D, 0x80, 0x84, 0x52, 0x88,
	0x83, 0x53, 0x81, 0x97, 0x72, 0x99, 0x87, 0x59, 0x83, 0x5E, 0x19, 0x49, 0x82, 0x35, 0x59, 0xA4,
	0x4E, 0x5E, 0x66, 0x1E, 0x44, 0x4C, 0x0F, 0x40, 0x66, 0x26, 0x4F, 0xA3, 0x61, 0x72, 0xBA, 0x7C,
	0x82, 0xD0, 0x9F, 0x98, 0xAD, 0x5B, 0x61, 0xA7, 0x4B, 0x59, 0xCD, 0x9A, 0x92, 0x7A, 0x41, 0x5A,
	0x48, 0x06, 0x38, 0x5B, 0x17, 0x41, 0x63, 0x1B, 0x42, 0x67, 0x1C, 0x40, 0x59, 0x0D, 0x38, 0x6A,
	0x23, 0x4A, 0x9C, 0x49, 0x5E, 0xAA, 0x39, 0x48, 0xC1, 0x48, 0x4E, 0xCF, 0x54, 0x56, 0xD2, 0x55,
	0x55, 0xD4, 0x57, 0x58, 0xD7, 0x5D, 0x60, 0xD9, 0x63, 0x65, 0xDA, 0x67, 0x66, 0xDA, 0x69, 0x68,
	0xDA, 0x6A, 0x6A, 0xDD, 0x72, 0x6E, 0xDC, 0x7A, 0x74, 0xDC, 0x7D, 0x76, 0xDE, 0x80, 0x78, 0xDC,
	0x80, 0x78, 0xD9, 0x7B, 0x76, 0xD9, 0x77, 0x73, 0xDA, 0x71, 0x6F, 0xD9, 0x68, 0x68, 0xDE, 0x7F,
	0x78, 0xE2, 0x9F, 0x93, 0xE2, 0x96, 0x8E, 0xE8, 0xB9, 0xA9, 0xE5, 0xB4, 0xA4, 0xDE, 0x8C, 0x85,
	0xD7, 0x74, 0x74, 0xD6, 0x6C, 0x6E, 0xD7, 0x67, 0x69, 0x99, 0x3E, 0x52, 0x51, 0x11, 0x3F, 0x51,
	0x11, 0x3F, 0x54, 0x13, 0x40, 0x67, 0x1D, 0x45, 0x81, 0x2B, 0x46, 0x83, 0x2C, 0x44, 0x77, 0x21,
	0x3D, 0x64, 0x12, 0x37, 0x5B, 0x0E, 0x3A, 0xB2, 0x6E, 0x75, 0xBD, 0x78, 0x79, 0x8A, 0x37, 0x4F,
	0xAE, 0x54, 0x5C, 0xD5, 0x76, 0x6B, 0xCF, 0x7B, 0x6D, 0xCD, 0x86, 0x76, 0xCA, 0x84, 0x77, 0xC9,
	0x82, 0x77, 0xC8, 0x7F, 0x76, 0xC8, 0x7E, 0x75, 0xC7, 0x7C, 0x74, 0xC5, 0x7B, 0x75, 0xC3, 0x7B,
	0x76, 0xC4, 0x79, 0x75, 0xC5, 0x7B, 0x76, 0xC2, 0x7A, 0x74, 0xBF, 0x77, 0x72, 0xBC, 0x75, 0x71,
	0xB3, 0x6A, 0x6B, 0xC3, 0x77, 0x70, 0xE9, 0xA8, 0x7B, 0xF0, 0xB9, 0x7D, 0xEF, 0xB7, 0x7D, 0xF0,
	0xBE, 0x8A, 0xEF, 0xC4, 0x96, 0xEE, 0xC4, 0x98, 0xED, 0xC2, 0x97, 0xEE, 0xC2, 0x96, 0xEE, 0xC5,
	0x9A, 0xED, 0xC6, 0x9F, 0xEB, 0xC5, 0xA4, 0xEC, 0xC7, 0xA6, 0xE9, 0xC6, 0xA9, 0xEB, 0xC8, 0xAC,
	0x88, 0x27, 0x3E, 0x87, 0x24, 0x3D, 0x89, 0x24, 0x3D, 0x88, 0x24, 0x3D, 0x7B, 0x1C, 0x3A, 0x7C,
	0x1E, 0x3B, 0xA2, 0x3E, 0x50, 0xCC, 0x68, 0x6B, 0xDD, 0x80, 0x74, 0xE3, 0x8C, 0x74, 0xE6, 0x91,
	0x73, 0xE8, 0x93, 0x73, 0xE9, 0x98, 0x79, 0xEB, 0x9A, 0x78, 0xE7, 0x89, 0x6C, 0xD5, 0x65, 0x5A,
	0xA4, 0x35, 0x44, 0x89, 0x25, 0x3D, 0x98, 0x2D, 0x3F, 0xAD, 0x46, 0x54, 0xC2, 0x6D, 0x74, 0xA8,
	0x59, 0x6B, 0x6E, 0x26, 0x51, 0x73, 0x35, 0x66, 0x88, 0x58, 0x87, 0x6F, 0x34, 0x61, 0x5B, 0x1B,
	0x49, 0x5A, 0x1B, 0x4A, 0x67, 0x26, 0x56, 0x6A, 0x2B, 0x5B, 0x6F, 0x34, 0x64, 0x7C, 0x48, 0x7B,
	0x78, 0x43, 0x75, 0x8E, 0x63, 0x90, 0x94, 0x6B, 0x91, 0x81, 0x42, 0x69, 0x8D, 0x44, 0x61, 0x6E,
	0x21, 0x47, 0x58, 0x0F, 0x39, 0x62, 0x12, 0x3D, 0x97, 0x51, 0x68, 0xCA, 0x8D, 0x8A, 0xDB, 0xB1,
	0xA5, 0xC1, 0x85, 0x81, 0x94, 0x2E, 0x41, 0xB9, 0x6F, 0x73, 0x8F, 0x56, 0x66, 0x49, 0x00, 0x30,
	0x5C, 0x11, 0x39, 0x5F, 0x11, 0x37, 0x68, 0x18, 0x3B, 0x6E, 0x1F, 0x3F, 0x5A, 0x0E, 0x37, 0x65,
	0x19, 0x40, 0x96, 0x46, 0x5E, 0xA9, 0x3F, 0x4E, 0xC0, 0x46, 0x4B, 0xCF, 0x53, 0x53, 0xD5, 0x57,
	0x56, 0xD5, 0x59, 0x59, 0xD7, 0x5D, 0x5C, 0xD9, 0x64, 0x63, 0xDA, 0x66, 0x66, 0xD9, 0x66, 0x68,
	0xDA, 0x68, 0x68, 0xDC, 0x6C, 0x68, 0xDC, 0x73, 0x6E, 0xDD, 0x76, 0x70, 0xDD, 0x76, 0x70, 0xDB,
	0x7B, 0x74, 0xD9, 0x76, 0x72, 0xD9, 0x74, 0x6F, 0xD8, 0x74, 0x71, 0xDA, 0x74, 0x6F, 0xE3, 0x98,
	0x8E, 0xE8, 0xC0, 0xB1, 0xE2, 0xA1, 0x97, 0xE8, 0xB7, 0xA9, 0xE8, 0xB6, 0xA7, 0xDD, 0x89, 0x82,
	0xD6, 0x70, 0x71, 0xDA, 0x6D, 0x6F, 0xC8, 0x5E, 0x63, 0x6B, 0x1F, 0x42, 0x4D, 0x0E, 0x3D, 0x54,
	0x12, 0x3D, 0x57, 0x15, 0x3E, 0x6D, 0x22, 0x45, 0x83, 0x2C, 0x44, 0x81, 0x26, 0x3F, 0x79, 0x1F,
	0x3C, 0x64, 0x10, 0x35, 0x54, 0x07, 0x34, 0xA6, 0x61, 0x6C, 0xBB, 0x79, 0x78, 0x9A, 0x46, 0x59,
	0xC6, 0x64, 0x60, 0xD7, 0x74, 0x64, 0xCD, 0x7E, 0x70, 0xCC, 0x86, 0x77, 0xC9, 0x84, 0x78, 0xC9,
	0x81, 0x76, 0xC8, 0x7D, 0x75, 0xC7, 0x7D, 0x76, 0xC4, 0x7C, 0x76, 0xC3, 0x7C, 0x76, 0xC1, 0x79,
	0x75, 0xC0, 0x79, 0x75, 0xC1, 0x79, 0x75, 0xBF, 0x78, 0x74, 0xBD, 0x76, 0x70, 0xBB, 0x74, 0x6E,
	0xB3, 0x69, 0x6A, 0xCA, 0x7E, 0x71, 0xEC, 0xAE, 0x7C, 0xEF, 0xB8, 0x7C, 0xF0, 0xBB, 0x83, 0xEF,
	0xC4, 0x95, 0xEF, 0xC6, 0x99, 0xEE, 0xC3, 0x96, 0xED, 0xC2, 0x97, 0xEE, 0xC3, 0x97, 0xEE, 0xC4,
	0x97, 0xEC, 0xC3, 0x9F, 0xEB, 0xC7, 0xAA, 0xEC, 0xC8, 0xA9, 0xEA, 0xC8, 0xAA, 0xE9, 0xC9, 0xAD,
	0x84, 0x24, 0x3D, 0x82, 0x22, 0x3E, 0x84, 0x23, 0x3D, 0x82, 0x21, 0x3D, 0x7B, 0x1E, 0x3C, 0x80,
	0x21, 0x3C, 0x9D, 0x3A, 0x4D, 0xC6, 0x64, 0x6B, 0xDA, 0x7E, 0x75, 0xE4, 0x8C, 0x72, 0xE6, 0x92,
	0x72, 0xE8, 0x93, 0x75, 0xEA, 0x99, 0x7A, 0xEA, 0x9C, 0x79, 0xE7, 0x8B, 0x6C, 0xD8, 0x65, 0x59,
	0xA4, 0x34, 0x43, 0x88, 0x1F, 0x39, 0x9B, 0x34, 0x48, 0xB1, 0x5F, 0x6C, 0xB8, 0x59, 0x64, 0xA1,
	0x4A, 0x60, 0x6E, 0x29, 0x57, 0x83, 0x4B, 0x79, 0x7B, 0x46, 0x74, 0x56, 0x11, 0x41, 0x65, 0x27,
	0x56, 0x68, 0x2B, 0x5A, 0x67, 0x2B, 0x5A, 0x6C, 0x2D, 0x5D, 0x67, 0x27, 0x57, 0x74, 0x3A, 0x6A,
	0x6D, 0x33, 0x64, 0x7D, 0x4B, 0x79, 0x93, 0x6D, 0x9B, 0x9F, 0x6B, 0x8A, 0x82, 0x38, 0x4D, 0x4C,
	0x00, 0x2F, 0x7F, 0x32, 0x4F, 0x9B, 0x4C, 0x63, 0xAC, 0x5E, 0x6C, 0xD0, 0x9F, 0x98, 0xD2, 0xA3,
	0x98, 0x9F, 0x41, 0x4E, 0xAD, 0x51, 0x5C, 0x9E, 0x62, 0x6E, 0x4B, 0x0A, 0x37, 0x63, 0x15, 0x3B,
	0x66, 0x18, 0x3C, 0x60, 0x0F, 0x35, 0x69, 0x16, 0x37, 0x76, 0x23, 0x3F, 0x5F, 0x0F, 0x36, 0x63,
	0x12, 0x38, 0x95, 0x40, 0x56, 0xA1, 0x3D, 0x4F, 0xB9, 0x40, 0x49, 0xCE, 0x50, 0x50, 0xD5, 0x56,
	0x55, 0xD6, 0x59, 0x58, 0xD7, 0x5D, 0x5C, 0xD9, 0x62, 0x63, 0xD9, 0x66, 0x67, 0xDA, 0x66, 0x65,
	0xD9, 0x63, 0x63, 0xD9, 0x64, 0x64, 0xDB, 0x6B, 0x6B, 0xDE, 0x70, 0x6D, 0xDC, 0x6E, 0x6D, 0xDB,
	0x71, 0x6E, 0xDA, 0x71, 0x6E, 0xD9, 0x70, 0x6F, 0xD8, 0x7A, 0x76, 0xDC, 0x81, 0x7A, 0xE5, 0x9F,
	0x92, 0xE8, 0xC3, 0xB1, 0xE4, 0xB2, 0xA3, 0xE9, 0xBB, 0xAB, 0xE8, 0xB7, 0xA7, 0xDD, 0x87, 0x81,
	0xD4, 0x67, 0x6A, 0xD8, 0x6F, 0x6F, 0x9E, 0x46, 0x59, 0x4F, 0x0C, 0x3A, 0x55, 0x13, 0x40, 0x56,
	0x14, 0x3F, 0x5B, 0x15, 0x3F, 0x71, 0x23, 0x44, 0x86, 0x2E, 0x45, 0x7F, 0x25, 0x41, 0x78, 0x1F,
	0x3C, 0x65, 0x10, 0x35, 0x4F, 0x05, 0x34, 0x9E, 0x5A, 0x67, 0xBE, 0x77, 0x78, 0xA5, 0x4F, 0x5F,
	0xCF, 0x68, 0x5E, 0xD3, 0x75, 0x67, 0xCB, 0x82, 0x74, 0xCB, 0x85, 0x76, 0xCA, 0x83, 0x76, 0xCA,
	0x80, 0x75, 0xC9, 0x7C, 0x74, 0xC6, 0x7B, 0x75, 0xC5, 0x7D, 0x76, 0xC4, 0x7D, 0x77, 0xC4, 0x7B,
	0x75, 0xC2, 0x79, 0x74, 0xC0, 0x77, 0x74, 0xBF, 0x78, 0x72, 0xBE, 0x77, 0x6F, 0xB8, 0x70, 0x6D,
	0xB1, 0x66, 0x6A, 0xCD, 0x82, 0x71, 0xED, 0xB0, 0x7C, 0xF0, 0xBA, 0x80, 0xF0, 0xC1, 0x8D, 0xF0,
	0xC7, 0x95, 0xEF, 0xC5, 0x95, 0xEE, 0xC2, 0x95, 0xED, 0xC3, 0x9A, 0xED, 0xC3, 0x98, 0xED, 0xC3,
	0x9A, 0xEB, 0xC6, 0xA6, 0xEC, 0xCB, 0xAD, 0xEC, 0xC8, 0xA9, 0xEB, 0xC7, 0xA9, 0xEA, 0xC9, 0xAC,
	0x7A, 0x20, 0x3E, 0x77, 0x1B, 0x3B, 0x7D, 0x21, 0x3E, 0x7F, 0x23, 0x3F, 0x7A, 0x1C, 0x3C, 0x7F,
	0x1F, 0x3A, 0x99, 0x38, 0x4B, 0xC6, 0x64, 0x6A, 0xDB, 0x7F, 0x77, 0xE2, 0x8D, 0x77, 0xE5, 0x94,
	0x76, 0xE8, 0x94, 0x79, 0xEA, 0x9B, 0x7C, 0xEA, 0x9B, 0x7C, 0xE7, 0x8B, 0x6D, 0xD8, 0x65, 0x58,
	0xA2, 0x31, 0x41, 0x85, 0x1E, 0x3B, 0xA9, 0x53, 0x63, 0xAC, 0x51, 0x5F, 0xB4, 0x46, 0x52, 0xA0,
	0x4F, 0x65, 0x5F, 0x1B, 0x4C, 0x74, 0x3C, 0x6B, 0x75, 0x3B, 0x68, 0x5B, 0x1A, 0x48, 0x63, 0x25,
	0x53, 0x62, 0x25, 0x53, 0x6E, 0x36, 0x66, 0x7B, 0x43, 0x75, 0x73, 0x37, 0x66, 0x6F, 0x31, 0x62,
	0x70, 0x36, 0x66, 0x69, 0x2F, 0x5D, 0x7E, 0x4C, 0x7C, 0x9D, 0x75, 0xA0, 0x68, 0x33, 0x61, 0x68,
	0x21, 0x47, 0xB0, 0x67, 0x76, 0xC7, 0x9A, 0x9C, 0xD3, 0xAE, 0xA6, 0xD8, 0xAE, 0x9E, 0xAC, 0x54,
	0x5A, 0xA3, 0x3F, 0x4F, 0xB5, 0x75, 0x79, 0x5B, 0x21, 0x46, 0x4B, 0x05, 0x33, 0x81, 0x2A, 0x43,
	0x65, 0x15, 0x3B, 0x5D, 0x0E, 0x36, 0x6A, 0x19, 0x3A, 0x7D, 0x28, 0x42, 0x67, 0x13, 0x38, 0x64,
	0x12, 0x38, 0x90, 0x3D, 0x52, 0x99, 0x37, 0x4A, 0xAF, 0x37, 0x44, 0xCB, 0x4D, 0x50, 0xD5, 0x57,
	0x55, 0xD8, 0x5A, 0x56, 0xD8, 0x5C, 0x58, 0xDA, 0x60, 0x5D, 0xD9, 0x63, 0x61, 0xDA, 0x67, 0x66,
	0xD9, 0x63, 0x62, 0xDA, 0x66, 0x64, 0xD6, 0x61, 0x60, 0xD4, 0x5C, 0x5A, 0xD9, 0x64, 0x62, 0xDA,
	0x6A, 0x68, 0xD9, 0x6B, 0x68, 0xD9, 0x68, 0x66, 0xDA, 0x6E, 0x69, 0xDB, 0x70, 0x69, 0xDA, 0x6F,
	0x69, 0xDE, 0x81, 0x76, 0xE1, 0x94, 0x85, 0xD9, 0x80, 0x7B, 0xD8, 0x7B, 0x77, 0xCC, 0x65, 0x66,
	0xCF, 0x61, 0x66, 0xCE, 0x69, 0x6C, 0x71, 0x25, 0x47, 0x4B, 0x0A, 0x3A, 0x5A, 0x17, 0x41, 0x58,
	0x14, 0x3F, 0x60, 0x16, 0x3E, 0x73, 0x24, 0x44, 0x82, 0x2D, 0x45, 0x84, 0x2B, 0x44, 0x7E, 0x24,
	0x40, 0x6A, 0x14, 0x37, 0x4B, 0x01, 0x31, 0x91, 0x4E, 0x63, 0xBF, 0x79, 0x7B, 0xB3, 0x59, 0x60,
	0xD5, 0x6D, 0x60, 0xD1, 0x75, 0x68, 0xCB, 0x83, 0x75, 0xCC, 0x85, 0x76, 0xCA, 0x81, 0x74, 0xC9,
	0x7E, 0x74, 0xC6, 0x7C, 0x75, 0xC4, 0x7A, 0x73, 0xC5, 0x7D, 0x76, 0xC5, 0x7D, 0x76, 0xC5, 0x7C,
	0x75, 0xC0, 0x79, 0x77, 0xBE, 0x78, 0x77, 0xC0, 0x78, 0x6F, 0xBF, 0x76, 0x6E, 0xB7, 0x6F, 0x6D,
	0xB0, 0x66, 0x69, 0xD0, 0x85, 0x73, 0xEF, 0xB2, 0x7C, 0xF2, 0xBF, 0x87, 0xF0, 0xC8, 0x99, 0xF1,
	0xCB, 0x9B, 0xEE, 0xC4, 0x97, 0xEE, 0xC4, 0x97, 0xF0, 0xC7, 0x9A, 0xEE, 0xC6, 0x9D, 0xED, 0xC7,
	0xA2, 0xED, 0xCA, 0xAA, 0xEC, 0xCC, 0xAD, 0xEB, 0xCA, 0xAB, 0xEA, 0xC8, 0xAA, 0xEB, 0xCA, 0xAB,
	0x6E, 0x1A, 0x3A, 0x71, 0x18, 0x39, 0x77, 0x1D, 0x3C, 0x7E, 0x20, 0x3E, 0x78, 0x1A, 0x3A, 0x81,
	0x20, 0x3B, 0x9B, 0x3B, 0x4D, 0xC8, 0x66, 0x6B, 0xDE, 0x81, 0x78, 0xE4, 0x90, 0x79, 0xE7, 0x96,
	0x7A, 0xE8, 0x96, 0x7B, 0xEA, 0x9A, 0x7C, 0xEB, 0x9B, 0x79, 0xE7, 0x8A, 0x6E, 0xD7, 0x61, 0x57,
	0x9C, 0x2A, 0x3E, 0x98, 0x43, 0x58, 0xAD, 0x58, 0x65, 0xA1, 0x33, 0x47, 0xC3, 0x68, 0x6D, 0x9D,
	0x51, 0x67, 0x5C, 0x16, 0x48, 0x63, 0x23, 0x52, 0x64, 0x25, 0x53, 0x64, 0x27, 0x55, 0x65, 0x29,
	0x57, 0x5A, 0x1B, 0x48, 0x6E, 0x37, 0x67, 0x8C, 0x5E, 0x92, 0x86, 0x54, 0x83, 0x79, 0x40, 0x70,
	0x6F, 0x34, 0x64, 0x7A, 0x46, 0x77, 0x7D, 0x4A, 0x7B, 0x75, 0x40, 0x74, 0x77, 0x40, 0x70, 0xA4,
	0x64, 0x77, 0xB8, 0x77, 0x82, 0xDB, 0xBC, 0xB2, 0xEB, 0xD5, 0xC0, 0xB6, 0x6D, 0x6E, 0x9B, 0x2F,
	0x41, 0xBE, 0x77, 0x7C, 0x80, 0x49, 0x60, 0x46, 0x01, 0x32, 0x58, 0x0D, 0x37, 0x71, 0x1C, 0x3B,
	0x65, 0x14, 0x38, 0x5C, 0x0D, 0x34, 0x6B, 0x18, 0x3A, 0x7C, 0x26, 0x40, 0x6C, 0x18, 0x39, 0x61,
	0x11, 0x38, 0x89, 0x38, 0x4F, 0x8D, 0x33, 0x48, 0xA2, 0x31, 0x42, 0xC5, 0x4A, 0x4D, 0xD4, 0x58,
	0x56, 0xD6, 0x5A, 0x56, 0xD6, 0x57, 0x52, 0xD9, 0x5C, 0x58, 0xDA, 0x60, 0x5D, 0xDA, 0x67, 0x66,
	0xDC, 0x6C, 0x69, 0xDE, 0x6C, 0x62, 0xC4, 0x4B, 0x4E, 0xAE, 0x37, 0x44, 0xB6, 0x3F, 0x48, 0xC0,
	0x49, 0x4D, 0xC9, 0x4E, 0x51, 0xC8, 0x4D, 0x4E, 0xC0, 0x43, 0x49, 0xB9, 0x3B, 0x45, 0xBE, 0x3B,
	0x44, 0xD1, 0x4A, 0x4B, 0xCF, 0x50, 0x53, 0xB7, 0x3E, 0x4C, 0xBC, 0x44, 0x4F, 0xC1, 0x4D, 0x54,
	0xDA, 0x70, 0x6D, 0xA9, 0x4F, 0x5C, 0x4F, 0x0C, 0x3B, 0x55, 0x11, 0x3D, 0x5B, 0x14, 0x3D, 0x59,
	0x11, 0x3B, 0x68, 0x1C, 0x40, 0x74, 0x24, 0x42, 0x7F, 0x28, 0x41, 0x85, 0x2D, 0x43, 0x76, 0x1E,
	0x3C, 0x6F, 0x1A, 0x3B, 0x51, 0x04, 0x31, 0x83, 0x3D, 0x57, 0xBC, 0x78, 0x7B, 0xC3, 0x68, 0x67,
	0xDA, 0x72, 0x63, 0xD2, 0x77, 0x69, 0xCB, 0x84, 0x75, 0xCB, 0x85, 0x76, 0xC9, 0x80, 0x74, 0xC7,
	0x7F, 0x75, 0xC6, 0x7C, 0x75, 0xC5, 0x7B, 0x75, 0xC2, 0x7C, 0x76, 0xC0, 0x7B, 0x79, 0xC3, 0x7C,
	0x77, 0xBF, 0x7A, 0x77, 0xBD, 0x79, 0x75, 0xC1, 0x78, 0x71, 0xBE, 0x76, 0x70, 0xB4, 0x6D, 0x6D,
	0xB0, 0x65, 0x69, 0xD7, 0x8B, 0x72, 0xF2, 0xB8, 0x80, 0xF2, 0xC6, 0x90, 0xF1, 0xCD, 0x9E, 0xF0,
	0xCA, 0x9C, 0xEE, 0xC4, 0x98, 0xEE, 0xC4, 0x97, 0xF0, 0xC7, 0x9A, 0xEF, 0xC8, 0x9F, 0xEF, 0xCA,
	0xA4, 0xED, 0xCA, 0xAA, 0xEC, 0xCD, 0xAD, 0xEB, 0xCD, 0xAD, 0xEB, 0xCB, 0xAB, 0xEC, 0xCC, 0xAC,
	0x67, 0x17, 0x3A, 0x6B, 0x19, 0x3A, 0x75, 0x1D, 0x3C, 0x7B, 0x1E, 0x3D, 0x77, 0x1B, 0x3A, 0x84,
	0x29, 0x43, 0xA1, 0x43, 0x57, 0xC9, 0x68, 0x6C, 0xDE, 0x82, 0x74, 0xE5, 0x91, 0x75, 0xE8, 0x98,
	0x77, 0xE9, 0x98, 0x79, 0xEA, 0x9E, 0x7B, 0xEA, 0x9C, 0x79, 0xE6, 0x86, 0x6B, 0xCF, 0x5B, 0x5A,
	0xAF, 0x52, 0x61, 0xAC, 0x60, 0x6B, 0x98, 0x2F, 0x44, 0xAB, 0x47, 0x57, 0xC7, 0x79, 0x7C, 0x93,
	0x46, 0x62, 0x65, 0x21, 0x51, 0x5F, 0x1B, 0x4B, 0x54, 0x13, 0x41, 0x5E, 0x20, 0x4E, 0x67, 0x2A,
	0x5A, 0x62, 0x24, 0x54, 0x74, 0x41, 0x6C, 0x96, 0x6E, 0x96, 0x7C, 0x45, 0x77, 0x83, 0x50, 0x83,
	0x7E, 0x4A, 0x7D, 0x7B, 0x45, 0x73, 0x7E, 0x49, 0x75, 0x67, 0x2F, 0x64, 0x82, 0x46, 0x70, 0xCB,
	0x6C, 0x6C, 0xD9, 0x62, 0x5F, 0xE7, 0xB8, 0xA8, 0xCD, 0xA5, 0x9A, 0x9B, 0x36, 0x49, 0xC2, 0x6D,
	0x6F, 0xA6, 0x72, 0x79, 0x50, 0x10, 0x3D, 0x5A, 0x0E, 0x38, 0x55, 0x0D, 0x37, 0x64, 0x15, 0x38,
	0x68, 0x15, 0x38, 0x5F, 0x10, 0x36, 0x69, 0x18, 0x3B, 0x73, 0x20, 0x3E, 0x70, 0x1C, 0x3C, 0x62,
	0x12, 0x3A, 0x80, 0x2E, 0x49, 0x86, 0x31, 0x46, 0x99, 0x30, 0x42, 0xBF, 0x44, 0x49, 0xCF, 0x53,
	0x50, 0xD2, 0x55, 0x50, 0xD2, 0x54, 0x52, 0xD4, 0x59, 0x5A, 0xD9, 0x5E, 0x5C, 0xDA, 0x64, 0x63,
	0xDB, 0x6E, 0x6D, 0xDC, 0x6E, 0x69, 0xD4, 0x5F, 0x5D, 0xCA, 0x4F, 0x53, 0xC2, 0x45, 0x4C, 0xC3,
	0x44, 0x4B, 0xCB, 0x4B, 0x4E, 0xCE, 0x52, 0x59, 0xCC, 0x59, 0x61, 0xCB, 0x67, 0x6B, 0xCF, 0x6E,
	0x70, 0xDB, 0x85, 0x81, 0xDD, 0x8D, 0x89, 0xD1, 0x64, 0x6B, 0xCE, 0x5D, 0x65, 0xDB, 0x70, 0x6D,
	0xD0, 0x67, 0x67, 0x6F, 0x20, 0x42, 0x4A, 0x0A, 0x3A, 0x5D, 0x15, 0x3D, 0x57, 0x11, 0x3B, 0x5A,
	0x12, 0x3C, 0x6A, 0x1B, 0x3E, 0x73, 0x21, 0x40, 0x83, 0x2B, 0x43, 0x83, 0x2C, 0x42, 0x72, 0x1D,
	0x3D, 0x75, 0x23, 0x43, 0x56, 0x0A, 0x36, 0x7A, 0x2E, 0x4F, 0xC2, 0x7C, 0x7D, 0xD0, 0x77, 0x6E,
	0xDA, 0x75, 0x64, 0xCF, 0x7B, 0x6E, 0xCA, 0x85, 0x76, 0xCA, 0x84, 0x75, 0xC9, 0x81, 0x75, 0xC8,
	0x81, 0x76, 0xC8, 0x80, 0x75, 0xC6, 0x7E, 0x77, 0xC1, 0x7C, 0x76, 0xBE, 0x7A, 0x78, 0xBF, 0x7C,
	0x78, 0xBE, 0x79, 0x75, 0xC0, 0x79, 0x74, 0xC1, 0x79, 0x74, 0xBD, 0x76, 0x71, 0xB3, 0x6B, 0x6D,
	0xB4, 0x65, 0x67, 0xDC, 0x94, 0x74, 0xF2, 0xC1, 0x89, 0xF2, 0xCC, 0x9A, 0xF1, 0xCD, 0x9E, 0xF0,
	0xC8, 0x9A, 0xEF, 0xC7, 0x9A, 0xF0, 0xC9, 0x9B, 0xF0, 0xCA, 0x9F, 0xEF, 0xCB, 0xA2, 0xEF, 0xCB,
	0xA6, 0xED, 0xCC, 0xAA, 0xEE, 0xCD, 0xAC, 0xEE, 0xCC, 0xAB, 0xEE, 0xCC, 0xAA, 0xEF, 0xCB, 0xA7,
	0x66, 0x18, 0x3C, 0x6A, 0x19, 0x39, 0x74, 0x1B, 0x3A, 0x77, 0x1A, 0x3A, 0x75, 0x19, 0x39, 0x85,
	0x2D, 0x46, 0xA0, 0x42, 0x55, 0xC7, 0x64, 0x69, 0xDD, 0x80, 0x71, 0xE4, 0x8F, 0x75, 0xE8, 0x97,
	0x77, 0xE9, 0x9A, 0x79, 0xEA, 0xA0, 0x7B, 0xEA, 0x99, 0x7A, 0xE2, 0x8B, 0x7D, 0xCB, 0x77, 0x7C,
	0xB3, 0x62, 0x6E, 0x8F, 0x2E, 0x45, 0x90, 0x2B, 0x43, 0xB7, 0x67, 0x71, 0xB4, 0x5A, 0x67, 0x87,
	0x37, 0x59, 0x6F, 0x32, 0x61, 0x75, 0x3B, 0x67, 0x50, 0x0D, 0x3B, 0x55, 0x17, 0x48, 0x6F, 0x33,
	0x64, 0x67, 0x29, 0x5C, 0x7D, 0x4E, 0x74, 0x9B, 0x77, 0x96, 0x6A, 0x2E, 0x60, 0x73, 0x3C, 0x6F,
	0x86, 0x55, 0x8A, 0x7B, 0x44, 0x76, 0x68, 0x2C, 0x5B, 0x7A, 0x48, 0x7E, 0xA0, 0x77, 0x99, 0xD6,
	0x73, 0x6F, 0xD8, 0x61, 0x5F, 0xCE, 0x98, 0x93, 0xAC, 0x5C, 0x63, 0xCA, 0x6C, 0x64, 0xC8, 0x86,
	0x7A, 0x62, 0x26, 0x4A, 0x50, 0x0D, 0x3C, 0x60, 0x18, 0x3F, 0x57, 0x0F, 0x38, 0x5D, 0x10, 0x36,
	0x67, 0x15, 0x38, 0x60, 0x10, 0x37, 0x69, 0x18, 0x3A, 0x71, 0x1F, 0x3E, 0x71, 0x1F, 0x3E, 0x64,
	0x14, 0x3C, 0x7C, 0x27, 0x44, 0x83, 0x2C, 0x42, 0x8A, 0x29, 0x3F, 0xB1, 0x3C, 0x47, 0xC6, 0x4B,
	0x4D, 0xCC, 0x50, 0x4E, 0xCE, 0x53, 0x52, 0xD0, 0x55, 0x56, 0xD5, 0x58, 0x58, 0xD7, 0x5F, 0x5F,
	0xD9, 0x6A, 0x68, 0xDD, 0x6F, 0x6A, 0xDE, 0x6E, 0x68, 0xDB, 0x61, 0x5E, 0xD8, 0x58, 0x55, 0xD6,
	0x56, 0x52, 0xD6, 0x57, 0x55, 0xD9, 0x5C, 0x5D, 0xDD, 0x6F, 0x71, 0xE2, 0x8D, 0x88, 0xE2, 0x93,
	0x8C, 0xE3, 0x99, 0x91, 0xE2, 0x97, 0x91, 0xDA, 0x70, 0x72, 0xD8, 0x72, 0x71, 0xDF, 0x79, 0x73,
	0x9A, 0x3E, 0x50, 0x4C, 0x07, 0x36, 0x55, 0x11, 0x3C, 0x5F, 0x14, 0x3C, 0x55, 0x0E, 0x37, 0x62,
	0x14, 0x39, 0x66, 0x14, 0x38, 0x72, 0x1F, 0x3F, 0x8A, 0x31, 0x48, 0x86, 0x2D, 0x44, 0x76, 0x20,
	0x3E, 0x7A, 0x27, 0x41, 0x5C, 0x0E, 0x37, 0x76, 0x2D, 0x50, 0xC5, 0x80, 0x81, 0xD5, 0x7D, 0x71,
	0xD8, 0x77, 0x66, 0xCD, 0x7C, 0x70, 0xCA, 0x86, 0x77, 0xCA, 0x86, 0x76, 0xC9, 0x84, 0x76, 0xC8,
	0x82, 0x75, 0xC9, 0x81, 0x75, 0xC7, 0x7F, 0x75, 0xC4, 0x7E, 0x77, 0xC4, 0x7D, 0x76, 0xC1, 0x7A,
	0x74, 0xBE, 0x79, 0x76, 0xC0, 0x7A, 0x75, 0xC0, 0x78, 0x71, 0xBC, 0x76, 0x72, 0xB1, 0x69, 0x6D,
	0xB4, 0x66, 0x69, 0xE1, 0x9B, 0x77, 0xF4, 0xC8, 0x90, 0xF3, 0xD0, 0xA1, 0xF2, 0xCD, 0x9E, 0xF0,
	0xC8, 0x9B, 0xF0, 0xCA, 0x9D, 0xF1, 0xCC, 0xA1, 0xF1, 0xCC, 0xA3, 0xF0, 0xCD, 0xA6, 0xF0, 0xCF,
	0xA9, 0xF0, 0xCE, 0xA7, 0xEF, 0xCA, 0xA3, 0xEE, 0xC7, 0x9F, 0xEF, 0xC7, 0x9D, 0xF0, 0xC5, 0x96,
	0x64, 0x16, 0x3D, 0x68, 0x13, 0x36, 0x6F, 0x17, 0x37, 0x70, 0x16, 0x36, 0x71, 0x17, 0x37, 0x89,
	0x2C, 0x43, 0x9F, 0x3C, 0x4F, 0xC5, 0x5F, 0x63, 0xDD, 0x7F, 0x71, 0xE4, 0x8D, 0x75, 0xE9, 0x9A,
	0x7B, 0xEA, 0x9B, 0x7B, 0xEA, 0x9E, 0x7B, 0xE9, 0x9A, 0x7F, 0xE2, 0x8D, 0x84, 0xCF, 0x75, 0x73,
	0x9A, 0x32, 0x44, 0x7D, 0x17, 0x35, 0xA6, 0x55, 0x64, 0xB8, 0x66, 0x70, 0xA9, 0x48, 0x5C, 0x72,
	0x26, 0x4E, 0x79, 0x43, 0x6F, 0x7B, 0x43, 0x68, 0x4C, 0x06, 0x34, 0x61, 0x28, 0x59, 0x70, 0x37,
	0x68, 0x6B, 0x2F, 0x62, 0x8C, 0x60, 0x85, 0x96, 0x6D, 0x93, 0x7A, 0x47, 0x78, 0x75, 0x3E, 0x71,
	0x71, 0x39, 0x6B, 0x82, 0x52, 0x82, 0x8A, 0x5B, 0x89, 0x87, 0x58, 0x88, 0xA6, 0x7F, 0x93, 0xC5,
	0x76, 0x7A, 0xCE, 0x77, 0x79, 0xC6, 0x8D, 0x8C, 0xCF, 0x73, 0x6B, 0xE2, 0x9A, 0x7F, 0x76, 0x35,
	0x50, 0x4A, 0x0C, 0x3E, 0x5B, 0x19, 0x41, 0x63, 0x1B, 0x40, 0x5C, 0x16, 0x3E, 0x5B, 0x14, 0x3D,
	0x60, 0x15, 0x3E, 0x62, 0x15, 0x3D, 0x6A, 0x1A, 0x3D, 0x70, 0x20, 0x40, 0x73, 0x22, 0x3F, 0x65,
	0x18, 0x3D, 0x7A, 0x27, 0x43, 0x81, 0x2B, 0x42, 0x7D, 0x22, 0x3E, 0xA1, 0x33, 0x43, 0xBC, 0x44,
	0x4A, 0xC2, 0x49, 0x4C, 0xC7, 0x4D, 0x50, 0xCC, 0x52, 0x53, 0xD1, 0x57, 0x59, 0xD4, 0x5C, 0x5F,
	0xD7, 0x63, 0x63, 0xDA, 0x69, 0x68, 0xDC, 0x6D, 0x68, 0xDA, 0x67, 0x63, 0xD8, 0x5C, 0x5A, 0xD5,
	0x57, 0x53, 0xD2, 0x55, 0x54, 0xD3, 0x54, 0x52, 0xD4, 0x56, 0x56, 0xD7, 0x60, 0x61, 0xD8, 0x65,
	0x66, 0xD6, 0x5C, 0x60, 0xD6, 0x61, 0x67, 0xD6, 0x70, 0x71, 0xDC, 0x79, 0x74, 0xC2, 0x5D, 0x61,
	0x67, 0x1A, 0x3D, 0x49, 0x0A, 0x38, 0x57, 0x14, 0x3B, 0x5E, 0x15, 0x3B, 0x5E, 0x13, 0x3A, 0x67,
	0x16, 0x39, 0x65, 0x12, 0x37, 0x77, 0x20, 0x3F, 0x89, 0x2F, 0x47, 0x87, 0x2E, 0x46, 0x7B, 0x22,
	0x3E, 0x7D, 0x26, 0x40, 0x62, 0x12, 0x39, 0x72, 0x2B, 0x50, 0xC6, 0x81, 0x80, 0xD8, 0x82, 0x74,
	0xD6, 0x7B, 0x6B, 0xCA, 0x7F, 0x72, 0xCA, 0x85, 0x76, 0xCA, 0x84, 0x75, 0xC8, 0x83, 0x76, 0xC8,
	0x83, 0x77, 0xC8, 0x82, 0x75, 0xC7, 0x80, 0x75, 0xC4, 0x7E, 0x76, 0xC3, 0x7E, 0x78, 0xC1, 0x7D,
	0x77, 0xBC, 0x7A, 0x78, 0xBB, 0x79, 0x77, 0xBD, 0x77, 0x72, 0xBC, 0x74, 0x6F, 0xAE, 0x68, 0x6A,
	0xB1, 0x66, 0x69, 0xE3, 0xA1, 0x7C, 0xF5, 0xCE, 0x99, 0xF2, 0xD0, 0xA4, 0xF2, 0xCE, 0xA0, 0xF1,
	0xCC, 0x9E, 0xF2, 0xCC, 0xA0, 0xF0, 0xCF, 0xA7, 0xF0, 0xCE, 0xA8, 0xF1, 0xCF, 0xA5, 0xF1, 0xCE,
	0xA2, 0xF0, 0xC6, 0x98, 0xEE, 0xC2, 0x95, 0xEE, 0xC2, 0x93, 0xEE, 0xC1, 0x93, 0xEE, 0xC1, 0x93,
	0x5F, 0x14, 0x3E, 0x64, 0x13, 0x38, 0x68, 0x15, 0x37, 0x65, 0x10, 0x34, 0x6E, 0x19, 0x39, 0x91,
	0x36, 0x47, 0xA0, 0x3A, 0x4B, 0xC5, 0x59, 0x5C, 0xDB, 0x78, 0x6C, 0xE2, 0x8B, 0x74, 0xE8, 0x9A,
	0x7A, 0xEA, 0x9A, 0x7A, 0xEA, 0x9D, 0x7A, 0xE9, 0x9D, 0x7B, 0xE5, 0x88, 0x72, 0xD5, 0x5F, 0x58,
	0x98, 0x2A, 0x3D, 0x7F, 0x25, 0x42, 0xAE, 0x65, 0x70, 0xAD, 0x51, 0x61, 0x93, 0x3C, 0x58, 0x5E,
	0x19, 0x48, 0x7F, 0x4A, 0x71, 0x71, 0x34, 0x5C, 0x4C, 0x08, 0x37, 0x68, 0x30, 0x5F, 0x61, 0x24,
	0x53, 0x5F, 0x24, 0x54, 0xA3, 0x7E, 0x9A, 0x92, 0x68, 0x8D, 0x83, 0x54, 0x83, 0x91, 0x65, 0x99,
	0x72, 0x3A, 0x6C, 0x78, 0x45, 0x74, 0x98, 0x70, 0x9E, 0x8C, 0x58, 0x81, 0x89, 0x56, 0x7D, 0xA1,
	0x63, 0x82, 0xC0, 0x80, 0x88, 0xE1, 0xA2, 0x90, 0xEC, 0x9D, 0x7D, 0x8D, 0x4A, 0x5A, 0x49, 0x09,
	0x3D, 0x55, 0x16, 0x42, 0x5F, 0x1A, 0x42, 0x67, 0x1C, 0x3E, 0x5C, 0x16, 0x3D, 0x5D, 0x16, 0x3D,
	0x5D, 0x15, 0x3F, 0x62, 0x19, 0x41, 0x6B, 0x1E, 0x3F, 0x6B, 0x1C, 0x3E, 0x6F, 0x1F, 0x3D, 0x65,
	0x19, 0x3D, 0x6F, 0x1F, 0x41, 0x7C, 0x29, 0x44, 0x75, 0x21, 0x3E, 0x90, 0x29, 0x3F, 0xAF, 0x39,
	0x45, 0xB8, 0x41, 0x49, 0xBE, 0x46, 0x4D, 0xC6, 0x4E, 0x51, 0xCD, 0x55, 0x57, 0xD3, 0x5A, 0x5D,
	0xD6, 0x5E, 0x63, 0xD7, 0x64, 0x68, 0xD9, 0x68, 0x68, 0xD8, 0x66, 0x67, 0xD8, 0x61, 0x63, 0xD8,
	0x5C, 0x5E, 0xD3, 0x59, 0x5B, 0xD1, 0x59, 0x59, 0xCE, 0x55, 0x56, 0xCD, 0x54, 0x57, 0xCF, 0x56,
	0x5A, 0xD3, 0x60, 0x63, 0xD7, 0x72, 0x73, 0xDB, 0x76, 0x74, 0xD1, 0x68, 0x69, 0x8E, 0x2F, 0x44,
	0x57, 0x0E, 0x38, 0x4D, 0x0D, 0x39, 0x58, 0x12, 0x3A, 0x60, 0x16, 0x3E, 0x65, 0x1C, 0x40, 0x64,
	0x17, 0x3A, 0x63, 0x10, 0x35, 0x7C, 0x25, 0x42, 0x8D, 0x31, 0x48, 0x89, 0x2F, 0x45, 0x7B, 0x22,
	0x3E, 0x7F, 0x25, 0x40, 0x67, 0x15, 0x3B, 0x6E, 0x27, 0x4C, 0xC5, 0x80, 0x7F, 0xDB, 0x84, 0x75,
	0xD3, 0x7B, 0x6E, 0xC8, 0x81, 0x74, 0xC9, 0x85, 0x76, 0xC9, 0x83, 0x77, 0xC8, 0x83, 0x78, 0xC9,
	0x84, 0x78, 0xC9, 0x83, 0x77, 0xCA, 0x85, 0x77, 0xC6, 0x82, 0x78, 0xC0, 0x7E, 0x7A, 0xBF, 0x7E,
	0x7A, 0xBC, 0x7A, 0x78, 0xB9, 0x78, 0x76, 0xB9, 0x77, 0x74, 0xB8, 0x72, 0x70, 0xAA, 0x66, 0x67,
	0xAD, 0x62, 0x64, 0xE1, 0xA2, 0x80, 0xF5, 0xD3, 0xA3, 0xF1, 0xD0, 0xA5, 0xF2, 0xCE, 0xA1, 0xF2,
	0xCE, 0xA1, 0xF0, 0xCE, 0xA5, 0xEF, 0xD0, 0xAC, 0xF0, 0xD0, 0xA9, 0xF1, 0xCB, 0x9D, 0xEF, 0xC4,
	0x96, 0xEE, 0xC1, 0x94, 0xEE, 0xC4, 0x96, 0xEE, 0xC5, 0x9A, 0xEE, 0xC6, 0x9E, 0xEF, 0xC9, 0xA0,
	0x5E, 0x13, 0x3E, 0x61, 0x14, 0x3A, 0x62, 0x11, 0x37, 0x5C, 0x0B, 0x34, 0x77, 0x21, 0x40, 0xA2,
	0x44, 0x4E, 0xAB, 0x42, 0x4F, 0xC5, 0x5A, 0x5D, 0xD7, 0x71, 0x68, 0xE1, 0x88, 0x72, 0xE8, 0x98,
	0x79, 0xEA, 0x98, 0x7A, 0xEA, 0x9A, 0x7A, 0xEA, 0x9A, 0x7A, 0xE6, 0x8A, 0x71, 0xD7, 0x65, 0x5B,
	0x9D, 0x2F, 0x42, 0x7F, 0x23, 0x41, 0xA6, 0x5B, 0x6A, 0xA5, 0x51, 0x64, 0x7D, 0x31, 0x58, 0x68,
	0x27, 0x56, 0x78, 0x39, 0x64, 0x5F, 0x1C, 0x48, 0x4D, 0x0E, 0x3F, 0x67, 0x2C, 0x5C, 0x5E, 0x1E,
	0x4E, 0x5D, 0x21, 0x4F, 0x9D, 0x78, 0x95, 0x97, 0x6F, 0x97, 0x89, 0x5D, 0x86, 0x96, 0x71, 0x99,
	0x88, 0x58, 0x8E, 0x7A, 0x46, 0x78, 0x83, 0x54, 0x85, 0x93, 0x55, 0x76, 0x7E, 0x42, 0x6E, 0x89,
	0x57, 0x83, 0xC2, 0x90, 0x94, 0xF5, 0xC3, 0x9E, 0xAA, 0x61, 0x5D, 0x4B, 0x09, 0x3B, 0x52, 0x13,
	0x41, 0x58, 0x15, 0x3F, 0x5E, 0x16, 0x3D, 0x68, 0x1A, 0x3D, 0x5D, 0x14, 0x3B, 0x5D, 0x14, 0x3C,
	0x62, 0x16, 0x3D, 0x5D, 0x15, 0x3E, 0x61, 0x18, 0x3E, 0x68, 0x19, 0x3D, 0x6F, 0x1B, 0x3B, 0x68,
	0x19, 0x3A, 0x66, 0x15, 0x3A, 0x75, 0x22, 0x40, 0x6F, 0x1F, 0x3D, 0x7C, 0x20, 0x3C, 0x99, 0x2B,
	0x40, 0xAE, 0x39, 0x44, 0xB9, 0x43, 0x4A, 0xC3, 0x4A, 0x4F, 0xCE, 0x54, 0x57, 0xD3, 0x59, 0x5B,
	0xD6, 0x5F, 0x63, 0xD7, 0x62, 0x67, 0xD8, 0x64, 0x68, 0xD8, 0x65, 0x69, 0xD7, 0x65, 0x68, 0xD8,
	0x65, 0x69, 0xD8, 0x66, 0x68, 0xDA, 0x70, 0x6E, 0xDB, 0x7B, 0x79, 0xDC, 0x7E, 0x7B, 0xDC, 0x79,
	0x73, 0xDC, 0x7D, 0x77, 0xD9, 0x7B, 0x79, 0xDE, 0x76, 0x73, 0xAA, 0x48, 0x55, 0x67, 0x14, 0x37,
	0x59, 0x13, 0x3D, 0x50, 0x0F, 0x3B, 0x58, 0x14, 0x3E, 0x63, 0x1A, 0x41, 0x66, 0x1D, 0x41, 0x62,
	0x15, 0x3A, 0x5E, 0x0D, 0x35, 0x7F, 0x29, 0x45, 0x91, 0x35, 0x49, 0x89, 0x2E, 0x44, 0x7F, 0x24,
	0x3F, 0x82, 0x29, 0x42, 0x6C, 0x17, 0x3A, 0x6E, 0x22, 0x48, 0xC3, 0x80, 0x7E, 0xDC, 0x88, 0x77,
	0xCD, 0x79, 0x6C, 0xC8, 0x83, 0x75, 0xC9, 0x86, 0x77, 0xC9, 0x85, 0x78, 0xC7, 0x85, 0x7A, 0xC7,
	0x84, 0x7A, 0xC8, 0x81, 0x78, 0xC8, 0x83, 0x79, 0xC6, 0x84, 0x7B, 0xC0, 0x7F, 0x7A, 0xBE, 0x7E,
	0x7C, 0xBB, 0x7B, 0x79, 0xB7, 0x78, 0x76, 0xB7, 0x76, 0x76, 0xB4, 0x6F, 0x70, 0xA4, 0x62, 0x66,
	0xA8, 0x62, 0x64, 0xE0, 0xA6, 0x82, 0xF5, 0xD4, 0xA5, 0xF1, 0xD0, 0xA5, 0xF2, 0xCE, 0xA2, 0xF1,
	0xCE, 0xA5, 0xF0, 0xCE, 0xA5, 0xF1, 0xCD, 0xA3, 0xF1, 0xCC, 0xA1, 0xF0, 0xC9, 0x9C, 0xF0, 0xC9,
	0x9D, 0xF0, 0xCB, 0xA0, 0xF0, 0xCA, 0x9D, 0xF0, 0xCA, 0x9F, 0xF0, 0xC9, 0x9E, 0xEF, 0xC8, 0x9B,
	0x5C, 0x10, 0x38, 0x5E, 0x11, 0x39, 0x5E, 0x11, 0x3B, 0x59, 0x0F, 0x3A, 0x82, 0x28, 0x41, 0xAB,
	0x46, 0x4E, 0xAE, 0x45, 0x50, 0xC8, 0x5C, 0x5C, 0xD8, 0x72, 0x66, 0xE2, 0x88, 0x72, 0xE8, 0x97,
	0x79, 0xE8, 0x97, 0x77, 0xE9, 0x98, 0x7A, 0xEA, 0x98, 0x7B, 0xE6, 0x89, 0x70, 0xD6, 0x65, 0x5A,
	0xA1, 0x31, 0x42, 0x81, 0x20, 0x3C, 0x98, 0x47, 0x5D, 0x9D, 0x52, 0x6A, 0x79, 0x31, 0x59, 0x78,
	0x35, 0x62, 0x76, 0x35, 0x60, 0x54, 0x13, 0x42, 0x50, 0x13, 0x44, 0x69, 0x2E, 0x5D, 0x5A, 0x1A,
	0x49, 0x63, 0x25, 0x53, 0x87, 0x58, 0x7F, 0x85, 0x52, 0x82, 0x85, 0x54, 0x87, 0x94, 0x6D, 0x99,
	0x92, 0x68, 0x9A, 0x7E, 0x4A, 0x80, 0x73, 0x41, 0x72, 0xA3, 0x5D, 0x78, 0xAA, 0x56, 0x6A, 0x79,
	0x42, 0x6D, 0xB9, 0x7F, 0x86, 0xC3, 0x8F, 0x87, 0x5F, 0x19, 0x42, 0x4F, 0x0F, 0x3F, 0x58, 0x18,
	0x42, 0x59, 0x14, 0x3F, 0x61, 0x18, 0x3E, 0x6A, 0x1C, 0x3F, 0x5C, 0x12, 0x3B, 0x5E, 0x15, 0x3B,
	0x63, 0x15, 0x3B, 0x5F, 0x13, 0x3A, 0x5A, 0x11, 0x3B, 0x65, 0x16, 0x3A, 0x6F, 0x1A, 0x3A, 0x6B,
	0x18, 0x3A, 0x63, 0x13, 0x38, 0x6F, 0x1C, 0x3C, 0x6C, 0x1A, 0x3A, 0x74, 0x1C, 0x3B, 0x7D, 0x1D,
	0x39, 0x90, 0x26, 0x3D, 0xAC, 0x39, 0x45, 0xBA, 0x42, 0x4A, 0xC9, 0x4D, 0x51, 0xD3, 0x5A, 0x5D,
	0xD5, 0x5F, 0x62, 0xD6, 0x61, 0x65, 0xD7, 0x66, 0x6A, 0xD8, 0x6B, 0x6B, 0xD9, 0x6D, 0x6C, 0xDB,
	0x7B, 0x78, 0xDC, 0x7D, 0x7B, 0xDD, 0x80, 0x7D, 0xE3, 0x8E, 0x86, 0xE3, 0x90, 0x87, 0xE1, 0x8B,
	0x82, 0xDE, 0x84, 0x7F, 0xDB, 0x7C, 0x7B, 0xD5, 0x74, 0x70, 0x7D, 0x26, 0x43, 0x5D, 0x0F, 0x36,
	0x56, 0x13, 0x3E, 0x51, 0x11, 0x3E, 0x5B, 0x19, 0x41, 0x68, 0x1F, 0x40, 0x67, 0x1A, 0x3C, 0x66,
	0x17, 0x3A, 0x5F, 0x0F, 0x37, 0x85, 0x30, 0x4A, 0x92, 0x39, 0x4C, 0x89, 0x30, 0x47, 0x83, 0x28,
	0x42, 0x84, 0x2A, 0x40, 0x71, 0x1A, 0x3B, 0x70, 0x23, 0x48, 0xC1, 0x80, 0x7E, 0xDA, 0x8A, 0x79,
	0xCA, 0x79, 0x6F, 0xC9, 0x85, 0x77, 0xCA, 0x87, 0x79, 0xC8, 0x86, 0x7A, 0xC6, 0x84, 0x7C, 0xC4,
	0x82, 0x7B, 0xC3, 0x7F, 0x79, 0xC4, 0x81, 0x79, 0xC6, 0x83, 0x79, 0xC2, 0x81, 0x7A, 0xBE, 0x7E,
	0x7C, 0xB7, 0x79, 0x79, 0xB6, 0x77, 0x76, 0xB6, 0x74, 0x76, 0xB2, 0x6E, 0x70, 0xA0, 0x5F, 0x67,
	0xA7, 0x62, 0x6A, 0xE2, 0xAF, 0x8A, 0xF4, 0xD5, 0xA7, 0xF1, 0xD0, 0xA5, 0xF2, 0xCE, 0xA0, 0xF1,
	0xCD, 0xA0, 0xF1, 0xCC, 0x9F, 0xF2, 0xCD, 0xA1, 0xF1, 0xCD, 0xA3, 0xF2, 0xCE, 0xA2, 0xF2, 0xCE,
	0x9F, 0xF0, 0xCA, 0x9D, 0xEF, 0xC7, 0x9B, 0xEF, 0xC5, 0x99, 0xEE, 0xC4, 0x99, 0xF0, 0xC6, 0x97,
	0x5B, 0x10, 0x39, 0x5D, 0x13, 0x3C, 0x59, 0x11, 0x3C, 0x59, 0x12, 0x3C, 0x80, 0x27, 0x40, 0xA3,
	0x3F, 0x4A, 0xAD, 0x43, 0x4E, 0xCA, 0x5C, 0x5A, 0xD9, 0x72, 0x65, 0xE2, 0x8A, 0x74, 0xE8, 0x99,
	0x79, 0xEA, 0x98, 0x75, 0xE9, 0x99, 0x78, 0xEB, 0x99, 0x79, 0xE8, 0x89, 0x6D, 0xD6, 0x65, 0x59,
	0x9E, 0x30, 0x42, 0x81, 0x1F, 0x3A, 0x97, 0x3C, 0x51, 0x8D, 0x3F, 0x5C, 0x67, 0x20, 0x4B, 0x6A,
	0x2D, 0x5B, 0x77, 0x3D, 0x68, 0x58, 0x19, 0x47, 0x57, 0x19, 0x48, 0x67, 0x29, 0x58, 0x56, 0x17,
	0x46, 0x64, 0x27, 0x56, 0x8C, 0x5C, 0x88, 0x74, 0x3D, 0x6B, 0x60, 0x23, 0x54, 0x83, 0x54, 0x85,
	0x97, 0x71, 0x9F, 0x91, 0x66, 0x9D, 0x83, 0x55, 0x8A, 0x96, 0x66, 0x8A, 0xB9, 0x70, 0x7B, 0x8B,
	0x43, 0x61, 0x8C, 0x47, 0x61, 0x7E, 0x3C, 0x59, 0x5B, 0x19, 0x46, 0x57, 0x17, 0x42, 0x5C, 0x19,
	0x41, 0x58, 0x14, 0x3F, 0x64, 0x1A, 0x40, 0x6D, 0x1E, 0x3F, 0x5D, 0x12, 0x3B, 0x61, 0x16, 0x3D,
	0x5F, 0x15, 0x3D, 0x62, 0x16, 0x3B, 0x5C, 0x11, 0x39, 0x5F, 0x11, 0x39, 0x68, 0x18, 0x3B, 0x6B,
	0x18, 0x39, 0x67, 0x17, 0x3A, 0x6B, 0x1A, 0x3B, 0x6B, 0x1A, 0x3B, 0x73, 0x20, 0x3E, 0x73, 0x1C,
	0x3A, 0x65, 0x0E, 0x34, 0x83, 0x1E, 0x3A, 0xA2, 0x30, 0x41, 0xBA, 0x40, 0x48, 0xCF, 0x55, 0x57,
	0xD4, 0x5D, 0x60, 0xD7, 0x61, 0x66, 0xDA, 0x68, 0x6B, 0xD8, 0x70, 0x6F, 0xD8, 0x74, 0x72, 0xDC,
	0x7F, 0x7C, 0xE1, 0x8C, 0x87, 0xE1, 0x8B, 0x85, 0xE2, 0x8C, 0x85, 0xE2, 0x8D, 0x86, 0xE3, 0x92,
	0x8B, 0xDF, 0x89, 0x85, 0xDE, 0x7E, 0x7B, 0xBE, 0x5E, 0x63, 0x65, 0x13, 0x39, 0x5F, 0x16, 0x3D,
	0x56, 0x18, 0x43, 0x55, 0x17, 0x44, 0x5D, 0x1B, 0x42, 0x6A, 0x1F, 0x3F, 0x64, 0x15, 0x39, 0x64,
	0x15, 0x3A, 0x62, 0x10, 0x36, 0x89, 0x36, 0x4D, 0x93, 0x3E, 0x51, 0x87, 0x32, 0x4A, 0x84, 0x2B,
	0x42, 0x82, 0x28, 0x3F, 0x75, 0x1E, 0x3D, 0x6F, 0x24, 0x49, 0xC0, 0x80, 0x7E, 0xD9, 0x8D, 0x7D,
	0xC7, 0x7C, 0x74, 0xC9, 0x85, 0x79, 0xCA, 0x89, 0x7B, 0xC7, 0x84, 0x7A, 0xC3, 0x7F, 0x7A, 0xC3,
	0x81, 0x7B, 0xC0, 0x7F, 0x7B, 0xC0, 0x7E, 0x7B, 0xC2, 0x7F, 0x7A, 0xC1, 0x7F, 0x7A, 0xBB, 0x7C,
	0x7B, 0xB6, 0x77, 0x78, 0xB6, 0x75, 0x75, 0xB5, 0x73, 0x75, 0xAF, 0x6E, 0x70, 0x9E, 0x5D, 0x67,
	0xAE, 0x6A, 0x6E, 0xEA, 0xBC, 0x92, 0xF3, 0xD6, 0xAC, 0xF1, 0xCF, 0xA3, 0xF2, 0xCB, 0x96, 0xF2,
	0xCB, 0x99, 0xF2, 0xCD, 0xA1, 0xF1, 0xCE, 0xA4, 0xF2, 0xCF, 0xA4, 0xF1, 0xCC, 0x9C, 0xF0, 0xC6,
	0x96, 0xEF, 0xC4, 0x95, 0xEF, 0xC5, 0x95, 0xF3, 0xC9, 0x97, 0xF6, 0xC8, 0x95, 0xF3, 0xB9, 0x89,
	0x5A, 0x12, 0x3D, 0x5B, 0x12, 0x3D, 0x57, 0x11, 0x3B, 0x57, 0x11, 0x3B, 0x70, 0x1D, 0x3E, 0x96,
	0x37, 0x46, 0xB1, 0x49, 0x51, 0xCE, 0x60, 0x5C, 0xDA, 0x74, 0x67, 0xE2, 0x8B, 0x74, 0xE8, 0x96,
	0x78, 0xE9, 0x96, 0x78, 0xEA, 0x99, 0x7C, 0xEB, 0x99, 0x7B, 0xE8, 0x8B, 0x6F, 0xD7, 0x67, 0x5A,
	0x98, 0x2D, 0x40, 0x73, 0x17, 0x38, 0x97, 0x43, 0x58, 0x7A, 0x30, 0x52, 0x51, 0x0F, 0x41, 0x6A,
	0x2E, 0x5A, 0x7C, 0x3B, 0x60, 0x5D, 0x1D, 0x4A, 0x61, 0x21, 0x50, 0x64, 0x24, 0x53, 0x53, 0x15,
	0x42, 0x56, 0x18, 0x48, 0x8E, 0x66, 0x8F, 0x85, 0x55, 0x82, 0x5D, 0x1C, 0x4C, 0x73, 0x3C, 0x6C,
	0x87, 0x57, 0x8C, 0x91, 0x67, 0x98, 0x97, 0x73, 0x9B, 0x8F, 0x67, 0x99, 0xA7, 0x7E, 0x98, 0x9C,
	0x61, 0x7A, 0x83, 0x3E, 0x62, 0x68, 0x22, 0x48, 0x51, 0x14, 0x40, 0x56, 0x18, 0x43, 0x5C, 0x19,
	0x42, 0x56, 0x15, 0x41, 0x67, 0x1C, 0x40, 0x74, 0x20, 0x40, 0x5B, 0x13, 0x3C, 0x64, 0x19, 0x3D,
	0x60, 0x17, 0x3F, 0x62, 0x18, 0x3E, 0x5F, 0x15, 0x3B, 0x5B, 0x11, 0x3A, 0x62, 0x16, 0x3C, 0x68,
	0x1A, 0x3B, 0x67, 0x1A, 0x3C, 0x69, 0x1B, 0x3D, 0x6A, 0x1D, 0x3E, 0x6B, 0x1D, 0x3F, 0x7E, 0x26,
	0x40, 0x67, 0x14, 0x39, 0x5D, 0x0C, 0x34, 0x74, 0x16, 0x37, 0x95, 0x28, 0x3D, 0xAC, 0x38, 0x45,
	0xB7, 0x43, 0x4C, 0xC4, 0x51, 0x58, 0xCB, 0x5B, 0x62, 0xD3, 0x64, 0x68, 0xD7, 0x6E, 0x6D, 0xD8,
	0x74, 0x72, 0xDC, 0x7F, 0x7C, 0xE2, 0x8A, 0x85, 0xE3, 0x8E, 0x87, 0xE0, 0x87, 0x81, 0xDF, 0x87,
	0x81, 0xDB, 0x7E, 0x7C, 0xDA, 0x75, 0x71, 0xAC, 0x47, 0x51, 0x5D, 0x0E, 0x38, 0x5A, 0x19, 0x45,
	0x58, 0x1E, 0x49, 0x58, 0x1C, 0x49, 0x5D, 0x1C, 0x45, 0x6D, 0x20, 0x42, 0x65, 0x17, 0x3D, 0x60,
	0x13, 0x3A, 0x65, 0x15, 0x3B, 0x8D, 0x39, 0x4E, 0x93, 0x3D, 0x50, 0x85, 0x30, 0x48, 0x88, 0x2F,
	0x44, 0x8A, 0x2F, 0x43, 0x7B, 0x22, 0x3F, 0x71, 0x26, 0x4C, 0xC2, 0x7F, 0x7D, 0xD8, 0x8C, 0x7D,
	0xC1, 0x78, 0x72, 0xBF, 0x79, 0x71, 0xC4, 0x80, 0x76, 0xC3, 0x7F, 0x79, 0xC1, 0x7E, 0x7B, 0xC0,
	0x7F, 0x7E, 0xC0, 0x7F, 0x7E, 0xBF, 0x7E, 0x7C, 0xBF, 0x7D, 0x7C, 0xBD, 0x7D, 0x7B, 0xB8, 0x7A,
	0x79, 0xB4, 0x76, 0x78, 0xB3, 0x74, 0x77, 0xB6, 0x73, 0x75, 0xAB, 0x6C, 0x70, 0x9C, 0x5A, 0x65,
	0xB8, 0x78, 0x71, 0xEF, 0xC5, 0x98, 0xF2, 0xD5, 0xAC, 0xF1, 0xCE, 0xA0, 0xF2, 0xCB, 0x94, 0xF2,
	0xCC, 0x9B, 0xF2, 0xCE, 0xA0, 0xF2, 0xCE, 0xA2, 0xF1, 0xCC, 0x9E, 0xEF, 0xC6, 0x98, 0xF0, 0xC5,
	0x94, 0xF4, 0xC8, 0x92, 0xF7, 0xBF, 0x8B, 0xE9, 0xA0, 0x76, 0xC7, 0x73, 0x61, 0x9D, 0x46, 0x4E,
	0x58, 0x10, 0x3B, 0x59, 0x10, 0x3B, 0x56, 0x0E, 0x37, 0x51, 0x0D, 0x38, 0x63, 0x14, 0x3A, 0x8F,
	0x33, 0x46, 0xA9, 0x43, 0x4E, 0xC8, 0x59, 0x57, 0xDC, 0x77, 0x6A, 0xE3, 0x8B, 0x74, 0xE6, 0x95,
	0x77, 0xE7, 0x94, 0x77, 0xEA, 0x98, 0x7B, 0xEA, 0x98, 0x7A, 0xE7, 0x88, 0x6E, 0xD0, 0x5C, 0x52,
	0x8A, 0x23, 0x3D, 0x8E, 0x50, 0x68, 0xAD, 0x6E, 0x79, 0x8B, 0x47, 0x65, 0x56, 0x18, 0x46, 0x6A,
	0x28, 0x55, 0x71, 0x29, 0x52, 0x60, 0x1D, 0x49, 0x64, 0x22, 0x50, 0x5E, 0x1C, 0x4A, 0x4F, 0x11,
	0x3E, 0x4D, 0x0D, 0x3F, 0x85, 0x5C, 0x83, 0x9C, 0x7A, 0x9D, 0x75, 0x3D, 0x6D, 0x69, 0x2C, 0x5D,
	0x81, 0x4E, 0x7D, 0x89, 0x5A, 0x88, 0x84, 0x55, 0x82, 0x8E, 0x64, 0x97, 0xA1, 0x85, 0xA3, 0x9B,
	0x79, 0x9B, 0xA3, 0x77, 0x91, 0x91, 0x63, 0x7D, 0x4C, 0x13, 0x43, 0x4C, 0x0D, 0x3B, 0x55, 0x17,
	0x44, 0x58, 0x16, 0x42, 0x75, 0x23, 0x42, 0x7C, 0x27, 0x42, 0x57, 0x12, 0x3B, 0x65, 0x1B, 0x3D,
	0x60, 0x17, 0x3E, 0x5E, 0x15, 0x3D, 0x60, 0x16, 0x3D, 0x5C, 0x12, 0x3B, 0x5D, 0x12, 0x3A, 0x63,
	0x17, 0x3C, 0x6A, 0x1C, 0x3E, 0x6B, 0x1E, 0x3F, 0x6C, 0x1F, 0x40, 0x67, 0x1A, 0x3E, 0x7B, 0x25,
	0x40, 0x85, 0x27, 0x3F, 0x71, 0x18, 0x39, 0x75, 0x1D, 0x3C, 0x83, 0x26, 0x42, 0x90, 0x2D, 0x46,
	0xA0, 0x3B, 0x4D, 0xAC, 0x48, 0x54, 0xB5, 0x53, 0x5E, 0xC4, 0x5A, 0x62, 0xD1, 0x63, 0x67, 0xD5,
	0x71, 0x72, 0xD8, 0x77, 0x78, 0xDD, 0x81, 0x7E, 0xE2, 0x8B, 0x84, 0xDD, 0x84, 0x7F, 0xDA, 0x7F,
	0x7B, 0xD1, 0x76, 0x76, 0xD1, 0x6F, 0x6A, 0x9F, 0x3F, 0x4C, 0x4E, 0x09, 0x38, 0x4F, 0x10, 0x40,
	0x57, 0x1C, 0x48, 0x58, 0x1E, 0x49, 0x5D, 0x1D, 0x47, 0x69, 0x20, 0x45, 0x63, 0x19, 0x3E, 0x5D,
	0x13, 0x3A, 0x66, 0x18, 0x3D, 0x8B, 0x39, 0x52, 0x96, 0x40, 0x53, 0x88, 0x34, 0x4A, 0x87, 0x32,
	0x48, 0x8B, 0x30, 0x45, 0x7B, 0x22, 0x3E, 0x7A, 0x2F, 0x51, 0xC8, 0x83, 0x80, 0xD2, 0x85, 0x78,
	0xAE, 0x63, 0x64, 0xAA, 0x59, 0x5E, 0xB7, 0x68, 0x67, 0xB9, 0x71, 0x6F, 0xB9, 0x74, 0x75, 0xB9,
	0x77, 0x78, 0xBD, 0x7D, 0x7B, 0xC0, 0x7E, 0x7B, 0xC0, 0x7F, 0x7C, 0xBB, 0x7C, 0x7C, 0xB7, 0x7A,
	0x79, 0xB5, 0x76, 0x77, 0xB2, 0x74, 0x78, 0xB1, 0x70, 0x73, 0xA7, 0x67, 0x6C, 0x99, 0x57, 0x69,
	0xC7, 0x8B, 0x7A, 0xF4, 0xCE, 0x9D, 0xF3, 0xD1, 0xA4, 0xF2, 0xCD, 0x9A, 0xF2, 0xCC, 0x96, 0xF2,
	0xCB, 0x98, 0xF1, 0xCA, 0x96, 0xF1, 0xCA, 0x98, 0xF1, 0xC7, 0x94, 0xEF, 0xC3, 0x92, 0xF0, 0xB9,
	0x88, 0xE2, 0x95, 0x71, 0xB5, 0x5D, 0x58, 0x7C, 0x25, 0x3F, 0x57, 0x06, 0x32, 0x4D, 0x04, 0x33,
	0x5C, 0x13, 0x3B, 0x5D, 0x15, 0x3D, 0x56, 0x10, 0x38, 0x4E, 0x0A, 0x35, 0x60, 0x10, 0x37, 0x87,
	0x29, 0x40, 0x95, 0x32, 0x44, 0xBE, 0x52, 0x53, 0xDC, 0x76, 0x68, 0xE3, 0x8C, 0x73, 0xE6, 0x95,
	0x77, 0xE6, 0x94, 0x76, 0xE7, 0x96, 0x78, 0xEA, 0x96, 0x78, 0xE5, 0x80, 0x67, 0xC4, 0x53, 0x57,
	0xB4, 0x6E, 0x76, 0xBC, 0x8A, 0x89, 0x8C, 0x45, 0x61, 0x89, 0x49, 0x65, 0x56, 0x19, 0x45, 0x61,
	0x21, 0x50, 0x6F, 0x2B, 0x56, 0x65, 0x1F, 0x4D, 0x64, 0x21, 0x4F, 0x5C, 0x1B, 0x49, 0x51, 0x11,
	0x40, 0x4F, 0x0E, 0x3F, 0x82, 0x54, 0x81, 0xA0, 0x7F, 0xA7, 0x8C, 0x5F, 0x8A, 0x65, 0x23, 0x55,
	0x64, 0x28, 0x55, 0x7E, 0x4A, 0x79, 0x89, 0x5C, 0x8A, 0x8A, 0x5D, 0x8A, 0x96, 0x73, 0x96, 0x98,
	0x74, 0x99, 0x7E, 0x45, 0x6D, 0x9B, 0x71, 0x88, 0x97, 0x70, 0x8A, 0x53, 0x1A, 0x48, 0x48, 0x0A,
	0x39, 0x58, 0x14, 0x41, 0x7B, 0x25, 0x42, 0x7B, 0x28, 0x42, 0x54, 0x10, 0x3A, 0x68, 0x1D, 0x3F,
	0x5F, 0x14, 0x3C, 0x5B, 0x12, 0x3C, 0x5F, 0x15, 0x3C, 0x5C, 0x12, 0x3A, 0x5C, 0x11, 0x3A, 0x5D,
	0x13, 0x3C, 0x65, 0x1B, 0x3E, 0x69, 0x1C, 0x3D, 0x6C, 0x1C, 0x3C, 0x62, 0x13, 0x38, 0x6C, 0x18,
	0x39, 0x8C, 0x29, 0x3F, 0x98, 0x32, 0x44, 0xAE, 0x45, 0x53, 0xBC, 0x52, 0x5D, 0xC5, 0x59, 0x60,
	0xCC, 0x60, 0x64, 0xCC, 0x67, 0x66, 0xC9, 0x66, 0x66, 0xCC, 0x67, 0x6A, 0xD3, 0x69, 0x6C, 0xD7,
	0x76, 0x75, 0xD9, 0x7E, 0x7B, 0xD9, 0x7D, 0x79, 0xDB, 0x81, 0x7C, 0xDC, 0x84, 0x7F, 0xDD, 0x87,
	0x81, 0xD9, 0x90, 0x88, 0xDB, 0x9F, 0x92, 0xCA, 0x93, 0x8E, 0x98, 0x64, 0x79, 0x6B, 0x36, 0x5F,
	0x50, 0x16, 0x48, 0x4D, 0x10, 0x3F, 0x59, 0x16, 0x40, 0x65, 0x1A, 0x40, 0x5C, 0x16, 0x3E, 0x59,
	0x13, 0x3D, 0x66, 0x18, 0x3D, 0x87, 0x36, 0x50, 0x92, 0x40, 0x53, 0x88, 0x35, 0x4D, 0x85, 0x31,
	0x4A, 0x89, 0x31, 0x46, 0x7B, 0x22, 0x3E, 0x82, 0x37, 0x54, 0xCD, 0x85, 0x7D, 0xC9, 0x75, 0x6D,
	0xA8, 0x50, 0x59, 0xA6, 0x49, 0x55, 0xA9, 0x4F, 0x59, 0xAE, 0x59, 0x60, 0xAF, 0x5D, 0x65, 0xAE,
	0x5F, 0x69, 0xAE, 0x67, 0x6E, 0xB2, 0x6E, 0x70, 0xB8, 0x77, 0x75, 0xB7, 0x78, 0x78, 0xB7, 0x78,
	0x77, 0xB5, 0x78, 0x7A, 0xB3, 0x75, 0x79, 0xAB, 0x6C, 0x6F, 0xA1, 0x61, 0x68, 0xA0, 0x5B, 0x69,
	0xD8, 0xA1, 0x85, 0xF6, 0xD3, 0xA1, 0xF3, 0xCD, 0x99, 0xF2, 0xC8, 0x8F, 0xF1, 0xC9, 0x94, 0xF0,
	0xC7, 0x95, 0xF0, 0xC5, 0x92, 0xF2, 0xC5, 0x8E, 0xEF, 0xC2, 0x8E, 0xEA, 0xB2, 0x89, 0xD3, 0x83,
	0x6F, 0x8B, 0x2E, 0x43, 0x4E, 0x02, 0x31, 0x43, 0x02, 0x34, 0x5B, 0x0F, 0x37, 0x72, 0x1D, 0x3D,
	0x6E, 0x1F, 0x40, 0x68, 0x1C, 0x3F, 0x5E, 0x15, 0x3C, 0x51, 0x0D, 0x39, 0x5D, 0x10, 0x38, 0x7A,
	0x1F, 0x3D, 0x83, 0x25, 0x3E, 0xB5, 0x4A, 0x50, 0xDA, 0x70, 0x65, 0xE2, 0x89, 0x72, 0xE5, 0x94,
	0x78, 0xE6, 0x93, 0x78, 0xE7, 0x94, 0x77, 0xEA, 0x92, 0x72, 0xE1, 0x7F, 0x6E, 0xD7, 0x88, 0x84,
	0xC0, 0x81, 0x7C, 0x7D, 0x2D, 0x4B, 0x74, 0x2D, 0x57, 0x7B, 0x3D, 0x5B, 0x45, 0x08, 0x38, 0x60,
	0x1F, 0x4C, 0x79, 0x31, 0x59, 0x62, 0x1C, 0x48, 0x5F, 0x1D, 0x4A, 0x6B, 0x2C, 0x58, 0x67, 0x28,
	0x54, 0x55, 0x13, 0x41, 0x74, 0x3C, 0x6C, 0x94, 0x6A, 0x9A, 0x93, 0x69, 0x96, 0x77, 0x43, 0x73,
	0x62, 0x27, 0x5A, 0x8D, 0x62, 0x90, 0x99, 0x78, 0x99, 0x79, 0x44, 0x74, 0x80, 0x4D, 0x80, 0x93,
	0x67, 0x90, 0x74, 0x39, 0x6A, 0x81, 0x47, 0x6B, 0xB6, 0x92, 0x9E, 0x8D, 0x65, 0x85, 0x51, 0x18,
	0x47, 0x55, 0x0F, 0x3C, 0x7C, 0x27, 0x44, 0x77, 0x23, 0x41, 0x55, 0x12, 0x3E, 0x6C, 0x22, 0x43,
	0x60, 0x18, 0x41, 0x59, 0x14, 0x3F, 0x5D, 0x16, 0x3C, 0x5F, 0x15, 0x3D, 0x5C, 0x12, 0x3C, 0x5D,
	0x15, 0x3D, 0x61, 0x16, 0x3D, 0x69, 0x1C, 0x3F, 0x69, 0x1A, 0x3D, 0x61, 0x14, 0x3A, 0x66, 0x16,
	0x39, 0x89, 0x2A, 0x40, 0xAB, 0x40, 0x4D, 0xC6, 0x55, 0x5B, 0xD1, 0x5D, 0x5F, 0xCE, 0x5B, 0x5E,
	0xCD, 0x5D, 0x5E, 0xCF, 0x62, 0x60, 0xCF, 0x64, 0x63, 0xD4, 0x66, 0x67, 0xD7, 0x6A, 0x6C, 0xD8,
	0x73, 0x70, 0xD7, 0x75, 0x71, 0xD5, 0x72, 0x70, 0xD4, 0x70, 0x6F, 0xD4, 0x72, 0x70, 0xDA, 0x80,
	0x7C, 0xE1, 0x97, 0x8B, 0xE2, 0xAE, 0x9E, 0xED, 0xC3, 0xAD, 0xF1, 0xC9, 0xAE, 0xD8, 0xB3, 0xA6,
	0xA8, 0x7D, 0x89, 0x74, 0x41, 0x65, 0x53, 0x13, 0x44, 0x51, 0x0B, 0x37, 0x54, 0x12, 0x3D, 0x53,
	0x13, 0x3F, 0x67, 0x1C, 0x42, 0x8C, 0x3A, 0x52, 0x8F, 0x3C, 0x53, 0x84, 0x31, 0x4D, 0x85, 0x31,
	0x49, 0x8D, 0x33, 0x47, 0x7C, 0x24, 0x45, 0x87, 0x3E, 0x5B, 0xD1, 0x84, 0x7A, 0xC4, 0x6C, 0x68,
	0xB1, 0x5A, 0x62, 0xB2, 0x5D, 0x61, 0xAB, 0x54, 0x5D, 0xAD, 0x50, 0x5B, 0xAA, 0x4C, 0x5A, 0xA7,
	0x4B, 0x5C, 0xA4, 0x4D, 0x5B, 0xA2, 0x53, 0x5F, 0xA4, 0x58, 0x62, 0xA9, 0x5F, 0x67, 0xAC, 0x68,
	0x6D, 0xAC, 0x6C, 0x72, 0xAB, 0x6C, 0x73, 0xA6, 0x68, 0x6E, 0x9D, 0x5C, 0x6B, 0xA3, 0x5E, 0x6D,
	0xE0, 0xAB, 0x86, 0xF7, 0xD2, 0x99, 0xF3, 0xC6, 0x8E, 0xF2, 0xC2, 0x89, 0xF1, 0xC8, 0x94, 0xEF,
	0xC5, 0x97, 0xF0, 0xC5, 0x94, 0xEF, 0xC0, 0x8B, 0xED, 0xB7, 0x89, 0xDB, 0x8F, 0x78, 0x92, 0x3B,
	0x4C, 0x52, 0x05, 0x33, 0x51, 0x0B, 0x38, 0x6C, 0x1A, 0x3C, 0x88, 0x2C, 0x42, 0x8A, 0x31, 0x44,
	0x97, 0x4F, 0x64, 0x89, 0x39, 0x52, 0x76, 0x22, 0x3F, 0x62, 0x16, 0x3B, 0x69, 0x17, 0x3B, 0x73,
	0x19, 0x39, 0x6E, 0x15, 0x36, 0x9E, 0x34, 0x43, 0xD4, 0x64, 0x5C, 0xE2, 0x86, 0x72, 0xE5, 0x93,
	0x78, 0xE6, 0x92, 0x76, 0xE6, 0x92, 0x75, 0xE6, 0x9A, 0x84, 0xE6, 0x9C, 0x89, 0xD9, 0x84, 0x74,
	0x90, 0x2D, 0x41, 0x76, 0x27, 0x50, 0xA0, 0x60, 0x72, 0x6B, 0x2B, 0x4B, 0x3F, 0x03, 0x34, 0x53,
	0x11, 0x40, 0x70, 0x27, 0x52, 0x66, 0x25, 0x50, 0x52, 0x10, 0x3E, 0x6B, 0x2A, 0x54, 0x7F, 0x40,
	0x69, 0x69, 0x25, 0x55, 0x56, 0x17, 0x48, 0x73, 0x41, 0x6D, 0x92, 0x68, 0x94, 0x7F, 0x4E, 0x7F,
	0x80, 0x4E, 0x7F, 0x99, 0x76, 0x98, 0x82, 0x55, 0x7C, 0x74, 0x3B, 0x6F, 0x7D, 0x49, 0x7C, 0x87,
	0x57, 0x8B, 0x7F, 0x4B, 0x81, 0x9A, 0x70, 0x90, 0xA1, 0x6D, 0x82, 0x90, 0x58, 0x77, 0x7A, 0x49,
	0x6E, 0x55, 0x0C, 0x39, 0x79, 0x22, 0x3F, 0x70, 0x20, 0x40, 0x54, 0x11, 0x3D, 0x71, 0x23, 0x42,
	0x62, 0x18, 0x3F, 0x59, 0x12, 0x3D, 0x5A, 0x13, 0x3B, 0x63, 0x18, 0x3D, 0x5E, 0x13, 0x3B, 0x5C,
	0x12, 0x3B, 0x5F, 0x15, 0x3C, 0x68, 0x1E, 0x40, 0x6B, 0x1D, 0x3F, 0x66, 0x19, 0x3D, 0x63, 0x14,
	0x39, 0x81, 0x28, 0x40, 0xAF, 0x42, 0x4F, 0xC5, 0x54, 0x59, 0xCA, 0x57, 0x59, 0xCA, 0x58, 0x5A,
	0xC8, 0x58, 0x5C, 0xCD, 0x5D, 0x63, 0xD1, 0x64, 0x67, 0xD5, 0x64, 0x64, 0xD8, 0x66, 0x68, 0xD7,
	0x6D, 0x6C, 0xD5, 0x6B, 0x6B, 0xD4, 0x69, 0x69, 0xD3, 0x6C, 0x6A, 0xD6, 0x72, 0x6F, 0xDE, 0x85,
	0x7C, 0xE0, 0x9B, 0x8C, 0xE1, 0xAC, 0x9A, 0xE5, 0xB8, 0xA0, 0xEC, 0xC0, 0xA1, 0xF3, 0xCA, 0xA9,
	0xF5, 0xCF, 0xAD, 0xE1, 0xBD, 0xA9, 0xB1, 0x86, 0x8D, 0x70, 0x38, 0x5B, 0x44, 0x04, 0x35, 0x42,
	0x01, 0x32, 0x65, 0x17, 0x3B, 0x8D, 0x38, 0x4F, 0x8D, 0x38, 0x50, 0x81, 0x2D, 0x48, 0x83, 0x2E,
	0x46, 0x89, 0x2C, 0x42, 0x75, 0x1E, 0x40, 0x8D, 0x42, 0x5A, 0xD3, 0x84, 0x77, 0xC3, 0x6E, 0x6A,
	0xB7, 0x6D, 0x6B, 0xBB, 0x6F, 0x6A, 0xBC, 0x6C, 0x69, 0xB5, 0x61, 0x62, 0xB0, 0x59, 0x61, 0xAA,
	0x52, 0x60, 0xA5, 0x4B, 0x58, 0xA1, 0x44, 0x50, 0x9B, 0x40, 0x51, 0x9B, 0x43, 0x55, 0x9B, 0x4B,
	0x5A, 0x97, 0x4A, 0x5D, 0x9A, 0x4B, 0x5E, 0x9D, 0x52, 0x62, 0x92, 0x45, 0x5E, 0x9B, 0x4B, 0x60,
	0xE0, 0xA4, 0x80, 0xF7, 0xCC, 0x90, 0xF2, 0xC0, 0x86, 0xF1, 0xC2, 0x8C, 0xF0, 0xC7, 0x95, 0xEF,
	0xC5, 0x95, 0xF0, 0xC9, 0x96, 0xF1, 0xC0, 0x90, 0xD7, 0x88, 0x71, 0x8B, 0x31, 0x45, 0x5B, 0x0B,
	0x34, 0x62, 0x12, 0x37, 0x74, 0x1F, 0x3E, 0x88, 0x2B, 0x41, 0x93, 0x33, 0x44, 0x90, 0x35, 0x48,
	0xAD, 0x74, 0x7F, 0xA8, 0x69, 0x76, 0x98, 0x49, 0x5D, 0x82, 0x2C, 0x46, 0x7D, 0x25, 0x40, 0x73,
	0x1B, 0x3A, 0x61, 0x0E, 0x35, 0x8E, 0x29, 0x3F, 0xCF, 0x5D, 0x59, 0xE3, 0x85, 0x71, 0xE5, 0x91,
	0x77, 0xE8, 0x93, 0x75, 0xE5, 0x93, 0x7A, 0xE6, 0x9C, 0x84, 0xE9, 0x93, 0x76, 0xCE, 0x5C, 0x55,
	0x96, 0x36, 0x50, 0xB0, 0x6F, 0x7A, 0x98, 0x59, 0x67, 0x46, 0x06, 0x35, 0x49, 0x0B, 0x38, 0x4B,
	0x0A, 0x39, 0x69, 0x2A, 0x58, 0x7C, 0x42, 0x6E, 0x42, 0x02, 0x33, 0x5F, 0x21, 0x50, 0x88, 0x52,
	0x7B, 0x7C, 0x3E, 0x6E, 0x59, 0x1C, 0x4C, 0x4D, 0x0F, 0x3D, 0x86, 0x56, 0x7F, 0x86, 0x54, 0x84,
	0x84, 0x52, 0x82, 0x84, 0x55, 0x7D, 0x6F, 0x37, 0x67, 0x83, 0x51, 0x85, 0x85, 0x53, 0x87, 0x89,
	0x5B, 0x8C, 0x8D, 0x63, 0x99, 0x9E, 0x6C, 0x8F, 0xA0, 0x69, 0x80, 0x6F, 0x2D, 0x58, 0x89, 0x54,
	0x75, 0x72, 0x32, 0x58, 0x6E, 0x17, 0x39, 0x6A, 0x1C, 0x3E, 0x53, 0x0F, 0x39, 0x74, 0x22, 0x3F,
	0x63, 0x16, 0x3D, 0x5A, 0x13, 0x3D, 0x58, 0x13, 0x3D, 0x62, 0x19, 0x3F, 0x61, 0x19, 0x41, 0x5A,
	0x13, 0x3D, 0x5E, 0x16, 0x3D, 0x64, 0x1C, 0x3F, 0x72, 0x23, 0x41, 0x6F, 0x1D, 0x3E, 0x5E, 0x12,
	0x3B, 0x77, 0x24, 0x41, 0xA8, 0x42, 0x4D, 0xC0, 0x4E, 0x54, 0xC6, 0x52, 0x57, 0xCA, 0x57, 0x5B,
	0xCC, 0x5A, 0x5E, 0xCA, 0x5C, 0x61, 0xD0, 0x62, 0x65, 0xD6, 0x64, 0x64, 0xD9, 0x67, 0x67, 0xD6,
	0x68, 0x69, 0xD5, 0x66, 0x68, 0xD5, 0x69, 0x69, 0xD5, 0x71, 0x6E, 0xD9, 0x7B, 0x74, 0xDF, 0x8D,
	0x7F, 0xDF, 0xA1, 0x8D, 0xE2, 0xAE, 0x96, 0xE4, 0xAE, 0x97, 0xE4, 0xB1, 0x99, 0xE7, 0xB8, 0xA0,
	0xEB, 0xC2, 0xA2, 0xF1, 0xC9, 0xA7, 0xF7, 0xD4, 0xB1, 0xE1, 0xBE, 0xAC, 0x92, 0x65, 0x79, 0x44,
	0x09, 0x3B, 0x56, 0x07, 0x30, 0x85, 0x30, 0x4A, 0x88, 0x35, 0x50, 0x7E, 0x2A, 0x45, 0x82, 0x2A,
	0x42, 0x85, 0x2A, 0x40, 0x72, 0x1C, 0x3F, 0x90, 0x45, 0x5C, 0xD2, 0x80, 0x75, 0xC2, 0x74, 0x70,
	0xBD, 0x79, 0x75, 0xBE, 0x76, 0x70, 0xBE, 0x75, 0x70, 0xB7, 0x6E, 0x6E, 0xB6, 0x6B, 0x6D, 0xB4,
	0x68, 0x6D, 0xAD, 0x5E, 0x67, 0xA8, 0x52, 0x5F, 0xA3, 0x4A, 0x59, 0x9C, 0x42, 0x52, 0x95, 0x3C,
	0x51, 0x8B, 0x36, 0x4D, 0x98, 0x43, 0x54, 0xAC, 0x55, 0x5C, 0x93, 0x3A, 0x4C, 0x89, 0x32, 0x49,
	0xDC, 0x99, 0x79, 0xF8, 0xCB, 0x8E, 0xF2, 0xC2, 0x89, 0xF1, 0xC8, 0x95, 0xF0, 0xC7, 0x96, 0xF0,
	0xC6, 0x93, 0xF2, 0xBB, 0x89, 0xDB, 0x8B, 0x70, 0x86, 0x30, 0x45, 0x58, 0x07, 0x31, 0x76, 0x20,
	0x3E, 0x82, 0x2A, 0x42, 0x85, 0x2D, 0x43, 0x90, 0x33, 0x44, 0x92, 0x33, 0x44, 0x93, 0x34, 0x48,
	0xAC, 0x73, 0x7D, 0xB0, 0x7C, 0x84, 0xAE, 0x75, 0x7F, 0x9F, 0x55, 0x66, 0x92, 0x3D, 0x50, 0x7B,
	0x23, 0x3E, 0x5D, 0x0B, 0x34, 0x8C, 0x28, 0x3E, 0xD0, 0x60, 0x5A, 0xE3, 0x86, 0x73, 0xE5, 0x93,
	0x77, 0xE5, 0x92, 0x75, 0xE8, 0x93, 0x75, 0xEA, 0x94, 0x74, 0xE5, 0x81, 0x68, 0xD1, 0x67, 0x64,
	0xBD, 0x78, 0x7D, 0xAD, 0x66, 0x72, 0x6E, 0x2A, 0x4D, 0x44, 0x07, 0x38, 0x4B, 0x0A, 0x37, 0x47,
	0x07, 0x36, 0x6D, 0x33, 0x62, 0x89, 0x56, 0x81, 0x6E, 0x39, 0x67, 0x7D, 0x4A, 0x75, 0x7F, 0x46,
	0x71, 0x6F, 0x33, 0x61, 0x63, 0x27, 0x56, 0x6C, 0x31, 0x5F, 0x6D, 0x2E, 0x5A, 0x78, 0x41, 0x6F,
	0x8B, 0x5D, 0x88, 0x6B, 0x32, 0x5F, 0x67, 0x2C, 0x5C, 0x7C, 0x48, 0x79, 0x8B, 0x5B, 0x93, 0x94,
	0x6D, 0x97, 0x9D, 0x7E, 0xA4, 0x93, 0x64, 0x8D, 0x84, 0x45, 0x65, 0x75, 0x42, 0x6A, 0x71, 0x37,
	0x61, 0x8F, 0x57, 0x72, 0x6D, 0x1E, 0x42, 0x5C, 0x13, 0x3D, 0x54, 0x12, 0x3D, 0x76, 0x26, 0x43,
	0x65, 0x1A, 0x41, 0x5D, 0x16, 0x40, 0x58, 0x14, 0x3E, 0x5D, 0x17, 0x41, 0x64, 0x1E, 0x45, 0x5C,
	0x18, 0x41, 0x5D, 0x14, 0x3D, 0x66, 0x1A, 0x40, 0x77, 0x25, 0x42, 0x7A, 0x25, 0x40, 0x5F, 0x15,
	0x3B, 0x76, 0x25, 0x42, 0xA5, 0x41, 0x4E, 0xC0, 0x4E, 0x52, 0xC7, 0x51, 0x57, 0xCD, 0x57, 0x5C,
	0xCA, 0x59, 0x5C, 0xC8, 0x5D, 0x61, 0xD6, 0x62, 0x65, 0xD8, 0x6A, 0x6A, 0xD8, 0x6C, 0x6A, 0xD8,
	0x65, 0x65, 0xD6, 0x62, 0x64, 0xD5, 0x6C, 0x6A, 0xD7, 0x77, 0x71, 0xDC, 0x82, 0x77, 0xE0, 0x8E,
	0x80, 0xDE, 0x9C, 0x8D, 0xDF, 0xA8, 0x96, 0xE1, 0xAC, 0x96, 0xE3, 0xAF, 0x95, 0xE4, 0xB1, 0x96,
	0xE8, 0xBA, 0x9E, 0xEA, 0xC1, 0xA2, 0xEB, 0xC4, 0xA4, 0xF4, 0xD1, 0xAF, 0xF4, 0xD3, 0xB7, 0xAE,
	0x86, 0x8D, 0x57, 0x15, 0x42, 0x65, 0x14, 0x3B, 0x7F, 0x30, 0x4B, 0x73, 0x24, 0x44, 0x7C, 0x28,
	0x42, 0x85, 0x2B, 0x40, 0x6B, 0x16, 0x3A, 0x97, 0x4C, 0x5F, 0xD3, 0x7F, 0x74, 0xC3, 0x76, 0x6F,
	0xC4, 0x7D, 0x78, 0xC2, 0x79, 0x75, 0xC0, 0x77, 0x72, 0xBA, 0x75, 0x75, 0xB8, 0x74, 0x75, 0xB7,
	0x72, 0x72, 0xB6, 0x6C, 0x6E, 0xB1, 0x65, 0x6C, 0xAB, 0x5F, 0x68, 0xA6, 0x58, 0x63, 0x9D, 0x4D,
	0x5F, 0x92, 0x3E, 0x56, 0xAB, 0x4F, 0x57, 0xC5, 0x64, 0x5C, 0x9F, 0x3D, 0x4A, 0x97, 0x3C, 0x4B,
	0xE3, 0xA6, 0x7F, 0xF6, 0xD0, 0x95, 0xF2, 0xCA, 0x94, 0xF2, 0xCB, 0x97, 0xF2, 0xCA, 0x95, 0xF4,
	0xC6, 0x90, 0xD7, 0x84, 0x6B, 0x7C, 0x22, 0x3D, 0x58, 0x0A, 0x34, 0x82, 0x2B, 0x42, 0x8F, 0x31,
	0x44, 0x8A, 0x2E, 0x43, 0x92, 0x38, 0x49, 0x9B, 0x3D, 0x4A, 0x92, 0x34, 0x44, 0x92, 0x30, 0x45,
	0xA6, 0x6D, 0x7D, 0xAA, 0x7F, 0x8E, 0xB0, 0x8E, 0x98, 0xAF, 0x7C, 0x84, 0xA3, 0x5B, 0x69, 0x86,
	0x2E, 0x46, 0x5E, 0x0C, 0x33, 0x88, 0x26, 0x3D, 0xD0, 0x60, 0x5C, 0xE3, 0x88, 0x74, 0xE8, 0x96,
	0x78, 0xE6, 0x95, 0x77, 0xE8, 0x95, 0x74, 0xE9, 0x97, 0x73, 0xE1, 0x7B, 0x67, 0xE2, 0x89, 0x81,
	0xD6, 0xA3, 0x98, 0x94, 0x48, 0x60, 0x62, 0x1A, 0x46, 0x53, 0x10, 0x3D, 0x54, 0x11, 0x3C, 0x52,
	0x10, 0x3D, 0x63, 0x1F, 0x4D, 0x64, 0x26, 0x53, 0x7E, 0x42, 0x6B, 0x7B, 0x3A, 0x61, 0x60, 0x1D,
	0x4C, 0x62, 0x24, 0x54, 0x71, 0x3A, 0x69, 0x74, 0x39, 0x64, 0x5B, 0x1A, 0x49, 0x7E, 0x4D, 0x78,
	0x68, 0x2F, 0x5B, 0x5D, 0x1F, 0x4E, 0x6B, 0x31, 0x61, 0x79, 0x44, 0x76, 0x80, 0x4D, 0x81, 0x94,
	0x6C, 0x9A, 0x9D, 0x7C, 0xA1, 0x9F, 0x7F, 0x9E, 0x68, 0x2F, 0x5E, 0x88, 0x50, 0x6B, 0x8D, 0x59,
	0x77, 0x8B, 0x51, 0x71, 0x7A, 0x35, 0x55, 0x4F, 0x0A, 0x38, 0x53, 0x14, 0x41, 0x72, 0x25, 0x46,
	0x67, 0x1B, 0x41, 0x5E, 0x17, 0x41, 0x57, 0x18, 0x43, 0x5D, 0x1A, 0x42, 0x69, 0x20, 0x42, 0x5D,
	0x18, 0x41, 0x5C, 0x18, 0x42, 0x6C, 0x20, 0x43, 0x7F, 0x28, 0x42, 0x95, 0x35, 0x45, 0x67, 0x17,
	0x3B, 0x6D, 0x1E, 0x3D, 0xA5, 0x42, 0x50, 0xC6, 0x50, 0x55, 0xCC, 0x56, 0x57, 0xC3, 0x52, 0x58,
	0xC7, 0x57, 0x5C, 0xD5, 0x63, 0x66, 0xD8, 0x63, 0x67, 0xD7, 0x68, 0x68, 0xD8, 0x6A, 0x69, 0xD8,
	0x64, 0x65, 0xD6, 0x65, 0x66, 0xD7, 0x70, 0x6B, 0xDB, 0x7E, 0x74, 0xDE, 0x86, 0x7B, 0xE2, 0x8B,
	0x7E, 0xE0, 0x94, 0x87, 0xDE, 0x9C, 0x8F, 0xDF, 0xA4, 0x91, 0xE3, 0xAD, 0x90, 0xE5, 0xB3, 0x90,
	0xE5, 0xB5, 0x93, 0xE8, 0xBB, 0x9B, 0xEB, 0xC3, 0xA1, 0xEA, 0xC5, 0xA7, 0xF1, 0xCB, 0xB1, 0xF8,
	0xD9, 0xBD, 0xB5, 0x8D, 0x92, 0x63, 0x1C, 0x44, 0x6C, 0x1B, 0x3C, 0x68, 0x1C, 0x3F, 0x78, 0x25,
	0x42, 0x83, 0x2A, 0x42, 0x64, 0x14, 0x3D, 0x9F, 0x51, 0x60, 0xD2, 0x80, 0x76, 0xC0, 0x77, 0x72,
	0xC5, 0x7D, 0x76, 0xBF, 0x7A, 0x75, 0xBC, 0x79, 0x76, 0xBB, 0x78, 0x77, 0xBB, 0x77, 0x76, 0xB8,
	0x73, 0x73, 0xB7, 0x71, 0x72, 0xB7, 0x6F, 0x71, 0xB2, 0x68, 0x6E, 0xAA, 0x66, 0x6D, 0xA5, 0x63,
	0x6C, 0xA0, 0x56, 0x66, 0xB2, 0x56, 0x5C, 0xC9, 0x63, 0x58, 0xAC, 0x43, 0x4C, 0xBB, 0x5F, 0x5B,
	0xEF, 0xBE, 0x8D, 0xF4, 0xD0, 0x98, 0xF2, 0xCD, 0x99, 0xF1, 0xCB, 0x99, 0xF3, 0xC8, 0x8F, 0xF2,
	0xB3, 0x80, 0xA5, 0x4B, 0x52, 0x54, 0x04, 0x33, 0x7F, 0x27, 0x41, 0x9C, 0x3D, 0x4B, 0x92, 0x33,
	0x46, 0x94, 0x34, 0x47, 0xA4, 0x44, 0x50, 0xA3, 0x42, 0x4C, 0x92, 0x34, 0x47, 0x96, 0x36, 0x49,
	0x95, 0x54, 0x6F, 0xA6, 0x71, 0x81, 0xAB, 0x8D, 0x9C, 0xAF, 0x8E, 0x9A, 0xB3, 0x7C, 0x83, 0x94,
	0x47, 0x59, 0x63, 0x0E, 0x33, 0x87, 0x24, 0x3C, 0xCE, 0x5F, 0x5B, 0xE4, 0x88, 0x71, 0xE9, 0x98,
	0x78, 0xE8, 0x96, 0x77, 0xE8, 0x97, 0x78, 0xEA, 0x97, 0x76, 0xE2, 0x7E, 0x69, 0xE4, 0x8C, 0x81,
	0xC4, 0x89, 0x8B, 0x90, 0x47, 0x5D, 0x53, 0x12, 0x3D, 0x51, 0x0E, 0x39, 0x5B, 0x16, 0x3F, 0x5E,
	0x1A, 0x44, 0x6B, 0x25, 0x4F, 0x5D, 0x16, 0x41, 0x5C, 0x17, 0x42, 0x5C, 0x17, 0x44, 0x66, 0x29,
	0x57, 0x60, 0x22, 0x4E, 0x53, 0x15, 0x41, 0x57, 0x18, 0x45, 0x55, 0x17, 0x46, 0x75, 0x40, 0x6E,
	0x6A, 0x32, 0x61, 0x5D, 0x21, 0x4F, 0x6A, 0x2C, 0x5C, 0x77, 0x3F, 0x72, 0x7D, 0x47, 0x7B, 0x88,
	0x5A, 0x86, 0x9E, 0x7C, 0xA2, 0x99, 0x74, 0x9B, 0x86, 0x59, 0x89, 0x8B, 0x4E, 0x6F, 0xA7, 0x72,
	0x86, 0x85, 0x4F, 0x70, 0x83, 0x49, 0x64, 0x4E, 0x0E, 0x3D, 0x55, 0x15, 0x41, 0x73, 0x27, 0x47,
	0x69, 0x1E, 0x42, 0x5E, 0x18, 0x41, 0x56, 0x16, 0x43, 0x5D, 0x1B, 0x42, 0x6C, 0x24, 0x45, 0x5C,
	0x1A, 0x42, 0x5C, 0x16, 0x41, 0x70, 0x22, 0x44, 0x85, 0x2E, 0x48, 0xB0, 0x45, 0x4F, 0x78, 0x21,
	0x40, 0x62, 0x15, 0x3A, 0xA5, 0x46, 0x54, 0xC8, 0x54, 0x58, 0xC1, 0x4F, 0x56, 0xC4, 0x56, 0x5C,
	0xD3, 0x5E, 0x61, 0xD9, 0x66, 0x66, 0xD6, 0x66, 0x66, 0xD7, 0x67, 0x66, 0xD9, 0x68, 0x65, 0xD8,
	0x67, 0x66, 0xD9, 0x6B, 0x69, 0xD9, 0x74, 0x6D, 0xDC, 0x7F, 0x74, 0xDF, 0x86, 0x7A, 0xE0, 0x8A,
	0x7B, 0xE1, 0x90, 0x80, 0xE0, 0x96, 0x85, 0xDF, 0x98, 0x88, 0xE0, 0xA1, 0x89, 0xE3, 0xAB, 0x8A,
	0xE4, 0xB1, 0x8E, 0xE8, 0xB9, 0x96, 0xEC, 0xC3, 0x9D, 0xEB, 0xC5, 0xA4, 0xEA, 0xC4, 0xAF, 0xEF,
	0xCB, 0xB7, 0xF8, 0xDF, 0xBE, 0xAF, 0x82, 0x86, 0x5F, 0x0E, 0x37, 0x5E, 0x0B, 0x32, 0x76, 0x20,
	0x3D, 0x79, 0x24, 0x40, 0x61, 0x16, 0x3F, 0xA9, 0x5A, 0x62, 0xD1, 0x7E, 0x72, 0xC1, 0x78, 0x73,
	0xC5, 0x7D, 0x74, 0xBE, 0x7A, 0x75, 0xBB, 0x78, 0x75, 0xBD, 0x77, 0x74, 0xBE, 0x76, 0x73, 0xBC,
	0x76, 0x73, 0xB8, 0x73, 0x73, 0xB6, 0x71, 0x74, 0xB6, 0x6D, 0x72, 0xAF, 0x6A, 0x72, 0xA5, 0x69,
	0x6F, 0xA3, 0x65, 0x68, 0xB4, 0x62, 0x60, 0xC9, 0x62, 0x56, 0xBF, 0x50, 0x4F, 0xD6, 0x84, 0x6C,
	0xF4, 0xCC, 0x96, 0xF3, 0xCE, 0x97, 0xF2, 0xCD, 0x9A, 0xF2, 0xCE, 0x9B, 0xF2, 0xC2, 0x8C, 0xDE,
	0x8A, 0x6B, 0x86, 0x2A, 0x43, 0x73, 0x1E, 0x3F, 0x9C, 0x3B, 0x49, 0x99, 0x39, 0x4A, 0x95, 0x39,
	0x4B, 0xA5, 0x45, 0x50, 0xB2, 0x4F, 0x55, 0xA0, 0x41, 0x4E, 0x94, 0x35, 0x4A, 0x9F, 0x3F, 0x4E,
	0x6C, 0x22, 0x49, 0x97, 0x58, 0x72, 0xA6, 0x82, 0x94, 0xB0, 0x93, 0xA0, 0xBF, 0x8D, 0x8D, 0xA1,
	0x5D, 0x69, 0x66, 0x13, 0x37, 0x84, 0x22, 0x3B, 0xD0, 0x61, 0x5D, 0xE5, 0x8A, 0x73, 0xEA, 0x9A,
	0x7C, 0xE9, 0x96, 0x7B, 0xE9, 0x99, 0x7B, 0xEA, 0x9A, 0x7A, 0xE5, 0x81, 0x69, 0xE1, 0x84, 0x75,
	0xB4, 0x70, 0x79, 0x71, 0x25, 0x4A, 0x4A, 0x0C, 0x38, 0x4C, 0x0C, 0x39, 0x51, 0x0E, 0x38, 0x5F,
	0x1F, 0x4A, 0x62, 0x21, 0x4C, 0x5D, 0x19, 0x40, 0x51, 0x0E, 0x39, 0x5A, 0x1B, 0x4B, 0x7D, 0x44,
	0x70, 0x68, 0x28, 0x54, 0x4E, 0x0C, 0x3B, 0x5D, 0x1F, 0x4D, 0x64, 0x27, 0x54, 0x56, 0x19, 0x4B,
	0x77, 0x3F, 0x6E, 0x65, 0x2A, 0x58, 0x6A, 0x2D, 0x5D, 0x6E, 0x30, 0x62, 0x77, 0x41, 0x74, 0x88,
	0x59, 0x87, 0x92, 0x67, 0x91, 0x92, 0x68, 0x96, 0xA1, 0x82, 0xA2, 0x90, 0x5A, 0x7A, 0x7E, 0x3D,
	0x5D, 0x94, 0x5F, 0x78, 0x9A, 0x65, 0x77, 0x53, 0x17, 0x42, 0x4C, 0x09, 0x37, 0x71, 0x21, 0x40,
	0x6D, 0x1D, 0x3E, 0x61, 0x15, 0x3C, 0x56, 0x11, 0x3C, 0x5D, 0x16, 0x3F, 0x6C, 0x22, 0x46, 0x5D,
	0x18, 0x42, 0x5A, 0x10, 0x39, 0x6C, 0x19, 0x3A, 0x92, 0x31, 0x45, 0xC6, 0x53, 0x53, 0x8E, 0x2A,
	0x40, 0x5F, 0x10, 0x36, 0x9A, 0x3D, 0x4E, 0xC0, 0x4E, 0x55, 0xCA, 0x57, 0x5A, 0xD5, 0x60, 0x60,
	0xD6, 0x5D, 0x60, 0xD9, 0x64, 0x65, 0xD7, 0x68, 0x64, 0xD7, 0x68, 0x64, 0xD9, 0x66, 0x65, 0xD9,
	0x69, 0x68, 0xD9, 0x6A, 0x69, 0xDA, 0x72, 0x6C, 0xDC, 0x7B, 0x6F, 0xDE, 0x82, 0x76, 0xDE, 0x86,
	0x79, 0xE0, 0x8B, 0x7A, 0xE1, 0x93, 0x7D, 0xE1, 0x96, 0x83, 0xE0, 0x9D, 0x88, 0xE0, 0xA5, 0x89,
	0xE3, 0xAE, 0x90, 0xE6, 0xB5, 0x92, 0xEB, 0xBE, 0x98, 0xEB, 0xC2, 0xA2, 0xEA, 0xC4, 0xAB, 0xEA,
	0xC4, 0xB2, 0xF3, 0xD5, 0xB8, 0xF2, 0xDE, 0xBD, 0x93, 0x5A, 0x6B, 0x52, 0x00, 0x2A, 0x6C, 0x16,
	0x37, 0x6A, 0x17, 0x39, 0x63, 0x14, 0x3C, 0xB4, 0x62, 0x63, 0xCD, 0x79, 0x6C, 0xC1, 0x79, 0x71,
	0xC5, 0x7C, 0x71, 0xC1, 0x7A, 0x72, 0xBE, 0x79, 0x72, 0xBF, 0x78, 0x73, 0xBE, 0x76, 0x72, 0xBD,
	0x76, 0x73, 0xBB, 0x75, 0x75, 0xB8, 0x72, 0x72, 0xB6, 0x70, 0x72, 0xB1, 0x6D, 0x74, 0xA8, 0x67,
	0x70, 0xA5, 0x67, 0x6A, 0xBA, 0x67, 0x5F, 0xCA, 0x64, 0x55, 0xC8, 0x5B, 0x54, 0xE4, 0x9C, 0x76,
	0xF5, 0xD1, 0x9D, 0xF2, 0xCE, 0x9D, 0xF2, 0xCC, 0x98, 0xF3, 0xCE, 0x95, 0xEF, 0xB4, 0x84, 0xBA,
	0x59, 0x55, 0x7D, 0x22, 0x3F, 0x90, 0x36, 0x4A, 0x9B, 0x3D, 0x4E, 0x99, 0x3A, 0x4C, 0xA3, 0x44,
	0x51, 0xB3, 0x50, 0x56, 0xA9, 0x47, 0x52, 0x99, 0x3B, 0x4C, 0x9D, 0x3E, 0x4F, 0xA2, 0x46, 0x55,
	0x4F, 0x05, 0x32, 0x79, 0x32, 0x58, 0xA3, 0x7C, 0x92, 0xBD, 0xA0, 0xA6, 0xC4, 0x98, 0x97, 0xAC,
	0x6E, 0x76, 0x68, 0x1B, 0x3E, 0x76, 0x18, 0x37, 0xCE, 0x61, 0x5E, 0xE6, 0x8B, 0x75, 0xE9, 0x98,
	0x7B, 0xEA, 0x97, 0x7B, 0xEA, 0x9A, 0x7B, 0xEA, 0x99, 0x79, 0xE6, 0x84, 0x69, 0xDD, 0x74, 0x65,
	0xBC, 0x70, 0x72, 0x75, 0x33, 0x53, 0x49, 0x0A, 0x38, 0x4F, 0x0D, 0x39, 0x55, 0x13, 0x3F, 0x68,
	0x27, 0x52, 0x58, 0x18, 0x43, 0x51, 0x14, 0x40, 0x51, 0x0F, 0x3A, 0x67, 0x25, 0x52, 0x80, 0x4A,
	0x75, 0x63, 0x25, 0x52, 0x5C, 0x17, 0x44, 0x4E, 0x0C, 0x3B, 0x6C, 0x2E, 0x58, 0x65, 0x2A, 0x59,
	0x6A, 0x2F, 0x5F, 0x72, 0x36, 0x65, 0x77, 0x40, 0x70, 0x7A, 0x45, 0x76, 0x71, 0x3B, 0x6B, 0x7A,
	0x45, 0x78, 0x86, 0x55, 0x85, 0x91, 0x67, 0x96, 0xA9, 0x8C, 0xA5, 0x94, 0x65, 0x7F, 0x52, 0x0D,
	0x3C, 0x85, 0x4E, 0x71, 0xB7, 0x8B, 0x93, 0x5E, 0x24, 0x49, 0x46, 0x01, 0x31, 0x6F, 0x1E, 0x3C,
	0x71, 0x1E, 0x3D, 0x63, 0x15, 0x3A, 0x57, 0x0F, 0x39, 0x5D, 0x16, 0x40, 0x6C, 0x22, 0x46, 0x5F,
	0x1A, 0x43, 0x5B, 0x12, 0x3C, 0x67, 0x13, 0x36, 0x9D, 0x36, 0x45, 0xCE, 0x55, 0x53, 0x96, 0x2E,
	0x40, 0x5B, 0x0D, 0x35, 0x91, 0x38, 0x4E, 0xC6, 0x51, 0x55, 0xD6, 0x5B, 0x59, 0xD5, 0x5F, 0x5F,
	0xD5, 0x5D, 0x61, 0xD8, 0x5F, 0x60, 0xD9, 0x68, 0x64, 0xD9, 0x6A, 0x65, 0xD9, 0x69, 0x66, 0xD9,
	0x69, 0x68, 0xD9, 0x6C, 0x6B, 0xDA, 0x73, 0x6D, 0xDB, 0x77, 0x6E, 0xDD, 0x7E, 0x72, 0xDE, 0x85,
	0x77, 0xE0, 0x88, 0x7A, 0xE2, 0x8E, 0x7C, 0xE1, 0x95, 0x83, 0xE0, 0x9A, 0x8A, 0xDF, 0xA2, 0x8B,
	0xE3, 0xAE, 0x8D, 0xE5, 0xB4, 0x91, 0xE8, 0xB9, 0x98, 0xEA, 0xC1, 0xA2, 0xEA, 0xC5, 0xA9, 0xEA,
	0xC3, 0xB1, 0xEB, 0xC9, 0xB5, 0xF8, 0xE5, 0xBF, 0xDB, 0xBB, 0xA8, 0x67, 0x20, 0x44, 0x5A, 0x07,
	0x30, 0x5F, 0x0C, 0x34, 0x66, 0x16, 0x3C, 0xBC, 0x68, 0x66, 0xC9, 0x76, 0x6B, 0xC3, 0x7B, 0x71,
	0xC4, 0x7B, 0x71, 0xC1, 0x79, 0x70, 0xBF, 0x79, 0x6F, 0xBE, 0x78, 0x71, 0xBC, 0x75, 0x72, 0xBC,
	0x75, 0x72, 0xB9, 0x74, 0x73, 0xB8, 0x73, 0x72, 0xB8, 0x71, 0x71, 0xB2, 0x6D, 0x73, 0xAA, 0x68,
	0x6E, 0xA8, 0x62, 0x66, 0xB9, 0x5F, 0x5D, 0xD1, 0x6D, 0x5D, 0xD9, 0x81, 0x67, 0xEC, 0xB4, 0x83,
	0xF4, 0xD0, 0x9F, 0xF2, 0xCE, 0x9E, 0xF2, 0xCD, 0x97, 0xF6, 0xCB, 0x8F, 0xE2, 0x96, 0x70, 0x9A,
	0x36, 0x45, 0x8B, 0x2B, 0x43, 0x99, 0x39, 0x4C, 0x99, 0x3D, 0x50, 0xA4, 0x44, 0x52, 0xB4, 0x4D,
	0x53, 0xAD, 0x46, 0x50, 0x97, 0x36, 0x48, 0x9C, 0x3B, 0x4B, 0xA6, 0x45, 0x54, 0x9C, 0x47, 0x5B,
	0x44, 0x01, 0x31, 0x63, 0x1C, 0x47, 0xA0, 0x75, 0x8C, 0xC7, 0xAA, 0xAA, 0xC9, 0xA2, 0x9F, 0xB0,
	0x75, 0x7B, 0x5F, 0x17, 0x3E, 0x6D, 0x13, 0x36, 0xCD, 0x61, 0x5A, 0xE7, 0x8A, 0x71, 0xEA, 0x9B,
	0x7A, 0xE9, 0x99, 0x7A, 0xEA, 0x99, 0x7B, 0xEB, 0x9A, 0x79, 0xEA, 0x8D, 0x6C, 0xD5, 0x67, 0x5C,
	0xB5, 0x60, 0x6A, 0x78, 0x39, 0x56, 0x49, 0x0B, 0x3A, 0x4F, 0x10, 0x3C, 0x5B, 0x1B, 0x46, 0x5F,
	0x1C, 0x46, 0x54, 0x11, 0x3B, 0x53, 0x14, 0x3F, 0x4D, 0x0B, 0x38, 0x6B, 0x2D, 0x5A, 0x81, 0x50,
	0x79, 0x5E, 0x1D, 0x4A, 0x64, 0x1F, 0x49, 0x4A, 0x07, 0x35, 0x57, 0x17, 0x45, 0x72, 0x36, 0x63,
	0x6E, 0x31, 0x60, 0x65, 0x27, 0x57, 0x75, 0x3E, 0x6F, 0x85, 0x54, 0x87, 0x7E, 0x4A, 0x7B, 0x6F,
	0x35, 0x67, 0x81, 0x4F, 0x7E, 0x9E, 0x7F, 0x9F, 0xA7, 0x8B, 0xA3, 0x7D, 0x4B, 0x6F, 0x4C, 0x06,
	0x3A, 0x8D, 0x57, 0x75, 0xC7, 0xA5, 0xA4, 0x5A, 0x20, 0x47, 0x47, 0x04, 0x33, 0x73, 0x20, 0x3E,
	0x79, 0x26, 0x43, 0x63, 0x18, 0x3E, 0x56, 0x10, 0x3B, 0x5F, 0x18, 0x3E, 0x6A, 0x1E, 0x3F, 0x5B,
	0x13, 0x3D, 0x5B, 0x11, 0x3C, 0x6F, 0x1B, 0x3A, 0xA7, 0x3D, 0x48, 0xC0, 0x47, 0x4C, 0x98, 0x2F,
	0x42, 0x64, 0x12, 0x36, 0x9A, 0x38, 0x4B, 0xCD, 0x53, 0x54, 0xD5, 0x59, 0x57, 0xD4, 0x59, 0x5A,
	0xD7, 0x60, 0x60, 0xD8, 0x62, 0x5E, 0xD9, 0x65, 0x61, 0xD9, 0x68, 0x64, 0xD9, 0x69, 0x63, 0xD9,
	0x6A, 0x66, 0xD9, 0x70, 0x6C, 0xDB, 0x70, 0x6B, 0xDB, 0x74, 0x6C, 0xDC, 0x7C, 0x6F, 0xDD, 0x82,
	0x74, 0xDE, 0x85, 0x79, 0xE1, 0x8C, 0x7E, 0xE1, 0x94, 0x84, 0xDF, 0x98, 0x8A, 0xDE, 0x9F, 0x8E,
	0xE0, 0xAA, 0x92, 0xE4, 0xB0, 0x94, 0xE9, 0xBB, 0x98, 0xEA, 0xC2, 0xA4, 0xEA, 0xC5, 0xAC, 0xEB,
	0xC4, 0xB1, 0xEB, 0xC5, 0xB6, 0xEF, 0xD6, 0xB7, 0xF9, 0xE5, 0xC0, 0xA0, 0x69, 0x73, 0x50, 0x00,
	0x2A, 0x50, 0x02, 0x2E, 0x6B, 0x1A, 0x3D, 0xC7, 0x71, 0x6A, 0xC9, 0x7A, 0x6F, 0xC7, 0x7D, 0x71,
	0xC5, 0x7B, 0x71, 0xC3, 0x79, 0x70, 0xC1, 0x79, 0x70, 0xBE, 0x78, 0x70, 0xBB, 0x75, 0x72, 0xBA,
	0x74, 0x71, 0xB7, 0x70, 0x6F, 0xB7, 0x71, 0x72, 0xB7, 0x71, 0x71, 0xAF, 0x6B, 0x6C, 0xA5, 0x64,
	0x66, 0xAF, 0x5A, 0x5F, 0xCA, 0x6E, 0x65, 0xE5, 0x99, 0x74, 0xEE, 0xB5, 0x80, 0xF1, 0xC7, 0x92,
	0xF2, 0xCE, 0x9F, 0xF2, 0xCE, 0x9C, 0xF3, 0xCD, 0x94, 0xF5, 0xBF, 0x85, 0xCC, 0x6E, 0x5B, 0x95,
	0x30, 0x43, 0x9B, 0x38, 0x48, 0x9C, 0x3A, 0x4B, 0xA6, 0x40, 0x4E, 0xB3, 0x4C, 0x52, 0xB1, 0x4B,
	0x51, 0x99, 0x39, 0x4A, 0x97, 0x34, 0x47, 0xA6, 0x41, 0x4D, 0xA1, 0x44, 0x55, 0x97, 0x47, 0x5F,
	0x43, 0x03, 0x33, 0x5E, 0x18, 0x45, 0x9B, 0x68, 0x80, 0xC2, 0xA3, 0xA6, 0xCA, 0xA5, 0xA2, 0xAB,
	0x6F, 0x79, 0x58, 0x10, 0x3C, 0x6E, 0x14, 0x36, 0xCD, 0x60, 0x58, 0xE7, 0x8C, 0x71, 0xEA, 0x9C,
	0x7A, 0xE9, 0x99, 0x79, 0xEA, 0x9B, 0x7B, 0xEB, 0x9D, 0x7A, 0xE9, 0x8D, 0x6D, 0xDC, 0x72, 0x64,
	0xBA, 0x6D, 0x74, 0x70, 0x33, 0x55, 0x4A, 0x0A, 0x3B, 0x54, 0x16, 0x44, 0x5C, 0x1C, 0x46, 0x57,
	0x13, 0x3D, 0x55, 0x10, 0x3B, 0x55, 0x14, 0x3D, 0x4C, 0x09, 0x38, 0x7A, 0x4A, 0x76, 0x87, 0x55,
	0x7D, 0x53, 0x0E, 0x3B, 0x61, 0x1C, 0x44, 0x59, 0x16, 0x43, 0x59, 0x18, 0x46, 0x58, 0x1B, 0x48,
	0x59, 0x18, 0x47, 0x5F, 0x21, 0x4F, 0x71, 0x39, 0x6A, 0x82, 0x50, 0x84, 0x7E, 0x49, 0x7B, 0x6D,
	0x32, 0x63, 0x7C, 0x48, 0x76, 0x9B, 0x7A, 0x9C, 0xA2, 0x81, 0x9E, 0x8C, 0x61, 0x83, 0x4D, 0x0B,
	0x3F, 0x89, 0x4E, 0x6A, 0xB2, 0x89, 0x93, 0x4C, 0x10, 0x41, 0x50, 0x0D, 0x37, 0x7A, 0x27, 0x42,
	0x7B, 0x27, 0x44, 0x65, 0x1B, 0x40, 0x59, 0x12, 0x3D, 0x61, 0x15, 0x3C, 0x66, 0x1D, 0x42, 0x57,
	0x12, 0x3D, 0x5E, 0x0F, 0x38, 0x80, 0x24, 0x3E, 0xB0, 0x3F, 0x48, 0xC1, 0x4B, 0x4E, 0xA5, 0x39,
	0x47, 0x6A, 0x14, 0x37, 0x9B, 0x39, 0x4A, 0xD0, 0x56, 0x56, 0xD8, 0x5C, 0x5A, 0xD5, 0x5A, 0x59,
	0xD9, 0x61, 0x5D, 0xDB, 0x65, 0x5F, 0xD9, 0x65, 0x60, 0xD9, 0x62, 0x5D, 0xD9, 0x65, 0x5F, 0xD8,
	0x68, 0x64, 0xD9, 0x6D, 0x68, 0xD9, 0x6F, 0x69, 0xDA, 0x73, 0x6A, 0xDC, 0x7B, 0x6E, 0xDD, 0x80,
	0x73, 0xDE, 0x84, 0x78, 0xE1, 0x8B, 0x7D, 0xE2, 0x91, 0x7F, 0xE0, 0x95, 0x86, 0xDE, 0x9E, 0x8E,
	0xDF, 0xA6, 0x96, 0xE2, 0xAC, 0x96, 0xE7, 0xB6, 0x99, 0xEA, 0xBF, 0xA4, 0xEA, 0xC6, 0xAA, 0xEB,
	0xC4, 0xB2, 0xEA, 0xC1, 0xB7, 0xEC, 0xCD, 0xB6, 0xF8, 0xE6, 0xBF, 0xD6, 0xB1, 0xA0, 0x61, 0x15,
	0x3C, 0x41, 0x00, 0x28, 0x74, 0x22, 0x41, 0xCF, 0x75, 0x6B, 0xC8, 0x7A, 0x70, 0xC5, 0x7C, 0x71,
	0xC5, 0x7C, 0x72, 0xC4, 0x7A, 0x70, 0xC3, 0x7A, 0x6F, 0xBE, 0x77, 0x6F, 0xBA, 0x75, 0x71, 0xB8,
	0x72, 0x6F, 0xB6, 0x6E, 0x6F, 0xB5, 0x6E, 0x71, 0xB3, 0x6C, 0x6E, 0xAB, 0x68, 0x68, 0xA5, 0x5F,
	0x62, 0xC1, 0x67, 0x65, 0xE9, 0xA4, 0x7E, 0xF3, 0xC4, 0x8A, 0xF1, 0xC0, 0x89, 0xF2, 0xC9, 0x95,
	0xF2, 0xCF, 0xA2, 0xF2, 0xCE, 0x9D, 0xF5, 0xCB, 0x90, 0xE9, 0x9E, 0x73, 0xB1, 0x48, 0x4C, 0x97,
	0x32, 0x43, 0x9F, 0x38, 0x47, 0xA5, 0x3F, 0x4C, 0xB1, 0x49, 0x50, 0xB8, 0x50, 0x53, 0xA6, 0x43,
	0x4E, 0x93, 0x36, 0x4A, 0x9E, 0x3E, 0x4B, 0xA6, 0x46, 0x50, 0x9A, 0x43, 0x57, 0x97, 0x49, 0x63,
	0x42, 0x00, 0x31, 0x55, 0x0D, 0x3C, 0x93, 0x5C, 0x76, 0xBB, 0x9D, 0xA4, 0xC9, 0xA6, 0xA3, 0xAE,
	0x73, 0x7C, 0x5D, 0x13, 0x3E, 0x6A, 0x0F, 0x34, 0xCA, 0x5E, 0x58, 0xE8, 0x8C, 0x70, 0xEA, 0x9C,
	0x79, 0xE9, 0x9B, 0x7A, 0xE9, 0x9D, 0x7A, 0xEB, 0x9E, 0x78, 0xE8, 0x8A, 0x6A, 0xE5, 0x78, 0x64,
	0xB2, 0x64, 0x6A, 0x57, 0x18, 0x44, 0x54, 0x12, 0x3F, 0x5C, 0x19, 0x45, 0x57, 0x12, 0x3D, 0x54,
	0x0D, 0x38, 0x55, 0x0F, 0x3B, 0x4B, 0x07, 0x35, 0x58, 0x1D, 0x4E, 0x94, 0x69, 0x8F, 0x80, 0x46,
	0x6B, 0x4A, 0x09, 0x37, 0x53, 0x12, 0x3E, 0x63, 0x1D, 0x47, 0x5E, 0x1A, 0x45, 0x52, 0x11, 0x40,
	0x52, 0x12, 0x40, 0x58, 0x18, 0x47, 0x64, 0x27, 0x57, 0x78, 0x43, 0x74, 0x86, 0x56, 0x86, 0x61,
	0x24, 0x53, 0x76, 0x41, 0x6C, 0x9C, 0x79, 0x9F, 0x9E, 0x7F, 0x9F, 0x93, 0x68, 0x8A, 0x76, 0x3F,
	0x6F, 0x8E, 0x62, 0x83, 0xAC, 0x86, 0x9B, 0x71, 0x3C, 0x62, 0x54, 0x0C, 0x35, 0x78, 0x25, 0x3F,
	0x70, 0x1F, 0x3E, 0x66, 0x1A, 0x3E, 0x61, 0x16, 0x3D, 0x61, 0x13, 0x3B, 0x60, 0x17, 0x3F, 0x59,
	0x16, 0x41, 0x67, 0x16, 0x3A, 0x96, 0x30, 0x42, 0xC2, 0x4C, 0x50, 0xD2, 0x5B, 0x58, 0xAA, 0x3D,
	0x48, 0x6E, 0x19, 0x3B, 0xA3, 0x3D, 0x4C, 0xD2, 0x56, 0x53, 0xD8, 0x5D, 0x5C, 0xD8, 0x61, 0x5F,
	0xD9, 0x63, 0x5E, 0xDA, 0x62, 0x5E, 0xD9, 0x62, 0x5E, 0xDA, 0x60, 0x5F, 0xDA, 0x61, 0x5E, 0xD9,
	0x66, 0x63, 0xD8, 0x6C, 0x68, 0xD8, 0x6E, 0x68, 0xD9, 0x72, 0x6A, 0xDA, 0x78, 0x6E, 0xDB, 0x7E,
	0x74, 0xDE, 0x84, 0x78, 0xDF, 0x88, 0x7A, 0xE1, 0x8C, 0x7C, 0xE0, 0x95, 0x85, 0xDE, 0x99, 0x8C,
	0xDE, 0xA3, 0x91, 0xE2, 0xAC, 0x97, 0xE5, 0xB2, 0x9C, 0xE9, 0xBE, 0xA5, 0xEA, 0xC5, 0xAB, 0xEB,
	0xC4, 0xB3, 0xEA, 0xC3, 0xB7, 0xEB, 0xC9, 0xB6, 0xF1, 0xD9, 0xB9, 0xF4, 0xDC, 0xBA, 0x85, 0x49,
	0x5F, 0x33, 0x00, 0x25, 0x7F, 0x2C, 0x45, 0xD2, 0x74, 0x68, 0xC7, 0x7C, 0x72, 0xC5, 0x7D, 0x73,
	0xC1, 0x7A, 0x71, 0xC0, 0x79, 0x70, 0xC2, 0x79, 0x70, 0xBD, 0x76, 0x71, 0xBA, 0x74, 0x71, 0xB9,
	0x72, 0x6F, 0xB7, 0x6E, 0x6D, 0xB4, 0x6C, 0x6D, 0xAC, 0x68, 0x6C, 0xA6, 0x67, 0x6A, 0xAB, 0x5A,
	0x60, 0xD4, 0x84, 0x71, 0xF3, 0xCD, 0x9C, 0xF3, 0xD0, 0x9E, 0xF2, 0xC4, 0x8C, 0xF2, 0xCA, 0x96,
	0xF2, 0xCF, 0xA2, 0xF3, 0xCF, 0x9A, 0xF3, 0xBF, 0x84, 0xD5, 0x73, 0x5E, 0xA5, 0x37, 0x45, 0x9B,
	0x34, 0x43, 0x9F, 0x36, 0x46, 0xAD, 0x41, 0x4D, 0xBA, 0x4F, 0x53, 0xB5, 0x4D, 0x53, 0x9B, 0x3C,
	0x4D, 0x97, 0x37, 0x49, 0xA4, 0x45, 0x4F, 0xA1, 0x49, 0x57, 0x97, 0x47, 0x5F, 0x95, 0x45, 0x5C,
	0x41, 0x01, 0x32, 0x4E, 0x08, 0x37, 0x8A, 0x51, 0x70, 0xBE, 0x9F, 0xA4, 0xCA, 0xA8, 0xA5, 0xB5,
	0x7C, 0x81, 0x66, 0x1B, 0x40, 0x67, 0x0C, 0x31, 0xC9, 0x5C, 0x56, 0xEA, 0x8D, 0x70, 0xEA, 0x9B,
	0x7A, 0xE9, 0x9A, 0x7A, 0xEA, 0x9E, 0x7A, 0xEB, 0x9D, 0x76, 0xE8, 0x8D, 0x6C, 0xE2, 0x75, 0x64,
	0xA1, 0x4A, 0x5B, 0x59, 0x18, 0x48, 0x5D, 0x1C, 0x47, 0x54, 0x11, 0x3C, 0x53, 0x0E, 0x38, 0x56,
	0x0F, 0x39, 0x52, 0x0D, 0x3B, 0x54, 0x14, 0x44, 0x73, 0x3B, 0x68, 0x85, 0x4D, 0x73, 0x70, 0x32,
	0x5B, 0x49, 0x0B, 0x39, 0x54, 0x16, 0x44, 0x68, 0x24, 0x4C, 0x58, 0x12, 0x3B, 0x4D, 0x0A, 0x38,
	0x59, 0x19, 0x46, 0x57, 0x18, 0x47, 0x5B, 0x1C, 0x4A, 0x69, 0x2E, 0x5C, 0x87, 0x57, 0x86, 0x78,
	0x42, 0x75, 0x82, 0x52, 0x83, 0x9D, 0x7C, 0xA1, 0x97, 0x73, 0x92, 0x91, 0x65, 0x8C, 0xA6, 0x81,
	0x9E, 0xAA, 0x8C, 0xA1, 0x7A, 0x49, 0x6C, 0x63, 0x24, 0x48, 0x61, 0x11, 0x35, 0x6A, 0x16, 0x38,
	0x67, 0x18, 0x3B, 0x66, 0x1A, 0x3E, 0x63, 0x19, 0x3E, 0x64, 0x17, 0x3C, 0x5F, 0x12, 0x3A, 0x61,
	0x15, 0x3C, 0x7B, 0x23, 0x3F, 0xB4, 0x46, 0x4B, 0xD1, 0x5A, 0x58, 0xD2, 0x5A, 0x57, 0xA0, 0x35,
	0x44, 0x72, 0x1D, 0x3E, 0xA9, 0x42, 0x4D, 0xD0, 0x56, 0x52, 0xD7, 0x5B, 0x59, 0xD8, 0x61, 0x60,
	0xD9, 0x65, 0x60, 0xDA, 0x64, 0x5E, 0xDA, 0x62, 0x5C, 0xD9, 0x62, 0x5E, 0xD9, 0x65, 0x60, 0xDA,
	0x66, 0x62, 0xDA, 0x69, 0x66, 0xD9, 0x6B, 0x66, 0xD8, 0x71, 0x6B, 0xDA, 0x75, 0x6D, 0xDC, 0x7D,
	0x71, 0xDD, 0x82, 0x77, 0xDE, 0x86, 0x79, 0xE1, 0x8B, 0x7B, 0xE1, 0x93, 0x84, 0xDE, 0x9A, 0x8C,
	0xDD, 0xA0, 0x90, 0xE1, 0xAA, 0x97, 0xE4, 0xB2, 0x9D, 0xEA, 0xBB, 0xA6, 0xEA, 0xC2, 0xAD, 0xEA,
	0xC4, 0xB2, 0xEA, 0xC2, 0xB6, 0xEA, 0xC5, 0xB6, 0xEC, 0xCF, 0xB6, 0xFC, 0xE7, 0xC0, 0xAE, 0x7F,
	0x81, 0x35, 0x00, 0x2B, 0x88, 0x32, 0x47, 0xD2, 0x74, 0x66, 0xC6, 0x7E, 0x74, 0xC3, 0x7D, 0x74,
	0xBF, 0x78, 0x71, 0xBF, 0x79, 0x70, 0xBE, 0x77, 0x72, 0xBC, 0x76, 0x71, 0xBC, 0x75, 0x70, 0xB9,
	0x73, 0x70, 0xB6, 0x6E, 0x6C, 0xB4, 0x6B, 0x6D, 0xAA, 0x67, 0x6B, 0xA4, 0x62, 0x65, 0xB4, 0x59,
	0x5E, 0xDF, 0x9A, 0x7A, 0xF5, 0xD4, 0xA3, 0xF2, 0xCD, 0x9B, 0xF2, 0xC8, 0x90, 0xF2, 0xCD, 0x9D,
	0xF2, 0xCF, 0xA1, 0xF4, 0xCD, 0x93, 0xEC, 0xA3, 0x73, 0xC4, 0x56, 0x50, 0xA9, 0x3A, 0x47, 0xA3,
	0x39, 0x46, 0xA1, 0x37, 0x45, 0xB2, 0x46, 0x4D, 0xBA, 0x50, 0x53, 0xAA, 0x43, 0x4E, 0x99, 0x39,
	0x4A, 0x9E, 0x3F, 0x4C, 0xA5, 0x4B, 0x55, 0x9C, 0x48, 0x5B, 0x96, 0x42, 0x58, 0x8A, 0x38, 0x50,
	0x40, 0x01, 0x32, 0x4C, 0x07, 0x38, 0x88, 0x51, 0x71, 0xBC, 0x9D, 0xA4, 0xCA, 0xA8, 0xA5, 0xB7,
	0x7F, 0x83, 0x6F, 0x23, 0x44, 0x68, 0x0C, 0x31, 0xC6, 0x59, 0x55, 0xEA, 0x8E, 0x70, 0xEA, 0x99,
	0x79, 0xE6, 0x95, 0x78, 0xE5, 0x96, 0x78, 0xE6, 0x98, 0x7B, 0xE4, 0x8A, 0x71, 0xDA, 0x74, 0x6A,
	0xA4, 0x57, 0x6D, 0x63, 0x26, 0x54, 0x51, 0x12, 0x3F, 0x51, 0x0F, 0x3A, 0x55, 0x11, 0x3A, 0x56,
	0x11, 0x3C, 0x5C, 0x1B, 0x4A, 0x67, 0x28, 0x56, 0x5A, 0x1A, 0x46, 0x6C, 0x2C, 0x59, 0x79, 0x38,
	0x63, 0x52, 0x14, 0x40, 0x59, 0x19, 0x46, 0x65, 0x21, 0x4C, 0x54, 0x11, 0x3D, 0x51, 0x0F, 0x3C,
	0x5C, 0x1B, 0x48, 0x5B, 0x1B, 0x4A, 0x68, 0x2A, 0x5A, 0x5D, 0x1F, 0x4D, 0x5C, 0x21, 0x51, 0x88,
	0x5A, 0x8C, 0x99, 0x73, 0xA3, 0x99, 0x75, 0x9E, 0x87, 0x54, 0x7E, 0x78, 0x3F, 0x6C, 0x95, 0x6E,
	0x8C, 0xA5, 0x7D, 0x8F, 0x83, 0x4E, 0x6F, 0x78, 0x3D, 0x65, 0x7C, 0x38, 0x5A, 0x72, 0x29, 0x4D,
	0x6E, 0x25, 0x49, 0x6F, 0x21, 0x42, 0x64, 0x18, 0x3B, 0x64, 0x17, 0x3D, 0x5E, 0x10, 0x3A, 0x6C,
	0x16, 0x39, 0x93, 0x2B, 0x40, 0xC2, 0x4D, 0x4E, 0xD1, 0x5B, 0x58, 0xD1, 0x59, 0x57, 0x97, 0x2F,
	0x41, 0x76, 0x1F, 0x3E, 0xB1, 0x46, 0x4F, 0xD2, 0x57, 0x55, 0xD8, 0x5D, 0x5A, 0xD8, 0x5F, 0x5D,
	0xD9, 0x66, 0x62, 0xDB, 0x68, 0x62, 0xD9, 0x64, 0x60, 0xD8, 0x62, 0x5C, 0xD9, 0x60, 0x5C, 0xDA,
	0x63, 0x5F, 0xDA, 0x67, 0x61, 0xD9, 0x6A, 0x61, 0xD9, 0x6E, 0x66, 0xDB, 0x73, 0x6B, 0xDC, 0x7A,
	0x6F, 0xDC, 0x80, 0x76, 0xDD, 0x83, 0x79, 0xE0, 0x87, 0x7A, 0xE1, 0x8E, 0x80, 0xE0, 0x94, 0x87,
	0xDF, 0x9E, 0x8E, 0xE0, 0xAB, 0x97, 0xE3, 0xB0, 0x9B, 0xE9, 0xB9, 0xA6, 0xEA, 0xC3, 0xAB, 0xEA,
	0xC5, 0xB1, 0xEA, 0xC3, 0xB5, 0xEA, 0xC3, 0xB6, 0xEB, 0xC9, 0xB7, 0xF7, 0xE3, 0xBE, 0xD4, 0xAF,
	0x9C, 0x4D, 0x0B, 0x38, 0x8E, 0x33, 0x46, 0xD2, 0x76, 0x67, 0xC5, 0x7E, 0x73, 0xC0, 0x7C, 0x74,
	0xBD, 0x76, 0x70, 0xBD, 0x78, 0x70, 0xBB, 0x76, 0x70, 0xBA, 0x75, 0x70, 0xBB, 0x74, 0x6F, 0xB9,
	0x73, 0x70, 0xB7, 0x71, 0x71, 0xB1, 0x6C, 0x6F, 0xA6, 0x66, 0x6A, 0xA6, 0x60, 0x63, 0xBC, 0x60,
	0x60, 0xE6, 0xA6, 0x80, 0xF5, 0xD3, 0x9D, 0xF2, 0xC4, 0x8D, 0xF1, 0xC2, 0x8B, 0xF2, 0xCE, 0xA1,
	0xF3, 0xD1, 0xA0, 0xF3, 0xC0, 0x87, 0xDD, 0x7E, 0x61, 0xC0, 0x4F, 0x4F, 0xB3, 0x43, 0x4B, 0xA9,
	0x3C, 0x47, 0xA7, 0x3D, 0x48, 0xB3, 0x48, 0x4E, 0xB7, 0x4D, 0x51, 0xA1, 0x3D, 0x4B, 0x98, 0x38,
	0x48, 0xA2, 0x44, 0x4F, 0xA1, 0x49, 0x57, 0x97, 0x42, 0x59, 0x8F, 0x3A, 0x50, 0x82, 0x30, 0x4D,
	0x41, 0x02, 0x32, 0x47, 0x05, 0x36, 0x83, 0x47, 0x68, 0xBB, 0x97, 0x9E, 0xCB, 0xA7, 0xA3, 0xBC,
	0x86, 0x88, 0x72, 0x29, 0x48, 0x67, 0x0C, 0x31, 0xC4, 0x56, 0x52, 0xEB, 0x8D, 0x6F, 0xEB, 0x9A,
	0x78, 0xE7, 0x98, 0x78, 0xE5, 0x97, 0x7D, 0xE7, 0x99, 0x7C, 0xE7, 0x8A, 0x6D, 0xDC, 0x78, 0x6B,
	0xA7, 0x5C, 0x70, 0x5F, 0x1F, 0x4A, 0x50, 0x0F, 0x3C, 0x55, 0x12, 0x3D, 0x57, 0x11, 0x3B, 0x58,
	0x12, 0x3C, 0x58, 0x17, 0x42, 0x5A, 0x1B, 0x47, 0x52, 0x12, 0x3E, 0x68, 0x27, 0x54, 0x72, 0x2D,
	0x59, 0x59, 0x18, 0x44, 0x57, 0x18, 0x45, 0x5C, 0x19, 0x44, 0x5B, 0x17, 0x41, 0x52, 0x0E, 0x3C,
	0x57, 0x16, 0x43, 0x61, 0x21, 0x50, 0x72, 0x35, 0x62, 0x55, 0x18, 0x46, 0x4E, 0x0F, 0x3F, 0x7A,
	0x48, 0x76, 0x96, 0x6D, 0x9A, 0x90, 0x66, 0x94, 0x94, 0x66, 0x8E, 0x6C, 0x2E, 0x5B, 0x56, 0x12,
	0x40, 0x68, 0x27, 0x4E, 0x76, 0x30, 0x4C, 0x75, 0x38, 0x5B, 0x7E, 0x42, 0x65, 0x86, 0x4D, 0x6C,
	0x8D, 0x4F, 0x6C, 0x81, 0x36, 0x54, 0x67, 0x19, 0x3C, 0x5F, 0x13, 0x3A, 0x5F, 0x12, 0x39, 0x79,
	0x20, 0x3C, 0xA5, 0x38, 0x44, 0xC9, 0x52, 0x52, 0xD0, 0x5B, 0x5C, 0xD0, 0x5B, 0x5A, 0x91, 0x2D,
	0x42, 0x80, 0x27, 0x41, 0xBB, 0x4E, 0x53, 0xD8, 0x5B, 0x58, 0xD8, 0x5E, 0x5C, 0xD8, 0x61, 0x5F,
	0xD9, 0x66, 0x62, 0xDA, 0x67, 0x61, 0xD9, 0x66, 0x60, 0xD9, 0x63, 0x5E, 0xD8, 0x5E, 0x5A, 0xD8,
	0x61, 0x5B, 0xD9, 0x65, 0x61, 0xD9, 0x6A, 0x62, 0xDA, 0x6B, 0x65, 0xDB, 0x71, 0x6B, 0xD9, 0x77,
	0x6F, 0xDC, 0x7E, 0x74, 0xDC, 0x81, 0x76, 0xDD, 0x84, 0x78, 0xE2, 0x8C, 0x7D, 0xE2, 0x91, 0x85,
	0xDE, 0x9C, 0x8D, 0xDF, 0xA7, 0x93, 0xE2, 0xB0, 0x9B, 0xE7, 0xB5, 0xA6, 0xEB, 0xBE, 0xAB, 0xEA,
	0xC5, 0xB1, 0xEA, 0xC3, 0xB5, 0xEA, 0xC3, 0xB6, 0xE9, 0xC4, 0xB7, 0xF0, 0xD4, 0xBB, 0xEB, 0xCE,
	0xAF, 0x73, 0x32, 0x4F, 0x96, 0x35, 0x44, 0xD0, 0x78, 0x6A, 0xC2, 0x7C, 0x72, 0xC3, 0x7E, 0x73,
	0xBE, 0x78, 0x70, 0xBC, 0x77, 0x72, 0xBA, 0x75, 0x71, 0xBA, 0x73, 0x6F, 0xBB, 0x74, 0x6F, 0xB9,
	0x74, 0x70, 0xB7, 0x72, 0x72, 0xB2, 0x6D, 0x6F, 0xA5, 0x66, 0x69, 0xA9, 0x61, 0x63, 0xC4, 0x66,
	0x61, 0xEB, 0xAD, 0x83, 0xF5, 0xD2, 0x99, 0xF2, 0xC1, 0x88, 0xF1, 0xC2, 0x8C, 0xF2, 0xD0, 0xA1,
	0xF3, 0xCE, 0x97, 0xEC, 0xA5, 0x74, 0xCE, 0x5E, 0x53, 0xBD, 0x4D, 0x50, 0xB4, 0x46, 0x4C, 0xA7,
	0x3C, 0x47, 0xA8, 0x3D, 0x48, 0xB4, 0x46, 0x4D, 0xAB, 0x42, 0x4B, 0x99, 0x35, 0x43, 0x9C, 0x3B,
	0x48, 0xA4, 0x4A, 0x56, 0x9B, 0x45, 0x58, 0x95, 0x3C, 0x53, 0x8D, 0x39, 0x51, 0x8A, 0x3A, 0x56,
	0x47, 0x04, 0x34, 0x46, 0x03, 0x34, 0x7A, 0x3A, 0x5D, 0xB7, 0x8F, 0x97, 0xCB, 0xA6, 0xA2, 0xBE,
	0x8B, 0x8B, 0x75, 0x2F, 0x4C, 0x69, 0x0F, 0x33, 0xC4, 0x54, 0x53, 0xE9, 0x8A, 0x6E, 0xEA, 0x9A,
	0x78, 0xEA, 0x9C, 0x79, 0xEA, 0x9C, 0x7A, 0xEA, 0x9C, 0x77, 0xE9, 0x8C, 0x6B, 0xDE, 0x7D, 0x70,
	0xA6, 0x58, 0x6C, 0x5D, 0x15, 0x40, 0x57, 0x13, 0x3D, 0x55, 0x11, 0x3C, 0x52, 0x0F, 0x3A, 0x53,
	0x11, 0x3D, 0x5B, 0x19, 0x46, 0x62, 0x20, 0x4A, 0x55, 0x15, 0x42, 0x5D, 0x1E, 0x4C, 0x64, 0x22,
	0x4D, 0x5C, 0x1A, 0x44, 0x51, 0x12, 0x3E, 0x5B, 0x1B, 0x46, 0x5E, 0x1C, 0x47, 0x4D, 0x0B, 0x38,
	0x53, 0x12, 0x3F, 0x5E, 0x21, 0x50, 0x70, 0x37, 0x65, 0x5F, 0x24, 0x54, 0x6C, 0x33, 0x64, 0x7B,
	0x44, 0x76, 0x88, 0x57, 0x88, 0x89, 0x5B, 0x8D, 0x89, 0x5B, 0x8A, 0x90, 0x67, 0x90, 0x6D, 0x30,
	0x59, 0x5D, 0x18, 0x42, 0x4D, 0x04, 0x2F, 0x56, 0x0F, 0x35, 0x65, 0x18, 0x3B, 0x66, 0x1F, 0x42,
	0x73, 0x27, 0x46, 0x7C, 0x2F, 0x4B, 0x6A, 0x20, 0x42, 0x56, 0x0D, 0x36, 0x64, 0x15, 0x38, 0x8C,
	0x2C, 0x40, 0xB3, 0x40, 0x48, 0xCC, 0x55, 0x55, 0xD0, 0x5F, 0x5F, 0xC8, 0x57, 0x59, 0x83, 0x26,
	0x41, 0x8C, 0x31, 0x48, 0xC7, 0x56, 0x57, 0xDB, 0x5F, 0x5D, 0xD9, 0x61, 0x61, 0xD9, 0x65, 0x62,
	0xDA, 0x67, 0x61, 0xDB, 0x68, 0x62, 0xDB, 0x69, 0x62, 0xD9, 0x63, 0x60, 0xD8, 0x5F, 0x5D, 0xD8,
	0x62, 0x5E, 0xD9, 0x65, 0x5F, 0xD9, 0x67, 0x60, 0xD9, 0x6B, 0x64, 0xD9, 0x6F, 0x6A, 0xD9, 0x75,
	0x6D, 0xDB, 0x7C, 0x71, 0xDB, 0x81, 0x76, 0xDE, 0x84, 0x79, 0xE1, 0x8B, 0x7B, 0xE0, 0x90, 0x80,
	0xDE, 0x97, 0x8A, 0xDE, 0xA3, 0x8F, 0xE1, 0xAF, 0x97, 0xE5, 0xB2, 0xA4, 0xEA, 0xB8, 0xAB, 0xEA,
	0xC1, 0xB0, 0xEA, 0xC3, 0xB4, 0xEA, 0xC3, 0xB5, 0xEA, 0xC3, 0xB6, 0xEB, 0xC6, 0xB8, 0xF3, 0xD8,
	0xBA, 0x9E, 0x63, 0x6C, 0xA0, 0x3C, 0x47, 0xCF, 0x7A, 0x6D, 0xC2, 0x7E, 0x77, 0xC1, 0x7E, 0x77,
	0xBD, 0x79, 0x72, 0xBE, 0x78, 0x72, 0xBD, 0x77, 0x71, 0xBB, 0x75, 0x6F, 0xBA, 0x74, 0x71, 0xB8,
	0x74, 0x73, 0xB6, 0x71, 0x72, 0xB0, 0x6C, 0x6D, 0xAB, 0x68, 0x69, 0xB3, 0x65, 0x66, 0xC6, 0x64,
	0x5C, 0xE5, 0x99, 0x72, 0xF4, 0xC6, 0x8A, 0xF1, 0xBE, 0x83, 0xF1, 0xC4, 0x8F, 0xF3, 0xD1, 0xA1,
	0xF3, 0xC8, 0x8E, 0xE4, 0x8E, 0x68, 0xC6, 0x50, 0x4E, 0xBB, 0x4B, 0x50, 0xB4, 0x45, 0x4D, 0xA3,
	0x3B, 0x46, 0xA6, 0x3C, 0x47, 0xAA, 0x3F, 0x48, 0x94, 0x30, 0x42, 0x99, 0x37, 0x46, 0xA4, 0x47,
	0x51, 0x9D, 0x47, 0x58, 0x95, 0x3F, 0x55, 0x95, 0x3D, 0x54, 0x91, 0x3C, 0x56, 0x92, 0x42, 0x5D,
	0x4C, 0x09, 0x36, 0x45, 0x03, 0x33, 0x71, 0x2F, 0x56, 0xB2, 0x86, 0x91, 0xC9, 0xA7, 0xA4, 0xBF,
	0x8E, 0x8E, 0x80, 0x3A, 0x56, 0x6F, 0x14, 0x37, 0xC1, 0x52, 0x52, 0xE7, 0x87, 0x6D, 0xE9, 0x9A,
	0x77, 0xE9, 0x99, 0x78, 0xE8, 0x9A, 0x79, 0xEA, 0x9A, 0x76, 0xE6, 0x87, 0x6A, 0xE1, 0x7D, 0x72,
	0xB9, 0x64, 0x70, 0x6F, 0x24, 0x4B, 0x56, 0x13, 0x40, 0x49, 0x0A, 0x39, 0x53, 0x12, 0x41, 0x68,
	0x25, 0x51, 0x6C, 0x2A, 0x53, 0x5B, 0x17, 0x40, 0x4F, 0x11, 0x3E, 0x5E, 0x20, 0x4D, 0x61, 0x1E,
	0x48, 0x59, 0x18, 0x42, 0x5B, 0x1A, 0x46, 0x57, 0x1A, 0x47, 0x5B, 0x1F, 0x4D, 0x56, 0x15, 0x41,
	0x59, 0x19, 0x47, 0x63, 0x29, 0x58, 0x67, 0x2C, 0x59, 0x6B, 0x30, 0x60, 0x63, 0x29, 0x5B, 0x80,
	0x52, 0x7E, 0x91, 0x67, 0x95, 0x8E, 0x61, 0x94, 0x6B, 0x30, 0x62, 0x80, 0x50, 0x7D, 0x94, 0x69,
	0x91, 0x7F, 0x4B, 0x74, 0x5F, 0x26, 0x50, 0x5D, 0x12, 0x38, 0x62, 0x16, 0x3B, 0x63, 0x17, 0x3B,
	0x65, 0x16, 0x39, 0x5F, 0x13, 0x38, 0x5E, 0x15, 0x3B, 0x56, 0x0C, 0x36, 0x73, 0x1C, 0x3A, 0x9E,
	0x33, 0x43, 0xBD, 0x47, 0x4D, 0xCA, 0x56, 0x56, 0xD1, 0x5F, 0x5B, 0xB7, 0x49, 0x4F, 0x76, 0x20,
	0x3F, 0x9A, 0x3E, 0x4F, 0xCE, 0x5B, 0x5A, 0xD8, 0x62, 0x5F, 0xDA, 0x67, 0x64, 0xDA, 0x68, 0x64,
	0xDA, 0x69, 0x66, 0xDA, 0x68, 0x63, 0xDA, 0x66, 0x5F, 0xD9, 0x63, 0x5E, 0xD9, 0x62, 0x5F, 0xD8,
	0x63, 0x5F, 0xD9, 0x61, 0x5C, 0xDA, 0x64, 0x5C, 0xD9, 0x6A, 0x63, 0xD9, 0x6F, 0x69, 0xDA, 0x75,
	0x6B, 0xDA, 0x79, 0x6E, 0xDC, 0x7D, 0x72, 0xDD, 0x83, 0x77, 0xDF, 0x87, 0x7B, 0xE0, 0x8B, 0x7C,
	0xE0, 0x95, 0x82, 0xDD, 0x9F, 0x8E, 0xDF, 0xA9, 0x98, 0xE2, 0xB1, 0xA0, 0xE7, 0xB6, 0xA8, 0xEB,
	0xBE, 0xAB, 0xEA, 0xC4, 0xB2, 0xEA, 0xC3, 0xB5, 0xEA, 0xC3, 0xB6, 0xE9, 0xC3, 0xB6, 0xF2, 0xD6,
	0xBE, 0xCE, 0x98, 0x8D, 0xBA, 0x52, 0x52, 0xC5, 0x73, 0x69, 0xB7, 0x73, 0x71, 0xBB, 0x79, 0x76,
	0xBC, 0x79, 0x74, 0xBE, 0x7B, 0x74, 0xBE, 0x7C, 0x75, 0xBB, 0x79, 0x75, 0xBA, 0x76, 0x72, 0xB9,
	0x75, 0x73, 0xB6, 0x73, 0x73, 0xB4, 0x6F, 0x6F, 0xB3, 0x6D, 0x6D, 0xBD, 0x6D, 0x69, 0xC8, 0x68,
	0x5D, 0xD2, 0x6F, 0x5B, 0xE2, 0x8C, 0x68, 0xEB, 0xA5, 0x74, 0xF2, 0xC8, 0x92, 0xF3, 0xD2, 0xA0,
	0xF3, 0xC1, 0x87, 0xDD, 0x7D, 0x61, 0xBF, 0x48, 0x4D, 0xB6, 0x44, 0x4C, 0xAB, 0x3C, 0x47, 0xA0,
	0x39, 0x47, 0xA6, 0x40, 0x4B, 0x97, 0x33, 0x42, 0x8A, 0x2A, 0x41, 0xA4, 0x45, 0x52, 0xA4, 0x49,
	0x56, 0x94, 0x3D, 0x51, 0x8F, 0x37, 0x4D, 0x96, 0x3E, 0x54, 0x96, 0x43, 0x5D, 0x8E, 0x3E, 0x57,
	0x4B, 0x0A, 0x37, 0x43, 0x02, 0x33, 0x67, 0x28, 0x52, 0xA8, 0x7E, 0x90, 0xBE, 0x9D, 0xA1, 0xBC,
	0x8B, 0x8E, 0x89, 0x45, 0x60, 0x75, 0x18, 0x39, 0xBE, 0x4D, 0x4E, 0xE6, 0x84, 0x6B, 0xEA, 0x98,
	0x76, 0xE8, 0x97, 0x76, 0xE8, 0x99, 0x76, 0xEA, 0x99, 0x79, 0xE6, 0x89, 0x6D, 0xDF, 0x79, 0x6B,
	0xBD, 0x67, 0x6D, 0x7A, 0x31, 0x55, 0x5A, 0x17, 0x43, 0x4B, 0x0B, 0x3A, 0x5E, 0x1B, 0x47, 0x69,
	0x24, 0x4D, 0x57, 0x17, 0x40, 0x4E, 0x0E, 0x3A, 0x54, 0x15, 0x44, 0x64, 0x23, 0x50, 0x5F, 0x1D,
	0x48, 0x5C, 0x1C, 0x4A, 0x62, 0x22, 0x4E, 0x5B, 0x1A, 0x46, 0x5E, 0x1D, 0x49, 0x55, 0x13, 0x40,
	0x5E, 0x22, 0x51, 0x68, 0x29, 0x56, 0x51, 0x0F, 0x3D, 0x76, 0x3E, 0x6E, 0x67, 0x2E, 0x5E, 0x5B,
	0x23, 0x4E, 0x6C, 0x37, 0x66, 0x8A, 0x5E, 0x8A, 0x6E, 0x35, 0x62, 0x5E, 0x1F, 0x52, 0x94, 0x6B,
	0x93, 0xAA, 0x89, 0xA1, 0x6B, 0x2F, 0x56, 0x58, 0x09, 0x32, 0x5C, 0x13, 0x3A, 0x63, 0x17, 0x3B,
	0x5E, 0x13, 0x39, 0x5A, 0x0F, 0x37, 0x57, 0x0D, 0x36, 0x5E, 0x0F, 0x36, 0x81, 0x23, 0x3C, 0xAD,
	0x3D, 0x48, 0xC6, 0x4E, 0x50, 0xCA, 0x58, 0x55, 0xD0, 0x5C, 0x57, 0x9B, 0x34, 0x47, 0x75, 0x21,
	0x41, 0xB5, 0x4C, 0x53, 0xD8, 0x60, 0x5C, 0xD9, 0x63, 0x61, 0xD9, 0x66, 0x64, 0xDA, 0x67, 0x64,
	0xDB, 0x6A, 0x67, 0xDB, 0x6B, 0x65, 0xDA, 0x66, 0x61, 0xDA, 0x67, 0x5E, 0xDA, 0x65, 0x5E, 0xD8,
	0x62, 0x5D, 0xD9, 0x61, 0x5B, 0xDA, 0x65, 0x5F, 0xD9, 0x6A, 0x65, 0xDA, 0x6D, 0x68, 0xDA, 0x75,
	0x6A, 0xDA, 0x77, 0x6B, 0xDC, 0x7A, 0x6F, 0xDB, 0x7E, 0x72, 0xDB, 0x80, 0x77, 0xE0, 0x89, 0x7A,
	0xE0, 0x93, 0x7E, 0xDF, 0x9D, 0x88, 0xDF, 0xA7, 0x92, 0xE1, 0xAD, 0x9B, 0xE7, 0xB6, 0xA6, 0xEB,
	0xBC, 0xAB, 0xEA, 0xC2, 0xB1, 0xEA, 0xC2, 0xB7, 0xEA, 0xC2, 0xB6, 0xEA, 0xC5, 0xB6, 0xED, 0xCE,
	0xBB, 0xE9, 0xC0, 0xAA, 0xD5, 0x74, 0x67, 0xB3, 0x57, 0x56, 0x9C, 0x4A, 0x57, 0xA8, 0x58, 0x5E,
	0xAD, 0x64, 0x66, 0xB5, 0x6F, 0x6C, 0xBC, 0x78, 0x74, 0xBC, 0x7B, 0x77, 0xBB, 0x7B, 0x77, 0xB9,
	0x79, 0x76, 0xB7, 0x76, 0x75, 0xB7, 0x72, 0x71, 0xBB, 0x74, 0x70, 0xC7, 0x79, 0x6F, 0xD1, 0x74,
	0x67, 0xCC, 0x67, 0x59, 0xC9, 0x62, 0x57, 0xE2, 0x93, 0x72, 0xF3, 0xCE, 0x9B, 0xF3, 0xD2, 0x9B,
	0xF0, 0xB2, 0x7C, 0xD6, 0x68, 0x58, 0xBC, 0x46, 0x4C, 0xAD, 0x40, 0x49, 0x9F, 0x36, 0x45, 0xA2,
	0x3D, 0x4A, 0x9E, 0x38, 0x48, 0x89, 0x29, 0x40, 0x96, 0x39, 0x4B, 0xA7, 0x49, 0x55, 0x9D, 0x42,
	0x54, 0x91, 0x39, 0x4F, 0x91, 0x3A, 0x50, 0x96, 0x40, 0x56, 0x95, 0x41, 0x56, 0x7F, 0x2E, 0x47,
	0x49, 0x07, 0x36, 0x44, 0x02, 0x33, 0x69, 0x24, 0x4C, 0xA9, 0x7B, 0x8C, 0xC1, 0xA2, 0xA4, 0xC0,
	0x92, 0x93, 0x8D, 0x49, 0x60, 0x75, 0x18, 0x38, 0xBD, 0x4A, 0x4D, 0xE5, 0x83, 0x69, 0xE7, 0x96,
	0x75, 0xE8, 0x97, 0x75, 0xEA, 0x99, 0x77, 0xEA, 0x9A, 0x79, 0xE9, 0x8E, 0x6D, 0xDF, 0x74, 0x61,
	0xB5, 0x5A, 0x64, 0x7D, 0x34, 0x58, 0x5E, 0x1A, 0x44, 0x4E, 0x0E, 0x3A, 0x5B, 0x15, 0x3F, 0x56,
	0x14, 0x3E, 0x51, 0x10, 0x3C, 0x56, 0x15, 0x42, 0x5E, 0x1F, 0x4B, 0x60, 0x20, 0x4D, 0x59, 0x1C,
	0x48, 0x66, 0x28, 0x55, 0x5E, 0x1E, 0x49, 0x52, 0x11, 0x3C, 0x59, 0x15, 0x3F, 0x4D, 0x0B, 0x39,
	0x5B, 0x1E, 0x4C, 0x60, 0x1F, 0x4B, 0x5C, 0x1D, 0x4D, 0x83, 0x51, 0x81, 0x89, 0x5A, 0x86, 0x58,
	0x18, 0x46, 0x48, 0x07, 0x36, 0x66, 0x2E, 0x57, 0x67, 0x2F, 0x5A, 0x64, 0x2B, 0x5D, 0x89, 0x56,
	0x83, 0x87, 0x52, 0x74, 0x5D, 0x11, 0x37, 0x5E, 0x0F, 0x36, 0x59, 0x0F, 0x38, 0x5F, 0x13, 0x38,
	0x59, 0x0F, 0x36, 0x54, 0x09, 0x32, 0x5C, 0x10, 0x36, 0x6F, 0x1B, 0x3C, 0x91, 0x2D, 0x41, 0xBA,
	0x46, 0x4C, 0xC7, 0x50, 0x50, 0xCC, 0x5A, 0x56, 0xC5, 0x52, 0x52, 0x79, 0x1F, 0x3F, 0x82, 0x2B,
	0x44, 0xCC, 0x59, 0x57, 0xDB, 0x62, 0x5C, 0xD8, 0x62, 0x60, 0xD9, 0x65, 0x63, 0xDB, 0x68, 0x64,
	0xDB, 0x6B, 0x66, 0xDB, 0x6C, 0x67, 0xDB, 0x6A, 0x63, 0xDB, 0x6A, 0x61, 0xDB, 0x67, 0x60, 0xDA,
	0x62, 0x5D, 0xD9, 0x63, 0x5D, 0xD9, 0x64, 0x5E, 0xD8, 0x6A, 0x62, 0xDA, 0x6E, 0x66, 0xDA, 0x74,
	0x6A, 0xDC, 0x76, 0x6B, 0xDB, 0x79, 0x6D, 0xDA, 0x7C, 0x72, 0xDB, 0x82, 0x77, 0xDF, 0x89, 0x78,
	0xE1, 0x91, 0x7B, 0xE0, 0x97, 0x81, 0xDE, 0xA3, 0x8C, 0xE1, 0xAB, 0x99, 0xE4, 0xB0, 0xA2, 0xE8,
	0xBC, 0xA9, 0xEA, 0xC3, 0xB1, 0xEA, 0xC2, 0xB6, 0xEA, 0xC2, 0xB6, 0xEA, 0xC5, 0xB6, 0xEC, 0xCC,
	0xB8, 0xF2, 0xD8, 0xBA, 0xD0, 0x84, 0x78, 0x92, 0x2D, 0x3E, 0x84, 0x29, 0x42, 0x8A, 0x2F, 0x44,
	0x92, 0x3B, 0x4B, 0x9D, 0x49, 0x56, 0xA6, 0x57, 0x5E, 0xAD, 0x64, 0x66, 0xB2, 0x6C, 0x6E, 0xB4,
	0x71, 0x71, 0xB4, 0x73, 0x75, 0xB9, 0x77, 0x74, 0xC6, 0x7E, 0x73, 0xD2, 0x82, 0x71, 0xCE, 0x70,
	0x62, 0xC5, 0x60, 0x56, 0xCC, 0x68, 0x5B, 0xE7, 0xA8, 0x81, 0xF4, 0xD4, 0xA1, 0xF3, 0xCC, 0x94,
	0xEB, 0x9C, 0x6F, 0xCC, 0x56, 0x50, 0xAF, 0x3C, 0x47, 0x96, 0x31, 0x42, 0x99, 0x37, 0x45, 0xA3,
	0x3D, 0x48, 0x8A, 0x28, 0x3E, 0x8C, 0x2F, 0x44, 0xA1, 0x46, 0x55, 0x9D, 0x42, 0x52, 0x95, 0x3C,
	0x51, 0x93, 0x3B, 0x51, 0x99, 0x45, 0x5C, 0x96, 0x43, 0x5A, 0x86, 0x33, 0x4C, 0x6F, 0x1E, 0x3C,
	0x46, 0x04, 0x34, 0x40, 0x01, 0x31, 0x5C, 0x18, 0x43, 0xA8, 0x76, 0x85, 0xCC, 0xAE, 0xAB, 0xC7,
	0x9E, 0x9C, 0x98, 0x56, 0x65, 0x74, 0x18, 0x38, 0xB8, 0x46, 0x4A, 0xE4, 0x7F, 0x68, 0xE6, 0x95,
	0x74, 0xE7, 0x97, 0x76, 0xE9, 0x98, 0x79, 0xEA, 0x9B, 0x7A, 0xEA, 0x90, 0x6E, 0xE0, 0x73, 0x5E,
	0xAE, 0x50, 0x5F, 0x85, 0x3B, 0x5F, 0x5F, 0x1C, 0x46, 0x4E, 0x0E, 0x3A, 0x5D, 0x16, 0x3F, 0x51,
	0x10, 0x3C, 0x50, 0x10, 0x3E, 0x5D, 0x1D, 0x49, 0x5E, 0x1F, 0x4A, 0x5C, 0x1E, 0x4A, 0x56, 0x1A,
	0x47, 0x66, 0x25, 0x4F, 0x64, 0x20, 0x48, 0x53, 0x11, 0x3B, 0x50, 0x0E, 0x3A, 0x55, 0x12, 0x3E,
	0x57, 0x15, 0x41, 0x5A, 0x1D, 0x4A, 0x68, 0x31, 0x63, 0x84, 0x52, 0x85, 0x97, 0x6F, 0x96, 0x7D,
	0x4B, 0x73, 0x5C, 0x1C, 0x4E, 0x5F, 0x1F, 0x4D, 0x69, 0x2A, 0x56, 0x78, 0x3F, 0x65, 0x77, 0x3A,
	0x61, 0x6A, 0x24, 0x4D, 0x5C, 0x0F, 0x35, 0x59, 0x0E, 0x35, 0x59, 0x10, 0x37, 0x58, 0x0F, 0x37,
	0x55, 0x0E, 0x37, 0x54, 0x0A, 0x34, 0x65, 0x15, 0x38, 0x83, 0x28, 0x40, 0xAB, 0x3D, 0x48, 0xC6,
	0x50, 0x50, 0xC8, 0x51, 0x4F, 0xCF, 0x58, 0x53, 0x9C, 0x33, 0x43, 0x63, 0x14, 0x3B, 0xA2, 0x43,
	0x4F, 0xD7, 0x5F, 0x5A, 0xDA, 0x61, 0x5C, 0xD8, 0x60, 0x60, 0xDA, 0x65, 0x63, 0xDB, 0x6A, 0x64,
	0xDC, 0x6C, 0x64, 0xDA, 0x67, 0x63, 0xDB, 0x6A, 0x62, 0xDB, 0x69, 0x61, 0xDA, 0x65, 0x60, 0xDA,
	0x62, 0x5D, 0xD9, 0x60, 0x5B, 0xD8, 0x60, 0x5A, 0xD8, 0x66, 0x5E, 0xD9, 0x6D, 0x63, 0xDA, 0x6F,
	0x66, 0xDB, 0x72, 0x69, 0xDB, 0x77, 0x6A, 0xDB, 0x7B, 0x6F, 0xDB, 0x80, 0x73, 0xDF, 0x88, 0x78,
	0xE2, 0x90, 0x7A, 0xE0, 0x93, 0x7E, 0xDF, 0x9D, 0x88, 0xE0, 0xA9, 0x95, 0xE1, 0xAD, 0x9E, 0xE6,
	0xB9, 0xA8, 0xEB, 0xC2, 0xB1, 0xEA, 0xC2, 0xB7, 0xEA, 0xC3, 0xB6, 0xE9, 0xC3, 0xB6, 0xEC, 0xCE,
	0xB6, 0xF6, 0xE5, 0xBF, 0xC8, 0x92, 0x89, 0x82, 0x23, 0x3C, 0x85, 0x2D, 0x43, 0x81, 0x2A, 0x42,
	0x81, 0x28, 0x41, 0x84, 0x2B, 0x42, 0x87, 0x2F, 0x44, 0x8A, 0x35, 0x49, 0x90, 0x3C, 0x4E, 0x95,
	0x47, 0x58, 0x9A, 0x4F, 0x61, 0xAD, 0x66, 0x6B, 0xC7, 0x7E, 0x72, 0xD3, 0x81, 0x6F, 0xCA, 0x73,
	0x66, 0xC9, 0x66, 0x5B, 0xD7, 0x79, 0x61, 0xEF, 0xBE, 0x8D, 0xF4, 0xD5, 0xA2, 0xF2, 0xBC, 0x85,
	0xDF, 0x78, 0x5D, 0xB4, 0x40, 0x48, 0x8F, 0x28, 0x3F, 0x88, 0x28, 0x3E, 0x9C, 0x3A, 0x47, 0x94,
	0x30, 0x41, 0x86, 0x28, 0x40, 0x9D, 0x41, 0x51, 0x9F, 0x45, 0x55, 0x96, 0x3E, 0x54, 0x95, 0x3B,
	0x51, 0x96, 0x40, 0x57, 0x98, 0x4A, 0x62, 0x91, 0x40, 0x59, 0x78, 0x27, 0x45, 0x67, 0x14, 0x37,
	0x4B, 0x08, 0x35, 0x42, 0x01, 0x31, 0x58, 0x14, 0x3F, 0xA8, 0x74, 0x82, 0xCA, 0xAB, 0xA9, 0xC8,
	0xA3, 0xA1, 0xA4, 0x67, 0x72, 0x77, 0x1E, 0x3C, 0xB3, 0x44, 0x49, 0xE2, 0x7F, 0x69, 0xE6, 0x95,
	0x75, 0xE7, 0x96, 0x74, 0xE8, 0x97, 0x76, 0xEA, 0x9D, 0x7C, 0xEC, 0x95, 0x74, 0xD4, 0x6A, 0x5B,
	0x9E, 0x48, 0x5C, 0x87, 0x3E, 0x61, 0x5E, 0x1B, 0x47, 0x50, 0x0F, 0x3C, 0x52, 0x0E, 0x38, 0x4C,
	0x0C, 0x39, 0x5D, 0x1B, 0x48, 0x61, 0x1F, 0x49, 0x57, 0x17, 0x44, 0x5B, 0x1C, 0x48, 0x55, 0x18,
	0x45, 0x66, 0x22, 0x4D, 0x64, 0x20, 0x4C, 0x5C, 0x1C, 0x46, 0x55, 0x11, 0x3D, 0x59, 0x15, 0x40,
	0x5A, 0x19, 0x44, 0x53, 0x14, 0x41, 0x4E, 0x11, 0x40, 0x6B, 0x33, 0x66, 0x8F, 0x62, 0x92, 0x9C,
	0x79, 0xA0, 0x82, 0x51, 0x7D, 0x7E, 0x43, 0x6F, 0x88, 0x4D, 0x75, 0x6F, 0x2F, 0x55, 0x4F, 0x0B,
	0x34, 0x5C, 0x12, 0x37, 0x60, 0x15, 0x3A, 0x56, 0x10, 0x39, 0x57, 0x10, 0x37, 0x53, 0x0B, 0x35,
	0x52, 0x0B, 0x35, 0x57, 0x0C, 0x35, 0x71, 0x1C, 0x3B, 0x98, 0x33, 0x42, 0xBD, 0x46, 0x4C, 0xC8,
	0x50, 0x51, 0xCE, 0x56, 0x51, 0xB9, 0x45, 0x49, 0x62, 0x0E, 0x36, 0x78, 0x26, 0x44, 0xC6, 0x59,
	0x59, 0xDB, 0x61, 0x5B, 0xDA, 0x60, 0x5C, 0xD9, 0x62, 0x5F, 0xD9, 0x66, 0x63, 0xDA, 0x67, 0x62,
	0xDA, 0x67, 0x61, 0xDA, 0x68, 0x63, 0xDB, 0x6B, 0x64, 0xDB, 0x69, 0x61, 0xDB, 0x65, 0x5D, 0xDA,
	0x64, 0x5E, 0xDA, 0x61, 0x5C, 0xD8, 0x5F, 0x5A, 0xD9, 0x65, 0x5D, 0xD9, 0x68, 0x5F, 0xD9, 0x6C,
	0x63, 0xDA, 0x6F, 0x66, 0xDB, 0x76, 0x69, 0xDB, 0x79, 0x6B, 0xDB, 0x7D, 0x70, 0xDD, 0x83, 0x75,
	0xE0, 0x8A, 0x79, 0xE1, 0x90, 0x7B, 0xE0, 0x98, 0x84, 0xDE, 0xA5, 0x92, 0xE1, 0xAD, 0x9B, 0xE7,
	0xB5, 0xA6, 0xEA, 0xBD, 0xAD, 0xEA, 0xC3, 0xB5, 0xEA, 0xC3, 0xB6, 0xE8, 0xC3, 0xB7, 0xEB, 0xCA,
	0xB6, 0xF4, 0xDF, 0xBD, 0xDA, 0xB1, 0x9E, 0x8E, 0x37, 0x49, 0x91, 0x36, 0x47, 0x97, 0x3E, 0x4D,
	0x91, 0x36, 0x48, 0x89, 0x30, 0x45, 0x81, 0x28, 0x40, 0x75, 0x1E, 0x3B, 0x6E, 0x1D, 0x3A, 0x69,
	0x19, 0x3A, 0x68, 0x19, 0x3C, 0x7D, 0x2D, 0x46, 0xA1, 0x49, 0x53, 0xC8, 0x6E, 0x64, 0xE5, 0x9E,
	0x78, 0xE3, 0x8C, 0x6B, 0xE3, 0x8F, 0x6D, 0xF2, 0xC9, 0x92, 0xF5, 0xD2, 0x98, 0xEF, 0xA4, 0x74,
	0xC6, 0x52, 0x4E, 0x8B, 0x23, 0x3C, 0x75, 0x19, 0x3A, 0x8D, 0x2B, 0x40, 0x91, 0x2F, 0x40, 0x8A,
	0x2C, 0x41, 0x99, 0x40, 0x51, 0xA1, 0x49, 0x59, 0x94, 0x3A, 0x4F, 0x93, 0x3A, 0x4F, 0x93, 0x3A,
	0x4F, 0x96, 0x43, 0x5A, 0x98, 0x48, 0x60, 0x89, 0x36, 0x53, 0x6F, 0x1D, 0x3D, 0x64, 0x13, 0x36,
	0x69, 0x19, 0x3A, 0x6D, 0x1B, 0x3C, 0x70, 0x20, 0x44, 0xA5, 0x6E, 0x7D, 0xCA, 0xAA, 0xA6, 0xCD,
	0xAD, 0xA8, 0xAC, 0x74, 0x7E, 0x7C, 0x24, 0x3F, 0xB2, 0x45, 0x4A, 0xE1, 0x7E, 0x6A, 0xE6, 0x94,
	0x75, 0xE6, 0x97, 0x73, 0xE6, 0x97, 0x74, 0xEA, 0xA1, 0x7B, 0xEF, 0x98, 0x75, 0xCA, 0x63, 0x59,
	0x9D, 0x4C, 0x60, 0x7C, 0x35, 0x57, 0x56, 0x10, 0x3D, 0x52, 0x12, 0x3D, 0x54, 0x14, 0x3F, 0x5A,
	0x17, 0x43, 0x5B, 0x17, 0x43, 0x59, 0x18, 0x43, 0x55, 0x16, 0x42, 0x59, 0x19, 0x46, 0x5C, 0x1D,
	0x49, 0x63, 0x22, 0x4E, 0x5F, 0x1D, 0x4A, 0x5F, 0x1C, 0x47, 0x5A, 0x17, 0x41, 0x50, 0x10, 0x3B,
	0x52, 0x13, 0x3E, 0x59, 0x17, 0x42, 0x55, 0x14, 0x40, 0x51, 0x11, 0x40, 0x6D, 0x35, 0x69, 0x99,
	0x75, 0x9C, 0xA1, 0x80, 0xA4, 0x86, 0x54, 0x83, 0x83, 0x48, 0x75, 0x7D, 0x41, 0x68, 0x51, 0x0E,
	0x3B, 0x5C, 0x10, 0x36, 0x58, 0x0F, 0x37, 0x55, 0x10, 0x3A, 0x54, 0x0F, 0x39, 0x51, 0x0A, 0x35,
	0x52, 0x08, 0x33, 0x64, 0x12, 0x36, 0x86, 0x29, 0x3F, 0xAD, 0x3F, 0x48, 0xC5, 0x4A, 0x4D, 0xCC,
	0x53, 0x51, 0xC8, 0x4F, 0x4E, 0x75, 0x1A, 0x39, 0x5C, 0x10, 0x38, 0xB0, 0x48, 0x50, 0xD7, 0x61,
	0x59, 0xD9, 0x62, 0x5D, 0xD9, 0x62, 0x5D, 0xD8, 0x63, 0x61, 0xD9, 0x65, 0x62, 0xDA, 0x65, 0x60,
	0xDA, 0x65, 0x61, 0xDB, 0x6A, 0x65, 0xDC, 0x6C, 0x66, 0xDB, 0x6A, 0x63, 0xDB, 0x69, 0x5F, 0xDA,
	0x66, 0x5E, 0xDA, 0x62, 0x5E, 0xD9, 0x61, 0x5C, 0xD9, 0x65, 0x5E, 0xDA, 0x65, 0x5C, 0xD9, 0x68,
	0x60, 0xD8, 0x6E, 0x63, 0xD7, 0x73, 0x69, 0xDB, 0x78, 0x6A, 0xDB, 0x7B, 0x6D, 0xDA, 0x7F, 0x72,
	0xDC, 0x82, 0x77, 0xE1, 0x8C, 0x7A, 0xE2, 0x97, 0x82, 0xDE, 0xA0, 0x8D, 0xDE, 0xA8, 0x97, 0xE4,
	0xB2, 0xA2, 0xE8, 0xBB, 0xAB, 0xE8, 0xC3, 0xB2, 0xEA, 0xC3, 0xB6, 0xE9, 0xC2, 0xB7, 0xEA, 0xC8,
	0xB7, 0xF0, 0xD6, 0xB9, 0xEC, 0xCE, 0xB1, 0xA3, 0x58, 0x60, 0x8F, 0x33, 0x46, 0xA4, 0x49, 0x53,
	0xA3, 0x46, 0x50, 0x9A, 0x3F, 0x4E, 0x8F, 0x37, 0x48, 0x82, 0x2B, 0x42, 0x6F, 0x1E, 0x3D, 0x5B,
	0x10, 0x37, 0x4D, 0x08, 0x34, 0x46, 0x02, 0x31, 0x75, 0x21, 0x41, 0xD7, 0x90, 0x74, 0xF6, 0xC3,
	0x85, 0xE5, 0x8F, 0x6A, 0xE8, 0xA0, 0x77, 0xF4, 0xD1, 0x95, 0xF8, 0xC9, 0x8B, 0xDC, 0x7E, 0x61,
	0x93, 0x2A, 0x3F, 0x6F, 0x17, 0x39, 0x7E, 0x23, 0x3E, 0x89, 0x2D, 0x41, 0x81, 0x26, 0x3F, 0x93,
	0x39, 0x4E, 0xA3, 0x4D, 0x5E, 0x98, 0x41, 0x56, 0x8C, 0x36, 0x4C, 0x88, 0x34, 0x4A, 0x93, 0x3C,
	0x52, 0x9A, 0x4B, 0x63, 0x96, 0x44, 0x5C, 0x7F, 0x2C, 0x47, 0x69, 0x19, 0x3A, 0x65, 0x15, 0x38,
	0x8D, 0x37, 0x49, 0x8C, 0x35, 0x48, 0x89, 0x38, 0x55, 0xA5, 0x6C, 0x7D, 0xCA, 0xA4, 0x9F, 0xD0,
	0xAF, 0xA7, 0xB3, 0x7F, 0x85, 0x86, 0x31, 0x49, 0xB3, 0x44, 0x49, 0xE0, 0x7B, 0x68, 0xE7, 0x95,
	0x77, 0xE9, 0x99, 0x76, 0xE7, 0x99, 0x77, 0xEA, 0xA4, 0x7A, 0xEC, 0x96, 0x70, 0xC6, 0x60, 0x5B,
	0xA5, 0x55, 0x68, 0x7D, 0x36, 0x59, 0x50, 0x0B, 0x39, 0x56, 0x14, 0x3F, 0x5F, 0x1C, 0x47, 0x5C,
	0x18, 0x41, 0x51, 0x0F, 0x3A, 0x57, 0x15, 0x40, 0x57, 0x17, 0x42, 0x58, 0x16, 0x43, 0x5E, 0x1C,
	0x48, 0x5E, 0x1F, 0x4C, 0x64, 0x22, 0x4F, 0x5F, 0x1C, 0x46, 0x50, 0x12, 0x3E, 0x4E, 0x10, 0x3B,
	0x52, 0x10, 0x3A, 0x57, 0x14, 0x3F, 0x66, 0x24, 0x4F, 0x59, 0x16, 0x42, 0x4E, 0x0D, 0x3C, 0x73,
	0x3D, 0x69, 0x96, 0x70, 0x96, 0x94, 0x6F, 0x97, 0x89, 0x54, 0x83, 0x84, 0x4B, 0x70, 0x5D, 0x19,
	0x41, 0x56, 0x0D, 0x35, 0x52, 0x0E, 0x37, 0x52, 0x0D, 0x36, 0x50, 0x08, 0x34, 0x50, 0x09, 0x36,
	0x5B, 0x0D, 0x35, 0x7B, 0x20, 0x3C, 0x9B, 0x33, 0x43, 0xBE, 0x49, 0x4D, 0xD0, 0x55, 0x52, 0xCB,
	0x51, 0x4F, 0x82, 0x22, 0x3D, 0x54, 0x0A, 0x34, 0x9A, 0x36, 0x45, 0xD2, 0x5C, 0x55, 0xD6, 0x61,
	0x59, 0xD6, 0x61, 0x5C, 0xDA, 0x62, 0x5C, 0xD9, 0x67, 0x61, 0xD9, 0x64, 0x61, 0xDA, 0x67, 0x62,
	0xDA, 0x66, 0x61, 0xDB, 0x69, 0x62, 0xDB, 0x6B, 0x65, 0xDB, 0x6A, 0x64, 0xDB, 0x6B, 0x62, 0xDA,
	0x67, 0x5E, 0xDA, 0x64, 0x5F, 0xD9, 0x63, 0x5D, 0xD9, 0x63, 0x5D, 0xDA, 0x67, 0x5E, 0xD8, 0x67,
	0x5E, 0xD7, 0x6A, 0x61, 0xD8, 0x6E, 0x65, 0xDB, 0x74, 0x66, 0xDC, 0x7B, 0x6C, 0xDA, 0x7D, 0x70,
	0xDB, 0x81, 0x75, 0xE0, 0x8B, 0x79, 0xE3, 0x93, 0x7A, 0xDF, 0x9A, 0x85, 0xDE, 0xA6, 0x95, 0xE2,
	0xB0, 0xA0, 0xE4, 0xB7, 0xA7, 0xE7, 0xC1, 0xB0, 0xE8, 0xC3, 0xB5, 0xEA, 0xC2, 0xB6, 0xE9, 0xC3,
	0xB7, 0xEB, 0xC8, 0xB7, 0xF4, 0xDB, 0xBC, 0xBC, 0x7E, 0x79, 0x8B, 0x2E, 0x44, 0xA2, 0x49, 0x55,
	0xA7, 0x4D, 0x54, 0xA2, 0x48, 0x52, 0x99, 0x41, 0x51, 0x8D, 0x3A, 0x4D, 0x81, 0x2D, 0x45, 0x6F,
	0x1F, 0x3E, 0x57, 0x11, 0x39, 0x3C, 0x00, 0x34, 0x75, 0x23, 0x42, 0xEB, 0xA4, 0x77, 0xF5, 0xBF,
	0x82, 0xE5, 0x8F, 0x69, 0xED, 0xB2, 0x7E, 0xF9, 0xCF, 0x8E, 0xEA, 0x9B, 0x71, 0x9C, 0x35, 0x43,
	0x67, 0x10, 0x36, 0x74, 0x1D, 0x3D, 0x86, 0x28, 0x3F, 0x7E, 0x25, 0x3F, 0x8A, 0x31, 0x46, 0xA2,
	0x4A, 0x5A, 0x99, 0x44, 0x58, 0x85, 0x31, 0x49, 0x81, 0x2E, 0x47, 0x87, 0x32, 0x49, 0x97, 0x47,
	0x5E, 0x9C, 0x53, 0x6A, 0x8F, 0x3E, 0x57, 0x80, 0x2D, 0x49, 0x6F, 0x20, 0x3F, 0x69, 0x1B, 0x3C,
	0x8E, 0x3A, 0x4C, 0x93, 0x3E, 0x53, 0x99, 0x50, 0x67, 0xB0, 0x79, 0x82, 0xC7, 0xA4, 0xA2, 0xCC,
	0xAC, 0xA8, 0xB9, 0x88, 0x8B, 0x8D, 0x3C, 0x50, 0xB1, 0x42, 0x48, 0xDF, 0x7A, 0x69, 0xE7, 0x95,
	0x77, 0xE9, 0x99, 0x77, 0xE9, 0x9D, 0x78, 0xEB, 0xA6, 0x7A, 0xEC, 0x97, 0x6F, 0xC0, 0x60, 0x5F,
	0xA1, 0x51, 0x69, 0x78, 0x30, 0x57, 0x51, 0x10, 0x3C, 0x54, 0x12, 0x3D, 0x56, 0x13, 0x3D, 0x56,
	0x12, 0x3C, 0x56, 0x12, 0x3D, 0x5B, 0x18, 0x42, 0x58, 0x18, 0x42, 0x53, 0x14, 0x40, 0x54, 0x14,
	0x40, 0x5F, 0x20, 0x4D, 0x5E, 0x1E, 0x4B, 0x61, 0x21, 0x4E, 0x5D, 0x1E, 0x4B, 0x4D, 0x0E, 0x3A,
	0x5A, 0x1A, 0x48, 0x60, 0x20, 0x4F, 0x62, 0x20, 0x4A, 0x5F, 0x1E, 0x4B, 0x5F, 0x20, 0x4F, 0x65,
	0x26, 0x55, 0x75, 0x3C, 0x6B, 0x86, 0x57, 0x81, 0x8B, 0x5D, 0x88, 0x6B, 0x2F, 0x58, 0x56, 0x0E,
	0x37, 0x53, 0x10, 0x3A, 0x54, 0x11, 0x38, 0x51, 0x0D, 0x37, 0x4D, 0x08, 0x36, 0x56, 0x0C, 0x36,
	0x6E, 0x1A, 0x3A, 0x90, 0x2D, 0x41, 0xB3, 0x40, 0x49, 0xCE, 0x53, 0x52, 0xBC, 0x48, 0x4B, 0x77,
	0x1C, 0x3B, 0x53, 0x08, 0x34, 0x91, 0x2E, 0x42, 0xCB, 0x54, 0x51, 0xD4, 0x5C, 0x55, 0xD5, 0x5F,
	0x58, 0xD6, 0x61, 0x5B, 0xDA, 0x64, 0x5E, 0xDA, 0x67, 0x61, 0xDA, 0x64, 0x5F, 0xDA, 0x66, 0x61,
	0xDA, 0x66, 0x62, 0xDB, 0x68, 0x62, 0xDB, 0x6B, 0x63, 0xDA, 0x68, 0x61, 0xDB, 0x6B, 0x63, 0xDB,
	0x69, 0x61, 0xDA, 0x68, 0x62, 0xDA, 0x63, 0x5E, 0xD9, 0x63, 0x5D, 0xD9, 0x69, 0x60, 0xD7, 0x69,
	0x5F, 0xD7, 0x68, 0x60, 0xD9, 0x6D, 0x63, 0xDA, 0x72, 0x66, 0xDA, 0x76, 0x68, 0xDA, 0x7A, 0x6D,
	0xDC, 0x82, 0x76, 0xDF, 0x89, 0x79, 0xE1, 0x8C, 0x79, 0xE1, 0x95, 0x80, 0xDE, 0x9F, 0x8E, 0xE0,
	0xAA, 0x9A, 0xE2, 0xB3, 0xA2, 0xE5, 0xBE, 0xAD, 0xE8, 0xC3, 0xB5, 0xEA, 0xC3, 0xB7, 0xE9, 0xC3,
	0xB7, 0xEA, 0xC2, 0xB6, 0xF3, 0xD7, 0xBD, 0xD3, 0xA3, 0x92, 0x8D, 0x33, 0x46, 0x98, 0x3E, 0x4E,
	0xA7, 0x4C, 0x54, 0xA6, 0x4B, 0x52, 0x9C, 0x42, 0x51, 0x95, 0x3D, 0x50, 0x8E, 0x38, 0x4A, 0x81,
	0x2D, 0x44, 0x6F, 0x1F, 0x3E, 0x5F, 0x11, 0x38, 0x84, 0x28, 0x42, 0xDE, 0x91, 0x70, 0xF6, 0xC5,
	0x89, 0xF0, 0xB8, 0x80, 0xF3, 0xB1, 0x7A, 0xE7, 0x92, 0x6C, 0xA5, 0x42, 0x48, 0x63, 0x0E, 0x35,
	0x66, 0x16, 0x3A, 0x7C, 0x22, 0x3F, 0x7C, 0x1F, 0x3C, 0x86, 0x2B, 0x43, 0x9E, 0x45, 0x55, 0x9F,
	0x48, 0x5B, 0x88, 0x33, 0x4C, 0x7D, 0x28, 0x43, 0x80, 0x2B, 0x45, 0x91, 0x3E, 0x55, 0x9C, 0x53,
	0x6A, 0x97, 0x4C, 0x65, 0x8C, 0x3A, 0x53, 0x7E, 0x2C, 0x4A, 0x6E, 0x20, 0x41, 0x6D, 0x22, 0x42,
	0x7E, 0x2D, 0x48, 0x99, 0x4B, 0x63, 0x9C, 0x59, 0x70, 0xAB, 0x74, 0x81, 0xC3, 0xA1, 0xA2, 0xCA,
	0xAB, 0xA9, 0xB9, 0x89, 0x8C, 0x90, 0x3F, 0x53, 0xAE, 0x43, 0x4A, 0xDE, 0x7A, 0x69, 0xE5, 0x94,
	0x76, 0xE7, 0x97, 0x76, 0xE9, 0x9D, 0x79, 0xEB, 0xA4, 0x7A, 0xED, 0x96, 0x71, 0xBE, 0x5F, 0x60,
	0x9D, 0x50, 0x69, 0x6F, 0x29, 0x4F, 0x4C, 0x0C, 0x3A, 0x55, 0x15, 0x41, 0x57, 0x15, 0x40, 0x5A,
	0x16, 0x42, 0x59, 0x15, 0x40, 0x5B, 0x19, 0x44, 0x5A, 0x19, 0x45, 0x4D, 0x0F, 0x3C, 0x59, 0x1A,
	0x48, 0x70, 0x32, 0x5F, 0x5C, 0x21, 0x4F, 0x67, 0x29, 0x57, 0x6E, 0x2F, 0x5C, 0x4C, 0x0C, 0x38,
	0x5B, 0x1C, 0x4B, 0x6F, 0x31, 0x5E, 0x60, 0x1F, 0x4A, 0x66, 0x2B, 0x57, 0x62, 0x26, 0x55, 0x69,
	0x2B, 0x5D, 0x80, 0x4D, 0x79, 0x83, 0x53, 0x7C, 0x6B, 0x2F, 0x5B, 0x69, 0x28, 0x52, 0x52, 0x0E,
	0x38, 0x52, 0x10, 0x39, 0x55, 0x10, 0x38, 0x4D, 0x0B, 0x36, 0x4D, 0x08, 0x35, 0x65, 0x14, 0x38,
	0x89, 0x2A, 0x40, 0xA3, 0x38, 0x44, 0xA6, 0x38, 0x46, 0x8B, 0x29, 0x40, 0x64, 0x12, 0x37, 0x67,
	0x14, 0x38, 0x9F, 0x35, 0x44, 0xC5, 0x4D, 0x4E, 0xCE, 0x58, 0x52, 0xD3, 0x5D, 0x57, 0xD7, 0x5E,
	0x59, 0xD8, 0x61, 0x5A, 0xD9, 0x63, 0x5C, 0xD9, 0x64, 0x5F, 0xDA, 0x65, 0x5F, 0xDB, 0x68, 0x5F,
	0xDA, 0x67, 0x62, 0xDB, 0x69, 0x62, 0xDC, 0x6C, 0x61, 0xDB, 0x6B, 0x61, 0xDC, 0x6D, 0x64, 0xDC,
	0x6C, 0x64, 0xDB, 0x6A, 0x62, 0xDA, 0x68, 0x60, 0xD9, 0x67, 0x62, 0xD9, 0x68, 0x60, 0xDA, 0x66,
	0x5D, 0xD9, 0x67, 0x5C, 0xD8, 0x6B, 0x61, 0xD8, 0x70, 0x65, 0xD9, 0x72, 0x67, 0xDA, 0x78, 0x6C,
	0xDC, 0x80, 0x73, 0xDE, 0x85, 0x78, 0xE1, 0x8C, 0x7A, 0xE2, 0x90, 0x7E, 0xDF, 0x96, 0x89, 0xDE,
	0xA4, 0x95, 0xE0, 0xAF, 0x9E, 0xE1, 0xB7, 0xA8, 0xE7, 0xBE, 0xB0, 0xE8, 0xC3, 0xB6, 0xE8, 0xC4,
	0xB8, 0xE8, 0xC4, 0xB7, 0xEF, 0xD1, 0xBB, 0xE7, 0xC3, 0xA9, 0x99, 0x48, 0x54, 0x8C, 0x32, 0x46,
	0xA0, 0x46, 0x54, 0xA2, 0x48, 0x53, 0x9D, 0x44, 0x52, 0x98, 0x3F, 0x52, 0x95, 0x40, 0x55, 0x89,
	0x36, 0x4B, 0x84, 0x30, 0x48, 0x86, 0x2E, 0x45, 0x9A, 0x36, 0x49, 0xDB, 0x94, 0x78, 0xFA, 0xD7,
	0x97, 0xF6, 0xBD, 0x84, 0xD2, 0x6F, 0x5C, 0x9A, 0x35, 0x45, 0x70, 0x16, 0x39, 0x6B, 0x18, 0x3B,
	0x7A, 0x25, 0x41, 0x7C, 0x22, 0x3E, 0x83, 0x29, 0x42, 0x98, 0x43, 0x56, 0x9E, 0x4B, 0x60, 0x8D,
	0x3A, 0x51, 0x7A, 0x27, 0x43, 0x7D, 0x27, 0x43, 0x8B, 0x34, 0x4C, 0x9B, 0x4E, 0x65, 0x9D, 0x53,
	0x6A, 0x94, 0x45, 0x60, 0x87, 0x36, 0x52, 0x72, 0x23, 0x42, 0x70, 0x24, 0x44, 0x6F, 0x24, 0x44,
	0x68, 0x1A, 0x3C, 0x8D, 0x3E, 0x59, 0x90, 0x48, 0x66, 0x9B, 0x63, 0x7B, 0xBC, 0x99, 0x9F, 0xCB,
	0xAC, 0xA9, 0xBA, 0x8B, 0x8E, 0x92, 0x45, 0x58, 0xAE, 0x43, 0x49, 0xDD, 0x76, 0x65, 0xE6, 0x94,
	0x75, 0xE9, 0x9A, 0x78, 0xEA, 0x9E, 0x7B, 0xEA, 0xA2, 0x7B, 0xF0, 0x99, 0x74, 0xC3, 0x64, 0x60,
	0x8B, 0x3C, 0x5D, 0x61, 0x1F, 0x47, 0x4A, 0x0C, 0x37, 0x56, 0x15, 0x40, 0x59, 0x17, 0x43, 0x5F,
	0x1A, 0x45, 0x5A, 0x16, 0x41, 0x5A, 0x19, 0x46, 0x5F, 0x21, 0x4E, 0x4F, 0x10, 0x3C, 0x5C, 0x1B,
	0x48, 0x74, 0x38, 0x64, 0x60, 0x24, 0x54, 0x68, 0x2C, 0x5B, 0x82, 0x49, 0x78, 0x5F, 0x21, 0x4D,
	0x56, 0x15, 0x42, 0x69, 0x2B, 0x57, 0x54, 0x15, 0x42, 0x6D, 0x36, 0x61, 0x6D, 0x35, 0x60, 0x5E,
	0x1E, 0x4E, 0x7D, 0x4A, 0x7B, 0x99, 0x74, 0x99, 0x70, 0x38, 0x61, 0x59, 0x18, 0x45, 0x51, 0x10,
	0x3C, 0x50, 0x0D, 0x37, 0x53, 0x10, 0x39, 0x55, 0x0E, 0x37, 0x56, 0x0A, 0x33, 0x66, 0x11, 0x35,
	0x72, 0x1C, 0x3B, 0x6E, 0x1A, 0x3A, 0x65, 0x17, 0x3B, 0x6B, 0x17, 0x3B, 0x8F, 0x2B, 0x42, 0xB9,
	0x44, 0x4B, 0xCA, 0x52, 0x51, 0xCD, 0x56, 0x55, 0xCE, 0x58, 0x55, 0xD0, 0x5D, 0x58, 0xD4, 0x5E,
	0x5A, 0xD5, 0x61, 0x5C, 0xD7, 0x63, 0x5D, 0xD8, 0x63, 0x5E, 0xDA, 0x66, 0x5F, 0xDA, 0x66, 0x5F,
	0xDA, 0x65, 0x61, 0xDB, 0x6A, 0x62, 0xDB, 0x6B, 0x60, 0xDC, 0x6F, 0x64, 0xDD, 0x6F, 0x65, 0xDC,
	0x6E, 0x64, 0xDB, 0x6C, 0x65, 0xDA, 0x6A, 0x63, 0xDA, 0x6A, 0x62, 0xD9, 0x67, 0x5F, 0xDB, 0x68,
	0x5E, 0xDA, 0x6A, 0x5D, 0xD9, 0x6A, 0x5F, 0xD8, 0x6E, 0x63, 0xD8, 0x73, 0x66, 0xDA, 0x79, 0x6B,
	0xDB, 0x7D, 0x70, 0xDD, 0x82, 0x77, 0xE0, 0x8A, 0x7A, 0xE2, 0x92, 0x81, 0xDE, 0x97, 0x8B, 0xDE,
	0x9F, 0x91, 0xE0, 0xAC, 0x9A, 0xE0, 0xB3, 0xA3, 0xE5, 0xBB, 0xAD, 0xE6, 0xC2, 0xB5, 0xE7, 0xC5,
	0xB8, 0xE6, 0xC6, 0xB8, 0xEB, 0xCA, 0xB8, 0xF1, 0xD1, 0xB6, 0xAB, 0x67, 0x6A, 0x84, 0x2A, 0x40,
	0x96, 0x40, 0x53, 0x9B, 0x44, 0x56, 0x9E, 0x47, 0x56, 0x99, 0x45, 0x59, 0x97, 0x44, 0x5B, 0x91,
	0x3F, 0x56, 0x95, 0x43, 0x59, 0x9B, 0x42, 0x53, 0xA3, 0x40, 0x4E, 0xD6, 0x80, 0x6C, 0xEF, 0xB1,
	0x81, 0xCE, 0x76, 0x61, 0x8E, 0x2F, 0x43, 0x77, 0x20, 0x3E, 0x7B, 0x22, 0x3E, 0x84, 0x29, 0x41,
	0x81, 0x27, 0x41, 0x83, 0x2A, 0x43, 0x98, 0x45, 0x59, 0xA0, 0x51, 0x64, 0x90, 0x3C, 0x52, 0x7F,
	0x2A, 0x44, 0x70, 0x1F, 0x3D, 0x7E, 0x2B, 0x45, 0x99, 0x46, 0x5C, 0x9F, 0x56, 0x6C, 0x9B, 0x52,
	0x69, 0x92, 0x43, 0x5F, 0x79, 0x2B, 0x49, 0x6C, 0x1F, 0x3E, 0x73, 0x25, 0x43, 0x68, 0x1D, 0x40,
	0x5B, 0x12, 0x38, 0x73, 0x25, 0x46, 0x83, 0x36, 0x5C, 0x96, 0x58, 0x74, 0xB6, 0x91, 0x99, 0xC8,
	0xA8, 0xA6, 0xBA, 0x8B, 0x8E, 0x99, 0x50, 0x60, 0xAF, 0x45, 0x4B, 0xDA, 0x72, 0x62, 0xE6, 0x93,
	0x75, 0xEA, 0x9B, 0x7A, 0xEA, 0x9E, 0x7B, 0xEA, 0xA2, 0x7C, 0xF1, 0x9C, 0x77, 0xCF, 0x6E, 0x63,
	0x76, 0x26, 0x4D, 0x53, 0x13, 0x41, 0x50, 0x11, 0x3C, 0x55, 0x14, 0x3E, 0x54, 0x14, 0x3F, 0x61,
	0x1E, 0x4A, 0x5E, 0x1B, 0x47, 0x60, 0x1F, 0x4D, 0x67, 0x2A, 0x56, 0x52, 0x12, 0x3D, 0x5B, 0x1B,
	0x48, 0x70, 0x33, 0x5F, 0x59, 0x1A, 0x48, 0x65, 0x29, 0x5A, 0x8E, 0x5E, 0x8C, 0x74, 0x3C, 0x69,
	0x4D, 0x0D, 0x3C, 0x72, 0x38, 0x66, 0x5F, 0x26, 0x53, 0x58, 0x1B, 0x47, 0x7B, 0x43, 0x6D, 0x64,
	0x27, 0x56, 0x7B, 0x45, 0x78, 0x92, 0x66, 0x93, 0x85, 0x55, 0x7F, 0x61, 0x22, 0x4F, 0x4D, 0x0F,
	0x39, 0x52, 0x12, 0x3D, 0x54, 0x10, 0x3A, 0x54, 0x0C, 0x36, 0x5A, 0x0B, 0x34, 0x61, 0x11, 0x37,
	0x6D, 0x19, 0x3B, 0x80, 0x22, 0x3E, 0x98, 0x2F, 0x43, 0xB4, 0x41, 0x4C, 0xC7, 0x4F, 0x51, 0xCD,
	0x54, 0x52, 0xCE, 0x56, 0x53, 0xCE, 0x59, 0x57, 0xCF, 0x5A, 0x57, 0xCF, 0x59, 0x54, 0xD2, 0x5B,
	0x55, 0xD4, 0x5F, 0x5A, 0xD6, 0x61, 0x5C, 0xD8, 0x63, 0x5E, 0xDA, 0x61, 0x5B, 0xD9, 0x62, 0x5D,
	0xDA, 0x67, 0x61, 0xDA, 0x68, 0x63, 0xDB, 0x69, 0x61, 0xDB, 0x6C, 0x64, 0xDC, 0x6E, 0x67, 0xDD,
	0x6F, 0x67, 0xDB, 0x6C, 0x67, 0xDB, 0x6C, 0x64, 0xDA, 0x6D, 0x60, 0xD9, 0x6A, 0x60, 0xD9, 0x69,
	0x5E, 0xDA, 0x6B, 0x5E, 0xDA, 0x6B, 0x60, 0xD8, 0x6C, 0x62, 0xD8, 0x72, 0x65, 0xDA, 0x78, 0x6A,
	0xDC, 0x7C, 0x6F, 0xDD, 0x81, 0x75, 0xDF, 0x86, 0x78, 0xE1, 0x8F, 0x7D, 0xDF, 0x97, 0x89, 0xDD,
	0xA1, 0x90, 0xE0, 0xA9, 0x97, 0xE1, 0xAF, 0x9E, 0xE2, 0xB8, 0xA8, 0xE5, 0xC0, 0xB2, 0xE8, 0xC4,
	0xB7, 0xE7, 0xC6, 0xB8, 0xE8, 0xC8, 0xB8, 0xF3, 0xD7, 0xBC, 0xC3, 0x8B, 0x85, 0x80, 0x2A, 0x40,
	0x8C, 0x38, 0x4B, 0x96, 0x42, 0x56, 0x9D, 0x48, 0x58, 0x9F, 0x4E, 0x5F, 0x99, 0x48, 0x5F, 0x99,
	0x49, 0x60, 0xA5, 0x51, 0x62, 0xAC, 0x4F, 0x57, 0xAD, 0x4A, 0x51, 0xBD, 0x54, 0x54, 0xBA, 0x59,
	0x57, 0x96, 0x38, 0x4B, 0x84, 0x2E, 0x46, 0x8D, 0x34, 0x46, 0x95, 0x34, 0x45, 0x8C, 0x2D, 0x41,
	0x81, 0x27, 0x40, 0x92, 0x3B, 0x52, 0x9C, 0x4E, 0x65, 0x92, 0x41, 0x58, 0x82, 0x2B, 0x43, 0x75,
	0x1F, 0x3D, 0x70, 0x1F, 0x3E, 0x8D, 0x3C, 0x55, 0x9E, 0x54, 0x6B, 0xA0, 0x5D, 0x70, 0x9B, 0x54,
	0x6C, 0x8A, 0x3B, 0x5B, 0x73, 0x24, 0x41, 0x6C, 0x1F, 0x3D, 0x6B, 0x1D, 0x3D, 0x5F, 0x16, 0x3B,
	0x5D, 0x18, 0x3F, 0x66, 0x1E, 0x40, 0x71, 0x27, 0x4D, 0x88, 0x46, 0x68, 0xB6, 0x8F, 0x97, 0xD1,
	0xB2, 0xAC, 0xC6, 0x9C, 0x98, 0xA2, 0x5F, 0x6A, 0xAE, 0x48, 0x4F, 0xDA, 0x72, 0x61, 0xE8, 0x94,
	0x76, 0xEB, 0x9D, 0x7D, 0xEA, 0x9F, 0x7C, 0xEB, 0xA4, 0x7D, 0xEC, 0x99, 0x77, 0xB7, 0x58, 0x59,
	0x68, 0x1E, 0x46, 0x57, 0x19, 0x46, 0x53, 0x15, 0x40, 0x55, 0x14, 0x3E, 0x55, 0x12, 0x3D, 0x5F,
	0x1F, 0x4B, 0x5E, 0x1D, 0x4B, 0x5E, 0x1D, 0x4C, 0x69, 0x2D, 0x59, 0x54, 0x16, 0x43, 0x58, 0x18,
	0x47, 0x71, 0x35, 0x62, 0x4F, 0x10, 0x40, 0x5F, 0x22, 0x55, 0x82, 0x4E, 0x7E, 0x83, 0x50, 0x7D,
	0x50, 0x12, 0x44, 0x70, 0x38, 0x65, 0x82, 0x4D, 0x76, 0x4A, 0x0A, 0x39, 0x6D, 0x30, 0x5A, 0x75,
	0x3B, 0x65, 0x68, 0x2F, 0x5E, 0x87, 0x55, 0x85, 0x7C, 0x45, 0x73, 0x60, 0x22, 0x4D, 0x4C, 0x0D,
	0x39, 0x54, 0x14, 0x3E, 0x54, 0x0E, 0x38, 0x59, 0x0B, 0x33, 0x6E, 0x14, 0x37, 0x8D, 0x28, 0x3F,
	0xA7, 0x38, 0x44, 0xB9, 0x44, 0x4B, 0xC2, 0x48, 0x4C, 0xC8, 0x4F, 0x50, 0xCB, 0x56, 0x54, 0xCD,
	0x56, 0x53, 0xCE, 0x57, 0x55, 0xD0, 0x5B, 0x55, 0xD1, 0x5C, 0x55, 0xD1, 0x59, 0x52, 0xD3, 0x5A,
	0x55, 0xD6, 0x60, 0x5B, 0xD8, 0x61, 0x5D, 0xDA, 0x61, 0x5B, 0xD9, 0x5E, 0x5A, 0xD9, 0x64, 0x5E,
	0xDA, 0x68, 0x61, 0xDB, 0x67, 0x5F, 0xDA, 0x6A, 0x63, 0xDA, 0x6A, 0x63, 0xDB, 0x6D, 0x66, 0xDC,
	0x6E, 0x67, 0xDC, 0x6C, 0x67, 0xDB, 0x6E, 0x66, 0xDA, 0x6F, 0x66, 0xDB, 0x70, 0x66, 0xD9, 0x6B,
	0x60, 0xD9, 0x6A, 0x60, 0xDA, 0x6C, 0x63, 0xD9, 0x6F, 0x64, 0xD9, 0x70, 0x64, 0xDA, 0x75, 0x68,
	0xDB, 0x79, 0x6B, 0xDA, 0x7D, 0x70, 0xDC, 0x83, 0x76, 0xE0, 0x89, 0x7B, 0xE1, 0x91, 0x83, 0xDE,
	0x9A, 0x8C, 0xDE, 0xA2, 0x93, 0xE0, 0xAA, 0x99, 0xDF, 0xB3, 0xA3, 0xE1, 0xBC, 0xAC, 0xE8, 0xC2,
	0xB3, 0xE9, 0xC3, 0xB7, 0xE7, 0xC5, 0xB8, 0xF0, 0xD4, 0xBD, 0xD8, 0xA9, 0x9A, 0x87, 0x32, 0x47,
	0x83, 0x30, 0x44, 0x94, 0x40, 0x54, 0x9C, 0x48, 0x5B, 0x9E, 0x50, 0x62, 0x9E, 0x51, 0x64, 0xA5,
	0x57, 0x65, 0xB0, 0x58, 0x5F, 0xB8, 0x51, 0x54, 0xB8, 0x4E, 0x52, 0xAF, 0x47, 0x4E, 0xA0, 0x3F,
	0x4D, 0x97, 0x39, 0x4D, 0xA1, 0x43, 0x51, 0xA9, 0x47, 0x4F, 0x9C, 0x37, 0x47, 0x8A, 0x2D, 0x41,
	0x8F, 0x35, 0x49, 0x98, 0x43, 0x58, 0x8C, 0x3A, 0x52, 0x80, 0x2B, 0x44, 0x7D, 0x28, 0x42, 0x74,
	0x22, 0x40, 0x80, 0x2D, 0x49, 0x9D, 0x4F, 0x64, 0xA4, 0x61, 0x72, 0x9E, 0x5A, 0x70, 0x95, 0x49,
	0x62, 0x7E, 0x2F, 0x4C, 0x6B, 0x1E, 0x3E, 0x67, 0x19, 0x3C, 0x63, 0x15, 0x38, 0x5E, 0x12, 0x38,
	0x5D, 0x17, 0x3E, 0x60, 0x1A, 0x3E, 0x5F, 0x1A, 0x41, 0x7F, 0x3F, 0x61, 0xC9, 0xA1, 0xA0, 0xE4,
	0xC7, 0xB8, 0xDE, 0xBE, 0xAD, 0xB5, 0x7A, 0x7A, 0xAF, 0x4A, 0x51, 0xDA, 0x71, 0x61, 0xE8, 0x94,
	0x72, 0xEA, 0x9C, 0x7A, 0xEA, 0x9F, 0x7B, 0xED, 0xA5, 0x7C, 0xE7, 0x94, 0x78, 0xA3, 0x4F, 0x5E,
	0x62, 0x1B, 0x47, 0x58, 0x16, 0x42, 0x57, 0x18, 0x42, 0x53, 0x13, 0x3E, 0x5A, 0x17, 0x43, 0x5E,
	0x1B, 0x48, 0x5E, 0x1A, 0x48, 0x5E, 0x1B, 0x4B, 0x62, 0x25, 0x53, 0x5A, 0x1D, 0x4C, 0x5A, 0x1D,
	0x4C, 0x7B, 0x44, 0x70, 0x51, 0x10, 0x40, 0x65, 0x2C, 0x5B, 0x7C, 0x41, 0x72, 0x8B, 0x5B, 0x86,
	0x71, 0x3C, 0x68, 0x56, 0x16, 0x46, 0x7F, 0x48, 0x73, 0x59, 0x1B, 0x4B, 0x59, 0x17, 0x43, 0x7F,
	0x44, 0x6B, 0x60, 0x24, 0x53, 0x71, 0x37, 0x67, 0x7E, 0x4A, 0x78, 0x62, 0x25, 0x52, 0x4D, 0x0A,
	0x37, 0x4E, 0x09, 0x35, 0x5D, 0x0F, 0x36, 0x70, 0x15, 0x35, 0x90, 0x26, 0x3C, 0xAD, 0x3A, 0x45,
	0xBB, 0x44, 0x4B, 0xC5, 0x4D, 0x4E, 0xC8, 0x4E, 0x4D, 0xC7, 0x4E, 0x4D, 0xCC, 0x56, 0x51, 0xCF,
	0x59, 0x53, 0xCF, 0x57, 0x54, 0xD0, 0x59, 0x53, 0xD1, 0x5B, 0x54, 0xD4, 0x5C, 0x55, 0xD6, 0x5D,
	0x58, 0xD7, 0x5D, 0x58, 0xD8, 0x5E, 0x5A, 0xD9, 0x5F, 0x5A, 0xDA, 0x62, 0x5B, 0xDA, 0x63, 0x5D,
	0xDA, 0x65, 0x5E, 0xDB, 0x66, 0x5F, 0xDA, 0x69, 0x61, 0xDA, 0x69, 0x61, 0xDB, 0x6B, 0x64, 0xDC,
	0x6C, 0x67, 0xDC, 0x6E, 0x68, 0xDC, 0x6F, 0x68, 0xDB, 0x6F, 0x68, 0xDC, 0x70, 0x68, 0xDC, 0x6E,
	0x64, 0xDA, 0x70, 0x65, 0xDA, 0x71, 0x66, 0xDA, 0x70, 0x66, 0xDB, 0x73, 0x67, 0xDC, 0x77, 0x69,
	0xDB, 0x78, 0x6B, 0xDB, 0x7C, 0x6E, 0xDD, 0x83, 0x76, 0xE0, 0x8A, 0x7A, 0xE1, 0x92, 0x7F, 0xDF,
	0x97, 0x8A, 0xDD, 0x9D, 0x8F, 0xDE, 0xA6, 0x96, 0xDF, 0xB0, 0x9F, 0xE2, 0xB9, 0xAA, 0xE7, 0xBF,
	0xAF, 0xE7, 0xC3, 0xB5, 0xE6, 0xC3, 0xB7, 0xEC, 0xCC, 0xBB, 0xE6, 0xC0, 0xAB, 0x93, 0x47, 0x59,
	0x7D, 0x27, 0x41, 0x92, 0x40, 0x54, 0x99, 0x48, 0x5D, 0x98, 0x4C, 0x65, 0xA0, 0x58, 0x67, 0xAD,
	0x60, 0x65, 0xB6, 0x57, 0x59, 0xB9, 0x50, 0x53, 0xB8, 0x4E, 0x52, 0xB4, 0x4A, 0x50, 0xAD, 0x43,
	0x4D, 0xAE, 0x47, 0x50, 0xBC, 0x51, 0x54, 0xB5, 0x4A, 0x50, 0x9D, 0x39, 0x49, 0x95, 0x3A, 0x4F,
	0x98, 0x44, 0x5B, 0x8D, 0x3D, 0x58, 0x7E, 0x2A, 0x44, 0x7B, 0x24, 0x3E, 0x7C, 0x26, 0x41, 0x80,
	0x2C, 0x48, 0x99, 0x45, 0x5B, 0xAA, 0x60, 0x6E, 0xA4, 0x61, 0x72, 0x99, 0x4F, 0x68, 0x88, 0x37,
	0x4F, 0x6D, 0x21, 0x3E, 0x63, 0x18, 0x3A, 0x64, 0x17, 0x3B, 0x60, 0x13, 0x37, 0x73, 0x1C, 0x3B,
	0x59, 0x13, 0x38, 0x5C, 0x14, 0x3B, 0x58, 0x12, 0x3E, 0x81, 0x41, 0x62, 0xD4, 0xAC, 0xA4, 0xE4,
	0xC6, 0xB6, 0xE1, 0xC1, 0xAF, 0xC5, 0x8D, 0x85, 0xB3, 0x4E, 0x54, 0xD8, 0x70, 0x61, 0xE7, 0x94,
	0x71, 0xE9, 0x9A, 0x75, 0xE9, 0x9C, 0x7B, 0xED, 0xA1, 0x7C, 0xE7, 0x91, 0x75, 0xB0, 0x5A, 0x66,
	0x69, 0x20, 0x49, 0x53, 0x10, 0x3C, 0x58, 0x14, 0x3E, 0x57, 0x16, 0x42, 0x5C, 0x1D, 0x49, 0x60,
	0x1B, 0x48, 0x68, 0x20, 0x4E, 0x71, 0x2A, 0x57, 0x62, 0x21, 0x4E, 0x5E, 0x1C, 0x4C, 0x6B, 0x31,
	0x5F, 0x7B, 0x43, 0x6D, 0x57, 0x11, 0x41, 0x72, 0x36, 0x63, 0x76, 0x3C, 0x6D, 0x7A, 0x41, 0x6E,
	0x87, 0x58, 0x80, 0x52, 0x12, 0x44, 0x74, 0x3A, 0x67, 0x6F, 0x35, 0x62, 0x59, 0x16, 0x43, 0x76,
	0x33, 0x5C, 0x68, 0x29, 0x57, 0x60, 0x1F, 0x4F, 0x7B, 0x43, 0x73, 0x84, 0x52, 0x7F, 0x66, 0x2D,
	0x5B, 0x4E, 0x03, 0x30, 0x6C, 0x12, 0x35, 0x8D, 0x24, 0x3D, 0xA7, 0x32, 0x42, 0xB6, 0x40, 0x48,
	0xBF, 0x47, 0x4C, 0xC5, 0x4D, 0x4E, 0xC7, 0x51, 0x4F, 0xC9, 0x51, 0x4F, 0xCE, 0x55, 0x50, 0xCF,
	0x59, 0x52, 0xCE, 0x58, 0x52, 0xCF, 0x58, 0x52, 0xD3, 0x5B, 0x55, 0xD6, 0x5D, 0x58, 0xD6, 0x5D,
	0x57, 0xD6, 0x5A, 0x53, 0xD8, 0x5E, 0x58, 0xD9, 0x61, 0x5B, 0xDA, 0x60, 0x5B, 0xD9, 0x60, 0x5B,
	0xDA, 0x66, 0x5E, 0xDA, 0x67, 0x62, 0xDA, 0x67, 0x60, 0xDB, 0x69, 0x62, 0xDC, 0x6C, 0x65, 0xDD,
	0x6D, 0x64, 0xDD, 0x6D, 0x66, 0xDC, 0x6D, 0x66, 0xDC, 0x6E, 0x65, 0xDD, 0x70, 0x67, 0xDD, 0x74,
	0x68, 0xDD, 0x73, 0x66, 0xDC, 0x72, 0x68, 0xDB, 0x6F, 0x65, 0xDB, 0x75, 0x68, 0xDE, 0x7A, 0x6A,
	0xDD, 0x7A, 0x6C, 0xDD, 0x7C, 0x6E, 0xDF, 0x85, 0x77, 0xDF, 0x89, 0x7A, 0xE0, 0x8C, 0x7C, 0xE0,
	0x94, 0x84, 0xDE, 0x9B, 0x8C, 0xDE, 0xA6, 0x96, 0xE0, 0xAD, 0x9C, 0xE0, 0xB6, 0xA7, 0xE5, 0xBF,
	0xAE, 0xE7, 0xC3, 0xB4, 0xE6, 0xC3, 0xB7, 0xE9, 0xC6, 0xB9, 0xF0, 0xCF, 0xB6, 0xAA, 0x6B, 0x72,
	0x78, 0x22, 0x3E, 0x8C, 0x3B, 0x4D, 0x94, 0x41, 0x57, 0x96, 0x48, 0x61, 0xA3, 0x58, 0x65, 0xB1,
	0x58, 0x5E, 0xBC, 0x59, 0x5A, 0xC0, 0x56, 0x56, 0xBC, 0x4F, 0x51, 0xBA, 0x4E, 0x50, 0xC0, 0x50,
	0x51, 0xC9, 0x59, 0x55, 0xC7, 0x57, 0x54, 0xAE, 0x45, 0x4E, 0x9A, 0x3C, 0x4D, 0x97, 0x41, 0x57,
	0x8A, 0x3A, 0x58, 0x83, 0x32, 0x50, 0x85, 0x33, 0x4A, 0x82, 0x2E, 0x47, 0x81, 0x2C, 0x45, 0x95,
	0x42, 0x57, 0xAB, 0x60, 0x6E, 0xAA, 0x68, 0x74, 0x9D, 0x55, 0x6C, 0x8B, 0x3D, 0x5B, 0x72, 0x23,
	0x42, 0x5F, 0x14, 0x38, 0x5F, 0x13, 0x37, 0x66, 0x19, 0x3C, 0x78, 0x24, 0x40, 0x97, 0x36, 0x47,
	0x58, 0x16, 0x3E, 0x5D, 0x17, 0x3E, 0x54, 0x0E, 0x39, 0x78, 0x35, 0x57, 0xCF, 0xA4, 0xA0, 0xE1,
	0xC4, 0xB5, 0xDF, 0xBD, 0xAB, 0xC4, 0x8A, 0x85, 0xB2, 0x4F, 0x56, 0xDA, 0x72, 0x62, 0xE7, 0x92,
	0x73, 0xEA, 0x9B, 0x7B, 0xEA, 0x9D, 0x7D, 0xEE, 0xA2, 0x7F, 0xE3, 0x8F, 0x74, 0x98, 0x45, 0x5B,
	0x63, 0x1C, 0x48, 0x51, 0x0E, 0x3A, 0x56, 0x12, 0x3C, 0x5A, 0x19, 0x43, 0x59, 0x1A, 0x47, 0x66,
	0x21, 0x4D, 0x6D, 0x24, 0x50, 0x73, 0x2D, 0x55, 0x66, 0x23, 0x4D, 0x65, 0x24, 0x54, 0x85, 0x53,
	0x79, 0x74, 0x36, 0x5D, 0x5A, 0x11, 0x41, 0x76, 0x36, 0x61, 0x71, 0x39, 0x66, 0x63, 0x20, 0x51,
	0x83, 0x4C, 0x76, 0x73, 0x3C, 0x68, 0x7A, 0x45, 0x70, 0x70, 0x38, 0x61, 0x4E, 0x0C, 0x3A, 0x6A,
	0x25, 0x51, 0x6A, 0x2A, 0x56, 0x55, 0x15, 0x42, 0x67, 0x27, 0x57, 0x75, 0x3A, 0x68, 0x82, 0x48,
	0x6F, 0x74, 0x26, 0x48, 0x87, 0x22, 0x3A, 0x9D, 0x2F, 0x41, 0xA9, 0x35, 0x43, 0xB9, 0x41, 0x49,
	0xC3, 0x48, 0x4D, 0xC8, 0x4F, 0x4E, 0xC9, 0x52, 0x4F, 0xCC, 0x55, 0x50, 0xCE, 0x58, 0x52, 0xCE,
	0x5A, 0x56, 0xCE, 0x59, 0x54, 0xD0, 0x5A, 0x52, 0xD3, 0x5A, 0x54, 0xD6, 0x5C, 0x57, 0xD6, 0x5E,
	0x57, 0xD7, 0x5C, 0x55, 0xD8, 0x5C, 0x56, 0xDA, 0x62, 0x5D, 0xDA, 0x61, 0x5D, 0xD9, 0x5D, 0x58,
	0xDA, 0x60, 0x5B, 0xDA, 0x64, 0x60, 0xDA, 0x67, 0x62, 0xDB, 0x68, 0x63, 0xDC, 0x6C, 0x65, 0xDC,
	0x6E, 0x65, 0xDB, 0x6C, 0x65, 0xDC, 0x6D, 0x67, 0xDD, 0x6E, 0x65, 0xDD, 0x6E, 0x64, 0xDE, 0x77,
	0x69, 0xDD, 0x75, 0x69, 0xDC, 0x74, 0x68, 0xDC, 0x75, 0x69, 0xDB, 0x76, 0x69, 0xDC, 0x79, 0x6C,
	0xDD, 0x7D, 0x6F, 0xDE, 0x7F, 0x6F, 0xDF, 0x84, 0x77, 0xE0, 0x88, 0x7E, 0xE0, 0x89, 0x7C, 0xE2,
	0x90, 0x84, 0xDE, 0x98, 0x8E, 0xDC, 0xA3, 0x94, 0xE0, 0xAC, 0x9B, 0xDF, 0xB3, 0xA2, 0xE1, 0xB9,
	0xA9, 0xE7, 0xC1, 0xB0, 0xE8, 0xC4, 0xB5, 0xE9, 0xC3, 0xB8, 0xF1, 0xD0, 0xBA, 0xC9, 0x94, 0x8E,
	0x8A, 0x3B, 0x58, 0x87, 0x37, 0x4A, 0x8D, 0x38, 0x49, 0x96, 0x43, 0x58, 0x9D, 0x4D, 0x5F, 0xB1,
	0x59, 0x5D, 0xCA, 0x62, 0x5A, 0xCA, 0x5D, 0x56, 0xC6, 0x56, 0x51, 0xC6, 0x58, 0x53, 0xD0, 0x64,
	0x5B, 0xD5, 0x64, 0x59, 0xC2, 0x51, 0x50, 0xA3, 0x3D, 0x49, 0x93, 0x36, 0x49, 0x85, 0x2F, 0x49,
	0x7B, 0x2C, 0x4D, 0x86, 0x35, 0x55, 0x8A, 0x39, 0x52, 0x83, 0x32, 0x4C, 0x8D, 0x37, 0x4E, 0xA9,
	0x53, 0x62, 0xB1, 0x6A, 0x75, 0xA7, 0x68, 0x77, 0x93, 0x47, 0x62, 0x73, 0x25, 0x45, 0x5E, 0x15,
	0x3B, 0x58, 0x0D, 0x34, 0x5E, 0x14, 0x38, 0x71, 0x23, 0x43, 0x97, 0x3A, 0x4C, 0xB0, 0x42, 0x4C
};

```

`SchedulerTests/Tests/PlatformTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include "../Profiler/Profiler.h"
#include <UnitTest++.h>
#include <MTScheduler.h>

SUITE(PlatformTests)
{
	static const intptr_t DATA_VALUE = 13;

	intptr_t g_Variable = 0;

	void MyThreadFunc(void* userData)
	{
		intptr_t data = (intptr_t)userData;

		CHECK(data == DATA_VALUE);

		g_Variable = data;
	}

	TEST(ThreadTest)
	{
		intptr_t data = DATA_VALUE;

		MT::Thread thread;
		thread.Start(32768, MyThreadFunc, (void*)data);
		thread.Join();

		CHECK(g_Variable == DATA_VALUE);
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	MT::Event *pEvent1 = nullptr;
	MT::Event *pEvent2 = nullptr;

	void MyThreadFunc2(void*)
	{
		MT::SpinSleepMilliSeconds(300);
		pEvent1->Signal();
	}

	TEST(EventTest)
	{
		MT::Event event1;
		event1.Create(MT::EventReset::MANUAL, false);
		pEvent1 = &event1;

		MT::Event event2;
		event2.Create(MT::EventReset::AUTOMATIC, false);
		pEvent2 = &event2;

		MT::Thread thread;
		thread.Start(32768, MyThreadFunc2, nullptr);

		bool res0 = event1.Wait(100);
		bool res1 = event1.Wait(1000);
		bool res2 = event1.Wait(1000);
		event1.Reset();
		bool res3 = event1.Wait(100);

		CHECK(!res0);
		CHECK(res1);
		CHECK(res2);
		CHECK(!res3);

		bool res4 = event2.Wait(100);
		CHECK(!res4);
		bool res5 = event2.Wait(100);
		CHECK(!res5);
		bool res6 = event2.Wait(100);
		CHECK(!res6);

		thread.Join();
	}



	MT::AtomicPtrBase<MT::Event> pStressEvent = { nullptr };
	MT::Atomic32Base<uint32> needExitSignal = { 0 };
	MT::Atomic32Base<uint32> needExitWait = { 0 };
	MT::Atomic32Base<uint32> needStartWork = { 0 };

	void EventStressTestSignalThreadFunc(void*)
	{ BROFILER_THREAD("SignalThread");

		while (needStartWork.Load() == 0)
		{ BROFILER_CATEGORY("Signal prepare", 0xFFFF00FF);
			MT::SpinSleepMicroSeconds(300);
		}
	
		while (needExitSignal.Load() == 0)
		{ BROFILER_CATEGORY("Signal Loop", 0xFF556B2F);
			MT::SpinSleepMicroSeconds(300);
			MT::Event * pEvent = pStressEvent.Load();
			pEvent->Signal();
		}
	}

	void EventStressTestWaitThreadFunc(void*)
	{ BROFILER_THREAD("WaitThread");

		while (needStartWork.Load() == 0)
		{ BROFILER_CATEGORY("Wait prepare", 0xFFFF00FF);
			MT::SpinSleepMicroSeconds(300);
		}

		while (needExitWait.Load() == 0)
		{ BROFILER_CATEGORY("Wait Loop", 0xFFF0F8FF);
			MT::Event* pEvent = pStressEvent.Load();
			bool res = pEvent->Wait(1000);
			MT::SpinSleepMicroSeconds(300);
			CHECK(res == true);
		}
	}


	


	TEST(EventStressTest)
	{
#if defined(MT_ENABLE_LEGACY_WINDOWSXP_SUPPORT) && defined(MT_PLATFORM_WINDOWS)
		printf("Kernel mode events\n");
#else
		printf("User mode events\n");
#endif

	
		MT::Event stressEvent;
		MT::Thread signalThreads[3];
		MT::Thread waitThreads[3];
		needStartWork.Store(0);

		{ 
			BROFILER_NEXT_FRAME();
			stressEvent.Create(MT::EventReset::AUTOMATIC, false);
			pStressEvent.Store( &stressEvent );

			needExitSignal.Store(0);
			needExitWait.Store(0);

			for(uint32 i = 0; i < MT_ARRAY_SIZE(signalThreads); i++)
			{
				signalThreads[i].Start(32768, EventStressTestSignalThreadFunc, nullptr);
			}

			for(uint32 i = 0; i < MT_ARRAY_SIZE(waitThreads); i++)
			{
				waitThreads[i].Start(32768, EventStressTestWaitThreadFunc, nullptr);
			}

			printf("Signal threads num = %d\n", (uint32)MT_ARRAY_SIZE(signalThreads));
			printf("Wait threads num = %d\n", (uint32)MT_ARRAY_SIZE(waitThreads));
		}


#if defined(MT_INSTRUMENTED_BUILD) && defined(MT_ENABLE_BROFILER_SUPPORT)
		BROFILER_FRAME("EventStressTest");
		{
			printf("Waiting for 'Brofiler' connection.\n");
			for(;;)
			{
				BROFILER_NEXT_FRAME();
				MT::Thread::Sleep(150);
				if (Brofiler::IsActive())
				{
					break;
				}
			}
		}
#endif
		needStartWork.Store(1);

		const int iterationsCount = 5000;

		int64 startTimeSignal = MT::GetTimeMicroSeconds();
		{ BROFILER_NEXT_FRAME();
		  BROFILER_CATEGORY("Signal Loop", 0xFF556B2F);
			for(int i = 0; i < iterationsCount; i++)
			{
				stressEvent.Signal();
			}
		}
		int64 endTimeSignal = MT::GetTimeMicroSeconds();


		int64 startTimeWait = MT::GetTimeMicroSeconds();
		{ BROFILER_NEXT_FRAME();
		  BROFILER_CATEGORY("Wait Loop", 0xFFF0F8FF);
			for(int i = 0; i < iterationsCount; i++)
			{
				bool res = stressEvent.Wait(1000);
				CHECK(res == true);
			}
		}
		int64 endTimeWait = MT::GetTimeMicroSeconds();

		double microSecondsPerWait = (double)((endTimeWait - startTimeWait) / (double)iterationsCount);
		double microSecondsPerSignal = (double)((endTimeSignal - startTimeSignal) / (double)iterationsCount);

		printf("microseconds per signal = %3.2f, iterations = %d\n", microSecondsPerSignal, iterationsCount);
		printf("microseconds per wait = %3.2f, iterations = %d\n", microSecondsPerWait, iterationsCount);

#if defined(MT_INSTRUMENTED_BUILD) && defined(MT_ENABLE_BROFILER_SUPPORT)
		{
			printf("Waiting for the 'Brofiler' to be disconnected\n");
			for(;;)
			{
				BROFILER_NEXT_FRAME();
				MT::Thread::Sleep(150);
				if (!Brofiler::IsActive())
				{
					break;
				}
			}
		}

		printf("Done\n");
#endif

		needExitWait.Store(1);
		for(uint32 i = 0; i < MT_ARRAY_SIZE(waitThreads); i++)
		{
			waitThreads[i].Join();
		}

		MT::Thread::Sleep(100);

		needExitSignal.Store(1);
		for(uint32 i = 0; i < MT_ARRAY_SIZE(signalThreads); i++)
		{
			signalThreads[i].Join();
		}

		bool res = stressEvent.Wait(300);
		CHECK(res == true);

		res = stressEvent.Wait(300);
		CHECK(res == false);

	}


	TEST(SleepTest)
	{

		MT::Timer timer;

		MT::SpinSleepMilliSeconds(100);

		CHECK( timer.GetPastMilliSeconds() >= 100 );
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`SchedulerTests/Tests/PriorityTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>

/*

Check that every worker thread executed tasks in specified priority. HIGH/NORMAL/LOW

*/
SUITE(PriorityTests)
{
	static const uint32 TASK_COUNT = 512;

	MT::Atomic32<int32> switchCountToNormal;
	MT::Atomic32<int32> switchCountToLow;


	struct ThreadState
	{
		uint32 taskPrio;
		uint32 highProcessed;
		uint32 normalProcessed;
		uint32 lowProcessed;
		byte cacheLine[64];

		ThreadState()
		{
			Reset();
		}

		void Reset()
		{
			taskPrio = 0;
			highProcessed = 0;
			normalProcessed = 0;
			lowProcessed = 0;
		}
	};

	ThreadState workerState[64];

	struct TaskHigh
	{
		MT_DECLARE_TASK(TaskHigh, MT::StackRequirements::STANDARD, MT::TaskPriority::HIGH, MT::Color::Blue);

		uint32 id;

		TaskHigh(uint32 _id)
			: id(_id)
		{
		}

		void Do(MT::FiberContext& ctx)
		{
			uint32 workerIndex = ctx.GetThreadContext()->workerIndex;
			MT_ASSERT(workerIndex < MT_ARRAY_SIZE(workerState), "Invalid worker index");
			ThreadState& state = workerState[workerIndex];

			CHECK_EQUAL((uint32)0, state.normalProcessed);
			CHECK_EQUAL((uint32)0, state.lowProcessed);

			state.highProcessed++;

			// Check we in right state (executing HIGH priority tasks)
			CHECK_EQUAL((uint32)0, state.taskPrio);

		}
	};


	struct TaskNormal
	{
		MT_DECLARE_TASK(TaskNormal, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		uint32 id;

		TaskNormal(uint32 _id)
			: id(_id)
		{
		}

		void Do(MT::FiberContext& ctx)
		{
			uint32 workerIndex = ctx.GetThreadContext()->workerIndex;
			MT_ASSERT(workerIndex < MT_ARRAY_SIZE(workerState), "Invalid worker index");
			ThreadState& state = workerState[workerIndex];

			CHECK_EQUAL((uint32)0, state.lowProcessed);

			state.normalProcessed++;

			//if state is set to HIGH tasks, change state to NORMAL tasks
			if (state.taskPrio == 0)
			{
				state.taskPrio = 1;
				switchCountToNormal.IncFetch();
			}

			// Check we in right state (executing NORMAL priority tasks)
			CHECK_EQUAL((uint32)1, state.taskPrio);
		}
	};

	struct TaskLow
	{
		MT_DECLARE_TASK(TaskLow, MT::StackRequirements::STANDARD, MT::TaskPriority::LOW, MT::Color::Blue);

		uint32 id;

		TaskLow(uint32 _id)
			: id(_id)
		{
		}


		void Do(MT::FiberContext& ctx)
		{
			uint32 workerIndex = ctx.GetThreadContext()->workerIndex;
			MT_ASSERT(workerIndex < MT_ARRAY_SIZE(workerState), "Invalid worker index");
			ThreadState& state = workerState[workerIndex];

			state.lowProcessed++;

			//if state is set to NORMAL tasks, change state to LOW tasks
			if (state.taskPrio == 1)
			{
				state.taskPrio = 2;
				switchCountToLow.IncFetch();
			}

			// Check we in right state (executing LOW priority tasks)
			CHECK_EQUAL((uint32)2, state.taskPrio);
		}
	};




	TEST(SimplePriorityTest)
	{
		MT::TaskPool<TaskLow, TASK_COUNT> lowPriorityTasksPool;
		MT::TaskPool<TaskNormal, TASK_COUNT> normalPriorityTasksPool;
		MT::TaskPool<TaskHigh, TASK_COUNT> highPriorityTasksPool;

		// Disable task stealing (for testing purposes only)
#ifdef MT_INSTRUMENTED_BUILD
		MT::TaskScheduler scheduler(0, nullptr, nullptr, MT::TaskStealingMode::DISABLED);
#else
		MT::TaskScheduler scheduler(0, nullptr, MT::TaskStealingMode::DISABLED);
#endif

		// Use task handles to add multiple tasks with different priorities in one RunAsync call
		MT::TaskHandle taskHandles[TASK_COUNT*3];

		uint32 index = 0;
		for(uint32 i = 0; i < TASK_COUNT; i++)
		{
			taskHandles[index] = lowPriorityTasksPool.Alloc(TaskLow(i));
			index++;
		}

		for(uint32 i = 0; i < TASK_COUNT; i++)
		{
			taskHandles[index] = highPriorityTasksPool.Alloc(TaskHigh(i));
			index++;
		}

		for(uint32 i = 0; i < TASK_COUNT; i++)
		{
			taskHandles[index] = normalPriorityTasksPool.Alloc(TaskNormal(i));
			index++;
		}

		switchCountToNormal.Store(0);
		switchCountToLow.Store(0);

		for(uint32 i = 0; i < MT_ARRAY_SIZE(workerState); i++)
		{
			workerState[i].Reset();
		}

		scheduler.RunAsync(MT::TaskGroup::Default(), &taskHandles[0], MT_ARRAY_SIZE(taskHandles));
		CHECK(scheduler.WaitAll(2000));

		int32 workersCount = scheduler.GetWorkersCount();
		float minTasksExecuted  = (float)TASK_COUNT / (float)workersCount;
		minTasksExecuted *= 0.95f;
		uint32 minTasksExecutedThreshold = (uint32)minTasksExecuted;

		uint32 lowProcessedTotal = 0;
		uint32 normalProcessedTotal = 0;
		uint32 highProcessedTotal = 0;

		for(int32 j = 0; j < workersCount; j++)
		{
			lowProcessedTotal += workerState[j].lowProcessed;
			normalProcessedTotal += workerState[j].normalProcessed;
			highProcessedTotal += workerState[j].highProcessed;
		}

		CHECK_EQUAL(TASK_COUNT, lowProcessedTotal);
		CHECK_EQUAL(TASK_COUNT, normalProcessedTotal);
		CHECK_EQUAL(TASK_COUNT, highProcessedTotal);

		for(int32 j = 0; j < workersCount; j++)
		{
			printf("worker #%d\n", j);

			CHECK_EQUAL((uint32)2, workerState[j].taskPrio);
			CHECK(workerState[j].lowProcessed >= minTasksExecutedThreshold);
			CHECK(workerState[j].normalProcessed >= minTasksExecutedThreshold);
			CHECK(workerState[j].highProcessed >= minTasksExecutedThreshold);

			printf("   low : %d\n", workerState[j].lowProcessed);
			printf("   normal : %d\n", workerState[j].normalProcessed);
			printf("   high : %d\n", workerState[j].highProcessed);
		}

		//
		// Every worker thread can't change state more than once.
		//
		CHECK_EQUAL(workersCount, switchCountToNormal.Load());
		CHECK_EQUAL(workersCount, switchCountToLow.Load());

		
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}


```

`SchedulerTests/Tests/ScopesTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>


SUITE(ScopesTests)
{


struct AssetStackEntry : public MT::ScopeStackEntry
{
	const char* assetName;

	AssetStackEntry(int32 parentIndex, int32 descIndex, const char* _assetName)
		: MT::ScopeStackEntry(parentIndex, descIndex)
		, assetName(_assetName)
	{
	}
};

//current thread scopes stack (unique per thread)
static mt_thread_local MT::StrongScopeStack<AssetStackEntry, 128>* threadScopesStack = nullptr;

//global scope descriptors storage
static MT::PersistentScopeDescriptorStorage<MT::ScopeDesc, 128>* globalScopesStorage = nullptr;

const char* assetName1 = "some_resource_name.asset";
const char* assetName2 = "some_another_name.asset";

void MacroSyntaxCheckerFunction()
{
	int32 descId = MT::invalidStackId;

	//declare scope descriptor
	DECLARE_SCOPE_DESCRIPTOR("test", globalScopesStorage, descId);

	//push to stack
	SCOPE_STACK_PUSH1(descId, assetName1, threadScopesStack);

	AssetStackEntry* stackTop = SCOPE_STACK_TOP(threadScopesStack);
	CHECK(stackTop != nullptr);
	int32 parentStackId = stackTop->GetParentId();
	CHECK(parentStackId == MT::invalidStackId);

	{
		int32 innerDescId = MT::invalidStackId;

		DECLARE_SCOPE_DESCRIPTOR("test2", globalScopesStorage, innerDescId);
		SCOPE_STACK_PUSH1(innerDescId, assetName2, threadScopesStack);

		AssetStackEntry* assetStackEntry = SCOPE_STACK_TOP(threadScopesStack);

		CHECK(assetStackEntry->assetName == assetName2);

		assetStackEntry = SCOPE_STACK_GET_PARENT(assetStackEntry, threadScopesStack);
		CHECK(assetStackEntry->assetName == assetName1);

		SCOPE_STACK_POP(threadScopesStack);
	}

	//pop from stack
	SCOPE_STACK_POP(threadScopesStack);
}


TEST(MacroSytnaxCheck)
{
	globalScopesStorage = new MT::PersistentScopeDescriptorStorage<MT::ScopeDesc, 128>();
	threadScopesStack = new MT::StrongScopeStack<AssetStackEntry, 128>();

	for(int i = 0; i < 16; i++)
	{
		MacroSyntaxCheckerFunction();
	}

	delete globalScopesStorage;
	globalScopesStorage = nullptr;

	delete threadScopesStack;
	threadScopesStack = nullptr;
}


TEST(WeakStackTest)
{
	MT::WeakScopeStack<MT::ScopeStackEntry, 64> weakStack;
	
	//new stack must be empty
	int parentId = weakStack.Top();
	CHECK(parentId == MT::invalidStackId);

	MT::ScopeStackEntry* pInstance = weakStack.Push(parentId, MT::invalidStorageId);
	CHECK(pInstance != nullptr);

	//check instance data
	CHECK(parentId == pInstance->GetParentId());
	CHECK(MT::invalidStorageId == pInstance->GetDescriptionId());

	// check updated stack top
	int stackTopId = weakStack.Top();
	CHECK(stackTopId != MT::invalidStackId);
	CHECK(weakStack.Get(stackTopId) == pInstance);

	int32 testStorageId = 3;

	MT::ScopeStackEntry* pInstance2 = weakStack.Push(stackTopId, testStorageId);

	CHECK(pInstance2 != pInstance);
	CHECK(stackTopId == pInstance2->GetParentId());
	CHECK(testStorageId == pInstance2->GetDescriptionId());

	int stackTopId2 = weakStack.Top();
	CHECK(stackTopId2 != MT::invalidStackId);
	CHECK(stackTopId2 != stackTopId);
	CHECK(weakStack.Get(stackTopId2) == pInstance2);

	weakStack.Pop();

	int _stackTopId = weakStack.Top();
	CHECK(stackTopId == _stackTopId);

	weakStack.Pop();
	CHECK(weakStack.Top() == MT::invalidStackId);
}

TEST(StrongStackTest)
{
	MT::StrongScopeStack<MT::ScopeStackEntry, 64> strongStack;

	//new stack must be empty
	int parentId = strongStack.Top();
	CHECK(parentId == MT::invalidStackId);

	MT::ScopeStackEntry* pInstance = strongStack.Push(parentId, MT::invalidStorageId);
	CHECK(pInstance != nullptr);

	//check instance data
	CHECK(parentId == pInstance->GetParentId());
	CHECK(MT::invalidStorageId == pInstance->GetDescriptionId());

	// check updated stack top
	int stackTopId = strongStack.Top();
	CHECK(stackTopId != MT::invalidStackId);
	CHECK(strongStack.Get(stackTopId) == pInstance);

	int32 testStorageId = 3;

	MT::ScopeStackEntry* pInstance2 = strongStack.Push(stackTopId, testStorageId);

	CHECK(pInstance2 != pInstance);
	CHECK(stackTopId == pInstance2->GetParentId());
	CHECK(testStorageId == pInstance2->GetDescriptionId());

	int stackTopId2 = strongStack.Top();
	CHECK(stackTopId2 != MT::invalidStackId);
	CHECK(stackTopId2 != stackTopId);
	CHECK(strongStack.Get(stackTopId2) == pInstance2);

	strongStack.Pop();

	int _stackTopId = strongStack.Top();
	CHECK(stackTopId == _stackTopId);

	strongStack.Pop();
	CHECK(strongStack.Top() == MT::invalidStackId);

	// strong stack is means that we can still use stack pointers (and Id's) after pop
	CHECK(strongStack.Get(stackTopId) == pInstance);
	CHECK(strongStack.Get(stackTopId2) == pInstance2);

	CHECK(stackTopId == pInstance2->GetParentId());
	CHECK(testStorageId == pInstance2->GetDescriptionId());

	CHECK(parentId == pInstance->GetParentId());
	CHECK(MT::invalidStorageId == pInstance->GetDescriptionId());


	MT::ScopeStackEntry* pInstance3 = strongStack.Push(parentId, MT::invalidStorageId);
	CHECK(pInstance3 != nullptr);

	// strong stack can't reuse memory
	// because it ensures that the memory is always accessible, even after popping from stack
	CHECK(pInstance3 != pInstance);


}

TEST(PersistentStorageTest)
{
	MT::PersistentScopeDescriptorStorage<MT::ScopeDesc, 128> persistentStorage;

	const char* srcFile = __FILE__;
	int32 srcLine = __LINE__;
	const char* scopeName1 = "TestScope1";
	const char* scopeName2 = "TestScope2";

	int32 id1 = persistentStorage.Alloc(srcFile, srcLine, scopeName1);
	CHECK(id1 != MT::invalidStorageId);

	int32 id2 = persistentStorage.Alloc(srcFile, srcLine, scopeName2);
	CHECK(id2 != MT::invalidStorageId);
	
	MT::ScopeDesc* desc1 = persistentStorage.Get(id1);
	CHECK(desc1 != nullptr);

	CHECK(desc1->GetSourceFile() == srcFile);
	CHECK(desc1->GetSourceLine() == srcLine);
	CHECK(desc1->GetName() == scopeName1);

	MT::ScopeDesc* desc2 = persistentStorage.Get(id2);
	CHECK(desc2 != nullptr);

	CHECK(desc2->GetSourceFile() == srcFile);
	CHECK(desc2->GetSourceLine() == srcLine);
	CHECK(desc2->GetName() == scopeName2);
}



TEST(ComplexStressTest)
{
	//TODO
}

}

```

`SchedulerTests/Tests/SimpleTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>
#include <MTStaticVector.h>

SUITE(SimpleTests)
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct SimpleTask
{
	MT_DECLARE_TASK(SimpleTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	static const int sourceData = 0xFF33FF;
	int resultData;

	SimpleTask() : resultData(0) {}

	void Do(MT::FiberContext&)
	{
		resultData = sourceData;
	}

	int GetSourceData()
	{
		return sourceData;
	}
};

// Checks one simple task
TEST(RunOneSimpleTask)
{
	MT::TaskScheduler scheduler;

	SimpleTask task;
	scheduler.RunAsync(MT::TaskGroup::Default(), &task, 1);

	CHECK(scheduler.WaitAll(1000));
	CHECK_EQUAL(task.GetSourceData(), task.resultData);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ALotOfTasks
{
	MT_DECLARE_TASK(ALotOfTasks, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	MT::Atomic32<int32>* counter;

	void Do(MT::FiberContext&)
	{
		counter->IncFetch();
		MT::SpinSleepMilliSeconds(1);
	}
};

// Checks one simple task
TEST(ALotOfTasks)
{
	MT::TaskScheduler scheduler;

	MT::Atomic32<int32> counter;

	static const int TASK_COUNT = 1000;

	ALotOfTasks tasks[TASK_COUNT];

	for (size_t i = 0; i < MT_ARRAY_SIZE(tasks); ++i)
		tasks[i].counter = &counter;

	scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));

	int timeout = (TASK_COUNT / scheduler.GetWorkersCount()) * 2000;

	CHECK(scheduler.WaitGroup(MT::TaskGroup::Default(), timeout));
	CHECK_EQUAL(TASK_COUNT, counter.Load());
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


struct WorkerThreadState
{
	uint32 counterPhase0;
	uint32 counterPhase1;

	WorkerThreadState()
	{
		Reset();
	}

	void Reset()
	{
		counterPhase0 = 0;
		counterPhase1 = 0;
	}
};


WorkerThreadState workerStates[64];

uint32 TASK_COUNT_PER_WORKER = 0;

MT::Atomic32<uint32> finishedTaskCount;

struct YieldTask
{
	MT::Atomic32<uint32> counter;

	MT_DECLARE_TASK(YieldTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	YieldTask()
	{
		counter.Store(0);
	}


	 volatile WorkerThreadState* GetWorkerState( volatile uint32 workerIndex) volatile
	{
		MT_ASSERT(workerIndex < MT_ARRAY_SIZE(workerStates), "Invalid worker index");
		volatile WorkerThreadState& state = workerStates[workerIndex];
		return &state;
	}

	void Do(MT::FiberContext& context)
	{
		volatile WorkerThreadState* state0 = GetWorkerState( context.GetThreadContext()->workerIndex );

		// phase 0
		CHECK_EQUAL((uint32)1, counter.IncFetch());
		state0->counterPhase0++;
		context.Yield();

		// worker index can be changed after yield, get actual index
		volatile WorkerThreadState* state1 = GetWorkerState( context.GetThreadContext()->workerIndex );

		//I check that all the tasks (on this worker) have passed phase0 before executing phase1
		CHECK_EQUAL(TASK_COUNT_PER_WORKER, state1->counterPhase0);

		// phase 1
		CHECK_EQUAL((uint32)2, counter.IncFetch());
		state1->counterPhase1++;

		finishedTaskCount.IncFetch();
	}
};


TEST(YieldTasks)
{
	// Disable task stealing (for testing purposes only)
#ifdef MT_INSTRUMENTED_BUILD
	MT::TaskScheduler scheduler(0, nullptr, nullptr, MT::TaskStealingMode::DISABLED);
#else
	MT::TaskScheduler scheduler(0, nullptr, MT::TaskStealingMode::DISABLED);
#endif

	finishedTaskCount.Store(0);

	int32 workersCount = scheduler.GetWorkersCount();
	TASK_COUNT_PER_WORKER = workersCount * 4;
	int32 taskCount = workersCount * TASK_COUNT_PER_WORKER;

	MT::HardwareFullMemoryBarrier();

	MT::StaticVector<YieldTask, 512> tasks;
	for(int32 i = 0; i < taskCount; i++)
	{
		tasks.PushBack(YieldTask());
	}

	for(int32 i = 0; i < workersCount; i++)
	{
		WorkerThreadState& state = workerStates[i];
		state.Reset();
	}


	scheduler.RunAsync(MT::TaskGroup::Default(), tasks.Begin(), (uint32)tasks.Size());

	CHECK(scheduler.WaitGroup(MT::TaskGroup::Default(), 10000));

	for(int32 i = 0; i < workersCount; i++)
	{
		WorkerThreadState& state = workerStates[i];

		CHECK_EQUAL(TASK_COUNT_PER_WORKER, state.counterPhase0);
		CHECK_EQUAL(TASK_COUNT_PER_WORKER, state.counterPhase1);
	}

	CHECK_EQUAL(taskCount, (int32)finishedTaskCount.Load());

	printf("Yield test: %d tasks finished, used %d workers\n", taskCount, workersCount);

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`SchedulerTests/Tests/StackSizeTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>

SUITE(StackSizeTests)
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct StandartStackSizeTask
{
	MT_DECLARE_TASK(StandartStackSizeTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	void Do(MT::FiberContext&)
	{
		//byte stackData[28000];

		// Looks like OSX ASAN took too many stack space
		byte stackData[20000]; 
		for (uint32 i = 0; i < MT_ARRAY_SIZE(stackData); i++)
		{
			stackData[i] = 0x0D;
		}
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ExtendedStackSizeTask
{
	MT_DECLARE_TASK(ExtendedStackSizeTask, MT::StackRequirements::EXTENDED, MT::TaskPriority::NORMAL, MT::Color::Red);

	void Do(MT::FiberContext&)
	{
		byte stackData[262144];
		for (uint32 i = 0; i < MT_ARRAY_SIZE(stackData); i++)
		{
			stackData[i] = 0x0D;
		}
	}

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST(RunStandartTasks)
{
	MT::TaskScheduler scheduler;

	StandartStackSizeTask tasks[100];
	scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));
	CHECK(scheduler.WaitAll(1000));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST(RunExtendedTasks)
{
	MT::TaskScheduler scheduler;

	ExtendedStackSizeTask tasks[100];
	scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));
	CHECK(scheduler.WaitAll(1000));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST(RunMixedTasks)
{
	MT::TaskScheduler scheduler;

	MT::TaskPool<ExtendedStackSizeTask, 64> extendedTaskPool;
	MT::TaskPool<StandartStackSizeTask, 64> standardTaskPool;

	MT::TaskHandle taskHandles[100];
	for (size_t i = 0; i < MT_ARRAY_SIZE(taskHandles); ++i)
	{
		MT::TaskHandle handle;

		if (i & 1)
		{
			handle = extendedTaskPool.Alloc(ExtendedStackSizeTask());
		} else
		{
			handle = standardTaskPool.Alloc(StandartStackSizeTask());
		}
		taskHandles[i] = handle;
	}

	scheduler.RunAsync(MT::TaskGroup::Default(), &taskHandles[0], MT_ARRAY_SIZE(taskHandles));
	CHECK(scheduler.WaitAll(1000));
}



}

```

`SchedulerTests/Tests/SubtasksTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>

#include "../Profiler/Profiler.h"


#ifdef MT_THREAD_SANITIZER
	#define MT_DEFAULT_WAIT_TIME (500000)
	#define MT_SUBTASK_QUEUE_DEEP (3)
	#define MT_ITERATIONS_COUNT (10)
#else
	#define MT_DEFAULT_WAIT_TIME (5000)
	#define MT_SUBTASK_QUEUE_DEEP (12)
	#define MT_ITERATIONS_COUNT (100000)
#endif

SUITE(SubtasksTests)
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<size_t N>
struct DeepSubtaskQueue
{
	MT_DECLARE_TASK(DeepSubtaskQueue<N>, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	int result;

	DeepSubtaskQueue() : result(0) {}

	void Do(MT::FiberContext& context)
	{
		DeepSubtaskQueue<N - 1> taskNm1;
		DeepSubtaskQueue<N - 2> taskNm2;

		context.RunSubtasksAndYield(MT::TaskGroup::Default(), &taskNm1, 1);
		context.RunSubtasksAndYield(MT::TaskGroup::Default(), &taskNm2, 1);

		result = taskNm2.result + taskNm1.result;
	}
};

template<>
struct DeepSubtaskQueue<0>
{
	MT_DECLARE_TASK(DeepSubtaskQueue<0>, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	int result;
	void Do(MT::FiberContext&)
	{
		result = 0;
	}
};


template<>
struct DeepSubtaskQueue<1>
{
	MT_DECLARE_TASK(DeepSubtaskQueue<1>, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	int result;
	void Do(MT::FiberContext&)
	{
		result = 1;
	}
};


//
TEST(DeepSubtaskQueue)
{
	MT::TaskScheduler scheduler;

	DeepSubtaskQueue<MT_SUBTASK_QUEUE_DEEP> task;
	scheduler.RunAsync(MT::TaskGroup::Default(), &task, 1);

	CHECK(scheduler.WaitAll(MT_DEFAULT_WAIT_TIME));
	CHECK_EQUAL(task.result, 144);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static MT::TaskGroup sourceGroup;
static MT::TaskGroup resultGroup;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct GroupSubtask
{
	MT_DECLARE_TASK(GroupSubtask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	void Do(MT::FiberContext& context)
	{
		resultGroup = context.currentGroup;
	}
};

struct GroupTask
{
	MT_DECLARE_TASK(GroupTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	void Do(MT::FiberContext& context)
	{
		GroupSubtask task;
		context.RunSubtasksAndYield(sourceGroup, &task, 1);
	}
};

struct TaskWithManySubtasks
{
	MT_DECLARE_TASK(TaskWithManySubtasks, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	void Do(MT::FiberContext& context)
	{
		GroupTask task;
		for (int i = 0; i < 2; ++i)
		{
			context.RunSubtasksAndYield(MT::TaskGroup::Default(), &task, 1);
			MT::SpinSleepMilliSeconds(1);
		}
	}

};

//
TEST(SubtaskGroup)
{
	MT::TaskScheduler scheduler;

	sourceGroup = scheduler.CreateGroup();

	GroupTask task;
	scheduler.RunAsync(sourceGroup, &task, 1);

	CHECK(scheduler.WaitAll(MT_DEFAULT_WAIT_TIME));

	CHECK_EQUAL(sourceGroup.GetValidIndex(), resultGroup.GetValidIndex());
}

// Checks task with multiple subtasks
TEST(OneTaskManySubtasks)
{
	MT::TaskScheduler scheduler;

	sourceGroup = scheduler.CreateGroup();

	TaskWithManySubtasks task;
	scheduler.RunAsync(MT::TaskGroup::Default(), &task, 1);
	CHECK(scheduler.WaitAll(MT_DEFAULT_WAIT_TIME));
}

// Checks many simple task with subtasks
TEST(ManyTasksOneSubtask)
{
#ifdef MT_INSTRUMENTED_BUILD
	MT::TaskScheduler scheduler(0, nullptr, GetProfiler());
#else
	MT::TaskScheduler scheduler;
#endif

	bool waitAllOK = true;

	sourceGroup = scheduler.CreateGroup();

	for (int i = 0; i < MT_ITERATIONS_COUNT; ++i)
	{
		GroupTask group;
		scheduler.RunAsync(sourceGroup, &group, 1);
		//if (!scheduler.WaitAll(MT_DEFAULT_WAIT_TIME))
		if (!scheduler.WaitGroup(sourceGroup, MT_DEFAULT_WAIT_TIME))
		{
			printf("Timeout: Failed iteration %d\n", i);
			waitAllOK = false;
			break;
		}
	}


	CHECK(waitAllOK);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct TaskSubtaskCombo_Sum1
{
	MT_DECLARE_TASK(TaskSubtaskCombo_Sum1, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	MT::Atomic32<int32>* data;

	void Do(MT::FiberContext&)
	{
		data->IncFetch();
	}
};

struct TaskSubtaskCombo_Sum4
{
	MT_DECLARE_TASK(TaskSubtaskCombo_Sum4, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	MT::Atomic32<int32>* data;

	TaskSubtaskCombo_Sum1 tasks[2];

	void Do(MT::FiberContext& context)
	{
		tasks[0].data = data;
		tasks[1].data = data;

		context.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));
		context.RunSubtasksAndYield(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));
	}
};

struct TaskSubtaskCombo_Sum16
{
	MT_DECLARE_TASK(TaskSubtaskCombo_Sum16, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

	MT::Atomic32<int32>* data;

	TaskSubtaskCombo_Sum4 tasks[2];

	void Do(MT::FiberContext& context)
	{
		tasks[0].data = data;
		tasks[1].data = data;

		context.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));
		context.RunSubtasksAndYield(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));
	}
};

MT::Atomic32<int32> sum;

//
TEST(TaskSubtaskCombo)
{
	sum.Store(0);

	MT::TaskScheduler scheduler;

	TaskSubtaskCombo_Sum16 task[16];
	for (int i = 0; i < 16; ++i)
	{
		task[i].data = &sum;
		scheduler.RunAsync(MT::TaskGroup::Default(), &task[i], 1);
	}

	CHECK(scheduler.WaitAll(MT_DEFAULT_WAIT_TIME));

	CHECK_EQUAL(sum.Load(), 256);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`SchedulerTests/Tests/Tests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Tests::RunAll()
{
	return UnitTest::RunAllTests();
}

```

`SchedulerTests/Tests/Tests.h`:

```h
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#pragma once

namespace Tests
{
	int RunAll();
}
```

`SchedulerTests/Tests/WaitTests.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#include "Tests.h"
#include <UnitTest++.h>
#include <MTScheduler.h>

SUITE(WaitTests)
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace SimpleWaitFromSubtask
{
	MT::Atomic32<int32> subTaskCount;
	MT::Atomic32<int32> taskCount;

	MT::TaskGroup testGroup;

	struct Subtask
	{
		MT_DECLARE_TASK(Subtask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		void Do(MT::FiberContext&)
		{
			MT::SpinSleepMilliSeconds(2);
			subTaskCount.IncFetch();
		}
	};


	struct Task
	{
		MT_DECLARE_TASK(Task, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		void Do(MT::FiberContext& ctx)
		{
			Subtask tasks[2];
			ctx.RunSubtasksAndYield(testGroup, &tasks[0], MT_ARRAY_SIZE(tasks));

			taskCount.IncFetch();

		}
	};


	// Checks one simple task
	TEST(RunOneSimpleWaitTask)
	{
		taskCount.Store(0);
		subTaskCount.Store(0);

		MT::TaskScheduler scheduler;

		testGroup = scheduler.CreateGroup();

		Task tasks[16];
		scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));

		CHECK(scheduler.WaitAll(2000));

		int subTaskCountFinisehd = subTaskCount.Load();
		CHECK_EQUAL(MT_ARRAY_SIZE(tasks) * 2, (size_t)subTaskCountFinisehd);

		int taskCountFinished = taskCount.Load();
		CHECK_EQUAL(MT_ARRAY_SIZE(tasks), (size_t)taskCountFinished);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	struct LongTask
	{
		MT_DECLARE_TASK(LongTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		void Do(MT::FiberContext&)
		{
			MT::Thread::Sleep(1);
		}
	};

	TEST(TimeoutWaitAllTest)
	{
		MT::TaskScheduler scheduler;

		LongTask tasks[4000];
		scheduler.RunAsync(MT::TaskGroup::Default(), &tasks[0], MT_ARRAY_SIZE(tasks));

		int64 startTime = MT::GetTimeMicroSeconds();

		CHECK_EQUAL(false, scheduler.WaitAll(33));

		int64 endTime = MT::GetTimeMicroSeconds();
		int32 waitTime = (int32)(endTime - startTime);
		printf("WaitAll(33) = %3.2f ms\n", waitTime / 1000.0f);
	}

	TEST(TimeoutWaitGroupTest)
	{
		MT::TaskScheduler scheduler;

		MT::TaskGroup myGroup = scheduler.CreateGroup();

		LongTask tasks[4000];
		scheduler.RunAsync(myGroup, &tasks[0], MT_ARRAY_SIZE(tasks));

		int64 startTime = MT::GetTimeMicroSeconds();

		CHECK_EQUAL(false, scheduler.WaitGroup(myGroup, 33));

		int64 endTime = MT::GetTimeMicroSeconds();
		int32 waitTime = (int32)(endTime - startTime);
		printf("WaitGroup(33) = %3.2f ms\n", waitTime / 1000.0f);
	}


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	MT::Atomic32<uint32> finishedTaskCount;

	struct SecondaryTask
	{
		MT_DECLARE_TASK(SecondaryTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		void Do(MT::FiberContext&)
		{
			MT::SpinSleepMicroSeconds(20);
			finishedTaskCount.IncFetch();
		}
	};


	struct PrimaryTask
	{
		MT::TaskGroup secondaryGroup;

		MT_DECLARE_TASK(PrimaryTask, MT::StackRequirements::STANDARD, MT::TaskPriority::NORMAL, MT::Color::Blue);

		PrimaryTask(MT::TaskGroup _secondaryGroup)
			: secondaryGroup(_secondaryGroup)
		{
		}

		void Do(MT::FiberContext& ctx)
		{
			SecondaryTask tasks[64];
			ctx.RunAsync(secondaryGroup, &tasks[0], MT_ARRAY_SIZE(tasks));

			//CHECK(ctx.WaitGroup(secondaryGroup, 10000));

			finishedTaskCount.IncFetch();
		}
	};


	TEST(RunOneSimpleWaitTaskFromTask)
	{
		finishedTaskCount.Store(0);

		MT::TaskScheduler scheduler;

		MT::TaskGroup mainGroup = scheduler.CreateGroup();
		MT::TaskGroup secondaryGroup = scheduler.CreateGroup();

		PrimaryTask task(secondaryGroup);
		scheduler.RunAsync(mainGroup, &task, 1);

		CHECK(scheduler.WaitGroup(mainGroup, 10000));
	}


}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}


```

`SchedulerTests/main.cpp`:

```cpp
// The MIT License (MIT)
//
// 	Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev
//
// 	Permission is hereby granted, free of charge, to any person obtaining a copy
// 	of this software and associated documentation files (the "Software"), to deal
// 	in the Software without restriction, including without limitation the rights
// 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// 	copies of the Software, and to permit persons to whom the Software is
// 	furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
// 	all copies or substantial portions of the Software.
//
// 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// 	THE SOFTWARE.

#ifdef _WIN32

#include <stdlib.h>
#include <crtdbg.h>
#include <windows.h>


#if _MSC_VER > 1600
#include <timeapi.h>
#endif

#pragma comment( lib, "winmm.lib" )

#endif

#include <stdio.h>
#include <string>
#include <set>

#include <MTScheduler.h>
#include "Tests/Tests.h"

#if !defined(_WIN32) 

#include <execinfo.h>

void PosixSignalHandler(int signum)
{
	pthread_t currentThread = pthread_self();

	const char* name = "Unknown";
	switch( signum )
	{
		case SIGABRT: name = "SIGABRT";  break;
		case SIGSEGV: name = "SIGSEGV";  break;
		case SIGBUS:  name = "SIGBUS";   break;
		case SIGILL:  name = "SIGILL";   break;
		case SIGFPE:  name = "SIGFPE";   break;
        case SIGTRAP: name = "SIGTRAP";  break;
	}

	void *callStack[32];
  size_t size = backtrace(callStack, 32);

	printf("Error: signal %s:\n", name);

  char** symbollist = backtrace_symbols( callStack, size );

   // print the stack trace.
  for ( size_t i = 0; i < size; i++ )
  {
      printf("[%zu, %lu] %s\n", i, (unsigned long int)currentThread, symbollist[i]);
	}

  free(symbollist);

  exit(1);
}
#endif


int main(int argc, char ** argv)
{

#if defined(_WIN32)
	timeBeginPeriod(1);
	_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
	_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
#else
	// install signal handler
	signal(SIGSEGV, PosixSignalHandler);
	signal(SIGTRAP, PosixSignalHandler);
#endif

	int passCount = 1;
	if (argc >= 2)
	{
		passCount = atoi(argv[1]);
	}

	int res = 0;
	printf("Tests will run %d times\n", passCount);
	for(int pass = 0; pass < passCount; pass++)
	{
		printf("---- [ attempt #%d] ----\n", pass + 1);

		res = Tests::RunAll();
		if (res != 0)
		{
			printf("Unit test failed - pass %d of %d\n", pass + 1, passCount);
			return res;
		}
	}

#if defined(_WIN32)
	 timeEndPeriod(1);
#endif

	return res;
}




```

`StripNdaCode.cmd`:

```cmd
rd /Q /S "./VisualStudio"
rd /Q /S "./Scheduler/Include/Platform/Orbis"
del /S *.cxx
sunifdef.exe --replace --recurse --filter cpp,h,inl --discard drop --undef MT_PLATFORM_DURANGO --undef MT_PLATFORM_ORBIS --undef _XBOX_ONE --undef __ORBIS__ ./Scheduler
sunifdef.exe --replace --recurse --filter cpp,h,inl --discard drop --undef MT_PLATFORM_DURANGO --undef MT_PLATFORM_ORBIS --undef _XBOX_ONE --undef __ORBIS__ ./SchedulerTests
```

`TaskScheduler.code-workspace`:

```code-workspace
{
	"folders": [
		{
			"path": "."
		}
	],
	"settings": {}
}
```

`ThirdParty/Boost.Context/LICENSE_1_0.txt`:

```txt
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

```

`ThirdParty/Boost.Context/asm/jump_arm64_aapcs_elf_gas.S`:

```S
/*
            Copyright Edward Nevill 2015
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/
/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  |    d8     |    d9     |    d10    |    d11    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  |    d12    |    d13    |    d14    |    d15    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  |    x19    |    x20    |    x21    |    x22    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
 *  -------------------------------------------------  *
 *  |    x23    |    x24    |    x25    |    x26    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
 *  -------------------------------------------------  *
 *  |    x27    |    x28    |    FP     |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 | 43  |           |           |  *
 *  -------------------------------------------------  *
 *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *
 *  -------------------------------------------------  *
 *  |     PC    |   align   |           |           |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.cpu    generic+fp+simd
.text
.align  2
.global jump_fcontext
.type   jump_fcontext, %function
jump_fcontext:
    # prepare stack for GP + FPU
    sub  sp, sp, #0xb0

# Because gcc may save integer registers in fp registers across a
# function call we cannot skip saving the fp registers.
#
# Do not reinstate this test unless you fully understand what you
# are doing.
#
#    # test if fpu env should be preserved
#    cmp  w3, #0
#    b.eq  1f

    # save d8 - d15
    stp  d8,  d9,  [sp, #0x00]
    stp  d10, d11, [sp, #0x10]
    stp  d12, d13, [sp, #0x20]
    stp  d14, d15, [sp, #0x30]

1:
    # save x19-x30
    stp  x19, x20, [sp, #0x40]
    stp  x21, x22, [sp, #0x50]
    stp  x23, x24, [sp, #0x60]
    stp  x25, x26, [sp, #0x70]
    stp  x27, x28, [sp, #0x80]
    stp  x29, x30, [sp, #0x90]

    # save LR as PC
    str  x30, [sp, #0xa0]

    # store RSP (pointing to context-data) in first argument (x0).
    # STR cannot have sp as a target register
    mov  x4, sp
    str  x4, [x0]

    # restore RSP (pointing to context-data) from A2 (x1)
    mov  sp, x1

#    # test if fpu env should be preserved
#    cmp  w3, #0
#    b.eq  2f

    # load d8 - d15
    ldp  d8,  d9,  [sp, #0x00]
    ldp  d10, d11, [sp, #0x10]
    ldp  d12, d13, [sp, #0x20]
    ldp  d14, d15, [sp, #0x30]

2:
    # load x19-x30
    ldp  x19, x20, [sp, #0x40]
    ldp  x21, x22, [sp, #0x50]
    ldp  x23, x24, [sp, #0x60]
    ldp  x25, x26, [sp, #0x70]
    ldp  x27, x28, [sp, #0x80]
    ldp  x29, x30, [sp, #0x90]

    # use third arg as return value after jump
    # and as first arg in context function
    mov  x0, x2

    # load pc
    ldr  x4, [sp, #0xa0]

    # restore stack from GP + FPU
    add  sp, sp, #0xb0

    ret x4
.size   jump_fcontext,.-jump_fcontext
# Mark that we don't need executable stack.
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_arm64_aapcs_macho_gas.S`:

```S
/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  |    d8     |    d9     |    d10    |    d11    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  |    d12    |    d13    |    d14    |    d15    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  |    x19    |    x20    |    x21    |    x22    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
 *  -------------------------------------------------  *
 *  |    x23    |    x24    |    x25    |    x26    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
 *  -------------------------------------------------  *
 *  |    x27    |    x28    |    FP     |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 | 43  |           |           |  *
 *  -------------------------------------------------  *
 *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *
 *  -------------------------------------------------  *
 *  |     PC    |   align   |           |           |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl _jump_fcontext
.balign 16
_jump_fcontext:
    ; prepare stack for GP + FPU
    sub  sp, sp, #0xb0

#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
    ; test if fpu env should be preserved
    cmp  w3, #0
    b.eq  1f

    ; save d8 - d15
    stp  d8,  d9,  [sp, #0x00]
    stp  d10, d11, [sp, #0x10]
    stp  d12, d13, [sp, #0x20]
    stp  d14, d15, [sp, #0x30]

1:
#endif

    ; save x19-x30
    stp  x19, x20, [sp, #0x40]
    stp  x21, x22, [sp, #0x50]
    stp  x23, x24, [sp, #0x60]
    stp  x25, x26, [sp, #0x70]
    stp  x27, x28, [sp, #0x80]
    stp  fp,  lr,  [sp, #0x90]

    ; save LR as PC
    str  lr, [sp, #0xa0]

    ; store RSP (pointing to context-data) in first argument (x0).
    ; STR cannot have sp as a target register
    mov  x4, sp
    str  x4, [x0]

    ; restore RSP (pointing to context-data) from A2 (x1)
    mov  sp, x1

#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
    ; test if fpu env should be preserved
    cmp  w3, #0
    b.eq  2f

    ; load d8 - d15
    ldp  d8,  d9,  [sp, #0x00]
    ldp  d10, d11, [sp, #0x10]
    ldp  d12, d13, [sp, #0x20]
    ldp  d14, d15, [sp, #0x30]

2:
#endif

    ; load x19-x30
    ldp  x19, x20, [sp, #0x40]
    ldp  x21, x22, [sp, #0x50]
    ldp  x23, x24, [sp, #0x60]
    ldp  x25, x26, [sp, #0x70]
    ldp  x27, x28, [sp, #0x80]
    ldp  fp,  lr,  [sp, #0x90]

    ; use third arg as return value after jump
    ; and as first arg in context function
    mov  x0, x2

    ; load pc
    ldr  x4, [sp, #0xa0]

    ; restore stack from GP + FPU
    add  sp, sp, #0xb0

    ret x4

```

`ThirdParty/Boost.Context/asm/jump_arm_aapcs_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  |  v1 |  v2 |  v3 |  v4 |  v5 |  v6 |  v7 |  v8 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |                                   |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64|                                   |  *
 *  -------------------------------------------------  *
 *  |  lr |  pc |                                   |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl jump_fcontext
.align 2
.type jump_fcontext,%function
jump_fcontext:
    @ save LR as PC
    push {lr}
    @ save V1-V8,LR
    push {v1-v8,lr}

    @ prepare stack for FPU
    sub  sp, sp, #64

#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
    @ test if fpu env should be preserved
    cmp  a4, #0
    beq  1f

    @ save S16-S31
    vstmia  sp, {d8-d15}

1:
#endif

    @ store RSP (pointing to context-data) in A1
    str  sp, [a1]

    @ restore RSP (pointing to context-data) from A2
    mov  sp, a2

#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
    @ test if fpu env should be preserved
    cmp  a4, #0
    beq  2f

    @ restore S16-S31
    vldmia  sp, {d8-d15}
2:
#endif

    @ prepare stack for FPU
    add  sp, sp, #64

    @ use third arg as return value after jump
    @ and as first arg in context function
    mov  a1, a3
    
    @ restore v1-V8,LR,PC
    pop {v1-v8,lr,pc}
.size jump_fcontext,.-jump_fcontext

@ Mark that we don't need executable stack.
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_arm_aapcs_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  | sjlj|  v1 |  v2 |  v3 |  v4 |  v5 |  v6 |  v7 |
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |                             |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64| 0x68|                             |  *
 *  -------------------------------------------------  *
 *  |  v8 |  lr |  pc |                             |  *
 *  -------------------------------------------------  *
 *                                                     *
 * *****************************************************/

.text
.globl _jump_fcontext
.align 2
_jump_fcontext:
    @ save LR as PC
    push {lr}
    @ save V1-V8,LR
    push {v1-v8,lr}

    @ locate TLS to save/restore SjLj handler
    mrc  p15, 0, v2, c13, c0, #3
    bic  v2, v2, #3

    @ load TLS[__PTK_LIBC_DYLD_Unwind_SjLj_Key]
    ldr  v1, [v2, #72]
    @ save SjLj handler
    push  {v1}

    @ prepare stack for FPU
    sub  sp, sp, #64

#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
    @ test if fpu env should be preserved
    cmp  a4, #0
    beq  1f

    @ save S16-S31
    vstmia  sp, {d8-d15}

1:
#endif

    @ store RSP (pointing to context-data) in A1
    str  sp, [a1]

    @ restore RSP (pointing to context-data) from A2
    mov  sp, a2

#if (defined(__VFP_FP__) && !defined(__SOFTFP__))
    @ test if fpu env should be preserved
    cmp  a4, #0
    beq  2f

    @ restore S16-S31
    vldmia  sp, {d8-d15}

2:
#endif

    @ prepare stack for FPU
    add  sp, sp, #64

    @ restore SjLj handler
    pop  {v1}
    @ store SjLj handler in TLS
    str  v1, [v2, #72]

    @ use third arg as return value after jump
    @ and as first arg in context function
    mov  a1, a3
    
    @ restore v1-V8,LR,PC
    pop {v1-v8,lr,pc}

```

`ThirdParty/Boost.Context/asm/jump_arm_aapcs_pe_armasm.asm`:

```asm
;/*
;            Copyright Oliver Kowalke 2009.
;   Distributed under the Boost Software License, Version 1.0.
;      (See accompanying file LICENSE_1_0.txt or copy at
;          http://www.boost.org/LICENSE_1_0.txt)
;*/

; *******************************************************
; *                                                     *
; *  -------------------------------------------------  *
; *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
; *  -------------------------------------------------  *
; *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
; *  -------------------------------------------------  *
; *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
; *  -------------------------------------------------  *
; *  -------------------------------------------------  *
; *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
; *  -------------------------------------------------  *
; *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
; *  -------------------------------------------------  *
; *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
; *  -------------------------------------------------  *
; *  -------------------------------------------------  *
; *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
; *  -------------------------------------------------  *
; *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
; *  -------------------------------------------------  *
; *  |deall|limit| base|  v1 |  v2 |  v3 |  v4 |  v5 |  *
; *  -------------------------------------------------  *
; *  -------------------------------------------------  *
; *  |  24 |  25 |  26 |  27 |  28 |                 |  *
; *  -------------------------------------------------  *
; *  | 0x60| 0x64| 0x68| 0x6c| 0x70|                 |  *
; *  -------------------------------------------------  *
; *  |  v6 |  v7 |  v8 |  lr |  pc |                 |  *
; *  -------------------------------------------------  *
; *                                                     *
; *******************************************************

    AREA |.text|, CODE
    ALIGN 4
    EXPORT jump_fcontext

jump_fcontext PROC
    @ save LR as PC
    push {lr}
    @ save V1-V8,LR
    push {v1-v8,lr}

    @ prepare stack for FPU
    sub  sp, sp, #0x4c

    @ test if fpu env should be preserved
    cmp  a4, #0
    beq  1f

    @ save S16-S31
    vstmia  sp, {d8-d15}

1:
    ; load TIB to save/restore thread size and limit.
    ; we do not need preserve CPU flag and can use it's arg register
    mrc     p15, #0, v1, c13, c0, #2

    ; save current stack base
    ldr  a5, [v1,#0x04]
    str  a5, [sp,#0x48]
    ; save current stack limit
    ldr  a5, [v1,#0x08]
    str  a5, [sp,#0x44]
    ; save current deallocation stack
    ldr  a5, [v1,#0xe0c]
    str  a5, [sp,#0x40]

    @ store RSP (pointing to context-data) in A1
    str  sp, [a1]

    @ restore RSP (pointing to context-data) from A2
    mov  sp, a2

    @ test if fpu env should be preserved
    cmp  a4, #0
    beq  2f

    @ restore S16-S31
    vldmia  sp, {d8-d15}

2:
    ; restore stack base
    ldr  a5, [sp,#0x48]
    str  a5, [v1,#0x04]
    ; restore stack limit
    ldr  a5, [sp,#0x44]
    str  a5, [v1,#0x08]
    ; restore deallocation stack
    ldr  a5, [sp,#0x40]
    str  a5, [v1,#0xe0c]

    @ prepare stack for FPU
    add  sp, sp, #0x4c

    ; use third arg as return value after jump
    ; and as first arg in context function
    mov  a1, a3

    @ restore v1-V8,LR
    pop  {v1-v8,lr}
    pop  {pc}

    ENDP
    END

```

`ThirdParty/Boost.Context/asm/jump_combined_sysv_macho_gas.S`:

```S
/*
            Copyright Sergue E. Leontiev 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

// Stub file for universal binary

#if defined(__i386__)
    #include "jump_i386_sysv_macho_gas.S"
#elif defined(__x86_64__)
    #include "jump_x86_64_sysv_macho_gas.S"
#elif defined(__ppc__)
    #include "jump_ppc32_sysv_macho_gas.S"
#elif defined(__ppc64__)
    #include "jump_ppc64_sysv_macho_gas.S"
#else
    #error "No arch's"
#endif

```

`ThirdParty/Boost.Context/asm/jump_i386_ms_pe_gas.asm`:

```asm
/*
            Copyright Oliver Kowalke 2009.
            Copyright Thomas Sailer 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/********************************************************************
  ---------------------------------------------------------------------------------
  |    0    |    1    |    2    |    3    |    4    |    5    |    6    |    7    |
  ---------------------------------------------------------------------------------
  |    0h   |   04h   |   08h   |   0ch   |   010h  |   014h  |   018h  |   01ch  |
  ---------------------------------------------------------------------------------
  | fc_mxcsr|fc_x87_cw| fc_strg |fc_deallo|  limit  |   base  |  fc_seh |   EDI   |
  ---------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------
  |    8    |    9    |   10    |    11   |    12   |    13   |    14   |    15   |
  ---------------------------------------------------------------------------------
  |   020h  |  024h   |  028h   |   02ch  |   030h  |   034h  |   038h  |   03ch  |
  ---------------------------------------------------------------------------------
  |   ESI   |   EBX   |   EBP   |   EIP   |   EXIT  |         | SEH NXT |SEH HNDLR|
  ---------------------------------------------------------------------------------
* *****************************************************************/

.file	"jump_i386_ms_pe_gas.asm"
.text
.p2align 4,,15
.globl	_jump_fcontext
.def	_jump_fcontext;	.scl	2;	.type	32;	.endef
_jump_fcontext:
    /* fourth arg of jump_fcontext() == flag indicating preserving FPU */
    movl  0x10(%esp), %ecx

    pushl  %ebp  /* save EBP */
    pushl  %ebx  /* save EBX */
    pushl  %esi  /* save ESI */
    pushl  %edi  /* save EDI */

    /* load NT_TIB */
    movl  %fs:(0x18), %edx

    /* load current SEH exception list */
    movl  (%edx), %eax
    push  %eax

    /* load current stack base */
    movl  0x04(%edx), %eax
    push  %eax

    /* load current stack limit */
    movl  0x08(%edx), %eax
    push  %eax
    
    /* load current dealloction stack */
    movl  0xe0c(%edx), %eax
    push  %eax
    
    /* load fiber local storage */
    movl  0x10(%edx), %eax
    push  %eax

    /* prepare stack for FPU */
    leal  -0x08(%esp), %esp

    /* test for flag preserve_fpu */
    testl  %ecx, %ecx 
    je  1f

    /* save MMX control word */
    stmxcsr  (%esp)
    /* save x87 control word */
    fnstcw  0x04(%esp)

1:
    /* first arg of jump_fcontext() == context jumping from */
    movl  0x30(%esp), %eax

    /* store ESP (pointing to context-data) in EAX */
    movl  %esp, (%eax)

    /* second arg of jump_fcontext() == context jumping to */
    movl  0x34(%esp), %edx

    /* third arg of jump_fcontext() == value to be returned after jump */
    movl  0x38(%esp), %eax

    /* restore ESP (pointing to context-data) from EDX */
    movl  %edx, %esp

    /* test for flag preserve_fpu */
    testl  %ecx, %ecx
    je  2f

    /* restore MMX control- and status-word */
    ldmxcsr  (%esp)
    /* restore x87 control-word */
    fldcw  0x04(%esp)

2:
    /* prepare stack for FPU */
    leal  0x08(%esp), %esp

    /* load NT_TIB into ECX */
    movl  %fs:(0x18), %edx

    /* restore fiber local storage */
    popl  %ecx
    movl  %ecx, 0x10(%edx)

    /* restore current deallocation stack */
    popl  %ecx
    movl  %ecx, 0xe0c(%edx)

    /* restore current stack limit */
    popl  %ecx
    movl  %ecx, 0x08(%edx)

    /* restore current stack base */
    popl  %ecx
    movl  %ecx, 0x04(%edx)

    /* restore current SEH exception list */
    popl  %ecx
    movl  %ecx, (%edx)

    popl  %edi  /* save EDI */
    popl  %esi  /* save ESI */
    popl  %ebx  /* save EBX */
    popl  %ebp  /* save EBP */

    /* restore return-address */
    popl  %edx

    /* use value in EAX as return-value after jump */
    /* use value in EAX as first arg in context function */
    movl  %eax, 0x04(%esp)

    /* indirect jump to context */
    jmp  *%edx

```

`ThirdParty/Boost.Context/asm/jump_i386_ms_pe_masm.asm`:

```asm

;           Copyright Oliver Kowalke 2009.
;  Distributed under the Boost Software License, Version 1.0.
;     (See accompanying file LICENSE_1_0.txt or copy at
;           http://www.boost.org/LICENSE_1_0.txt)

;  ---------------------------------------------------------------------------------
;  |    0    |    1    |    2    |    3    |    4    |    5    |    6    |    7    |
;  ---------------------------------------------------------------------------------
;  |    0h   |   04h   |   08h   |   0ch   |   010h  |   014h  |   018h  |   01ch  |
;  ---------------------------------------------------------------------------------
;  | fc_mxcsr|fc_x87_cw| fc_strg |fc_deallo|  limit  |   base  |  fc_seh |   EDI   |
;  ---------------------------------------------------------------------------------
;  ---------------------------------------------------------------------------------
;  |    8    |    9    |   10    |    11   |    12   |    13   |    14   |    15   |
;  ---------------------------------------------------------------------------------
;  |   020h  |  024h   |  028h   |   02ch  |   030h  |   034h  |   038h  |   03ch  |
;  ---------------------------------------------------------------------------------
;  |   ESI   |   EBX   |   EBP   |   EIP   |   EXIT  |         | SEH NXT |SEH HNDLR|
;  ---------------------------------------------------------------------------------

.386
.XMM
.model flat, c
.code

jump_fcontext PROC
    ; fourth arg of jump_fcontext() == flag indicating preserving FPU
    mov  ecx, [esp+010h]

    push  ebp  ; save EBP 
    push  ebx  ; save EBX 
    push  esi  ; save ESI 
    push  edi  ; save EDI 

    assume  fs:nothing
    ; load NT_TIB into ECX
    mov  edx, fs:[018h]
    assume  fs:error

    ; load current SEH exception list
    mov  eax, [edx]
    push  eax

    ; load current stack base
    mov  eax, [edx+04h]
    push  eax

    ; load current stack limit
    mov  eax, [edx+08h]
    push  eax

    ; load current deallocation stack
    mov  eax, [edx+0e0ch]
    push  eax

    ; load fiber local storage
    mov  eax, [edx+010h]
    push  eax

    ; prepare stack for FPU
    lea  esp, [esp-08h]

    ; test for flag preserve_fpu
    test  ecx, ecx
    je  nxt1

    ; save MMX control- and status-word
    stmxcsr  [esp]
    ; save x87 control-word
    fnstcw  [esp+04h]

nxt1:
    ; first arg of jump_fcontext() == context jumping from
    mov  eax, [esp+030h]

    ; store ESP (pointing to context-data) in EAX
    mov  [eax], esp

    ; second arg of jump_fcontext() == context jumping to
    mov  edx, [esp+034h]

    ; third arg of jump_fcontext() == value to be returned after jump
    mov  eax, [esp+038h]

    ; restore ESP (pointing to context-data) from EDX
    mov  esp, edx

    ; test for flag preserve_fpu
    test  ecx, ecx
    je  nxt2

    ; restore MMX control- and status-word
    ldmxcsr  [esp]
    ; restore x87 control-word
    fldcw  [esp+04h]

nxt2:
    ; prepare stack for FPU
    lea  esp, [esp+08h]

    assume  fs:nothing
    ; load NT_TIB into ECX
    mov  edx, fs:[018h]
    assume  fs:error

    ; restore fiber local storage
    pop  ecx
    mov  [edx+010h], ecx

    ; restore current deallocation stack
    pop  ecx
    mov  [edx+0e0ch], ecx

    ; restore current stack limit
    pop  ecx
    mov  [edx+08h], ecx

    ; restore current stack base
    pop  ecx
    mov  [edx+04h], ecx

    ; restore current SEH exception list
    pop  ecx
    mov  [edx], ecx

    pop  edi  ; save EDI 
    pop  esi  ; save ESI 
    pop  ebx  ; save EBX 
    pop  ebp  ; save EBP 

    ; restore return-address
    pop  edx

    ; use value in EAX as return-value after jump
    ; use value in EAX as first arg in context function
    mov  [esp+04h], eax

    ; indirect jump to context
    jmp  edx
jump_fcontext ENDP
END

```

`ThirdParty/Boost.Context/asm/jump_i386_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |   EXIT  |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl jump_fcontext
.align 2
.type jump_fcontext,@function
jump_fcontext:
    /* fourth arg of jump_fcontext() == flag indicating preserving FPU */
    movl  0x10(%esp), %ecx

    pushl  %ebp  /* save EBP */
    pushl  %ebx  /* save EBX */
    pushl  %esi  /* save ESI */
    pushl  %edi  /* save EDI */

    /* prepare stack for FPU */
    leal  -0x8(%esp), %esp

    /* test for flag preserve_fpu */
    test  %ecx, %ecx
    je  1f

    /* save MMX control- and status-word */
    stmxcsr  (%esp)
    /* save x87 control-word */
    fnstcw  0x4(%esp)

1:
    /* first arg of jump_fcontext() == context jumping from */
    movl  0x1c(%esp), %eax

    /* store ESP (pointing to context-data) in EAX */
    movl  %esp, (%eax)

    /* second arg of jump_fcontext() == context jumping to */
    movl  0x20(%esp), %edx

    /* third arg of jump_fcontext() == value to be returned after jump */
    movl  0x24(%esp), %eax

    /* restore ESP (pointing to context-data) from EDX */
    movl  %edx, %esp

    /* test for flag preserve_fpu */
    test  %ecx, %ecx
    je  2f

    /* restore MMX control- and status-word */
    ldmxcsr  (%esp)
    /* restore x87 control-word */
    fldcw  0x4(%esp)
2:
    /* prepare stack for FPU */
    leal  0x8(%esp), %esp

    popl  %edi  /* restore EDI */
    popl  %esi  /* restore ESI */
    popl  %ebx  /* restore EBX */
    popl  %ebp  /* restore EBP */

    /* restore return-address */
    popl  %edx

    /* use value in EAX as return-value after jump */
    /* use value in EAX as first arg in context function */
    movl  %eax, 0x4(%esp)

    /* indirect jump to context */
    jmp  *%edx
.size jump_fcontext,.-jump_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_i386_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |   EXIT  |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl _jump_fcontext
.align 2
_jump_fcontext:
    /* fourth arg of jump_fcontext() == flag indicating preserving FPU */
    movl  0x10(%esp), %ecx

    pushl  %ebp  /* save EBP */
    pushl  %ebx  /* save EBX */
    pushl  %esi  /* save ESI */
    pushl  %edi  /* save EDI */

    /* prepare stack for FPU */
    leal  -0x8(%esp), %esp

    /* test for flag preserve_fpu */
    test  %ecx, %ecx
    je  1f

    /* save MMX control- and status-word */
    stmxcsr  (%esp)
    /* save x87 control-word */
    fnstcw  0x4(%esp)

1:
    /* first arg of jump_fcontext() == context jumping from */
    movl  0x1c(%esp), %eax

    /* store ESP (pointing to context-data) in EAX */
    movl  %esp, (%eax)

    /* second arg of jump_fcontext() == context jumping to */
    movl  0x20(%esp), %edx

    /* third arg of jump_fcontext() == value to be returned after jump */
    movl  0x24(%esp), %eax

    /* restore ESP (pointing to context-data) from EDX */
    movl  %edx, %esp

    /* test for flag preserve_fpu */
    test  %ecx, %ecx
    je  2f

    /* restore MMX control- and status-word */
    ldmxcsr  (%esp)
    /* restore x87 control-word */
    fldcw  0x4(%esp)
2:
    /* prepare stack for FPU */
    leal  0x8(%esp), %esp

    popl  %edi  /* restore EDI */
    popl  %esi  /* restore ESI */
    popl  %ebx  /* restore EBX */
    popl  %ebp  /* restore EBP */

    /* restore return-address */
    popl  %edx

    /* use value in EAX as return-value after jump */
    /* use value in EAX as first arg in context function */
    movl  %eax, 0x4(%esp)

    /* indirect jump to context */
    jmp  *%edx

```

`ThirdParty/Boost.Context/asm/jump_i386_x86_64_sysv_macho_gas.S`:

```S
/*
            Copyright Sergue E. Leontiev 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

// Stub file for universal binary

#if defined(__i386__)
    #include "jump_i386_sysv_macho_gas.S"
#elif defined(__x86_64__)
    #include "jump_x86_64_sysv_macho_gas.S"
#else
    #error "No arch's"
#endif

```

`ThirdParty/Boost.Context/asm/jump_mips32_o32_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F20    |    F22    |    F24    |    F26    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F28    |    F30    |  S0 |  S1 |  S2 |  S3 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |     |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |     |  *
 *  -------------------------------------------------  *
 *  |  S4 |  S5 |  S6 |  S7 |  FP |  RA |  PC |     |  *
 *  -------------------------------------------------  *
 *                                                     *
 * *****************************************************/

.text
.globl jump_fcontext
.align 2
.type jump_fcontext,@function
.ent jump_fcontext
jump_fcontext:
    # reserve space on stack
    addiu $sp, $sp, -92

    sw  $s0, 48($sp)  # save S0
    sw  $s1, 52($sp)  # save S1
    sw  $s2, 56($sp)  # save S2
    sw  $s3, 60($sp)  # save S3
    sw  $s4, 64($sp)  # save S4
    sw  $s5, 68($sp)  # save S5
    sw  $s6, 72($sp)  # save S6
    sw  $s7, 76($sp)  # save S7
    sw  $fp, 80($sp)  # save FP
    sw  $ra, 84($sp)  # save RA
    sw  $ra, 88($sp)  # save RA as PC

#if defined(__mips_hard_float)
    # test if fpu env should be preserved 
    beqz    $a3,  1f

    s.d  $f20, ($sp)  # save F20
    s.d  $f22, 8($sp)  # save F22
    s.d  $f24, 16($sp)  # save F24
    s.d  $f26, 24($sp)  # save F26
    s.d  $f28, 32($sp)  # save F28
    s.d  $f30, 40($sp)  # save F30

1:
#endif

    # store SP (pointing to context-data) in A0
    sw  $sp, ($a0)

    # restore SP (pointing to context-data) from A1
    move  $sp, $a1


#if defined(__mips_hard_float)
    # test if fpu env should be preserved 
    beqz    $a3,  2f

    l.d  $f20, ($sp)  # restore F20
    l.d  $f22, 8($sp)  # restore F22
    l.d  $f24, 16($sp)  # restore F24
    l.d  $f26, 24($sp)  # restore F26
    l.d  $f28, 32($sp)  # restore F28
    l.d  $f30, 40($sp)  # restore F30

2:
#endif

    lw  $s0, 48($sp)  # restore S0
    lw  $s1, 52($sp)  # restore S1
    lw  $s2, 56($sp)  # restore S2
    lw  $s3, 60($sp)  # restore S3
    lw  $s4, 64($sp)  # restore S4
    lw  $s5, 68($sp)  # restore S5
    lw  $s6, 72($sp)  # restore S6
    lw  $s7, 76($sp)  # restore S7
    lw  $fp, 80($sp)  # restore FP
    lw  $ra, 84($sp)  # restore RA

    # load PC
    lw  $t9, 88($sp)

    # adjust stack
    addiu $sp, $sp, 92

    # use third arg as return value after jump
    move  $v0, $a2
    # use third arg as first arg in context function
    move  $a0, $a2

    # jump to context
    jr  $t9
.end jump_fcontext
.size jump_fcontext, .-jump_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_ppc32_ppc64_sysv_macho_gas.S`:

```S
/*
            Copyright Sergue E. Leontiev 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

// Stub file for universal binary

#if defined(__ppc__)
    #include "jump_ppc32_sysv_macho_gas.S"
#elif defined(__ppc64__)
    #include "jump_ppc64_sysv_macho_gas.S"
#else
    #error "No arch's"
#endif

```

`ThirdParty/Boost.Context/asm/jump_ppc32_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   | R13 | R14 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  | R15 | R16 | R17 | R18 | R19 | R20 | R21 | R22 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  | R23 | R24 | R25 | R26 | R27 | R28 | R29 | R30 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |                       |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 |                       |  *
 *  -------------------------------------------------  *
 *  | R31 |  CR |  LR |  PC |                       |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl jump_fcontext
.align 2
.type jump_fcontext,@function
jump_fcontext:
    # reserve space on stack
    subi  %r1, %r1, 240

    stw  %r13, 152(%r1)  # save R13
    stw  %r14, 156(%r1)  # save R14
    stw  %r15, 160(%r1)  # save R15
    stw  %r16, 164(%r1)  # save R16
    stw  %r17, 168(%r1)  # save R17
    stw  %r18, 172(%r1)  # save R18
    stw  %r19, 176(%r1)  # save R19
    stw  %r20, 180(%r1)  # save R20
    stw  %r21, 184(%r1)  # save R21
    stw  %r22, 188(%r1)  # save R22
    stw  %r23, 192(%r1)  # save R23
    stw  %r24, 196(%r1)  # save R24
    stw  %r25, 200(%r1)  # save R25
    stw  %r26, 204(%r1)  # save R26
    stw  %r27, 208(%r1)  # save R27
    stw  %r28, 212(%r1)  # save R28
    stw  %r29, 216(%r1)  # save R29
    stw  %r30, 220(%r1)  # save R30
    stw  %r31, 224(%r1)  # save R31

    # save CR
    mfcr  %r0
    stw  %r0, 228(%r1)
    # save LR
    mflr  %r0
    stw  %r0, 232(%r1)
    # save LR as PC
    stw  %r0, 236(%r1)

    # test if fpu env should be preserved
    cmpwi  cr7, %r6, 0
    beq  cr7, 1f

    stfd  %f14, 0(%r1)  # save F14
    stfd  %f15, 8(%r1)  # save F15
    stfd  %f16, 16(%r1)  # save F16
    stfd  %f17, 24(%r1)  # save F17
    stfd  %f18, 32(%r1)  # save F18
    stfd  %f19, 40(%r1)  # save F19
    stfd  %f20, 48(%r1)  # save F20
    stfd  %f21, 56(%r1)  # save F21
    stfd  %f22, 64(%r1)  # save F22
    stfd  %f23, 72(%r1)  # save F23
    stfd  %f24, 80(%r1)  # save F24
    stfd  %f25, 88(%r1)  # save F25
    stfd  %f26, 96(%r1)  # save F26
    stfd  %f27, 104(%r1)  # save F27
    stfd  %f28, 112(%r1)  # save F28
    stfd  %f29, 120(%r1)  # save F29
    stfd  %f30, 128(%r1)  # save F30
    stfd  %f31, 136(%r1)  # save F31
    mffs  %f0  # load FPSCR
    stfd  %f0, 144(%r1)  # save FPSCR

1:
    # store RSP (pointing to context-data) in R3
    stw  %r1, 0(%r3)

    # restore RSP (pointing to context-data) from R4
    mr  %r1, %r4

    # test if fpu env should be preserved
    cmpwi  cr7, %r6, 0
    beq  cr7, 2f

    lfd  %f14, 0(%r1)  # restore F14
    lfd  %f15, 8(%r1)  # restore F15
    lfd  %f16, 16(%r1)  # restore F16
    lfd  %f17, 24(%r1)  # restore F17
    lfd  %f18, 32(%r1)  # restore F18
    lfd  %f19, 40(%r1)  # restore F19
    lfd  %f20, 48(%r1)  # restore F20
    lfd  %f21, 56(%r1)  # restore F21
    lfd  %f22, 64(%r1)  # restore F22
    lfd  %f23, 72(%r1)  # restore F23
    lfd  %f24, 80(%r1)  # restore F24
    lfd  %f25, 88(%r1)  # restore F25
    lfd  %f26, 96(%r1)  # restore F26
    lfd  %f27, 104(%r1)  # restore F27
    lfd  %f28, 112(%r1)  # restore F28
    lfd  %f29, 120(%r1)  # restore F29
    lfd  %f30, 128(%r1)  # restore F30
    lfd  %f31, 136(%r1)  # restore F31
    lfd  %f0,  144(%r1)  # load FPSCR
    mtfsf  0xff, %f0  # restore FPSCR

2:
    lwz  %r13, 152(%r1)  # restore R13
    lwz  %r14, 156(%r1)  # restore R14
    lwz  %r15, 160(%r1)  # restore R15
    lwz  %r16, 164(%r1)  # restore R16
    lwz  %r17, 168(%r1)  # restore R17
    lwz  %r18, 172(%r1)  # restore R18
    lwz  %r19, 176(%r1)  # restore R19
    lwz  %r20, 180(%r1)  # restore R20
    lwz  %r21, 184(%r1)  # restore R21
    lwz  %r22, 188(%r1)  # restore R22
    lwz  %r23, 192(%r1)  # restore R23
    lwz  %r24, 196(%r1)  # restore R24
    lwz  %r25, 200(%r1)  # restore R25
    lwz  %r26, 204(%r1)  # restore R26
    lwz  %r27, 208(%r1)  # restore R27
    lwz  %r28, 212(%r1)  # restore R28
    lwz  %r29, 216(%r1)  # restore R29
    lwz  %r30, 220(%r1)  # restore R30
    lwz  %r31, 224(%r1)  # restore R31

    # restore CR
    lwz  %r0, 228(%r1)
    mtcr  %r0
    # restore LR
    lwz  %r0, 232(%r1)
    mtlr  %r0

    # load PC
    lwz  %r0, 236(%r1)
    # restore CTR
    mtctr  %r0

    # adjust stack
    addi  %r1, %r1, 240

    # use third arg as return value after jump
    # use third arg as first arg in context function
    mr  %r3, %r5

    # jump to context
    bctr
.size jump_fcontext, .-jump_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_ppc32_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   | R13 | R14 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  | R15 | R16 | R17 | R18 | R19 | R20 | R21 | R22 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  | R23 | R24 | R25 | R26 | R27 | R28 | R29 | R30 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |                       |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 |                       |  *
 *  -------------------------------------------------  *
 *  | R31 |  CR |  LR |  PC |                       |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl _jump_fcontext
.align 2
_jump_fcontext:
    ; reserve space on stack
    subi  r1, r1, 240

    stw  r13, 152(r1)  ; save R13
    stw  r14, 156(r1)  ; save R14
    stw  r15, 160(r1)  ; save R15
    stw  r16, 164(r1)  ; save R16
    stw  r17, 168(r1)  ; save R17
    stw  r18, 172(r1)  ; save R18
    stw  r19, 176(r1)  ; save R19
    stw  r20, 180(r1)  ; save R20
    stw  r21, 184(r1)  ; save R21
    stw  r22, 188(r1)  ; save R22
    stw  r23, 192(r1)  ; save R23
    stw  r24, 196(r1)  ; save R24
    stw  r25, 200(r1)  ; save R25
    stw  r26, 204(r1)  ; save R26
    stw  r27, 208(r1)  ; save R27
    stw  r28, 212(r1)  ; save R28
    stw  r29, 216(r1)  ; save R29
    stw  r30, 220(r1)  ; save R30
    stw  r31, 224(r1)  ; save R31

    ; save CR
    mfcr  r0
    stw  r0, 228(r1)
    ; save LR
    mflr  r0
    stw  r0, 232(r1)
    ; save LR as PC
    stw  r0, 236(r1)

    ; test if fpu env should be preserved
    cmpwi  cr7, r6, 0
    beq  cr7, l1 

    stfd  f14, 0(r1)  ; save F14
    stfd  f15, 8(r1)  ; save F15
    stfd  f16, 16(r1)  ; save F16
    stfd  f17, 24(r1)  ; save F17
    stfd  f18, 32(r1)  ; save F18
    stfd  f19, 40(r1)  ; save F19
    stfd  f20, 48(r1)  ; save F20
    stfd  f21, 56(r1)  ; save F21
    stfd  f22, 64(r1)  ; save F22
    stfd  f23, 72(r1)  ; save F23
    stfd  f24, 80(r1)  ; save F24
    stfd  f25, 88(r1)  ; save F25
    stfd  f26, 96(r1)  ; save F26
    stfd  f27, 104(r1)  ; save F27
    stfd  f28, 112(r1)  ; save F28
    stfd  f29, 120(r1)  ; save F29
    stfd  f30, 128(r1)  ; save F30
    stfd  f31, 136(r1)  ; save F31
    mffs  f0  ; load FPSCR
    stfd  f0, 144(r1)  ; save FPSCR

l1:
    ; store RSP (pointing to context-data) in R3
    stw  r1, 0(r3)

    ; restore RSP (pointing to context-data) from R4
    mr  r1, r4

    ; test if fpu env should be preserved
    cmpwi  cr7, r6, 0
    beq  cr7, l2

    lfd  f14, 0(r1)  ; restore F14
    lfd  f15, 8(r1)  ; restore F15
    lfd  f16, 16(r1)  ; restore F16
    lfd  f17, 24(r1)  ; restore F17
    lfd  f18, 32(r1)  ; restore F18
    lfd  f19, 40(r1)  ; restore F19
    lfd  f20, 48(r1)  ; restore F20
    lfd  f21, 56(r1)  ; restore F21
    lfd  f22, 64(r1)  ; restore F22
    lfd  f23, 72(r1)  ; restore F23
    lfd  f24, 80(r1)  ; restore F24
    lfd  f25, 88(r1)  ; restore F25
    lfd  f26, 96(r1)  ; restore F26
    lfd  f27, 104(r1)  ; restore F27
    lfd  f28, 112(r1)  ; restore F28
    lfd  f29, 120(r1)  ; restore F29
    lfd  f30, 128(r1)  ; restore F30
    lfd  f31, 136(r1)  ; restore F31
    lfd  f0,  144(r1)  ; load FPSCR
    mtfsf  0xff, f0  ; restore FPSCR

l2:
    lwz  r13, 152(r1)  ; restore R13
    lwz  r14, 156(r1)  ; restore R14
    lwz  r15, 160(r1)  ; restore R15
    lwz  r16, 164(r1)  ; restore R16
    lwz  r17, 168(r1)  ; restore R17
    lwz  r18, 172(r1)  ; restore R18
    lwz  r19, 176(r1)  ; restore R19
    lwz  r20, 180(r1)  ; restore R20
    lwz  r21, 184(r1)  ; restore R21
    lwz  r22, 188(r1)  ; restore R22
    lwz  r23, 192(r1)  ; restore R23
    lwz  r24, 196(r1)  ; restore R24
    lwz  r25, 200(r1)  ; restore R25
    lwz  r26, 204(r1)  ; restore R26
    lwz  r27, 208(r1)  ; restore R27
    lwz  r28, 212(r1)  ; restore R28
    lwz  r29, 216(r1)  ; restore R29
    lwz  r30, 220(r1)  ; restore R30
    lwz  r31, 224(r1)  ; restore R31

    ; restore CR
    lwz  r0, 228(r1)
    mtcr  r0
    ; restore LR
    lwz  r0, 232(r1)
    mtlr  r0

    ; load PC
    lwz  r0, 236(r1)
    ; restore CTR
    mtctr  r0

    ; adjust stack
    addi  r1, r1, 240

    ; use third arg as return value after jump
    ; use third arg as first arg in context function
    mr  r3, r5

    ; jump to context
    bctr

```

`ThirdParty/Boost.Context/asm/jump_ppc32_sysv_xcoff_gas.S`:

```S
.globl .jump_fcontext
.globl  jump_fcontext[DS]
.align 2 
.csect	jump_fcontext[DS]
jump_fcontext:
  .long	.jump_fcontext
.jump_fcontext:
    # reserve space on stack
    subi 1, 1, 240

    stw 13, 152(1) # save R13
    stw 14, 156(1) # save R14
    stw 15, 160(1) # save R15
    stw 16, 164(1) # save R16
    stw 17, 168(1) # save R17
    stw 18, 172(1) # save R18
    stw 19, 176(1) # save R19
    stw 20, 180(1) # save R20
    stw 21, 184(1) # save R21
    stw 22, 188(1) # save R22
    stw 23, 192(1) # save R23
    stw 24, 196(1) # save R24
    stw 25, 200(1) # save R25
    stw 26, 204(1) # save R26
    stw 27, 208(1) # save R27
    stw 28, 212(1) # save R28
    stw 29, 216(1) # save R29
    stw 30, 220(1) # save R30
    stw 31, 224(1) # save R31

    # save CR
    mfcr 0
    stw 0, 228(1)
    # save LR
    mflr 0
    stw 0, 232(1)
    # save LR as PC
    stw 0, 236(1)

    # test if fpu env should be preserved
    cmpwi 7, 6, 0
    beq 7, label1

    stfd 14, 0(1) # save F14
    stfd 15, 8(1) # save F15
    stfd 16, 16(1) # save F16
    stfd 17, 24(1) # save F17
    stfd 18, 32(1) # save F18
    stfd 19, 40(1) # save F19
    stfd 20, 48(1) # save F20
    stfd 21, 56(1) # save F21
    stfd 22, 64(1) # save F22
    stfd 23, 72(1) # save F23
    stfd 24, 80(1) # save F24
    stfd 25, 88(1) # save F25
    stfd 26, 96(1) # save F26
    stfd 27, 104(1) # save F27
    stfd 28, 112(1) # save F28
    stfd 29, 120(1) # save F29
    stfd 30, 128(1) # save F30
    stfd 31, 136(1) # save F31
    mffs 0 # load FPSCR
    stfd 0, 144(1) # save FPSCR

label1:
    # store RSP (pointing to context-data) in R3
    stw 1, 0(3)

    # restore RSP (pointing to context-data) from R4
    mr 1, 4

    # test if fpu env should be preserved
    cmpwi 7, 6, 0
    beq 7, label2 

    lfd 14, 0(1) # restore F14
    lfd 15, 8(1) # restore F15
    lfd 16, 16(1) # restore F16
    lfd 17, 24(1) # restore F17
    lfd 18, 32(1) # restore F18
    lfd 19, 40(1) # restore F19
    lfd 20, 48(1) # restore F20
    lfd 21, 56(1) # restore F21
    lfd 22, 64(1) # restore F22
    lfd 23, 72(1) # restore F23
    lfd 24, 80(1) # restore F24
    lfd 25, 88(1) # restore F25
    lfd 26, 96(1) # restore F26
    lfd 27, 104(1) # restore F27
    lfd 28, 112(1) # restore F28
    lfd 29, 120(1) # restore F29
    lfd 30, 128(1) # restore F30
    lfd 31, 136(1) # restore F31
    lfd 0, 144(1) # load FPSCR
    mtfsf 0xff, 0 # restore FPSCR

label2:
    lwz 13, 152(1) # restore R13
    lwz 14, 156(1) # restore R14
    lwz 15, 160(1) # restore R15
    lwz 16, 164(1) # restore R16
    lwz 17, 168(1) # restore R17
    lwz 18, 172(1) # restore R18
    lwz 19, 176(1) # restore R19
    lwz 20, 180(1) # restore R20
    lwz 21, 184(1) # restore R21
    lwz 22, 188(1) # restore R22
    lwz 23, 192(1) # restore R23
    lwz 24, 196(1) # restore R24
    lwz 25, 200(1) # restore R25
    lwz 26, 204(1) # restore R26
    lwz 27, 208(1) # restore R27
    lwz 28, 212(1) # restore R28
    lwz 29, 216(1) # restore R29
    lwz 30, 220(1) # restore R30
    lwz 31, 224(1) # restore R31

    # restore CR
    lwz 0, 228(1)
    mtcr 0
    # restore LR
    lwz 0, 232(1)
    mtlr 0

    # load PC
    lwz 0, 236(1)
    # restore CTR
    mtctr 0

    # adjust stack
    addi 1, 1, 240

    # use third arg as return value after jump
    # use third arg as first arg in context function
    mr 3, 5

    # jump to context
    bctr

```

`ThirdParty/Boost.Context/asm/jump_ppc64_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   |    TOC    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  |    R14    |    R15    |     R16   |    R17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  |    R18    |    R19    |    R20    |    R21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |  60 |  61 |  62 |  63 |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 | 240 | 244 | 248 | 252 |  *
 *  -------------------------------------------------  *
 *  |    R22    |    R23    |    R24    |    R25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  64 |  65 |  66 |  67 |  68 |  69 |  70 |  71 |  *
 *  -------------------------------------------------  *
 *  | 256 | 260 | 264 | 268 | 272 | 276 | 280 | 284 |  *
 *  -------------------------------------------------  *
 *  |    R26    |    R27    |    R28    |    R29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  72 |  73 |  74 |  75 |  76 |  77 |  78 |  79 |  *
 *  -------------------------------------------------  *
 *  | 288 | 292 | 296 | 300 | 304 | 308 | 312 | 316 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |    R30    |    R31    |     CR    |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  80 |  81 |                                   |  *
 *  -------------------------------------------------  *
 *  | 320 | 324 |                                   |  *
 *  -------------------------------------------------  *
 *  |    PC     |                                   |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.globl jump_fcontext
#if _CALL_ELF == 2
	.text
	.align 2
jump_fcontext:
        addis   %r2, %r12, .TOC.-jump_fcontext@ha
        addi    %r2, %r2, .TOC.-jump_fcontext@l
        .localentry jump_fcontext, . - jump_fcontext
#else
	.section ".opd","aw"
	.align 3
jump_fcontext:
# ifdef _CALL_LINUX
        .quad   .L.jump_fcontext,.TOC.@tocbase,0
        .type   jump_fcontext,@function
        .text
        .align 2
.L.jump_fcontext:
# else
        .hidden .jump_fcontext
        .globl  .jump_fcontext
        .quad   .jump_fcontext,.TOC.@tocbase,0
        .size   jump_fcontext,24
        .type   .jump_fcontext,@function
        .text
        .align 2
.jump_fcontext:
# endif
#endif
    # reserve space on stack
    subi  %r1, %r1, 328

#if _CALL_ELF != 2
    std  %r2,  152(%r1)  # save TOC
#endif
    std  %r14, 160(%r1)  # save R14
    std  %r15, 168(%r1)  # save R15
    std  %r16, 176(%r1)  # save R16
    std  %r17, 184(%r1)  # save R17
    std  %r18, 192(%r1)  # save R18
    std  %r19, 200(%r1)  # save R19
    std  %r20, 208(%r1)  # save R20
    std  %r21, 216(%r1)  # save R21
    std  %r22, 224(%r1)  # save R22
    std  %r23, 232(%r1)  # save R23
    std  %r24, 240(%r1)  # save R24
    std  %r25, 248(%r1)  # save R25
    std  %r26, 256(%r1)  # save R26
    std  %r27, 264(%r1)  # save R27
    std  %r28, 272(%r1)  # save R28
    std  %r29, 280(%r1)  # save R29
    std  %r30, 288(%r1)  # save R30
    std  %r31, 296(%r1)  # save R31

    # save CR
    mfcr  %r0
    std  %r0, 304(%r1)
    # save LR
    mflr  %r0
    std  %r0, 312(%r1)
    # save LR as PC
    std  %r0, 320(%r1)

    # test if fpu env should be preserved
    cmpwi  cr7, %r6, 0
    beq  cr7, 1f

    stfd  %f14, 0(%r1)  # save F14
    stfd  %f15, 8(%r1)  # save F15
    stfd  %f16, 16(%r1)  # save F16
    stfd  %f17, 24(%r1)  # save F17
    stfd  %f18, 32(%r1)  # save F18
    stfd  %f19, 40(%r1)  # save F19
    stfd  %f20, 48(%r1)  # save F20
    stfd  %f21, 56(%r1)  # save F21
    stfd  %f22, 64(%r1)  # save F22
    stfd  %f23, 72(%r1)  # save F23
    stfd  %f24, 80(%r1)  # save F24
    stfd  %f25, 88(%r1)  # save F25
    stfd  %f26, 96(%r1)  # save F26
    stfd  %f27, 104(%r1)  # save F27
    stfd  %f28, 112(%r1)  # save F28
    stfd  %f29, 120(%r1)  # save F29
    stfd  %f30, 128(%r1)  # save F30
    stfd  %f31, 136(%r1)  # save F31
    mffs  %f0  # load FPSCR
    stfd  %f0, 144(%r1)  # save FPSCR

1:
    # store RSP (pointing to context-data) in R3
    std  %r1, 0(%r3)

    # restore RSP (pointing to context-data) from R4
    mr  %r1, %r4

    # test if fpu env should be preserved
    cmpwi  cr7, %r6, 0
    beq  cr7, 2f

    lfd  %f14, 0(%r1)  # restore F14
    lfd  %f15, 8(%r1)  # restore F15
    lfd  %f16, 16(%r1)  # restore F16
    lfd  %f17, 24(%r1)  # restore F17
    lfd  %f18, 32(%r1)  # restore F18
    lfd  %f19, 40(%r1)  # restore F19
    lfd  %f20, 48(%r1)  # restore F20
    lfd  %f21, 56(%r1)  # restore F21
    lfd  %f22, 64(%r1)  # restore F22
    lfd  %f23, 72(%r1)  # restore F23
    lfd  %f24, 80(%r1)  # restore F24
    lfd  %f25, 88(%r1)  # restore F25
    lfd  %f26, 96(%r1)  # restore F26
    lfd  %f27, 104(%r1)  # restore F27
    lfd  %f28, 112(%r1)  # restore F28
    lfd  %f29, 120(%r1)  # restore F29
    lfd  %f30, 128(%r1)  # restore F30
    lfd  %f31, 136(%r1)  # restore F31
    lfd  %f0,  144(%r1)  # load FPSCR
    mtfsf  0xff, %f0  # restore FPSCR

2:
#if _CALL_ELF != 2
    ld  %r2,  152(%r1)  # restore TOC
#endif
    ld  %r14, 160(%r1)  # restore R14
    ld  %r15, 168(%r1)  # restore R15
    ld  %r16, 176(%r1)  # restore R16
    ld  %r17, 184(%r1)  # restore R17
    ld  %r18, 192(%r1)  # restore R18
    ld  %r19, 200(%r1)  # restore R19
    ld  %r20, 208(%r1)  # restore R20
    ld  %r21, 216(%r1)  # restore R21
    ld  %r22, 224(%r1)  # restore R22
    ld  %r23, 232(%r1)  # restore R23
    ld  %r24, 240(%r1)  # restore R24
    ld  %r25, 248(%r1)  # restore R25
    ld  %r26, 256(%r1)  # restore R26
    ld  %r27, 264(%r1)  # restore R27
    ld  %r28, 272(%r1)  # restore R28
    ld  %r29, 280(%r1)  # restore R29
    ld  %r30, 288(%r1)  # restore R30
    ld  %r31, 296(%r1)  # restore R31

    # restore CR
    ld  %r0, 304(%r1)
    mtcr  %r0
    # restore LR
    ld  %r0, 312(%r1)
    mtlr  %r0

    # load PC
    ld  %r12, 320(%r1)
    # restore CTR
    mtctr  %r12

    # adjust stack
    addi  %r1, %r1, 328

    # use third arg as return value after jump
    # use third arg as first arg in context function
    mr  %r3, %r5

    # jump to context
    bctr
#if _CALL_ELF == 2
	.size jump_fcontext, .-jump_fcontext
#else
# ifdef _CALL_LINUX
	.size .jump_fcontext, .-.L.jump_fcontext
# else
	.size .jump_fcontext, .-.jump_fcontext
# endif
#endif


/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_ppc64_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   |    R13    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  |    R14    |    R15    |     R16   |    R17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  |    R18    |    R19    |    R20    |    R21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |  60 |  61 |  62 |  63 |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 | 240 | 244 | 248 | 252 |  *
 *  -------------------------------------------------  *
 *  |    R22    |    R23    |    R24    |    R25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  64 |  65 |  66 |  67 |  68 |  69 |  70 |  71 |  *
 *  -------------------------------------------------  *
 *  | 256 | 260 | 264 | 268 | 272 | 276 | 280 | 284 |  *
 *  -------------------------------------------------  *
 *  |    R26    |    R27    |    R28    |    R29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  72 |  73 |  74 |  75 |  76 |  77 |  78 |  79 |  *
 *  -------------------------------------------------  *
 *  | 288 | 292 | 296 | 300 | 304 | 308 | 312 | 316 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |    R30    |    R31    |     CR    |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  80 |  81 |                                   |  *
 *  -------------------------------------------------  *
 *  | 320 | 324 |                                   |  *
 *  -------------------------------------------------  *
 *  |    PC     |                                   |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.align 2
.globl jump_fcontext

_jump_fcontext:
    ; reserve space on stack
    subi  r1, r1, 328

    std  r13, 152(r1)  ; save R13
    std  r14, 160(r1)  ; save R14
    std  r15, 168(r1)  ; save R15
    std  r16, 176(r1)  ; save R16
    std  r17, 184(r1)  ; save R17
    std  r18, 192(r1)  ; save R18
    std  r19, 200(r1)  ; save R19
    std  r20, 208(r1)  ; save R20
    std  r21, 216(r1)  ; save R21
    std  r22, 224(r1)  ; save R22
    std  r23, 232(r1)  ; save R23
    std  r24, 240(r1)  ; save R24
    std  r25, 248(r1)  ; save R25
    std  r26, 256(r1)  ; save R26
    std  r27, 264(r1)  ; save R27
    std  r28, 272(r1)  ; save R28
    std  r29, 280(r1)  ; save R29
    std  r30, 288(r1)  ; save R30
    std  r31, 296(r1)  ; save R31

    ; save CR
    mfcr  r0
    std  r0, 304(r1)
    ; save LR
    mflr  r0
    std  r0, 312(r1)
    ; save LR as PC
    std  r0, 320(r1)

    ; test if fpu env should be preserved
    cmpwi  cr7, r6, 0
    beq  cr7, l1

    stfd  f14, 0(r1)  ; save F14
    stfd  f15, 8(r1)  ; save F15
    stfd  f16, 16(r1)  ; save F16
    stfd  f17, 24(r1)  ; save F17
    stfd  f18, 32(r1)  ; save F18
    stfd  f19, 40(r1)  ; save F19
    stfd  f20, 48(r1)  ; save F20
    stfd  f21, 56(r1)  ; save F21
    stfd  f22, 64(r1)  ; save F22
    stfd  f23, 72(r1)  ; save F23
    stfd  f24, 80(r1)  ; save F24
    stfd  f25, 88(r1)  ; save F25
    stfd  f26, 96(r1)  ; save F26
    stfd  f27, 104(r1)  ; save F27
    stfd  f28, 112(r1)  ; save F28
    stfd  f29, 120(r1)  ; save F29
    stfd  f30, 128(r1)  ; save F30
    stfd  f31, 136(r1)  ; save F31
    mffs  f0  ; load FPSCR
    stfd  f0, 144(r1)  ; save FPSCR

l1:
    ; store RSP (pointing to context-data) in R3
    stw  r1, 0(r3)

    ; restore RSP (pointing to context-data) from R4
    mr  r1, r4

    ; test if fpu env should be preserved
    cmpwi  cr7, r6, 0
    beq  cr7, l2

    lfd  f14, 0(r1)  ; restore F14
    lfd  f15, 8(r1)  ; restore F15
    lfd  f16, 16(r1)  ; restore F16
    lfd  f17, 24(r1)  ; restore F17
    lfd  f18, 32(r1)  ; restore F18
    lfd  f19, 40(r1)  ; restore F19
    lfd  f20, 48(r1)  ; restore F20
    lfd  f21, 56(r1)  ; restore F21
    lfd  f22, 64(r1)  ; restore F22
    lfd  f23, 72(r1)  ; restore F23
    lfd  f24, 80(r1)  ; restore F24
    lfd  f25, 88(r1)  ; restore F25
    lfd  f26, 96(r1)  ; restore F26
    lfd  f27, 104(r1)  ; restore F27
    lfd  f28, 112(r1)  ; restore F28
    lfd  f29, 120(r1)  ; restore F29
    lfd  f30, 128(r1)  ; restore F30
    lfd  f31, 136(r1)  ; restore F31
    lfd  f0,  144(r1)  ; load FPSCR
    mtfsf  0xff, f0  ; restore FPSCR

2:
    ld  r13, 152(r1)  ; restore R13
    ld  r14, 160(r1)  ; restore R14
    ld  r15, 168(r1)  ; restore R15
    ld  r16, 176(r1)  ; restore R16
    ld  r17, 184(r1)  ; restore R17
    ld  r18, 192(r1)  ; restore R18
    ld  r19, 200(r1)  ; restore R19
    ld  r20, 208(r1)  ; restore R20
    ld  r21, 216(r1)  ; restore R21
    ld  r22, 224(r1)  ; restore R22
    ld  r23, 232(r1)  ; restore R23
    ld  r24, 240(r1)  ; restore R24
    ld  r25, 248(r1)  ; restore R25
    ld  r26, 256(r1)  ; restore R26
    ld  r27, 264(r1)  ; restore R27
    ld  r28, 272(r1)  ; restore R28
    ld  r29, 280(r1)  ; restore R29
    ld  r30, 288(r1)  ; restore R30
    ld  r31, 296(r1)  ; restore R31

    ; restore CR
    ld  r0, 304(r1)
    mtcr  r0
    ; restore LR
    ld  r0, 312(r1)
    mtlr  r0

    ; load PC
    ld  r0, 320(r1)
    ; restore CTR
    mtctr  r0

    ; adjust stack
    addi  r1, r1, 328

    ; use third arg as return value after jump
    ; use third arg as first arg in context function
    mr  r3, r5

    ; jump to context
    bctr

```

`ThirdParty/Boost.Context/asm/jump_ppc64_sysv_xcoff_gas.S`:

```S
.align 2
.globl .jump_fcontext
.jump_fcontext:
    # reserve space on stack
    subi  1, 1, 328

    std  13, 152(1)  # save R13
    std  14, 160(1)  # save R14
    std  15, 168(1)  # save R15
    std  16, 176(1)  # save R16
    std  17, 184(1)  # save R17
    std  18, 192(1)  # save R18
    std  19, 200(1)  # save R19
    std  20, 208(1)  # save R20
    std  21, 216(1)  # save R21
    std  22, 224(1)  # save R22
    std  23, 232(1)  # save R23
    std  24, 240(1)  # save R24
    std  25, 248(1)  # save R25
    std  26, 256(1)  # save R26
    std  27, 264(1)  # save R27
    std  28, 272(1)  # save R28
    std  29, 280(1)  # save R29
    std  30, 288(1)  # save R30
    std  31, 296(1)  # save R31

    # save CR
    mfcr  0
    std  0, 304(1)
    # save LR
    mflr  0
    std  0, 312(1)
    # save LR as PC
    std  0, 320(1)

    # test if fpu env should be preserved
    cmpwi  7, 6, 0
    beq  7, label1

    stfd  14, 0(1)  # save F14
    stfd  15, 8(1)  # save F15
    stfd  16, 16(1)  # save F16
    stfd  17, 24(1)  # save F17
    stfd  18, 32(1)  # save F18
    stfd  19, 40(1)  # save F19
    stfd  20, 48(1)  # save F20
    stfd  21, 56(1)  # save F21
    stfd  22, 64(1)  # save F22
    stfd  23, 72(1)  # save F23
    stfd  24, 80(1)  # save F24
    stfd  25, 88(1)  # save F25
    stfd  26, 96(1)  # save F26
    stfd  27, 104(1)  # save F27
    stfd  28, 112(1)  # save F28
    stfd  29, 120(1)  # save F29
    stfd  30, 128(1)  # save F30
    stfd  31, 136(1)  # save F31
    mffs  0  # load FPSCR
    stfd  0, 144(1)  # save FPSCR

label1:
    # store RSP (pointing to context-data) in R3
    stw  1, 0(3)

    # restore RSP (pointing to context-data) from R4
    mr  1, 4

    # test if fpu env should be preserved
    cmpwi  7, 6, 0
    beq  7, label2

    lfd  14, 0(1)  # restore F14
    lfd  15, 8(1)  # restore F15
    lfd  16, 16(1)  # restore F16
    lfd  17, 24(1)  # restore F17
    lfd  18, 32(1)  # restore F18
    lfd  19, 40(1)  # restore F19
    lfd  20, 48(1)  # restore F20
    lfd  21, 56(1)  # restore F21
    lfd  22, 64(1)  # restore F22
    lfd  23, 72(1)  # restore F23
    lfd  24, 80(1)  # restore F24
    lfd  25, 88(1)  # restore F25
    lfd  26, 96(1)  # restore F26
    lfd  27, 104(1)  # restore F27
    lfd  28, 112(1)  # restore F28
    lfd  29, 120(1)  # restore F29
    lfd  30, 128(1)  # restore F30
    lfd  31, 136(1)  # restore F31
    lfd  0,  144(1)  # load FPSCR
    mtfsf  0xff, 0  # restore FPSCR

label2:
    ld  13, 152(1)  # restore R13
    ld  14, 160(1)  # restore R14
    ld  15, 168(1)  # restore R15
    ld  16, 176(1)  # restore R16
    ld  17, 184(1)  # restore R17
    ld  18, 192(1)  # restore R18
    ld  19, 200(1)  # restore R19
    ld  20, 208(1)  # restore R20
    ld  21, 216(1)  # restore R21
    ld  22, 224(1)  # restore R22
    ld  23, 232(1)  # restore R23
    ld  24, 240(1)  # restore R24
    ld  25, 248(1)  # restore R25
    ld  26, 256(1)  # restore R26
    ld  27, 264(1)  # restore R27
    ld  28, 272(1)  # restore R28
    ld  29, 280(1)  # restore R29
    ld  30, 288(1)  # restore R30
    ld  31, 296(1)  # restore R31

    # restore CR
    ld  0, 304(1)
    mtcr  0
    # restore LR
    ld  0, 312(1)
    mtlr  0

    # load PC
    ld  0, 320(1)
    # restore CTR
    mtctr  0

    # adjust stack
    addi  1, 1, 328

    # use third arg as return value after jump
    # use third arg as first arg in context function
    mr  3, 5

    # jump to context
    bctr

```

`ThirdParty/Boost.Context/asm/jump_sparc64_sysv_elf_gas.S`:

```S
/*
            Copyright Martin Husemann 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************************
 *                                                                 *
 *  -------------------------------------------------------------  *
 *  |  Offset (in 4 or 8 byte units) | Content                  |  *
 *  -------------------------------------------------------------  *
 *  | 0                              | %sp                      |  *
 *  -------------------------------------------------------------  *
 *  | 1                              | %pc                      |  *
 *  -------------------------------------------------------------  *
 *  | 2                              | %i7 (return address)     |  *
 *  -------------------------------------------------------------  *
 *  | 3                              | %g1                      |  *
 *  -------------------------------------------------------------  *
 *  | 4                              | %g2                      |  *
 *  -------------------------------------------------------------  *
 *  | 5                              | %g3                      |  *
 *  -------------------------------------------------------------  *
 *  | 6                              | %g6                      |  *
 *  -------------------------------------------------------------  *
 *  | 7                              | %g7                      |  *
 *  -------------------------------------------------------------  *
 *    The local and in registers are stored on the stack.          *
 *******************************************************************/

#define OFF(N)	(8*(N))
#define CCFSZ   176		// C Compiler Frame Size
#define BIAS    (2048-1)	// Stack offset for 64 bit programs
#define FC_SZ   448		// sizeof(fcontext_t)
#define FC_STK  384		// offsetof(fcontext_t, fc_stack)
#define FC_FPU  0		// offsetof(fcontext_t, fc_fp)
#define FC_FSR  264		// offsetof(fcontext_t, fc_fp.fp_fsr)
#define FC_FPRS 256		// offsetof(fcontext_t, fc_fp.fp_fprs)
#define FC_GREG 320		// offsetof(fcontext_t, fc_greg)
#define BLOCK_SIZE  64

    .register %g2,#ignore
    .register %g3,#ignore
    .register %g6,#ignore

.text
.globl jump_fcontext
.align 4
.type jump_fcontext,@function
// intptr_t
// jump_fcontext( fcontext_t * ofc, fcontext_t const* nfc, intptr_t vp,
//                bool preserve_fpu = true);
jump_fcontext:
    // %o0 = pointer to old fcontext, save current state here
    // %o1 = new context to jump to
    // %o2 = new return value in context %o0
    // %o3 = preserve fpu registers
    // Save current state in %o0 fcontext, then activate %o1.
    // If %o3, include fpu registers.

    flushw // make sure all shadow registers are up to date in the current stack

    // save current state to fcontext_t at %o0
    stx %sp, [%o0 + FC_GREG + OFF(0)]    // current stack pointer
    add %o7, 8, %o4         // calculate next instruction past call
    stx %o4, [%o0 + FC_GREG + OFF(1)]    // and store it as %pc in save context
    stx %o7, [%o0 + FC_GREG + OFF(2)]
    stx %g1, [%o0 + FC_GREG + OFF(3)]
    stx %g2, [%o0 + FC_GREG + OFF(4)]
    stx %g3, [%o0 + FC_GREG + OFF(5)]
    stx %g6, [%o0 + FC_GREG + OFF(6)]
    stx %g7, [%o0 + FC_GREG + OFF(7)]

    // do we need to handle fpu?
    brz %o3, Lno_fpu
    nop

    add %o0, FC_FPU, %o5
    stda %f0, [%o5] 0xf0 /* ASI_BLOCK_PRIMARY */
    add %o5, BLOCK_SIZE, %o5
    stda %f16, [%o5] 0xf0
    add %o5, BLOCK_SIZE, %o5
    stda %f32, [%o5] 0xf0
    add %o5, BLOCK_SIZE, %o5
    stda %f48, [%o5] 0xf0
    stx %fsr, [%o0+FC_FSR]
    rd %fprs, %o4
    stx %o4, [%o0+FC_FPRS]

    add %o1, FC_FPU, %o5
    ldda [%o5] 0xf0 /* ASI_BLOCK_PRIMARY */, %f0
    add %o5, BLOCK_SIZE, %o5
    ldda [%o5] 0xf0, %f16
    add %o5, BLOCK_SIZE, %o5
    ldda [%o5] 0xf0, %f32
    add %o5, BLOCK_SIZE, %o5
    ldda [%o5] 0xf0, %f48
    ldx [%o1+FC_FSR], %fsr
    ldx [%o1+FC_FPRS], %o4
    wr %o4,0,%fprs

Lno_fpu:
    // load new state from %o1
    ldx [%o1 + FC_GREG + OFF(1)], %o4
    ldx [%o1 + FC_GREG + OFF(2)], %o7
    ldx [%o1 + FC_GREG + OFF(3)], %g1
    ldx [%o1 + FC_GREG + OFF(4)], %g2
    ldx [%o1 + FC_GREG + OFF(5)], %g3
    ldx [%o1 + FC_GREG + OFF(6)], %g6
    ldx [%o1 + FC_GREG + OFF(7)], %g7
    // switch to new stack
    ldx [%o1 + FC_GREG + OFF(0)], %sp
    // and now reload from this stack the shadow regist bank contents
    ldx [%sp + BIAS + OFF(0)], %l0
    ldx [%sp + BIAS + OFF(1)], %l1
    ldx [%sp + BIAS + OFF(2)], %l2
    ldx [%sp + BIAS + OFF(3)], %l3
    ldx [%sp + BIAS + OFF(4)], %l4
    ldx [%sp + BIAS + OFF(5)], %l5
    ldx [%sp + BIAS + OFF(6)], %l6
    ldx [%sp + BIAS + OFF(7)], %l7
    ldx [%sp + BIAS + OFF(8)], %i0
    ldx [%sp + BIAS + OFF(9)], %i1
    ldx [%sp + BIAS + OFF(10)], %i2
    ldx [%sp + BIAS + OFF(11)], %i3
    ldx [%sp + BIAS + OFF(12)], %i4
    ldx [%sp + BIAS + OFF(13)], %i5
    ldx [%sp + BIAS + OFF(14)], %i6
    ldx [%sp + BIAS + OFF(15)], %i7

    // finally continue execution in new context
    jmp %o4
    mov %o2, %o0    // return arg as result

.size jump_fcontext,.-jump_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_sparc_sysv_elf_gas.S`:

```S
/*
            Copyright Martin Husemann 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************************
 *                                                                 *
 *  -------------------------------------------------------------  *
 *  |  Offset (in 4 or 8 byte units) | Content                  |  *
 *  -------------------------------------------------------------  *
 *  | 0                              | %sp                      |  *
 *  -------------------------------------------------------------  *
 *  | 1                              | %pc                      |  *
 *  -------------------------------------------------------------  *
 *  | 2                              | %i7 (return address)     |  *
 *  -------------------------------------------------------------  *
 *  | 3                              | %g1                      |  *
 *  -------------------------------------------------------------  *
 *  | 4                              | %g2                      |  *
 *  -------------------------------------------------------------  *
 *  | 5                              | %g3                      |  *
 *  -------------------------------------------------------------  *
 *  | 6                              | %g6                      |  *
 *  -------------------------------------------------------------  *
 *  | 7                              | %g7                      |  *
 *  -------------------------------------------------------------  *
 *    The local and in registers are stored on the stack.          *
 *******************************************************************/

#define OFF(N)  (4*(N))
#define CCFSZ   96
#define FC_SZ   176
#define FC_stK  168     // offsetof(fcontext_t, fc_stack)
#define FC_FPU  0       // offsetof(fcontext_t, fc_fp)
#define FC_FSR  128     // offsetof(fcontext_t, fc_fp.fp_fsr)
#define FC_GREG 136     // offsetof(fcontext_t, fc_greg)
#define BLOCK_SIZE 8
#ifdef __NetBSD__
#define FLUSHW  t 0x83; nop // T_FLUSHWIN
#endif

.text
.globl jump_fcontext
.align 4
.type jump_fcontext,@function
// intptr_t
// jump_fcontext( fcontext_t * ofc, fcontext_t const* nfc, intptr_t vp,
//                bool preserve_fpu = true);
jump_fcontext:
    // %o0 = pointer to old fcontext, save current state here
    // %o1 = new context to jump to
    // %o2 = new return value in context %o0
    // %o3 = preserve fpu registers
    // Save current state in %o0 fcontext, then activate %o1.
    // If %o3, include fpu registers.

    FLUSHW // make sure all shadow registers are up to date in the current stack

    // save current state to fcontext_t at %o0
    st %sp, [%o0 + FC_GREG + OFF(0)]    // current stack pointer
    add %o7, 8, %o4         // calculate next instruction past call
    st %o4, [%o0 + FC_GREG + OFF(1)]    // and store it as %pc in save context
    st %o7, [%o0 + FC_GREG + OFF(2)]
    st %g1, [%o0 + FC_GREG + OFF(3)]
    st %g2, [%o0 + FC_GREG + OFF(4)]
    st %g3, [%o0 + FC_GREG + OFF(5)]
    st %g6, [%o0 + FC_GREG + OFF(6)]
    st %g7, [%o0 + FC_GREG + OFF(7)]

    // do we need to handle fpu?
    cmp %o3, 0
    bz Lno_fpu
    nop

    add %o0, FC_FPU, %o5
    std %f0, [%o5]
    std %f2, [%o5+0x08]
    std %f4, [%o5+0x10]
    std %f6, [%o5+0x18]
    std %f8, [%o5+0x20]
    std %f10, [%o5+0x28]
    std %f12, [%o5+0x30]
    std %f14, [%o5+0x38]
    st %fsr, [%o0+FC_FSR]

    add %o1, FC_FPU, %o5
    ldd [%o5], %f0
    ldd [%o5+0x08], %f2
    ldd [%o5+0x10], %f4
    ldd [%o5+0x18], %f6
    ldd [%o5+0x20], %f8
    ldd [%o5+0x28], %f10
    ldd [%o5+0x30], %f12
    ldd [%o5+0x38], %f14
    ld [%o1+FC_FSR], %fsr

Lno_fpu:
    // load new state from %o1
    ld [%o1 + FC_GREG + OFF(1)], %o4
    ld [%o1 + FC_GREG + OFF(2)], %o7
    ld [%o1 + FC_GREG + OFF(3)], %g1
    ld [%o1 + FC_GREG + OFF(4)], %g2
    ld [%o1 + FC_GREG + OFF(5)], %g3
    ld [%o1 + FC_GREG + OFF(6)], %g6
    ld [%o1 + FC_GREG + OFF(7)], %g7
    // switch to new stack
    ld [%o1 + FC_GREG + OFF(0)], %sp
    // and now reload from this stack the shadow regist bank contents
    ld [%sp + OFF(0)], %l0
    ld [%sp + OFF(1)], %l1
    ld [%sp + OFF(2)], %l2
    ld [%sp + OFF(3)], %l3
    ld [%sp + OFF(4)], %l4
    ld [%sp + OFF(5)], %l5
    ld [%sp + OFF(6)], %l6
    ld [%sp + OFF(7)], %l7
    ld [%sp + OFF(8)], %i0
    ld [%sp + OFF(9)], %i1
    ld [%sp + OFF(10)], %i2
    ld [%sp + OFF(11)], %i3
    ld [%sp + OFF(12)], %i4
    ld [%sp + OFF(13)], %i5
    ld [%sp + OFF(14)], %i6
    ld [%sp + OFF(15)], %i7

    // finally continue execution in new context
    jmp %o4
    mov %o2, %o0    // return arg as result

.size jump_fcontext,.-jump_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_x86_64_ms_pe_gas.asm`:

```asm
/*
            Copyright Oliver Kowalke 2009.
            Copyright Thomas Sailer 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------
 *  |    0    |    1    |                                                            |
 *  ----------------------------------------------------------------------------------
 *  |   0x0   |   0x4   |                                                            |
 *  ----------------------------------------------------------------------------------
 *  |    <indicator>    |                                                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    2    |    3    |    4     |    5    |    6    |    7    |    8    |    9    |
 *  ----------------------------------------------------------------------------------
 *  |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |   0x20  |   0x24  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |   10    |   11    |    12    |    13   |    14   |    15   |    16   |    17   |
 *  ----------------------------------------------------------------------------------
 *  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |   0x40  |   0x44  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    18   |    19   |    20   |    21    |    22   |    23   |    24   |    25   |
 *  ----------------------------------------------------------------------------------
 *  |   0x48  |   0x4c  |   0x50  |   0x54   |   0x58  |   0x5c  |  0x60   |   0x64  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    26   |    27   |    28    |   29    |    30   |    31   |    32   |    33   |
 *  ----------------------------------------------------------------------------------
 *  |   0x68  |   0x6c  |   0x70   |   0x74  |   0x78  |   0x7c  |   0x80  |   0x84  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    34    |   35   |    36    |    37   |    38   |    39   |    40   |    41   |
 *  ----------------------------------------------------------------------------------
 *  |   0x88   |  0x8c  |   0x90   |   0x94  |   0x98  |   0x9c  |   0xa0  |   0xa4  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    42   |    43   |    44    |    45   |    46   |    47   |    48   |    49   |
 *  ----------------------------------------------------------------------------------
 *  |   0xa8  |   0xac  |   0xb0   |   0xb4  |   0xb8  |   0xbc  |   0xc0  |   0xc4  |
 *  ----------------------------------------------------------------------------------
 *  | fc_mxcsr|fc_x87_cw|     <alignment>    |      fbr_strg     |      fc_dealloc   |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    50   |   51    |    52    |    53   |    54   |    55   |    56   |    57   |
 *  ----------------------------------------------------------------------------------
 *  |   0xc8  |  0xcc   |   0xd0   |   0xd4  |   0xd8  |   0xdc  |   0xe0  |   0xe4  |
 *  ----------------------------------------------------------------------------------
 *  |      limit        |       base         |      R12          |        R13        |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    58   |    59   |    60   |    61    |    62   |    63   |    64   |    65   |
 *  ----------------------------------------------------------------------------------
 *  |   0xe8  |   0xec  |   0xf0  |   0xf4   |   0xf8  |   0xfc  |  0x100  |  0x104  |
 *  ----------------------------------------------------------------------------------
 *  |        R14        |        R15         |       RDI         |       RSI         |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    66   |   67    |    68    |   69    |    70   |  71     |    72   |    73   |
 *  ----------------------------------------------------------------------------------
 *  |  0x108  |  0x10c  |  0x110   |  0x114  |  0x118  |  0x11c  |  0x120  |  0x124  |
 *  ----------------------------------------------------------------------------------
 *  |        RBX        |         RBP        |        RIP        |       EXIT        |
 *  ----------------------------------------------------------------------------------
 *                                                                                      *
 * *************************************************************************************/

.file	"jump_x86_64_ms_pe_gas.asm"
.text
.p2align 4,,15
.globl	jump_fcontext
.def	jump_fcontext;	.scl	2;	.type	32;	.endef
.seh_proc	jump_fcontext
jump_fcontext:
.seh_endprologue

    pushq  %rbp  /* save RBP */
    pushq  %rbx  /* save RBX */
    pushq  %rsi  /* save RSI */
    pushq  %rdi  /* save RDI */
    pushq  %r15  /* save R15 */
    pushq  %r14  /* save R14 */
    pushq  %r13  /* save R13 */
    pushq  %r12  /* save R12 */

    /* load NT_TIB */
    movq  %gs:(0x30), %r10
    /* save current stack base */
    movq  0x08(%r10), %rax
    pushq  %rax
    /* save current stack limit */
    movq  0x10(%r10), %rax
    pushq  %rax
    /* save current deallocation stack */
    movq  0x1478(%r10), %rax
    pushq  %rax
    /* save fiber local storage */
    movq  0x18(%r10), %rax
    pushq  %rax

    /* prepare stack for FPU */
    leaq  -0xa8(%rsp), %rsp

    /* test for flag preserve_fpu */
    testq  %r9, %r9
    je  1f

    /* save MMX control- and status-word */
    stmxcsr  0xa0(%rsp)
    /* save x87 control-word */
    fnstcw  0xa4(%rsp)

    /* save XMM storage */
    movaps  %xmm6, (%rsp)
    movaps  %xmm7, 0x10(%rsp)
    movaps  %xmm8, 0x20(%rsp)
    movaps  %xmm9, 0x30(%rsp)
    movaps  %xmm10, 0x40(%rsp)
    movaps  %xmm11, 0x50(%rsp)
    movaps  %xmm12, 0x60(%rsp)
    movaps  %xmm13, 0x70(%rsp)
    movaps  %xmm14, 0x80(%rsp)
    movaps  %xmm15, 0x90(%rsp)

1:
    /* set R10 to zero */
    xorq  %r10, %r10
    /* set indicator */
    pushq  %r10

    /* store RSP (pointing to context-data) in RCX */
    movq  %rsp, (%rcx)

    /* restore RSP (pointing to context-data) from RDX */
    movq  %rdx, %rsp

    /* load indicator */
    popq  %r10

    /* test for flag preserve_fpu */
    testq  %r9, %r9
    je  2f

    /* restore MMX control- and status-word */
    ldmxcsr  0xa0(%rsp)
    /* save x87 control-word */
    fldcw  0xa4(%rsp)

    /* restore XMM storage */
    movaps  (%rsp), %xmm6
    movaps  0x10(%rsp), %xmm7
    movaps  0x20(%rsp), %xmm8
    movaps  0x30(%rsp), %xmm9
    movaps  0x40(%rsp), %xmm10
    movaps  0x50(%rsp), %xmm11
    movaps  0x60(%rsp), %xmm12
    movaps  0x70(%rsp), %xmm13
    movaps  0x80(%rsp), %xmm14
    movaps  0x90(%rsp), %xmm15

2:
    /* set offset of stack */
    movq  0xa8, %rcx

    /* test for indicator */
    testq  %r10, %r10
    je  3f

    addq  0x8, %rcx

3:
    /* prepare stack for FPU */
    leaq (%rsp,%rcx), %rsp

    /* load NT_TIB */
    movq  %gs:(0x30), %r10
    /* restore fiber local storage */
    popq  %rax
    movq  %rax, 0x18(%r10)
    /* restore deallocation stack */
    popq  %rax
    movq  %rax, 0x1478(%r10)
    /* restore stack limit */
    popq  %rax
    movq  %rax, 0x10(%r10)
    /* restore stack base */
    popq  %rax
    movq  %rax, 0x8(%r10)

    popq  %r12  /* restore R12 */
    popq  %r13  /* restore R13 */
    popq  %r14  /* restore R14 */
    popq  %r15  /* restore R15 */
    popq  %rdi  /* restore RDI */
    popq  %rsi  /* restore RSI */
    popq  %rbx  /* restore RBX */
    popq  %rbp  /* restore RBP */

    /* restore return-address */
    popq  %r10

    /* use third arg as return-value after jump */
    movq  %r8, %rax
    /* use third arg as first arg in context function */
    movq  %r8, %rcx

    /* indirect jump to context */
    jmp  *%r10
.seh_endproc

```

`ThirdParty/Boost.Context/asm/jump_x86_64_ms_pe_masm.asm`:

```asm

;           Copyright Oliver Kowalke 2009.
;  Distributed under the Boost Software License, Version 1.0.
;     (See accompanying file LICENSE_1_0.txt or copy at
;           http://www.boost.org/LICENSE_1_0.txt)

;  ----------------------------------------------------------------------------------
;  |    0    |    1    |                                                            |
;  ----------------------------------------------------------------------------------
;  |   0x0   |   0x4   |                                                            |
;  ----------------------------------------------------------------------------------
;  |    <indicator>    |                                                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    2    |    3    |    4     |    5    |    6    |    7    |    8    |    9    |
;  ----------------------------------------------------------------------------------
;  |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |   0x20  |   0x24  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |   10    |   11    |    12    |    13   |    14   |    15   |    16   |    17   |
;  ----------------------------------------------------------------------------------
;  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |   0x40  |   0x44  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    18   |    19   |    20   |    21    |    22   |    23   |    24   |    25   |
;  ----------------------------------------------------------------------------------
;  |   0x48  |   0x4c  |   0x50  |   0x54   |   0x58  |   0x5c  |  0x60   |   0x64  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    26   |    27   |    28    |   29    |    30   |    31   |    32   |    33   |
;  ----------------------------------------------------------------------------------
;  |   0x68  |   0x6c  |   0x70   |   0x74  |   0x78  |   0x7c  |   0x80  |   0x84  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    34    |   35   |    36    |    37   |    38   |    39   |    40   |    41   |
;  ----------------------------------------------------------------------------------
;  |   0x88   |  0x8c  |   0x90   |   0x94  |   0x98  |   0x9c  |   0xa0  |   0xa4  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    42   |    43   |    44    |    45   |    46   |    47   |    48   |    49   |
;  ----------------------------------------------------------------------------------
;  |   0xa8  |   0xac  |   0xb0   |   0xb4  |   0xb8  |   0xbc  |   0xc0  |   0xc4  |
;  ----------------------------------------------------------------------------------
;  | fc_mxcsr|fc_x87_cw|     <alignment>    |      fbr_strg     |      fc_dealloc   |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    50   |   51    |    52    |    53   |    54   |    55   |    56   |    57   |
;  ----------------------------------------------------------------------------------
;  |   0xc8  |  0xcc   |   0xd0   |   0xd4  |   0xd8  |   0xdc  |   0xe0  |   0xe4  |
;  ----------------------------------------------------------------------------------
;  |      limit        |       base         |      R12          |        R13        |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    58   |    59   |    60   |    61    |    62   |    63   |    64   |    65   |
;  ----------------------------------------------------------------------------------
;  |   0xe8  |   0xec  |   0xf0  |   0xf4   |   0xf8  |   0xfc  |  0x100  |  0x104  |
;  ----------------------------------------------------------------------------------
;  |        R14        |        R15         |       RDI         |       RSI         |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    66   |   67    |    68    |   69    |    70   |  71     |    72   |    73   |
;  ----------------------------------------------------------------------------------
;  |  0x108  |  0x10c  |  0x110   |  0x114  |  0x118  |  0x11c  |  0x120  |  0x124  |
;  ----------------------------------------------------------------------------------
;  |        RBX        |         RBP        |        RIP        |       EXIT        |
;  ----------------------------------------------------------------------------------

.code

jump_fcontext PROC FRAME
    .endprolog

    push  rbp  ; save RBP
    push  rbx  ; save RBX
    push  rsi  ; save RSI
    push  rdi  ; save RDI
    push  r15  ; save R15
    push  r14  ; save R14
    push  r13  ; save R13
    push  r12  ; save R12

    ; load NT_TIB
    mov  r10,  gs:[030h]
    ; save current stack base
    mov  rax,  [r10+08h]
    push  rax
    ; save current stack limit
    mov  rax, [r10+010h]
    push  rax
    ; save current deallocation stack
    mov  rax, [r10+01478h]
    push  rax
    ; save fiber local storage
    mov  rax, [r10+018h]
    push  rax

    ; prepare stack for FPU
    lea rsp, [rsp-0a8h]

    ; test for flag preserve_fpu
    test  r9, r9
    je  nxt1

    ; save MMX control- and status-word
    stmxcsr  [rsp+0a0h]
    ; save x87 control-word
    fnstcw  [rsp+0a4h]

    ; save XMM storage
    movaps  [rsp], xmm6
    movaps  [rsp+010h], xmm7
    movaps  [rsp+020h], xmm8
    movaps  [rsp+030h], xmm9
    movaps  [rsp+040h], xmm10
    movaps  [rsp+050h], xmm11
    movaps  [rsp+060h], xmm12
    movaps  [rsp+070h], xmm13
    movaps  [rsp+080h], xmm14
    movaps  [rsp+090h], xmm15

nxt1:
    ; set R10 to zero
    xor  r10, r10
    ; set indicator
    push  r10

    ; store RSP (pointing to context-data) in RCX
    mov  [rcx], rsp

    ; restore RSP (pointing to context-data) from RDX
    mov  rsp, rdx

    ; load indicator
    pop  r10

    ; test for flag preserve_fpu
    test  r9, r9
    je  nxt2

    ; restore MMX control- and status-word
    ldmxcsr  [rsp+0a0h]
    ; save x87 control-word
    fldcw   [rsp+0a4h]

    ; restore XMM storage
    movaps  xmm6, [rsp]
    movaps  xmm7, [rsp+010h]
    movaps  xmm8, [rsp+020h]
    movaps  xmm9, [rsp+030h]
    movaps  xmm10, [rsp+040h]
    movaps  xmm11, [rsp+050h]
    movaps  xmm12, [rsp+060h]
    movaps  xmm13, [rsp+070h]
    movaps  xmm14, [rsp+080h]
    movaps  xmm15, [rsp+090h]

nxt2:
    ; set offset of stack
    mov  rcx, 0a8h

    ; test for indicator
    test  r10, r10
    je  nxt3

    add  rcx, 08h

nxt3:
    ; prepare stack for FPU
    lea rsp, [rsp+rcx]

    ; load NT_TIB
    mov  r10, gs:[030h]
    ; restore fiber local storage
    pop  rax
    mov  [r10+018h], rax
    ; restore deallocation stack
    pop  rax
    mov  [r10+01478h], rax
    ; restore stack limit
    pop  rax
    mov  [r10+010h], rax
    ; restore stack base
    pop  rax
    mov  [r10+08h], rax

    pop  r12  ; restore R12
    pop  r13  ; restore R13
    pop  r14  ; restore R14
    pop  r15  ; restore R15
    pop  rdi  ; restore RDI
    pop  rsi  ; restore RSI
    pop  rbx  ; restore RBX
    pop  rbp  ; restore RBP

    ; restore return-address
    pop  r10

    ; use third arg as return-value after jump
    mov  rax, r8
    ; use third arg as first arg in context function
    mov  rcx, r8

    ; indirect jump to context
    jmp  r10
jump_fcontext ENDP
END

```

`ThirdParty/Boost.Context/asm/jump_x86_64_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        R15        |        RBX        |         RBP        |        RIP        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    16   |   17    |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x40  |   0x44  |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        EXIT       |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl jump_fcontext
.type jump_fcontext,@function
.align 16
jump_fcontext:
    pushq  %rbp  /* save RBP */
    pushq  %rbx  /* save RBX */
    pushq  %r15  /* save R15 */
    pushq  %r14  /* save R14 */
    pushq  %r13  /* save R13 */
    pushq  %r12  /* save R12 */

    /* prepare stack for FPU */
    leaq  -0x8(%rsp), %rsp

    /* test for flag preserve_fpu */
    cmp  $0, %rcx
    je  1f

    /* save MMX control- and status-word */
    stmxcsr  (%rsp)
    /* save x87 control-word */
    fnstcw   0x4(%rsp)

1:
    /* store RSP (pointing to context-data) in RDI */
    movq  %rsp, (%rdi)

    /* restore RSP (pointing to context-data) from RSI */
    movq  %rsi, %rsp

    /* test for flag preserve_fpu */
    cmp  $0, %rcx
    je  2f

    /* restore MMX control- and status-word */
    ldmxcsr  (%rsp)
    /* restore x87 control-word */
    fldcw  0x4(%rsp)

2:
    /* prepare stack for FPU */
    leaq  0x8(%rsp), %rsp

    popq  %r12  /* restrore R12 */
    popq  %r13  /* restrore R13 */
    popq  %r14  /* restrore R14 */
    popq  %r15  /* restrore R15 */
    popq  %rbx  /* restrore RBX */
    popq  %rbp  /* restrore RBP */

    /* restore return-address */
    popq  %r8

    /* use third arg as return-value after jump */
    movq  %rdx, %rax
    /* use third arg as first arg in context function */
    movq  %rdx, %rdi

    /* indirect jump to context */
    jmp  *%r8
.size jump_fcontext,.-jump_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/jump_x86_64_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        R15        |        RBX        |         RBP        |        RIP        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    16   |   17    |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x40  |   0x44  |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        EXIT       |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl _jump_fcontext
.align 8
_jump_fcontext:
    pushq  %rbp  /* save RBP */
    pushq  %rbx  /* save RBX */
    pushq  %r15  /* save R15 */
    pushq  %r14  /* save R14 */
    pushq  %r13  /* save R13 */
    pushq  %r12  /* save R12 */

    /* prepare stack for FPU */
    leaq  -0x8(%rsp), %rsp

    /* test for flag preserve_fpu */
    cmp  $0, %rcx
    je  1f

    /* save MMX control- and status-word */
    stmxcsr  (%rsp)
    /* save x87 control-word */
    fnstcw   0x4(%rsp)

1:
    /* store RSP (pointing to context-data) in RDI */
    movq  %rsp, (%rdi)

    /* restore RSP (pointing to context-data) from RSI */
    movq  %rsi, %rsp

    /* test for flag preserve_fpu */
    cmp  $0, %rcx
    je  2f

    /* restore MMX control- and status-word */
    ldmxcsr  (%rsp)
    /* restore x87 control-word */
    fldcw  0x4(%rsp)

2:
    /* prepare stack for FPU */
    leaq  0x8(%rsp), %rsp

    popq  %r12  /* restrore R12 */
    popq  %r13  /* restrore R13 */
    popq  %r14  /* restrore R14 */
    popq  %r15  /* restrore R15 */
    popq  %rbx  /* restrore RBX */
    popq  %rbp  /* restrore RBP */

    /* restore return-address */
    popq  %r8

    /* use third arg as return-value after jump */
    movq  %rdx, %rax
    /* use third arg as first arg in context function */
    movq  %rdx, %rdi

    /* indirect jump to context */
    jmp  *%r8

```

`ThirdParty/Boost.Context/asm/make_arm64_aapcs_elf_gas.S`:

```S
/*
            Copyright Edward Nevill 2015
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/
/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  |    d8     |    d9     |    d10    |    d11    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  |    d12    |    d13    |    d14    |    d15    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  |    x19    |    x20    |    x21    |    x22    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
 *  -------------------------------------------------  *
 *  |    x23    |    x24    |    x25    |    x26    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
 *  -------------------------------------------------  *
 *  |    x27    |    x28    |    FP     |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 | 43  |           |           |  *
 *  -------------------------------------------------  *
 *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *
 *  -------------------------------------------------  *
 *  |     PC    |   align   |           |           |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.cpu    generic+fp+simd
.text
.align  2
.global make_fcontext
.type   make_fcontext, %function
make_fcontext:
    # shift address in x0 (allocated stack) to lower 16 byte boundary
    and x0, x0, ~0xF

    # reserve space for context-data on context-stack
    sub  x0, x0, #0xb0

    # third arg of make_fcontext() == address of context-function
    # store address as a PC to jump in
    str  x2, [x0, #0xa0]

    # save address of finish as return-address for context-function
    # will be entered after context-function returns (LR register)
    adr  x1, finish
    str  x1, [x0, #0x98]

    ret  x30 // return pointer to context-data (x0)

finish:
    # exit code is zero
    mov  x0, #0
    # exit application
    bl  _exit

.size   make_fcontext,.-make_fcontext
# Mark that we don't need executable stack.
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_arm64_aapcs_macho_gas.S`:

```S
/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  |    d8     |    d9     |    d10    |    d11    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  |    d12    |    d13    |    d14    |    d15    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  |    x19    |    x20    |    x21    |    x22    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *
 *  -------------------------------------------------  *
 *  |    x23    |    x24    |    x25    |    x26    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *
 *  -------------------------------------------------  *
 *  |    x27    |    x28    |    FP     |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 | 43  |           |           |  *
 *  -------------------------------------------------  *
 *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *
 *  -------------------------------------------------  *
 *  |     PC    |   align   |           |           |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/


.text
.globl _make_fcontext
.balign 16

_make_fcontext:
    ; shift address in x0 (allocated stack) to lower 16 byte boundary
    and x0, x0, ~0xF

    ; reserve space for context-data on context-stack
    sub  x0, x0, #0xb0

    ; third arg of make_fcontext() == address of context-function
    ; store address as a PC to jump in
    str  x2, [x0, #0xa0]

    ; compute abs address of label finish
    ; 0x0c = 3 instructions * size (4) before label 'finish'

    ; TODO: Numeric offset since llvm still does not support labels in ADR. Fix:
    ;       http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140407/212336.html
    adr  x1, 0x0c

    ; save address of finish as return-address for context-function
    ; will be entered after context-function returns (LR register)
    str  x1, [x0, #0x98]

    ret  lr ; return pointer to context-data (x0)

finish:
    ; exit code is zero
    mov  x0, #0
    ; exit application
    bl  __exit



```

`ThirdParty/Boost.Context/asm/make_arm_aapcs_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  |  v1 |  v2 |  v3 |  v4 |  v5 |  v6 |  v7 |  v8 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |                                   |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64|                                   |  *
 *  -------------------------------------------------  *
 *  |  lr |  pc |                                   |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl make_fcontext
.align 2
.type make_fcontext,%function
make_fcontext:
    @ shift address in A1 to lower 16 byte boundary
    bic  a1, a1, #15

    @ reserve space for context-data on context-stack
    sub  a1, a1, #104

    @ third arg of make_fcontext() == address of context-function
    str  a3, [a1,#100]

    @ compute abs address of label finish
    adr  a2, finish
    @ save address of finish as return-address for context-function
    @ will be entered after context-function returns
    str  a2, [a1,#96]

    bx  lr @ return pointer to context-data

finish:
    @ exit code is zero
    mov  a1, #0
    @ exit application
    bl  _exit@PLT
.size make_fcontext,.-make_fcontext

@ Mark that we don't need executable stack.
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_arm_aapcs_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
 *  -------------------------------------------------  *
 *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
 *  -------------------------------------------------  *
 *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
 *  -------------------------------------------------  *
 *  | sjlj|  v1 |  v2 |  v3 |  v4 |  v5 |  v6 |  v7 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |                             |  *
 *  -------------------------------------------------  *
 *  | 0x60| 0x64| 0x68|                             |  *
 *  -------------------------------------------------  *
 *  |  v8 |  lr |  pc |                             |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl _make_fcontext
.align 2
_make_fcontext:
    @ shift address in A1 to lower 16 byte boundary
    bic  a1, a1, #15

    @ reserve space for context-data on context-stack
    sub  a1, a1, #108

    @ third arg of make_fcontext() == address of context-function
    str  a3, [a1,#104]

    @ compute abs address of label finish
    adr  a2, finish
    @ save address of finish as return-address for context-function
    @ will be entered after context-function returns
    str  a2, [a1,#100]

    bx  lr @ return pointer to context-data

finish:
    @ exit code is zero
    mov  a1, #0
    @ exit application
    bl  __exit

```

`ThirdParty/Boost.Context/asm/make_arm_aapcs_pe_armasm.asm`:

```asm
;/*
;            Copyright Oliver Kowalke 2009.
;   Distributed under the Boost Software License, Version 1.0.
;      (See accompanying file LICENSE_1_0.txt or copy at
;          http://www.boost.org/LICENSE_1_0.txt)
;*/

; *******************************************************
; *                                                     *
; *  -------------------------------------------------  *
; *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
; *  -------------------------------------------------  *
; *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *
; *  -------------------------------------------------  *
; *  | s16 | s17 | s18 | s19 | s20 | s21 | s22 | s23 |  *
; *  -------------------------------------------------  *
; *  -------------------------------------------------  *
; *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
; *  -------------------------------------------------  *
; *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *
; *  -------------------------------------------------  *
; *  | s24 | s25 | s26 | s27 | s28 | s29 | s30 | s31 |  *
; *  -------------------------------------------------  *
; *  -------------------------------------------------  *
; *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
; *  -------------------------------------------------  *
; *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *
; *  -------------------------------------------------  *
; *  |deall|limit| base|  v1 |  v2 |  v3 |  v4 |  v5 |  *
; *  -------------------------------------------------  *
; *  -------------------------------------------------  *
; *  |  24 |  25 |  26 |  27 |  28 |                 |  *
; *  -------------------------------------------------  *
; *  | 0x60| 0x64| 0x68| 0x6c| 0x70|                 |  *
; *  -------------------------------------------------  *
; *  |  v6 |  v7 |  v8 |  lr |  pc |                 |  *
; *  -------------------------------------------------  *
; *                                                     *
; *******************************************************


    AREA |.text|, CODE
    ALIGN 4
    EXPORT make_fcontext
    IMPORT _exit

make_fcontext PROC
    ; first arg of make_fcontext() == top of context-stack
    ; save top of context-stack (base) A4
    mov  a4, a1

    ; shift address in A1 to lower 16 byte boundary
    bic  a1, a1, #0x0f

    ; reserve space for context-data on context-stack
    sub  a1, a1, #0x74

    ; save top address of context_stack as 'base'
    str  a4, [a1,#0x48]
    ; second arg of make_fcontext() == size of context-stack
    ; compute bottom address of context-stack (limit)
    sub  a4, a4, a2
    ; save bottom address of context-stack as 'limit'
    str  a4, [a1,#0x44]
    ; save bottom address of context-stack as 'dealloction stack'
    str  a4, [a1,#0x40]

    ; third arg of make_fcontext() == address of context-function
    str  a3, [a1,#0x70]

    ; compute abs address of label finish
    adr  a2, finish
    ; save address of finish as return-address for context-function
    ; will be entered after context-function returns
    str  a2, [a1,#0x6c]

    bx  lr ; return pointer to context-data

finish
    ; exit code is zero
    mov  a1, #0
    ; exit application
    bl  _exit

    ENDP
    END

```

`ThirdParty/Boost.Context/asm/make_combined_sysv_macho_gas.S`:

```S
/*
            Copyright Sergue E. Leontiev 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

// Stub file for universal binary

#if defined(__i386__)
    #include "make_i386_sysv_macho_gas.S"
#elif defined(__x86_64__)
    #include "make_x86_64_sysv_macho_gas.S"
#elif defined(__ppc__)
    #include "make_ppc32_sysv_macho_gas.S"
#elif defined(__ppc64__)
    #include "make_ppc64_sysv_macho_gas.S"
#else
    #error "No arch's"
#endif

```

`ThirdParty/Boost.Context/asm/make_i386_ms_pe_gas.asm`:

```asm
/*
            Copyright Oliver Kowalke 2009.
            Copyright Thomas Sailer 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/********************************************************************
  ---------------------------------------------------------------------------------
  |    0    |    1    |    2    |    3    |    4    |    5    |    6    |    7    |
  ---------------------------------------------------------------------------------
  |    0h   |   04h   |   08h   |   0ch   |   010h  |   014h  |   018h  |   01ch  |
  ---------------------------------------------------------------------------------
  | fc_mxcsr|fc_x87_cw| fc_strg |fc_deallo|  limit  |   base  |  fc_seh |   EDI   |
  ---------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------
  |    8    |    9    |   10    |    11   |    12   |    13   |    14   |    15   |
  ---------------------------------------------------------------------------------
  |   020h  |  024h   |  028h   |   02ch  |   030h  |   034h  |   038h  |   03ch  |
  ---------------------------------------------------------------------------------
  |   ESI   |   EBX   |   EBP   |   EIP   |   EXIT  |         | SEH NXT |SEH HNDLR|
  ---------------------------------------------------------------------------------
*******************************************************************/

.file	"make_i386_ms_pe_gas.asm"
.text
.p2align 4,,15
.globl	_make_fcontext
.def	_make_fcontext;	.scl	2;	.type	32;	.endef
_make_fcontext:
    /* first arg of make_fcontext() == top of context-stack */
    movl  0x04(%esp), %eax

    /* reserve space for first argument of context-function */
    /* EAX might already point to a 16byte border */
    leal  -0x08(%eax), %eax

    /* shift address in EAX to lower 16 byte boundary */
    andl  $-16, %eax

    /* reserve space for context-data on context-stack */
    /* size for fc_mxcsr .. EIP + return-address for context-function */
    /* on context-function entry: (ESP -0x4) % 8 == 0 */
    /* additional space is required for SEH */
    leal  -0x3c(%eax), %eax

    /* first arg of make_fcontext() == top of context-stack */
    movl  0x04(%esp), %ecx
    /* save top address of context stack as 'base' */
    movl  %ecx, 0x14(%eax)
    /* second arg of make_fcontext() == size of context-stack */
    movl  0x08(%esp), %edx
    /* negate stack size for LEA instruction (== substraction) */
    negl  %edx
    /* compute bottom address of context stack (limit) */
    leal  (%ecx,%edx), %ecx
    /* save bottom address of context-stack as 'limit' */
    movl  %ecx, 0x10(%eax)
    /* save bottom address of context-stack as 'dealloction stack' */
    movl  %ecx, 0xc(%eax)

    /* third arg of make_fcontext() == address of context-function */
    movl  0xc(%esp), %ecx
    movl  %ecx, 0x2c(%eax)

    /* save MMX control- and status-word */
    stmxcsr  (%eax)
    /* save x87 control-word */
    fnstcw  0x04(%eax)

    /* compute abs address of label finish */
    movl  $finish, %ecx
    /* save address of finish as return-address for context-function */
    /* will be entered after context-function returns */
    movl  %ecx, 0x30(%eax)

    /* traverse current seh chain to get the last exception handler installed by Windows */
    /* note that on Windows Server 2008 and 2008 R2, SEHOP is activated by default */
    /* the exception handler chain is tested for the presence of ntdll.dll!FinalExceptionHandler */
    /* at its end by RaiseException all seh andlers are disregarded if not present and the */
    /* program is aborted */
    /* load NT_TIB into ECX */
    movl  %fs:(0x0), %ecx

walk:
    /* load 'next' member of current SEH into EDX */
    movl  (%ecx), %edx
    /* test if 'next' of current SEH is last (== 0xffffffff) */
    incl  %edx
    jz  found
    decl  %edx
    /* exchange content; ECX contains address of next SEH */
    xchgl  %ecx, %edx
    /* inspect next SEH */
    jmp  walk

found:
    /* load 'handler' member of SEH == address of last SEH handler installed by Windows */
    movl  0x04(%ecx), %ecx
    /* save address in ECX as SEH handler for context */
    movl  %ecx, 0x3c(%eax)
    /* set ECX to -1 */
    movl  $0xffffffff, %ecx
    /* save ECX as next SEH item */
    movl  %ecx, 0x38(%eax)
    /* load address of next SEH item */
    leal  0x38(%eax), %ecx
    /* save next SEH */
    movl  %ecx, 0x18(%eax)

    /* return pointer to context-data */
    ret

finish:
    /* ESP points to same address as ESP on entry of context function + 0x4 */
    xorl  %eax, %eax
    /* exit code is zero */
    movl  %eax, (%esp)
    /* exit application */
    call  __exit
    hlt

.def	__exit;	.scl	2;	.type	32;	.endef  /* standard C library function */

```

`ThirdParty/Boost.Context/asm/make_i386_ms_pe_masm.asm`:

```asm

;           Copyright Oliver Kowalke 2009.
;  Distributed under the Boost Software License, Version 1.0.
;     (See accompanying file LICENSE_1_0.txt or copy at
;           http://www.boost.org/LICENSE_1_0.txt)

;  ---------------------------------------------------------------------------------
;  |    0    |    1    |    2    |    3    |    4    |    5    |    6    |    7    |
;  ---------------------------------------------------------------------------------
;  |    0h   |   04h   |   08h   |   0ch   |   010h  |   014h  |   018h  |   01ch  |
;  ---------------------------------------------------------------------------------
;  | fc_mxcsr|fc_x87_cw| fc_strg |fc_deallo|  limit  |   base  |  fc_seh |   EDI   |
;  ---------------------------------------------------------------------------------
;  ---------------------------------------------------------------------------------
;  |    8    |    9    |   10    |    11   |    12   |    13   |    14   |    15   |
;  ---------------------------------------------------------------------------------
;  |   020h  |  024h   |  028h   |   02ch  |   030h  |   034h  |   038h  |   03ch  |
;  ---------------------------------------------------------------------------------
;  |   ESI   |   EBX   |   EBP   |   EIP   |   EXIT  |         | SEH NXT |SEH HNDLR|
;  ---------------------------------------------------------------------------------

.386
.XMM
.model flat, c
; standard C library function
_exit PROTO, value:SDWORD
.code

make_fcontext PROC
    ; first arg of make_fcontext() == top of context-stack
    mov  eax, [esp+04h]

    ; reserve space for first argument of context-function
    ; EAX might already point to a 16byte border
    lea  eax, [eax-08h]

    ; shift address in EAX to lower 16 byte boundary
    and  eax, -16

    ; reserve space for context-data on context-stack
    ; size for fc_mxcsr .. EIP + return-address for context-function
    ; on context-function entry: (ESP -0x4) % 8 == 0
    ; additional space is required for SEH
    lea  eax, [eax-03ch]

    ; first arg of make_fcontext() == top of context-stack
    mov  ecx, [esp+04h]
    ; save top address of context stack as 'base'
    mov  [eax+014h], ecx
    ; second arg of make_fcontext() == size of context-stack
    mov  edx, [esp+08h]
    ; negate stack size for LEA instruction (== substraction)
    neg  edx
    ; compute bottom address of context stack (limit)
    lea  ecx, [ecx+edx]
    ; save bottom address of context-stack as 'limit'
    mov  [eax+010h], ecx
    ; save bottom address of context-stack as 'dealloction stack'
    mov  [eax+0ch], ecx

    ; third arg of make_fcontext() == address of context-function
    mov  ecx, [esp+0ch]
    mov  [eax+02ch], ecx

    ; save MMX control- and status-word
    stmxcsr  [eax]
    ; save x87 control-word
    fnstcw  [eax+04h]

    ; compute abs address of label finish
    mov  ecx, finish
    ; save address of finish as return-address for context-function
    ; will be entered after context-function returns
    mov  [eax+030h], ecx

    ; traverse current seh chain to get the last exception handler installed by Windows
    ; note that on Windows Server 2008 and 2008 R2, SEHOP is activated by default
    ; the exception handler chain is tested for the presence of ntdll.dll!FinalExceptionHandler
    ; at its end by RaiseException all seh-handlers are disregarded if not present and the
    ; program is aborted
    assume  fs:nothing
    ; load NT_TIB into ECX
    mov  ecx, fs:[0h]
    assume  fs:error

walk:
    ; load 'next' member of current SEH into EDX
    mov  edx, [ecx]
    ; test if 'next' of current SEH is last (== 0xffffffff)
    inc  edx
    jz  found
    dec  edx
    ; exchange content; ECX contains address of next SEH
    xchg edx, ecx
    ; inspect next SEH
    jmp  walk

found:
    ; load 'handler' member of SEH == address of last SEH handler installed by Windows
    mov  ecx, [ecx+04h]
    ; save address in ECX as SEH handler for context
    mov  [eax+03ch], ecx
    ; set ECX to -1
    mov  ecx, 0ffffffffh
    ; save ECX as next SEH item
    mov  [eax+038h], ecx
    ; load address of next SEH item
    lea  ecx, [eax+038h]
    ; save next SEH
    mov  [eax+018h], ecx

    ret ; return pointer to context-data

finish:
    ; exit code is zero
    xor  eax, eax
    mov  [esp], eax
    ; exit application
    call  _exit
    hlt
make_fcontext ENDP
END

```

`ThirdParty/Boost.Context/asm/make_i386_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |   EXIT  |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl make_fcontext
.align 2
.type make_fcontext,@function
make_fcontext:
    /* first arg of make_fcontext() == top of context-stack */
    movl  0x4(%esp), %eax

    /* reserve space for first argument of context-function
       rax might already point to a 16byte border */
    leal  -0x8(%eax), %eax

    /* shift address in EAX to lower 16 byte boundary */
    andl  $-16, %eax

    /* reserve space for context-data on context-stack */
    /* size for fc_mxcsr .. EIP + return-address for context-function */
    /* on context-function entry: (ESP -0x4) % 8 == 0 */
    leal  -0x20(%eax), %eax

    /* third arg of make_fcontext() == address of context-function */
    movl  0xc(%esp), %edx
    movl  %edx, 0x18(%eax)

    /* save MMX control- and status-word */
    stmxcsr  (%eax)
    /* save x87 control-word */
    fnstcw  0x4(%eax)

    /* compute abs address of label finish */
    call  1f
    /* address of label 1 */
1:  popl  %ecx
    /* compute abs address of label finish */
    addl  $finish-1b, %ecx
    /* save address of finish as return-address for context-function */
    /* will be entered after context-function returns */
    movl  %ecx, 0x1c(%eax)

    ret /* return pointer to context-data */

finish:
    call  2f
    /* address of label 2 */
2:  popl  %ebx
    /* compute address of GOT and store it in EBX */
    addl  $_GLOBAL_OFFSET_TABLE_+[.-2b], %ebx

    /* exit code is zero */
    xorl  %eax, %eax
    movl  %eax, (%esp)
    /* exit application */
    call  _exit@PLT
    hlt
.size make_fcontext,.-make_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_i386_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |   EXIT  |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl _make_fcontext
.align 2
_make_fcontext:
    /* first arg of make_fcontext() == top of context-stack */
    movl  0x4(%esp), %eax

    /* reserve space for first argument of context-function
       rax might already point to a 16byte border */
    leal  -0x8(%eax), %eax

    /* shift address in EAX to lower 16 byte boundary */
    andl  $-16, %eax

    /* reserve space for context-data on context-stack */
    /* size for fc_mxcsr .. EIP + return-address for context-function */
    /* on context-function entry: (ESP -0x4) % 8 == 0 */
    leal  -0x20(%eax), %eax

    /* thrid arg of make_fcontext() == address of context-function */
    movl  0xc(%esp), %edx
    movl  %edx, 0x18(%eax)

    /* save MMX control- and status-word */
    stmxcsr  (%eax)
    /* save x87 control-word */
    fnstcw  0x4(%eax)

    /* compute abs address of label finish */
    call  1f
    /* address of label 1 */
1:  popl  %ecx
    /* compute abs address of label finish */
    addl  $finish-1b, %ecx
    /* save address of finish as return-address for context-function */
    /* will be entered after context-function returns */
    movl  %ecx, 0x1c(%eax)

    ret /* return pointer to context-data */

finish:
    /* exit code is zero */
    xorl  %eax, %eax
    movl  %eax, (%esp)
    /* exit application */
    call  __exit
    hlt

```

`ThirdParty/Boost.Context/asm/make_i386_x86_64_sysv_macho_gas.S`:

```S
/*
            Copyright Sergue E. Leontiev 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

// Stub file for universal binary

#if defined(__i386__)
    #include "make_i386_sysv_macho_gas.S"
#elif defined(__x86_64__)
    #include "make_x86_64_sysv_macho_gas.S"
#else
    #error "No arch's"
#endif

```

`ThirdParty/Boost.Context/asm/make_mips32_o32_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F20    |    F22    |    F24    |    F26    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F28    |    F30    |  S0 |  S1 |  S2 |  S3 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |     |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |     |  *
 *  -------------------------------------------------  *
 *  |  S4 |  S5 |  S6 |  S7 |  FP |  RA |  PC |     |  *
 *  -------------------------------------------------  *
 *                                                     *
 * *****************************************************/

.text
.globl make_fcontext
.align 2
.type make_fcontext,@function
.ent make_fcontext
make_fcontext:
#ifdef __PIC__
.set    noreorder
.cpload $t9
.set    reorder
#endif
    # first arg of make_fcontext() == top address of context-stack
    move $v0, $a0

    # shift address in A0 to lower 16 byte boundary
    move $v1, $v0
    li $v0, -16 # 0xfffffffffffffff0
    and $v0, $v1, $v0

    # reserve space for context-data on context-stack
    # including 48 byte of shadow space (sp % 16 == 0)
    addiu $v0, $v0, -140

    # third arg of make_fcontext() == address of context-function
    sw  $a2, 88($v0)
    # save global pointer in context-data
    # S0 will contain address of global pointer
    sw  $gp, 48($v0)

    # compute abs address of label finish
    la  $t9, finish
    # save address of finish as return-address for context-function
    # will be entered after context-function returns
    sw  $t9, 84($v0)

    jr  $ra # return pointer to context-data

finish:
    # allocate stack space (contains shadow space for subroutines)
    addiu  $sp, $sp, -32
    # save return address
    sw  $ra, 28($sp)

    # restore GP (global pointer)
    move  $gp, $s0
    # exit code is zero
    move  $a0, $zero
    # address of exit
    lw  $t9, %call16(_exit)($gp)
    # exit application
    jalr  $t9
.end make_fcontext
.size make_fcontext, .-make_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_ppc32_ppc64_sysv_macho_gas.S`:

```S
/*
            Copyright Sergue E. Leontiev 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

// Stub file for universal binary

#if defined(__ppc__)
    #include "make_ppc32_sysv_macho_gas.S"
#elif defined(__ppc64__)
    #include "make_ppc64_sysv_macho_gas.S"
#else
    #error "No arch's"
#endif

```

`ThirdParty/Boost.Context/asm/make_ppc32_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   | R13 | R14 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  | R15 | R16 | R17 | R18 | R19 | R20 | R21 | R22 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  | R23 | R24 | R25 | R26 | R27 | R28 | R29 | R30 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |                       |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 |                       |  *
 *  -------------------------------------------------  *
 *  | R31 |  CR |  LR |  PC |                       |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl make_fcontext
.align 2
.type make_fcontext,@function
make_fcontext:
    # save return address into R6
    mflr  %r6

    # first arg of make_fcontext() == top address of context-function
    # shift address in R3 to lower 16 byte boundary
    clrrwi  %r3, %r3, 4

    # reserve space for context-data on context-stack
    # including 64 byte of linkage + parameter area (R1 % 16 == 0)
    subi  %r3, %r3, 304

    # third arg of make_fcontext() == address of context-function
    stw  %r5, 236(%r3)

    # load LR
    mflr  %r0
    # jump to label 1
    bl  1f
1:
    # load LR into R4
    mflr  %r4
    # compute abs address of label finish
    addi  %r4, %r4, finish - 1b
    # restore LR
    mtlr  %r0
    # save address of finish as return-address for context-function
    # will be entered after context-function returns
    stw  %r4, 232(%r3)

    # restore return address from R6
    mtlr  %r6

    blr  # return pointer to context-data

finish:
    # save return address into R0
    mflr  %r0
    # save return address on stack, set up stack frame
    stw  %r0, 4(%r1)
    # allocate stack space, R1 % 16 == 0
    stwu  %r1, -16(%r1)

    # exit code is zero
    li  %r3, 0
    # exit application
    bl  _exit@plt
.size make_fcontext, .-make_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_ppc32_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   | R13 | R14 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  | R15 | R16 | R17 | R18 | R19 | R20 | R21 | R22 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  | R23 | R24 | R25 | R26 | R27 | R28 | R29 | R30 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |                       |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 |                       |  *
 *  -------------------------------------------------  *
 *  | R31 |  CR |  LR |  PC |                       |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl _make_fcontext
.align 2
_make_fcontext:
    ; save return address into R6
    mflr  r6

    ; first arg of make_fcontext() == top address of context-function
    ; shift address in R3 to lower 16 byte boundary
    clrrwi  r3, r3, 4

    ; reserve space for context-data on context-stack
    ; including 64 byte of linkage + parameter area (R1 % 16 == 0)
    subi  r3, r3, 304

    ; third arg of make_fcontext() == address of context-function
    stw  r5, 236(r3)

    ; load LR
    mflr  r0
    ; jump to label 1
    bl  l1
l1:
    ; load LR into R4
    mflr  r4
    ; compute abs address of label finish
    addi  r4, r4, lo16((finish - .)+4)
    # restore LR
    mtlr  r0
    ; save address of finish as return-address for context-function
    ; will be entered after context-function returns
    stw  r4, 232(r3)

    ; restore return address from R6
    mtlr  r6

    blr  ; return pointer to context-data

finish:
    ; save return address into R0
    mflr  r0
    ; save return address on stack, set up stack frame
    stw  r0, 4(r1)
    ; allocate stack space, R1 % 16 == 0
    stwu  r1, -16(r1)

    ; exit code is zero
    li  r3, 0
    ; exit application
    bl  __exit

```

`ThirdParty/Boost.Context/asm/make_ppc32_sysv_xcoff_gas.S`:

```S
	.globl	make_fcontext[DS]
	.globl .make_fcontext[PR]
	.align 2 
	.csect  make_fcontext[DS]
make_fcontext:
	.long .make_fcontext[PR]
	.csect .make_fcontext[PR], 3
#.make_fcontext:
    # save return address into R6
    mflr  6

    # first arg of make_fcontext() == top address of context-function
    # shift address in R3 to lower 16 byte boundary
    clrrwi  3, 3, 4

    # reserve space for context-data on context-stack
    # including 64 byte of linkage + parameter area (R1 % 16 == 0)
    subi  3, 3, 304

    # third arg of make_fcontext() == address of context-function
    stw  5, 236(3)

    # load LR
    mflr  0
    # jump to label 1
    bl  .Label
.Label:
    # load LR into R4
    mflr  4
    # compute abs address of label .L_finish
    addi  4, 4, .L_finish - .Label 
    # restore LR
    mtlr  0
    # save address of finish as return-address for context-function
    # will be entered after context-function returns
    stw  4, 232(3)

    # restore return address from R6
    mtlr  6

    blr  # return pointer to context-data

.L_finish:
    # save return address into R0
    mflr  0
    # save return address on stack, set up stack frame
    stw  0, 4(1)
    # allocate stack space, R1 % 16 == 0
    stwu  1, -16(1)

    # exit code is zero
    li  3, 0
    # exit application
    bl  ._exit
    nop

```

`ThirdParty/Boost.Context/asm/make_ppc64_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   |    TOC    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  |    R14    |    R15    |     R16   |    R17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  |    R18    |    R19    |    R20    |    R21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |  60 |  61 |  62 |  63 |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 | 240 | 244 | 248 | 252 |  *
 *  -------------------------------------------------  *
 *  |    R22    |    R23    |    R24    |    R25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  64 |  65 |  66 |  67 |  68 |  69 |  70 |  71 |  *
 *  -------------------------------------------------  *
 *  | 256 | 260 | 264 | 268 | 272 | 276 | 280 | 284 |  *
 *  -------------------------------------------------  *
 *  |    R26    |    R27    |    R28    |    R29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  72 |  73 |  74 |  75 |  76 |  77 |  78 |  79 |  *
 *  -------------------------------------------------  *
 *  | 288 | 292 | 296 | 300 | 304 | 308 | 312 | 316 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |    R30    |    R31    |     CR    |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  80 |  81 |                                   |  *
 *  -------------------------------------------------  *
 *  | 320 | 324 |                                   |  *
 *  -------------------------------------------------  *
 *  |    PC     |                                   |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.globl make_fcontext
#if _CALL_ELF == 2
	.text
	.align 2
make_fcontext:
	addis	%r2, %r12, .TOC.-make_fcontext@ha
	addi	%r2, %r2, .TOC.-make_fcontext@l
	.localentry make_fcontext, . - make_fcontext
#else
	.section ".opd","aw"
	.align 3
make_fcontext:
# ifdef _CALL_LINUX
	.quad	.L.make_fcontext,.TOC.@tocbase,0
	.type	make_fcontext,@function
	.text
	.align 2
.L.make_fcontext:
# else
	.hidden	.make_fcontext
	.globl	.make_fcontext
	.quad	.make_fcontext,.TOC.@tocbase,0
	.size	make_fcontext,24
	.type	.make_fcontext,@function
	.text
	.align 2
.make_fcontext:
# endif
#endif
    # save return address into R6
    mflr  %r6

    # first arg of make_fcontext() == top address of context-stack
    # shift address in R3 to lower 16 byte boundary
    clrrdi  %r3, %r3, 4

    # reserve space for context-data on context-stack
    # including 64 byte of linkage + parameter area (R1 % 16 == 0)
    subi  %r3, %r3, 392

    # third arg of make_fcontext() == address of context-function
    # entry point (ELFv2) or descriptor (ELFv1)
#if _CALL_ELF == 2
    # save address of context-function entry point
    std  %r5, 320(%r3)
#else
    # save address of context-function entry point
    ld   %r4, 0(%r5)
    std  %r4, 320(%r3)
    # save TOC of context-function
    ld   %r4, 8(%r5)
    std  %r4, 152(%r3)
#endif

    # load LR
    mflr  %r0
    # jump to label 1
    bl  1f
1:
    # load LR into R4
    mflr  %r4
    # compute abs address of label finish
    addi  %r4, %r4, finish - 1b
    # restore LR
    mtlr  %r0
    # save address of finish as return-address for context-function
    # will be entered after context-function returns
    std  %r4, 312(%r3)

    # restore return address from R6
    mtlr  %r6

    blr  # return pointer to context-data

finish:
    # save return address into R0
    mflr  %r0
    # save return address on stack, set up stack frame
    std  %r0, 8(%r1)
    # allocate stack space, R1 % 16 == 0
    stdu  %r1, -32(%r1)

    # exit code is zero
    li  %r3, 0
    # exit application
    bl  _exit
    nop
#if _CALL_ELF == 2
	.size make_fcontext, .-make_fcontext
#else
# ifdef _CALL_LINUX
	.size .make_fcontext, .-.L.make_fcontext
# else
	.size .make_fcontext, .-.make_fcontext
# endif
#endif

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_ppc64_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************
 *                                                     *
 *  -------------------------------------------------  *
 *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *
 *  -------------------------------------------------  *
 *  |  0  |  4  |  8  |  12 |  16 |  20 |  24 |  28 |  *
 *  -------------------------------------------------  *
 *  |    F14    |    F15    |    F16    |    F17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *
 *  -------------------------------------------------  *
 *  |  32 |  36 |  40 |  44 |  48 |  52 |  56 |  60 |  *
 *  -------------------------------------------------  *
 *  |    F18    |    F19    |    F20    |    F21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *
 *  -------------------------------------------------  *
 *  |  64 |  68 |  72 |  76 |  80 |  84 |  88 |  92 |  *
 *  -------------------------------------------------  *
 *  |    F22    |    F23    |    F24    |    F25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *
 *  -------------------------------------------------  *
 *  |  96 | 100 | 104 | 108 | 112 | 116 | 120 | 124 |  *
 *  -------------------------------------------------  *
 *  |    F26    |    F27    |    F28    |    F29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *
 *  -------------------------------------------------  *
 *  | 128 | 132 | 136 | 140 | 144 | 148 | 152 | 156 |  *
 *  -------------------------------------------------  *
 *  |    F30    |    F31    |   fpscr   |    R13    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  40 |  41 |  42 |  43 |  44 |  45 |  46 |  47 |  *
 *  -------------------------------------------------  *
 *  | 160 | 164 | 168 | 172 | 176 | 180 | 184 | 188 |  *
 *  -------------------------------------------------  *
 *  |    R14    |    R15    |     R16   |    R17    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  48 |  49 |  50 |  51 |  52 |  53 |  54 |  55 |  *
 *  -------------------------------------------------  *
 *  | 192 | 196 | 200 | 204 | 208 | 212 | 216 | 220 |  *
 *  -------------------------------------------------  *
 *  |    R18    |    R19    |    R20    |    R21    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  56 |  57 |  58 |  59 |  60 |  61 |  62 |  63 |  *
 *  -------------------------------------------------  *
 *  | 224 | 228 | 232 | 236 | 240 | 244 | 248 | 252 |  *
 *  -------------------------------------------------  *
 *  |    R22    |    R23    |    R24    |    R25    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  64 |  65 |  66 |  67 |  68 |  69 |  70 |  71 |  *
 *  -------------------------------------------------  *
 *  | 256 | 260 | 264 | 268 | 272 | 276 | 280 | 284 |  *
 *  -------------------------------------------------  *
 *  |    R26    |    R27    |    R28    |    R29    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  72 |  73 |  74 |  75 |  76 |  77 |  78 |  79 |  *
 *  -------------------------------------------------  *
 *  | 288 | 292 | 296 | 300 | 304 | 308 | 312 | 316 |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |    R30    |    R31    |     CR    |     LR    |  *
 *  -------------------------------------------------  *
 *  -------------------------------------------------  *
 *  |  80 |  81 |                                   |  *
 *  -------------------------------------------------  *
 *  | 320 | 324 |                                   |  *
 *  -------------------------------------------------  *
 *  |    PC     |                                   |  *
 *  -------------------------------------------------  *
 *                                                     *
 *******************************************************/

.text
.globl _make_fcontext
_make_fcontext:
    ; save return address into R6
    mflr  r6

    ; first arg of make_fcontext() == top address of context-function
    ; shift address in R3 to lower 16 byte boundary
    clrrwi  r3, r3, 4

    ; reserve space for context-data on context-stack
    ; including 64 byte of linkage + parameter area (R1  16 == 0)
    subi  r3, r3, 392

    ; third arg of make_fcontext() == address of context-function
    stw  r5, 320(r3)

    ; load LR
    mflr  r0
    ; jump to label 1
    bl  l1
l1:
    ; load LR into R4
    mflr  r4
    ; compute abs address of label finish
    addi  r4, r4, lo16((finish - .) + 4)
    ; restore LR
    mtlr  r0
    ; save address of finish as return-address for context-function
    ; will be entered after context-function returns
    std  r4, 312(r3)

    ; restore return address from R6
    mtlr  r6

    blr  ; return pointer to context-data

finish:
    ; save return address into R0
    mflr  r0
    ; save return address on stack, set up stack frame
    stw  r0, 8(r1)
    ; allocate stack space, R1  16 == 0
    stwu  r1, -32(r1)

    ; set return value to zero
    li  r3, 0
    ; exit application
    bl  __exit
    nop

```

`ThirdParty/Boost.Context/asm/make_ppc64_sysv_xcoff_gas.S`:

```S
	.globl	make_fcontext[DS]
	.globl .make_fcontext[PR]
	.align 2 
	.csect .make_fcontext[PR], 3
	.globl _make_fcontext
#._make_fcontext:
    # save return address into R6
    mflr  6

    # first arg of make_fcontext() == top address of context-function
    # shift address in R3 to lower 16 byte boundary
    clrrwi  3, 3, 4

    # reserve space for context-data on context-stack
    # including 64 byte of linkage + parameter area (R1 % 16 == 0)
    subi  3, 3, 392

    # third arg of make_fcontext() == address of context-function
    stw  5, 320(3)

    # load LR
    mflr  0
    # jump to label 1
    bl  .Label
.Label:
    # load LR into R4
    mflr  4
    # compute abs address of label .L_finish
    addi  4, 4, .L_finish - .Label
    # restore LR
    mtlr  0
    # save address of finish as return-address for context-function
    # will be entered after context-function returns
    stw  4, 312(3)

    # restore return address from R6
    mtlr  6

    blr  # return pointer to context-data

.L_finish:
    # save return address into R0
    mflr  0
    # save return address on stack, set up stack frame
    stw  0, 8(1)
    # allocate stack space, R1 % 16 == 0
    stwu  1, -32(1)

    # exit code is zero
    li  3, 0
    # exit application
    bl  ._exit
    nop

```

`ThirdParty/Boost.Context/asm/make_sparc64_sysv_elf_gas.S`:

```S
/*
            Copyright Martin Husemann 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************************
 *                                                                 *
 *  -------------------------------------------------------------  *
 *  |  Offset (in 4 or 8 byte units) | Content                  |  *
 *  -------------------------------------------------------------  *
 *  | 0                              | %sp                      |  *
 *  -------------------------------------------------------------  *
 *  | 1                              | %pc                      |  *
 *  -------------------------------------------------------------  *
 *  | 2                              | %i7 (return address)     |  *
 *  -------------------------------------------------------------  *
 *  | 3                              | %g1                      |  *
 *  -------------------------------------------------------------  *
 *  | 4                              | %g2                      |  *
 *  -------------------------------------------------------------  *
 *  | 5                              | %g3                      |  *
 *  -------------------------------------------------------------  *
 *  | 6                              | %g6                      |  *
 *  -------------------------------------------------------------  *
 *  | 7                              | %g7                      |  *
 *  -------------------------------------------------------------  *
 *    The local and in registers are stored on the stack.          *
 *******************************************************************/

#define	OFF(N)	(8*(N))
#define	CCFSZ	176		// C Compiler Frame Size
#define	BIAS	(2048-1)	// Stack offset for 64 bit programs
#define	FC_SZ	448		// sizeof(fcontext_t)
#define	FC_STK	384		// offsetof(fcontext_t, fc_stack)
#define	FC_FPU	0		// offsetof(fcontext_t, fc_fp)
#define	FC_FSR	264		// offsetof(fcontext_t, fc_fp.fp_fsr)
#define	FC_FPRS	256		// offsetof(fcontext_t, fc_fp.fp_fprs)
#define	FC_GREG	320		// offsetof(fcontext_t, fc_greg)
#define	BLOCK_SIZE	64

	.register %g2,#ignore
	.register %g3,#ignore
	.register %g6,#ignore

.text
.globl make_fcontext
.align 4
.type make_fcontext,@function
// fcontext_t *
// make_fcontext( void * sp, std::size_t size, void (* fn)( intptr_t) )
make_fcontext:
    save %sp, -CCFSZ, %sp
    // %i0 initial stack pointer
    // %i1 stack size limit
    // %i2 function pointer for context start function

    sub %i0, FC_SZ, %i4		// allocate fcontext_t at on the new stack and keep pointer as return value
    andn %i4, BLOCK_SIZE-1, %i5	// force block ops usable alignement and keep pointer to fcontext in %i5

    stx %i0, [%i5+FC_STK+OFF(0)]	// save fs_stack.sp
    stx %i1, [%i5+FC_STK+OFF(1)]	// save fs_stack.size
    sub %i5, CCFSZ+BIAS, %o1	   	// leave space for one register window (and offset stack for 64bit)
    stx %o1, [%i5+FC_GREG+OFF(0)]	// save new stack pointer
    stx %i2, [%i5+FC_GREG+OFF(1)]	// save new %pc (function pointer)
    stx %g1, [%i5+FC_GREG+OFF(3)]
    stx %g2, [%i5+FC_GREG+OFF(4)]
    stx %g3, [%i5+FC_GREG+OFF(5)]
    stx %g6, [%i5+FC_GREG+OFF(6)]
    stx %g7, [%i5+FC_GREG+OFF(7)]

    // synthesize "return address": jump to finish
1:  rd %pc, %i4
    add %i4, finish-1b-8, %i4
    stx %i4, [%i5+FC_GREG+OFF(2)]

    ret
    restore %g0, %i5, %o0	// return fcontext_t

finish:
    mov %g0, %o0
    call _exit
     nop

.size make_fcontext,.-make_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_sparc_sysv_elf_gas.S`:

```S
/*
            Copyright Martin Husemann 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
*/

/*******************************************************************
 *                                                                 *
 *  -------------------------------------------------------------  *
 *  |  Offset (in 4 or 8 byte units) | Content                  |  *
 *  -------------------------------------------------------------  *
 *  | 0                              | %sp                      |  *
 *  -------------------------------------------------------------  *
 *  | 1                              | %pc                      |  *
 *  -------------------------------------------------------------  *
 *  | 2                              | %i7 (return address)     |  *
 *  -------------------------------------------------------------  *
 *  | 3                              | %g1                      |  *
 *  -------------------------------------------------------------  *
 *  | 4                              | %g2                      |  *
 *  -------------------------------------------------------------  *
 *  | 5                              | %g3                      |  *
 *  -------------------------------------------------------------  *
 *  | 6                              | %g6                      |  *
 *  -------------------------------------------------------------  *
 *  | 7                              | %g7                      |  *
 *  -------------------------------------------------------------  *
 *    The local and in registers are stored on the stack.          *
 *******************************************************************/

#define	OFF(N)	(4*(N))
#define	CCFSZ	96
#define	FC_SZ	176
#define	FC_stK	168		// offsetof(fcontext_t, fc_stack)
#define	FC_FPU	0		// offsetof(fcontext_t, fc_fp)
#define	FC_FSR	128		// offsetof(fcontext_t, fc_fp.fp_fsr)
#define	FC_GREG	136		// offsetof(fcontext_t, fc_greg)
#define	BLOCK_SIZE 8

.text
.globl make_fcontext
.align 4
.type make_fcontext,@function
// fcontext_t *
// make_fcontext( void * sp, std::size_t size, void (* fn)( intptr_t) )
make_fcontext:
    save %sp, -CCFSZ, %sp
    // %i0 initial stack pointer
    // %i1 stack size limit
    // %i2 function pointer for context start function

    sub %i0, FC_SZ, %i4			// allocate fcontext_t at on the new stack and keep pointer as return value
    andn %i4, BLOCK_SIZE-1, %i5		// force block ops usable alignement and keep pointer to fcontext in %i5

    st %i0, [%i5+FC_stK+OFF(0)]		// save fs_stack.sp
    st %i1, [%i5+FC_stK+OFF(1)]		// save fs_stack.size
    sub %i5, CCFSZ, %o1   		// leave space for one register window
    st %o1, [%i5+FC_GREG+OFF(0)]	// save new stack pointer
    st %i2, [%i5+FC_GREG+OFF(1)]	// save new %pc (function pointer)
    st %g1, [%i5+FC_GREG+OFF(3)]
    st %g2, [%i5+FC_GREG+OFF(4)]
    st %g3, [%i5+FC_GREG+OFF(5)]
    st %g6, [%i5+FC_GREG+OFF(6)]
    st %g7, [%i5+FC_GREG+OFF(7)]

    // synthesize "return address": jump to finish
    mov %i7, %l0
2:  call 3f
     nop
3:  add finish-2b-8, %o7, %i4
    st %i4, [%i5+FC_GREG+OFF(2)]

    ret
    restore %g0, %i5, %o0	// return fcontext_t

finish:
    mov %g0, %o0
    call _exit
     nop

.size make_fcontext,.-make_fcontext

/* Mark that we don't need executable stack.  */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_x86_64_ms_pe_gas.asm`:

```asm
/*
            Copyright Oliver Kowalke 2009.
            Copyright Thomas Sailer 2013.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------
 *  |    0    |    1    |                                                            |
 *  ----------------------------------------------------------------------------------
 *  |   0x0   |   0x4   |                                                            |
 *  ----------------------------------------------------------------------------------
 *  |    <indicator>    |                                                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    2    |    3    |    4     |    5    |    6    |    7    |    8    |    9    |
 *  ----------------------------------------------------------------------------------
 *  |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |   0x20  |   0x24  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |   10    |   11    |    12    |    13   |    14   |    15   |    16   |    17   |
 *  ----------------------------------------------------------------------------------
 *  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |   0x40  |   0x44  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    18   |    19   |    20   |    21    |    22   |    23   |    24   |    25   |
 *  ----------------------------------------------------------------------------------
 *  |   0x48  |   0x4c  |   0x50  |   0x54   |   0x58  |   0x5c  |  0x60   |   0x64  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    26   |    27   |    28    |   29    |    30   |    31   |    32   |    33   |
 *  ----------------------------------------------------------------------------------
 *  |   0x68  |   0x6c  |   0x70   |   0x74  |   0x78  |   0x7c  |   0x80  |   0x84  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    34    |   35   |    36    |    37   |    38   |    39   |    40   |    41   |
 *  ----------------------------------------------------------------------------------
 *  |   0x88   |  0x8c  |   0x90   |   0x94  |   0x98  |   0x9c  |   0xa0  |   0xa4  |
 *  ----------------------------------------------------------------------------------
 *  |                          SEE registers (XMM6-XMM15)                            |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    42   |    43   |    44    |    45   |    46   |    47   |    48   |    49   |
 *  ----------------------------------------------------------------------------------
 *  |   0xa8  |   0xac  |   0xb0   |   0xb4  |   0xb8  |   0xbc  |   0xc0  |   0xc4  |
 *  ----------------------------------------------------------------------------------
 *  | fc_mxcsr|fc_x87_cw|     <alignment>    |      fbr_strg     |      fc_dealloc   |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    50   |   51    |    52    |    53   |    54   |    55   |    56   |    57   |
 *  ----------------------------------------------------------------------------------
 *  |   0xc8  |  0xcc   |   0xd0   |   0xd4  |   0xd8  |   0xdc  |   0xe0  |   0xe4  |
 *  ----------------------------------------------------------------------------------
 *  |      limit        |       base         |      R12          |        R13        |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    58   |    59   |    60   |    61    |    62   |    63   |    64   |    65   |
 *  ----------------------------------------------------------------------------------
 *  |   0xe8  |   0xec  |   0xf0  |   0xf4   |   0xf8  |   0xfc  |  0x100  |  0x104  |
 *  ----------------------------------------------------------------------------------
 *  |        R14        |        R15         |       RDI         |       RSI         |
 *  ----------------------------------------------------------------------------------
 *  ----------------------------------------------------------------------------------
 *  |    66   |   67    |    68    |   69    |    70   |  71     |    72   |    73   |
 *  ----------------------------------------------------------------------------------
 *  |  0x108  |  0x10c  |  0x110   |  0x114  |  0x118  |  0x11c  |  0x120  |  0x124  |
 *  ----------------------------------------------------------------------------------
 *  |        RBX        |         RBP        |        RIP        |       EXIT        |
 *  ----------------------------------------------------------------------------------
 *                                                                                      *
 * *************************************************************************************/

.file	"make_x86_64_ms_pe_gas.asm"
.text
.p2align 4,,15
.globl	make_fcontext
.def	make_fcontext;	.scl	2;	.type	32;	.endef
.seh_proc	make_fcontext
make_fcontext:
.seh_endprologue

    /* first arg of make_fcontext() == top of context-stack */
    movq  %rcx, %rax

    /* reserve 32byte shadow-space for context-function */
    leaq  -0x28(%rax), %rax

    /* shift address in RAX to lower 16 byte boundary */
    /* == pointer to fcontext_t and address of context stack */
    andq  $-16, %rax

    /* reserve space for context-data on context-stack */
    /* size for fc_mxcsr .. RIP + return-address for context-function */
    /* on context-function entry: (RSP -0x8) % 16 == 0 */
    leaq  -0x128(%rax), %rax

    /* third arg of make_fcontext() == address of context-function */
    movq  %r8, 0x118(%rax)

    /* first arg of make_fcontext() == top of context-stack */
    /* save top address of context stack as 'base' */
    movq  %rcx, 0xd0(%rax)
    /* second arg of make_fcontext() == size of context-stack */
    /* negate stack size for LEA instruction (== substraction) */
    negq  %rdx
    /* compute bottom address of context stack (limit) */
    leaq  (%rcx,%rdx), %rcx
    /* save bottom address of context stack as 'limit' */
    movq  %rcx, 0xc8(%rax)
    /* save address of context stack limit as 'dealloction stack' */
    movq  %rcx, 0xc0(%rax)

    /* save MMX control- and status-word */
    stmxcsr  0xa8(%rax)
    /* save x87 control-word */
    fnstcw  0xac(%rax)

    /* compute abs address of label finish */
    leaq  finish(%rip), %rcx
    /* save address of finish as return-address for context-function */
    /* will be entered after context-function returns */
    movq  %rcx, 0x120(%rax)

    /* set indicator */
    movq  1, %rcx
    movq  %rcx, (%rax)

    ret /* return pointer to context-data */

finish:
    /* 32byte shadow-space for _exit() are */
    /* already reserved by make_fcontext() */
    /* exit code is zero */
    xorq  %rcx, %rcx
    /* exit application */
    call  _exit
    hlt
.seh_endproc

.def	_exit;	.scl	2;	.type	32;	.endef  /* standard C library function */

```

`ThirdParty/Boost.Context/asm/make_x86_64_ms_pe_masm.asm`:

```asm

;           Copyright Oliver Kowalke 2009.
;  Distributed under the Boost Software License, Version 1.0.
;     (See accompanying file LICENSE_1_0.txt or copy at
;           http://www.boost.org/LICENSE_1_0.txt)

;  ----------------------------------------------------------------------------------
;  |    0    |    1    |                                                            |
;  ----------------------------------------------------------------------------------
;  |   0x0   |   0x4   |                                                            |
;  ----------------------------------------------------------------------------------
;  |    <indicator>    |                                                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    2    |    3    |    4     |    5    |    6    |    7    |    8    |    9    |
;  ----------------------------------------------------------------------------------
;  |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |   0x20  |   0x24  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |   10    |   11    |    12    |    13   |    14   |    15   |    16   |    17   |
;  ----------------------------------------------------------------------------------
;  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |   0x40  |   0x44  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    18   |    19   |    20   |    21    |    22   |    23   |    24   |    25   |
;  ----------------------------------------------------------------------------------
;  |   0x48  |   0x4c  |   0x50  |   0x54   |   0x58  |   0x5c  |  0x60   |   0x64  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    26   |    27   |    28    |   29    |    30   |    31   |    32   |    33   |
;  ----------------------------------------------------------------------------------
;  |   0x68  |   0x6c  |   0x70   |   0x74  |   0x78  |   0x7c  |   0x80  |   0x84  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    34    |   35   |    36    |    37   |    38   |    39   |    40   |    41   |
;  ----------------------------------------------------------------------------------
;  |   0x88   |  0x8c  |   0x90   |   0x94  |   0x98  |   0x9c  |   0xa0  |   0xa4  |
;  ----------------------------------------------------------------------------------
;  |                          SEE registers (XMM6-XMM15)                            |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    42   |    43   |    44    |    45   |    46   |    47   |    48   |    49   |
;  ----------------------------------------------------------------------------------
;  |   0xa8  |   0xac  |   0xb0   |   0xb4  |   0xb8  |   0xbc  |   0xc0  |   0xc4  |
;  ----------------------------------------------------------------------------------
;  | fc_mxcsr|fc_x87_cw|     <alignment>    |      fbr_strg     |      fc_dealloc   |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    50   |   51    |    52    |    53   |    54   |    55   |    56   |    57   |
;  ----------------------------------------------------------------------------------
;  |   0xc8  |  0xcc   |   0xd0   |   0xd4  |   0xd8  |   0xdc  |   0xe0  |   0xe4  |
;  ----------------------------------------------------------------------------------
;  |      limit        |       base         |      R12          |        R13        |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    58   |    59   |    60   |    61    |    62   |    63   |    64   |    65   |
;  ----------------------------------------------------------------------------------
;  |   0xe8  |   0xec  |   0xf0  |   0xf4   |   0xf8  |   0xfc  |  0x100  |  0x104  |
;  ----------------------------------------------------------------------------------
;  |        R14        |        R15         |       RDI         |       RSI         |
;  ----------------------------------------------------------------------------------
;  ----------------------------------------------------------------------------------
;  |    66   |   67    |    68    |   69    |    70   |  71     |    72   |    73   |
;  ----------------------------------------------------------------------------------
;  |  0x108  |  0x10c  |  0x110   |  0x114  |  0x118  |  0x11c  |  0x120  |  0x124  |
;  ----------------------------------------------------------------------------------
;  |        RBX        |         RBP        |        RIP        |       EXIT        |
;  ----------------------------------------------------------------------------------

; standard C library function
EXTERN  _exit:PROC
.code

; generate function table entry in .pdata and unwind information in
make_fcontext PROC FRAME
    ; .xdata for a function's structured exception handling unwind behavior
    .endprolog

    ; first arg of make_fcontext() == top of context-stack
    mov  rax, rcx

    ; reserve 32byte shadow-space for context-function
    sub  rax, 028h

    ; shift address in RAX to lower 16 byte boundary
    ; == pointer to fcontext_t and address of context stack
    and  rax, -16

    ; reserve space for context-data on context-stack
    ; size for fc_mxcsr .. RIP + return-address for context-function
    ; on context-function entry: (RSP -0x8) % 16 == 0
    sub  rax, 0128h

    ; third arg of make_fcontext() == address of context-function
    mov  [rax+0118h], r8

    ; first arg of make_fcontext() == top of context-stack
    ; save top address of context stack as 'base'
    mov  [rax+0d0h], rcx
    ; second arg of make_fcontext() == size of context-stack
    ; negate stack size for LEA instruction (== substraction)
    neg  rdx
    ; compute bottom address of context stack (limit)
    lea  rcx, [rcx+rdx]
    ; save bottom address of context stack as 'limit'
    mov  [rax+0c8h], rcx
    ; save address of context stack limit as 'dealloction stack'
    mov  [rax+0c0h], rcx

    ; save MMX control- and status-word
    stmxcsr  [rax+0a8h]
    ; save x87 control-word
    fnstcw  [rax+0ach]

    ; compute abs address of label finish
    lea  rcx, finish
    ; save address of finish as return-address for context-function
    ; will be entered after context-function returns
    mov  [rax+0120h], rcx

    ; set indicator
    mov  rcx, 1
    mov  [rax], rcx

    ret ; return pointer to context-data

finish:
    ; 32byte shadow-space for _exit() are
    ; already reserved by make_fcontext()
    ; exit code is zero
    xor  rcx, rcx
    ; exit application
    call  _exit
    hlt
make_fcontext ENDP
END

```

`ThirdParty/Boost.Context/asm/make_x86_64_sysv_elf_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        R15        |        RBX        |         RBP        |        RIP        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    16   |   17    |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x40  |   0x44  |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        EXIT       |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl make_fcontext
.type make_fcontext,@function
.align 16
make_fcontext:
    /* first arg of make_fcontext() == top of context-stack */
    movq  %rdi, %rax

    /* shift address in RAX to lower 16 byte boundary */
    andq  $-16, %rax

    /* reserve space for context-data on context-stack */
    /* size for fc_mxcsr .. RIP + return-address for context-function */
    /* on context-function entry: (RSP -0x8) % 16 == 0 */
    leaq  -0x48(%rax), %rax

    /* third arg of make_fcontext() == address of context-function */
    movq  %rdx, 0x38(%rax)

    /* save MMX control- and status-word */
    stmxcsr  (%rax)
    /* save x87 control-word */
    fnstcw   0x4(%rax)

    /* compute abs address of label finish */
    leaq  finish(%rip), %rcx
    /* save address of finish as return-address for context-function */
    /* will be entered after context-function returns */
    movq  %rcx, 0x40(%rax)

    ret /* return pointer to context-data */

finish:
    /* exit code is zero */
    xorq  %rdi, %rdi
    /* exit application */
    call  _exit@PLT
    hlt
.size make_fcontext,.-make_fcontext

/* Mark that we don't need executable stack. */
.section .note.GNU-stack,"",%progbits

```

`ThirdParty/Boost.Context/asm/make_x86_64_sysv_macho_gas.S`:

```S
/*
            Copyright Oliver Kowalke 2009.
   Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
            http://www.boost.org/LICENSE_1_0.txt)
*/

/****************************************************************************************
 *                                                                                      *
 *  ----------------------------------------------------------------------------------  *
 *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        R15        |        RBX        |         RBP        |        RIP        |  *
 *  ----------------------------------------------------------------------------------  *
 *  ----------------------------------------------------------------------------------  *
 *  |    16   |   17    |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |   0x40  |   0x44  |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *  |        EXIT       |                                                            |  *
 *  ----------------------------------------------------------------------------------  *
 *                                                                                      *
 ****************************************************************************************/

.text
.globl _make_fcontext
.align 8
_make_fcontext:
    /* first arg of make_fcontext() == top of context-stack */
    movq  %rdi, %rax

    /* shift address in RAX to lower 16 byte boundary */
    movabs  $-16,           %r8
    andq    %r8,            %rax

    /* reserve space for context-data on context-stack */
    /* size for fc_mxcsr .. RIP + return-address for context-function */
    /* on context-function entry: (RSP -0x8) % 16 == 0 */
    leaq  -0x48(%rax), %rax

    /* third arg of make_fcontext() == address of context-function */
    movq  %rdx, 0x38(%rax)

    /* save MMX control- and status-word */
    stmxcsr  (%rax)
    /* save x87 control-word */
    fnstcw   0x4(%rax)

    /* compute abs address of label finish */
    leaq  finish(%rip), %rcx
    /* save address of finish as return-address for context-function */
    /* will be entered after context-function returns */
    movq  %rcx, 0x40(%rax)

    ret /* return pointer to context-data */

finish:
    /* exit code is zero */
    xorq  %rdi, %rdi
    /* exit application */
    call  __exit
    hlt

```

`ThirdParty/Boost.Context/fcontext.h`:

```h
/*
Copyright (c) 2016 Richard Maxwell

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef FCONTEXT_H
#define FCONTEXT_H

#include <stdint.h>
// intptr_t

#include <stddef.h>
// size_t

// -----------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif
// -----------------------------------------------------------------------------

typedef void* fcontext_t;

intptr_t jump_fcontext
(
      fcontext_t* ofc
    , fcontext_t  nfc
    , intptr_t    vp
    , int         preserve_fpu
);

fcontext_t make_fcontext
(
      void*  sp
    , size_t size
    , void  (*fn)(intptr_t)
);
// sp is the pointer to the _top_ of the stack (ie &stack_buffer[size]).

// -----------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif
// -----------------------------------------------------------------------------

#endif

```

`ThirdParty/Squish/ChangeLog`:

```
1.10
* Iterative cluster fit is now considered to be a new compression mode
* The core cluster fit is now 4x faster using contributions by Ignacio
Castano from NVIDIA
* The single colour lookup table has been halved by exploiting symmetry

1.9
* Added contributed SSE1 truncate implementation
* Changed use of SQUISH_USE_SSE to be 1 for SSE and 2 for SSE2 instructions
* Cluster fit is now iterative to further reduce image error

1.8
* Switched from using floor to trunc for much better SSE performance (again)
* Xcode build now expects libpng in /usr/local for extra/squishpng

1.7
* Fixed floating-point equality issue in clusterfit sort (x86 affected only)
* Implemented proper SSE(2) floor function for 50% speedup on SSE builds 
* The range fit implementation now uses the correct colour metric

1.6
* Fixed bug in CompressImage where masked pixels were not skipped over
* DXT3 and DXT5 alpha compression now properly use the mask to ignore pixels
* Fixed major DXT1 bug that can generate unexpected transparent pixels

1.5
* Added CompressMasked function to handle incomplete DXT blocks more cleanly
* Added kWeightColourByAlpha flag for better quality images when alpha blending

1.4
* Fixed stack overflow in rangefit

1.3
* Worked around SSE floor implementation bug, proper fix needed!
* This release has visual studio and makefile builds that work

1.2
* Added provably optimal single colour compressor
* Added extra/squishgen.cpp that generates single colour lookup tables

1.1
* Fixed a DXT1 colour output bug
* Changed argument order for Decompress function to match Compress
* Added GetStorageRequirements function
* Added CompressImage function
* Added DecompressImage function
* Moved squishtool.cpp to extra/squishpng.cpp
* Added extra/squishtest.cpp

1.0
* Initial release


```

`ThirdParty/Squish/Doxyfile`:

```
# Doxyfile 1.4.6

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------
PROJECT_NAME           = squish
PROJECT_NUMBER         = 1.1
OUTPUT_DIRECTORY       = docs 
CREATE_SUBDIRS         = NO
OUTPUT_LANGUAGE        = English
USE_WINDOWS_ENCODING   = NO
BRIEF_MEMBER_DESC      = YES
REPEAT_BRIEF           = YES
ABBREVIATE_BRIEF       = 
ALWAYS_DETAILED_SEC    = NO
INLINE_INHERITED_MEMB  = NO
FULL_PATH_NAMES        = YES
STRIP_FROM_PATH        = 
STRIP_FROM_INC_PATH    = 
SHORT_NAMES            = NO
JAVADOC_AUTOBRIEF      = NO
MULTILINE_CPP_IS_BRIEF = NO
DETAILS_AT_TOP         = NO
INHERIT_DOCS           = YES
SEPARATE_MEMBER_PAGES  = NO
TAB_SIZE               = 4
ALIASES                = 
OPTIMIZE_OUTPUT_FOR_C  = NO
OPTIMIZE_OUTPUT_JAVA   = NO
BUILTIN_STL_SUPPORT    = NO
DISTRIBUTE_GROUP_DOC   = NO
SUBGROUPING            = YES
#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------
EXTRACT_ALL            = YES
EXTRACT_PRIVATE        = NO
EXTRACT_STATIC         = NO
EXTRACT_LOCAL_CLASSES  = YES
EXTRACT_LOCAL_METHODS  = NO
HIDE_UNDOC_MEMBERS     = NO
HIDE_UNDOC_CLASSES     = NO
HIDE_FRIEND_COMPOUNDS  = NO
HIDE_IN_BODY_DOCS      = NO
INTERNAL_DOCS          = NO
CASE_SENSE_NAMES       = NO
HIDE_SCOPE_NAMES       = NO
SHOW_INCLUDE_FILES     = YES
INLINE_INFO            = YES
SORT_MEMBER_DOCS       = YES
SORT_BRIEF_DOCS        = NO
SORT_BY_SCOPE_NAME     = NO
GENERATE_TODOLIST      = YES
GENERATE_TESTLIST      = YES
GENERATE_BUGLIST       = YES
GENERATE_DEPRECATEDLIST= YES
ENABLED_SECTIONS       = 
MAX_INITIALIZER_LINES  = 30
SHOW_USED_FILES        = YES
SHOW_DIRECTORIES       = NO
FILE_VERSION_FILTER    = 
#---------------------------------------------------------------------------
# configuration options related to warning and progress messages
#---------------------------------------------------------------------------
QUIET                  = YES
WARNINGS               = YES
WARN_IF_UNDOCUMENTED   = YES
WARN_IF_DOC_ERROR      = YES
WARN_NO_PARAMDOC       = NO
WARN_FORMAT            = "$file:$line: $text"
WARN_LOGFILE           = 
#---------------------------------------------------------------------------
# configuration options related to the input files
#---------------------------------------------------------------------------
INPUT                  = squish.h
FILE_PATTERNS          = 
RECURSIVE              = NO
EXCLUDE                = 
EXCLUDE_SYMLINKS       = NO
EXCLUDE_PATTERNS       = 
EXAMPLE_PATH           = 
EXAMPLE_PATTERNS       = 
EXAMPLE_RECURSIVE      = NO
IMAGE_PATH             = 
INPUT_FILTER           = 
FILTER_PATTERNS        = 
FILTER_SOURCE_FILES    = NO
#---------------------------------------------------------------------------
# configuration options related to source browsing
#---------------------------------------------------------------------------
SOURCE_BROWSER         = NO
INLINE_SOURCES         = NO
STRIP_CODE_COMMENTS    = YES
REFERENCED_BY_RELATION = YES
REFERENCES_RELATION    = YES
USE_HTAGS              = NO
VERBATIM_HEADERS       = YES
#---------------------------------------------------------------------------
# configuration options related to the alphabetical class index
#---------------------------------------------------------------------------
ALPHABETICAL_INDEX     = NO
COLS_IN_ALPHA_INDEX    = 5
IGNORE_PREFIX          = 
#---------------------------------------------------------------------------
# configuration options related to the HTML output
#---------------------------------------------------------------------------
GENERATE_HTML          = YES
HTML_OUTPUT            = html
HTML_FILE_EXTENSION    = .html
HTML_HEADER            = 
HTML_FOOTER            = 
HTML_STYLESHEET        = 
HTML_ALIGN_MEMBERS     = YES
GENERATE_HTMLHELP      = NO
CHM_FILE               = 
HHC_LOCATION           = 
GENERATE_CHI           = NO
BINARY_TOC             = NO
TOC_EXPAND             = NO
DISABLE_INDEX          = NO
ENUM_VALUES_PER_LINE   = 4
GENERATE_TREEVIEW      = NO
TREEVIEW_WIDTH         = 250
#---------------------------------------------------------------------------
# configuration options related to the LaTeX output
#---------------------------------------------------------------------------
GENERATE_LATEX         = NO
LATEX_OUTPUT           = latex
LATEX_CMD_NAME         = latex
MAKEINDEX_CMD_NAME     = makeindex
COMPACT_LATEX          = NO
PAPER_TYPE             = a4wide
EXTRA_PACKAGES         = 
LATEX_HEADER           = 
PDF_HYPERLINKS         = NO
USE_PDFLATEX           = NO
LATEX_BATCHMODE        = NO
LATEX_HIDE_INDICES     = NO
#---------------------------------------------------------------------------
# configuration options related to the RTF output
#---------------------------------------------------------------------------
GENERATE_RTF           = NO
RTF_OUTPUT             = rtf
COMPACT_RTF            = NO
RTF_HYPERLINKS         = NO
RTF_STYLESHEET_FILE    = 
RTF_EXTENSIONS_FILE    = 
#---------------------------------------------------------------------------
# configuration options related to the man page output
#---------------------------------------------------------------------------
GENERATE_MAN           = NO
MAN_OUTPUT             = man
MAN_EXTENSION          = .3
MAN_LINKS              = NO
#---------------------------------------------------------------------------
# configuration options related to the XML output
#---------------------------------------------------------------------------
GENERATE_XML           = NO
XML_OUTPUT             = xml
XML_SCHEMA             = 
XML_DTD                = 
XML_PROGRAMLISTING     = YES
#---------------------------------------------------------------------------
# configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------
GENERATE_AUTOGEN_DEF   = NO
#---------------------------------------------------------------------------
# configuration options related to the Perl module output
#---------------------------------------------------------------------------
GENERATE_PERLMOD       = NO
PERLMOD_LATEX          = NO
PERLMOD_PRETTY         = YES
PERLMOD_MAKEVAR_PREFIX = 
#---------------------------------------------------------------------------
# Configuration options related to the preprocessor   
#---------------------------------------------------------------------------
ENABLE_PREPROCESSING   = YES
MACRO_EXPANSION        = NO
EXPAND_ONLY_PREDEF     = NO
SEARCH_INCLUDES        = YES
INCLUDE_PATH           = 
INCLUDE_FILE_PATTERNS  = 
PREDEFINED             = 
EXPAND_AS_DEFINED      = 
SKIP_FUNCTION_MACROS   = YES
#---------------------------------------------------------------------------
# Configuration::additions related to external references   
#---------------------------------------------------------------------------
TAGFILES               = 
GENERATE_TAGFILE       = 
ALLEXTERNALS           = NO
EXTERNAL_GROUPS        = YES
PERL_PATH              = /usr/bin/perl
#---------------------------------------------------------------------------
# Configuration options related to the dot tool   
#---------------------------------------------------------------------------
CLASS_DIAGRAMS         = YES
HIDE_UNDOC_RELATIONS   = YES
HAVE_DOT               = YES
CLASS_GRAPH            = YES
COLLABORATION_GRAPH    = YES
GROUP_GRAPHS           = YES
UML_LOOK               = NO
TEMPLATE_RELATIONS     = NO
INCLUDE_GRAPH          = YES
INCLUDED_BY_GRAPH      = YES
CALL_GRAPH             = NO
GRAPHICAL_HIERARCHY    = YES
DIRECTORY_GRAPH        = YES
DOT_IMAGE_FORMAT       = png
DOT_PATH               = /Applications/Graphviz.app/Contents/MacOS
DOTFILE_DIRS           = 
MAX_DOT_GRAPH_WIDTH    = 1024
MAX_DOT_GRAPH_HEIGHT   = 1024
MAX_DOT_GRAPH_DEPTH    = 0
DOT_TRANSPARENT        = NO
DOT_MULTI_TARGETS      = NO
GENERATE_LEGEND        = YES
DOT_CLEANUP            = YES
#---------------------------------------------------------------------------
# Configuration::additions related to the search engine   
#---------------------------------------------------------------------------
SEARCHENGINE           = NO

```

`ThirdParty/Squish/Makefile`:

```

include config

SRC = alpha.cpp clusterfit.cpp colourblock.cpp colourfit.cpp colourset.cpp maths.cpp rangefit.cpp singlecolourfit.cpp squish.cpp

OBJ = $(SRC:%.cpp=%.o)

LIB = libsquish.a

all : $(LIB)

install : $(LIB)
	install squish.h $(INSTALL_DIR)/include 
	install libsquish.a $(INSTALL_DIR)/lib

uninstall:
	$(RM) $(INSTALL_DIR)/include/squish.h
	$(RM) $(INSTALL_DIR)/lib/libsquish.a

$(LIB) : $(OBJ)
	$(AR) cr $@ $?
	ranlib $@

%.o : %.cpp
	$(CXX) $(CPPFLAGS) -I. $(CXXFLAGS) -o$@ -c $<

clean :
	$(RM) $(OBJ) $(LIB)




```

`ThirdParty/Squish/README`:

```
LICENSE
-------

The squish library is distributed under the terms and conditions of the MIT
license. This license is specified at the top of each source file and must be
preserved in its entirety.

BUILDING AND INSTALLING THE LIBRARY
-----------------------------------

If you are using Visual Studio 2003 or above under Windows then load the Visual
Studio 2003 project in the vs7 folder. By default, the library is built using
SSE2 optimisations. To change this either change or remove the SQUISH_USE_SSE=2
from the preprocessor symbols.

If you are using a Mac then load the Xcode 2.2 project in the distribution. By
default, the library is built using Altivec optimisations. To change this
either change or remove SQUISH_USE_ALTIVEC=1 from the preprocessor symbols. I
guess I'll have to think about changing this for the new Intel Macs that are
rolling out...

If you are using unix then first edit the config file in the base directory of
the distribution, enabling Altivec or SSE with the USE_ALTIVEC or USE_SSE
variables, and editing the optimisation flags passed to the C++ compiler if
necessary. Then make can be used to build the library, and make install (from
the superuser account) can be used to install (into /usr/local by default).

REPORTING BUGS OR FEATURE REQUESTS
----------------------------------

Feedback can be sent to Simon Brown (the developer) at si@sjbrown.co.uk

New releases are announced on the squish library homepage at
http://sjbrown.co.uk/?code=squish


```

`ThirdParty/Squish/alpha.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

   -------------------------------------------------------------------------- */

#include "alpha.h"
#include <algorithm>

namespace squish {

static int FloatToInt( float a, int limit )
{
	// use ANSI round-to-zero behaviour to get round-to-nearest
	int i = ( int )( a + 0.5f );

	// clamp to the limit
	if( i < 0 )
		i = 0;
	else if( i > limit )
		i = limit;

	// done
	return i;
}

void CompressAlphaDxt3( u8 const* rgba, int mask, void* block )
{
	u8* bytes = reinterpret_cast< u8* >( block );

	// quantise and pack the alpha values pairwise
	for( int i = 0; i < 8; ++i )
	{
		// quantise down to 4 bits
		float alpha1 = ( float )rgba[8*i + 3] * ( 15.0f/255.0f );
		float alpha2 = ( float )rgba[8*i + 7] * ( 15.0f/255.0f );
		int quant1 = FloatToInt( alpha1, 15 );
		int quant2 = FloatToInt( alpha2, 15 );

		// set alpha to zero where masked
		int bit1 = 1 << ( 2*i );
		int bit2 = 1 << ( 2*i + 1 );
		if( ( mask & bit1 ) == 0 )
			quant1 = 0;
		if( ( mask & bit2 ) == 0 )
			quant2 = 0;

		// pack into the byte
		bytes[i] = ( u8 )( quant1 | ( quant2 << 4 ) );
	}
}

void DecompressAlphaDxt3( u8* rgba, void const* block )
{
	u8 const* bytes = reinterpret_cast< u8 const* >( block );

	// unpack the alpha values pairwise
	for( int i = 0; i < 8; ++i )
	{
		// quantise down to 4 bits
		u8 quant = bytes[i];

		// unpack the values
		u8 lo = quant & 0x0f;
		u8 hi = quant & 0xf0;

		// convert back up to bytes
		rgba[8*i + 3] = lo | ( lo << 4 );
		rgba[8*i + 7] = hi | ( hi >> 4 );
	}
}

static void FixRange( int& min, int& max, int steps )
{
	if( max - min < steps )
		max = std::min( min + steps, 255 );
	if( max - min < steps )
		min = std::max( 0, max - steps );
}

static int FitCodes( u8 const* rgba, int mask, u8 const* codes, u8* indices )
{
	// fit each alpha value to the codebook
	int err = 0;
	for( int i = 0; i < 16; ++i )
	{
		// check this pixel is valid
		int bit = 1 << i;
		if( ( mask & bit ) == 0 )
		{
			// use the first code
			indices[i] = 0;
			continue;
		}

		// find the least error and corresponding index
		int value = rgba[4*i + 3];
		int least = 2000000000;//INT_MAX;
		int index = 0;
		for( int j = 0; j < 8; ++j )
		{
			// get the squared error from this code
			int dist = ( int )value - ( int )codes[j];
			dist *= dist;

			// compare with the best so far
			if( dist < least )
			{
				least = dist;
				index = j;
			}
		}

		// save this index and accumulate the error
		indices[i] = ( u8 )index;
		err += least;
	}

	// return the total error
	return err;
}

static void WriteAlphaBlock( int alpha0, int alpha1, u8 const* indices, void* block )
{
	u8* bytes = reinterpret_cast< u8* >( block );

	// write the first two bytes
	bytes[0] = ( u8 )alpha0;
	bytes[1] = ( u8 )alpha1;

	// pack the indices with 3 bits each
	u8* dest = bytes + 2;
	u8 const* src = indices;
	for( int i = 0; i < 2; ++i )
	{
		// pack 8 3-bit values
		int value = 0;
		for( int j = 0; j < 8; ++j )
		{
			int index = *src++;
			value |= ( index << 3*j );
		}

		// store in 3 bytes
		for( int j = 0; j < 3; ++j )
		{
			int byte = ( value >> 8*j ) & 0xff;
			*dest++ = ( u8 )byte;
		}
	}
}

static void WriteAlphaBlock5( int alpha0, int alpha1, u8 const* indices, void* block )
{
	// check the relative values of the endpoints
	if( alpha0 > alpha1 )
	{
		// swap the indices
		u8 swapped[16];
		for( int i = 0; i < 16; ++i )
		{
			u8 index = indices[i];
			if( index == 0 )
				swapped[i] = 1;
			else if( index == 1 )
				swapped[i] = 0;
			else if( index <= 5 )
				swapped[i] = 7 - index;
			else
				swapped[i] = index;
		}

		// write the block
		WriteAlphaBlock( alpha1, alpha0, swapped, block );
	}
	else
	{
		// write the block
		WriteAlphaBlock( alpha0, alpha1, indices, block );
	}
}

static void WriteAlphaBlock7( int alpha0, int alpha1, u8 const* indices, void* block )
{
	// check the relative values of the endpoints
	if( alpha0 < alpha1 )
	{
		// swap the indices
		u8 swapped[16];
		for( int i = 0; i < 16; ++i )
		{
			u8 index = indices[i];
			if( index == 0 )
				swapped[i] = 1;
			else if( index == 1 )
				swapped[i] = 0;
			else
				swapped[i] = 9 - index;
		}

		// write the block
		WriteAlphaBlock( alpha1, alpha0, swapped, block );
	}
	else
	{
		// write the block
		WriteAlphaBlock( alpha0, alpha1, indices, block );
	}
}

void CompressAlphaDxt5( u8 const* rgba, int mask, void* block )
{
	// get the range for 5-alpha and 7-alpha interpolation
	int min5 = 255;
	int max5 = 0;
	int min7 = 255;
	int max7 = 0;
	for( int i = 0; i < 16; ++i )
	{
		// check this pixel is valid
		int bit = 1 << i;
		if( ( mask & bit ) == 0 )
			continue;

		// incorporate into the min/max
		int value = rgba[4*i + 3];
		if( value < min7 )
			min7 = value;
		if( value > max7 )
			max7 = value;
		if( value != 0 && value < min5 )
			min5 = value;
		if( value != 255 && value > max5 )
			max5 = value;
	}

	// handle the case that no valid range was found
	if( min5 > max5 )
		min5 = max5;
	if( min7 > max7 )
		min7 = max7;

	// fix the range to be the minimum in each case
	FixRange( min5, max5, 5 );
	FixRange( min7, max7, 7 );

	// set up the 5-alpha code book
	u8 codes5[8];
	codes5[0] = ( u8 )min5;
	codes5[1] = ( u8 )max5;
	for( int i = 1; i < 5; ++i )
		codes5[1 + i] = ( u8 )( ( ( 5 - i )*min5 + i*max5 )/5 );
	codes5[6] = 0;
	codes5[7] = 255;

	// set up the 7-alpha code book
	u8 codes7[8];
	codes7[0] = ( u8 )min7;
	codes7[1] = ( u8 )max7;
	for( int i = 1; i < 7; ++i )
		codes7[1 + i] = ( u8 )( ( ( 7 - i )*min7 + i*max7 )/7 );

	// fit the data to both code books
	u8 indices5[16];
	u8 indices7[16];
	int err5 = FitCodes( rgba, mask, codes5, indices5 );
	int err7 = FitCodes( rgba, mask, codes7, indices7 );

	// save the block with least error
	if( err5 <= err7 )
		WriteAlphaBlock5( min5, max5, indices5, block );
	else
		WriteAlphaBlock7( min7, max7, indices7, block );
}

void DecompressAlphaDxt5( u8* rgba, void const* block )
{
	// get the two alpha values
	u8 const* bytes = reinterpret_cast< u8 const* >( block );
	int alpha0 = bytes[0];
	int alpha1 = bytes[1];

	// compare the values to build the codebook
	u8 codes[8];
	codes[0] = ( u8 )alpha0;
	codes[1] = ( u8 )alpha1;
	if( alpha0 <= alpha1 )
	{
		// use 5-alpha codebook
		for( int i = 1; i < 5; ++i )
			codes[1 + i] = ( u8 )( ( ( 5 - i )*alpha0 + i*alpha1 )/5 );
		codes[6] = 0;
		codes[7] = 255;
	}
	else
	{
		// use 7-alpha codebook
		for( int i = 1; i < 7; ++i )
			codes[1 + i] = ( u8 )( ( ( 7 - i )*alpha0 + i*alpha1 )/7 );
	}

	// decode the indices
	u8 indices[16];
	u8 const* src = bytes + 2;
	u8* dest = indices;
	for( int i = 0; i < 2; ++i )
	{
		// grab 3 bytes
		int value = 0;
		for( int j = 0; j < 3; ++j )
		{
			int byte = *src++;
			value |= ( byte << 8*j );
		}

		// unpack 8 3-bit values from it
		for( int j = 0; j < 8; ++j )
		{
			int index = ( value >> 3*j ) & 0x7;
			*dest++ = ( u8 )index;
		}
	}

	// write out the indexed codebook values
	for( int i = 0; i < 16; ++i )
		rgba[4*i + 3] = codes[indices[i]];
}

} // namespace squish

```

`ThirdParty/Squish/alpha.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_ALPHA_H
#define SQUISH_ALPHA_H

#include <squish.h>

namespace squish {

void CompressAlphaDxt3( u8 const* rgba, int mask, void* block );
void CompressAlphaDxt5( u8 const* rgba, int mask, void* block );

void DecompressAlphaDxt3( u8* rgba, void const* block );
void DecompressAlphaDxt5( u8* rgba, void const* block );

} // namespace squish

#endif // ndef SQUISH_ALPHA_H

```

`ThirdParty/Squish/clusterfit.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk
	Copyright (c) 2007 Ignacio Castano                   icastano@nvidia.com

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#include "clusterfit.h"
#include "colourset.h"
#include "colourblock.h"
#include <cfloat>

namespace squish {

ClusterFit::ClusterFit( ColourSet const* colours, int flags ) 
  : ColourFit( colours, flags )
{
	// set the iteration count
	m_iterationCount = ( m_flags & kColourIterativeClusterFit ) ? kMaxIterations : 1;

	// initialise the best error
	m_besterror = VEC4_CONST( FLT_MAX );

	// initialise the metric
	bool perceptual = ( ( m_flags & kColourMetricPerceptual ) != 0 );
	if( perceptual )
		m_metric = Vec4( 0.2126f, 0.7152f, 0.0722f, 0.0f );
	else
		m_metric = VEC4_CONST( 1.0f );	

	// cache some values
	int const count = m_colours->GetCount();
	Vec3 const* values = m_colours->GetPoints();

	// get the covariance matrix
	Sym3x3 covariance = ComputeWeightedCovariance( count, values, m_colours->GetWeights() );
	
	// compute the principle component
	m_principle = ComputePrincipleComponent( covariance );
}

bool ClusterFit::ConstructOrdering( Vec3 const& axis, int iteration )
{
	// cache some values
	int const count = m_colours->GetCount();
	Vec3 const* values = m_colours->GetPoints();

	// build the list of dot products
	float dps[16];
	u8* order = ( u8* )m_order + 16*iteration;
	for( int i = 0; i < count; ++i )
	{
		dps[i] = Dot( values[i], axis );
		order[i] = ( u8 )i;
	}
		
	// stable sort using them
	for( int i = 0; i < count; ++i )
	{
		for( int j = i; j > 0 && dps[j] < dps[j - 1]; --j )
		{
			std::swap( dps[j], dps[j - 1] );
			std::swap( order[j], order[j - 1] );
		}
	}
	
	// check this ordering is unique
	for( int it = 0; it < iteration; ++it )
	{
		u8 const* prev = ( u8* )m_order + 16*it;
		bool same = true;
		for( int i = 0; i < count; ++i )
		{
			if( order[i] != prev[i] )
			{
				same = false;
				break;
			}
		}
		if( same )
			return false;
	}
	
	// copy the ordering and weight all the points
	Vec3 const* unweighted = m_colours->GetPoints();
	float const* weights = m_colours->GetWeights();
	m_xsum_wsum = VEC4_CONST( 0.0f );
	for( int i = 0; i < count; ++i )
	{
		int j = order[i];
		Vec4 p( unweighted[j].X(), unweighted[j].Y(), unweighted[j].Z(), 1.0f );
		Vec4 w( weights[j] );
		Vec4 x = p*w;
		m_points_weights[i] = x;
		m_xsum_wsum += x;
	}
	return true;
}

void ClusterFit::Compress3( void* block )
{
	// declare variables
	int const count = m_colours->GetCount();
	Vec4 const two = VEC4_CONST( 2.0 );
	Vec4 const one = VEC4_CONST( 1.0f );
	Vec4 const half_half2( 0.5f, 0.5f, 0.5f, 0.25f );
	Vec4 const zero = VEC4_CONST( 0.0f );
	Vec4 const half = VEC4_CONST( 0.5f );
	Vec4 const grid( 31.0f, 63.0f, 31.0f, 0.0f );
	Vec4 const gridrcp( 1.0f/31.0f, 1.0f/63.0f, 1.0f/31.0f, 0.0f );

	// prepare an ordering using the principle axis
	ConstructOrdering( m_principle, 0 );
	
	// check all possible clusters and iterate on the total order
	Vec4 beststart = VEC4_CONST( 0.0f );
	Vec4 bestend = VEC4_CONST( 0.0f );
	Vec4 besterror = m_besterror;
	u8 bestindices[16];
	int bestiteration = 0;
	int besti = 0, bestj = 0;
	
	// loop over iterations (we avoid the case that all points in first or last cluster)
	for( int iterationIndex = 0;; )
	{
		// first cluster [0,i) is at the start
		Vec4 part0 = VEC4_CONST( 0.0f );
		for( int i = 0; i < count; ++i )
		{
			// second cluster [i,j) is half along
			Vec4 part1 = ( i == 0 ) ? m_points_weights[0] : VEC4_CONST( 0.0f );
			int jmin = ( i == 0 ) ? 1 : i;
			for( int j = jmin;; )
			{
				// last cluster [j,count) is at the end
				Vec4 part2 = m_xsum_wsum - part1 - part0;
				
				// compute least squares terms directly
				Vec4 alphax_sum = MultiplyAdd( part1, half_half2, part0 );
				Vec4 alpha2_sum = alphax_sum.SplatW();

				Vec4 betax_sum = MultiplyAdd( part1, half_half2, part2 );
				Vec4 beta2_sum = betax_sum.SplatW();

				Vec4 alphabeta_sum = ( part1*half_half2 ).SplatW();

				// compute the least-squares optimal points
				Vec4 factor = Reciprocal( NegativeMultiplySubtract( alphabeta_sum, alphabeta_sum, alpha2_sum*beta2_sum ) );
				Vec4 a = NegativeMultiplySubtract( betax_sum, alphabeta_sum, alphax_sum*beta2_sum )*factor;
				Vec4 b = NegativeMultiplySubtract( alphax_sum, alphabeta_sum, betax_sum*alpha2_sum )*factor;

				// clamp to the grid
				a = Min( one, Max( zero, a ) );
				b = Min( one, Max( zero, b ) );
				a = Truncate( MultiplyAdd( grid, a, half ) )*gridrcp;
				b = Truncate( MultiplyAdd( grid, b, half ) )*gridrcp;
				
				// compute the error (we skip the constant xxsum)
				Vec4 e1 = MultiplyAdd( a*a, alpha2_sum, b*b*beta2_sum );
				Vec4 e2 = NegativeMultiplySubtract( a, alphax_sum, a*b*alphabeta_sum );
				Vec4 e3 = NegativeMultiplySubtract( b, betax_sum, e2 );
				Vec4 e4 = MultiplyAdd( two, e3, e1 );

				// apply the metric to the error term
				Vec4 e5 = e4*m_metric;
				Vec4 error = e5.SplatX() + e5.SplatY() + e5.SplatZ();
				
				// keep the solution if it wins
				if( CompareAnyLessThan( error, besterror ) )
				{
					beststart = a;
					bestend = b;
					besti = i;
					bestj = j;
					besterror = error;
					bestiteration = iterationIndex;
				}

				// advance
				if( j == count )
					break;
				part1 += m_points_weights[j];
				++j;
			}

			// advance
			part0 += m_points_weights[i];
		}
		
		// stop if we didn't improve in this iteration
		if( bestiteration != iterationIndex )
			break;
			
		// advance if possible
		++iterationIndex;
		if( iterationIndex == m_iterationCount )
			break;
			
		// stop if a new iteration is an ordering that has already been tried
		Vec3 axis = ( bestend - beststart ).GetVec3();
		if( !ConstructOrdering( axis, iterationIndex ) )
			break;
	}
		
	// save the block if necessary
	if( CompareAnyLessThan( besterror, m_besterror ) )
	{
		// remap the indices
		u8 const* order = ( u8* )m_order + 16*bestiteration;

		u8 unordered[16];
		for( int m = 0; m < besti; ++m )
			unordered[order[m]] = 0;
		for( int m = besti; m < bestj; ++m )
			unordered[order[m]] = 2;
		for( int m = bestj; m < count; ++m )
			unordered[order[m]] = 1;

		m_colours->RemapIndices( unordered, bestindices );
		
		// save the block
		WriteColourBlock3( beststart.GetVec3(), bestend.GetVec3(), bestindices, block );

		// save the error
		m_besterror = besterror;
	}
}

void ClusterFit::Compress4( void* block )
{
	// declare variables
	int const count = m_colours->GetCount();
	Vec4 const two = VEC4_CONST( 2.0f );
	Vec4 const one = VEC4_CONST( 1.0f );
	Vec4 const onethird_onethird2( 1.0f/3.0f, 1.0f/3.0f, 1.0f/3.0f, 1.0f/9.0f );
	Vec4 const twothirds_twothirds2( 2.0f/3.0f, 2.0f/3.0f, 2.0f/3.0f, 4.0f/9.0f );
	Vec4 const twonineths = VEC4_CONST( 2.0f/9.0f );
	Vec4 const zero = VEC4_CONST( 0.0f );
	Vec4 const half = VEC4_CONST( 0.5f );
	Vec4 const grid( 31.0f, 63.0f, 31.0f, 0.0f );
	Vec4 const gridrcp( 1.0f/31.0f, 1.0f/63.0f, 1.0f/31.0f, 0.0f );

	// prepare an ordering using the principle axis
	ConstructOrdering( m_principle, 0 );
	
	// check all possible clusters and iterate on the total order
	Vec4 beststart = VEC4_CONST( 0.0f );
	Vec4 bestend = VEC4_CONST( 0.0f );
	Vec4 besterror = m_besterror;
	u8 bestindices[16];
	int bestiteration = 0;
	int besti = 0, bestj = 0, bestk = 0;
	
	// loop over iterations (we avoid the case that all points in first or last cluster)
	for( int iterationIndex = 0;; )
	{
		// first cluster [0,i) is at the start
		Vec4 part0 = VEC4_CONST( 0.0f );
		for( int i = 0; i < count; ++i )
		{
			// second cluster [i,j) is one third along
			Vec4 part1 = VEC4_CONST( 0.0f );
			for( int j = i;; )
			{
				// third cluster [j,k) is two thirds along
				Vec4 part2 = ( j == 0 ) ? m_points_weights[0] : VEC4_CONST( 0.0f );
				int kmin = ( j == 0 ) ? 1 : j;
				for( int k = kmin;; )
				{
					// last cluster [k,count) is at the end
					Vec4 part3 = m_xsum_wsum - part2 - part1 - part0;

					// compute least squares terms directly
					Vec4 const alphax_sum = MultiplyAdd( part2, onethird_onethird2, MultiplyAdd( part1, twothirds_twothirds2, part0 ) );
					Vec4 const alpha2_sum = alphax_sum.SplatW();
					
					Vec4 const betax_sum = MultiplyAdd( part1, onethird_onethird2, MultiplyAdd( part2, twothirds_twothirds2, part3 ) );
					Vec4 const beta2_sum = betax_sum.SplatW();
					
					Vec4 const alphabeta_sum = twonineths*( part1 + part2 ).SplatW();

					// compute the least-squares optimal points
					Vec4 factor = Reciprocal( NegativeMultiplySubtract( alphabeta_sum, alphabeta_sum, alpha2_sum*beta2_sum ) );
					Vec4 a = NegativeMultiplySubtract( betax_sum, alphabeta_sum, alphax_sum*beta2_sum )*factor;
					Vec4 b = NegativeMultiplySubtract( alphax_sum, alphabeta_sum, betax_sum*alpha2_sum )*factor;

					// clamp to the grid
					a = Min( one, Max( zero, a ) );
					b = Min( one, Max( zero, b ) );
					a = Truncate( MultiplyAdd( grid, a, half ) )*gridrcp;
					b = Truncate( MultiplyAdd( grid, b, half ) )*gridrcp;
					
					// compute the error (we skip the constant xxsum)
					Vec4 e1 = MultiplyAdd( a*a, alpha2_sum, b*b*beta2_sum );
					Vec4 e2 = NegativeMultiplySubtract( a, alphax_sum, a*b*alphabeta_sum );
					Vec4 e3 = NegativeMultiplySubtract( b, betax_sum, e2 );
					Vec4 e4 = MultiplyAdd( two, e3, e1 );

					// apply the metric to the error term
					Vec4 e5 = e4*m_metric;
					Vec4 error = e5.SplatX() + e5.SplatY() + e5.SplatZ();

					// keep the solution if it wins
					if( CompareAnyLessThan( error, besterror ) )
					{
						beststart = a;
						bestend = b;
						besterror = error;
						besti = i;
						bestj = j;
						bestk = k;
						bestiteration = iterationIndex;
					}

					// advance
					if( k == count )
						break;
					part2 += m_points_weights[k];
					++k;
				}

				// advance
				if( j == count )
					break;
				part1 += m_points_weights[j];
				++j;
			}

			// advance
			part0 += m_points_weights[i];
		}
		
		// stop if we didn't improve in this iteration
		if( bestiteration != iterationIndex )
			break;
			
		// advance if possible
		++iterationIndex;
		if( iterationIndex == m_iterationCount )
			break;
			
		// stop if a new iteration is an ordering that has already been tried
		Vec3 axis = ( bestend - beststart ).GetVec3();
		if( !ConstructOrdering( axis, iterationIndex ) )
			break;
	}

	// save the block if necessary
	if( CompareAnyLessThan( besterror, m_besterror ) )
	{
		// remap the indices
		u8 const* order = ( u8* )m_order + 16*bestiteration;

		u8 unordered[16];
		for( int m = 0; m < besti; ++m )
			unordered[order[m]] = 0;
		for( int m = besti; m < bestj; ++m )
			unordered[order[m]] = 2;
		for( int m = bestj; m < bestk; ++m )
			unordered[order[m]] = 3;
		for( int m = bestk; m < count; ++m )
			unordered[order[m]] = 1;

		m_colours->RemapIndices( unordered, bestindices );
		
		// save the block
		WriteColourBlock4( beststart.GetVec3(), bestend.GetVec3(), bestindices, block );

		// save the error
		m_besterror = besterror;
	}
}

} // namespace squish

```

`ThirdParty/Squish/clusterfit.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk
	Copyright (c) 2007 Ignacio Castano                   icastano@nvidia.com

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_CLUSTERFIT_H
#define SQUISH_CLUSTERFIT_H

#include <squish.h>
#include "maths.h"
#include "simd.h"
#include "colourfit.h"

namespace squish {

class ClusterFit : public ColourFit
{
public:
	ClusterFit( ColourSet const* colours, int flags );
	
private:
	bool ConstructOrdering( Vec3 const& axis, int iteration );

	virtual void Compress3( void* block );
	virtual void Compress4( void* block );

	enum { kMaxIterations = 8 };

	int m_iterationCount;
	Vec3 m_principle;
	u8 m_order[16*kMaxIterations];
	Vec4 m_points_weights[16];
	Vec4 m_xsum_wsum;
	Vec4 m_metric;
	Vec4 m_besterror;
};

} // namespace squish

#endif // ndef SQUISH_CLUSTERFIT_H

```

`ThirdParty/Squish/colourblock.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#include "colourblock.h"

namespace squish {

static int FloatToInt( float a, int limit )
{
	// use ANSI round-to-zero behaviour to get round-to-nearest
	int i = ( int )( a + 0.5f );

	// clamp to the limit
	if( i < 0 )
		i = 0;
	else if( i > limit )
		i = limit; 

	// done
	return i;
}

static int FloatTo565( Vec3::Arg colour )
{
	// get the components in the correct range
	int r = FloatToInt( 31.0f*colour.X(), 31 );
	int g = FloatToInt( 63.0f*colour.Y(), 63 );
	int b = FloatToInt( 31.0f*colour.Z(), 31 );
	
	// pack into a single value
	return ( r << 11 ) | ( g << 5 ) | b;
}

static void WriteColourBlock( int a, int b, u8* indices, void* block )
{
	// get the block as bytes
	u8* bytes = ( u8* )block;

	// write the endpoints
	bytes[0] = ( u8 )( a & 0xff );
	bytes[1] = ( u8 )( a >> 8 );
	bytes[2] = ( u8 )( b & 0xff );
	bytes[3] = ( u8 )( b >> 8 );
	
	// write the indices
	for( int i = 0; i < 4; ++i )
	{
		u8 const* ind = indices + 4*i;
		bytes[4 + i] = ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 );
	}
}

void WriteColourBlock3( Vec3::Arg start, Vec3::Arg end, u8 const* indices, void* block )
{
	// get the packed values
	int a = FloatTo565( start );
	int b = FloatTo565( end );

	// remap the indices
	u8 remapped[16];
	if( a <= b )
	{
		// use the indices directly
		for( int i = 0; i < 16; ++i )
			remapped[i] = indices[i];
	}
	else
	{
		// swap a and b
		std::swap( a, b );
		for( int i = 0; i < 16; ++i )
		{
			if( indices[i] == 0 )
				remapped[i] = 1;
			else if( indices[i] == 1 )
				remapped[i] = 0;
			else
				remapped[i] = indices[i];
		}
	}
	
	// write the block
	WriteColourBlock( a, b, remapped, block );
}

void WriteColourBlock4( Vec3::Arg start, Vec3::Arg end, u8 const* indices, void* block )
{
	// get the packed values
	int a = FloatTo565( start );
	int b = FloatTo565( end );

	// remap the indices
	u8 remapped[16];
	if( a < b )
	{
		// swap a and b
		std::swap( a, b );
		for( int i = 0; i < 16; ++i )
			remapped[i] = ( indices[i] ^ 0x1 ) & 0x3;
	}
	else if( a == b )
	{
		// use index 0
		for( int i = 0; i < 16; ++i )
			remapped[i] = 0;
	}
	else
	{
		// use the indices directly
		for( int i = 0; i < 16; ++i )
			remapped[i] = indices[i];
	}
	
	// write the block
	WriteColourBlock( a, b, remapped, block );
}

static int Unpack565( u8 const* packed, u8* colour )
{
	// build the packed value
	int value = ( int )packed[0] | ( ( int )packed[1] << 8 );
	
	// get the components in the stored range
	u8 red = ( u8 )( ( value >> 11 ) & 0x1f );
	u8 green = ( u8 )( ( value >> 5 ) & 0x3f );
	u8 blue = ( u8 )( value & 0x1f );

	// scale up to 8 bits
	colour[0] = ( red << 3 ) | ( red >> 2 );
	colour[1] = ( green << 2 ) | ( green >> 4 );
	colour[2] = ( blue << 3 ) | ( blue >> 2 );
	colour[3] = 255;
	
	// return the value
	return value;
}

void DecompressColour( u8* rgba, void const* block, bool isDxt1 )
{
	// get the block bytes
	u8 const* bytes = reinterpret_cast< u8 const* >( block );
	
	// unpack the endpoints
	u8 codes[16];
	int a = Unpack565( bytes, codes );
	int b = Unpack565( bytes + 2, codes + 4 );
	
	// generate the midpoints
	for( int i = 0; i < 3; ++i )
	{
		int c = codes[i];
		int d = codes[4 + i];

		if( isDxt1 && a <= b )
		{
			codes[8 + i] = ( u8 )( ( c + d )/2 );
			codes[12 + i] = 0;
		}
		else
		{
			codes[8 + i] = ( u8 )( ( 2*c + d )/3 );
			codes[12 + i] = ( u8 )( ( c + 2*d )/3 );
		}
	}
	
	// fill in alpha for the intermediate values
	codes[8 + 3] = 255;
	codes[12 + 3] = ( isDxt1 && a <= b ) ? 0 : 255;
	
	// unpack the indices
	u8 indices[16];
	for( int i = 0; i < 4; ++i )
	{
		u8* ind = indices + 4*i;
		u8 packed = bytes[4 + i];
		
		ind[0] = packed & 0x3;
		ind[1] = ( packed >> 2 ) & 0x3;
		ind[2] = ( packed >> 4 ) & 0x3;
		ind[3] = ( packed >> 6 ) & 0x3;
	}

	// store out the colours
	for( int i = 0; i < 16; ++i )
	{
		u8 offset = 4*indices[i];
		for( int j = 0; j < 4; ++j )
			rgba[4*i + j] = codes[offset + j];
	}
}

} // namespace squish

```

`ThirdParty/Squish/colourblock.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_COLOURBLOCK_H
#define SQUISH_COLOURBLOCK_H

#include <squish.h>
#include "maths.h"

namespace squish {

void WriteColourBlock3( Vec3::Arg start, Vec3::Arg end, u8 const* indices, void* block );
void WriteColourBlock4( Vec3::Arg start, Vec3::Arg end, u8 const* indices, void* block );

void DecompressColour( u8* rgba, void const* block, bool isDxt1 );

} // namespace squish

#endif // ndef SQUISH_COLOURBLOCK_H

```

`ThirdParty/Squish/colourfit.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#include "colourfit.h"
#include "colourset.h"

namespace squish {

ColourFit::ColourFit( ColourSet const* colours, int flags ) 
  : m_colours( colours ), 
	m_flags( flags )
{
}

void ColourFit::Compress( void* block )
{
	bool isDxt1 = ( ( m_flags & kDxt1 ) != 0 );
	if( isDxt1 )
	{
		Compress3( block );
		if( !m_colours->IsTransparent() )
			Compress4( block );
	}
	else
		Compress4( block );
}

} // namespace squish

```

`ThirdParty/Squish/colourfit.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_COLOURFIT_H
#define SQUISH_COLOURFIT_H

#include <squish.h>
#include "maths.h"

namespace squish {

class ColourSet;

class ColourFit
{
public:
	ColourFit( ColourSet const* colours, int flags );

	void Compress( void* block );

protected:
	virtual void Compress3( void* block ) = 0;
	virtual void Compress4( void* block ) = 0;

	ColourSet const* m_colours;
	int m_flags;
};

} // namespace squish

#endif // ndef SQUISH_COLOURFIT_H

```

`ThirdParty/Squish/colourset.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#include "colourset.h"

namespace squish {

ColourSet::ColourSet( u8 const* rgba, int mask, int flags )
  : m_count( 0 ), 
	m_transparent( false )
{
	// check the compression mode for dxt1
	bool isDxt1 = ( ( flags & kDxt1 ) != 0 );
	bool weightByAlpha = ( ( flags & kWeightColourByAlpha ) != 0 );

	// create the minimal set
	for( int i = 0; i < 16; ++i )
	{
		// check this pixel is enabled
		int bit = 1 << i;
		if( ( mask & bit ) == 0 )
		{
			m_remap[i] = -1;
			continue;
		}
	
		// check for transparent pixels when using dxt1
		if( isDxt1 && rgba[4*i + 3] < 128 )
		{
			m_remap[i] = -1;
			m_transparent = true;
			continue;
		}

		// loop over previous points for a match
		for( int j = 0;; ++j )
		{
			// allocate a new point
			if( j == i )
			{
				// normalise coordinates to [0,1]
				float x = ( float )rgba[4*i] / 255.0f;
				float y = ( float )rgba[4*i + 1] / 255.0f;
				float z = ( float )rgba[4*i + 2] / 255.0f;
				
				// ensure there is always non-zero weight even for zero alpha
				float w = ( float )( rgba[4*i + 3] + 1 ) / 256.0f;

				// add the point
				m_points[m_count] = Vec3( x, y, z );
				m_weights[m_count] = ( weightByAlpha ? w : 1.0f );
				m_remap[i] = m_count;
				
				// advance
				++m_count;
				break;
			}
		
			// check for a match
			int oldbit = 1 << j;
			bool match = ( ( mask & oldbit ) != 0 )
				&& ( rgba[4*i] == rgba[4*j] )
				&& ( rgba[4*i + 1] == rgba[4*j + 1] )
				&& ( rgba[4*i + 2] == rgba[4*j + 2] )
				&& ( rgba[4*j + 3] >= 128 || !isDxt1 );
			if( match )
			{
				// get the index of the match
				int index = m_remap[j];
				
				// ensure there is always non-zero weight even for zero alpha
				float w = ( float )( rgba[4*i + 3] + 1 ) / 256.0f;

				// map to this point and increase the weight
				m_weights[index] += ( weightByAlpha ? w : 1.0f );
				m_remap[i] = index;
				break;
			}
		}
	}

	// square root the weights
	for( int i = 0; i < m_count; ++i )
		m_weights[i] = std::sqrt( m_weights[i] );
}

void ColourSet::RemapIndices( u8 const* source, u8* target ) const
{
	for( int i = 0; i < 16; ++i )
	{
		int j = m_remap[i];
		if( j == -1 )
			target[i] = 3;
		else
			target[i] = source[j];
	}
}

} // namespace squish

```

`ThirdParty/Squish/colourset.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_COLOURSET_H
#define SQUISH_COLOURSET_H

#include <squish.h>
#include "maths.h"

namespace squish {

/*! @brief Represents a set of block colours
*/
class ColourSet
{
public:
	ColourSet( u8 const* rgba, int mask, int flags );

	int GetCount() const { return m_count; }
	Vec3 const* GetPoints() const { return m_points; }
	float const* GetWeights() const { return m_weights; }
	bool IsTransparent() const { return m_transparent; }

	void RemapIndices( u8 const* source, u8* target ) const;

private:
	int m_count;
	Vec3 m_points[16];
	float m_weights[16];
	int m_remap[16];
	bool m_transparent;
};

} // namespace sqish

#endif // ndef SQUISH_COLOURSET_H

```

`ThirdParty/Squish/config`:

```
# config file used for the Makefile only

# define to 1 to use Altivec instructions
USE_ALTIVEC ?= 0

# define to 1 to use SSE2 instructions
USE_SSE ?= 0

# default flags
CXXFLAGS ?= -O2
ifeq ($(USE_ALTIVEC),1)
CPPFLAGS += -DSQUISH_USE_ALTIVEC=1
CXXFLAGS += -maltivec
endif
ifeq ($(USE_SSE),1)
CPPFLAGS += -DSQUISH_USE_SSE=2
CXXFLAGS += -msse
endif

# where should we install to
INSTALL_DIR ?= /usr/local


```

`ThirdParty/Squish/config.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_CONFIG_H
#define SQUISH_CONFIG_H

// Set to 1 when building squish to use Altivec instructions.
#ifndef SQUISH_USE_ALTIVEC
#define SQUISH_USE_ALTIVEC 0
#endif

// Set to 1 or 2 when building squish to use SSE or SSE2 instructions.
#ifndef SQUISH_USE_SSE
#define SQUISH_USE_SSE 0
#endif

// Internally et SQUISH_USE_SIMD when either Altivec or SSE is available.
#if SQUISH_USE_ALTIVEC && SQUISH_USE_SSE
#error "Cannot enable both Altivec and SSE!"
#endif
#if SQUISH_USE_ALTIVEC || SQUISH_USE_SSE
#define SQUISH_USE_SIMD 1
#else
#define SQUISH_USE_SIMD 0
#endif

#endif // ndef SQUISH_CONFIG_H

```

`ThirdParty/Squish/maths.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
/*! @file

	The symmetric eigensystem solver algorithm is from 
	http://www.geometrictools.com/Documentation/EigenSymmetric3x3.pdf
*/

#include "maths.h"
#include <cfloat>

namespace squish {

Sym3x3 ComputeWeightedCovariance( int n, Vec3 const* points, float const* weights )
{
	// compute the centroid
	float total = 0.0f;
	Vec3 centroid( 0.0f );
	for( int i = 0; i < n; ++i )
	{
		total += weights[i];
		centroid += weights[i]*points[i];
	}
	centroid /= total;

	// accumulate the covariance matrix
	Sym3x3 covariance( 0.0f );
	for( int i = 0; i < n; ++i )
	{
		Vec3 a = points[i] - centroid;
		Vec3 b = weights[i]*a;
		
		covariance[0] += a.X()*b.X();
		covariance[1] += a.X()*b.Y();
		covariance[2] += a.X()*b.Z();
		covariance[3] += a.Y()*b.Y();
		covariance[4] += a.Y()*b.Z();
		covariance[5] += a.Z()*b.Z();
	}
	
	// return it
	return covariance;
}

static Vec3 GetMultiplicity1Evector( Sym3x3 const& matrix, float evalue )
{
	// compute M
	Sym3x3 m;
	m[0] = matrix[0] - evalue;
	m[1] = matrix[1];
	m[2] = matrix[2];
	m[3] = matrix[3] - evalue;
	m[4] = matrix[4];
	m[5] = matrix[5] - evalue;

	// compute U
	Sym3x3 u;
	u[0] = m[3]*m[5] - m[4]*m[4];
	u[1] = m[2]*m[4] - m[1]*m[5];
	u[2] = m[1]*m[4] - m[2]*m[3];
	u[3] = m[0]*m[5] - m[2]*m[2];
	u[4] = m[1]*m[2] - m[4]*m[0];
	u[5] = m[0]*m[3] - m[1]*m[1];

	// find the largest component
	float mc = std::fabs( u[0] );
	int mi = 0;
	for( int i = 1; i < 6; ++i )
	{
		float c = std::fabs( u[i] );
		if( c > mc )
		{
			mc = c;
			mi = i;
		}
	}

	// pick the column with this component
	switch( mi )
	{
	case 0:
		return Vec3( u[0], u[1], u[2] );

	case 1:
	case 3:
		return Vec3( u[1], u[3], u[4] );

	default:
		return Vec3( u[2], u[4], u[5] );
	}
}

static Vec3 GetMultiplicity2Evector( Sym3x3 const& matrix, float evalue )
{
	// compute M
	Sym3x3 m;
	m[0] = matrix[0] - evalue;
	m[1] = matrix[1];
	m[2] = matrix[2];
	m[3] = matrix[3] - evalue;
	m[4] = matrix[4];
	m[5] = matrix[5] - evalue;

	// find the largest component
	float mc = std::fabs( m[0] );
	int mi = 0;
	for( int i = 1; i < 6; ++i )
	{
		float c = std::fabs( m[i] );
		if( c > mc )
		{
			mc = c;
			mi = i;
		}
	}

	// pick the first eigenvector based on this index
	switch( mi )
	{
	case 0:
	case 1:
		return Vec3( -m[1], m[0], 0.0f );

	case 2:
		return Vec3( m[2], 0.0f, -m[0] );

	case 3:
	case 4:
		return Vec3( 0.0f, -m[4], m[3] );

	default:
		return Vec3( 0.0f, -m[5], m[4] );
	}
}

Vec3 ComputePrincipleComponent( Sym3x3 const& matrix )
{
	// compute the cubic coefficients
	float c0 = matrix[0]*matrix[3]*matrix[5] 
		+ 2.0f*matrix[1]*matrix[2]*matrix[4] 
		- matrix[0]*matrix[4]*matrix[4] 
		- matrix[3]*matrix[2]*matrix[2] 
		- matrix[5]*matrix[1]*matrix[1];
	float c1 = matrix[0]*matrix[3] + matrix[0]*matrix[5] + matrix[3]*matrix[5]
		- matrix[1]*matrix[1] - matrix[2]*matrix[2] - matrix[4]*matrix[4];
	float c2 = matrix[0] + matrix[3] + matrix[5];

	// compute the quadratic coefficients
	float a = c1 - ( 1.0f/3.0f )*c2*c2;
	float b = ( -2.0f/27.0f )*c2*c2*c2 + ( 1.0f/3.0f )*c1*c2 - c0;

	// compute the root count check
	float Q = 0.25f*b*b + ( 1.0f/27.0f )*a*a*a;

	// test the multiplicity
	if( FLT_EPSILON < Q )
	{
		// only one root, which implies we have a multiple of the identity
        return Vec3( 1.0f );
	}
	else if( Q < -FLT_EPSILON )
	{
		// three distinct roots
		float theta = std::atan2( std::sqrt( -Q ), -0.5f*b );
		float rho = std::sqrt( 0.25f*b*b - Q );

		float rt = std::pow( rho, 1.0f/3.0f );
		float ct = std::cos( theta/3.0f );
		float st = std::sin( theta/3.0f );

		float l1 = ( 1.0f/3.0f )*c2 + 2.0f*rt*ct;
		float l2 = ( 1.0f/3.0f )*c2 - rt*( ct + ( float )sqrt( 3.0f )*st );
		float l3 = ( 1.0f/3.0f )*c2 - rt*( ct - ( float )sqrt( 3.0f )*st );

		// pick the larger
		if( std::fabs( l2 ) > std::fabs( l1 ) )
			l1 = l2;
		if( std::fabs( l3 ) > std::fabs( l1 ) )
			l1 = l3;

		// get the eigenvector
		return GetMultiplicity1Evector( matrix, l1 );
	}
	else // if( -FLT_EPSILON <= Q && Q <= FLT_EPSILON )
	{
		// two roots
		float rt;
		if( b < 0.0f )
			rt = -std::pow( -0.5f*b, 1.0f/3.0f );
		else
			rt = std::pow( 0.5f*b, 1.0f/3.0f );
		
		float l1 = ( 1.0f/3.0f )*c2 + rt;		// repeated
		float l2 = ( 1.0f/3.0f )*c2 - 2.0f*rt;
		
		// get the eigenvector
		if( std::fabs( l1 ) > std::fabs( l2 ) )
			return GetMultiplicity2Evector( matrix, l1 );
		else
			return GetMultiplicity1Evector( matrix, l2 );
	}
}

} // namespace squish

```

`ThirdParty/Squish/maths.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_MATHS_H
#define SQUISH_MATHS_H

#include <cmath>
#include <algorithm>
#include "config.h"

namespace squish {

class Vec3
{
public:
	typedef Vec3 const& Arg;

	Vec3()
	{
	}

	explicit Vec3( float s )
	{
		m_x = s;
		m_y = s;
		m_z = s;
	}

	Vec3( float x, float y, float z )
	{
		m_x = x;
		m_y = y;
		m_z = z;
	}
	
	float X() const { return m_x; }
	float Y() const { return m_y; }
	float Z() const { return m_z; }
	
	Vec3 operator-() const
	{
		return Vec3( -m_x, -m_y, -m_z );
	}
	
	Vec3& operator+=( Arg v )
	{
		m_x += v.m_x;
		m_y += v.m_y;
		m_z += v.m_z;
		return *this;
	}
	
	Vec3& operator-=( Arg v )
	{
		m_x -= v.m_x;
		m_y -= v.m_y;
		m_z -= v.m_z;
		return *this;
	}
	
	Vec3& operator*=( Arg v )
	{
		m_x *= v.m_x;
		m_y *= v.m_y;
		m_z *= v.m_z;
		return *this;
	}
	
	Vec3& operator*=( float s )
	{
		m_x *= s;
		m_y *= s;
		m_z *= s;
		return *this;
	}
	
	Vec3& operator/=( Arg v )
	{
		m_x /= v.m_x;
		m_y /= v.m_y;
		m_z /= v.m_z;
		return *this;
	}
	
	Vec3& operator/=( float s )
	{
		float t = 1.0f/s;
		m_x *= t;
		m_y *= t;
		m_z *= t;
		return *this;
	}
	
	friend Vec3 operator+( Arg left, Arg right )
	{
		Vec3 copy( left );
		return copy += right;
	}
	
	friend Vec3 operator-( Arg left, Arg right )
	{
		Vec3 copy( left );
		return copy -= right;
	}
	
	friend Vec3 operator*( Arg left, Arg right )
	{
		Vec3 copy( left );
		return copy *= right;
	}
	
	friend Vec3 operator*( Arg left, float right )
	{
		Vec3 copy( left );
		return copy *= right;
	}
	
	friend Vec3 operator*( float left, Arg right )
	{
		Vec3 copy( right );
		return copy *= left;
	}
	
	friend Vec3 operator/( Arg left, Arg right )
	{
		Vec3 copy( left );
		return copy /= right;
	}
	
	friend Vec3 operator/( Arg left, float right )
	{
		Vec3 copy( left );
		return copy /= right;
	}
	
	friend float Dot( Arg left, Arg right )
	{
		return left.m_x*right.m_x + left.m_y*right.m_y + left.m_z*right.m_z;
	}
	
	friend Vec3 Min( Arg left, Arg right )
	{
		return Vec3(
			std::min( left.m_x, right.m_x ), 
			std::min( left.m_y, right.m_y ), 
			std::min( left.m_z, right.m_z )
		);
	}

	friend Vec3 Max( Arg left, Arg right )
	{
		return Vec3(
			std::max( left.m_x, right.m_x ), 
			std::max( left.m_y, right.m_y ), 
			std::max( left.m_z, right.m_z )
		);
	}

	friend Vec3 Truncate( Arg v )
	{
		return Vec3(
			v.m_x > 0.0f ? std::floor( v.m_x ) : std::ceil( v.m_x ), 
			v.m_y > 0.0f ? std::floor( v.m_y ) : std::ceil( v.m_y ), 
			v.m_z > 0.0f ? std::floor( v.m_z ) : std::ceil( v.m_z )
		);
	}

private:
	float m_x;
	float m_y;
	float m_z;
};

inline float LengthSquared( Vec3::Arg v )
{
	return Dot( v, v );
}

class Sym3x3
{
public:
	Sym3x3()
	{
	}

	Sym3x3( float s )
	{
		for( int i = 0; i < 6; ++i )
			m_x[i] = s;
	}

	float operator[]( int index ) const
	{
		return m_x[index];
	}

	float& operator[]( int index )
	{
		return m_x[index];
	}

private:
	float m_x[6];
};

Sym3x3 ComputeWeightedCovariance( int n, Vec3 const* points, float const* weights );
Vec3 ComputePrincipleComponent( Sym3x3 const& matrix );

} // namespace squish

#endif // ndef SQUISH_MATHS_H

```

`ThirdParty/Squish/rangefit.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#include "rangefit.h"
#include "colourset.h"
#include "colourblock.h"
#include <cfloat>

namespace squish {

RangeFit::RangeFit( ColourSet const* colours, int flags ) 
  : ColourFit( colours, flags )
{
	// initialise the metric
	bool perceptual = ( ( m_flags & kColourMetricPerceptual ) != 0 );
	if( perceptual )
		m_metric = Vec3( 0.2126f, 0.7152f, 0.0722f );
	else
		m_metric = Vec3( 1.0f );

	// initialise the best error
	m_besterror = FLT_MAX;

	// cache some values
	int const count = m_colours->GetCount();
	Vec3 const* values = m_colours->GetPoints();
	float const* weights = m_colours->GetWeights();
	
	// get the covariance matrix
	Sym3x3 covariance = ComputeWeightedCovariance( count, values, weights );
	
	// compute the principle component
	Vec3 principle = ComputePrincipleComponent( covariance );

	// get the min and max range as the codebook endpoints
	Vec3 start( 0.0f );
	Vec3 end( 0.0f );
	if( count > 0 )
	{
		float min, max;
		
		// compute the range
		start = end = values[0];
		min = max = Dot( values[0], principle );
		for( int i = 1; i < count; ++i )
		{
			float val = Dot( values[i], principle );
			if( val < min )
			{
				start = values[i];
				min = val;
			}
			else if( val > max )
			{
				end = values[i];
				max = val;
			}
		}
	}
			
	// clamp the output to [0, 1]
	Vec3 const one( 1.0f );
	Vec3 const zero( 0.0f );
	start = Min( one, Max( zero, start ) );
	end = Min( one, Max( zero, end ) );

	// clamp to the grid and save
	Vec3 const grid( 31.0f, 63.0f, 31.0f );
	Vec3 const gridrcp( 1.0f/31.0f, 1.0f/63.0f, 1.0f/31.0f );
	Vec3 const half( 0.5f );
	m_start = Truncate( grid*start + half )*gridrcp;
	m_end = Truncate( grid*end + half )*gridrcp;
}

void RangeFit::Compress3( void* block )
{
	// cache some values
	int const count = m_colours->GetCount();
	Vec3 const* values = m_colours->GetPoints();
	
	// create a codebook
	Vec3 codes[3];
	codes[0] = m_start;
	codes[1] = m_end;
	codes[2] = 0.5f*m_start + 0.5f*m_end;

	// match each point to the closest code
	u8 closest[16];
	float error = 0.0f;
	for( int i = 0; i < count; ++i )
	{
		// find the closest code
		float dist = FLT_MAX;
		int idx = 0;
		for( int j = 0; j < 3; ++j )
		{
			float d = LengthSquared( m_metric*( values[i] - codes[j] ) );
			if( d < dist )
			{
				dist = d;
				idx = j;
			}
		}
		
		// save the index
		closest[i] = ( u8 )idx;
		
		// accumulate the error
		error += dist;
	}
	
	// save this scheme if it wins
	if( error < m_besterror )
	{
		// remap the indices
		u8 indices[16];
		m_colours->RemapIndices( closest, indices );
		
		// save the block
		WriteColourBlock3( m_start, m_end, indices, block );
		
		// save the error
		m_besterror = error;
	}
}

void RangeFit::Compress4( void* block )
{
	// cache some values
	int const count = m_colours->GetCount();
	Vec3 const* values = m_colours->GetPoints();
	
	// create a codebook
	Vec3 codes[4];
	codes[0] = m_start;
	codes[1] = m_end;
	codes[2] = ( 2.0f/3.0f )*m_start + ( 1.0f/3.0f )*m_end;
	codes[3] = ( 1.0f/3.0f )*m_start + ( 2.0f/3.0f )*m_end;

	// match each point to the closest code
	u8 closest[16];
	float error = 0.0f;
	for( int i = 0; i < count; ++i )
	{
		// find the closest code
		float dist = FLT_MAX;
		int idx = 0;
		for( int j = 0; j < 4; ++j )
		{
			float d = LengthSquared( m_metric*( values[i] - codes[j] ) );
			if( d < dist )
			{
				dist = d;
				idx = j;
			}
		}
		
		// save the index
		closest[i] = ( u8 )idx;
		
		// accumulate the error
		error += dist;
	}
	
	// save this scheme if it wins
	if( error < m_besterror )
	{
		// remap the indices
		u8 indices[16];
		m_colours->RemapIndices( closest, indices );
		
		// save the block
		WriteColourBlock4( m_start, m_end, indices, block );

		// save the error
		m_besterror = error;
	}
}

} // namespace squish

```

`ThirdParty/Squish/rangefit.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_RANGEFIT_H
#define SQUISH_RANGEFIT_H

#include <squish.h>
#include "colourfit.h"
#include "maths.h"

namespace squish {

class ColourSet;

class RangeFit : public ColourFit
{
public:
	RangeFit( ColourSet const* colours, int flags );
	
private:
	virtual void Compress3( void* block );
	virtual void Compress4( void* block );
	
	Vec3 m_metric;
	Vec3 m_start;
	Vec3 m_end;
	float m_besterror;
};

} // squish

#endif // ndef SQUISH_RANGEFIT_H

```

`ThirdParty/Squish/simd.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_SIMD_H
#define SQUISH_SIMD_H

#include "maths.h"

#if SQUISH_USE_ALTIVEC
#include "simd_ve.h"
#elif SQUISH_USE_SSE
#include "simd_sse.h"
#else
#include "simd_float.h"
#endif


#endif // ndef SQUISH_SIMD_H

```

`ThirdParty/Squish/simd_float.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_SIMD_FLOAT_H
#define SQUISH_SIMD_FLOAT_H

#include <algorithm>

namespace squish {

#define VEC4_CONST( X ) Vec4( X )

class Vec4
{
public:
	typedef Vec4 const& Arg;

	Vec4() {}
		
	explicit Vec4( float s )
	  : m_x( s ),
		m_y( s ),
		m_z( s ),
		m_w( s )
	{
	}
	
	Vec4( float x, float y, float z, float w )
	  : m_x( x ),
		m_y( y ),
		m_z( z ),
		m_w( w )
	{
	}
	
	Vec3 GetVec3() const
	{
		return Vec3( m_x, m_y, m_z );
	}
	
	Vec4 SplatX() const { return Vec4( m_x ); }
	Vec4 SplatY() const { return Vec4( m_y ); }
	Vec4 SplatZ() const { return Vec4( m_z ); }
	Vec4 SplatW() const { return Vec4( m_w ); }

	Vec4& operator+=( Arg v )
	{
		m_x += v.m_x;
		m_y += v.m_y;
		m_z += v.m_z;
		m_w += v.m_w;
		return *this;
	}
	
	Vec4& operator-=( Arg v )
	{
		m_x -= v.m_x;
		m_y -= v.m_y;
		m_z -= v.m_z;
		m_w -= v.m_w;
		return *this;
	}
	
	Vec4& operator*=( Arg v )
	{
		m_x *= v.m_x;
		m_y *= v.m_y;
		m_z *= v.m_z;
		m_w *= v.m_w;
		return *this;
	}
	
	friend Vec4 operator+( Vec4::Arg left, Vec4::Arg right  )
	{
		Vec4 copy( left );
		return copy += right;
	}
	
	friend Vec4 operator-( Vec4::Arg left, Vec4::Arg right  )
	{
		Vec4 copy( left );
		return copy -= right;
	}
	
	friend Vec4 operator*( Vec4::Arg left, Vec4::Arg right  )
	{
		Vec4 copy( left );
		return copy *= right;
	}
	
	//! Returns a*b + c
	friend Vec4 MultiplyAdd( Vec4::Arg a, Vec4::Arg b, Vec4::Arg c )
	{
		return a*b + c;
	}
	
	//! Returns -( a*b - c )
	friend Vec4 NegativeMultiplySubtract( Vec4::Arg a, Vec4::Arg b, Vec4::Arg c )
	{
		return c - a*b;
	}
	
	friend Vec4 Reciprocal( Vec4::Arg v )
	{
		return Vec4( 
			1.0f/v.m_x, 
			1.0f/v.m_y, 
			1.0f/v.m_z, 
			1.0f/v.m_w 
		);
	}
	
	friend Vec4 Min( Vec4::Arg left, Vec4::Arg right )
	{
		return Vec4( 
			std::min( left.m_x, right.m_x ), 
			std::min( left.m_y, right.m_y ), 
			std::min( left.m_z, right.m_z ), 
			std::min( left.m_w, right.m_w ) 
		);
	}
	
	friend Vec4 Max( Vec4::Arg left, Vec4::Arg right )
	{
		return Vec4( 
			std::max( left.m_x, right.m_x ), 
			std::max( left.m_y, right.m_y ), 
			std::max( left.m_z, right.m_z ), 
			std::max( left.m_w, right.m_w ) 
		);
	}
	
	friend Vec4 Truncate( Vec4::Arg v )
	{
		return Vec4(
			v.m_x > 0.0f ? std::floor( v.m_x ) : std::ceil( v.m_x ), 
			v.m_y > 0.0f ? std::floor( v.m_y ) : std::ceil( v.m_y ), 
			v.m_z > 0.0f ? std::floor( v.m_z ) : std::ceil( v.m_z ),
			v.m_w > 0.0f ? std::floor( v.m_w ) : std::ceil( v.m_w )
		);
	}
	
	friend bool CompareAnyLessThan( Vec4::Arg left, Vec4::Arg right ) 
	{
		return left.m_x < right.m_x
			|| left.m_y < right.m_y
			|| left.m_z < right.m_z
			|| left.m_w < right.m_w;
	}
	
private:
	float m_x;
	float m_y;
	float m_z;
	float m_w;
};

} // namespace squish

#endif // ndef SQUISH_SIMD_FLOAT_H


```

`ThirdParty/Squish/simd_sse.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_SIMD_SSE_H
#define SQUISH_SIMD_SSE_H

#include <xmmintrin.h>
#if ( SQUISH_USE_SSE > 1 )
#include <emmintrin.h>
#endif

#define SQUISH_SSE_SPLAT( a )										\
	( ( a ) | ( ( a ) << 2 ) | ( ( a ) << 4 ) | ( ( a ) << 6 ) )

#define SQUISH_SSE_SHUF( x, y, z, w )								\
	( ( x ) | ( ( y ) << 2 ) | ( ( z ) << 4 ) | ( ( w ) << 6 ) )

namespace squish {

#define VEC4_CONST( X ) Vec4( X )

class Vec4
{
public:
	typedef Vec4 const& Arg;

	Vec4() {}
		
	explicit Vec4( __m128 v ) : m_v( v ) {}
	
	Vec4( Vec4 const& arg ) : m_v( arg.m_v ) {}
	
	Vec4& operator=( Vec4 const& arg )
	{
		m_v = arg.m_v;
		return *this;
	}
	
	explicit Vec4( float s ) : m_v( _mm_set1_ps( s ) ) {}
	
	Vec4( float x, float y, float z, float w ) : m_v( _mm_setr_ps( x, y, z, w ) ) {}
	
	Vec3 GetVec3() const
	{
#ifdef __GNUC__
		__attribute__ ((__aligned__ (16))) float c[4];
#else
		__declspec(align(16)) float c[4];
#endif
		_mm_store_ps( c, m_v );
		return Vec3( c[0], c[1], c[2] );
	}
	
	Vec4 SplatX() const { return Vec4( _mm_shuffle_ps( m_v, m_v, SQUISH_SSE_SPLAT( 0 ) ) ); }
	Vec4 SplatY() const { return Vec4( _mm_shuffle_ps( m_v, m_v, SQUISH_SSE_SPLAT( 1 ) ) ); }
	Vec4 SplatZ() const { return Vec4( _mm_shuffle_ps( m_v, m_v, SQUISH_SSE_SPLAT( 2 ) ) ); }
	Vec4 SplatW() const { return Vec4( _mm_shuffle_ps( m_v, m_v, SQUISH_SSE_SPLAT( 3 ) ) ); }

	Vec4& operator+=( Arg v )
	{
		m_v = _mm_add_ps( m_v, v.m_v );
		return *this;
	}
	
	Vec4& operator-=( Arg v )
	{
		m_v = _mm_sub_ps( m_v, v.m_v );
		return *this;
	}
	
	Vec4& operator*=( Arg v )
	{
		m_v = _mm_mul_ps( m_v, v.m_v );
		return *this;
	}
	
	friend Vec4 operator+( Vec4::Arg left, Vec4::Arg right  )
	{
		return Vec4( _mm_add_ps( left.m_v, right.m_v ) );
	}
	
	friend Vec4 operator-( Vec4::Arg left, Vec4::Arg right  )
	{
		return Vec4( _mm_sub_ps( left.m_v, right.m_v ) );
	}
	
	friend Vec4 operator*( Vec4::Arg left, Vec4::Arg right  )
	{
		return Vec4( _mm_mul_ps( left.m_v, right.m_v ) );
	}
	
	//! Returns a*b + c
	friend Vec4 MultiplyAdd( Vec4::Arg a, Vec4::Arg b, Vec4::Arg c )
	{
		return Vec4( _mm_add_ps( _mm_mul_ps( a.m_v, b.m_v ), c.m_v ) );
	}
	
	//! Returns -( a*b - c )
	friend Vec4 NegativeMultiplySubtract( Vec4::Arg a, Vec4::Arg b, Vec4::Arg c )
	{
		return Vec4( _mm_sub_ps( c.m_v, _mm_mul_ps( a.m_v, b.m_v ) ) );
	}
	
	friend Vec4 Reciprocal( Vec4::Arg v )
	{
		// get the reciprocal estimate
		__m128 estimate = _mm_rcp_ps( v.m_v );

		// one round of Newton-Rhaphson refinement
		__m128 diff = _mm_sub_ps( _mm_set1_ps( 1.0f ), _mm_mul_ps( estimate, v.m_v ) );
		return Vec4( _mm_add_ps( _mm_mul_ps( diff, estimate ), estimate ) );
	}
	
	friend Vec4 Min( Vec4::Arg left, Vec4::Arg right )
	{
		return Vec4( _mm_min_ps( left.m_v, right.m_v ) );
	}
	
	friend Vec4 Max( Vec4::Arg left, Vec4::Arg right )
	{
		return Vec4( _mm_max_ps( left.m_v, right.m_v ) );
	}
	
	friend Vec4 Truncate( Vec4::Arg v )
	{
#if ( SQUISH_USE_SSE == 1 )
		// convert to ints
		__m128 input = v.m_v;
		__m64 lo = _mm_cvttps_pi32( input );
		__m64 hi = _mm_cvttps_pi32( _mm_movehl_ps( input, input ) );

		// convert to floats
		__m128 part = _mm_movelh_ps( input, _mm_cvtpi32_ps( input, hi ) );
		__m128 truncated = _mm_cvtpi32_ps( part, lo );
		
		// clear out the MMX multimedia state to allow FP calls later
		_mm_empty(); 
		return Vec4( truncated );
#else
		// use SSE2 instructions
		return Vec4( _mm_cvtepi32_ps( _mm_cvttps_epi32( v.m_v ) ) );
#endif
	}
	
	friend bool CompareAnyLessThan( Vec4::Arg left, Vec4::Arg right ) 
	{
		__m128 bits = _mm_cmplt_ps( left.m_v, right.m_v );
		int value = _mm_movemask_ps( bits );
		return value != 0;
	}
	
private:
	__m128 m_v;
};

} // namespace squish

#endif // ndef SQUISH_SIMD_SSE_H

```

`ThirdParty/Squish/simd_ve.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_SIMD_VE_H
#define SQUISH_SIMD_VE_H

#include <altivec.h>
#undef bool

namespace squish {

#define VEC4_CONST( X ) Vec4( ( vector float )( X ) )

class Vec4
{
public:
	typedef Vec4 Arg;

	Vec4() {}
		
	explicit Vec4( vector float v ) : m_v( v ) {}
	
	Vec4( Vec4 const& arg ) : m_v( arg.m_v ) {}
	
	Vec4& operator=( Vec4 const& arg )
	{
		m_v = arg.m_v;
		return *this;
	}
	
	explicit Vec4( float s )
	{
		union { vector float v; float c[4]; } u;
		u.c[0] = s;
		u.c[1] = s;
		u.c[2] = s;
		u.c[3] = s;
		m_v = u.v;
	}
	
	Vec4( float x, float y, float z, float w )
	{
		union { vector float v; float c[4]; } u;
		u.c[0] = x;
		u.c[1] = y;
		u.c[2] = z;
		u.c[3] = w;
		m_v = u.v;
	}
	
	Vec3 GetVec3() const
	{
		union { vector float v; float c[4]; } u;
		u.v = m_v;
		return Vec3( u.c[0], u.c[1], u.c[2] );
	}
	
	Vec4 SplatX() const { return Vec4( vec_splat( m_v, 0 ) ); }
	Vec4 SplatY() const { return Vec4( vec_splat( m_v, 1 ) ); }
	Vec4 SplatZ() const { return Vec4( vec_splat( m_v, 2 ) ); }
	Vec4 SplatW() const { return Vec4( vec_splat( m_v, 3 ) ); }

	Vec4& operator+=( Arg v )
	{
		m_v = vec_add( m_v, v.m_v );
		return *this;
	}
	
	Vec4& operator-=( Arg v )
	{
		m_v = vec_sub( m_v, v.m_v );
		return *this;
	}
	
	Vec4& operator*=( Arg v )
	{
		m_v = vec_madd( m_v, v.m_v, ( vector float )( -0.0f ) );
		return *this;
	}
	
	friend Vec4 operator+( Vec4::Arg left, Vec4::Arg right  )
	{
		return Vec4( vec_add( left.m_v, right.m_v ) );
	}
	
	friend Vec4 operator-( Vec4::Arg left, Vec4::Arg right  )
	{
		return Vec4( vec_sub( left.m_v, right.m_v ) );
	}
	
	friend Vec4 operator*( Vec4::Arg left, Vec4::Arg right  )
	{
		return Vec4( vec_madd( left.m_v, right.m_v, ( vector float )( -0.0f ) ) );
	}
	
	//! Returns a*b + c
	friend Vec4 MultiplyAdd( Vec4::Arg a, Vec4::Arg b, Vec4::Arg c )
	{
		return Vec4( vec_madd( a.m_v, b.m_v, c.m_v ) );
	}
	
	//! Returns -( a*b - c )
	friend Vec4 NegativeMultiplySubtract( Vec4::Arg a, Vec4::Arg b, Vec4::Arg c )
	{
		return Vec4( vec_nmsub( a.m_v, b.m_v, c.m_v ) );
	}
	
	friend Vec4 Reciprocal( Vec4::Arg v )
	{
		// get the reciprocal estimate
		vector float estimate = vec_re( v.m_v );
		
		// one round of Newton-Rhaphson refinement
		vector float diff = vec_nmsub( estimate, v.m_v, ( vector float )( 1.0f ) );
		return Vec4( vec_madd( diff, estimate, estimate ) );
	}
	
	friend Vec4 Min( Vec4::Arg left, Vec4::Arg right )
	{
		return Vec4( vec_min( left.m_v, right.m_v ) );
	}
	
	friend Vec4 Max( Vec4::Arg left, Vec4::Arg right )
	{
		return Vec4( vec_max( left.m_v, right.m_v ) );
	}
	
	friend Vec4 Truncate( Vec4::Arg v )
	{
		return Vec4( vec_trunc( v.m_v ) );
	}
	
	friend bool CompareAnyLessThan( Vec4::Arg left, Vec4::Arg right ) 
	{
		return vec_any_lt( left.m_v, right.m_v ) != 0;
	}
	
private:
	vector float m_v;
};

} // namespace squish

#endif // ndef SQUISH_SIMD_VE_H

```

`ThirdParty/Squish/singlecolourfit.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

   -------------------------------------------------------------------------- */

#include "singlecolourfit.h"
#include "colourset.h"
#include "colourblock.h"
#include <limits>

namespace squish {

struct SourceBlock
{
	u8 start;
	u8 end;
	u8 error;
};

struct SingleColourLookup
{
	SourceBlock sources[2];
};

#include "singlecolourlookup.inl"

static int FloatToInt( float a, int limit )
{
	// use ANSI round-to-zero behaviour to get round-to-nearest
	int i = ( int )( a + 0.5f );

	// clamp to the limit
	if( i < 0 )
		i = 0;
	else if( i > limit )
		i = limit;

	// done
	return i;
}

SingleColourFit::SingleColourFit( ColourSet const* colours, int flags )
  : ColourFit( colours, flags )
{
	// grab the single colour
	Vec3 const* values = m_colours->GetPoints();
	m_colour[0] = ( u8 )FloatToInt( 255.0f*values->X(), 255 );
	m_colour[1] = ( u8 )FloatToInt( 255.0f*values->Y(), 255 );
	m_colour[2] = ( u8 )FloatToInt( 255.0f*values->Z(), 255 );

	// initialise the best error
	m_besterror = std::numeric_limits<int>::max();
}

void SingleColourFit::Compress3( void* block )
{
	// build the table of lookups
	SingleColourLookup const* const lookups[] =
	{
		lookup_5_3,
		lookup_6_3,
		lookup_5_3
	};

	// find the best end-points and index
	ComputeEndPoints( lookups );

	// build the block if we win
	if( m_error < m_besterror )
	{
		// remap the indices
		u8 indices[16];
		m_colours->RemapIndices( &m_index, indices );

		// save the block
		WriteColourBlock3( m_start, m_end, indices, block );

		// save the error
		m_besterror = m_error;
	}
}

void SingleColourFit::Compress4( void* block )
{
	// build the table of lookups
	SingleColourLookup const* const lookups[] =
	{
		lookup_5_4,
		lookup_6_4,
		lookup_5_4
	};

	// find the best end-points and index
	ComputeEndPoints( lookups );

	// build the block if we win
	if( m_error < m_besterror )
	{
		// remap the indices
		u8 indices[16];
		m_colours->RemapIndices( &m_index, indices );

		// save the block
		WriteColourBlock4( m_start, m_end, indices, block );

		// save the error
		m_besterror = m_error;
	}
}

void SingleColourFit::ComputeEndPoints( SingleColourLookup const* const* lookups )
{
	// check each index combination (endpoint or intermediate)
	m_error = std::numeric_limits<int>::max();
	for( int index = 0; index < 2; ++index )
	{
		// check the error for this codebook index
		SourceBlock const* sources[3];
		int error = 0;
		for( int channel = 0; channel < 3; ++channel )
		{
			// grab the lookup table and index for this channel
			SingleColourLookup const* lookup = lookups[channel];
			int target = m_colour[channel];

			// store a pointer to the source for this channel
			sources[channel] = lookup[target].sources + index;

			// accumulate the error
			int diff = sources[channel]->error;
			error += diff*diff;
		}

		// keep it if the error is lower
		if( error < m_error )
		{
			m_start = Vec3(
				( float )sources[0]->start/31.0f,
				( float )sources[1]->start/63.0f,
				( float )sources[2]->start/31.0f
			);
			m_end = Vec3(
				( float )sources[0]->end/31.0f,
				( float )sources[1]->end/63.0f,
				( float )sources[2]->end/31.0f
			);
			m_index = ( u8 )( 2*index );
			m_error = error;
		}
	}
}

} // namespace squish

```

`ThirdParty/Squish/singlecolourfit.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_SINGLECOLOURFIT_H
#define SQUISH_SINGLECOLOURFIT_H

#include <squish.h>
#include "colourfit.h"

namespace squish {

class ColourSet;
struct SingleColourLookup;

class SingleColourFit : public ColourFit
{
public:
	SingleColourFit( ColourSet const* colours, int flags );
	
private:
	virtual void Compress3( void* block );
	virtual void Compress4( void* block );
	
	void ComputeEndPoints( SingleColourLookup const* const* lookups );
	
	u8 m_colour[3];
	Vec3 m_start;
	Vec3 m_end;
	u8 m_index;
	int m_error;
	int m_besterror;
};

} // namespace squish

#endif // ndef SQUISH_SINGLECOLOURFIT_H

```

`ThirdParty/Squish/singlecolourlookup.inl`:

```inl

static SingleColourLookup const lookup_5_3[] = 
{
	{ { { 0, 0, 0 }, { 0, 0, 0 } } },
	{ { { 0, 0, 1 }, { 0, 0, 1 } } },
	{ { { 0, 0, 2 }, { 0, 0, 2 } } },
	{ { { 0, 0, 3 }, { 0, 1, 1 } } },
	{ { { 0, 0, 4 }, { 0, 1, 0 } } },
	{ { { 1, 0, 3 }, { 0, 1, 1 } } },
	{ { { 1, 0, 2 }, { 0, 1, 2 } } },
	{ { { 1, 0, 1 }, { 0, 2, 1 } } },
	{ { { 1, 0, 0 }, { 0, 2, 0 } } },
	{ { { 1, 0, 1 }, { 0, 2, 1 } } },
	{ { { 1, 0, 2 }, { 0, 2, 2 } } },
	{ { { 1, 0, 3 }, { 0, 3, 1 } } },
	{ { { 1, 0, 4 }, { 0, 3, 0 } } },
	{ { { 2, 0, 3 }, { 0, 3, 1 } } },
	{ { { 2, 0, 2 }, { 0, 3, 2 } } },
	{ { { 2, 0, 1 }, { 0, 4, 1 } } },
	{ { { 2, 0, 0 }, { 0, 4, 0 } } },
	{ { { 2, 0, 1 }, { 0, 4, 1 } } },
	{ { { 2, 0, 2 }, { 0, 4, 2 } } },
	{ { { 2, 0, 3 }, { 0, 5, 1 } } },
	{ { { 2, 0, 4 }, { 0, 5, 0 } } },
	{ { { 3, 0, 3 }, { 0, 5, 1 } } },
	{ { { 3, 0, 2 }, { 0, 5, 2 } } },
	{ { { 3, 0, 1 }, { 0, 6, 1 } } },
	{ { { 3, 0, 0 }, { 0, 6, 0 } } },
	{ { { 3, 0, 1 }, { 0, 6, 1 } } },
	{ { { 3, 0, 2 }, { 0, 6, 2 } } },
	{ { { 3, 0, 3 }, { 0, 7, 1 } } },
	{ { { 3, 0, 4 }, { 0, 7, 0 } } },
	{ { { 4, 0, 4 }, { 0, 7, 1 } } },
	{ { { 4, 0, 3 }, { 0, 7, 2 } } },
	{ { { 4, 0, 2 }, { 1, 7, 1 } } },
	{ { { 4, 0, 1 }, { 1, 7, 0 } } },
	{ { { 4, 0, 0 }, { 0, 8, 0 } } },
	{ { { 4, 0, 1 }, { 0, 8, 1 } } },
	{ { { 4, 0, 2 }, { 2, 7, 1 } } },
	{ { { 4, 0, 3 }, { 2, 7, 0 } } },
	{ { { 4, 0, 4 }, { 0, 9, 0 } } },
	{ { { 5, 0, 3 }, { 0, 9, 1 } } },
	{ { { 5, 0, 2 }, { 3, 7, 1 } } },
	{ { { 5, 0, 1 }, { 3, 7, 0 } } },
	{ { { 5, 0, 0 }, { 0, 10, 0 } } },
	{ { { 5, 0, 1 }, { 0, 10, 1 } } },
	{ { { 5, 0, 2 }, { 0, 10, 2 } } },
	{ { { 5, 0, 3 }, { 0, 11, 1 } } },
	{ { { 5, 0, 4 }, { 0, 11, 0 } } },
	{ { { 6, 0, 3 }, { 0, 11, 1 } } },
	{ { { 6, 0, 2 }, { 0, 11, 2 } } },
	{ { { 6, 0, 1 }, { 0, 12, 1 } } },
	{ { { 6, 0, 0 }, { 0, 12, 0 } } },
	{ { { 6, 0, 1 }, { 0, 12, 1 } } },
	{ { { 6, 0, 2 }, { 0, 12, 2 } } },
	{ { { 6, 0, 3 }, { 0, 13, 1 } } },
	{ { { 6, 0, 4 }, { 0, 13, 0 } } },
	{ { { 7, 0, 3 }, { 0, 13, 1 } } },
	{ { { 7, 0, 2 }, { 0, 13, 2 } } },
	{ { { 7, 0, 1 }, { 0, 14, 1 } } },
	{ { { 7, 0, 0 }, { 0, 14, 0 } } },
	{ { { 7, 0, 1 }, { 0, 14, 1 } } },
	{ { { 7, 0, 2 }, { 0, 14, 2 } } },
	{ { { 7, 0, 3 }, { 0, 15, 1 } } },
	{ { { 7, 0, 4 }, { 0, 15, 0 } } },
	{ { { 8, 0, 4 }, { 0, 15, 1 } } },
	{ { { 8, 0, 3 }, { 0, 15, 2 } } },
	{ { { 8, 0, 2 }, { 1, 15, 1 } } },
	{ { { 8, 0, 1 }, { 1, 15, 0 } } },
	{ { { 8, 0, 0 }, { 0, 16, 0 } } },
	{ { { 8, 0, 1 }, { 0, 16, 1 } } },
	{ { { 8, 0, 2 }, { 2, 15, 1 } } },
	{ { { 8, 0, 3 }, { 2, 15, 0 } } },
	{ { { 8, 0, 4 }, { 0, 17, 0 } } },
	{ { { 9, 0, 3 }, { 0, 17, 1 } } },
	{ { { 9, 0, 2 }, { 3, 15, 1 } } },
	{ { { 9, 0, 1 }, { 3, 15, 0 } } },
	{ { { 9, 0, 0 }, { 0, 18, 0 } } },
	{ { { 9, 0, 1 }, { 0, 18, 1 } } },
	{ { { 9, 0, 2 }, { 0, 18, 2 } } },
	{ { { 9, 0, 3 }, { 0, 19, 1 } } },
	{ { { 9, 0, 4 }, { 0, 19, 0 } } },
	{ { { 10, 0, 3 }, { 0, 19, 1 } } },
	{ { { 10, 0, 2 }, { 0, 19, 2 } } },
	{ { { 10, 0, 1 }, { 0, 20, 1 } } },
	{ { { 10, 0, 0 }, { 0, 20, 0 } } },
	{ { { 10, 0, 1 }, { 0, 20, 1 } } },
	{ { { 10, 0, 2 }, { 0, 20, 2 } } },
	{ { { 10, 0, 3 }, { 0, 21, 1 } } },
	{ { { 10, 0, 4 }, { 0, 21, 0 } } },
	{ { { 11, 0, 3 }, { 0, 21, 1 } } },
	{ { { 11, 0, 2 }, { 0, 21, 2 } } },
	{ { { 11, 0, 1 }, { 0, 22, 1 } } },
	{ { { 11, 0, 0 }, { 0, 22, 0 } } },
	{ { { 11, 0, 1 }, { 0, 22, 1 } } },
	{ { { 11, 0, 2 }, { 0, 22, 2 } } },
	{ { { 11, 0, 3 }, { 0, 23, 1 } } },
	{ { { 11, 0, 4 }, { 0, 23, 0 } } },
	{ { { 12, 0, 4 }, { 0, 23, 1 } } },
	{ { { 12, 0, 3 }, { 0, 23, 2 } } },
	{ { { 12, 0, 2 }, { 1, 23, 1 } } },
	{ { { 12, 0, 1 }, { 1, 23, 0 } } },
	{ { { 12, 0, 0 }, { 0, 24, 0 } } },
	{ { { 12, 0, 1 }, { 0, 24, 1 } } },
	{ { { 12, 0, 2 }, { 2, 23, 1 } } },
	{ { { 12, 0, 3 }, { 2, 23, 0 } } },
	{ { { 12, 0, 4 }, { 0, 25, 0 } } },
	{ { { 13, 0, 3 }, { 0, 25, 1 } } },
	{ { { 13, 0, 2 }, { 3, 23, 1 } } },
	{ { { 13, 0, 1 }, { 3, 23, 0 } } },
	{ { { 13, 0, 0 }, { 0, 26, 0 } } },
	{ { { 13, 0, 1 }, { 0, 26, 1 } } },
	{ { { 13, 0, 2 }, { 0, 26, 2 } } },
	{ { { 13, 0, 3 }, { 0, 27, 1 } } },
	{ { { 13, 0, 4 }, { 0, 27, 0 } } },
	{ { { 14, 0, 3 }, { 0, 27, 1 } } },
	{ { { 14, 0, 2 }, { 0, 27, 2 } } },
	{ { { 14, 0, 1 }, { 0, 28, 1 } } },
	{ { { 14, 0, 0 }, { 0, 28, 0 } } },
	{ { { 14, 0, 1 }, { 0, 28, 1 } } },
	{ { { 14, 0, 2 }, { 0, 28, 2 } } },
	{ { { 14, 0, 3 }, { 0, 29, 1 } } },
	{ { { 14, 0, 4 }, { 0, 29, 0 } } },
	{ { { 15, 0, 3 }, { 0, 29, 1 } } },
	{ { { 15, 0, 2 }, { 0, 29, 2 } } },
	{ { { 15, 0, 1 }, { 0, 30, 1 } } },
	{ { { 15, 0, 0 }, { 0, 30, 0 } } },
	{ { { 15, 0, 1 }, { 0, 30, 1 } } },
	{ { { 15, 0, 2 }, { 0, 30, 2 } } },
	{ { { 15, 0, 3 }, { 0, 31, 1 } } },
	{ { { 15, 0, 4 }, { 0, 31, 0 } } },
	{ { { 16, 0, 4 }, { 0, 31, 1 } } },
	{ { { 16, 0, 3 }, { 0, 31, 2 } } },
	{ { { 16, 0, 2 }, { 1, 31, 1 } } },
	{ { { 16, 0, 1 }, { 1, 31, 0 } } },
	{ { { 16, 0, 0 }, { 4, 28, 0 } } },
	{ { { 16, 0, 1 }, { 4, 28, 1 } } },
	{ { { 16, 0, 2 }, { 2, 31, 1 } } },
	{ { { 16, 0, 3 }, { 2, 31, 0 } } },
	{ { { 16, 0, 4 }, { 4, 29, 0 } } },
	{ { { 17, 0, 3 }, { 4, 29, 1 } } },
	{ { { 17, 0, 2 }, { 3, 31, 1 } } },
	{ { { 17, 0, 1 }, { 3, 31, 0 } } },
	{ { { 17, 0, 0 }, { 4, 30, 0 } } },
	{ { { 17, 0, 1 }, { 4, 30, 1 } } },
	{ { { 17, 0, 2 }, { 4, 30, 2 } } },
	{ { { 17, 0, 3 }, { 4, 31, 1 } } },
	{ { { 17, 0, 4 }, { 4, 31, 0 } } },
	{ { { 18, 0, 3 }, { 4, 31, 1 } } },
	{ { { 18, 0, 2 }, { 4, 31, 2 } } },
	{ { { 18, 0, 1 }, { 5, 31, 1 } } },
	{ { { 18, 0, 0 }, { 5, 31, 0 } } },
	{ { { 18, 0, 1 }, { 5, 31, 1 } } },
	{ { { 18, 0, 2 }, { 5, 31, 2 } } },
	{ { { 18, 0, 3 }, { 6, 31, 1 } } },
	{ { { 18, 0, 4 }, { 6, 31, 0 } } },
	{ { { 19, 0, 3 }, { 6, 31, 1 } } },
	{ { { 19, 0, 2 }, { 6, 31, 2 } } },
	{ { { 19, 0, 1 }, { 7, 31, 1 } } },
	{ { { 19, 0, 0 }, { 7, 31, 0 } } },
	{ { { 19, 0, 1 }, { 7, 31, 1 } } },
	{ { { 19, 0, 2 }, { 7, 31, 2 } } },
	{ { { 19, 0, 3 }, { 8, 31, 1 } } },
	{ { { 19, 0, 4 }, { 8, 31, 0 } } },
	{ { { 20, 0, 4 }, { 8, 31, 1 } } },
	{ { { 20, 0, 3 }, { 8, 31, 2 } } },
	{ { { 20, 0, 2 }, { 9, 31, 1 } } },
	{ { { 20, 0, 1 }, { 9, 31, 0 } } },
	{ { { 20, 0, 0 }, { 12, 28, 0 } } },
	{ { { 20, 0, 1 }, { 12, 28, 1 } } },
	{ { { 20, 0, 2 }, { 10, 31, 1 } } },
	{ { { 20, 0, 3 }, { 10, 31, 0 } } },
	{ { { 20, 0, 4 }, { 12, 29, 0 } } },
	{ { { 21, 0, 3 }, { 12, 29, 1 } } },
	{ { { 21, 0, 2 }, { 11, 31, 1 } } },
	{ { { 21, 0, 1 }, { 11, 31, 0 } } },
	{ { { 21, 0, 0 }, { 12, 30, 0 } } },
	{ { { 21, 0, 1 }, { 12, 30, 1 } } },
	{ { { 21, 0, 2 }, { 12, 30, 2 } } },
	{ { { 21, 0, 3 }, { 12, 31, 1 } } },
	{ { { 21, 0, 4 }, { 12, 31, 0 } } },
	{ { { 22, 0, 3 }, { 12, 31, 1 } } },
	{ { { 22, 0, 2 }, { 12, 31, 2 } } },
	{ { { 22, 0, 1 }, { 13, 31, 1 } } },
	{ { { 22, 0, 0 }, { 13, 31, 0 } } },
	{ { { 22, 0, 1 }, { 13, 31, 1 } } },
	{ { { 22, 0, 2 }, { 13, 31, 2 } } },
	{ { { 22, 0, 3 }, { 14, 31, 1 } } },
	{ { { 22, 0, 4 }, { 14, 31, 0 } } },
	{ { { 23, 0, 3 }, { 14, 31, 1 } } },
	{ { { 23, 0, 2 }, { 14, 31, 2 } } },
	{ { { 23, 0, 1 }, { 15, 31, 1 } } },
	{ { { 23, 0, 0 }, { 15, 31, 0 } } },
	{ { { 23, 0, 1 }, { 15, 31, 1 } } },
	{ { { 23, 0, 2 }, { 15, 31, 2 } } },
	{ { { 23, 0, 3 }, { 16, 31, 1 } } },
	{ { { 23, 0, 4 }, { 16, 31, 0 } } },
	{ { { 24, 0, 4 }, { 16, 31, 1 } } },
	{ { { 24, 0, 3 }, { 16, 31, 2 } } },
	{ { { 24, 0, 2 }, { 17, 31, 1 } } },
	{ { { 24, 0, 1 }, { 17, 31, 0 } } },
	{ { { 24, 0, 0 }, { 20, 28, 0 } } },
	{ { { 24, 0, 1 }, { 20, 28, 1 } } },
	{ { { 24, 0, 2 }, { 18, 31, 1 } } },
	{ { { 24, 0, 3 }, { 18, 31, 0 } } },
	{ { { 24, 0, 4 }, { 20, 29, 0 } } },
	{ { { 25, 0, 3 }, { 20, 29, 1 } } },
	{ { { 25, 0, 2 }, { 19, 31, 1 } } },
	{ { { 25, 0, 1 }, { 19, 31, 0 } } },
	{ { { 25, 0, 0 }, { 20, 30, 0 } } },
	{ { { 25, 0, 1 }, { 20, 30, 1 } } },
	{ { { 25, 0, 2 }, { 20, 30, 2 } } },
	{ { { 25, 0, 3 }, { 20, 31, 1 } } },
	{ { { 25, 0, 4 }, { 20, 31, 0 } } },
	{ { { 26, 0, 3 }, { 20, 31, 1 } } },
	{ { { 26, 0, 2 }, { 20, 31, 2 } } },
	{ { { 26, 0, 1 }, { 21, 31, 1 } } },
	{ { { 26, 0, 0 }, { 21, 31, 0 } } },
	{ { { 26, 0, 1 }, { 21, 31, 1 } } },
	{ { { 26, 0, 2 }, { 21, 31, 2 } } },
	{ { { 26, 0, 3 }, { 22, 31, 1 } } },
	{ { { 26, 0, 4 }, { 22, 31, 0 } } },
	{ { { 27, 0, 3 }, { 22, 31, 1 } } },
	{ { { 27, 0, 2 }, { 22, 31, 2 } } },
	{ { { 27, 0, 1 }, { 23, 31, 1 } } },
	{ { { 27, 0, 0 }, { 23, 31, 0 } } },
	{ { { 27, 0, 1 }, { 23, 31, 1 } } },
	{ { { 27, 0, 2 }, { 23, 31, 2 } } },
	{ { { 27, 0, 3 }, { 24, 31, 1 } } },
	{ { { 27, 0, 4 }, { 24, 31, 0 } } },
	{ { { 28, 0, 4 }, { 24, 31, 1 } } },
	{ { { 28, 0, 3 }, { 24, 31, 2 } } },
	{ { { 28, 0, 2 }, { 25, 31, 1 } } },
	{ { { 28, 0, 1 }, { 25, 31, 0 } } },
	{ { { 28, 0, 0 }, { 28, 28, 0 } } },
	{ { { 28, 0, 1 }, { 28, 28, 1 } } },
	{ { { 28, 0, 2 }, { 26, 31, 1 } } },
	{ { { 28, 0, 3 }, { 26, 31, 0 } } },
	{ { { 28, 0, 4 }, { 28, 29, 0 } } },
	{ { { 29, 0, 3 }, { 28, 29, 1 } } },
	{ { { 29, 0, 2 }, { 27, 31, 1 } } },
	{ { { 29, 0, 1 }, { 27, 31, 0 } } },
	{ { { 29, 0, 0 }, { 28, 30, 0 } } },
	{ { { 29, 0, 1 }, { 28, 30, 1 } } },
	{ { { 29, 0, 2 }, { 28, 30, 2 } } },
	{ { { 29, 0, 3 }, { 28, 31, 1 } } },
	{ { { 29, 0, 4 }, { 28, 31, 0 } } },
	{ { { 30, 0, 3 }, { 28, 31, 1 } } },
	{ { { 30, 0, 2 }, { 28, 31, 2 } } },
	{ { { 30, 0, 1 }, { 29, 31, 1 } } },
	{ { { 30, 0, 0 }, { 29, 31, 0 } } },
	{ { { 30, 0, 1 }, { 29, 31, 1 } } },
	{ { { 30, 0, 2 }, { 29, 31, 2 } } },
	{ { { 30, 0, 3 }, { 30, 31, 1 } } },
	{ { { 30, 0, 4 }, { 30, 31, 0 } } },
	{ { { 31, 0, 3 }, { 30, 31, 1 } } },
	{ { { 31, 0, 2 }, { 30, 31, 2 } } },
	{ { { 31, 0, 1 }, { 31, 31, 1 } } },
	{ { { 31, 0, 0 }, { 31, 31, 0 } } }
};

static SingleColourLookup const lookup_6_3[] = 
{
	{ { { 0, 0, 0 }, { 0, 0, 0 } } },
	{ { { 0, 0, 1 }, { 0, 1, 1 } } },
	{ { { 0, 0, 2 }, { 0, 1, 0 } } },
	{ { { 1, 0, 1 }, { 0, 2, 1 } } },
	{ { { 1, 0, 0 }, { 0, 2, 0 } } },
	{ { { 1, 0, 1 }, { 0, 3, 1 } } },
	{ { { 1, 0, 2 }, { 0, 3, 0 } } },
	{ { { 2, 0, 1 }, { 0, 4, 1 } } },
	{ { { 2, 0, 0 }, { 0, 4, 0 } } },
	{ { { 2, 0, 1 }, { 0, 5, 1 } } },
	{ { { 2, 0, 2 }, { 0, 5, 0 } } },
	{ { { 3, 0, 1 }, { 0, 6, 1 } } },
	{ { { 3, 0, 0 }, { 0, 6, 0 } } },
	{ { { 3, 0, 1 }, { 0, 7, 1 } } },
	{ { { 3, 0, 2 }, { 0, 7, 0 } } },
	{ { { 4, 0, 1 }, { 0, 8, 1 } } },
	{ { { 4, 0, 0 }, { 0, 8, 0 } } },
	{ { { 4, 0, 1 }, { 0, 9, 1 } } },
	{ { { 4, 0, 2 }, { 0, 9, 0 } } },
	{ { { 5, 0, 1 }, { 0, 10, 1 } } },
	{ { { 5, 0, 0 }, { 0, 10, 0 } } },
	{ { { 5, 0, 1 }, { 0, 11, 1 } } },
	{ { { 5, 0, 2 }, { 0, 11, 0 } } },
	{ { { 6, 0, 1 }, { 0, 12, 1 } } },
	{ { { 6, 0, 0 }, { 0, 12, 0 } } },
	{ { { 6, 0, 1 }, { 0, 13, 1 } } },
	{ { { 6, 0, 2 }, { 0, 13, 0 } } },
	{ { { 7, 0, 1 }, { 0, 14, 1 } } },
	{ { { 7, 0, 0 }, { 0, 14, 0 } } },
	{ { { 7, 0, 1 }, { 0, 15, 1 } } },
	{ { { 7, 0, 2 }, { 0, 15, 0 } } },
	{ { { 8, 0, 1 }, { 0, 16, 1 } } },
	{ { { 8, 0, 0 }, { 0, 16, 0 } } },
	{ { { 8, 0, 1 }, { 0, 17, 1 } } },
	{ { { 8, 0, 2 }, { 0, 17, 0 } } },
	{ { { 9, 0, 1 }, { 0, 18, 1 } } },
	{ { { 9, 0, 0 }, { 0, 18, 0 } } },
	{ { { 9, 0, 1 }, { 0, 19, 1 } } },
	{ { { 9, 0, 2 }, { 0, 19, 0 } } },
	{ { { 10, 0, 1 }, { 0, 20, 1 } } },
	{ { { 10, 0, 0 }, { 0, 20, 0 } } },
	{ { { 10, 0, 1 }, { 0, 21, 1 } } },
	{ { { 10, 0, 2 }, { 0, 21, 0 } } },
	{ { { 11, 0, 1 }, { 0, 22, 1 } } },
	{ { { 11, 0, 0 }, { 0, 22, 0 } } },
	{ { { 11, 0, 1 }, { 0, 23, 1 } } },
	{ { { 11, 0, 2 }, { 0, 23, 0 } } },
	{ { { 12, 0, 1 }, { 0, 24, 1 } } },
	{ { { 12, 0, 0 }, { 0, 24, 0 } } },
	{ { { 12, 0, 1 }, { 0, 25, 1 } } },
	{ { { 12, 0, 2 }, { 0, 25, 0 } } },
	{ { { 13, 0, 1 }, { 0, 26, 1 } } },
	{ { { 13, 0, 0 }, { 0, 26, 0 } } },
	{ { { 13, 0, 1 }, { 0, 27, 1 } } },
	{ { { 13, 0, 2 }, { 0, 27, 0 } } },
	{ { { 14, 0, 1 }, { 0, 28, 1 } } },
	{ { { 14, 0, 0 }, { 0, 28, 0 } } },
	{ { { 14, 0, 1 }, { 0, 29, 1 } } },
	{ { { 14, 0, 2 }, { 0, 29, 0 } } },
	{ { { 15, 0, 1 }, { 0, 30, 1 } } },
	{ { { 15, 0, 0 }, { 0, 30, 0 } } },
	{ { { 15, 0, 1 }, { 0, 31, 1 } } },
	{ { { 15, 0, 2 }, { 0, 31, 0 } } },
	{ { { 16, 0, 2 }, { 1, 31, 1 } } },
	{ { { 16, 0, 1 }, { 1, 31, 0 } } },
	{ { { 16, 0, 0 }, { 0, 32, 0 } } },
	{ { { 16, 0, 1 }, { 2, 31, 0 } } },
	{ { { 16, 0, 2 }, { 0, 33, 0 } } },
	{ { { 17, 0, 1 }, { 3, 31, 0 } } },
	{ { { 17, 0, 0 }, { 0, 34, 0 } } },
	{ { { 17, 0, 1 }, { 4, 31, 0 } } },
	{ { { 17, 0, 2 }, { 0, 35, 0 } } },
	{ { { 18, 0, 1 }, { 5, 31, 0 } } },
	{ { { 18, 0, 0 }, { 0, 36, 0 } } },
	{ { { 18, 0, 1 }, { 6, 31, 0 } } },
	{ { { 18, 0, 2 }, { 0, 37, 0 } } },
	{ { { 19, 0, 1 }, { 7, 31, 0 } } },
	{ { { 19, 0, 0 }, { 0, 38, 0 } } },
	{ { { 19, 0, 1 }, { 8, 31, 0 } } },
	{ { { 19, 0, 2 }, { 0, 39, 0 } } },
	{ { { 20, 0, 1 }, { 9, 31, 0 } } },
	{ { { 20, 0, 0 }, { 0, 40, 0 } } },
	{ { { 20, 0, 1 }, { 10, 31, 0 } } },
	{ { { 20, 0, 2 }, { 0, 41, 0 } } },
	{ { { 21, 0, 1 }, { 11, 31, 0 } } },
	{ { { 21, 0, 0 }, { 0, 42, 0 } } },
	{ { { 21, 0, 1 }, { 12, 31, 0 } } },
	{ { { 21, 0, 2 }, { 0, 43, 0 } } },
	{ { { 22, 0, 1 }, { 13, 31, 0 } } },
	{ { { 22, 0, 0 }, { 0, 44, 0 } } },
	{ { { 22, 0, 1 }, { 14, 31, 0 } } },
	{ { { 22, 0, 2 }, { 0, 45, 0 } } },
	{ { { 23, 0, 1 }, { 15, 31, 0 } } },
	{ { { 23, 0, 0 }, { 0, 46, 0 } } },
	{ { { 23, 0, 1 }, { 0, 47, 1 } } },
	{ { { 23, 0, 2 }, { 0, 47, 0 } } },
	{ { { 24, 0, 1 }, { 0, 48, 1 } } },
	{ { { 24, 0, 0 }, { 0, 48, 0 } } },
	{ { { 24, 0, 1 }, { 0, 49, 1 } } },
	{ { { 24, 0, 2 }, { 0, 49, 0 } } },
	{ { { 25, 0, 1 }, { 0, 50, 1 } } },
	{ { { 25, 0, 0 }, { 0, 50, 0 } } },
	{ { { 25, 0, 1 }, { 0, 51, 1 } } },
	{ { { 25, 0, 2 }, { 0, 51, 0 } } },
	{ { { 26, 0, 1 }, { 0, 52, 1 } } },
	{ { { 26, 0, 0 }, { 0, 52, 0 } } },
	{ { { 26, 0, 1 }, { 0, 53, 1 } } },
	{ { { 26, 0, 2 }, { 0, 53, 0 } } },
	{ { { 27, 0, 1 }, { 0, 54, 1 } } },
	{ { { 27, 0, 0 }, { 0, 54, 0 } } },
	{ { { 27, 0, 1 }, { 0, 55, 1 } } },
	{ { { 27, 0, 2 }, { 0, 55, 0 } } },
	{ { { 28, 0, 1 }, { 0, 56, 1 } } },
	{ { { 28, 0, 0 }, { 0, 56, 0 } } },
	{ { { 28, 0, 1 }, { 0, 57, 1 } } },
	{ { { 28, 0, 2 }, { 0, 57, 0 } } },
	{ { { 29, 0, 1 }, { 0, 58, 1 } } },
	{ { { 29, 0, 0 }, { 0, 58, 0 } } },
	{ { { 29, 0, 1 }, { 0, 59, 1 } } },
	{ { { 29, 0, 2 }, { 0, 59, 0 } } },
	{ { { 30, 0, 1 }, { 0, 60, 1 } } },
	{ { { 30, 0, 0 }, { 0, 60, 0 } } },
	{ { { 30, 0, 1 }, { 0, 61, 1 } } },
	{ { { 30, 0, 2 }, { 0, 61, 0 } } },
	{ { { 31, 0, 1 }, { 0, 62, 1 } } },
	{ { { 31, 0, 0 }, { 0, 62, 0 } } },
	{ { { 31, 0, 1 }, { 0, 63, 1 } } },
	{ { { 31, 0, 2 }, { 0, 63, 0 } } },
	{ { { 32, 0, 2 }, { 1, 63, 1 } } },
	{ { { 32, 0, 1 }, { 1, 63, 0 } } },
	{ { { 32, 0, 0 }, { 16, 48, 0 } } },
	{ { { 32, 0, 1 }, { 2, 63, 0 } } },
	{ { { 32, 0, 2 }, { 16, 49, 0 } } },
	{ { { 33, 0, 1 }, { 3, 63, 0 } } },
	{ { { 33, 0, 0 }, { 16, 50, 0 } } },
	{ { { 33, 0, 1 }, { 4, 63, 0 } } },
	{ { { 33, 0, 2 }, { 16, 51, 0 } } },
	{ { { 34, 0, 1 }, { 5, 63, 0 } } },
	{ { { 34, 0, 0 }, { 16, 52, 0 } } },
	{ { { 34, 0, 1 }, { 6, 63, 0 } } },
	{ { { 34, 0, 2 }, { 16, 53, 0 } } },
	{ { { 35, 0, 1 }, { 7, 63, 0 } } },
	{ { { 35, 0, 0 }, { 16, 54, 0 } } },
	{ { { 35, 0, 1 }, { 8, 63, 0 } } },
	{ { { 35, 0, 2 }, { 16, 55, 0 } } },
	{ { { 36, 0, 1 }, { 9, 63, 0 } } },
	{ { { 36, 0, 0 }, { 16, 56, 0 } } },
	{ { { 36, 0, 1 }, { 10, 63, 0 } } },
	{ { { 36, 0, 2 }, { 16, 57, 0 } } },
	{ { { 37, 0, 1 }, { 11, 63, 0 } } },
	{ { { 37, 0, 0 }, { 16, 58, 0 } } },
	{ { { 37, 0, 1 }, { 12, 63, 0 } } },
	{ { { 37, 0, 2 }, { 16, 59, 0 } } },
	{ { { 38, 0, 1 }, { 13, 63, 0 } } },
	{ { { 38, 0, 0 }, { 16, 60, 0 } } },
	{ { { 38, 0, 1 }, { 14, 63, 0 } } },
	{ { { 38, 0, 2 }, { 16, 61, 0 } } },
	{ { { 39, 0, 1 }, { 15, 63, 0 } } },
	{ { { 39, 0, 0 }, { 16, 62, 0 } } },
	{ { { 39, 0, 1 }, { 16, 63, 1 } } },
	{ { { 39, 0, 2 }, { 16, 63, 0 } } },
	{ { { 40, 0, 1 }, { 17, 63, 1 } } },
	{ { { 40, 0, 0 }, { 17, 63, 0 } } },
	{ { { 40, 0, 1 }, { 18, 63, 1 } } },
	{ { { 40, 0, 2 }, { 18, 63, 0 } } },
	{ { { 41, 0, 1 }, { 19, 63, 1 } } },
	{ { { 41, 0, 0 }, { 19, 63, 0 } } },
	{ { { 41, 0, 1 }, { 20, 63, 1 } } },
	{ { { 41, 0, 2 }, { 20, 63, 0 } } },
	{ { { 42, 0, 1 }, { 21, 63, 1 } } },
	{ { { 42, 0, 0 }, { 21, 63, 0 } } },
	{ { { 42, 0, 1 }, { 22, 63, 1 } } },
	{ { { 42, 0, 2 }, { 22, 63, 0 } } },
	{ { { 43, 0, 1 }, { 23, 63, 1 } } },
	{ { { 43, 0, 0 }, { 23, 63, 0 } } },
	{ { { 43, 0, 1 }, { 24, 63, 1 } } },
	{ { { 43, 0, 2 }, { 24, 63, 0 } } },
	{ { { 44, 0, 1 }, { 25, 63, 1 } } },
	{ { { 44, 0, 0 }, { 25, 63, 0 } } },
	{ { { 44, 0, 1 }, { 26, 63, 1 } } },
	{ { { 44, 0, 2 }, { 26, 63, 0 } } },
	{ { { 45, 0, 1 }, { 27, 63, 1 } } },
	{ { { 45, 0, 0 }, { 27, 63, 0 } } },
	{ { { 45, 0, 1 }, { 28, 63, 1 } } },
	{ { { 45, 0, 2 }, { 28, 63, 0 } } },
	{ { { 46, 0, 1 }, { 29, 63, 1 } } },
	{ { { 46, 0, 0 }, { 29, 63, 0 } } },
	{ { { 46, 0, 1 }, { 30, 63, 1 } } },
	{ { { 46, 0, 2 }, { 30, 63, 0 } } },
	{ { { 47, 0, 1 }, { 31, 63, 1 } } },
	{ { { 47, 0, 0 }, { 31, 63, 0 } } },
	{ { { 47, 0, 1 }, { 32, 63, 1 } } },
	{ { { 47, 0, 2 }, { 32, 63, 0 } } },
	{ { { 48, 0, 2 }, { 33, 63, 1 } } },
	{ { { 48, 0, 1 }, { 33, 63, 0 } } },
	{ { { 48, 0, 0 }, { 48, 48, 0 } } },
	{ { { 48, 0, 1 }, { 34, 63, 0 } } },
	{ { { 48, 0, 2 }, { 48, 49, 0 } } },
	{ { { 49, 0, 1 }, { 35, 63, 0 } } },
	{ { { 49, 0, 0 }, { 48, 50, 0 } } },
	{ { { 49, 0, 1 }, { 36, 63, 0 } } },
	{ { { 49, 0, 2 }, { 48, 51, 0 } } },
	{ { { 50, 0, 1 }, { 37, 63, 0 } } },
	{ { { 50, 0, 0 }, { 48, 52, 0 } } },
	{ { { 50, 0, 1 }, { 38, 63, 0 } } },
	{ { { 50, 0, 2 }, { 48, 53, 0 } } },
	{ { { 51, 0, 1 }, { 39, 63, 0 } } },
	{ { { 51, 0, 0 }, { 48, 54, 0 } } },
	{ { { 51, 0, 1 }, { 40, 63, 0 } } },
	{ { { 51, 0, 2 }, { 48, 55, 0 } } },
	{ { { 52, 0, 1 }, { 41, 63, 0 } } },
	{ { { 52, 0, 0 }, { 48, 56, 0 } } },
	{ { { 52, 0, 1 }, { 42, 63, 0 } } },
	{ { { 52, 0, 2 }, { 48, 57, 0 } } },
	{ { { 53, 0, 1 }, { 43, 63, 0 } } },
	{ { { 53, 0, 0 }, { 48, 58, 0 } } },
	{ { { 53, 0, 1 }, { 44, 63, 0 } } },
	{ { { 53, 0, 2 }, { 48, 59, 0 } } },
	{ { { 54, 0, 1 }, { 45, 63, 0 } } },
	{ { { 54, 0, 0 }, { 48, 60, 0 } } },
	{ { { 54, 0, 1 }, { 46, 63, 0 } } },
	{ { { 54, 0, 2 }, { 48, 61, 0 } } },
	{ { { 55, 0, 1 }, { 47, 63, 0 } } },
	{ { { 55, 0, 0 }, { 48, 62, 0 } } },
	{ { { 55, 0, 1 }, { 48, 63, 1 } } },
	{ { { 55, 0, 2 }, { 48, 63, 0 } } },
	{ { { 56, 0, 1 }, { 49, 63, 1 } } },
	{ { { 56, 0, 0 }, { 49, 63, 0 } } },
	{ { { 56, 0, 1 }, { 50, 63, 1 } } },
	{ { { 56, 0, 2 }, { 50, 63, 0 } } },
	{ { { 57, 0, 1 }, { 51, 63, 1 } } },
	{ { { 57, 0, 0 }, { 51, 63, 0 } } },
	{ { { 57, 0, 1 }, { 52, 63, 1 } } },
	{ { { 57, 0, 2 }, { 52, 63, 0 } } },
	{ { { 58, 0, 1 }, { 53, 63, 1 } } },
	{ { { 58, 0, 0 }, { 53, 63, 0 } } },
	{ { { 58, 0, 1 }, { 54, 63, 1 } } },
	{ { { 58, 0, 2 }, { 54, 63, 0 } } },
	{ { { 59, 0, 1 }, { 55, 63, 1 } } },
	{ { { 59, 0, 0 }, { 55, 63, 0 } } },
	{ { { 59, 0, 1 }, { 56, 63, 1 } } },
	{ { { 59, 0, 2 }, { 56, 63, 0 } } },
	{ { { 60, 0, 1 }, { 57, 63, 1 } } },
	{ { { 60, 0, 0 }, { 57, 63, 0 } } },
	{ { { 60, 0, 1 }, { 58, 63, 1 } } },
	{ { { 60, 0, 2 }, { 58, 63, 0 } } },
	{ { { 61, 0, 1 }, { 59, 63, 1 } } },
	{ { { 61, 0, 0 }, { 59, 63, 0 } } },
	{ { { 61, 0, 1 }, { 60, 63, 1 } } },
	{ { { 61, 0, 2 }, { 60, 63, 0 } } },
	{ { { 62, 0, 1 }, { 61, 63, 1 } } },
	{ { { 62, 0, 0 }, { 61, 63, 0 } } },
	{ { { 62, 0, 1 }, { 62, 63, 1 } } },
	{ { { 62, 0, 2 }, { 62, 63, 0 } } },
	{ { { 63, 0, 1 }, { 63, 63, 1 } } },
	{ { { 63, 0, 0 }, { 63, 63, 0 } } }
};

static SingleColourLookup const lookup_5_4[] = 
{
	{ { { 0, 0, 0 }, { 0, 0, 0 } } },
	{ { { 0, 0, 1 }, { 0, 1, 1 } } },
	{ { { 0, 0, 2 }, { 0, 1, 0 } } },
	{ { { 0, 0, 3 }, { 0, 1, 1 } } },
	{ { { 0, 0, 4 }, { 0, 2, 1 } } },
	{ { { 1, 0, 3 }, { 0, 2, 0 } } },
	{ { { 1, 0, 2 }, { 0, 2, 1 } } },
	{ { { 1, 0, 1 }, { 0, 3, 1 } } },
	{ { { 1, 0, 0 }, { 0, 3, 0 } } },
	{ { { 1, 0, 1 }, { 1, 2, 1 } } },
	{ { { 1, 0, 2 }, { 1, 2, 0 } } },
	{ { { 1, 0, 3 }, { 0, 4, 0 } } },
	{ { { 1, 0, 4 }, { 0, 5, 1 } } },
	{ { { 2, 0, 3 }, { 0, 5, 0 } } },
	{ { { 2, 0, 2 }, { 0, 5, 1 } } },
	{ { { 2, 0, 1 }, { 0, 6, 1 } } },
	{ { { 2, 0, 0 }, { 0, 6, 0 } } },
	{ { { 2, 0, 1 }, { 2, 3, 1 } } },
	{ { { 2, 0, 2 }, { 2, 3, 0 } } },
	{ { { 2, 0, 3 }, { 0, 7, 0 } } },
	{ { { 2, 0, 4 }, { 1, 6, 1 } } },
	{ { { 3, 0, 3 }, { 1, 6, 0 } } },
	{ { { 3, 0, 2 }, { 0, 8, 0 } } },
	{ { { 3, 0, 1 }, { 0, 9, 1 } } },
	{ { { 3, 0, 0 }, { 0, 9, 0 } } },
	{ { { 3, 0, 1 }, { 0, 9, 1 } } },
	{ { { 3, 0, 2 }, { 0, 10, 1 } } },
	{ { { 3, 0, 3 }, { 0, 10, 0 } } },
	{ { { 3, 0, 4 }, { 2, 7, 1 } } },
	{ { { 4, 0, 4 }, { 2, 7, 0 } } },
	{ { { 4, 0, 3 }, { 0, 11, 0 } } },
	{ { { 4, 0, 2 }, { 1, 10, 1 } } },
	{ { { 4, 0, 1 }, { 1, 10, 0 } } },
	{ { { 4, 0, 0 }, { 0, 12, 0 } } },
	{ { { 4, 0, 1 }, { 0, 13, 1 } } },
	{ { { 4, 0, 2 }, { 0, 13, 0 } } },
	{ { { 4, 0, 3 }, { 0, 13, 1 } } },
	{ { { 4, 0, 4 }, { 0, 14, 1 } } },
	{ { { 5, 0, 3 }, { 0, 14, 0 } } },
	{ { { 5, 0, 2 }, { 2, 11, 1 } } },
	{ { { 5, 0, 1 }, { 2, 11, 0 } } },
	{ { { 5, 0, 0 }, { 0, 15, 0 } } },
	{ { { 5, 0, 1 }, { 1, 14, 1 } } },
	{ { { 5, 0, 2 }, { 1, 14, 0 } } },
	{ { { 5, 0, 3 }, { 0, 16, 0 } } },
	{ { { 5, 0, 4 }, { 0, 17, 1 } } },
	{ { { 6, 0, 3 }, { 0, 17, 0 } } },
	{ { { 6, 0, 2 }, { 0, 17, 1 } } },
	{ { { 6, 0, 1 }, { 0, 18, 1 } } },
	{ { { 6, 0, 0 }, { 0, 18, 0 } } },
	{ { { 6, 0, 1 }, { 2, 15, 1 } } },
	{ { { 6, 0, 2 }, { 2, 15, 0 } } },
	{ { { 6, 0, 3 }, { 0, 19, 0 } } },
	{ { { 6, 0, 4 }, { 1, 18, 1 } } },
	{ { { 7, 0, 3 }, { 1, 18, 0 } } },
	{ { { 7, 0, 2 }, { 0, 20, 0 } } },
	{ { { 7, 0, 1 }, { 0, 21, 1 } } },
	{ { { 7, 0, 0 }, { 0, 21, 0 } } },
	{ { { 7, 0, 1 }, { 0, 21, 1 } } },
	{ { { 7, 0, 2 }, { 0, 22, 1 } } },
	{ { { 7, 0, 3 }, { 0, 22, 0 } } },
	{ { { 7, 0, 4 }, { 2, 19, 1 } } },
	{ { { 8, 0, 4 }, { 2, 19, 0 } } },
	{ { { 8, 0, 3 }, { 0, 23, 0 } } },
	{ { { 8, 0, 2 }, { 1, 22, 1 } } },
	{ { { 8, 0, 1 }, { 1, 22, 0 } } },
	{ { { 8, 0, 0 }, { 0, 24, 0 } } },
	{ { { 8, 0, 1 }, { 0, 25, 1 } } },
	{ { { 8, 0, 2 }, { 0, 25, 0 } } },
	{ { { 8, 0, 3 }, { 0, 25, 1 } } },
	{ { { 8, 0, 4 }, { 0, 26, 1 } } },
	{ { { 9, 0, 3 }, { 0, 26, 0 } } },
	{ { { 9, 0, 2 }, { 2, 23, 1 } } },
	{ { { 9, 0, 1 }, { 2, 23, 0 } } },
	{ { { 9, 0, 0 }, { 0, 27, 0 } } },
	{ { { 9, 0, 1 }, { 1, 26, 1 } } },
	{ { { 9, 0, 2 }, { 1, 26, 0 } } },
	{ { { 9, 0, 3 }, { 0, 28, 0 } } },
	{ { { 9, 0, 4 }, { 0, 29, 1 } } },
	{ { { 10, 0, 3 }, { 0, 29, 0 } } },
	{ { { 10, 0, 2 }, { 0, 29, 1 } } },
	{ { { 10, 0, 1 }, { 0, 30, 1 } } },
	{ { { 10, 0, 0 }, { 0, 30, 0 } } },
	{ { { 10, 0, 1 }, { 2, 27, 1 } } },
	{ { { 10, 0, 2 }, { 2, 27, 0 } } },
	{ { { 10, 0, 3 }, { 0, 31, 0 } } },
	{ { { 10, 0, 4 }, { 1, 30, 1 } } },
	{ { { 11, 0, 3 }, { 1, 30, 0 } } },
	{ { { 11, 0, 2 }, { 4, 24, 0 } } },
	{ { { 11, 0, 1 }, { 1, 31, 1 } } },
	{ { { 11, 0, 0 }, { 1, 31, 0 } } },
	{ { { 11, 0, 1 }, { 1, 31, 1 } } },
	{ { { 11, 0, 2 }, { 2, 30, 1 } } },
	{ { { 11, 0, 3 }, { 2, 30, 0 } } },
	{ { { 11, 0, 4 }, { 2, 31, 1 } } },
	{ { { 12, 0, 4 }, { 2, 31, 0 } } },
	{ { { 12, 0, 3 }, { 4, 27, 0 } } },
	{ { { 12, 0, 2 }, { 3, 30, 1 } } },
	{ { { 12, 0, 1 }, { 3, 30, 0 } } },
	{ { { 12, 0, 0 }, { 4, 28, 0 } } },
	{ { { 12, 0, 1 }, { 3, 31, 1 } } },
	{ { { 12, 0, 2 }, { 3, 31, 0 } } },
	{ { { 12, 0, 3 }, { 3, 31, 1 } } },
	{ { { 12, 0, 4 }, { 4, 30, 1 } } },
	{ { { 13, 0, 3 }, { 4, 30, 0 } } },
	{ { { 13, 0, 2 }, { 6, 27, 1 } } },
	{ { { 13, 0, 1 }, { 6, 27, 0 } } },
	{ { { 13, 0, 0 }, { 4, 31, 0 } } },
	{ { { 13, 0, 1 }, { 5, 30, 1 } } },
	{ { { 13, 0, 2 }, { 5, 30, 0 } } },
	{ { { 13, 0, 3 }, { 8, 24, 0 } } },
	{ { { 13, 0, 4 }, { 5, 31, 1 } } },
	{ { { 14, 0, 3 }, { 5, 31, 0 } } },
	{ { { 14, 0, 2 }, { 5, 31, 1 } } },
	{ { { 14, 0, 1 }, { 6, 30, 1 } } },
	{ { { 14, 0, 0 }, { 6, 30, 0 } } },
	{ { { 14, 0, 1 }, { 6, 31, 1 } } },
	{ { { 14, 0, 2 }, { 6, 31, 0 } } },
	{ { { 14, 0, 3 }, { 8, 27, 0 } } },
	{ { { 14, 0, 4 }, { 7, 30, 1 } } },
	{ { { 15, 0, 3 }, { 7, 30, 0 } } },
	{ { { 15, 0, 2 }, { 8, 28, 0 } } },
	{ { { 15, 0, 1 }, { 7, 31, 1 } } },
	{ { { 15, 0, 0 }, { 7, 31, 0 } } },
	{ { { 15, 0, 1 }, { 7, 31, 1 } } },
	{ { { 15, 0, 2 }, { 8, 30, 1 } } },
	{ { { 15, 0, 3 }, { 8, 30, 0 } } },
	{ { { 15, 0, 4 }, { 10, 27, 1 } } },
	{ { { 16, 0, 4 }, { 10, 27, 0 } } },
	{ { { 16, 0, 3 }, { 8, 31, 0 } } },
	{ { { 16, 0, 2 }, { 9, 30, 1 } } },
	{ { { 16, 0, 1 }, { 9, 30, 0 } } },
	{ { { 16, 0, 0 }, { 12, 24, 0 } } },
	{ { { 16, 0, 1 }, { 9, 31, 1 } } },
	{ { { 16, 0, 2 }, { 9, 31, 0 } } },
	{ { { 16, 0, 3 }, { 9, 31, 1 } } },
	{ { { 16, 0, 4 }, { 10, 30, 1 } } },
	{ { { 17, 0, 3 }, { 10, 30, 0 } } },
	{ { { 17, 0, 2 }, { 10, 31, 1 } } },
	{ { { 17, 0, 1 }, { 10, 31, 0 } } },
	{ { { 17, 0, 0 }, { 12, 27, 0 } } },
	{ { { 17, 0, 1 }, { 11, 30, 1 } } },
	{ { { 17, 0, 2 }, { 11, 30, 0 } } },
	{ { { 17, 0, 3 }, { 12, 28, 0 } } },
	{ { { 17, 0, 4 }, { 11, 31, 1 } } },
	{ { { 18, 0, 3 }, { 11, 31, 0 } } },
	{ { { 18, 0, 2 }, { 11, 31, 1 } } },
	{ { { 18, 0, 1 }, { 12, 30, 1 } } },
	{ { { 18, 0, 0 }, { 12, 30, 0 } } },
	{ { { 18, 0, 1 }, { 14, 27, 1 } } },
	{ { { 18, 0, 2 }, { 14, 27, 0 } } },
	{ { { 18, 0, 3 }, { 12, 31, 0 } } },
	{ { { 18, 0, 4 }, { 13, 30, 1 } } },
	{ { { 19, 0, 3 }, { 13, 30, 0 } } },
	{ { { 19, 0, 2 }, { 16, 24, 0 } } },
	{ { { 19, 0, 1 }, { 13, 31, 1 } } },
	{ { { 19, 0, 0 }, { 13, 31, 0 } } },
	{ { { 19, 0, 1 }, { 13, 31, 1 } } },
	{ { { 19, 0, 2 }, { 14, 30, 1 } } },
	{ { { 19, 0, 3 }, { 14, 30, 0 } } },
	{ { { 19, 0, 4 }, { 14, 31, 1 } } },
	{ { { 20, 0, 4 }, { 14, 31, 0 } } },
	{ { { 20, 0, 3 }, { 16, 27, 0 } } },
	{ { { 20, 0, 2 }, { 15, 30, 1 } } },
	{ { { 20, 0, 1 }, { 15, 30, 0 } } },
	{ { { 20, 0, 0 }, { 16, 28, 0 } } },
	{ { { 20, 0, 1 }, { 15, 31, 1 } } },
	{ { { 20, 0, 2 }, { 15, 31, 0 } } },
	{ { { 20, 0, 3 }, { 15, 31, 1 } } },
	{ { { 20, 0, 4 }, { 16, 30, 1 } } },
	{ { { 21, 0, 3 }, { 16, 30, 0 } } },
	{ { { 21, 0, 2 }, { 18, 27, 1 } } },
	{ { { 21, 0, 1 }, { 18, 27, 0 } } },
	{ { { 21, 0, 0 }, { 16, 31, 0 } } },
	{ { { 21, 0, 1 }, { 17, 30, 1 } } },
	{ { { 21, 0, 2 }, { 17, 30, 0 } } },
	{ { { 21, 0, 3 }, { 20, 24, 0 } } },
	{ { { 21, 0, 4 }, { 17, 31, 1 } } },
	{ { { 22, 0, 3 }, { 17, 31, 0 } } },
	{ { { 22, 0, 2 }, { 17, 31, 1 } } },
	{ { { 22, 0, 1 }, { 18, 30, 1 } } },
	{ { { 22, 0, 0 }, { 18, 30, 0 } } },
	{ { { 22, 0, 1 }, { 18, 31, 1 } } },
	{ { { 22, 0, 2 }, { 18, 31, 0 } } },
	{ { { 22, 0, 3 }, { 20, 27, 0 } } },
	{ { { 22, 0, 4 }, { 19, 30, 1 } } },
	{ { { 23, 0, 3 }, { 19, 30, 0 } } },
	{ { { 23, 0, 2 }, { 20, 28, 0 } } },
	{ { { 23, 0, 1 }, { 19, 31, 1 } } },
	{ { { 23, 0, 0 }, { 19, 31, 0 } } },
	{ { { 23, 0, 1 }, { 19, 31, 1 } } },
	{ { { 23, 0, 2 }, { 20, 30, 1 } } },
	{ { { 23, 0, 3 }, { 20, 30, 0 } } },
	{ { { 23, 0, 4 }, { 22, 27, 1 } } },
	{ { { 24, 0, 4 }, { 22, 27, 0 } } },
	{ { { 24, 0, 3 }, { 20, 31, 0 } } },
	{ { { 24, 0, 2 }, { 21, 30, 1 } } },
	{ { { 24, 0, 1 }, { 21, 30, 0 } } },
	{ { { 24, 0, 0 }, { 24, 24, 0 } } },
	{ { { 24, 0, 1 }, { 21, 31, 1 } } },
	{ { { 24, 0, 2 }, { 21, 31, 0 } } },
	{ { { 24, 0, 3 }, { 21, 31, 1 } } },
	{ { { 24, 0, 4 }, { 22, 30, 1 } } },
	{ { { 25, 0, 3 }, { 22, 30, 0 } } },
	{ { { 25, 0, 2 }, { 22, 31, 1 } } },
	{ { { 25, 0, 1 }, { 22, 31, 0 } } },
	{ { { 25, 0, 0 }, { 24, 27, 0 } } },
	{ { { 25, 0, 1 }, { 23, 30, 1 } } },
	{ { { 25, 0, 2 }, { 23, 30, 0 } } },
	{ { { 25, 0, 3 }, { 24, 28, 0 } } },
	{ { { 25, 0, 4 }, { 23, 31, 1 } } },
	{ { { 26, 0, 3 }, { 23, 31, 0 } } },
	{ { { 26, 0, 2 }, { 23, 31, 1 } } },
	{ { { 26, 0, 1 }, { 24, 30, 1 } } },
	{ { { 26, 0, 0 }, { 24, 30, 0 } } },
	{ { { 26, 0, 1 }, { 26, 27, 1 } } },
	{ { { 26, 0, 2 }, { 26, 27, 0 } } },
	{ { { 26, 0, 3 }, { 24, 31, 0 } } },
	{ { { 26, 0, 4 }, { 25, 30, 1 } } },
	{ { { 27, 0, 3 }, { 25, 30, 0 } } },
	{ { { 27, 0, 2 }, { 28, 24, 0 } } },
	{ { { 27, 0, 1 }, { 25, 31, 1 } } },
	{ { { 27, 0, 0 }, { 25, 31, 0 } } },
	{ { { 27, 0, 1 }, { 25, 31, 1 } } },
	{ { { 27, 0, 2 }, { 26, 30, 1 } } },
	{ { { 27, 0, 3 }, { 26, 30, 0 } } },
	{ { { 27, 0, 4 }, { 26, 31, 1 } } },
	{ { { 28, 0, 4 }, { 26, 31, 0 } } },
	{ { { 28, 0, 3 }, { 28, 27, 0 } } },
	{ { { 28, 0, 2 }, { 27, 30, 1 } } },
	{ { { 28, 0, 1 }, { 27, 30, 0 } } },
	{ { { 28, 0, 0 }, { 28, 28, 0 } } },
	{ { { 28, 0, 1 }, { 27, 31, 1 } } },
	{ { { 28, 0, 2 }, { 27, 31, 0 } } },
	{ { { 28, 0, 3 }, { 27, 31, 1 } } },
	{ { { 28, 0, 4 }, { 28, 30, 1 } } },
	{ { { 29, 0, 3 }, { 28, 30, 0 } } },
	{ { { 29, 0, 2 }, { 30, 27, 1 } } },
	{ { { 29, 0, 1 }, { 30, 27, 0 } } },
	{ { { 29, 0, 0 }, { 28, 31, 0 } } },
	{ { { 29, 0, 1 }, { 29, 30, 1 } } },
	{ { { 29, 0, 2 }, { 29, 30, 0 } } },
	{ { { 29, 0, 3 }, { 29, 30, 1 } } },
	{ { { 29, 0, 4 }, { 29, 31, 1 } } },
	{ { { 30, 0, 3 }, { 29, 31, 0 } } },
	{ { { 30, 0, 2 }, { 29, 31, 1 } } },
	{ { { 30, 0, 1 }, { 30, 30, 1 } } },
	{ { { 30, 0, 0 }, { 30, 30, 0 } } },
	{ { { 30, 0, 1 }, { 30, 31, 1 } } },
	{ { { 30, 0, 2 }, { 30, 31, 0 } } },
	{ { { 30, 0, 3 }, { 30, 31, 1 } } },
	{ { { 30, 0, 4 }, { 31, 30, 1 } } },
	{ { { 31, 0, 3 }, { 31, 30, 0 } } },
	{ { { 31, 0, 2 }, { 31, 30, 1 } } },
	{ { { 31, 0, 1 }, { 31, 31, 1 } } },
	{ { { 31, 0, 0 }, { 31, 31, 0 } } }
};

static SingleColourLookup const lookup_6_4[] = 
{
	{ { { 0, 0, 0 }, { 0, 0, 0 } } },
	{ { { 0, 0, 1 }, { 0, 1, 0 } } },
	{ { { 0, 0, 2 }, { 0, 2, 0 } } },
	{ { { 1, 0, 1 }, { 0, 3, 1 } } },
	{ { { 1, 0, 0 }, { 0, 3, 0 } } },
	{ { { 1, 0, 1 }, { 0, 4, 0 } } },
	{ { { 1, 0, 2 }, { 0, 5, 0 } } },
	{ { { 2, 0, 1 }, { 0, 6, 1 } } },
	{ { { 2, 0, 0 }, { 0, 6, 0 } } },
	{ { { 2, 0, 1 }, { 0, 7, 0 } } },
	{ { { 2, 0, 2 }, { 0, 8, 0 } } },
	{ { { 3, 0, 1 }, { 0, 9, 1 } } },
	{ { { 3, 0, 0 }, { 0, 9, 0 } } },
	{ { { 3, 0, 1 }, { 0, 10, 0 } } },
	{ { { 3, 0, 2 }, { 0, 11, 0 } } },
	{ { { 4, 0, 1 }, { 0, 12, 1 } } },
	{ { { 4, 0, 0 }, { 0, 12, 0 } } },
	{ { { 4, 0, 1 }, { 0, 13, 0 } } },
	{ { { 4, 0, 2 }, { 0, 14, 0 } } },
	{ { { 5, 0, 1 }, { 0, 15, 1 } } },
	{ { { 5, 0, 0 }, { 0, 15, 0 } } },
	{ { { 5, 0, 1 }, { 0, 16, 0 } } },
	{ { { 5, 0, 2 }, { 1, 15, 0 } } },
	{ { { 6, 0, 1 }, { 0, 17, 0 } } },
	{ { { 6, 0, 0 }, { 0, 18, 0 } } },
	{ { { 6, 0, 1 }, { 0, 19, 0 } } },
	{ { { 6, 0, 2 }, { 3, 14, 0 } } },
	{ { { 7, 0, 1 }, { 0, 20, 0 } } },
	{ { { 7, 0, 0 }, { 0, 21, 0 } } },
	{ { { 7, 0, 1 }, { 0, 22, 0 } } },
	{ { { 7, 0, 2 }, { 4, 15, 0 } } },
	{ { { 8, 0, 1 }, { 0, 23, 0 } } },
	{ { { 8, 0, 0 }, { 0, 24, 0 } } },
	{ { { 8, 0, 1 }, { 0, 25, 0 } } },
	{ { { 8, 0, 2 }, { 6, 14, 0 } } },
	{ { { 9, 0, 1 }, { 0, 26, 0 } } },
	{ { { 9, 0, 0 }, { 0, 27, 0 } } },
	{ { { 9, 0, 1 }, { 0, 28, 0 } } },
	{ { { 9, 0, 2 }, { 7, 15, 0 } } },
	{ { { 10, 0, 1 }, { 0, 29, 0 } } },
	{ { { 10, 0, 0 }, { 0, 30, 0 } } },
	{ { { 10, 0, 1 }, { 0, 31, 0 } } },
	{ { { 10, 0, 2 }, { 9, 14, 0 } } },
	{ { { 11, 0, 1 }, { 0, 32, 0 } } },
	{ { { 11, 0, 0 }, { 0, 33, 0 } } },
	{ { { 11, 0, 1 }, { 2, 30, 0 } } },
	{ { { 11, 0, 2 }, { 0, 34, 0 } } },
	{ { { 12, 0, 1 }, { 0, 35, 0 } } },
	{ { { 12, 0, 0 }, { 0, 36, 0 } } },
	{ { { 12, 0, 1 }, { 3, 31, 0 } } },
	{ { { 12, 0, 2 }, { 0, 37, 0 } } },
	{ { { 13, 0, 1 }, { 0, 38, 0 } } },
	{ { { 13, 0, 0 }, { 0, 39, 0 } } },
	{ { { 13, 0, 1 }, { 5, 30, 0 } } },
	{ { { 13, 0, 2 }, { 0, 40, 0 } } },
	{ { { 14, 0, 1 }, { 0, 41, 0 } } },
	{ { { 14, 0, 0 }, { 0, 42, 0 } } },
	{ { { 14, 0, 1 }, { 6, 31, 0 } } },
	{ { { 14, 0, 2 }, { 0, 43, 0 } } },
	{ { { 15, 0, 1 }, { 0, 44, 0 } } },
	{ { { 15, 0, 0 }, { 0, 45, 0 } } },
	{ { { 15, 0, 1 }, { 8, 30, 0 } } },
	{ { { 15, 0, 2 }, { 0, 46, 0 } } },
	{ { { 16, 0, 2 }, { 0, 47, 0 } } },
	{ { { 16, 0, 1 }, { 1, 46, 0 } } },
	{ { { 16, 0, 0 }, { 0, 48, 0 } } },
	{ { { 16, 0, 1 }, { 0, 49, 0 } } },
	{ { { 16, 0, 2 }, { 0, 50, 0 } } },
	{ { { 17, 0, 1 }, { 2, 47, 0 } } },
	{ { { 17, 0, 0 }, { 0, 51, 0 } } },
	{ { { 17, 0, 1 }, { 0, 52, 0 } } },
	{ { { 17, 0, 2 }, { 0, 53, 0 } } },
	{ { { 18, 0, 1 }, { 4, 46, 0 } } },
	{ { { 18, 0, 0 }, { 0, 54, 0 } } },
	{ { { 18, 0, 1 }, { 0, 55, 0 } } },
	{ { { 18, 0, 2 }, { 0, 56, 0 } } },
	{ { { 19, 0, 1 }, { 5, 47, 0 } } },
	{ { { 19, 0, 0 }, { 0, 57, 0 } } },
	{ { { 19, 0, 1 }, { 0, 58, 0 } } },
	{ { { 19, 0, 2 }, { 0, 59, 0 } } },
	{ { { 20, 0, 1 }, { 7, 46, 0 } } },
	{ { { 20, 0, 0 }, { 0, 60, 0 } } },
	{ { { 20, 0, 1 }, { 0, 61, 0 } } },
	{ { { 20, 0, 2 }, { 0, 62, 0 } } },
	{ { { 21, 0, 1 }, { 8, 47, 0 } } },
	{ { { 21, 0, 0 }, { 0, 63, 0 } } },
	{ { { 21, 0, 1 }, { 1, 62, 0 } } },
	{ { { 21, 0, 2 }, { 1, 63, 0 } } },
	{ { { 22, 0, 1 }, { 10, 46, 0 } } },
	{ { { 22, 0, 0 }, { 2, 62, 0 } } },
	{ { { 22, 0, 1 }, { 2, 63, 0 } } },
	{ { { 22, 0, 2 }, { 3, 62, 0 } } },
	{ { { 23, 0, 1 }, { 11, 47, 0 } } },
	{ { { 23, 0, 0 }, { 3, 63, 0 } } },
	{ { { 23, 0, 1 }, { 4, 62, 0 } } },
	{ { { 23, 0, 2 }, { 4, 63, 0 } } },
	{ { { 24, 0, 1 }, { 13, 46, 0 } } },
	{ { { 24, 0, 0 }, { 5, 62, 0 } } },
	{ { { 24, 0, 1 }, { 5, 63, 0 } } },
	{ { { 24, 0, 2 }, { 6, 62, 0 } } },
	{ { { 25, 0, 1 }, { 14, 47, 0 } } },
	{ { { 25, 0, 0 }, { 6, 63, 0 } } },
	{ { { 25, 0, 1 }, { 7, 62, 0 } } },
	{ { { 25, 0, 2 }, { 7, 63, 0 } } },
	{ { { 26, 0, 1 }, { 16, 45, 0 } } },
	{ { { 26, 0, 0 }, { 8, 62, 0 } } },
	{ { { 26, 0, 1 }, { 8, 63, 0 } } },
	{ { { 26, 0, 2 }, { 9, 62, 0 } } },
	{ { { 27, 0, 1 }, { 16, 48, 0 } } },
	{ { { 27, 0, 0 }, { 9, 63, 0 } } },
	{ { { 27, 0, 1 }, { 10, 62, 0 } } },
	{ { { 27, 0, 2 }, { 10, 63, 0 } } },
	{ { { 28, 0, 1 }, { 16, 51, 0 } } },
	{ { { 28, 0, 0 }, { 11, 62, 0 } } },
	{ { { 28, 0, 1 }, { 11, 63, 0 } } },
	{ { { 28, 0, 2 }, { 12, 62, 0 } } },
	{ { { 29, 0, 1 }, { 16, 54, 0 } } },
	{ { { 29, 0, 0 }, { 12, 63, 0 } } },
	{ { { 29, 0, 1 }, { 13, 62, 0 } } },
	{ { { 29, 0, 2 }, { 13, 63, 0 } } },
	{ { { 30, 0, 1 }, { 16, 57, 0 } } },
	{ { { 30, 0, 0 }, { 14, 62, 0 } } },
	{ { { 30, 0, 1 }, { 14, 63, 0 } } },
	{ { { 30, 0, 2 }, { 15, 62, 0 } } },
	{ { { 31, 0, 1 }, { 16, 60, 0 } } },
	{ { { 31, 0, 0 }, { 15, 63, 0 } } },
	{ { { 31, 0, 1 }, { 24, 46, 0 } } },
	{ { { 31, 0, 2 }, { 16, 62, 0 } } },
	{ { { 32, 0, 2 }, { 16, 63, 0 } } },
	{ { { 32, 0, 1 }, { 17, 62, 0 } } },
	{ { { 32, 0, 0 }, { 25, 47, 0 } } },
	{ { { 32, 0, 1 }, { 17, 63, 0 } } },
	{ { { 32, 0, 2 }, { 18, 62, 0 } } },
	{ { { 33, 0, 1 }, { 18, 63, 0 } } },
	{ { { 33, 0, 0 }, { 27, 46, 0 } } },
	{ { { 33, 0, 1 }, { 19, 62, 0 } } },
	{ { { 33, 0, 2 }, { 19, 63, 0 } } },
	{ { { 34, 0, 1 }, { 20, 62, 0 } } },
	{ { { 34, 0, 0 }, { 28, 47, 0 } } },
	{ { { 34, 0, 1 }, { 20, 63, 0 } } },
	{ { { 34, 0, 2 }, { 21, 62, 0 } } },
	{ { { 35, 0, 1 }, { 21, 63, 0 } } },
	{ { { 35, 0, 0 }, { 30, 46, 0 } } },
	{ { { 35, 0, 1 }, { 22, 62, 0 } } },
	{ { { 35, 0, 2 }, { 22, 63, 0 } } },
	{ { { 36, 0, 1 }, { 23, 62, 0 } } },
	{ { { 36, 0, 0 }, { 31, 47, 0 } } },
	{ { { 36, 0, 1 }, { 23, 63, 0 } } },
	{ { { 36, 0, 2 }, { 24, 62, 0 } } },
	{ { { 37, 0, 1 }, { 24, 63, 0 } } },
	{ { { 37, 0, 0 }, { 32, 47, 0 } } },
	{ { { 37, 0, 1 }, { 25, 62, 0 } } },
	{ { { 37, 0, 2 }, { 25, 63, 0 } } },
	{ { { 38, 0, 1 }, { 26, 62, 0 } } },
	{ { { 38, 0, 0 }, { 32, 50, 0 } } },
	{ { { 38, 0, 1 }, { 26, 63, 0 } } },
	{ { { 38, 0, 2 }, { 27, 62, 0 } } },
	{ { { 39, 0, 1 }, { 27, 63, 0 } } },
	{ { { 39, 0, 0 }, { 32, 53, 0 } } },
	{ { { 39, 0, 1 }, { 28, 62, 0 } } },
	{ { { 39, 0, 2 }, { 28, 63, 0 } } },
	{ { { 40, 0, 1 }, { 29, 62, 0 } } },
	{ { { 40, 0, 0 }, { 32, 56, 0 } } },
	{ { { 40, 0, 1 }, { 29, 63, 0 } } },
	{ { { 40, 0, 2 }, { 30, 62, 0 } } },
	{ { { 41, 0, 1 }, { 30, 63, 0 } } },
	{ { { 41, 0, 0 }, { 32, 59, 0 } } },
	{ { { 41, 0, 1 }, { 31, 62, 0 } } },
	{ { { 41, 0, 2 }, { 31, 63, 0 } } },
	{ { { 42, 0, 1 }, { 32, 61, 0 } } },
	{ { { 42, 0, 0 }, { 32, 62, 0 } } },
	{ { { 42, 0, 1 }, { 32, 63, 0 } } },
	{ { { 42, 0, 2 }, { 41, 46, 0 } } },
	{ { { 43, 0, 1 }, { 33, 62, 0 } } },
	{ { { 43, 0, 0 }, { 33, 63, 0 } } },
	{ { { 43, 0, 1 }, { 34, 62, 0 } } },
	{ { { 43, 0, 2 }, { 42, 47, 0 } } },
	{ { { 44, 0, 1 }, { 34, 63, 0 } } },
	{ { { 44, 0, 0 }, { 35, 62, 0 } } },
	{ { { 44, 0, 1 }, { 35, 63, 0 } } },
	{ { { 44, 0, 2 }, { 44, 46, 0 } } },
	{ { { 45, 0, 1 }, { 36, 62, 0 } } },
	{ { { 45, 0, 0 }, { 36, 63, 0 } } },
	{ { { 45, 0, 1 }, { 37, 62, 0 } } },
	{ { { 45, 0, 2 }, { 45, 47, 0 } } },
	{ { { 46, 0, 1 }, { 37, 63, 0 } } },
	{ { { 46, 0, 0 }, { 38, 62, 0 } } },
	{ { { 46, 0, 1 }, { 38, 63, 0 } } },
	{ { { 46, 0, 2 }, { 47, 46, 0 } } },
	{ { { 47, 0, 1 }, { 39, 62, 0 } } },
	{ { { 47, 0, 0 }, { 39, 63, 0 } } },
	{ { { 47, 0, 1 }, { 40, 62, 0 } } },
	{ { { 47, 0, 2 }, { 48, 46, 0 } } },
	{ { { 48, 0, 2 }, { 40, 63, 0 } } },
	{ { { 48, 0, 1 }, { 41, 62, 0 } } },
	{ { { 48, 0, 0 }, { 41, 63, 0 } } },
	{ { { 48, 0, 1 }, { 48, 49, 0 } } },
	{ { { 48, 0, 2 }, { 42, 62, 0 } } },
	{ { { 49, 0, 1 }, { 42, 63, 0 } } },
	{ { { 49, 0, 0 }, { 43, 62, 0 } } },
	{ { { 49, 0, 1 }, { 48, 52, 0 } } },
	{ { { 49, 0, 2 }, { 43, 63, 0 } } },
	{ { { 50, 0, 1 }, { 44, 62, 0 } } },
	{ { { 50, 0, 0 }, { 44, 63, 0 } } },
	{ { { 50, 0, 1 }, { 48, 55, 0 } } },
	{ { { 50, 0, 2 }, { 45, 62, 0 } } },
	{ { { 51, 0, 1 }, { 45, 63, 0 } } },
	{ { { 51, 0, 0 }, { 46, 62, 0 } } },
	{ { { 51, 0, 1 }, { 48, 58, 0 } } },
	{ { { 51, 0, 2 }, { 46, 63, 0 } } },
	{ { { 52, 0, 1 }, { 47, 62, 0 } } },
	{ { { 52, 0, 0 }, { 47, 63, 0 } } },
	{ { { 52, 0, 1 }, { 48, 61, 0 } } },
	{ { { 52, 0, 2 }, { 48, 62, 0 } } },
	{ { { 53, 0, 1 }, { 56, 47, 0 } } },
	{ { { 53, 0, 0 }, { 48, 63, 0 } } },
	{ { { 53, 0, 1 }, { 49, 62, 0 } } },
	{ { { 53, 0, 2 }, { 49, 63, 0 } } },
	{ { { 54, 0, 1 }, { 58, 46, 0 } } },
	{ { { 54, 0, 0 }, { 50, 62, 0 } } },
	{ { { 54, 0, 1 }, { 50, 63, 0 } } },
	{ { { 54, 0, 2 }, { 51, 62, 0 } } },
	{ { { 55, 0, 1 }, { 59, 47, 0 } } },
	{ { { 55, 0, 0 }, { 51, 63, 0 } } },
	{ { { 55, 0, 1 }, { 52, 62, 0 } } },
	{ { { 55, 0, 2 }, { 52, 63, 0 } } },
	{ { { 56, 0, 1 }, { 61, 46, 0 } } },
	{ { { 56, 0, 0 }, { 53, 62, 0 } } },
	{ { { 56, 0, 1 }, { 53, 63, 0 } } },
	{ { { 56, 0, 2 }, { 54, 62, 0 } } },
	{ { { 57, 0, 1 }, { 62, 47, 0 } } },
	{ { { 57, 0, 0 }, { 54, 63, 0 } } },
	{ { { 57, 0, 1 }, { 55, 62, 0 } } },
	{ { { 57, 0, 2 }, { 55, 63, 0 } } },
	{ { { 58, 0, 1 }, { 56, 62, 1 } } },
	{ { { 58, 0, 0 }, { 56, 62, 0 } } },
	{ { { 58, 0, 1 }, { 56, 63, 0 } } },
	{ { { 58, 0, 2 }, { 57, 62, 0 } } },
	{ { { 59, 0, 1 }, { 57, 63, 1 } } },
	{ { { 59, 0, 0 }, { 57, 63, 0 } } },
	{ { { 59, 0, 1 }, { 58, 62, 0 } } },
	{ { { 59, 0, 2 }, { 58, 63, 0 } } },
	{ { { 60, 0, 1 }, { 59, 62, 1 } } },
	{ { { 60, 0, 0 }, { 59, 62, 0 } } },
	{ { { 60, 0, 1 }, { 59, 63, 0 } } },
	{ { { 60, 0, 2 }, { 60, 62, 0 } } },
	{ { { 61, 0, 1 }, { 60, 63, 1 } } },
	{ { { 61, 0, 0 }, { 60, 63, 0 } } },
	{ { { 61, 0, 1 }, { 61, 62, 0 } } },
	{ { { 61, 0, 2 }, { 61, 63, 0 } } },
	{ { { 62, 0, 1 }, { 62, 62, 1 } } },
	{ { { 62, 0, 0 }, { 62, 62, 0 } } },
	{ { { 62, 0, 1 }, { 62, 63, 0 } } },
	{ { { 62, 0, 2 }, { 63, 62, 0 } } },
	{ { { 63, 0, 1 }, { 63, 63, 1 } } },
	{ { { 63, 0, 0 }, { 63, 63, 0 } } }
};

```

`ThirdParty/Squish/squish.cpp`:

```cpp
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#include <squish.h>
#include "colourset.h"
#include "maths.h"
#include "rangefit.h"
#include "clusterfit.h"
#include "colourblock.h"
#include "alpha.h"
#include "singlecolourfit.h"

namespace squish {

static int FixFlags( int flags )
{
	// grab the flag bits
	int method = flags & ( kDxt1 | kDxt3 | kDxt5 );
	int fit = flags & ( kColourIterativeClusterFit | kColourClusterFit | kColourRangeFit );
	int metric = flags & ( kColourMetricPerceptual | kColourMetricUniform );
	int extra = flags & kWeightColourByAlpha;
	
	// set defaults
	if( method != kDxt3 && method != kDxt5 )
		method = kDxt1;
	if( fit != kColourRangeFit )
		fit = kColourClusterFit;
	if( metric != kColourMetricUniform )
		metric = kColourMetricPerceptual;
		
	// done
	return method | fit | metric | extra;
}

void Compress( u8 const* rgba, void* block, int flags )
{
	// compress with full mask
	CompressMasked( rgba, 0xffff, block, flags );
}

void CompressMasked( u8 const* rgba, int mask, void* block, int flags )
{
	// fix any bad flags
	flags = FixFlags( flags );

	// get the block locations
	void* colourBlock = block;
	void* alphaBock = block;
	if( ( flags & ( kDxt3 | kDxt5 ) ) != 0 )
		colourBlock = reinterpret_cast< u8* >( block ) + 8;

	// create the minimal point set
	ColourSet colours( rgba, mask, flags );
	
	// check the compression type and compress colour
	if( colours.GetCount() == 1 )
	{
		// always do a single colour fit
		SingleColourFit fit( &colours, flags );
		fit.Compress( colourBlock );
	}
	else if( ( flags & kColourRangeFit ) != 0 || colours.GetCount() == 0 )
	{
		// do a range fit
		RangeFit fit( &colours, flags );
		fit.Compress( colourBlock );
	}
	else
	{
		// default to a cluster fit (could be iterative or not)
		ClusterFit fit( &colours, flags );
		fit.Compress( colourBlock );
	}
	
	// compress alpha separately if necessary
	if( ( flags & kDxt3 ) != 0 )
		CompressAlphaDxt3( rgba, mask, alphaBock );
	else if( ( flags & kDxt5 ) != 0 )
		CompressAlphaDxt5( rgba, mask, alphaBock );
}

void Decompress( u8* rgba, void const* block, int flags )
{
	// fix any bad flags
	flags = FixFlags( flags );

	// get the block locations
	void const* colourBlock = block;
	void const* alphaBock = block;
	if( ( flags & ( kDxt3 | kDxt5 ) ) != 0 )
		colourBlock = reinterpret_cast< u8 const* >( block ) + 8;

	// decompress colour
	DecompressColour( rgba, colourBlock, ( flags & kDxt1 ) != 0 );

	// decompress alpha separately if necessary
	if( ( flags & kDxt3 ) != 0 )
		DecompressAlphaDxt3( rgba, alphaBock );
	else if( ( flags & kDxt5 ) != 0 )
		DecompressAlphaDxt5( rgba, alphaBock );
}

int GetStorageRequirements( int width, int height, int flags )
{
	// fix any bad flags
	flags = FixFlags( flags );
	
	// compute the storage requirements
	int blockcount = ( ( width + 3 )/4 ) * ( ( height + 3 )/4 );
	int blocksize = ( ( flags & kDxt1 ) != 0 ) ? 8 : 16;
	return blockcount*blocksize;	
}

void CompressImage( u8 const* rgba, int width, int height, void* blocks, int flags )
{
	// fix any bad flags
	flags = FixFlags( flags );

	// initialise the block output
	u8* targetBlock = reinterpret_cast< u8* >( blocks );
	int bytesPerBlock = ( ( flags & kDxt1 ) != 0 ) ? 8 : 16;

	// loop over blocks
	for( int y = 0; y < height; y += 4 )
	{
		for( int x = 0; x < width; x += 4 )
		{
			// build the 4x4 block of pixels
			u8 sourceRgba[16*4];
			u8* targetPixel = sourceRgba;
			int mask = 0;
			for( int py = 0; py < 4; ++py )
			{
				for( int px = 0; px < 4; ++px )
				{
					// get the source pixel in the image
					int sx = x + px;
					int sy = y + py;
					
					// enable if we're in the image
					if( sx < width && sy < height )
					{
						// copy the rgba value
						u8 const* sourcePixel = rgba + 4*( width*sy + sx );
						for( int i = 0; i < 4; ++i )
							*targetPixel++ = *sourcePixel++;
							
						// enable this pixel
						mask |= ( 1 << ( 4*py + px ) );
					}
					else
					{
						// skip this pixel as its outside the image
						targetPixel += 4;
					}
				}
			}
			
			// compress it into the output
			CompressMasked( sourceRgba, mask, targetBlock, flags );
			
			// advance
			targetBlock += bytesPerBlock;
		}
	}
}

void DecompressImage( u8* rgba, int width, int height, void const* blocks, int flags )
{
	// fix any bad flags
	flags = FixFlags( flags );

	// initialise the block input
	u8 const* sourceBlock = reinterpret_cast< u8 const* >( blocks );
	int bytesPerBlock = ( ( flags & kDxt1 ) != 0 ) ? 8 : 16;

	// loop over blocks
	for( int y = 0; y < height; y += 4 )
	{
		for( int x = 0; x < width; x += 4 )
		{
			// decompress the block
			u8 targetRgba[4*16];
			Decompress( targetRgba, sourceBlock, flags );
			
			// write the decompressed pixels to the correct image locations
			u8 const* sourcePixel = targetRgba;
			for( int py = 0; py < 4; ++py )
			{
				for( int px = 0; px < 4; ++px )
				{
					// get the target location
					int sx = x + px;
					int sy = y + py;
					if( sx < width && sy < height )
					{
						u8* targetPixel = rgba + 4*( width*sy + sx );
						
						// copy the rgba value
						for( int i = 0; i < 4; ++i )
							*targetPixel++ = *sourcePixel++;
					}
					else
					{
						// skip this pixel as its outside the image
						sourcePixel += 4;
					}
				}
			}
			
			// advance
			sourceBlock += bytesPerBlock;
		}
	}
}

} // namespace squish

```

`ThirdParty/Squish/squish.h`:

```h
/* -----------------------------------------------------------------------------

	Copyright (c) 2006 Simon Brown                          si@sjbrown.co.uk

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the 
	"Software"), to	deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to 
	permit persons to whom the Software is furnished to do so, subject to 
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
   -------------------------------------------------------------------------- */
   
#ifndef SQUISH_H
#define SQUISH_H

//! All squish API functions live in this namespace.
namespace squish {

// -----------------------------------------------------------------------------

//! Typedef a quantity that is a single unsigned byte.
typedef unsigned char u8;

// -----------------------------------------------------------------------------

enum
{
	//! Use DXT1 compression.
	kDxt1 = ( 1 << 0 ), 
	
	//! Use DXT3 compression.
	kDxt3 = ( 1 << 1 ), 
	
	//! Use DXT5 compression.
	kDxt5 = ( 1 << 2 ), 
	
	//! Use a very slow but very high quality colour compressor.
	kColourIterativeClusterFit = ( 1 << 8 ),	
	
	//! Use a slow but high quality colour compressor (the default).
	kColourClusterFit = ( 1 << 3 ),	
	
	//! Use a fast but low quality colour compressor.
	kColourRangeFit	= ( 1 << 4 ),
	
	//! Use a perceptual metric for colour error (the default).
	kColourMetricPerceptual = ( 1 << 5 ),

	//! Use a uniform metric for colour error.
	kColourMetricUniform = ( 1 << 6 ),
	
	//! Weight the colour by alpha during cluster fit (disabled by default).
	kWeightColourByAlpha = ( 1 << 7 )
};

// -----------------------------------------------------------------------------

/*! @brief Compresses a 4x4 block of pixels.

	@param rgba		The rgba values of the 16 source pixels.
	@param block	Storage for the compressed DXT block.
	@param flags	Compression flags.
	
	The source pixels should be presented as a contiguous array of 16 rgba
	values, with each component as 1 byte each. In memory this should be:
	
		{ r1, g1, b1, a1, .... , r16, g16, b16, a16 }
	
	The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, 
	however, DXT1 will be used by default if none is specified. When using DXT1 
	compression, 8 bytes of storage are required for the compressed DXT block. 
	DXT3 and DXT5 compression require 16 bytes of storage per block.
	
	The flags parameter can also specify a preferred colour compressor and 
	colour error metric to use when fitting the RGB components of the data. 
	Possible colour compressors are: kColourClusterFit (the default), 
	kColourRangeFit or kColourIterativeClusterFit. Possible colour error metrics 
	are: kColourMetricPerceptual (the default) or kColourMetricUniform. If no 
	flags are specified in any particular category then the default will be 
	used. Unknown flags are ignored.
	
	When using kColourClusterFit, an additional flag can be specified to
	weight the colour of each pixel by its alpha value. For images that are
	rendered using alpha blending, this can significantly increase the 
	perceived quality.
*/
void Compress( u8 const* rgba, void* block, int flags );

// -----------------------------------------------------------------------------

/*! @brief Compresses a 4x4 block of pixels.

	@param rgba		The rgba values of the 16 source pixels.
	@param mask		The valid pixel mask.
	@param block	Storage for the compressed DXT block.
	@param flags	Compression flags.
	
	The source pixels should be presented as a contiguous array of 16 rgba
	values, with each component as 1 byte each. In memory this should be:
	
		{ r1, g1, b1, a1, .... , r16, g16, b16, a16 }
		
	The mask parameter enables only certain pixels within the block. The lowest
	bit enables the first pixel and so on up to the 16th bit. Bits beyond the
	16th bit are ignored. Pixels that are not enabled are allowed to take
	arbitrary colours in the output block. An example of how this can be used
	is in the CompressImage function to disable pixels outside the bounds of
	the image when the width or height is not divisible by 4.
	
	The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, 
	however, DXT1 will be used by default if none is specified. When using DXT1 
	compression, 8 bytes of storage are required for the compressed DXT block. 
	DXT3 and DXT5 compression require 16 bytes of storage per block.
	
	The flags parameter can also specify a preferred colour compressor and 
	colour error metric to use when fitting the RGB components of the data. 
	Possible colour compressors are: kColourClusterFit (the default), 
	kColourRangeFit or kColourIterativeClusterFit. Possible colour error metrics 
	are: kColourMetricPerceptual (the default) or kColourMetricUniform. If no 
	flags are specified in any particular category then the default will be 
	used. Unknown flags are ignored.
	
	When using kColourClusterFit, an additional flag can be specified to
	weight the colour of each pixel by its alpha value. For images that are
	rendered using alpha blending, this can significantly increase the 
	perceived quality.
*/
void CompressMasked( u8 const* rgba, int mask, void* block, int flags );

// -----------------------------------------------------------------------------

/*! @brief Decompresses a 4x4 block of pixels.

	@param rgba		Storage for the 16 decompressed pixels.
	@param block	The compressed DXT block.
	@param flags	Compression flags.

	The decompressed pixels will be written as a contiguous array of 16 rgba
	values, with each component as 1 byte each. In memory this is:
	
		{ r1, g1, b1, a1, .... , r16, g16, b16, a16 }
	
	The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, 
	however, DXT1 will be used by default if none is specified. All other flags 
	are ignored.
*/
void Decompress( u8* rgba, void const* block, int flags );

// -----------------------------------------------------------------------------

/*! @brief Computes the amount of compressed storage required.

	@param width	The width of the image.
	@param height	The height of the image.
	@param flags	Compression flags.
	
	The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, 
	however, DXT1 will be used by default if none is specified. All other flags 
	are ignored.
	
	Most DXT images will be a multiple of 4 in each dimension, but this 
	function supports arbitrary size images by allowing the outer blocks to
	be only partially used.
*/
int GetStorageRequirements( int width, int height, int flags );

// -----------------------------------------------------------------------------

/*! @brief Compresses an image in memory.

	@param rgba		The pixels of the source.
	@param width	The width of the source image.
	@param height	The height of the source image.
	@param blocks	Storage for the compressed output.
	@param flags	Compression flags.
	
	The source pixels should be presented as a contiguous array of width*height
	rgba values, with each component as 1 byte each. In memory this should be:
	
		{ r1, g1, b1, a1, .... , rn, gn, bn, an } for n = width*height
		
	The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, 
	however, DXT1 will be used by default if none is specified. When using DXT1 
	compression, 8 bytes of storage are required for each compressed DXT block. 
	DXT3 and DXT5 compression require 16 bytes of storage per block.
	
	The flags parameter can also specify a preferred colour compressor and 
	colour error metric to use when fitting the RGB components of the data. 
	Possible colour compressors are: kColourClusterFit (the default), 
	kColourRangeFit or kColourIterativeClusterFit. Possible colour error metrics 
	are: kColourMetricPerceptual (the default) or kColourMetricUniform. If no 
	flags are specified in any particular category then the default will be 
	used. Unknown flags are ignored.
	
	When using kColourClusterFit, an additional flag can be specified to
	weight the colour of each pixel by its alpha value. For images that are
	rendered using alpha blending, this can significantly increase the 
	perceived quality.
	
	Internally this function calls squish::Compress for each block. To see how
	much memory is required in the compressed image, use
	squish::GetStorageRequirements.
*/
void CompressImage( u8 const* rgba, int width, int height, void* blocks, int flags );

// -----------------------------------------------------------------------------

/*! @brief Decompresses an image in memory.

	@param rgba		Storage for the decompressed pixels.
	@param width	The width of the source image.
	@param height	The height of the source image.
	@param blocks	The compressed DXT blocks.
	@param flags	Compression flags.
	
	The decompressed pixels will be written as a contiguous array of width*height
	16 rgba values, with each component as 1 byte each. In memory this is:
	
		{ r1, g1, b1, a1, .... , rn, gn, bn, an } for n = width*height
		
	The flags parameter should specify either kDxt1, kDxt3 or kDxt5 compression, 
	however, DXT1 will be used by default if none is specified. All other flags 
	are ignored.

	Internally this function calls squish::Decompress for each block.
*/
void DecompressImage( u8* rgba, int width, int height, void const* blocks, int flags );

// -----------------------------------------------------------------------------

} // namespace squish

#endif // ndef SQUISH_H


```

`ThirdParty/Squish/texture_compression_s3tc.txt`:

```txt
Name

    EXT_texture_compression_s3tc

Name Strings

    GL_EXT_texture_compression_s3tc

Contact

    Pat Brown, NVIDIA Corporation (pbrown 'at' nvidia.com)

Status

    FINAL

Version

    1.1, 16 November 2001 (containing only clarifications relative to
                           version 1.0, dated 7 July 2000)

Number

    198

Dependencies

    OpenGL 1.1 is required.

    GL_ARB_texture_compression is required.

    This extension is written against the OpenGL 1.2.1 Specification.

Overview

    This extension provides additional texture compression functionality
    specific to S3's S3TC format (called DXTC in Microsoft's DirectX API),
    subject to all the requirements and limitations described by the extension
    GL_ARB_texture_compression.

    This extension supports DXT1, DXT3, and DXT5 texture compression formats.
    For the DXT1 image format, this specification supports an RGB-only mode
    and a special RGBA mode with single-bit "transparent" alpha.

IP Status

    Contact S3 Incorporated (http://www.s3.com) regarding any intellectual
    property issues associated with implementing this extension.

    WARNING:  Vendors able to support S3TC texture compression in Direct3D
    drivers do not necessarily have the right to use the same functionality in
    OpenGL.

Issues

    (1) Should DXT2 and DXT4 (premultiplied alpha) formats be supported?

        RESOLVED:  No -- insufficient interest.  Supporting DXT2 and DXT4
        would require some rework to the TexEnv definition (maybe add a new
        base internal format RGBA_PREMULTIPLIED_ALPHA) for these formats.
        Note that the EXT_texture_env_combine extension (which extends normal
        TexEnv modes) can be used to support textures with premultipled alpha.

    (2) Should generic "RGB_S3TC_EXT" and "RGBA_S3TC_EXT" enums be supported
        or should we use only the DXT<n> enums?  

        RESOLVED:  No.  A generic RGBA_S3TC_EXT is problematic because DXT3
        and DXT5 are both nominally RGBA (and DXT1 with the 1-bit alpha is
        also) yet one format must be chosen up front.

    (3) Should TexSubImage support all block-aligned edits or just the minimal
        functionality required by the ARB_texture_compression extension?

        RESOLVED:  Allow all valid block-aligned edits.

    (4) A pre-compressed image with a DXT1 format can be used as either an
        RGB_S3TC_DXT1 or an RGBA_S3TC_DXT1 image.  If the image has
        transparent texels, how are they treated in each format?

        RESOLVED:  The renderer has to make sure that an RGB_S3TC_DXT1 format
        is decoded as RGB (where alpha is effectively one for all texels),
        while RGBA_S3TC_DXT1 is decoded as RGBA (where alpha is zero for all
        texels with "transparent" encodings).  Otherwise, the formats are
        identical.

    (5) Is the encoding of the RGB components for DXT1 formats correct in this
        spec?  MSDN documentation does not specify an RGB color for the
        "transparent" encoding.  Is it really black?

        RESOLVED:  Yes.  The specification for the DXT1 format initially
        required black, but later changed that requirement to a
        recommendation.  All vendors involved in the definition of this
        specification support black.  In addition, specifying black has a
        useful behavior.

        When blending multiple texels (GL_LINEAR filtering), mixing opaque and
        transparent samples is problematic.  Defining a black color on
        transparent texels achieves a sensible result that works like a
        texture with premultiplied alpha.  For example, if three opaque white
        and one transparent sample is being averaged, the result would be a
        75% intensity gray (with an alpha of 75%).  This is the same result on
        the color channels as would be obtained using a white color, 75%
        alpha, and a SRC_ALPHA blend factor.

    (6) Is the encoding of the RGB components for DXT3 and DXT5 formats
        correct in this spec?  MSDN documentation suggests that the RGB blocks
        for DXT3 and DXT5 are decoded as described by the DXT1 format.

        RESOLVED:  Yes -- this appears to be a bug in the MSDN documentation.
        The specification for the DXT2-DXT5 formats require decoding using the
        opaque block encoding, regardless of the relative values of "color0"
        and "color1".

New Procedures and Functions

    None.

New Tokens

    Accepted by the <internalformat> parameter of TexImage2D, CopyTexImage2D,
    and CompressedTexImage2DARB and the <format> parameter of
    CompressedTexSubImage2DARB:

        COMPRESSED_RGB_S3TC_DXT1_EXT                   0x83F0
        COMPRESSED_RGBA_S3TC_DXT1_EXT                  0x83F1
        COMPRESSED_RGBA_S3TC_DXT3_EXT                  0x83F2
        COMPRESSED_RGBA_S3TC_DXT5_EXT                  0x83F3

Additions to Chapter 2 of the OpenGL 1.2.1 Specification (OpenGL Operation)

    None.

Additions to Chapter 3 of the OpenGL 1.2.1 Specification (Rasterization)

    Add to Table 3.16.1:  Specific Compressed Internal Formats

        Compressed Internal Format         Base Internal Format
        ==========================         ====================
        COMPRESSED_RGB_S3TC_DXT1_EXT       RGB
        COMPRESSED_RGBA_S3TC_DXT1_EXT      RGBA
        COMPRESSED_RGBA_S3TC_DXT3_EXT      RGBA
        COMPRESSED_RGBA_S3TC_DXT5_EXT      RGBA

    
    Modify Section 3.8.2, Alternate Image Specification

    (add to end of TexSubImage discussion, p.123 -- after edit from the
    ARB_texture_compression spec)

    If the internal format of the texture image being modified is
    COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1_EXT,
    COMPRESSED_RGBA_S3TC_DXT3_EXT, or COMPRESSED_RGBA_S3TC_DXT5_EXT, the
    texture is stored using one of the several S3TC compressed texture image
    formats.  Such images are easily edited along 4x4 texel boundaries, so the
    limitations on TexSubImage2D or CopyTexSubImage2D parameters are relaxed.
    TexSubImage2D and CopyTexSubImage2D will result in an INVALID_OPERATION
    error only if one of the following conditions occurs:

        * <width> is not a multiple of four or equal to TEXTURE_WIDTH, 
          unless <xoffset> and <yoffset> are both zero.
        * <height> is not a multiple of four or equal to TEXTURE_HEIGHT,
          unless <xoffset> and <yoffset> are both zero.
        * <xoffset> or <yoffset> is not a multiple of four.

    The contents of any 4x4 block of texels of an S3TC compressed texture
    image that does not intersect the area being modified are preserved during
    valid TexSubImage2D and CopyTexSubImage2D calls.


    Add to Section 3.8.2, Alternate Image Specification (adding to the end of
    the CompressedTexImage section introduced by the ARB_texture_compression
    spec)

    If <internalformat> is COMPRESSED_RGB_S3TC_DXT1_EXT,
    COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3_EXT, or
    COMPRESSED_RGBA_S3TC_DXT5_EXT, the compressed texture is stored using one
    of several S3TC compressed texture image formats.  The S3TC texture
    compression algorithm supports only 2D images without borders.
    CompressedTexImage1DARB and CompressedTexImage3DARB produce an
    INVALID_ENUM error if <internalformat> is an S3TC format.
    CompressedTexImage2DARB will produce an INVALID_OPERATION error if
    <border> is non-zero.


    Add to Section 3.8.2, Alternate Image Specification (adding to the end of
    the CompressedTexSubImage section introduced by the
    ARB_texture_compression spec)

    If the internal format of the texture image being modified is
    COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1_EXT,
    COMPRESSED_RGBA_S3TC_DXT3_EXT, or COMPRESSED_RGBA_S3TC_DXT5_EXT, the
    texture is stored using one of the several S3TC compressed texture image
    formats.  Since the S3TC texture compression algorithm supports only 2D
    images, CompressedTexSubImage1DARB and CompressedTexSubImage3DARB produce
    an INVALID_ENUM error if <format> is an S3TC format.  Since S3TC images
    are easily edited along 4x4 texel boundaries, the limitations on
    CompressedTexSubImage2D are relaxed.  CompressedTexSubImage2D will result
    in an INVALID_OPERATION error only if one of the following conditions
    occurs:

        * <width> is not a multiple of four or equal to TEXTURE_WIDTH.
        * <height> is not a multiple of four or equal to TEXTURE_HEIGHT.
        * <xoffset> or <yoffset> is not a multiple of four.

    The contents of any 4x4 block of texels of an S3TC compressed texture
    image that does not intersect the area being modified are preserved during
    valid TexSubImage2D and CopyTexSubImage2D calls.

Additions to Chapter 4 of the OpenGL 1.2.1 Specification (Per-Fragment
Operations and the Frame Buffer)

    None.

Additions to Chapter 5 of the OpenGL 1.2.1 Specification (Special Functions)

    None.

Additions to Chapter 6 of the OpenGL 1.2.1 Specification (State and
State Requests)

    None.

Additions to Appendix A of the OpenGL 1.2.1 Specification (Invariance)

    None.

Additions to the AGL/GLX/WGL Specifications

    None.

GLX Protocol

    None.

Errors

    INVALID_ENUM is generated by CompressedTexImage1DARB or
    CompressedTexImage3DARB if <internalformat> is
    COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1_EXT,
    COMPRESSED_RGBA_S3TC_DXT3_EXT, or COMPRESSED_RGBA_S3TC_DXT5_EXT.

    INVALID_OPERATION is generated by CompressedTexImage2DARB if
    <internalformat> is COMPRESSED_RGB_S3TC_DXT1_EXT,
    COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3_EXT, or
    COMPRESSED_RGBA_S3TC_DXT5_EXT and <border> is not equal to zero.

    INVALID_ENUM is generated by CompressedTexSubImage1DARB or
    CompressedTexSubImage3DARB if <format> is COMPRESSED_RGB_S3TC_DXT1_EXT,
    COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3_EXT, or
    COMPRESSED_RGBA_S3TC_DXT5_EXT.

    INVALID_OPERATION is generated by TexSubImage2D CopyTexSubImage2D, or
    CompressedTexSubImage2D if TEXTURE_INTERNAL_FORMAT is
    COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1_EXT,
    COMPRESSED_RGBA_S3TC_DXT3_EXT, or COMPRESSED_RGBA_S3TC_DXT5_EXT and any of
    the following apply: <width> is not a multiple of four or equal to
    TEXTURE_WIDTH; <height> is not a multiple of four or equal to
    TEXTURE_HEIGHT; <xoffset> or <yoffset> is not a multiple of four.


    The following restrictions from the ARB_texture_compression specification
    do not apply to S3TC texture formats, since subimage modification is
    straightforward as long as the subimage is properly aligned.

    DELETE: INVALID_OPERATION is generated by TexSubImage1D, TexSubImage2D,
    DELETE: TexSubImage3D, CopyTexSubImage1D, CopyTexSubImage2D, or
    DELETE: CopyTexSubImage3D if the internal format of the texture image is
    DELETE: compressed and <xoffset>, <yoffset>, or <zoffset> does not equal
    DELETE: -b, where b is value of TEXTURE_BORDER.

    DELETE: INVALID_VALUE is generated by CompressedTexSubImage1DARB,
    DELETE: CompressedTexSubImage2DARB, or CompressedTexSubImage3DARB if the
    DELETE: entire texture image is not being edited:  if <xoffset>,
    DELETE: <yoffset>, or <zoffset> is greater than -b, <xoffset> + <width> is
    DELETE: less than w+b, <yoffset> + <height> is less than h+b, or <zoffset>
    DELETE: + <depth> is less than d+b, where b is the value of
    DELETE: TEXTURE_BORDER, w is the value of TEXTURE_WIDTH, h is the value of
    DELETE: TEXTURE_HEIGHT, and d is the value of TEXTURE_DEPTH.

    See also errors in the GL_ARB_texture_compression specification.

New State

    In the "Textures" state table, increment the TEXTURE_INTERNAL_FORMAT
    subscript for Z by 4 in the "Type" row.

New Implementation Dependent State

    None

Appendix

    S3TC Compressed Texture Image Formats

    Compressed texture images stored using the S3TC compressed image formats
    are represented as a collection of 4x4 texel blocks, where each block
    contains 64 or 128 bits of texel data.  The image is encoded as a normal
    2D raster image in which each 4x4 block is treated as a single pixel.  If
    an S3TC image has a width or height less than four, the data corresponding
    to texels outside the image are irrelevant and undefined.

    When an S3TC image with a width of <w>, height of <h>, and block size of
    <blocksize> (8 or 16 bytes) is decoded, the corresponding image size (in
    bytes) is:
    
        ceil(<w>/4) * ceil(<h>/4) * blocksize.

    When decoding an S3TC image, the block containing the texel at offset
    (<x>, <y>) begins at an offset (in bytes) relative to the base of the
    image of:

        blocksize * (ceil(<w>/4) * floor(<y>/4) + floor(<x>/4)).

    The data corresponding to a specific texel (<x>, <y>) are extracted from a
    4x4 texel block using a relative (x,y) value of
    
        (<x> modulo 4, <y> modulo 4).

    There are four distinct S3TC image formats:

    COMPRESSED_RGB_S3TC_DXT1_EXT:  Each 4x4 block of texels consists of 64
    bits of RGB image data.  

    Each RGB image data block is encoded as a sequence of 8 bytes, called (in
    order of increasing address):

            c0_lo, c0_hi, c1_lo, c1_hi, bits_0, bits_1, bits_2, bits_3

        The 8 bytes of the block are decoded into three quantities:

            color0 = c0_lo + c0_hi * 256
            color1 = c1_lo + c1_hi * 256
            bits   = bits_0 + 256 * (bits_1 + 256 * (bits_2 + 256 * bits_3))
        
        color0 and color1 are 16-bit unsigned integers that are unpacked to
        RGB colors RGB0 and RGB1 as though they were 16-bit packed pixels with
        a <format> of RGB and a type of UNSIGNED_SHORT_5_6_5.

        bits is a 32-bit unsigned integer, from which a two-bit control code
        is extracted for a texel at location (x,y) in the block using:

            code(x,y) = bits[2*(4*y+x)+1..2*(4*y+x)+0]
        
        where bit 31 is the most significant and bit 0 is the least
        significant bit.

        The RGB color for a texel at location (x,y) in the block is given by:

            RGB0,              if color0 > color1 and code(x,y) == 0
            RGB1,              if color0 > color1 and code(x,y) == 1
            (2*RGB0+RGB1)/3,   if color0 > color1 and code(x,y) == 2
            (RGB0+2*RGB1)/3,   if color0 > color1 and code(x,y) == 3

            RGB0,              if color0 <= color1 and code(x,y) == 0
            RGB1,              if color0 <= color1 and code(x,y) == 1
            (RGB0+RGB1)/2,     if color0 <= color1 and code(x,y) == 2
            BLACK,             if color0 <= color1 and code(x,y) == 3

        Arithmetic operations are done per component, and BLACK refers to an
        RGB color where red, green, and blue are all zero.

    Since this image has an RGB format, there is no alpha component and the
    image is considered fully opaque.


    COMPRESSED_RGBA_S3TC_DXT1_EXT:  Each 4x4 block of texels consists of 64
    bits of RGB image data and minimal alpha information.  The RGB components
    of a texel are extracted in the same way as COMPRESSED_RGB_S3TC_DXT1_EXT.
 
        The alpha component for a texel at location (x,y) in the block is
        given by:

            0.0,               if color0 <= color1 and code(x,y) == 3
            1.0,               otherwise

        IMPORTANT:  When encoding an RGBA image into a format using 1-bit
        alpha, any texels with an alpha component less than 0.5 end up with an
        alpha of 0.0 and any texels with an alpha component greater than or
        equal to 0.5 end up with an alpha of 1.0.  When encoding an RGBA image
        into the COMPRESSED_RGBA_S3TC_DXT1_EXT format, the resulting red,
        green, and blue components of any texels with a final alpha of 0.0
        will automatically be zero (black).  If this behavior is not desired
        by an application, it should not use COMPRESSED_RGBA_S3TC_DXT1_EXT.
        This format will never be used when a generic compressed internal
        format (Table 3.16.2) is specified, although the nearly identical
        format COMPRESSED_RGB_S3TC_DXT1_EXT (above) may be.


    COMPRESSED_RGBA_S3TC_DXT3_EXT:  Each 4x4 block of texels consists of 64
    bits of uncompressed alpha image data followed by 64 bits of RGB image
    data.  

    Each RGB image data block is encoded according to the
    COMPRESSED_RGB_S3TC_DXT1_EXT format, with the exception that the two code
    bits always use the non-transparent encodings.  In other words, they are
    treated as though color0 > color1, regardless of the actual values of
    color0 and color1.

    Each alpha image data block is encoded as a sequence of 8 bytes, called
    (in order of increasing address):

            a0, a1, a2, a3, a4, a5, a6, a7

        The 8 bytes of the block are decoded into one 64-bit integer:

            alpha = a0 + 256 * (a1 + 256 * (a2 + 256 * (a3 + 256 * (a4 +
                         256 * (a5 + 256 * (a6 + 256 * a7))))))

        alpha is a 64-bit unsigned integer, from which a four-bit alpha value
        is extracted for a texel at location (x,y) in the block using:

            alpha(x,y) = bits[4*(4*y+x)+3..4*(4*y+x)+0]

        where bit 63 is the most significant and bit 0 is the least
        significant bit.

        The alpha component for a texel at location (x,y) in the block is
        given by alpha(x,y) / 15.

 
    COMPRESSED_RGBA_S3TC_DXT5_EXT:  Each 4x4 block of texels consists of 64
    bits of compressed alpha image data followed by 64 bits of RGB image data.

    Each RGB image data block is encoded according to the
    COMPRESSED_RGB_S3TC_DXT1_EXT format, with the exception that the two code
    bits always use the non-transparent encodings.  In other words, they are
    treated as though color0 > color1, regardless of the actual values of
    color0 and color1.

    Each alpha image data block is encoded as a sequence of 8 bytes, called
    (in order of increasing address):

        alpha0, alpha1, bits_0, bits_1, bits_2, bits_3, bits_4, bits_5

        The alpha0 and alpha1 are 8-bit unsigned bytes converted to alpha
        components by multiplying by 1/255.

        The 6 "bits" bytes of the block are decoded into one 48-bit integer:

          bits = bits_0 + 256 * (bits_1 + 256 * (bits_2 + 256 * (bits_3 + 
                          256 * (bits_4 + 256 * bits_5))))

        bits is a 48-bit unsigned integer, from which a three-bit control code
        is extracted for a texel at location (x,y) in the block using:

            code(x,y) = bits[3*(4*y+x)+1..3*(4*y+x)+0]

        where bit 47 is the most significant and bit 0 is the least
        significant bit.

        The alpha component for a texel at location (x,y) in the block is
        given by:

              alpha0,                   code(x,y) == 0
              alpha1,                   code(x,y) == 1

              (6*alpha0 + 1*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 2
              (5*alpha0 + 2*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 3
              (4*alpha0 + 3*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 4
              (3*alpha0 + 4*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 5
              (2*alpha0 + 5*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 6
              (1*alpha0 + 6*alpha1)/7,  alpha0 > alpha1 and code(x,y) == 7

              (4*alpha0 + 1*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 2
              (3*alpha0 + 2*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 3
              (2*alpha0 + 3*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 4
              (1*alpha0 + 4*alpha1)/5,  alpha0 <= alpha1 and code(x,y) == 5
              0.0,                      alpha0 <= alpha1 and code(x,y) == 6
              1.0,                      alpha0 <= alpha1 and code(x,y) == 7


Revision History

    1.1,  11/16/01 pbrown:    Updated contact info, clarified where texels
                              fall within a single block.

    1.0,  07/07/00 prbrown1:  Published final version agreed to by working
                              group members.

    0.9,  06/24/00 prbrown1:  Documented that block-aligned TexSubImage calls
                              do not modify existing texels outside the
                              modified blocks.  Added caveat to allow for a
                              (0,0)-anchored TexSubImage operation of
                              arbitrary size.

    0.7,  04/11/00 prbrown1:  Added issues on DXT1, DXT3, and DXT5 encodings
                              where the MSDN documentation doesn't match what
                              is really done.  Added enum values from the
                              extension registry.

    0.4,  03/28/00 prbrown1:  Updated to reflect final version of the
                              ARB_texture_compression extension.  Allowed
                              block-aligned TexSubImage calls.

    0.3,  03/07/00 prbrown1:  Resolved issues pertaining to the format of RGB
                              blocks in the DXT3 and DXT5 formats (they don't
                              ever use the "transparent" encoding).  Fixed
                              decoding of DXT1 blocks.  Pointed out issue of
                              "transparent" texels in DXT1 encodings having
                              different behaviors for RGB and RGBA internal
                              formats.

    0.2,  02/23/00 prbrown1:  Minor revisions; added several issues.

    0.11, 02/17/00 prbrown1:  Slight modification to error semantics
                              (INVALID_ENUM instead of INVALID_OPERATION).

    0.1,  02/15/00 prbrown1:  Initial revision.

```

`ThirdParty/UnitTest++/AUTHORS`:

```
See README.md for the historic contributor list.

The maintainer of UnitTest++ is Patrick Johnmeyer (pjohnmeyer@gmail.com).

```

`ThirdParty/UnitTest++/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.8.1)
project(UnitTest++)

option(UTPP_USE_PLUS_SIGN "Set this to OFF is you with to use '-cpp' instead of '++' in lib/include paths" ON)

# get the main sources
file(GLOB headers_ RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} UnitTest++/*.h)
file(GLOB sources_ RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} UnitTest++/*.cpp)
source_group("" FILES ${headers_} ${sources_})

# get platform specific sources
if (WIN32)
    add_definitions(-D_CRT_SECURE_NO_DEPRECATE)
    set(platformDir_ Win32)
else()
    set(platformDir_ Posix)
endif(WIN32)

file(GLOB platformHeaders_ RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} UnitTest++/${platformDir_}/*.h)
file(GLOB platformSources_ RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} UnitTest++/${platformDir_}/*.cpp)
source_group(${platformDir_} FILES ${platformHeaders_} ${platformSources_})

# create the lib
add_library(UnitTest++ STATIC ${headers_} ${sources_} ${platformHeaders_} ${platformSources_})

if(${UTPP_USE_PLUS_SIGN})
	set_target_properties(UnitTest++ PROPERTIES OUTPUT_NAME UnitTest++)
endif()


# build the test runner
file(GLOB TEST_SRCS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} tests/*.cpp tests/*.h)
source_group( "" FILES ${TEST_SRCS})
add_executable(TestUnitTest++ ${TEST_SRCS})
include_directories(.)

if(${UTPP_USE_PLUS_SIGN})
	set_target_properties(TestUnitTest++ PROPERTIES OUTPUT_NAME TestUnitTest++)
endif()

target_link_libraries(TestUnitTest++ UnitTest++)

# turn on testing
enable_testing()
add_custom_target(check COMMAND ${CMAKE_CTEST_COMMAND} -V)

# add the test runner as a test
add_test(NAME TestUnitTest++ COMMAND TestUnitTest++ ${CONFIG_PATH} ${CONFIG_TASKS_PATH} ${SOUND_LOG_PATH})
add_dependencies(check TestUnitTest++)


# add install targets
# need a custom install path?
# define CMAKE_INSTALL_PREFIX to change root folder
if(${UTPP_USE_PLUS_SIGN})
	set (UTPP_INSTALL_DESTINATION "include/UnitTest++")
else()
	set (UTPP_INSTALL_DESTINATION "include/UnitTestPP")
endif()

install(TARGETS UnitTest++ DESTINATION lib)
install(FILES ${headers_} DESTINATION ${UTPP_INSTALL_DESTINATION})
install(FILES ${platformHeaders_} DESTINATION ${UTPP_INSTALL_DESTINATION}/${platformDir_})
```

`ThirdParty/UnitTest++/INSTALL`:

```
Installation Instructions
*************************

Copyright (C) 1994-1996, 1999-2002, 2004-2012 Free Software Foundation,
Inc.

   Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.  This file is offered as-is,
without warranty of any kind.

Basic Installation
==================

   Briefly, the shell commands `./configure; make; make install' should
configure, build, and install this package.  The following
more-detailed instructions are generic; see the `README' file for
instructions specific to this package.  Some packages provide this
`INSTALL' file but do not implement all of the features documented
below.  The lack of an optional feature in a given package is not
necessarily a bug.  More recommendations for GNU packages can be found
in *note Makefile Conventions: (standards)Makefile Conventions.

   The `configure' shell script attempts to guess correct values for
various system-dependent variables used during compilation.  It uses
those values to create a `Makefile' in each directory of the package.
It may also create one or more `.h' files containing system-dependent
definitions.  Finally, it creates a shell script `config.status' that
you can run in the future to recreate the current configuration, and a
file `config.log' containing compiler output (useful mainly for
debugging `configure').

   It can also use an optional file (typically called `config.cache'
and enabled with `--cache-file=config.cache' or simply `-C') that saves
the results of its tests to speed up reconfiguring.  Caching is
disabled by default to prevent problems with accidental use of stale
cache files.

   If you need to do unusual things to compile the package, please try
to figure out how `configure' could check whether to do them, and mail
diffs or instructions to the address given in the `README' so they can
be considered for the next release.  If you are using the cache, and at
some point `config.cache' contains results you don't want to keep, you
may remove or edit it.

   The file `configure.ac' (or `configure.in') is used to create
`configure' by a program called `autoconf'.  You need `configure.ac' if
you want to change it or regenerate `configure' using a newer version
of `autoconf'.

   The simplest way to compile this package is:

  1. `cd' to the directory containing the package's source code and type
     `./configure' to configure the package for your system.

     Running `configure' might take a while.  While running, it prints
     some messages telling which features it is checking for.

  2. Type `make' to compile the package.

  3. Optionally, type `make check' to run any self-tests that come with
     the package, generally using the just-built uninstalled binaries.

  4. Type `make install' to install the programs and any data files and
     documentation.  When installing into a prefix owned by root, it is
     recommended that the package be configured and built as a regular
     user, and only the `make install' phase executed with root
     privileges.

  5. Optionally, type `make installcheck' to repeat any self-tests, but
     this time using the binaries in their final installed location.
     This target does not install anything.  Running this target as a
     regular user, particularly if the prior `make install' required
     root privileges, verifies that the installation completed
     correctly.

  6. You can remove the program binaries and object files from the
     source code directory by typing `make clean'.  To also remove the
     files that `configure' created (so you can compile the package for
     a different kind of computer), type `make distclean'.  There is
     also a `make maintainer-clean' target, but that is intended mainly
     for the package's developers.  If you use it, you may have to get
     all sorts of other programs in order to regenerate files that came
     with the distribution.

  7. Often, you can also type `make uninstall' to remove the installed
     files again.  In practice, not all packages have tested that
     uninstallation works correctly, even though it is required by the
     GNU Coding Standards.

  8. Some packages, particularly those that use Automake, provide `make
     distcheck', which can by used by developers to test that all other
     targets like `make install' and `make uninstall' work correctly.
     This target is generally not run by end users.

Compilers and Options
=====================

   Some systems require unusual options for compilation or linking that
the `configure' script does not know about.  Run `./configure --help'
for details on some of the pertinent environment variables.

   You can give `configure' initial values for configuration parameters
by setting variables in the command line or in the environment.  Here
is an example:

     ./configure CC=c99 CFLAGS=-g LIBS=-lposix

   *Note Defining Variables::, for more details.

Compiling For Multiple Architectures
====================================

   You can compile the package for more than one kind of computer at the
same time, by placing the object files for each architecture in their
own directory.  To do this, you can use GNU `make'.  `cd' to the
directory where you want the object files and executables to go and run
the `configure' script.  `configure' automatically checks for the
source code in the directory that `configure' is in and in `..'.  This
is known as a "VPATH" build.

   With a non-GNU `make', it is safer to compile the package for one
architecture at a time in the source code directory.  After you have
installed the package for one architecture, use `make distclean' before
reconfiguring for another architecture.

   On MacOS X 10.5 and later systems, you can create libraries and
executables that work on multiple system types--known as "fat" or
"universal" binaries--by specifying multiple `-arch' options to the
compiler but only a single `-arch' option to the preprocessor.  Like
this:

     ./configure CC="gcc -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
                 CXX="g++ -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
                 CPP="gcc -E" CXXCPP="g++ -E"

   This is not guaranteed to produce working output in all cases, you
may have to build one architecture at a time and combine the results
using the `lipo' tool if you have problems.

Installation Names
==================

   By default, `make install' installs the package's commands under
`/usr/local/bin', include files under `/usr/local/include', etc.  You
can specify an installation prefix other than `/usr/local' by giving
`configure' the option `--prefix=PREFIX', where PREFIX must be an
absolute file name.

   You can specify separate installation prefixes for
architecture-specific files and architecture-independent files.  If you
pass the option `--exec-prefix=PREFIX' to `configure', the package uses
PREFIX as the prefix for installing programs and libraries.
Documentation and other data files still use the regular prefix.

   In addition, if you use an unusual directory layout you can give
options like `--bindir=DIR' to specify different values for particular
kinds of files.  Run `configure --help' for a list of the directories
you can set and what kinds of files go in them.  In general, the
default for these options is expressed in terms of `${prefix}', so that
specifying just `--prefix' will affect all of the other directory
specifications that were not explicitly provided.

   The most portable way to affect installation locations is to pass the
correct locations to `configure'; however, many packages provide one or
both of the following shortcuts of passing variable assignments to the
`make install' command line to change installation locations without
having to reconfigure or recompile.

   The first method involves providing an override variable for each
affected directory.  For example, `make install
prefix=/alternate/directory' will choose an alternate location for all
directory configuration variables that were expressed in terms of
`${prefix}'.  Any directories that were specified during `configure',
but not in terms of `${prefix}', must each be overridden at install
time for the entire installation to be relocated.  The approach of
makefile variable overrides for each directory variable is required by
the GNU Coding Standards, and ideally causes no recompilation.
However, some platforms have known limitations with the semantics of
shared libraries that end up requiring recompilation when using this
method, particularly noticeable in packages that use GNU Libtool.

   The second method involves providing the `DESTDIR' variable.  For
example, `make install DESTDIR=/alternate/directory' will prepend
`/alternate/directory' before all installation names.  The approach of
`DESTDIR' overrides is not required by the GNU Coding Standards, and
does not work on platforms that have drive letters.  On the other hand,
it does better at avoiding recompilation issues, and works well even
when some directory options were not specified in terms of `${prefix}'
at `configure' time.

Optional Features
=================

   If the package supports it, you can cause programs to be installed
with an extra prefix or suffix on their names by giving `configure' the
option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.

   Some packages pay attention to `--enable-FEATURE' options to
`configure', where FEATURE indicates an optional part of the package.
They may also pay attention to `--with-PACKAGE' options, where PACKAGE
is something like `gnu-as' or `x' (for the X Window System).  The
`README' should mention any `--enable-' and `--with-' options that the
package recognizes.

   For packages that use the X Window System, `configure' can usually
find the X include and library files automatically, but if it doesn't,
you can use the `configure' options `--x-includes=DIR' and
`--x-libraries=DIR' to specify their locations.

   Some packages offer the ability to configure how verbose the
execution of `make' will be.  For these packages, running `./configure
--enable-silent-rules' sets the default to minimal output, which can be
overridden with `make V=1'; while running `./configure
--disable-silent-rules' sets the default to verbose, which can be
overridden with `make V=0'.

Particular systems
==================

   On HP-UX, the default C compiler is not ANSI C compatible.  If GNU
CC is not installed, it is recommended to use the following options in
order to use an ANSI C compiler:

     ./configure CC="cc -Ae -D_XOPEN_SOURCE=500"

and if that doesn't work, install pre-built binaries of GCC for HP-UX.

   HP-UX `make' updates targets which have the same time stamps as
their prerequisites, which makes it generally unusable when shipped
generated files such as `configure' are involved.  Use GNU `make'
instead.

   On OSF/1 a.k.a. Tru64, some versions of the default C compiler cannot
parse its `<wchar.h>' header file.  The option `-nodtk' can be used as
a workaround.  If GNU CC is not installed, it is therefore recommended
to try

     ./configure CC="cc"

and if that doesn't work, try

     ./configure CC="cc -nodtk"

   On Solaris, don't put `/usr/ucb' early in your `PATH'.  This
directory contains several dysfunctional programs; working variants of
these programs are available in `/usr/bin'.  So, if you need `/usr/ucb'
in your `PATH', put it _after_ `/usr/bin'.

   On Haiku, software installed for all users goes in `/boot/common',
not `/usr/local'.  It is recommended to use the following options:

     ./configure --prefix=/boot/common

Specifying the System Type
==========================

   There may be some features `configure' cannot figure out
automatically, but needs to determine by the type of machine the package
will run on.  Usually, assuming the package is built to be run on the
_same_ architectures, `configure' can figure that out, but if it prints
a message saying it cannot guess the machine type, give it the
`--build=TYPE' option.  TYPE can either be a short name for the system
type, such as `sun4', or a canonical name which has the form:

     CPU-COMPANY-SYSTEM

where SYSTEM can have one of these forms:

     OS
     KERNEL-OS

   See the file `config.sub' for the possible values of each field.  If
`config.sub' isn't included in this package, then this package doesn't
need to know the machine type.

   If you are _building_ compiler tools for cross-compiling, you should
use the option `--target=TYPE' to select the type of system they will
produce code for.

   If you want to _use_ a cross compiler, that generates code for a
platform different from the build platform, you should specify the
"host" platform (i.e., that on which the generated programs will
eventually be run) with `--host=TYPE'.

Sharing Defaults
================

   If you want to set default values for `configure' scripts to share,
you can create a site shell script called `config.site' that gives
default values for variables like `CC', `cache_file', and `prefix'.
`configure' looks for `PREFIX/share/config.site' if it exists, then
`PREFIX/etc/config.site' if it exists.  Or, you can set the
`CONFIG_SITE' environment variable to the location of the site script.
A warning: not all `configure' scripts look for a site script.

Defining Variables
==================

   Variables not defined in a site shell script can be set in the
environment passed to `configure'.  However, some packages may run
configure again during the build, and the customized values of these
variables may be lost.  In order to avoid this problem, you should set
them in the `configure' command line, using `VAR=value'.  For example:

     ./configure CC=/usr/local2/bin/gcc

causes the specified `gcc' to be used as the C compiler (unless it is
overridden in the site shell script).

Unfortunately, this technique does not work for `CONFIG_SHELL' due to
an Autoconf limitation.  Until the limitation is lifted, you can use
this workaround:

     CONFIG_SHELL=/bin/bash ./configure CONFIG_SHELL=/bin/bash

`configure' Invocation
======================

   `configure' recognizes the following options to control how it
operates.

`--help'
`-h'
     Print a summary of all of the options to `configure', and exit.

`--help=short'
`--help=recursive'
     Print a summary of the options unique to this package's
     `configure', and exit.  The `short' variant lists options used
     only in the top level, while the `recursive' variant lists options
     also present in any nested packages.

`--version'
`-V'
     Print the version of Autoconf used to generate the `configure'
     script, and exit.

`--cache-file=FILE'
     Enable the cache: use and save the results of the tests in FILE,
     traditionally `config.cache'.  FILE defaults to `/dev/null' to
     disable caching.

`--config-cache'
`-C'
     Alias for `--cache-file=config.cache'.

`--quiet'
`--silent'
`-q'
     Do not print messages saying which checks are being made.  To
     suppress all normal output, redirect it to `/dev/null' (any error
     messages will still be shown).

`--srcdir=DIR'
     Look for the package's source code in directory DIR.  Usually
     `configure' can determine that directory automatically.

`--prefix=DIR'
     Use DIR as the installation prefix.  *note Installation Names::
     for more details, including other options available for fine-tuning
     the installation locations.

`--no-create'
`-n'
     Run the configure checks, but stop before creating any output
     files.

`configure' also accepts some other, not widely useful, options.  Run
`configure --help' for more details.

```

`ThirdParty/UnitTest++/LICENSE`:

```
Copyright (c) 2006 Noel Llopis and Charles Nicholson

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`ThirdParty/UnitTest++/Makefile.am`:

```am
ACLOCAL_AMFLAGS = -I m4
EXTRA_DIST = docs
SUBDIRS = UnitTest++

```

`ThirdParty/UnitTest++/README.md`:

```md
UnitTest++
===========

UnitTest++ is a lightweight unit testing framework for C++. It was designed to do test-driven development on a wide variety of platforms. Simplicity, portability, speed, and small footprint are all very important aspects of UnitTest++. UnitTest++ is ANSI portable C++ and makes minimal use of advanced library and languages features, which means it should be easily portable to just about any platform. Out of the box, the following platforms are supported:

* Windows
* Linux
* Mac OS X

Documentation
--------------
The full documentation for building and using UnitTest++ can be found on the [GitHub wiki page](https://github.com/unittest-cpp/unittest-cpp/wiki). The contents of this wiki are also included as a git submodule under the `docs` folder, so version-specific Markdown documentation is always available along with the download.

Pre-requisites
---------------
While there are currently some bundled makefiles and projects, UnitTest++ is primarily built and supported using [CMake](http://cmake.org).

Downloading
------------
### Latest (HEAD) ###

Via git:

    git clone https://github.com/unittest-cpp/unittest-cpp

Via svn:

    svn checkout https://github.com/unittest-cpp/unittest-cpp/trunk unittest-cpp

### Latest release (v1.4) ###

Via git:

    git clone https://github.com/unittest-cpp/unittest-cpp
    cd unittest-cpp
    git checkout v1.4

Via svn:

    svn checkout https://github.com/unittest-cpp/unittest-cpp/tags/v1.4 unittest-cpp

License
---------
*UnitTest++ is free software. You may copy, distribute, and modify it under
the terms of the License contained in the file LICENSE distributed
with this package. This license is the same as the MIT/X Consortium
license.*

Contributors
--------------
### [GitHub Contributor Graph](https://github.com/unittest-cpp/unittest-cpp/contributors) ###

### Current Maintainers: ###
* Patrick Johnmeyer (pjohnmeyer@gmail.com) @pjohnmeyer
* Charles Nicholson (charles.nicholson@gmail.com) @charlesnicholson

### Original Authors: ###
* Noel Llopis (llopis@convexhull.com) 
* Charles Nicholson (charles.nicholson@gmail.com)

### Contributors not included in github history ###
* Jim Tilander
* Kim Grasman
* Jonathan Jansson
* Dirck Blaskey
* Rory Driscoll
* Dan Lind
* Matt Kimmel -- Submitted with permission from Blue Fang Games
* Anthony Moralez
* Jeff Dixon
* Randy Coulman
* Lieven van der Heide

Historic release notes
----------------------

### Version 1.4 (2008-10-30) ###
- CHECK macros work at arbitrary stack depth from inside TESTs.
- Remove obsolete TEST_UTILITY macros
- Predicated test execution (via TestRunner::RunTestsIf)
- Better exception handling for fixture ctors/dtors.
- VC6/7/8/9 support

### Version 1.3 (2007-4-22) ###
- Removed dynamic memory allocations (other than streams)
- MinGW support
- Consistent (native) line endings
- Minor bug fixing

### Version 1.2 (2006-10-29) ###
- First pass at documentation.
- More detailed error crash catching in fixtures.
- Standard streams used for printing objects under check. This should allow the
  use of standard class types such as std::string or other custom classes with
  stream operators to ostream.
- Standard streams can be optionally compiled off by defining UNITTEST_USE_CUSTOM_STREAMS
  in Config.h
- Added named test suites
- Added CHECK_ARRAY2D_CLOSE 
- Posix library name is libUnitTest++.a now
- Floating point numbers are postfixed with 'f' in the failure reports

### Version 1.1 (2006-04-18) ###
- CHECK macros do not have side effects even if one of the parameters changes state
- Removed CHECK_ARRAY_EQUAL (too similar to CHECK_ARRAY_CLOSE)
- Added local and global time constraints
- Removed dependencies on strstream
- Improved Posix signal to exception translator
- Failing tests are added to Visual Studio's error list
- Fixed Visual Studio projects to work with spaces in directories

### Version 1.0 (2006-03-15) ###
- Initial release


```

`ThirdParty/UnitTest++/UnitTest++/AssertException.cpp`:

```cpp
#include "AssertException.h"

#ifndef UNITTEST_NO_EXCEPTIONS

namespace UnitTest {

AssertException::AssertException()
{
}

AssertException::~AssertException() throw()
{
}

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/AssertException.h`:

```h
#ifndef UNITTEST_ASSERTEXCEPTION_H
#define UNITTEST_ASSERTEXCEPTION_H

#include "Config.h"
#ifndef UNITTEST_NO_EXCEPTIONS

#include "HelperMacros.h"
#include <exception>

namespace UnitTest {

class UNITTEST_LINKAGE AssertException : public std::exception
{
public:
    AssertException();
    virtual ~AssertException() throw();
};

}

#endif

#endif

```

`ThirdParty/UnitTest++/UnitTest++/CheckMacros.h`:

```h
#ifndef UNITTEST_CHECKMACROS_H 
#define UNITTEST_CHECKMACROS_H

#include "HelperMacros.h"
#include "ExceptionMacros.h"
#include "Checks.h"
#include "AssertException.h"
#include "MemoryOutStream.h"
#include "TestDetails.h"
#include "CurrentTest.h"
#include "ReportAssertImpl.h"

#ifdef CHECK
    #error UnitTest++ redefines CHECK
#endif

#ifdef CHECK_EQUAL
	#error UnitTest++ redefines CHECK_EQUAL
#endif

#ifdef CHECK_CLOSE
	#error UnitTest++ redefines CHECK_CLOSE
#endif

#ifdef CHECK_ARRAY_EQUAL
	#error UnitTest++ redefines CHECK_ARRAY_EQUAL
#endif

#ifdef CHECK_ARRAY_CLOSE
	#error UnitTest++ redefines CHECK_ARRAY_CLOSE
#endif

#ifdef CHECK_ARRAY2D_CLOSE
	#error UnitTest++ redefines CHECK_ARRAY2D_CLOSE
#endif

#define CHECK(value) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
	UT_TRY \
		({ \
			if (!UnitTest::Check(value)) \
				UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), #value); \
		}) \
		UT_CATCH (std::exception, e, \
		{ \
			UnitTest::MemoryOutStream message; \
			message << "Unhandled exception (" << e.what() << ") in CHECK(" #value ")"; \
			UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
				message.GetText()); \
		}) \
		UT_CATCH_ALL \
		({ \
			UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
				"Unhandled exception in CHECK(" #value ")"); \
		}) \
	UNITTEST_MULTILINE_MACRO_END

#define CHECK_EQUAL(expected, actual) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
        UT_TRY \
		({ \
            UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), expected, actual, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__)); \
        }) \
		UT_CATCH (std::exception, e, \
		{ \
			UnitTest::MemoryOutStream message; \
			message << "Unhandled exception (" << e.what() << ") in CHECK_EQUAL(" #expected ", " #actual ")"; \
			UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
				message.GetText()); \
		}) \
        UT_CATCH_ALL \
		({ \
            UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
                    "Unhandled exception in CHECK_EQUAL(" #expected ", " #actual ")"); \
        }) \
	UNITTEST_MULTILINE_MACRO_END

#define CHECK_CLOSE(expected, actual, tolerance) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
        UT_TRY \
		({ \
            UnitTest::CheckClose(*UnitTest::CurrentTest::Results(), expected, actual, tolerance, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__)); \
        }) \
		UT_CATCH (std::exception, e, \
		{ \
			UnitTest::MemoryOutStream message; \
			message << "Unhandled exception (" << e.what() << ") in CHECK_CLOSE(" #expected ", " #actual ")"; \
			UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
				message.GetText()); \
		}) \
        UT_CATCH_ALL \
		({ \
            UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
                    "Unhandled exception in CHECK_CLOSE(" #expected ", " #actual ")"); \
        }) \
	UNITTEST_MULTILINE_MACRO_END

#define CHECK_ARRAY_EQUAL(expected, actual, count) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
        UT_TRY \
		({ \
            UnitTest::CheckArrayEqual(*UnitTest::CurrentTest::Results(), expected, actual, count, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__)); \
        }) \
 		UT_CATCH (std::exception, e, \
		{ \
			UnitTest::MemoryOutStream message; \
			message << "Unhandled exception (" << e.what() << ") in CHECK_ARRAY_EQUAL(" #expected ", " #actual ")"; \
			UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
				message.GetText()); \
		}) \
        UT_CATCH_ALL \
		({ \
            UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
                    "Unhandled exception in CHECK_ARRAY_EQUAL(" #expected ", " #actual ")"); \
        }) \
	UNITTEST_MULTILINE_MACRO_END

#define CHECK_ARRAY_CLOSE(expected, actual, count, tolerance) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
        UT_TRY \
		({ \
            UnitTest::CheckArrayClose(*UnitTest::CurrentTest::Results(), expected, actual, count, tolerance, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__)); \
        }) \
 		UT_CATCH (std::exception, e, \
		{ \
			UnitTest::MemoryOutStream message; \
			message << "Unhandled exception (" << e.what() << ") in CHECK_ARRAY_CLOSE(" #expected ", " #actual ")"; \
			UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
				message.GetText()); \
		}) \
        UT_CATCH_ALL \
		({ \
            UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
                    "Unhandled exception in CHECK_ARRAY_CLOSE(" #expected ", " #actual ")"); \
        }) \
	UNITTEST_MULTILINE_MACRO_END

#define CHECK_ARRAY2D_CLOSE(expected, actual, rows, columns, tolerance) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
        UT_TRY \
		({ \
            UnitTest::CheckArray2DClose(*UnitTest::CurrentTest::Results(), expected, actual, rows, columns, tolerance, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__)); \
        }) \
 		UT_CATCH (std::exception, e, \
		{ \
			UnitTest::MemoryOutStream message; \
			message << "Unhandled exception (" << e.what() << ") in CHECK_ARRAY2D_CLOSE(" #expected ", " #actual ")"; \
			UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
				message.GetText()); \
		}) \
        UT_CATCH_ALL \
		({ \
            UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), \
                    "Unhandled exception in CHECK_ARRAY2D_CLOSE(" #expected ", " #actual ")"); \
        }) \
	UNITTEST_MULTILINE_MACRO_END


// CHECK_THROW and CHECK_ASSERT only exist when UNITTEST_NO_EXCEPTIONS isn't defined (see config.h)
#ifndef UNITTEST_NO_EXCEPTIONS
#define CHECK_THROW(expression, ExpectedExceptionType) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
        bool caught_ = false; \
        try { expression; } \
        catch (ExpectedExceptionType const&) { caught_ = true; } \
		catch (...) {} \
        if (!caught_) \
	        UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), __LINE__), "Expected exception: \"" #ExpectedExceptionType "\" not thrown"); \
	UNITTEST_MULTILINE_MACRO_END


#define CHECK_ASSERT(expression) \
	UNITTEST_MULTILINE_MACRO_BEGIN \
		UnitTest::Detail::ExpectAssert(true); \
		CHECK_THROW(expression, UnitTest::AssertException); \
		UnitTest::Detail::ExpectAssert(false); \
	UNITTEST_MULTILINE_MACRO_END
#endif
#endif

```

`ThirdParty/UnitTest++/UnitTest++/Checks.cpp`:

```cpp
#include "Checks.h"
#include <cstring>

namespace UnitTest {

namespace {

void CheckStringsEqual(TestResults& results, char const* expected, char const* actual, 
                       TestDetails const& details)
{
	using namespace std;

    if ((expected && actual) ? strcmp(expected, actual) : (expected || actual))
    {
        UnitTest::MemoryOutStream stream;
        stream << "Expected " << (expected ? expected : "<NULLPTR>") << " but was " << (actual ? actual : "<NULLPTR>");

        results.OnTestFailure(details, stream.GetText());
    }
}

}


void CheckEqual(TestResults& results, char const* expected, char const* actual,
                TestDetails const& details)
{
    CheckStringsEqual(results, expected, actual, details);
}

void CheckEqual(TestResults& results, char* expected, char* actual,
                TestDetails const& details)
{
    CheckStringsEqual(results, expected, actual, details);
}

void CheckEqual(TestResults& results, char* expected, char const* actual,
                TestDetails const& details)
{
    CheckStringsEqual(results, expected, actual, details);
}

void CheckEqual(TestResults& results, char const* expected, char* actual,
                TestDetails const& details)
{
    CheckStringsEqual(results, expected, actual, details);
}


}

```

`ThirdParty/UnitTest++/UnitTest++/Checks.h`:

```h
#ifndef UNITTEST_CHECKS_H
#define UNITTEST_CHECKS_H

#include "Config.h"
#include "TestResults.h"
#include "MemoryOutStream.h"

namespace UnitTest {


template< typename Value >
bool Check(Value const value)
{
    return !!value; // doing double negative to avoid silly VS warnings
}


template< typename Expected, typename Actual >
void CheckEqual(TestResults& results, Expected const& expected, Actual const& actual, TestDetails const& details)
{
    if (!(expected == actual))
    {
        UnitTest::MemoryOutStream stream;
        stream << "Expected " << expected << " but was " << actual;

        results.OnTestFailure(details, stream.GetText());
    }
}

UNITTEST_LINKAGE void CheckEqual(TestResults& results, char const* expected, char const* actual, TestDetails const& details);

UNITTEST_LINKAGE void CheckEqual(TestResults& results, char* expected, char* actual, TestDetails const& details);

UNITTEST_LINKAGE void CheckEqual(TestResults& results, char* expected, char const* actual, TestDetails const& details);

UNITTEST_LINKAGE void CheckEqual(TestResults& results, char const* expected, char* actual, TestDetails const& details);

template< typename Expected, typename Actual, typename Tolerance >
bool AreClose(Expected const& expected, Actual const& actual, Tolerance const& tolerance)
{
    return (actual >= (expected - tolerance)) && (actual <= (expected + tolerance));
}

template< typename Expected, typename Actual, typename Tolerance >
void CheckClose(TestResults& results, Expected const& expected, Actual const& actual, Tolerance const& tolerance,
                TestDetails const& details)
{
    if (!AreClose(expected, actual, tolerance))
    { 
        UnitTest::MemoryOutStream stream;
        stream << "Expected " << expected << " +/- " << tolerance << " but was " << actual;

        results.OnTestFailure(details, stream.GetText());
    }
}


template< typename Expected, typename Actual >
void CheckArrayEqual(TestResults& results, Expected const& expected, Actual const& actual,
                int const count, TestDetails const& details)
{
    bool equal = true;
    for (int i = 0; i < count; ++i)
        equal &= (expected[i] == actual[i]);

    if (!equal)
    {
        UnitTest::MemoryOutStream stream;

		stream << "Expected [ ";

		for (int expectedIndex = 0; expectedIndex < count; ++expectedIndex)
            stream << expected[expectedIndex] << " ";

		stream << "] but was [ ";

		for (int actualIndex = 0; actualIndex < count; ++actualIndex)
            stream << actual[actualIndex] << " ";

		stream << "]";

        results.OnTestFailure(details, stream.GetText());
    }
}

template< typename Expected, typename Actual, typename Tolerance >
bool ArrayAreClose(Expected const& expected, Actual const& actual, int const count, Tolerance const& tolerance)
{
    bool equal = true;
    for (int i = 0; i < count; ++i)
        equal &= AreClose(expected[i], actual[i], tolerance);
    return equal;
}

template< typename Expected, typename Actual, typename Tolerance >
void CheckArrayClose(TestResults& results, Expected const& expected, Actual const& actual,
                   int const count, Tolerance const& tolerance, TestDetails const& details)
{
    bool equal = ArrayAreClose(expected, actual, count, tolerance);

    if (!equal)
    {
        UnitTest::MemoryOutStream stream;

        stream << "Expected [ ";
        for (int expectedIndex = 0; expectedIndex < count; ++expectedIndex)
            stream << expected[expectedIndex] << " ";
        stream << "] +/- " << tolerance << " but was [ ";

		for (int actualIndex = 0; actualIndex < count; ++actualIndex)
            stream << actual[actualIndex] << " ";
        stream << "]";

        results.OnTestFailure(details, stream.GetText());
    }
}

template< typename Expected, typename Actual, typename Tolerance >
void CheckArray2DClose(TestResults& results, Expected const& expected, Actual const& actual,
                   int const rows, int const columns, Tolerance const& tolerance, TestDetails const& details)
{
    bool equal = true;
    for (int i = 0; i < rows; ++i)
        equal &= ArrayAreClose(expected[i], actual[i], columns, tolerance);

    if (!equal)
    {
        UnitTest::MemoryOutStream stream;

        stream << "Expected [ ";    

		for (int expectedRow = 0; expectedRow < rows; ++expectedRow)
        {
            stream << "[ ";
            for (int expectedColumn = 0; expectedColumn < columns; ++expectedColumn)
                stream << expected[expectedRow][expectedColumn] << " ";
            stream << "] ";
        }

		stream << "] +/- " << tolerance << " but was [ ";

		for (int actualRow = 0; actualRow < rows; ++actualRow)
        {
            stream << "[ ";
            for (int actualColumn = 0; actualColumn < columns; ++actualColumn)
                stream << actual[actualRow][actualColumn] << " ";
            stream << "] ";
        }

		stream << "]";

        results.OnTestFailure(details, stream.GetText());
    }
}

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/CompositeTestReporter.cpp`:

```cpp
#include "CompositeTestReporter.h"
#include <cstddef>

namespace UnitTest {

CompositeTestReporter::CompositeTestReporter()
	: m_reporterCount(0)
{
}

int CompositeTestReporter::GetReporterCount() const
{
	return m_reporterCount;
}

bool CompositeTestReporter::AddReporter(TestReporter* reporter)
{
	if (m_reporterCount == kMaxReporters)
		return false;

	m_reporters[m_reporterCount++] = reporter;
	return true;
}

bool CompositeTestReporter::RemoveReporter(TestReporter* reporter)
{
    for (int index = 0; index < m_reporterCount; ++index)
    {
        if (m_reporters[index] == reporter)
        {
            m_reporters[index] = m_reporters[m_reporterCount - 1];
			--m_reporterCount;
			return true;
        }
    }

    return false;
}

void CompositeTestReporter::ReportFailure(TestDetails const& details, char const* failure)
{
    for (int index = 0; index < m_reporterCount; ++index)
		m_reporters[index]->ReportFailure(details, failure);
}

void CompositeTestReporter::ReportTestStart(TestDetails const& test)
{
	for (int index = 0; index < m_reporterCount; ++index)
		m_reporters[index]->ReportTestStart(test);
}

void CompositeTestReporter::ReportTestFinish(TestDetails const& test, float secondsElapsed)
{
	for (int index = 0; index < m_reporterCount; ++index)
		m_reporters[index]->ReportTestFinish(test, secondsElapsed);
}

void CompositeTestReporter::ReportSummary(int totalTestCount,
										  int failedTestCount,
										  int failureCount,
										  float secondsElapsed)
{
	for (int index = 0; index < m_reporterCount; ++index)
		m_reporters[index]->ReportSummary(totalTestCount, failedTestCount, failureCount, secondsElapsed);
}

}

```

`ThirdParty/UnitTest++/UnitTest++/CompositeTestReporter.h`:

```h
#ifndef UNITTEST_COMPOSITETESTREPORTER_H
#define UNITTEST_COMPOSITETESTREPORTER_H

#include "TestReporter.h"

namespace UnitTest {

class UNITTEST_LINKAGE CompositeTestReporter : public TestReporter
{
public:
    CompositeTestReporter();

	int GetReporterCount() const;
    bool AddReporter(TestReporter* reporter);
    bool RemoveReporter(TestReporter* reporter);

    virtual void ReportTestStart(TestDetails const& test);
    virtual void ReportFailure(TestDetails const& test, char const* failure);
    virtual void ReportTestFinish(TestDetails const& test, float secondsElapsed);
    virtual void ReportSummary(int totalTestCount, int failedTestCount, int failureCount, float secondsElapsed);

private:
	enum { kMaxReporters = 16 };
	TestReporter* m_reporters[kMaxReporters];
	int m_reporterCount;

	// revoked
	CompositeTestReporter(const CompositeTestReporter&);
	CompositeTestReporter& operator =(const CompositeTestReporter&);
};

}

#endif 

```

`ThirdParty/UnitTest++/UnitTest++/Config.h`:

```h
#ifndef UNITTEST_CONFIG_H
#define UNITTEST_CONFIG_H

// Standard defines documented here: http://predef.sourceforge.net

#if defined(_MSC_VER)
#ifndef _CRT_SECURE_NO_WARNINGS
	#define _CRT_SECURE_NO_WARNINGS
#endif
	#pragma warning(disable:4702) // unreachable code
	#pragma warning(disable:4722) // destructor never returns, potential memory leak

#if (_MSC_VER == 1200)  // VC6
		#define UNITTEST_COMPILER_IS_MSVC6
		#pragma warning(disable:4786)
		#pragma warning(disable:4290)
	#endif

	#ifdef _USRDLL
		#define UNITTEST_WIN32_DLL
	#endif
	#define UNITTEST_WIN32
#endif

#if defined(unix) || defined(__unix__) || defined(__unix) || defined(linux) || \
    defined(__APPLE__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__)
    #define UNITTEST_POSIX
#endif

#if defined(__MINGW32__)
    #define UNITTEST_MINGW
#endif


// By default, MemoryOutStream is implemented in terms of std::ostringstream.
// This is useful if you are using the CHECK macros on objects that have something like this defined:
// std::ostringstream& operator<<(std::ostringstream& s, const YourObject& value)
//
// On the other hand, it can be more expensive.
// Un-comment this line to use the custom MemoryOutStream (no deps on std::ostringstream).

// #define UNITTEST_USE_CUSTOM_STREAMS

// Developer note: This dual-macro setup is to preserve compatibility with UnitTest++ 1.4 users
// who may have used or defined UNITTEST_USE_CUSTOM_STREAMS outside of this configuration file, as
// well as Google Code HEAD users that may have used or defined
// UNITTEST_MEMORYOUTSTREAM_IS_STD_OSTRINGSTREAM outside of this configuration file.
#ifndef UNITTEST_USE_CUSTOM_STREAMS
    #define UNITTEST_MEMORYOUTSTREAM_IS_STD_OSTRINGSTREAM
#endif

// DeferredTestReporter uses the STL to collect test results for subsequent export by reporters like
// XmlTestReporter.  If you don't want to use this functionality, uncomment this line and no STL
// headers or code will be compiled into UnitTest++

//#define UNITTEST_NO_DEFERRED_REPORTER


// By default, asserts that you report via UnitTest::ReportAssert() abort the current test and
// continue to the next one by throwing an exception, which unwinds the stack naturally, destroying
// all auto variables on its way back down.  If you don't want to (or can't) use exceptions for your
// platform/compiler, uncomment this line.  All exception code will be removed from UnitTest++,
// assert recovery will be done via setjmp/longjmp, and NO correct stack unwinding will happen!

#define UNITTEST_NO_EXCEPTIONS


// std namespace qualification: used for functions like strcpy that
// may live in std:: namespace (cstring header).
#if defined( UNITTEST_COMPILER_IS_MSVC6 )
	#define UNIITEST_NS_QUAL_STD(x) x
#else
	#define UNIITEST_NS_QUAL_STD(x) ::std::x
#endif

#endif

```

`ThirdParty/UnitTest++/UnitTest++/CurrentTest.cpp`:

```cpp
#include "CurrentTest.h"
#include <cstddef>

namespace UnitTest {

UNITTEST_LINKAGE TestResults*& CurrentTest::Results()
{
	static TestResults* testResults = NULL;
	return testResults;
}

UNITTEST_LINKAGE const TestDetails*& CurrentTest::Details()
{
	static const TestDetails* testDetails = NULL;
	return testDetails;
}

}

```

`ThirdParty/UnitTest++/UnitTest++/CurrentTest.h`:

```h
#ifndef UNITTEST_CURRENTTESTRESULTS_H
#define UNITTEST_CURRENTTESTRESULTS_H

#include "HelperMacros.h"

namespace UnitTest {

class TestResults;
class TestDetails;

namespace CurrentTest
{
	UNITTEST_LINKAGE TestResults*& Results();
	UNITTEST_LINKAGE const TestDetails*& Details();
}

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/DeferredTestReporter.cpp`:

```cpp
#include "Config.h"
#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "DeferredTestReporter.h"
#include "TestDetails.h"

using namespace UnitTest;

void DeferredTestReporter::ReportTestStart(TestDetails const& details)
{
    m_results.push_back(DeferredTestResult(details.suiteName, details.testName));
}

void DeferredTestReporter::ReportFailure(TestDetails const& details, char const* failure)
{
    DeferredTestResult& r = m_results.back();
    r.failed = true;
    r.failures.push_back(DeferredTestFailure(details.lineNumber, failure));
    r.failureFile = details.filename;
}

void DeferredTestReporter::ReportTestFinish(TestDetails const&, float secondsElapsed)
{
    DeferredTestResult& r = m_results.back();
    r.timeElapsed = secondsElapsed;
}

DeferredTestReporter::DeferredTestResultList& DeferredTestReporter::GetResults()
{
    return m_results;
}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/DeferredTestReporter.h`:

```h
#ifndef UNITTEST_DEFERREDTESTREPORTER_H
#define UNITTEST_DEFERREDTESTREPORTER_H

#include "Config.h"

#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "TestReporter.h"
#include "DeferredTestResult.h"

#include <vector>

UNITTEST_STDVECTOR_LINKAGE(UnitTest::DeferredTestResult);

namespace UnitTest
{

class UNITTEST_LINKAGE DeferredTestReporter : public TestReporter
{
public:
    virtual void ReportTestStart(TestDetails const& details);
    virtual void ReportFailure(TestDetails const& details, char const* failure);
    virtual void ReportTestFinish(TestDetails const& details, float secondsElapsed);

    typedef std::vector< DeferredTestResult > DeferredTestResultList;
    DeferredTestResultList& GetResults();

private:
    DeferredTestResultList m_results;
};

}

#endif
#endif

```

`ThirdParty/UnitTest++/UnitTest++/DeferredTestResult.cpp`:

```cpp
#include "Config.h"
#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "DeferredTestResult.h"
#include <cstring>

namespace UnitTest
{

DeferredTestFailure::DeferredTestFailure()
	: lineNumber(-1)
{
	failureStr[0] = '\0';
}

DeferredTestFailure::DeferredTestFailure(int lineNumber_, const char* failureStr_)
	: lineNumber(lineNumber_)
{
	UNIITEST_NS_QUAL_STD(strcpy)(failureStr, failureStr_);
}

DeferredTestResult::DeferredTestResult()
	: suiteName("")
	, testName("")
	, failureFile("")
	, timeElapsed(0.0f)
	, failed(false)
{
}

DeferredTestResult::DeferredTestResult(char const* suite, char const* test)
	: suiteName(suite)
	, testName(test)
	, failureFile("")
	, timeElapsed(0.0f)
	, failed(false)
{
}

DeferredTestResult::~DeferredTestResult()
{
}

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/DeferredTestResult.h`:

```h
#ifndef UNITTEST_DEFERREDTESTRESULT_H
#define UNITTEST_DEFERREDTESTRESULT_H

#include "Config.h"
#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "HelperMacros.h"
#include <string>
#include <vector>

namespace UnitTest
{

class UNITTEST_LINKAGE DeferredTestFailure
{
public:
	DeferredTestFailure();
	DeferredTestFailure(int lineNumber_, const char* failureStr_);

	int lineNumber;
	char failureStr[1024];
};

}

UNITTEST_STDVECTOR_LINKAGE(UnitTest::DeferredTestFailure);

namespace UnitTest
{

class UNITTEST_LINKAGE DeferredTestResult
{
public:
	DeferredTestResult();
    DeferredTestResult(char const* suite, char const* test);
    ~DeferredTestResult();
    
    std::string suiteName;
    std::string testName;
    std::string failureFile;
    
    typedef std::vector< DeferredTestFailure > FailureVec;
    FailureVec failures;
    
    float timeElapsed;
	bool failed;
};

}

#endif
#endif

```

`ThirdParty/UnitTest++/UnitTest++/ExceptionMacros.h`:

```h
#ifndef UNITTEST_EXCEPTIONMACROS_H
#define UNITTEST_EXCEPTIONMACROS_H

#include "Config.h"

#ifndef UNITTEST_NO_EXCEPTIONS
	#define UT_TRY(x) try x
	#define UT_THROW(x) throw x
	#define UT_CATCH(ExceptionType, ExceptionName, CatchBody) catch(ExceptionType& ExceptionName) CatchBody
	#define UT_CATCH_ALL(CatchBody) catch(...) CatchBody
#else
	#define UT_TRY(x) x
	#define UT_THROW(x)
	#define UT_CATCH(ExceptionType, ExceptionName, CatchBody)
	#define UT_CATCH_ALL(CatchBody)
#endif

#endif

```

`ThirdParty/UnitTest++/UnitTest++/ExecuteTest.h`:

```h
#ifndef UNITTEST_EXECUTE_TEST_H
#define UNITTEST_EXECUTE_TEST_H

#include <time.h>
#include "Config.h"
#include "ExceptionMacros.h"
#include "TestDetails.h"
#include "TestResults.h"
#include "MemoryOutStream.h"
#include "AssertException.h"
#include "CurrentTest.h"
#include "TimeHelpers.h"

#ifdef UNITTEST_NO_EXCEPTIONS
	#include "ReportAssertImpl.h"
#endif

#ifdef UNITTEST_POSIX
	#include "Posix/SignalTranslator.h"
#endif

namespace UnitTest {

template< typename T >
void ExecuteTest(T& testObject, TestDetails const& details, bool isMockTest)
{
	if (isMockTest == false)
		CurrentTest::Details() = &details;

	testObject.RunImpl();
}

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/HelperMacros.h`:

```h
#ifndef UNITTEST_HELPERMACROS_H
#define UNITTEST_HELPERMACROS_H

#include "Config.h"

#define UNITTEST_MULTILINE_MACRO_BEGIN do {

#if defined(UNITTEST_WIN32) && !defined(UNITTEST_COMPILER_IS_MSVC6)
	#define UNITTEST_MULTILINE_MACRO_END \
		} __pragma(warning(push)) __pragma(warning(disable:4127)) while (0) __pragma(warning(pop))
#else
	#define UNITTEST_MULTILINE_MACRO_END } while(0)
#endif


#ifdef UNITTEST_WIN32_DLL
	#define UNITTEST_IMPORT __declspec(dllimport)
	#define UNITTEST_EXPORT	__declspec(dllexport)

	#ifdef UNITTEST_DLL_EXPORT
		#define UNITTEST_LINKAGE UNITTEST_EXPORT
		#define UNITTEST_IMPEXP_TEMPLATE
	#else
		#define UNITTEST_LINKAGE UNITTEST_IMPORT
		#define UNITTEST_IMPEXP_TEMPLATE extern
	#endif

	#define UNITTEST_STDVECTOR_LINKAGE(T) \
		__pragma(warning(push)) \
		__pragma(warning(disable:4231)) \
		UNITTEST_IMPEXP_TEMPLATE template class UNITTEST_LINKAGE std::allocator< T >; \
		UNITTEST_IMPEXP_TEMPLATE template class UNITTEST_LINKAGE std::vector< T >; \
		__pragma(warning(pop))
#else
	#define UNITTEST_IMPORT
	#define UNITTEST_EXPORT
	#define UNITTEST_LINKAGE
	#define UNITTEST_IMPEXP_TEMPLATE
	#define UNITTEST_STDVECTOR_LINKAGE(T)
#endif

#ifdef UNITTEST_WIN32
	#define UNITTEST_JMPBUF jmp_buf
	#define UNITTEST_SETJMP setjmp
	#define UNITTEST_LONGJMP longjmp
#elif defined UNITTEST_POSIX
	#define UNITTEST_JMPBUF std::jmp_buf
	#define UNITTEST_SETJMP setjmp
	#define UNITTEST_LONGJMP std::longjmp
#endif

#endif

```

`ThirdParty/UnitTest++/UnitTest++/Makefile.am`:

```am
lib_LTLIBRARIES = libUnitTest++.la
pkgincludedir = $(includedir)/UnitTest++
nobase_pkginclude_HEADERS = UnitTest++.h UnitTestPP.h Config.h HelperMacros.h Test.h TestDetails.h TestList.h TestSuite.h TestResults.h TestMacros.h CheckMacros.h TestRunner.h TimeConstraint.h ExecuteTest.h AssertException.h MemoryOutStream.h CurrentTest.h Posix/SignalTranslator.h Checks.h TimeHelpers.h Posix/TimeHelpers.h ExceptionMacros.h ReportAssert.h ReportAssertImpl.h CompositeTestReporter.h
libUnitTest___la_SOURCES = AssertException.cpp Test.cpp Checks.cpp TestRunner.cpp TestResults.cpp TestReporter.cpp TestReporterStdout.cpp ReportAssert.cpp TestList.cpp TimeConstraint.cpp TestDetails.cpp MemoryOutStream.cpp DeferredTestReporter.cpp DeferredTestResult.cpp XmlTestReporter.cpp CurrentTest.cpp Posix/SignalTranslator.cpp Posix/TimeHelpers.cpp CompositeTestReporter.cpp
libUnitTest___la_LDFLAGS = -version-number @LIBUNITTEST_SO_VERSION@
check_PROGRAMS = TestUnitTest++
TestUnitTest___SOURCES = $(top_srcdir)/tests/Main.cpp $(top_srcdir)/tests/TestAssertHandler.cpp $(top_srcdir)/tests/TestCheckMacros.cpp $(top_srcdir)/tests/TestChecks.cpp $(top_srcdir)/tests/TestCompositeTestReporter.cpp $(top_srcdir)/tests/TestCurrentTest.cpp $(top_srcdir)/tests/TestDeferredTestReporter.cpp $(top_srcdir)/tests/TestExceptions.cpp $(top_srcdir)/tests/TestMemoryOutStream.cpp $(top_srcdir)/tests/TestTest.cpp $(top_srcdir)/tests/TestTestList.cpp $(top_srcdir)/tests/TestTestMacros.cpp $(top_srcdir)/tests/TestTestResults.cpp $(top_srcdir)/tests/TestTestRunner.cpp $(top_srcdir)/tests/TestTestSuite.cpp $(top_srcdir)/tests/TestTimeConstraint.cpp $(top_srcdir)/tests/TestTimeConstraintMacro.cpp $(top_srcdir)/tests/TestUnitTestPP.cpp $(top_srcdir)/tests/TestXmlTestReporter.cpp
TestUnitTest___LDADD = libUnitTest++.la
TESTS = TestUnitTest++

```

`ThirdParty/UnitTest++/UnitTest++/MemoryOutStream.cpp`:

```cpp
#include "MemoryOutStream.h"

#ifdef UNITTEST_MEMORYOUTSTREAM_IS_STD_OSTRINGSTREAM

namespace UnitTest {

char const* MemoryOutStream::GetText() const
{
	m_text = this->str();
	return m_text.c_str();
}

void MemoryOutStream::Clear()
{
	this->str(std::string());
	m_text = this->str();
}

#ifdef UNITTEST_COMPILER_IS_MSVC6

#define snprintf _snprintf

template<typename ValueType>
std::ostream& FormatToStream(std::ostream& stream, char const* format, ValueType const& value)
{
   using namespace std;
   
   const size_t BUFFER_SIZE=32;
   char txt[BUFFER_SIZE];
   snprintf(txt, BUFFER_SIZE, format, value);
   return stream << txt;
}

std::ostream& operator<<(std::ostream& stream, __int64 const n)
{
   return FormatToStream(stream, "%I64d", n);
}

std::ostream& operator<<(std::ostream& stream, unsigned __int64 const n)
{
   return FormatToStream(stream, "%I64u", n);
}

#endif

}

#else

#include <cstring>
#include <cstdio>

#if _MSC_VER
#define snprintf _snprintf
#endif

namespace UnitTest {

namespace {

template<typename ValueType>
void FormatToStream(MemoryOutStream& stream, char const* format, ValueType const& value)
{
	using namespace std;

    const size_t BUFFER_SIZE=32;
    char txt[BUFFER_SIZE];
    snprintf(txt, BUFFER_SIZE, format, value);
    stream << txt;
}

int RoundUpToMultipleOfPow2Number (int n, int pow2Number)
{
    return (n + (pow2Number - 1)) & ~(pow2Number - 1);
}

}


MemoryOutStream::MemoryOutStream(int const size)
    : m_capacity (0)
    , m_buffer (0)

{
    GrowBuffer(size);
}

MemoryOutStream::~MemoryOutStream()
{
    delete [] m_buffer;
}

void MemoryOutStream::Clear()
{
	m_buffer[0] = '\0';
}

char const* MemoryOutStream::GetText() const
{
    return m_buffer;
}

MemoryOutStream& MemoryOutStream::operator <<(char const* txt)
{
	using namespace std;

    int const bytesLeft = m_capacity - (int)strlen(m_buffer);
    int const bytesRequired = (int)strlen(txt) + 1;

    if (bytesRequired > bytesLeft)
    {
        int const requiredCapacity = bytesRequired + m_capacity - bytesLeft;
        GrowBuffer(requiredCapacity);
    }

    strcat(m_buffer, txt);
    return *this;
}

MemoryOutStream& MemoryOutStream::operator <<(int const n)
{
    FormatToStream(*this, "%i", n);
    return *this;
}

MemoryOutStream& MemoryOutStream::operator <<(long const n)
{
    FormatToStream(*this, "%li", n);
    return *this;
}

MemoryOutStream& MemoryOutStream::operator <<(unsigned long const n)
{
    FormatToStream(*this, "%lu", n);
    return *this;
}

#ifdef UNITTEST_COMPILER_IS_MSVC6
MemoryOutStream& MemoryOutStream::operator <<(__int64 const n)
#else
MemoryOutStream& MemoryOutStream::operator <<(long long const n)
#endif
{
#ifdef UNITTEST_WIN32
	FormatToStream(*this, "%I64d", n);
#else
	FormatToStream(*this, "%lld", n);
#endif

	return *this;
}

#ifdef UNITTEST_COMPILER_IS_MSVC6
MemoryOutStream& MemoryOutStream::operator <<(unsigned __int64 const n)
#else
MemoryOutStream& MemoryOutStream::operator <<(unsigned long long const n)
#endif
{
#ifdef UNITTEST_WIN32
	FormatToStream(*this, "%I64u", n);
#else
	FormatToStream(*this, "%llu", n);
#endif

	return *this;
}

MemoryOutStream& MemoryOutStream::operator <<(float const f)
{
    FormatToStream(*this, "%0.6f", f);
    return *this;    
}

MemoryOutStream& MemoryOutStream::operator <<(void const* p)
{
    FormatToStream(*this, "%p", p);
    return *this;    
}

MemoryOutStream& MemoryOutStream::operator <<(unsigned int const s)
{
    FormatToStream(*this, "%u", s);
    return *this;    
}

MemoryOutStream& MemoryOutStream::operator <<(double const d)
{
	FormatToStream(*this, "%0.6f", d);
	return *this;
}

int MemoryOutStream::GetCapacity() const
{
    return m_capacity;
}


void MemoryOutStream::GrowBuffer(int const desiredCapacity)
{
    int const newCapacity = RoundUpToMultipleOfPow2Number(desiredCapacity, GROW_CHUNK_SIZE);

	using namespace std;

    char* buffer = new char[newCapacity];
    if (m_buffer)
        strcpy(buffer, m_buffer);
    else
        strcpy(buffer, "");

    delete [] m_buffer;
    m_buffer = buffer;
    m_capacity = newCapacity;
}

}


#endif

```

`ThirdParty/UnitTest++/UnitTest++/MemoryOutStream.h`:

```h
#ifndef UNITTEST_MEMORYOUTSTREAM_H
#define UNITTEST_MEMORYOUTSTREAM_H

#include "Config.h"
#include "HelperMacros.h"

#ifdef UNITTEST_MEMORYOUTSTREAM_IS_STD_OSTRINGSTREAM

#include <sstream>

namespace UnitTest
{

class UNITTEST_LINKAGE MemoryOutStream : public std::ostringstream
{
public:
    MemoryOutStream() {}
    ~MemoryOutStream() {}
	void Clear();
	char const* GetText() const;

private:
    MemoryOutStream(MemoryOutStream const&);
    void operator =(MemoryOutStream const&);

    mutable std::string m_text;
};

#ifdef UNITTEST_COMPILER_IS_MSVC6
std::ostream& operator<<(std::ostream& stream, __int64 const n);
std::ostream& operator<<(std::ostream& stream, unsigned __int64 const n);
#endif

}

#else

#include <cstddef>

#ifdef UNITTEST_COMPILER_IS_MSVC6
namespace std {}
#endif

namespace UnitTest
{

class UNITTEST_LINKAGE MemoryOutStream
{
public:
    explicit MemoryOutStream(int const size = 256);
    ~MemoryOutStream();

	void Clear();
    char const* GetText() const;

    MemoryOutStream& operator <<(char const* txt);
    MemoryOutStream& operator <<(int n);
    MemoryOutStream& operator <<(long n);
    MemoryOutStream& operator <<(unsigned long n);
#ifdef UNITTEST_COMPILER_IS_MSVC6
    MemoryOutStream& operator <<(__int64 n);
    MemoryOutStream& operator <<(unsigned __int64 n);
#else
    MemoryOutStream& operator <<(long long n);
    MemoryOutStream& operator <<(unsigned long long n);
#endif
   MemoryOutStream& operator <<(float f);
    MemoryOutStream& operator <<(double d);
    MemoryOutStream& operator <<(void const* p);
    MemoryOutStream& operator <<(unsigned int s);

    enum { GROW_CHUNK_SIZE = 32 };
    int GetCapacity() const;

private:
    void operator= (MemoryOutStream const&);
    void GrowBuffer(int capacity);

    int m_capacity;
    char* m_buffer;
};

}

#endif

#endif

```

`ThirdParty/UnitTest++/UnitTest++/Posix/SignalTranslator.cpp`:

```cpp
#include "SignalTranslator.h"


namespace UnitTest {


#if defined(__ORBIS__)
#else

sigjmp_buf* SignalTranslator::s_jumpTarget = 0;

namespace {

void SignalHandler(int sig)
{
    siglongjmp(*SignalTranslator::s_jumpTarget, sig );
}

}


SignalTranslator::SignalTranslator()
{
    m_oldJumpTarget = s_jumpTarget;
    s_jumpTarget = &m_currentJumpTarget;

    struct sigaction action;
    action.sa_flags = 0;
    action.sa_handler = SignalHandler;
    sigemptyset( &action.sa_mask );

    sigaction( SIGSEGV, &action, &m_old_SIGSEGV_action );
    sigaction( SIGFPE , &action, &m_old_SIGFPE_action  );
    sigaction( SIGTRAP, &action, &m_old_SIGTRAP_action );
    sigaction( SIGBUS , &action, &m_old_SIGBUS_action  );
    sigaction( SIGILL , &action, &m_old_SIGBUS_action  );
}

SignalTranslator::~SignalTranslator()
{
    sigaction( SIGILL , &m_old_SIGBUS_action , 0 );
    sigaction( SIGBUS , &m_old_SIGBUS_action , 0 );
    sigaction( SIGTRAP, &m_old_SIGTRAP_action, 0 );
    sigaction( SIGFPE , &m_old_SIGFPE_action , 0 );
    sigaction( SIGSEGV, &m_old_SIGSEGV_action, 0 );

    s_jumpTarget = m_oldJumpTarget;
}

#endif

}

```

`ThirdParty/UnitTest++/UnitTest++/Posix/SignalTranslator.h`:

```h
#ifndef UNITTEST_SIGNALTRANSLATOR_H
#define UNITTEST_SIGNALTRANSLATOR_H

#if defined(__ORBIS__)


#else

#include <setjmp.h>
#include <signal.h>

namespace UnitTest {

class SignalTranslator
{
public:
    SignalTranslator();
    ~SignalTranslator();

    static sigjmp_buf* s_jumpTarget;

private:
    sigjmp_buf m_currentJumpTarget;
    sigjmp_buf* m_oldJumpTarget;

    struct sigaction m_old_SIGFPE_action;
    struct sigaction m_old_SIGTRAP_action;
    struct sigaction m_old_SIGSEGV_action;
    struct sigaction m_old_SIGBUS_action;
    //struct sigaction m_old_SIGABRT_action;
    //struct sigaction m_old_SIGALRM_action;
};

#if !defined (__GNUC__)
    #define UNITTEST_EXTENSION
#else
    #define UNITTEST_EXTENSION __extension__
#endif

#define UNITTEST_THROW_SIGNALS_POSIX_ONLY \
	UnitTest::SignalTranslator sig; \
	if (UNITTEST_EXTENSION sigsetjmp(*UnitTest::SignalTranslator::s_jumpTarget, 1) != 0) \
        throw ("Unhandled system exception"); 

}

#endif

#endif

```

`ThirdParty/UnitTest++/UnitTest++/Posix/TimeHelpers.cpp`:

```cpp
#include "TimeHelpers.h"
#include <unistd.h>

namespace UnitTest {

Timer::Timer()
{
    m_startTime.tv_sec = 0;
    m_startTime.tv_usec = 0;
}

void Timer::Start()
{
    gettimeofday(&m_startTime, 0);
}

double Timer::GetTimeInMs() const
{
    struct timeval currentTime;
    gettimeofday(&currentTime, 0);

	double const dsecs = currentTime.tv_sec - m_startTime.tv_sec;
    double const dus = currentTime.tv_usec - m_startTime.tv_usec;

	return (dsecs * 1000.0) + (dus / 1000.0);
}

void TimeHelpers::SleepMs(int ms)
{
    usleep(ms * 1000);
}

}

```

`ThirdParty/UnitTest++/UnitTest++/Posix/TimeHelpers.h`:

```h
#ifndef UNITTEST_TIMEHELPERS_H
#define UNITTEST_TIMEHELPERS_H

#include <sys/time.h>

namespace UnitTest {

class Timer
{
public:
    Timer();
    void Start();
    double GetTimeInMs() const;    

private:
    struct timeval m_startTime;    
};


namespace TimeHelpers
{
	void SleepMs(int ms);
}


}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/ReportAssert.cpp`:

```cpp
#include "ReportAssert.h"
#include "ReportAssertImpl.h"
#include "AssertException.h"
#include "CurrentTest.h"
#include "TestResults.h"
#include "TestDetails.h"

#ifdef UNITTEST_NO_EXCEPTIONS
	#include "ReportAssertImpl.h"
#endif

namespace UnitTest {

namespace
{
	bool& AssertExpectedFlag()
	{
		static bool s_assertExpected = false;
		return s_assertExpected;
	}
}

UNITTEST_LINKAGE void ReportAssert(char const* description, char const* filename, int lineNumber)
{
	Detail::ReportAssertEx(CurrentTest::Results(), CurrentTest::Details(), 
						   description, filename, lineNumber);
}

namespace Detail {

#ifdef UNITTEST_NO_EXCEPTIONS
UNITTEST_JMPBUF* GetAssertJmpBuf()
{
	static UNITTEST_JMPBUF s_jmpBuf;
	return &s_jmpBuf;
}
#endif

UNITTEST_LINKAGE void ReportAssertEx(TestResults* testResults,
									 const TestDetails* testDetails,
									 char const* description,
									 char const* filename,
									 int lineNumber)
{
	if (AssertExpectedFlag() == false)
	{
		TestDetails assertDetails(testDetails->testName, testDetails->suiteName, filename, lineNumber);
		testResults->OnTestFailure(assertDetails, description);
	}

	ExpectAssert(false);

#ifndef UNITTEST_NO_EXCEPTIONS
	throw AssertException();
#else
	UNITTEST_JUMP_TO_ASSERT_JUMP_TARGET();
#endif
}

UNITTEST_LINKAGE void ExpectAssert(bool expected)
{
	AssertExpectedFlag() = expected;
}

UNITTEST_LINKAGE bool AssertExpected()
{
	return AssertExpectedFlag();
}

}}

```

`ThirdParty/UnitTest++/UnitTest++/ReportAssert.h`:

```h
#ifndef UNITTEST_ASSERT_H
#define UNITTEST_ASSERT_H

#include "HelperMacros.h"

namespace UnitTest {

UNITTEST_LINKAGE void ReportAssert(char const* description, char const* filename, int lineNumber);

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/ReportAssertImpl.h`:

```h
#ifndef UNITTEST_REPORTASSERTIMPL_H
#define UNITTEST_REPORTASSERTIMPL_H

#include "Config.h"
#include "HelperMacros.h"

#ifdef UNITTEST_NO_EXCEPTIONS
	#include <csetjmp>
#endif

namespace UnitTest {

class TestResults;
class TestDetails;

namespace Detail {

UNITTEST_LINKAGE void ExpectAssert(bool expected);

UNITTEST_LINKAGE void ReportAssertEx(TestResults* testResults, 
									 const TestDetails* testDetails,
									 char const* description, 
									 char const* filename, 
									 int lineNumber);

UNITTEST_LINKAGE bool AssertExpected();

#ifdef UNITTEST_NO_EXCEPTIONS
	UNITTEST_LINKAGE UNITTEST_JMPBUF* GetAssertJmpBuf();

	#ifdef UNITTEST_WIN32
		#define UNITTEST_SET_ASSERT_JUMP_TARGET() \
			__pragma(warning(push)) __pragma(warning(disable:4611)) \
			UNITTEST_SETJMP(*UnitTest::Detail::GetAssertJmpBuf()) \
			__pragma(warning(pop))
	#else
		#define UNITTEST_SET_ASSERT_JUMP_TARGET() UNITTEST_SETJMP(*UnitTest::Detail::GetAssertJmpBuf())
	#endif

	#define UNITTEST_JUMP_TO_ASSERT_JUMP_TARGET() UNITTEST_LONGJMP(*UnitTest::Detail::GetAssertJmpBuf(), 1)
#endif

}
}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/Test.cpp`:

```cpp
#include "Config.h"
#include "Test.h"
#include "TestList.h"
#include "TestResults.h"
#include "AssertException.h"
#include "MemoryOutStream.h"
#include "ExecuteTest.h"

#ifdef UNITTEST_POSIX
    #include "Posix/SignalTranslator.h"
#endif

namespace UnitTest {

TestList& Test::GetTestList()
{
    static TestList s_list;
    return s_list;
}

Test::Test(char const* testName, char const* suiteName, char const* filename, int lineNumber)
    : m_details(testName, suiteName, filename, lineNumber)
    , m_nextTest(0)
	, m_isMockTest(false)
{
}

Test::~Test()
{
}

void Test::Run()
{
	ExecuteTest(*this, m_details, m_isMockTest);
}

void Test::RunImpl() const
{
}

}

```

`ThirdParty/UnitTest++/UnitTest++/Test.h`:

```h
#ifndef UNITTEST_TEST_H
#define UNITTEST_TEST_H

#include "TestDetails.h"

namespace UnitTest {

class TestResults;
class TestList;

class UNITTEST_LINKAGE Test
{
public:
    explicit Test(char const* testName, char const* suiteName = "DefaultSuite", char const* filename = "", int lineNumber = 0);
    virtual ~Test();
    void Run();

    TestDetails const m_details;
    Test* m_nextTest;

	mutable bool m_isMockTest;

    static TestList& GetTestList();

    virtual void RunImpl() const;

private:
	Test(Test const&);
    Test& operator =(Test const&);
};


}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/TestDetails.cpp`:

```cpp
#include "TestDetails.h"

namespace UnitTest {

TestDetails::TestDetails(char const* testName_, char const* suiteName_, char const* filename_, int lineNumber_)
    : suiteName(suiteName_)
    , testName(testName_)
    , filename(filename_)
    , lineNumber(lineNumber_)
    , timeConstraintExempt(false)
{
}

TestDetails::TestDetails(const TestDetails& details, int lineNumber_)
    : suiteName(details.suiteName)
    , testName(details.testName)
    , filename(details.filename)
    , lineNumber(lineNumber_)
    , timeConstraintExempt(details.timeConstraintExempt)
{
}


}

```

`ThirdParty/UnitTest++/UnitTest++/TestDetails.h`:

```h
#ifndef UNITTEST_TESTDETAILS_H
#define UNITTEST_TESTDETAILS_H

#include "HelperMacros.h"

namespace UnitTest {

class UNITTEST_LINKAGE TestDetails
{
public:
    TestDetails(char const* testName, char const* suiteName, char const* filename, int lineNumber);
    TestDetails(const TestDetails& details, int lineNumber);

    char const* const suiteName;
    char const* const testName;
    char const* const filename;
    int const lineNumber;
    mutable bool timeConstraintExempt;

    TestDetails(TestDetails const&); // Why is it public? --> http://gcc.gnu.org/bugs.html#cxx_rvalbind
private:
    TestDetails& operator=(TestDetails const&);
};

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/TestList.cpp`:

```cpp
#include "TestList.h"
#include "Test.h"

#include <cassert>

namespace UnitTest {

TestList::TestList() 
    : m_head(0)
    , m_tail(0)
{
}

void TestList::Add(Test* test)
{
    if (m_tail == 0)
    {
        assert(m_head == 0);
        m_head = test;
        m_tail = test;
    }
    else
    {
        m_tail->m_nextTest = test;
        m_tail = test;
    }
}

Test* TestList::GetHead() const
{
    return m_head;
}

ListAdder::ListAdder(TestList& list, Test* test)
{
    list.Add(test);
}

}

```

`ThirdParty/UnitTest++/UnitTest++/TestList.h`:

```h
#ifndef UNITTEST_TESTLIST_H
#define UNITTEST_TESTLIST_H

#include "HelperMacros.h"

namespace UnitTest {

class Test;

class UNITTEST_LINKAGE TestList
{
public:
    TestList();
    void Add (Test* test);

    Test* GetHead() const;

private:
    Test* m_head;
    Test* m_tail;
};


class UNITTEST_LINKAGE ListAdder
{
public:
    ListAdder(TestList& list, Test* test);
};

}


#endif

```

`ThirdParty/UnitTest++/UnitTest++/TestMacros.h`:

```h
#ifndef UNITTEST_TESTMACROS_H
#define UNITTEST_TESTMACROS_H

#include "Config.h"
#include "TestSuite.h"
#include "ExceptionMacros.h"
#include "ExecuteTest.h"
#include "AssertException.h"
#include "TestDetails.h"
#include "MemoryOutStream.h"

#ifndef UNITTEST_POSIX
	#define UNITTEST_THROW_SIGNALS_POSIX_ONLY
#else
	#include "Posix/SignalTranslator.h"
#endif

#ifdef TEST
    #error UnitTest++ redefines TEST
#endif

#ifdef TEST_EX
	#error UnitTest++ redefines TEST_EX
#endif

#ifdef TEST_FIXTURE_EX
	#error UnitTest++ redefines TEST_FIXTURE_EX
#endif

#define SUITE(Name)                                                         \
	namespace Suite##Name {                                                        \
        namespace UnitTestSuite {                                           \
            inline char const* GetSuiteName () {                            \
                return #Name ;                                              \
            }                                                               \
        }                                                                   \
    }                                                                       \
	namespace Suite##Name

#define TEST_EX(Name, List)                                                \
    class Test##Name : public UnitTest::Test                               \
    {                                                                      \
    public:                                                                \
		Test##Name() : Test(#Name, UnitTestSuite::GetSuiteName(), __FILE__, __LINE__) {}  \
    private:                                                               \
        virtual void RunImpl() const;   \
    } test##Name##Instance;                                                \
																		   \
    UnitTest::ListAdder adder##Name (List, &test##Name##Instance);         \
																		   \
    void Test##Name::RunImpl() const


#define TEST(Name) TEST_EX(Name, UnitTest::Test::GetTestList())


#define TEST_FIXTURE_EX(Fixture, Name, List)                                         \
    class Fixture##Name##Helper : public Fixture									 \
	{																				 \
	public:																			 \
        explicit Fixture##Name##Helper(UnitTest::TestDetails const& details) : m_details(details) {} \
        void RunImpl();                           \
        UnitTest::TestDetails const& m_details;                                      \
    private:                                                                         \
        Fixture##Name##Helper(Fixture##Name##Helper const&);                         \
        Fixture##Name##Helper& operator =(Fixture##Name##Helper const&);             \
    };                                                                               \
																					 \
    class Test##Fixture##Name : public UnitTest::Test                                \
    {                                                                                \
    public:                                                                          \
	    Test##Fixture##Name() : Test(#Name, UnitTestSuite::GetSuiteName(), __FILE__, __LINE__) {} \
    private:                                                                         \
        virtual void RunImpl() const;             \
    } test##Fixture##Name##Instance;                                                 \
																					 \
    UnitTest::ListAdder adder##Fixture##Name (List, &test##Fixture##Name##Instance); \
																					 \
    void Test##Fixture##Name::RunImpl() const	 \
	{																				 \
		volatile bool ctorOk = false;												 \
		UT_TRY \
		({ \
			Fixture##Name##Helper fixtureHelper(m_details);							 \
			ctorOk = true;															 \
			UnitTest::ExecuteTest(fixtureHelper, m_details, false);					 \
		}) \
		UT_CATCH (UnitTest::AssertException, e, \
		{ \
			(void)e;	\
		}) \
		UT_CATCH (std::exception, e, \
		{ \
			UnitTest::MemoryOutStream stream;													 \
			stream << "Unhandled exception: " << e.what();							 \
			UnitTest::CurrentTest::Results()->OnTestFailure(m_details, stream.GetText());				 \
		}) \
		UT_CATCH_ALL \
		({ \
			if (ctorOk)																 \
			{																		 \
	            UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(m_details, __LINE__),	 \
					"Unhandled exception while destroying fixture " #Fixture);		 \
			}																		 \
			else																	 \
			{																		 \
				UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(m_details, __LINE__),   \
					"Unhandled exception while constructing fixture " #Fixture);         \
			}																		 \
		}) \
    }                                                                                \
    void Fixture##Name##Helper::RunImpl()

#define TEST_FIXTURE(Fixture,Name) TEST_FIXTURE_EX(Fixture, Name, UnitTest::Test::GetTestList())


#endif

```

`ThirdParty/UnitTest++/UnitTest++/TestReporter.cpp`:

```cpp
#include "TestReporter.h"

namespace UnitTest {

TestReporter::~TestReporter()
{
}

}

```

`ThirdParty/UnitTest++/UnitTest++/TestReporter.h`:

```h
#ifndef UNITTEST_TESTREPORTER_H
#define UNITTEST_TESTREPORTER_H

#include "HelperMacros.h"

namespace UnitTest {

class TestDetails;

class UNITTEST_LINKAGE TestReporter
{
public:
    virtual ~TestReporter();

    virtual void ReportTestStart(TestDetails const& test) = 0;
    virtual void ReportFailure(TestDetails const& test, char const* failure) = 0;
    virtual void ReportTestFinish(TestDetails const& test, float secondsElapsed) = 0;
    virtual void ReportSummary(int totalTestCount, int failedTestCount, int failureCount, float secondsElapsed) = 0;
};

}
#endif

```

`ThirdParty/UnitTest++/UnitTest++/TestReporterStdout.cpp`:

```cpp
#include "TestReporterStdout.h"
#include <cstdio>

#include "TestDetails.h"

#ifdef _XBOX_ONE
#include <windows.h>
#include <assert.h>
#endif

// cstdio doesn't pull in namespace std on VC6, so we do it here.
#if defined(UNITTEST_WIN32) && (_MSC_VER == 1200)
	namespace std {}
#endif

namespace UnitTest {

void TestReporterStdout::ReportFailure(TestDetails const& details, char const* failure)
{
#ifdef _XBOX_ONE
	details;
	failure;
	OutputDebugStringA("Failed ");
	OutputDebugStringA(failure);
	OutputDebugStringA("\n");
	//assert(false);
#else

    using namespace std;
#if defined(__APPLE__) || defined(__GNUG__)
    char const* const errorFormat = "%s:%d:%d: error: Failure in %s: %s\n";
    fprintf(stderr, errorFormat, details.filename, details.lineNumber, 1, details.testName, failure);
#else
    char const* const errorFormat = "%s(%d): error: Failure in %s: %s\n";
    fprintf(stderr, errorFormat, details.filename, details.lineNumber, details.testName, failure);
#endif
#endif
}

void TestReporterStdout::ReportTestStart(TestDetails const& details/*test*/)
{
#ifdef _XBOX_ONE
	OutputDebugStringA("\n=> Test: ");
	OutputDebugStringA(details.testName);
	OutputDebugStringA("\n");
#else
	printf("\n=> Test: %s\n", details.testName);
#endif
}

void TestReporterStdout::ReportTestFinish(TestDetails const& /*test*/, float delta)
{
#ifdef _XBOX_ONE
	char msg[128];
	sprintf(msg, "=> Finished in %3.2f sec\n", delta);
	OutputDebugStringA(msg);
#else
	printf("=> Finished in %3.2f sec\n", delta);
#endif
}

void TestReporterStdout::ReportSummary(int const totalTestCount, int const failedTestCount,
                                       int const failureCount, float const secondsElapsed)
{
	using namespace std;

    if (failureCount > 0)
        printf("FAILURE: %d out of %d tests failed (%d failures).\n", failedTestCount, totalTestCount, failureCount);
    else
        printf("Success: %d tests passed.\n", totalTestCount);

#ifdef _XBOX_ONE
	char msg[128];
	sprintf(msg, "Test time: %.2f seconds.\n", secondsElapsed);
	OutputDebugStringA(msg);
#else
    printf("Test time: %.2f seconds.\n", secondsElapsed);
#endif
}

}

```

`ThirdParty/UnitTest++/UnitTest++/TestReporterStdout.h`:

```h
#ifndef UNITTEST_TESTREPORTERSTDOUT_H
#define UNITTEST_TESTREPORTERSTDOUT_H

#include "TestReporter.h"

namespace UnitTest {

class UNITTEST_LINKAGE TestReporterStdout : public TestReporter
{
private:
    virtual void ReportTestStart(TestDetails const& test);
    virtual void ReportFailure(TestDetails const& test, char const* failure);
    virtual void ReportTestFinish(TestDetails const& test, float secondsElapsed);
    virtual void ReportSummary(int totalTestCount, int failedTestCount, int failureCount, float secondsElapsed);
};

}

#endif 

```

`ThirdParty/UnitTest++/UnitTest++/TestResults.cpp`:

```cpp
#include "TestResults.h"
#include "TestReporter.h"

#include "TestDetails.h"

namespace UnitTest {

TestResults::TestResults(TestReporter* testReporter)
    : m_testReporter(testReporter)
    , m_totalTestCount(0)
    , m_failedTestCount(0)
    , m_failureCount(0)
    , m_currentTestFailed(false)
{
}

void TestResults::OnTestStart(TestDetails const& test)
{
    ++m_totalTestCount;
    m_currentTestFailed = false;
    if (m_testReporter)
        m_testReporter->ReportTestStart(test);
}

void TestResults::OnTestFailure(TestDetails const& test, char const* failure)
{
    ++m_failureCount;
    if (!m_currentTestFailed)
    {
        ++m_failedTestCount;
        m_currentTestFailed = true;
    }

    if (m_testReporter)
        m_testReporter->ReportFailure(test, failure);
}

void TestResults::OnTestFinish(TestDetails const& test, float secondsElapsed)
{
    if (m_testReporter)
        m_testReporter->ReportTestFinish(test, secondsElapsed);
}

int TestResults::GetTotalTestCount() const
{
    return m_totalTestCount;
}

int TestResults::GetFailedTestCount() const
{
    return m_failedTestCount;
}

int TestResults::GetFailureCount() const
{
    return m_failureCount;
}


}

```

`ThirdParty/UnitTest++/UnitTest++/TestResults.h`:

```h
#ifndef UNITTEST_TESTRESULTS_H
#define UNITTEST_TESTRESULTS_H

#include "HelperMacros.h"

namespace UnitTest {

class TestReporter;
class TestDetails;

class UNITTEST_LINKAGE TestResults
{
public:
    explicit TestResults(TestReporter* reporter = 0);

    void OnTestStart(TestDetails const& test);
    void OnTestFailure(TestDetails const& test, char const* failure);
    void OnTestFinish(TestDetails const& test, float secondsElapsed);

    int GetTotalTestCount() const;
    int GetFailedTestCount() const;
    int GetFailureCount() const;

private:
    TestReporter* m_testReporter;
    int m_totalTestCount;
    int m_failedTestCount;
    int m_failureCount;

    bool m_currentTestFailed;

    TestResults(TestResults const&);
    TestResults& operator =(TestResults const&);
};

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/TestRunner.cpp`:

```cpp
#include "TestRunner.h"
#include "TestResults.h"
#include "TestReporter.h"
#include "TestReporterStdout.h"
#include "TimeHelpers.h"
#include "MemoryOutStream.h"

#include <cstring>


namespace UnitTest {

int RunAllTests()
{
	TestReporterStdout reporter;
	TestRunner runner(reporter);
	return runner.RunTestsIf(Test::GetTestList(), NULL, True(), 0);
}


TestRunner::TestRunner(TestReporter& reporter)
	: m_reporter(&reporter)
	, m_result(new TestResults(&reporter))
	, m_timer(new Timer)
{
	m_timer->Start();
}

TestRunner::~TestRunner()
{
	delete m_result;
	delete m_timer;
}

TestResults* TestRunner::GetTestResults()
{
	return m_result;
}

int TestRunner::Finish() const
{
    float const secondsElapsed = static_cast<float>(m_timer->GetTimeInMs() / 1000.0);
    m_reporter->ReportSummary(m_result->GetTotalTestCount(), 
							  m_result->GetFailedTestCount(), 
							  m_result->GetFailureCount(), 
							  secondsElapsed);
    
	return m_result->GetFailureCount();
}

bool TestRunner::IsTestInSuite(const Test* const curTest, char const* suiteName) const
{
	using namespace std;
	return (suiteName == NULL) || !strcmp(curTest->m_details.suiteName, suiteName);
}

void TestRunner::RunTest(TestResults* const result, Test* const curTest, int const maxTestTimeInMs) const
{
	if (curTest->m_isMockTest == false)
		CurrentTest::Results() = result;

	Timer testTimer;
	testTimer.Start();

	result->OnTestStart(curTest->m_details);

	curTest->Run();

	double const testTimeInMs = testTimer.GetTimeInMs();
	if (maxTestTimeInMs > 0 && testTimeInMs > maxTestTimeInMs && !curTest->m_details.timeConstraintExempt)
	{
	    MemoryOutStream stream;
	    stream << "Global time constraint failed. Expected under " << maxTestTimeInMs <<
	            "ms but took " << testTimeInMs << "ms.";

	    result->OnTestFailure(curTest->m_details, stream.GetText());
	}

	result->OnTestFinish(curTest->m_details, static_cast< float >(testTimeInMs / 1000.0));
}

}

```

`ThirdParty/UnitTest++/UnitTest++/TestRunner.h`:

```h
#ifndef UNITTEST_TESTRUNNER_H
#define UNITTEST_TESTRUNNER_H

#include "Test.h"
#include "TestList.h"
#include "CurrentTest.h"

namespace UnitTest {

class TestReporter;
class TestResults;
class Timer;

UNITTEST_LINKAGE int RunAllTests();

struct True
{
	bool operator()(const Test* const) const
	{
		return true;	
	}
};

class UNITTEST_LINKAGE TestRunner
{
public:
	explicit TestRunner(TestReporter& reporter);
	~TestRunner();

	template< class Predicate >
	int RunTestsIf(TestList const& list, char const* suiteName, 
				   const Predicate& predicate, int maxTestTimeInMs) const
	{
	    Test* curTest = list.GetHead();

	    while (curTest != 0)
	    {
		    if (IsTestInSuite(curTest, suiteName) && predicate(curTest))
				RunTest(m_result, curTest, maxTestTimeInMs);

			curTest = curTest->m_nextTest;
	    }

	    return Finish();
	}	

	TestResults* GetTestResults();

private:
	TestReporter* m_reporter;
	TestResults* m_result;
	Timer* m_timer;

	int Finish() const;
	bool IsTestInSuite(const Test* const curTest, char const* suiteName) const;
	void RunTest(TestResults* const result, Test* const curTest, int const maxTestTimeInMs) const;
};

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/TestSuite.h`:

```h
#ifndef UNITTEST_TESTSUITE_H
#define UNITTEST_TESTSUITE_H

namespace UnitTestSuite 
{
    inline char const* GetSuiteName ()
    {
        return "DefaultSuite";
    }
}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/TimeConstraint.cpp`:

```cpp
#include "TimeConstraint.h"
#include "TestResults.h"
#include "MemoryOutStream.h"
#include "CurrentTest.h"

namespace UnitTest {


TimeConstraint::TimeConstraint(int ms, TestDetails const& details)
	: m_details(details)
    , m_maxMs(ms)
{
    m_timer.Start();
}

TimeConstraint::~TimeConstraint()
{
    double const totalTimeInMs = m_timer.GetTimeInMs();
    if (totalTimeInMs > m_maxMs)
    {
        MemoryOutStream stream;
        stream << "Time constraint failed. Expected to run test under " << m_maxMs <<
                  "ms but took " << totalTimeInMs << "ms.";

		CurrentTest::Results()->OnTestFailure(m_details, stream.GetText());
    }
}

}

```

`ThirdParty/UnitTest++/UnitTest++/TimeConstraint.h`:

```h
#ifndef UNITTEST_TIMECONSTRAINT_H
#define UNITTEST_TIMECONSTRAINT_H

#include "TimeHelpers.h"
#include "HelperMacros.h"

namespace UnitTest {

class TestResults;
class TestDetails;

class UNITTEST_LINKAGE TimeConstraint
{
public:
    TimeConstraint(int ms, TestDetails const& details);
    ~TimeConstraint();

private:
    void operator=(TimeConstraint const&); 
	TimeConstraint(TimeConstraint const&);

	Timer m_timer;
    TestDetails const& m_details;
	int const m_maxMs;
};

#define UNITTEST_TIME_CONSTRAINT(ms) \
	UnitTest::TimeConstraint unitTest__timeConstraint__(ms, UnitTest::TestDetails(m_details, __LINE__))

#define UNITTEST_TIME_CONSTRAINT_EXEMPT() \
	UNITTEST_MULTILINE_MACRO_BEGIN \
	m_details.timeConstraintExempt = true; \
	UNITTEST_MULTILINE_MACRO_END

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/TimeHelpers.h`:

```h
#include "Config.h"

#if defined UNITTEST_POSIX
    #include "Posix/TimeHelpers.h"
#else
    #include "Win32/TimeHelpers.h"
#endif

```

`ThirdParty/UnitTest++/UnitTest++/UnitTest++.h`:

```h
#include "UnitTestPP.h"
```

`ThirdParty/UnitTest++/UnitTest++/UnitTestPP.h`:

```h
#ifndef UNITTESTPP_H
#define UNITTESTPP_H

#include "Config.h"
#include "TestMacros.h"
#include "CheckMacros.h"
#include "TestRunner.h"
#include "TimeConstraint.h"
#include "ReportAssert.h"

#endif

```

`ThirdParty/UnitTest++/UnitTest++/UnitTestTimer.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN
#include <windows.h>


namespace Time
{
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline __int64 GetTime()
	{
		LARGE_INTEGER largeInteger;
		QueryPerformanceCounter( &largeInteger );
		return largeInteger.QuadPart;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline __int64 GetFrequency()
	{
		LARGE_INTEGER frequency;
		QueryPerformanceFrequency(&frequency);
		return frequency.QuadPart;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline __int64 GetTimeMilliSeconds()
	{
		LARGE_INTEGER largeInteger;
		QueryPerformanceCounter( &largeInteger );
		return ( largeInteger.QuadPart * __int64(1000) ) / GetFrequency();
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline __int64 GetTimeMicroSeconds()
	{
		LARGE_INTEGER largeInteger;
		QueryPerformanceCounter( &largeInteger );
		return ( largeInteger.QuadPart * __int64(1000000) ) / GetFrequency();
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	inline void SpinSleep(size_t microSeconds)
	{
		__int64 time = GetTimeMicroSeconds() + microSeconds;
		while(GetTimeMicroSeconds() < time)
		{
			Sleep(0);
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

```

`ThirdParty/UnitTest++/UnitTest++/Win32/TimeHelpers.cpp`:

```cpp
#include "TimeHelpers.h"

#ifndef WIN32_LEAN_AND_MEAN
	#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>

namespace UnitTest {

Timer::Timer()
	: m_threadHandle(::GetCurrentThread())
	, m_startTime(0)
{
#if defined(UNITTEST_WIN32) && (_MSC_VER == 1200) // VC6 doesn't have DWORD_PTR
	typedef unsigned long DWORD_PTR;
#endif

	DWORD_PTR systemMask;
	::GetProcessAffinityMask(GetCurrentProcess(), &m_processAffinityMask, &systemMask);
	::SetThreadAffinityMask(m_threadHandle, 1);
	::QueryPerformanceFrequency(reinterpret_cast< LARGE_INTEGER* >(&m_frequency));
	::SetThreadAffinityMask(m_threadHandle, m_processAffinityMask);
}

void Timer::Start()
{
	m_startTime = GetTime();
}

double Timer::GetTimeInMs() const
{
	__int64 const elapsedTime = GetTime() - m_startTime;
	double const seconds = double(elapsedTime) / double(m_frequency);
	return seconds * 1000.0;
}

__int64 Timer::GetTime() const
{
	LARGE_INTEGER curTime;
	::SetThreadAffinityMask(m_threadHandle, 1);
	::QueryPerformanceCounter(&curTime);
	::SetThreadAffinityMask(m_threadHandle, m_processAffinityMask);
	return curTime.QuadPart;
}

void TimeHelpers::SleepMs(int ms)
{
	::Sleep(ms);
}

}

```

`ThirdParty/UnitTest++/UnitTest++/Win32/TimeHelpers.h`:

```h
#ifndef UNITTEST_TIMEHELPERS_H
#define UNITTEST_TIMEHELPERS_H

#include "../Config.h"
#include "../HelperMacros.h"

#ifdef UNITTEST_MINGW
    #ifndef __int64
        #define __int64 long long
    #endif
#endif

namespace UnitTest {

class UNITTEST_LINKAGE Timer
{
public:
    Timer();
	void Start();
	double GetTimeInMs() const;    

private:
    __int64 GetTime() const;

    void* m_threadHandle;

#if defined(_WIN64)
    unsigned __int64 m_processAffinityMask;
#else
    unsigned long m_processAffinityMask;
#endif

	__int64 m_startTime;
	__int64 m_frequency;
};


namespace TimeHelpers
{
	UNITTEST_LINKAGE void SleepMs(int ms);
}

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/XmlTestReporter.cpp`:

```cpp
#include "Config.h"
#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "XmlTestReporter.h"

#include <iostream>
#include <sstream>
#include <string>

using std::string;
using std::ostringstream;
using std::ostream;

namespace {

void ReplaceChar(string& str, char c, string const& replacement)
{
    for (size_t pos = str.find(c); pos != string::npos; pos = str.find(c, pos + 1))
        str.replace(pos, 1, replacement);
}

string XmlEscape(string const& value)
{
    string escaped = value;

    ReplaceChar(escaped, '&', "&amp;");
    ReplaceChar(escaped, '<', "&lt;");
    ReplaceChar(escaped, '>', "&gt;");
    ReplaceChar(escaped, '\'', "&apos;");
    ReplaceChar(escaped, '\"', "&quot;");
 
    return escaped;
}

string BuildFailureMessage(string const& file, int line, string const& message)
{
    ostringstream failureMessage;
    failureMessage << file << "(" << line << ") : " << message;
    return failureMessage.str();
}

}

namespace UnitTest {

XmlTestReporter::XmlTestReporter(ostream& ostream)
    : m_ostream(ostream)
{
}

void XmlTestReporter::ReportSummary(int totalTestCount, int failedTestCount,
                                    int failureCount, float secondsElapsed)
{
    AddXmlElement(m_ostream, NULL);

    BeginResults(m_ostream, totalTestCount, failedTestCount, failureCount, secondsElapsed);

    DeferredTestResultList const& results = GetResults();
    for (DeferredTestResultList::const_iterator i = results.begin(); i != results.end(); ++i)
    {
        BeginTest(m_ostream, *i);

        if (i->failed)
            AddFailure(m_ostream, *i);

        EndTest(m_ostream, *i);
    }

    EndResults(m_ostream);
}

void XmlTestReporter::AddXmlElement(ostream& os, char const* encoding)
{
    os << "<?xml version=\"1.0\"";

    if (encoding != NULL)
        os << " encoding=\"" << encoding << "\"";

    os << "?>";
}

void XmlTestReporter::BeginResults(std::ostream& os, int totalTestCount, int failedTestCount, 
                                   int failureCount, float secondsElapsed)
{
   os << "<unittest-results"
       << " tests=\"" << totalTestCount << "\"" 
       << " failedtests=\"" << failedTestCount << "\"" 
       << " failures=\"" << failureCount << "\"" 
       << " time=\"" << secondsElapsed << "\""
       << ">";
}

void XmlTestReporter::EndResults(std::ostream& os)
{
    os << "</unittest-results>";
}

void XmlTestReporter::BeginTest(std::ostream& os, DeferredTestResult const& result)
{
    os << "<test"
        << " suite=\"" << result.suiteName << "\"" 
        << " name=\"" << result.testName << "\""
        << " time=\"" << result.timeElapsed << "\"";
}

void XmlTestReporter::EndTest(std::ostream& os, DeferredTestResult const& result)
{
    if (result.failed)
        os << "</test>";
    else
        os << "/>";
}

void XmlTestReporter::AddFailure(std::ostream& os, DeferredTestResult const& result)
{
    os << ">"; // close <test> element

    for (DeferredTestResult::FailureVec::const_iterator it = result.failures.begin(); 
         it != result.failures.end(); 
         ++it)
    {
		string const escapedMessage = XmlEscape(std::string(it->failureStr));
        string const message = BuildFailureMessage(result.failureFile, it->lineNumber, escapedMessage);

        os << "<failure" << " message=\"" << message << "\"" << "/>";
    }
}

}

#endif

```

`ThirdParty/UnitTest++/UnitTest++/XmlTestReporter.h`:

```h
#ifndef UNITTEST_XMLTESTREPORTER_H
#define UNITTEST_XMLTESTREPORTER_H

#include "Config.h"
#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "DeferredTestReporter.h"

#include <iosfwd>

namespace UnitTest
{

class UNITTEST_LINKAGE XmlTestReporter : public DeferredTestReporter
{
public:
    explicit XmlTestReporter(std::ostream& ostream);

    virtual void ReportSummary(int totalTestCount, int failedTestCount, int failureCount, float secondsElapsed);

private:
    XmlTestReporter(XmlTestReporter const&);
    XmlTestReporter& operator=(XmlTestReporter const&);

    void AddXmlElement(std::ostream& os, char const* encoding);
    void BeginResults(std::ostream& os, int totalTestCount, int failedTestCount, int failureCount, float secondsElapsed);
    void EndResults(std::ostream& os);
    void BeginTest(std::ostream& os, DeferredTestResult const& result);
    void AddFailure(std::ostream& os, DeferredTestResult const& result);
    void EndTest(std::ostream& os, DeferredTestResult const& result);

    std::ostream& m_ostream;
};

}

#endif
#endif

```

`ThirdParty/UnitTest++/UnitTest++/unittestpp_vs2005.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="unittestpp_vs2005"
	ProjectGUID="{64A4FEFE-0461-4E95-8CC1-91EF5F57DBC6}"
	RootNamespace="unittestpp"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="win32_static_vc80_md_debug|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				MinimalRebuild="true"
				ExceptionHandling="2"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_static_vc80_md_release|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			WholeProgramOptimization="0"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				ExceptionHandling="2"
				RuntimeLibrary="2"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_dll_vc80_debug|Win32"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;UNITTEST_DLL_EXPORT"
				MinimalRebuild="true"
				ExceptionHandling="2"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\unittestpp.dll"
				GenerateDebugInformation="true"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_dll_vc80_release|Win32"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="0"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="WIN32;NDEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;UNITTEST_DLL_EXPORT"
				ExceptionHandling="2"
				RuntimeLibrary="2"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\unittestpp.dll"
				GenerateDebugInformation="true"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_static_vc80_mt_debug|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				MinimalRebuild="true"
				ExceptionHandling="2"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_static_vc80_mt_release|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			WholeProgramOptimization="0"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				ExceptionHandling="2"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Win32"
			>
			<File
				RelativePath=".\Win32\TimeHelpers.cpp"
				>
			</File>
			<File
				RelativePath=".\Win32\TimeHelpers.h"
				>
			</File>
		</Filter>
		<File
			RelativePath=".\AssertException.cpp"
			>
		</File>
		<File
			RelativePath=".\AssertException.h"
			>
		</File>
		<File
			RelativePath=".\CheckMacros.h"
			>
		</File>
		<File
			RelativePath=".\Checks.cpp"
			>
		</File>
		<File
			RelativePath=".\Checks.h"
			>
		</File>
		<File
			RelativePath=".\CompositeTestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\CompositeTestReporter.h"
			>
		</File>
		<File
			RelativePath="..\config.h"
			>
		</File>
		<File
			RelativePath=".\CurrentTest.cpp"
			>
		</File>
		<File
			RelativePath=".\CurrentTest.h"
			>
		</File>
		<File
			RelativePath=".\DeferredTestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\DeferredTestReporter.h"
			>
		</File>
		<File
			RelativePath=".\DeferredTestResult.cpp"
			>
		</File>
		<File
			RelativePath=".\DeferredTestResult.h"
			>
		</File>
		<File
			RelativePath=".\ExceptionMacros.h"
			>
		</File>
		<File
			RelativePath=".\ExecuteTest.h"
			>
		</File>
		<File
			RelativePath=".\HelperMacros.h"
			>
		</File>
		<File
			RelativePath=".\MemoryOutStream.cpp"
			>
		</File>
		<File
			RelativePath=".\MemoryOutStream.h"
			>
		</File>
		<File
			RelativePath=".\ReportAssert.cpp"
			>
		</File>
		<File
			RelativePath=".\ReportAssert.h"
			>
		</File>
		<File
			RelativePath=".\ReportAssertImpl.h"
			>
		</File>
		<File
			RelativePath=".\Test.cpp"
			>
		</File>
		<File
			RelativePath=".\Test.h"
			>
		</File>
		<File
			RelativePath=".\TestDetails.cpp"
			>
		</File>
		<File
			RelativePath=".\TestDetails.h"
			>
		</File>
		<File
			RelativePath=".\TestList.cpp"
			>
		</File>
		<File
			RelativePath=".\TestList.h"
			>
		</File>
		<File
			RelativePath=".\TestMacros.h"
			>
		</File>
		<File
			RelativePath=".\TestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\TestReporter.h"
			>
		</File>
		<File
			RelativePath=".\TestReporterStdout.cpp"
			>
		</File>
		<File
			RelativePath=".\TestReporterStdout.h"
			>
		</File>
		<File
			RelativePath=".\TestResults.cpp"
			>
		</File>
		<File
			RelativePath=".\TestResults.h"
			>
		</File>
		<File
			RelativePath=".\TestRunner.cpp"
			>
		</File>
		<File
			RelativePath=".\TestRunner.h"
			>
		</File>
		<File
			RelativePath=".\TestSuite.h"
			>
		</File>
		<File
			RelativePath=".\TimeConstraint.cpp"
			>
		</File>
		<File
			RelativePath=".\TimeConstraint.h"
			>
		</File>
		<File
			RelativePath=".\TimeHelpers.h"
			>
		</File>
		<File
			RelativePath="..\unittestpp.h"
			>
		</File>
		<File
			RelativePath=".\XmlTestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\XmlTestReporter.h"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`ThirdParty/UnitTest++/UnitTest++/unittestpp_vs2008.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="unittestpp_vs2008"
	ProjectGUID="{64A4FEFE-0461-4E95-8CC1-91EF5F57DBC6}"
	RootNamespace="unittestpp"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="win32_static_vc90_md_debug|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				MinimalRebuild="true"
				ExceptionHandling="2"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_static_vc90_md_release|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			WholeProgramOptimization="0"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				ExceptionHandling="2"
				RuntimeLibrary="2"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_dll_vc90_debug|Win32"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;UNITTEST_DLL_EXPORT"
				MinimalRebuild="true"
				ExceptionHandling="2"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\unittestpp.dll"
				GenerateDebugInformation="true"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_dll_vc90_release|Win32"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="0"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="WIN32;NDEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;UNITTEST_DLL_EXPORT"
				ExceptionHandling="2"
				RuntimeLibrary="2"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\unittestpp.dll"
				GenerateDebugInformation="true"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_static_vc90_mt_debug|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				MinimalRebuild="true"
				ExceptionHandling="2"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="win32_static_vc90_mt_release|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(SolutionDir)obj\$(ProjectName)\$(ConfigurationName)"
			ConfigurationType="4"
			CharacterSet="1"
			WholeProgramOptimization="0"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="3"
				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
				ExceptionHandling="2"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="4"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\unittestpp.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Win32"
			>
			<File
				RelativePath=".\Win32\TimeHelpers.cpp"
				>
			</File>
			<File
				RelativePath=".\Win32\TimeHelpers.h"
				>
			</File>
		</Filter>
		<File
			RelativePath=".\AssertException.cpp"
			>
		</File>
		<File
			RelativePath=".\AssertException.h"
			>
		</File>
		<File
			RelativePath=".\CheckMacros.h"
			>
		</File>
		<File
			RelativePath=".\Checks.cpp"
			>
		</File>
		<File
			RelativePath=".\Checks.h"
			>
		</File>
		<File
			RelativePath=".\CompositeTestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\CompositeTestReporter.h"
			>
		</File>
		<File
			RelativePath="..\config.h"
			>
		</File>
		<File
			RelativePath=".\CurrentTest.cpp"
			>
		</File>
		<File
			RelativePath=".\CurrentTest.h"
			>
		</File>
		<File
			RelativePath=".\DeferredTestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\DeferredTestReporter.h"
			>
		</File>
		<File
			RelativePath=".\DeferredTestResult.cpp"
			>
		</File>
		<File
			RelativePath=".\DeferredTestResult.h"
			>
		</File>
		<File
			RelativePath=".\ExceptionMacros.h"
			>
		</File>
		<File
			RelativePath=".\ExecuteTest.h"
			>
		</File>
		<File
			RelativePath=".\HelperMacros.h"
			>
		</File>
		<File
			RelativePath=".\MemoryOutStream.cpp"
			>
		</File>
		<File
			RelativePath=".\MemoryOutStream.h"
			>
		</File>
		<File
			RelativePath=".\ReportAssert.cpp"
			>
		</File>
		<File
			RelativePath=".\ReportAssert.h"
			>
		</File>
		<File
			RelativePath=".\ReportAssertImpl.h"
			>
		</File>
		<File
			RelativePath=".\Test.cpp"
			>
		</File>
		<File
			RelativePath=".\Test.h"
			>
		</File>
		<File
			RelativePath=".\TestDetails.cpp"
			>
		</File>
		<File
			RelativePath=".\TestDetails.h"
			>
		</File>
		<File
			RelativePath=".\TestList.cpp"
			>
		</File>
		<File
			RelativePath=".\TestList.h"
			>
		</File>
		<File
			RelativePath=".\TestMacros.h"
			>
		</File>
		<File
			RelativePath=".\TestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\TestReporter.h"
			>
		</File>
		<File
			RelativePath=".\TestReporterStdout.cpp"
			>
		</File>
		<File
			RelativePath=".\TestReporterStdout.h"
			>
		</File>
		<File
			RelativePath=".\TestResults.cpp"
			>
		</File>
		<File
			RelativePath=".\TestResults.h"
			>
		</File>
		<File
			RelativePath=".\TestRunner.cpp"
			>
		</File>
		<File
			RelativePath=".\TestRunner.h"
			>
		</File>
		<File
			RelativePath=".\TestSuite.h"
			>
		</File>
		<File
			RelativePath=".\TimeConstraint.cpp"
			>
		</File>
		<File
			RelativePath=".\TimeConstraint.h"
			>
		</File>
		<File
			RelativePath=".\TimeHelpers.h"
			>
		</File>
		<File
			RelativePath="..\unittestpp.h"
			>
		</File>
		<File
			RelativePath=".\XmlTestReporter.cpp"
			>
		</File>
		<File
			RelativePath=".\XmlTestReporter.h"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`ThirdParty/UnitTest++/UnitTest++/unittestpp_vs2008.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="win32_dll_vc90_debug|Win32">
      <Configuration>win32_dll_vc90_debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="win32_dll_vc90_release|Win32">
      <Configuration>win32_dll_vc90_release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="win32_static_vc90_md_debug|Win32">
      <Configuration>win32_static_vc90_md_debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="win32_static_vc90_md_release|Win32">
      <Configuration>win32_static_vc90_md_release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="win32_static_vc90_mt_debug|Win32">
      <Configuration>win32_static_vc90_mt_debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="win32_static_vc90_mt_release|Win32">
      <Configuration>win32_static_vc90_mt_release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{64A4FEFE-0461-4E95-8CC1-91EF5F57DBC6}</ProjectGuid>
    <RootNamespace>unittestpp</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <ProjectName>UnitTest++</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_debug|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_debug|Win32'">$(SolutionDir)obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_release|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_release|Win32'">$(SolutionDir)obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_debug|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_debug|Win32'">$(SolutionDir)obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_release|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_release|Win32'">$(SolutionDir)obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_debug|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_debug|Win32'">$(SolutionDir)obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_release|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_release|Win32'">$(SolutionDir)obj\$(ProjectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <ExceptionHandling>Async</ExceptionHandling>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)unittestpp.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_md_release|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>Async</ExceptionHandling>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)unittestpp.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;UNITTEST_DLL_EXPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <ExceptionHandling>Async</ExceptionHandling>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <OutputFile>$(OutDir)unittestpp.dll</OutputFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='win32_dll_vc90_release|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <PreprocessorDefinitions>WIN32;NDEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;UNITTEST_DLL_EXPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>Async</ExceptionHandling>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <OutputFile>$(OutDir)unittestpp.dll</OutputFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <ExceptionHandling>Async</ExceptionHandling>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)unittestpp.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='win32_static_vc90_mt_release|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>Async</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)unittestpp.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Win32\TimeHelpers.cpp" />
    <ClCompile Include="AssertException.cpp" />
    <ClCompile Include="Checks.cpp" />
    <ClCompile Include="CompositeTestReporter.cpp" />
    <ClCompile Include="CurrentTest.cpp" />
    <ClCompile Include="DeferredTestReporter.cpp" />
    <ClCompile Include="DeferredTestResult.cpp" />
    <ClCompile Include="MemoryOutStream.cpp" />
    <ClCompile Include="ReportAssert.cpp" />
    <ClCompile Include="Test.cpp" />
    <ClCompile Include="TestDetails.cpp" />
    <ClCompile Include="TestList.cpp" />
    <ClCompile Include="TestReporter.cpp" />
    <ClCompile Include="TestReporterStdout.cpp" />
    <ClCompile Include="TestResults.cpp" />
    <ClCompile Include="TestRunner.cpp" />
    <ClCompile Include="TimeConstraint.cpp" />
    <ClCompile Include="XmlTestReporter.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Win32\TimeHelpers.h" />
    <ClInclude Include="AssertException.h" />
    <ClInclude Include="CheckMacros.h" />
    <ClInclude Include="Checks.h" />
    <ClInclude Include="CompositeTestReporter.h" />
    <ClInclude Include="..\config.h" />
    <ClInclude Include="CurrentTest.h" />
    <ClInclude Include="DeferredTestReporter.h" />
    <ClInclude Include="DeferredTestResult.h" />
    <ClInclude Include="ExceptionMacros.h" />
    <ClInclude Include="ExecuteTest.h" />
    <ClInclude Include="HelperMacros.h" />
    <ClInclude Include="MemoryOutStream.h" />
    <ClInclude Include="ReportAssert.h" />
    <ClInclude Include="ReportAssertImpl.h" />
    <ClInclude Include="Test.h" />
    <ClInclude Include="TestDetails.h" />
    <ClInclude Include="TestList.h" />
    <ClInclude Include="TestMacros.h" />
    <ClInclude Include="TestReporter.h" />
    <ClInclude Include="TestReporterStdout.h" />
    <ClInclude Include="TestResults.h" />
    <ClInclude Include="TestRunner.h" />
    <ClInclude Include="TestSuite.h" />
    <ClInclude Include="TimeConstraint.h" />
    <ClInclude Include="TimeHelpers.h" />
    <ClInclude Include="..\unittestpp.h" />
    <ClInclude Include="XmlTestReporter.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ThirdParty/UnitTest++/UnitTest++/unittestpp_vs2008.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Win32">
      <UniqueIdentifier>{8532d556-7b68-49d6-8fca-85f1fc6c4864}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Win32\TimeHelpers.cpp">
      <Filter>Win32</Filter>
    </ClCompile>
    <ClCompile Include="AssertException.cpp" />
    <ClCompile Include="Checks.cpp" />
    <ClCompile Include="CompositeTestReporter.cpp" />
    <ClCompile Include="CurrentTest.cpp" />
    <ClCompile Include="DeferredTestReporter.cpp" />
    <ClCompile Include="DeferredTestResult.cpp" />
    <ClCompile Include="MemoryOutStream.cpp" />
    <ClCompile Include="ReportAssert.cpp" />
    <ClCompile Include="Test.cpp" />
    <ClCompile Include="TestDetails.cpp" />
    <ClCompile Include="TestList.cpp" />
    <ClCompile Include="TestReporter.cpp" />
    <ClCompile Include="TestReporterStdout.cpp" />
    <ClCompile Include="TestResults.cpp" />
    <ClCompile Include="TestRunner.cpp" />
    <ClCompile Include="TimeConstraint.cpp" />
    <ClCompile Include="XmlTestReporter.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Win32\TimeHelpers.h">
      <Filter>Win32</Filter>
    </ClInclude>
    <ClInclude Include="AssertException.h" />
    <ClInclude Include="CheckMacros.h" />
    <ClInclude Include="Checks.h" />
    <ClInclude Include="CompositeTestReporter.h" />
    <ClInclude Include="..\config.h" />
    <ClInclude Include="CurrentTest.h" />
    <ClInclude Include="DeferredTestReporter.h" />
    <ClInclude Include="DeferredTestResult.h" />
    <ClInclude Include="ExceptionMacros.h" />
    <ClInclude Include="ExecuteTest.h" />
    <ClInclude Include="HelperMacros.h" />
    <ClInclude Include="MemoryOutStream.h" />
    <ClInclude Include="ReportAssert.h" />
    <ClInclude Include="ReportAssertImpl.h" />
    <ClInclude Include="Test.h" />
    <ClInclude Include="TestDetails.h" />
    <ClInclude Include="TestList.h" />
    <ClInclude Include="TestMacros.h" />
    <ClInclude Include="TestReporter.h" />
    <ClInclude Include="TestReporterStdout.h" />
    <ClInclude Include="TestResults.h" />
    <ClInclude Include="TestRunner.h" />
    <ClInclude Include="TestSuite.h" />
    <ClInclude Include="TimeConstraint.h" />
    <ClInclude Include="TimeHelpers.h" />
    <ClInclude Include="..\unittestpp.h" />
    <ClInclude Include="XmlTestReporter.h" />
  </ItemGroup>
</Project>
```

`ThirdParty/UnitTest++/builds/.gitignore`:

```
# Ignore everything in this directory
*
# Except this file
!.gitignore

```

`ThirdParty/UnitTest++/configure.ac`:

```ac
#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.

AC_PREREQ([2.69])
AC_INIT([UnitTest++], [1.4.1], [pjohnmeyer@gmail.com])
AC_CONFIG_SRCDIR([UnitTest++/TestDetails.cpp])
AC_CONFIG_MACRO_DIR([m4])
AC_CONFIG_HEADERS([config.h])

AM_INIT_AUTOMAKE([foreign])
LT_INIT()

AC_SUBST([LIBUNITTEST_SO_VERSION], [1:4:1])

# Checks for programs.
AC_PROG_CXX
AC_PROG_CC

# Checks for libraries.

# Checks for header files.
AC_CHECK_HEADERS([sys/time.h unistd.h setjmp.h signal.h cassert cstddef cstdio cstring exception iosfwd iostream sstream string vector])

# Checks for typedefs, structures, and compiler characteristics.
AC_CHECK_HEADER_STDBOOL
AC_C_INLINE
AC_TYPE_SIZE_T

# Checks for library functions.
AC_CHECK_FUNCS([gettimeofday strstr])

AC_CONFIG_FILES([Makefile
		 UnitTest++/Makefile])
AC_OUTPUT

```

`ThirdParty/UnitTest++/tests/Main.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"

int main(int, char const *[])
{
    return UnitTest::RunAllTests();
}

```

`ThirdParty/UnitTest++/tests/RecordingReporter.h`:

```h
#ifndef UNITTEST_RECORDINGREPORTER_H
#define UNITTEST_RECORDINGREPORTER_H

#include "UnitTest++/TestReporter.h"
#include <cstring>

#include "UnitTest++/TestDetails.h"

struct RecordingReporter : public UnitTest::TestReporter
{
private:
    enum { kMaxStringLength = 256 };

public:
    RecordingReporter()
        : testRunCount(0)
        , testFailedCount(0)
        , lastFailedLine(0)
        , testFinishedCount(0)
        , lastFinishedTestTime(0)
        , summaryTotalTestCount(0)
        , summaryFailedTestCount(0)
        , summaryFailureCount(0)
        , summarySecondsElapsed(0)
    {
        lastStartedSuite[0] = '\0';
        lastStartedTest[0] = '\0';
        lastFailedFile[0] = '\0';
        lastFailedSuite[0] = '\0';
        lastFailedTest[0] = '\0';
        lastFailedMessage[0] = '\0';
        lastFinishedSuite[0] = '\0';
        lastFinishedTest[0] = '\0';
    }

    virtual void ReportTestStart(UnitTest::TestDetails const& test)
    {
		using namespace std;

        ++testRunCount;
        strcpy(lastStartedSuite, test.suiteName);
        strcpy(lastStartedTest, test.testName);
    }

    virtual void ReportFailure(UnitTest::TestDetails const& test, char const* failure)
    {
		using namespace std;

		++testFailedCount;
        strcpy(lastFailedFile, test.filename);
        lastFailedLine = test.lineNumber;
        strcpy(lastFailedSuite, test.suiteName);
        strcpy(lastFailedTest, test.testName);
        strcpy(lastFailedMessage, failure);
    }

    virtual void ReportTestFinish(UnitTest::TestDetails const& test, float testDuration)
    {
		using namespace std;

		++testFinishedCount;
        strcpy(lastFinishedSuite, test.suiteName);
        strcpy(lastFinishedTest, test.testName);
        lastFinishedTestTime = testDuration;
    }

    virtual void ReportSummary(int totalTestCount, int failedTestCount, int failureCount, float secondsElapsed) 
    {
        summaryTotalTestCount = totalTestCount;
        summaryFailedTestCount = failedTestCount;
        summaryFailureCount = failureCount;
        summarySecondsElapsed = secondsElapsed;
    }

    int testRunCount;
    char lastStartedSuite[kMaxStringLength];
    char lastStartedTest[kMaxStringLength];

    int testFailedCount;
    char lastFailedFile[kMaxStringLength];
    int lastFailedLine;
    char lastFailedSuite[kMaxStringLength];
    char lastFailedTest[kMaxStringLength];
    char lastFailedMessage[kMaxStringLength];

    int testFinishedCount;
    char lastFinishedSuite[kMaxStringLength];
    char lastFinishedTest[kMaxStringLength];
    float lastFinishedTestTime;

    int summaryTotalTestCount;
    int summaryFailedTestCount;
    int summaryFailureCount;
    float summarySecondsElapsed;
};


#endif

```

`ThirdParty/UnitTest++/tests/ScopedCurrentTest.h`:

```h
#ifndef UNITTEST_SCOPEDCURRENTTEST_H
#define UNITTEST_SCOPEDCURRENTTEST_H

#include "UnitTest++/CurrentTest.h"
#include <cstddef>

class ScopedCurrentTest
{
public:
	ScopedCurrentTest()
		: m_oldTestResults(UnitTest::CurrentTest::Results())
		, m_oldTestDetails(UnitTest::CurrentTest::Details())
	{
	}

	explicit ScopedCurrentTest(UnitTest::TestResults& newResults, const UnitTest::TestDetails* newDetails = NULL)
		: m_oldTestResults(UnitTest::CurrentTest::Results())
		, m_oldTestDetails(UnitTest::CurrentTest::Details())
	{
		UnitTest::CurrentTest::Results() = &newResults;

		if (newDetails != NULL)
			UnitTest::CurrentTest::Details() = newDetails;
	}

	~ScopedCurrentTest()
	{
		UnitTest::CurrentTest::Results() = m_oldTestResults;
		UnitTest::CurrentTest::Details() = m_oldTestDetails;
	}

private:
	UnitTest::TestResults* m_oldTestResults;
	const UnitTest::TestDetails* m_oldTestDetails;
};

#endif

```

`ThirdParty/UnitTest++/tests/TestAssertHandler.cpp`:

```cpp
#include "UnitTest++/Config.h"
#include "UnitTest++/UnitTestPP.h"

#include "UnitTest++/ReportAssert.h"
#include "UnitTest++/ReportAssertImpl.h"
#include "UnitTest++/AssertException.h"

#include "RecordingReporter.h"
#include <csetjmp>

using namespace UnitTest;

namespace {

TEST(CanSetAssertExpected)
{
	Detail::ExpectAssert(true);
	CHECK(Detail::AssertExpected());

	Detail::ExpectAssert(false);
	CHECK(!Detail::AssertExpected());
}

#ifndef UNITTEST_NO_EXCEPTIONS

TEST(ReportAssertThrowsAssertException)
{
    bool caught = false;

    try
    {
		TestResults testResults;
		TestDetails testDetails("", "", "", 0);
        Detail::ReportAssertEx(&testResults, &testDetails, "", "", 0);
    }
    catch(AssertException const&)
    {
        caught = true;
    }

    CHECK(true == caught);
}

TEST(ReportAssertClearsExpectAssertFlag)
{
	RecordingReporter reporter;
	TestResults testResults(&reporter);
	TestDetails testDetails("", "", "", 0);

	try
	{
		Detail::ExpectAssert(true);
		Detail::ReportAssertEx(&testResults, &testDetails, "", "", 0);
	}
	catch(AssertException const&)
	{
	}

	CHECK(Detail::AssertExpected() == false);
	CHECK_EQUAL(0, reporter.testFailedCount);
}

TEST(ReportAssertWritesFailureToResultsAndDetailsWhenAssertIsNotExpected)
{
    const int lineNumber = 12345;
    const char* description = "description";
    const char* filename = "filename";

	RecordingReporter reporter;
	TestResults testResults(&reporter);
	TestDetails testDetails("", "", "", 0);

    try
    {
        Detail::ReportAssertEx(&testResults, &testDetails, description, filename, lineNumber);
    }
    catch(AssertException const&)
    {
    }

	CHECK_EQUAL(description, reporter.lastFailedMessage);
	CHECK_EQUAL(filename, reporter.lastFailedFile);
	CHECK_EQUAL(lineNumber, reporter.lastFailedLine);
}

TEST(ReportAssertReportsNoErrorsWhenAssertIsExpected)
{
	Detail::ExpectAssert(true);

	RecordingReporter reporter;
	TestResults testResults(&reporter);
	TestDetails testDetails("", "", "", 0);

	try
	{
		Detail::ReportAssertEx(&testResults, &testDetails, "", "", 0);
	}
	catch(AssertException const&)
	{
	}

	CHECK_EQUAL(0, reporter.testFailedCount);
}

TEST(CheckAssertMacroSetsAssertExpectationToFalseAfterRunning)
{
	Detail::ExpectAssert(true);
	CHECK_ASSERT(ReportAssert("", "", 0));
	CHECK(!Detail::AssertExpected());
	Detail::ExpectAssert(false);
}

#else

TEST(SetAssertJumpTargetReturnsFalseWhenSettingJumpTarget)
{
	CHECK(UNITTEST_SET_ASSERT_JUMP_TARGET() == false);
}

TEST(JumpToAssertJumpTarget_JumpsToSetPoint_ReturnsTrue)
{
	const volatile bool taken = !!UNITTEST_SET_ASSERT_JUMP_TARGET();

	volatile bool set = false;
	if (taken == false)
	{
		UNITTEST_JUMP_TO_ASSERT_JUMP_TARGET();
		set = true;
	}

	CHECK(set == false);
}

#endif

}

```

`ThirdParty/UnitTest++/tests/TestCheckMacros.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/CurrentTest.h"
#include "RecordingReporter.h"
#include "ScopedCurrentTest.h"

using namespace std;

namespace {

TEST(CheckSucceedsOnTrue)
{
    bool failure = true;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);

		ScopedCurrentTest scopedResults(testResults);
		CHECK(true);

		failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(!failure);
}

TEST(CheckFailsOnFalse)
{
    bool failure = false;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        CHECK(false);
        failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(failure);
}

TEST(FailureReportsCorrectTestName)
{
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        CHECK(false);
    }

    CHECK_EQUAL(m_details.testName, reporter.lastFailedTest);
}

TEST(CheckFailureIncludesCheckContents)
{
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        const bool yaddayadda = false;
        CHECK(yaddayadda);
    }

    CHECK(strstr(reporter.lastFailedMessage, "yaddayadda"));
}

TEST(CheckEqualSucceedsOnEqual)
{
    bool failure = true;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        CHECK_EQUAL(1, 1);
        failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(!failure);
}

TEST(CheckEqualFailsOnNotEqual)
{
    bool failure = false;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        CHECK_EQUAL(1, 2);
        failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(failure);
}

TEST(CheckEqualFailureContainsCorrectDetails)
{
    int line = 0;
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		UnitTest::TestDetails const testDetails("testName", "suiteName", "filename", -1);
		ScopedCurrentTest scopedResults(testResults, &testDetails);

		CHECK_EQUAL(1, 123);    line = __LINE__;
    }

    CHECK_EQUAL("testName", reporter.lastFailedTest);
    CHECK_EQUAL("suiteName", reporter.lastFailedSuite);
    CHECK_EQUAL("filename", reporter.lastFailedFile);
    CHECK_EQUAL(line, reporter.lastFailedLine);
}

int g_sideEffect = 0;
int FunctionWithSideEffects()
{
    ++g_sideEffect;
    return 1;
}

TEST(CheckEqualDoesNotHaveSideEffectsWhenPassing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);
        CHECK_EQUAL(1, FunctionWithSideEffects());
    }
    CHECK_EQUAL(1, g_sideEffect);
}

TEST(CheckEqualDoesNotHaveSideEffectsWhenFailing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);
        CHECK_EQUAL(2, FunctionWithSideEffects());
    }
    CHECK_EQUAL(1, g_sideEffect);
}


TEST(CheckCloseSucceedsOnEqual)
{
    bool failure = true;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        CHECK_CLOSE (1.0f, 1.001f, 0.01f);
        failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(!failure);
}

TEST(CheckCloseFailsOnNotEqual)
{
    bool failure = false;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        CHECK_CLOSE (1.0f, 1.1f, 0.01f);
        failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(failure);
}

TEST(CheckCloseFailureContainsCorrectDetails)
{
    int line = 0;
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		UnitTest::TestDetails testDetails("test", "suite", "filename", -1);
		ScopedCurrentTest scopedResults(testResults, &testDetails);

		CHECK_CLOSE (1.0f, 1.1f, 0.01f);    line = __LINE__;
    }

    CHECK_EQUAL("test", reporter.lastFailedTest);
    CHECK_EQUAL("suite", reporter.lastFailedSuite);
    CHECK_EQUAL("filename", reporter.lastFailedFile);
    CHECK_EQUAL(line, reporter.lastFailedLine);
}

TEST(CheckCloseDoesNotHaveSideEffectsWhenPassing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);
        CHECK_CLOSE (1, FunctionWithSideEffects(), 0.1f);
    }
    CHECK_EQUAL(1, g_sideEffect);
}

TEST(CheckCloseDoesNotHaveSideEffectsWhenFailing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);
        CHECK_CLOSE (2, FunctionWithSideEffects(), 0.1f);
    }
    CHECK_EQUAL(1, g_sideEffect);
}

TEST(CheckArrayCloseSucceedsOnEqual)
{
    bool failure = true;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);
        const float data[4] = { 0, 1, 2, 3 };
        CHECK_ARRAY_CLOSE (data, data, 4, 0.01f);
        failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(!failure);
}

TEST(CheckArrayCloseFailsOnNotEqual)
{
    bool failure = false;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		int const data1[4] = { 0, 1, 2, 3 };
        int const data2[4] = { 0, 1, 3, 3 };
		CHECK_ARRAY_CLOSE (data1, data2, 4, 0.01f);

		failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(failure);
}

TEST(CheckArrayCloseFailureIncludesCheckExpectedAndActual)
{
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		int const data1[4] = { 0, 1, 2, 3 };
        int const data2[4] = { 0, 1, 3, 3 };
        CHECK_ARRAY_CLOSE (data1, data2, 4, 0.01f);
    }

    CHECK(strstr(reporter.lastFailedMessage, "xpected [ 0 1 2 3 ]"));
    CHECK(strstr(reporter.lastFailedMessage, "was [ 0 1 3 3 ]"));
}

TEST(CheckArrayCloseFailureContainsCorrectDetails)
{
    int line = 0;
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		UnitTest::TestDetails testDetails("arrayCloseTest", "arrayCloseSuite", "filename", -1);
		ScopedCurrentTest scopedResults(testResults, &testDetails);

		int const data1[4] = { 0, 1, 2, 3 };
        int const data2[4] = { 0, 1, 3, 3 };
        CHECK_ARRAY_CLOSE (data1, data2, 4, 0.01f);     line = __LINE__;
    }

    CHECK_EQUAL("arrayCloseTest", reporter.lastFailedTest);
    CHECK_EQUAL("arrayCloseSuite", reporter.lastFailedSuite);
    CHECK_EQUAL("filename", reporter.lastFailedFile);
    CHECK_EQUAL(line, reporter.lastFailedLine);
}

TEST(CheckArrayCloseFailureIncludesTolerance)
{
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		float const data1[4] = { 0, 1, 2, 3 };
        float const data2[4] = { 0, 1, 3, 3 };
        CHECK_ARRAY_CLOSE (data1, data2, 4, 0.01f);
    }

    CHECK(strstr(reporter.lastFailedMessage, "0.01"));
}

TEST(CheckArrayEqualSuceedsOnEqual)
{
    bool failure = true;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		const float data[4] = { 0, 1, 2, 3 };
        CHECK_ARRAY_EQUAL (data, data, 4);

		failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(!failure);
}

TEST(CheckArrayEqualFailsOnNotEqual)
{
    bool failure = false;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		int const data1[4] = { 0, 1, 2, 3 };
        int const data2[4] = { 0, 1, 3, 3 };
        CHECK_ARRAY_EQUAL (data1, data2, 4);

		failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(failure);
}

TEST(CheckArrayEqualFailureIncludesCheckExpectedAndActual)
{
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		int const data1[4] = { 0, 1, 2, 3 };
        int const data2[4] = { 0, 1, 3, 3 };
        CHECK_ARRAY_EQUAL (data1, data2, 4);
    }

    CHECK(strstr(reporter.lastFailedMessage, "xpected [ 0 1 2 3 ]"));
    CHECK(strstr(reporter.lastFailedMessage, "was [ 0 1 3 3 ]"));
}

TEST(CheckArrayEqualFailureContainsCorrectInfo)
{
    int line = 0;
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		int const data1[4] = { 0, 1, 2, 3 };
        int const data2[4] = { 0, 1, 3, 3 };
        CHECK_ARRAY_EQUAL (data1, data2, 4);     line = __LINE__;
    }

    CHECK_EQUAL("CheckArrayEqualFailureContainsCorrectInfo", reporter.lastFailedTest);
    CHECK_EQUAL(__FILE__, reporter.lastFailedFile);
    CHECK_EQUAL(line, reporter.lastFailedLine);
}

float const* FunctionWithSideEffects2()
{
    ++g_sideEffect;
    static float const data[] = {1,2,3,4};
    return data;
}

TEST(CheckArrayCloseDoesNotHaveSideEffectsWhenPassing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);

		const float data[] = { 0, 1, 2, 3 };
        CHECK_ARRAY_CLOSE (data, FunctionWithSideEffects2(), 4, 0.01f);
    }
    CHECK_EQUAL(1, g_sideEffect);
}

TEST(CheckArrayCloseDoesNotHaveSideEffectsWhenFailing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);

		const float data[] = { 0, 1, 3, 3 };
        CHECK_ARRAY_CLOSE (data, FunctionWithSideEffects2(), 4, 0.01f);
    }

	CHECK_EQUAL(1, g_sideEffect);
}

TEST(CheckArray2DCloseSucceedsOnEqual)
{
    bool failure = true;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		const float data[2][2] = { {0, 1}, {2, 3} };
        CHECK_ARRAY2D_CLOSE (data, data, 2, 2, 0.01f);

		failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(!failure);
}

TEST(CheckArray2DCloseFailsOnNotEqual)
{
    bool failure = false;
    {
        RecordingReporter reporter;
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		int const data1[2][2] = { {0, 1}, {2, 3} };
        int const data2[2][2] = { {0, 1}, {3, 3} };
        CHECK_ARRAY2D_CLOSE (data1, data2, 2, 2, 0.01f);

		failure = (testResults.GetFailureCount() > 0);
    }

    CHECK(failure);
}

TEST(CheckArray2DCloseFailureIncludesCheckExpectedAndActual)
{
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		int const data1[2][2] = { {0, 1}, {2, 3} };
        int const data2[2][2] = { {0, 1}, {3, 3} };

		CHECK_ARRAY2D_CLOSE (data1, data2, 2, 2, 0.01f);
    }

    CHECK(strstr(reporter.lastFailedMessage, "xpected [ [ 0 1 ] [ 2 3 ] ]"));
    CHECK(strstr(reporter.lastFailedMessage, "was [ [ 0 1 ] [ 3 3 ] ]"));
}

TEST(CheckArray2DCloseFailureContainsCorrectDetails)
{
    int line = 0;
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		UnitTest::TestDetails testDetails("array2DCloseTest", "array2DCloseSuite", "filename", -1);
		ScopedCurrentTest scopedResults(testResults, &testDetails);

		int const data1[2][2] = { {0, 1}, {2, 3} };
        int const data2[2][2] = { {0, 1}, {3, 3} };
		CHECK_ARRAY2D_CLOSE (data1, data2, 2, 2, 0.01f);     line = __LINE__;
    }

    CHECK_EQUAL("array2DCloseTest", reporter.lastFailedTest);
    CHECK_EQUAL("array2DCloseSuite", reporter.lastFailedSuite);
    CHECK_EQUAL("filename", reporter.lastFailedFile);
    CHECK_EQUAL(line, reporter.lastFailedLine);
}

TEST(CheckArray2DCloseFailureIncludesTolerance)
{
    RecordingReporter reporter;
    {
        UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		float const data1[2][2] = { {0, 1}, {2, 3} };
        float const data2[2][2] = { {0, 1}, {3, 3} };
        CHECK_ARRAY2D_CLOSE (data1, data2, 2, 2, 0.01f);
    }

    CHECK(strstr(reporter.lastFailedMessage, "0.01"));
}

float const* const* FunctionWithSideEffects3()
{
    ++g_sideEffect;
    static float const data1[] = {0,1};
    static float const data2[] = {2,3};
    static const float* const data[] = {data1, data2};
    return data;
}

TEST(CheckArray2DCloseDoesNotHaveSideEffectsWhenPassing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);

		const float data[2][2] = { {0, 1}, {2, 3} };
        CHECK_ARRAY2D_CLOSE (data, FunctionWithSideEffects3(), 2, 2, 0.01f);
    }
    CHECK_EQUAL(1, g_sideEffect);
}

TEST(CheckArray2DCloseDoesNotHaveSideEffectsWhenFailing)
{
    g_sideEffect = 0;
    {
        UnitTest::TestResults testResults;
		ScopedCurrentTest scopedResults(testResults);

		const float data[2][2] = { {0, 1}, {3, 3} };
        CHECK_ARRAY2D_CLOSE (data, FunctionWithSideEffects3(), 2, 2, 0.01f);
    }
    CHECK_EQUAL(1, g_sideEffect);
}

}

```

`ThirdParty/UnitTest++/tests/TestChecks.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "RecordingReporter.h"

#include <cstring>

using namespace UnitTest;


namespace {


TEST(CheckEqualWithUnsignedLong)
{
    TestResults results;
    unsigned long something = 2;
    CHECK_EQUAL(something, something);
}

TEST(CheckEqualsWithStringsFailsOnDifferentStrings)
{
    char txt1[] = "Hello";
    char txt2[] = "Hallo";
    TestResults results;
    CheckEqual(results, txt1, txt2, TestDetails("", "", "", 0));
    CHECK_EQUAL(1, results.GetFailureCount());
}

char txt1[] = "Hello"; // non-const on purpose so no folding of duplicate data
char txt2[] = "Hello";

TEST(CheckEqualsWithStringsWorksOnContentsNonConstNonConst)
{
    char const* const p1 = txt1;
    char const* const p2 = txt2;
    TestResults results;
    CheckEqual(results, p1, p2, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckEqualsWithStringsWorksOnContentsConstConst)
{
    char* const p1 = txt1;
    char* const p2 = txt2;
    TestResults results;
    CheckEqual(results, p1, p2, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckEqualsWithStringsWorksOnContentsNonConstConst)
{
    char* const p1 = txt1;
    char const* const p2 = txt2;
    TestResults results;
    CheckEqual(results, p1, p2, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckEqualsWithStringsWorksOnContentsConstNonConst)
{
    char const* const p1 = txt1;
    char* const p2 = txt2;
    TestResults results;
    CheckEqual(results, p1, p2, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckEqualsWithStringsWorksOnContentsWithALiteral)
{
    char const* const p1 = txt1;
    TestResults results;
    CheckEqual(results, "Hello", p1, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckEqualsWithStringsWorksOnNullExpected)
{
    char const* const expected = "hi";
    char const* const actual = NULL;
    TestResults results;
    CheckEqual(results, expected, actual, TestDetails("", "", "", 0));
    CHECK_EQUAL (1, results.GetFailureCount());
}

TEST(CheckEqualsWithStringsWorksOnNullActual)
{
    char const* const expected = NULL;
    char const* const actual = "hi";
    TestResults results;
    CheckEqual(results, expected, actual, TestDetails("", "", "", 0));
    CHECK_EQUAL (1, results.GetFailureCount());
}

TEST(CheckEqualsWithStringsWorksOnNullExpectedAndActual)
{
    char const* const expected = NULL;
    char const* const actual = NULL;
    TestResults results;
    CheckEqual(results, expected, actual, TestDetails("", "", "", 0));
    CHECK_EQUAL (0, results.GetFailureCount());
}

TEST(CheckEqualFailureIncludesCheckExpectedAndActual)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    const int something = 2;
    CheckEqual(results, 1, something, TestDetails("", "", "", 0));

	using namespace std;
    CHECK(strstr(reporter.lastFailedMessage, "xpected 1"));
    CHECK(strstr(reporter.lastFailedMessage, "was 2"));
}

TEST(CheckEqualFailureIncludesDetails)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    TestDetails const details("mytest", "mysuite", "file.h", 101);

    CheckEqual(results, 1, 2, details);

    CHECK_EQUAL("mytest", reporter.lastFailedTest);
    CHECK_EQUAL("mysuite", reporter.lastFailedSuite);
    CHECK_EQUAL("file.h", reporter.lastFailedFile);
    CHECK_EQUAL(101, reporter.lastFailedLine);
}

TEST(CheckCloseTrue)
{
    TestResults results;
    CheckClose(results, 3.001f, 3.0f, 0.1f, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckCloseFalse)
{
    TestResults results;
    CheckClose(results, 3.12f, 3.0f, 0.1f, TestDetails("", "", "", 0));
    CHECK_EQUAL(1, results.GetFailureCount());
}

TEST(CheckCloseWithZeroEpsilonWorksForSameNumber)
{
    TestResults results;
    CheckClose(results, 0.1f, 0.1f, 0, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckCloseWithNaNFails)
{
	const unsigned int bitpattern = 0xFFFFFFFF;
	float nan;
	UNIITEST_NS_QUAL_STD(memcpy)(&nan, &bitpattern, sizeof(bitpattern));

	TestResults results;
    CheckClose(results, 3.0f, nan, 0.1f, TestDetails("", "", "", 0));
    CHECK_EQUAL(1, results.GetFailureCount());
}

TEST(CheckCloseWithNaNAgainstItselfFails)
{
	const unsigned int bitpattern = 0xFFFFFFFF;
	float nan;
	UNIITEST_NS_QUAL_STD(memcpy)(&nan, &bitpattern, sizeof(bitpattern));

    TestResults results;
    CheckClose(results, nan, nan, 0.1f, TestDetails("", "", "", 0));
    CHECK_EQUAL(1, results.GetFailureCount());
}

TEST(CheckCloseFailureIncludesCheckExpectedAndActual)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    const float expected = 0.9f;
    const float actual = 1.1f;
    CheckClose(results, expected, actual, 0.01f, TestDetails("", "", "", 0));

	using namespace std;
    CHECK(strstr(reporter.lastFailedMessage, "xpected 0.9"));
    CHECK(strstr(reporter.lastFailedMessage, "was 1.1"));
}

TEST(CheckCloseFailureIncludesTolerance)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    CheckClose(results, 2, 3, 0.01f, TestDetails("", "", "", 0));

	using namespace std;
    CHECK(strstr(reporter.lastFailedMessage, "0.01"));
}

TEST(CheckCloseFailureIncludesDetails)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    TestDetails const details("mytest", "mysuite", "header.h", 10);

    CheckClose(results, 2, 3, 0.01f, details);

    CHECK_EQUAL("mytest", reporter.lastFailedTest);
    CHECK_EQUAL("mysuite", reporter.lastFailedSuite);
    CHECK_EQUAL("header.h", reporter.lastFailedFile);
    CHECK_EQUAL(10, reporter.lastFailedLine);
}


TEST(CheckArrayEqualTrue)
{
    TestResults results;

    int const array[3] = { 1, 2, 3 };
    CheckArrayEqual(results, array, array, 3, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckArrayEqualFalse)
{
    TestResults results;

    int const array1[3] = { 1, 2, 3 };
    int const array2[3] = { 1, 2, 2 };
    CheckArrayEqual(results, array1, array2, 3, TestDetails("", "", "", 0));
    CHECK_EQUAL(1, results.GetFailureCount());
}

TEST(CheckArrayCloseTrue)
{
    TestResults results;

    float const array1[3] = { 1.0f, 1.5f, 2.0f };
    float const array2[3] = { 1.01f, 1.51f, 2.01f };
    CheckArrayClose(results, array1, array2, 3, 0.02f, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckArrayCloseFalse)
{
    TestResults results;

    float const array1[3] = { 1.0f, 1.5f, 2.0f };
    float const array2[3] = { 1.01f, 1.51f, 2.01f };
    CheckArrayClose(results, array1, array2, 3, 0.001f, TestDetails("", "", "", 0));
    CHECK_EQUAL(1, results.GetFailureCount());
}

TEST(CheckArrayCloseFailureIncludesDetails)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    TestDetails const details("arrayCloseTest", "arrayCloseSuite", "file", 1337);

    float const array1[3] = { 1.0f, 1.5f, 2.0f };
    float const array2[3] = { 1.01f, 1.51f, 2.01f };
    CheckArrayClose(results, array1, array2, 3, 0.001f, details);

    CHECK_EQUAL("arrayCloseTest", reporter.lastFailedTest);
    CHECK_EQUAL("arrayCloseSuite", reporter.lastFailedSuite);
    CHECK_EQUAL("file", reporter.lastFailedFile);
    CHECK_EQUAL(1337, reporter.lastFailedLine);
}


TEST(CheckArray2DCloseTrue)
{
    TestResults results;

    float const array1[3][3] = { { 1.0f, 1.5f, 2.0f },
                                 { 2.0f, 2.5f, 3.0f },
                                 { 3.0f, 3.5f, 4.0f } };
    float const array2[3][3] = { { 1.01f, 1.51f, 2.01f },
                                 { 2.01f, 2.51f, 3.01f },
                                 { 3.01f, 3.51f, 4.01f } };
    CheckArray2DClose(results, array1, array2, 3, 3, 0.02f, TestDetails("", "", "", 0));
    CHECK_EQUAL(0, results.GetFailureCount());
}

TEST(CheckArray2DCloseFalse)
{
    TestResults results;

    float const array1[3][3] = { { 1.0f, 1.5f, 2.0f },
                                 { 2.0f, 2.5f, 3.0f },
                                 { 3.0f, 3.5f, 4.0f } };
    float const array2[3][3] = { { 1.01f, 1.51f, 2.01f },
                                 { 2.01f, 2.51f, 3.01f },
                                 { 3.01f, 3.51f, 4.01f } };
    CheckArray2DClose(results, array1, array2, 3, 3, 0.001f, TestDetails("", "", "", 0));
    CHECK_EQUAL(1, results.GetFailureCount());
}

TEST(CheckCloseWithDoublesSucceeds)
{
    CHECK_CLOSE(0.5, 0.5, 0.0001);
}

TEST(CheckArray2DCloseFailureIncludesDetails)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    TestDetails const details("array2DCloseTest", "array2DCloseSuite", "file", 1234);

    float const array1[3][3] = { { 1.0f, 1.5f, 2.0f },
                                 { 2.0f, 2.5f, 3.0f },
                                 { 3.0f, 3.5f, 4.0f } };
    float const array2[3][3] = { { 1.01f, 1.51f, 2.01f },
                                 { 2.01f, 2.51f, 3.01f },
                                 { 3.01f, 3.51f, 4.01f } };
    CheckArray2DClose(results, array1, array2, 3, 3, 0.001f, details);

    CHECK_EQUAL("array2DCloseTest", reporter.lastFailedTest);
    CHECK_EQUAL("array2DCloseSuite", reporter.lastFailedSuite);
    CHECK_EQUAL("file", reporter.lastFailedFile);
    CHECK_EQUAL(1234, reporter.lastFailedLine);
}

}

```

`ThirdParty/UnitTest++/tests/TestCompositeTestReporter.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/CompositeTestReporter.h"

using namespace UnitTest;

namespace {

TEST(ZeroReportersByDefault)
{
	CHECK_EQUAL(0, CompositeTestReporter().GetReporterCount());
}

struct MockReporter : TestReporter
{
	MockReporter()
		: testStartCalled(false)
		, testStartDetails(NULL)
		, failureCalled(false)
		, failureDetails(NULL)
		, failureStr(NULL)
		, testFinishCalled(false)
		, testFinishDetails(NULL)
		, testFinishSecondsElapsed(-1.0f)
		, summaryCalled(false)
		, summaryTotalTestCount(-1)
		, summaryFailureCount(-1)
		, summarySecondsElapsed(-1.0f)
	{
	}

	virtual void ReportTestStart(TestDetails const& test)
	{
		testStartCalled = true;
		testStartDetails = &test;
	}

	virtual void ReportFailure(TestDetails const& test, char const* failure)
	{
		failureCalled = true;
		failureDetails = &test;
		failureStr = failure;
	}

	virtual void ReportTestFinish(TestDetails const& test, float secondsElapsed)
	{
		testFinishCalled = true;
		testFinishDetails = &test;
		testFinishSecondsElapsed = secondsElapsed;
	}

	virtual void ReportSummary(int totalTestCount, 
							   int failedTestCount,
							   int failureCount,
							   float secondsElapsed)
	{
		summaryCalled = true;
		summaryTotalTestCount = totalTestCount;
		summaryFailedTestCount = failedTestCount;
		summaryFailureCount = failureCount;
		summarySecondsElapsed = secondsElapsed;
	}

	bool testStartCalled;
	TestDetails const* testStartDetails;

	bool failureCalled;
	TestDetails const* failureDetails;
	const char* failureStr;

	bool testFinishCalled;
	TestDetails const* testFinishDetails;
	float testFinishSecondsElapsed;

	bool summaryCalled;
	int summaryTotalTestCount;
	int summaryFailedTestCount;
	int summaryFailureCount;
	float summarySecondsElapsed;
};

TEST(AddReporter)
{
	MockReporter r;
	CompositeTestReporter c;

	CHECK(c.AddReporter(&r));
	CHECK_EQUAL(1, c.GetReporterCount());
}

TEST(RemoveReporter)
{
	MockReporter r;
	CompositeTestReporter c;

	c.AddReporter(&r);
	CHECK(c.RemoveReporter(&r));
	CHECK_EQUAL(0, c.GetReporterCount());
}

struct Fixture
{
	Fixture()
	{
		c.AddReporter(&r0);
		c.AddReporter(&r1);
	}

	MockReporter r0, r1;
	CompositeTestReporter c;
};

TEST_FIXTURE(Fixture, ReportTestStartCallsReportTestStartOnAllAggregates)
{
	TestDetails t("", "", "", 0);
	c.ReportTestStart(t);

	CHECK(r0.testStartCalled);
	CHECK_EQUAL(&t, r0.testStartDetails);
	CHECK(r1.testStartCalled);
	CHECK_EQUAL(&t, r1.testStartDetails);
}

TEST_FIXTURE(Fixture, ReportFailureCallsReportFailureOnAllAggregates)
{
	TestDetails t("", "", "", 0);
	const char* failStr = "fail";
	c.ReportFailure(t, failStr);

	CHECK(r0.failureCalled);
	CHECK_EQUAL(&t, r0.failureDetails);
	CHECK_EQUAL(failStr, r0.failureStr);

	CHECK(r1.failureCalled);
	CHECK_EQUAL(&t, r1.failureDetails);
	CHECK_EQUAL(failStr, r1.failureStr);
}

TEST_FIXTURE(Fixture, ReportTestFinishCallsReportTestFinishOnAllAggregates)
{
	TestDetails t("", "", "", 0);
	const float s = 1.2345f;
	c.ReportTestFinish(t, s);

	CHECK(r0.testFinishCalled);
	CHECK_EQUAL(&t, r0.testFinishDetails);
	CHECK_CLOSE(s, r0.testFinishSecondsElapsed, 0.00001f);

	CHECK(r1.testFinishCalled);
	CHECK_EQUAL(&t, r1.testFinishDetails);
	CHECK_CLOSE(s, r1.testFinishSecondsElapsed, 0.00001f);
}

TEST_FIXTURE(Fixture, ReportSummaryCallsReportSummaryOnAllAggregates)
{
	TestDetails t("", "", "", 0);
	const int testCount = 3;
	const int failedTestCount = 4;
	const int failureCount = 5;
	const float secondsElapsed = 3.14159f;

	c.ReportSummary(testCount, failedTestCount, failureCount, secondsElapsed);

	CHECK(r0.summaryCalled);
	CHECK_EQUAL(testCount, r0.summaryTotalTestCount);
	CHECK_EQUAL(failedTestCount, r0.summaryFailedTestCount);
	CHECK_EQUAL(failureCount, r0.summaryFailureCount);
	CHECK_CLOSE(secondsElapsed, r0.summarySecondsElapsed, 0.00001f);

	CHECK(r1.summaryCalled);
	CHECK_EQUAL(testCount, r1.summaryTotalTestCount);
	CHECK_EQUAL(failedTestCount, r1.summaryFailedTestCount);
	CHECK_EQUAL(failureCount, r1.summaryFailureCount);
	CHECK_CLOSE(secondsElapsed, r1.summarySecondsElapsed, 0.00001f);
}

}

```

`ThirdParty/UnitTest++/tests/TestCurrentTest.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/CurrentTest.h"
#include "ScopedCurrentTest.h"

namespace 
{

TEST(CanSetandGetDetails)
{
	bool ok = false;
	{
		ScopedCurrentTest scopedTest;

		const UnitTest::TestDetails* details = reinterpret_cast< const UnitTest::TestDetails* >(12345);
		UnitTest::CurrentTest::Details() = details;

		ok = (UnitTest::CurrentTest::Details() == details);
	}

	CHECK(ok);
}

TEST(CanSetAndGetResults)
{
	bool ok = false;
	{
		ScopedCurrentTest scopedTest;

		UnitTest::TestResults results;
		UnitTest::CurrentTest::Results() = &results;

		ok = (UnitTest::CurrentTest::Results() == &results);
	}

	CHECK(ok);
}

}

```

`ThirdParty/UnitTest++/tests/TestDeferredTestReporter.cpp`:

```cpp
#include "UnitTest++/Config.h"

#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/DeferredTestReporter.h"
#include <cstring>

namespace UnitTest
{

namespace 
{

#ifndef UNITTEST_MEMORYOUTSTREAM_IS_STD_OSTRINGSTREAM
	MemoryOutStream& operator <<(MemoryOutStream& lhs, const std::string& rhs)
	{
		lhs << rhs.c_str();
		return lhs;
	}
#endif

struct MockDeferredTestReporter : public DeferredTestReporter
{
    virtual void ReportSummary(int, int, int, float) 
    {
    }
};

struct DeferredTestReporterFixture
{
    DeferredTestReporterFixture()
        : testName("UniqueTestName")
        , testSuite("UniqueTestSuite")
        , fileName("filename.h")
        , lineNumber(12)
        , details(testName.c_str(), testSuite.c_str(), fileName.c_str(), lineNumber)
    {
    }

    MockDeferredTestReporter reporter;
    std::string const testName;
    std::string const testSuite;
    std::string const fileName;
    int const lineNumber;
    TestDetails const details;
};

TEST_FIXTURE(DeferredTestReporterFixture, ReportTestStartCreatesANewDeferredTest)
{
    reporter.ReportTestStart(details);
    CHECK_EQUAL(1, (int)reporter.GetResults().size());
}

TEST_FIXTURE(DeferredTestReporterFixture, ReportTestStartCapturesTestNameAndSuite)
{
    reporter.ReportTestStart(details);

    DeferredTestResult const& result = reporter.GetResults().at(0);
    CHECK_EQUAL(testName.c_str(), result.testName.c_str());
    CHECK_EQUAL(testSuite.c_str(), result.suiteName.c_str());
}

TEST_FIXTURE(DeferredTestReporterFixture, ReportTestEndCapturesTestTime)
{
    float const elapsed = 123.45f;
    reporter.ReportTestStart(details);
    reporter.ReportTestFinish(details, elapsed);

    DeferredTestResult const& result = reporter.GetResults().at(0);
    CHECK_CLOSE(elapsed, result.timeElapsed, 0.0001f);
}

TEST_FIXTURE(DeferredTestReporterFixture, ReportFailureSavesFailureDetails)
{
    char const* failure = "failure";

    reporter.ReportTestStart(details);
    reporter.ReportFailure(details, failure);

    DeferredTestResult const& result = reporter.GetResults().at(0);
    CHECK(result.failed == true);
    CHECK_EQUAL(fileName.c_str(), result.failureFile.c_str());
}

TEST_FIXTURE(DeferredTestReporterFixture, ReportFailureSavesFailureDetailsForMultipleFailures)
{
    char const* failure1 = "failure 1";
    char const* failure2 = "failure 2";

    reporter.ReportTestStart(details);
    reporter.ReportFailure(details, failure1);
    reporter.ReportFailure(details, failure2);

    DeferredTestResult const& result = reporter.GetResults().at(0);
    CHECK_EQUAL(2, (int)result.failures.size());
    CHECK_EQUAL(failure1, result.failures[0].failureStr);
    CHECK_EQUAL(failure2, result.failures[1].failureStr);
}

TEST_FIXTURE(DeferredTestReporterFixture, DeferredTestReporterTakesCopyOfFailureMessage)
{
    reporter.ReportTestStart(details);

    char failureMessage[128];
    char const* goodStr = "Real failure message";
    char const* badStr = "Bogus failure message";
    
	using namespace std;

    strcpy(failureMessage, goodStr);
    reporter.ReportFailure(details, failureMessage);
    strcpy(failureMessage, badStr);

    DeferredTestResult const& result = reporter.GetResults().at(0);
    DeferredTestFailure const& failure = result.failures.at(0);
    CHECK_EQUAL(goodStr, failure.failureStr);
}

}}

#endif

```

`ThirdParty/UnitTest++/tests/TestExceptions.cpp`:

```cpp
#include "UnitTest++/Config.h"
#ifndef UNITTEST_NO_EXCEPTIONS

#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/CurrentTest.h"
#include "RecordingReporter.h"
#include "ScopedCurrentTest.h"

#include <stdexcept>

using namespace std;

namespace {

int ThrowingFunction()
{
    throw "Doh";
}

int ThrowingStdExceptionFunction()
{
    throw std::logic_error("Doh");
}

SUITE(CheckExceptionTests)
{
    struct CheckFixture
    {
        CheckFixture()
          : reporter()
          , testResults(&reporter)
        {
        }

        void PerformCheckWithNonStdThrow()
        {
            ScopedCurrentTest scopedResults(testResults);
            CHECK(ThrowingFunction() == 1);
        }

        void PerformCheckWithStdThrow()
        {
            ScopedCurrentTest scopedResults(testResults);
            CHECK(ThrowingStdExceptionFunction() == 1);
        }

        RecordingReporter reporter;
        UnitTest::TestResults testResults;
    };

    TEST_FIXTURE(CheckFixture, CheckFailsOnException)
    {
        PerformCheckWithNonStdThrow();
        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckFixture, CheckFailsOnStdException)
    {
        PerformCheckWithStdThrow();
        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckFixture, CheckFailureBecauseOfExceptionIncludesCheckContents)
    {
        PerformCheckWithNonStdThrow();
        CHECK(strstr(reporter.lastFailedMessage, "ThrowingFunction() == 1"));
    }

    TEST_FIXTURE(CheckFixture, CheckFailureBecauseOfStdExceptionIncludesCheckContents)
    {
        PerformCheckWithStdThrow();
        CHECK(strstr(reporter.lastFailedMessage, "ThrowingStdExceptionFunction() == 1"));
    }

    TEST_FIXTURE(CheckFixture, CheckFailureBecauseOfStandardExceptionIncludesWhat)
    {
        PerformCheckWithStdThrow();
        CHECK(strstr(reporter.lastFailedMessage, "exception (Doh)"));
    }
}

SUITE(CheckEqualExceptionTests)
{
    struct CheckEqualFixture
    {
        CheckEqualFixture()
          : reporter()
          , testResults(&reporter)
          , line(-1)
        {
        }

        void PerformCheckWithNonStdThrow()
        {
            UnitTest::TestDetails const testDetails("testName", "suiteName", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            CHECK_EQUAL(ThrowingFunction(), 123); line = __LINE__;
        }

        void PerformCheckWithStdThrow()
        {
            UnitTest::TestDetails const testDetails("testName", "suiteName", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            CHECK_EQUAL(ThrowingStdExceptionFunction(), 123); line = __LINE__;
        }

        RecordingReporter reporter;
        UnitTest::TestResults testResults;
        int line;
    };

    TEST_FIXTURE(CheckEqualFixture, CheckEqualFailsOnException)
    {
        PerformCheckWithNonStdThrow();
        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckEqualFixture, CheckEqualFailsOnStdException)
    {
        PerformCheckWithStdThrow();
        CHECK(testResults.GetFailureCount() > 0);   
    }

    TEST_FIXTURE(CheckEqualFixture, CheckEqualFailureBecauseOfExceptionContainsCorrectDetails)
    {
        PerformCheckWithNonStdThrow();

        CHECK_EQUAL("testName", reporter.lastFailedTest);
        CHECK_EQUAL("suiteName", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckEqualFixture, CheckEqualFailureBecauseOfStdExceptionContainsCorrectDetails)
    {
        PerformCheckWithStdThrow();

        CHECK_EQUAL("testName", reporter.lastFailedTest);
        CHECK_EQUAL("suiteName", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckEqualFixture, CheckEqualFailureBecauseOfExceptionIncludesCheckContents)
    {
        PerformCheckWithNonStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "ThrowingFunction()"));
        CHECK(strstr(reporter.lastFailedMessage, "123"));
    }

    TEST_FIXTURE(CheckEqualFixture, CheckEqualFailureBecauseOfStdExceptionIncludesCheckContents)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "ThrowingStdExceptionFunction()"));
        CHECK(strstr(reporter.lastFailedMessage, "123"));
    }

    TEST_FIXTURE(CheckEqualFixture, CheckEqualFailureBecauseOfStandardExceptionIncludesWhat)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "exception (Doh)"));
    }
}

SUITE(CheckCloseExceptionTests)
{
    struct CheckCloseFixture
    {
        CheckCloseFixture()
          : reporter()
          , testResults(&reporter)
          , line(-1)
        {
        }

        void PerformCheckWithNonStdThrow()
        {
            UnitTest::TestDetails const testDetails("closeTest", "closeSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            CHECK_CLOSE(static_cast<float>(ThrowingFunction()), 1.0001f, 0.1f); line = __LINE__;
        }

        void PerformCheckWithStdThrow()
        {
            UnitTest::TestDetails const testDetails("closeTest", "closeSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            CHECK_CLOSE(static_cast<float>(ThrowingStdExceptionFunction()), 1.0001f, 0.1f); line = __LINE__;
        }

        RecordingReporter reporter;
        UnitTest::TestResults testResults;
        int line;
    };

    TEST_FIXTURE(CheckCloseFixture, CheckCloseFailsOnException)
    {
        PerformCheckWithNonStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckCloseFixture, CheckCloseFailsOnStdException)
    {
        PerformCheckWithStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckCloseFixture, CheckCloseFailureBecauseOfExceptionContainsCorrectDetails)
    {
        PerformCheckWithNonStdThrow();

        CHECK_EQUAL("closeTest", reporter.lastFailedTest);
        CHECK_EQUAL("closeSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckCloseFixture, CheckCloseFailureBecauseOfStdExceptionContainsCorrectDetails)
    {
        PerformCheckWithStdThrow();

        CHECK_EQUAL("closeTest", reporter.lastFailedTest);
        CHECK_EQUAL("closeSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckCloseFixture, CheckCloseFailureBecauseOfExceptionIncludesCheckContents)
    {
        PerformCheckWithNonStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "static_cast<float>(ThrowingFunction())"));
        CHECK(strstr(reporter.lastFailedMessage, "1.0001f"));
    }

    TEST_FIXTURE(CheckCloseFixture, CheckCloseFailureBecauseOfStdExceptionIncludesCheckContents)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "static_cast<float>(ThrowingStdExceptionFunction())"));
        CHECK(strstr(reporter.lastFailedMessage, "1.0001f"));
    }

    TEST_FIXTURE(CheckCloseFixture, CheckCloseFailureBecauseOfStandardExceptionIncludesWhat)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "exception (Doh)"));
    }
}

class ThrowingObject
{
public:
    float operator[](int) const
    {
        throw "Test throw";
    }
};

class StdThrowingObject
{
public:
    float operator[](int) const
    {
        throw std::runtime_error("Test throw");
    }
};

SUITE(CheckArrayCloseExceptionTests)
{
    struct CheckArrayCloseFixture
    {
        CheckArrayCloseFixture()
          : reporter()
          , testResults(&reporter)
          , line(-1)
        {
        }

        void PerformCheckWithNonStdThrow()
        {
            UnitTest::TestDetails const testDetails("arrayCloseTest", "arrayCloseSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            int const data[4] = { 0, 1, 2, 3 };
            CHECK_ARRAY_CLOSE(data, ThrowingObject(), 4, 0.01f); line = __LINE__;
        }

        void PerformCheckWithStdThrow()
        {
            UnitTest::TestDetails const testDetails("arrayCloseTest", "arrayCloseSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            int const data[4] = { 0, 1, 2, 3 };
            CHECK_ARRAY_CLOSE(data, StdThrowingObject(), 4, 0.01f); line = __LINE__;
        }

        RecordingReporter reporter;
        UnitTest::TestResults testResults;
        int line;
    };

    TEST_FIXTURE(CheckArrayCloseFixture, CheckFailureBecauseOfExceptionContainsCorrectDetails)
    {
        PerformCheckWithNonStdThrow();

        CHECK_EQUAL("arrayCloseTest", reporter.lastFailedTest);
        CHECK_EQUAL("arrayCloseSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckArrayCloseFixture, CheckFailureBecauseOfStdExceptionContainsCorrectDetails)
    {
        PerformCheckWithStdThrow();

        CHECK_EQUAL("arrayCloseTest", reporter.lastFailedTest);
        CHECK_EQUAL("arrayCloseSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckArrayCloseFixture, CheckFailsOnException)
    {
        PerformCheckWithNonStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckArrayCloseFixture, CheckFailsOnStdException)
    {
        PerformCheckWithStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckArrayCloseFixture, CheckFailureOnExceptionIncludesCheckContents)
    {
        PerformCheckWithNonStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "data"));
        CHECK(strstr(reporter.lastFailedMessage, "ThrowingObject()"));
    }

    TEST_FIXTURE(CheckArrayCloseFixture, CheckFailureOnStdExceptionIncludesCheckContents)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "data"));
        CHECK(strstr(reporter.lastFailedMessage, "StdThrowingObject()"));
    }

    TEST_FIXTURE(CheckArrayCloseFixture, CheckFailureOnStdExceptionIncludesWhat)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "exception (Test throw)"));
    }
}

SUITE(CheckArrayEqualExceptionTests)
{
    struct CheckArrayEqualFixture
    {
        CheckArrayEqualFixture()
        : reporter()
        , testResults(&reporter)
        , line(-1)
        {
        }

        void PerformCheckWithNonStdThrow()
        {
            UnitTest::TestDetails const testDetails("arrayEqualTest", "arrayEqualSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            int const data[4] = { 0, 1, 2, 3 };
            CHECK_ARRAY_EQUAL(data, ThrowingObject(), 4); line = __LINE__;
        }

        void PerformCheckWithStdThrow()
        {
            UnitTest::TestDetails const testDetails("arrayEqualTest", "arrayEqualSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            int const data[4] = { 0, 1, 2, 3 };
            CHECK_ARRAY_EQUAL(data, StdThrowingObject(), 4); line = __LINE__;
        }

        RecordingReporter reporter;
        UnitTest::TestResults testResults;
        int line;
    };

    TEST_FIXTURE(CheckArrayEqualFixture, CheckFailureBecauseOfExceptionContainsCorrectDetails)
    {
        PerformCheckWithNonStdThrow();

        CHECK_EQUAL("arrayEqualTest", reporter.lastFailedTest);
        CHECK_EQUAL("arrayEqualSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckArrayEqualFixture, CheckFailureBecauseOfStdExceptionContainsCorrectDetails)
    {
        PerformCheckWithStdThrow();

        CHECK_EQUAL("arrayEqualTest", reporter.lastFailedTest);
        CHECK_EQUAL("arrayEqualSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckArrayEqualFixture, CheckFailsOnException)
    {
        PerformCheckWithNonStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckArrayEqualFixture, CheckFailsOnStdException)
    {
        PerformCheckWithStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckArrayEqualFixture, CheckFailureOnExceptionIncludesCheckContents)
    {
        PerformCheckWithNonStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "data"));
        CHECK(strstr(reporter.lastFailedMessage, "ThrowingObject()"));
    }

    TEST_FIXTURE(CheckArrayEqualFixture, CheckFailureOnStdExceptionIncludesCheckContents)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "data"));
        CHECK(strstr(reporter.lastFailedMessage, "StdThrowingObject()"));
    }

    TEST_FIXTURE(CheckArrayEqualFixture, CheckFailureOnStdExceptionIncludesWhat)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "exception (Test throw)"));
    }
}

SUITE(CheckArray2DExceptionTests)
{
    class ThrowingObject2D
    {
    public:
        float* operator[](int) const
        {
            throw "Test throw";
        }
    };

    class StdThrowingObject2D
    {
    public:
        float* operator[](int) const
        {
            throw std::runtime_error("Test throw");
        }
    };

    struct CheckArray2DCloseFixture
    {
        CheckArray2DCloseFixture()
          : reporter()
          , testResults(&reporter)
          , line(-1)
        {
        }

        void PerformCheckWithNonStdThrow()
        {
            UnitTest::TestDetails const testDetails("array2DCloseTest", "array2DCloseSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            const float data[2][2] = { {0, 1}, {2, 3} };
            CHECK_ARRAY2D_CLOSE(data, ThrowingObject2D(), 2, 2, 0.01f); line = __LINE__;
        }

        void PerformCheckWithStdThrow()
        {
            UnitTest::TestDetails const testDetails("array2DCloseTest", "array2DCloseSuite", "filename", -1);
            ScopedCurrentTest scopedResults(testResults, &testDetails);
            const float data[2][2] = { {0, 1}, {2, 3} };
            CHECK_ARRAY2D_CLOSE(data, StdThrowingObject2D(), 2, 2, 0.01f); line = __LINE__;
        }

        RecordingReporter reporter;
        UnitTest::TestResults testResults;
        int line;
    };

    TEST_FIXTURE(CheckArray2DCloseFixture, CheckFailureBecauseOfExceptionContainsCorrectDetails)
    {
        PerformCheckWithNonStdThrow();

        CHECK_EQUAL("array2DCloseTest", reporter.lastFailedTest);
        CHECK_EQUAL("array2DCloseSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckArray2DCloseFixture, CheckFailureBecauseOfStdExceptionContainsCorrectDetails)
    {
        PerformCheckWithStdThrow();

        CHECK_EQUAL("array2DCloseTest", reporter.lastFailedTest);
        CHECK_EQUAL("array2DCloseSuite", reporter.lastFailedSuite);
        CHECK_EQUAL("filename", reporter.lastFailedFile);
        CHECK_EQUAL(line, reporter.lastFailedLine);
    }

    TEST_FIXTURE(CheckArray2DCloseFixture, CheckFailsOnException)
    {
        PerformCheckWithNonStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckArray2DCloseFixture, CheckFailsOnStdException)
    {
        PerformCheckWithStdThrow();

        CHECK(testResults.GetFailureCount() > 0);
    }

    TEST_FIXTURE(CheckArray2DCloseFixture, CheckFailureOnExceptionIncludesCheckContents)
    {
        PerformCheckWithNonStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "data"));
        CHECK(strstr(reporter.lastFailedMessage, "ThrowingObject2D()"));
    }

    TEST_FIXTURE(CheckArray2DCloseFixture, CheckFailureOnStdExceptionIncludesCheckContents)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "data"));
        CHECK(strstr(reporter.lastFailedMessage, "StdThrowingObject2D()"));
    }

    TEST_FIXTURE(CheckArray2DCloseFixture, CheckFailureOnStdExceptionIncludesWhat)
    {
        PerformCheckWithStdThrow();

        CHECK(strstr(reporter.lastFailedMessage, "exception (Test throw)"));
    }
}
}

#endif

```

`ThirdParty/UnitTest++/tests/TestMemoryOutStream.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"

#include "UnitTest++/MemoryOutStream.h"
#include <cstring>
#include <cstdlib>
#include <climits>
#include <cfloat>

using namespace UnitTest;
using namespace std;

namespace {

const char* const maxSignedIntegralStr(size_t nBytes)
{
    switch(nBytes)
    {
        case 8:
            return "9223372036854775807";
        case 4:
            return "2147483647";
        case 2:
            return "32767";
        case 1:
            return "127";
        default:
            return "Unsupported signed integral size";
    }
}

const char* const minSignedIntegralStr(size_t nBytes)
{
    switch(nBytes)
    {
        case 8:
            return "-9223372036854775808";
        case 4:
            return "-2147483648";
        case 2:
            return "-32768";
        case 1:
            return "-128";
        default:
            return "Unsupported signed integral size";
    }
}

const char* const maxUnsignedIntegralStr(size_t nBytes)
{
    switch(nBytes)
    {
        case 8:
            return "18446744073709551615";
        case 4:
            return "4294967295";
        case 2:
            return "65535";
        case 1:
            return "255";
        default:
            return "Unsupported signed integral size";
    }
}

TEST(DefaultIsEmptyString)
{
    MemoryOutStream const stream;
    CHECK(stream.GetText() != 0);
    CHECK_EQUAL("", stream.GetText());
}

TEST(StreamingTextCopiesCharacters)
{
    MemoryOutStream stream;
    stream << "Lalala";
    CHECK_EQUAL("Lalala", stream.GetText());
}

TEST(StreamingMultipleTimesConcatenatesResult)
{
    MemoryOutStream stream;
    stream << "Bork" << "Foo" << "Bar";
    CHECK_EQUAL("BorkFooBar", stream.GetText());
}

TEST(StreamingIntWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (int)123;
    CHECK_EQUAL("123", stream.GetText());
}

TEST(StreaminMaxIntWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << INT_MAX;
    CHECK_EQUAL(maxSignedIntegralStr(sizeof(int)), stream.GetText());    
}

TEST(StreamingMinIntWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << INT_MIN;
    CHECK_EQUAL(minSignedIntegralStr(sizeof(int)), stream.GetText());
}

TEST(StreamingUnsignedIntWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (unsigned int)123;
    CHECK_EQUAL("123", stream.GetText());
}

TEST(StreamingMaxUnsignedIntWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (unsigned int)UINT_MAX;
    CHECK_EQUAL(maxUnsignedIntegralStr(sizeof(unsigned int)), stream.GetText());
}

TEST(StreamingMinUnsignedIntWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (unsigned int)0;
    CHECK_EQUAL("0", stream.GetText());
}

TEST(StreamingLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (long)(-123);
    CHECK_EQUAL("-123", stream.GetText());
}

TEST(StreamingMaxLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (long)(LONG_MAX);
    CHECK_EQUAL(maxSignedIntegralStr(sizeof(long)), stream.GetText());
}

TEST(StreamingMinLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (long)(LONG_MIN);
    CHECK_EQUAL(minSignedIntegralStr(sizeof(long)), stream.GetText());
}

TEST(StreamingUnsignedLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (unsigned long)123;
    CHECK_EQUAL("123", stream.GetText());
}

TEST(StreamingMaxUnsignedLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (unsigned long)ULONG_MAX;
    CHECK_EQUAL(maxUnsignedIntegralStr(sizeof(unsigned long)), stream.GetText());
}

TEST(StreamingMinUnsignedLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (unsigned long)0ul;
    CHECK_EQUAL("0", stream.GetText());
}

TEST(StreamingLongLongWritesCorrectCharacters)
{
	MemoryOutStream stream;
#ifdef UNITTEST_COMPILER_IS_MSVC6
   stream << (__int64)-12345i64;
#else
	stream << (long long)-12345ll;
#endif
   CHECK_EQUAL("-12345", stream.GetText());
}

#ifdef LLONG_MAX
TEST(StreamingMaxLongLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (long long)LLONG_MAX;
    CHECK_EQUAL(maxSignedIntegralStr(sizeof(long long)), stream.GetText());
}
#endif

#ifdef LLONG_MIN
TEST(StreamingMinLongLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (long long)LLONG_MIN;
    CHECK_EQUAL(minSignedIntegralStr(sizeof(long long)), stream.GetText());
}
#endif

TEST(StreamingUnsignedLongLongWritesCorrectCharacters)
{
	MemoryOutStream stream;
#ifdef UNITTEST_COMPILER_IS_MSVC6
   stream << (unsigned __int64)85899ui64;
#else
   stream << (unsigned long long)85899ull;
#endif
   CHECK_EQUAL("85899", stream.GetText());
}

#ifdef ULLONG_MAX
TEST(StreamingMaxUnsignedLongLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << (unsigned long long)ULLONG_MAX;
    CHECK_EQUAL(maxUnsignedIntegralStr(sizeof(unsigned long long)), stream.GetText());
}
#endif

TEST(StreamingMinUnsignedLongLongWritesCorrectCharacters)
{
    MemoryOutStream stream;
#ifdef UNITTEST_COMPILER_IS_MSVC6
    stream << (unsigned __int64)0ui64;
#else
    stream << (unsigned long long)0ull;
#endif
    CHECK_EQUAL("0", stream.GetText());
}

TEST(StreamingFloatWritesCorrectCharacters)
{
    MemoryOutStream stream;
    stream << 3.1415f;
	CHECK(strstr(stream.GetText(), "3.1415"));
}

TEST(StreamingDoubleWritesCorrectCharacters)
{
	MemoryOutStream stream;
	stream << 3.1415;
	CHECK(strstr(stream.GetText(), "3.1415"));
}

TEST(StreamingPointerWritesCorrectCharacters)
{
    MemoryOutStream stream;
    int* p = (int*)0x1234;
    stream << p;
    CHECK(strstr(stream.GetText(), "1234"));
}

TEST(StreamingSizeTWritesCorrectCharacters)
{
    MemoryOutStream stream;
    size_t const s = 53124;
    stream << s;
    CHECK_EQUAL("53124", stream.GetText());
}

TEST(ClearEmptiesMemoryOutStreamContents)
{
	MemoryOutStream stream;
	stream << "Hello world";
	stream.Clear();
	CHECK_EQUAL("", stream.GetText());
}

#ifndef UNITTEST_MEMORYOUTSTREAM_IS_STD_OSTRINGSTREAM

TEST(StreamInitialCapacityIsCorrect)
{
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    CHECK_EQUAL((int)MemoryOutStream::GROW_CHUNK_SIZE, stream.GetCapacity());
}

TEST(StreamInitialCapacityIsMultipleOfGrowChunkSize)
{
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE + 1);
    CHECK_EQUAL((int)MemoryOutStream::GROW_CHUNK_SIZE * 2, stream.GetCapacity());
}


TEST(ExceedingCapacityGrowsBuffer)
{
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    stream << "012345678901234567890123456789";
    char const* const oldBuffer = stream.GetText();
    stream << "0123456789";
    CHECK(oldBuffer != stream.GetText());
}

TEST(ExceedingCapacityGrowsBufferByGrowChunk)
{
    MemoryOutStream stream(MemoryOutStream::GROW_CHUNK_SIZE);
    stream << "0123456789012345678901234567890123456789";
    CHECK_EQUAL(MemoryOutStream::GROW_CHUNK_SIZE * 2, stream.GetCapacity());
}

TEST(WritingStringLongerThanCapacityFitsInNewBuffer)
{
    MemoryOutStream stream(8);
    stream << "0123456789ABCDEF";
    CHECK_EQUAL("0123456789ABCDEF", stream.GetText());
}

TEST(WritingIntLongerThanCapacityFitsInNewBuffer)
{
    MemoryOutStream stream(8);
    stream << "aaaa" << 123456;
    CHECK_EQUAL("aaaa123456", stream.GetText());
}

TEST(WritingFloatLongerThanCapacityFitsInNewBuffer)
{
    MemoryOutStream stream(8);
    stream << "aaaa" << 123456.0f;
    CHECK_EQUAL("aaaa123456.000000", stream.GetText());
}

TEST(WritingSizeTLongerThanCapacityFitsInNewBuffer)
{
    MemoryOutStream stream(8);
    stream << "aaaa" << size_t(32145);
    CHECK_EQUAL("aaaa32145", stream.GetText());
}

TEST(VerifyLargeDoubleCanBeStreamedWithoutCrashing)
{
    MemoryOutStream stream(8);
    stream << DBL_MAX;
    CHECK(true);
}

#endif

}

```

`ThirdParty/UnitTest++/tests/TestTest.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/TestReporter.h"
#include "UnitTest++/TimeHelpers.h"
#include "ScopedCurrentTest.h"

using namespace UnitTest;

namespace {

TEST(PassingTestHasNoFailures)
{
    class PassingTest : public Test
    {
    public:
        PassingTest() : Test("passing") {}
        virtual void RunImpl() const
        {
            CHECK(true);
        }
    };

    TestResults results;
	{
		ScopedCurrentTest scopedResults(results);
		PassingTest().Run();
	}

    CHECK_EQUAL(0, results.GetFailureCount());
}


TEST(FailingTestHasFailures)
{
    class FailingTest : public Test
    {
    public:
        FailingTest() : Test("failing") {}
        virtual void RunImpl() const
        {
            CHECK(false);
        }
    };

    TestResults results;
	{
		ScopedCurrentTest scopedResults(results);
		FailingTest().Run();
	}

    CHECK_EQUAL(1, results.GetFailureCount());
}

#ifndef UNITTEST_NO_EXCEPTIONS
TEST(ThrowingTestsAreReportedAsFailures)
{
    class CrashingTest : public Test
    {
    public:
        CrashingTest() : Test("throwing") {}
        virtual void RunImpl() const
        {
            throw "Blah";
        }
    };
 
    TestResults results;
	{
		ScopedCurrentTest scopedResult(results);
		CrashingTest().Run();
	}

	CHECK_EQUAL(1, results.GetFailureCount());
}

#if !defined(UNITTEST_MINGW) && !defined(UNITTEST_WIN32)
TEST(CrashingTestsAreReportedAsFailures)
{
    class CrashingTest : public Test
    {
    public:
        CrashingTest() : Test("crashing") {}
        virtual void RunImpl() const
        {

            reinterpret_cast< void (*)() >(0)();
        }
    };

    TestResults results;
	{
		ScopedCurrentTest scopedResult(results);
		CrashingTest().Run();
	}

	CHECK_EQUAL(1, results.GetFailureCount());
}
#endif
#endif

TEST(TestWithUnspecifiedSuiteGetsDefaultSuite)
{
    Test test("test");
    CHECK(test.m_details.suiteName != NULL);
    CHECK_EQUAL("DefaultSuite", test.m_details.suiteName);
}

TEST(TestReflectsSpecifiedSuiteName)
{
    Test test("test", "testSuite");
    CHECK(test.m_details.suiteName != NULL);
    CHECK_EQUAL("testSuite", test.m_details.suiteName);
}

void Fail()
{
	CHECK(false);
}

TEST(OutOfCoreCHECKMacrosCanFailTests)
{
	TestResults results;
	{
		ScopedCurrentTest scopedResult(results);
		Fail();
	}

	CHECK_EQUAL(1, results.GetFailureCount());
}

}

```

`ThirdParty/UnitTest++/tests/TestTestList.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/TestList.h"

using namespace UnitTest;

namespace {


TEST(TestListIsEmptyByDefault)
{
    TestList list;
    CHECK(list.GetHead() == 0);
}

TEST(AddingTestSetsHeadToTest)
{
    Test test("test");
    TestList list;
    list.Add(&test);

    CHECK(list.GetHead() == &test);
    CHECK(test.m_nextTest == 0);
}

TEST(AddingSecondTestAddsItToEndOfList)
{
    Test test1("test1");
    Test test2("test2");

    TestList list;
    list.Add(&test1);
    list.Add(&test2);

    CHECK(list.GetHead() == &test1);
    CHECK(test1.m_nextTest == &test2);
    CHECK(test2.m_nextTest == 0);
}

TEST(ListAdderAddsTestToList)
{
    TestList list;

    Test test("");    
    ListAdder adder(list, &test);

    CHECK(list.GetHead() == &test);
    CHECK(test.m_nextTest == 0);
}

}

```

`ThirdParty/UnitTest++/tests/TestTestMacros.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/TestMacros.h"
#include "UnitTest++/TestList.h"
#include "UnitTest++/TestResults.h"
#include "UnitTest++/TestReporter.h"
#include "UnitTest++/ReportAssert.h"
#include "RecordingReporter.h"
#include "ScopedCurrentTest.h"

using namespace UnitTest;
using namespace std;

namespace {

TestList list1;
TEST_EX(DummyTest, list1)
{
}

TEST (TestsAreAddedToTheListThroughMacro)
{
    CHECK(list1.GetHead() != 0);
    CHECK(list1.GetHead()->m_nextTest == 0);
}

#ifndef UNITTEST_NO_EXCEPTIONS

struct ThrowingThingie
{
    ThrowingThingie() : dummy(false)
    {
        if (!dummy)
            throw "Oops";
    }

    bool dummy;
};

TestList list2;
TEST_FIXTURE_EX(ThrowingThingie, DummyTestName, list2)
{
}

TEST (ExceptionsInFixtureAreReportedAsHappeningInTheFixture)
{
    RecordingReporter reporter;
    TestResults result(&reporter);
	{
		ScopedCurrentTest scopedResults(result);
		list2.GetHead()->Run();
	}

    CHECK(strstr(reporter.lastFailedMessage, "xception"));
    CHECK(strstr(reporter.lastFailedMessage, "fixture"));
    CHECK(strstr(reporter.lastFailedMessage, "ThrowingThingie"));
}

#endif

struct DummyFixture
{
    int x;
};

// We're really testing the macros so we just want them to compile and link
SUITE(TestSuite1)
{
	TEST(SimilarlyNamedTestsInDifferentSuitesWork)
	{
	}

	TEST_FIXTURE(DummyFixture, SimilarlyNamedFixtureTestsInDifferentSuitesWork)
	{
	}
}

SUITE(TestSuite2)
{
	TEST(SimilarlyNamedTestsInDifferentSuitesWork)
	{
	}

	TEST_FIXTURE(DummyFixture,SimilarlyNamedFixtureTestsInDifferentSuitesWork)
	{
	}
}

TestList macroTestList1;
TEST_EX(MacroTestHelper1, macroTestList1)
{
}

TEST(TestAddedWithTEST_EXMacroGetsDefaultSuite)
{
    CHECK(macroTestList1.GetHead() != NULL);
    CHECK_EQUAL ("MacroTestHelper1", macroTestList1.GetHead()->m_details.testName);
    CHECK_EQUAL ("DefaultSuite", macroTestList1.GetHead()->m_details.suiteName);
}

TestList macroTestList2;
TEST_FIXTURE_EX(DummyFixture, MacroTestHelper2, macroTestList2)
{
}

TEST(TestAddedWithTEST_FIXTURE_EXMacroGetsDefaultSuite)
{
    CHECK(macroTestList2.GetHead() != NULL);
    CHECK_EQUAL ("MacroTestHelper2", macroTestList2.GetHead()->m_details.testName);
    CHECK_EQUAL ("DefaultSuite", macroTestList2.GetHead()->m_details.suiteName);
}

#ifndef UNITTEST_NO_EXCEPTIONS

struct FixtureCtorThrows
{
	FixtureCtorThrows()	{ throw "exception"; }
};

TestList throwingFixtureTestList1;
TEST_FIXTURE_EX(FixtureCtorThrows, FixtureCtorThrowsTestName, throwingFixtureTestList1)
{
}

TEST(FixturesWithThrowingCtorsAreFailures)
{
	CHECK(throwingFixtureTestList1.GetHead() != NULL);
	RecordingReporter reporter;
	TestResults result(&reporter);
	{
		ScopedCurrentTest scopedResult(result);
		throwingFixtureTestList1.GetHead()->Run();
	}

	int const failureCount = result.GetFailedTestCount();
	CHECK_EQUAL(1, failureCount);
	CHECK(strstr(reporter.lastFailedMessage, "while constructing fixture"));
}

struct FixtureDtorThrows
{
	~FixtureDtorThrows() { throw "exception"; }
};

TestList throwingFixtureTestList2;
TEST_FIXTURE_EX(FixtureDtorThrows, FixtureDtorThrowsTestName, throwingFixtureTestList2)
{
}

TEST(FixturesWithThrowingDtorsAreFailures)
{
	CHECK(throwingFixtureTestList2.GetHead() != NULL);

	RecordingReporter reporter;
	TestResults result(&reporter);
	{
		ScopedCurrentTest scopedResult(result);
		throwingFixtureTestList2.GetHead()->Run();
	}

	int const failureCount = result.GetFailedTestCount();
	CHECK_EQUAL(1, failureCount);
	CHECK(strstr(reporter.lastFailedMessage, "while destroying fixture"));
}

const int FailingLine = 123;

struct FixtureCtorAsserts
{
	FixtureCtorAsserts()
	{
		UnitTest::ReportAssert("assert failure", "file", FailingLine);
	}
};

TestList ctorAssertFixtureTestList;
TEST_FIXTURE_EX(FixtureCtorAsserts, CorrectlyReportsAssertFailureInCtor, ctorAssertFixtureTestList)
{
}

TEST(CorrectlyReportsFixturesWithCtorsThatAssert)
{
	RecordingReporter reporter;
	TestResults result(&reporter);
	{
		ScopedCurrentTest scopedResults(result);
		ctorAssertFixtureTestList.GetHead()->Run();
	}

	const int failureCount = result.GetFailedTestCount();
	CHECK_EQUAL(1, failureCount);
	CHECK_EQUAL(FailingLine, reporter.lastFailedLine);
	CHECK(strstr(reporter.lastFailedMessage, "assert failure"));
}

#endif

}

// We're really testing if it's possible to use the same suite in two files
// to compile and link successfuly (TestTestSuite.cpp has suite with the same name)
// Note: we are outside of the anonymous namespace
SUITE(SameTestSuite)
{
	TEST(DummyTest1)
	{
	}
}

#define CUR_TEST_NAME CurrentTestDetailsContainCurrentTestInfo
#define INNER_STRINGIFY(X) #X
#define STRINGIFY(X) INNER_STRINGIFY(X)

TEST(CUR_TEST_NAME)
{
	const UnitTest::TestDetails* details = CurrentTest::Details();
	CHECK_EQUAL(STRINGIFY(CUR_TEST_NAME), details->testName);
}

#undef CUR_TEST_NAME
#undef INNER_STRINGIFY
#undef STRINGIFY

```

`ThirdParty/UnitTest++/tests/TestTestResults.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/TestResults.h"
#include "RecordingReporter.h"

using namespace UnitTest;

namespace {

TestDetails const details("testname", "suitename", "filename", 123);


TEST(StartsWithNoTestsRun)
{
    TestResults results;
    CHECK_EQUAL (0, results.GetTotalTestCount());
}

TEST(RecordsNumbersOfTests)
{
    TestResults results;
    results.OnTestStart(details);
    results.OnTestStart(details);
    results.OnTestStart(details);
    CHECK_EQUAL(3, results.GetTotalTestCount());
}

TEST(StartsWithNoTestsFailing)
{
    TestResults results;
    CHECK_EQUAL (0, results.GetFailureCount());
}

TEST(RecordsNumberOfFailures)
{
    TestResults results;
    results.OnTestFailure(details, "");
    results.OnTestFailure(details, "");
    CHECK_EQUAL(2, results.GetFailureCount());
}

TEST(RecordsNumberOfFailedTests)
{
    TestResults results;

    results.OnTestStart(details);
    results.OnTestFailure(details, "");
    results.OnTestFinish(details, 0);

    results.OnTestStart(details);
    results.OnTestFailure(details, "");
    results.OnTestFailure(details, "");
    results.OnTestFailure(details, "");
    results.OnTestFinish(details, 0);

    CHECK_EQUAL (2, results.GetFailedTestCount());
}

TEST(NotifiesReporterOfTestStartWithCorrectInfo)
{
    RecordingReporter reporter;
    TestResults results(&reporter);
    results.OnTestStart(details);

    CHECK_EQUAL (1, reporter.testRunCount);
    CHECK_EQUAL ("suitename", reporter.lastStartedSuite);
    CHECK_EQUAL ("testname", reporter.lastStartedTest);
}

TEST(NotifiesReporterOfTestFailureWithCorrectInfo)
{
    RecordingReporter reporter;
    TestResults results(&reporter);

    results.OnTestFailure(details, "failurestring");
    CHECK_EQUAL (1, reporter.testFailedCount);
    CHECK_EQUAL ("filename", reporter.lastFailedFile);
    CHECK_EQUAL (123, reporter.lastFailedLine);
    CHECK_EQUAL ("suitename", reporter.lastFailedSuite);
    CHECK_EQUAL ("testname", reporter.lastFailedTest);
    CHECK_EQUAL ("failurestring", reporter.lastFailedMessage);
}

TEST(NotifiesReporterOfCheckFailureWithCorrectInfo)
{
    RecordingReporter reporter;
    TestResults results(&reporter);

    results.OnTestFailure(details, "failurestring");
    CHECK_EQUAL (1, reporter.testFailedCount);

    CHECK_EQUAL ("filename", reporter.lastFailedFile);
    CHECK_EQUAL (123, reporter.lastFailedLine);
    CHECK_EQUAL ("testname", reporter.lastFailedTest);
    CHECK_EQUAL ("suitename", reporter.lastFailedSuite);
    CHECK_EQUAL ("failurestring", reporter.lastFailedMessage);
}

TEST(NotifiesReporterOfTestEnd)
{
    RecordingReporter reporter;
    TestResults results(&reporter);

    results.OnTestFinish(details, 0.1234f);
    CHECK_EQUAL (1, reporter.testFinishedCount);
    CHECK_EQUAL ("testname", reporter.lastFinishedTest);
    CHECK_EQUAL ("suitename", reporter.lastFinishedSuite);
    CHECK_CLOSE (0.1234f, reporter.lastFinishedTestTime, 0.0001f);
}


}

```

`ThirdParty/UnitTest++/tests/TestTestRunner.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "RecordingReporter.h"
#include "UnitTest++/ReportAssert.h"
#include "UnitTest++/TestList.h"
#include "UnitTest++/TimeHelpers.h"
#include "UnitTest++/TimeConstraint.h"
#include "UnitTest++/ReportAssertImpl.h"

using namespace UnitTest;

namespace
{
    
    struct MockTest : public Test
    {
        MockTest(char const* testName, bool const success_, bool const assert_, int const count_ = 1)
        : Test(testName)
        , success(success_)
        , asserted(assert_)
        , count(count_)
        {
        }
        
        virtual void RunImpl() const
        {
            TestResults& testResults_ = *CurrentTest::Results();

            for (int i=0; i < count; ++i)
            {
                if (asserted)
                {
                    ReportAssert("desc", "file", 0);
                }
                else if (!success)
                {
                    testResults_.OnTestFailure(m_details, "message");
                }
            }
        }
        
        bool const success;
        bool const asserted;
        int const count;
    };
    
    struct FixtureBase
    {
        FixtureBase()
        : runner(reporter)
        {
        }

        template <class Predicate>
        int RunTestsIf(TestList const& list, char const* suiteName,
                       const Predicate& predicate, int maxTestTimeInMs)
        {
            TestResults* oldResults = CurrentTest::Results();
            const TestDetails* oldDetails = CurrentTest::Details();
            int result = runner.RunTestsIf(list, suiteName, predicate, maxTestTimeInMs);
            CurrentTest::Results() = oldResults;
            CurrentTest::Details() = oldDetails;
            return result;
        }

        TestRunner runner;
        RecordingReporter reporter;
    };
    
    struct TestRunnerFixture : public FixtureBase
    {
        TestList list;
    };
    
    TEST_FIXTURE(TestRunnerFixture, TestStartIsReportedCorrectly)
    {
        MockTest test("goodtest", true, false);
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(1, reporter.testRunCount);
        CHECK_EQUAL("goodtest", reporter.lastStartedTest);
    }
    
    TEST_FIXTURE(TestRunnerFixture, TestFinishIsReportedCorrectly)
    {
        MockTest test("goodtest", true, false);
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(1, reporter.testFinishedCount);
        CHECK_EQUAL("goodtest", reporter.lastFinishedTest);
    }
    
    class SlowTest : public Test
    {
    public:
        SlowTest()
        : Test("slow", "somesuite", "filename", 123)
        {
        }
        
        virtual void RunImpl() const
        {
            TimeHelpers::SleepMs(20);
        }
    };
    
    TEST_FIXTURE(TestRunnerFixture, TestFinishIsCalledWithCorrectTime)
    {
        SlowTest test;
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK(reporter.lastFinishedTestTime >= 0.005f && reporter.lastFinishedTestTime <= 0.050f);
    }
    
    TEST_FIXTURE(TestRunnerFixture, FailureCountIsZeroWhenNoTestsAreRun)
    {
        CHECK_EQUAL(0, RunTestsIf(list, NULL, True(), 0));
        CHECK_EQUAL(0, reporter.testRunCount);
        CHECK_EQUAL(0, reporter.testFailedCount);
    }
    
    TEST_FIXTURE(TestRunnerFixture, CallsReportFailureOncePerFailingTest)
    {
        MockTest test1("test", false, false);
        list.Add(&test1);
        MockTest test2("test", true, false);
        list.Add(&test2);
        MockTest test3("test", false, false);
        list.Add(&test3);
        
        CHECK_EQUAL(2, RunTestsIf(list, NULL, True(), 0));
        CHECK_EQUAL(2, reporter.testFailedCount);
    }
    
    TEST_FIXTURE(TestRunnerFixture, TestsThatAssertAreReportedAsFailing)
    {
        MockTest test("test", true, true);
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(1, reporter.testFailedCount);
    }
    
    
    TEST_FIXTURE(TestRunnerFixture, ReporterNotifiedOfTestCount)
    {
        MockTest test1("test", true, false);
        MockTest test2("test", true, false);
        MockTest test3("test", true, false);
        list.Add(&test1);
        list.Add(&test2);
        list.Add(&test3);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(3, reporter.summaryTotalTestCount);
    }
    
    TEST_FIXTURE(TestRunnerFixture, ReporterNotifiedOfFailedTests)
    {
        MockTest test1("test", false, false, 2);
        MockTest test2("test", true, false);
        MockTest test3("test", false, false, 3);
        list.Add(&test1);
        list.Add(&test2);
        list.Add(&test3);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(2, reporter.summaryFailedTestCount);
    }
    
    TEST_FIXTURE(TestRunnerFixture, ReporterNotifiedOfFailures)
    {
        MockTest test1("test", false, false, 2);
        MockTest test2("test", true, false);
        MockTest test3("test", false, false, 3);
        list.Add(&test1);
        list.Add(&test2);
        list.Add(&test3);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(5, reporter.summaryFailureCount);
    }
    
    TEST_FIXTURE(TestRunnerFixture, SlowTestPassesForHighTimeThreshold)
    {
        SlowTest test;
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(0, reporter.testFailedCount);
    }
    
    TEST_FIXTURE(TestRunnerFixture, SlowTestFailsForLowTimeThreshold)
    {
        SlowTest test;
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 3);
        CHECK_EQUAL(1, reporter.testFailedCount);
    }
    
    TEST_FIXTURE(TestRunnerFixture, SlowTestHasCorrectFailureInformation)
    {
        SlowTest test;
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 3);
        
        using namespace std;
        
        CHECK_EQUAL(test.m_details.testName, reporter.lastFailedTest);
        CHECK(strstr(test.m_details.filename, reporter.lastFailedFile));
        CHECK_EQUAL(test.m_details.lineNumber, reporter.lastFailedLine);
        
        CHECK(strstr(reporter.lastFailedMessage, "Global time constraint failed"));
        CHECK(strstr(reporter.lastFailedMessage, "3ms"));
    }
    
    TEST_FIXTURE(TestRunnerFixture, SlowTestWithTimeExemptionPasses)
    {
        class SlowExemptedTest : public Test
        {
        public:
            SlowExemptedTest() : Test("slowexempted", "", 0) {}
            virtual void RunImpl() const
            {
                UNITTEST_TIME_CONSTRAINT_EXEMPT();
                TimeHelpers::SleepMs(20);
            }
        };
        
        SlowExemptedTest test;
        list.Add(&test);
        
        RunTestsIf(list, NULL, True(), 3);
        CHECK_EQUAL(0, reporter.testFailedCount);
    }
    
    struct TestSuiteFixture : FixtureBase
    {
        TestSuiteFixture()
        : test1("TestInDefaultSuite")
        , test2("TestInOtherSuite", "OtherSuite")
        , test3("SecondTestInDefaultSuite")
        {
            list.Add(&test1);
            list.Add(&test2);
        }
        
        Test test1;
        Test test2;
        Test test3;
        TestList list;
    };
    
    TEST_FIXTURE(TestSuiteFixture, TestRunnerRunsAllSuitesIfNullSuiteIsPassed)
    {
        RunTestsIf(list, NULL, True(), 0);
        CHECK_EQUAL(2, reporter.summaryTotalTestCount);
    }
    
    TEST_FIXTURE(TestSuiteFixture,TestRunnerRunsOnlySpecifiedSuite)
    {
        RunTestsIf(list, "OtherSuite", True(), 0);
        CHECK_EQUAL(1, reporter.summaryTotalTestCount);
        CHECK_EQUAL("TestInOtherSuite", reporter.lastFinishedTest);
    }
    
    struct RunTestIfNameIs
    {
        RunTestIfNameIs(char const* name_)
        : name(name_)
        {
        }
        
        bool operator()(const Test* const test) const
        {
            using namespace std;
            return (0 == strcmp(test->m_details.testName, name));
        }
        
        char const* name;
    };
    
    TEST(TestMockPredicateBehavesCorrectly)
    {
        RunTestIfNameIs predicate("pass");
        
        Test pass("pass");
        Test fail("fail");
        
        CHECK(predicate(&pass));
        CHECK(!predicate(&fail));   
    }
    
    TEST_FIXTURE(TestRunnerFixture, TestRunnerRunsTestsThatPassPredicate)
    {
        Test should_run("goodtest");
        list.Add(&should_run);
        
        Test should_not_run("badtest");
        list.Add(&should_not_run);
        
        RunTestsIf(list, NULL, RunTestIfNameIs("goodtest"), 0);
        CHECK_EQUAL(1, reporter.testRunCount);
        CHECK_EQUAL("goodtest", reporter.lastStartedTest);
    }
    
    TEST_FIXTURE(TestRunnerFixture, TestRunnerOnlyRunsTestsInSpecifiedSuiteAndThatPassPredicate)
    {
        Test runningTest1("goodtest", "suite");
        Test skippedTest2("goodtest");
        Test skippedTest3("badtest", "suite");
        Test skippedTest4("badtest");
        
        list.Add(&runningTest1);
        list.Add(&skippedTest2);
        list.Add(&skippedTest3);
        list.Add(&skippedTest4);
        
        RunTestsIf(list, "suite", RunTestIfNameIs("goodtest"), 0);
        
        CHECK_EQUAL(1, reporter.testRunCount);
        CHECK_EQUAL("goodtest", reporter.lastStartedTest);
        CHECK_EQUAL("suite", reporter.lastStartedSuite);
    }
    
}
```

`ThirdParty/UnitTest++/tests/TestTestSuite.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"

// We're really testing if it's possible to use the same suite in two files
// to compile and link successfuly (TestTestSuite.cpp has suite with the same name)
// Note: we are outside of the anonymous namespace
SUITE(SameTestSuite)
{
    TEST(DummyTest2)
    {
    }
}


```

`ThirdParty/UnitTest++/tests/TestTimeConstraint.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/TestResults.h"
#include "UnitTest++/TimeHelpers.h"
#include "RecordingReporter.h"
#include "ScopedCurrentTest.h"

using namespace UnitTest;

namespace
{

TEST(TimeConstraintSucceedsWithFastTest)
{
    TestResults result;
    {
		ScopedCurrentTest scopedResult(result);
        TimeConstraint t(200, TestDetails("", "", "", 0));
        TimeHelpers::SleepMs(5);
    }
    CHECK_EQUAL(0, result.GetFailureCount());
}

TEST(TimeConstraintFailsWithSlowTest)
{
    TestResults result;
    {
		ScopedCurrentTest scopedResult(result);
        TimeConstraint t(10, TestDetails("", "", "", 0));
        TimeHelpers::SleepMs(20);
    }
    CHECK_EQUAL(1, result.GetFailureCount());
}

TEST(TimeConstraintFailureIncludesCorrectData)
{
    RecordingReporter reporter;
    TestResults result(&reporter);
    {
		ScopedCurrentTest scopedResult(result);

		TestDetails const details("testname", "suitename", "filename", 10);
        TimeConstraint t(10, details);
        TimeHelpers::SleepMs(20);
    }

	using namespace std;

	CHECK(strstr(reporter.lastFailedFile, "filename"));
    CHECK_EQUAL(10, reporter.lastFailedLine);
    CHECK(strstr(reporter.lastFailedTest, "testname"));
}

TEST(TimeConstraintFailureIncludesTimeoutInformation)
{
    RecordingReporter reporter;
    TestResults result(&reporter);
    {
		ScopedCurrentTest scopedResult(result);
        TimeConstraint t(10, TestDetails("", "", "", 0));
        TimeHelpers::SleepMs(20);
    }

	using namespace std;

	CHECK(strstr(reporter.lastFailedMessage, "ime constraint"));
    CHECK(strstr(reporter.lastFailedMessage, "under 10ms"));
}

}

```

`ThirdParty/UnitTest++/tests/TestTimeConstraintMacro.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/TimeHelpers.h"

#include "RecordingReporter.h"
#include "ScopedCurrentTest.h"

namespace {

TEST(TimeConstraintMacroQualifiesNamespace)
{
    // If this compiles without a "using namespace UnitTest;", all is well.
    UNITTEST_TIME_CONSTRAINT(1);
}

TEST(TimeConstraintMacroUsesCorrectInfo)
{
    int testLine = 0;
    RecordingReporter reporter;

    {
      UnitTest::TestResults testResults(&reporter);
      ScopedCurrentTest scopedResults(testResults);

      UNITTEST_TIME_CONSTRAINT(10);  testLine = __LINE__;
      UnitTest::TimeHelpers::SleepMs(20);
    }

    using namespace std;

    CHECK_EQUAL(1, reporter.testFailedCount);
    CHECK(strstr(reporter.lastFailedFile, __FILE__));
    CHECK_EQUAL(testLine, reporter.lastFailedLine);
    CHECK(strstr(reporter.lastFailedTest, "TimeConstraintMacroUsesCorrectInfo"));
}

TEST(TimeConstraintMacroComparesAgainstPreciseActual)
{
    int testLine = 0;
    RecordingReporter reporter;

	{
		UnitTest::TestResults testResults(&reporter);
		ScopedCurrentTest scopedResults(testResults);

		UNITTEST_TIME_CONSTRAINT(1);  testLine = __LINE__;

		// start a new timer and run until we're as little over the 1 msec
		// threshold as we can achieve; this should guarantee that the "test"
		// runs in some very small amount of time > 1 msec
		UnitTest::Timer myTimer;
		myTimer.Start();

		while (myTimer.GetTimeInMs() < 1.001)
			UnitTest::TimeHelpers::SleepMs(0);
	}

    using namespace std;

    CHECK_EQUAL(1, reporter.testFailedCount);
    CHECK(strstr(reporter.lastFailedFile, __FILE__));
    CHECK_EQUAL(testLine, reporter.lastFailedLine);
    CHECK(strstr(reporter.lastFailedTest, "TimeConstraintMacroComparesAgainstPreciseActual"));
}

struct EmptyFixture {};

TEST_FIXTURE(EmptyFixture, TimeConstraintMacroWorksInFixtures)
{
    int testLine = 0;
    RecordingReporter reporter;

    {
      UnitTest::TestResults testResults(&reporter);
      ScopedCurrentTest scopedResults(testResults);

      UNITTEST_TIME_CONSTRAINT(10);  testLine = __LINE__;
      UnitTest::TimeHelpers::SleepMs(20);
    }

    using namespace std;

    CHECK_EQUAL(1, reporter.testFailedCount);
    CHECK(strstr(reporter.lastFailedFile, __FILE__));
    CHECK_EQUAL(testLine, reporter.lastFailedLine);
    CHECK(strstr(reporter.lastFailedTest, "TimeConstraintMacroWorksInFixtures"));
} 

}

```

`ThirdParty/UnitTest++/tests/TestUnitTestPP.cpp`:

```cpp
#include "UnitTest++/UnitTestPP.h"
#include "ScopedCurrentTest.h"

// These are sample tests that show the different features of the framework

namespace {

TEST(ValidCheckSucceeds)
{
    bool const b = true;
    CHECK(b);
}

TEST(CheckWorksWithPointers)
{
    void* p = (void *)0x100;
    CHECK(p);
    CHECK(p != 0);
}

TEST(ValidCheckEqualSucceeds)
{
    int const x = 3;
    int const y = 3;
    CHECK_EQUAL(x, y);
}

TEST(CheckEqualWorksWithPointers)
{
    void* p = (void *)0;
    CHECK_EQUAL((void*)0, p);
}

TEST(ValidCheckCloseSucceeds)
{
    CHECK_CLOSE(2.0f, 2.001f, 0.01f);
    CHECK_CLOSE(2.001f, 2.0f, 0.01f);
}

TEST(ArrayCloseSucceeds)
{
    float const a1[] = {1, 2, 3};
    float const a2[] = {1, 2.01f, 3};
    CHECK_ARRAY_CLOSE(a1, a2, 3, 0.1f);
}

#ifndef UNITTEST_NO_EXCEPTIONS

TEST(CheckThrowMacroSucceedsOnCorrectException)
{
    struct TestException {};
    CHECK_THROW(throw TestException(), TestException);
}

TEST(CheckAssertSucceeds)
{
    CHECK_ASSERT(UnitTest::ReportAssert("desc", "file", 0));
}

TEST(CheckThrowMacroFailsOnMissingException)
{
    class NoThrowTest : public UnitTest::Test
    {
    public:
        NoThrowTest() : Test("nothrow") {}
        void DontThrow() const
        {
        }

        virtual void RunImpl() const
        {
            CHECK_THROW(DontThrow(), int);
        }
    };

    UnitTest::TestResults results;
	{
		ScopedCurrentTest scopedResults(results);

		NoThrowTest test;
		test.Run();
	}

	CHECK_EQUAL(1, results.GetFailureCount());
}

TEST(CheckThrowMacroFailsOnWrongException)
{
    class WrongThrowTest : public UnitTest::Test
    {
    public:
        WrongThrowTest() : Test("wrongthrow") {}
        virtual void RunImpl() const
        {
            CHECK_THROW(throw "oops", int);
        }
    };

    UnitTest::TestResults results;
	{
		ScopedCurrentTest scopedResults(results);

		WrongThrowTest test;
		test.Run();
	}

	CHECK_EQUAL(1, results.GetFailureCount());
}

#endif

struct SimpleFixture
{
    SimpleFixture()
    {
        ++instanceCount;
    }
    ~SimpleFixture()
    {
        --instanceCount;
    }

    static int instanceCount;
};

int SimpleFixture::instanceCount = 0;

TEST_FIXTURE(SimpleFixture, DefaultFixtureCtorIsCalled)
{
    CHECK(SimpleFixture::instanceCount > 0);
}

TEST_FIXTURE(SimpleFixture, OnlyOneFixtureAliveAtATime)
{
    CHECK_EQUAL(1, SimpleFixture::instanceCount);
}

void CheckBool(const bool b)
{
	CHECK(b);
}

TEST(CanCallCHECKOutsideOfTestFunction)
{
	CheckBool(true);
}

}

```

`ThirdParty/UnitTest++/tests/TestXmlTestReporter.cpp`:

```cpp
#include "UnitTest++/Config.h"
#ifndef UNITTEST_NO_DEFERRED_REPORTER

#include "UnitTest++/UnitTestPP.h"
#include "UnitTest++/XmlTestReporter.h"

#include <sstream>

using namespace UnitTest;
using std::ostringstream;

namespace
{

#ifndef UNITTEST_MEMORYOUTSTREAM_IS_STD_OSTRINGSTREAM

// Overload to let MemoryOutStream accept std::string
MemoryOutStream& operator<<(MemoryOutStream& s, const std::string& value)
{
    s << value.c_str();
    return s;
}

#endif

struct XmlTestReporterFixture
{
    XmlTestReporterFixture()
        : reporter(output)
    {
    }

    ostringstream output;
    XmlTestReporter reporter;
};

TEST_FIXTURE(XmlTestReporterFixture, MultipleCharactersAreEscaped)
{
    TestDetails const details("TestName", "suite", "filename.h", 4321);

    reporter.ReportTestStart(details);
    reporter.ReportFailure(details, "\"\"\'\'&&<<>>");
    reporter.ReportTestFinish(details, 0.1f);
    reporter.ReportSummary(1, 2, 3, 0.1f);

    char const* expected =
        "<?xml version=\"1.0\"?>"
        "<unittest-results tests=\"1\" failedtests=\"2\" failures=\"3\" time=\"0.1\">"
        "<test suite=\"suite\" name=\"TestName\" time=\"0.1\">"
        "<failure message=\"filename.h(4321) : "
        "&quot;&quot;&apos;&apos;&amp;&amp;&lt;&lt;&gt;&gt;\"/>"
        "</test>"
        "</unittest-results>";

    CHECK_EQUAL(expected, output.str().c_str());
}

TEST_FIXTURE(XmlTestReporterFixture, OutputIsCachedUntilReportSummaryIsCalled)
{
    TestDetails const details("", "", "", 0);

    reporter.ReportTestStart(details);
    reporter.ReportFailure(details, "message");
    reporter.ReportTestFinish(details, 1.0F);
    CHECK(output.str().empty());

    reporter.ReportSummary(1, 1, 1, 1.0f);
    CHECK(!output.str().empty());
}

TEST_FIXTURE(XmlTestReporterFixture, EmptyReportSummaryFormat)
{
    reporter.ReportSummary(0, 0, 0, 0.1f);

    const char *expected =
		"<?xml version=\"1.0\"?>"
		"<unittest-results tests=\"0\" failedtests=\"0\" failures=\"0\" time=\"0.1\">"
		"</unittest-results>";

    CHECK_EQUAL(expected, output.str().c_str());
}

TEST_FIXTURE(XmlTestReporterFixture, SingleSuccessfulTestReportSummaryFormat)
{
    TestDetails const details("TestName", "DefaultSuite", "", 0);

    reporter.ReportTestStart(details);
    reporter.ReportSummary(1, 0, 0, 0.1f);

    const char *expected =
		"<?xml version=\"1.0\"?>"
		"<unittest-results tests=\"1\" failedtests=\"0\" failures=\"0\" time=\"0.1\">"
		"<test suite=\"DefaultSuite\" name=\"TestName\" time=\"0\"/>"
		"</unittest-results>";

    CHECK_EQUAL(expected, output.str().c_str());
}

TEST_FIXTURE(XmlTestReporterFixture, SingleFailedTestReportSummaryFormat)
{
    TestDetails const details("A Test", "suite", "A File", 4321);

    reporter.ReportTestStart(details);
    reporter.ReportFailure(details, "A Failure");
    reporter.ReportSummary(1, 1, 1, 0.1f);

    const char *expected =
        "<?xml version=\"1.0\"?>"
        "<unittest-results tests=\"1\" failedtests=\"1\" failures=\"1\" time=\"0.1\">"
        "<test suite=\"suite\" name=\"A Test\" time=\"0\">"
        "<failure message=\"A File(4321) : A Failure\"/>"
        "</test>"
        "</unittest-results>";

    CHECK_EQUAL(expected, output.str().c_str());
}

TEST_FIXTURE(XmlTestReporterFixture, FailureMessageIsXMLEscaped)
{
    TestDetails const details("TestName", "suite", "filename.h", 4321);

    reporter.ReportTestStart(details);
    reporter.ReportFailure(details, "\"\'&<>");
    reporter.ReportTestFinish(details, 0.1f);
    reporter.ReportSummary(1, 1, 1, 0.1f);

    char const* expected =
        "<?xml version=\"1.0\"?>"
        "<unittest-results tests=\"1\" failedtests=\"1\" failures=\"1\" time=\"0.1\">"
        "<test suite=\"suite\" name=\"TestName\" time=\"0.1\">"
        "<failure message=\"filename.h(4321) : &quot;&apos;&amp;&lt;&gt;\"/>"
        "</test>"
        "</unittest-results>";

    CHECK_EQUAL(expected, output.str().c_str());
}

TEST_FIXTURE(XmlTestReporterFixture, OneFailureAndOneSuccess)
{
    TestDetails const failedDetails("FailedTest", "suite", "fail.h", 1);
    reporter.ReportTestStart(failedDetails);
    reporter.ReportFailure(failedDetails, "expected 1 but was 2");
    reporter.ReportTestFinish(failedDetails, 0.1f);

    TestDetails const succeededDetails("SucceededTest", "suite", "", 0);
    reporter.ReportTestStart(succeededDetails);
    reporter.ReportTestFinish(succeededDetails, 1.0f);
    reporter.ReportSummary(2, 1, 1, 1.1f);

    char const* expected =
        "<?xml version=\"1.0\"?>"
        "<unittest-results tests=\"2\" failedtests=\"1\" failures=\"1\" time=\"1.1\">"
        "<test suite=\"suite\" name=\"FailedTest\" time=\"0.1\">"
        "<failure message=\"fail.h(1) : expected 1 but was 2\"/>"
        "</test>"
        "<test suite=\"suite\" name=\"SucceededTest\" time=\"1\"/>"
        "</unittest-results>";

    CHECK_EQUAL(expected, output.str().c_str());
}

TEST_FIXTURE(XmlTestReporterFixture, MultipleFailures)
{
    TestDetails const failedDetails1("FailedTest", "suite", "fail.h", 1);
    TestDetails const failedDetails2("FailedTest", "suite", "fail.h", 31);

    reporter.ReportTestStart(failedDetails1);
    reporter.ReportFailure(failedDetails1, "expected 1 but was 2");
    reporter.ReportFailure(failedDetails2, "expected one but was two");
    reporter.ReportTestFinish(failedDetails1, 0.1f);

    reporter.ReportSummary(1, 1, 2, 1.1f);

    char const* expected =
        "<?xml version=\"1.0\"?>"
        "<unittest-results tests=\"1\" failedtests=\"1\" failures=\"2\" time=\"1.1\">"
        "<test suite=\"suite\" name=\"FailedTest\" time=\"0.1\">"
        "<failure message=\"fail.h(1) : expected 1 but was 2\"/>"
        "<failure message=\"fail.h(31) : expected one but was two\"/>"
        "</test>"
        "</unittest-results>";

    CHECK_EQUAL(expected, output.str().c_str());
}

}

#endif

```

`appveyor.yml`:

```yml
version: 1.0.{build}

build_script:
- premake4 vs2010
- cd Build/vs2010
- MsBuild TaskScheduler.sln /t:Rebuild /p:Configuration=Release

test_script:
- cd ..\..\Bin
- TaskSchedulerTests.exe 3
```

`license.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2015 Sergey Makeev, Vadim Slyusarev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

```

`premake4.lua`:

```lua
if not _ACTION then
	_ACTION="vs2010"
end

isPosix = false
isVisualStudio = false
isOSX = false

if _ACTION == "vs2002" or _ACTION == "vs2003" or _ACTION == "vs2005" or _ACTION == "vs2008" or _ACTION == "vs2010" or _ACTION == "vs2012" then
	isVisualStudio = true
end

if _ACTION == "codeblocks" or _ACTION == "gmake"
then
	isPosix = true
end

if _ACTION == "xcode3" or os.is("macosx")
then
	isOSX = true
end



solution "TaskScheduler"

	language "C++"

	location ( "Build/" .. _ACTION )
if isVisualStudio then
	flags {"NoManifest", "ExtraWarnings", "StaticRuntime", "NoMinimalRebuild", "FloatFast" }
else
	flags {"NoManifest", "ExtraWarnings", "StaticRuntime", "NoMinimalRebuild", "FloatFast", "EnableSSE2" }
end
	optimization_flags = { "OptimizeSpeed" }
	targetdir("Bin")

if isPosix or isOSX then
	defines { "_XOPEN_SOURCE=600" }
end

if isOSX then
	defines { "_DARWIN_C_SOURCE=1" }
end

if isVisualStudio then
	defines { "_ALLOW_RTCc_IN_STL=1" }
	debugdir ("Bin")
end

	local config_list = {
		"Release",
		"Debug",
		"Instrumented_Release",
		"Instrumented_Debug"
	}
	local platform_list = {
		"x32",
		"x64"
	}

	configurations(config_list)
	platforms(platform_list)


-- CONFIGURATIONS

configuration "Instrumented_Release"
	defines { "NDEBUG", "MT_INSTRUMENTED_BUILD", "MT_UNICODE" }
	flags { "Symbols", optimization_flags }

configuration "Instrumented_Debug"
	defines { "_DEBUG", "_CRTDBG_MAP_ALLOC", "MT_INSTRUMENTED_BUILD", "MT_UNICODE" }
	flags { "Symbols" }

configuration "Release"
	defines { "NDEBUG", "MT_UNICODE" }
	flags { "Symbols", optimization_flags }

configuration "Debug"
	defines { "_DEBUG", "_CRTDBG_MAP_ALLOC", "MT_UNICODE"}
	flags { "Symbols" }

configuration "x32"
if isVisualStudio then
-- Compiler Warning (level 4) C4127. Conditional expression is constant
	buildoptions { "/wd4127"  }
	flags { "EnableSSE2" }
else
	buildoptions { "-std=c++11" }
  if isPosix then
  	linkoptions { "-rdynamic" }
  	if isOSX then
		buildoptions { "-Wno-invalid-offsetof -Wno-deprecated-declarations -fno-omit-frame-pointer" }
		--linkoptions { "-fsanitize=undefined" }
	else
--		defines { "MT_THREAD_SANITIZER"}
		buildoptions { "-Wno-invalid-offsetof -fPIE -g -fno-omit-frame-pointer" }
--		buildoptions { "-Wno-invalid-offsetof -fsanitize=address -fPIE -g -fno-omit-frame-pointer" }
--  		linkoptions { "-fsanitize=address -pie" }
  	end
  end
end

configuration "x64"
if isVisualStudio then
-- Compiler Warning (level 4) C4127. Conditional expression is constant
	buildoptions { "/wd4127"  }
else
	buildoptions { "-std=c++11" }
  if isPosix then
  	linkoptions { "-rdynamic" }
  	if isOSX then
		buildoptions { "-Wno-invalid-offsetof -Wno-deprecated-declarations -fno-omit-frame-pointer" }
		--linkoptions { "-fsanitize=undefined" }
	else
--		defines { "MT_THREAD_SANITIZER"}
		buildoptions { "-Wno-invalid-offsetof -fPIE -g -fno-omit-frame-pointer" }
--		buildoptions { "-Wno-invalid-offsetof -fsanitize=address -fPIE -g -fno-omit-frame-pointer" }
--  		linkoptions { "-fsanitize=address -pie" }
  	end
  end
end


--  give each configuration/platform a unique output directory

for _, config in ipairs(config_list) do
	for _, plat in ipairs(platform_list) do
		configuration { config, plat }
		objdir    ( "Build/" .. _ACTION .. "/tmp/"  .. config  .. "-" .. plat )
	end
end

os.mkdir("./Bin")

-- SUBPROJECTS


project "UnitTest++"
	kind "StaticLib"
	defines {
		"_CRT_SECURE_NO_WARNINGS"
	}

	files {
		"ThirdParty/UnitTest++/UnitTest++/**.cpp",
		"ThirdParty/UnitTest++/UnitTest++/**.h", 
	}

	if isPosix or isOSX then
		excludes { "ThirdParty/UnitTest++/UnitTest++/Win32/**.*" }
	else
		excludes { "ThirdParty/UnitTest++/UnitTest++/Posix/**.*" }
	end


project "Squish"
	kind "StaticLib"
	defines { 
		"_CRT_SECURE_NO_WARNINGS"
	}

	files {
		"ThirdParty/Squish/**.*", 
	}

	includedirs {
		"ThirdParty/Squish"
	}

project "TaskScheduler"
    kind "StaticLib"
 	flags {"NoPCH"}
 	files {
 		"Scheduler/**.*",
		 "ThirdParty/Boost.Context/*.h",
 	}

	includedirs {
		"ThirdParty/Squish", "Scheduler/Include", "ThirdParty/UnitTest++/UnitTest++", "ThirdParty/Boost.Context"
	}
	
	if isPosix or isOSX then
	excludes { "Src/Platform/Windows/**.*" }
	else
	excludes { "Src/Platform/Posix/**.*" }
	end

project "TaskSchedulerTests"
 	flags {"NoPCH"}
 	kind "ConsoleApp"
 	files {
 		"SchedulerTests/**.*", 
 	}

	includedirs {
		"ThirdParty/Squish", "Scheduler/Include", "ThirdParty/UnitTest++/UnitTest++"
	}
	
	if isPosix or isOSX then
	excludes { "Src/Platform/Windows/**.*" }
	else
	excludes { "Src/Platform/Posix/**.*" }
	end

	links {
		"UnitTest++", "Squish", "TaskScheduler"
	}

	if isPosix or isOSX then
		links { "pthread" }
	end



```