Project Path: arc_borzacchiello_seninja_ic2sbid4

Source Tree:

```txt
arc_borzacchiello_seninja_ic2sbid4
├── LICENSE
├── README.md
├── __init__.py
├── apis.py
├── arch
│   ├── arch_aarch64.py
│   ├── arch_aarch64_sph.py
│   ├── arch_abstract.py
│   ├── arch_arm32.py
│   ├── arch_armv7.py
│   ├── arch_armv7_sph.py
│   ├── arch_riscv.py
│   ├── arch_x86.py
│   ├── arch_x86_64.py
│   ├── arch_x86_64_sph.py
│   └── arch_x86_sph.py
├── expr
│   ├── __init__.py
│   ├── bitvector.py
│   ├── bitvector_array.py
│   ├── bool_expr.py
│   └── interval.py
├── globals.py
├── media
│   ├── icons
│   │   ├── cancel.svg
│   │   ├── pi.svg
│   │   ├── reset_searchers.svg
│   │   ├── run_addr.svg
│   │   ├── run_bfs.svg
│   │   ├── run_branch.svg
│   │   ├── run_dfs.svg
│   │   ├── set_avoid.svg
│   │   ├── set_target.svg
│   │   ├── start.svg
│   │   ├── stepinto.svg
│   │   └── stop.svg
│   └── pictures
│       ├── buffers.png
│       ├── files.png
│       ├── memory.png
│       ├── registers.png
│       ├── screenshot.png
│       └── states.png
├── memory
│   ├── memory_abstract.py
│   ├── memory_object.py
│   ├── registers.py
│   ├── sym_file.py
│   ├── sym_flat_memory.py
│   ├── sym_flat_memory_not_paged.py
│   └── sym_memory.py
├── models
│   ├── function_models.py
│   ├── libc.py
│   ├── linux_syscalls.py
│   ├── others.py
│   ├── string.py
│   ├── teensy.py
│   └── unistd.py
├── multipath
│   ├── fringe.py
│   └── searcher.py
├── os_models
│   ├── linux.py
│   ├── macos.py
│   ├── null.py
│   ├── os_abstract.py
│   ├── os_file.py
│   └── windows.py
├── plugin.json
├── requirements.txt
├── settings.py
├── sym_executor.py
├── sym_solver.py
├── sym_state.py
├── sym_visitor.py
├── target
│   ├── __init__.py
│   ├── abi.py
│   ├── arch.py
│   ├── context.py
│   ├── layout.py
│   ├── registry.py
│   └── syscall.py
├── tests
│   ├── __init__.py
│   ├── file_tests.py
│   ├── memory_tests.py
│   ├── os_linux_tests.py
│   └── os_windows_tests.py
├── ui
│   ├── __init__.py
│   ├── argv_form.py
│   ├── buffer_view.py
│   ├── control_view.py
│   ├── files_view.py
│   ├── memory_view.py
│   ├── qmemview.py
│   ├── registers_view.py
│   ├── seninja_widget.py
│   ├── state_view.py
│   └── ui_manager.py
└── utility
    ├── aarch64_native_handlers_util.py
    ├── armv7_native_handlers_util.py
    ├── binary_ninja_cache.py
    ├── bninja_util.py
    ├── exceptions.py
    ├── expr_wrap_util.py
    ├── models_util.py
    ├── string_util.py
    ├── x86_native_handlers_util.py
    └── z3_wrap_util.py

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2019-2024, Luca Borzacchiello
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# SENinja - Symbolic Execution Plugin for Binary Ninja
![](media/pictures/screenshot.png)
This is a binary ninja plugin that implements a symbolic execution engine based only on z3, highly inspired by the _angr framework_ (https://angr.io/). 
The plugin is implemented as an emulator of LLIL instructions that builds and manipulates z3 formulas. 

SENinja simulates a debugger: the execution is _path driven_, only one state is _active_ and executes instructions. The other states, generated at branches, are saved in a _deferred queue_. At any time, the active state can be changed with a deferred one.

### UI Widgets

SENinja comes with a side-panel widget that can be used to start and control the execution using the following buttons:

- <img src="media/icons/start.svg" alt="" width="10"/>: start the execution
- <img src="media/icons/stepinto.svg" alt="" width="10"/>: step the current state
- <img src="media/icons/run_branch.svg" alt="" width="10"/>: run until branch
- <img src="media/icons/run_addr.svg" alt="" width="10"/>: execute the current state until the currently selected address
- <img src="media/icons/run_dfs.svg" alt="" width="10"/>: start a DFS search
- <img src="media/icons/run_bfs.svg" alt="" width="10"/>: start a BFS search
- <img src="media/icons/set_target.svg" alt="" width="10"/>: set the currently selected address as the target of the search
- <img src="media/icons/set_avoid.svg" alt="" width="10"/>: avoid the currently selected address during a search
- <img src="media/icons/reset_searchers.svg" alt="" width="10"/>: reset targets and avoid addresses
- <img src="media/icons/stop.svg" alt="" width="10"/>: stop a search
- <img src="media/icons/cancel.svg" alt="" width="10"/>: reset SENinja

#### Register View
![](media/pictures/registers.png)

The Register View can be used to visualize the value of the registers of the active state. The value of a register can be modifyied by double-clicking on it. The right-click menu allows to:
- Copy the content of the register
- Concretize the value of the register
- Evaluate the value of the register using the solver
- Inject symbols
- Show the register expression
- Set the register to the address of a buffer created with the buffer view

#### Memory View
![](media/pictures/memory.png)

The Memory View can be used to visualize the value of a portion of memory of the active state. By clicking on "monitor memory", the user can specify a memory address to monitor. The widget will show 512 bytes starting from that address. 
The memory view is splitted in two sections: an hexview and an ascii view. The hexview shows the hex value of each byte only if the byte is mapped and concrete. If the byte is unmapped, the characted `_` is shown; if the byte is symbolic, the widget shows the character `.`. 

The right-click menu allows to:
- Copy the selection (in various format, e.g. little-endian, binary, etc.)
- Concretize the value of the selection
- Evaluate the value of the selection using the solver
- Inject symbols

#### Buffers View
![](media/pictures/buffers.png)
This widget allows the creation of buffers containing symbolic data.

### Command Line APIs

More APIs can be executed through the python shell. For example, we can use the solver to _prove_ a condition for the current state:
``` python
>>> import borzacchiello_seninja as seninja
>>> s = seninja.get_current_state()
>>> s.solver.satisfiable(extra_constraints=[s.regs.eax == 3])
```
the code will check the satisfiablity of `eax == 3` given the path constraint of the active state.

Consult the [wiki](https://github.com/borzacchiello/seninja/wiki) to have more info about the commands.

### Settings

SENinja gives to the user the possibility to configure many parts of the symbolic engine (e.g. dimension of pages, symbolic memory access strategy, etc.). 
All the available settings can be accessed and modified by clicking on `Edit/Preferences/Settings` and selecting `SENinja` in the left widget.


#### Version and Dependencies
Tested with 
- binary ninja `4.0` with personal license
- python `3.11`
- z3 `4.8.14`

To make it work, you need to install z3 with pip:
`$ pip3 install z3-solver`

```

`__init__.py`:

```py
import traceback
import os

from binaryninjaui import Sidebar
from binaryninja import PluginCommand
from .utility.expr_wrap_util import split_bv_in_list
from .utility.bninja_util import get_address_after_merge
from .utility.string_util import (
    int_to_str,
    str_to_int,
    as_bytes,
    get_byte,
    str_to_bv_list,
    str_to_bv,
    constraint_alphanumeric_string,
    constraint_ascii_string
)
from .models import function_models as seninja_models
from .expr import BVV, BVS, BV, And, Or, ITE
from . import settings
from .apis import (
    get_current_state,
    register_hook,
    register_logger,
    get_stdin_bv,
    get_stdout_bv,
    reload_settings
)

from .globals import uimanager_registry
from .ui.ui_manager import UIManager
from .ui.seninja_widget import SENinjaWidgetType

Sidebar.addSidebarWidgetType(SENinjaWidgetType())

PluginCommand.register(
    "SENinja\\Setup argv...",
    "Setup argv for the current function",
    lambda bv: uimanager_registry.get_or_create(bv.file.session_id).launch_argv_dialog() if bv.file else None
)
PluginCommand.register_for_address(
    "SENinja\\Select state",
    "Select the state at the current address",
    lambda bv, addr: uimanager_registry.get_or_create(bv.file.session_id).async_change_current_state(addr) if bv.file else None
)
PluginCommand.register_for_address(
    "SENinja\\Set ip",
    "Set the instruction pointer of the current state to the selected address",
    lambda bv, addr: uimanager_registry.get_or_create(bv.file.session_id).async_change_active_state_ip(addr) if bv.file else None
)
PluginCommand.register_for_address(
    "SENinja\\Merge states",
    "Merge all the states at the current address",
    lambda bv, addr: uimanager_registry.get_or_create(bv.file.session_id).async_merge_states(addr) if bv.file else None
)
PluginCommand.register_for_address(
    "SENinja\\Mark as address to reach",
    "Set the destination address",
    lambda bv, addr: uimanager_registry.get_or_create(bv.file.session_id).set_run_target(addr) if bv.file else None
)
PluginCommand.register_for_address(
    "SENinja\\Mark as address to avoid",
    "Set the avoid address",
    lambda bv, addr: uimanager_registry.get_or_create(bv.file.session_id).set_run_avoid(addr) if bv.file else None
)

```

`apis.py`:

```py
from binaryninja import (
    log_alert,
    log_info,
    BackgroundTaskThread,
    PluginCommand
)
from .sym_executor import SymbolicExecutor
from .multipath import searcher
from .sym_state import State
from .models import function_models as seninja_models
from .expr import BVV, BVS, BV, And, Or, ITE
from .utility.string_util import (
    int_to_str,
    str_to_int,
    as_bytes,
    get_byte,
    str_to_bv_list,
    str_to_bv
)
from .utility.expr_wrap_util import split_bv_in_list
from .utility.bninja_util import get_address_after_merge
from .globals import uimanager_registry

def get_current_state():
    uimanager = uimanager_registry.get_active()
    if not uimanager or not uimanager.symbolic_started():
        return None
    return uimanager.executor.state

def constraint_bv(bv_list: list, pattern: str):
    state = get_current_state()
    if state is None:
        return

    for bv in bv_list:
        assert bv.size == 8

        expr = Or(*list(map(lambda x: bv == BVV(x, 8), pattern)))
        state.solver.add_constraints(
            expr
        )

def mk_symb_buffer(state, name, size):
    buff = BVS(name, size * 8)
    address = state.mem.allocate(size)
    state.mem.store(address, buff)
    state.symbolic_buffers.append(
        (buff, address, "")
    )
    return buff

def get_stdin_bv(state):
    r = None
    for el in state.os.get_stdin_stream():
        if r is None:
            r = el
        else:
            r = r.Concat(el)
    return r

def get_stdout_bv(state):
    r = None
    for el in state.os.get_stdout_stream():
        if r is None:
            r = el
        else:
            r = r.Concat(el)
    return r

def register_hook(address, func):
    uimanager = uimanager_registry.get_active()
    if not uimanager or not uimanager.symbolic_started():
        return
    uimanager.executor.user_hooks[address] = func


def register_logger(address, func):
    uimanager = uimanager_registry.get_active()
    if not uimanager or not uimanager.symbolic_started():
        return
    uimanager.executor.user_loggers[address] = func


def reload_settings():
    uimanager = uimanager_registry.get_active()
    if not uimanager or not uimanager.symbolic_started():
        return
    uimanager.executor.bncache.settings = {}

```

`arch/arch_aarch64.py`:

```py
from ..expr import And, Or
from .arch_abstract import Arch
from .arch_aarch64_sph import AArch64SPH


class AArch64Arch(Arch):
    REGS = {
        # GPR
        'x0': {
            'size': 8,
            'sub': {
                'w0': {'offset': 4, 'size': 4}
            }
        },
        'x1': {
            'size': 8,
            'sub': {
                'w1': {'offset': 4, 'size': 4}
            }
        },
        'x2': {
            'size': 8,
            'sub': {
                'w2': {'offset': 4, 'size': 4}
            }
        },
        'x3': {
            'size': 8,
            'sub': {
                'w3': {'offset': 4, 'size': 4}
            }
        },
        'x4': {
            'size': 8,
            'sub': {
                'w4': {'offset': 4, 'size': 4}
            }
        },
        'x5': {
            'size': 8,
            'sub': {
                'w5': {'offset': 4, 'size': 4}
            }
        },
        'x6': {
            'size': 8,
            'sub': {
                'w6': {'offset': 4, 'size': 4}
            }
        },
        'x7': {
            'size': 8,
            'sub': {
                'w7': {'offset': 4, 'size': 4}
            }
        },
        'x8': {
            'size': 8,
            'sub': {
                'w8': {'offset': 4, 'size': 4}
            }
        },
        'x9': {
            'size': 8,
            'sub': {
                'w9': {'offset': 4, 'size': 4}
            }
        },
        'x10': {
            'size': 8,
            'sub': {
                'w10': {'offset': 4, 'size': 4}
            }
        },
        'x11': {
            'size': 8,
            'sub': {
                'w11': {'offset': 4, 'size': 4}
            }
        },
        'x12': {
            'size': 8,
            'sub': {
                'w12': {'offset': 4, 'size': 4}
            }
        },
        'x13': {
            'size': 8,
            'sub': {
                'w13': {'offset': 4, 'size': 4}
            }
        },
        'x14': {
            'size': 8,
            'sub': {
                'w14': {'offset': 4, 'size': 4}
            }
        },
        'x15': {
            'size': 8,
            'sub': {
                'w15': {'offset': 4, 'size': 4}
            }
        },
        'x16': {
            'size': 8,
            'sub': {
                'w16': {'offset': 4, 'size': 4}
            }
        },
        'x17': {
            'size': 8,
            'sub': {
                'w17': {'offset': 4, 'size': 4}
            }
        },
        'x18': {
            'size': 8,
            'sub': {
                'w18': {'offset': 4, 'size': 4}
            }
        },
        'x19': {
            'size': 8,
            'sub': {
                'w19': {'offset': 4, 'size': 4}
            }
        },
        'x20': {
            'size': 8,
            'sub': {
                'w20': {'offset': 4, 'size': 4}
            }
        },
        'x21': {
            'size': 8,
            'sub': {
                'w21': {'offset': 4, 'size': 4}
            }
        },
        'x22': {
            'size': 8,
            'sub': {
                'w22': {'offset': 4, 'size': 4}
            }
        },
        'x23': {
            'size': 8,
            'sub': {
                'w23': {'offset': 4, 'size': 4}
            }
        },
        'x24': {
            'size': 8,
            'sub': {
                'w24': {'offset': 4, 'size': 4}
            }
        },
        'x25': {
            'size': 8,
            'sub': {
                'w25': {'offset': 4, 'size': 4}
            }
        },
        'x26': {
            'size': 8,
            'sub': {
                'w26': {'offset': 4, 'size': 4}
            }
        },
        'x27': {
            'size': 8,
            'sub': {
                'w27': {'offset': 4, 'size': 4}
            }
        },
        'x28': {
            'size': 8,
            'sub': {
                'w28': {'offset': 4, 'size': 4}
            }
        },
        'fp': {
            'size': 8,
            'sub': {
                'w29': {'offset': 4, 'size': 4}
            }
        },
        'lr': {
            'size': 8,
            'sub': {
                'w30': {'offset': 4, 'size': 4}
            }
        },
        'sp': {
            'size': 8,
            'sub': {
                'wsp': {'offset': 4, 'size': 4}
            }
        },
        'pc': {
            'size': 8,
            'sub': {}
        },
        'xzr': {
            'size': 8,
            'sub': {
                'wzr': {'offset': 4, 'size': 4}
            }
        },
        'v0': {
            'size': 16,
            'sub': {
                'q0': {'offset': 0, 'size': 16},
                'd0': {'offset': 8, 'size': 8},
                's0': {'offset': 12, 'size': 4},
                'h0': {'offset': 14, 'size': 2},
                'b0': {'offset': 15, 'size': 1}
            }
        },
        'v1': {
            'size': 16,
            'sub': {
                'q1': {'offset': 0, 'size': 16},
                'd1': {'offset': 8, 'size': 8},
                's1': {'offset': 12, 'size': 4},
                'h1': {'offset': 14, 'size': 2},
                'b1': {'offset': 15, 'size': 1}
            }
        },
        'v2': {
            'size': 16,
            'sub': {
                'q2': {'offset': 0, 'size': 16},
                'd2': {'offset': 8, 'size': 8},
                's2': {'offset': 12, 'size': 4},
                'h2': {'offset': 14, 'size': 2},
                'b2': {'offset': 15, 'size': 1}
            }
        },
        'v3': {
            'size': 16,
            'sub': {
                'q3': {'offset': 0, 'size': 16},
                'd3': {'offset': 8, 'size': 8},
                's3': {'offset': 12, 'size': 4},
                'h3': {'offset': 14, 'size': 2},
                'b3': {'offset': 15, 'size': 1}
            }
        },
        'v4': {
            'size': 16,
            'sub': {
                'q4': {'offset': 0, 'size': 16},
                'd4': {'offset': 8, 'size': 8},
                's4': {'offset': 12, 'size': 4},
                'h4': {'offset': 14, 'size': 2},
                'b4': {'offset': 15, 'size': 1}
            }
        },
        'v5': {
            'size': 16,
            'sub': {
                'q5': {'offset': 0, 'size': 16},
                'd5': {'offset': 8, 'size': 8},
                's5': {'offset': 12, 'size': 4},
                'h5': {'offset': 14, 'size': 2},
                'b5': {'offset': 15, 'size': 1}
            }
        },
        'v6': {
            'size': 16,
            'sub': {
                'q6': {'offset': 0, 'size': 16},
                'd6': {'offset': 8, 'size': 8},
                's6': {'offset': 12, 'size': 4},
                'h6': {'offset': 14, 'size': 2},
                'b6': {'offset': 15, 'size': 1}
            }
        },
        'v7': {
            'size': 16,
            'sub': {
                'q7': {'offset': 0, 'size': 16},
                'd7': {'offset': 8, 'size': 8},
                's7': {'offset': 12, 'size': 4},
                'h7': {'offset': 14, 'size': 2},
                'b7': {'offset': 15, 'size': 1}
            }
        },
        'v8': {
            'size': 16,
            'sub': {
                'q8': {'offset': 0, 'size': 16},
                'd8': {'offset': 8, 'size': 8},
                's8': {'offset': 12, 'size': 4},
                'h8': {'offset': 14, 'size': 2},
                'b8': {'offset': 15, 'size': 1}
            }
        },
        'v9': {
            'size': 16,
            'sub': {
                'q9': {'offset': 0, 'size': 16},
                'd9': {'offset': 8, 'size': 8},
                's9': {'offset': 12, 'size': 4},
                'h9': {'offset': 14, 'size': 2},
                'b9': {'offset': 15, 'size': 1}
            }
        },
        'v10': {
            'size': 16,
            'sub': {
                'q10': {'offset': 0, 'size': 16},
                'd10': {'offset': 8, 'size': 8},
                's10': {'offset': 12, 'size': 4},
                'h10': {'offset': 14, 'size': 2},
                'b10': {'offset': 15, 'size': 1}
            }
        },
        'v11': {
            'size': 16,
            'sub': {
                'q11': {'offset': 0, 'size': 16},
                'd11': {'offset': 8, 'size': 8},
                's11': {'offset': 12, 'size': 4},
                'h11': {'offset': 14, 'size': 2},
                'b11': {'offset': 15, 'size': 1}
            }
        },
        'v12': {
            'size': 16,
            'sub': {
                'q12': {'offset': 0, 'size': 16},
                'd12': {'offset': 8, 'size': 8},
                's12': {'offset': 12, 'size': 4},
                'h12': {'offset': 14, 'size': 2},
                'b12': {'offset': 15, 'size': 1}
            }
        },
        'v13': {
            'size': 16,
            'sub': {
                'q13': {'offset': 0, 'size': 16},
                'd13': {'offset': 8, 'size': 8},
                's13': {'offset': 12, 'size': 4},
                'h13': {'offset': 14, 'size': 2},
                'b13': {'offset': 15, 'size': 1}
            }
        },
        'v14': {
            'size': 16,
            'sub': {
                'q14': {'offset': 0, 'size': 16},
                'd14': {'offset': 8, 'size': 8},
                's14': {'offset': 12, 'size': 4},
                'h14': {'offset': 14, 'size': 2},
                'b14': {'offset': 15, 'size': 1}
            }
        },
        'v15': {
            'size': 16,
            'sub': {
                'q15': {'offset': 0, 'size': 16},
                'd15': {'offset': 8, 'size': 8},
                's15': {'offset': 12, 'size': 4},
                'h15': {'offset': 14, 'size': 2},
                'b15': {'offset': 15, 'size': 1}
            }
        },
        'v16': {
            'size': 16,
            'sub': {
                'q16': {'offset': 0, 'size': 16},
                'd16': {'offset': 8, 'size': 8},
                's16': {'offset': 12, 'size': 4},
                'h16': {'offset': 14, 'size': 2},
                'b16': {'offset': 15, 'size': 1}
            }
        },
        'v17': {
            'size': 16,
            'sub': {
                'q17': {'offset': 0, 'size': 16},
                'd17': {'offset': 8, 'size': 8},
                's17': {'offset': 12, 'size': 4},
                'h17': {'offset': 14, 'size': 2},
                'b17': {'offset': 15, 'size': 1}
            }
        },
        'v18': {
            'size': 16,
            'sub': {
                'q18': {'offset': 0, 'size': 16},
                'd18': {'offset': 8, 'size': 8},
                's18': {'offset': 12, 'size': 4},
                'h18': {'offset': 14, 'size': 2},
                'b18': {'offset': 15, 'size': 1}
            }
        },
        'v19': {
            'size': 16,
            'sub': {
                'q19': {'offset': 0, 'size': 16},
                'd19': {'offset': 8, 'size': 8},
                's19': {'offset': 12, 'size': 4},
                'h19': {'offset': 14, 'size': 2},
                'b19': {'offset': 15, 'size': 1}
            }
        },
        'v20': {
            'size': 16,
            'sub': {
                'q20': {'offset': 0, 'size': 16},
                'd20': {'offset': 8, 'size': 8},
                's20': {'offset': 12, 'size': 4},
                'h20': {'offset': 14, 'size': 2},
                'b20': {'offset': 15, 'size': 1}
            }
        },
        'v21': {
            'size': 16,
            'sub': {
                'q21': {'offset': 0, 'size': 16},
                'd21': {'offset': 8, 'size': 8},
                's21': {'offset': 12, 'size': 4},
                'h21': {'offset': 14, 'size': 2},
                'b21': {'offset': 15, 'size': 1}
            }
        },
        'v22': {
            'size': 16,
            'sub': {
                'q22': {'offset': 0, 'size': 16},
                'd22': {'offset': 8, 'size': 8},
                's22': {'offset': 12, 'size': 4},
                'h22': {'offset': 14, 'size': 2},
                'b22': {'offset': 15, 'size': 1}
            }
        },
        'v23': {
            'size': 16,
            'sub': {
                'q23': {'offset': 0, 'size': 16},
                'd23': {'offset': 8, 'size': 8},
                's23': {'offset': 12, 'size': 4},
                'h23': {'offset': 14, 'size': 2},
                'b23': {'offset': 15, 'size': 1}
            }
        },
        'v24': {
            'size': 16,
            'sub': {
                'q24': {'offset': 0, 'size': 16},
                'd24': {'offset': 8, 'size': 8},
                's24': {'offset': 12, 'size': 4},
                'h24': {'offset': 14, 'size': 2},
                'b24': {'offset': 15, 'size': 1}
            }
        },
        'v25': {
            'size': 16,
            'sub': {
                'q25': {'offset': 0, 'size': 16},
                'd25': {'offset': 8, 'size': 8},
                's25': {'offset': 12, 'size': 4},
                'h25': {'offset': 14, 'size': 2},
                'b25': {'offset': 15, 'size': 1}
            }
        },
        'v26': {
            'size': 16,
            'sub': {
                'q26': {'offset': 0, 'size': 16},
                'd26': {'offset': 8, 'size': 8},
                's26': {'offset': 12, 'size': 4},
                'h26': {'offset': 14, 'size': 2},
                'b26': {'offset': 15, 'size': 1}
            }
        },
        'v27': {
            'size': 16,
            'sub': {
                'q27': {'offset': 0, 'size': 16},
                'd27': {'offset': 8, 'size': 8},
                's27': {'offset': 12, 'size': 4},
                'h27': {'offset': 14, 'size': 2},
                'b27': {'offset': 15, 'size': 1}
            }
        },
        'v28': {
            'size': 16,
            'sub': {
                'q28': {'offset': 0, 'size': 16},
                'd28': {'offset': 8, 'size': 8},
                's28': {'offset': 12, 'size': 4},
                'h28': {'offset': 14, 'size': 2},
                'b28': {'offset': 15, 'size': 1}
            }
        },
        'v29': {
            'size': 16,
            'sub': {
                'q29': {'offset': 0, 'size': 16},
                'd29': {'offset': 8, 'size': 8},
                's29': {'offset': 12, 'size': 4},
                'h29': {'offset': 14, 'size': 2},
                'b29': {'offset': 15, 'size': 1}
            }
        },
        'v30': {
            'size': 16,
            'sub': {
                'q30': {'offset': 0, 'size': 16},
                'd30': {'offset': 8, 'size': 8},
                's30': {'offset': 12, 'size': 4},
                'h30': {'offset': 14, 'size': 2},
                'b30': {'offset': 15, 'size': 1}
            }
        },
        'v31': {
            'size': 16,
            'sub': {
                'q31': {'offset': 0, 'size': 16},
                'd31': {'offset': 8, 'size': 8},
                's31': {'offset': 12, 'size': 4},
                'h31': {'offset': 14, 'size': 2},
                'b31': {'offset': 15, 'size': 1}
            }
        }
    }

    FLAGS = {'n': 31, 'z': 30, 'c': 29, 'v': 28}

    REG_NAMES = [
        "pc", "sp", "fp", "lr",
        "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10", "x11",
        "x12", "x13", "x14", "x15", "x16", "x17", "x18", "x19", "x20", "x21", "x22",
        "x23", "x24", "x25", "x26", "x27", "x28", "xzr",
        "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v10", "v11",
        "v12", "v13", "v14", "v15", "v16", "v17", "v18", "v19", "v20", "v21", "v22",
        "v23", "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31"
    ]

    # AArch64 condition codes
    FLAGS_CONDS = {
        'EQ': lambda s: s.regs.flags['z'] == 1,  # equal
        'NE': lambda s: s.regs.flags['z'] == 0,  # not equal
        'CS': lambda s: s.regs.flags['c'] == 1,  # carry set (unsigned higher or same)
        'HS': lambda s: s.regs.flags['c'] == 1,  # unsigned higher or same (alias for CS)
        'CC': lambda s: s.regs.flags['c'] == 0,  # carry clear (unsigned lower)
        'LO': lambda s: s.regs.flags['c'] == 0,  # unsigned lower (alias for CC)
        'MI': lambda s: s.regs.flags['n'] == 1,  # minus (negative)
        'PL': lambda s: s.regs.flags['n'] == 0,  # plus (positive or zero)
        'VS': lambda s: s.regs.flags['v'] == 1,  # overflow
        'VC': lambda s: s.regs.flags['v'] == 0,  # no overflow
        'HI': lambda s: And(                     # unsigned higher
            s.regs.flags['c'] == 1,
            s.regs.flags['z'] == 0
        ),
        'LS': lambda s: Or(                      # unsigned lower or same
            s.regs.flags['c'] == 0,
            s.regs.flags['z'] == 1
        ),
        'GE': lambda s: s.regs.flags['n'] == s.regs.flags['v'],  # signed greater or equal
        'LT': lambda s: s.regs.flags['n'] != s.regs.flags['v'],  # signed less than
        'GT': lambda s: And(                     # signed greater than
            s.regs.flags['z'] == 0,
            s.regs.flags['n'] == s.regs.flags['v']
        ),
        'LE': lambda s: Or(                      # signed less than or equal
            s.regs.flags['z'] == 1,
            s.regs.flags['n'] != s.regs.flags['v']
        ),
        'AL': lambda s: True                     # always (unconditional)
    }

    sph = AArch64SPH()

    def __init__(self):
        self._bits = 64

    def bits(self):
        return self._bits

    def regs_data(self):
        return AArch64Arch.REGS

    def reg_names(self):
        return AArch64Arch.REG_NAMES

    def flags_data(self):
        return AArch64Arch.FLAGS

    def flags_default(self, flag):
        return None

    def endness(self):
        return 'little'

    def getip_reg(self):
        return 'pc'

    def get_base_pointer_reg(self):
        return 'fp'

    def get_stack_pointer_reg(self):
        return 'sp'

    def save_return_address(self, state, return_address):
        state.regs.lr = return_address

    def get_return_address(self, state):
        return state.regs.lr

    def get_argument_regs(self, calling_convention):
        return ['x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7']

    def save_result_value(self, state, calling_convention, value):
        if value.size == 8:
            state.regs.x0 = value.ZeroExt(56)
        elif value.size == 16:
            state.regs.x0 = value.ZeroExt(48)
        elif value.size == 32:
            state.regs.x0 = value.ZeroExt(32)
        elif value.size == 64:
            state.regs.x0 = value
        else:
            raise Exception("Wrong size in save_result_value")

    def get_flag_cond_lambda(self, cond: str, state):
        assert cond in AArch64Arch.FLAGS_CONDS
        return AArch64Arch.FLAGS_CONDS[cond]

    def execute_special_handler(self, disasm_str, sv):
        res = AArch64Arch.sph.handle_instruction(disasm_str, sv)
        return res

    def normalize_reg_write(self, reg_name, value, dest_size_bytes):
        if reg_name in ("xzr", "wzr"):
            return None, value
        if reg_name.startswith("w"):
            if reg_name == "wsp":
                full_reg = "sp"
            elif reg_name == "w29":
                full_reg = "fp"
            elif reg_name == "w30":
                full_reg = "lr"
            else:
                full_reg = "x" + reg_name[1:]
            if full_reg in AArch64Arch.REGS:
                full_size_bits = AArch64Arch.REGS[full_reg]["size"] * 8
                if value.size < full_size_bits:
                    value = value.ZeroExt(full_size_bits - value.size)
                elif value.size > full_size_bits:
                    value = value.Extract(full_size_bits - 1, 0)
                return full_reg, value
        return reg_name, value

    def is_synthetic_reg(self, reg_name):
        # pc and xzr aren't queryable via binja
        return reg_name in ['pc', 'xzr']

    def is_zero_reg(self, reg_name):
        return reg_name == 'xzr'


Arch.fix_reg_addressess(AArch64Arch)

```

`arch/arch_aarch64_sph.py`:

```py
from .arch_abstract import SpecialInstructionHandler


class AArch64SPH(SpecialInstructionHandler):
    def __init__(self):
        pass

    def handle_instruction(self, disasm_str: str, sv):
        inst_name = disasm_str.split(" ")[0]
        parameters = ''.join(disasm_str.split(" ")[1:]).split(",")

        return False

```

`arch/arch_abstract.py`:

```py
class Arch(object):  # abstract class
    REGS = None

    def __init__(self):
        raise NotImplementedError

    def bits(self):
        raise NotImplementedError

    def regs_data(self):
        raise NotImplementedError

    def reg_names(self):
        raise NotImplementedError

    def flags_data(self):
        raise NotImplementedError

    def flags_default(self, flag):
        raise NotImplementedError

    def endness(self):
        raise NotImplementedError

    def save_return_address(self, state, return_address):
        raise NotImplementedError

    def get_return_address(self, state):
        raise NotImplementedError

    def getip_reg(self):
        raise NotImplementedError

    def get_base_pointer_reg(self):
        raise NotImplementedError

    def get_stack_pointer_reg(self):
        raise NotImplementedError

    def get_argument_regs(self, calling_convention):
        raise NotImplementedError

    def save_result_value(self, state, calling_convention, value):
        raise NotImplementedError

    def get_flag_cond_lambda(self, cond: str):
        raise NotImplementedError

    def execute_special_handler(self, disasm_str, sv):
        raise NotImplementedError

    def normalize_reg_write(self, reg_name, value, dest_size_bytes):
        return reg_name, value

    def is_synthetic_reg(self, reg_name):
        return False

    def is_zero_reg(self, reg_name):
        return False

    @staticmethod
    def fix_reg_addressess(obj):
        assert obj.REGS is not None

        curr_addr = 0
        for reg in obj.REGS:
            if 'addr' in obj.REGS[reg]:
                # already done
                break
            obj.REGS[reg]['addr'] = curr_addr
            curr_addr += obj.REGS[reg]['size']


class SpecialInstructionHandler(object):
    def __init__(self):
        raise NotImplementedError  # do not instantiate this class

    def handle_instruction(self, disasm_str: str, sv):
        inst_name = disasm_str.split(" ")[0]
        parameters = ''.join(disasm_str.split(" ")[1:]).split(",")

        handle_name = "{}_handler".format(inst_name)
        if hasattr(self, handle_name):
            return getattr(self, handle_name)(sv, parameters)
        return False

```

`arch/arch_arm32.py`:

```py
from ..target.arch import BnArchAdapter


class Arm32Arch(BnArchAdapter):
    BASE_POINTER_CANDIDATES = ("fp", "r11")

    def __init__(self, view):
        super().__init__(view)

    def get_base_pointer_reg(self):
        if self._bp:
            return self._bp
        for name in Arm32Arch.BASE_POINTER_CANDIDATES:
            if name in self._regs:
                return name
        return super().get_base_pointer_reg()

```

`arch/arch_armv7.py`:

```py
from .arch_abstract import Arch
from .arch_armv7_sph import ArmV7SPH


class ArmV7Arch(Arch):
    REGS = {
        'r0': {
            'size': 4,
            'sub': {}
        },
        'r1': {
            'size': 4,
            'sub': {}
        },
        'r2': {
            'size': 4,
            'sub': {}
        },
        'r3': {
            'size': 4,
            'sub': {}
        },
        'r4': {
            'size': 4,
            'sub': {}
        },
        'r5': {
            'size': 4,
            'sub': {}
        },
        'r6': {
            'size': 4,
            'sub': {}
        },
        'r7': {
            'size': 4,
            'sub': {}
        },
        'r8': {
            'size': 4,
            'sub': {}
        },
        'r9': {
            'size': 4,
            'sub': {}
        },
        'r10': {
            'size': 4,
            'sub': {}
        },
        'r11': {
            'size': 4,
            'sub': {}
        },
        'r12': {
            'size': 4,
            'sub': {}
        },
        'sp': {
            'size': 4,
            'sub': {}
        },
        'lr': {
            'size': 4,
            'sub': {}
        },
        'pc': {
            'size': 4,
            'sub': {}
        }
    }

    FLAGS = {'n': 0, 'z': 0, 'c': 0, 'v': 0, 'e': 0, 't': 0, 'm': 0, 'j': 0}

    REG_NAMES = [
        "pc", "sp", "r0", "r1", "r2",  "r3",  "r4",  "r5",
        "r6", "r7", "r8", "r9", "r10", "r11", "r12", "lr"
    ]

    FLAGS_CONDS = {}

    sph = ArmV7SPH()

    def __init__(self):
        self._bits = 32

    def bits(self):
        return self._bits

    def regs_data(self):
        return ArmV7Arch.REGS

    def reg_names(self):
        return ArmV7Arch.REG_NAMES

    def flags_data(self):
        return ArmV7Arch.FLAGS

    def flags_default(self, flag):
        return None

    def endness(self):
        # is this correct? Not always...
        return 'little'

    def getip_reg(self):
        return 'pc'

    def get_base_pointer_reg(self):
        return 'r11'

    def get_stack_pointer_reg(self):
        return 'sp'

    def save_return_address(self, state, return_address):
        state.regs.lr = return_address

    def get_return_address(self, state):
        return state.regs.lr

    def get_argument_regs(self, calling_convention):
        assert calling_convention == 'cdecl'
        return ['r0', 'r1', 'r2', 'r3']

    def save_result_value(self, state, calling_convention, value):
        if value.size == 32:
            state.regs.r0 = value
        else:
            state.regs.r0 = value.ZeroExt(32 - value.size)

    def get_flag_cond_lambda(self, cond: str, state):
        assert cond in ArmV7Arch.FLAGS_CONDS
        return ArmV7Arch.FLAGS_CONDS[cond]

    def execute_special_handler(self, disasm_str, sv):
        res = ArmV7Arch.sph.handle_instruction(disasm_str, sv)
        return res


Arch.fix_reg_addressess(ArmV7Arch)

```

`arch/arch_armv7_sph.py`:

```py
from ..utility.armv7_native_handlers_util import (
    parse_mnemonic, parse_immediate,
    parse_rot_shift, ArmV7Mnemonic,
    ArmV7RotShift
)
from .arch_abstract import SpecialInstructionHandler


class ArmV7SPH(SpecialInstructionHandler):
    def __init__(self):
        pass

    # override
    def handle_instruction(self, disasm_str: str, sv):
        inst_name = disasm_str.split(" ")[0]
        parameters = ''.join(disasm_str.split(" ")[1:]).split(",")

        parsed_mnemonic = parse_mnemonic(inst_name)
        handle_name = "{}_handler".format(parsed_mnemonic.mnemonic)

        if hasattr(self, handle_name):
            return getattr(self, handle_name)(sv, parsed_mnemonic, parameters)
        return False

    def uxtb_handler(self, sv, parsed_mnemonic, parameters):
        dst_reg = parameters[0]
        src_reg = parameters[1]  # cannot be an immediate, right?

        src = getattr(sv.state.regs, src_reg)
        if len(parameters) == 3:
            # there is a rotation/shift
            op, v = parameters[2].split("#")
            if op == "ror":
                v = int(v)
                src.RotateRight(v)
            else:
                assert False  # TODO

        setattr(sv.state.regs, dst_reg, src.Extract(7, 0).ZeroExt(24))

        return True

```

`arch/arch_riscv.py`:

```py
from ..target.arch import BnArchAdapter


class RiscVArch(BnArchAdapter):
    ZERO_REG_NAMES = {"zero", "x0"}

    def __init__(self, view):
        super().__init__(view)

    def normalize_reg_write(self, reg_name, value, dest_size_bytes):
        if reg_name in RiscVArch.ZERO_REG_NAMES:
            return None, value
        return reg_name, value

    def is_synthetic_reg(self, reg_name):
        return reg_name in RiscVArch.ZERO_REG_NAMES

    def is_zero_reg(self, reg_name):
        return reg_name in RiscVArch.ZERO_REG_NAMES

```

`arch/arch_x86.py`:

```py
import z3

from .arch_abstract import Arch
from ..globals import logger
from .arch_x86_sph import ArchX86SPH


class x86Arch(Arch):
    REGS = {
        'eax': {
            'size': 4,
            'sub': {
                'ax':  {'offset': 2,  'size': 2},
                'al':  {'offset': 3,  'size': 1},
                'ah':  {'offset': 2,  'size': 1}
            }
        },
        'ebx': {
            'size': 4,
            'sub': {
                'bx':  {'offset': 2, 'size': 2},
                'bl':  {'offset': 3, 'size': 1},
                'bh':  {'offset': 2, 'size': 1}
            }
        },
        'ecx': {
            'size': 4,
            'sub': {
                'cx':  {'offset': 2, 'size': 2},
                'cl':  {'offset': 3, 'size': 1},
                'ch':  {'offset': 2, 'size': 1}
            }
        },
        'edx': {
            'size': 4,
            'sub': {
                'dx':  {'offset': 2, 'size': 2},
                'dl':  {'offset': 3, 'size': 1},
                'dh':  {'offset': 2, 'size': 1}
            }
        },
        'esi': {
            'size': 4,
            'sub': {
                'si':  {'offset': 2, 'size': 2},
                'sil': {'offset': 3, 'size': 1},
            }
        },
        'edi': {
            'size': 4,
            'sub': {
                'di':  {'offset': 2, 'size': 2},
                'dil': {'offset': 3, 'size': 1}
            }
        },
        'ebp': {
            'size': 4,
            'sub': {
                'bp':  {'offset': 2, 'size': 2},
                'bpl': {'offset': 3, 'size': 1}
            }
        },
        'esp': {
            'size': 4,
            'sub': {
                'sp':  {'offset': 2, 'size': 2},
                'spl': {'offset': 3, 'size': 1}
            }
        },
        'eip': {
            'size': 4,
            'sub': {
                'ip':  {'offset': 2, 'size': 2}
            }
        },
        'eflags': {
            'size': 4,
            'sub': {
                'flags':  {'offset': 2, 'size': 2}
            }
        },
        'gsbase': {
            'size': 4,
            'sub': {}
        },
        'fsbase': {
            'size': 4,
            'sub': {}
        }
    }

    FLAGS = {'c': 0, 'p': 2, 'a': 4, 'z': 6, 's': 7, 'd': 10, 'o': 11, 'c0': 32,
             'c1': 33, 'c2': 34, 'c3': 35}

    REG_NAMES = [
        "eip", "esp", "ebp", "eax", "ebx", "ecx", "edx", "esi", "edi",
    ]

    FLAGS_CONDS = {
        'E': lambda s: s.regs.flags['z'] == 0,
        'NE': lambda s: s.regs.flags['z'] == 1,
        'NEG': lambda s: s.regs.flags['s'] == 1,
        'POS': lambda s: s.regs.flags['s'] == 0,
        'O': lambda s: s.regs.flags['o'] == 1,
        'NO': lambda s: s.regs.flags['o'] == 0,
        'SGE': lambda s: s.regs.flags['s'] == s.regs.flags['o'],
        'SGT': lambda s: z3.And(
            s.regs.flags['z'] == 0,
            s.regs.flags['s'] == s.regs.flags['o']),
        'SLE': lambda s: z3.And(
            s.regs.flags['z'] == 1,
            s.regs.flags['s'] != s.regs.flags['o']),
        'SLT': lambda s: s.regs.flags['s'] != s.regs.flags['o'],
        'UGE': lambda s: s.regs.flags['c'] == 0,
        'UGT': lambda s: z3.And(
            s.regs.flags['c'] == 0,
            s.regs.flags['z'] == 0),
        'ULE': lambda s: z3.Or(
            s.regs.flags['z'] == 1,
            s.regs.flags['c'] == 1),
        'ULT': lambda s: s.regs.flags['c'] == 1
    }

    sph = ArchX86SPH()

    def __init__(self):
        self._bits = 32

    def bits(self):
        return self._bits

    def regs_data(self):
        return x86Arch.REGS

    def reg_names(self):
        return x86Arch.REG_NAMES

    def flags_data(self):
        return x86Arch.FLAGS

    def flags_default(self, flag):
        if flag == 'd':
            return 0
        return None

    def endness(self):
        return 'little'

    def getip_reg(self):
        return 'eip'

    def get_base_pointer_reg(self):
        return 'ebp'

    def get_stack_pointer_reg(self):
        return 'esp'

    def save_return_address(self, state, return_address):
        state.stack_push(return_address)

    def get_return_address(self, state):
        return state.stack_pop()

    def save_result_value(self, state, calling_convention, value):
        if value.size == 8:
            state.regs.al = value
        elif value.size == 16:
            state.regs.ax = value
        elif value.size == 32:
            state.regs.eax = value
        else:
            raise Exception("Wrong size in save_result_value")

    def get_argument_regs(self, calling_convention):
        if calling_convention == 'cdecl':
            return []
        if calling_convention == 'regparm':
            return ["eax", "edx", "ecx"]

        logger.log_error("!Err: unexpected calling convention %s" % calling_convention)
        return []

    def get_flag_cond_lambda(self, cond: str):
        assert cond in x86Arch.FLAGS_CONDS
        return x86Arch.FLAGS_CONDS[cond]

    def execute_special_handler(self, disasm_str, sv):
        res = x86Arch.sph.handle_instruction(disasm_str, sv)
        return res


Arch.fix_reg_addressess(x86Arch)

```

`arch/arch_x86_64.py`:

```py
from ..expr import And, Or
from .arch_abstract import Arch
from .arch_x86_64_sph import ArchX8664SPH


class x8664Arch(Arch):
    REGS = {
        'rax': {
            'size': 8,
            'sub': {
                'eax': {'offset': 4,  'size': 4},
                'ax':  {'offset': 6,  'size': 2},
                'al':  {'offset': 7,  'size': 1},
                'ah':  {'offset': 6,  'size': 1}
            }
        },
        'rbx': {
            'size': 8,
            'sub': {
                'ebx': {'offset': 4, 'size': 4},
                'bx':  {'offset': 6, 'size': 2},
                'bl':  {'offset': 7, 'size': 1},
                'bh':  {'offset': 6, 'size': 1}
            }
        },
        'rcx': {
            'size': 8,
            'sub': {
                'ecx': {'offset': 4, 'size': 4},
                'cx':  {'offset': 6, 'size': 2},
                'cl':  {'offset': 7, 'size': 1},
                'ch':  {'offset': 6, 'size': 1}
            }
        },
        'rdx': {
            'size': 8,
            'sub': {
                'edx': {'offset': 4, 'size': 4},
                'dx':  {'offset': 6, 'size': 2},
                'dl':  {'offset': 7, 'size': 1},
                'dh':  {'offset': 6, 'size': 1}
            }
        },
        'rsi': {
            'size': 8,
            'sub': {
                'esi': {'offset': 4, 'size': 4},
                'si':  {'offset': 6, 'size': 2},
                'sil': {'offset': 7, 'size': 1},
            }
        },
        'rdi': {
            'size': 8,
            'sub': {
                'edi': {'offset': 4, 'size': 4},
                'di':  {'offset': 6, 'size': 2},
                'dil': {'offset': 7, 'size': 1}
            }
        },
        'rbp': {
            'size': 8,
            'sub': {
                'ebp': {'offset': 4, 'size': 4},
                'bp':  {'offset': 6, 'size': 2},
                'bpl': {'offset': 7, 'size': 1}
            }
        },
        'rsp': {
            'size': 8,
            'sub': {
                'esp': {'offset': 4, 'size': 4},
                'sp':  {'offset': 6, 'size': 2},
                'spl': {'offset': 7, 'size': 1}
            }
        },
        'rip': {
            'size': 8,
            'sub': {
                'eip': {'offset': 4, 'size': 4},
                'ip':  {'offset': 6, 'size': 2},
            }
        },
        'rflags': {
            'size': 8,
            'sub': {
                'eflags': {'offset': 4, 'size': 4},
                'flags':  {'offset': 6, 'size': 2}
            }
        },
        'fsbase': {
            'size': 8,
            'sub': {}
        },
        'gsbase': {
            'size': 8,
            'sub': {}
        },
        'r8': {
            'size': 8,
            'sub': {
                'r8d': {'offset': 4, 'size': 4},
                'r8w': {'offset': 6, 'size': 2},
                'r8b': {'offset': 7, 'size': 1}
            }
        },
        'r9': {
            'size': 8,
            'sub': {
                'r9d': {'offset': 4, 'size': 4},
                'r9w': {'offset': 6, 'size': 2},
                'r9b': {'offset': 7, 'size': 1}
            }
        },
        'r10': {
            'size': 8,
            'sub': {
                'r10d': {'offset': 4, 'size': 4},
                'r10w': {'offset': 6, 'size': 2},
                'r10b': {'offset': 7, 'size': 1}
            }
        },
        'r11': {
            'size': 8,
            'sub': {
                'r11d': {'offset': 4, 'size': 4},
                'r11w': {'offset': 6, 'size': 2},
                'r11b': {'offset': 7, 'size': 1}
            }
        },
        'r12': {
            'size': 8,
            'sub': {
                'r12d': {'offset': 4, 'size': 4},
                'r12w': {'offset': 6, 'size': 2},
                'r12b': {'offset': 7, 'size': 1}
            }
        },
        'r13': {
            'size': 8,
            'sub': {
                'r13d': {'offset': 4, 'size': 4},
                'r13w': {'offset': 6, 'size': 2},
                'r13b': {'offset': 7, 'size': 1}
            }
        },
        'r14': {
            'size': 8,
            'sub': {
                'r14d': {'offset': 4, 'size': 4},
                'r14w': {'offset': 6, 'size': 2},
                'r14b': {'offset': 7, 'size': 1}
            }
        },
        'r15': {
            'size': 8,
            'sub': {
                'r15d': {'offset': 4, 'size': 4},
                'r15w': {'offset': 6, 'size': 2},
                'r15b': {'offset': 7, 'size': 1}
            }
        },
        'zmm0': {
            'size': 64,
            'sub': {
                'ymm0': {'offset': 32, 'size': 32},
                'xmm0': {'offset': 48, 'size': 16}
            }
        },
        'zmm1': {
            'size': 64,
            'sub': {
                'ymm1': {'offset': 32, 'size': 32},
                'xmm1': {'offset': 48, 'size': 16}
            }
        },
        'zmm2': {
            'size': 64,
            'sub': {
                'ymm2': {'offset': 32, 'size': 32},
                'xmm2': {'offset': 48, 'size': 16}
            }
        },
        'zmm3': {
            'size': 64,
            'sub': {
                'ymm3': {'offset': 32, 'size': 32},
                'xmm3': {'offset': 48, 'size': 16}
            }
        },
        'zmm4': {
            'size': 64,
            'sub': {
                'ymm4': {'offset': 32, 'size': 32},
                'xmm4': {'offset': 48, 'size': 16}
            }
        },
        'zmm5': {
            'size': 64,
            'sub': {
                'ymm5': {'offset': 32, 'size': 32},
                'xmm5': {'offset': 48, 'size': 16}
            }
        },
        'zmm6': {
            'size': 64,
            'sub': {
                'ymm6': {'offset': 32, 'size': 32},
                'xmm6': {'offset': 48, 'size': 16}
            }
        },
        'zmm7': {
            'size': 64,
            'sub': {
                'ymm7': {'offset': 32, 'size': 32},
                'xmm7': {'offset': 48, 'size': 16}
            }
        },
        'zmm8': {
            'size': 64,
            'sub': {
                'ymm8': {'offset': 32, 'size': 32},
                'xmm8': {'offset': 48, 'size': 16}
            }
        },
        'zmm9': {
            'size': 64,
            'sub': {
                'ymm9': {'offset': 32, 'size': 32},
                'xmm9': {'offset': 48, 'size': 16}
            }
        },
        'zmm10': {
            'size': 64,
            'sub': {
                'ymm10': {'offset': 32, 'size': 32},
                'xmm10': {'offset': 48, 'size': 16}
            }
        },
        'zmm11': {
            'size': 64,
            'sub': {
                'ymm11': {'offset': 32, 'size': 32},
                'xmm11': {'offset': 48, 'size': 16}
            }
        },
        'zmm12': {
            'size': 64,
            'sub': {
                'ymm12': {'offset': 32, 'size': 32},
                'xmm12': {'offset': 48, 'size': 16}
            }
        },
        'zmm13': {
            'size': 64,
            'sub': {
                'ymm13': {'offset': 32, 'size': 32},
                'xmm13': {'offset': 48, 'size': 16}
            }
        },
        'zmm14': {
            'size': 64,
            'sub': {
                'ymm14': {'offset': 32, 'size': 32},
                'xmm14': {'offset': 48, 'size': 16}
            }
        },
        'zmm15': {
            'size': 64,
            'sub': {
                'ymm15': {'offset': 32, 'size': 32},
                'xmm15': {'offset': 48, 'size': 16}
            }
        },
        'zmm16': {
            'size': 64,
            'sub': {
                'ymm16': {'offset': 32, 'size': 32},
                'xmm16': {'offset': 48, 'size': 16}
            }
        },
        'zmm17': {
            'size': 64,
            'sub': {
                'ymm17': {'offset': 32, 'size': 32},
                'xmm17': {'offset': 48, 'size': 16}
            }
        },
        'zmm18': {
            'size': 64,
            'sub': {
                'ymm18': {'offset': 32, 'size': 32},
                'xmm18': {'offset': 48, 'size': 16}
            }
        },
        'zmm19': {
            'size': 64,
            'sub': {
                'ymm19': {'offset': 32, 'size': 32},
                'xmm19': {'offset': 48, 'size': 16}
            }
        },
        'zmm20': {
            'size': 64,
            'sub': {
                'ymm20': {'offset': 32, 'size': 32},
                'xmm20': {'offset': 48, 'size': 16}
            }
        },
        'zmm21': {
            'size': 64,
            'sub': {
                'ymm21': {'offset': 32, 'size': 32},
                'xmm21': {'offset': 48, 'size': 16}
            }
        },
        'zmm22': {
            'size': 64,
            'sub': {
                'ymm22': {'offset': 32, 'size': 32},
                'xmm22': {'offset': 48, 'size': 16}
            }
        },
        'zmm23': {
            'size': 64,
            'sub': {
                'ymm23': {'offset': 32, 'size': 32},
                'xmm23': {'offset': 48, 'size': 16}
            }
        },
        'zmm24': {
            'size': 64,
            'sub': {
                'ymm24': {'offset': 32, 'size': 32},
                'xmm24': {'offset': 48, 'size': 16}
            }
        },
        'zmm25': {
            'size': 64,
            'sub': {
                'ymm25': {'offset': 32, 'size': 32},
                'xmm25': {'offset': 48, 'size': 16}
            }
        },
        'zmm26': {
            'size': 64,
            'sub': {
                'ymm26': {'offset': 32, 'size': 32},
                'xmm26': {'offset': 48, 'size': 16}
            }
        },
        'zmm27': {
            'size': 64,
            'sub': {
                'ymm27': {'offset': 32, 'size': 32},
                'xmm27': {'offset': 48, 'size': 16}
            }
        },
        'zmm28': {
            'size': 64,
            'sub': {
                'ymm28': {'offset': 32, 'size': 32},
                'xmm28': {'offset': 48, 'size': 16}
            }
        },
        'zmm29': {
            'size': 64,
            'sub': {
                'ymm29': {'offset': 32, 'size': 32},
                'xmm29': {'offset': 48, 'size': 16}
            }
        },
        'zmm30': {
            'size': 64,
            'sub': {
                'ymm30': {'offset': 32, 'size': 32},
                'xmm30': {'offset': 48, 'size': 16}
            }
        },
        'zmm31': {
            'size': 64,
            'sub': {
                'ymm31': {'offset': 32, 'size': 32},
                'xmm31': {'offset': 48, 'size': 16}
            }
        }
    }

    FLAGS = {'c': 0, 'p': 2, 'a': 4, 'z': 6, 's': 7, 'd': 10,
             'o': 11, 'c0': 32, 'c1': 33, 'c2': 34, 'c3': 35}

    REG_NAMES = [
        "rip", "rsp", "rbp", "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13",
        "r14", "r15", "zmm0", "zmm1", "zmm2",
        "zmm3", "zmm4", "zmm5", "zmm6", "zmm7", "zmm8", "zmm9", "zmm10", "zmm11", "zmm12", "zmm13", "zmm14",
        "zmm15", "zmm16", "zmm17", "zmm18", "zmm19", "zmm20", "zmm21", "zmm22", "zmm23", "zmm24", "zmm25",
        "zmm26", "zmm27", "zmm28", "zmm29", "zmm30", "zmm31"
    ]

    FLAGS_CONDS = {
        'E': lambda s: s.regs.flags['z'] == 0,
        'NE': lambda s: s.regs.flags['z'] == 1,
        'NEG': lambda s: s.regs.flags['s'] == 1,
        'POS': lambda s: s.regs.flags['s'] == 0,
        'O': lambda s: s.regs.flags['o'] == 1,
        'NO': lambda s: s.regs.flags['o'] == 0,
        'SGE': lambda s: s.regs.flags['s'] == s.regs.flags['o'],
        'SGT': lambda s: And(
            s.regs.flags['z'] == 0,
            s.regs.flags['s'] == s.regs.flags['o']),
        'SLE': lambda s: And(
            s.regs.flags['z'] == 1,
            s.regs.flags['s'] != s.regs.flags['o']),
        'SLT': lambda s: s.regs.flags['s'] != s.regs.flags['o'],
        'UGE': lambda s: s.regs.flags['c'] == 0,
        'UGT': lambda s: And(
            s.regs.flags['c'] == 0,
            s.regs.flags['z'] == 0),
        'ULE': lambda s: Or(
            s.regs.flags['z'] == 1,
            s.regs.flags['c'] == 1),
        'ULT': lambda s: s.regs.flags['c'] == 1
    }

    sph = ArchX8664SPH()

    def __init__(self):
        self._bits = 64

    def bits(self):
        return self._bits

    def regs_data(self):
        return x8664Arch.REGS

    def reg_names(self):
        return x8664Arch.REG_NAMES

    def flags_data(self):
        return x8664Arch.FLAGS

    def flags_default(self, flag):
        if flag == 'd':
            return 0
        return None

    def endness(self):
        return 'little'

    def getip_reg(self):
        return 'rip'

    def get_base_pointer_reg(self):
        return 'rbp'

    def get_stack_pointer_reg(self):
        return 'rsp'

    def save_return_address(self, state, return_address):
        state.stack_push(return_address)

    def get_return_address(self, state):
        return state.stack_pop()

    def get_argument_regs(self, calling_convention):
        if calling_convention == 'cdecl':
            return []
        elif calling_convention == 'sysv':
            return ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9']
        elif calling_convention == 'win64':
            return ['rcx', 'rdx', 'r8', 'r9']
        raise Exception("Unknown calling convention {name}".format(
            name=calling_convention
        ))

    def save_result_value(self, state, calling_convention, value):
        if value.size == 8:
            state.regs.al = value
        elif value.size == 16:
            state.regs.ax = value
        elif value.size == 32:
            state.regs.rax = value.ZeroExt(32)
        elif value.size == 64:
            state.regs.rax = value
        else:
            raise Exception("Wrong size in save_result_value")

    def get_flag_cond_lambda(self, cond: str, state):
        assert cond in x8664Arch.FLAGS_CONDS
        return x8664Arch.FLAGS_CONDS[cond]

    def execute_special_handler(self, disasm_str, sv):
        res = x8664Arch.sph.handle_instruction(disasm_str, sv)
        return res

    def normalize_reg_write(self, reg_name, value, dest_size_bytes):
        zero_extend_regs = {
            'eax',  'ebx',  'ecx',  'edx',
            'edi',  'esi',  'esp',  'ebp',
            'r8d',  'r9d',  'r10d', 'r11d',
            'r12d', 'r13d', 'r14d', 'r15d'
        }
        if reg_name in zero_extend_regs:
            full_reg = ("r" + reg_name[1:]) if reg_name[0] == 'e' else reg_name[:-1]
            full_size_bits = x8664Arch.REGS[full_reg]['size'] * 8
            if value.size < full_size_bits:
                value = value.ZeroExt(full_size_bits - value.size)
            elif value.size > full_size_bits:
                value = value.Extract(full_size_bits - 1, 0)
            return full_reg, value
        return reg_name, value


Arch.fix_reg_addressess(x8664Arch)

```

`arch/arch_x86_64_sph.py`:

```py
from .arch_x86_sph import ArchX86SPH
from ..utility.x86_native_handlers_util import (
    get_src, store_to_dst
)
from ..utility.expr_wrap_util import split_bv_in_list
from ..expr import BVArray, ITE, BVV


class ArchX8664SPH(ArchX86SPH):
    def __init__(self):
        self._vpermd_idx = 0
        self._vpshufb_idx = 0

    def cpuid_handler(self, sv, parameters):
        return self.cpuid_util(sv, 64)

    def xgetbv_handler(self, sv, parameters):
        sv.state.regs.rax = BVV(7, 64)
        sv.state.regs.rdx = BVV(0, 64)
        return True

    # --- AVX2 ---
    def vmovdqu_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        src = get_src(sv.state, src_p)
        store_to_dst(sv.state, dst_p, src)

        return True

    def vpmaddubsw_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, src2_p)
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for i in range(0, 32, 2):
            a1 = src1_bytes[i].ZeroExt(8)
            a2 = src1_bytes[i+1].ZeroExt(8)
            b1 = src2_bytes[i].SignExt(8)
            b2 = src2_bytes[i+1].SignExt(8)

            w1 = a1 * b1
            w2 = a2 * b2

            res = (
                w1 + w2
            ) if res is None else (
                (w1 + w2).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpmaddwd_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_words = split_bv_in_list(src1, 16)
        src2 = get_src(sv.state, src2_p)
        src2_words = split_bv_in_list(src2, 16)

        res = None
        for i in range(0, 16, 2):
            a1 = src1_words[i].SignExt(16)
            a2 = src1_words[i+1].SignExt(16)
            b1 = src2_words[i].SignExt(16)
            b2 = src2_words[i+1].SignExt(16)

            d1 = a1 * b1
            d2 = a2 * b2

            res = (
                d1 + d2
            ) if res is None else (
                (d1 + d2).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpaddd_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_dwords = split_bv_in_list(src1, 32)
        src2 = get_src(sv.state, src2_p)
        src2_dwords = split_bv_in_list(src2, 32)

        res = None
        for i in range(32 // 4):
            res = (
                src1_dwords[i] + src2_dwords[i]
            ) if res is None else (
                (src1_dwords[i] + src2_dwords[i]).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpaddb_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, src2_p)
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for i in range(32):
            res = (
                src1_bytes[i] + src2_bytes[i]
            ) if res is None else (
                (src1_bytes[i] + src2_bytes[i]).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpxor_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src2 = get_src(sv.state, src2_p)

        res = src1 ^ src2

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpor_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src2 = get_src(sv.state, src2_p)

        res = src1 | src2

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpand_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src2 = get_src(sv.state, src2_p)

        res = src1 & src2

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpermd_handler(self, sv, parameters):
        dst_p = parameters[0]
        idx_p = parameters[1]
        src_p = parameters[2]

        # get src and store it in a BVArray
        src = get_src(sv.state, src_p)
        src_dwords = split_bv_in_list(src, 32)
        assert len(src_dwords) == 8
        array_src = BVArray(
            "vpermd_array_{}".format(self._vpermd_idx),
            3,
            32
        )
        for i in range(8):
            array_src.Store(i, src_dwords[i])

        # get idx
        idx = get_src(sv.state, idx_p)
        idx_dwords = split_bv_in_list(idx, 32)

        # compute permutation
        res = None
        for idx in idx_dwords:
            idx_value = idx.Extract(2, 0)
            res = (
                array_src.Select(idx_value)
            ) if res is None else (
                array_src.Select(idx_value).Concat(
                    res
                )
            )

        # save result
        store_to_dst(sv.state, dst_p, res)
        sv.state.solver.add_constraints(*array_src.get_assertions())

        self._vpermd_idx += 1
        return True

    def vpshufb_handler(self, sv, parameters):
        dst_p = parameters[0]
        idx_p = parameters[2]
        src_p = parameters[1]

        src = get_src(sv.state, src_p)
        src_bytes = split_bv_in_list(src, 8)
        idx = get_src(sv.state, idx_p)
        idx_bytes = split_bv_in_list(idx, 8)

        array_src_low = BVArray(
            "vpshufb_array_low_{}".format(self._vpshufb_idx),
            4,
            8
        )
        for i in range(16):
            array_src_low.Store(i, src_bytes[i])

        array_src_hig = BVArray(
            "vpshufb_array_hig_{}".format(self._vpshufb_idx),
            4,
            8
        )
        for i in range(16, 32):
            array_src_hig.Store(i, src_bytes[i])

        idx_bytes_low = idx_bytes[:16]
        idx_bytes_hig = idx_bytes[16:]

        res = None
        for idx in idx_bytes_low:
            idx_low4 = idx.Extract(3, 0)
            val = ITE(
                idx.Extract(7, 7) == 0,
                array_src_low.Select(idx_low4),
                BVV(0, 8)
            )
            res = (
                val
            ) if res is None else (
                val.Concat(
                    res
                )
            )
        for idx in idx_bytes_hig:
            idx_low4 = idx.Extract(3, 0)
            val = ITE(
                idx.Extract(7, 7) == 0,
                array_src_hig.Select(idx_low4),
                BVV(0, 8)
            )
            res = val.Concat(res)

        # save result
        store_to_dst(sv.state, dst_p, res)
        sv.state.solver.add_constraints(*array_src_low.get_assertions())
        sv.state.solver.add_constraints(*array_src_hig.get_assertions())

        self._vpshufb_idx += 1
        return True

    def vpsrld_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]
        count_p = parameters[2]

        src = get_src(sv.state, src_p)
        src_dwords = split_bv_in_list(src, 32)

        count = get_src(sv.state, count_p)
        count = count.Extract(31, 0)

        res = None
        for dw in src_dwords:
            res = (
                dw.LShR(count)
            ) if res is None else(
                dw.LShR(count).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpslld_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]
        count_p = parameters[2]

        src = get_src(sv.state, src_p)
        src_dwords = split_bv_in_list(src, 32)

        count = get_src(sv.state, count_p)
        count = count.Extract(31, 0)

        res = None
        for dw in src_dwords:
            res = (
                dw.LShL(count)
            ) if res is None else (
                dw.LShL(count).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpcmpeqb_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, src2_p)
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for i in range(32):
            val = ITE(
                src1_bytes[i] == src2_bytes[i],
                BVV(0xff, 8),
                BVV(0x00, 8)
            )
            res = (
                val
            ) if res is None else (
                val.Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpmovmskb_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        src = get_src(sv.state, src_p)
        src_bytes = split_bv_in_list(src, 8)

        res = None
        for i in range(32):
            val = src_bytes[i].Extract(7, 7)
            res = (
                val
            ) if res is None else (
                val.Concat(res)
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def unpcklpd_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        dst = get_src(sv.state, dst_p)
        src = get_src(sv.state, src_p)

        res = src.Extract(63, 0).Concat(dst.Extract(63, 0))
        store_to_dst(sv.state, dst_p, res)
        return True
    # ------------

```

`arch/arch_x86_sph.py`:

```py
from ..utility.bninja_util import (
    get_function, get_addr_next_inst
)
from ..utility.x86_native_handlers_util import (
    store_to_dst, get_src
)
from ..utility.expr_wrap_util import split_bv_in_list
from ..utility.exceptions import ModelError
from ..expr import ITE, BVV, Bool
from .arch_abstract import SpecialInstructionHandler


class ArchX86SPH(SpecialInstructionHandler):
    flag_ops = ['a', 'ae', 'b', 'be', 'c', 'e', 'g', 'ge', 'l',
                'le', 'na', 'ae', 'nb', 'nbe', 'nc', 'ne', 'ng', 'nge',
                'nl', 'nle', 'no', 'np', 'ns', 'nz', 'o', 'p', 'pe',
                'po', 's', 'z']

    def __init__(self):
        setcc_format = "set{fo}_handler"
        cmovcc_format = "cmov{fo}_handler"
        for fo in ArchX86SPH.flag_ops:
            setattr(
                self,
                setcc_format.format(fo=fo),
                lambda sv, parameters: self._setCC(sv, parameters)
            )
            setattr(
                self,
                cmovcc_format.format(fo=fo),
                lambda sv, parameters: self._cmovCC(sv, parameters)
            )

    def _setCC(self, executor, parameters):
        func = executor.bncache.get_function(executor.ip)
        expr = func.llil[executor.llil_ip]
        if expr.operation.name != "LLIL_IF":
            return False

        # we have cmp/test + setCC. Avoid fork
        cond = executor.visitor.visit(expr.condition)
        if not isinstance(cond, Bool):
            assert cond.size == 1
            cond = cond == BVV(1, 1)  # to bool

        v = ITE(cond, BVV(1, 8), BVV(0, 8))
        store_to_dst(executor.state, parameters[0], v)

        return True

    def _cmovCC(self, executor, parameters):
        func = executor.bncache.get_function(executor.ip)
        expr = func.llil[executor.llil_ip]
        if expr.operation.name != "LLIL_IF":
            return False

        # we have cmp/test + cmovCC. Avoid fork
        cond = executor.visitor.visit(expr.condition)
        if not isinstance(cond, Bool):
            assert cond.size == 1
            cond = cond == BVV(1, 1)  # to bool

        new_data = get_src(executor.state, parameters[1])
        old_data = get_src(executor.state, parameters[0])
        cond_data = ITE(cond, new_data, old_data)

        store_to_dst(executor.state, parameters[0], cond_data)

        return True

    def cpuid_util(self, sv, bits):
        dst_eax = 'eax' if bits == 32 else 'rax'
        dst_ebx = 'ebx' if bits == 32 else 'rbx'
        dst_ecx = 'ecx' if bits == 32 else 'rcx'
        dst_edx = 'edx' if bits == 32 else 'rdx'

        eax_v = sv.state.regs.eax
        ecx_v = sv.state.regs.ecx
        if not isinstance(eax_v, BVV):
            raise ModelError("cpuid", "symbolic eax")
        if not isinstance(ecx_v, BVV):
            raise ModelError("cpuid", "symbolic ecx")
        eax_v = eax_v.value
        ecx_v = ecx_v.value
        if eax_v == 0 and ecx_v == 0:
            setattr(sv.state.regs, dst_eax, BVV(0x00000010, bits))
            setattr(sv.state.regs, dst_ebx, BVV(0x68747541, bits))
            setattr(sv.state.regs, dst_ecx, BVV(0x444d4163, bits))
            setattr(sv.state.regs, dst_edx, BVV(0x69746e65, bits))
        elif eax_v == 1 and ecx_v == 0:
            setattr(sv.state.regs, dst_eax, BVV(0x00870f10, bits))
            setattr(sv.state.regs, dst_ebx, BVV(0x000c0800, bits))
            setattr(sv.state.regs, dst_ecx, BVV(0x7ed8320b, bits))
            setattr(sv.state.regs, dst_edx, BVV(0x178bfbff, bits))
        elif eax_v == 7 and ecx_v == 0:
            setattr(sv.state.regs, dst_eax, BVV(0x00000000, bits))
            setattr(sv.state.regs, dst_ebx, BVV(0x219c91a9, bits))
            setattr(sv.state.regs, dst_ecx, BVV(0x00400004, bits))
            setattr(sv.state.regs, dst_edx, BVV(0x00000000, bits))
        else:
            raise ModelError(
                "cpuid", "unsupported (eax, ecx) value (%d, %d)" % (eax_v, ecx_v))

        return True

    def cpuid_handler(self, sv, parameters):
        return self.cpuid_util(sv, 32)

    def xgetbv_handler(self, sv, parameters):
        sv.state.regs.eax = BVV(7, 32)
        sv.state.regs.edx = BVV(0, 32)
        return True

    def paddb_handler(self, sv, parameters):
        src1 = get_src(sv.state, parameters[0])
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, parameters[1])
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for b1, b2 in zip(src1_bytes, src2_bytes):
            if res is None:
                res = b1 + b2
            else:
                res = (b1 + b2).Concat(res)

        store_to_dst(sv.state, parameters[0], res)
        return True

    def paddw_handler(self, sv, parameters):
        return False

    def paddd_handler(self, sv, parameters):
        return False

    def paddq_handler(self, sv, parameters):
        return False

    def paddsb_handler(self, sv, parameters):
        return False

    def paddsw_handler(self, sv, parameters):
        return False

    def paddsd_handler(self, sv, parameters):
        return False

    def paddsq_handler(self, sv, parameters):
        return False

    # ----- mmx -----
    def movd_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        # get src (32bit)
        src = get_src(sv.state, src_p)
        assert src.size == 32

        store_to_dst(sv.state, dst_p, src.ZeroExt(16*8-32))
        return True

    def movq_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        # get src (64bit)
        src = get_src(sv.state, src_p)
        if src.size > 64:
            src = src.Extract(63, 0)

        if "[" not in dst_p:
            store_to_dst(sv.state, dst_p, src.ZeroExt(16*8-64))
        else:
            store_to_dst(sv.state, dst_p, src)
        return True
    # ----------------

```

`expr/__init__.py`:

```py
import z3

from .bitvector import BV, BVV, BVS, BVExpr
from .bool_expr import Bool, BoolExpr, BoolS, BoolV
from .bitvector_array import BVArray

def ITE(cond: Bool, iftrue: BV, iffalse: BV):
    assert iftrue.size == iffalse.size
    if isinstance(cond, BoolV):
        return iftrue if cond.value else iffalse
    return BVExpr(
        iftrue.size,
        z3.If(cond.z3obj, iftrue.z3obj, iffalse.z3obj)
    )

def Or(*conditions):
    res = None
    for cond in conditions:
        assert isinstance(cond, Bool)
        res = res.Or(cond) if res is not None else cond

    assert res is not None
    return res

def And(*conditions):
    res = None
    for cond in conditions:
        assert isinstance(cond, Bool)
        res = res.And(cond) if res is not None else cond

    assert res is not None
    return res

def Xor(*conditions):
    res = None
    for cond in conditions:
        assert isinstance(cond, Bool)
        res = res.Xor(cond) if res is not None else cond

    assert res is not None
    return res

```

`expr/bitvector.py`:

```py
import z3

from .bool_expr import BoolExpr, BoolV
from .interval import Interval


class BV(object):
    def __init__(self):
        # do not instantiate this class
        raise NotImplementedError

    def __repr__(self):
        return self.__str__()

    def __neg__(self):
        raise NotImplementedError

    def __add__(self, other):
        raise NotImplementedError

    def __sub__(self, other):
        raise NotImplementedError

    def __mul__(self, other):
        raise NotImplementedError

    def __radd__(self, other):
        return self.__add__(other)

    def __rsub__(self, other):
        return self.__neg__().__add__(other)

    def __rmul__(self, other):
        return self.__mul__(other)


class BVExpr(BV):
    def __init__(self, size: int, z3obj, interval=None):
        self.z3obj = z3obj
        self.size = size
        self.interval = interval if interval is not None else Interval(
            self.size)

    def __str__(self):
        return "<BVExpr{size} {obj}>".format(
            size=self.size, obj=str(self.z3obj)
        )

    def simplify(self):
        simplified = z3.simplify(self.z3obj)
        if simplified.decl().kind() == z3.Z3_OP_BNUM:
            return BVV(simplified.as_long(), self.size)
        if simplified.decl().kind() == z3.Z3_OP_UNINTERPRETED:
            return BVS(simplified.sexpr(), self.size)
        if not simplified.eq(self.z3obj):
            return BVExpr(self.size, simplified, self.interval)
        return self

    def eq(self, other):
        if not isinstance(other, BV):
            return False
        return self.z3obj.eq(other.z3obj)

    def __hash__(self):
        return self.z3obj.__hash__()

    def __add__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj + other.z3obj, self.interval + other.interval)

    def __sub__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj - other.z3obj, self.interval - other.interval)

    def __mul__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj * other.z3obj, self.interval * other.interval)

    def __truediv__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj / other.z3obj, self.interval / other.interval)

    def __mod__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj % other.z3obj, self.interval % other.interval)

    def __xor__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj ^ other.z3obj, self.interval ^ other.interval)

    def __and__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj & other.z3obj, self.interval & other.interval)

    def __or__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj | other.z3obj, self.interval | other.interval)

    def __lshift__(self, other):
        # arithmetic/logical left shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj << other.z3obj, self.interval << other.interval)

    def __rshift__(self, other):
        # arithmetic right shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        new_interval = self.interval.LShR(other.interval)
        if new_interval.low == new_interval.high:
            # concrete path
            return BVV(new_interval.low, self.size)
        return BVExpr(self.size, self.z3obj >> other.z3obj, new_interval)

    def __eq__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj == other.z3obj)

    def __ne__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj != other.z3obj)

    def __lt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj < other.z3obj)

    def __le__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj <= other.z3obj)

    def __gt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj > other.z3obj)

    def __ge__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj >= other.z3obj)

    def __invert__(self):
        return BVExpr(self.size, self.z3obj.__invert__(), self.interval.__invert__())

    def __neg__(self):
        return BVExpr(self.size, self.z3obj.__neg__(), self.interval.__neg__())

    def UDiv(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.UDiv(self.z3obj, other.z3obj), self.interval.UDiv(other.interval))

    def SDiv(self, other):
        return self.__truediv__(other)

    def URem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.URem(self.z3obj, other.z3obj), self.interval.URem(other.interval))

    def SRem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.SRem(self.z3obj, other.z3obj), self.interval.SRem(other.interval))

    def LShL(self, other):
        return self.__lshift__(other)

    def AShL(self, other):
        # arithmetic and logical left shift are identical
        return self.__lshift__(other)

    def LShR(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        new_interval = self.interval.LShR(other.interval)
        if new_interval.low == new_interval.high:
            # concrete path
            return BVV(new_interval.low, self.size)
        return BVExpr(self.size, z3.LShR(self.z3obj, other.z3obj), new_interval)

    def AShR(self, other):
        return self.__rshift__(other)

    def ULT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.ULT(self.z3obj, other.z3obj))

    def ULE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.ULE(self.z3obj, other.z3obj))

    def UGT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.UGT(self.z3obj, other.z3obj))

    def UGE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.UGE(self.z3obj, other.z3obj))

    def SLT(self, other):
        return self.__lt__(other)

    def SLE(self, other):
        return self.__le__(other)

    def SGT(self, other):
        return self.__gt__(other)

    def SGE(self, other):
        return self.__ge__(other)

    def RotateLeft(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.RotateLeft(self.z3obj, other.z3obj), self.interval.RotateLeft(other.interval))

    def RotateRight(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.RotateRight(self.z3obj, other.z3obj), self.interval.RotateRight(other.interval))

    def Concat(self, other: BV):
        return BVExpr(self.size + other.size, z3.Concat(self.z3obj, other.z3obj), self.interval.Concat(other.interval))

    def Extract(self, high: int, low: int):
        assert high >= low
        new_interval = self.interval.Extract(high, low)
        if new_interval.high == new_interval.low:
            # extract is concrete
            return BVV(new_interval.high, high-low+1)
        return BVExpr(high-low+1, z3.Extract(high, low, self.z3obj), new_interval)

    def SignExt(self, n: int):
        assert n >= 0
        return BVExpr(self.size + n, z3.SignExt(n, self.z3obj), self.interval.SignExt(n))

    def ZeroExt(self, n: int):
        assert n >= 0
        return BVExpr(self.size + n, z3.ZeroExt(n, self.z3obj), self.interval.ZeroExt(n))


class BVS(BVExpr):
    def __init__(self, name: str, size: int):
        self.name = name
        self.size = size
        self.z3obj = z3.BitVec(name, size)

    def __str__(self):
        return "<BVS{size} {obj}>".format(
            size=self.size, obj=str(self.z3obj)
        )

    def simplify(self):
        return self

    @property
    def interval(self):
        return Interval(self.size)


class BVV(BV):
    def __init__(self, value: int, size: int):
        self.size = size
        self.value = value & self._mask

    def as_bytes(self):
        assert self.size % 8 == 0
        res = b""
        for i in range(0, self.size, 8):
            bv = self.Extract(i+8-1, i)
            res = bytes([bv.value]) + res
        return res

    def simplify(self):
        return self

    @property
    def _mask(self):
        return (2 << (self.size-1)) - 1

    @property
    def _signMask(self):
        return 2 << (self.size-1-1) if self.size > 1 else 0

    @property
    def z3obj(self):
        return z3.BitVecVal(self.value, self.size)

    @property
    def interval(self):
        return Interval(self.size, self.value, self.value)

    def __str__(self):
        return "<BVV{size} 0x{obj:0{width}x}>".format(
            size=self.size, obj=self.value,
            width=(self.size+3) // 4
        )

    def eq(self, other):
        if not isinstance(other, BV):
            return False
        if isinstance(other, BVV):
            return self.value == other.value and \
                self.size == other.size
        return self.z3obj.eq(other.z3obj)

    def __hash__(self):
        return hash((self.value, self.size))

    def __add__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value + other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value + other.z3obj, self.interval + other.interval)

    def __sub__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value - other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value - other.z3obj, self.interval - other.interval)

    def __mul__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value * other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value * other.z3obj, self.interval * other.interval)

    def __truediv__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            # python round up -x.y to -(x+1). Z3 round up to -x
            # We want to be consistent with Z3
            sign = 1 if signed_left * signed_right > 0 else -1
            value = abs(signed_left) // abs(signed_right)
            return BVV((sign * value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj / other.z3obj, self.interval / other.interval)

    def __mod__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BVV((signed_left % signed_right) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj % other.z3obj, self.interval % other.interval)

    def __xor__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value ^ other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value ^ other.z3obj, self.interval ^ other.interval)

    def __and__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value & other.value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj & other.z3obj, self.interval & other.interval)

    def __or__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value | other.value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj | other.z3obj, self.interval | other.interval)

    def __lshift__(self, other):
        # arithmetic/logical left shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value << other.value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj << other.z3obj, self.interval << other.interval)

    def __rshift__(self, other):
        # arithmetic right shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            tmp = self._signMask >> other.value
            new = ((self.value >> other.value) ^ tmp) - tmp
            return BVV(new & self._mask, self.size)
        return BVExpr(self.size, self.z3obj >> other.z3obj, self.interval >> other.interval)

    def __eq__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value == other.value)
        return BoolExpr(self.z3obj == other.z3obj)

    def __ne__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value != other.value)
        return BoolExpr(self.z3obj != other.z3obj)

    def __lt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left < signed_right)
        return BoolExpr(self.z3obj < other.z3obj)

    def __le__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left <= signed_right)
        return BoolExpr(self.z3obj <= other.z3obj)

    def __gt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left > signed_right)
        return BoolExpr(self.z3obj > other.z3obj)

    def __ge__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left >= signed_right)
        return BoolExpr(self.z3obj >= other.z3obj)

    def __invert__(self):
        return BVV(~self.value, self.size)

    def __neg__(self):
        return BVV(-self.value, self.size)

    def UDiv(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value // other.value) & self._mask, self.size)
        return BVExpr(self.size, z3.UDiv(self.z3obj, other.z3obj), self.interval.UDiv(other.interval))

    def SDiv(self, other):
        return self.__truediv__(other)

    def URem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value % other.value) & self._mask, self.size)
        return BVExpr(self.size, z3.URem(self.z3obj, other.z3obj), self.interval.URem(other.interval))

    def SRem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            # sign div
            sign = 1 if signed_left * signed_right > 0 else -1
            div_abs = abs(signed_left) // abs(signed_right)
            div = sign * div_abs
            # sign rem
            rem = signed_left - (signed_right * div)
            return BVV(rem, self.size)
        return BVExpr(self.size, z3.SRem(self.z3obj, other.z3obj), self.interval.SRem(other.interval))

    def LShL(self, other):
        return self.__lshift__(other)

    def AShL(self, other):
        # arithmetic and logical left shift are identical
        return self.__lshift__(other)

    def LShR(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value >> other.value) & self._mask, self.size)
        return BVExpr(self.size, z3.LShR(self.z3obj, other.z3obj), self.interval.LShR(other.interval))

    def AShR(self, other):
        return self.__rshift__(other)

    def ULT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value < other.value)
        return BoolExpr(z3.ULT(self.z3obj, other.z3obj))

    def ULE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value <= other.value)
        return BoolExpr(z3.ULE(self.z3obj, other.z3obj))

    def UGT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value > other.value)
        return BoolExpr(z3.UGT(self.z3obj, other.z3obj))

    def UGE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value >= other.value)
        return BoolExpr(z3.UGE(self.z3obj, other.z3obj))

    def SLT(self, other):
        return self.__lt__(other)

    def SLE(self, other):
        return self.__le__(other)

    def SGT(self, other):
        return self.__gt__(other)

    def SGE(self, other):
        return self.__ge__(other)

    def RotateLeft(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            other_norm = other.value % self.size
            new = (((self.value << other_norm) & self._mask) |
                   ((self.value >> ((self.size - other_norm) & self._mask)) & self._mask))
            return BVV(new & self._mask, self.size)
        return BVExpr(self.size, z3.RotateLeft(self.z3obj, other.z3obj), self.interval.RotateLeft(other.interval))

    def RotateRight(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            other_norm = other.value % self.size
            new = (((self.value >> other_norm) & self._mask) |
                   ((self.value << ((self.size - other_norm) & self._mask)) & self._mask))
            return BVV(new & self._mask, self.size)
        return BVExpr(self.size, z3.RotateRight(self.z3obj, other.z3obj), self.interval.RotateRight(other.interval))

    def Concat(self, other: BV):
        if isinstance(other, BVV):
            new_value = (self.value << other.size) + other.value
            new_size = self.size + other.size
            new_mask = 2**new_size-1
            return BVV(new_value & new_mask, new_size)
        return BVExpr(self.size + other.size, z3.Concat(self.z3obj, other.z3obj), self.interval.Concat(other.interval))

    def Extract(self, high: int, low: int):
        assert high >= low
        new_size = high-low+1
        new_value = (self.value >> low) & ((2 << (new_size-1))-1)
        return BVV(new_value, new_size)

    def SignExt(self, n: int):
        assert n >= 0
        if self._signMask & self.value:
            new = (((2 << (n-1))-1) << self.size) + self.value
        else:
            new = self.value
        mask = (2 << (self.size+n-1))-1
        return BVV(new & mask, self.size + n)

    def ZeroExt(self, n: int):
        assert n >= 0
        return BVV(self.value, self.size + n)

```

`expr/bitvector_array.py`:

```py
import z3

from enum import Enum
from copy import deepcopy
from .bitvector import BV, BVV, BVS, BVExpr
from .bool_expr import Bool, BoolV, BoolExpr


class BVArrayState(Enum):
    # Never registered a symbolic memory access (either Load or Store)
    CONCRETE_MODE = 0
    # Registered only a symbolic Load. Allowed concrete Load
    SEMI_CONCRETE_MODE = 1
    # Registered a symbolic Store
    SYMBOLIC_MODE = 2


class BVArray(object):
    """ Wrapper of z3's Array. Beware: this is not immutable, differently from z3 """

    def __init__(self, name: str, index_width: int, value_width: int):
        assert index_width > 0
        assert value_width > 0

        self.name = name
        self.uninit_id = 0
        self.index_width = index_width
        self.value_width = value_width
        self._conc_store = {}
        self._assertions = dict()
        self._z3obj = None
        self._z3objConcCache = None
        self._mode = BVArrayState.CONCRETE_MODE

    def __str__(self):
        return "<BVArray [BV{ind} -> BV{val}] {name}>".format(
            name=self.name,
            ind=self.index_width,
            val=self.value_width
        )

    def __repr__(self):
        return self.__str__()

    def get_mode(self):
        return self._mode

    def simplify(self):
        if self._z3obj is None:
            return
        self._z3obj = z3.simplify(self._z3obj)

    @property
    def z3obj(self):
        if self._z3obj is not None:
            # symbolic mode
            return self._z3obj

        # concrete mode
        if self._z3objConcCache is not None:
            return self._z3objConcCache
        res = z3.Array(
            self.name,
            z3.BitVecSort(self.index_width),
            z3.BitVecSort(self.value_width)
        )
        for index in self._conc_store:
            res = z3.Store(
                res,
                z3.BitVecVal(index, self.index_width),
                self._conc_store[index].z3obj
            )
        self._z3objConcCache = res
        return res

    def _switch_to_symbolic(self, soft=False):
        if self._mode == BVArrayState.SEMI_CONCRETE_MODE and soft:
            return

        if self._mode == BVArrayState.SEMI_CONCRETE_MODE and not soft:
            self._mode = BVArrayState.SYMBOLIC_MODE
            self._conc_store = None
            return

        if self._mode == BVArrayState.CONCRETE_MODE:
            assert self._z3obj is None
            self._z3obj = z3.Array(
                self.name,
                z3.BitVecSort(self.index_width),
                z3.BitVecSort(self.value_width)
            )
            # The solver needs to add those constraints! (even lazly)
            for index in self._conc_store:
                self._assertions[index] = \
                    BoolExpr(z3.Select(
                        self._z3obj, index) == self._conc_store[index].z3obj)

            if soft:
                self._mode = BVArrayState.SEMI_CONCRETE_MODE
            else:
                self._mode = BVArrayState.SYMBOLIC_MODE
                self._conc_store = None

    def get_assertions(self):
        return list(self._assertions.values())

    def Store(self, index, value):
        if isinstance(index, int):
            index = BVV(index, self.index_width)
        else:
            assert index.size == self.index_width
        if isinstance(value, int):
            value = BVV(value, self.value_width)
        else:
            assert value.size == self.value_width

        # invalidate cache
        self._z3objConcCache = None

        if (
            isinstance(index, BVV) and
            self._mode == BVArrayState.CONCRETE_MODE
        ):
            # concrete mode
            self._conc_store[index.value] = value
        else:
            # symbolic mode
            self._switch_to_symbolic(soft=False)
            self._z3obj = z3.Store(
                self._z3obj,
                index.z3obj,
                value.z3obj
            )

    def ConditionalStore(self, index, value, cond):
        if isinstance(index, int):
            index = BVV(index, self.index_width)
        else:
            assert index.size == self.index_width
        if isinstance(value, int):
            value = BVV(value, self.value_width)
        else:
            assert value.size == self.value_width
        if isinstance(cond, bool):
            cond = BoolV(cond)

        if isinstance(cond, BoolV):
            if cond.value:
                self.Store(index, value)
            return

        if (
            self._mode == BVArrayState.CONCRETE_MODE and
            isinstance(index, BVV) and
            index.value in self._conc_store and
            self._conc_store[index.value].eq(value)
        ):
            # the condition is symbolic, but the value is already in memory
            # we can safetely skip the store
            return

        self._switch_to_symbolic(soft=False)
        self._z3obj = z3.If(
            cond.z3obj,
            z3.Store(
                self._z3obj,
                index.z3obj,
                value.z3obj
            ),
            self._z3obj
        )
        # this can be quite inefficient.
        # Let's try to simplfy the expression.
        self._z3obj = z3.simplify(self._z3obj)

    def Select(self, index: BV) -> BV:
        if isinstance(index, int):
            index = BVV(index, self.index_width)
        else:
            assert index.size == self.index_width

        if (
            isinstance(index, BVV) and
            self._mode in {BVArrayState.CONCRETE_MODE, BVArrayState.SEMI_CONCRETE_MODE} and
            index.value in self._conc_store
        ):
            # concrete mode
            return self._conc_store[index.value]

        if (
            isinstance(index, BVV) and
            self._mode in {BVArrayState.CONCRETE_MODE, BVArrayState.SEMI_CONCRETE_MODE} and
            index.value not in self._conc_store
        ):
            res = BVS("uninit_read_%s_%d" % (self.name, self.uninit_id), self.value_width)
            self.uninit_id += 1
            return res

        # symbolic mode
        self._switch_to_symbolic(soft=True)
        return BVExpr(self.value_width, z3.Select(self._z3obj, index.z3obj))

    def copy(self):
        new = BVArray(self.name, self.index_width, self.value_width)
        new._conc_store = deepcopy(self._conc_store)
        new._z3obj = self._z3obj
        new._assertions = dict(self._assertions)
        new.uninit_id = self.uninit_id

        return new

    def merge(self, other, merge_condition: Bool):
        assert self.name == other.name
        assert self.index_width == other.index_width
        assert self.value_width == other.value_width
        if isinstance(merge_condition, BoolV):
            if merge_condition.value:
                return other.copy()
            return self

        self.uninit_id = max(self.uninit_id, other.uninit_id)

        if self.get_mode() == BVArrayState.CONCRETE_MODE and other.get_mode() == BVArrayState.CONCRETE_MODE:
            # Handle concrete mode merge (easy)
            all_indexes = set(self._conc_store.keys()) | set(other._conc_store.keys())
            for idx in all_indexes:
                self._conc_store[idx] = BVExpr(self.value_width, z3.If(
                    merge_condition.z3obj,
                    other.Select(BVV(idx, self.index_width)).z3obj,
                    self.Select(BVV(idx, self.index_width)).z3obj
                ))
        elif (
                self.get_mode() == BVArrayState.SEMI_CONCRETE_MODE and
                other.get_mode() in {BVArrayState.CONCRETE_MODE,
                                     BVArrayState.SEMI_CONCRETE_MODE}
            ) or (
                other.get_mode() == BVArrayState.SEMI_CONCRETE_MODE and
                self.get_mode() in {BVArrayState.CONCRETE_MODE,
                                    BVArrayState.SEMI_CONCRETE_MODE}
        ):
            # Handle semi-concrete mode merge
            other_copy = other.copy()
            other_copy._switch_to_symbolic(soft=True)
            self._switch_to_symbolic(soft=True)

            all_indexes = set(self._conc_store.keys()) | set(other._conc_store.keys())
            for idx in all_indexes:
                self._conc_store[idx] = BVExpr(self.value_width, z3.If(
                    merge_condition.z3obj,
                    other.Select(BVV(idx, self.index_width)).z3obj,
                    self.Select(BVV(idx, self.index_width)).z3obj
                ))

            all_indexes = set(self._assertions.keys()) | set(other._assertions.keys())
            new_assertions = dict()
            for idx in all_indexes:
                other_cond = other._assertions[idx] if idx in other._assertions else BoolV(True)
                self_cond  = self._assertions[idx] if idx in self._assertions else BoolV(True)
                new_assertions[idx] = z3.If(
                    merge_condition.z3obj,
                    other_cond.z3obj,
                    self_cond.z3obj
                )

            self._z3obj = z3.If(
                merge_condition.z3obj,
                other._z3obj,
                self._z3obj
            )

        else:
            # Handle symbolic mode merge
            other_copy = other.copy()
            other_copy._switch_to_symbolic(soft=False)
            self._switch_to_symbolic(soft=False)

            all_indexes = set(self._assertions.keys()) | set(other._assertions.keys())
            new_assertions = dict()
            for idx in all_indexes:
                other_cond = other._assertions[idx] if idx in other._assertions else BoolV(True)
                self_cond  = self._assertions[idx] if idx in self._assertions else BoolV(True)
                new_assertions[idx] = z3.If(
                    merge_condition.z3obj,
                    other_cond.z3obj,
                    self_cond.z3obj
                )

            self._z3obj = z3.If(
                merge_condition.z3obj,
                other._z3obj,
                self._z3obj
            )

        return self

```

`expr/bool_expr.py`:

```py
import z3


class Bool(object):
    def __init__(self):
        # do not instantiate this class
        raise NotImplementedError

    def __repr__(self):
        return self.__str__()


class BoolExpr(Bool):
    def __init__(self, z3obj):
        self.z3obj = z3obj

    def __str__(self):
        return "<BoolExpr {obj}>".format(
            obj=str(self.z3obj)
        )

    def __hash__(self):
        return self.z3obj.__hash__()

    def simplify(self):
        simplified = z3.simplify(self.z3obj)
        if simplified.decl().kind() == z3.Z3_OP_TRUE:
            return BoolV(True)
        elif simplified.decl().kind() == z3.Z3_OP_FALSE:
            return BoolV(False)

        if simplified.eq(self.z3obj):
            return self
        return BoolExpr(simplified)

    def eq(self, other: Bool):
        return self.z3obj.eq(other.z3obj)

    def __eq__(self, other: Bool):
        return BoolExpr(self.z3obj == other.z3obj)

    def __neq__(self, other: Bool):
        return BoolExpr(self.z3obj != other.z3obj)

    def Not(self):
        return BoolExpr(z3.Not(self.z3obj))

    def Or(self, other: Bool):
        return BoolExpr(z3.Or(self.z3obj, other.z3obj))

    def And(self, other: Bool):
        return BoolExpr(z3.And(self.z3obj, other.z3obj))

    def Xor(self, other: Bool):
        return BoolExpr(z3.Xor(self.z3obj, other.z3obj))


class BoolS(BoolExpr):
    def __init__(self, name):
        self.name = name
        self.z3obj = z3.Bool(name)

    def simplify(self):
        return self

    def __str__(self):
        return "<BoolS {name}>".format(
            name=str(self.name)
        )


class BoolV(Bool):
    def __init__(self, value: bool):
        self.value = value

    @property
    def z3obj(self):
        return z3.BoolVal(self.value)

    def simplify(self):
        return self

    def __str__(self):
        return "<BoolV {val}>".format(
            val=str(self.value)
        )

    def __hash__(self):
        return hash(self.value)

    def eq(self, other: Bool):
        return isinstance(other, BoolV) and other.value == self.value

    def __eq__(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value == other.value)
        return BoolExpr(self.z3obj == other.z3obj)

    def __neq__(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value != other.value)
        return BoolExpr(self.z3obj != other.z3obj)

    def Not(self):
        return BoolV(not self.value)

    def Or(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value or other.value)
        return BoolExpr(z3.Or(self.z3obj, other.z3obj))

    def And(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value and other.value)
        return BoolExpr(z3.And(self.z3obj, other.z3obj))

    def Xor(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(
                (self.value or other.value) and not (
                    self.value and other.value)
            )
        return BoolExpr(z3.Xor(self.z3obj, other.z3obj))

```

`expr/interval.py`:

```py
class Interval(object):
    def __init__(self, bits, low=None, high=None):
        assert bits > 0
        self.bits = bits
        self.max = (2 << (bits - 1)) - 1
        self.low = low if low is not None else 0
        self.high = high if high is not None else self.max

        self.low = self.low & self.max
        self.high = self.high & self.max

        assert self.high >= self.low

    def __str__(self):
        return "<Interval%d [%s -> %s]>" % (
            self.bits, hex(self.low), hex(self.high)
        )

    def __repr__(self):
        return self.__str__()

    @property
    def is_top(self):
        return self.low == 0 and self.high == self.max

    def __add__(self, other):
        assert other.bits == self.bits

        new_low = self.low + other.low
        new_high = self.high + other.high
        if new_high > self.max:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __sub__(self, other):
        assert other.bits == self.bits

        new_low = self.low - other.high
        new_high = self.high - other.low
        if new_low < 0:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __mul__(self, other):
        assert other.bits == self.bits

        new_low = self.low * other.low
        new_high = self.high * other.high
        if new_high > self.max:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __truediv__(self, other):
        assert other.bits == self.bits
        return Interval(self.bits)

    def __mod__(self, other):
        assert other.bits == self.bits

        new_low = 0
        new_high = other.high

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __xor__(self, other):
        assert other.bits == self.bits

        new_low = 0
        new_high = max(self.high, other.high)

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __and__(self, other):
        assert other.bits == self.bits

        new_low = 0
        new_high = self.high & other.high

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __or__(self, other):
        assert other.bits == self.bits

        new_low = min(self.low, other.low)
        new_high = max(self.high, other.high, self.high | other.high)

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __lshift__(self, other):
        # arithmetic/logical left shift
        assert other.bits == self.bits

        new_low = self.low << other.low
        new_high = self.high << other.high
        if new_high > self.max:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __rshift__(self, other):
        # arithmetic right shift
        assert other.bits == self.bits

        new_low = self.low >> other.high
        # check sign
        if self.high >> (self.bits-1) == 1:
            new_high = self.high
        else:
            new_high = self.high >> other.low

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __invert__(self):
        return Interval(self.bits)

    def __neg__(self):
        return Interval(self.bits)

    def UDiv(self, other):
        assert other.bits == self.bits
        if other.low == 0 or other.high == 0:
            return Interval(self.bits)

        new_low = self.low // other.high
        new_high = self.high // other.low

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def SDiv(self, other):
        return self.__truediv__(other)

    def URem(self, other):
        assert other.bits == self.bits
        return Interval(
            self.bits,
            0,
            min(self.high, other.high - 1)
        )

    def SRem(self, other):
        assert other.bits == self.bits
        return Interval(self.bits)

    def LShL(self, other):
        return self.__lshift__(other)

    def AShL(self, other):
        # arithmetic and logical left shift are identical
        return self.__lshift__(other)

    def LShR(self, other):
        assert other.bits == self.bits

        new_low = self.low >> other.high
        new_high = self.high >> other.low

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def AShR(self, other):
        return self.__rshift__(other)

    def RotateLeft(self, other):
        assert self.bits == other.bits
        return Interval(self.bits)

    def RotateRight(self, other):
        assert self.bits == other.bits
        return Interval(self.bits)

    def Concat(self, other):
        new_low = (self.low << other.bits) + other.low
        new_high = (self.high << other.bits) + other.high

        return Interval(
            self.bits + other.bits,
            new_low,
            new_high
        )

    def Extract(self, high: int, low: int):
        mask = (2 << (high - low)) - 1
        new_low = (self.low >> low) & mask
        new_high = (((self.high - self.low) >> low) & mask) + new_low

        if new_high > mask:
            new_high = mask

        return Interval(
            high - low + 1,
            new_low,
            new_high
        )

    def SignExt(self, n: int):
        assert n >= 0
        new_low = self.low
        if self.high >> (self.bits-1) == 1:
            new_high = (2 << (self.bits + n - 1)) - 1
        else:
            new_high = self.high

        return Interval(
            self.bits + n,
            new_low,
            new_high
        )

    def ZeroExt(self, n: int):
        assert n >= 0
        return Interval(
            self.bits + n,
            self.low,
            self.high
        )

```

`globals.py`:

```py
import threading
from binaryninja import Logger
from binaryninjaui import UIContext

class UIManagerRegistry(object):
    def __init__(self):
        self._managers = {}
        self._lock = threading.RLock()

    def get_or_create(self, session_id):
        if session_id is None:
            return None

        with self._lock:
            if session_id not in self._managers:
                from .ui.ui_manager import UIManager
                self._managers[session_id] = UIManager()
            return self._managers[session_id]

    def get(self, session_id):
        if session_id is None:
            return None
        with self._lock:
            return self._managers.get(session_id)

    def remove(self, session_id):
        if session_id is None:
            return
        with self._lock:
            if session_id in self._managers:
                del self._managers[session_id]

    def get_active(self):
        ctx = UIContext.activeContext()
        if ctx is None:
            return None
        view_frame = ctx.getCurrentViewFrame()
        if view_frame is None:
            return None
        view_interface = view_frame.getCurrentViewInterface()
        if view_interface is None:
            return None
        bv = view_interface.getData()
        if bv is None or bv.file is None:
            return None

        session_id = bv.file.session_id
        return self.get_or_create(session_id)

uimanager_registry = UIManagerRegistry()

# Global logger instance
logger = Logger(0, "SENinja")
```

`media/icons/cancel.svg`:

```svg
<?xml version="1.0"?>
<svg width="295" height="295" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
 <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
 <g class="layer">
  <title>Layer 1</title>
  <path d="m147.699563,0.287913c-81.28772,0 -147.41165,66.1302 -147.41165,147.4115c0,81.2815 66.12393,147.4117 147.41165,147.4117c81.28772,0 147.41159,-66.1302 147.41159,-147.4117c0,-81.2813 -66.12387,-147.4115 -147.41159,-147.4115zm0,282.5391c-74.50968,0 -135.12755,-60.6179 -135.12755,-135.1276c0,-74.5097 60.61787,-135.1275 135.12755,-135.1275c74.50968,0 135.12751,60.6178 135.12751,135.1275c0,74.5097 -60.61783,135.1276 -135.12751,135.1276z" fill="white" id="svg_3" stroke-width="0.575827"/>
  <rect fill="#ffffff" height="14.571686" id="svg_2" rx="7.285843" ry="7.285843" stroke-dashoffset="0" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="4" stroke-width="2.455856" transform="rotate(45 723.067 1610.54)" width="149.37303" x="-792.850627" y="975.712783"/>
  <rect fill="#ffffff" height="14.571686" id="svg_1" rx="7.285843" ry="7.285843" stroke-dashoffset="0" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="4" stroke-width="2.455856" transform="matrix(-0.707107 0.707107 0.707107 0.707107 0 0)" width="149.37303" x="-74.687008" y="201.593133"/>
 </g>
</svg>
```

`media/icons/pi.svg`:

```svg
<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" version="1.2" baseProfile="tiny" xmlns="http://www.w3.org/2000/svg"><path d="M20.121 7.121c-.566-.567-1.32-.879-2.121-.879s-1.555.312-2.121.879c-.233.233-.546.362-.879.362s-.646-.129-.879-.362c-1.366-1.366-3.185-2.118-5.121-2.118s-3.755.752-5.121 2.118c-.567.567-.879 1.32-.879 2.121s.312 1.555.879 2.121c.566.567 1.32.879 2.121.879v4.758c0 1.654 1.346 3 3 3s3-1.346 3-3c0 1.654 1.346 3 3 3s3-1.346 3-3v-4.166c.784-.356 1.501-.851 2.12-1.47.568-.567.88-1.321.88-2.122s-.312-1.554-.879-2.121zm-1.414 2.828c-.768.767-1.715 1.245-2.707 1.437v5.614c0 .553-.447 1-1 1s-1-.447-1-1v-5.614c-.992-.191-1.939-.67-2.707-1.437-.374-.374-.821-.623-1.293-.775v7.826c0 .553-.447 1-1 1s-1-.447-1-1v-7.827c-.473.152-.919.402-1.293.776-.195.196-.451.293-.707.293s-.512-.098-.707-.293c-.391-.391-.391-1.023 0-1.414 1.021-1.021 2.364-1.532 3.707-1.532s2.685.511 3.707 1.532c.633.632 1.463.948 2.293.948.831 0 1.661-.316 2.293-.948.195-.195.451-.293.707-.293s.512.098.707.293c.391.391.391 1.024 0 1.414z"/></svg>
```

`media/icons/reset_searchers.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="reset_searchers.svg"
   inkscape:version="1.3.2 (091e20e, 2023-11-25)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="true"
     inkscape:zoom="2.5592978"
     inkscape:cx="154.14384"
     inkscape:cy="144.96164"
     inkscape:window-width="1512"
     inkscape:window-height="945"
     inkscape:window-x="0"
     inkscape:window-y="37"
     inkscape:window-maximized="0"
     inkscape:current-layer="svg1">
    <inkscape:grid
       id="grid1"
       units="px"
       originx="0"
       originy="0"
       spacingx="1"
       spacingy="1"
       empcolor="#0099e5"
       empopacity="0.30196078"
       color="#0099e5"
       opacity="0.14901961"
       empspacing="5"
       dotted="false"
       gridanglex="30"
       gridanglez="30"
       visible="true" />
  </sodipodi:namedview>
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <path
     d="m 147.69961,0.287913 c -81.2877,0 -147.4117,66.1302 -147.4117,147.411497 0,81.2815 66.124,147.4117 147.4117,147.4117 81.2877,0 147.4116,-66.1302 147.4116,-147.4117 0,-81.281297 -66.1239,-147.411497 -147.4116,-147.411497 z m 0,282.539097 c -74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276 0,-74.509697 60.6179,-135.127497 135.1276,-135.127497 74.5097,0 135.1275,60.6178 135.1275,135.127497 0,74.5097 -60.6178,135.1276 -135.1275,135.1276 z"
     fill="#ffffff"
     id="svg_4"
     stroke-width="0.575827" />
  <text
     xml:space="preserve"
     style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;text-anchor:middle;fill:#ffffff"
     x="146.64229"
     y="228.72467"
     id="text1"><tspan
       sodipodi:role="line"
       id="tspan1"
       x="146.64229"
       y="228.72467"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:System-ui;-inkscape-font-specification:System-ui">RST</tspan></text>
  <g
     id="g1"
     transform="translate(-0.39073217,-1.5629287)">
    <rect
       fill="#ffffff"
       height="14.571686"
       id="svg_2"
       rx="7.2858429"
       ry="7.2858429"
       stroke-dashoffset="0"
       stroke-linecap="round"
       stroke-linejoin="round"
       stroke-miterlimit="4"
       stroke-width="2.45586"
       transform="rotate(45)"
       width="149.37303"
       x="78.098053"
       y="-60.067364" />
    <rect
       fill="#ffffff"
       height="14.571691"
       id="svg_1"
       rx="7.2858453"
       ry="7.2858453"
       stroke-dashoffset="0"
       stroke-linecap="round"
       stroke-linejoin="round"
       stroke-miterlimit="4"
       stroke-width="2.45586"
       transform="matrix(-0.70710678,0.70710678,0.70710678,0.70710678,0,0)"
       width="149.37308"
       x="-127.46534"
       y="145.49957" />
  </g>
</svg>

```

`media/icons/run_addr.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="run_addr.svg"
   inkscape:version="1.3.2 (091e20ef0f, 2023-11-25, custom)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="true"
     inkscape:zoom="3.9491525"
     inkscape:cx="147.5"
     inkscape:cy="145.98069"
     inkscape:window-width="2560"
     inkscape:window-height="1383"
     inkscape:window-x="0"
     inkscape:window-y="33"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg1">
    <inkscape:grid
       id="grid1"
       units="px"
       originx="0"
       originy="0"
       spacingx="1"
       spacingy="1"
       empcolor="#0099e5"
       empopacity="0.30196078"
       color="#0099e5"
       opacity="0.14901961"
       empspacing="5"
       dotted="false"
       gridanglex="30"
       gridanglez="30"
       visible="true" />
  </sodipodi:namedview>
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <path
     d="m 147.69961,0.287913 c -81.2877,0 -147.4117,66.1302 -147.4117,147.411497 0,81.2815 66.124,147.4117 147.4117,147.4117 81.2877,0 147.4116,-66.1302 147.4116,-147.4117 0,-81.281297 -66.1239,-147.411497 -147.4116,-147.411497 z m 0,282.539097 c -74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276 0,-74.509697 60.6179,-135.127497 135.1276,-135.127497 74.5097,0 135.1275,60.6178 135.1275,135.127497 0,74.5097 -60.6178,135.1276 -135.1275,135.1276 z"
     fill="#ffffff"
     id="svg_4"
     stroke-width="0.575827" />
  <path
     d="M 190.0989,79.920807 131.04482,40.67805 c -1.29357,-0.872751 -2.96589,-0.919817 -4.3006,-0.161857 -1.35951,0.766407 -2.19982,2.231498 -2.19982,3.828205 v 78.485592 c 0,1.59663 0.84031,3.06172 2.19982,3.8282 0.62604,0.35367 1.3264,0.53228 2.01844,0.53228 0.79094,0 1.59012,-0.23029 2.28216,-0.69414 L 190.0989,87.253503 c 1.20299,-0.800412 1.93617,-2.184504 1.93617,-3.666206 0,-1.481916 -0.73318,-2.865652 -1.93617,-3.66649 z M 132.98051,114.84163 V 52.332755 l 47.03441,31.2544 z"
     fill="#ffffff"
     id="svg_3"
     stroke-width="0.402061" />
  <text
     xml:space="preserve"
     style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;text-anchor:middle;fill:#ffffff"
     x="145.10733"
     y="228.72467"
     id="text1"><tspan
       sodipodi:role="line"
       id="tspan1"
       x="145.10733"
       y="228.72467"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:System-ui;-inkscape-font-specification:System-ui">ADR</tspan></text>
</svg>

```

`media/icons/run_bfs.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="run_bfs.svg"
   inkscape:version="1.3.2 (091e20ef0f, 2023-11-25, custom)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="true"
     inkscape:zoom="3.9491525"
     inkscape:cx="147.5"
     inkscape:cy="145.72747"
     inkscape:window-width="2560"
     inkscape:window-height="1383"
     inkscape:window-x="0"
     inkscape:window-y="33"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg1">
    <inkscape:grid
       id="grid1"
       units="px"
       originx="0"
       originy="0"
       spacingx="1"
       spacingy="1"
       empcolor="#0099e5"
       empopacity="0.30196078"
       color="#0099e5"
       opacity="0.14901961"
       empspacing="5"
       dotted="false"
       gridanglex="30"
       gridanglez="30"
       visible="true" />
  </sodipodi:namedview>
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <path
     d="m 147.69961,0.287913 c -81.2877,0 -147.4117,66.1302 -147.4117,147.411497 0,81.2815 66.124,147.4117 147.4117,147.4117 81.2877,0 147.4116,-66.1302 147.4116,-147.4117 0,-81.281297 -66.1239,-147.411497 -147.4116,-147.411497 z m 0,282.539097 c -74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276 0,-74.509697 60.6179,-135.127497 135.1276,-135.127497 74.5097,0 135.1275,60.6178 135.1275,135.127497 0,74.5097 -60.6178,135.1276 -135.1275,135.1276 z"
     fill="#ffffff"
     id="svg_4"
     stroke-width="0.575827" />
  <path
     d="M 190.0989,79.920807 131.04482,40.67805 c -1.29357,-0.872751 -2.96589,-0.919817 -4.3006,-0.161857 -1.35951,0.766407 -2.19982,2.231498 -2.19982,3.828205 v 78.485592 c 0,1.59663 0.84031,3.06172 2.19982,3.8282 0.62604,0.35367 1.3264,0.53228 2.01844,0.53228 0.79094,0 1.59012,-0.23029 2.28216,-0.69414 L 190.0989,87.253503 c 1.20299,-0.800412 1.93617,-2.184504 1.93617,-3.666206 0,-1.481916 -0.73318,-2.865652 -1.93617,-3.66649 z M 132.98051,114.84163 V 52.332755 l 47.03441,31.2544 z"
     fill="#ffffff"
     id="svg_3"
     stroke-width="0.402061" />
  <text
     xml:space="preserve"
     style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;text-anchor:middle;fill:#ffffff"
     x="146.64229"
     y="228.72467"
     id="text1"><tspan
       sodipodi:role="line"
       id="tspan1"
       x="146.64229"
       y="228.72467"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:System-ui;-inkscape-font-specification:System-ui">BFS</tspan></text>
</svg>

```

`media/icons/run_branch.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="run_branch.svg"
   inkscape:version="1.3.2 (091e20ef0f, 2023-11-25, custom)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="true"
     inkscape:zoom="3.9491525"
     inkscape:cx="147.5"
     inkscape:cy="145.98069"
     inkscape:window-width="2560"
     inkscape:window-height="1383"
     inkscape:window-x="0"
     inkscape:window-y="33"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg1">
    <inkscape:grid
       id="grid1"
       units="px"
       originx="0"
       originy="0"
       spacingx="1"
       spacingy="1"
       empcolor="#0099e5"
       empopacity="0.30196078"
       color="#0099e5"
       opacity="0.14901961"
       empspacing="5"
       dotted="false"
       gridanglex="30"
       gridanglez="30"
       visible="true" />
  </sodipodi:namedview>
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <path
     d="m 147.69961,0.287913 c -81.2877,0 -147.4117,66.1302 -147.4117,147.411497 0,81.2815 66.124,147.4117 147.4117,147.4117 81.2877,0 147.4116,-66.1302 147.4116,-147.4117 0,-81.281297 -66.1239,-147.411497 -147.4116,-147.411497 z m 0,282.539097 c -74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276 0,-74.509697 60.6179,-135.127497 135.1276,-135.127497 74.5097,0 135.1275,60.6178 135.1275,135.127497 0,74.5097 -60.6178,135.1276 -135.1275,135.1276 z"
     fill="#ffffff"
     id="svg_4"
     stroke-width="0.575827" />
  <path
     d="M 190.0989,79.920807 131.04482,40.67805 c -1.29357,-0.872751 -2.96589,-0.919817 -4.3006,-0.161857 -1.35951,0.766407 -2.19982,2.231498 -2.19982,3.828205 v 78.485592 c 0,1.59663 0.84031,3.06172 2.19982,3.8282 0.62604,0.35367 1.3264,0.53228 2.01844,0.53228 0.79094,0 1.59012,-0.23029 2.28216,-0.69414 L 190.0989,87.253503 c 1.20299,-0.800412 1.93617,-2.184504 1.93617,-3.666206 0,-1.481916 -0.73318,-2.865652 -1.93617,-3.66649 z M 132.98051,114.84163 V 52.332755 l 47.03441,31.2544 z"
     fill="#ffffff"
     id="svg_3"
     stroke-width="0.402061" />
  <text
     xml:space="preserve"
     style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;text-anchor:middle;fill:#ffffff"
     x="145.10733"
     y="228.72467"
     id="text1"><tspan
       sodipodi:role="line"
       id="tspan1"
       x="145.10733"
       y="228.72467"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:System-ui;-inkscape-font-specification:System-ui">BRC</tspan></text>
</svg>

```

`media/icons/run_dfs.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="run_dfs.svg"
   inkscape:version="1.3.2 (091e20ef0f, 2023-11-25, custom)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="true"
     inkscape:zoom="3.9491525"
     inkscape:cx="147.5"
     inkscape:cy="145.72747"
     inkscape:window-width="2560"
     inkscape:window-height="1383"
     inkscape:window-x="0"
     inkscape:window-y="33"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg1">
    <inkscape:grid
       id="grid1"
       units="px"
       originx="0"
       originy="0"
       spacingx="1"
       spacingy="1"
       empcolor="#0099e5"
       empopacity="0.30196078"
       color="#0099e5"
       opacity="0.14901961"
       empspacing="5"
       dotted="false"
       gridanglex="30"
       gridanglez="30"
       visible="true" />
  </sodipodi:namedview>
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <path
     d="m 147.69961,0.287913 c -81.2877,0 -147.4117,66.1302 -147.4117,147.411497 0,81.2815 66.124,147.4117 147.4117,147.4117 81.2877,0 147.4116,-66.1302 147.4116,-147.4117 0,-81.281297 -66.1239,-147.411497 -147.4116,-147.411497 z m 0,282.539097 c -74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276 0,-74.509697 60.6179,-135.127497 135.1276,-135.127497 74.5097,0 135.1275,60.6178 135.1275,135.127497 0,74.5097 -60.6178,135.1276 -135.1275,135.1276 z"
     fill="#ffffff"
     id="svg_4"
     stroke-width="0.575827" />
  <path
     d="M 190.0989,79.920807 131.04482,40.67805 c -1.29357,-0.872751 -2.96589,-0.919817 -4.3006,-0.161857 -1.35951,0.766407 -2.19982,2.231498 -2.19982,3.828205 v 78.485592 c 0,1.59663 0.84031,3.06172 2.19982,3.8282 0.62604,0.35367 1.3264,0.53228 2.01844,0.53228 0.79094,0 1.59012,-0.23029 2.28216,-0.69414 L 190.0989,87.253503 c 1.20299,-0.800412 1.93617,-2.184504 1.93617,-3.666206 0,-1.481916 -0.73318,-2.865652 -1.93617,-3.66649 z M 132.98051,114.84163 V 52.332755 l 47.03441,31.2544 z"
     fill="#ffffff"
     id="svg_3"
     stroke-width="0.402061" />
  <text
     xml:space="preserve"
     style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;text-anchor:middle;fill:#ffffff"
     x="145.10733"
     y="228.72467"
     id="text1"><tspan
       sodipodi:role="line"
       id="tspan1"
       x="145.10733"
       y="228.72467"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:System-ui;-inkscape-font-specification:System-ui">DFS</tspan></text>
</svg>

```

`media/icons/set_avoid.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="set_avoid.svg"
   inkscape:version="1.3.2 (091e20e, 2023-11-25)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="true"
     inkscape:zoom="1.9517536"
     inkscape:cx="189.31693"
     inkscape:cy="191.62255"
     inkscape:window-width="1512"
     inkscape:window-height="945"
     inkscape:window-x="0"
     inkscape:window-y="37"
     inkscape:window-maximized="0"
     inkscape:current-layer="svg1">
    <inkscape:grid
       id="grid1"
       units="px"
       originx="0"
       originy="0"
       spacingx="1"
       spacingy="1"
       empcolor="#0099e5"
       empopacity="0.30196078"
       color="#0099e5"
       opacity="0.14901961"
       empspacing="5"
       dotted="false"
       gridanglex="30"
       gridanglez="30"
       visible="true" />
  </sodipodi:namedview>
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <path
     d="m 147.69961,0.287913 c -81.2877,0 -147.4117,66.1302 -147.4117,147.411497 0,81.2815 66.124,147.4117 147.4117,147.4117 81.2877,0 147.4116,-66.1302 147.4116,-147.4117 0,-81.281297 -66.1239,-147.411497 -147.4116,-147.411497 z m 0,282.539097 c -74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276 0,-74.509697 60.6179,-135.127497 135.1276,-135.127497 74.5097,0 135.1275,60.6178 135.1275,135.127497 0,74.5097 -60.6178,135.1276 -135.1275,135.1276 z"
     fill="#ffffff"
     id="svg_4"
     stroke-width="0.575827" />
  <text
     xml:space="preserve"
     style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:120px;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;text-anchor:middle;fill:#ffffff"
     x="151.76588"
     y="228.21231"
     id="text1"><tspan
       sodipodi:role="line"
       id="tspan1"
       x="151.76588"
       y="228.21231"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:120px;font-family:System-ui;-inkscape-font-specification:System-ui">AVD</tspan></text>
  <circle
     style="fill:#ffffff"
     id="path1"
     cx="146.27872"
     cy="65.838234"
     r="46.368557" />
</svg>

```

`media/icons/set_target.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="set_target.svg"
   inkscape:version="1.3.2 (091e20e, 2023-11-25)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="true"
     inkscape:zoom="2.0405843"
     inkscape:cx="156.08275"
     inkscape:cy="157.30789"
     inkscape:window-width="1512"
     inkscape:window-height="945"
     inkscape:window-x="0"
     inkscape:window-y="37"
     inkscape:window-maximized="0"
     inkscape:current-layer="svg1">
    <inkscape:grid
       id="grid1"
       units="px"
       originx="0"
       originy="0"
       spacingx="1"
       spacingy="1"
       empcolor="#0099e5"
       empopacity="0.30196078"
       color="#0099e5"
       opacity="0.14901961"
       empspacing="5"
       dotted="false"
       gridanglex="30"
       gridanglez="30"
       visible="true" />
  </sodipodi:namedview>
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <path
     d="m 147.69961,0.287913 c -81.2877,0 -147.4117,66.1302 -147.4117,147.411497 0,81.2815 66.124,147.4117 147.4117,147.4117 81.2877,0 147.4116,-66.1302 147.4116,-147.4117 0,-81.281297 -66.1239,-147.411497 -147.4116,-147.411497 z m 0,282.539097 c -74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276 0,-74.509697 60.6179,-135.127497 135.1276,-135.127497 74.5097,0 135.1275,60.6178 135.1275,135.127497 0,74.5097 -60.6178,135.1276 -135.1275,135.1276 z"
     fill="#ffffff"
     id="svg_4"
     stroke-width="0.575827" />
  <text
     xml:space="preserve"
     style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:'DejaVu Sans Mono';-inkscape-font-specification:'DejaVu Sans Mono';text-align:center;text-anchor:middle;fill:#ffffff"
     x="146.64229"
     y="228.72467"
     id="text1"><tspan
       sodipodi:role="line"
       id="tspan1"
       x="146.6423"
       y="228.72467"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:133.333px;font-family:System-ui;-inkscape-font-specification:System-ui">TRG</tspan></text>
  <circle
     style="fill:#ffffff;fill-opacity:1"
     id="path2"
     cx="147.7518"
     cy="72.283218"
     r="42.38982" />
</svg>

```

`media/icons/start.svg`:

```svg
<?xml version="1.0"?>
<svg width="295" height="295" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
 <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
 <g class="layer">
  <title>Layer 1</title>
  <path d="m147.69961,0.287913c-81.2877,0 -147.4117,66.1302 -147.4117,147.4115c0,81.2815 66.124,147.4117 147.4117,147.4117c81.2877,0 147.4116,-66.1302 147.4116,-147.4117c0,-81.2813 -66.1239,-147.4115 -147.4116,-147.4115zm0,282.5391c-74.5097,0 -135.1276,-60.6179 -135.1276,-135.1276c0,-74.5097 60.6179,-135.1275 135.1276,-135.1275c74.5097,0 135.1275,60.6178 135.1275,135.1275c0,74.5097 -60.6178,135.1276 -135.1275,135.1276z" fill="white" id="svg_4" stroke-width="0.575827"/>
  <path d="m206.30201,142.534813l-85.9899,-55.2793c-1.8836,-1.2294 -4.3187,-1.2957 -6.2622,-0.228c-1.9796,1.0796 -3.2032,3.1434 -3.2032,5.3926l0,110.5587c0,2.2491 1.2236,4.3129 3.2032,5.3926c0.9116,0.4982 1.9314,0.7498 2.9391,0.7498c1.1517,0 2.3154,-0.3244 3.3231,-0.9778l85.9899,-55.2794c1.7517,-1.1275 2.8193,-3.0772 2.8193,-5.1644c0,-2.0875 -1.0676,-4.0367 -2.8193,-5.1648zm-83.1713,49.1912l0,-88.0531l68.4878,44.0265l-68.4878,44.0266z" fill="white" id="svg_3" stroke-width="0.575827"/>
 </g>
</svg>

```

`media/icons/stepinto.svg`:

```svg
<?xml version="1.0"?>
<svg width="295" height="295" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
 <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->

 <g class="layer">
  <title>Layer 1</title>
  <rect fill="#ffffff" height="14.571745" id="svg_24" rx="7.285872" ry="7.285872" stroke-dashoffset="0" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="4" stroke-width="2.455856" transform="matrix(0.707107 0.707107 0.707107 -0.707107 2110.59 1644.46)" width="95.819725" x="-2510.694281" y="-361.790899"/>
  <path d="m147.699552,0.287913c-81.28773,0 -147.41165,66.13022 -147.41165,147.41162c0,81.28142 66.12392,147.4116 147.41165,147.4116c81.28767,0 147.41157,-66.13018 147.41157,-147.4116c0,-81.2814 -66.1239,-147.41162 -147.41157,-147.41162zm0,282.53917c-74.50969,0 -135.12753,-60.61783 -135.12753,-135.12755c0,-74.50966 60.61784,-135.12751 135.12753,-135.12751c74.5097,0 135.12759,60.61785 135.12759,135.12751c0,74.50972 -60.61789,135.12755 -135.12759,135.12755z" fill="white" id="svg_25" stroke-width="0.575827"/>
  <rect fill="#ffffff" height="14.571745" id="svg_23" rx="7.285842" ry="7.285842" stroke-dashoffset="0" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="4" stroke-width="2.455856" transform="matrix(0 1 1 0 2110.59 1644.46)" width="125.70561" x="-1579.849159" y="-1970.384648"/>
  <circle cx="-1962.886219" cy="-1424.832189" fill="#ffffff" id="svg_22" r="14.345113" stroke-dashoffset="0" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="4" stroke-width="18.976213" transform="matrix(1 0 0 1 2110.59 1644.46)"/>
  <rect fill="#ffffff" height="14.571745" id="svg_26" rx="7.28587" ry="7.28587" stroke-dashoffset="0" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="4" stroke-width="2.455856" transform="rotate(-90 177.023 154.023) matrix(0.707107 0.707107 0.707107 -0.707107 2110.59 1644.46)" width="95.819725" x="-2469.045544" y="-320.626114"/>
 </g>
</svg>
```

`media/icons/stop.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="295"
   height="295"
   version="1.1"
   id="svg1"
   sodipodi:docname="stop.svg"
   inkscape:version="1.3.2 (091e20e, 2023-11-25)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs1" />
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#000000"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:zoom="0.8"
     inkscape:cx="146.875"
     inkscape:cy="146.875"
     inkscape:window-width="1440"
     inkscape:window-height="710"
     inkscape:window-x="0"
     inkscape:window-y="38"
     inkscape:window-maximized="0"
     inkscape:current-layer="svg1" />
  <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
  <g
     class="layer"
     id="g1">
    <title
       id="title1">Layer 1</title>
    <path
       d="m147.699562,0.287913c-81.28773,0 -147.41166,66.1302 -147.41166,147.4115c0,81.2815 66.12394,147.4117 147.41166,147.4117c81.28769,0 147.41159,-66.1302 147.41159,-147.4117c0,-81.2813 -66.1239,-147.4115 -147.41159,-147.4115zm0,282.5391c-74.50968,0 -135.12754,-60.6179 -135.12754,-135.1276c0,-74.5097 60.61786,-135.1275 135.12754,-135.1275c74.50972,0 135.12748,60.6178 135.12748,135.1275c0,74.5097 -60.61776,135.1276 -135.12748,135.1276z"
       fill="white"
       id="svg_8"
       stroke-width="0.575827" />
    <path
       clip-rule="nonzero"
       d="m103.109472,93.263313c-7.20475,0 -13.1906,5.9859 -13.1906,13.1906l0,82.4877c0,7.2047 5.98585,13.1906 13.1906,13.1906l89.18667,0c7.20485,0 13.19069,-5.9859 13.19069,-13.1906l0,-82.4877c0,-7.2047 -5.98584,-13.1906 -13.19069,-13.1906l-89.18667,0zm0,11.8071l89.18667,0c0.86799,0 1.38365,0.5157 1.38365,1.3835l0,82.4877c0,0.8679 -0.51592,1.3835 -1.38365,1.3835l-89.18667,0c-0.86788,0 -1.38361,-0.5156 -1.38361,-1.3835l0,-82.4877c0,-0.8678 0.51597,-1.3835 1.38361,-1.3835z"
       fill="#ffffff"
       fill-rule="nonzero"
       id="svg_7"
       stroke-dashoffset="0"
       stroke-linecap="round"
       stroke-linejoin="round"
       stroke-miterlimit="4"
       stroke-width="11.807001" />
  </g>
</svg>

```

`memory/memory_abstract.py`:

```py
import z3


class MemoryAbstract(object):
    def mmap(self, address: int, size: int, init):
        raise NotImplementedError

    def is_mapped(self, address: int):
        raise NotImplementedError

    def store(self, address: z3.BitVecRef, value: z3.BitVecRef, endness):
        raise NotImplementedError

    def load(self, address: z3.BitVecRef, size: int, endness):
        raise NotImplementedError

    def get_unmapped(self, size: int, start_from: int, from_end: int):
        raise NotImplementedError

    def allocate(self, size: int, init):
        raise NotImplementedError

    def copy(self, state):
        raise NotImplementedError

    def merge(self, other, merge_condition):
        raise NotImplementedError

    def register_read_hook(self, function):
        raise NotImplementedError

    def register_store_hook(self, function):
        raise NotImplementedError

    def get_regions(self):
        return NotImplementedError

```

`memory/memory_object.py`:

```py
from ..expr import BV, BVArray, Bool, ITE


class MemoryObj(object):
    def __init__(self, name, bits=64, bvarray=None):
        self.bvarray = BVArray(
            "MEMOBJ_" + name, bits, 8
        ) if bvarray is None else bvarray

        self.name = name
        self.bits = bits

    def __str__(self):
        return "<MemoryObj{bits} {name}>".format(
            bits=self.bits,
            name=self.name
        )

    def __repr__(self):
        return self.__str__()

    def load(self, index: BV):
        return self.bvarray.Select(index)

    def store(self, index: BV, value: BV, condition: Bool = None):
        if condition is None:
            self.bvarray.Store(index, value)
        else:
            # this can be inefficient
            self.bvarray.ConditionalStore(index, value, condition)

    def copy(self):
        return MemoryObj(self.name, self.bits, self.bvarray.copy())

    def merge(self, other, merge_condition: Bool):
        self.bvarray = self.bvarray.merge(other.bvarray, merge_condition)

```

`memory/registers.py`:

```py
from copy import deepcopy
from .sym_flat_memory import MemoryConcreteFlat
from ..expr import BVV, BVS, Bool, ITE
from ..globals import logger


class Regs(object):

    attr = set(['state', 'bits', '_mem', '_regs', '_tmp_regs', '_last_mod', 'flags', '__class__', '__delattr__',
                '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
                '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__',
                '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
                '__str__', '__subclasshook__', '__weakref__', 'attr', 'copy', 'has_reg', 'merge'])

    def __init__(self, state):
        self.state = state
        self.bits = state.arch.bits()
        self._mem = MemoryConcreteFlat(state, self.bits // 8, self.bits)
        self._regs = dict()
        self._tmp_regs = dict()
        self.flags = dict()

        regs_data = state.arch.regs_data()
        for reg_name in regs_data:
            reg_info = regs_data[reg_name]
            self._mem.mmap(reg_info["addr"], reg_info["size"])

            self._regs[reg_name] = BVV(
                reg_info["addr"], self.bits), reg_info["size"]
            for subreg_name in reg_info["sub"]:
                subreg_info = reg_info["sub"][subreg_name]
                self._regs[subreg_name] = BVV(
                    reg_info["addr"] + subreg_info["offset"], self.bits), subreg_info["size"]

        for flag_name in state.arch.flags_data():
            default = state.arch.flags_default(flag_name)
            self.flags[flag_name] = BVS(
                flag_name, 1) if default is None else BVV(default, 1)

    def has_reg(self, reg_name: str):
        return reg_name in self._regs

    def __getattribute__(self, k):
        if k in Regs.attr:
            return super().__getattribute__(k)
        elif k in self._regs:
            reg_addr, reg_size = self._regs[k]
            return self._mem.load(reg_addr, reg_size, endness='big')
        elif k in self._tmp_regs:
            return self._tmp_regs[k]
        raise AttributeError("'%s' object has not attribute '%s'" %
                             (self.__class__.__name__, k))

    def __setattr__(self, k, val):
        if k in Regs.attr:
            return super().__setattr__(k, val)
        elif k in self._regs:
            reg_addr, reg_size = self._regs[k]
            if reg_size * 8 < val.size:
                logger.log_warn("WARNING trimming value size in regs.setattr")
                val = val.Extract(reg_size * 8 - 1, 0)
            self._mem.store(reg_addr, val, endness='big')
        elif "temp" in k:
            self._tmp_regs[k] = val
        else:
            raise AttributeError("'%s' object has not attribute '%s'" % (
                self.__class__.__name__, k))

    def copy(self, state):
        new_regs = Regs(state)
        new_regs._mem = self._mem.copy(state)
        new_regs.flags = deepcopy(self.flags)
        new_regs._tmp_regs = deepcopy(self._tmp_regs)
        return new_regs

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Regs)

        for reg in self.state.arch.regs_data():
            assert reg in other.state.arch.regs_data()

            self_reg = getattr(self, reg)
            other_reg = getattr(other, reg)

            if self_reg.eq(other_reg):
                continue

            setattr(self, reg,
                    ITE(
                        merge_condition,
                        other_reg,
                        self_reg
                    )
                    )

```

`memory/sym_file.py`:

```py
from ..expr import BV, BVV
from .sym_flat_memory_not_paged import MemoryConcreteFlatNotPaged


class SymFile(object):
    def __init__(self, filename, symfile=None):
        self.filename = filename
        if symfile is None:
            self.data = MemoryConcreteFlatNotPaged(filename)
            self.seek_idx = 0
            self.file_size = 0
        else:
            self.data = symfile.data.copy()
            self.seek_idx = symfile.seek_idx
            self.file_size = symfile.file_size

    def __str__(self):
        return "<SymFile %s, size: %s>" % (self.filename, self.file_size)

    def __repr__(self):
        return self.__str__()

    def seek(self, idx: int):
        self.seek_idx = idx

    def read(self, size: int) -> list:
        res = []
        for i in range(self.seek_idx, self.seek_idx + size):
            res.append(self.data.load(BVV(i, self.data.bits), 1))

        self.seek_idx += size
        self.file_size = max(self.file_size, self.seek_idx)
        return res

    def write(self, data: list):
        for i, el in enumerate(data):
            assert isinstance(el, BV) and el.size == 8
            self.data.store(
                BVV(self.seek_idx + i, 64),
                el
            )

        self.seek_idx += len(data)
        self.file_size = max(self.file_size, self.seek_idx)

    def merge(self, other, merge_condition):
        pass  # not implemented

    def copy(self, state=None):
        return SymFile(self.filename, self)

```

`memory/sym_flat_memory.py`:

```py
import math

from copy import deepcopy
from .memory_abstract import MemoryAbstract
from ..expr import BV, BVS
from ..utility.expr_wrap_util import symbolic


class Page(object):
    def __init__(self, addr, size, index_bits):
        self.addr = addr
        self.size = size
        self.index_bits = index_bits
        self.max_index = 2**index_bits - 1
        self._data = {}
        self._lazycopy = 0

    def read(self, index: int):
        assert 0 <= index <= self.max_index
        if index not in self._data:
            self._data[index] = BVS('page_%x_i%d' % (self.addr, index), 8)
        return self._data[index]

    def write(self, index: int, data: BV):
        assert 0 <= index <= self.max_index
        assert data.size == 8
        if self._lazycopy > 0:
            self._lazycopy -= 1
            new_page = Page(self.addr, self.size, self.index_bits)
            new_page._data = deepcopy(self._data)
            return new_page.write(index, data)

        self._data[index] = data
        return self

    def copy(self):
        self._lazycopy += 1
        return self


class MemoryConcreteFlat(MemoryAbstract):
    def __init__(self, state, page_size=0x100, bits=64):
        # page_size must be a power of 2
        assert (page_size & (page_size - 1)) == 0
        self.bits = bits
        self.state = state
        self.pages = dict()
        self.page_size = page_size
        self.index_bits = math.ceil(math.log(page_size, 2))

    def __str__(self):
        return "<SymMemoryFlat, %d pages>" % len(self.pages)

    def __repr__(self):
        return self.__str__()

    def mmap(self, address: int, size: int, init=None):
        assert address % self.page_size == 0
        assert size % self.page_size == 0
        for a in range(address // self.page_size, address // self.page_size + size // self.page_size, 1):
            self.pages[a] = Page(a * self.page_size,
                                 self.page_size, self.index_bits)

    def _store(self, page_address: int, page_index: int, value: BV):
        assert value.size == 8
        assert page_address in self.pages
        value = value.simplify()
        self.pages[page_address] = self.pages[page_address].write(
            page_index, value)

    def store(self, address: BV, value: BV, endness='big'):
        assert not symbolic(address)

        address = address.value
        size = value.size
        for i in range((size >> 3) - 1, -1, -1):
            if endness == 'little':
                addr = address + i
            else:
                addr = address + (size >> 3) - i - 1

            page_address = addr >> self.index_bits
            page_index = addr - (page_address << self.index_bits)

            self._store(page_address, page_index,
                        value.Extract(8*(i+1)-1, 8*i))

    def _load(self, page_address: int, page_index: int):
        assert page_address in self.pages
        return self.pages[page_address].read(page_index)

    def load(self, address: BV, size: int, endness='big'):
        assert not symbolic(address)

        address = address.value

        ran = range(size - 1, -1, -1) if endness == 'little' else range(size)
        res = None
        for i in ran:
            addr = address + i
            page_address = addr >> self.index_bits
            page_index = addr - (page_address << self.index_bits)

            tmp = self._load(page_address, page_index)
            res = tmp if res is None else res.Concat(tmp)

        return res.simplify()

    def is_mapped(self, address: int):
        return address >> self.index_bits in self.pages

    def get_unmapped(self, size, start_from, from_end):
        raise NotImplementedError

    def allocate(self, size):
        raise NotImplementedError

    def copy(self, state):
        new_memory = MemoryConcreteFlat(state, self.page_size, self.bits)
        new_pages = dict()
        for page_addr in self.pages:
            new_pages[page_addr] = self.pages[page_addr].copy()
        new_memory.pages = new_pages
        return new_memory

```

`memory/sym_flat_memory_not_paged.py`:

```py
from ..utility.expr_wrap_util import symbolic
from ..expr import BV, BVS
from .memory_abstract import MemoryAbstract


class MemoryConcreteFlatNotPaged(MemoryAbstract):
    def __init__(self, name, bits=64):
        self.name = name
        self.bits = bits
        self.values = {}
        self._lazycopy = False

    def __str__(self):
        return "<SymMemoryFlatNotPaged, %d values>" % len(self.values)

    def __repr__(self):
        return self.__str__()

    def _handle_lazycopy(self):
        if self._lazycopy:
            self._lazycopy = False
            old_dict = self.values
            self.values = {}
            for addr in old_dict:
                self.values[addr] = old_dict[addr]

    def mmap(self, address: int, size: int, init=None):
        pass  # do nothing

    def store(self, address: BV, value: BV, endness='big'):
        assert not symbolic(address)
        self._handle_lazycopy()

        address = address.value
        size = value.size

        for i in range(size // 8 - 1, -1, -1):
            if endness == 'little':
                addr = address + i
            else:
                addr = address + size // 8 - i - 1
            self.values[addr] = value.Extract(8*(i+1)-1, 8*i)

    def load(self, address: BV, size: int, endness='big'):
        assert not symbolic(address)

        address = address.value

        ran = range(size - 1, -1, -1) if endness == 'little' else range(size)
        res = None
        for i in ran:
            if (address+i) not in self.values:
                self.values[address+i] = BVS('unconstrained_{name}_{address}'.format(
                    name=self.name,
                    address=address + i,
                ), 8)

            tmp = self.values[address+i]
            res = tmp if res is None else res.Concat(tmp)

        return res

    def get_unmapped(self, size, start_from, from_end):
        raise NotImplementedError

    def allocate(self, size):
        raise NotImplementedError

    def copy(self, state=None):
        self._lazycopy = True
        res = MemoryConcreteFlatNotPaged(self.name, self.bits)
        res.values = self.values
        res._lazycopy = True
        return res

```

`memory/sym_memory.py`:

```py
import math

from collections import namedtuple
from ..utility.expr_wrap_util import symbolic, split_bv, heuristic_find_base
from ..utility import exceptions
from ..expr import BV, BVV, Bool, Or, ITE
from .memory_object import MemoryObj
from .memory_abstract import MemoryAbstract
from ..globals import logger

# bytes: byte array; index: int
InitData = namedtuple('InitData', ['bytes', 'index'])


class Page(object):
    def __init__(self, addr: int, size: int = 0x1000, bits: int = 12, init: InitData = None):
        self.addr = addr
        self.size = size
        self.bits = bits
        self.dirty = False
        self.mo = MemoryObj("%Xh" % addr, bits)
        self._init = init
        self._lazycopy = 0

    def lazy_init(self):
        if self._init is not None:
            start = BVV(self._init.index, self.bits)
            val = self._init.bytes
            assert len(val) + self._init.index <= self.size
            for i in range(len(val)):
                subval = val[i]
                self.mo.store(start + i, BVV(subval, 8))
            self._init = None

    def store(self, index: BV, value: BV, condition: Bool = None):
        self.dirty = True

        self.lazy_init()
        if self._lazycopy > 0:
            self._lazycopy -= 1
            new_page = Page(self.addr, self.size, self.bits)
            new_page.mo = self.mo.copy()
            return new_page.store(index, value)

        index = index.simplify()
        self.mo.store(index, value, condition)
        return self

    def load(self, index: BV):
        self.lazy_init()
        return self.mo.load(index)

    def copy(self):
        self._lazycopy += 1
        return self


class Memory(MemoryAbstract):
    CHECK_SYMB_ADDR_WITH_SOLVER = False

    def __init__(self, state, page_size=0x1000, bits=64, symb_uninitialized=False):
        # page_size must be a power of 2
        assert (page_size & (page_size - 1)) == 0, f"page_size must be power of 2, got 0x{page_size:x}"
        self.bits = bits
        self.state = state
        self.pages = dict()
        self.page_size = page_size
        self.index_bits = math.ceil(math.log(page_size, 2))
        self.symb_init = symb_uninitialized
        self.load_hooks = []
        self.store_hooks = []

    def __str__(self):
        return "<SymMemory, %d pages>" % len(self.pages)

    def __repr__(self):
        return self.__str__()

    def get_assertions_for_page(self, page_addr):
        if page_addr not in self.pages:
            return None

        return self.pages[page_addr].mo.bvarray.get_assertions()

    def mmap(self, address: int, size: int, init: InitData = None):
        assert address % self.page_size == 0, f"mmap: address 0x{address:x} not aligned to page_size 0x{self.page_size:x}"
        assert size % self.page_size == 0, f"mmap: size 0x{size:x} not multiple of page_size 0x{self.page_size:x}"

        init_val = None
        init_index = None
        if init is not None:
            init_val = init.bytes
            init_index = init.index
            data_index_i = 0
            data_index_f = self.page_size - init_index

        if not self.symb_init:
            # zero initialize
            if init_val is None:
                init_val = b"\x00" * size
                init_index = 0
            init_val = b"\x00" * init_index + init_val  # fill begin
            init_val = init_val + b"\x00" * \
                (self.page_size % len(init_val))  # fill end
            init_index = 0
            data_index_i = 0
            data_index_f = self.page_size

        i = 0
        for a in range(
            address // self.page_size,
            address // self.page_size + size // self.page_size,
            1
        ):
            if a not in self.pages:
                init_data = None
                if init_index is not None:
                    init_data = InitData(
                        init_val[data_index_i: data_index_f],
                        init_index)
                    init_index = 0  # only the first page has a starting index
                    data_index_i = data_index_f
                    data_index_f = data_index_i + self.page_size
                self.pages[a] = Page(
                    a, self.page_size, self.index_bits, init_data)
            else:
                logger.log_info("remapping the same page '%s'" % hex(a))
            i += 1

    def is_mapped(self, address: int):
        return address >> self.index_bits in self.pages

    def _handle_symbolic_address(self, address: BV, size: int, op_type: str):

        if isinstance(address, BVV):
            return address, None, None
        if Memory.CHECK_SYMB_ADDR_WITH_SOLVER and not self.state.solver.symbolic(address):  # check with solver
            return self.state.solver.evaluate(address), None, None

        logger.log_warn("WARNING: memory %s, symbolic memory access" % op_type)
        symb_access_mode = self.state.executor.bncache.get_setting(
            "memory.symb_address_mode")
        page_limit = int(self.state.executor.bncache.get_setting(
            "memory.limit_pages_limit"))
        concretize_unconstrained = self.state.executor.bncache.get_setting(
            "memory.concretize_unconstrained") == 'true'
        use_heuristic_find_base = self.state.executor.bncache.get_setting(
            "memory.use_heuristic_find_base") == 'true'
        min_addr = None
        max_addr = None
        min_addr_approx = address.interval.low
        max_addr_approx = address.interval.high
        heuristic_base = None

        if concretize_unconstrained:
            min_addr_approx = address.interval.low
            max_addr_approx = address.interval.high

            if max_addr_approx - min_addr_approx == 2**self.state.arch.bits() - 1:
                # slow path. let's use the solver to validate
                min_addr = self.state.solver.min(address)
                max_addr = self.state.solver.max(address)

                if max_addr - min_addr == 2**self.state.arch.bits() - 1:
                    # unconstrained case
                    logger.log_warn(
                        "WARNING: memory %s, concretizing mem access to a newly allocated address (\"concretize_unconstrained\" policy)" % op_type)
                    address_conc = self.get_unmapped(
                        size // self.page_size + 1, from_end=False) * self.page_size
                    self.mmap(address_conc,
                              (size // self.page_size + 1) * self.page_size)
                    self.state.solver.add_constraints(address == address_conc)
                    address = BVV(address_conc, address.size)
                    return address, min_addr, max_addr

        if symb_access_mode == "concretization":
            logger.log_warn(
                "WARNING: memory %s, concretizing mem access (\"concretization\" policy)" % op_type)
            heuristic_base = heuristic_find_base(
                address) if heuristic_base is None else heuristic_base
            if use_heuristic_find_base and heuristic_base != -1 and self.state.solver.satisfiable([address == heuristic_base]):
                logger.log_warn("WARNING: memory %s, heuristic address 0x%x" %
                      (op_type, heuristic_base))
                address_conc = BVV(heuristic_base, address.size)
            else:
                address_conc = self.state.solver.evaluate(address)
            self.state.solver.add_constraints(address == address_conc)
            return address_conc, None, None

        if symb_access_mode == "fully_symbolic":
            return (
                address,
                min_addr_approx if min_addr is None else min_addr,
                max_addr_approx if max_addr is None else max_addr
            )

        assert symb_access_mode == "limit_pages", f"symb_access_mode: expected 'limit_pages', got {repr(symb_access_mode)}"
        assert page_limit > 0, f"page_limit must be > 0, got {page_limit}"

        if max_addr_approx - min_addr_approx == 2**self.state.arch.bits() - 1:
            # slow path. let's use the solver to validate
            min_addr = self.state.solver.min(
                address) if min_addr is None else min_addr
            max_addr = self.state.solver.max(
                address) if max_addr is None else max_addr
            if max_addr - min_addr > page_limit * self.page_size:
                logger.log_warn(
                    "WARNING: memory %s, limiting memory access (\"limit_pages\" policy)" % op_type)

                min_addr_page = min_addr >> self.index_bits
                max_addr_page = max_addr >> self.index_bits
                page_address, _ = split_bv(address, self.index_bits)

                heuristic_base = heuristic_find_base(
                    address) if heuristic_base is None else heuristic_base
                heuristic_base_page = heuristic_base >> self.index_bits

                if (
                    use_heuristic_find_base and
                    heuristic_base != -1 and
                    heuristic_base_page >= min_addr_page and
                    heuristic_base_page <= max_addr_page - page_limit and
                    self.state.solver.satisfiable([address == heuristic_base])
                ):
                    logger.log_warn("WARNING: memory %s, heuristic address 0x%x" %
                          (op_type, heuristic_base))
                    pivot = heuristic_base_page
                else:
                    # make it more efficient! (interval tree?)
                    pages_in_range = [page for page in self.pages if (
                        page >= min_addr_page and page <= max_addr_page)]

                    if pages_in_range:
                        pivot = min(pages_in_range)
                    else:
                        logger.log_warn(
                            "WARNING: memory %s, allocating pages (\"limit_pages\" policy)" % op_type)
                        pivot = self.get_unmapped(
                            self.page_size * page_limit, from_end=False)
                        self.mmap(pivot << self.index_bits,
                                  page_limit * self.page_size)

                condition = None
                for i in range(page_limit):
                    condition = (page_address == pivot + i) if condition is None else (
                        Or(condition, page_address == pivot + i))

                # I am not checking the satisfiability of every page, but at least the first one is satisfiable
                self.state.solver.add_constraints(condition)
                return address, min_addr, max_addr

        return (
            address,
            min_addr_approx if min_addr is None else min_addr,
            max_addr_approx if max_addr is None else max_addr
        )

    def _store(self, page_address: int, page_index: BV, value: BV, condition: Bool = None):
        assert page_address in self.pages, f"_store: page 0x{page_address:x} not mapped"
        assert value.size == 8, f"_store: value size must be 8, got {value.size}"

        value = value.simplify()
        self.pages[page_address] = self.pages[page_address].store(
            page_index, value, condition)

    def store(self, address, value: BV, endness='big'):
        if isinstance(address, int):
            address = BVV(address, self.state.arch.bits())
        assert address.size == self.bits, f"store: address size must be {self.bits}, got {address.size}"

        for f in self.store_hooks:
            f(address, value.size)

        address, min_addr, max_addr = self._handle_symbolic_address(
            address, value.size, "store")

        conditions = list()
        size = value.size
        assert size % 8 == 0
        for i in range(size // 8 - 1, -1, -1):
            if endness == 'little':
                page_address, page_index = split_bv(
                    address + i, self.index_bits)
            else:
                page_address, page_index = split_bv(
                    address + size // 8 - i - 1, self.index_bits)

            # syntactic check + check with path constraint
            if not symbolic(page_address) or not self.state.solver.symbolic(page_address):
                if symbolic(page_address):
                    page_address = self.state.solver.evaluate(page_address)
                page_address = page_address.value
                if page_address not in self.pages:
                    self.state.executor.put_in_errored(
                        self.state, "write unmapped"
                    )
                    raise exceptions.UnmappedWrite(self.state.get_ip())
                self._store(page_address, page_index,
                            value.Extract(8*(i+1)-1, 8*i))
            else:  # symbolic access
                conditions = list()
                for p in self.pages:  # can be improved?
                    at_least_one_page = False
                    if p < (min_addr >> self.index_bits) or p > (max_addr >> self.index_bits):
                        continue
                    if self.state.solver.satisfiable(extra_constraints=[
                        page_address == p
                    ]):
                        at_least_one_page = True
                        condition = p == page_address
                        conditions.append(condition)
                        self._store(p, page_index, value.Extract(
                            8*(i+1)-1, 8*i), condition)
                if not at_least_one_page:
                    self.state.executor.put_in_errored(
                        self.state, "write unmapped"
                    )
                    raise exceptions.UnmappedWrite(self.state.get_ip())
            if conditions:
                check_unmapped = self.state.executor.bncache.get_setting(
                    "memory.check_unmapped") == 'true'
                if check_unmapped and self.state.solver.satisfiable(extra_constraints=[
                    Or(*conditions).Not()
                ]):
                    errored_state = self.state.copy()
                    errored_state.solver.add_constraints(Or(*conditions).Not())
                    self.state.executor.put_in_errored(
                        errored_state, "write unmapped"
                    )
                self.state.solver.add_constraints(Or(*conditions))

    def _load(self, page_address: int, page_index: BV):
        assert page_address in self.pages, f"_load: page 0x{page_address:x} not mapped"
        return self.pages[page_address].load(page_index)

    def load(self, address, size: int, endness='big'):
        if isinstance(address, int):
            address = BVV(address, self.state.arch.bits())
        assert address.size == self.bits, f"load: address size must be {self.bits}, got {address.size}"

        for f in self.load_hooks:
            f(address, size)

        address, min_addr, max_addr = self._handle_symbolic_address(
            address, size, "load")

        res = None
        conditions = list()
        ran = range(size - 1, -1, -1) if endness == 'little' else range(size)
        for i in ran:
            page_address, page_index = split_bv(address + i, self.index_bits)
            # syntactic check + check with path constraint
            if not symbolic(page_address) or not self.state.solver.symbolic(page_address):
                if symbolic(page_address):
                    page_address = self.state.solver.evaluate(page_address)
                page_address = page_address.value
                if page_address not in self.pages:
                    self.state.executor.put_in_errored(
                        self.state, "read unmapped"
                    )
                    raise exceptions.UnmappedRead(self.state.get_ip())
                tmp = self._load(page_address, page_index)
            else:  # symbolic access
                conditions = list()
                tmp = None
                for p in self.pages:  # can be improved?
                    if p < (min_addr >> self.index_bits) or p > (max_addr >> self.index_bits):
                        continue
                    if self.state.solver.satisfiable(extra_constraints=[
                        page_address == p
                    ]):
                        condition = p == page_address
                        conditions.append(condition)
                        tmp = ITE(condition,
                                  self._load(p, page_index),
                                  tmp
                                  ) if tmp is not None else self._load(p, page_index)

                if tmp is None:
                    self.state.executor.put_in_errored(
                        self.state, "read unmapped"
                    )
                    raise exceptions.UnmappedRead(self.state.get_ip())
            res = tmp if res is None else res.Concat(tmp)

        if conditions:
            check_unmapped = self.state.executor.bncache.get_setting(
                "memory.check_unmapped") == 'true'
            if check_unmapped and self.state.solver.satisfiable(extra_constraints=[
                Or(*conditions).Not()
            ]):
                errored_state = self.state.copy()
                errored_state.solver.add_constraints(Or(*conditions).Not())
                self.state.executor.put_in_errored(
                    errored_state, "read unmapped"
                )
            self.state.solver.add_constraints(Or(*conditions))

        assert res is not None
        assert res.size // 8 == size

        return res.simplify()

    def get_unmapped(self, size: int, start_from: int = None, from_end: int = True):
        start_from = start_from >> self.index_bits if start_from is not None else None
        last_page = 2**(self.bits - self.index_bits) - 4
        first_page = 2

        if from_end:
            res = last_page if start_from is None else start_from
            count = 0

            while res >= first_page:
                if res not in self.pages:
                    count += 1
                    if count == size:
                        return res
                else:
                    count = 0
                res -= 1

            return -1

        else:
            idx = first_page if start_from is None else start_from
            res = first_page if start_from is None else start_from
            count = 0

            while idx <= last_page:
                if idx not in self.pages:
                    count += 1
                    if count == size:
                        return res
                else:
                    count = 0
                    idx += count+1
                    res = idx

            return -1

    def allocate(self, size: int, init: InitData = None):
        assert size > 0
        num_pages = (size + self.page_size - 1) >> self.index_bits
        page_addr = self.get_unmapped(num_pages)
        full_addr = page_addr << self.index_bits
        self.mmap(full_addr, num_pages * self.page_size, init)

        return full_addr

    def copy(self, state):
        new_memory = Memory(state, self.page_size, self.bits)
        new_pages = dict()
        for page_addr in self.pages:
            new_pages[page_addr] = self.pages[page_addr].copy()
        new_memory.pages = new_pages
        return new_memory

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Memory)
        for page_addr in other.pages:
            other_page = other.pages[page_addr]

            if (
                page_addr in self.pages and
                self.pages[page_addr].mo.bvarray.z3obj.eq(
                    other_page.mo.bvarray.z3obj)
            ):
                continue  # very same page. No need to update

            if page_addr not in self.pages:
                self.mmap(page_addr, self.page_size)

            self.pages[page_addr].mo.merge(
                other_page.mo,
                merge_condition
            )

    def register_read_hook(self, function):
        self.read_hooks.append(function)

    def register_store_hook(self, function):
        self.store_hooks.append(function)

    def get_regions(self):
        regions = list()
        addresses = list(sorted(self.pages.keys()))
        if len(addresses) == 0:
            return regions
        addresses = list(map(lambda a: a*self.page_size, addresses))

        currAddr = addresses[0]
        currSize = self.page_size
        i = 1
        while i < len(addresses):
            if addresses[i] == currAddr + currSize:
                currSize += self.page_size
            else:
                regions.append(
                    (currAddr, currSize)
                )
                currAddr = addresses[i]
                currSize = self.page_size
            i += 1
        regions.append(
            (currAddr, currSize)
        )
        return regions

```

`models/function_models.py`:

```py
from ..expr import BVV, BVS
from . import others as models_other
from . import libc as models_libc
from . import unistd as models_unistd
from . import string as models_string
from . import teensy as models_teensy

def reval_model(val, nbits):
    return lambda state, view: BVV(val, nbits)

library_functions = {
    'printf':           models_libc.printf_handler,
    '__printf_chk':     models_libc.printf_chk_handler,
    'scanf':            models_libc.scanf_handler,
    '__isoc99_scanf':   models_libc.scanf_handler,
    'sscanf':           models_libc.sscanf_handler,
    '__isoc99_sscanf':  models_libc.sscanf_handler,
    'getchar':          models_libc.getchar_handler,
    'putchar':          models_libc.putchar_handler,
    'puts':             models_libc.puts_handler,
    'fgets':            models_libc.fgets_handler,
    'strcmp':           models_string.strcmp_handler,
    'strlen':           models_string.strlen_handler,
    'strcpy':           models_string.strcpy_handler,
    'strncpy':          models_string.strncpy_handler,
    'isxdigit':         models_libc.isxdigit_handler,
    'atoi':             models_libc.atoi_handler,
    'atol':             models_libc.atol_handler,
    'atoll':            models_libc.atol_handler,
    'malloc':           models_libc.malloc_handler,
    'calloc':           models_libc.calloc_handler,
    'read':             models_unistd.read_handler,
    'write':            models_unistd.write_handler,
    'memcmp':           models_string.memcmp_handler,
    'memset':           models_string.memset_handler,
    'time':             models_other.time_handler,
    'stat':             models_unistd.stat_handler,
    '__xstat':          models_unistd.xstat_handler,
    'exit':             models_libc.exit_handler,

    # Antidebug
    'ptrace':           models_libc.ptrace_handler,

    # C++
    '_Znwm':            models_libc.malloc_handler,
    '_Znwj':            models_libc.malloc_handler,

    # concrete models
    'strtoul':          models_libc.strtoul_handler,
    'srand':            models_libc.srand_handler,
    'rand':             models_libc.rand_handler,

    # models Teensy Board
    # Print::println(int)
    '_ZN5Print7printlnEi':   models_teensy.println_handler,
    # Print::println(char*)
    '_ZN5Print7printlnEPKc': models_teensy.println_handler
}

```

`models/libc.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS, BoolV, ITE, Or, And
from ..utility.models_util import get_arg_k
from ..utility.exceptions import ExitException, ModelError
from ..utility.string_util import as_bytes, str_to_bv_list
from ..memory.sym_memory import InitData
import re
import os
import ctypes
import ctypes.util

if os.name == 'nt':
    # windows
    libc_native_path = ctypes.util.find_library('msvcrt')
else:
    libc_native_path = ctypes.util.find_library('c')
libc_native = ctypes.cdll.LoadLibrary(libc_native_path)
ascii_numbers = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]

# ---- NATIVE CONCRETE HANDLERS -----

def srand_handler(state: State, view):
    seed = get_arg_k(state, 1, state.arch.bits() // 8, view)
    libc_native.srand(seed.value)
    return BVV(1, 32)

def rand_handler(state: State, view):
    val = libc_native.rand()
    return BVV(val, 32)

def strtoul_handler(state: State, view):
    str_p = get_arg_k(state, 1, state.arch.bits() // 8, view)
    endptr = get_arg_k(state, 2, state.arch.bits() // 8, view)
    base = get_arg_k(state, 3, 4, view)

    if symbolic(base) or symbolic(endptr) or symbolic(str_p):
        raise ModelError("strtoul", "symbolic arguments are not supported")

    i = 0
    str_data = b""
    b = state.mem.load(str_p, 1)
    while not symbolic(b) and i < 64:
        b = b.value
        str_data += bytes([b])
        if b == 0:
            break
        i += 1
        b = state.mem.load(str_p + i, 1)

    _native_buff = ctypes.c_char_p(str_data)
    _native_endptr = ctypes.c_ulong(0)
    _native_base = base.value

    _native_res = libc_native.strtoul(
        _native_buff,
        ctypes.byref(_native_endptr),
        _native_base
    )

    offset = (_native_endptr.value & 0xffffffff) - \
        (ctypes.cast(_native_buff, ctypes.c_void_p).value & 0xffffffff)
    assert offset >= 0
    state.mem.store(endptr, BVV((str_p.value + offset),
                                state.arch.bits()), 'little')
    return BVV(_native_res, state.arch.bits())
# -----------------------------------

def exit_handler(state: State, view):
    raise ExitException()

def _intbv_to_strbv16(intbv):
    # int bv to string bv in hex
    res = [BVV(ord("0"), 8), BVV(ord("x"), 8)]
    for b in as_bytes(intbv):
        low = b.Extract(3, 0).ZeroExt(4)
        hig = b.Extract(7, 4).ZeroExt(4)

        rb_low = ITE(
            low.ULT(10),
            BVV(ord("0"), 8) + low,
            BVV(ord("A"), 8) - 10 + low
        )
        rb_hig = ITE(
            hig.ULT(10),
            BVV(ord("0"), 8) + hig,
            BVV(ord("A"), 8) - 10 + hig
        )
        v = [rb_hig, rb_low]
        res.extend(v)

    return res

def _printf_common(state: State, format_str_p, param_idx_start, view):
    if symbolic(format_str_p) and state.solver.symbolic(format_str_p):
        raise ModelError("_printf_common", "symbolic format string not supported")

    b = state.mem.load(format_str_p, 1)
    format_str = ""
    while not symbolic(b) and b.value != 0:
        format_str += chr(b.value)
        format_str_p += 1
        b = state.mem.load(format_str_p, 1)

    state.events.append(
        "printf with format '%s'" % format_str
    )

    match = ""
    res = list()
    last_idx = 0
    param_idx = param_idx_start
    params = re.finditer("%([0-9]*s|d|u|x|X|c)", format_str)  # TODO generalize
    for param in params:
        index = param.start()
        match = param.group()

        val = list()
        if match[-1] == "s":
            # string
            param_p = get_arg_k(state, param_idx, state.arch.bits() // 8, view)
            max_symb_str = int(state.executor.bncache.get_setting(
                "models.max_size_symb_string"))
            l = int(match[1:-1]) if len(match) > 2 else max_symb_str

            i = 0
            c = state.mem.load(param_p, 1)
            while i < l:
                if not symbolic(c) and c.value == 0:
                    break
                val.append(c)
                param_p += 1
                c = state.mem.load(param_p, 1)
                i += 1

        elif match == "%d" or match == "%u" or match == "%x" or match == "%X":
            int_val = get_arg_k(state, param_idx, 4, view)
            if symbolic(int_val):
                val = _intbv_to_strbv16(int_val)
            else:
                if match == "%d" or match == "%u":
                    val = str_to_bv_list(str(int_val.value))
                else:
                    val = str_to_bv_list(hex(int_val.value)[2:])

        elif match == "%c":
            c = get_arg_k(state, param_idx, 1, view)

            val = [c]

        param_idx += 1

        format_substr = format_str[last_idx:index]
        last_idx = index + len(match)
        res.extend(str_to_bv_list(format_substr))
        res.extend(val)

    format_substr = format_str[last_idx + len(match):]
    res.extend(str_to_bv_list(format_substr))

    return res, BVV(len(res), 32)

def printf_handler(state: State, view):  # only concrete
    format_str_p = get_arg_k(state, 1, state.arch.bits() // 8, view)
    data_list, res_n = _printf_common(state, format_str_p, 2, view)

    state.os.write(state.os.stdout_fd, data_list)
    return res_n

def printf_chk_handler(state: State, view):
    flag = get_arg_k(state, 1, 4, view)  # TODO ignored
    format_str_p = get_arg_k(state, 2, state.arch.bits() // 8, view)
    data_list, res_n = _printf_common(state, format_str_p, 3, view)

    state.os.write(state.os.stdout_fd, data_list)
    return res_n

def putchar_handler(state: State, view):
    res = get_arg_k(state, 1, 4, view)
    c = res.Extract(7, 0)

    state.os.write(state.os.stdout_fd, [c])
    return res

def puts_handler(state: State, view):
    string_p = get_arg_k(state, 1, state.arch.bits() // 8, view)

    max_symb_str = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))
    i = 0
    c = state.mem.load(string_p, 1)
    while (not symbolic(c) and c.value != 0) or (symbolic(c) and i < max_symb_str):
        state.os.write(state.os.stdout_fd, [c])
        i += 1
        c = state.mem.load(string_p + i, 1)

    return BVV(0, 32)

def getchar_handler(state: State, view):
    state.events.append(
        "getchar called"
    )

    v = state.os.read(state.os.stdin_fd, 1)
    return v[0]


scanf_count = 0

def _internal_scanf_handler(state: State, view, argoff):
    # scanf does not support reading data from stdin... Too difficult to model
    # it will simply write on stdin the correct data
    global scanf_count
    format_str_p = get_arg_k(state, argoff+1, state.arch.bits() // 8, view)

    if symbolic(format_str_p) and state.solver.symbolic(format_str_p):
        raise ModelError("scanf_handler", "symbolic format string not supported")

    b = state.mem.load(format_str_p, 1)
    format_str = ""
    while not symbolic(b) and b.value != 0:
        format_str += chr(b.value)
        format_str_p += 1
        b = state.mem.load(format_str_p, 1)

    state.events.append(
        "scanf with format '%s'" % format_str
    )

    match = ""
    bytes_read = list()
    last_idx = 0
    param_idx = 2
    params = re.finditer("%([0-9]*s|d|x)", format_str)  # TODO generalize
    num_params = 0
    for param in params:
        num_params += 1
        index = param.start()
        match = param.group()

        tmp_bytes_read = list()
        par_p = get_arg_k(state, argoff+param_idx, state.arch.bits() // 8, view)
        if symbolic(par_p) and state.solver.symbolic(par_p):
            raise ModelError("scanf_handler", "symbolic pointer for arguments not supported")
        name = 'scanf_input_%d' % scanf_count

        if match[-1] == "d" or match[-1] == "x":
            data = BVS(name + "_INT", 32)
            # Since we are generating new inputs, let's view them in the UI
            state.symbolic_buffers.append((data, par_p.value, ""))
            state.mem.store(par_p, data, endness=state.arch.endness())
            tmp_bytes_read = _intbv_to_strbv16(data)
        elif match[-1] == "s":
            max_symb_str = int(state.executor.bncache.get_setting(
                "models.max_size_symb_string"))
            n = int(match[1:-1]) if len(match) > 2 else max_symb_str

            data = BVS(name + "_STR", 8*(n - 1))
            # Since we are generating new inputs, let's view them in the UI
            state.symbolic_buffers.append((data, par_p.value, ""))
            state.mem.store(par_p, data.Concat(BVV(0, 8)), 'big')
            for i in range(0, data.size, 8):
                b = data.Extract(i+7, i)
                state.solver.add_constraints(b != ord("\n"))
                tmp_bytes_read.append(b)

        param_idx += 1

        format_substr = format_str[last_idx:index]
        last_idx = index + len(match)
        bytes_read.extend(str_to_bv_list(format_substr))
        bytes_read.extend(tmp_bytes_read)

        scanf_count += 1

    format_substr = format_str[last_idx + len(match):]
    bytes_read.extend(str_to_bv_list(format_substr))
    return BVV(num_params, 32), bytes_read

def scanf_handler(state: State, view):
    res, bytes = _internal_scanf_handler(state, view, 0)
    state.os.write(state.os.stdin_fd, bytes)
    return res

def sscanf_handler(state: State, view):
    res, bytes = _internal_scanf_handler(state, view, 1)
    sptr = get_arg_k(state, 1, state.arch.bits() // 8, view)
    for off, b in enumerate(bytes):
        state.mem.store(sptr+off, b)
    return res

def fgets_handler(state: State, view):
    s_p = get_arg_k(state, 1, state.arch.bits() // 8, view)
    size = get_arg_k(state, 2, 4, view)
    if symbolic(size):
        actual_size = state.solver.max(size)
        max_size = state.executor.bncache.get_setting(
            "models.max_size_symb_string")

        if actual_size > max_size:
            actual_size = max_size
            state.solver.add_constraints(size == actual_size)
    else:
        actual_size = size.value

    for i in range(actual_size):
        # TODO get correct FD
        v = state.os.read(state.os.stdin_fd, 1)[0]
        state.mem.store(s_p + i, v)
    state.mem.store(s_p + actual_size, BVV(0, 8))

    return s_p


def isxdigit_handler(state: State, view):
    c = get_arg_k(state, 1, 4, view)

    res = ITE(
        Or(
            And(c >= 48, c <= 57),  # 0 -> 9
            And(c >= 97, c <= 102),  # a -> f
            And(c >= 65, c <= 70)   # A -> F
        ), BVV(1, 32), BVV(0, 32)
    )
    return res

# ************** atoX models **************

# SLOW... but cool :)
atox_idx = 0

def _atox(state: State, view, size: int):
    atox_slow_model = state.executor.bncache.get_setting(
        "models.use_atox_slow_model") == 'true'
    if not atox_slow_model:
        global atox_idx
        atox_idx += 1
        return BVS('atox_unconstrained_{idx}'.format(atox_idx), size*8)

    input_p = get_arg_k(state, 1, state.arch.bits() // 8, view)

    if symbolic(input_p) and state.solver.symbolic(input_p):
        # FIXME: I should:
        #            1. return a fresh new symbol
        #            2. allocate a new buffer with a concrete address
        #            3. store the correct expression in the buffer for consistency
        raise ModelError("atox", "symbolic input pointer (not supported)")

    def build_or_expression(b):
        conditions = []
        for n in ascii_numbers:
            n = ord(n)
            conditions.append(b == n)
        return Or(*conditions)

    max_len = len(str(2**(size * 8)))  # max valid number

    first_char = state.mem.load(input_p, 1)
    state.solver.add_constraints(
        build_or_expression(first_char)
    )  # first char must be ascii

    i = 1
    char = state.mem.load(input_p + i, 1)
    chars = []
    while i <= max_len:

        cond_1 = build_or_expression(char)
        cond_2 = char == 0
        cond_3 = BoolV(False)
        for old_char in chars:
            cond_2 = And(
                cond_2,
                old_char != 0
            )
            cond_3 = Or(
                cond_3,
                old_char == 0
            )
        cond = Or(
            cond_1, cond_2, cond_3
        )
        state.solver.add_constraints(
            cond
        )

        chars.append(char)
        i += 1
        char = state.mem.load(input_p + i, 1)

    chars = [first_char] + chars

    # one bit more, to prevent overflow
    res = first_char.ZeroExt(size*8+1-8) - ord('0')
    for i in range(len(chars)-1, 0, -1):
        char = chars[i]

        expr = None
        for j in range(len(chars[:i])):
            # one bit more, to prevent overflow
            old_char = chars[i-j-1].ZeroExt(size*8+1-8)
            if expr is not None:
                expr += (10**j)*(old_char - ord('0'))
            else:
                expr = (10**j)*(old_char - ord('0'))

        res = ITE(
            char == 0,
            expr,
            res
        )

    # prevent overflow
    overflow_bit = res.Extract(size*8, size*8)
    state.solver.add_constraints(
        overflow_bit == 0
    )

    if not state.solver.satisfiable():
        raise ModelError("_atox", "unsat solver")
    return res.Extract(size*8-1, 0)

def atoi_handler(state: State, view):
    return _atox(state, view, 4)

def atol_handler(state: State, view):
    return _atox(state, view, 8)

# ********* MALLOC MODELS *********

def malloc_handler(state: State, view):
    size = get_arg_k(state, 1, 4, view)
    max_malloc = int(state.executor.bncache.get_setting(
        "models.max_malloc_size"))
    if symbolic(size):
        size = state.solver.max(size)
        if size > max_malloc:
            size = max_malloc
    else:
        size = size.value

    res = state.mem.allocate(size)
    return BVV(res, state.arch.bits())

def calloc_handler(state: State, view):
    size = get_arg_k(state, 1, 4, view)
    max_malloc = int(state.executor.bncache.get_setting(
        "models.max_malloc_size"))
    if symbolic(size):
        size = state.solver.max(size)
        if size > max_malloc:
            size = max_malloc
    else:
        size = size.value

    res = state.mem.allocate(
        size,
        InitData(bytes=b"\x00"*size, index=0)
    )
    return BVV(res, state.arch.bits())

# ***************************************

# ********* MISC MODELS *********

def ptrace_handler(state: State, view):
    # Just a stub to trick anti-debug code
    return BVV(1, 32)

# ***************************************

```

`models/linux_syscalls.py`:

```py
from ..utility.expr_wrap_util import symbolic
from ..utility.exceptions import ExitException, ModelError
from ..expr import BVV

MAX_SYM_READ_WRITE = 100


def read_handler(state):
    fd = state.syscall_abi.get_arg(state, 0)
    buf = state.syscall_abi.get_arg(state, 1)
    count = state.syscall_abi.get_arg(state, 2)

    if symbolic(fd) and state.solver.symbolic(fd):
        raise ModelError("linux_read", "symbolic fd not supported")
    fd = fd.value
    if not state.os.is_open(fd):
        return BVV(-9, 32) # EBADF

    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_SYM_READ_WRITE if count > MAX_SYM_READ_WRITE else count
    else:
        count = count.value

    res = state.os.read(fd, count)
    for i, b in enumerate(res):
        state.mem.store(buf + i, b)

    state.events.append(
        "read from fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


def write_handler(state):
    fd = state.syscall_abi.get_arg(state, 0)
    buf = state.syscall_abi.get_arg(state, 1)
    count = state.syscall_abi.get_arg(state, 2)

    if symbolic(fd) and state.solver.symbolic(fd):
        raise ModelError("linux_write", "symbolic fd not supported")
    fd = fd.value
    if not state.os.is_open(fd):
        return BVV(-9, 32) # EBADF

    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_SYM_READ_WRITE if count > MAX_SYM_READ_WRITE else count
    else:
        count = count.value

    data = []
    for i in range(count):
        b = state.mem.load(buf + i, 1)
        data.append(b)
    state.os.write(fd, data)

    state.events.append(
        "write to fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


def exit_handler(state):
    raise ExitException()

```

`models/others.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS
from ..utility.models_util import get_arg_k

time_idx = 0


def time_handler(state: State, view):
    global time_idx
    res = BVS("time_%d" % time_idx, state.arch.bits())

    return res


pid_cache = None


def getpid_handler(state: State, view):
    res = pid_cache if pid_cache else BVS('pid_symb', 32)

    return res

```

`models/string.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS, BoolV, And, ITE
from ..utility.models_util import get_arg_k
from ..utility.exceptions import ModelError


def memcmp_handler(state: State, view):
    buff1 = get_arg_k(state, 1, state.arch.bits() // 8, view)
    buff2 = get_arg_k(state, 2, state.arch.bits() // 8, view)
    n = get_arg_k(state, 3, state.arch.bits() // 8, view)

    if symbolic(n):
        n = state.solver.max(n)
        max_memcmp = int(state.executor.bncache.get_setting(
            "models.max_memcmp_size"))
        if n > max_memcmp:
            n = max_memcmp
    else:
        n = n.value

    res = BoolV(True)
    for i in range(n):
        c1 = state.mem.load(buff1 + i, 1)
        c2 = state.mem.load(buff2 + i, 1)

        res = And(
            c1 == c2, res
        )

    return ITE(res, BVV(0, 32), BVV(1, 32))


def memset_handler(state: State, view):
    buff = get_arg_k(state, 1, state.arch.bits() // 8, view)
    val = get_arg_k(state, 2, 1, view)
    n = get_arg_k(state, 3, 4, view)

    if symbolic(n):
        n = state.solver.max(n)
        max_memset = int(state.executor.bncache.get_setting(
            "models.max_memset_size"))
        if n > max_memset:
            n = max_memset
    else:
        n = n.value

    for i in range(n):
        state.mem.store(buff+i, val)

    return buff


def strcmp_handler(state: State, view):
    str1 = get_arg_k(state, 1, state.arch.bits() // 8, view)
    str2 = get_arg_k(state, 2, state.arch.bits() // 8, view)

    if symbolic(str1) and state.solver.symbolic(str1):
        raise ModelError("strcmp", "symbolic string1 pointer not supported")
    if symbolic(str2) and state.solver.symbolic(str2):
        raise ModelError("strcmp", "symbolic string2 pointer not supported")
    if symbolic(str1):
        str1 = state.solver.evaluate(str1)
    if symbolic(str2):
        str1 = state.solver.evaluate(str2)

    max_sym_string = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))

    b1 = state.mem.load(str1, 1)
    b2 = state.mem.load(str2, 1)
    cond = BoolV(True)
    i = 0
    while True:
        if not symbolic(b1) or not state.solver.symbolic(b1):
            b1 = state.solver.evaluate(b1) if symbolic(b1) else b1
            if b1.value == 0:
                break
        if not symbolic(b2) or not state.solver.symbolic(b2):
            b2 = state.solver.evaluate(b2) if symbolic(b2) else b2
            if b2.value == 0:
                break

        if symbolic(b1) and symbolic(b2) and i > max_sym_string:
            state.solver.add_constraints(b1 == 0, b2 == 0)
            break

        cond = (b1 == b2).And(cond)
        str1 += 1
        str2 += 1
        b1 = state.mem.load(str1, 1)
        b2 = state.mem.load(str2, 1)
        i += 1

    return ITE(cond, BVV(0, 32), BVV(1, 32))


def strlen_handler(state: State, view):
    str1 = get_arg_k(state, 1, state.arch.bits() // 8, view)

    if symbolic(str1) and state.solver.symbolic(str1):
        raise ModelError("strlen", "symbolic string pointer not supported")
    if symbolic(str1):
        str1 = state.solver.evaluate(str1)

    max_sym_string = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))

    b1 = state.mem.load(str1, 1)
    vals = []
    i = 0
    while True:
        if not symbolic(b1) or not state.solver.symbolic(b1):
            b1 = state.solver.evaluate(b1)
            if b1.value == 0:
                break
        elif i > max_sym_string:
            state.solver.add_constraints(b1 == 0)
            break

        vals.append((i, b1))
        i += 1
        str1 += 1
        b1 = state.mem.load(str1, 1)

    res = BVV(i, state.arch.bits())
    for i, b in vals[::-1]:
        res = ITE(b == 0, BVV(i, state.arch.bits()), res)
    return res


def strcpy_handler(state: State, view):
    dst = get_arg_k(state, 1, state.arch.bits() // 8, view)
    src = get_arg_k(state, 2, state.arch.bits() // 8, view)

    if symbolic(dst) and state.solver.symbolic(dst):
        raise ModelError("strcpy", "symbolic dst not supported")
    if symbolic(src) and state.solver.symbolic(src):
        raise ModelError("strcpy", "symbolic src not supported")

    if symbolic(dst):
        dst = state.solver.evaluate(dst)
    if symbolic(src):
        src = state.solver.evaluate(src)

    max_sym_string = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))

    i = 0
    src_b = state.mem.load(src, 1)
    while True:
        if not symbolic(src_b) or not state.solver.symbolic(src_b):
            src_b = state.solver.evaluate(src_b) if symbolic(src_b) else src_b
            if src_b.value == 0:
                break
        elif i > max_sym_string:
            state.solver.add_constraints(src_b == 0)
            break

        state.mem.store(dst + i, src_b)
        i += 1
        src_b = state.mem.load(src + i, 1)

    state.mem.store(dst + i, BVV(0, 8))
    return dst


def strncpy_handler(state: State, view):
    dst = get_arg_k(state, 1, state.arch.bits() // 8, view)
    src = get_arg_k(state, 2, state.arch.bits() // 8, view)
    n = get_arg_k(state, 3, state.arch.bits() // 8, view)

    if symbolic(dst) and state.solver.symbolic(dst):
        raise ModelError("strncpy", "symbolic dst not supported")
    if symbolic(src) and state.solver.symbolic(src):
        raise ModelError("strncpy", "symbolic src not supported")
    if symbolic(n) and state.solver.symbolic(n):
        raise ModelError("strncpy", "symbolic n not supported")

    if symbolic(dst):
        dst = state.solver.evaluate(dst)
    if symbolic(src):
        src = state.solver.evaluate(src)
    if symbolic(n):
        n = state.solver.evaluate(n)

    n = n.value

    i = 0
    src_b = state.mem.load(src, 1)
    while i < n:
        if not symbolic(src_b) or not state.solver.symbolic(src_b):
            src_b = state.solver.evaluate(src_b) if symbolic(src_b) else src_b
            if src_b.value == 0:
                break
        state.mem.store(dst + i, src_b)
        i += 1
        src_b = state.mem.load(src + i, 1)

    while i < n:
        state.mem.store(dst + i, BVV(0, 8))
        i += 1

    return dst

```

`models/teensy.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS
from ..utility.models_util import get_arg_k


def println_handler(state: State, view):
    to_print = get_arg_k(state, 0, state.arch.bits() // 8, view)
    state.events.append(
        "println called with parameter: {to_print}".format(
            to_print=to_print
        )
    )
    return BVV(0, 32)

```

`models/unistd.py`:

```py
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS
from ..utility.models_util import get_arg_k
from ..sym_state import State
from ..utility.exceptions import ModelError

MAX_SYM_READ_WRITE = 100


def read_handler(state: State, view):
    fd = get_arg_k(state, 1, 4, view)
    buf = get_arg_k(state, 2, state.arch.bits() // 8, view)
    count = get_arg_k(state, 3, 4, view)

    if symbolic(fd) and state.solver.symbolic(fd):
        raise ModelError("read", "symbolic fd not supported")

    fd = fd.value
    if not state.os.is_open(fd):
        return BVV(-9, 32) # EBADF

    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_SYM_READ_WRITE if count > MAX_SYM_READ_WRITE else count
    else:
        count = count.value

    res = state.os.read(fd, count)
    for i, b in enumerate(res):
        state.mem.store(buf + i, b)

    state.events.append(
        "read from fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


def write_handler(state: State, view):
    fd = get_arg_k(state, 1, 4, view)
    buf = get_arg_k(state, 2, state.arch.bits() // 8, view)
    count = get_arg_k(state, 3, 4, view)

    if symbolic(fd) and state.solver.symbolic(fd):
        raise ModelError("write", "symbolic fd not supported")

    fd = fd.value
    if not state.os.is_open(fd):
        return BVV(-9, 32) # EBADF

    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_SYM_READ_WRITE if count > MAX_SYM_READ_WRITE else count
    else:
        count = count.value

    data = []
    for i in range(count):
        b = state.mem.load(buf + i, 1)
        data.append(b)
    state.os.write(fd, data)

    state.events.append(
        "write to fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


stat_idx = 0


def _stat(state: State, statbuf):
    global stat_idx

    long_t = state.arch.bits()
    int_t = 32

    st_dev = BVS('stat_st_dev_%d' % stat_idx,     long_t)
    st_ino = BVS('stat_st_ino_%d' % stat_idx,     long_t)
    st_mode = BVS('stat_st_mode_%d' % stat_idx,    long_t)
    st_nlink = BVS('stat_st_nlink_%d' % stat_idx,   long_t)
    st_uid = BVS('stat_st_uid_%d' % stat_idx,     int_t)
    st_gid = BVS('stat_st_gid_%d' % stat_idx,     int_t)
    st_rdev = BVS('stat_st_rdev_%d' % stat_idx,    long_t)
    st_size = BVS('stat_st_size_%d' % stat_idx,    long_t)
    st_blksize = BVS('stat_st_blksize_%d' % stat_idx, long_t)
    st_blocks = BVS('stat_st_blocks_%d' % stat_idx,  long_t)
    st_atim_tv_sec = BVS('stat_atim.sec_%d' % stat_idx,   long_t)
    st_atim_tv_nsec = BVS('stat_atim.nsec_%d' % stat_idx,  long_t)
    st_mtim_tv_sec = BVS('stat_mtim.sec_%d' % stat_idx,   long_t)
    st_mtim_tv_nsec = BVS('stat_mtim.nsec_%d' % stat_idx,  long_t)
    st_ctim_tv_sec = BVS('stat_ctim.sec_%d' % stat_idx,   long_t)
    st_ctim_tv_nsec = BVS('stat_ctim.nsec_%d' % stat_idx,  long_t)

    stat_idx += 1

    state.mem.store(statbuf + 0, st_dev,          state.arch.endness())
    state.mem.store(statbuf + 8, st_ino,          state.arch.endness())
    state.mem.store(statbuf + 16, st_nlink,        state.arch.endness())
    state.mem.store(statbuf + 24, st_mode,         state.arch.endness())
    state.mem.store(statbuf + 32, st_uid,          state.arch.endness())
    state.mem.store(statbuf + 36, st_gid,          state.arch.endness())
    state.mem.store(statbuf + 40, BVV(0, 8*8))  # padding
    state.mem.store(statbuf + 48, st_rdev,         state.arch.endness())
    state.mem.store(statbuf + 56, st_size,         state.arch.endness())
    state.mem.store(statbuf + 64, st_blksize,      state.arch.endness())
    state.mem.store(statbuf + 72, st_blocks,       state.arch.endness())
    state.mem.store(statbuf + 80, st_atim_tv_sec,  state.arch.endness())
    state.mem.store(statbuf + 88, st_atim_tv_nsec, state.arch.endness())
    state.mem.store(statbuf + 96, st_mtim_tv_sec,  state.arch.endness())
    state.mem.store(statbuf + 104, st_mtim_tv_nsec, state.arch.endness())
    state.mem.store(statbuf + 112, st_ctim_tv_sec,  state.arch.endness())
    state.mem.store(statbuf + 120, st_ctim_tv_nsec, state.arch.endness())
    state.mem.store(statbuf + 128, BVV(0, 8*16))  # reserved (zero (?))

    return BVV(0, 32)


def stat_handler(state: State, view):
    global stat_idx

    pathname = get_arg_k(state, 1, state.arch.bits() // 8, view)
    statbuf = get_arg_k(state, 2, state.arch.bits() // 8, view)

    path = ""
    if not symbolic(pathname):
        i = 0
        c = state.mem.load(pathname, 1)
        while not symbolic(c) and c.value != 0 and i < 100:
            path += chr(c.value)
            i += 1
            c = state.mem.load(pathname+i, 1)
    else:
        path = "<symbolic>"

    state.events.append(
        "stat on %s" % path
    )

    return _stat(state, statbuf)


def xstat_handler(state: State, view):
    version = get_arg_k(state, 1, 4, view)
    pathname = get_arg_k(state, 2, state.arch.bits() // 8, view)
    statbuf = get_arg_k(state, 3, state.arch.bits() // 8, view)

    path = ""
    if not symbolic(pathname):
        i = 0
        c = state.mem.load(pathname, 1)
        while not symbolic(c) and c.value != 0 and i < 100:
            path += chr(c.value)
            i += 1
            c = state.mem.load(pathname+i, 1)
    else:
        path = "<symbolic>"

    if not symbolic(version):
        version = str(version.value)
    else:
        version = "<symbolic>"

    state.events.append(
        "__xstat on %s. version %s" % (path, version)
    )

    return _stat(state, statbuf)

```

`multipath/fringe.py`:

```py
import random


class Fringe(object):
    def __init__(self):
        self.unsat = list()
        self.errored = list()
        self.avoided = list()
        self.exited = list()
        self._deferred = dict()
        self.last_added = None

    def __str__(self):
        return "<Fringe id: 0x%x, unsat: %d, errored: %d, avoided: %d, deferred: %d, exited: %d>" % (
            id(self), len(self.unsat), len(self.errored), len(
                self.avoided), len(self.deferred), len(self.exited)
        )

    def __repr__(self):
        return self.__str__()

    @property
    def deferred(self):
        res = list()
        for addr in self._deferred:
            res.extend(self._deferred[addr])
        return res

    @property
    def get_unsat_states(self):
        return self.unsat

    @property
    def get_error_states(self):
        return self.errored

    @property
    def get_avoided_states(self):
        return self.avoided

    @property
    def get_exited_states(self):
        return self.exited

    @property
    def num_states(self):
        return len(self.unsat) + len(self.errored) + \
            len(self.avoided) + len(self.deferred) + \
            len(self.exited)

    def is_empty(self):
        return len(self._deferred) == 0

    def get_list_deferred_by_address(self, address):
        if address in self._deferred:
            return self._deferred[address]
        return list()

    def get_deferred_by_address(self, address, idx=None):
        if address in self._deferred:
            if idx is None:
                res = self._deferred[address].pop()
            else:
                if idx >= len(self._deferred[address]):
                    return None
                res = self._deferred[address][idx]
                del self._deferred[address][idx]

            if len(self._deferred[address]) == 0:
                del self._deferred[address]
            return res
        return None

    def get_all_deferred_by_address(self, address):
        if address in self._deferred:
            res = self._deferred[address]
            del self._deferred[address]
            return res
        return None

    def get_one_deferred(self):
        assert not self.is_empty()
        addr, states = self._deferred.popitem()
        state = states.pop()
        if states:
            self._deferred[addr] = states
        return state

    def get_random_deferred(self):
        assert not self.is_empty()
        addresses = list(self._deferred.keys())
        random.shuffle(addresses)
        random_address = addresses[0]
        states = self._deferred[random_address]
        random.shuffle(states)
        random_state = states.pop()
        if not states:
            del self._deferred[random_address]

        return random_state

    def add_deferred(self, state):
        self.last_added = state
        if state.get_ip() not in self._deferred:
            self._deferred[state.get_ip()] = [state]
        else:
            self._deferred[state.get_ip()].append(state)

    def add_errored(self, state):
        self.errored.append(state)

    def add_unsat(self, state):
        self.unsat.append(state)

    def add_avoided(self, state):
        self.avoided.append(state)

    def add_exited(self, state):
        self.exited.append(state)

```

`multipath/searcher.py`:

```py
import traceback

from ..globals import logger

class Searcher(object):
    def __init__(self, executor):
        self.target = None
        self.avoid = []
        self.executor = executor

    def __str__(self):
        return "<%s target: %s, %d avoid>" % \
            (
                self.__class__.__name__,
                hex(self.target) if self.target is not None else "None",
                len(self.avoid)
            )

    def __repr__(self):
        return self.__str__()

    def set_target(self, target: int):
        self.target = target

    def add_avoid(self, avoid: int):
        self.avoid.append(avoid)

    def ready_to_run(self):
        return self.target is not None

    def run(self, step_callback=None):
        raise NotImplementedError

class DFSSearcher(Searcher):
    def __init__(self, executor):
        Searcher.__init__(self, executor)

    # override
    def run(self, step_callback=None, findall=False):
        res = []
        while 1:
            if not self.executor.state:
                break
            ip = self.executor.state.get_ip()
            if ip in self.avoid:
                if self.executor.fringe.is_empty():
                    break
                old_state = self.executor.state
                self.executor.fringe.add_avoided(old_state)
                self.executor.state = None
                new_state = self.executor.fringe.get_one_deferred()
                self.executor.set_current_state(new_state)
            ip = self.executor.state.get_ip()
            if ip == self.target:
                res.append(self.executor.state)
                if not findall or self.executor.fringe.is_empty():
                    break
                self.executor.state = None
                new_state = self.executor.fringe.get_one_deferred()
                self.executor.set_current_state(new_state)

            try:
                self.executor.execute_one()
            except Exception as e:
                logger.log_error("!ERROR!:")
                logger.log_error(traceback.format_exc())
                break

            if step_callback is not None:
                if not step_callback(self.executor.state):
                    break

        if not findall:
            return res[0] if len(res) > 0 else None

        state_res = res[0]
        self.executor.set_current_state(state_res)
        for state in res[1:]:
            self.executor.fringe.add_deferred(state)
        return state_res

class BFSSearcher(Searcher):
    def __init__(self, executor):
        Searcher.__init__(self, executor)

    def _continue_until_branch(self, step_callback):
        k = self.executor.fringe.last_added
        i = k
        while i == k:
            if not self.executor.state:
                return None
            ip = self.executor.state.get_ip()
            if ip in self.avoid:
                if self.executor.fringe.is_empty():
                    return None
                old_state = self.executor.state
                self.executor.fringe.add_avoided(old_state)
                self.executor.state = None
                new_state = self.executor.fringe.get_one_deferred()
                self.executor.set_current_state(new_state)
            ip = self.executor.state.get_ip()
            if ip == self.target:
                return True

            try:
                self.executor.execute_one()
            except Exception as e:
                logger.log_error("!ERROR!:")
                logger.log_error(traceback.format_exc())
                return None

            if step_callback is not None:
                if not step_callback(self.executor.state):
                    return None

            i = self.executor.fringe.last_added

        return False

    # override
    def run(self, step_callback=None):
        while 1:
            res = self._continue_until_branch(step_callback)
            if res is None:
                return None
            if res:
                return self.executor.state

            new_state = self.executor.fringe.get_random_deferred()
            self.executor.set_current_state(new_state)

```

`os_models/linux.py`:

```py
from ..models import linux_syscalls as models
from ..expr import Bool
from .os_file import OsFileHandler
from ..target.syscall import RegSyscallAbi


class Linux(OsFileHandler):
    SYSCALL_TABLE = {}

    def __init__(self):
        super().__init__()
        self.stdin_fd = self.open("__stdin",  "r--")
        self.stdout_fd = self.open("__stdout", "-w-")

    def get_syscall_by_number(self, n: int):
        if n not in self.SYSCALL_TABLE:
            return None
        return self.SYSCALL_TABLE[n]

    def get_stdin_stream(self):
        session = self.descriptors_map[self.stdin_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def get_stdout_stream(self):
        session = self.descriptors_map[self.stdout_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def copy_to(self, other):
        super().copy_to(other)
        other.stdin_fd = self.stdin_fd
        other.stdout_fd = self.stdout_fd


class Linuxi386(Linux):
    SYSCALL_TABLE = {
        0: None,
        3: models.read_handler,
        4: models.write_handler
    }

    def get_syscall_abi(self, view, arch):
        return RegSyscallAbi(
            "eax",
            ["ebx", "ecx", "edx", "esi", "edi", "ebp"],
            "eax",
        )

    def copy(self):
        res = Linuxi386()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Linuxi386)
        pass  # TODO implement this


class Linuxia64(Linux):
    SYSCALL_TABLE = {
        0: models.read_handler,
        1: models.write_handler,
        2: None
    }

    def get_syscall_abi(self, view, arch):
        return RegSyscallAbi(
            "rax",
            ["rdi", "rsi", "rdx", "r10", "r8", "r9"],
            "rax",
        )

    def copy(self):
        res = Linuxia64()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Linuxia64)
        pass  # TODO implement this


class LinuxArmV7(Linux):

    SYSCALL_TABLE = {
        0x900003: models.read_handler,
        0x900004: models.write_handler
    }

    def get_syscall_abi(self, view, arch):
        return RegSyscallAbi(
            "r7",
            ["r0", "r1", "r2", "r3", "r4", "r5", "r6"],
            "r0",
        )

    def copy(self):
        res = LinuxArmV7()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, LinuxArmV7)
        pass  # TODO implement this


class LinuxAArch64(Linux):

    SYSCALL_TABLE = {
        63: models.read_handler,   # sys_read
        64: models.write_handler,  # sys_write
    }

    def get_syscall_abi(self, view, arch):
        return RegSyscallAbi(
            "x8",
            ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"],
            "x0",
        )

    def copy(self):
        res = LinuxAArch64()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, LinuxAArch64)
        pass  # TODO implement this


class LinuxRiscV(Linux):

    SYSCALL_TABLE = {
        63: models.read_handler,   # sys_read
        64: models.write_handler,  # sys_write
    }

    def get_syscall_abi(self, view, arch):
        return RegSyscallAbi(
            "a7",
            ["a0", "a1", "a2", "a3", "a4", "a5"],
            "a0",
        )

    def copy(self):
        res = LinuxRiscV()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, LinuxRiscV)
        pass  # TODO implement this

```

`os_models/macos.py`:

```py
from ..expr import Bool
from .os_file import OsFileHandler


class MacOS(OsFileHandler):
    def __init__(self):
        super().__init__()
        self.stdin_fd = self.open("__stdin", "r--")
        self.stdout_fd = self.open("__stdout", "-w-")

    def get_syscall_by_number(self, n):
        raise NotImplementedError

    def get_stdin_stream(self):
        session = self.descriptors_map[self.stdin_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def get_stdout_stream(self):
        session = self.descriptors_map[self.stdout_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def copy(self):
        res = MacOS()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, MacOS)
        pass  # TODO implement this

```

`os_models/null.py`:

```py
from ..expr import Bool
from .os_file import OsFileHandler


class NullOS(OsFileHandler):
    def __init__(self):
        super().__init__()
        self.stdin_fd = self.open("__stdin", "r--")
        self.stdout_fd = self.open("__stdout", "-w-")

    def get_syscall_by_number(self, n):
        return None

    def get_stdin_stream(self):
        session = self.descriptors_map[self.stdin_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)
        return res

    def get_stdout_stream(self):
        session = self.descriptors_map[self.stdout_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)
        return res

    def copy(self):
        res = NullOS()
        super().copy_to(res)
        res.stdin_fd = self.stdin_fd
        res.stdout_fd = self.stdout_fd
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, NullOS)
        pass  # TODO implement this

```

`os_models/os_abstract.py`:

```py
class Os(object):
    # syscall
    def get_syscall_by_number(self, n):
        raise NotImplementedError

    def get_syscall_abi(self, view, arch):
        return None
    # devices

    def open(self, filename, mode):
        raise NotImplementedError

    def read(self, fd, size):
        raise NotImplementedError

    def write(self, fd, data):
        raise NotImplementedError

    def is_open(self, fd: int):
        raise NotImplementedError

    def close(self, fd: int):
        raise NotImplementedError

    def get_stdin_stream(self):
        raise NotImplementedError

    def get_stdout_stream(self):
        raise NotImplementedError
    # other

    def copy(self):
        raise NotImplementedError

    def merge(self, other, merge_condition):
        raise NotImplementedError

```

`os_models/os_file.py`:

```py
from ..memory.sym_file import SymFile
from .os_abstract import Os


class FileSession(object):
    def __init__(self, fd, symfile, mode):
        self.fd = fd
        self.symfile = symfile
        self.mode = mode  # for now, ignored
        self.seek_idx = 0

    def __str__(self):
        return "<FileSession {filename} @ {seek} - {fd}>".format(
            filename=self.symfile.filename,
            fd=self.fd,
            seek=self.seek_idx
        )

    def __repr__(self):
        return self.__str__()

    def seek(self, idx):
        self.seek_idx = idx

    def read(self, size: int) -> list:
        self.symfile.seek(self.seek_idx)
        self.seek_idx += size
        return self.symfile.read(size)

    def write(self, data: list):
        self.symfile.seek(self.seek_idx)
        self.symfile.write(data)
        self.seek_idx += len(data)

    def copy(self, new_symfile):
        res = FileSession(self.fd, new_symfile, self.mode)
        res.seek(self.seek_idx)
        return res


class OsFileHandler(Os):
    # os that handles files
    def __init__(self):
        self.next_descriptor = 0
        self.descriptors_map = {}  # descriptor to file session
        self.filesystem = {}       # filename to symfile object

    def open(self, filename, mode):
        if filename in self.filesystem:
            symfile = self.filesystem[filename]
        else:
            symfile = SymFile(filename)
            self.filesystem[filename] = symfile

        fd = self.next_descriptor
        file_session = FileSession(fd, symfile, mode)
        self.descriptors_map[fd] = file_session

        self.next_descriptor += 1
        return fd

    def is_open(self, fd):
        return fd in self.descriptors_map

    def seek(self, fd: int, idx: int):
        assert fd in self.descriptors_map

        session = self.descriptors_map[fd]
        session.seek(idx)

    def read(self, fd: int, size: int):
        assert fd in self.descriptors_map

        session = self.descriptors_map[fd]
        return session.read(size)

    def write(self, fd: int, data: list):
        assert fd in self.descriptors_map

        session = self.descriptors_map[fd]
        return session.write(data)

    def close(self, fd: int):
        assert fd in self.descriptors_map
        del self.descriptors_map[fd]

    def copy_to(self, other):
        for filename in self.filesystem:
            other.filesystem[filename] = self.filesystem[filename].copy()
        for fd in self.descriptors_map:
            other.descriptors_map[fd] = self.descriptors_map[fd].copy(
                other.filesystem[self.descriptors_map[fd].symfile.filename]
            )

```

`os_models/windows.py`:

```py
from ..expr import Bool
from .os_file import OsFileHandler


class Windows(OsFileHandler):
    def __init__(self):
        super().__init__()
        self.stdin_fd = self.open("__stdin", "r--")
        self.stdout_fd = self.open("__stdout", "-w-")

    def get_syscall_by_number(self, n):
        raise NotImplementedError

    def get_stdin_stream(self):
        session = self.descriptors_map[self.stdin_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def get_stdout_stream(self):
        session = self.descriptors_map[self.stdout_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def copy(self):
        res = Windows()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Windows)
        pass  # TODO implement this

```

`plugin.json`:

```json
{
   "pluginmetadataversion": 2,
   "name": "SENinja",
   "author": "Luca Borzacchiello",
   "type": [
      "helper", "ui"
   ],
   "api": [
      "python3"
   ],
   "description": "Symbolic execution plugin for BinaryNinja",
   "longdescription": "# SENinja - Symbolic Execution Plugin for Binary Ninja\n\n![](https://github.com/borzacchiello/seninja/raw/master/media/pictures/screenshot.png)\nThis is a binary ninja plugin that implements a symbolic execution engine based only on z3, highly inspired by the _angr framework_ (https://angr.io/). \nThe plugin is implemented as an emulator of LLIL instructions that builds and manipulates z3 formulas.\n\nSENinja simulates a debugger: the execution is _path driven_, only one state is _active_ and executes instructions. The other states, generated at branches, are saved in a _deferred queue_. At any time, the active state can be changed with a deferred one.\n\n### UI Widgets\n\nSENinja comes with a side-panel widget that can be used to start and control the execution using the following buttons:\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/start.svg\" alt=\"\" width=\"10\"/>: start the execution\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/stepinto.svg\" alt=\"\" width=\"10\"/>: step the current state\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/run_branch.svg\" alt=\"\" width=\"10\"/>: run until branch\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/run_addr.svg\" alt=\"\" width=\"10\"/>: execute the current state until the currently selected address\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/run_dfs.svg\" alt=\"\" width=\"10\"/>: start a DFS search\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/run_bfs.svg\" alt=\"\" width=\"10\"/>: start a BFS search\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/set_target.svg\" alt=\"\" width=\"10\"/>: set the currently selected address as the target of the search\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/set_avoid.svg\" alt=\"\" width=\"10\"/>: avoid the currently selected address during a search\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/reset_searchers.svg\" alt=\"\" width=\"10\"/>: reset targets and avoid addresses\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/stop.svg\" alt=\"\" width=\"10\"/>: stop a search\n- <img src=\"https://github.com/borzacchiello/seninja/raw/master/media/icons/cancel.svg\" alt=\"\" width=\"10\"/>: reset SENinja\n",
   "license": {
      "name": "2-Clause BSD",
      "text": "Copyright 2019-2024 Luca Borzacchiello\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
   },
   "platforms": [
      "Darwin",
      "Windows",
      "Linux"
   ],
   "installinstructions": {
      "Darwin": "Install `z3-solver` using pip: `pip install z3-solver`",
      "Windows": "Install `z3-solver` using pip: `pip install z3-solver`",
      "Linux": "Install `z3-solver` using pip: `pip install z3-solver`"
   },
   "dependencies": {
		"apt": [],
		"installers": [],
		"other": []
	},
   "version": "0.5.0",
   "minimumbinaryninjaversion": 4000
}

```

`requirements.txt`:

```txt
z3-solver

```

`settings.py`:

```py
from binaryninja import Settings

Settings().register_group("seninja", "SENinja")
Settings().register_setting("seninja.memory.symb_address_mode", """
    {
        "title" : "Symbolic access mode",
        "type" : "string",
        "default" : "limit_pages",
        "description" : "Select the policy to use when a memory access from symbolic address occurs.",
        "enum": ["concretization", "limit_pages", "fully_symbolic"]
    }
    """)
Settings().register_setting("seninja.memory.limit_pages_limit", """
    {
        "title" : "Limit pages, page limit",
        "type" : "number",
        "default" : 3,
        "description" : "If the symbolic access policy is set to 'limit_pages', the maximum width of a symbolic access (in pages)."
    }
    """)
Settings().register_setting("seninja.memory.concretize_unconstrained", """
    {
        "title" : "Concretize unconstrained memory accesses",
        "type" : "boolean",
        "default" : true,
        "description" : "When a memory access on a unconstrained symbolic address occurs, allocate a new page and concretize the address to it."
    }
    """)
Settings().register_setting("seninja.memory.use_heuristic_find_base", """
    {
        "title" : "Use find-base heuristic on symbolic memory accesses",
        "type" : "boolean",
        "default" : true,
        "description" : "When a memory access on a symbolic address occurs, if the current policy impose concretization, use find-base heuristic to drive the concretization."
    }
    """)
Settings().register_setting("seninja.memory.check_unmapped", """
    {
        "title" : "Check unmapped symbolic memory accesses",
        "type" : "boolean",
        "default" : false,
        "description" : "Check if symbolic memory accesses can access unmapped memory pages. Performance may decrease."
    }
    """)
Settings().register_setting("seninja.memory.page_size", """
    {
        "title" : "Size of a memory page",
        "type" : "string",
        "default" : "2048",
        "description" : "Size (in bytes) of a memory page. It must be a power of 2."
    }
    """)

Settings().register_setting("seninja.stack_size", """
    {
        "title" : "Stack size (in pages)",
        "type" : "number",
        "default" : 4,
        "description" : "Number of pages allocated for the stack."
    }
    """)
Settings().register_setting("seninja.use_bn_jumptable_targets", """
    {
        "title" : "Use jump table targets computed by Binary Ninja",
        "type" : "boolean",
        "default" : true,
        "description" : "If true, the symbolic executor will use targets of jump tables computed by Binary Ninja."
    }
    """)
Settings().register_setting("seninja.save_unsat", """
    {
        "title" : "Save unsat states",
        "type" : "boolean",
        "default" : false,
        "description" : "Save unsatisfiable states. If True, performance will decrease drastically."
    }
    """)
Settings().register_setting("seninja.single_llil_step", """
    {
        "title" : "Single LLIL step",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, a single step executes only one LLIL instruction, instead of an assembly instruction."
    }
    """)
Settings().register_setting("seninja.check_division_by_zero", """
    {
        "title" : "Check division by zero",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, division by zero are checked. Performance may decrease."
    }
    """)
Settings().register_setting("seninja.dont_use_special_handlers", """
    {
        "title" : "Do not use special handlers",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, architecture-specific handlers will not be used."
    }
    """)
Settings().register_setting("seninja.save_state_history", """
    {
        "title" : "Save instructions executed by the state",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, each state will save the instruction that it executed."
    }
    """)
Settings().register_setting("seninja.exploration_timeout", """
    {
        "title" : "Timeout (seconds) during automatic exploration (0 for no timeout)",
        "type" : "number",
        "default" : 0,
        "description" : "If greater than 0, automatic explorations will terminate after X seconds"
    }
    """)

Settings().register_setting("seninja.models.use_atox_slow_model", """
    {
        "title" : "Use atoX slow model",
        "type" : "boolean",
        "default" : true,
        "description" : "If true, atoX functions are modelled in a sound and complete (but slow) way."
    }
    """)
Settings().register_setting("seninja.models.max_malloc_size", """
    {
        "title" : "Maximum malloc size when concretized",
        "type" : "string",
        "default" : "4096",
        "description" : "Maximum value to which a symbolic malloc size can be concretized."
    }
    """)
Settings().register_setting("seninja.models.max_memcmp_size", """
    {
        "title" : "Maximum memcmp size when concretized",
        "type" : "string",
        "default" : "4096",
        "description" : "Maximum value to which a symbolic memcmp size can be concretized."
    }
    """)
Settings().register_setting("seninja.models.max_memcpy_size", """
    {
        "title" : "Maximum memcpy size when concretized",
        "type" : "string",
        "default" : "4096",
        "description" : "Maximum value to which a symbolic memcpy size can be concretized."
    }
    """)
Settings().register_setting("seninja.models.max_size_symb_string", """
    {
        "title" : "Maximum length of symbolic string",
        "type" : "number",
        "default" : 30,
        "description" : "Maximum length of a string with symbolic characters."
    }
    """)

Settings().register_setting("seninja.init_reg_mem_with_zero", """
    {
        "title" : "Set uninitialized registers and memory to zero",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, memory and registers are initialized with zero. Otherwise, with symbols."
    }
""")

```

`sym_executor.py`:

```py
import sys

from binaryninja import (
    BinaryReader, BinaryWriter,
    RegisterValueType
)
from .sym_visitor import SymbolicVisitor
from .sym_state import State
from .utility.bninja_util import get_imported_functions_and_addresses
from .utility.expr_wrap_util import symbolic
from .target.context import resolve_target
from .utility import exceptions
from .expr import BVV, BVS
from .utility.binary_ninja_cache import BNCache
from .memory.sym_memory import InitData
from .multipath.fringe import Fringe
from .globals import logger

class SymbolicExecutor(object):
    def __init__(self, view, addr):

        self.view = view
        self.bw = BinaryWriter(view)
        self.br = BinaryReader(view)
        self.visitor = SymbolicVisitor(self)
        self.bncache = BNCache(view)
        self.vars = set()
        self.fringe = Fringe()
        self.ip = addr
        self.llil_ip = None
        self.arch = None
        self.user_hooks = dict()
        self.user_loggers = dict()
        self.imported_functions, self.imported_addresses = \
            get_imported_functions_and_addresses(view)
        self._last_colored_ip = None
        self._last_error = None
        self.init_with_zero = self.bncache.get_setting(
            "init_reg_mem_with_zero") == "true"

        self._wasjmp = False

        self.target = resolve_target(self.view)
        self.arch = self.target.arch
        logger.log_info(
            "target resolved: arch=%s os=%s abi=%s syscall=%s layout=%s/%s"
            % (
                type(self.target.arch).__name__,
                type(self.target.os).__name__,
                type(self.target.abi).__name__,
                type(self.target.syscall_abi).__name__,
                self.target.layout.ptr_bits,
                self.target.layout.endian,
            )
        )
        page_size = int(self.bncache.get_setting("memory.page_size"))
        self.state = State(self, target=self.target, page_size=page_size)

        # load memory
        logger.log_info("loading segments...")
        for segment in self.view.segments:
            start = segment.start
            end = segment.end
            size = segment.data_length
            logger.log_info("%s %s -> %s" % (segment, hex(start), hex(size)))

            if size == 0 and end - start != 0:
                size = end - start
                data = b"\x00" * size
            elif size == 0:
                continue
            else:
                self.br.seek(start)
                data = self.br.read(end-start)

            self.state.mem.mmap(
                self.state.address_page_aligned(start),
                self.state.address_page_aligned(end + self.state.mem.page_size - 1) -
                self.state.address_page_aligned(start),
                InitData(data, start - self.state.address_page_aligned(start))
            )
        logger.log_info("loading finished!")

        current_function = self.bncache.get_function(addr)

        # initialize stack
        stack_page_size = int(self.bncache.get_setting("stack_size"))

        unmapped_page_init = self.state.mem.get_unmapped(
            stack_page_size,
            start_from=(0x80 << (self.arch.bits() - 8)))
        self.state.mem.mmap(
            unmapped_page_init*self.state.page_size,
            self.state.page_size * stack_page_size)
        # leave one page for upper stack portion
        p = unmapped_page_init + stack_page_size - 1
        stack_base = p * self.state.page_size - self.arch.bits() // 8

        self.state.initialize_stack(stack_base)

        # initialize registers
        for reg in self.arch.regs_data():
            reg_dict = self.arch.regs_data()[reg]
            
            # skip synthetic registers (that can't be queried)
            if self.arch.is_synthetic_reg(reg):
                if self.arch.is_zero_reg(reg):
                    # zero registers must always be zero
                    setattr(self.state.regs, reg, BVV(0, reg_dict['size'] * 8))
                elif not self.init_with_zero:
                    symb = BVS(reg + "_init", reg_dict['size'] * 8)
                    self.vars.add(symb)
                    setattr(self.state.regs, reg, symb)
                else:
                    setattr(self.state.regs, reg, BVV(0, reg_dict['size'] * 8))
                continue
            
            val = current_function.get_reg_value_after(addr, reg)

            if val.type.value == RegisterValueType.StackFrameOffset:
                setattr(self.state.regs, reg, BVV(
                    stack_base + val.offset, reg_dict['size'] * 8))
            elif (
                val.type.value == RegisterValueType.ConstantPointerValue or
                val.type.value == RegisterValueType.ConstantValue
            ):
                setattr(self.state.regs, reg, BVV(
                    val.value, reg_dict['size'] * 8))
            else:
                if not self.init_with_zero:
                    symb = BVS(reg + "_init", reg_dict['size'] * 8)
                    self.vars.add(symb)
                    setattr(self.state.regs, reg, symb)
                else:
                    setattr(self.state.regs, reg, BVV(0, reg_dict['size'] * 8))

        # initialize known local variables
        stack_vars = current_function.stack_layout
        for var in stack_vars:
            offset = var.storage
            s_type = var.type

            if s_type.confidence != 255:
                continue

            if abs(offset) > self.state.page_size * (stack_page_size - 1):
                logger.log_error("ERROR: not enough space in stack. Unable to add known variable to stack.")
                continue

            width = s_type.width
            name = var.name
            val = current_function.get_stack_contents_at(addr, offset, width)
            if val.type.value == RegisterValueType.StackFrameOffset:
                assert width*8 == self.arch.bits(), f"stack var width mismatch: {width*8} != {self.arch.bits()}"
                self.state.mem.store(
                    BVV(stack_base + offset, self.arch.bits()),
                    BVV(stack_base + val.offset, width*8),
                    endness=self.arch.endness())
            elif (
                val.type.value == RegisterValueType.ConstantPointerValue or
                val.type.value == RegisterValueType.ConstantValue
            ):
                self.state.mem.store(
                    BVV(stack_base + offset, self.arch.bits()),
                    BVV(val.value, width*8),
                    endness=self.arch.endness())
            elif not self.init_with_zero:
                symb = BVS(name + "_init", self.arch.bits())
                self.vars.add(symb)
                self.state.mem.store(
                    BVV(stack_base + offset, self.arch.bits()),
                    symb,
                    endness=self.arch.endness())

        # set eip
        self.state.set_ip(addr)
        self.llil_ip = current_function.llil.get_instruction_start(addr)

    def __str__(self):
        return "<SymExecutor id: 0x%x, %d states>" % \
            (id(self), self.fringe.num_states + 1 if self.state is not None else 0)

    def __repr__(self):
        return self.__str__()

    def put_in_deferred(self, state):
        self.fringe.add_deferred(state)

    def put_in_exited(self, state):
        self.fringe.add_exited(state)

    def put_in_unsat(self, state):
        save_unsat = self.bncache.get_setting("save_unsat") == 'true'
        if save_unsat:
            self.fringe.add_unsat(state)

    def put_in_errored(self, state, msg: str):
        self.fringe.add_errored(
            (msg, state)
        )

    def extract_mergeable_with_current_state(self, to_merge):
        # returns the set of states that do not deviate from
        # the current state after executing the current instruction

        func_name = self.bncache.get_function_name(self.ip)
        expr = self.bncache.get_llil(func_name, self.llil_ip)

        if expr.operation.name in {"LLIL_JUMP", "LLIL_JUMP_TO", "LLIL_CALL", "LLIL_TAILCALL"}:
            curr_state_dst = self.visitor.visit(expr.dest)
            if symbolic(curr_state_dst):
                # I do not want to call the solver... Just return them all
                return to_merge, list()

            curr_state = self.state

            mergeable = list()
            not_mergeable = list()
            for s in to_merge:
                self.state = s
                s_dst = self.visitor.visit(expr.dest)
                if symbolic(s_dst) or s_dst.value == curr_state_dst.value:
                    mergeable.append(s)
                else:
                    not_mergeable.append(s)

            self.state = curr_state
            return mergeable, not_mergeable

        return to_merge, list()

    def set_current_state(self, state):
        if self.state is not None:
            self.state.llil_ip = self.llil_ip
            self.put_in_deferred(self.state)
            self.state = None

        ip = state.get_ip()
        llil_ip = state.llil_ip

        self.state = state
        new_func = self.bncache.get_function(ip)
        self.ip = ip
        self.llil_ip = new_func.llil.get_instruction_start(
            ip) if llil_ip is None else llil_ip

    def select_from_deferred(self):
        if self.fringe.is_empty():
            return False

        state = self.fringe.get_one_deferred()
        self.set_current_state(state)
        return True

    def update_ip(self, funcion_name, new_llil_ip):
        self.llil_ip = new_llil_ip
        self.ip = self.bncache.get_address(funcion_name, new_llil_ip)
        self.state.set_ip(self.ip)
        self.state.llil_ip = new_llil_ip

    def _update_state_history(self, state, addr):
        if self.bncache.get_setting("save_state_history") == 'true':
            state.insn_history.add(addr)

    def _execute_one(self):
        self._last_error = None
        func_name = self.bncache.get_function_name(self.ip)

        # handle user hooks and loggers
        if self.ip in self.user_loggers:
            self.user_loggers[self.ip](self.state)
        if self.ip in self.user_hooks:
            old_ip = self.ip
            new_state, new_deferred, new_errored = self.user_hooks[self.ip](
                self.state)

            for s in new_deferred:
                self._update_state_history(s, old_ip)
                self.put_in_deferred(s)
            for s, msg in new_errored:
                self._update_state_history(s, old_ip)
                self.put_in_errored(s, msg)

            if new_state is not None:
                self.state = new_state

                if old_ip == self.state.get_ip():
                    new_ip = self.ip + \
                        self.bncache.get_instruction_len(self.ip)
                else:
                    new_ip = self.state.get_ip()

                dest_func_name = self.bncache.get_function_name(
                    new_ip
                )
                self.update_ip(
                    dest_func_name,
                    self.bncache.get_llil_address(dest_func_name, new_ip)
                )
                self._update_state_history(new_state, old_ip)
                return self.ip

        else:
            # check if a special handler is defined

            dont_use_special_handlers = \
                self.bncache.get_setting("dont_use_special_handlers") == 'true'
            disasm_str = self.bncache.get_disasm(self.ip)
            old_ip = self.ip

            try:
                if (
                    dont_use_special_handlers or
                    not self.arch.execute_special_handler(disasm_str, self)
                ):
                    expr = self.bncache.get_llil(func_name, self.llil_ip)
                    self.visitor.visit(expr)
                else:
                    self._wasjmp = True
                    self.ip = self.ip + \
                        self.view.get_instruction_length(self.ip)
                    self.state.set_ip(self.ip)
                    self.llil_ip = self.bncache.get_function(
                        self.ip).llil.get_instruction_start(self.ip)
            except exceptions.ExitException:
                self._update_state_history(self.state, old_ip)
                self.put_in_exited(self.state)
                self.state = None
            except exceptions.SENinjaError as err:
                logger.log_error("An error occurred: %s" % err.message)
                self.put_in_errored(self.state, str(err))
                self.state = None
                self._last_error = err
                if err.is_fatal():
                    raise err

            if self.state is not None:
                self._update_state_history(self.state, old_ip)

        if self.state is None:
            if self.fringe.is_empty():
                logger.log_warn("WARNING: no more states")
                return -1
            else:
                self.select_from_deferred()
                self._wasjmp = True

        if not self._wasjmp:
            # go on by 1 instruction
            self.update_ip(func_name, self.llil_ip + 1)
        else:
            self._wasjmp = False

        return self.ip

    def execute_one(self):
        if not self.state:
            return

        res = None
        try:
            single_llil_step = self.bncache.get_setting(
                "single_llil_step") == 'true'
            if single_llil_step:
                res = self._execute_one()
            else:
                old_ip = self.ip
                res = old_ip
                while res == old_ip:
                    res = self._execute_one()
        except exceptions.SENinjaError:
            res = None
        except Exception as e:
            import os
            _, _, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.log_error("Unknown exception in SymbolicExecutor.execute_one():")
            logger.log_error(" ".join(map(str, ["\t", repr(e), fname, exc_tb.tb_lineno, "\n"])))
            self.put_in_errored(self.state, "Unknown error")
            self.state = None
            res = None

        if res is None:
            if not self.fringe.is_empty():
                self.select_from_deferred()
        return res

```

`sym_solver.py`:

```py
import z3

from copy import deepcopy
from collections import OrderedDict
from .utility.expr_wrap_util import symbolic
from .expr import BV, BVV, Bool, And, Or, BoolExpr

USE_OPT_SOLVER = False
DBG            = False

class Solver(object):
    def __init__(self, state):
        self.state = state
        self.assertions = []
        self._added_mem_constraints = set()
        self._solver = z3.Optimize() if USE_OPT_SOLVER else z3.Solver()
        self._min_cache = OrderedDict()
        self._max_cache = OrderedDict()
        self._eval_cache = OrderedDict()
        self._symb_check_cache = OrderedDict()

        if DBG:
            self.dbg_idx = 0

    def __str__(self):
        return "<SymSolver id: 0x%x, %d assertions>" % \
            (id(self), len(self.assertions))

    def __repr__(self):
        return self.__str__()

    def _invalidate_cache(self):
        self._min_cache = OrderedDict()
        self._max_cache = OrderedDict()
        self._eval_cache = OrderedDict()
        self._symb_check_cache = OrderedDict()

    def _rejuvenate(self):
        self._solver = z3.Optimize() if USE_OPT_SOLVER else z3.Solver()
        for a in self.assertions:
            self._solver.add(a.z3obj)

    @staticmethod
    def _get_all_symbols_from_z3_formula(formula):
        processed_formulas = set()
        res = set()

        queue = [formula]
        while queue:
            formula = queue.pop()
            if formula in processed_formulas:
                continue
            processed_formulas.add(formula)

            decl = formula.decl()
            if decl.kind() == z3.Z3_OP_UNINTERPRETED:
                res.add(decl.name())

            for c in formula.children():
                queue.append(c)

        return res

    def _add_memory_constraints(self, *constraints):
        # If we find a page symbol, then we will add the
        # eventual concrete values as assertion to the solver
        for formula in constraints:
            for s in Solver._get_all_symbols_from_z3_formula(formula.z3obj):
                if s.startswith("MEMOBJ_") and s.endswith("h"):
                    page_addr = s.split("_")[1][:-1]
                    page_addr = int(page_addr, 16)

                    if page_addr in self._added_mem_constraints:
                        continue
                    self._added_mem_constraints.add(page_addr)
                    assertions = self.state.mem.get_assertions_for_page(page_addr)
                    for a in assertions:
                        self.add_constraints(a, simplify_constraint=False, check_mem=False)

    def get_path_constraint(self):
        return self.assertions

    def add_constraints(self, *constraints, simplify_constraint=True, check_mem=True):
        if len(constraints) == 0:
            return

        self._invalidate_cache()
        for c in constraints:
            assert isinstance(c, Bool)
            if simplify_constraint:
                c = c.simplify()
            cz3 = c.z3obj
            if not z3.BoolVal(True).eq(cz3):
                if check_mem:
                    self._add_memory_constraints(c)
                self._solver.add(cz3)
                self.assertions.append(c)

    def _add_tmp_constraints(self, *constraints):
        for c in constraints:
            assert isinstance(c, Bool)
            c = c.simplify()
            cz3 = c.z3obj
            if not z3.BoolVal(True).eq(cz3):
                self._solver.add(cz3)

    def satisfiable(self, extra_constraints: list = None):
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._solver.push()
            self._add_tmp_constraints(*extra_constraints)

        if DBG:
            fout = open("/dev/shm/seninja_q_%d" % self.dbg_idx, "w")
            self.dbg_idx += 1
            fout.write(self._solver.sexpr())
            fout.close()

        res = self._solver.check().r == 1

        if extra_constraints:
            self._solver.pop()
        return res

    def evaluate(self, var, extra_constraints: list = None) -> int:
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._solver.push()
            self._add_tmp_constraints(*extra_constraints)
        elif var in self._eval_cache:
            return self._eval_cache[var]

        self._add_memory_constraints(var)
        if not self.satisfiable():
            if extra_constraints:
                self._solver.pop()
            assert False  # not satisfiable!
        model = self._solver.model()
        res = model.evaluate(var.z3obj, model_completion=True)
        res = BVV(res.as_long(), var.size)

        if extra_constraints:
            self._solver.pop()
        else:
            self._eval_cache[var] = res
        return res

    def evaluate_upto(self, var, n, extra_constraints: list = None) -> list:
        self._solver.push()
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._add_tmp_constraints(*extra_constraints)

        self._add_memory_constraints(var)
        if not self.satisfiable():
            if extra_constraints:
                self._solver.pop()
            assert False  # not satisfiable!

        res = list()
        while n > 0 and self.satisfiable():
            model = self._solver.model()
            r = model.evaluate(var.z3obj, model_completion=True)
            r = BVV(r.as_long(), var.size)
            res.append(r)
            self._add_tmp_constraints(var != r)
            n -= 1

        self._solver.pop()
        return res

    def symbolic(self, val: BV):
        if val in self._symb_check_cache:
            return self._symb_check_cache[val]

        res = len(self.evaluate_upto(val, 2)) != 1
        self._symb_check_cache[val] = res
        return res

    def _max_binary_search(self, val: BV):
        lb = 0
        ub = 2 ** val.size - 1
        while lb <= ub:
            m = (lb + ub) // 2
            if not self.satisfiable(extra_constraints=[val.UGE(m)]):
                ub = m - 1
            else:
                lb = m + 1
        self._max_cache[val] = ub
        return ub

    def _max_z3_optimize(self, val: BV):
        if USE_OPT_SOLVER:
            self._solver.push()
            h = self._solver.maximize(val.z3obj)
            assert self._solver.check().r == 1
            res = self._solver.upper(h).as_long()
            self._solver.pop()
        else:
            opt = z3.Optimize()
            for c in self.assertions:
                opt.add(c.z3obj)
            h = opt.maximize(val.z3obj)
            assert opt.check().r == 1
            res = opt.upper(h).as_long()
        return res

    def max(self, val: BV):
        if not symbolic(val):
            return val.value
        if val in self._max_cache:
            return self._max_cache[val]

        self._add_memory_constraints(val)
        # res = self._max_binary_search(val)
        res = self._max_z3_optimize(val)
        val.interval.high = res

        self._max_cache[val] = res
        return res

    def _min_binary_search(self, val: BV):
        lb = 0
        ub = 2 ** val.size - 1
        while lb <= ub:
            m = (lb + ub) // 2
            if not self.satisfiable(extra_constraints=[val.ULE(m)]):
                lb = m + 1
            else:
                ub = m - 1
        return lb

    def _min_z3_optimize(self, val: BV):
        if USE_OPT_SOLVER:
            self._solver.push()
            h = self._solver.minimize(val.z3obj)
            assert self._solver.check().r == 1
            res = self._solver.lower(h).as_long()
            self._solver.pop()
        else:
            opt = z3.Optimize()
            for c in self.assertions:
                opt.add(c.z3obj)
            h = opt.minimize(val.z3obj)
            assert opt.check().r == 1
            res = opt.lower(h).as_long()
        return res

    def min(self, val: BV):
        if not symbolic(val):
            return val.value
        if val in self._min_cache:
            return self._min_cache[val]

        self._add_memory_constraints(val)
        # res = self._min_binary_search(val)
        res = self._min_z3_optimize(val)
        val.interval.low = res

        self._min_cache[val] = res
        return res

    def model(self, extra_constraints: list = None):
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._solver.push()
            self._add_tmp_constraints(*extra_constraints)

        assert self.satisfiable()
        res = self._solver.model()
        if extra_constraints:
            self._solver.pop()
        return res

    def _copy_cache(self, new, max_num_elem=3):
        i = 0
        for key in reversed(self._min_cache.keys()):
            if i > max_num_elem:
                break
            new._min_cache[key] = self._min_cache[key]
            i += 1
        i = 0
        for key in reversed(self._max_cache.keys()):
            if i > max_num_elem:
                break
            new._max_cache[key] = self._max_cache[key]
            i += 1
        i = 0
        for key in reversed(self._eval_cache.keys()):
            if i > max_num_elem:
                break
            new._eval_cache[key] = self._eval_cache[key]
            i += 1
        i = 0
        for key in reversed(self._symb_check_cache.keys()):
            if i > max_num_elem:
                break
            new._symb_check_cache[key] = self._symb_check_cache[key]
            i += 1

    def copy(self, state, fast_copy=False):
        fast_copy = True  # deepcopy seems broken

        res = Solver(state)
        if not fast_copy:
            # print("copying the solver slow")
            res._solver = self._solver.__deepcopy__()
            # print("copying done")
        else:
            for a in self._solver.assertions():
                res._solver.add(a)

        res.assertions = self.assertions[:]
        self._copy_cache(res, 3)
        return res

    def compute_solvers_difference(self, other):  # can be quite slow
        assert isinstance(other, Solver)

        i = 0
        for c1, c2 in zip(self.assertions, other.assertions):
            if not c1.eq(c2):
                break
            i += 1

        const1 = None
        for c in self.assertions[i:]:  # additional constraints self
            const1 = c if const1 is None else And(const1, c)

        const2 = None
        for c in other.assertions[i:]:  # additional constraints other
            const2 = c if const2 is None else And(const2, c)

        # common, consts only self, consts only other
        return self.assertions[:i], const1, const2

    def merge(self, other):
        assert isinstance(other, Solver)
        common, only_self, only_other = self.compute_solvers_difference(other)

        self._invalidate_cache()

        new_z3_solver = z3.Solver()
        self.assertions = []
        for const in common:
            new_z3_solver.add(const.z3obj)  # common constraints
            self.assertions.append(const)

        if only_self is not None and only_other is not None:
            cond = Or(only_self, only_other)
            cond = cond.simplify()
            if not cond.z3obj.eq(z3.BoolVal(True)):
                new_z3_solver.add(cond.z3obj)
                self.assertions.append(cond)
        else:
            raise Exception("Can this happen?")

        self._solver = new_z3_solver

```

`sym_state.py`:

```py
from .memory.registers import Regs
from .memory.sym_memory import Memory
from .sym_solver import Solver
from .utility.expr_wrap_util import symbolic
from .expr import BV, BVV


class State(object):
    def __init__(self, executor, target, page_size: int = 0x1000):
        self.page_size = page_size
        self.target = target
        self.arch = target.arch
        self.os = target.os
        self.abi = target.abi
        self.syscall_abi = target.syscall_abi
        self.layout = target.layout
        self.mem = Memory(self, page_size, self.arch.bits(),
                          not executor.init_with_zero)
        self.regs = Regs(self)
        self.solver = Solver(self)
        self.events = list()
        self.insn_history = set()
        self.llil_ip = None
        self.executor = executor
        self.symbolic_buffers = list()
        self._ipreg = self.arch.getip_reg()
        self._bits = self.arch.bits()

    def __str__(self):
        return "<SymState 0x{id:x} @ 0x{addr:0{width}X}>".format(
            id=id(self),
            addr=self.get_ip(),
            width=(self._bits+3) // 4
        )

    def __repr__(self):
        return self.__str__()

    def get_ip(self):
        ip = getattr(self.regs, self._ipreg)
        assert not symbolic(ip)
        return ip.value

    def address_page_aligned(self, addr):
        return addr >> self.mem.index_bits << self.mem.index_bits

    def initialize_stack(self, stack_base):
        setattr(self.regs, self.arch.get_stack_pointer_reg(),
                BVV(stack_base, self._bits))
        base_reg = self.arch.get_base_pointer_reg()
        if base_reg:
            setattr(self.regs, base_reg, BVV(stack_base, self._bits))

    def stack_push(self, val: BV):
        stack_pointer = getattr(self.regs, self.arch.get_stack_pointer_reg())
        new_stack_pointer = stack_pointer - self._bits // 8
        self.mem.store(new_stack_pointer, val, endness=self.arch.endness())
        setattr(self.regs, self.arch.get_stack_pointer_reg(), new_stack_pointer)

    def stack_pop(self):
        stack_pointer = getattr(self.regs, self.arch.get_stack_pointer_reg())
        res = self.mem.load(stack_pointer, self._bits //
                            8, endness=self.arch.endness())
        new_stack_pointer = stack_pointer + self._bits // 8
        setattr(self.regs, self.arch.get_stack_pointer_reg(), new_stack_pointer)
        return res

    def set_ip(self, new_ip):
        ip = getattr(self.regs, self._ipreg)
        if not symbolic(ip):
            self.executor._update_state_history(self, ip.value)
        setattr(self.regs, self._ipreg, BVV(new_ip, self._bits))

    def copy(self, solver_copy_fast=False):
        new_os = self.os.copy()
        new_target = self.target.clone_with(os_model=new_os)
        new_state = State(self.executor, target=new_target,
                          page_size=self.page_size)
        new_state.mem = self.mem.copy(new_state)
        new_state.regs = self.regs.copy(new_state)
        new_state.solver = self.solver.copy(new_state, solver_copy_fast)
        new_state.events = list(self.events)
        new_state.insn_history = set(self.insn_history)
        new_state.symbolic_buffers = list(self.symbolic_buffers)
        new_state.llil_ip = self.llil_ip

        return new_state

    def merge_symb_buffers(self, other):
        self_buffers_name = [b[0].name for b in self.symbolic_buffers]
        for el in other.symbolic_buffers:
            buff = el[0]
            if buff.name not in self_buffers_name:
                self.symbolic_buffers.append(el)

    def merge(self, other):
        assert isinstance(other, State)
        assert self.arch.__class__ == other.arch.__class__
        assert self.os.__class__ == other.os.__class__
        assert self.get_ip() == other.get_ip()
        assert self.llil_ip == other.llil_ip

        _, _, merge_condition = self.solver.compute_solvers_difference(
            other.solver)
        self.solver.merge(other.solver)
        self.mem.merge(other.mem, merge_condition)
        self.regs.merge(other.regs, merge_condition)
        self.os.merge(other.os, merge_condition)
        self.events.append(
            (
                "merged with %s" % str(other),
                other.events[:]  # TODO delete common events
            )
        )
        self.insn_history |= other.insn_history

```

`sym_visitor.py`:

```py
from binaryninja import RegisterValueType
from binaryninja.lowlevelil import ILRegister
from .models.function_models import library_functions
from .utility.expr_wrap_util import symbolic
from .utility.exceptions import (
    UnimplementedInstruction, DivByZero, NoDestination,
    UnconstrainedIp, UnsatState, ExitException,
    UnimplementedModel, UnimplementedSyscall
)
from .expr import BV, BVV, Bool, BoolV, ITE, And, Or
from .globals import logger


class BNILVisitor(object):
    # thanks joshwatson
    # https://github.com/joshwatson/f-ing-around-with-binaryninja/blob/master/ep4-emulator/vm_visitor.py
    def __init__(self, **kw):
        super(BNILVisitor, self).__init__()

    def visit(self, expression):
        if isinstance(expression, ILRegister):
            # direct register reference
            return getattr(self.executor.state.regs, expression.name)
        
        method_name = 'visit_{}'.format(expression.operation.name)
        if hasattr(self, method_name):
            value = getattr(self, method_name)(expression)
        else:
            raise UnimplementedInstruction(expression.operation.name, self.executor.state.get_ip())
        return value


class SymbolicVisitor(BNILVisitor):
    def __init__(self, executor):
        super(SymbolicVisitor, self).__init__()
        self.executor = executor

    def __str__(self):
        return "<SymVisitor @ SymExecutor 0x%x>" % \
            id(self.executor)

    def __repr__(self):
        return self.__str__()

    def _handle_symbolic_ip(self, expr, max_sol):
        state = self.executor.state
        sols = state.solver.evaluate_upto(expr, max_sol)
        return len(sols), sols

    # --- HANDLERS ---

    def visit_LLIL_CONST(self, expr):
        return BVV(expr.constant, max(expr.size, 1) * 8)

    def visit_LLIL_CONST_PTR(self, expr):
        return BVV(expr.constant, self.executor.arch.bits())

    def visit_LLIL_SET_REG(self, expr):
        dest = expr.dest.name
        src = self.visit(expr.src)

        if isinstance(src, Bool):
            src = ITE(
                src,
                BVV(1, 1).ZeroExt(expr.dest.info.size*8-1),
                BVV(0, 1).ZeroExt(expr.dest.info.size*8-1)
            )
        if src.size == 1:
            src = src.ZeroExt(8)

        dest, src = self.executor.arch.normalize_reg_write(
            dest, src, expr.dest.info.size
        )
        if dest is None:
            return True

        setattr(self.executor.state.regs, dest, src)
        return True

    def visit_LLIL_REG(self, expr):
        src = expr.src
        return getattr(self.executor.state.regs, src.name)

    def visit_LLIL_REG_SPLIT(self, expr):
        lo = getattr(self.executor.state.regs, expr.lo.name)
        hi = getattr(self.executor.state.regs, expr.hi.name)

        return hi.Concat(lo)

    def visit_LLIL_SET_REG_SPLIT(self, expr):
        src = self.visit(expr.src)
        lo = expr.lo.name
        hi = expr.hi.name

        lo_val = src.Extract(src.size // 2 - 1, 0)
        hi_val = src.Extract(src.size - 1, src.size // 2)

        setattr(self.executor.state.regs, lo, lo_val)
        setattr(self.executor.state.regs, hi, hi_val)
        return True

    def visit_LLIL_SET_FLAG(self, expr):
        dest = expr.dest.name
        src = self.visit(expr.src)

        if isinstance(src, Bool):
            res = ITE(src, BVV(1, 1), BVV(0, 1))
        else:
            res = ITE(src == 0, BVV(0, 1), BVV(1, 1))
        self.executor.state.regs.flags[dest] = res
        return True

    def visit_LLIL_FLAG(self, expr):
        src = expr.src.name
        return self.executor.state.regs.flags[src]

    def visit_LLIL_LOW_PART(self, expr):
        src = self.visit(expr.src)
        size = expr.size

        return src.Extract(size*8-1, 0)

    def visit_LLIL_ADD(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left + right

    def visit_LLIL_ADC(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)
        carry = self.visit(expr.carry)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left + right + carry.ZeroExt(left.size - 1)

    def visit_LLIL_ADD_OVERFLOW(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        # add with one more bit
        res = (BVV(0, 1).Concat(left) + BVV(0, 1).Concat(right))
        # check if overflow
        res = res.Extract(left.size, left.size)
        return res

    def visit_LLIL_SUB(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left - right

    def visit_LLIL_SBB(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)
        carry = self.visit(expr.carry)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)
        if carry.size < left.size:
            carry = carry.ZeroExt(left.size - carry.size)

        return left - (right + carry)

    def visit_LLIL_MUL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left * right

    def visit_LLIL_MULS_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == right.size, f"MULS_DP size mismatch: {left.size} != {right.size}"
        left = left.SignExt(left.size)
        right = right.SignExt(right.size)
        return left * right

    def visit_LLIL_MULU_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == right.size, f"MULU_DP size mismatch: {left.size} != {right.size}"
        left = left.ZeroExt(left.size)
        right = right.ZeroExt(right.size)
        return left * right

    def visit_LLIL_DIVU_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size, f"DIVU_DP size mismatch: {left.size} != 2*{right.size}"

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.ZeroExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            logger.log_warn("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "DIVU_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        div = left.UDiv(right)
        return div.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_DIVS_DP(self, expr):  # is it correct?
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size, f"DIVS_DP size mismatch: {left.size} != 2*{right.size}"

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.SignExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            logger.log_warn("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "DIVS_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        div = left / right
        return div.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_MODU_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size, f"MODU_DP size mismatch: {left.size} != 2*{right.size}"

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.ZeroExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            logger.log_warn("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "MODU_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        mod = left.URem(right)
        return mod.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_MODS_DP(self, expr):  # is it correct?
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size, f"MODS_DP size mismatch: {left.size} != 2*{right.size}"

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.SignExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            logger.log_warn("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "MODS_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        mod = left.SRem(right)
        return mod.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_AND(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if isinstance(left, Bool):
            left = ITE(left, BVV(1, 8), BVV(0, 8))
        if isinstance(right, Bool):
            right = ITE(right, BVV(1, 8), BVV(0, 8))

        if right.size > left.size:
            left = left.ZeroExt(right.size - left.size)
        if left.size > right.size:
            right = right.ZeroExt(left.size - right.size)

        return left & right

    def visit_LLIL_OR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if isinstance(left, Bool):
            left = ITE(left, BVV(1, 8), BVV(0, 8))
        if isinstance(right, Bool):
            right = ITE(right, BVV(1, 8), BVV(0, 8))

        if right.size > left.size:
            left = left.ZeroExt(right.size - left.size)
        if left.size > right.size:
            right = right.ZeroExt(left.size - right.size)

        return left | right

    def visit_LLIL_XOR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.ZeroExt(right.size - left.size)
        if left.size > right.size:
            right = right.ZeroExt(left.size - right.size)

        return left ^ right

    def visit_LLIL_NOT(self, expr):
        src = self.visit(expr.src)

        return src.__invert__()

    def visit_LLIL_NEG(self, expr):
        src = self.visit(expr.src)

        return src.__neg__()

    def visit_LLIL_LOAD(self, expr):
        src = self.visit(expr.src)
        size = expr.size

        loaded = self.executor.state.mem.load(
            src, size, endness=self.executor.arch.endness())

        return loaded

    def visit_LLIL_STORE(self, expr):
        dest = self.visit(expr.dest)
        src = self.visit(expr.src)
        assert expr.size*8 == src.size, f"STORE size mismatch: {expr.size*8} != {src.size}"

        self.executor.state.mem.store(
            dest, src, endness=self.executor.arch.endness())
        return True

    def visit_LLIL_LSL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size, f"LSL size check: {right.size} > {left.size}"

        # the logical and arithmetic left-shifts are exactly the same
        return left << right.ZeroExt(left.size - right.size)

    def visit_LLIL_LSR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size, f"LSR size check: {right.size} > {left.size}"

        return left.LShR(
            right.ZeroExt(left.size - right.size)
        )

    def visit_LLIL_ROR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size, f"ROR size check: {right.size} > {left.size}"

        return left.RotateRight(
            right.ZeroExt(left.size - right.size)
        )

    def visit_LLIL_ROL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size, f"ROL size check: {right.size} > {left.size}"

        return left.RotateLeft(
            right.ZeroExt(left.size - right.size)
        )

    def visit_LLIL_ASL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size, f"ASL size check: {right.size} > {left.size}"

        return left << right.ZeroExt(left.size - right.size)

    def visit_LLIL_ASR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size, f"ASR size check: {right.size} > {left.size}"

        return left >> right.ZeroExt(left.size - right.size)

    def visit_LLIL_CALL(self, expr):
        dest = self.visit(expr.dest)

        if symbolic(dest):
            raise UnconstrainedIp()

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)
        if dest.value in self.executor.imported_functions:
            dest_fun_name = self.executor.imported_functions[dest.value]
        else:
            dest_fun_name = self.executor.bncache.get_function_name(dest.value)
        if dest_fun_name is None:
            # Last chance, look in symbols
            sym = self.executor.view.get_symbol_at(dest.value)
            if sym is None:
                raise Exception("Unable to find function name @ 0x%x" % dest.value)

            # If we are here, it is for sure a library function
            dest_fun_name = sym.name
            if dest_fun_name not in library_functions:
                raise UnimplementedModel(dest_fun_name)

        ret_addr = self.executor.ip + \
            self.executor.bncache.get_instruction_len(self.executor.ip)

        # save ret address
        self.executor.arch.save_return_address(
            self.executor.state, BVV(ret_addr, self.executor.arch.bits()))

        # check if we have an handler
        if dest_fun_name in library_functions:
            res = library_functions[dest_fun_name](
                self.executor.state, self.executor.view)

            try:
                dest_fun = self.executor.bncache.get_function(dest.value)
                calling_convention = dest_fun.calling_convention
            except IndexError:
                # dest_fun is not a function (imported). We do not have the info about the calling convention..
                # Let's use the caller convention
                curr_fun = self.executor.bncache.get_function(self.executor.ip)
                calling_convention = curr_fun.calling_convention
            self.executor.arch.save_result_value(
                self.executor.state, calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            dest_fun_name = curr_fun_name
            assert not symbolic(dest), "symbolic return address"

        # check if imported
        elif dest.value in self.executor.imported_functions:
            name = self.executor.imported_functions[dest.value]
            if name not in library_functions:
                raise UnimplementedModel(name)

            res = library_functions[name](
                self.executor.state, self.executor.view)

            dest_fun = self.executor.bncache.get_function(dest.value)
            self.executor.arch.save_result_value(
                self.executor.state, dest_fun.calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            dest_fun_name = curr_fun_name
            assert not symbolic(dest), "symbolic return address"

        # change ip
        self.executor.update_ip(dest_fun_name, self.executor.bncache.get_llil_address(
            dest_fun_name, dest.value))

        self.executor._wasjmp = True
        return True

    def visit_LLIL_TAILCALL(self, expr):
        dest = self.visit(expr.dest)

        if symbolic(dest):
            raise UnconstrainedIp()

        if dest.value in self.executor.imported_functions:
            dest_fun_name = self.executor.imported_functions[dest.value]
        else:
            dest_fun_name = self.executor.bncache.get_function_name(dest.value)
        if dest_fun_name is None:
            # Last chance, look in symbols
            sym = self.executor.view.get_symbol_at(dest.value)
            if sym is None:
                raise Exception("Unable to find function name @ 0x%x" % dest.value)
            # If we are here, it is for sure a library function
            dest_fun_name = sym.name
            if dest_fun_name not in library_functions:
                raise UnimplementedModel(dest_fun_name)

        # check if we have an handler
        if dest_fun_name in library_functions:
            res = library_functions[dest_fun_name](
                self.executor.state, self.executor.view)

            calling_convention = "cdecl"
            dest_fun = self.executor.bncache.get_function(dest.value)
            if dest_fun is not None:
                calling_convention = dest_fun.calling_convention
            self.executor.arch.save_result_value(
                self.executor.state, calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            if symbolic(dest):
                raise UnconstrainedIp()

            dest_fun_name = self.executor.bncache.get_function_name(dest.value)

        # check if imported
        if dest.value in self.executor.imported_functions:
            name = self.executor.imported_functions[dest.value]
            if name not in library_functions:
                raise UnimplementedModel(name)

            res = library_functions[name](
                self.executor.state, self.executor.view)

            dest_fun = self.executor.bncache.get_function(dest.value)
            self.executor.arch.save_result_value(
                self.executor.state, dest_fun.calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            if symbolic(dest):
                raise UnconstrainedIp()

            dest_fun_name = self.executor.bncache.get_function_name(dest.value)

        # change ip
        self.executor.update_ip(dest_fun_name, self.executor.bncache.get_llil_address(
            dest_fun_name, dest.value))

        self.executor._wasjmp = True
        return True

    def visit_LLIL_JUMP(self, expr):
        destination = self.visit(expr.dest)

        if not symbolic(destination):
            # fast path. The destination is concrete
            dest_fun_name = self.executor.bncache.get_function_name(
                destination.value)
            self.executor.update_ip(dest_fun_name, self.executor.bncache.get_llil_address(
                dest_fun_name, destination.value))
            self.executor._wasjmp = True
            return True

        assert False, "JUMP: unimplemented case"

    def visit_LLIL_JUMP_TO(self, expr):
        destination = self.visit(expr.dest)

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)

        if not symbolic(destination):
            # fast path. The destination is concrete
            self.executor.update_ip(curr_fun_name, self.executor.bncache.get_llil_address(
                curr_fun_name, destination.value))
            self.executor._wasjmp = True
            return True

        # symbolic IP path
        if self.executor.bncache.get_setting("use_bn_jumptable_targets") == 'true':
            max_num = len(expr.targets)
        else:
            max_num = 256
        num_ips, dest_ips = self._handle_symbolic_ip(destination, max_num)

        if num_ips == 256:
            self.executor.put_in_errored(
                self.executor.state, "Probably unconstrained IP")
            raise UnconstrainedIp()

        if num_ips == 0:
            self.executor.put_in_errored(
                self.executor.state, "No valid destination")
            raise NoDestination()

        for ip in dest_ips[1:]:
            new_state = self.executor.state.copy()
            new_state.solver.add_constraints(
                destination == ip
            )
            new_state.set_ip(ip.value)
            new_state.llil_ip = self.executor.bncache.get_llil_address(
                curr_fun_name, ip.value)
            self.executor.put_in_deferred(new_state)

        self.executor.update_ip(curr_fun_name, self.executor.bncache.get_llil_address(
            curr_fun_name, dest_ips[0].value))
        self.executor.state.solver.add_constraints(dest_ips[0] == destination)
        self.executor._wasjmp = True
        return True

        # ips = expr.targets
        # current_constraint = None
        # for dst_ip in ips:
        #     llil_index = self.executor.bncache.get_llil_address(
        #         curr_fun_name, dst_ip)
        #     if self.executor.state.solver.satisfiable([
        #         destination == dst_ip
        #     ]):
        #         if current_constraint is None:
        #             current_constraint = destination == dst_ip
        #             self.executor.update_ip(
        #                 curr_fun_name, llil_index)
        #         else:
        #             new_state = self.executor.state.copy()
        #             new_state.solver.add_constraints(
        #                 destination == dst_ip
        #             )
        #             new_state.set_ip(dst_ip)
        #             new_state.llil_ip = llil_index
        #             self.executor.put_in_deferred(new_state)

        # if current_constraint is None:
        #     return ErrorInstruction.NO_DEST

        # self.executor.state.solver.add_constraints(current_constraint)
        # self.executor._wasjmp = True
        # return True

    def visit_LLIL_IF(self, expr):
        condition = self.visit(expr.condition)
        true_llil_index = expr.true
        false_llil_index = expr.false

        save_unsat = self.executor.bncache.get_setting("save_unsat") == 'true'

        true_sat = True
        false_sat = True
        if isinstance(condition, BV):
            assert condition.size == 1, f"IF: condition size must be 1, got {condition.size}"
            condition = condition == 1

        if isinstance(condition, BoolV):
            # Fast path
            true_sat = condition.value
            false_sat = not condition.value
        else:
            if not self.executor.state.solver.satisfiable(extra_constraints=[
                condition
            ]):
                true_sat = False
            if not self.executor.state.solver.satisfiable(extra_constraints=[
                condition.Not()
            ]):
                false_sat = False

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)

        if true_sat and false_sat:
            true_state = self.executor.state
            false_state = self.executor.state.copy()

            true_state.solver.add_constraints(condition)
            self.executor.update_ip(curr_fun_name, true_llil_index)

            false_state.solver.add_constraints(condition.Not())
            false_state.set_ip(self.executor.bncache.get_address(
                curr_fun_name, false_llil_index))
            false_state.llil_ip = false_llil_index
            self.executor.put_in_deferred(false_state)
        elif true_sat and not false_sat:
            true_state = self.executor.state
            false_state = self.executor.state.copy() if save_unsat else None

            true_state.solver.add_constraints(condition)
            self.executor.update_ip(curr_fun_name, true_llil_index)

            if save_unsat:
                false_state.solver.add_constraints(condition.Not())
                import z3; false_state.solver._solver = z3.Solver()

                false_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, false_llil_index))
                false_state.llil_ip = false_llil_index
                self.executor.put_in_unsat(false_state)
        elif not true_sat and false_sat:
            false_state = self.executor.state
            true_state = self.executor.state.copy() if save_unsat else None

            false_state.solver.add_constraints(condition.Not())
            self.executor.state = false_state
            self.executor.update_ip(curr_fun_name, false_llil_index)

            if save_unsat:
                true_state.solver.add_constraints(condition)
                import z3; true_state.solver._solver = z3.Solver()

                true_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, true_llil_index))
                true_state.llil_ip = true_llil_index
                self.executor.put_in_unsat(true_state)
        else:
            true_state = self.executor.state.copy() if save_unsat else None
            false_state = self.executor.state.copy() if save_unsat else None

            if save_unsat:
                true_state.solver.add_constraints(condition)
                import z3; true_state.solver._solver = z3.Solver()

                true_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, true_llil_index))
                true_state.llil_ip = true_llil_index
                self.executor.put_in_unsat(true_state)

                false_state.solver.add_constraints(condition.Not())
                import z3; false_state.solver._solver = z3.Solver()

                false_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, false_llil_index))
                false_state.llil_ip = false_llil_index
                self.executor.put_in_unsat(false_state)

            self.executor.put_in_unsat(self.executor.state)
            raise UnsatState(self.executor.state.get_ip())

        self.executor._wasjmp = True
        return True

    def visit_LLIL_BOOL_TO_INT(self, expr):
        bool_val = self.visit(expr.src)
        size = expr.size * 8
        
        # flags are 1-bit bitvectors, convert to bool for ITE
        if isinstance(bool_val, BV) and bool_val.size == 1:
            bool_val = bool_val == 1
        
        return ITE(bool_val, BVV(1, size), BVV(0, size))

    def visit_LLIL_CMP_E(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left == right

    def visit_LLIL_CMP_NE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left != right

    def visit_LLIL_CMP_SLT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left < right

    def visit_LLIL_CMP_ULT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.ULT(right)

    def visit_LLIL_CMP_SLE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left <= right

    def visit_LLIL_CMP_ULE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.ULE(right)

    def visit_LLIL_CMP_SGT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left > right

    def visit_LLIL_CMP_UGT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.UGT(right)

    def visit_LLIL_CMP_SGE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left >= right

    def visit_LLIL_CMP_UGE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.UGE(right)

    def visit_LLIL_GOTO(self, expr):
        dest = expr.dest

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)
        self.executor.update_ip(curr_fun_name, dest)

        self.executor._wasjmp = True
        return True

    def visit_LLIL_RET(self, expr):
        dest = self.visit(expr.dest)

        if symbolic(dest):
            num_ips, dest_ips = self._handle_symbolic_ip(dest, 256)

            if num_ips == 256:
                self.executor.put_in_errored(
                    self.executor.state, "Probably unconstrained IP")
                raise UnconstrainedIp()
            if num_ips == 0:
                self.executor.put_in_errored(
                    self.executor.state, "No valid destination")
                raise NoDestination()

            for ip in dest_ips[1:]:
                dest_fun_name = self.executor.bncache.get_function_name(
                    ip.value)
                new_state = self.executor.state.copy()
                new_state.solver.add_constraints(
                    dest == ip
                )
                new_state.set_ip(ip.value)
                new_state.llil_ip = self.executor.bncache.get_llil_address(
                    dest_fun_name, ip.value)
                self.executor.put_in_deferred(new_state)

            dest_ip = dest_ips[0].value
        else:
            dest_ip = dest.value

        dest_fun_name = self.executor.bncache.get_function_name(dest_ip)
        self.executor.update_ip(
            dest_fun_name, self.executor.bncache.get_llil_address(dest_fun_name, dest_ip))

        self.executor._wasjmp = True
        return True

    def visit_LLIL_PUSH(self, expr):
        src = self.visit(expr.src)

        self.executor.state.stack_push(src)
        return True

    def visit_LLIL_POP(self, expr):
        return self.executor.state.stack_pop()

    def visit_LLIL_SX(self, expr):
        src = self.visit(expr.src)
        dest_size = expr.size * 8

        assert src.size <= dest_size, f"SX size check: {src.size} > {dest_size}"

        return src.SignExt(dest_size - src.size)

    def visit_LLIL_ZX(self, expr):
        src = self.visit(expr.src)
        dest_size = expr.size * 8

        assert src.size <= dest_size, f"ZX size check: {src.size} > {dest_size}"

        return src.ZeroExt(dest_size - src.size)

    def visit_LLIL_SYSCALL(self, expr):
        n = self.executor.state.syscall_abi.get_number(self.executor.state)
        assert not symbolic(n), "SYSCALL: symbolic syscall number"
        n = n.value

        handler = self.executor.state.os.get_syscall_by_number(n)
        if handler is None:
            raise UnimplementedSyscall(n)

        res = handler(self.executor.state)
        self.executor.state.syscall_abi.set_return(self.executor.state, res)

        return True

    def visit_LLIL_NORET(self, expr):
        raise ExitException()

    def visit_LLIL_ASSERT(self, expr):
        # add constraint from UIDF (user informed dataflow)
        # https://docs.binary.ninja/dev/uidf.html
        # https://api.binary.ninja/binaryninja.variable-module.html#binaryninja.variable.PossibleValueSet

        reg_val = self.visit(expr.src)
        constraint_set = expr.constraint
        
        # convert PossibleValueSet to symbolic constraints
        
        if constraint_set.type == RegisterValueType.ConstantValue:
            # reg equals constant
            self.executor.state.solver.add_constraints(reg_val == constraint_set.value)
        
        elif constraint_set.type == RegisterValueType.SignedRangeValue:
            # reg is in signed range
            range_constraints = []
            for range_obj in constraint_set.ranges:
                range_constraints.append(
                    And(reg_val >= range_obj.start, reg_val <= range_obj.end)
                )
            if range_constraints:
                self.executor.state.solver.add_constraints(Or(*range_constraints))
        
        elif constraint_set.type == RegisterValueType.UnsignedRangeValue:
            # reg is in unsigned range
            range_constraints = []
            for range_obj in constraint_set.ranges:
                range_constraints.append(
                    And(reg_val.UGE(range_obj.start), reg_val.ULE(range_obj.end))
                )
            if range_constraints:
                self.executor.state.solver.add_constraints(Or(*range_constraints))
        
        elif constraint_set.type == RegisterValueType.InSetOfValues:
            # reg is one of these values
            value_constraints = [reg_val == v for v in constraint_set.values]
            if value_constraints:
                self.executor.state.solver.add_constraints(Or(*value_constraints))
        
        elif constraint_set.type == RegisterValueType.NotInSetOfValues:
            # reg is not one of these values
            for v in constraint_set.values:
                self.executor.state.solver.add_constraints(reg_val != v)
        
        # it can also be undetermined, so ignore that
        return True

```

`target/__init__.py`:

```py
from .context import TargetContext, resolve_target

__all__ = [
    "TargetContext",
    "resolve_target",
]

```

`target/abi.py`:

```py
from ..utility.expr_wrap_util import symbolic


class CallConvAdapter(object):
    def __init__(self, calling_convention, arch_adapter=None):
        self.calling_convention = calling_convention
        self.arch = arch_adapter

    def arg_reg_names(self):
        if self.calling_convention is None:
            return []
        return list(self.calling_convention.int_arg_regs)

    def return_reg_names(self):
        if self.calling_convention is None:
            return []
        return list(self.calling_convention.int_return_regs)

    def get_arg(self, state, k, size_bytes):
        arg_regs = self.arg_reg_names()
        if k - 1 < len(arg_regs):
            res = getattr(state.regs, arg_regs[k - 1])
            return res.Extract(size_bytes * 8 - 1, 0)

        stack_pointer = getattr(state.regs, state.arch.get_stack_pointer_reg())
        assert not symbolic(stack_pointer)
        offset_words = k - len(arg_regs)
        return state.mem.load(
            stack_pointer + (state.arch.bits() // 8) * offset_words,
            size_bytes,
            state.arch.endness(),
        )

    def set_return(self, state, value):
        regs = self.return_reg_names()
        if not regs:
            if self.arch is not None:
                self.arch.save_result_value(state, self.calling_convention, value)
            return
        setattr(state.regs, regs[0], value)


class AbiResolver(object):
    def __init__(self, view, arch_adapter=None):
        self.view = view
        self.arch = arch_adapter

    def _default_calling_convention(self):
        if self.view is None:
            return None
        return self.view.platform.default_calling_convention

    def resolve_for_function(self, function):
        cc = function.calling_convention if function is not None else self._default_calling_convention()
        return CallConvAdapter(cc, self.arch)

    def get_arg(self, state, function, k, size_bytes):
        cc = self.resolve_for_function(function)
        return cc.get_arg(state, k, size_bytes)

```

`target/arch.py`:

```py
from ..arch.arch_abstract import Arch


class BnArchAdapter(Arch):
    def __init__(self, view):
        self._view = view
        self._arch = view.arch
        self._bits = self._resolve_bits()
        self._endian = self._resolve_endian()
        self._regs = self._build_regs()
        self._reg_names = self._build_reg_names()
        self._flags = self._build_flags()
        self._ip = None
        self._sp = self._normalize_reg_name(self._arch.stack_pointer)
        self._bp = None
        self._lr = self._normalize_reg_name(self._arch.link_reg)

    def _normalize_reg_name(self, reg):
        if reg is None:
            return None
        if isinstance(reg, str):
            return reg
        return getattr(reg, "name", reg)

    def _resolve_bits(self):
        return self._arch.address_size * 8

    def _resolve_endian(self):
        return "little" if self._arch.endianness.name == "LittleEndian" else "big"

    def _iter_reg_infos(self):
        return self._arch.regs.items()

    def _get_full_reg_name(self, reg_info, reg_name):
        full = reg_info.full_width_reg
        if full:
            return full
        return reg_name

    def _get_reg_offset(self, reg_info):
        return reg_info.offset

    def _get_reg_size(self, reg_info):
        return reg_info.size

    def _build_regs(self):
        full_regs = {}
        reg_infos = list(self._iter_reg_infos())
        for reg_name, reg_info in reg_infos:
            full_name = self._get_full_reg_name(reg_info, reg_name)
            if full_name not in full_regs:
                full_info = self._arch.regs[full_name]
                size = self._get_reg_size(full_info)
                full_regs[full_name] = {
                    "size": size,
                    "sub": {},
                }

        for reg_name, reg_info in reg_infos:
            full_name = self._get_full_reg_name(reg_info, reg_name)
            if full_name == reg_name:
                continue
            parent = full_regs.get(full_name)
            if not parent:
                continue
            parent_size = parent["size"]
            sub_size = self._get_reg_size(reg_info)
            bn_offset = self._get_reg_offset(reg_info)
            mem_offset = max(parent_size - sub_size - bn_offset, 0)
            parent["sub"][reg_name] = {
                "offset": mem_offset,
                "size": sub_size,
            }

        curr_addr = 0
        for reg_name in full_regs:
            reg = full_regs[reg_name]
            reg["addr"] = curr_addr
            curr_addr += reg["size"]
        return full_regs

    def _build_reg_names(self):
        return list(self._regs.keys())

    def _build_flags(self):
        names = list(self._arch.flags)
        return {name: 0 for name in names}

    def bits(self):
        return self._bits

    def regs_data(self):
        return self._regs

    def reg_names(self):
        return self._reg_names

    def flags_data(self):
        return self._flags

    def flags_default(self, flag):
        return None

    def endness(self):
        return self._endian

    def getip_reg(self):
        if self._ip:
            return self._ip
        for name in ("pc", "ip", "rip", "eip"):
            if name in self._regs:
                return name
        return next(iter(self._regs.keys()))

    def get_base_pointer_reg(self):
        if self._bp:
            return self._bp
        for name in ("bp", "rbp", "ebp", "fp"):
            if name in self._regs:
                return name
        return None

    def get_stack_pointer_reg(self):
        if self._sp:
            return self._sp
        for name in ("sp", "rsp", "esp"):
            if name in self._regs:
                return name
        return next(iter(self._regs.keys()))

    def save_return_address(self, state, return_address):
        if self._lr and self._lr in self._regs:
            setattr(state.regs, self._lr, return_address)
            return
        state.stack_push(return_address)

    def get_return_address(self, state):
        if self._lr and self._lr in self._regs:
            return getattr(state.regs, self._lr)
        return state.stack_pop()

    def get_argument_regs(self, calling_convention):
        return list(calling_convention.int_arg_regs)

    def save_result_value(self, state, calling_convention, value):
        reg_names = list(calling_convention.int_return_regs)
        if not reg_names:
            return
        reg = reg_names[0]
        setattr(state.regs, reg, value)

    def get_flag_cond_lambda(self, cond: str):
        raise NotImplementedError

    def execute_special_handler(self, disasm_str, sv):
        return False

```

`target/context.py`:

```py
from .registry import resolve_arch_adapter, resolve_os_model
from .layout import DataLayout
from .abi import AbiResolver
from .syscall import NullSyscallAbi
from ..os_models.null import NullOS


class TargetContext(object):
    def __init__(self, view, arch, abi, syscall_abi, os_model, layout):
        self.view = view
        self.arch = arch
        self.abi = abi
        self.syscall_abi = syscall_abi
        self.os = os_model
        self.layout = layout

    def clone_with(self, os_model=None):
        os_model = os_model if os_model is not None else self.os
        syscall_abi = self.syscall_abi
        return TargetContext(self.view, self.arch, self.abi, syscall_abi, os_model, self.layout)


def resolve_target(view):
    arch = resolve_arch_adapter(view)
    os_model = resolve_os_model(view)
    if os_model is None:
        os_model = NullOS()
    layout = DataLayout.from_view(view)
    abi = AbiResolver(view, arch)
    syscall_abi = os_model.get_syscall_abi(view, arch)

    if syscall_abi is None:
        syscall_abi = NullSyscallAbi(
            "syscall ABI not configured for platform {}".format(view.platform.name)
        )
    return TargetContext(view, arch, abi, syscall_abi, os_model, layout)

```

`target/layout.py`:

```py
class DataLayout(object):
    def __init__(self, ptr_bits, endian, long_bits=None, size_t_bits=None,
                 time_t_bits=None, stack_grows_down=True):
        self.ptr_bits = ptr_bits
        self.endian = endian
        self.long_bits = long_bits if long_bits is not None else ptr_bits
        self.size_t_bits = size_t_bits if size_t_bits is not None else ptr_bits
        self.time_t_bits = time_t_bits if time_t_bits is not None else ptr_bits
        self.stack_grows_down = stack_grows_down

    @staticmethod
    def from_view(view):
        arch = view.arch
        ptr_bits = arch.address_size * 8
        endian = "little" if arch.endianness.name == "LittleEndian" else "big"
        return DataLayout(ptr_bits, endian)

    @staticmethod
    def from_arch(arch):
        ptr_bits = arch.bits()
        endian = arch.endness()
        return DataLayout(ptr_bits, endian)

```

`target/registry.py`:

```py
import inspect

from .arch import BnArchAdapter

_ARCH_FACTORIES = {}
_OS_FACTORIES = {}
_BUILTINS_LOADED = False


def register_arch_adapter(arch_name, factory):
    _ARCH_FACTORIES[arch_name] = factory


def register_os_model(platform_name, factory):
    _OS_FACTORIES[platform_name] = factory


def _load_builtins():
    global _BUILTINS_LOADED
    if _BUILTINS_LOADED:
        return

    from ..arch.arch_x86 import x86Arch
    from ..arch.arch_x86_64 import x8664Arch
    from ..arch.arch_armv7 import ArmV7Arch
    from ..arch.arch_arm32 import Arm32Arch
    from ..arch.arch_aarch64 import AArch64Arch
    from ..arch.arch_riscv import RiscVArch
    from ..os_models.linux import (
        Linuxi386,
        Linuxia64,
        LinuxArmV7,
        LinuxAArch64,
        LinuxRiscV,
    )
    from ..os_models.windows import Windows
    from ..os_models.macos import MacOS

    register_arch_adapter("x86", x86Arch)
    register_arch_adapter("x86_64", x8664Arch)
    register_arch_adapter("armv7", ArmV7Arch)
    register_arch_adapter("armv7eb", Arm32Arch)
    register_arch_adapter("thumb2", Arm32Arch)
    register_arch_adapter("thumb2eb", Arm32Arch)
    register_arch_adapter("aarch64", AArch64Arch)
    register_arch_adapter("riscv32", RiscVArch)
    register_arch_adapter("riscv64", RiscVArch)
    register_arch_adapter("rv32gc", RiscVArch)
    register_arch_adapter("rv64gc", RiscVArch)

    register_os_model("linux-x86", Linuxi386)
    register_os_model("linux-x86_64", Linuxia64)
    register_os_model("linux-armv7", LinuxArmV7)
    register_os_model("linux-armv7eb", LinuxArmV7)
    register_os_model("linux-thumb2", LinuxArmV7)
    register_os_model("linux-thumb2eb", LinuxArmV7)
    register_os_model("linux-aarch64", LinuxAArch64)
    register_os_model("linux-riscv32", LinuxRiscV)
    register_os_model("linux-riscv64", LinuxRiscV)
    register_os_model("linux-rv32gc", LinuxRiscV)
    register_os_model("linux-rv64gc", LinuxRiscV)
    register_os_model("windows-x86", Windows)
    register_os_model("windows-x86_64", Windows)
    register_os_model("mac-x86_64", MacOS)
    register_os_model("mac-aarch64", MacOS)

    _BUILTINS_LOADED = True


def _instantiate(factory, view):
    if factory is None:
        return None
    if inspect.isclass(factory):
        sig = inspect.signature(factory)
        if len(sig.parameters) == 0:
            return factory()
        return factory(view)
    try:
        return factory(view)
    except TypeError:
        return factory()


def resolve_arch_adapter(view):
    _load_builtins()
    arch_name = view.arch.name
    factory = _ARCH_FACTORIES.get(arch_name)
    if factory is None:
        return BnArchAdapter(view)
    return _instantiate(factory, view)


def resolve_os_model(view):
    _load_builtins()
    platform_name = view.platform.name
    factory = _OS_FACTORIES.get(platform_name)
    if factory is None:
        return None
    return _instantiate(factory, view)

```

`target/syscall.py`:

```py
class SyscallAbi(object):
    def get_number(self, state):
        raise NotImplementedError

    def get_arg(self, state, idx: int):
        raise NotImplementedError

    def set_return(self, state, value):
        raise NotImplementedError


class NullSyscallAbi(SyscallAbi):
    def __init__(self, reason="syscall ABI not configured"):
        self.reason = reason

    def get_number(self, state):
        raise NotImplementedError(self.reason)

    def get_arg(self, state, idx: int):
        raise NotImplementedError(self.reason)

    def set_return(self, state, value):
        raise NotImplementedError(self.reason)


class RegSyscallAbi(SyscallAbi):
    def __init__(self, number_reg, arg_regs, return_reg):
        self.number_reg = number_reg
        self.arg_regs = list(arg_regs)
        self.return_reg = return_reg

    def get_number(self, state):
        return getattr(state.regs, self.number_reg)

    def get_arg(self, state, idx: int):
        if idx >= len(self.arg_regs):
            raise NotImplementedError("Syscall argument index out of range")
        return getattr(state.regs, self.arg_regs[idx])

    def set_return(self, state, value):
        setattr(state.regs, self.return_reg, value)


```

`tests/__init__.py`:

```py
from . import file_tests
from . import os_linux_tests
from . import os_windows_tests
from . import memory_tests


def handle_test(module, test):
    print(test + "\t", end="")
    try:
        getattr(module, test)()
        print("OK")
    except Exception as e:
        print("ERROR")
        # raise e


def handle_module(module_name, module):
    print(module_name)
    for test in dir(module):
        if "test" in test:
            handle_test(module, test)


def run():
    handle_module("memory tests", memory_tests)
    handle_module("file tests", file_tests)
    handle_module("os linux tests", os_linux_tests)
    handle_module("os windows tests", os_windows_tests)

```

`tests/file_tests.py`:

```py
from ..expr import BVS, BVV
from ..memory.sym_file import SymFile
from ..os_models.os_file import OsFileHandler


def test_1():  # read unconstrained
    f = SymFile("a")
    res = f.read(1)
    assert len(res) == 1
    assert isinstance(res[0], BVS)
    assert res[0].name == "unconstrained_a_0"


def test_2():  # read concrete
    f = SymFile("a")
    f.write([BVV(0xff, 8)])
    f.seek(0)
    res = f.read(1)
    assert len(res) == 1
    assert isinstance(res[0], BVV)
    assert res[0].value == 255


def test_3():
    os = OsFileHandler()
    fd = os.open("stdin", "r--")
    assert fd == 0


def test_4():
    os = OsFileHandler()
    fd = os.open("stdin", "r--")

    assert os.is_open(fd)
    os.close(fd)
    assert not os.is_open(fd)


def test_5():
    os = OsFileHandler()
    fd1 = os.open("A", "-w-")
    fd2 = os.open("A", "r--")

    os.write(fd1, [BVV(0xff, 8)])
    res = os.read(fd2, 1)

    assert len(res) == 1
    assert isinstance(res[0], BVV)
    assert res[0].value == 255


def test_6():
    os1 = OsFileHandler()
    os2 = OsFileHandler()

    fd1 = os1.open("A", "-w-")
    os1.write(fd1, [BVV(0xff, 8)])
    fd2 = os1.open("A", "r--")

    os1.copy_to(os2)

    res = os2.read(fd2, 1)
    assert len(res) == 1
    assert isinstance(res[0], BVV)
    assert res[0].value == 255

```

`tests/memory_tests.py`:

```py
from ..expr import BVV
from ..memory.sym_flat_memory_not_paged import MemoryConcreteFlatNotPaged


def test_1():
    m1 = MemoryConcreteFlatNotPaged("")
    m1.store(BVV(0, m1.bits), BVV(0xff, 8))

    m2 = m1.copy()

    assert id(m1.values) == id(m2.values)

    m2.store(BVV(1, m2.bits), BVV(0xfa, 8))

    r11 = m1.load(BVV(0, m1.bits), 1)
    r12 = m1.load(BVV(1, m1.bits), 1)

    r21 = m2.load(BVV(0, m2.bits), 1)
    r22 = m2.load(BVV(1, m2.bits), 1)

    assert isinstance(r11, BVV)
    assert r11.value == 0xff
    assert not isinstance(r12, BVV)

    assert isinstance(r21, BVV)
    assert r21.value == 0xff
    assert isinstance(r22, BVV)
    assert r22.value == 0xfa

```

`tests/os_linux_tests.py`:

```py
from ..expr import BVS, BVV
from ..os_models.linux import Linux, Linuxi386, Linuxia64, LinuxArmV7


def test_1():
    l = Linux()
    l.write(0, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdin_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_2():
    l = Linux()
    l.write(1, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdout_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_3():
    l = Linux()
    assert l.stdin_fd == 0
    assert l.stdout_fd == 1


def test_4():
    l1 = Linux()
    l1.write(0, [BVV(0xaa, 8)])

    l2 = Linux()
    l1.copy_to(l2)

    l2.write(0, [BVV(0xbb, 8)])

    res1 = l1.get_stdin_stream()
    res2 = l2.get_stdin_stream()

    assert len(res1) == 1
    assert isinstance(res1[0], BVV)
    assert res1[0].value == 0xaa

    assert len(res2) == 2
    assert (
        isinstance(res2[0], BVV) and
        isinstance(res2[1], BVV)
    )
    assert (
        res2[0].value == 0xaa and
        res2[1].value == 0xbb
    )

```

`tests/os_windows_tests.py`:

```py
from ..expr import BVS, BVV
from ..os_models.windows import Windows


def test_1():
    l = Windows()
    l.write(0, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdin_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_2():
    l = Windows()
    l.write(1, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdout_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_3():
    l = Windows()
    assert l.stdin_fd == 0
    assert l.stdout_fd == 1


def test_4():
    l1 = Windows()
    l1.write(0, [BVV(0xaa, 8)])

    l2 = l1.copy(None)

    l2.write(0, [BVV(0xbb, 8)])

    res1 = l1.get_stdin_stream()
    res2 = l2.get_stdin_stream()

    assert len(res1) == 1
    assert isinstance(res1[0], BVV)
    assert res1[0].value == 0xaa

    assert len(res2) == 2
    assert (
        isinstance(res2[0], BVV) and
        isinstance(res2[1], BVV)
    )
    assert (
        res2[0].value == 0xaa and
        res2[1].value == 0xbb
    )

```

`ui/argv_form.py`:

```py
from PySide6.QtWidgets import (
    QDialog,
    QLineEdit,
    QPushButton,
    QGridLayout,
    QLabel,
    QComboBox
)
from ..globals import logger, uimanager_registry
from binaryninja.interaction import show_message_box
from ..utility.string_util import str_to_bv, str_to_bv_list
from ..expr import BVV, BV

import sys

class GetArgvDialog(QDialog):
    def __init__(self, state, parent=None):
        super(GetArgvDialog, self).__init__(parent)
        self.state = state

        self.setWindowTitle('Setup argv')

        self._outerLayout = QGridLayout()
        self._layout = QGridLayout()
        self._outerLayout.addLayout(self._layout, 0, 0, 1, 2)

        self.okButton = QPushButton("Ok")
        self.okButton.clicked.connect(self.onOkClick)
        self.cancelButton = QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.onCancelClick)

        self._outerLayout.addWidget(self.okButton, 2, 0, 1, 1)
        self._outerLayout.addWidget(self.cancelButton, 2, 1, 1, 1)

        self.n_args = 0
        self.args = list()

        self.add_conc_button = QPushButton("Add conc param")
        self.add_conc_button.clicked.connect(self.onConcClick)
        self.add_symb_button = QPushButton("Add symb param")
        self.add_symb_button.clicked.connect(self.onSymbClick)

        self.label = QLabel("Number of args: " + str(self.n_args))

        self._layout.addWidget(self.add_conc_button, 0, 0, 1, 5)
        self._layout.addWidget(self.add_symb_button, 0, 5, 1, 5)
        self._layout.addWidget(self.label, 1, 0, 1, 10)

        self.setLayout(self._outerLayout)

    def update_label_args(self):
        self.label.setText("Number of args: " + str(self.n_args))

    def onConcClick(self):
        self.n_args += 1
        self.update_label_args()

        label = QLabel(str(self.n_args) + ": ")
        line_edit = QLineEdit("arg value...")

        self._layout.addWidget(label, self.n_args + 2, 0, 1, 1)
        self._layout.addWidget(line_edit, self.n_args + 2, 1, 1, 9)

        self.args.append(
            ("conc", label, line_edit)
        )

    def onSymbClick(self):
        self.n_args += 1
        self.update_label_args()

        label     = QLabel(str(self.n_args) + ": ")
        combo_box = QComboBox()
        buffer_names = [
            b[0].name for b in self.state.symbolic_buffers]

        if len(buffer_names) == 0:
            show_message_box("Error", "No symbolic buffer")
            return

        for name in buffer_names:
            combo_box.addItem(name)

        self._layout.addWidget(label, self.n_args + 2, 0, 1, 1)
        self._layout.addWidget(combo_box, self.n_args + 2, 1, 1, 9)

        self.args.append(
            ("symb", label, combo_box)
        )

    def _get_buff_from_name(self, name):
        for buff, _, _ in self.state.symbolic_buffers:
            if buff.name == name:
                return buff
        return None

    def _get_arguments(self):
        res = list()
        for t, _, obj in self.args:
            if t == "conc":
                res.append(str_to_bv(obj.text(), True))
            else:
                buff = self._get_buff_from_name(
                    obj.currentText())
                assert buff is not None
                res.append(buff.Concat(BVV(0, 8)))
        return res

    def onOkClick(self):
        args = self._get_arguments()
        GetArgvDialog.setup_argv(*args)
        self.accept()

    def onCancelClick(self):
        self.reject()

    @staticmethod
    def setup_argv(*args, argc_loc=None, argv_loc=None):
        uimanager = uimanager_registry.get_active()
        if not uimanager or not uimanager.executor:
            logger.log_error("SENinja [error]: No active symbolic execution")
            return

        filename = uimanager.executor.view.file.filename
        state = uimanager.executor.state
        argv_p = BVV(state.mem.allocate((len(args) + 1) *
                                        (state.arch.bits() // 8)), state.arch.bits())
        argv_1_p = BVV(state.mem.allocate(len(filename)), state.arch.bits())
        for i, b in enumerate(str_to_bv_list(filename, terminator=True)):
            state.mem.store(argv_1_p + i, b)
        state.mem.store(argv_p, argv_1_p, state.arch.endness())

        for i, arg in enumerate(args):
            if not isinstance(arg, BV):
                logger.log_error("SENinja [error]: %s is not a BitVector" % str(arg))
                return
            argv_el_p = BVV(state.mem.allocate(
                arg.size // 8 + 1), state.arch.bits())
            state.mem.store(argv_el_p, arg)
            state.mem.store(argv_p + (i + 1) *
                            (state.arch.bits() // 8), argv_el_p, state.arch.endness())

        argc = BVV(len(args) + 1, state.arch.bits())
        if argc_loc is None:
            current_function = uimanager.executor.bncache.get_function(
                uimanager.executor.ip)
            argc_loc = current_function.calling_convention.int_arg_regs[0]

        if isinstance(argc_loc, str):
            setattr(state.regs, argc_loc, argc)
        elif isinstance(argc_loc, BV):
            state.mem.store(argc_loc, argc, state.arch.endness())
        else:
            logger.log_error("SENinja [error]: invalid argc_loc %s" % str(argc_loc))
            return

        if argv_loc is None:
            current_function = uimanager.executor.bncache.get_function(
                uimanager.executor.ip)
            argv_loc = current_function.calling_convention.int_arg_regs[1]

        if isinstance(argv_loc, str):
            setattr(state.regs, argv_loc, argv_p)
        elif isinstance(argv_loc, BV):
            state.mem.store(argv_loc, argv_p, state.arch.endness())
        else:
            logger.log_error("SENinja [error]: invalid argv_loc %s" % str(argv_loc))
            return

```

`ui/buffer_view.py`:

```py
from binaryninja import BackgroundTaskThread
from binaryninja.interaction import (
    show_message_box,
    get_int_input,
    get_choice_input
)
from binaryninjaui import (
    getMonospaceFont,
    UIActionHandler
)
from PySide6 import QtCore
from PySide6.QtCore import Qt, QMimeData
from PySide6.QtWidgets import (
    QApplication,
    QVBoxLayout,
    QWidget,
    QTableWidget,
    QTableWidgetItem,
    QMenu,
    QDialog,
    QLineEdit,
    QRadioButton,
    QPushButton,
    QCheckBox
)

from ..utility.expr_wrap_util import symbolic
from ..utility.string_util import (
    constraint_alphanumeric_string,
    constraint_ascii_string
)
from ..expr.bitvector import BVS, BVV

NO_CONSTRAINTS = 0
ASCII_STRING = 1
ALPHANUMERIC_STRING = 2

gBuffersPerTab = {}

def get_int(v):
    try:
        return int(v)
    except:
        try:
            return int(v, 16)
        except:
            pass
    return None

class BufferViewBT(BackgroundTaskThread):
    def __init__(self, msg, bw, callback, pars):
        BackgroundTaskThread.__init__(self, msg, False)
        self.bw = bw
        self.pars = pars
        self.callback = callback

    def run(self):
        self.callback(*self.pars)

class CreateBufferDialog(QDialog):
    constraint_list = {
        NO_CONSTRAINTS: "No constraint",
        ASCII_STRING: "ASCII string",
        ALPHANUMERIC_STRING: "Alphanumeric string"
    }

    def __init__(self, blacklisted_names=[], parent=None):
        super(CreateBufferDialog, self).__init__(parent)

        self.setWindowTitle('Create new buffer')

        self.blacklisted_names = blacklisted_names

        layout = QVBoxLayout()

        self.buff_name = QLineEdit("Buffer name")
        self.buff_width = QLineEdit("Buffer size (bytes)")

        layout.addWidget(self.buff_name)
        layout.addWidget(self.buff_width)

        self.constraints = dict()
        for cid in sorted(CreateBufferDialog.constraint_list.keys()):
            name = CreateBufferDialog.constraint_list[cid]
            item = QRadioButton(name)
            if cid == NO_CONSTRAINTS:
                item.setChecked(True)
            self.constraints[cid] = item
            layout.addWidget(item)

        self.checkbox_terminator = QCheckBox("Terminator")
        self.checkbox_terminator.setChecked(True)
        layout.addWidget(self.checkbox_terminator)

        self.ok = QPushButton("Ok")
        self.ok.clicked.connect(self.on_okClick)
        self.cancel = QPushButton("Cancel")
        self.cancel.clicked.connect(self.on_cancelClick)

        layout.addWidget(self.ok)
        layout.addWidget(self.cancel)

        self.setLayout(layout)

        self.res_name = None
        self.res_width = None
        self.res_constraints = None

    def on_okClick(self):
        width = get_int(self.buff_width.text())
        if width is None:
            show_message_box(
                "Error", "Invalid buffer width: must be an integer")
            return
        if self.buff_name.text() in self.blacklisted_names:
            show_message_box(
                "Error", "Name already used")
            return

        self.res_width = width
        self.res_name = self.buff_name.text()

        for cid in self.constraints:
            el = self.constraints[cid]
            if el.isChecked():
                self.res_constraints = cid
                break
        self.res_terminator = self.checkbox_terminator.isChecked()

        self.accept()

    def on_cancelClick(self):
        self.reject()


def _makewidget(parent, val, center=False):
    """ Small helper function that builds a TableWidgetItem and sets up the font the way we want"""
    out = QTableWidgetItem(str(val))
    out.setFlags(Qt.ItemIsEnabled)
    out.setFont(getMonospaceFont(parent))
    if center:
        out.setTextAlignment(Qt.AlignCenter)
    return out

class BufferViewData(object):
    def __init__(self):
        self.current_state = None

class BufferView(QWidget):
    def __init__(self, parent):
        QWidget.__init__(self, parent)

        self.parent = parent
        self.data = BufferViewData()
        self.tabname = ""

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self.layout = QVBoxLayout()

        # Set up register table
        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(
            ['Address', 'Name', 'Size', 'Constraints'])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setVisible(False)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(
            self.on_customContextMenuRequested)
        self.table.doubleClicked.connect(self.on_doubleClick)

        self.button = QPushButton("New Buffer")
        self.button.clicked.connect(self.on_newBufferClick)

        self.layout.addWidget(self.button)
        self.layout.addWidget(self.table)

        self.setLayout(self.layout)

    def on_newBufferClick(self):
        if self.data.current_state is None:
            return

        blacklisted_names = [
            b[0].name for b in self.data.current_state.symbolic_buffers]

        new_buff_dialog = CreateBufferDialog(
            blacklisted_names=blacklisted_names)
        new_buff_dialog.exec_()

        if new_buff_dialog.res_name is None:
            return

        buff = BVS(new_buff_dialog.res_name, new_buff_dialog.res_width * 8)
        if new_buff_dialog.res_terminator:
            buff_to_store = buff.Concat(BVV(0, 8))
        else:
            buff_to_store = buff

        address = self.data.current_state.mem.allocate(new_buff_dialog.res_width)
        if new_buff_dialog.res_constraints == ALPHANUMERIC_STRING:
            constraint_alphanumeric_string(buff, self.data.current_state)
        elif new_buff_dialog.res_constraints == ASCII_STRING:
            constraint_ascii_string(buff, self.data.current_state)

        constraint_str = ""
        if new_buff_dialog.res_constraints != NO_CONSTRAINTS:
            constraint_str = CreateBufferDialog.constraint_list[new_buff_dialog.res_constraints]
        self.data.current_state.mem.store(address, buff_to_store)
        self.data.current_state.symbolic_buffers.append(
            (buff, address, constraint_str)
        )
        self.stateUpdate(self.data.current_state)

    def stateReset(self):
        self.data = BufferViewData()
        self.table.setRowCount(0)

    def _init_internal(self):
        self.stateUpdate(self.data.current_state)

    def stateInit(self, arch, state):
        self.data.current_state = state
        self._init_internal()

    def stateUpdate(self, state):
        self.data.current_state = state
        self.table.setRowCount(0)
        if self.data.current_state is None:
            return

        self.table.setRowCount(len(self.data.current_state.symbolic_buffers))
        i = 0
        for buff, address, constraints in self.data.current_state.symbolic_buffers:
            self.table.setItem(i, 0, _makewidget(self, hex(address)))
            self.table.setItem(i, 1, _makewidget(self, buff.name))
            self.table.setItem(i, 2, _makewidget(self, buff.size // 8))
            self.table.setItem(i, 3, _makewidget(self, constraints))
            i += 1

    @staticmethod
    def _condom(f, *pars):
        def g():
            f(*pars)
        return g

    @staticmethod
    def _condom_async(bw, f, *pars):
        def g():
            bt = BufferViewBT("BufferView background task...", bw, f, pars)
            bt.start()
        return g

    # right click menu
    def on_customContextMenuRequested(self, pos):
        item = self.table.itemAt(pos)
        if item is None:
            return
        row_idx = item.row()
        menu = QMenu()

        copy_address = menu.addAction("Copy address")
        copy_address.triggered.connect(BufferView._condom(
            self._menuAction_copy_address, row_idx))
        eval_upto = menu.addAction("Evaluate upto")
        eval_upto.triggered.connect(BufferView._condom_async(
            self, self._menuAction_evaluate_upto_buffer, row_idx))
        eval_as_bytes = menu.addAction("Evaluate as bytes")
        eval_as_bytes.triggered.connect(BufferView._condom_async(
            self, self._menuAction_evaluate_buffer, row_idx))
        copy_eval = menu.addAction("Copy evaluated bytes")
        copy_eval.triggered.connect(BufferView._condom_async(
            self, self._menuAction_copy_evaluated_buffer, row_idx))
        add_constraint = menu.addAction("Add constraint")
        add_constraint.triggered.connect(BufferView._condom(
            self._menuAction_add_constraint, row_idx))

        menu.exec_(self.table.viewport().mapToGlobal(pos))

    def _menuAction_copy_address(self, buffer_id):
        mime = QMimeData()
        mime.setText(hex(self.data.current_state.symbolic_buffers[buffer_id][1]))
        QApplication.clipboard().setMimeData(mime)

    def _menuAction_evaluate_buffer(self, buffer_id):
        buff = self.data.current_state.symbolic_buffers[buffer_id][0]
        res = self.data.current_state.solver.evaluate(buff).as_bytes()
        res = repr(res)[2:-1]
        show_message_box("%s evaluate" % buff.name, res)

    def _menuAction_evaluate_upto_buffer(self, buffer_id):
        buff = self.data.current_state.symbolic_buffers[buffer_id][0]

        n_eval = get_int_input("How many values (upto) ?", "Number of distinct values")
        if n_eval is None:
            return
        r = ""
        for i, v in enumerate(self.data.current_state.solver.evaluate_upto(buff, n_eval)):
            r += "solution %d: %s\n" % (i, hex(v.value))

        show_message_box("%s evaluate" % buff.name, r)

    def _menuAction_copy_evaluated_buffer(self, buffer_id):
        mime = QMimeData()
        buff = self.data.current_state.symbolic_buffers[buffer_id][0]
        res = self.data.current_state.solver.evaluate(buff).as_bytes()
        res = '"' + repr(res)[2:-1] + '"'
        mime.setText(res)
        QApplication.clipboard().setMimeData(mime)

    def _menuAction_add_constraint(self, buffer_id):
        buff = self.data.current_state.symbolic_buffers[buffer_id][0]
        constraints = self.data.current_state.symbolic_buffers[buffer_id][2]
        if constraints != "":
            show_message_box("Error", "The buffer already has a constraint.")
            return

        choices = [CreateBufferDialog.constraint_list[i]
                   for i in CreateBufferDialog.constraint_list.keys() if i != NO_CONSTRAINTS]
        res = get_choice_input(
            "Constraint buffer", "choices:", choices
        )
        if choices[res] == "Alphanumeric string":
            constraint_alphanumeric_string(buff, self.data.current_state)
        elif choices[res] == "ASCII string":
            constraint_ascii_string(buff, self.data.current_state)
        else:
            return

        t = self.data.current_state.symbolic_buffers[buffer_id]
        t = t[0], t[1], choices[res]
        self.data.current_state.symbolic_buffers[buffer_id] = t
        self.update_state(self.data.current_state)

    # double click event
    def on_doubleClick(self, item):
        # row_idx = item.row()
        pass

    def contextMenuEvent(self, event):
        self.m_contextMenuManager.show(self.m_menu, self.actionHandler)

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        return True

    def notifytab(self, newName):
        if newName != self.tabname:
            if self.tabname is not None:
                gBuffersPerTab[self.tabname] = self.data
                self.stateReset()

            if newName in gBuffersPerTab:
                self.data = gBuffersPerTab[newName]
                self._init_internal()
        self.tabname = newName

```

`ui/control_view.py`:

```py
import os

from binaryninjaui import (
    UIActionHandler,
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QPixmap, QIcon, QAction
from PySide6.QtWidgets import (
    QVBoxLayout,
    QWidget,
    QToolBar,
    QToolButton
)

def load_icon(fname_icon):
    path_this_file = os.path.abspath(__file__)
    path_this_dir = os.path.dirname(path_this_file)
    path_icons = os.path.join(path_this_dir, '..', 'media', 'icons')
    path_icon = os.path.join(path_icons, fname_icon)

    pixmap = QPixmap(path_icon)

    icon = QIcon()
    icon.addPixmap(pixmap, QIcon.Normal)
    icon.addPixmap(pixmap, QIcon.Disabled)
    return icon

gControlPerTab = {}

class ControlView(QWidget):
    def __init__(self, parent):
        QWidget.__init__(self, parent)
        self.parent = parent
        self._uimanager = None

        self.toolbar = QToolBar(self, parent)
        self.toolbar.setStyleSheet("QToolBar{spacing:0px;}")
        maxheight = 24

        # ----
        self.toolbar.btnStart = QToolButton(self.toolbar)
        self.toolbar.btnStart.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnStart.setMaximumHeight(maxheight)

        self.toolbar.btnStart.actionStart = QAction("Start...", self.toolbar)
        self.toolbar.btnStart.actionStart.triggered.connect(lambda: self.perform_start())
        self.toolbar.btnStart.actionStart.setIcon(load_icon('start.svg'))

        self.toolbar.btnStart.setDefaultAction(self.toolbar.btnStart.actionStart)
        self.toolbar.addWidget(self.toolbar.btnStart)
        # ----

        # ----
        self.toolbar.btnStepInto = QToolButton(self.toolbar)
        self.toolbar.btnStepInto.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnStepInto.setMaximumHeight(maxheight)

        self.toolbar.btnStepInto.actionStep = QAction("Step", self.toolbar)
        self.toolbar.btnStepInto.actionStep.triggered.connect(lambda: self.perform_step())
        self.toolbar.btnStepInto.actionStep.setIcon(load_icon('stepinto.svg'))

        self.toolbar.btnStepInto.setDefaultAction(self.toolbar.btnStepInto.actionStep)
        self.toolbar.addWidget(self.toolbar.btnStepInto)
        # ----

        # ----
        self.toolbar.btnRunBranch = QToolButton(self.toolbar)
        self.toolbar.btnRunBranch.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnRunBranch.setMaximumHeight(maxheight)

        self.toolbar.btnRunBranch.actionRunUntilBranch = QAction("Run Until Branch", self.toolbar)
        self.toolbar.btnRunBranch.actionRunUntilBranch.triggered.connect(lambda: self.perform_run_until_branch())
        self.toolbar.btnRunBranch.actionRunUntilBranch.setIcon(load_icon('run_branch.svg'))

        self.toolbar.btnRunBranch.setDefaultAction(self.toolbar.btnRunBranch.actionRunUntilBranch)
        self.toolbar.addWidget(self.toolbar.btnRunBranch)
        # ----

        # ----
        self.toolbar.btnRunAddr = QToolButton(self.toolbar)
        self.toolbar.btnRunAddr.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnRunAddr.setMaximumHeight(maxheight)

        self.toolbar.btnRunAddr.actionRunAddr = QAction("Run Until Address", self.toolbar)
        self.toolbar.btnRunAddr.actionRunAddr.triggered.connect(lambda: self.perform_run_until_addr())
        self.toolbar.btnRunAddr.actionRunAddr.setIcon(load_icon('run_addr.svg'))

        self.toolbar.btnRunAddr.setDefaultAction(self.toolbar.btnRunAddr.actionRunAddr)
        self.toolbar.addWidget(self.toolbar.btnRunAddr)
        # ----

        # ----
        self.toolbar.btnRunDFS = QToolButton(self.toolbar)
        self.toolbar.btnRunDFS.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnRunDFS.setMaximumHeight(maxheight)

        self.toolbar.btnRunDFS.actionRunDFS = QAction("Run DFS", self.toolbar)
        self.toolbar.btnRunDFS.actionRunDFS.triggered.connect(lambda: self.perform_dfs())
        self.toolbar.btnRunDFS.actionRunDFS.setIcon(load_icon('run_dfs.svg'))

        self.toolbar.btnRunDFS.setDefaultAction(self.toolbar.btnRunDFS.actionRunDFS)
        self.toolbar.addWidget(self.toolbar.btnRunDFS)
        # ----

        # ----
        self.toolbar.btnRunBFS = QToolButton(self.toolbar)
        self.toolbar.btnRunBFS.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnRunBFS.setMaximumHeight(maxheight)

        self.toolbar.btnRunBFS.actionRunBFS = QAction("Run BFS", self.toolbar)
        self.toolbar.btnRunBFS.actionRunBFS.triggered.connect(lambda: self.perform_bfs())
        self.toolbar.btnRunBFS.actionRunBFS.setIcon(load_icon('run_bfs.svg'))

        self.toolbar.btnRunBFS.setDefaultAction(self.toolbar.btnRunBFS.actionRunBFS)
        self.toolbar.addWidget(self.toolbar.btnRunBFS)
        # ----

        # ----
        self.toolbar.btnSetTarget = QToolButton(self.toolbar)
        self.toolbar.btnSetTarget.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnSetTarget.setMaximumHeight(maxheight)

        self.toolbar.btnSetTarget.actionSetTarget = QAction("Set Target", self.toolbar)
        self.toolbar.btnSetTarget.actionSetTarget.triggered.connect(lambda: self.set_target())
        self.toolbar.btnSetTarget.actionSetTarget.setIcon(load_icon('set_target.svg'))

        self.toolbar.btnSetTarget.setDefaultAction(self.toolbar.btnSetTarget.actionSetTarget)
        self.toolbar.addWidget(self.toolbar.btnSetTarget)
        # ----

        # ----
        self.toolbar.btnSetAvoid = QToolButton(self.toolbar)
        self.toolbar.btnSetAvoid.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnSetAvoid.setMaximumHeight(maxheight)

        self.toolbar.btnSetAvoid.actionSetAvoid = QAction("Set Avoid", self.toolbar)
        self.toolbar.btnSetAvoid.actionSetAvoid.triggered.connect(lambda: self.set_avoid())
        self.toolbar.btnSetAvoid.actionSetAvoid.setIcon(load_icon('set_avoid.svg'))

        self.toolbar.btnSetAvoid.setDefaultAction(self.toolbar.btnSetAvoid.actionSetAvoid)
        self.toolbar.addWidget(self.toolbar.btnSetAvoid)
        # ----

        # ----
        self.toolbar.btnResetSearcher = QToolButton(self.toolbar)
        self.toolbar.btnResetSearcher.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnResetSearcher.setMaximumHeight(maxheight)

        self.toolbar.btnResetSearcher.actionResetSearcher = QAction("Reset Searchers", self.toolbar)
        self.toolbar.btnResetSearcher.actionResetSearcher.triggered.connect(lambda: self.reset_searchers())
        self.toolbar.btnResetSearcher.actionResetSearcher.setIcon(load_icon('reset_searchers.svg'))

        self.toolbar.btnResetSearcher.setDefaultAction(self.toolbar.btnResetSearcher.actionResetSearcher)
        self.toolbar.addWidget(self.toolbar.btnResetSearcher)
        # ----

        # ----
        self.toolbar.btnStop = QToolButton(self.toolbar)
        self.toolbar.btnStop.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnStop.setMaximumHeight(maxheight)

        self.toolbar.btnStop.actionStop = QAction("Stop", self.toolbar)
        self.toolbar.btnStop.actionStop.triggered.connect(lambda: self.perform_stop())
        self.toolbar.btnStop.actionStop.setIcon(load_icon('stop.svg'))

        self.toolbar.btnStop.setDefaultAction(self.toolbar.btnStop.actionStop)
        self.toolbar.addWidget(self.toolbar.btnStop)
        # ----

        # ----
        self.toolbar.btnReset = QToolButton(self.toolbar)
        self.toolbar.btnReset.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.toolbar.btnReset.setMaximumHeight(maxheight)

        self.toolbar.btnReset.actionReset = QAction("Reset", self.toolbar)
        self.toolbar.btnReset.actionReset.triggered.connect(lambda: self.perform_reset())
        self.toolbar.btnReset.actionReset.setIcon(load_icon('cancel.svg'))

        self.toolbar.btnReset.setDefaultAction(self.toolbar.btnReset.actionReset)
        self.toolbar.addWidget(self.toolbar.btnReset)
        # ----

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self.layout = QVBoxLayout()
        self.layout.addWidget(self.toolbar)
        self.setLayout(self.layout)

    def stateInit(self, arch, state):
        pass

    def stateReset(self):
        pass

    def stateUpdate(self, state):
        pass

    def notifytab(self, newName):
        pass

    def set_uimanager(self, uimanager):
        self._uimanager = uimanager

    def set_target(self):
        if self._uimanager:
            self._uimanager.set_run_target(self._uimanager.bv.file.offset)

    def set_avoid(self):
        if self._uimanager:
            self._uimanager.set_run_avoid(self._uimanager.bv.file.offset)

    def reset_searchers(self):
        if self._uimanager:
            self._uimanager.reset_searchers()

    def perform_start(self):
        if self._uimanager:
            self._uimanager.start_se()

    def perform_step(self):
        if self._uimanager:
            self._uimanager.async_step()

    def perform_dfs(self):
        if self._uimanager:
            self._uimanager.async_run_dfs_searcher()

    def perform_bfs(self):
        if self._uimanager:
            self._uimanager.async_run_bfs_searcher()

    def perform_run_until_branch(self):
        if self._uimanager:
            self._uimanager.async_continue_until_branch()

    def perform_run_until_addr(self):
        if self._uimanager:
            self._uimanager.async_continue_until_address(self._uimanager.bv.file.offset)

    def perform_stop(self):
        if self._uimanager and self._uimanager.running:
            self._uimanager.stop = True

    def perform_reset(self):
        if self._uimanager:
            self._uimanager.async_reset_se()

    def notifyOffsetChanged(self, offset):
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        return True

```

`ui/files_view.py`:

```py
from binaryninja import BackgroundTaskThread
from binaryninja.interaction import (
    show_message_box,
    get_int_input,
)
from binaryninjaui import (
    getMonospaceFont,
    UIActionHandler
)
from PySide6.QtCore import Qt, QMimeData
from PySide6.QtWidgets import (
    QApplication,
    QVBoxLayout,
    QWidget,
    QTableWidget,
    QTableWidgetItem,
    QMenu,
)
from ..expr.bitvector import BVS, BVV

NO_CONSTRAINTS = 0
ASCII_STRING = 1
ALPHANUMERIC_STRING = 2

gFilesPerTab = {}

def _makewidget(parent, val, center=False):
    """ Small helper function that builds a TableWidgetItem and sets up the font the way we want"""
    out = QTableWidgetItem(str(val))
    out.setFlags(Qt.ItemIsEnabled)
    out.setFont(getMonospaceFont(parent))
    if center:
        out.setTextAlignment(Qt.AlignCenter)
    return out

class FilesViewBT(BackgroundTaskThread):
    def __init__(self, msg, bw, callback, pars):
        BackgroundTaskThread.__init__(self, msg, False)
        self.bw = bw
        self.pars = pars
        self.callback = callback

    def run(self):
        self.callback(*self.pars)

class FilesViewData(object):
    def __init__(self):
        self.current_state = None

class FilesView(QWidget):
    def __init__(self, parent):
        QWidget.__init__(self, parent)

        self.parent = parent
        self.data = FilesViewData()
        self.tabname = ""

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self.layout = QVBoxLayout()

        self.table = QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(
            ['Path', 'Size'])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setVisible(False)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(
            self.on_customContextMenuRequested)
        self.table.doubleClicked.connect(self.on_doubleClick)

        self.layout.addWidget(self.table)
        self.setLayout(self.layout)

    def stateReset(self):
        self.data = FilesViewData()
        self.table.setRowCount(0)

    def _init_internal(self):
        self.stateUpdate(self.data.current_state)

    def stateInit(self, arch, state):
        self.data.current_state = state
        self._init_internal()

    def stateUpdate(self, state):
        self.data.current_state = state
        self.table.setRowCount(0)
        if state is None:
            return

        self.table.setRowCount(len(state.os.filesystem))
        for i, path in enumerate(sorted(state.os.filesystem.keys())):
            self.table.setItem(i, 0, _makewidget(self, path))
            self.table.setItem(i, 1, _makewidget(self, state.os.filesystem[path].file_size))

    # right click menu
    def on_customContextMenuRequested(self, pos):
        item = self.table.itemAt(pos)
        if item is None:
            return
        row_idx = item.row()
        menu = QMenu()

        a = menu.addAction("Evaluate upto")
        a.triggered.connect(lambda: self._menuAction_evaluate_upto_buffer(row_idx))
        a = menu.addAction("Evaluate as bytes")
        a.triggered.connect(lambda: self._menuAction_evaluate_buffer(row_idx))
        a = menu.addAction("Evaluate as string")
        a.triggered.connect(lambda: self._menuAction_evaluate_buffer(row_idx, as_string=True))
        a = menu.addAction("Copy evaluated bytes")
        a.triggered.connect(lambda: self._menuAction_copy_evaluated_buffer(row_idx))
        menu.exec_(self.table.viewport().mapToGlobal(pos))

    def _menuAction_evaluate_buffer(self, files_id, as_string=False):
        files = sorted(self.data.current_state.os.filesystem.keys())
        symfile = self.data.current_state.os.filesystem[files[files_id]]
        if symfile.file_size == 0:
            return
        data = symfile.data.load(BVV(0, symfile.data.bits), symfile.file_size)
        dataBytes = self.data.current_state.solver.evaluate(data).as_bytes()

        if not as_string:
            res = dataBytes
            res = repr(res)[2:-1]
        else:
            res = ""
            for el in dataBytes:
                if el == 0:
                    break
                res += chr(el) if el >= 32 and el <= 126 else "."
        show_message_box("evaluate", res)

    def _menuAction_evaluate_upto_buffer(self, files_id):
        files = sorted(self.data.current_state.os.filesystem.keys())
        symfile = self.data.current_state.os.filesystem[files[files_id]]
        if symfile.file_size == 0:
            return
        data = symfile.data.load(BVV(0, symfile.data.bits), symfile.file_size)

        n_eval = get_int_input("How many values (upto) ?", "Number of distinct values")
        if n_eval is None:
            return
        r = ""
        for i, v in enumerate(self.data.current_state.solver.evaluate_upto(data, n_eval)):
            r += "solution %d: %s\n" % (i, hex(v.value))

        show_message_box("evaluate", r)

    def _menuAction_copy_evaluated_buffer(self, files_id):
        files = sorted(self.data.current_state.os.filesystem.keys())
        symfile = self.data.current_state.os.filesystem[files[files_id]]
        if symfile.file_size == 0:
            return
        data = symfile.data.load(BVV(0, symfile.data.bits), symfile.file_size)

        mime = QMimeData()
        res = self.data.current_state.solver.evaluate(data).as_bytes()
        res = '"' + repr(res)[2:-1] + '"'
        mime.setText(res)
        QApplication.clipboard().setMimeData(mime)

    # double click event
    def on_doubleClick(self, item):
        pass

    def contextMenuEvent(self, event):
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        return True

    def notifytab(self, newName):
        if newName != self.tabname:
            if self.tabname is not None:
                gFilesPerTab[self.tabname] = self.data
                self.stateReset()

            if newName in gFilesPerTab:
                self.data = gFilesPerTab[newName]
                self._init_internal()
        self.tabname = newName

```

`ui/memory_view.py`:

```py
from binaryninja import BackgroundTaskThread
from binaryninja.interaction import (
    show_message_box,
    get_int_input,
)
from binaryninjaui import (
    UIActionHandler
)
from PySide6 import QtCore
from PySide6.QtCore import QMimeData
from PySide6.QtWidgets import (
    QApplication,
    QVBoxLayout,
    QMenu,
    QWidget,
    QComboBox
)

from ..utility.expr_wrap_util import symbolic, split_bv_in_list
from ..expr.bitvector import BVS, BVV
from .qmemview import QMemView

gMemPerTab = {}

class MemoryViewData(object):
    def __init__(self):
        self.current_state = None
        self.regions       = None

class MemoryView(QWidget):
    def __init__(self, parent):
        QWidget.__init__(self, parent)

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self.tabname  = ""
        self.data     = MemoryViewData()
        self.symb_idx = 0

        self.layout    = QVBoxLayout()
        self.memWidget = QMemView(
            addr=0,
            size=0,
            dataCallback=self._memwidget_callback)
        self.regionSelector = QComboBox()
        self.regionSelector.currentIndexChanged.connect(
            self.regionSelectorChanged)

        self.memWidget.customMenu = self.on_customContextMenuRequested

        self.layout.addWidget(self.regionSelector)
        self.layout.addWidget(self.memWidget)
        self.setLayout(self.layout)

    def regionSelectorChanged(self, i):
        if self.data.current_state is None:
            return
        regions = self.data.current_state.mem.get_regions()
        if i >= len(regions):
            return

        addr, size = regions[i]
        self.memWidget.addr = addr
        self.memWidget.size = size
        self.memWidget.updateScrollbars()
        self.memWidget.viewport().update()

    def stateReset(self):
        self.data = MemoryViewData()
        self.memWidget.addr = 0
        self.memWidget.size = 0
        self.memWidget.updateScrollbars()
        self.memWidget.viewport().update()
        self.regionSelector.clear()

    def setEnabled(self, v):
        self.regionSelector.setEnabled(v)
        self.memWidget.setEnabled(v)

    def setDisabled(self, v):
        self.setEnabled(not v)

    def _init_internal(self):
        self.stateUpdate(self.data.current_state)

    def stateInit(self, arch, state):
        self.data = MemoryViewData()
        self.data.current_state = state
        self._init_internal()

    def stateUpdate(self, state):
        self.data.current_state = state
        if state is None:
            return

        def regionsAreEqual(r1, r2):
            if r1 is None or r2 is None:
                return False
            if len(r1) != len(r2):
                return False
            for t1, t2 in zip(r1, r2):
                if t1 != t2:
                    return False
            return True

        regions = state.mem.get_regions()
        if not regionsAreEqual(self.data.regions, regions):
            self.regionSelector.clear()
            for addr, size in regions:
                self.regionSelector.addItem(
                    "0x%x -> 0x%x" % (addr, addr+size))
            self.data.regions = regions

        if len(regions) > 0 and self.memWidget.size == 0:
            addr, size = regions[0]
            self.memWidget.addr = addr
            self.memWidget.size = size
            self.memWidget.updateScrollbars()
            self.memWidget.viewport().update()

    def _memwidget_callback(self, addr):
        if self.data.current_state is None:
            return "  "
        v = self.data.current_state.mem.load(addr, 1)
        if isinstance(v, BVV):
            return "%02x" % v.value
        return ".."

    def _show_expression(self, address, expr):
        show_message_box("Expression at %s" %
                         hex(address), str(expr.z3obj.sexpr()))

    def _evaluate_with_solver(self, address, expr):
        val = ""
        if not self.data.current_state.solver.symbolic(expr):
            new_expr = self.data.current_state.solver.evaluate(expr)
            self.data.current_state.mem.store(address, new_expr)
            self.stateUpdate(self.data.current_state)
            show_message_box(
                "Expression at %s" % hex(address),
                "The value was indeed concrete! State modified"
            )
        else:
            val = self.data.current_state.solver.evaluate(expr).value
            show_message_box("Value at %s (with solver):" %
                             hex(address), hex(val))

    def _evaluate_upto_with_solver(self, address, expr):
        if not self.data.current_state.solver.symbolic(expr):
            new_expr = self.data.current_state.solver.evaluate(expr)
            self.data.current_state.mem.store(address, new_expr)
            self.stateUpdate(self.data.current_state)
            show_message_box(
                "Expression at %s" % hex(address),
                "The value was indeed concrete! State modified"
            )
        else:
            n_eval = get_int_input("How many values (upto) ?", "Number of distinct values")
            if n_eval is None:
                return
            r = ""
            for i, v in enumerate(self.data.current_state.solver.evaluate_upto(expr, n_eval)):
                r += "solution %d: %s\n" % (i, hex(v.value))

            show_message_box("Value at %s (with solver):" %
                             hex(address), r)

    def _concretize(self, address, expr):
        new_expr = self.data.current_state.solver.evaluate(expr)
        self.data.current_state.mem.store(address, new_expr)
        self.data.current_state.solver.add_constraints(
            expr == new_expr
        )

    def _concretize_ascii_str(self, address, expr):
        extra_constraints = []
        for i in range(expr.size // 8):
            b = expr.Extract(i*8+7, i*8)
            extra_constraints.extend(
                [b <= 0x7e, b >= 0x20]
            )
        if not self.data.current_state.solver.satisfiable(
            extra_constraints
        ):
            show_message_box(
                "Info", "The selected memory is not an ascii str (unsat)")
            return
        new_expr = self.data.current_state.solver.evaluate(
            expr, extra_constraints
        )
        self.data.current_state.mem.store(address, new_expr)
        self.data.current_state.solver.add_constraints(
            expr == new_expr
        )
        self.stateUpdate(self.data.current_state)

    def _make_symbolic(self, address, size):
        buff = BVS("b_ui_mem_%d" % self.symb_idx, size * 8)
        self.data.current_state.mem.store(address, buff)
        self.data.current_state.symbolic_buffers.append(
            (buff, address, "")
        )
        self.symb_idx += 1
        self.stateUpdate(self.data.current_state)

    def _copy_big_endian(self, expr):
        mime = QMimeData()
        mime.setText(hex(expr.value))
        QApplication.clipboard().setMimeData(mime)

    def _copy_little_endian(self, expr):
        mime = QMimeData()
        expr_bytes = split_bv_in_list(expr, 8)
        res = 0
        i = 0
        for el in reversed(expr_bytes):
            res += el.value << i*8
            i += 1
        mime.setText(hex(res))
        QApplication.clipboard().setMimeData(mime)

    def _copy_string(self, expr):
        mime = QMimeData()
        expr_bytes = split_bv_in_list(expr, 8)
        res = ""
        for el in reversed(expr_bytes):
            res += chr(el.value) if el.value >= 32 and el.value <= 126 else "."

        mime.setText(res)
        QApplication.clipboard().setMimeData(mime)

    def _copy_expression(self, expr):
        mime = QMimeData()
        mime.setText(str(expr.z3obj.sexpr()))
        QApplication.clipboard().setMimeData(mime)

    def _copy_binary(self, expr):
        mime = QMimeData()
        expr_bytes = split_bv_in_list(expr, 8)
        res = "\""
        for el in reversed(expr_bytes):
            res += "\\x{:02x}".format(el.value)
        res += "\""

        mime.setText(res)
        QApplication.clipboard().setMimeData(mime)

    def on_customContextMenuRequested(self):
        if self.data.current_state is None:
            return
        menu = QMenu(self)

        selStart, selSize = self.memWidget.getSelection()
        if selSize == 0:
            return

        if not self.data.current_state.mem.is_mapped(
                selStart):
            return
        if not self.data.current_state.mem.is_mapped(
                selStart + selSize):
            return

        expr = self.data.current_state.mem.load(
            selStart,
            selSize
        )

        if symbolic(expr):
            a = menu.addAction("Show expression")
            a.triggered.connect(lambda: self._show_expression(selStart, expr))
            a = menu.addAction("Evaluate with solver")
            a.triggered.connect(lambda: self._evaluate_with_solver(selStart, expr))
            a = menu.addAction("Evaluate with solver (upto)")
            a.triggered.connect(lambda: self._evaluate_upto_with_solver(selStart, expr))
            a = menu.addAction("Concretize")
            a.triggered.connect(lambda: self._concretize(selStart, expr))
            a = menu.addAction("Concretize (ascii str)")
            a.triggered.connect(lambda: self._concretize_ascii_str(selStart, expr))
            a = menu.addAction("Copy expression")
            a.triggered.connect(lambda: self._copy_expression(expr))
        else:
            a = menu.addAction("Make symbolic")
            a.triggered.connect(lambda: self._make_symbolic(selStart, selSize))
            copy_menu = menu.addMenu("Copy...")
            a = copy_menu.addAction("Copy Little Endian")
            a.triggered.connect(lambda: self._copy_little_endian(expr))
            a = copy_menu.addAction("Copy Big Endian")
            a.triggered.connect(lambda: self._copy_big_endian(expr))
            a = copy_menu.addAction("Copy String")
            a.triggered.connect(lambda: self._copy_string(expr))
            a = copy_menu.addAction("Copy Binary")
            a.triggered.connect(lambda: self._copy_binary(expr))
        return menu

    def notifyOffsetChanged(self, offset):
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        return True

    def notifytab(self, newName):
        if newName != self.tabname:
            if self.tabname is not None:
                self.data.regions = None
                gMemPerTab[self.tabname] = self.data
                self.stateReset()

            if newName in gMemPerTab:
                self.data = gMemPerTab[newName]
                self._init_internal()
        self.tabname = newName

```

`ui/qmemview.py`:

```py
from PySide6.QtCore import Qt, QRectF
from PySide6.QtGui import QFontMetrics, QFontDatabase, QMouseEvent, QPainter, QPen, QColor, QPalette
from PySide6.QtWidgets import QAbstractScrollArea

from binaryninjaui import ThemeColor, getThemeColor

import math

class QMemView(QAbstractScrollArea):
    ROW_WIDTH      = 16 # amount of bytes per row
    CHARS_PER_WORD = 2

    COLOR_ADDR      = getThemeColor(ThemeColor.AddressColor)
    COLOR_LINE      = getThemeColor(ThemeColor.WhiteStandardHighlightColor)
    COLOR_BYTES     = getThemeColor(ThemeColor.OpcodeColor)
    HIGHLIGHT_COLOR = getThemeColor(ThemeColor.BackgroundHighlightLightColor)

    HIGHLIGHT_ON  = 1
    HIGHLIGHT_OFF = 2

    def __init__(self, addr, size, dataCallback, parent=None):
        super().__init__(parent)
        self.addr         = addr
        self.size         = size
        self.dataCallback = dataCallback
        self.customMenu   = None
        self.enabled      = True

        self.highligting    = QMemView.HIGHLIGHT_OFF
        self.selectionStart = -1
        self.selectionEnd   = -1

        self.setFont()
        self.updateScrollbars()

    def setEnabled(self, v):
        self.enabled = v

    def setDisabled(self, v):
        self.setEnabled(not v)

    def getSelection(self):
        if self.selectionStart == self.selectionEnd:
            return 0, 0
        return self.addr + min(self.selectionStart, self.selectionEnd), abs(self.selectionEnd-self.selectionStart)

    def setFont(self):
        self.font        = QFontDatabase.systemFont(QFontDatabase.FixedFont)
        self.fontMetrics = QFontMetrics(self.font)

        self.fontWidth  = self.fontMetrics.horizontalAdvance('X')
        self.fontHeight = self.fontMetrics.height()
        super().setFont(self.font)

    def padding(self):
        """ Padding space """
        return self.fontWidth / 2

    def addrline(self):
        """ The X coordinate of the line between the addresses and the hexdump """
        return 17 * self.fontWidth + self.padding()

    def hexdumpCoordinate(self):
        """ The X coordinate of the hexdump """
        return self.addrline() + self.padding()

    def rightborder(self):
        """ The X coordinate of the right border """
        elements = QMemView.ROW_WIDTH * (QMemView.CHARS_PER_WORD + 1) - 1
        return self.hexdumpCoordinate() + elements * self.fontWidth + self.padding()

    def updateScrollbars(self):
        maxval = self.size / QMemView.ROW_WIDTH - self.viewport().height() / self.fontHeight + 2

        self.verticalScrollBar().setMaximum(max(0, maxval))
        self.horizontalScrollBar().setMaximum(
            max(0, (self.rightborder() - self.viewport().width()) / self.fontWidth))

    def isSelected(self, index):
        if index >= self.size:
            return False
        if self.selectionStart == self.selectionEnd:
            return False
        if self.selectionStart < self.selectionEnd:
            return index >= self.selectionStart and index < self.selectionEnd
        return index >= self.selectionEnd and index < self.selectionStart

    def paintEvent(self, event):
        painter = QPainter(self.viewport())
        painter.translate(
            -self.horizontalScrollBar().value() * self.fontWidth, 0)

        charsPerRow = QMemView.ROW_WIDTH
        row         = self.fontHeight
        offset      = self.verticalScrollBar().value() * charsPerRow

        while row + self.fontHeight < self.height() and offset < self.size:
            # Draw the address
            addr    = self.addr + offset
            addrStr = "%016x" % addr
            painter.setPen(QPen(QMemView.COLOR_ADDR))
            painter.drawText(self.padding(), row, addrStr)

            # Draw the bytes
            for i in range(QMemView.ROW_WIDTH):
                boff = offset + i
                if boff >= self.size:
                    break

                drawCoordinate = self.hexdumpCoordinate() + (i * (QMemView.CHARS_PER_WORD + 1) * self.fontWidth)
                drawText       = self.dataCallback(self.addr + boff) if self.dataCallback is not None else "  "
                assert isinstance(drawText, str) and len(drawText) == 2

                if self.isSelected(boff):
                    colorGroup = QPalette.ColorGroup.Active if self.hasFocus() else QPalette.ColorGroup.Inactive
                    painter.fillRect(
                        QRectF(drawCoordinate, row-self.fontHeight+self.padding(), self.fontWidth*2, self.fontHeight),
                        QMemView.HIGHLIGHT_COLOR
                    )
                    if (boff+1) % QMemView.ROW_WIDTH != 0 and self.isSelected(boff+1):
                        painter.fillRect(
                            QRectF(drawCoordinate+self.fontWidth*2, row-self.fontHeight+self.padding(), self.fontWidth, self.fontHeight),
                            QMemView.HIGHLIGHT_COLOR
                        )

                painter.setPen(QPen(QMemView.COLOR_BYTES))
                painter.drawText(drawCoordinate, row, drawText)

            offset += charsPerRow
            row    += self.fontHeight

        # Draw the address line
        painter.setPen(QPen(QMemView.COLOR_LINE))
        painter.drawLine(self.addrline(), 0, self.addrline(), self.height())

    def pixelToOffset(self, x, y):
        x  = max(self.addrline()+self.padding(), min(x, self.rightborder()))
        x -= self.addrline()
        x  = x / self.fontWidth

        y /= self.fontHeight
        x /= QMemView.CHARS_PER_WORD + 1

        x = math.floor(x)
        y = math.floor(y)
        return y * QMemView.ROW_WIDTH + x + self.verticalScrollBar().value() * QMemView.ROW_WIDTH

    def mousePressEvent(self, event: QMouseEvent):
        if not self.enabled:
            return

        if event.buttons() & Qt.LeftButton:
            if self.highligting == QMemView.HIGHLIGHT_ON:
                self.highligting = QMemView.HIGHLIGHT_OFF
                self.selectionStart = -1
                self.selectionEnd   = -1

            else:
                self.highligting = QMemView.HIGHLIGHT_ON

                x = event.x() + self.horizontalScrollBar().value() * self.fontWidth
                y = event.y()
                off = self.pixelToOffset(x, y)
                self.selectionStart = off
                self.selectionEnd   = off+1

            self.viewport().update()
        if self.customMenu is not None and event.buttons() & Qt.RightButton:
            menu = self.customMenu()
            menu.exec_(self.mapToGlobal(event.pos()))

    def mouseMoveEvent(self, event: QMouseEvent):
        if not self.enabled:
            return

        if self.highligting != QMemView.HIGHLIGHT_ON:
            return

        x = event.x() + self.horizontalScrollBar().value() * self.fontWidth
        y = event.y()
        off = self.pixelToOffset(x, y)
        self.selectionEnd = off+1
        self.viewport().update()

    def resizeEvent(self, event):
        self.updateScrollbars()

```

`ui/registers_view.py`:

```py
from binaryninja.interaction import (
    show_message_box,
    get_int_input,
    get_choice_input
)
from binaryninjaui import (
    getMonospaceFont,
    UIActionHandler,
    getThemeColor,
    ThemeColor
)
from PySide6.QtCore import (
    Qt,
    QMimeData
)
from PySide6.QtGui import (
    QBrush,
)
from PySide6.QtWidgets import (
    QApplication,
    QVBoxLayout,
    QWidget,
    QTableWidget,
    QTableWidgetItem,
    QMenu
)

from ..utility.expr_wrap_util import symbolic
from ..expr.bitvector import BVS, BVV

def _makewidget(parent, val, center=False):
    out = QTableWidgetItem(str(val))
    out.setFlags(Qt.ItemIsEnabled)
    out.setFont(getMonospaceFont(parent))
    if center:
        out.setTextAlignment(Qt.AlignCenter)
    return out

gRegsPerTab = {}

class RegisterData(object):
    def __init__(self):
        self.arch          = None
        self.current_state = None
        self.symb_idx      = 0
        self.reg_to_index  = dict()
        self.index_to_reg  = dict()
        self.reg_cache     = dict()

class RegisterWidget(QWidget):
    dirty_color      = QBrush(getThemeColor(ThemeColor.OrangeStandardHighlightColor))
    expression_color = QBrush(getThemeColor(ThemeColor.RedStandardHighlightColor))
    symbolic_color   = QBrush(getThemeColor(ThemeColor.BlueStandardHighlightColor))
    no_color         = QBrush(getThemeColor(ThemeColor.WhiteStandardHighlightColor))

    def __init__(self, parent):
        QWidget.__init__(self, parent)
        self.tabname = ""
        self.data    = RegisterData()

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self.layout = QVBoxLayout()

        # Set up register table
        self.table = QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(['Register', 'Value'])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setVisible(False)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.on_customContextMenuRequested)
        self.table.doubleClicked.connect(self.on_doubleClick)

        self.layout.addWidget(self.table)
        self.setLayout(self.layout)

    def stateReset(self):
        self.data = RegisterData()
        self.table.setRowCount(0)

    def _init_internal(self):
        if self.data.arch is None:
            return
        regs = self.data.arch.reg_names()

        self.table.setRowCount(len(regs))
        for i, reg in enumerate(regs):
            self.data.reg_to_index[reg] = i
            self.data.index_to_reg[i] = reg
            self.table.setItem(i, 0, _makewidget(self, reg))
            self.table.setItem(i, 1, _makewidget(self, ""))
        self.stateUpdate(self.data.current_state)

    def stateInit(self, arch, state):
        self.data.arch = arch
        self.data.current_state = state
        self._init_internal()

    def set_reg_value(self, reg, value, color=None):
        assert self.data.arch is not None

        idx = self.data.reg_to_index[reg]

        if symbolic(value):
            if isinstance(value, BVS):
                val_str = value.name
                if color is None:
                    color = RegisterWidget.symbolic_color
            else:
                val_str = "< symbolic expression >"
                if color is None:
                    color = RegisterWidget.expression_color
        else:
            val_str = "0x{obj:0{width}x}".format(
                obj=value.value,
                width=(value.size+3) // 4
            )

        self.data.reg_cache[reg] = val_str
        table_item = self.table.item(idx, 1)
        table_item.setText(val_str)
        if color is not None:
            table_item.setForeground(color)
        else:
            table_item.setForeground(self.no_color)

    def stateUpdate(self, state):
        self.data.current_state = state
        for reg in self.data.reg_to_index:
            val = getattr(state.regs, reg)
            self.set_reg_value(reg, val)

    # right click menu
    def on_customContextMenuRequested(self, pos):
        item = self.table.itemAt(pos)
        if item is None:
            return
        row_idx = item.row()

        if self.data.index_to_reg[row_idx] == self.data.arch.getip_reg():
            return

        expr = getattr(self.data.current_state.regs, self.data.index_to_reg[row_idx])

        menu = QMenu()
        show_reg_expr = menu.addAction(
            "Show reg expression") if not isinstance(expr, BVV) else None
        make_reg_symb = menu.addAction(
            "Make reg symbolic") if isinstance(expr, BVV) else None
        set_reg_value = menu.addAction("Set reg value")
        eval_with_sol = menu.addAction(
            "Evaluate with solver") if not isinstance(expr, BVV) else None
        eval_upto_with_sol = menu.addAction(
            "Evaluate upto with solver") if not isinstance(expr, BVV) else None
        concretize = menu.addAction(
            "Concretize") if not isinstance(expr, BVV) else None
        copy = menu.addAction("Copy to clipboard") if not isinstance(
            expr, BVS) else None
        bind_to_buffer = menu.addAction("Bind to symbolic buffer")
        make_pointer = menu.addAction("Make pointer")

        action = menu.exec_(self.table.viewport().mapToGlobal(pos))
        if action is None:
            return

        if action == bind_to_buffer:
            buffer_names = [
                b[0].name for b in self.data.current_state.symbolic_buffers]
            if len(buffer_names) == 0:
                return
            buff_id = get_choice_input(
                "Select a buffer", "choices", buffer_names)
            address = self.data.current_state.symbolic_buffers[buff_id][1]
            buff_p = BVV(address,
                         self.data.current_state.arch.bits())
            setattr(self.data.current_state.regs,
                    self.data.index_to_reg[row_idx],
                    buff_p)
            self.set_reg_value(
                self.data.index_to_reg[row_idx], buff_p, RegisterWidget.dirty_color)
        elif action == make_pointer:
            size = get_int_input("Enter the size in bytes", "Size")
            ptr = BVV(self.data.current_state.mem.allocate(size), self.data.current_state.arch.bits())
            setattr(self.data.current_state.regs,
                    self.data.index_to_reg[row_idx],
                    ptr)
            self.set_reg_value(
                self.data.index_to_reg[row_idx], ptr)
        elif action == show_reg_expr:
            show_message_box("Reg Expression", str(expr.z3obj.sexpr()))
        elif action == make_reg_symb:
            new_expr = BVS('symb_injected_through_ui_%d' %
                           self.data.symb_idx, expr.size)
            setattr(self.data.current_state.regs,
                    self.data.index_to_reg[row_idx], new_expr)
            self.set_reg_value(
                self.data.index_to_reg[row_idx], new_expr, RegisterWidget.dirty_color)
            self.data.symb_idx += 1
        elif action == set_reg_value:
            self.on_doubleClick(item)
        elif action == eval_with_sol:
            expr = getattr(self.data.current_state.regs, self.data.index_to_reg[row_idx])
            if not self.data.current_state.solver.symbolic(expr):
                new_expr = self.data.current_state.solver.evaluate(expr)
                setattr(self.data.current_state.regs,
                        self.data.index_to_reg[row_idx], new_expr)
                self.set_reg_value(
                    self.data.index_to_reg[row_idx], new_expr, RegisterWidget.dirty_color)
                show_message_box(
                    "Reg Value (with solver)",
                    "The value was indeed concrete! State modified"
                )
            else:
                show_message_box(
                    "Reg Value (with solver)",
                    hex(self.data.current_state.solver.evaluate(expr).value)
                )
        elif action == eval_upto_with_sol:
            expr = getattr(self.data.current_state.regs, self.data.index_to_reg[row_idx])
            if not self.data.current_state.solver.symbolic(expr):
                new_expr = self.data.current_state.solver.evaluate(expr)
                setattr(self.data.current_state.regs,
                        self.data.index_to_reg[row_idx], new_expr)
                self.set_reg_value(
                    self.data.index_to_reg[row_idx], new_expr, RegisterWidget.dirty_color)
                show_message_box(
                    "Reg Value (with solver)",
                    "The value was indeed concrete! State modified"
                )
            else:
                n_eval = get_int_input("How many values (upto) ?", "Number of distinct values")
                if n_eval is None:
                    return
                r = ""
                for i, v in enumerate(self.data.current_state.solver.evaluate_upto(expr, n_eval)):
                    r += "solution %d: %s\n" % (i, hex(v.value))
                show_message_box(
                    "Reg Value (with solver)",
                    r
                )
        elif action == concretize:
            expr = getattr(self.data.current_state.regs, self.data.index_to_reg[row_idx])
            new_expr = self.data.current_state.solver.evaluate(expr)
            res = get_choice_input(
                "Concretize %s to %s?" % (
                    self.data.index_to_reg[row_idx], hex(new_expr.value)),
                "Concretize",
                ["Yes", "No"]
            )
            if res == 0:
                setattr(self.data.current_state.regs,
                        self.data.index_to_reg[row_idx], new_expr)
                self.data.current_state.solver.add_constraints(
                    expr == new_expr
                )
                self.set_reg_value(
                    self.data.index_to_reg[row_idx], new_expr, RegisterWidget.dirty_color)
        elif action == copy:
            mime = QMimeData()
            if isinstance(expr, BVV):
                mime.setText(hex(expr.value))
            else:
                mime.setText(str(expr.z3obj.sexpr()))
            QApplication.clipboard().setMimeData(mime)

    # double click event
    def on_doubleClick(self, item):
        row_idx = item.row()
        if self.data.index_to_reg[row_idx] == self.data.arch.getip_reg():
            return

        old_expr = getattr(self.data.current_state.regs, self.data.index_to_reg[row_idx])
        new_val = get_int_input("value for %s" %
                                self.data.index_to_reg[row_idx], "Set Reg")
        if new_val is None:
            return
        new_expr = BVV(new_val, old_expr.size)
        setattr(self.data.current_state.regs, self.data.index_to_reg[row_idx], new_expr)
        self.set_reg_value(
            self.data.index_to_reg[row_idx], new_expr, RegisterWidget.dirty_color)

    def notifyOffsetChanged(self, offset):
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        return True

    def notifytab(self, newName):
        if newName != self.tabname:
            if self.tabname is not None:
                gRegsPerTab[self.tabname] = self.data
                self.stateReset()

            if newName in gRegsPerTab:
                self.data = gRegsPerTab[newName]
                self._init_internal()
        self.tabname = newName

    def contextMenuEvent(self, event):
        self.m_contextMenuManager.show(self.m_menu, self.actionHandler)

```

`ui/seninja_widget.py`:

```py
from binaryninjaui import (
    SidebarWidget,
    SidebarWidgetType,
    SidebarWidgetLocation,
    SidebarContextSensitivity,
    getThemeColor,
    ThemeColor
)
from PySide6 import QtCore
from PySide6.QtGui import (
    QPainter,
    QPixmap,
    QBrush,
    QImage,
    QIcon
)
from PySide6.QtSvg import QSvgRenderer
from PySide6.QtWidgets import (
    QVBoxLayout,
    QTabWidget
)

from .files_view import FilesView
from .registers_view import RegisterWidget
from .control_view import ControlView
from .state_view import StateView
from .buffer_view import BufferView
from .memory_view import MemoryView
from ..globals import uimanager_registry

import os

def load_icon(fname_icon):
    path_this_file = os.path.abspath(__file__)
    path_this_dir = os.path.dirname(path_this_file)
    path_icons = os.path.join(path_this_dir, '..', 'media', 'icons')
    path_icon = os.path.join(path_icons, fname_icon)

    pixmap = QPixmap(path_icon)

    icon = QIcon()
    icon.addPixmap(pixmap, QIcon.Normal)
    icon.addPixmap(pixmap, QIcon.Disabled)
    return icon

class SENinjaWidget(SidebarWidget):
    updateStateSignal = QtCore.Signal(object)
    initSignal        = QtCore.Signal(object, object)
    resetSignal       = QtCore.Signal()

    dirty_color      = QBrush(getThemeColor(ThemeColor.OrangeStandardHighlightColor))
    expression_color = QBrush(getThemeColor(ThemeColor.RedStandardHighlightColor))
    symbolic_color   = QBrush(getThemeColor(ThemeColor.BlueStandardHighlightColor))
    no_color         = QBrush(getThemeColor(ThemeColor.WhiteStandardHighlightColor))

    def __init__(self, name, frame, data):
        SidebarWidget.__init__(self, name)
        self.updateStateSignal.connect(self.stateUpdate)
        self.initSignal.connect(self.stateInit)
        self.resetSignal.connect(self.stateReset)

        self._current_bv = None
        self._current_uimanager = None

        self.tabs = QTabWidget(frame)
        self.regs = RegisterWidget(frame)
        self.controls = ControlView(frame)
        self.states = StateView(frame)
        self.buffers = BufferView(frame)
        self.files = FilesView(frame)
        self.mem = MemoryView(frame)

        self.tabs.addTab(self.regs, "Registers")
        self.tabs.addTab(self.mem, "Memory")
        self.tabs.addTab(self.states, "States")
        self.tabs.addTab(self.buffers, "Buffers")
        self.tabs.addTab(self.files, "Files")

        self.layout = QVBoxLayout()
        self.layout.addWidget(self.controls)
        self.layout.addWidget(self.tabs)
        self.layout.setSpacing(0)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(self.layout)

    def stateUpdate(self, state):
        self.regs.stateUpdate(state)
        self.states.stateUpdate(state)
        self.buffers.stateUpdate(state)
        self.controls.stateUpdate(state)
        self.files.stateUpdate(state)
        self.mem.stateUpdate(state)

    def stateInit(self, arch, state):
        self.regs.stateInit(arch, state)
        self.states.stateInit(arch, state)
        self.buffers.stateInit(arch, state)
        self.controls.stateInit(arch, state)
        self.files.stateInit(arch, state)
        self.mem.stateInit(arch, state)

    def stateReset(self):
        self.regs.stateReset()
        self.states.stateReset()
        self.buffers.stateReset()
        self.controls.stateReset()
        self.files.stateReset()
        self.mem.stateReset()

    def notifyViewChanged(self, view_frame):
        newName = None
        self._current_bv = None
        self._current_uimanager = None

        if view_frame is not None:
            view_interface = view_frame.getCurrentViewInterface()
            if view_interface is not None:
                bv = view_interface.getData()
                if bv and bv.file:
                    newName = bv.file.session_id
                    self._current_bv = bv
                    self._current_uimanager = uimanager_registry.get_or_create(newName)

        self.controls.set_uimanager(self._current_uimanager)
        self.states.set_uimanager(self._current_uimanager)

        self.regs.notifytab(newName)
        self.states.notifytab(newName)
        self.buffers.notifytab(newName)
        self.controls.notifytab(newName)
        self.files.notifytab(newName)
        self.mem.notifytab(newName)

    def disableAll(self):
        self.regs.setDisabled(True)
        self.states.setDisabled(True)
        self.buffers.setDisabled(True)
        self.files.setDisabled(True)
        self.mem.setDisabled(True)

    def enableAll(self):
        self.regs.setEnabled(True)
        self.states.setEnabled(True)
        self.buffers.setEnabled(True)
        self.files.setEnabled(True)
        self.mem.setEnabled(True)

class SENinjaWidgetType(SidebarWidgetType):
    name = "SENinja"

    def __init__(self):
        path_this_file = os.path.abspath(__file__)
        path_this_dir = os.path.dirname(path_this_file)
        path_icons = os.path.join(path_this_dir, '..', 'media', 'icons')
        path_icon = os.path.join(path_icons, "pi.svg")

        renderer = QSvgRenderer(path_icon)
        icon = QImage(56, 56, QImage.Format_ARGB32)
        icon.fill(0xaaA08080)

        p = QPainter(icon)
        renderer.render(p)
        p.end()
        SidebarWidgetType.__init__(self, icon, SENinjaWidgetType.name)

    def createWidget(self, frame, data):
        # This callback is called when a widget needs to be created for a given context. Different
        # widgets are created for each unique BinaryView. They are created on demand when the sidebar
        # widget is visible and the BinaryView becomes active.
        return SENinjaWidget(SENinjaWidgetType.name, frame, data)

    def defaultLocation(self):
        # Default location in the sidebar where this widget will appear
        return SidebarWidgetLocation.LeftContent

    def contextSensitivity(self):
        # Context sensitivity controls which contexts have separate instances of the sidebar widget.
        # Using `contextSensitivity` instead of the deprecated `viewSensitive` callback allows sidebar
        # widget implementations to reduce resource usage.

        # This example widget uses a single instance and detects view changes.
        return SidebarContextSensitivity.SelfManagedSidebarContext

```

`ui/state_view.py`:

```py
from binaryninjaui import (
    getMonospaceFont,
    getThemeColor,
    ThemeColor
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QBrush
from PySide6.QtWidgets import (
    QVBoxLayout,
    QWidget,
    QTableWidget,
    QTableWidgetItem,
)

gStatesPerTab = {}

def _makewidget(parent, val, center=False):
    out = QTableWidgetItem(str(val))
    out.setFlags(Qt.ItemIsEnabled)
    out.setFont(getMonospaceFont(parent))
    if center:
        out.setTextAlignment(Qt.AlignCenter)
    return out

class StateViewData(object):
    def __init__(self):
        self.current_state = None
        self.index_to_state_address = dict()
        self.state_collection = []
        self.active_idx = None

class StateView(QWidget):
    def __init__(self, parent):
        QWidget.__init__(self, parent)

        self.parent = parent
        self.tabname = ""
        self.data = StateViewData()
        self._uimanager = None

        # Set up register table
        self.table = QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(['Status', 'State'])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setVisible(False)

        self.active_state_color = QBrush(getThemeColor(ThemeColor.GreenStandardHighlightColor))
        self.defered_state_color = QBrush(getThemeColor(ThemeColor.RedStandardHighlightColor))
        self.unsat_state_color = QBrush(getThemeColor(ThemeColor.OrangeStandardHighlightColor))
        self.error_state_color = QBrush(getThemeColor(ThemeColor.RedStandardHighlightColor))
        self.avoided_state_color = QBrush(getThemeColor(ThemeColor.MagentaStandardHighlightColor))
        self.exited_state_color = QBrush(getThemeColor(ThemeColor.BlackStandardHighlightColor))
        self.item_color = QBrush(getThemeColor(ThemeColor.BlackStandardHighlightColor))
        self.item_color_inverted = QBrush(getThemeColor(ThemeColor.WhiteStandardHighlightColor))

        self.table.doubleClicked.connect(self.on_doubleClick)

        self.layout = QVBoxLayout()
        self.layout.addWidget(self.table)
        self.setLayout(self.layout)

    def stateReset(self):
        self.data = StateViewData()
        self.table.setRowCount(0)

    def _init_internal(self):
        self.set_state_table(self.data.current_state)

    def stateInit(self, arch, state):
        self.stateUpdate(state)

    def stateUpdate(self, state):
        self.data.current_state = state
        self._init_internal()

    def set_uimanager(self, uimanager):
        self._uimanager = uimanager

    def set_state_table(self, state):
        if not self._uimanager or not self._uimanager.executor:
            return

        STATE_ACTIVE = 0
        STATE_DEFERRED = 1
        STATE_UNSAT = 2
        STATE_ERROR = 3
        STATE_AVOIDED = 4
        STATE_EXITED = 5
        self.data.state_collection.clear()

        deferred_states = self._uimanager.executor.fringe.deferred
        unsat_states = self._uimanager.executor.fringe.get_unsat_states
        error_states = self._uimanager.executor.fringe.get_error_states
        avoided_states = self._uimanager.executor.fringe.get_avoided_states
        exited_states = self._uimanager.executor.fringe.get_exited_states

        rowCount = len(deferred_states)+len(unsat_states)+len(error_states)+len(avoided_states)+len(exited_states)
        if state:
            rowCount += 1
        self.table.setRowCount(rowCount)
        if state:
            self.data.state_collection.append((state,STATE_ACTIVE))

        for idx, a in enumerate(deferred_states):
            self.data.state_collection.append((a,STATE_DEFERRED))
        for idx, a in enumerate(unsat_states):
            self.data.state_collection.append((a,STATE_UNSAT))
        for idx, a in enumerate(error_states):
            self.data.state_collection.append((a[1],STATE_ERROR))
        for idx, a in enumerate(avoided_states):
            self.data.state_collection.append((a,STATE_AVOIDED))
        for idx, a in enumerate(exited_states):
            self.data.state_collection.append((a,STATE_EXITED))
        
        self.data.state_collection = sorted(self.data.state_collection, key=lambda t: t[0].get_ip())

        for idx, (a,s) in enumerate(self.data.state_collection):
            if s==STATE_DEFERRED:
                state_colour = self.defered_state_color
                state_text_colour = self.item_color
                state_status = "Deferred"
            if s==STATE_ACTIVE:
                state_colour = self.active_state_color
                state_text_colour = self.item_color
                state_status = "Active"
                self.data.active_idx = idx
            if s==STATE_UNSAT:
                state_colour = self.unsat_state_color
                state_text_colour = self.item_color
                state_status = "UnSat"
            if s==STATE_ERROR:
                state_colour = self.error_state_color
                state_text_colour = self.item_color
                state_status = "Errored"
            if s==STATE_AVOIDED:
                state_colour = self.avoided_state_color
                state_text_colour = self.item_color
                state_status = "Avoided"
            if s==STATE_EXITED:
                state_colour = self.exited_state_color
                state_text_colour = self.item_color_inverted
                state_status = "Exited"

            self.table.setItem(idx, 0, _makewidget(self, state_status))
            self.table.setItem(idx, 1, _makewidget(self, f"State_{hex(a.get_ip())}"))
            self.table.item(idx, 0).setBackground(state_colour)
            self.table.item(idx, 1).setBackground(state_colour)
            self.table.item(idx, 0).setForeground(state_text_colour)
            self.table.item(idx, 1).setForeground(state_text_colour)
            self.data.index_to_state_address[idx] = a.get_ip()    

    # double click event
    def on_doubleClick(self, item):
        row_idx = item.row()
        if row_idx == self.data.active_idx:
            return
        state_addr = self.data.index_to_state_address[row_idx]
        if self._uimanager:
            self._uimanager.async_change_current_state(state_addr)

    def notifyOffsetChanged(self, offset):
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        return True

    def notifytab(self, newName):
        if newName != self.tabname:
            if self.tabname is not None:
                gStatesPerTab[self.tabname] = self.data
                self.stateReset()

            if newName in gStatesPerTab:
                self.data = gStatesPerTab[newName]
                self._init_internal()
        self.tabname = newName

```

`ui/ui_manager.py`:

```py
import threading
import time
import sys

from binaryninja.interaction import get_choice_input
from binaryninja import (
    enums,
    BackgroundTaskThread,
)
from binaryninjaui import UIContext

from .seninja_widget import SENinjaWidgetType
from .argv_form import GetArgvDialog
from ..utility.bninja_util import get_address_after_merge
from ..utility.exceptions import SENinjaError
from ..sym_executor import SymbolicExecutor
from ..multipath import searcher
from ..globals import logger

class UIBackgroundTask(BackgroundTaskThread):
    def __init__(self, bv, msg, callback):
        BackgroundTaskThread.__init__(self, msg, False)
        self.bv       = bv
        self.callback = callback
        self._i       = 0

    def run(self):
        self.bv.update_analysis_and_wait()
        self.callback(self)

class UIManager(object):
    NO_COLOR = enums.HighlightStandardColor(0)
    CURR_STATE_COLOR = enums.HighlightStandardColor.GreenHighlightColor
    DEFERRED_STATE_COLOR = enums.HighlightStandardColor.RedHighlightColor
    ERRORED_STATE_COLOR = enums.HighlightStandardColor.BlackHighlightColor
    HIGHLIGHTED_HISTORY_COLOR = enums.HighlightStandardColor.YellowHighlightColor

    def get_target_tt(self, bv):
        if self._target_tag_type is not None:
            return self._target_tag_type
        self._target_tag_type = "SENinja Target"
        bv.create_tag_type(self._target_tag_type, "O")
        return self._target_tag_type

    def get_avoid_tt(self, bv):
        if self._avoid_tag_type is not None:
            return self._avoid_tag_type
        self._avoid_tag_type = "SENinja Avoid"
        bv.create_tag_type(self._avoid_tag_type, "X")
        return self._avoid_tag_type

    @property
    def bv(self):
        if self._bv is not None:
            return self._bv
        ctx = UIContext.activeContext()
        if ctx is None:
            return None
        view = ctx.getCurrentView()
        if view is None:
            return None
        self._bv = view.getData()
        return self._bv

    @property
    def widget(self):
        if self._widget is not None:
            return self._widget
        ctx = UIContext.activeContext()
        if ctx is None:
            return None
        view_frame = ctx.getCurrentViewFrame()
        if view_frame is None:
            return None
        sidebar = view_frame.getSidebar()
        if sidebar is None:
            return None
        self._widget = sidebar.widget(SENinjaWidgetType.name)
        return self._widget

    # decorator
    def locked(func):
        def wrapper(self, *args, **kwargs):
            with self.lock:
                r = func(self, *args, **kwargs)
            return r
        return wrapper

    def __init__(self):
        self.lock    = threading.RLock()
        self._widget = None
        self._bv     = None

        self.executor      = None
        self.dfs_searcher  = None
        self.bfs_searcher  = None
        self.searcher_tags = {}
        self.running       = False
        self.stop          = False

        self.highlighted_state_history = list()

        self._target_tag_type = None
        self._avoid_tag_type = None

    def symbolic_started(self):
        if self.executor is not None:
            return True
        logger.log_info("SENinja not running")
        return False

    def reset_state_history_highlight(self):
        if len(self.highlighted_state_history) > 0:
            # Remove highlight
            for insn in self.highlighted_state_history:
                func = self.executor.bncache.get_function(insn)
                func.set_auto_instr_highlight(insn, UIManager.NO_COLOR)
            self.highlighted_state_history = list()

    def _initialize_ui(self):
        if not self.symbolic_started():
            return
        self.widget.initSignal.emit(self.executor.arch, self.executor.state)

    def _sync_ui(self, delta=True):
        if not self.symbolic_started():
            return

        self.reset_state_history_highlight()
        self._set_colors()
        if self.executor.state is not None:
            self.widget.updateStateSignal.emit(self.executor.state)
            self.bv.file.navigate(self.bv.file.view, self.executor.state.get_ip())

    def _reset_ui(self):
        if not self.symbolic_started():
            return

        self.reset_state_history_highlight()
        self.widget.resetSignal.emit()

    def _delete_comment_for_address(self, address):
        if not self.symbolic_started():
            return

        func = self.executor.bncache.get_function(address)
        func.set_comment_at(address, None)

    def _set_colors(self, reset=False):
        if not self.symbolic_started():
            return

        old_ip = self.executor._last_colored_ip
        if old_ip is not None:
            old_func = self.executor.bncache.get_function(old_ip)
            old_func.set_auto_instr_highlight(old_ip, UIManager.NO_COLOR)

        for ip in self.executor.fringe._deferred:
            func = self.executor.bncache.get_function(ip)
            func.set_auto_instr_highlight(
                ip, UIManager.DEFERRED_STATE_COLOR if not reset else UIManager.NO_COLOR)
            if reset:
                func.set_comment_at(ip, None)
            elif len(self.executor.fringe._deferred[ip]) > 1 or (len(self.executor.fringe._deferred[ip]) == 1 and self.executor.ip == ip):
                func.set_comment_at(ip, "n deferred: %d" %
                                    len(self.executor.fringe._deferred[ip]))

        for _, state in self.executor.fringe.errored:
            func = self.executor.bncache.get_function(state.get_ip())
            func.set_auto_instr_highlight(
                state.get_ip(), UIManager.ERRORED_STATE_COLOR if not reset else UIManager.NO_COLOR)

        if self.executor.state:
            func = self.executor.bncache.get_function(self.executor.ip)
            func.set_auto_instr_highlight(
                self.executor.ip, UIManager.CURR_STATE_COLOR if not reset else UIManager.NO_COLOR)
        if not reset:
            self.executor._last_colored_ip = self.executor.ip

    @locked
    def start_se(self):
        if self.executor is not None:
            logger.log_info("SENinja already started")
            return

        address = self.bv.file.offset
        try:
            self.executor = SymbolicExecutor(self.bv, address)
        except SENinjaError as e:
            logger.log_error(e.message)
            return
        self.dfs_searcher = searcher.DFSSearcher(self.executor)
        self.bfs_searcher = searcher.BFSSearcher(self.executor)

        self._initialize_ui()
        self._sync_ui()

    @locked
    def set_run_target(self, address):
        if not self.symbolic_started():
            return

        address = get_address_after_merge(self.bv, address)
        func = self.executor.bncache.get_function(address)
        if address in self.searcher_tags:
            func.remove_auto_address_tags_of_type(address, self.searcher_tags[address][0])
            del self.searcher_tags[address]

        tt = self.get_target_tt(self.bv)
        func.add_tag(tt, "SENINJA: target address", address, True)
        self.searcher_tags[address] = (tt, func)
        if address in self.dfs_searcher.avoid:
            self.dfs_searcher.avoid.remove(address)
            self.bfs_searcher.avoid.remove(address)

        self.dfs_searcher.set_target(address)
        self.bfs_searcher.set_target(address)

    @locked
    def set_run_avoid(self, address):
        if not self.symbolic_started():
            return

        address = get_address_after_merge(self.bv, address)
        func = self.executor.bncache.get_function(address)
        if address in self.searcher_tags:
            func.remove_auto_address_tags_of_type(address, self.searcher_tags[address])
            del self.searcher_tags[address]

        tt = self.get_avoid_tt(self.bv)
        func.add_tag(tt, "SENINJA: avoid address", address, True)
        self.searcher_tags[address] = (tt, func)
        if address == self.dfs_searcher.target:
            self.dfs_searcher.target = None
            self.bfs_searcher.target = None

        self.dfs_searcher.add_avoid(address)
        self.bfs_searcher.add_avoid(address)

    @locked
    def reset_searchers(self):
        if not self.symbolic_started():
            return

        for addr in self.searcher_tags:
            tt, func = self.searcher_tags[addr]
            func.remove_auto_address_tags_of_type(addr, tt)

        self.searcher_tags = {}
        self.dfs_searcher.target = None
        self.bfs_searcher.target = None
        self.dfs_searcher.avoid = []
        self.bfs_searcher.avoid = []

    @locked
    def async_run_dfs_searcher(self):
        if not self.symbolic_started():
            return

        if not self.dfs_searcher.ready_to_run():
            logger.log_info("SENinja: no target set for searcher")
            return

        timeout = self.executor.bncache.get_setting("exploration_timeout")
        timeout = int(timeout)

        def f(tb):
            start = time.time()
            def callback(s):
                if s is None:
                    return False
                tb.progress = "SENinja: running DFS @ %s" % hex(s.get_ip())
                if timeout > 0 and time.time() - start > timeout:
                    logger.log_error("SENinja: Timeout elapsed (%d sec)" % timeout)
                    return False
                if self.stop:
                    self.stop = False
                    return False
                return True

            self.dfs_searcher.run(step_callback=callback)
            self._sync_ui(self.executor._last_error == None)
            self.running = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(self.bv, "SENinja: running DFS", f)
            background_task.start()

    @locked
    def async_run_bfs_searcher(self):
        if not self.symbolic_started():
            return

        if not self.bfs_searcher.ready_to_run():
            logger.log_info("SENinja: no target set for searcher")
            return

        timeout = self.executor.bncache.get_setting("exploration_timeout")
        timeout = int(timeout)

        def f(tb):
            start = time.time()
            def callback(s):
                if s is None:
                    return False
                tb.progress = "SENinja: running BFS @ %s" % hex(s.get_ip())
                if timeout > 0 and time.time() - start > timeout:
                    logger.log_error("SENinja: Timeout elapsed (%d sec)" % timeout)
                    return False
                if self.stop:
                    self.stop = False
                    return False
                return True

            self.bfs_searcher.run(callback)

            self._sync_ui(self.executor._last_error == None)
            self.running = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(self.bv, "SENinja: running BFS", f)
            background_task.start()

    @locked
    def async_step(self):
        if not self.symbolic_started():
            return

        def f(tb):
            self.executor.execute_one()
            self._sync_ui(self.executor._last_error == None)
            self.running = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(self.bv, "SENinja: stepping", f)
            background_task.start()

    @locked
    def async_continue_until_branch(self):
        if not self.symbolic_started():
            return

        timeout = self.executor.bncache.get_setting("exploration_timeout")
        timeout = int(timeout)

        def f(tb):
            start = time.time()
            k = len(self.executor.fringe.deferred)
            i = k
            count = 0
            while not self.stop and i == k:
                self.executor.execute_one()
                if not self.executor.state:
                    break

                if timeout > 0 and time.time() - start > timeout:
                    # Timeout elapsed
                    logger.log_error("SENinja: Timeout elapsed (%d sec)" % timeout)
                    break

                i = len(self.executor.fringe.deferred)
                ip = self.executor.state.get_ip()
                count = (count+1) % 20
                if count == 0:
                    self._set_colors()
                tb.progress = "SENinja: continue until branch: %s" % hex(ip)

            self._sync_ui(self.executor._last_error == None)
            self.running = False
            self.stop = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(
                self.bv, "SENinja: continue until branch", f)
            background_task.start()

    @locked
    def async_continue_until_address(self, address):
        if not self.symbolic_started():
            return

        timeout = self.executor.bncache.get_setting("exploration_timeout")
        timeout = int(timeout)

        address = get_address_after_merge(self.bv, address)

        def f(tb):
            ip = self.executor.state.get_ip()
            start = time.time()

            count = 0
            while not self.stop and ip != address:
                self.executor.execute_one()
                if not self.executor.state:
                    break

                if timeout > 0 and time.time() - start > timeout:
                    # Timeout elapsed
                    logger.log_error("SENinja: Timeout elapsed (%d sec)" % timeout)
                    break

                ip = self.executor.state.get_ip()
                count = (count+1) % 20
                if count == 0:
                    self._set_colors()
                tb.progress = "SENinja: continue until address: %s" % hex(ip)

            self._sync_ui(self.executor._last_error == None)
            self.running = False
            self.stop = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(
                self.bv, "SENinja: continue until address", f)
            background_task.start()

    @locked
    def async_merge_states(self, address):
        # merge all states at address and put them in current state. Current state must be at address
        if not self.symbolic_started():
            return

        if self.executor.state.get_ip() != address:
            logger.log_info("SENinja: current state is not at this address")
            return

        to_be_merged_all = self.executor.fringe.get_all_deferred_by_address(
            address)
        if to_be_merged_all is None:
            logger.log_info("SENinja: no deferred state at this address")
            return

        mergeable, not_mergeable = self.executor.extract_mergeable_with_current_state(
            to_be_merged_all)
        if len(not_mergeable) > 0:
            logger.log_error(
                "SENinja [warning]: %d states was not merged since they deviate from the current state after executing the current instruction" % len(not_mergeable))
            self.executor.fringe._deferred[address] = not_mergeable

        if len(mergeable) == 0:
            return
        to_be_merged = mergeable

        def f(tb):
            tot = len(to_be_merged)
            i = 0
            for s in to_be_merged:
                self.executor.state.merge(s)
                i += 1
                tb.progress = "SENinja: merging states %d/%d" % (i, tot)

            self._delete_comment_for_address(address)
            self._sync_ui()
            self.running = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(self.bv, "SENinja: merging states", f)
            background_task.start()

    @locked
    def async_change_current_state(self, address):
        if not self.symbolic_started():
            return

        states = self.executor.fringe.get_list_deferred_by_address(address)
        if len(states) == 0:
            logger.log_info("SENinja: no such deferred state")
            return
        if len(states) == 1:
            state = self.executor.fringe.get_deferred_by_address(address)
        else:
            state_idx = get_choice_input(
                "Select state", "states", list(map(str, states)))
            state = self.executor.fringe.get_deferred_by_address(
                address, state_idx)

        self._delete_comment_for_address(address)
        self.executor.set_current_state(state)
        self._sync_ui(delta=False)

    @locked
    def async_save_active_state(self):
        if not self.symbolic_started():
            return

        def f(tb):
            saved_state = self.executor.state.copy()
            self.executor.put_in_deferred(saved_state)

            self._sync_ui(delta=False)
            self.running = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(
                self.bv, "SENinja: saving current state", f)
            background_task.start()

    @locked
    def async_change_active_state_ip(self, address):
        if not self.symbolic_started():
            return

        def f(tb):
            state = self.executor.state
            state.set_ip(address)
            func_name = self.executor.bncache.get_function_name(address)
            state.llil_ip = self.executor.bncache.get_llil_address(
                func_name, address)

            self.executor.state = None
            self.executor.set_current_state(state)

            self._sync_ui(delta=False)
            self.running = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()
            background_task = UIBackgroundTask(
                self.bv, "SENinja: changing current state", f)
            background_task.start()

    @locked
    def async_reset_se(self):
        if not self.symbolic_started():
            return

        def f(tb):
            for addr in self.searcher_tags:
                tag, func = self.searcher_tags[addr]
                func.remove_auto_address_tags_of_type(addr, tag)
            self.searcher_tags = dict()

            self._set_colors(reset=True)
            self._bv = None
            self.executor = None
            self.dfs_searcher = None
            self.bfs_searcher = None
            self.running = False
            self.widget.enableAll()

        if not self.running:
            self.running = True
            self.widget.disableAll()

            self._reset_ui()
            background_task = UIBackgroundTask(
                self.bv, "SENinja: resetting symbolic execution", f)
            background_task.start()

    @locked
    def launch_argv_dialog(self):
        if self.running:
            return
        if self.executor is None:
            return

        # This is an hack: keep a pointer to the widget before spawning the dialog
        #                  because otherwise is won't be accessible
        widget = self.widget

        d = GetArgvDialog(self.executor.state)
        d.exec_()
        widget.updateStateSignal.emit(self.executor.state)

```

`utility/aarch64_native_handlers_util.py`:

```py
from collections import namedtuple
import re

AArch64Mnemonic = namedtuple("AArch64Mnemonic", ["mnemonic", "cond"])
AArch64ShiftExtend = namedtuple("AArch64ShiftExtend", ["type", "amount"])

conds = {
    'EQ', 'NE', 'CS', 'HS', 'CC', 'LO', 'MI', 'PL',
    'VS', 'VC', 'HI', 'LS', 'GE', 'LT', 'GT', 'LE', 'AL', 'NV'
}

shift_extend = {
    'LSL', 'LSR', 'ASR', 'ROR',      # shifts
    'UXTB', 'UXTH', 'UXTW', 'UXTX',  # unsigned extends
    'SXTB', 'SXTH', 'SXTW', 'SXTX'   # signed extends
}

conds_regex = '|'.join(map(lambda x: x.lower(), conds))
shift_extend_regex = '|'.join(map(lambda x: x.lower(), shift_extend))


def parse_mnemonic(instr):
    regex_mnemonic = \
        r"^([a-z]+)" + \
        r"(?:\.({conds_regex}))?\b" \
        .format(conds_regex=conds_regex)

    res = re.match(regex_mnemonic, instr)
    assert res is not None  # parse failed
    res = res.groups()

    return AArch64Mnemonic(
        mnemonic=res[0],
        cond=res[1]
    )


def parse_shift_extend(par):
    regex_shift_extend = r"({shift_extend_regex})\s*\#(0x[0-9a-fA-F]+|[0-9]+)".format(
        shift_extend_regex=shift_extend_regex
    )
    tokens = re.match(regex_shift_extend, par)
    assert tokens is not None  # parse failed
    tokens = tokens.groups()

    return AArch64ShiftExtend(
        type=tokens[0].upper(),
        amount=int(tokens[1], 16) if tokens[1][:2] == '0x' else int(tokens[1])
    )


def parse_immediate(par):
    regex_imm = r"\#(0x[0-9a-fA-F]+|[0-9]+)"
    tokens = re.match(regex_imm, par)
    assert tokens is not None  # parse failed
    tokens = tokens.groups()

    return int(tokens[0], 16) if tokens[0][:2] == '0x' else int(tokens[0])


def get_src(state, param):
    if param.startswith('#'):
        return parse_immediate(param)
    else:
        # assume it's a register name
        return state.regs[param]


def store_to_dst(state, param, value):
    # store to register
    state.regs[param] = value

```

`utility/armv7_native_handlers_util.py`:

```py
from collections import namedtuple
import re

ArmV7Mnemonic = namedtuple("ArmV7Mnemonic",  ["mnemonic", "set_flag", "cond"])
ArmV7RotShift = namedtuple("ArmV7RotShift",  ["type", "size"])

conds = {
    'EQ', 'NE', 'GT', 'LT', 'GE', 'LE',
    'CS', 'CC', 'LO', 'MI', 'PL', 'AL',
    'NV', 'VS', 'VC', 'HI', 'LS'
}
shift_rot = {
    'ASR', 'LSL', 'LSR', 'ROR', 'RRX'
}
conds_regex = '|'.join(map(lambda x: x.lower(), conds))
shift_rot_regex = '|'.join(map(lambda x: x.lower(), shift_rot))


def parse_mnemonic(instr):
    regex_mnemonic = \
        r"^([a-z]+?)" + \
        r"(s?)" + \
        r"({conds_regex})?\b"  \
        .format(conds_regex=conds_regex)

    res = re.match(regex_mnemonic, instr)
    assert res is not None  # parse failed
    res = res.groups()

    return ArmV7Mnemonic(
        mnemonic=res[0],
        set_flag=res[1] != '',
        cond=res[2]
    )


def parse_rot_shift(par):
    regex_rot_shift = r"({shift_rot_regex})\s*\#(0x[0-9]+)".format(
        shift_rot_regex=shift_rot_regex
    )
    tokens = re.match(regex_rot_shift, par)
    assert tokens is not None  # parse failed
    tokens = tokens.groups()

    return ArmV7RotShift(
        type=tokens[0],
        size=int(tokens[1], 16) if tokens[1][:2] == '0x' else int(tokens[1])
    )


def parse_immediate(par):
    regex_imm = r"\#(0x[0-9]+)"
    tokens = re.match(regex_imm, par)
    assert tokens is not None  # parse failed
    tokens = tokens.groups()

    return int(tokens[0], 16) if tokens[0][:2] == '0x' else int(tokens[0])

```

`utility/binary_ninja_cache.py`:

```py
from binaryninja import Settings
from .bninja_util import (
    get_function
)


class BNCache(object):
    def __init__(self, bv):
        self.bv = bv
        self.addr_to_func_cache = dict()
        self.name_to_func_cache = dict()
        self.func_name_cache = dict()
        self.llil_cache = dict()
        self.llil_addr_cache = dict()
        self.addr_cache = dict()
        self.disasm_cache = dict()
        self.instruction_len_cache = dict()
        self.settings = dict()

    def reset(self):
        self.addr_to_func_cache = dict()
        self.name_to_func_cache = dict()
        self.func_name_cache = dict()
        self.llil_cache = dict()
        self.llil_addr_cache = dict()
        self.addr_cache = dict()
        self.disasm_cache = dict()
        self.instruction_len_cache = dict()
        self.settings = dict()

    def get_function(self, address):
        if address in self.addr_to_func_cache:
            return self.addr_to_func_cache[address]
        function = get_function(self.bv, address)
        self.addr_to_func_cache[address] = function
        return function

    def get_function_name(self, address):
        if address in self.func_name_cache:
            return self.func_name_cache[address]
        function = self.get_function(address)
        if function is None:
            return None
        function_name = function.name
        self.func_name_cache[address] = function_name
        self.name_to_func_cache[function_name] = function
        return function_name

    def get_llil(self, func_name, llil_addr):
        if (func_name, llil_addr) in self.llil_cache:
            return self.llil_cache[
                (func_name, llil_addr)
            ]
        func = self.name_to_func_cache[func_name]
        expr = func.llil[llil_addr]
        self.llil_cache[
            (func_name, llil_addr)
        ] = expr
        return expr

    def get_llil_address(self, func_name, address):
        if (func_name, address) in self.llil_addr_cache:
            return self.llil_addr_cache[
                (func_name, address)
            ]
        func = self.name_to_func_cache[func_name]
        llil_addr = func.llil.get_instruction_start(address, func.arch)
        self.llil_addr_cache[
            (func_name, address)
        ] = llil_addr
        return llil_addr

    def get_address(self, func_name, llil_addr):
        if (func_name, llil_addr) in self.addr_cache:
            return self.addr_cache[
                (func_name, llil_addr)
            ]
        addr = self.get_llil(func_name, llil_addr).address
        self.addr_cache[
            (func_name, llil_addr)
        ] = addr
        return addr

    def get_disasm(self, address):
        if address in self.disasm_cache:
            return self.disasm_cache[address]
        func = self.get_function(address)
        disasm = self.bv.get_disassembly(address, func.arch)
        self.disasm_cache[address] = disasm
        return disasm

    def get_instruction_len(self, address):
        if address in self.instruction_len_cache:
            return self.instruction_len_cache[address]

        ret_len = self.bv.get_instruction_length(address)
        self.instruction_len_cache[address] = ret_len
        return ret_len

    def get_setting(self, name: str):
        if name in self.settings:
            return self.settings[name]

        val = Settings().get_string("seninja." + name)
        self.settings[name] = val
        return val

```

`utility/bninja_util.py`:

```py
from binaryninja import SymbolType
from ..globals import logger


sticky_fun = None
def get_function(view, address):
    global sticky_fun

    funcs = view.get_functions_at(address)
    if len(funcs) == 0:
        funcs = view.get_functions_containing(address)

    if len(funcs) > 1:
        logger.log_warn("WARNING: more than one function at {addr:x}".format(
            addr=address
        ))
        # Prefer the last translated function when there is an ambiguity.
        # This is just an heuristic, it does not solve the problem in general.
        funcs = sorted(
            funcs,
            key=lambda f: \
                0 if (sticky_fun is not None and sticky_fun.name == f.name)
                else 1)

    if len(funcs) == 0:
        return None
    sticky_fun = funcs[0]
    return funcs[0]


def get_imported_functions_and_addresses(view):
    res_functions = dict()
    res_addresses = dict()

    symbols = view.symbols
    for name in symbols:
        symb_types = symbols[name]
        if not isinstance(symb_types, list):
            symb_types = [symb_types]

        for symb_type in symb_types:
            if symb_type.type == SymbolType.ImportedFunctionSymbol:
                res_functions[symb_type.address] = symb_type.name
            if symb_type.type == SymbolType.ImportAddressSymbol or symb_type.type == SymbolType.ExternalSymbol:
                res_addresses[symb_type.address] = symb_type.name

                if "@IAT" in symb_type.name or "@GOT" in symb_type.name:
                    addr = int.from_bytes(
                        view.read(symb_type.address, view.arch.address_size),
                        'little' if view.arch.endianness.name == 'LittleEndian' else 'big'
                    )
                    res_functions[addr] = symb_type.name.replace(
                        "@IAT" if "@IAT" in symb_type.name else "@GOT", "")

    return res_functions, res_addresses


def get_addr_next_inst(view, addr):
    return addr + view.get_instruction_length(addr)


def parse_disasm_str(disasm_str):
    inst_name = disasm_str.split(" ")[0]
    parameters = ''.join(disasm_str.split(" ")[1:]).split(",")
    return inst_name, parameters


def get_address_after_merge(view, address):
    func = get_function(view, address)
    llil = func.llil.get_instruction_start(address, func.arch)
    return func.llil[llil].address


```

`utility/exceptions.py`:

```py
# ERRORS
class SENinjaError(Exception):
    def __init__(self, msg):
        self.message = msg
        super().__init__(msg)

    def is_fatal(self):
        raise NotImplementedError  # override


class DivByZero(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "division by zero occurred at 0x%x" % pc
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnmappedRead(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "unmapped read at 0x%x" % pc
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnmappedWrite(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "unmapped write at 0x%x" % pc
        super().__init__(self.message)

    def is_fatal(self):
        return False


class NoDestination(SENinjaError):
    def __init__(self):
        self.message = "no destination"
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnconstrainedIp(SENinjaError):
    def __init__(self):
        self.message = "unconstrained ip"
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnsatState(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "UNSAT state at 0x%x"
        super().__init__(self.message)

    def is_fatal(self):
        return True


class ModelError(SENinjaError):
    def __init__(self, model_name, msg):
        self.model_name = model_name
        self.message = "%s: %s" % (model_name, msg)
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnimplementedInstruction(SENinjaError):
    def __init__(self, instr_name, ip):
        self.instr_name = instr_name
        self.message = "%s instruction is unimplemented @ %#x" % (instr_name, ip)
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnimplementedModel(SENinjaError):
    def __init__(self, f_name):
        self.f_name = f_name
        self.message = "unimplemented model for function %s" % f_name
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnimplementedSyscall(SENinjaError):
    def __init__(self, syscall_n):
        self.syscall_n = syscall_n
        self.message = "unimplemented syscall %d" % syscall_n
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnsupportedOs(SENinjaError):
    def __init__(self, platform_name):
        self.platform_name = platform_name
        self.message = "unsupported os %s" % platform_name
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnsupportedArch(SENinjaError):
    def __init__(self, arch_name):
        self.arch_name = arch_name
        self.message = "unsupported arch %s" % arch_name
        super().__init__(self.message)

    def is_fatal(self):
        return True
# *****


class SENinjaExeption(Exception):
    pass


class ExitException(SENinjaExeption):
    pass

```

`utility/expr_wrap_util.py`:

```py
from ..expr import BV, BVV
import z3

MIN_BASE = 0x10000


def split_bv_in_list(bv: BV, size: int) -> list:
    assert size % 8 == 0
    res = []
    for i in range(0, bv.size, size):
        b = bv.Extract(i+size-1, i)
        res.append(b)
    return res


def bvv_from_bytes(val: bytes):  # DONT USE IT TO CREATE LONG BV!!
    res = None
    for c in val:
        v = BVV(c, 8)
        res = res.Concat(v) if res is not None else v
    return res


def split_bv(bv: BV, split_index: int):
    return (
        bv.Extract(bv.size - 1, split_index),  # most significant
        bv.Extract(split_index - 1, 0)         # least significant
    )


def symbolic(val: BV) -> bool:
    return not isinstance(val, BVV)


def heuristic_find_base(val: BV):  # this can be brough inside BVExpr
    z3val = val.z3obj
    fringe = z3val.children()
    while fringe:
        el = fringe.pop()
        if (
            not (z3.simplify(z3val).decl().kind() != z3.Z3_OP_BNUM) and
            el.value > MIN_BASE
        ):
            return el.value
        fringe.extend(el.children())
    return -1

```

`utility/models_util.py`:

```py
from .bninja_util import get_function


def get_arg_k(state, k, size, view):

    ip = state.get_ip()
    func = get_function(view, ip)
    if not hasattr(state, "abi") or state.abi is None:
        raise Exception("Missing ABI resolver for argument access")
    return state.abi.get_arg(state, func, k, size)

```

`utility/string_util.py`:

```py
from ..expr import BV, BVV, And, Or
from .expr_wrap_util import split_bv_in_list


def str_to_int(s):
    res = ""
    for c in s:
        res += hex(ord(c))[2:]
    res += "00"
    return int(res, 16)


def str_to_bv_list(s, terminator=False):
    res = list()
    for c in s:
        res.append(BVV(ord(c), 8))
    if terminator:
        res += [BVV(0, 8)]
    return res


def str_to_bv(s, terminator=False):
    if len(s) == 0:
        return None

    res = BVV(ord(s[0]), 8)
    for c in s[1:]:
        res = res.Concat(BVV(ord(c), 8))
    if terminator:
        res = res.Concat(BVV(0, 8))
    return res


def int_to_str(i):
    s = hex(i)[2:]
    res = ""
    for i in range(0, len(s), 2):
        res += chr(int(s[i] + s[i+1], 16))
    return res


def as_bytes(bv: BV):
    for i in range(bv.size, 0, -8):
        yield bv.Extract(i-1, i-8)


def get_byte(bv: BV, i: int):
    return bv.Extract(bv.size-i*8-1, bv.size-i*8-8)


def constraint_alphanumeric_string(bv, state):
    for bv in split_bv_in_list(bv, 8):
        state.solver.add_constraints(
            Or(
                And(bv >= ord("a"), bv <= ord("z")),
                And(bv >= ord("A"), bv <= ord("Z")),
                And(bv >= ord("0"), bv <= ord("9"))
            )
        )


def constraint_ascii_string(bv, state):
    for bv in split_bv_in_list(bv, 8):
        state.solver.add_constraints(
            bv >= 0x20, bv <= 0x7E
        )

```

`utility/x86_native_handlers_util.py`:

```py
from ..expr import BVV

_size_dict = {
    "byte":     1,
    "word":     2,
    "dword":    4,
    "qword":    8,
    "xmmword": 16,
    "ymmword": 32,
    "zmmword": 64
}


def __is_hex(v):
    try:
        int(v, 16)
        return True
    except:
        return False


# hackish way of parsing a mem address. bad, bad, bad code
def __find_address_mem(state, parameter):
    assert "[" in parameter and "]" in parameter

    size = parameter[:parameter.find("[")]
    size = size.replace(" ", "")
    size = _size_dict[size]

    parameter = parameter.replace("rel", "")
    parameter = parameter[parameter.find("[")+1:]
    parameter = parameter[:parameter.find("]")]

    res = None
    was_add = False
    if "+" in parameter:
        parameter = parameter.split("+")
        was_add = True
    else:
        parameter = parameter.split("-")
        was_add = False
    for sub in parameter[::-1]:

        m_res = None
        m_subs = sub.split("*")
        for m_sub in m_subs:
            if state.regs.has_reg(m_sub):
                v = getattr(state.regs, m_sub)
                m_res = v if m_res is None else (m_res * v)
            elif __is_hex(m_sub):
                v = BVV(int(m_sub, 16), state.arch.bits())
                m_res = v if m_res is None else (m_res * v)
            else:
                raise Exception("Unknown subexpression")

        if was_add:
            res = m_res if res is None else (res + m_res)
        else:
            res = m_res if res is None else (m_res - res)

    return res, size


def get_src(state, parameter: str):
    if state.regs.has_reg(parameter):
        res = getattr(state.regs, parameter)
        return res

    addr, size = __find_address_mem(state, parameter)
    return state.mem.load(addr, size, state.arch.endness())


def store_to_dst(state, parameter: str, value):
    if state.regs.has_reg(parameter):
        setattr(state.regs, parameter, value)
        return

    assert "[" in parameter and "]" in parameter

    addr, _ = __find_address_mem(state, parameter)
    return state.mem.store(addr, value, state.arch.endness())

```

`utility/z3_wrap_util.py`:

```py
import z3

MIN_BASE = 0x10000


def bvs(name: str, size: int):
    return z3.BitVec(name, size)


def bvv(val: int, size: int):
    return z3.BitVecVal(val, size)


def split_bv_in_list(bv: z3.BitVecRef, size: int) -> list:
    assert size % 8 == 0
    res = []
    for i in range(0, bv.size, size):
        b = z3.simplify(z3.Extract(i+size-1, i, bv))
        res.append(b)
    return res


def bvv_from_bytes(val: bytes):  # DONT USE IT TO CREATE LONG BV!!
    res = None
    for c in val:
        v = z3.BitVecVal(c, 8)
        res = z3.Concat(res, v) if res is not None else v
    return res


def split_bv(bv: z3.BitVecRef, split_index: int):
    return (
        # most significant
        z3.simplify(z3.Extract(bv.size - 1, split_index, bv)),
        z3.simplify(z3.Extract(split_index - 1, 0, bv)
                    )         # least significant
    )


def symbolic(val: z3.BitVecRef) -> bool:
    return z3.simplify(val).decl().kind() != z3.Z3_OP_BNUM


def bvv_to_long(val: z3.BitVecRef):
    assert not symbolic(val)
    return z3.simplify(val).value


def heuristic_find_base(val: z3.BitVecRef):
    fringe = val.children()
    while fringe:
        el = fringe.pop()
        if not symbolic(el) and el.value > MIN_BASE:
            return el.value
        fringe.extend(el.children())
    return -1

```