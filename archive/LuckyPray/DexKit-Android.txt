Project Path: arc_LuckyPray_DexKit-Android_nzlihqac

Source Tree:

```txt
arc_LuckyPray_DexKit-Android_nzlihqac
├── LICENSE
├── README.md
├── README_zh.md
├── build.gradle
├── dexkit
│   ├── build.gradle
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── CMakeLists.txt
│           ├── DexKit
│           ├── java
│           │   └── com
│           │       └── github
│           │           └── LuckyPray
│           │               └── DexKitHelper.kt
│           └── jni
│               ├── CMakeLists.txt
│               └── jni.cpp
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── jitpack.yml
└── settings.gradle

```

`LICENSE`:

```
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2022 LuckyPray
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.
```

`README.md`:

```md
<div align="center">
    <h1> DexKit-Android </h1>

[![license](https://img.shields.io/github/license/LuckyPray/DexKit-Android.svg)](https://www.gnu.org/licenses/lgpl-3.0.html)
[![](https://jitpack.io/v/LuckyPray/DexKit-Android.svg)](https://jitpack.io/#LuckyPray/DexKit-Android)

[README](https://github.com/LuckyPray/DexKit-Android/blob/master/README.md)|[中文文档](https://github.com/LuckyPray/DexKit-Android/blob/master/README_zh.md)

</div>

# This repository update has been terminated, Please use [DexKit](https://github.com/LuckyPray/DexKit) in the future, it's easier to use.


A high performance dex deobfuscator library(NDK).

> **Warning**: The current project has been refactored, `1.1.0` and earlier APIs are deprecated. Please refer to the latest documentation for use.

## API introduction

These two APIs can meet most of your usage scenarios:

- **`DexKit::BatchFindClassesUsedStrings`**
- **`DexKit::BatchFindMethodsUsedStrings`**

> **Note**: In all cases you should avoid searching for keywords that contain duplicate content, eg: {"key_word", "word"}, as this will cause tags to be overwritten, resulting in inaccurate search results.
> If there is such a need, open the advanced search mode as much as possible, and use the string to match the content exactly, for example, modify it to this: {"^key_word$", "^word$"}

And there are many other APIs:

- `DexKit::FindMethodBeInvoked`: find caller for specified method.
- `DexKit::FindMethodInvoking`: find the called method
- `DexKit::FindMethodUsedField`: find method getting specified field, access types(put/get) can be limited by setting `used_flags`
- `DexKit::FindMethodUsedString`: find method used utf8 string
- `DexKit::FindMethod`: find method by multiple conditions
- `DexKit::FindSubClasses`: find all direct subclasses of the specified class
- `DexKit::FindMethodOpPrefixSeq`:  find all method used opcode prefix sequence

For more detailed instructions, please refer to [dex_kit.h](https://github.com/LuckyPray/DexKit/blob/master/include/dex_kit.h).

## Integration

Gradle:

`implementation: com.github.LuckyPray:DexKit-Android:<version>`

This library uses [prefab](https://google.github.io/prefab/), you should enable it in gradle (Android Gradle Plugin 4.1+):

```
android {
    buildFeatures {
        prefab true
    }
}
```

**Note**: DexKit-Android uses the [prefab package schema v2](https://github.com/google/prefab/releases/tag/v2.0.0), 
which is configured by default since [Android Gradle Plugin 7.1.0](https://developer.android.com/studio/releases/gradle-plugin?buildsystem=cmake#7-1-0). 
If you are using Android Gradle Plugin earlier than 7.1.0, please add the following configuration to `gradle.properties`:

```
android.prefabVersion=2.0.0
```

## Usage

### CMake

You can use `find_package` in `CMakeLists.txt`:

```cmake
add_library(mylib SHARED main.cpp)

# Add two lines below
find_package(dexkit REQUIRED CONFIG)
target_link_libraries(mylib dexkit::dex_kit_static z)
```

> Note: This header file was added since `1.1.0`

At the same time, we also provide [DexKitJniHelper.h](https://github.com/LuckyPray/DexKit/blob/master/include/DexKitJniHelper.h) 
for the conversion of complex objects between java and c++. For example: `HashMap<String, HashSet<String>>` -> `std::map<std::string, std::set<std::string>>`

JNI used example :
- [dexkit.cpp](https://github.com/LuckyPray/XAutoDaily/blob/master/app/src/main/cpp/dexkit.cpp)
- [DexKitHelper.kt](https://github.com/LuckyPray/XAutoDaily/blob/master/app/src/main/java/me/teble/xposed/autodaily/dexkit/DexKitHelper.kt)

## Example

- [main.cpp](https://github.com/LuckyPray/DexKit/blob/master/main.cpp)
- [qq-example.cpp](https://github.com/LuckyPray/DexKit/blob/master/qq-example.cpp)

## Benchmark

qq-example.cpp in MacPro M1 to deobfuscate `qq-8.9.3.apk`, the result is:

```txt
findClass count: 47
findMethod count: 29
used time: 207 ms
```

## License

The slicer directory is partially copied from [AOSP](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/startop/view_compiler).

Modified parts are owed by LuckyPray Developers. If you would like to use it in an open source project, please submodule it.

```

`README_zh.md`:

```md
<div align="center">
    <h1> DexKit-Android </h1>

[![license](https://img.shields.io/github/license/LuckyPray/DexKit-Android.svg)](https://www.gnu.org/licenses/lgpl-3.0.html)
[![](https://jitpack.io/v/LuckyPray/DexKit-Android.svg)](https://jitpack.io/#LuckyPray/DexKit-Android)

[README](https://github.com/LuckyPray/DexKit-Android/blob/master/README.md)|[中文文档](https://github.com/LuckyPray/DexKit-Android/blob/master/README_zh.md)

</div>

# 本仓库更新终止, 后续请使用 [DexKit](https://github.com/LuckyPray/DexKit), 它使用起来更便捷。

一个高性能的 dex 反混淆工具（NDK版本）。

> **Warning**: 当前项目已经进行重构，`1.1.0`及以下的API全被弃用，请参考最新的文档进行使用。

## API说明

这两个 API 可以满足你大部分的使用场景：

- **`DexKit::BatchFindClassesUsedStrings`**
- **`DexKit::BatchFindMethodsUsedStrings`**

> **Note**：无论什么情况都应当避免搜索关键词包含重复内容， 例如：{"key_word", "word"}，因为这样会导致标记被覆盖，从而导致搜索结果不准确。
> 如果真的有这样的需求，尽可能打开高级搜索模式，同时使用字符串完全匹配内容，例如修改成这样：{"^key_word$", "^word$"}

以及其他 API：

- `DexKit::FindMethodBeInvoked`: 查找指定方法的调用者
- `DexKit::FindMethodInvoking`: 查找指定方法调用的方法
- `DexKit::FindMethodUsedField`: 查找指定的属性被什么方法调用，可通过参数 `used_flags` 限制访问类型(put/get)
- `DexKit::FindMethodUsedString`: 查找指定字符串的调用者
- `DexKit::FindMethod`: 多条件查找方法
- `DexKit::FindSubClasses`: 查找直系子类
- `DexKit::FindMethodOpPrefixSeq`: 查找满足特定op前缀序列的方法(使用`0x00`-`0xff`)

更详细的API说明请参考 [dex_kit.h](https://github.com/LuckyPray/DexKit/blob/master/include/dex_kit.h).

## 集成

Gradle:

`implementation: com.github.LuckyPray:DexKit-Android:<version>`

这个库使用了 [prefab](https://google.github.io/prefab/)，你需要在 gradle (Android Gradle Plugin 4.1+ 版本以上才支持)中开启此特性：

```
android {
    buildFeatures {
        prefab true
    }
}
```

**注意**：DexKit-Android 使用 [prefab package schema v2](https://github.com/google/prefab/releases/tag/v2.0.0)，
它是从 [Android Gradle Plugin 7.1.0](https://developer.android.com/studio/releases/gradle-plugin?buildsystem=cmake#7-1-0) 开始作为默认配置的。
如果你使用的是 Android Gradle Plugin 7.1.0 之前的版本，请在 `gradle.properties` 中加入以下配置：

```
android.prefabVersion=2.0.0
```

## 使用

### CMake

你可以直接在 `CMakeLists.txt` 中使用 `find_package` 来使用 DexKit:

```cmake
add_library(mylib SHARED main.cpp)

# 添加如下两行，注意必须添加 libz，如果你有其他依赖可以放在后面
find_package(dexkit REQUIRED CONFIG)
target_link_libraries(mylib dexkit::dex_kit_static z)
```

> 注意：此头文件从 `1.1.0` 版本开始加入

同时，我们提供了 [DexKitJniHelper.h](https://github.com/LuckyPray/DexKit/blob/master/include/DexKitJniHelper.h)
用于java与c++之间复杂对象的转换，例如：`HashMap<String, HashSet<String>>` -> `std::map<std::string, std::set<std::string>>`。

JNI 使用示例：
- [dexkit.cpp](https://github.com/LuckyPray/XAutoDaily/blob/master/app/src/main/cpp/dexkit.cpp)
- [DexKitHelper.kt](https://github.com/LuckyPray/XAutoDaily/blob/master/app/src/main/java/me/teble/xposed/autodaily/dexkit/DexKitHelper.kt)

## 使用示例

- [main.cpp](https://github.com/LuckyPray/DexKit/blob/master/main.cpp)
- [qq-example.cpp](https://github.com/LuckyPray/DexKit/blob/master/qq-example.cpp)

## 基准测试

qq-example.cpp 在MacPro M1环境下对 `qq-8.9.3.apk` 执行结果如下所示:
```text
findClass count: 47
findMethod count: 29
used time: 207 ms
```

## License

slicer目录下内容是从 [AOSP](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/startop/view_compiler) 拷贝的.

修改部分归 LuckyPray 所有。如果您想在开源项目中使用，请将其子模块化。

```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id 'com.android.application' version '7.2.2' apply false
    id 'com.android.library' version '7.2.2' apply false
    id 'org.jetbrains.kotlin.android' version '1.7.10' apply false
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
```

`dexkit/build.gradle`:

```gradle
plugins {
    id 'com.android.library'
    id 'maven-publish'
    id 'org.jetbrains.kotlin.android'
}

android {
    compileSdk 32

    defaultConfig {
        minSdk 21
        targetSdk 32

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles "consumer-rules.pro"

        externalNativeBuild {
            cmake {
                cppFlags '-std=c++17'
            }
        }
    }

    externalNativeBuild {
        cmake {
            path file('src/main/CMakeLists.txt')
            version '3.18.1'
        }
    }

    buildFeatures {
        prefab true
        prefabPublishing true
    }

    prefab {
        dex_kit_static {
            headers "src/main/DexKit/include"
        }
    }
}

// Because the components are created only during the afterEvaluate phase, you must
// configure your publications using the afterEvaluate() lifecycle method.
afterEvaluate {
    publishing {
        publications {
            // Creates a Maven publication called "release".
            release(MavenPublication) {
                // Applies the component for the release build variant.
                from components.release

                // You can then customize attributes of the publication as shown below.
                groupId = 'io.luckypray'
                artifactId = 'dexkit'
                version = '1.3.0'
            }
        }
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:+'
}
```

`dexkit/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="io.luckypray.dexkit">

</manifest>
```

`dexkit/src/main/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18.1)

project(root)

add_subdirectory(DexKit)
add_subdirectory(jni)
```

`dexkit/src/main/java/com/github/LuckyPray/DexKitHelper.kt`:

```kt
package com.github.LuckyPray

import java.io.Closeable
import java.net.URL

class DexKitHelper private constructor(dexpath: String): Closeable {

    companion object {
        const val FLAG_GETTING = 1
        const val FLAG_SETTING = 2
        const val FLAG_USING = FLAG_GETTING or FLAG_SETTING

        fun create(dexpath: String): DexKitHelper? {
            val helper = DexKitHelper(dexpath)
            return if (helper.valid()) helper else null
        }

        fun create(loader: ClassLoader): DexKitHelper? {
            val url = loader.javaClass.getDeclaredMethod("findResource", String::class.java)
                .invoke(loader, "AndroidManifest.xml")
            if (url is URL) {
                url.path.substring(5, url.path.length - 26).let {
                    return DexKitHelper(it)
                }
            }
            return null
        }
    }

    /**
     * 使用完成后切记记得调用 [release]，否则内存不会释放
     */
    private var token: Long = 0

    init {
        token = initDexKit(dexpath)
    }

    fun release() {
        release(token)
    }

    fun valid(): Boolean {
        return token != 0L
    }

    fun batchFindClassesUsedStrings(
        map: Map<String, Set<String>>,
        advancedMatch: Boolean = true,
        dexPriority: IntArray? = intArrayOf(),
    ): Map<String, Array<String>> {
        return batchFindClassesUsedStrings(token, map, advancedMatch, dexPriority)
    }

    fun batchFindMethodsUsedStrings(
        map: Map<String, Set<String>>,
        advancedMatch: Boolean = true,
        dexPriority: IntArray? = intArrayOf(),
    ): Map<String, Array<String>> {
        return batchFindMethodsUsedStrings(token, map, advancedMatch, dexPriority)
    }

    @JvmName("batchFindClassesUsedStrings2")
    fun batchFindClassesUsedStrings(
        map: Map<String, Array<String>>,
        advancedMatch: Boolean = true,
        dexPriority: IntArray? = intArrayOf(),
    ): Map<String, Array<String>> {
        return convertSignature(batchFindClassesUsedStrings(token, toSet(map), advancedMatch, dexPriority))
    }

    @JvmName("batchFindMethodsUsedStrings2")
    fun batchFindMethodsUsedStrings(
        map: Map<String, Array<String>>,
        advancedMatch: Boolean = true,
        dexPriority: IntArray? = intArrayOf(),
    ): Map<String, Array<String>> {
        return batchFindMethodsUsedStrings(token, toSet(map), advancedMatch, dexPriority)
    }

    fun toSet(map: Map<String, Array<String>>): Map<String, Set<String>> {
        val result = mutableMapOf<String, Set<String>>()
        for (entry in map) {
            result[entry.key] = entry.value.toSet()
        }
        return result
    }

    fun convertSignature(map: Map<String, Array<String>>) : Map<String, Array<String>> {
        val result = mutableMapOf<String, Array<String>>()
        for (entry in map) {
            result[entry.key] = entry.value.map { it.jniSignatureToJava() }.toTypedArray()
        }
        return result
    }

    fun findMethodBeInvoked(
        methodDescriptor: String,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>? = null,
        callerMethodDeclareClass: String,
        callerMethodName: String,
        callerMethodReturnType: String,
        callerMethodParamTypes: Array<String>? = null,
        dexPriority: IntArray? = intArrayOf(),
    ): Array<String> {
        return findMethodBeInvoked(
            token,
            methodDescriptor,
            methodDeclareClass,
            methodName,
            methodReturnType,
            methodParamTypes,
            callerMethodDeclareClass,
            callerMethodName,
            callerMethodReturnType,
            callerMethodParamTypes,
            dexPriority
        )
    }

    fun findMethodInvoking(
        methodDescriptor: String,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>? = null,
        beCalledMethodDeclareClass: String,
        beCalledMethodName: String,
        beCalledMethodReturnType: String,
        beCalledMethodParamTypes: Array<String>? = null,
        dexPriority: IntArray? = intArrayOf(),
    ): Map<String, Array<String>> {
        return findMethodInvoking(
            token,
            methodDescriptor,
            methodDeclareClass,
            methodName,
            methodReturnType,
            methodParamTypes,
            beCalledMethodDeclareClass,
            beCalledMethodName,
            beCalledMethodReturnType,
            beCalledMethodParamTypes,
            dexPriority
        )
    }

    fun findMethodUsedField(
        fieldDescriptor: String,
        fieldDeclareClass: String,
        fieldName: String,
        fieldType: String,
        usedFlags: Int,
        callerMethodDeclareClass: String,
        callerMethodName: String,
        callerMethodReturnType: String,
        callerMethodParamTypes: Array<String>? = null,
        dexPriority: IntArray? = intArrayOf(),
    ): Array<String> {
        return findMethodUsedField(
            token,
            fieldDescriptor,
            fieldDeclareClass,
            fieldName,
            fieldType,
            usedFlags,
            callerMethodDeclareClass,
            callerMethodName,
            callerMethodReturnType,
            callerMethodParamTypes,
            dexPriority
        )
    }

    fun findMethodUsedString(
        usedString: String,
        advancedMatch: Boolean = true,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>? = null,
        dexPriority: IntArray? = intArrayOf(),
    ): Array<String> {
        return findMethodUsedString(
            token,
            usedString,
            advancedMatch,
            methodDeclareClass,
            methodName,
            methodReturnType,
            methodParamTypes,
            dexPriority
        )
    }

    fun findMethod(
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>? = null,
        dexPriority: IntArray? = intArrayOf(),
    ): Array<String> {
        return findMethod(
            token,
            methodDeclareClass,
            methodName,
            methodReturnType,
            methodParamTypes,
            dexPriority
        )
    }

    fun findSubClasses(
        parentClass: String,
        dexPriority: IntArray? = intArrayOf(),
    ): Array<String> {
        return findSubClasses(token, parentClass, dexPriority).map { it.jniSignatureToJava() }.toTypedArray()
    }

    fun findMethodOpPrefixSeq(
        opPrefixSeq: IntArray,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>? = null,
        dexPriority: IntArray? = intArrayOf(),
    ): Array<String> {
        return findMethodOpPrefixSeq(
            token,
            opPrefixSeq,
            methodDeclareClass,
            methodName,
            methodReturnType,
            methodParamTypes,
            dexPriority
        )
    }

    private external fun initDexKit(dexpath: String): Long

    private external fun release(token: Long)

    private external fun batchFindClassesUsedStrings(
        token: Long,
        map: Map<String, Set<String>>,
        advancedMatch: Boolean,
        dexPriority: IntArray?,
    ): Map<String, Array<String>>

    private external fun batchFindMethodsUsedStrings(
        token: Long,
        map: Map<String, Set<String>>,
        advancedMatch: Boolean,
        dexPriority: IntArray?,
    ): Map<String, Array<String>>

    private external fun findMethodBeInvoked(
        token: Long,
        methodDescriptor: String,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>?,
        callerMethodDeclareClass: String,
        callerMethodName: String,
        callerMethodReturnType: String,
        callerMethodParamTypes: Array<String>?,
        dexPriority: IntArray?,
    ): Array<String>
    
    private external fun findMethodInvoking(
        token: Long,
        methodDescriptor: String,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>?,
        beCalledMethodDeclareClass: String,
        beCalledMethodName: String,
        beCalledMethodReturnType: String,
        beCalledMethodParamTypes: Array<String>?,
        dexPriority: IntArray?,
    ): Map<String, Array<String>>
    
    private external fun findMethodUsedField(
        token: Long,
        fieldDescriptor: String,
        fieldDeclareClass: String,
        fieldName: String,
        fieldType: String,
        usedFlags: Int,
        callerMethodDeclareClass: String,
        callerMethodName: String,
        callerMethodReturnType: String,
        callerMethodParamTypes: Array<String>?,
        dexPriority: IntArray?,
    ): Array<String>

    private external fun findMethodUsedString(
        token: Long,
        usedString: String,
        advancedMatch: Boolean,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>?,
        dexPriority: IntArray?,
    ): Array<String>

    private external fun findMethod(
        token: Long,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>?,
        dexPriority: IntArray?,
    ): Array<String>

    private external fun findSubClasses(
        token: Long,
        parentClass: String,
        dexPriority: IntArray?,
    ): Array<String>

    private external fun findMethodOpPrefixSeq(
        token: Long,
        opPrefixSeq: IntArray,
        methodDeclareClass: String,
        methodName: String,
        methodReturnType: String,
        methodParamTypes: Array<String>?,
        dexPriority: IntArray?,
    ): Array<String>

    override fun close() {
        release()
    }

    fun String.jniSignatureToJava(): String {
        return this.replace('/', '.').substring(1, this.length - 1)
    }
}
```

`dexkit/src/main/jni/CMakeLists.txt`:

```txt

# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

cmake_minimum_required(VERSION 3.18.1)

project("jni")

set(CMAKE_CXX_STANDARD 17)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-rtti")

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fvisibility=hidden")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fvisibility-inlines-hidden")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility-inlines-hidden")

# 开启空间优化
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Os")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Os")

# 使用gc-section优化
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -ffunction-sections -fdata-sections")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -ffunction-sections -fdata-sections")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wl,--gc-sections")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wl,--gc-sections")

# 使用LTO
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -flto=full")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -flto=full")

# 去除静态库不用的符号
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wl,--exclude-libs,ALL")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wl,--exclude-libs,ALL")

add_library(dex_kit SHARED jni.cpp )

find_library(log-lib log)

# Add two lines below
target_link_libraries(dex_kit dex_kit_static z ${log-lib} )
```

`dexkit/src/main/jni/jni.cpp`:

```cpp
#include <dex_kit.h>
#include "DexKitJniHelper.h"

extern "C"
JNIEXPORT jlong JNICALL
Java_com_github_LuckyPray_DexKitHelper_initDexKit(JNIEnv *env, jobject thiz, jstring dexpath) {
    if (!dexpath) {
        return 0;
    }

    auto cdexpath = env->GetStringUTFChars(dexpath, nullptr);
    auto dexkit = new dexkit::DexKit(cdexpath);
    env->ReleaseStringUTFChars(dexpath, cdexpath);
    return (jlong) dexkit;
}

extern "C"
JNIEXPORT void JNICALL
Java_com_github_LuckyPray_DexKitHelper_release(JNIEnv *env, jobject thiz, jlong token) {
    ReleaseDexKitInstance(env, token);
}

extern "C"
JNIEXPORT jobject JNICALL
Java_com_github_LuckyPray_DexKitHelper_batchFindClassesUsedStrings(JNIEnv *env,
                                                                               jobject thiz,
                                                                               jlong token,
                                                                               jobject map,
                                                                               jboolean advanced_match,
                                                                               jintArray dex_priority) {
    return BatchFindClassesUsedStrings(env, token, map, advanced_match, dex_priority);
}

extern "C"
JNIEXPORT jobject JNICALL
Java_com_github_LuckyPray_DexKitHelper_batchFindMethodsUsedStrings(JNIEnv *env,
                                                                               jobject thiz,
                                                                               jlong token,
                                                                               jobject map,
                                                                               jboolean advanced_match,
                                                                               jintArray dex_priority) {
    return BatchFindMethodsUsedStrings(env, token, map, advanced_match, dex_priority);
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_github_LuckyPray_DexKitHelper_findMethodBeInvoked(JNIEnv *env, jobject thiz,
                                                                       jlong token,
                                                                       jstring method_descriptor,
                                                                       jstring method_declare_class,
                                                                       jstring method_declare_name,
                                                                       jstring method_return_type,
                                                                       jobjectArray method_param_types,
                                                                       jstring caller_method_declare_class,
                                                                       jstring caller_method_declare_name,
                                                                       jstring caller_method_return_type,
                                                                       jobjectArray caller_method_param_types,
                                                                       jintArray dex_priority) {
    return FindMethodBeInvoked(env, token, method_descriptor, method_declare_class,
                               method_declare_name, method_return_type, method_param_types,
                               caller_method_declare_class, caller_method_declare_name,
                               caller_method_return_type, caller_method_param_types, dex_priority);
}

extern "C"
JNIEXPORT jobject JNICALL
Java_com_github_LuckyPray_DexKitHelper_findMethodInvoking(JNIEnv *env, jobject thiz,
                                                                      jlong token,
                                                                      jstring method_descriptor,
                                                                      jstring method_declare_class,
                                                                      jstring method_declare_name,
                                                                      jstring method_return_type,
                                                                      jobjectArray method_param_types,
                                                                      jstring be_called_method_declare_class,
                                                                      jstring be_called_method_declare_name,
                                                                      jstring be_called_method_return_type,
                                                                      jobjectArray be_called_method_param_types,
                                                                      jintArray dex_priority) {
    return FindMethodInvoking(env, token, method_descriptor, method_declare_class,
                              method_declare_name, method_return_type, method_param_types,
                              be_called_method_declare_class, be_called_method_declare_name,
                              be_called_method_return_type, be_called_method_param_types,
                              dex_priority);
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_github_LuckyPray_DexKitHelper_findMethodUsedField(JNIEnv *env, jobject thiz,
                                                                       jlong token,
                                                                       jstring field_descriptor,
                                                                       jstring field_declare_class,
                                                                       jstring field_name,
                                                                       jstring field_type,
                                                                       jint used_flags,
                                                                       jstring caller_method_declare_class,
                                                                       jstring caller_method_name,
                                                                       jstring caller_method_return_type,
                                                                       jobjectArray caller_method_param_types,
                                                                       jintArray dex_priority) {
    return FindMethodUsedField(env, token, field_descriptor, field_declare_class, field_name,
                               field_type, used_flags, caller_method_declare_class,
                               caller_method_name, caller_method_return_type,
                               caller_method_param_types, dex_priority);
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_github_LuckyPray_DexKitHelper_findMethodUsedString(JNIEnv *env, jobject thiz,
                                                                        jlong token,
                                                                        jstring used_string,
                                                                        jboolean advanced_match,
                                                                        jstring method_declare_class,
                                                                        jstring method_name,
                                                                        jstring method_return_type,
                                                                        jobjectArray method_param_types,
                                                                        jintArray dex_priority) {
    return FindMethodUsedString(env, token, used_string, advanced_match, method_declare_class,
                                method_name, method_return_type, method_param_types, dex_priority);
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_github_LuckyPray_DexKitHelper_findMethod(JNIEnv *env, jobject thiz,
                                                              jlong token,
                                                              jstring method_declare_class,
                                                              jstring method_name,
                                                              jstring method_return_type,
                                                              jobjectArray method_param_types,
                                                              jintArray dex_priority) {
    return FindMethod(env, token, method_declare_class, method_name, method_return_type,
                      method_param_types, dex_priority);
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_github_LuckyPray_DexKitHelper_findSubClasses(JNIEnv *env, jobject thiz,
                                                                  jlong token, jstring parent_class,
                                                                  jintArray dex_priority) {
    return FindSubClasses(env, token, parent_class, dex_priority);
}

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_com_github_LuckyPray_DexKitHelper_findMethodOpPrefixSeq(JNIEnv *env, jobject thiz,
                                                                         jlong token,
                                                                         jintArray op_prefix_seq,
                                                                         jstring method_declare_class,
                                                                         jstring method_name,
                                                                         jstring method_return_type,
                                                                         jobjectArray method_param_types,
                                                                         jintArray dex_priority) {
    return FindMethodOpPrefixSeq(env, token, op_prefix_seq, method_declare_class, method_name,
                                 method_return_type, method_param_types, dex_priority);
}
```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Fri Sep 09 17:55:11 CST 2022
distributionBase=GRADLE_USER_HOME
distributionUrl=https\://services.gradle.org/distributions/gradle-7.3.3-bin.zip
distributionPath=wrapper/dists
zipStorePath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`jitpack.yml`:

```yml
jdk:
  - openjdk11
```

`settings.gradle`:

```gradle
pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "DexKit"
include ':dexkit'

```