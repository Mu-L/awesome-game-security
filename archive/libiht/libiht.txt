Project Path: arc_libiht_libiht__gwnx8h7

Source Tree:

```txt
arc_libiht_libiht__gwnx8h7
├── LICENSE
├── README.md
├── docs
│   ├── build
│   │   ├── kmd.md
│   │   ├── lib.md
│   │   └── lkm.md
│   └── usage
│       ├── kernel.md
│       ├── lib.md
│       └── plugins.md
├── kernel
│   ├── commons
│   │   ├── Makefile
│   │   ├── README.md
│   │   ├── bts.c
│   │   ├── bts.h
│   │   ├── debug.c
│   │   ├── debug.h
│   │   ├── lbr.c
│   │   ├── lbr.h
│   │   ├── types.h
│   │   ├── xioctl.h
│   │   └── xplat.h
│   ├── demo
│   │   ├── kmd-demo
│   │   │   ├── kmd-demo
│   │   │   │   ├── kmd-demo.cpp
│   │   │   │   ├── kmd-demo.vcxproj
│   │   │   │   ├── kmd-demo.vcxproj.filters
│   │   │   │   └── kmd-demo.vcxproj.user
│   │   │   └── kmd-demo.sln
│   │   └── lkm-demo
│   │       ├── Makefile
│   │       └── lkm-demo.c
│   ├── kmd
│   │   ├── include
│   │   │   ├── headers_kmd.h
│   │   │   └── libiht_kmd.h
│   │   ├── infinity_hook
│   │   │   ├── hde
│   │   │   │   ├── hde64.cpp
│   │   │   │   ├── hde64.h
│   │   │   │   ├── pstdint.h
│   │   │   │   └── table64.h
│   │   │   ├── headers.hpp
│   │   │   ├── hook.cpp
│   │   │   ├── hook.hpp
│   │   │   ├── imports.hpp
│   │   │   └── utils.hpp
│   │   ├── kmd.inf
│   │   ├── kmd.sln
│   │   ├── kmd.vcxproj
│   │   ├── kmd.vcxproj.filters
│   │   ├── kmd.vcxproj.user
│   │   └── src
│   │       ├── libiht_kmd.cpp
│   │       └── xplat_kmd.c
│   └── lkm
│       ├── Makefile
│       ├── include
│       │   ├── headers_lkm.h
│       │   └── libiht_lkm.h
│       └── src
│           ├── libiht_lkm.c
│           └── xplat_lkm.c
└── lib
    ├── commons
    │   └── api.h
    ├── demo
    │   ├── kmd-demo
    │   │   ├── kmd-demo
    │   │   │   ├── kmd-demo.cpp
    │   │   │   ├── kmd-demo.vcxproj
    │   │   │   ├── kmd-demo.vcxproj.filters
    │   │   │   └── kmd-demo.vcxproj.user
    │   │   └── kmd-demo.sln
    │   └── lkm-demo
    │       ├── Makefile
    │       ├── gdb-demo.c
    │       └── lkm-demo.c
    ├── kmd
    │   ├── kmd
    │   │   ├── dllmain.cpp
    │   │   ├── framework.h
    │   │   ├── kmd.cpp
    │   │   ├── kmd.h
    │   │   ├── kmd.sln
    │   │   ├── kmd.vcxproj
    │   │   ├── kmd.vcxproj.filters
    │   │   ├── kmd.vcxproj.user
    │   │   ├── pch.cpp
    │   │   └── pch.h
    │   └── kmd-ext
    │       ├── Source.def
    │       ├── dllmain.cpp
    │       ├── framework.h
    │       ├── kmd-ext.cpp
    │       ├── kmd-ext.h
    │       ├── kmd-ext.sln
    │       ├── kmd-ext.vcxproj
    │       ├── kmd-ext.vcxproj.filters
    │       ├── kmd-ext.vcxproj.user
    │       ├── pch.cpp
    │       └── pch.h
    └── lkm
        ├── include
        │   └── lkm.h
        └── src
            ├── Makefile
            ├── api.c
            └── libiht-gdb.py

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# LibIHT (Intel Hardware Trace Library)

<p align="center">
   <img src="https://i.imgur.com/PbQXUEL.png" style="width: 50%;" alt="LibIHT Logo Desc"/>
</p>

LibIHT (Intel Hardware Trace Library) is a cross platform library framework for managing (i.e., retrieving, analyzing, and visualizing) hardware trace information from Intel processors and helping reverse engineers and security researchers to understand the control flow behavior of the target program. We assume users have a basic understanding of operating systems, computer architecture, and Intel hardware trace capabilities.

Modern Intel CPUs have introduced a suite of hardware features, such as Last Branch Record (LBR) and Branch Trace Store (BTS), which promise to deliver detailed program tracing information with minimal overhead. LibIHT bridge the gap between low-level hardware trace capabilities and high-level user space applications by offering both kernel and user interfaces that hide all the complexity of hardware-assisted tracing and a user-friendly approach to interacting with Intel CPU hardware trace features.

It is proudly brought to you by **[Tencent Security Xuanwu Lab](https://xlab.tencent.com/en/)** and its long-term talent cultivation program **Tencent Spark Talent Program**.

It has been selected by the following security conferences:

- **Black Hat USA 2024**: [LIBIHT: A Cross-Platform Library for Accessing Intel Hardware Trace Features](https://www.blackhat.com/us-24/arsenal/schedule/#libiht-a-cross-platform-library-for-accessing-intel-hardware-trace-features-38754), [Video](https://www.youtube.com/watch?v=4FodtsPNABc), [Slides](https://github.com/ThomasonZhao/Slides/blob/main/BHUS24-Arsenal-Zhao-LibIHT.pdf)

## LibIHT Components

The LibIHT library consists of two main components: kernel space components and user space components.

The kernel space components are responsible for retrieving raw hardware trace information from the Intel processors and process granular trace control operations, such as enabling/disabling hardware trace capabilities, configuring hardware trace parameters.

The user space components are responsible for providing a set of APIs for user space applications to access the raw hardware trace information, control the hardware trace capabilities of the Intel processors, and help with basic analyze of the raw hardware trace information.

### Kernel Space Components

The kernel space components are implemented as a kernel module on Linux and a kernel driver on Windows. By taking advantage of the ring 0 kernel space, the kernel space components can communicate with the Intel processors directly and collect the information as it is generated.

### User Space Components

The user space components are implemented as a shared library on Linux and a dynamic link library on Windows. It interact with the kernel space components to retrieve the raw hardware trace information through IOCTLs. Base on the raw hardware trace information, it provides interfaces for user space applications with more upper-level operations, such as control the hardware trace capabilities of the Intel processors, and help with basic analyze of the raw hardware trace information.

## Build & Usage

Depending on the operating systems and components, detailed instructions are provided in separate documents and directories. Please refer to the following links for more information:

- Build Instructions documents directory: [docs/build](./docs/build/)
  - [Build LibIHT Linux Kernel Components](./docs/build/lkm.md)
  - [Build LibIHT Windows Kernel Components](./docs/build/kmd.md)
  - [Build LibIHT User Space Library](./docs/build/lib.md)

- Usage documents directory: [docs/usage](./docs/usage/)
  - [Usage of LibIHT Kernel Space Components](./docs/usage/kernel.md)
  - [Usage of LibIHT User Space Library](./docs/usage/lib.md)
  - [Usage of LibIHT Debugger Plugin](./docs/usage/plugins.md)

## Contributing

We welcome contributions to the LibIHT project. Here's how you can help:

- **Reporting issues:** If you find any problems or have suggestions about the library, please create an issue on GitHub. Be sure to include as much detail as possible so we can understand and reproduce the problem.

- **Improving the code:** If you'd like to fix a bug or implement a new feature, feel free to fork the repository and submit a pull request. Please make sure your code follows the existing style for consistency.

- **Testing on different platforms:** The library supports Windows 10 and above, and Linux kernel version 5.0 and above. If you have access to other platforms or versions, your help in testing the library would be very valuable.

Thank you for considering contributing to LibIHT!

## FAQ

**Q: What versions of Windows and Linux are supported?**

A: The library is currently been tested on Windows 10 21H1 debug version, and Linux kernel version 5.15.* with Ubuntu 22.04.

**Q: What Intel processors are supported?**

A: The library supports any Intel processors with hardware trace (Intel Processor Trace, Last Branch Record, Brach Trace Store, etc.) capabilities. Please refer to [Intel Software Developer Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html) for more information. Typically, morden Intel processors (e.g., Intel Core, Intel Xeon, etc.) are supported.

**Q: Is there any documentation available for the APIs?**

A: Yes, you can find the API documentation are specified in [usage](./docs/usage/) directory.

## Citation

We have systematically evaluated LibIHT in academic publication. If you have used LibIHT or its sub-components in your research, please cite the following paper describing it:

```bibtex
@inproceedings{zhaoLibIHTHardwareBasedApproach2025,
title = {LibIHT: A Hardware-Based Approach to Efficient and Evasion-Resistant Dynamic Binary Analysis},
author = {Changyu Zhao and Yohan Beugin and Jean-Charles Noirot Ferrand and Quinn Burke and Guancheng Li and Patrick McDaniel},
month = oct,
year = {2025},
booktitle = {Proceedings of the 1st Workshop on Software Understanding and Reverse Engineering (SURE 2025)},
doi = {10.1145/3733822.3764670},
}
```


```

`docs/build/kmd.md`:

```md
# Build Instruction for KMD (Kernel Mode Driver)

The KMD(Kernel Mode Driver) component of LibIHT provides functionality for retrieving raw hardware trace information from the Intel processors within the Windows kernel.

## Disclaimer

Following this procedure will run some scripts, code, and command as system-level privileged user, and load a kernel module/driver. This is **inherently dangerous** and **should not** be done on a production system or any system that contains sensitive data. We **highly recommend** you to prepare a seperate machine for LibIHT.

By proceeding, you acknowledge that you are doing so at your own risk. The authors of this document and the LibIHT project are not responsible for any damage or loss of data that may occur as a result of following these instructions.

## Build

If you wish to build the KMD component of LibIHT yourself, you will need to install the [Software Development Kit (SDK)](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/) and [Windows Driver Kit (WDK)](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk) and [Visual Studio](https://visualstudio.microsoft.com/downloads/). (Typically SDK will come with the Visual Studio, but it is recommended to install the latest SDK and WDK). Once installed, you can build the KMD component of LibIHT using the provided Visual Studio solution file (`kmd.sln`).

Navigate to the `kernel/kmd` directory and run the following command to build the KMD component of LibIHT:

```powershell
msbuild /p:Configuration=Debug /p:Platform=x64 .\kmd.sln
```

Please refer to the Microsoft's documentation on [building a driver](https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/building-a-driver) for more detailed instructions on building the KMD component of LibIHT.

## Usage

To use the KMD component of LibIHT, you will need to load the driver into the Windows kernel. You can do this using the `sc` command in the command prompt. Run the following command to load the driver:

```powershell
sc create libiht type= kernel binPath= <path-to-kmd.sys>
```

Once the driver is loaded, you can use the IOCTL to interact with Windows file device `\\\\.\\libiht-info` to access the raw hardware trace information.

Please refer to the article on [loading a Windows kernel driver](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/loading-a-windows-kernel-driver-osr-driver-loader-debugging-with-source-code) for more detailed instructions on loading the KMD component of LibIHT.

## Kernel Debugging

Luckily, Microsoft provides a powerful feature to do remote kernel debug on Windows. Please refer to the Microsoft's documentation on [set up KDNET network kernel debugging manually](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection) for more detailed instructions on setting up KDNET network kernel debugging.

## Useful Links

- [Microsoft's documentation on building a driver](https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/building-a-driver)
- [Microsoft's documentation on getting started with WinDbg](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg--kernel-mode-)
- [Microsoft's documentation on debugging a universal driver](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debug-universal-drivers---step-by-step-lab--echo-kernel-mode-)

```

`docs/build/lib.md`:

```md
# Build Instruction for User Space Library

The User Space Library component of LibIHT provides functionality for retrieving raw hardware trace information from the Intel processors within the user space.

## Linux Build

To build the userspace library, use the provided Makefile located in the `lib` directory. Run `make` to compile the library. Once compiled, you can link your applications with the LibIHT library and utilize the provided APIs for accessing Intel hardware trace capabilities. Refer to the documentation for detailed instructions on building and using the userspace library.

## Windows Build

To build the userspace library on Windows, you will need to install the [Software Development Kit (SDK)](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/) and [Visual Studio](https://visualstudio.microsoft.com/downloads/). Once installed, you can build the userspace library using the provided Visual Studio solution file.

Navigate to the `lib/kmd` directory and run the following command to build the KMD component of LibIHT:

```powershell
msbuild /p:Configuration=Debug /p:Platform=x64 .\kmd.sln
```

```

`docs/build/lkm.md`:

```md
# Build Instruction for LKM (Linux Kernel Module)

The LKM (Linux Kernel Module) component of LibIHT provides functionality for retrieving raw hardware trace information from the Intel processors within the Linux kernel.

## Disclaimer

Following this procedure will run some scripts, code, and command as system-level privileged user, and load a kernel module/driver. This is **inherently dangerous** and **should not** be done on a production system or any system that contains sensitive data. We **highly recommend** you to prepare a seperate machine for LibIHT.

By proceeding, you acknowledge that you are doing so at your own risk. The authors of this document and the LibIHT project are not responsible for any damage or loss of data that may occur as a result of following these instructions.

## Build

If you wish to build the LKM component of LibIHT yourself, you will need to install the [GNU Make](https://www.gnu.org/software/make/), build essentials and Linux header. On Ubuntu, you can install these dependencies using the following command:

```bash
sudo apt install build-essential linux-headers-$(uname -r)
```

Once installed, you can build the LKM component of LibIHT using the provided Makefile. Navigate to the `kernel/lkm` directory and run the following command to build the LKM component of LibIHT:

```bash
make
```

## Usage

To use the LKM component of LibIHT, you will need to load the driver into the Linux kernel. You can do this using the `insmod` command in the terminal. Run the following command to load the driver:

```bash
sudo insmod libiht.ko
```

Once the driver is loaded, you can use IOCTL to interact with `/proc/libiht-info` to access the raw hardware trace information.

Please refer to the article on [loading a Linux kernel module](https://www.cyberciti.biz/faq/linux-how-to-load-a-kernel-module-automatically-at-boot-time/) for more detailed instructions on loading the LKM component of LibIHT.

## Kernel Debugging

Kernel debugging on Linux is a complex topic and is beyond the scope of this document. Please refer to the [Linux Kernel Debugging](https://www.kernel.org/doc/html/latest/dev-tools/kgdb.html) documentation for more detailed instructions on setting up kernel debugging on Linux.

```

`docs/usage/kernel.md`:

```md
# Kernel Module/Driver Usage

This document provides an overview of the IOCTL operations and their usage in the kernel module/driver. The kernel module/driver is responsible for retrieving raw hardware trace information from Intel processors. Therefore, it only provides very low level operations to users and hides part of the complexity of hardware-assisted tracing. 

To interact with the kernel module/driver, it requires the user to have a basic understanding of the hardware trace capabilities of Intel processors. For more detailed information about Intel LBR or BTS, please refer to the respective chapter in Volume 3 of the Intel Software Developer's Manual at http://www.intel.com/sdm.

## Introduction

The libiht kernel module/driver provides a set of simple IOCTL operations to interact with the hardware trace capabilities of Intel processors. The IOCTL operations are used to enable/disable, configure, and retrieve the raw hardware trace information from the Last Branch Record (LBR) and Branch Trace Store (BTS) features. The IOCTL operations are organized as follows:

- *Enable trace capabilities* \- Enable the hardware trace capabilities with a specified config (if none, use the default config) for specified process ID and its future children.
- *Disable trace capabilities* \- Disable the hardware trace capabilities for the specified process ID.
- *Config trace information* \- Configure the hardware trace preference (e.g., trace filter, buffer size, etc.) for the specified process ID.
- *Dump trace information* \- Dump the most recent raw hardware trace information for the specified process ID.

For cross-platform compatibility, the IOCTL operations are defined in a generic format and implemented in the kernel module/driver. The user can use one IOCTL request structure to interact all the hardware trace capabilities across different platforms.

## Enable Trace Capabilities

By default, after loading the kernel module/driver, the hardware trace capabilities are disabled and all trace related hardware registers are flushed. The kernel module/driver will expose a process or character device interface to user space applications. To enable the hardware trace capabilities, the user needs to send an IOCTL request with the command code `LIBIHT_IOCTL_ENABLE_LBR` or `LIBIHT_IOCTL_ENABLE_BTS` to the kernel module/driver. The kernel module/driver will enable the hardware trace capabilities with specified configuration for the specified process ID and its future children.

It gives the user the flexibility to start tracing the target process only when needed. They can enable the trace as shown below:

```c
struct xioctl_request request;
int fd, pid;

// Open the process or character device
fd = open(<proc_or_char_dev>, O_RDWR);
pid = <target_pid>;

// Setup the buffers for storing the trace information
memset(&request, 0, sizeof(request));
request.body.<feature>.buffer  = malloc(<size_may_varies>);
// May require multiple malloc setup for the buffer

// Setup the target process ID and the trace configuration
request.body.<feature>.<feature_config>.<specific_config> = <specified_config>;
request.body.<feature>.<feature_config>.pid = pid;

// Enable the trace capabilities
request.cmd = <feature_code>;
ioctl(fd, <feature_code_base>, &request);

// Follow with the crucial operations that we want to trace
...
```

For more details about the buffer setup and raw trace data structure, please check appendix [LBR IOCTL Request](#lbr-ioctl-request) and [BTS IOCTL Request](#bts-ioctl-request) for the specific hardware trace.

## Disable Trace Capabilities

To disable the hardware trace capabilities, the user needs to send an IOCTL request with the command code `LIBIHT_IOCTL_DISABLE_LBR` or `LIBIHT_IOCTL_DISABLE_BTS` to the kernel module/driver. The kernel module/driver will disable the hardware trace capabilities and their traced information for the specified process ID.

It gives the user the flexibility to stop tracing the target process when it is no longer needed. They can disable the trace as shown below:

```c
struct xioctl_request request;
int fd, pid;

// Finish the crucial operations that we want to trace
...

// Open the process or character device
fd = open(<proc_or_char_dev>, O_RDWR);
pid = <target_pid>;

// Setup the target process ID
request.body.<feature>.<feature_config>.pid = pid;

// Disable the trace capabilities
request.cmd = <feature_code>;
ioctl(fd, <feature_code_base>, &request);
```

## Config Trace Information

To configure the hardware trace information, the user needs to send an IOCTL request with the command code `LIBIHT_IOCTL_CONFIG_LBR` or `LIBIHT_IOCTL_CONFIG_BTS` to the kernel module/driver. The kernel module/driver will configure the hardware trace preference (e.g., trace filter, buffer size, etc.) for the specified process ID.

The configuration of the hardware trace information is crucial for the user to capture the desired trace information. It may vary based on the user's requirements and the hardware trace capabilities. (e.g., only want to trace function call jumps with LBR, or want to trace all branches with BTS). Users can configure the trace information as shown below:

```c
struct xioctl_request request;
int fd, pid;

// Open the process or character device
fd = open(<proc_or_char_dev>, O_RDWR);
pid = <target_pid>;

// Setup the target process ID and the trace configuration
request.body.<feature>.<feature_config>.<specific_config> = <specified_config>;
request.body.<feature>.<feature_config>.pid = pid;

// Config the trace information
request.cmd = <feature_code>;
ioctl(fd, <feature_code_base>, &request);
```

For more detailed explanation of the configuration, please check appendix [LBR Configuration](#lbr-configuration) and [BTS Configuration](#bts-configuration) for the specific hardware trace

## Dump Trace Information

To dump the hardware trace information, the user needs to send an IOCTL request with the command code `LIBIHT_IOCTL_DUMP_LBR` or `LIBIHT_IOCTL_DUMP_BTS` to the kernel module/driver. The kernel module/driver will dump the most recent raw hardware trace information for the specified process ID.

The dump operation is crucial for the users and our user space library component to analyze the trace information and understand the control flow behavior of the target program. Users can dump the trace information as shown below:

```c
struct xioctl_request request;
int fd, pid;

// Open the process or character device
fd = open(<proc_or_char_dev>, O_RDWR);
pid = <target_pid>;

// Setup the target process ID
request.body.<feature>.<feature_config>.pid = pid;

// Dump the trace information (Assume the buffer is already allocated)
request.cmd = <feature_code>;
ioctl(fd, <feature_code_base>, &request);
// All the trace information will be copied to the userspace buffer
```

For more details about the buffer setup and raw trace data structure, please check appendix [LBR IOCTL Request](#lbr-ioctl-request) and [BTS IOCTL Request](#bts-ioctl-request) for the specific hardware trace.

## Appendix

### IOCTL Request Command Code

The IOCTL request command code is defined as follows:

```c
enum IOCTL {
    LIBIHT_IOCTL_BASE,          // Placeholder

    // LBR
    LIBIHT_IOCTL_ENABLE_LBR,
    LIBIHT_IOCTL_DISABLE_LBR,
    LIBIHT_IOCTL_DUMP_LBR,
    LIBIHT_IOCTL_CONFIG_LBR,
    LIBIHT_IOCTL_LBR_END,       // End of LBR

    // BTS
    LIBIHT_IOCTL_ENABLE_BTS,
    LIBIHT_IOCTL_DISABLE_BTS,
    LIBIHT_IOCTL_DUMP_BTS,
    LIBIHT_IOCTL_CONFIG_BTS,
    LIBIHT_IOCTL_BTS_END,       // End of BTS
};
```

- `LIBIHT_IOCTL_BASE`: Placeholder for the base IOCTL request code.
- `LIBIHT_IOCTL_ENABLE_LBR`: Enable the Last Branch Record (LBR) hardware trace capability
- `LIBIHT_IOCTL_DISABLE_LBR`: Disable the Last Branch Record (LBR) hardware trace capability
- `LIBIHT_IOCTL_DUMP_LBR`: Dump the Last Branch Record (LBR) hardware trace information
- `LIBIHT_IOCTL_CONFIG_LBR`: Config the Last Branch Record (LBR) hardware trace information
- `LIBIHT_IOCTL_LBR_END`: End of Last Branch Record (LBR) hardware trace commands
- `LIBIHT_IOCTL_ENABLE_BTS`: Enable the Branch Trace Store (BTS) hardware trace capability
- `LIBIHT_IOCTL_DISABLE_BTS`: Disable the Branch Trace Store (BTS) hardware trace capability
- `LIBIHT_IOCTL_DUMP_BTS`: Dump the Branch Trace Store (BTS) hardware trace information
- `LIBIHT_IOCTL_CONFIG_BTS`: Configure the Branch Trace Store (BTS) hardware trace capability
- `LIBIHT_IOCTL_BTS_END`: End of Branch Trace Store (BTS) hardware trace commands

### Generic IOCTL Request Format

The generic IOCTL request format is defined as follows:

```c
struct xioctl_request{
    enum IOCTL cmd;
    union {
        struct lbr_ioctl_request lbr;
        struct bts_ioctl_request bts;
    } body;
};
```

- `cmd`: The IOCTL command code.
- `body`: The body of the IOCTL request, which contains the specific hardware trace capability request.

#### LBR IOCTL Request

The LBR IOCTL request is defined as follows:

```c
struct lbr_ioctl_request{
    struct lbr_config lbr_config;
    struct lbr_data *buffer;
};
```

- `lbr_config`: The LBR configuration structure.
- `buffer`: The buffer for storing the LBR trace information.

The LBR configuration structure is defined as follows:

```c
struct lbr_config
{
    u32 pid;                          // Process ID
    u64 lbr_select;                   // MSR_LBR_SELECT
};
```

- `pid`: The process ID for filtering the LBR trace information.
- `lbr_select`: The value of the `MSR_LBR_SELECT` register.

The LBR data structure is defined as follows:

```c
struct lbr_data
{
    u64 lbr_tos;                      // MSR_LBR_TOS
    struct lbr_stack_entry *entries;  // LBR stack entries
};
```

- `lbr_tos`: The value of the `MSR_LBR_TOS` register.
- `entries`: The LBR stack entries.

The LBR stack entry structure is defined as follows:

```c
struct lbr_stack_entry
{
    u64 from;   // Retrieve from MSR_LBR_NHM_FROM + offset
    u64 to;     // Retrieve from MSR_LBR_NHM_TO + offset
};
```

- `from`: The value of the `MSR_LBR_NHM_FROM` register.
- `to`: The value of the `MSR_LBR_NHM_TO` register.

#### LBR Configuration

The LBR uses the `MSR_LBR_SELECT` register to configure the LBR trace information. The `MSR_LBR_SELECT` register is defined as follows:

```c
/* Bit Field  Bit Offset  Access  Description
 *
 * CPL_EQ_0      0   R/W     When set, do not capture branches ending in ring 0
 * CPL_NEQ_0     1   R/W     When set, do not capture branches ending in ring >0
 * JCC           2   R/W     When set, do not capture conditional branches
 * NEAR_REL_CALL 3   R/W     When set, do not capture near relative calls
 * NEAR_IND_CALL 4   R/W     When set, do not capture near indirect calls
 * NEAR_RET      5   R/W     When set, do not capture near returns
 * NEAR_IND_JMP  6   R/W     When set, do not capture near indirect jumps
 * NEAR_REL_JMP  7   R/W     When set, do not capture near relative jumps
 * FAR_BRANCH    8   R/W     When set, do not capture far branches
 * Reserved      63:9        Must be zero
 *
 * Default selection bit set to:
 * 0x1 = 00000001   --> capture branches occuring in ring >0
 */
#define LBR_SELECT              (1UL <<  0)
```

By default, the `MSR_LBR_SELECT` register is set to capture all branches occurring in ring >0. Users can configure the `MSR_LBR_SELECT` register to filter the LBR trace information based on their requirements.

#### BTS IOCTL Request

The BTS IOCTL request is defined as follows:

```c
struct bts_ioctl_request{
    struct bts_config bts_config;
    struct bts_data *buffer;
};
```

- `bts_config`: The BTS configuration structure.
- `buffer`: The buffer for storing the BTS trace information.

The BTS configuration structure is defined as follows:

```c
struct bts_config
{
    u32 pid;                        // Process ID
    u64 bts_config;                 // MSR_IA32_DEBUGCTLMSR
    u64 bts_buffer_size;            // BTS buffer size
};
```

- `pid`: The process ID for filtering the BTS trace information.
- `bts_config`: The value of the `MSR_IA32_DEBUGCTLMSR` register.
- `bts_buffer_size`: The size of the BTS buffer.

The BTS data structure is defined as follows:

```c
struct bts_data
{
    struct bts_record *bts_buffer_base; // BTS buffer base
    struct bts_record *bts_index;       // BTS current index
    u64 bts_interrupt_threshold;        // BTS interrupt threshold
};
```

- `bts_buffer_base`: The base address of the BTS buffer.
- `bts_index`: The current index of the BTS buffer.
- `bts_interrupt_threshold`: The interrupt threshold of the BTS buffer.

The BTS record structure is defined as follows:

```c
struct bts_record
{
    u64 from;   // branch from
    u64 to;     // branch to
    u64 misc;   // misc information
};
```

- `from`: The source address of the branch.
- `to`: The destination address of the branch.
- `misc`: The miscellaneous information of the branch.

#### BTS Configuration

The BTS uses the `MSR_IA32_DEBUGCTLMSR` register to configure the BTS trace information. The `MSR_IA32_DEBUGCTLMSR` register is defined as follows:

```c
/* CPL-Qualified Branch Trace Store Encodings (Table 18-6 from Intel SDM)
 *
 * TR  BTS  BTS_OFF_OS  BTS_OFF_USR  BTINT  Description
 * 0    X        X           X         X    Branch trace messages (BTMs) off
 * 1    0        X           X         X    Generates BTMs but do not store BTMs
 * 1    1        0           0         0    Store all BTMs in the BTS buffer, 
 *                                          used here as a circular buffer
 * 1    1        1           0         0    Store BTMs with CPL > 0 in the BTS 
 *                                          buffer
 * 1    1        0           1         0    Store BTMs with CPL = 0 in the BTS 
 *                                          buffer
 * 1    1        1           1         X    Generate BTMs but do not store BTMs
 * 1    1        0           0         1    Store all BTMs in the BTS buffer; 
 *                                          generate an interrupt when the 
 *                                          buffer is nearly full
 * 1    1        1           0         1    Store BTMs with CPL > 0 in the BTS 
 *                                          buffer; generate an interrupt when 
 *                                          the buffer is nearly full
 * 1    1        0           1         1    Store BTMs with CPL = 0 in the BTS 
 *                                          buffer; generate an interrupt when 
 *                                          the buffer is nearly full
 */
#define DEFAULT_BTS_CONFIG     (DEBUGCTLMSR_TR | DEBUGCTLMSR_BTS | DEBUGCTLMSR_BTS_OFF_OS)
```

By default, BTS is configured to store all traces in the BTS buffer as a circular buffer. Users can configure the buffer size to store the desired number of records. Base on the design of the processor, the buffer size must be the multiple of `0x18` bytes and the number of records (size / `0x18`) is preferred to be align with a page. The buffer size is defined as follows:

```c
// BTS buffer size 0x200 * 2 = 0x400 = 1024 records
#define DEFAULT_BTS_BUFFER_SIZE        (0x3000 << 1) 
```

```

`docs/usage/lib.md`:

```md
# User Library Usage

User space applications can interact with the kernel space components through the provided user space APIs. The specific user space APIs and their corresponding operations are defined in the [`api.h`](../../lib/commons/api.h) header file. The following sections provide an overview of the user space APIs and their usage.

Currently, the user space APIs are just wrappers of the kernel space IOCTLs. This allows user space applications have a more easier wayy to interact with the kernel space components.

You may also refer to the kernel document for details. We will be providing more high-level APIs in the future.

## Installation

To use the user library on Linux, please include the `lib/include/api.h` and `lib/lkm/include/lkm.h` header files in your code, and compile your code together with `liblbr_api.so`.

On Windows, copy the `x64/Release` directory to your code directory. In your code, include the `lib/include/api.h` and `lib/kmd/kmd.h` header files. Copy the files from `lib/kmd/x64/Release` to your code directory and link against `kmd.dll`.

## Usage

To obtain a `struct lbr_ioctl_request` or `struct bts_ioctl_request` variable for enabling LBR or BTS, you can follow the steps below:

1. Declare a variable of type `struct lbr_ioctl_request` or `struct bts_ioctl_request`. For example:

   ```c
   struct lbr_ioctl_request lbr_request;
   struct bts_ioctl_request bts_request;
   ```

2. Set the necessary parameters in the variable. These parameters may include the buffer size, sampling period, or other configuration options specific to LBR or BTS. Refer to the documentation or header files for the specific structure fields and their meanings. For example:

   ```c
   lbr_request = enable_lbr();
   bts_reqeust = enable_bts();
   ```

3. Call the corresponding functions to perform the desired action, such as `dump_lbr`, `config_lbr`, `disable_lbr`, `dump_bts`, `config_bts`, or `disable_bts`. Pass the created variable as an argument to these functions. For example:

   ```c
   dump_lbr(lbr_request);
   config_lbr(lbr_request);
   disable_lbr(lbr_request);
   ```

   ```c
   dump_bts(&bts_request);
   config_bts(&bts_request);
   disable_bts(&bts_request);
   ```

## Appendix

### User Space API Functions

The user space API functions are defined as follows:

```c
struct lbr_ioctl_request enable_lbr();
void disable_lbr(struct lbr_ioctl_request usr_request);
void dump_lbr(struct lbr_ioctl_request usr_request);
void select_lbr(struct lbr_ioctl_request usr_request);
struct bts_ioctl_request enable_bts();
void disable_bts(struct bts_ioctl_request usr_request);
void dump_bts(struct bts_ioctl_request usr_request);
void config_bts(struct bts_ioctl_request usr_request);
```

- `enable_lbr()`: Enable the Last Branch Record (LBR) hardware trace capability.
- `disable_lbr()`: Disable the Last Branch Record (LBR) hardware trace capability.
- `dump_lbr()`: Dump the Last Branch Record (LBR) hardware trace information.
- `select_lbr()`: Select the Last Branch Record (LBR) hardware trace information.
- `enable_bts()`: Enable the Branch Trace Store (BTS) hardware trace capability.
- `disable_bts()`: Disable the Branch Trace Store (BTS) hardware trace capability.
- `dump_bts()`: Dump the Branch Trace Store (BTS) hardware trace information.
- `config_bts()`: Configure the Branch Trace Store (BTS) hardware trace capability.

### IOCTL Requests

#### LBR IOCTL Request

The LBR IOCTL request is defined as follows:

```c
struct lbr_ioctl_request{
    struct lbr_config lbr_config;
    struct lbr_data *buffer;
};
```

- `lbr_config`: The LBR configuration structure.
- `buffer`: The buffer for storing the LBR trace information.

The LBR configuration structure is defined as follows:

```c
struct lbr_config
{
    u32 pid;                          // Process ID
    u64 lbr_select;                   // MSR_LBR_SELECT
};
```

- `pid`: The process ID for filtering the LBR trace information.
- `lbr_select`: The value of the `MSR_LBR_SELECT` register.

The LBR data structure is defined as follows:

```c
struct lbr_data
{
    u64 lbr_tos;                      // MSR_LBR_TOS
    struct lbr_stack_entry *entries;  // LBR stack entries
};
```

- `lbr_tos`: The value of the `MSR_LBR_TOS` register.
- `entries`: The LBR stack entries.

The LBR stack entry structure is defined as follows:

```c
struct lbr_stack_entry
{
    u64 from;   // Retrieve from MSR_LBR_NHM_FROM + offset
    u64 to;     // Retrieve from MSR_LBR_NHM_TO + offset
};
```

- `from`: The value of the `MSR_LBR_NHM_FROM` register.

- `to`: The value of the `MSR_LBR_NHM_TO` register.

#### BTS IOCTL Request

The BTS IOCTL request is defined as follows:

```c
struct bts_ioctl_request{
    struct bts_config bts_config;
    struct bts_data *buffer;
};
```

- `bts_config`: The BTS configuration structure.
- `buffer`: The buffer for storing the BTS trace information.

The BTS configuration structure is defined as follows:

```c
struct bts_config
{
    u32 pid;                        // Process ID
    u64 bts_config;                 // MSR_IA32_DEBUGCTLMSR
    u64 bts_buffer_size;            // BTS buffer size
};
```

- `pid`: The process ID for filtering the BTS trace information.
- `bts_config`: The value of the `MSR_IA32_DEBUGCTLMSR` register.
- `bts_buffer_size`: The size of the BTS buffer.

The BTS data structure is defined as follows:

```c
struct bts_data
{
    struct bts_record *bts_buffer_base; // BTS buffer base
    struct bts_record *bts_index;       // BTS current index
    u64 bts_interrupt_threshold;        // BTS interrupt threshold
};
```

- `bts_buffer_base`: The base address of the BTS buffer.
- `bts_index`: The current index of the BTS buffer.
- `bts_interrupt_threshold`: The interrupt threshold of the BTS buffer.

The BTS record structure is defined as follows:

```c
struct bts_record
{
    u64 from;   // branch from
    u64 to;     // branch to
    u64 misc;   // misc information
};
```

- `from`: The source address of the branch.
- `to`: The destination address of the branch.
- `misc`: The miscellaneous information of the branch.

```

`docs/usage/plugins.md`:

```md
# Debugger Plugin Usage

The debugger plugin is a cross-platform plugin framework for debugging and analyzing the control flow behavior of the target program. It acts as another layer of abstraction on top of the LibIHT user space library, providing a user-friendly interface for debugging and analyzing the control flow behavior of the target program. For more information about the LibIHT user space library, please refer to the [LibIHT User Library Usage](./lib.md).

Currently it supports GDB and WinDbg as the backend debugger. Both LBR and BTS tracing are supported in both GDB and WinDbg. The GDB plugin is more stable and has more features than the WinDbg plugin. We recommend you to use the GDB plugin for better experience.

## GDB Plugin

To start with, you need to source the GDB plugin script in GDB. The GDB plugin script is located at `lib/lkm/src/libiht-gdb.py`. You can source the script by running the following command in GDB, or add it to your `.gdbinit` file:

```
source /path/to/libiht-gdb.py
```

After sourcing the script, you can use the following commands to interact with the GDB plugin:

- LBR trace commands:

  - `enable_lbr`: Enable Last Branch Record (LBR) tracing.
  - `disable_lbr`: Disable Last Branch Record (LBR) tracing.
  - `dump_lbr`: Dump Last Branch Record (LBR) trace information. It will print the LBR trace information to the console. If valid symbols are available, it will also print the function names.
  - `config_lbr`: Config the Last Branch Record (LBR) trace information.

- BTS trace commands:

  - `enable_bts`: Enable Branch Trace Store (BTS) tracing.
  - `disable_bts`: Disable Branch Trace Store (BTS) tracing.
  - `dump_bts`: Dump Branch Trace Store (BTS) trace information. It will print the BTS trace information to the console. If valid symbols are available, it will also print the function names.
  - `config_bts`: Config the Branch Trace Store (BTS) trace information.

We recommend you to use the GDB plugin in the following way:

1. Start GDB with the target program.
2. Source the GDB plugin script.
3. Enable LBR tracing at the entry point.
4. Break at the ending point of the critical logic you want to analyze or interested in. (Because the LBR trace information is only available for limited amount of branch jumps, we recommend you to use LBR tracing for small functions or basic blocks.)
5. Dump the LBR trace information at the ending point.
6. Analyze the LBR trace information.
7. Continue the execution of the target program.
8.  Repeat the above steps for different functions or basic blocks.
9.  Disable LBR tracing when you finish the analysis.
10. Exit GDB.

## WinDbg Plugin

TODO: Not finish yet.

To start with, you need to load the WinDbg plugin DLL in WinDbg. You will first need to compile the KMD user library DLL under the `lib/kmd/kmd` and WinDbg plugin DLL under the `lib/kmd/kmd-ext` directory. For more information about building the KMD user library DLL, please refer to the [Build Instruction for User Space Library](../build/lib.md). Basically, you can just run `msbuild` under both directories to compile the DLLs.

After compiling the DLL, you can load the DLL in WinDbg by running the following command:

```windbg
.load C:\path\to\kmd-ext.dll
```

To unload the DLL, you can run the following command:

```windbg
.unload C:\path\to\kmd-ext.dll
```

We do recommend you to copy the DLL to one of the `PATH` directories (will show up if you use command `.chain`) that WinDbg searches, so that you can just use the DLL name to load it. (Can be something like `C:\Users\<username>\AppData\Local\EngineExtensions\` depending on how your WinDbg is configured.)

For more information about the WinDbg plugin, please refer to official WinDbg documentation about [Loading Debugger Extension DLLs](https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/loading-debugger-extension-dlls).

After loading the WinDbg plugin DLL, you can use the following commands to interact with the WinDbg plugin:

- LBR trace commands:
  - `!EnableLBR`: Enable Last Branch Record (LBR) tracing.
  - `!DisableLBR`: Disable Last Branch Record (LBR) tracing.
  - `!DumpLBR`: Dump Last Branch Record (LBR) trace information. It will print the LBR trace information to the console. If valid symbols are available, it will also print the function names.
  - `!ConfigLBR`: Config the Last Branch Record (LBR) trace information.

- BTS trace commands:
  - `!EnableBTS`: Enable Branch Trace Store (BTS) tracing.
  - `!DisableBTS`: Disable Branch Trace Store (BTS) tracing.
  - `!DumpBTS`: Dump Branch Trace Store (BTS) trace information. It will print the BTS trace information to the console. If valid symbols are available, it will also print the function names.
  - `!ConfigBTS`: Config the Branch Trace Store (BTS) trace information.


Similar to the GDB plugin, we recommend you to use the WinDbg plugin in the following way:

1. Start WinDbg with the target program.
2. Load the WinDbg plugin DLL.
3. Enable LBR tracing at the entry point.
4. Break at the ending point of the critical logic you want to analyze or interested in. (Because the LBR trace information is only available for limited amount of branch jumps, we recommend you to use LBR tracing for small functions or basic blocks.)
5. Dump the LBR trace information at the ending point.
6. Analyze the LBR trace information.
7. Continue the execution of the target program.
8. Repeat the above steps for different functions or basic blocks.
9. Disable LBR tracing when you finish the analysis.
10. Exit WinDbg.

```

`kernel/commons/Makefile`:

```
clean:
	rm -f .*.cmd *.o *.ko *.mod.c *.symvers *.order
```

`kernel/commons/README.md`:

```md
# Commons

This directory contains common files used by `kmd` and `lkm`. It adds another layer of abstraction to the project and makes it easier to maintain and add new features.

## Building

This directory does not contain any buildable components. It is used by `kmd` and `lkm` to share common code. The `Makefile` is just for convenience to clean the build intermediates.

## New Features

When considering the addition of a new feature to the project, it's important to first determine its relevance to both `kmd` and `lkm` components. If the feature is applicable to both, it should be integrated into the shared directory. This approach promotes consistency throughout the project, aligning features across both `kmd` and `lkm`.

For features that are incorporated into this shared directory, it's crucial to adhere to the abstractions outlined in the `xplat.h` and `types.h` header files. By doing so, you ensure the new feature's compatibility and applicability with both `kmd` and `lkm`, maintaining the integrity and cohesiveness of the project architecture.
```

`kernel/commons/bts.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/bts.c
//  Description    : This is the implementation of the BTS feature for the
//                   libiht library. See associated documentation for more
//                   information.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#include "bts.h"

//
// Global Variables
char bts_state_lock[MAX_LOCK_LEN];
// Lock for bts state list

char bts_state_head[MAX_LIST_LEN];
// Head of bts state list

////////////////////////////////////////////////////////////////////////////////
//
// Function     : get_bts
// Description  : Get the BTS records out from the BTS buffer. Pause the BTS
//                tracing.
//
// Inputs       : state - the BTS state
// Outputs      : 0 if successful, -1 if failure

void get_bts(struct bts_state *state)
{
    u64 dbgctlmsr;
    char irql_flag[MAX_IRQL_LEN];

    // Disable BTS
    xacquire_lock(bts_state_lock, irql_flag);

    xrdmsr(MSR_IA32_DEBUGCTLMSR, &dbgctlmsr);
    dbgctlmsr &= ~state->config.bts_config;
    xwrmsr(MSR_IA32_DEBUGCTLMSR, dbgctlmsr);

    // Reset BTS debug store buffer pointer
    xwrmsr(MSR_IA32_DS_AREA, NULL);

    xrelease_lock(bts_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : put_bts
// Description  : Put the BTS records into the BTS buffer. Resume the BTS
//                tracing.
//
// Inputs       : state - the BTS state
// Outputs      : 0 if successful, -1 if failure

void put_bts(struct bts_state *state)
{
    u64 dbgctlmsr;
    char irql_flag[MAX_IRQL_LEN];

    // Setup BTS debug store buffer pointer
    xacquire_lock(bts_state_lock, irql_flag);

    xwrmsr(MSR_IA32_DS_AREA, (u64)state->ds_area);

    // Enable BTS
    xrdmsr(MSR_IA32_DEBUGCTLMSR, &dbgctlmsr);
    dbgctlmsr |= state->config.bts_config;
    xwrmsr(MSR_IA32_DEBUGCTLMSR, dbgctlmsr);

    xrelease_lock(bts_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : flush_bts
// Description  : Flush the BTS buffer. Caller should ensure this function is
//                called with interrupts disabled (either on single core or
//                with interrupts disabled for that core).
//
// Inputs       : void
// Outputs      : void

void flush_bts(void)
{
    u64 dbgctlmsr;
    u64 bts_bits;
    char irql_flag[MAX_IRQL_LEN];

    bts_bits = DEBUGCTLMSR_TR |
                DEBUGCTLMSR_BTS |
                DEBUGCTLMSR_BTINT |
                DEBUGCTLMSR_BTS_OFF_OS |
                DEBUGCTLMSR_BTS_OFF_USR;

    xlock_core(irql_flag);

    // Disable BTS
    xprintdbg("LIBIHT-COM: Flush BTS on cpu core: %d...\n", xcoreid());
    xrdmsr(MSR_IA32_DEBUGCTLMSR, &dbgctlmsr);
    dbgctlmsr &= ~bts_bits;
    xwrmsr(MSR_IA32_DEBUGCTLMSR, dbgctlmsr);

    // Reset BTS debug store buffer pointer
    xwrmsr(MSR_IA32_DS_AREA, NULL);

    xrelease_core(irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : enable_bts
// Description  : Enable the BTS.
//
// Inputs       : request - the BTS ioctl request
// Outputs      : 0 if successful, -1 if failure

s32 enable_bts(struct bts_ioctl_request *request)
{
    struct bts_state *state;

    state = find_bts_state(request->bts_config.pid);
    if (state)
    {
        xprintdbg("LIBIHT-COM: BTS already enabled for pid %d.\n",
                    request->bts_config.pid);
        return -1;
    }

    state = create_bts_state();
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: Create BTS state failed.\n");
        return -1;
    }

    // Setup fields for BTS state
    state->parent = NULL;
    state->config.pid = request->bts_config.pid ?
                request->bts_config.pid : xgetcurrent_pid();
    state->config.bts_config = request->bts_config.bts_config ?
                request->bts_config.bts_config : DEFAULT_BTS_CONFIG;
    state->config.bts_buffer_size = request->bts_config.bts_buffer_size ?
                request->bts_config.bts_buffer_size : DEFAULT_BTS_BUFFER_SIZE;

    // Setup fields for BTS debug store area
    state->ds_area->bts_buffer_base = (u64)xmalloc(state->config.bts_buffer_size);
    state->ds_area->bts_index = state->ds_area->bts_buffer_base;
    state->ds_area->bts_absolute_maximum =
            state->ds_area->bts_buffer_base +
            state->config.bts_buffer_size + 1;
    // Not yet support state->ds_area->bts_interrupt_threshold

    // Print BTS debug store area info
    xprintdbg("LIBIHT-COM: BTS ds_area pointer: %llx, bts_buffer_base: %llx, "
                "bts_index: %llx, bts_absolute_maximum: %llx.\n",
                (u64)state->ds_area, state->ds_area->bts_buffer_base,
                state->ds_area->bts_index,
                state->ds_area->bts_absolute_maximum);


    insert_bts_state(state);
    // If the requesting process is the current process, trace it right away
    if (state->config.pid == xgetcurrent_pid())
        put_bts(state);
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : disable_bts
// Description  : Disable the BTS tracing for a given process in request.
//
// Inputs       : request - the BTS ioctl request
// Outputs      : 0 if successful, -1 if failure

s32 disable_bts(struct bts_ioctl_request *request)
{
    struct bts_state *state;

    state = find_bts_state(request->bts_config.pid);
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: BTS not enabled for pid %d.\n",
                    request->bts_config.pid);
        return -1;
    }

    if (state->config.pid == xgetcurrent_pid())
        get_bts(state);
    remove_bts_state(state);
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : dump_bts
// Description  : Dump the BTS records for a given process in request.
//
// Inputs       : request - the BTS ioctl request
// Outputs      : 0 if successful, -1 if failure

s32 dump_bts(struct bts_ioctl_request *request)
{
    u64 i, bytes_left, bts_offset;
    struct bts_state *state;
    struct bts_record *record;
    struct bts_data req_buf;
    char irql_flag[MAX_IRQL_LEN];

    state = find_bts_state(request->bts_config.pid);
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: BTS not enabled for pid %d.\n",
                    request->bts_config.pid);
        return -1;
    }

    // Dump some BTS buffer records
    xacquire_lock(bts_state_lock, irql_flag);

    bts_offset = (state->ds_area->bts_index -
                    state->ds_area->bts_buffer_base) /
                    sizeof(struct bts_record);
    xprintdbg("LIBIHT-COM: BTS buffer base: 0x%llx, index: 0x%llx. offset: 0x%llx\n",
                state->ds_area->bts_buffer_base,
                state->ds_area->bts_index,
                bts_offset);
    for (i = 0; i < state->config.bts_buffer_size / sizeof(struct bts_record); i++)
    {
        record = (struct bts_record*)state->ds_area->bts_buffer_base + i;
        xprintdbg("LIBIHT-COM: BTS record ptr: 0x%llx.\n", (u64)record);
        xprintdbg("LIBIHT-COM: BTS record %d: from %llx to %llx.\n",
                    i, record->from, record->to);
    }

    // Dump the BTS data to userspace buffer
    // TODO: Try best to support mmap share between user and kernel space
    if (request->buffer)
    {
        // Get a copy of data from userspace buffer
        bytes_left = xcopy_from_user(&req_buf, request->buffer,
                                    sizeof(struct bts_data));
        if (bytes_left)
        {
            xprintdbg("LIBIHT-COM: Copy BTS data from user failed.\n");
            xrelease_lock(bts_state_lock, irql_flag);
            return -1;
        }

        // Dump data to userspace buffer ptr
        // Not yet support state->ds_area->bts_interrupt_threshold
        req_buf.bts_index = req_buf.bts_buffer_base + bts_offset;
        if (req_buf.bts_buffer_base)
        {
            bytes_left = xcopy_to_user(req_buf.bts_buffer_base,
                                        (void *)state->ds_area->bts_buffer_base,
                                        state->config.bts_buffer_size);
            if (bytes_left)
            {
                xprintdbg("LIBIHT-COM: Copy to user failed.\n");
                xrelease_lock(bts_state_lock, irql_flag);
                return -1;
            }
        }

        // Copy updated data back to userspace buffer
        bytes_left = xcopy_to_user(request->buffer, &req_buf,
                                    sizeof(struct bts_data));
        if (bytes_left)
        {
            xprintdbg("LIBIHT-COM: Copy to user failed.\n");
            xrelease_lock(bts_state_lock, irql_flag);
            return -1;
        }
    }

    xrelease_lock(bts_state_lock, irql_flag);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : config_bts
// Description  : Configure the BTS trace bits and BTS buffer size for a given
//                process in request.
//
// Inputs       : request - the BTS ioctl request
// Outputs      : 0 if successful, -1 if failure

s32 config_bts(struct bts_ioctl_request *request)
{
    struct bts_state *state;

    state = find_bts_state(request->bts_config.pid);
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: BTS not enabled for pid %d.\n",
                    request->bts_config.pid);
        return -1;
    }

    state->config.bts_config = request->bts_config.bts_config;
    // If the current process is the target process, we need to
    // disable and re-enable BTS to apply the new configuration
    if (xgetcurrent_pid() == request->bts_config.pid)
    {
        // TODO: check if it works
        get_bts(state);

        if (request->bts_config.bts_buffer_size != state->config.bts_buffer_size &&
            request->bts_config.bts_buffer_size != 0)
        {
            state->config.bts_buffer_size = request->bts_config.bts_buffer_size;

            // Reconfigure BTS debug store area
            xfree((void *)state->ds_area->bts_buffer_base);
            state->ds_area->bts_buffer_base = (u64)xmalloc(request->bts_config.bts_buffer_size);
            state->ds_area->bts_index = state->ds_area->bts_buffer_base;
            state->ds_area->bts_absolute_maximum =
                    state->ds_area->bts_buffer_base +
                    request->bts_config.bts_buffer_size + 1;
        }

        put_bts(state);
    }
    else
    {
        if (request->bts_config.bts_buffer_size != state->config.bts_buffer_size &&
            request->bts_config.bts_buffer_size != 0)
        {
            state->config.bts_buffer_size = request->bts_config.bts_buffer_size;

            // Reconfigure BTS debug store area
            xfree((void *)state->ds_area->bts_buffer_base);
            state->ds_area->bts_buffer_base = (u64)xmalloc(request->bts_config.bts_buffer_size);
            state->ds_area->bts_index = 0;
            state->ds_area->bts_absolute_maximum =
                    state->ds_area->bts_buffer_base +
                    request->bts_config.bts_buffer_size + 1;
        }

    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : create_bts_state
// Description  : Create a new BTS state.
//
// Inputs       : void
// Outputs      : The new BTS state

struct bts_state *create_bts_state(void)
{
    struct bts_state *state;

    state = xmalloc(sizeof(struct bts_state));
    if (state == NULL)
        return NULL;
    state->ds_area = xmalloc(sizeof(struct ds_area));
    if (state->ds_area == NULL)
    {
        xfree(state);
        return NULL;
    }

    return state;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : find_bts_state
// Description  : Find a BTS state by pid.
//
// Inputs       : pid - the pid of the target process
// Outputs      : The BTS state

struct bts_state *find_bts_state(u32 pid)
{
    char irql_flag[MAX_IRQL_LEN];
    struct bts_state *curr_state, *ret_state = NULL;
    void *curr_list;
    u64 offset;

    xacquire_lock(bts_state_lock, irql_flag);

    // offsetof(st, m) macro implementation of stddef.h
    offset = (u64)(&((struct bts_state *)0)->list);
    curr_list = xlist_next(bts_state_head);
    while (curr_list != NULL && curr_list != bts_state_head)
    {
        curr_state = (struct bts_state *)((u64)curr_list - offset);
        curr_list = xlist_next(curr_list);
        if (curr_state->config.pid == pid)
        {
            ret_state = curr_state;
            break;
        }
    }

    xrelease_lock(bts_state_lock, irql_flag);

    return ret_state;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : insert_bts_state
// Description  : Insert a new BTS state into the list.
//
// Inputs       : new_state - the new BTS state
// Outputs      : void

void insert_bts_state(struct bts_state *new_state)
{
    char irql_flag[MAX_IRQL_LEN];

    if (new_state == NULL)
        return;

    xacquire_lock(bts_state_lock, irql_flag);
    xprintdbg("LIBIHT-COM: Insert BTS state for pid %d.\n",
                new_state->config.pid);
    xlist_add(new_state->list, bts_state_head);
    xrelease_lock(bts_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : remove_bts_state
// Description  : Remove a BTS state from the list.
//
// Inputs       : old_state - the old BTS state
// Outputs      : void

void remove_bts_state(struct bts_state *old_state)
{
    char irql_flag[MAX_IRQL_LEN];

    if (old_state == NULL)
        return;

    xacquire_lock(bts_state_lock, irql_flag);
    xprintdbg("LIBIHT-COM: Remove BTS state for pid %d.\n",
                old_state->config.pid);
    xlist_del(&old_state->list);
    xfree((void *)old_state->ds_area->bts_buffer_base);
    xfree(old_state->ds_area);
    xfree(old_state);
    xrelease_lock(bts_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : free_bts_state_list
// Description  : Free the BTS state list.
//
// Inputs       : void
// Outputs      : void

void free_bts_state_list(void)
{
    char irql_flag[MAX_IRQL_LEN];
    struct bts_state *curr_state;
    void *curr_list;
    u64 offset;

    xacquire_lock(bts_state_lock, irql_flag);

    // offsetof(st, m) macro implementation of stddef.h
    offset = (u64)(&((struct bts_state *)0)->list);
    curr_list = xlist_next(bts_state_head);
    while (curr_list != NULL && curr_list != bts_state_head)
    {
        curr_state = (struct bts_state *)((u64)curr_list - offset);
        curr_list = xlist_next(curr_list);
        xprintdbg("LIBIHT-COM: Free BTS state for pid %d.\n",
                    curr_state->config.pid);

        xlist_del(curr_state->list);
        xfree((void *)curr_state->ds_area->bts_buffer_base);
        xfree(curr_state->ds_area);
        xfree(curr_state);
    }

    xrelease_lock(bts_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : bts_ioctl_handler
// Description  : The ioctl handler for the BTS.
//
// Inputs       : request - the cross platform ioctl request
// Outputs      : 0 if successful, -1 if failure

s32 bts_ioctl_handler(struct xioctl_request *request)
{
    s32 ret = 0;

    xprintdbg("LIBIHT-COM: BTS ioctl command %d.\n", request->cmd);
    switch (request->cmd)
    {
    case LIBIHT_IOCTL_ENABLE_BTS:
        xprintdbg("LIBIHT-COM: Enable BTS for pid %d.\n",
                    request->body.bts.bts_config.pid);
        ret = enable_bts(&request->body.bts);
        break;

    case LIBIHT_IOCTL_DISABLE_BTS:
        xprintdbg("LIBIHT-COM: Disable BTS for pid %d.\n",
                    request->body.bts.bts_config.pid);
        ret = disable_bts(&request->body.bts);
        break;

    case LIBIHT_IOCTL_DUMP_BTS:
        xprintdbg("LIBIHT-COM: Dump BTS for pid %d.\n",
                    request->body.bts.bts_config.pid);
        ret = dump_bts(&request->body.bts);
        break;

    case LIBIHT_IOCTL_CONFIG_BTS:
        xprintdbg("LIBIHT-COM: Config BTS for pid %d.\n",
                    request->body.bts.bts_config.pid);
        ret = config_bts(&request->body.bts);
        break;

    default:
        xprintdbg("LIBIHT-COM: Invalid BTS ioctl command.\n");
        ret = -1;
        break;
    }

    return ret;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : bts_cswitch_handler
// Description  : The context switch handler for the BTS.
//
// Inputs       : prev_pid - the pid of the previous process
//                next_pid - the pid of the next process
// Outputs      : void

void bts_cswitch_handler(u32 prev_pid, u32 next_pid)
{
    struct bts_state *prev_state, *next_state;

    prev_state = find_bts_state(prev_pid);
    next_state = find_bts_state(next_pid);

    if (prev_state)
    {
        xprintdbg("LIBIHT-COM: BTS context switch from pid %d on core %d\n",
            prev_state->config.pid, xcoreid());
        get_bts(prev_state);
    }

    if (next_state)
    {
        xprintdbg("LIBIHT-COM: BTS context switch to pid %d on core %d\n",
                next_state->config.pid, xcoreid());
        put_bts(next_state);
    }
}

void bts_newproc_handler(u32 parent_pid, u32 child_pid)
{
    struct bts_state *parent_state, *child_state;
    // char irql_flag[MAX_IRQL_LEN];

    parent_state = find_bts_state(parent_pid);
    if (parent_state == NULL)
        return;

    xprintdbg("LIBIHT-COM: BTS new process %d parent pid %d\n",
            child_pid, parent_pid);
    child_state = create_bts_state();
    if (child_state == NULL)
        return;

    child_state->parent = parent_state;
    child_state->config.pid = child_pid;
    child_state->config.bts_config = parent_state->config.bts_config;
    child_state->config.bts_buffer_size = parent_state->config.bts_buffer_size;
    // TODO: memcpy or not? overhead? If yes, acquire lock for this operation
    insert_bts_state(child_state);

    // If the child process is the current process, trace it right away
    if (child_pid == xgetcurrent_pid())
        put_bts(child_state);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : bts_check
// Description  : Check if the BTS is available.
//
// Inputs       : void
// Outputs      : 0 if successful, -1 if failure

s32 bts_check(void)
{
    u32 cpuinfo[4] = { 0 };
    u64 misc_msr;

    xcpuid(1, &cpuinfo[0], &cpuinfo[1], &cpuinfo[2], &cpuinfo[3]);

    // Check if BTS is supported
    if (!(cpuinfo[3] & (1 << X64_FEATURE_DS)))
        return -1;

    // Check if BTS is available
    xrdmsr(MSR_IA32_MISC_ENABLE, &misc_msr);
    if (misc_msr & MSR_IA32_MISC_ENABLE_BTS_UNAVAIL)
        return -1;

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : bts_init
// Description  : Initialize the BTS.
//
// Inputs       : void
// Outputs      : 0 if successful, -1 if failure

s32 bts_init(void)
{
    // Check if BTS is supported and available
    if (bts_check())
    {
        xprintdbg("LIBIHT-COM: BTS is not supported or available.\n");
        return -1;
    }

    xprintdbg("LIBIHT-COM: Init BTS related structs.\n");
    xinit_lock(bts_state_lock);
    xinit_list_head(bts_state_head);

    // Flush BTS on each cpu
    xprintdbg("LIBIHT-COM: Flushing BTS for all cpus...\n");
    xon_each_cpu(flush_bts);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : bts_exit
// Description  : Exit the BTS.
//
// Inputs       : void
// Outputs      : 0 if successful, -1 if failure

s32 bts_exit(void)
{
    // Flush BTS on each cpu
    xprintdbg("LIBIHT-COM: Flushing BTS for all cpus...\n");
    xon_each_cpu(flush_bts);

    // Free bts_state_list
    xprintdbg("LIBIHT-COM: Freeing BTS state list.\n");
    free_bts_state_list();

    return 0;
}

```

`kernel/commons/bts.h`:

```h
#ifndef _COMMONS_BTS_H_
#define _COMMONS_BTS_H_

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/bts.h
//  Description    : This is the header file for the BTS (Branch Trace Store)
//                   module, which is used to capture the branch trace records
//                   of a given process. Some of the macros and constants are
//                   adapted from the Linux kernel source code.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#include "types.h"
#include "xplat.h"
#include "xioctl.h"

// cpp cross compile handler
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Library constants

// Intel-defined CPU features, CPUID level 0x00000001 (EDX), word 0
#ifndef X64_FEATURE_DS
#define X64_FEATURE_DS          (0*32+2)
#endif

// MSR related constants
#ifndef MSR_IA32_DEBUGCTLMSR
#define MSR_IA32_DEBUGCTLMSR    0x000001d9
#endif

#ifndef MSR_IA32_DS_AREA
#define MSR_IA32_DS_AREA        0x00000600
#endif

#ifndef MSR_IA32_MISC_ENABLE
#define MSR_IA32_MISC_ENABLE    0x000001a0
#endif

// MSR bit shifts
#ifndef DEBUGCTLMSR_TR
#define DEBUGCTLMSR_TR          (1UL <<  6)
#endif

#ifndef DEBUGCTLMSR_BTS
#define DEBUGCTLMSR_BTS         (1UL <<  7)
#endif

#ifndef DEBUGCTLMSR_BTINT
#define DEBUGCTLMSR_BTINT       (1UL <<  8)
#endif

#ifndef DEBUGCTLMSR_BTS_OFF_OS
#define DEBUGCTLMSR_BTS_OFF_OS  (1UL <<  9)
#endif

#ifndef DEBUGCTLMSR_BTS_OFF_USR
#define DEBUGCTLMSR_BTS_OFF_USR (1UL << 10)
#endif

#ifndef MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT
#define MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT    11
#endif

#ifndef MSR_IA32_MISC_ENABLE_BTS_UNAVAIL
#define MSR_IA32_MISC_ENABLE_BTS_UNAVAIL    (1ULL << MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT)
#endif

/* CPL-Qualified Branch Trace Store Encodings (Table 18-6 from Intel SDM)
 *
 * TR  BTS  BTS_OFF_OS  BTS_OFF_USR  BTINT  Description
 * 0    X        X           X         X    Branch trace messages (BTMs) off
 * 1    0        X           X         X    Generates BTMs but do not store BTMs
 * 1    1        0           0         0    Store all BTMs in the BTS buffer, 
 *                                          used here as a circular buffer
 * 1    1        1           0         0    Store BTMs with CPL > 0 in the BTS 
 *                                          buffer
 * 1    1        0           1         0    Store BTMs with CPL = 0 in the BTS 
 *                                          buffer
 * 1    1        1           1         X    Generate BTMs but do not store BTMs
 * 1    1        0           0         1    Store all BTMs in the BTS buffer; 
 *                                          generate an interrupt when the 
 *                                          buffer is nearly full
 * 1    1        1           0         1    Store BTMs with CPL > 0 in the BTS 
 *                                          buffer; generate an interrupt when 
 *                                          the buffer is nearly full
 * 1    1        0           1         1    Store BTMs with CPL = 0 in the BTS 
 *                                          buffer; generate an interrupt when 
 *                                          the buffer is nearly full
 */
#define DEFAULT_BTS_CONFIG     (DEBUGCTLMSR_TR | DEBUGCTLMSR_BTS | DEBUGCTLMSR_BTS_OFF_OS)

// BTS buffer size 0x200 * 2 = 0x400 = 1024 records
#define DEFAULT_BTS_BUFFER_SIZE        (0x3000 << 1) 

//
// Type definitions

// Define Debug Store buffer management area (Assuming 64-bit)
struct ds_area
{
    u64 bts_buffer_base;            // BTS buffer base
    u64 bts_index;                  // BTS current index
    u64 bts_absolute_maximum;       // BTS absolute maximum
    u64 bts_interrupt_threshold;    // BTS interrupt threshold
    u64 pebs_buffer_base;           // PEBS placeholder
    u64 pebs_index;                 // PEBS placeholder
    u64 pebs_absolute_maximum;      // PEBS placeholder
    u64 pebs_interrupt_threshold;   // PEBS placeholder
};

// Define BTS state
struct bts_state
{
    char list[MAX_LIST_LEN];            // Kernel linked list
    struct bts_state *parent;           // Parent bts_state
    struct bts_config config;           // BTS configuration
    struct ds_area *ds_area;            // Debug Store area pointer
};

//
// Global Variables

extern char bts_state_lock[MAX_LOCK_LEN];
// The lock for bts_state_list.

extern char bts_state_head[MAX_LIST_LEN];
// The head of the bts_state_list.

//
// Function Prototypes

void get_bts(struct bts_state *state);
// Get the BTS records from the BTS buffer.

void put_bts(struct bts_state *state);
// Put the BTS records into the BTS buffer.

void flush_bts(void);
// Flush the BTS buffer.

s32 enable_bts(struct bts_ioctl_request *request);
// Enable the BTS.

s32 disable_bts(struct bts_ioctl_request *request);
// Disable the BTS.

s32 dump_bts(struct bts_ioctl_request *request);
// Dump the BTS records.

s32 config_bts(struct bts_ioctl_request *request);
// Configure the BTS trace bits

struct bts_state *create_bts_state(void);
// Create a new BTS state

struct bts_state *find_bts_state(u32 pid);
// Find the BTS state by pid

void insert_bts_state(struct bts_state *new_state);
// Insert the BTS state into the list

void remove_bts_state(struct bts_state *old_state);
// Remove the BTS state from the list

void free_bts_state_list(void);
// Free the BTS state list

s32 bts_ioctl_handler(struct xioctl_request *request);
// The ioctl handler for the BTS

void bts_cswitch_handler(u32 prev_pid, u32 next_pid);
// The context switch handler for the BTS

void bts_newproc_handler(u32 parent_pid, u32 child_pid);
// The new process handler for the BTS

s32 bts_check(void);
// Check if the BTS is available

s32 bts_init(void);
// Initialize the BTS

s32 bts_exit(void);
// Exit the BTS


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _COMMONS_BTS_H_

```

`kernel/commons/debug.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/debug.h
//  Description    : This is the implementation of the debug and logging
//                   functions used for libiht library.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//


#include "debug.h"

// TODO: To be implemented, a better logging system instead of just xprintdbg
```

`kernel/commons/debug.h`:

```h
#ifndef _COMMONS_DEBUG_H
#define _COMMONS_DEBUG_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/debug.h
//  Description    : This is the header file for the debug and logging functions
//                   used for libiht library.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// cpp cross compile handler
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Library constants

// Debug control macros
#define DEBUG_MSG
#define ON_INTELx

// Dbg default log levels
#define DBG_ERROR_LEVEL     (1 << 0)
#define DBG_ERROR_DESC      "ERROR"
#define DBG_WARNING_LEVEL   (1 << 1)
#define DBG_WARNING_DESC    "WARNING"
#define DBG_INFO_LEVEL      (1 << 2)
#define DBG_INFO_DESC       "INFO"
#define DBG_OUTPUT_LEVEL    (1 << 3)
#define DBG_OUTPUT_DESC     "OUTPUT"
#define DBG_MAX_LEVEL       (1 << 5)
#define DEFAULT_DBG_LEVEL   (DBG_ERROR_LEVEL | DBG_WARNING_LEVEL | DBG_INFO_LEVEL | DBG_OUTPUT_LEVEL)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _COMMONS_DEBUG_H
```

`kernel/commons/lbr.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/lbr.c
//  Description    : This is the implementation of the LBR feature for the
//                   libiht library. See associated documentation for more
//                   information. The implementation is largely based on the
//                   LBR manipulation of PathArmor project.
//
//                   Reference:
//                   https://github.com/vusec/patharmor/blob/master/lkm/lbr.c
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#include "lbr.h"

//
// Global Variables

u64 lbr_capacity;
// The capacity of the LBR.

char lbr_state_lock[MAX_LOCK_LEN];
// The lock for lbr_state_list.

char lbr_state_head[MAX_LIST_LEN];
// The head of the lbr_state_list.

static const struct cpu_to_lbr cpu_lbr_maps[] = {
    {0x5c, 32}, {0x5f, 32}, {0x4e, 32}, {0x5e, 32}, {0x8e, 32}, {0x9e, 32},
    {0x55, 32}, {0x66, 32}, {0x7a, 32}, {0x67, 32}, {0x6a, 32}, {0x6c, 32},
    {0x7d, 32}, {0x7e, 32}, {0x8c, 32}, {0x8d, 32}, {0xa5, 32}, {0xa6, 32},
    {0xa7, 32}, {0xa8, 32}, {0x86, 32}, {0x8a, 32}, {0x96, 32}, {0x9c, 32},
    {0x3d, 16}, {0x47, 16}, {0x4f, 16}, {0x56, 16}, {0x3c, 16}, {0x45, 16},
    {0x46, 16}, {0x3f, 16}, {0x2a, 16}, {0x2d, 16}, {0x3a, 16}, {0x3e, 16},
    {0x1a, 16}, {0x1e, 16}, {0x1f, 16}, {0x2e, 16}, {0x25, 16}, {0x2c, 16},
    {0x2f, 16}, {0x17,  4}, {0x1d,  4}, {0x0f,  4}, {0x37,  8}, {0x4a,  8},
    {0x4c,  8}, {0x4d,  8}, {0x5a,  8}, {0x5d,  8}, {0x1c,  8}, {0x26,  8},
    {0x27,  8}, {0x35,  8}, {0x36,  8}};
// CPU - LBR map table

//
// Low level LBR stack and registers access

////////////////////////////////////////////////////////////////////////////////
//
// Function     : get_lbr
// Description  : Read the LBR registers into kernel maintained datastructure.
//                And pause the LBR tracing.
//
// Inputs       : state - the LBR state
// Outputs      : void

void get_lbr(struct lbr_state *state)
{
    u32 i;
    u64 dbgctlmsr;
    char irql_flag[MAX_IRQL_LEN];

    // Disable LBR
    xrdmsr(MSR_IA32_DEBUGCTLMSR, &dbgctlmsr);
    dbgctlmsr &= ~DEBUGCTLMSR_LBR;
    xwrmsr(MSR_IA32_DEBUGCTLMSR, dbgctlmsr);

    // Read out LBR registers
    xacquire_lock(lbr_state_lock, irql_flag);

    xrdmsr(MSR_LBR_SELECT, &state->config.lbr_select);
    xrdmsr(MSR_LBR_TOS, &state->data->lbr_tos);

    for (i = 0; i < lbr_capacity; i++)
    {
        xrdmsr(MSR_LBR_NHM_FROM + i, &state->data->entries[i].from);
        xrdmsr(MSR_LBR_NHM_TO + i, &state->data->entries[i].to);
    }

    xrelease_lock(lbr_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : put_lbr
// Description  : Write the LBR registers from kernel maintained datastructure.
//                And resume the LBR tracing.
//
// Inputs       : state - the LBR state
// Outputs      : void

void put_lbr(struct lbr_state *state)
{
    u32 i;
    u64 dbgctlmsr;
    char irql_flag[MAX_IRQL_LEN];

    // Write in LBR registers
    xacquire_lock(lbr_state_lock, irql_flag);

    xwrmsr(MSR_LBR_SELECT, state->config.lbr_select);
    xwrmsr(MSR_LBR_TOS, state->data->lbr_tos);

    for (i = 0; i < lbr_capacity; i++)
    {
        xwrmsr(MSR_LBR_NHM_FROM + i, state->data->entries[i].from);
        xwrmsr(MSR_LBR_NHM_TO + i, state->data->entries[i].to);
    }

    xrelease_lock(lbr_state_lock, irql_flag);

    // Enable LBR
    xrdmsr(MSR_IA32_DEBUGCTLMSR, &dbgctlmsr);
    dbgctlmsr |= DEBUGCTLMSR_LBR;
    xwrmsr(MSR_IA32_DEBUGCTLMSR, dbgctlmsr);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : flush_lbr
// Description  : Flush the LBR stack and registers. Caller should ensure this
//                function is called with interrupts disabled (either on single
//                core or with interrupts disabled for that core).
//
// Inputs       : void
// Outputs      : void

void flush_lbr(void)
{
    u32 i;
    u64 dbgctlmsr;
    char irql_flag[MAX_IRQL_LEN];

    xlock_core(irql_flag);

    // Disable LBR
    xprintdbg("LIBIHT-COM: Flush LBR on cpu core: %d\n", xcoreid());
    xrdmsr(MSR_IA32_DEBUGCTLMSR, &dbgctlmsr);
    dbgctlmsr &= ~DEBUGCTLMSR_LBR;
    xwrmsr(MSR_IA32_DEBUGCTLMSR, dbgctlmsr);

    // Flush LBR registers
    xwrmsr(MSR_LBR_SELECT, 0);
    xwrmsr(MSR_LBR_TOS, 0);

    for (i = 0; i < lbr_capacity; i++)
    {
        xwrmsr(MSR_LBR_NHM_FROM + i, 0);
        xwrmsr(MSR_LBR_NHM_TO + i, 0);
    }

    xrelease_core(irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : enable_lbr
// Description  : Enable the LBR feature for the requested process id.
//
// Inputs       : request - the LBR ioctl request
// Outputs      : s32 - 0 on success, -1 on failure

s32 enable_lbr(struct lbr_ioctl_request *request)
{
    struct lbr_state *state;

    state = find_lbr_state(request->lbr_config.pid);
    if (state)
    {
        xprintdbg("LIBIHT-COM: LBR already enabled for pid %d\n",
                    request->lbr_config.pid);
        return -1;
    }

    state = create_lbr_state();
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: Create LBR state failed\n");
        return -1;
    }

    // Setup config fields for LBR state
    state->parent = NULL;
    state->config.pid = request->lbr_config.pid ?
                                    request->lbr_config.pid : xgetcurrent_pid();
    state->config.lbr_select = request->lbr_config.lbr_select ?
                                    request->lbr_config.lbr_select : LBR_SELECT;
    insert_lbr_state(state);

    // If the requesting process is the current process, trace it right away
    if (state->config.pid == xgetcurrent_pid())
        put_lbr(state);
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : disable_lbr
// Description  : Disable the LBR feature for the requested process id.
//
// Inputs       : request - the LBR ioctl request
// Outputs      : s32 - 0 on success, -1 on failure


s32 disable_lbr(struct lbr_ioctl_request *request)
{
    struct lbr_state *state;

    state = find_lbr_state(request->lbr_config.pid);
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: LBR not enabled for pid %d\n",
                    request->lbr_config.pid);
        return -1;
    }

    if (state->config.pid == xgetcurrent_pid())
        get_lbr(state);
    remove_lbr_state(state);
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : dump_lbr
// Description  : Dump the LBR registers for the given process id.
//
// Inputs       : request - the LBR ioctl request
// Outputs      : s32 - 0 on success, -1 on failure

s32 dump_lbr(struct lbr_ioctl_request *request)
{
    u64 i, bytes_left;
    struct lbr_state* state;
    struct lbr_data req_buf;
    char irql_flag[MAX_IRQL_LEN];

    state = find_lbr_state(request->lbr_config.pid);
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: LBR not enabled for pid %d\n",
                    request->lbr_config.pid);
        return -1;
    }

    // Examine if the current process is the owner of the LBR state
    if (state->config.pid == xgetcurrent_pid())
    {
        xprintdbg("LIBIHT-COM: Dump LBR for current process\n");
        // Get fresh LBR info
        get_lbr(state);
        put_lbr(state);
    }

    xacquire_lock(lbr_state_lock, irql_flag);

    // Dump the LBR state
    xprintdbg("PROC_PID:             %d\n", state->config.pid);
    xprintdbg("MSR_LBR_SELECT:       0x%llx\n", state->config.lbr_select);
    xprintdbg("MSR_LBR_TOS:          %lld\n", state->data->lbr_tos);

    for (i = 0; i < lbr_capacity; i++)
    {
        xprintdbg("MSR_LBR_NHM_FROM[%2d]: 0x%llx\n", i,
                    state->data->entries[i].from);
        xprintdbg("MSR_LBR_NHM_TO  [%2d]: 0x%llx\n", i,
                    state->data->entries[i].to);
    }

    xprintdbg("LIBIHT-COM: LBR info for cpuid: %d\n", xcoreid());

    // Dump the LBR data to userspace buffer
    if (request->buffer)
    {
        // Get a copy of data from userspace buffer
        bytes_left = xcopy_from_user(&req_buf, request->buffer,
                                        sizeof(struct lbr_data));
        if (bytes_left)
        {
            xprintdbg("LIBIHT-COM: Copy LBR data from user failed\n");
            xrelease_lock(lbr_state_lock, irql_flag);
            return -1;
        }

        // Dump data to userspace entry ptr
        req_buf.lbr_tos = state->data->lbr_tos;
        if (req_buf.entries)
        {
            bytes_left = xcopy_to_user(req_buf.entries,
                                        state->data->entries,
                                        lbr_capacity * sizeof(struct lbr_stack_entry));

            if (bytes_left)
            {
                xprintdbg("LIBIHT-COM: Copy LBR data to user failed\n");
                xrelease_lock(lbr_state_lock, irql_flag);
                return -1;
            }
        }

        // Copy updated data back to userspace buffer
        bytes_left = xcopy_to_user(request->buffer, &req_buf,
                                    sizeof(struct lbr_data));
        if (bytes_left)
        {
            xprintdbg("LIBIHT-COM: Copy LBR data to user failed\n");
            xrelease_lock(lbr_state_lock, irql_flag);
            return -1;
        }
    }

    xrelease_lock(lbr_state_lock, irql_flag);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : config_lbr
// Description  : Configure the LBR selection bit for the given process in the
//                request.
//
// Inputs       : request - the LBR ioctl request
// Outputs      : s32 - 0 on success, -1 on failure

s32 config_lbr(struct lbr_ioctl_request *request)
{
    struct lbr_state* state;

    state = find_lbr_state(request->lbr_config.pid);
    if (state == NULL)
    {
        xprintdbg("LIBIHT-COM: LBR not enabled for pid %d\n",
                    request->lbr_config.pid);
        return -1;
    }

    if (state->config.pid == xgetcurrent_pid())
    {
        get_lbr(state);
        state->config.lbr_select = request->lbr_config.lbr_select;
        put_lbr(state);
    }
    else
    {
        state->config.lbr_select = request->lbr_config.lbr_select;
    }

    return 0;
}

//
// LBR state (kernel maintained datastructure) helper functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : create_lbr_state
// Description  : Create a new blank LBR state.
//
// Inputs       : pid - the process id
// Outputs      : struct lbr_state* - the newly created LBR state

struct lbr_state* create_lbr_state(void)
{
    struct lbr_state* state;
    struct lbr_data* data;
    struct lbr_stack_entry* entries;

    state = xmalloc(sizeof(struct lbr_state));
    if (state == NULL)
        return NULL;

    data = xmalloc(sizeof(struct lbr_data));
    if (data == NULL)
    {
        xfree(state);
        return NULL;
    }

    entries = xmalloc(sizeof(struct lbr_stack_entry) * lbr_capacity);
    if (entries == NULL)
    {
        xfree(data);
        xfree(state);
        return NULL;
    }

    xmemset(state, 0, sizeof(struct lbr_state));
    xmemset(data, 0, sizeof(struct lbr_data));
    xmemset(entries, 0, sizeof(struct lbr_stack_entry) * lbr_capacity);

    state->data = data;
    data->entries = entries;

    return state;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : find_lbr_state
// Description  : Find the LBR state for the given process id.
//
// Inputs       : pid - the process id
// Outputs      : struct lbr_state* - the LBR state

struct lbr_state* find_lbr_state(u32 pid)
{
    char irql_flag[MAX_IRQL_LEN];
    struct lbr_state *curr_state, *ret_state = NULL;
    void *curr_list;
    u64 offset;

    xacquire_lock(lbr_state_lock, irql_flag);

    // offsetof(st, m) macro implementation of stddef.h
    offset = (u64)(&((struct lbr_state *)0)->list);
    curr_list = xlist_next(lbr_state_head);
    while (curr_list != NULL && curr_list != lbr_state_head)
    {
        curr_state = (struct lbr_state *)((u64)curr_list - offset);
        curr_list = xlist_next(curr_list);
        if (pid != 0 && curr_state->config.pid == pid)
        {
            ret_state = curr_state;
            break;
        }
    }

    xrelease_lock(lbr_state_lock, irql_flag);

    return ret_state;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : insert_lbr_state
// Description  : Insert new LBR state into the list.
//
// Inputs       : new_state - the new LBR state
// Outputs      : void

void insert_lbr_state(struct lbr_state* new_state)
{
    char irql_flag[MAX_IRQL_LEN];

    if (new_state == NULL)
        return;

    xacquire_lock(lbr_state_lock, irql_flag);
    xprintdbg("LIBIHT-COM: Insert LBR state for pid %d\n",
                new_state->config.pid);
    xlist_add(new_state->list, lbr_state_head);
    xrelease_lock(lbr_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : remove_lbr_state
// Description  : Remove the LBR state from the list.
//
// Inputs       : old_state - the old LBR state
// Outputs      : void

void remove_lbr_state(struct lbr_state* old_state)
{
    char irql_flag[MAX_IRQL_LEN];

    if (old_state == NULL)
        return;

    xacquire_lock(lbr_state_lock, irql_flag);
    xprintdbg("LIBIHT-COM: Remove LBR state for pid %d\n",
                old_state->config.pid);
    xlist_del(old_state->list);
    xfree(old_state->data->entries);
    xfree(old_state->data);
    xfree(old_state);
    xrelease_lock(lbr_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : free_lbr_state_list
// Description  : Free the LBR state list.
//
// Inputs       : void
// Outputs      : void

void free_lbr_state_list(void)
{
    char irql_flag[MAX_IRQL_LEN];
    struct lbr_state *curr_state;
    void *curr_list;
    u64 offset;

    xacquire_lock(lbr_state_lock, irql_flag);

    // offsetof(st, m) macro implementation of stddef.h
    offset = (u64)(&((struct lbr_state *)0)->list);
    curr_list = xlist_next(lbr_state_head);
    while (curr_list != NULL && curr_list != lbr_state_head)
    {
        curr_state = (struct lbr_state *)((u64)curr_list - offset);
        curr_list = xlist_next(curr_list);
        xprintdbg("LIBIHT-COM: Free LBR state for pid %d\n",
                    curr_state->config.pid);

        xlist_del(curr_state->list);
        xfree(curr_state->data->entries);
        xfree(curr_state->data);
        xfree(curr_state);
    }

    xrelease_lock(lbr_state_lock, irql_flag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : lbr_ioctl_handler
// Description  : The ioctl handler for the LBR feature.
//
// Inputs       : request - the LBR ioctl request
// Outputs      : s32 - 0 on success, -1 on failure

s32 lbr_ioctl_handler(struct xioctl_request *request)
{
    s32 ret = 0;

    xprintdbg("LIBIHT-COM: LBR ioctl command %d.\n", request->cmd);
    switch (request->cmd)
    {
        case LIBIHT_IOCTL_ENABLE_LBR:
            xprintdbg("LIBIHT-COM: Enable LBR for pid %d\n",
                        request->body.lbr.lbr_config.pid);
            ret = enable_lbr(&request->body.lbr);
            break;
        case LIBIHT_IOCTL_DISABLE_LBR:
            xprintdbg("LIBIHT-COM: Disable LBR for pid %d\n",
                        request->body.lbr.lbr_config.pid);
            ret = disable_lbr(&request->body.lbr);
            break;
        case LIBIHT_IOCTL_DUMP_LBR:
            xprintdbg("LIBIHT-COM: Dump LBR for pid %d\n",
                        request->body.lbr.lbr_config.pid);
            ret = dump_lbr(&request->body.lbr);
            break;
        case LIBIHT_IOCTL_CONFIG_LBR:
            xprintdbg("LIBIHT-COM: Config LBR for pid %d\n",
                        request->body.lbr.lbr_config.pid);
            ret = config_lbr(&request->body.lbr);
            break;
        default:
            xprintdbg("LIBIHT-COM: Invalid LBR ioctl command\n");
            ret = -1;
            break;
    }

    return ret;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : lbr_cswitch_handler
// Description  : The context switch handler for the LBR feature.
//
// Inputs       : prev_pid - the previous process id
//                next_pid - the next process id
// Outputs      : void

void lbr_cswitch_handler(u32 prev_pid, u32 next_pid)
{
    struct lbr_state *prev_state, *next_state;

    prev_state = find_lbr_state(prev_pid);
    next_state = find_lbr_state(next_pid);

    if (prev_state)
    {
        xprintdbg("LIBIHT-COM: LBR context switch from pid %d on cpu core %d\n",
                    prev_state->config.pid, xcoreid());
        get_lbr(prev_state);
    }

    if (next_state)
    {
        xprintdbg("LIBIHT-COM: LBR context switch to pid %d on cpu core %d\n",
                    next_state->config.pid, xcoreid());
        put_lbr(next_state);
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : lbr_newproc_handler
// Description  : The new process handler for the LBR feature.
//
// Inputs       : parent_pid - the parent process id
//                child_pid - the child process id
// Outputs      : void

void lbr_newproc_handler(u32 parent_pid, u32 child_pid)
{
    struct lbr_state *parent_state, *child_state;
    char irql_flag[MAX_IRQL_LEN];

    parent_state = find_lbr_state(parent_pid);
    if (parent_state == NULL)
        return;

    xprintdbg("LIBIHT-COM: LBR new child process pid %d, parent pid %d\n",
                child_pid, parent_pid);
    child_state = create_lbr_state();
    if (child_state == NULL)
        return;

    xacquire_lock(lbr_state_lock, irql_flag);
    // Copy parent state to child state
    child_state->parent = parent_state;
    child_state->config.pid = child_pid;
    child_state->config.lbr_select = parent_state->config.lbr_select;
    xmemcpy(child_state->data, parent_state->data,
                sizeof(struct lbr_data) +
                    lbr_capacity * sizeof(struct lbr_stack_entry));
    xrelease_lock(lbr_state_lock, irql_flag);
    insert_lbr_state(child_state);

    // If the child process is the current process, trace it right away
    if (child_pid == xgetcurrent_pid())
        put_lbr(child_state);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : lbr_check
// Description  : Check if the LBR feature is available on the current CPU.
//                And set the global variable `lbr_capacity`.
//
// Inputs       : void
// Outputs      : s32 - 0 on success, -1 on failure

s32 lbr_check(void)
{
    u32 cpuinfo[4] = { 0 };
    u32 family, model;
    u64 i;

    xcpuid(1, &cpuinfo[0], &cpuinfo[1], &cpuinfo[2], &cpuinfo[3]);

    family = ((cpuinfo[0] >> 8) & 0xF) + ((cpuinfo[0] >> 20) & 0xFF);
    model = ((cpuinfo[0] >> 4) & 0xF) | ((cpuinfo[0] >> 12) & 0xF0);

    // Identify CPU model
    for (i = 0; i < sizeof(cpu_lbr_maps) / sizeof(cpu_lbr_maps[0]); ++i)
    {
        if (model == cpu_lbr_maps[i].model)
        {
            lbr_capacity = cpu_lbr_maps[i].lbr_capacity;
            break;
        }
    }

    xprintdbg("LIBIHT-COM: DisplayFamily_DisplayModel - %x_%xH\n",
                    family, model);
    xprintdbg("LIBIHT-COM: LBR capacity - %ld\n", lbr_capacity);

    if (lbr_capacity == 0)
    {
        // Model name not found
        xprintdbg("LIBIHT-COM: CPU model not found\n");
        return -1;
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : lbr_init
// Description  : Initialize the LBR feature and its related datastructures.
//
// Inputs       : void
// Outputs      : s32 - 0 on success, -1 on failure

s32 lbr_init(void)
{
    if (lbr_check())
    {
        xprintdbg("LIBIHT-COM: LBR not available\n");
        return -1;
    }

    xprintdbg("LIBIHT-COM: Init LBR related structs.\n");
    xinit_lock(lbr_state_lock);
    xinit_list_head(lbr_state_head);

    // Flush LBR on each cpu
    xprintdbg("LIBIHT-COM: Flushing LBR for all cpus...\n");
    xon_each_cpu(flush_lbr);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : lbr_exit
// Description  : Free the LBR feature and its related datastructures.
//
// Inputs       : void
// Outputs      : s32 - 0 on success, -1 on failure

s32 lbr_exit(void)
{
    // Flush LBR on each cpu
    xprintdbg("LIBIHT-COM: Flushing LBR for all cpus...\n");
    xon_each_cpu(flush_lbr);

    // Free all LBR state
    xprintdbg("LIBIHT-COM: Freeing LBR state list...\n");
    free_lbr_state_list();

    return 0;
}

```

`kernel/commons/lbr.h`:

```h
#ifndef _COMMONS_LBR_H
#define _COMMONS_LBR_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/lbr.h
//  Description    : This is the header file for the LBR (Last Branch Record)
//                   module, which is used to capture the last branch records
//                   of a given process.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#include "types.h"
#include "xplat.h"
#include "xioctl.h"

// cpp cross compile handler
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Library constants

// MSR related constants
#ifndef MSR_IA32_DEBUGCTLMSR
#define MSR_IA32_DEBUGCTLMSR    0x000001d9
#endif

#ifndef MSR_LBR_SELECT
#define MSR_LBR_SELECT          0x000001c8
#endif

#ifndef MSR_LBR_TOS
#define MSR_LBR_TOS             0x000001c9
#endif

#ifndef MSR_LBR_NHM_FROM
#define MSR_LBR_NHM_FROM        0x00000680
#endif

#ifndef MSR_LBR_NHM_TO
#define MSR_LBR_NHM_TO          0x000006c0
#endif

#ifndef DEBUGCTLMSR_LBR
#define DEBUGCTLMSR_LBR         (1UL <<  0)
#endif

/* Bit Field  Bit Offset  Access  Description
 *
 * CPL_EQ_0      0   R/W     When set, do not capture branches ending in ring 0
 * CPL_NEQ_0     1   R/W     When set, do not capture branches ending in ring >0
 * JCC           2   R/W     When set, do not capture conditional branches
 * NEAR_REL_CALL 3   R/W     When set, do not capture near relative calls
 * NEAR_IND_CALL 4   R/W     When set, do not capture near indirect calls
 * NEAR_RET      5   R/W     When set, do not capture near returns
 * NEAR_IND_JMP  6   R/W     When set, do not capture near indirect jumps
 * NEAR_REL_JMP  7   R/W     When set, do not capture near relative jumps
 * FAR_BRANCH    8   R/W     When set, do not capture far branches
 * Reserved      63:9        Must be zero
 *
 * Default selection bit set to:
 * 0x1 = 00000001   --> capture branches occuring in ring >0
 */
#define LBR_SELECT              (1UL <<  0)

//
// Type definitions

// Define LBR state
struct lbr_state
{
    char list[MAX_LIST_LEN];          // Kernel linked list
    struct lbr_state *parent;         // Parent lbr_state
    struct lbr_config config;         // LBR configuration
    struct lbr_data *data;            // LBR data
};

// CPU - LBR map
struct cpu_to_lbr
{
    u32 model;          // CPU model
    u32 lbr_capacity;   // LBR capacity
};

//
// Global variables

extern u64 lbr_capacity;
// The capacity of the LBR.

extern char lbr_state_lock[MAX_LOCK_LEN];
// The lock for lbr_state_list.

extern char lbr_state_head[MAX_LIST_LEN];
// The head of the lbr_state_list.

//
// Function Prototypes

void get_lbr(struct lbr_state *state);
// Get the LBR of a given process.

void put_lbr(struct lbr_state *state);
// Put the LBR of a given process.

void flush_lbr(void);
// Flush the LBR.

s32 enable_lbr(struct lbr_ioctl_request *request);
// Enable the LBR.

s32 disable_lbr(struct lbr_ioctl_request *request);
// Disable the LBR.

s32 dump_lbr(struct lbr_ioctl_request *request);
// Dump the LBR of a given process.

s32 config_lbr(struct lbr_ioctl_request *request);
// Configure the LBR.

struct lbr_state *create_lbr_state(void);
// Create a new lbr_state.

struct lbr_state *find_lbr_state(u32 pid);
// Find a lbr_state from the lbr_state_list.

void insert_lbr_state(struct lbr_state *new_state);
// Insert a new lbr_state to the lbr_state_list.

void remove_lbr_state(struct lbr_state *old_state);
// Remove a lbr_state from the lbr_state_list.

void free_lbr_state_list(void);
// Free the lbr_state_list.

s32 lbr_ioctl_handler(struct xioctl_request *request);
// The ioctl handler for the LBR.

void lbr_cswitch_handler(u32 prev_pid, u32 next_pid);
// The context switch handler for the LBR.

void lbr_newproc_handler(u32 parent_pid, u32 child_pid);
// The new process handler for the LBR.

s32 lbr_check(void);
// Check if the LBR is available.

s32 lbr_init(void);
// Initialize the LBR.

s32 lbr_exit(void);
// Exit the LBR.

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _COMMONS_LBR_H
```

`kernel/commons/types.h`:

```h
#ifndef _COMMONS_TYPES_H
#define _COMMONS_TYPES_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/types.h
//  Description    : This is the header file for the common types for the 
//                   libiht library.  
//                   
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// cpp cross compile handler
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Type definitions

// Redefine types that works for both linux and windows platform
typedef signed      char        s8;
typedef unsigned    char        u8;
typedef signed      short       s16;
typedef unsigned    short       u16;
typedef signed      int         s32;
typedef unsigned    int         u32;
typedef signed      long long   s64;
typedef unsigned    long long   u64;

#ifndef NULL
#define NULL 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifdef __cplusplus
}
#endif // __cplusplus


#endif // _COMMONS_TYPES_H
```

`kernel/commons/xioctl.h`:

```h
#ifndef _COMMONS_XIOCTL_H
#define _COMMONS_XIOCTL_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/xioclt.h
//  Description    : This is the header file for the cross platform and cross 
//                   feature IOCTL definitions for the library.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

//
// Include Files
#include "types.h"

//
// Library constants
enum IOCTL {
    LIBIHT_IOCTL_BASE,          // Placeholder

    // LBR
    LIBIHT_IOCTL_ENABLE_LBR,
    LIBIHT_IOCTL_DISABLE_LBR,
    LIBIHT_IOCTL_DUMP_LBR,
    LIBIHT_IOCTL_CONFIG_LBR,
    LIBIHT_IOCTL_LBR_END,       // End of LBR

    // BTS
    LIBIHT_IOCTL_ENABLE_BTS,
    LIBIHT_IOCTL_DISABLE_BTS,
    LIBIHT_IOCTL_DUMP_BTS,
    LIBIHT_IOCTL_CONFIG_BTS,
    LIBIHT_IOCTL_BTS_END,       // End of BTS
};

//
// LBR Type definitions

// Define LBR stack entry
struct lbr_stack_entry
{
    u64 from;   // Retrieve from MSR_LBR_NHM_FROM + offset
    u64 to;     // Retrieve from MSR_LBR_NHM_TO + offset
};

// Define LBR configuration
struct lbr_config
{
    u32 pid;                          // Process ID
    u64 lbr_select;                   // MSR_LBR_SELECT
};

// Define LBR data
struct lbr_data
{
    u64 lbr_tos;                      // MSR_LBR_TOS
    struct lbr_stack_entry *entries;  // LBR stack entries
};

// Define the lbr IOCTL structure
struct lbr_ioctl_request{
    struct lbr_config lbr_config;
    struct lbr_data *buffer;
};

//
// BTS Type definitions

// Define BTS record
struct bts_record
{
    u64 from;   // branch from
    u64 to;     // branch to
    u64 misc;   // misc information
};

// Define BTS configuration
struct bts_config
{
    u32 pid;                        // Process ID
    u64 bts_config;                 // MSR_IA32_DEBUGCTLMSR
    u64 bts_buffer_size;            // BTS buffer size
};

// Define BTS data
// TODO: pay attention when using this struct in dump bts
struct bts_data
{
    struct bts_record *bts_buffer_base; // BTS buffer base
    struct bts_record *bts_index;       // BTS current index
    u64 bts_interrupt_threshold;        // BTS interrupt threshold
};

// Define the bts IOCTL structure
struct bts_ioctl_request{
    struct bts_config bts_config;
    struct bts_data *buffer;
};

//
// xIOCTL Type definitions

// Define the xIOCTL structure
struct xioctl_request{
    enum IOCTL cmd;
    union {
        struct lbr_ioctl_request lbr;
        struct bts_ioctl_request bts;
    } body;
};

#endif // _COMMONS_XIOCTL_H
```

`kernel/commons/xplat.h`:

```h
#ifndef _COMMONS_XPLAT_H
#define _COMMONS_XPLAT_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/commons/xplat.h
//  Description    : This is the header file for the cross platform functions
//                   used for libiht library. Details of the functions are
//                   implemented in the corresponding platform specific files.
//                   i.e. `xplat_kmd.c` and `xplat_lkm.c` for windows and linux.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

#include "types.h"
#include "debug.h"

// cpp cross compile handler
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Library constants

#define MAX_IRQL_LEN    0x10    // Maximum length of OS irql struct
#define MAX_LOCK_LEN    0x20    // Maximum length of OS lock struct
#define MAX_LIST_LEN    0x20    // Maximum length of OS list struct

//
// Function Prototypes

//
// Memory management functions

void *xmalloc(u64 size);
// Cross platform kernel malloc function.

void xfree(void *ptr);
// Cross platform kernel free function.

u64 xcopy_from_user(void *dst, void *src, u64 cnt);
// Cross platform kernel copy from user function.

u64 xcopy_to_user(void *dst, void *src, u64 cnt);
// Cross platform kernel copy to user function.

void *xmemset(void *ptr, s32 c, u64 cnt);
// Cross platform kernel memset function.

void *xmemcpy(void *dst, void *src, u64 cnt);
// Cross platform kernel memcpy function.

//
// CPU core, hardware, register read/write functions

void xlock_core(void *old_irql);
// Cross platform lock core function.

void xrelease_core(void *new_irql);
// Cross platform release core function.

void xwrmsr(u32 msr, u64 val);
// Cross platform write msr function.

void xrdmsr(u32 msr, u64 *val);
// Cross platform read msr function.

u32  xcoreid(void);
// Cross platform get core id function.

u32 xgetcurrent_pid(void);
// Cross platform get current user process pid function.

void xcpuid(u32 func_id, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx);
// Cross platform cpuid function.

void xon_each_cpu(void (*func)(void));
// Cross platform on each cpu dispatch function.

//
// Lock functions

void xinit_lock(void *lock);
// Cross platform init lock function.

void xacquire_lock(void *lock, void *old_irql);
// Cross platform acquire lock function.

void xrelease_lock(void *lock, void *new_irql);
// Cross platform release lock function.

//
// List functions

void xinit_list_head(void *list);
// Cross platform init list head function.

void xlist_add(void *new_entry, void *head);
// Cross platform list add function.

void xlist_del(void *entry);
// Cross platform list del function.

void *xlist_next(void *entry);
// Cross platform list next function.

void *xlist_prev(void *entry);
// Cross platform list prev function.

//
// Debug functions (will be moved to debug.h)

void xprintdbg(const char *format, ...);
// Cross platform print kernel debug message function.

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _COMMONS_XPLAT_H

```

`kernel/demo/kmd-demo/kmd-demo.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33829.357
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kmd-demo", "kmd-demo\kmd-demo.vcxproj", "{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Debug|x64.ActiveCfg = Debug|x64
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Debug|x64.Build.0 = Debug|x64
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Debug|x86.ActiveCfg = Debug|Win32
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Debug|x86.Build.0 = Debug|Win32
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Release|x64.ActiveCfg = Release|x64
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Release|x64.Build.0 = Release|x64
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Release|x86.ActiveCfg = Release|Win32
		{8BFFD4D5-FC2F-4911-8B48-3B176D016D16}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BD2A360B-56C4-444C-8979-0906AFB29786}
	EndGlobalSection
EndGlobal

```

`kernel/demo/kmd-demo/kmd-demo/kmd-demo.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/demo/kmd-demo/kmd-demo/kmd-demo.cpp
//  Description    : This is the main program for the kmd-demo program. It will
//                   open the helper device and send the ioctl request to the
//                   helper device. The kernel driver will trace the process 
//                   and dump the LBR to show the call stack information of the
//                   cross recursive function call.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#include <iostream>
#include <Windows.h>
#include <winioctl.h>

#define ENABLE_LBR
// #define ENABLE_BTS

/*
 * I/O Device name
 */
#define DEVICE_NAME         L"\\Device\\libiht-info"
#define SYM_DEVICE_NAME     L"\\DosDevices\\libiht-info"

 /*
  * I/O control table
  */
#define KMD_IOCTL_TYPE 0x8888
#define KMD_IOCTL_FUNC 0x888

#define LIBIHT_KMD_IOCTL_BASE       CTL_CODE(KMD_IOCTL_TYPE, KMD_IOCTL_FUNC + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Redefine/Copy the structs for IOCTL

//
// Library constants
enum IOCTL {
    LIBIHT_IOCTL_BASE,          // Placeholder

    // LBR
    LIBIHT_IOCTL_ENABLE_LBR,
    LIBIHT_IOCTL_DISABLE_LBR,
    LIBIHT_IOCTL_DUMP_LBR,
    LIBIHT_IOCTL_CONFIG_LBR,
    LIBIHT_IOCTL_LBR_END,       // End of LBR

    // BTS
    LIBIHT_IOCTL_ENABLE_BTS,
    LIBIHT_IOCTL_DISABLE_BTS,
    LIBIHT_IOCTL_DUMP_BTS,
    LIBIHT_IOCTL_CONFIG_BTS,
    LIBIHT_IOCTL_BTS_END,       // End of BTS
};

//
// LBR Type definitions

// Define LBR stack entry
struct lbr_stack_entry
{
    unsigned long long from;   // Retrieve from MSR_LBR_NHM_FROM + offset
    unsigned long long to;     // Retrieve from MSR_LBR_NHM_TO + offset
};

// Define LBR configuration
struct lbr_config
{
    unsigned int pid;                          // Process ID
    unsigned long long lbr_select;                   // MSR_LBR_SELECT
};

// Define LBR data
struct lbr_data
{
    unsigned long long lbr_tos;                      // MSR_LBR_TOS
    struct lbr_stack_entry* entries;  // LBR stack entries
};

// Define the lbr IOCTL structure
struct lbr_ioctl_request {
    struct lbr_config lbr_config;
    struct lbr_data* buffer;
};

//
// BTS Type definitions

// Define BTS record
struct bts_record
{
    unsigned long long from;   // branch from
    unsigned long long to;     // branch to
    unsigned long long misc;   // misc information
};

// Define BTS configuration
struct bts_config
{
    unsigned int pid;                        // Process ID
    unsigned long long bts_config;           // MSR_IA32_DEBUGCTLMSR
    unsigned long long bts_buffer_size;      // BTS buffer size
};

// Define BTS data
// TODO: pay attention when using this struct in dump bts
struct bts_data
{
    struct bts_record* bts_buffer_base;         // BTS buffer base
    struct bts_record* bts_index;               // BTS current index
    unsigned long long bts_interrupt_threshold; // BTS interrupt threshold
};

// Define the bts IOCTL structure
struct bts_ioctl_request {
    struct bts_config bts_config;
    struct bts_data* buffer;
};

//
// xIOCTL Type definitions

// Define the xIOCTL structure
struct xioctl_request {
    enum IOCTL cmd;
    union {
        struct lbr_ioctl_request lbr;
        struct bts_ioctl_request bts;
    } body;
};

int cnt = 10;

void func1(void);
void func2(void);

void func1()
{
    //printf("func1: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func2();
    }
}

void func2()
{
    //printf("func2: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func1();
    }
}

void print_usage()
{
    printf("Usage: kmd-demo.exe [pid] [count]\n");
    printf("pid: the pid of the process want to trace, trace it self if it is 0\n");
    printf("count: the number of recursive function call\n");
    printf("Example: kmd-demo.exe 0 10\n");
    fflush(stdout);
    exit(-1);
}

int main(int argc, char* argv[])
{
    if (argc != 3)
        print_usage();

    int pid = atoi(argv[1]);
    if (pid == 0)
        pid = GetCurrentProcessId();
    cnt = atoi(argv[2]);
    printf("func1's ptr: %p\nfunc2's ptr: %p\n", &func1, &func2);
    fflush(stdout);
    Sleep(1000);

    HANDLE hDevice = CreateFileA("\\\\.\\libiht-info", GENERIC_READ |
        GENERIC_WRITE, 0,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("Failed to open device!\n");
        CloseHandle(hDevice);
        return 0;
    }

    struct xioctl_request input;
    memset(&input, 0, sizeof(input));

#ifdef ENABLE_LBR
    // Setup LBR buffer
    input.body.lbr.buffer = (struct lbr_data*)malloc(sizeof(struct lbr_data));
    input.body.lbr.buffer->entries = (struct lbr_stack_entry*)malloc(32 * sizeof(struct lbr_stack_entry));
    printf("LBR buffer: %p\n", input.body.lbr.buffer);
    printf("LBR entries: %p\n", input.body.lbr.buffer->entries);
    memset(input.body.lbr.buffer->entries, -1, 32 * sizeof(struct lbr_stack_entry));

    // Enable LBR
    input.body.lbr.lbr_config.lbr_select = 0;
    input.body.lbr.lbr_config.pid = pid;

    input.cmd = LIBIHT_IOCTL_ENABLE_LBR;
    DeviceIoControl(hDevice, LIBIHT_KMD_IOCTL_BASE, &input, sizeof(input), NULL, 0, NULL, NULL);
    Sleep(1000);

    // Simulate critical logic
    func1();

    // Dump LBR
    input.cmd = LIBIHT_IOCTL_DUMP_LBR;
    DeviceIoControl(hDevice, LIBIHT_KMD_IOCTL_BASE, &input, sizeof(input), NULL, 0, NULL, NULL);
    Sleep(1000);

    // Disable LBR
    input.cmd = LIBIHT_IOCTL_DISABLE_LBR;
    DeviceIoControl(hDevice, LIBIHT_KMD_IOCTL_BASE, &input, sizeof(input), NULL, 0, NULL, NULL);
    Sleep(1000);

    // Print LBR buffer
    printf("LBR TOS: %lld\n", input.body.lbr.buffer->lbr_tos);
    for (int i = 0; i < 32; i++)
    {
        printf("LBR[%d]: 0x%llx -> 0x%llx\n", i, input.body.lbr.buffer->entries[i].from, input.body.lbr.buffer->entries[i].to);
    }

    // Free LBR buffer
    free(input.body.lbr.buffer->entries);
    free(input.body.lbr.buffer);
#endif // ENABLE_LBR

#ifdef ENABLE_BTS
    // Setup BTS buffer
    input.body.bts.buffer = (struct bts_data*)malloc(sizeof(struct bts_data));
    input.body.bts.buffer->bts_buffer_base = (struct bts_record*)malloc(1024 * sizeof(struct bts_record));
    printf("BTS buffer: %p\n", input.body.bts.buffer);
    printf("BTS buffer base: %p\n", input.body.bts.buffer->bts_buffer_base);
    memset(input.body.bts.buffer->bts_buffer_base, -1, 1024 * sizeof(struct bts_record));

    // Enable BTS
    input.body.bts.bts_config.bts_buffer_size = 0;
    input.body.bts.bts_config.bts_config = 0;
    input.body.bts.bts_config.pid = pid;

    input.cmd = LIBIHT_IOCTL_ENABLE_BTS;
    DeviceIoControl(hDevice, LIBIHT_KMD_IOCTL_BASE, &input, sizeof(input), NULL, 0, NULL, NULL);
    Sleep(1000);

    // Simulate critical logic
    func1();

    // Dump BTS
    input.cmd = LIBIHT_IOCTL_DUMP_BTS;
    DeviceIoControl(hDevice, LIBIHT_KMD_IOCTL_BASE, &input, sizeof(input), NULL, 0, NULL, NULL);
    Sleep(1000);

    // Disable BTS
    input.cmd = LIBIHT_IOCTL_DISABLE_BTS;
    DeviceIoControl(hDevice, LIBIHT_KMD_IOCTL_BASE, &input, sizeof(input), NULL, 0, NULL, NULL);
    Sleep(1000);

    // Print BTS buffer
    int position = (input.body.bts.buffer->bts_index - input.body.bts.buffer->bts_buffer_base);
    printf("BTS Information:\n");
    printf("BTS Buffer Base: %p\n", input.body.bts.buffer->bts_buffer_base);
    printf("BTS Index: %p\n", input.body.bts.buffer->bts_index);
    printf("BTS Index (position in array): %d\n", position);
    for (int i = 0; i < 1024; i++)
    {
        printf("BTS[%d]: 0x%llx -> 0x%llx\n", i, input.body.bts.buffer->bts_buffer_base[i].from, input.body.bts.buffer->bts_buffer_base[i].to);
    }

    // Free BTS buffer
    free(input.body.bts.buffer->bts_buffer_base);
    free(input.body.bts.buffer);
#endif // ENABLE_BTS

    printf("Close device!\n");
    CloseHandle(hDevice);
    return 0;
}

```

`kernel/demo/kmd-demo/kmd-demo/kmd-demo.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8bffd4d5-fc2f-4911-8b48-3b176d016d16}</ProjectGuid>
    <RootNamespace>kmddemo</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="kmd-demo.cpp">
      <RuntimeLibrary Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">MultiThreaded</RuntimeLibrary>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kernel/demo/kmd-demo/kmd-demo/kmd-demo.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kmd-demo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`kernel/demo/kmd-demo/kmd-demo/kmd-demo.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`kernel/demo/lkm-demo/Makefile`:

```
# LKM demo program compile process

TARGET = lkm-demo

all:
	$(CC) -g -static -Wall -o $(TARGET) $(TARGET).c

clean:
	rm -f $(TARGET)

```

`kernel/demo/lkm-demo/lkm-demo.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/demo/lkm-demo/lkm-demo.c
//  Description    : This is the main program for the lkm-demo program. It will
//                   open the helper process and send the ioctl request to the
//                   helper processs. The kernel module will trace the process 
//                   and dump the LBR to show the call stack information of the
//                   cross recursive function call.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>

#define ENABLE_LBR
// #define ENABLE_BTS

// Redefine/Copy the structs for IOCTL

// Device name
#define DEVICE_NAME "libiht-info"

// I/O control macros
// TODO: Is IOCTL macros really needed? seems xioctl_request handles it
#define LIBIHT_LKM_IOCTL_MAGIC 'l'
#define LIBIHT_LKM_IOCTL_BASE       _IO(LIBIHT_LKM_IOCTL_MAGIC, 0)

//
// Library constants
enum IOCTL {
    LIBIHT_IOCTL_BASE,          // Placeholder

    // LBR
    LIBIHT_IOCTL_ENABLE_LBR,
    LIBIHT_IOCTL_DISABLE_LBR,
    LIBIHT_IOCTL_DUMP_LBR,
    LIBIHT_IOCTL_CONFIG_LBR,
    LIBIHT_IOCTL_LBR_END,       // End of LBR

    // BTS
    LIBIHT_IOCTL_ENABLE_BTS,
    LIBIHT_IOCTL_DISABLE_BTS,
    LIBIHT_IOCTL_DUMP_BTS,
    LIBIHT_IOCTL_CONFIG_BTS,
    LIBIHT_IOCTL_BTS_END,       // End of BTS
};

//
// LBR Type definitions

// Define LBR stack entry
struct lbr_stack_entry
{
    unsigned long long from;   // Retrieve from MSR_LBR_NHM_FROM + offset
    unsigned long long to;     // Retrieve from MSR_LBR_NHM_TO + offset
};

// Define LBR configuration
struct lbr_config
{
    unsigned int pid;                          // Process ID
    unsigned long long lbr_select;                   // MSR_LBR_SELECT
};

// Define LBR data
struct lbr_data
{
    unsigned long long lbr_tos;                      // MSR_LBR_TOS
    struct lbr_stack_entry *entries;  // LBR stack entries
};

// Define the lbr IOCTL structure
struct lbr_ioctl_request{
    struct lbr_config lbr_config;
    struct lbr_data *buffer;
};

//
// BTS Type definitions

// Define BTS record
struct bts_record
{
    unsigned long long from;   // branch from
    unsigned long long to;     // branch to
    unsigned long long misc;   // misc information
};

// Define BTS configuration
struct bts_config
{
    unsigned int pid;                        // Process ID
    unsigned long long bts_config;                 // MSR_IA32_DEBUGCTLMSR
    unsigned long long bts_buffer_size;            // BTS buffer size
};

// Define BTS data
// TODO: pay attention when using this struct in dump bts
struct bts_data
{
    struct bts_record *bts_buffer_base; // BTS buffer base
    unsigned long long bts_index;                      // BTS current index
    unsigned long long bts_absolute_maximum;           // BTS absolute maximum
    unsigned long long bts_interrupt_threshold;        // BTS interrupt threshold
};

// Define the bts IOCTL structure
struct bts_ioctl_request{
    struct bts_config bts_config;
    struct bts_data *buffer;
};

//
// xIOCTL Type definitions

// Define the xIOCTL structure
struct xioctl_request{
    enum IOCTL cmd;
    union {
        struct lbr_ioctl_request lbr;
        struct bts_ioctl_request bts;
    } body;
};

int cnt = 10;

void func1(void);
void func2(void);

void func1()
{
    //printf("func1: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func2();
    }
}

void func2()
{
    //printf("func2: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func1();
    }
}

void print_usage()
{
    printf("Usage: lkm-demo [pid] [count]\n");
    printf("pid: the pid of the process want to trace, trace it self if it is 0\n");
    printf("count: the number of recursive function call\n");
    printf("Example: lkm-demo 0 10\n");
    fflush(stdout);
    exit(-1);
}

int main(int argc, char* argv[])
{
    if (argc != 3)
        print_usage();

    int pid = atoi(argv[1]);
    if (pid == 0)
        pid = getpid();
    cnt = atoi(argv[2]);
    printf("pid: %d, count: %d\n", pid, cnt);
    printf("func1's ptr: %p\nfunc2's ptr: %p\n", &func1, &func2);
    fflush(stdout);
    sleep(1);

    int fd = open("/proc/" DEVICE_NAME, O_RDWR);

    if (fd < 0)
    {
        printf("Failed to open device!\n");
        return 0;
    }

    struct xioctl_request input;
    memset(&input, 0, sizeof(input));

#ifdef ENABLE_LBR
    // Setup LBR buffer
    input.body.lbr.buffer = (struct lbr_data *)malloc(sizeof(struct lbr_data));
    input.body.lbr.buffer->entries = (struct lbr_stack_entry *)malloc(sizeof(struct lbr_stack_entry) * 32);
    printf("LBR buffer: %p\n", input.body.lbr.buffer);
    printf("LBR entries: %p\n", input.body.lbr.buffer->entries);
    memset(input.body.lbr.buffer->entries, -1, sizeof(struct lbr_stack_entry) * 32);

    // Enable LBR
    input.body.lbr.lbr_config.lbr_select = 0;
    input.body.lbr.lbr_config.pid = pid;

    input.cmd = LIBIHT_IOCTL_ENABLE_LBR;
    ioctl(fd, LIBIHT_LKM_IOCTL_BASE, &input);
    sleep(1);

    // Simulate critical logic
    func1();

    // Dump LBR
    input.cmd = LIBIHT_IOCTL_DUMP_LBR;
    ioctl(fd, LIBIHT_LKM_IOCTL_BASE, &input);
    sleep(1);

    // Disable LBR
    input.cmd = LIBIHT_IOCTL_DISABLE_LBR;
    ioctl(fd, LIBIHT_LKM_IOCTL_BASE, &input);
    sleep(1);

    // Print LBR buffer
    printf("LBR TOS: %lld\n", input.body.lbr.buffer->lbr_tos);
    for (int i = 0; i < 32; i++)
    {
        printf("LBR[%d]: 0x%llx -> 0x%llx\n", i, input.body.lbr.buffer->entries[i].from, input.body.lbr.buffer->entries[i].to);
    }

    // Print LBR buffer
    free(input.body.lbr.buffer->entries);
    free(input.body.lbr.buffer);
#endif

#ifdef ENABLE_BTS
    // Setup BTS buffer
    input.body.bts.buffer = (struct bts_data *)malloc(sizeof(struct bts_data));
    input.body.bts.buffer->bts_buffer_base = (struct bts_record *)malloc(sizeof(struct bts_record) * 1024);
    printf("BTS buffer: %p\n", input.body.bts.buffer);
    printf("BTS buffer base: %p\n", input.body.bts.buffer->bts_buffer_base);
    memset(input.body.bts.buffer->bts_buffer_base, -1, sizeof(struct bts_record) * 1024);

    // Enable BTS
    input.body.bts.bts_config.bts_buffer_size = 0;
    input.body.bts.bts_config.bts_config = 0;
    input.body.bts.bts_config.pid = pid;

    input.cmd = LIBIHT_IOCTL_ENABLE_BTS;
    ioctl(fd, LIBIHT_LKM_IOCTL_BASE, &input);
    sleep(1);

    // Simulate critical logic
    func1();

    // Dump BTS
    input.cmd = LIBIHT_IOCTL_DUMP_BTS;
    ioctl(fd, LIBIHT_LKM_IOCTL_BASE, &input);
    sleep(1);

    // Disable BTS
    input.cmd = LIBIHT_IOCTL_DISABLE_BTS;
    ioctl(fd, LIBIHT_LKM_IOCTL_BASE, &input);
    sleep(1);

    // Print BTS buffer
    printf("BTS Information:\n");
    printf("BTS Buffer Base: %p\n", input.body.bts.buffer->bts_buffer_base);
    printf("BTS Index: %p\n", input.body.bts.buffer->bts_index);
    for (int i = 0; i < 1024; i++)
    {
        printf("BTS[%d]: 0x%llx -> 0x%llx\n", i, input.body.bts.buffer->bts_buffer_base[i].from, input.body.bts.buffer->bts_buffer_base[i].to);
    }

    // Free BTS buffer
    free(input.body.bts.buffer->bts_buffer_base);
    free(input.body.bts.buffer);
#endif

    printf("Close device!\n");
    close(fd);
    return 0;
}
```

`kernel/kmd/include/headers_kmd.h`:

```h
#ifndef _HEADERS_KMD_H
#define _HEADERS_KMD_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/kmd/include/header_kmd.h
//  Description    : This is the header file for the kernel-mode driver. It
//                   contains all the necessary header files for the driver.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#include <ntifs.h>
#include <ntdef.h>
#include <ntddk.h>
#include <wdm.h>
#include <ntstatus.h>
#include <ntimage.h>
#include <ntstrsafe.h>
#include <intrin.h>
#include <intsafe.h>

#endif // _HEADERS_KMD_H

```

`kernel/kmd/include/libiht_kmd.h`:

```h
#ifndef _LIBIHT_KMD_H
#define _LIBIHT_KMD_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/kmd/include/libiht_kmd.h
//  Description    : This is the header file for the kernel mode driver of 
//                   libiht. 
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Includes Files
#include "../../commons/lbr.h"
#include "../../commons/bts.h"
#include "../../commons/types.h"
#include "../../commons/debug.h"
#include "../infinity_hook/imports.hpp"

// cpp cross compile handler
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Library constants

// Device specification
#define DEVICE_NAME         L"\\Device\\libiht-info"
#define SYM_DEVICE_NAME     L"\\DosDevices\\libiht-info"

// I/O control codes
#define LIBIHT_KMD_IOCTL_TYPE       0x8888
#define LIBIHT_KMD_IOCTL_FUNC       0x888
#define LIBIHT_KMD_IOCTL_BASE       CTL_CODE(LIBIHT_KMD_IOCTL_TYPE, LIBIHT_KMD_IOCTL_FUNC + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Type definitions

// Nothing here

//
// Function Prototypes

// TODO: Determine if this function are necessary
BOOLEAN bypass_check_sign(PDRIVER_OBJECT driver_obj);

VOID create_proc_notify(PEPROCESS proc, HANDLE proc_id,
                        PPS_CREATE_NOTIFY_INFO create_info);
// This function is used to create a process notifier

NTSTATUS device_create(PDRIVER_OBJECT driver_obj);
// This function is used to create a device object

NTSTATUS device_remove(PDRIVER_OBJECT driver_obj);
// This function is used to remove a device object

NTSTATUS device_ioctl(PDEVICE_OBJECT device_obj, PIRP Irp);
// This function is used to handle IOCTL requests

NTSTATUS device_default(PDEVICE_OBJECT device_obj, PIRP Irp);
// This function is used to handle default requests

NTSTATUS DriverEntry(PDRIVER_OBJECT driverObject, PUNICODE_STRING regPath);
// This function is used to initialize the driver

NTSTATUS DriverExit(PDRIVER_OBJECT driverObject);
// This function is used to exit the driver

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _LIBIHT_KMD_H


```

`kernel/kmd/infinity_hook/hde/hde64.cpp`:

```cpp
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "../headers.hpp"

#if defined(_M_X64) || defined(__x86_64__)
#pragma warning(push, 0)
#pragma warning(disable: 4701 4706 26451)

#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void* code, hde64s* hs)
{
	uint8_t x, c, * p = (uint8_t*)code, cflags, opcode, pref = 0;
	uint8_t* ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
	uint8_t op64 = 0;

	// Avoid using memset to reduce the footprint.
	memset(hs, 0, sizeof(hde64s));

	for (x = 16; x; x--)
		switch (c = *p++) {
		case 0xf3:
			hs->p_rep = c;
			pref |= PRE_F3;
			break;
		case 0xf2:
			hs->p_rep = c;
			pref |= PRE_F2;
			break;
		case 0xf0:
			hs->p_lock = c;
			pref |= PRE_LOCK;
			break;
		case 0x26: case 0x2e: case 0x36:
		case 0x3e: case 0x64: case 0x65:
			hs->p_seg = c;
			pref |= PRE_SEG;
			break;
		case 0x66:
			hs->p_66 = c;
			pref |= PRE_66;
			break;
		case 0x67:
			hs->p_67 = c;
			pref |= PRE_67;
			break;
		default:
			goto pref_done;
		}
pref_done:

	hs->flags = (uint32_t)pref << 23;

	if (!pref)
		pref |= PRE_NONE;

	if ((c & 0xf0) == 0x40) {
		hs->flags |= F_PREFIX_REX;
		if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
			op64++;
		hs->rex_r = (c & 7) >> 2;
		hs->rex_x = (c & 3) >> 1;
		hs->rex_b = c & 1;
		if (((c = *p++) & 0xf0) == 0x40) {
			opcode = c;
			goto error_opcode;
		}
	}

	if ((hs->opcode = c) == 0x0f) {
		hs->opcode2 = c = *p++;
		ht += DELTA_OPCODES;
	}
	else if (c >= 0xa0 && c <= 0xa3) {
		op64++;
		if (pref & PRE_67)
			pref |= PRE_66;
		else
			pref &= ~PRE_66;
	}

	opcode = c;
	cflags = ht[ht[opcode / 4] + (opcode % 4)];

	if (cflags == C_ERROR) {
	error_opcode:
		hs->flags |= F_ERROR | F_ERROR_OPCODE;
		cflags = 0;
		if ((opcode & -3) == 0x24)
			cflags++;
	}

	x = 0;
	if (cflags & C_GROUP) {
		uint16_t t;
		t = *(uint16_t*)(ht + (cflags & 0x7f));
		cflags = (uint8_t)t;
		x = (uint8_t)(t >> 8);
	}

	if (hs->opcode2) {
		ht = hde64_table + DELTA_PREFIXES;
		if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
			hs->flags |= F_ERROR | F_ERROR_OPCODE;
	}

	if (cflags & C_MODRM) {
		hs->flags |= F_MODRM;
		hs->modrm = c = *p++;
		hs->modrm_mod = m_mod = c >> 6;
		hs->modrm_rm = m_rm = c & 7;
		hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

		if (x && ((x << m_reg) & 0x80))
			hs->flags |= F_ERROR | F_ERROR_OPCODE;

		if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
			uint8_t t = opcode - 0xd9;
			if (m_mod == 3) {
				ht = hde64_table + DELTA_FPU_MODRM + t * 8;
				t = ht[m_reg] << m_rm;
			}
			else {
				ht = hde64_table + DELTA_FPU_REG;
				t = ht[t] << m_reg;
			}
			if (t & 0x80)
				hs->flags |= F_ERROR | F_ERROR_OPCODE;
		}

		if (pref & PRE_LOCK) {
			if (m_mod == 3) {
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			}
			else {
				uint8_t* table_end, op = opcode;
				if (hs->opcode2) {
					ht = hde64_table + DELTA_OP2_LOCK_OK;
					table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
				}
				else {
					ht = hde64_table + DELTA_OP_LOCK_OK;
					table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
					op &= -2;
				}
				for (; ht != table_end; ht++)
					if (*ht++ == op) {
						if (!((*ht << m_reg) & 0x80))
							goto no_lock_error;
						else
							break;
					}
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			no_lock_error:
				;
			}
		}

		if (hs->opcode2) {
			switch (opcode) {
			case 0x20: case 0x22:
				m_mod = 3;
				if (m_reg > 4 || m_reg == 1)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x21: case 0x23:
				m_mod = 3;
				if (m_reg == 4 || m_reg == 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}
		else {
			switch (opcode) {
			case 0x8c:
				if (m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x8e:
				if (m_reg == 1 || m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}

		if (m_mod == 3) {
			uint8_t* table_end;
			if (hs->opcode2) {
				ht = hde64_table + DELTA_OP2_ONLY_MEM;
				table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
			}
			else {
				ht = hde64_table + DELTA_OP_ONLY_MEM;
				table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
			}
			for (; ht != table_end; ht += 2)
				if (*ht++ == opcode) {
					if (*ht++ & pref && !((*ht << m_reg) & 0x80))
						goto error_operand;
					else
						break;
				}
			goto no_error_operand;
		}
		else if (hs->opcode2) {
			switch (opcode) {
			case 0x50: case 0xd7: case 0xf7:
				if (pref & (PRE_NONE | PRE_66))
					goto error_operand;
				break;
			case 0xd6:
				if (pref & (PRE_F2 | PRE_F3))
					goto error_operand;
				break;
			case 0xc5:
				goto error_operand;
			}
			goto no_error_operand;
		}
		else
			goto no_error_operand;

	error_operand:
		hs->flags |= F_ERROR | F_ERROR_OPERAND;
	no_error_operand:

		c = *p++;
		if (m_reg <= 1) {
			if (opcode == 0xf6)
				cflags |= C_IMM8;
			else if (opcode == 0xf7)
				cflags |= C_IMM_P66;
		}

		switch (m_mod) {
		case 0:
			if (pref & PRE_67) {
				if (m_rm == 6)
					disp_size = 2;
			}
			else
				if (m_rm == 5)
					disp_size = 4;
			break;
		case 1:
			disp_size = 1;
			break;
		case 2:
			disp_size = 2;
			if (!(pref & PRE_67))
				disp_size <<= 1;
		}

		if (m_mod != 3 && m_rm == 4) {
			hs->flags |= F_SIB;
			p++;
			hs->sib = c;
			hs->sib_scale = c >> 6;
			hs->sib_index = (c & 0x3f) >> 3;
			if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
				disp_size = 4;
		}

		p--;
		switch (disp_size) {
		case 1:
			hs->flags |= F_DISP8;
			hs->disp.disp8 = *p;
			break;
		case 2:
			hs->flags |= F_DISP16;
			hs->disp.disp16 = *(uint16_t*)p;
			break;
		case 4:
			hs->flags |= F_DISP32;
			hs->disp.disp32 = *(uint32_t*)p;
		}
		p += disp_size;
	}
	else if (pref & PRE_LOCK)
		hs->flags |= F_ERROR | F_ERROR_LOCK;

	if (cflags & C_IMM_P66) {
		if (cflags & C_REL32) {
			if (pref & PRE_66) {
				hs->flags |= F_IMM16 | F_RELATIVE;
				hs->imm.imm16 = *(uint16_t*)p;
				p += 2;
				goto disasm_done;
			}
			goto rel32_ok;
		}
		if (op64) {
			hs->flags |= F_IMM64;
			hs->imm.imm64 = *(uint64_t*)p;
			p += 8;
		}
		else if (!(pref & PRE_66)) {
			hs->flags |= F_IMM32;
			hs->imm.imm32 = *(uint32_t*)p;
			p += 4;
		}
		else
			goto imm16_ok;
	}

	if (cflags & C_IMM16) {
	imm16_ok:
		hs->flags |= F_IMM16;
		hs->imm.imm16 = *(uint16_t*)p;
		p += 2;
	}
	if (cflags & C_IMM8) {
		hs->flags |= F_IMM8;
		hs->imm.imm8 = *p++;
	}

	if (cflags & C_REL32) {
	rel32_ok:
		hs->flags |= F_IMM32 | F_RELATIVE;
		hs->imm.imm32 = *(uint32_t*)p;
		p += 4;
	}
	else if (cflags & C_REL8) {
		hs->flags |= F_IMM8 | F_RELATIVE;
		hs->imm.imm8 = *p++;
	}

disasm_done:

	if ((hs->len = (uint8_t)(p - (uint8_t*)code)) > 15) {
		hs->flags |= F_ERROR | F_ERROR_LENGTH;
		hs->len = 15;
	}

	return (unsigned int)hs->len;
}

#pragma warning(pop)
#endif // defined(_M_X64) || defined(__x86_64__)
```

`kernel/kmd/infinity_hook/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`kernel/kmd/infinity_hook/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`kernel/kmd/infinity_hook/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`kernel/kmd/infinity_hook/headers.hpp`:

```hpp
#pragma once

#include <ntifs.h>
#include <ntdef.h>
#include <ntddk.h>
#include <wdm.h>
#include <ntstatus.h>
#include <ntimage.h>
#include <ntstrsafe.h>
#include <intrin.h>
#include <intsafe.h>
```

`kernel/kmd/infinity_hook/hook.cpp`:

```cpp
#pragma warning(disable : 4201 4819 4311 4302 4996)
#include "hook.hpp"
#include "utils.hpp"

/* 微软官方文档定义
*   https://docs.microsoft.com/en-us/windows/win32/etw/wnode-header
*/
typedef struct _WNODE_HEADER
{
	ULONG BufferSize;
	ULONG ProviderId;
	union {
		ULONG64 HistoricalContext;
		struct {
			ULONG Version;
			ULONG Linkage;
		};
	};
	union {
		HANDLE KernelHandle;
		LARGE_INTEGER TimeStamp;
	};
	GUID Guid;
	ULONG ClientContext;
	ULONG Flags;
} WNODE_HEADER, * PWNODE_HEADER;

/* 微软文档定义
*   https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties
*/
typedef struct _EVENT_TRACE_PROPERTIES
{
	WNODE_HEADER Wnode;
	ULONG BufferSize;
	ULONG MinimumBuffers;
	ULONG MaximumBuffers;
	ULONG MaximumFileSize;
	ULONG LogFileMode;
	ULONG FlushTimer;
	ULONG EnableFlags;
	union {
		LONG AgeLimit;
		LONG FlushThreshold;
	} DUMMYUNIONNAME;
	ULONG NumberOfBuffers;
	ULONG FreeBuffers;
	ULONG EventsLost;
	ULONG BuffersWritten;
	ULONG LogBuffersLost;
	ULONG RealTimeBuffersLost;
	HANDLE LoggerThreadId;
	ULONG LogFileNameOffset;
	ULONG LoggerNameOffset;
} EVENT_TRACE_PROPERTIES, * PEVENT_TRACE_PROPERTIES;

/* 
*  这结构是大佬逆向出来的 
*/
typedef struct _CKCL_TRACE_PROPERIES : EVENT_TRACE_PROPERTIES
{
	ULONG64 Unknown[3];
	UNICODE_STRING ProviderName;
} CKCL_TRACE_PROPERTIES, * PCKCL_TRACE_PROPERTIES;

/* 
*  操作类型
*/
typedef enum _trace_type
{
	start_trace = 1,
	stop_trace = 2,
	query_trace = 3,
	update_trace = 4,
	flush_trace = 5
}trace_type;

namespace k_hook
{
	f_call_back m_call_back = nullptr; 
	unsigned long m_build_number = 0;
	void* m_syscall_table = nullptr;
	bool m_routine_status = true;

	void* m_EtwpDebuggerData = nullptr; 
	void* m_CkclWmiLoggerContext = nullptr;
	
	void** m_EtwpDebuggerDataSilo = nullptr;
	void** m_GetCpuClock_ptr = nullptr;

	unsigned long long m_original_GetCpuClock = 0;
	unsigned long long m_HvlpReferenceTscPage = 0;
	unsigned long long m_HvlGetQpcBias_ptr = 0;
	//unsigned long long m_HvlGetReferenceTimeUsingTscPage = 0;
	//unsigned long long m_HvlGetReferenceTimeUsingTscPage_ptr = 0;
	//unsigned long long m_original_HalpPerformanceCounter = 0;
	//unsigned long long m_HalpPerformanceCounter_ptr = 0;
	//unsigned long long m_HalpPerformanceCounter = 0;
	unsigned long long m_HalpTimerQueryHostPerformanceCounter_ptr = 0;

	typedef __int64 (*FHvlGetQpcBias)();
	FHvlGetQpcBias m_original_HvlGetQpcBias = nullptr;
	//typedef __int64 (*FHvlGetReferenceTimeUsingTscPage)();
	//FHvlGetReferenceTimeUsingTscPage m_original_HvlGetReferenceTimeUsingTscPage = nullptr;
	typedef __int64 (*FHalpTimerQueryHostPerformanceCounter)(PVOID a1);
	FHalpTimerQueryHostPerformanceCounter m_original_HalpTimerQueryHostPerformanceCounter = nullptr;

	// 修改跟踪设置
	NTSTATUS modify_trace_settings(trace_type type)
	{
		const unsigned long tag = 'VMON';

		// 申请结构体空间
		CKCL_TRACE_PROPERTIES* property = (CKCL_TRACE_PROPERTIES*)ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, tag);
		if (!property)
		{
			DbgPrintEx(0, 0, "[%s] allocate ckcl trace propertice struct fail \n", __FUNCTION__);
			return STATUS_MEMORY_NOT_ALLOCATED;
		}

		// 申请保存名称的空间
		wchar_t* provider_name = (wchar_t*)ExAllocatePoolWithTag(NonPagedPool, 256 * sizeof(wchar_t), tag);
		if (!provider_name)
		{
			DbgPrintEx(0, 0, "[%s] allocate provider name fail \n", __FUNCTION__);
			ExFreePoolWithTag(property, tag);
			return STATUS_MEMORY_NOT_ALLOCATED;
		}

		// 清空内存
		RtlZeroMemory(property, PAGE_SIZE);
		RtlZeroMemory(provider_name, 256 * sizeof(wchar_t));

		// 名称赋值
		RtlCopyMemory(provider_name, L"Circular Kernel Context Logger", sizeof(L"Circular Kernel Context Logger"));
		RtlInitUnicodeString(&property->ProviderName, (const wchar_t*)provider_name);

		// 唯一标识符
		GUID ckcl_session_guid = { 0x54dea73a, 0xed1f, 0x42a4, { 0xaf, 0x71, 0x3e, 0x63, 0xd0, 0x56, 0xf1, 0x74 } };

		// 结构体填充
		property->Wnode.BufferSize = PAGE_SIZE;
		property->Wnode.Flags = 0x00020000;
		property->Wnode.Guid = ckcl_session_guid;
		property->Wnode.ClientContext = 3;
		property->BufferSize = sizeof(unsigned long);
		property->MinimumBuffers = 2;
		property->MaximumBuffers = 2;
		property->LogFileMode = 0x00000400;

		// 执行操作
		unsigned long length = 0;
		// if (type == trace_type::update_trace) property->EnableFlags = 0x00000080; // Trace system calls
		if (type == trace_type::update_trace) property->EnableFlags = 0x00000010; // Trace context switches
		NTSTATUS status = NtTraceControl(type, property, PAGE_SIZE, property, PAGE_SIZE, &length);

		// 释放内存空间
		ExFreePoolWithTag(provider_name, tag);
		ExFreePoolWithTag(property, tag);

		return status;
	}

	// 我们的替换函数,针对的是从Win7到Win10 1909的系统
	unsigned long long self_get_cpu_clock()
	{
		void** stack_frame = (void**)_AddressOfReturnAddress();
		//unsigned long long core_idx = KeGetCurrentProcessorNumberEx(NULL);
		//DbgPrintEx(0, 0, "[%s] stack frame: %p core index: %lld\n", __FUNCTION__, stack_frame, core_idx);
		//DbgBreakPoint();

		// TODO: The offset will change depending on the build version
		// try to search for the offset dynamically
		PKTHREAD new_thread = (PKTHREAD)stack_frame[21];
		PKTHREAD old_thread = (PKTHREAD)stack_frame[23];
		// DbgPrintEx(0, 0, "[%s] new thread: %p old thread: %p\n", __FUNCTION__, new_thread, old_thread);

		if (new_thread && old_thread)
		{
			HANDLE new_proc = PsGetThreadProcessId(new_thread);
			HANDLE old_proc = PsGetThreadProcessId(old_thread);
			// DbgPrintEx(0, 0, "[%s] new proc: %p old proc: %p\n", __FUNCTION__, new_proc, old_proc);

			m_call_back((unsigned int)(UINT_PTR)new_proc, (unsigned int)(UINT_PTR)old_proc);
		}
		return __rdtsc();
	}

	// 我们的替换函数,针对的是Win 1919往上的系统
	EXTERN_C __int64 self_hvl_get_qpc_bias()
	{
		// 我们的过滤函数
		self_get_cpu_clock();

		// 这里是真正HvlGetQpcBias做的事情
		return *((unsigned long long*)(*((unsigned long long*)m_HvlpReferenceTscPage)) + 3);
	}

	EXTERN_C __int64 self_halp_timer_query_host_performance_counter(PVOID a1)
	{
		// 我们的过滤函数
		self_get_cpu_clock();

		// 这里是真正HalpTimerQueryHostPerformanceCounter做的事情
		return m_original_HalpTimerQueryHostPerformanceCounter(a1);
	}

	// 检测例程
	void detect_routine(void*)
	{
		while (m_routine_status)
		{
			// 线程常用休眠
			k_utils::sleep(4000);

			// GetCpuClock还是一个函数指针
			if (m_build_number <= 18363)
			{
				DbgPrintEx(0, 0, "[%s] fix 0x%p 0x%p \n", __FUNCTION__, m_GetCpuClock_ptr, MmIsAddressValid(m_GetCpuClock_ptr) ? *m_GetCpuClock_ptr : 0);

				if (MmIsAddressValid(m_GetCpuClock_ptr) && MmIsAddressValid(*m_GetCpuClock_ptr))
				{
					// 值不一样,必须重新挂钩
					if (self_get_cpu_clock != *m_GetCpuClock_ptr)
					{
						if (initialize(m_call_back)) start();
					}
				}
				else initialize(m_call_back); // GetCpuClock无效后要重新获取
			}
		}
	}

	bool initialize(f_call_back call_back)
	{
		if (!m_routine_status) return false;

		// 回调函数指针检查
		DbgPrintEx(0, 0, "[%s] call back func ptr is 0x%p \n", __FUNCTION__, call_back);
		if (!MmIsAddressValid(call_back)) return false;
		else m_call_back = call_back;

		// 先尝试挂钩
		if (!NT_SUCCESS(modify_trace_settings(update_trace)))
		{
			// 无法开启CKCL
			if (!NT_SUCCESS(modify_trace_settings(start_trace)))
			{
				DbgPrintEx(0, 0, "[%s] start ckcl fail \n", __FUNCTION__);
				return false;
			}

			// 再次尝试挂钩
			if (!NT_SUCCESS(modify_trace_settings(update_trace)))
			{
				DbgPrintEx(0, 0, "[%s] syscall ckcl fail \n", __FUNCTION__);
				return false;
			}
		}

		// 获取系统版本号
		m_build_number = k_utils::get_system_build_number();
		DbgPrintEx(0, 0, "[%s] build number is %ld \n", __FUNCTION__, m_build_number);
		if (!m_build_number) return false;

		// 获取系统基址
		unsigned long long ntoskrnl = k_utils::get_module_address("ntoskrnl.exe", nullptr);
		DbgPrintEx(0, 0, "[%s] ntoskrnl address is 0x%llX \n", __FUNCTION__, ntoskrnl);
		if (!ntoskrnl) return false;

		// 这里不同系统不同位置
		// https://github.com/FiYHer/InfinityHookPro/issues/17  win10 21h2.2130 安装 KB5018410 补丁后需要使用新的特征码 
		unsigned long long EtwpDebuggerData = k_utils::find_pattern_image(ntoskrnl, "\x00\x00\x2c\x08\x04\x38\x0c", "??xxxxx", ".text");
		if (!EtwpDebuggerData) EtwpDebuggerData = k_utils::find_pattern_image(ntoskrnl, "\x00\x00\x2c\x08\x04\x38\x0c", "??xxxxx", ".data");
		if (!EtwpDebuggerData) EtwpDebuggerData = k_utils::find_pattern_image(ntoskrnl, "\x00\x00\x2c\x08\x04\x38\x0c", "??xxxxx", ".rdata");
		DbgPrintEx(0, 0, "[%s] etwp debugger data is 0x%llX \n", __FUNCTION__, EtwpDebuggerData);
		if (!EtwpDebuggerData) return false;
		m_EtwpDebuggerData = (void*)EtwpDebuggerData;

		// 这里暂时不知道怎么定位,偏移0x10在全部系统都一样
		m_EtwpDebuggerDataSilo = *(void***)((unsigned long long)m_EtwpDebuggerData + 0x10);
		DbgPrintEx(0, 0, "[%s] etwp debugger data silo is 0x%p \n", __FUNCTION__, m_EtwpDebuggerDataSilo);
		if (!m_EtwpDebuggerDataSilo) return false;

		// 这里也不知道怎么定位,偏移0x2在全部系统都哦一样
		m_CkclWmiLoggerContext = m_EtwpDebuggerDataSilo[0x2];
		DbgPrintEx(0, 0, "[%s] ckcl wmi logger context is 0x%p \n", __FUNCTION__, m_CkclWmiLoggerContext);
		if (!m_CkclWmiLoggerContext) return false;

		/*  Win7系统测试,m_GetCpuClock该值会改变几次,先阶段使用线程检测后修复
		*   靠,Win11的偏移变成了0x18,看漏的害我调试这么久  -_-
		*   这里总结一下,Win7和Win11都是偏移0x18,其它的是0x28
		*/
		if (m_build_number <= 7601 || m_build_number >= 22000) m_GetCpuClock_ptr = (void**)((unsigned long long)m_CkclWmiLoggerContext + 0x18); // Win7版本以及更旧, Win11也是
		else m_GetCpuClock_ptr = (void**)((unsigned long long)m_CkclWmiLoggerContext + 0x28); // Win8 -> Win10全系统
		if (!MmIsAddressValid(m_GetCpuClock_ptr)) return false;
		DbgPrintEx(0, 0, "[%s] get cpu clock is 0x%p \n", __FUNCTION__, *m_GetCpuClock_ptr);

		// 拿到ssdt指针
		m_syscall_table = PAGE_ALIGN(k_utils::get_syscall_entry(ntoskrnl));
		DbgPrintEx(0, 0, "[%s] syscall table is 0x%p \n", __FUNCTION__, m_syscall_table);
		if (!m_syscall_table) return false;

		if (m_build_number > 18363)
		{
			/* HvlGetQpcBias函数内部需要用到这个结构
			*   所以我们手动定位这个结构
			*/
			unsigned long long address = k_utils::find_pattern_image(ntoskrnl,
				"\x48\x8b\x05\x00\x00\x00\x00\x48\x8b\x40\x00\x48\x8b\x0d\x00\x00\x00\x00\x48\xf7\xe2",
				"xxx????xxx?xxx????xxx");
			if (!address) return false;
			m_HvlpReferenceTscPage = reinterpret_cast<unsigned long long>(reinterpret_cast<char*>(address) + 7 + *reinterpret_cast<int*>(reinterpret_cast<char*>(address) + 3));
			DbgPrintEx(0, 0, "[%s] hvlp reference tsc page is 0x%llX \n", __FUNCTION__, m_HvlpReferenceTscPage);
			if (!m_HvlpReferenceTscPage) return false;

			/* 这里我们查找到HvlGetQpcBias的指针
			*   详细介绍可以看https://www.freebuf.com/articles/system/278857.html
			*/
			address = k_utils::find_pattern_image(ntoskrnl,
			 	"\x48\x8b\x05\x00\x00\x00\x00\x48\x85\xc0\x74\x00\x48\x83\x3d\x00\x00\x00\x00\x00\x74",
				"xxx????xxxx?xxx?????x");
			// Copy from https://github.com/FiYHer/InfinityHookPro/issues/20
			if (!address)
				address = k_utils::find_pattern_image(ntoskrnl,
					"\x48\x8b\x05\x00\x00\x00\x00\xe8\x00\x00\x00\x00\x48\x03\xd8\x48\x89\x1f",
					"xxx????x????xxxxxx");
			if (!address) return false;
			m_HvlGetQpcBias_ptr = reinterpret_cast<unsigned long long>(reinterpret_cast<char*>(address) + 7 + *reinterpret_cast<int*>(reinterpret_cast<char*>(address) + 3));
			DbgPrintEx(0, 0, "[%s] hvl get qpc bias ptr is 0x%llX \n", __FUNCTION__, m_HvlGetQpcBias_ptr);
			if (!m_HvlGetQpcBias_ptr) return false;

			// NEW

			///* 定位HvlGetReferenceTimeUsingTscPage地址
			//*/
			//address = k_utils::find_pattern_image(ntoskrnl,
			//	"\x48\x8d\x05\x00\x00\x00\x00\x48\x89\x43\x28\xf7\x05\x00\x00\x00\x00\x00\x40\x00\x00",
			//	"xxx????xxxxxx????xxxx");
			//if (!address) return false;
			//m_HvlGetReferenceTimeUsingTscPage = reinterpret_cast<unsigned long long>(reinterpret_cast<char*>(address) + 7 + *reinterpret_cast<int*>(reinterpret_cast<char*>(address) + 3));
			//DbgPrintEx(0, 0, "[%s] hvl get reference time using tsc page is 0x%llX \n", __FUNCTION__, m_HvlGetReferenceTimeUsingTscPage);

			///* 定位HvlGetReferenceTimeUsingTscPage的指针
			//*  后续需要覆写指针保证控制流按照希望的方式执行
			//*/
			//address = k_utils::find_pattern_image(ntoskrnl,
			//	"\x48\x8b\x05\x00\x00\x00\x00\x48\x85\xc0\x74\x00\x33\xc9\xe8\x00\x00\x00\x00\x48\x8b\xd8",
			//	"xxx????xxxx?xxx????xxx");
			//if (!address) return false;
			//m_HvlGetReferenceTimeUsingTscPage_ptr = reinterpret_cast<unsigned long long>(reinterpret_cast<char*>(address) + 7 + *reinterpret_cast<int*>(reinterpret_cast<char*>(address) + 3));
			//DbgPrintEx(0, 0, "[%s] hvl get reference time using tsc page ptr is 0x%llX \n", __FUNCTION__, m_HvlGetReferenceTimeUsingTscPage_ptr);

			///* 定位HalpPerformanceCounter的指针
			//*/
			//address = k_utils::find_pattern_image(ntoskrnl,
			//	"\x48\x8b\x05\x00\x00\x00\x00\x48\x8b\xf9\x48\x85\xc0\x74\x00\x83\xb8\x00\x00\x00\x00\x08", // TODO: Sometimes last byte should be 7, depend on kernel version
			//	"xxx????xxxxxxx?xx????x");
			//if (!address) return false;
			//m_HalpPerformanceCounter_ptr = reinterpret_cast<unsigned long long>(reinterpret_cast<char*>(address) + 7 + *reinterpret_cast<int*>(reinterpret_cast<char*>(address) + 3));
			//DbgPrintEx(0, 0, "[%s] halp performance counter ptr is 0x%llX \n", __FUNCTION__, m_HalpPerformanceCounter_ptr);
			//m_HalpPerformanceCounter = *reinterpret_cast<unsigned long long*>(m_HalpPerformanceCounter_ptr);
			//DbgPrintEx(0, 0, "[%s] halp performance counter is 0x%llX \n", __FUNCTION__, m_HalpPerformanceCounter);

			/* 定位HalpTimerQueryHostPerformanceCounter的指针
			*  后续需要覆写指针保证控制流按照希望的方式执行
			*/
			address = k_utils::find_pattern_image(ntoskrnl,
				"\x48\x83\x64\x24\x30\x00\x48\x8d\x4c\x24\x30\x48\x8b\x05\x00\x00\x00\x00\xe8\x00\x00\x00\x00\x48\x8b\x44\x24\x30\xe9",
				"xxxxxxxxxxxxxx????x????xxxxx");
			if (!address) return false;
			m_HalpTimerQueryHostPerformanceCounter_ptr = reinterpret_cast<unsigned long long>(reinterpret_cast<char*>(address) + 18 + *reinterpret_cast<int*>(reinterpret_cast<char*>(address) + 14));
			DbgPrintEx(0, 0, "[%s] halp timer query host performance counter ptr is 0x%llX \n", __FUNCTION__, m_HalpTimerQueryHostPerformanceCounter_ptr);
		}

		return true;
	}

	bool start()
	{
		if (!m_call_back) return false;

		// 无效指针
		if (!MmIsAddressValid(m_GetCpuClock_ptr))
		{
			DbgPrintEx(0, 0, "[%s] get cpu clock vaild \n", __FUNCTION__);
			return false;
		}

		/* 这里我们区分一下系统版本
		*   从Win7到Win10 1909,g_GetCpuClock是一个函数,往后的版本是一个数值了
		*   大于3抛异常
		*   等于3用rdtsc
		*   等于2用off_140C00A30
		*   等于1用KeQueryPerformanceCounter
		*   等于0用RtlGetSystemTimePrecise
		*   我们的做法参考网址https://www.freebuf.com/articles/system/278857.html
		*   我们这里在2身上做文章
		*/
		if (m_build_number <= 18363)
		{
			// 直接修改函数指针
			DbgPrintEx(0, 0, "[%s] get cpu clock is 0x%p\n", __FUNCTION__, *m_GetCpuClock_ptr);
			*m_GetCpuClock_ptr = self_get_cpu_clock;
			DbgPrintEx(0, 0, "[%s] update get cpu clock is 0x%p\n", __FUNCTION__, *m_GetCpuClock_ptr);
		}
		else
		{
			// 保存GetCpuClock原始值,退出时好恢复
			m_original_GetCpuClock = (unsigned long long)(*m_GetCpuClock_ptr);

			/* 这里我们设置为2, 这样子才能调用off_140C00A30函数
			*   其实该指针就是HalpTimerQueryHostPerformanceCounter函数
			*   该函数里面又有两个函数指针,第一个就是HvlGetQpcBias,就是我们的目标
			*/
			*m_GetCpuClock_ptr = (void*)2;
			DbgPrintEx(0, 0, "[%s] update get cpu clock is %p \n", __FUNCTION__, *m_GetCpuClock_ptr);

			//// 保存旧HvlGetQpcBias地址,方便后面清理的时候复原环境
			//m_original_HvlGetQpcBias = (FHvlGetQpcBias)(*((unsigned long long*)m_HvlGetQpcBias_ptr));

			//// 设置钩子
			//*((unsigned long long*)m_HvlGetQpcBias_ptr) = (unsigned long long)self_hvl_get_qpc_bias;
			//DbgPrintEx(0, 0, "[%s] update hvl get qpc bias is %p \n", __FUNCTION__, self_hvl_get_qpc_bias);

			// NEW
			
			//// 保存旧HvlGetReferenceTimeUsingTscPage地址,方便后面清理的时候复原环境
			//m_original_HvlGetReferenceTimeUsingTscPage = (FHvlGetReferenceTimeUsingTscPage)(*((unsigned long long*)m_HvlGetReferenceTimeUsingTscPage_ptr));

			//// 设置函数指针指引控制流
			//*((unsigned long long*)m_HvlGetReferenceTimeUsingTscPage_ptr) = (unsigned long long)m_HvlGetReferenceTimeUsingTscPage;

			//// 设置HvlpReferenceTscPage数值指引控制流
			//*(unsigned long long**)m_HvlpReferenceTscPage = (unsigned long long*)ExAllocatePoolWithTag(NonPagedPool, 0x10, 'VMON');
			//if (!*(unsigned long long**)m_HvlpReferenceTscPage) return false;
			//**(unsigned long long**)m_HvlpReferenceTscPage = 0x1;

			//// 设置数值指引控制流
			//m_original_HalpPerformanceCounter = *((char*)m_HalpPerformanceCounter + 0xe4);
			//DbgPrintEx(0, 0, "[%s] halp performance counter is %lld \n", __FUNCTION__, m_original_HalpPerformanceCounter);
			//// TODO: Sometimes here should be 7, depend on kernel version
			//*((char*)m_HalpPerformanceCounter + 0xe4) = 8;

			// 保存旧HalpTimerQueryHostPerformanceCounter地址,方便后面清理的时候复原环境
			m_original_HalpTimerQueryHostPerformanceCounter = (FHalpTimerQueryHostPerformanceCounter)(*((unsigned long long*)m_HalpTimerQueryHostPerformanceCounter_ptr));

			// 设置钩子
			*((unsigned long long*)m_HalpTimerQueryHostPerformanceCounter_ptr) = (unsigned long long)self_halp_timer_query_host_performance_counter;
			DbgPrintEx(0, 0, "[%s] update halp timer query host performance counter is %p \n", __FUNCTION__, self_halp_timer_query_host_performance_counter);
		}

		// 创建GetCpuClock数值检测线程
		static bool is_create_thread = false;
		if (!is_create_thread)
		{
			is_create_thread = true;
			HANDLE h_thread = NULL;
			CLIENT_ID client{ 0 };
			OBJECT_ATTRIBUTES att{ 0 };
			InitializeObjectAttributes(&att, 0, OBJ_KERNEL_HANDLE, 0, 0);
			NTSTATUS status = PsCreateSystemThread(&h_thread, THREAD_ALL_ACCESS, &att, 0, &client, detect_routine, 0);
			if (NT_SUCCESS(status)) ZwClose(h_thread);
			DbgPrintEx(0, 0, "[%s] detect routine thread id is %d \n", __FUNCTION__, (int)client.UniqueThread);
		}

		return true;
	}

	bool stop()
	{
		// 停止检测线程
		m_routine_status = false;

		bool result = NT_SUCCESS(modify_trace_settings(stop_trace)) && NT_SUCCESS(modify_trace_settings(start_trace));

		// Win10 1909以上系统需要恢复环境
		if (m_build_number > 18363)
		{
			//*((unsigned long long*)m_HvlGetQpcBias_ptr) = (unsigned long long)m_original_HvlGetQpcBias;
			*m_GetCpuClock_ptr = (void*)m_original_GetCpuClock;

			// NEW

			//*((unsigned long long*)m_HvlGetReferenceTimeUsingTscPage_ptr) = (unsigned long long)m_original_HvlGetReferenceTimeUsingTscPage;
			//*((unsigned long long*)((char*)m_HalpPerformanceCounter_ptr + 0xe4)) = m_original_HalpPerformanceCounter;
			*((unsigned long long*)m_HalpTimerQueryHostPerformanceCounter_ptr) = (unsigned long long)m_original_HalpTimerQueryHostPerformanceCounter;
		}

		return result;
	}
}

```

`kernel/kmd/infinity_hook/hook.hpp`:

```hpp
#pragma once
#include "headers.hpp"

namespace k_hook
{
	// SSDT回调函数
	typedef void(__fastcall* f_call_back)(unsigned int new_proc, unsigned int old_proc);

	// 初始化数据
	bool initialize(f_call_back ssdt_call_back);

	// 开始拦截函数调用
	bool start();

	// 结束拦截函数调用
	bool stop();
}
```

`kernel/kmd/infinity_hook/imports.hpp`:

```hpp
#pragma once
#include "headers.hpp"

#ifdef __cplusplus
extern "C"
{
#endif

	typedef struct _SYSTEM_MODULE
	{
		ULONG_PTR Reserved[2];
		PVOID Base;
		ULONG Size;
		ULONG Flags;
		USHORT Index;
		USHORT Unknown;
		USHORT LoadCount;
		USHORT ModuleNameOffset;
		CHAR ImageName[256];
	} SYSTEM_MODULE, * PSYSTEM_MODULE;

	typedef struct _SYSTEM_MODULE_INFORMATION
	{
		ULONG_PTR ulModuleCount;
		SYSTEM_MODULE Modules[1];
	} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

	NTSTATUS NTAPI ZwQuerySystemInformation(
		DWORD32 systemInformationClass,
		PVOID systemInformation,
		ULONG systemInformationLength,
		PULONG returnLength);

	NTSTATUS NTAPI NtTraceControl(
		ULONG FunctionCode,
		PVOID InBuffer,
		ULONG InBufferLen,
		PVOID OutBuffer,
		ULONG OutBufferLen,
		PULONG ReturnLength);

	ULONG NTAPI PsGetProcessSessionId(PEPROCESS Process);

#ifdef __cplusplus
}
#endif
```

`kernel/kmd/infinity_hook/utils.hpp`:

```hpp
#pragma once
#include "imports.hpp"
#include "hde/hde64.h"

namespace k_utils
{
	// 获取系统版本号
	unsigned long get_system_build_number()
	{
		unsigned long number = 0;
		RTL_OSVERSIONINFOEXW info{ 0 };
		info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
		if (NT_SUCCESS(RtlGetVersion((PRTL_OSVERSIONINFOW)&info))) number = info.dwBuildNumber;
		return number;
	}

	// 获取指定模块基址
	unsigned long long get_module_address(const char* name, unsigned long* size)
	{
		unsigned long long result = 0;

		unsigned long length = 0;
		ZwQuerySystemInformation(11, &length, 0, &length);
		if (!length) return result;

		const unsigned long tag = 'VMON';
		PSYSTEM_MODULE_INFORMATION system_modules = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, length, tag);
		if (!system_modules) return result;

		NTSTATUS status = ZwQuerySystemInformation(11, system_modules, length, 0);
		if (NT_SUCCESS(status))
		{
			for (unsigned long long i = 0; i < system_modules->ulModuleCount; i++)
			{
				PSYSTEM_MODULE mod = &system_modules->Modules[i];
				if (strstr(mod->ImageName, name))
				{
					result = (unsigned long long)mod->Base;
					if (size) *size = (unsigned long)mod->Size;
					break;
				}
			}
		}

		ExFreePoolWithTag(system_modules, tag);
		return result;
	}

	// 模式匹配
	bool pattern_check(const char* data, const char* pattern, const char* mask)
	{
		size_t len = strlen(mask);

		for (size_t i = 0; i < len; i++)
		{
			if (data[i] == pattern[i] || mask[i] == '?')
				continue;
			else
				return false;
		}

		return true;
	}

	// 模式查找
	unsigned long long find_pattern(unsigned long long addr, unsigned long size, const char* pattern, const char* mask)
	{
		size -= (unsigned long)strlen(mask);

		for (unsigned long i = 0; i < size; i++)
		{
			if (pattern_check((const char*)addr + i, pattern, mask))
				return addr + i;
		}

		return 0;
	}

	// 查找映像模式
	unsigned long long find_pattern_image(unsigned long long addr, const char* pattern, const char* mask, const char* name = ".text")
	{
		PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)addr;
		if (dos->e_magic != IMAGE_DOS_SIGNATURE) return 0;

		PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS64)(addr + dos->e_lfanew);
		if (nt->Signature != IMAGE_NT_SIGNATURE) return 0;

		PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);
		for (unsigned short i = 0; i < nt->FileHeader.NumberOfSections; i++)
		{
			PIMAGE_SECTION_HEADER p = &section[i];

			if (strstr((const char*)p->Name, name))
			{
				unsigned long long result = find_pattern(addr + p->VirtualAddress, p->Misc.VirtualSize, pattern, mask);
				if (result) return result;
			}
		}

		return 0;
	}

	// 获取映像地址
	unsigned long long get_image_address(unsigned long long addr, const char* name, unsigned long* size)
	{
		PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)addr;
		if (dos->e_magic != IMAGE_DOS_SIGNATURE) return 0;

		PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS64)(addr + dos->e_lfanew);
		if (nt->Signature != IMAGE_NT_SIGNATURE) return 0;

		PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);
		for (unsigned short i = 0; i < nt->FileHeader.NumberOfSections; i++)
		{
			PIMAGE_SECTION_HEADER p = &section[i];

			if (strstr((const char*)p->Name, name))
			{
				if (size) *size = p->SizeOfRawData;
				return (unsigned long long)p + p->VirtualAddress;
			}
		}

		return 0;
	}

	// 获取SSDT表地址
	void* get_syscall_entry(unsigned long long ntoskrnl)
	{
		if (!ntoskrnl) return nullptr;

		/*
		2018年的内核页表隔离补丁 https://bbs.pediy.com/thread-223805.htm
		没有补丁的话就是KiSystemCall64
		*/
#define IA32_LSTAR_MSR 0xC0000082
		void* syscall_entry = (void*)__readmsr(IA32_LSTAR_MSR);

		// 没有补丁过,直接返回KiSystemCall64就行
		unsigned long section_size = 0;
		unsigned long long KVASCODE = get_image_address(ntoskrnl, "KVASCODE", &section_size);
		if (!KVASCODE) return syscall_entry;

		// KiSystemCall64还是在区域内,也是直接返回
		if (!(syscall_entry >= (void*)KVASCODE && syscall_entry < (void*)(KVASCODE + section_size))) return syscall_entry;

		// 来到这一步那就是KiSystemCall64Shadow,代表打补丁了
		hde64s hde_info{ 0 };
		for (char* ki_system_service_user = (char*)syscall_entry; ; ki_system_service_user += hde_info.len)
		{
			// 反汇编
			if (!hde64_disasm(ki_system_service_user, &hde_info)) break;

			// 我们要查找jmp
#define OPCODE_JMP_NEAR 0xE9
			if (hde_info.opcode != OPCODE_JMP_NEAR) continue;

			// 忽略在KVASCODE节区内的jmp指令
			void* possible_syscall_entry = (void*)((long long)ki_system_service_user + (int)hde_info.len + (int)hde_info.imm.imm32);
			// DbgPrintEx(0, 0, "possible_syscall_entry: %p\n", possible_syscall_entry);
			if (possible_syscall_entry >= (void*)KVASCODE && possible_syscall_entry < (void*)((unsigned long long)KVASCODE + section_size)) continue;

			// 发现KiSystemServiceUser
			syscall_entry = possible_syscall_entry;
			break;
		}

		// DbgPrintEx(0, 0, "syscall_entry: %p\n", syscall_entry);
		return syscall_entry;
	}

	// 休眠函数
	void sleep(long msec)
	{
		LARGE_INTEGER integer{ 0 };

		// 这里的负数表示的是相对时间，正数拒说表示绝对时间，我没试出效果。单位是100nm,此处乘以10000是让单位变为s,很多代码都是乘以10,即传入的单位是ms;
		integer.QuadPart = -10000;
		integer.QuadPart *= msec;
		KeDelayExecutionThread(KernelMode, FALSE, &integer);
	}
}
```

`kernel/kmd/kmd.inf`:

```inf
;
; kmd.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=kmd.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
kmd_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
kmd.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%kmd.DeviceDesc%=kmd_Device, Root\kmd ; TODO: edit hw-id

[kmd_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
kmd.sys

;-------------- Service installation
[kmd_Device.NT.Services]
AddService = kmd,%SPSVCINST_ASSOCSERVICE%, kmd_Service_Inst

; -------------- kmd driver install sections
[kmd_Service_Inst]
DisplayName    = %kmd.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\kmd.sys

;
;--- kmd_Device Coinstaller installation ------
;

[kmd_Device.NT.CoInstallers]
AddReg=kmd_Device_CoInstaller_AddReg
CopyFiles=kmd_Device_CoInstaller_CopyFiles

[kmd_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[kmd_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[kmd_Device.NT.Wdf]
KmdfService =  kmd, kmd_wdfsect
[kmd_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "kmd Installation Disk"
kmd.DeviceDesc = "kmd Device"
kmd.SVCDESC = "kmd Service"

```

`kernel/kmd/kmd.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33815.320
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kmd", "kmd.vcxproj", "{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Debug|ARM64.Build.0 = Debug|ARM64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Debug|x64.ActiveCfg = Debug|x64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Debug|x64.Build.0 = Debug|x64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Debug|x64.Deploy.0 = Debug|x64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Release|ARM64.ActiveCfg = Release|ARM64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Release|ARM64.Build.0 = Release|ARM64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Release|ARM64.Deploy.0 = Release|ARM64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Release|x64.ActiveCfg = Release|x64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Release|x64.Build.0 = Release|x64
		{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FFEC1C4F-C33B-4436-BF14-B4AEE7EE6794}
	EndGlobalSection
EndGlobal

```

`kernel/kmd/kmd.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1C99AA54-CD07-4881-B2D3-4C9B916CEF4D}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>kmd</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <DisableSpecificWarnings>4748;4200;4152;6387;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DisableSpecificWarnings>4748;4200;4152;6387;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="kmd.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\commons\bts.c" />
    <ClCompile Include="..\commons\debug.c" />
    <ClCompile Include="..\commons\lbr.c" />
    <ClCompile Include="infinity_hook\hde\hde64.cpp" />
    <ClCompile Include="infinity_hook\hook.cpp" />
    <ClCompile Include="src\libiht_kmd.cpp" />
    <ClCompile Include="src\xplat_kmd.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\commons\bts.h" />
    <ClInclude Include="..\commons\debug.h" />
    <ClInclude Include="..\commons\lbr.h" />
    <ClInclude Include="..\commons\types.h" />
    <ClInclude Include="..\commons\xioctl.h" />
    <ClInclude Include="..\commons\xplat.h" />
    <ClInclude Include="include\headers_kmd.h" />
    <ClInclude Include="include\libiht_kmd.h" />
    <ClInclude Include="infinity_hook\hde\hde64.h" />
    <ClInclude Include="infinity_hook\hde\pstdint.h" />
    <ClInclude Include="infinity_hook\hde\table64.h" />
    <ClInclude Include="infinity_hook\headers.hpp" />
    <ClInclude Include="infinity_hook\hook.hpp" />
    <ClInclude Include="infinity_hook\imports.hpp" />
    <ClInclude Include="infinity_hook\utils.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`kernel/kmd/kmd.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="infinity_hook">
      <UniqueIdentifier>{3d8c4aca-5005-4d15-b674-d9f471518595}</UniqueIdentifier>
    </Filter>
    <Filter Include="infinity_hook\hde">
      <UniqueIdentifier>{fe4712d8-0a92-4f62-8bb8-c67e2efca5e7}</UniqueIdentifier>
    </Filter>
    <Filter Include="commons">
      <UniqueIdentifier>{7ad72d73-dfea-44d8-9e8d-62f92963a24f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="kmd.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="infinity_hook\hook.cpp">
      <Filter>infinity_hook</Filter>
    </ClCompile>
    <ClCompile Include="infinity_hook\hde\hde64.cpp">
      <Filter>infinity_hook\hde</Filter>
    </ClCompile>
    <ClCompile Include="..\commons\debug.c">
      <Filter>commons</Filter>
    </ClCompile>
    <ClCompile Include="..\commons\lbr.c">
      <Filter>commons</Filter>
    </ClCompile>
    <ClCompile Include="src\libiht_kmd.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\xplat_kmd.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\commons\bts.c">
      <Filter>commons</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="infinity_hook\headers.hpp">
      <Filter>infinity_hook</Filter>
    </ClInclude>
    <ClInclude Include="infinity_hook\hook.hpp">
      <Filter>infinity_hook</Filter>
    </ClInclude>
    <ClInclude Include="infinity_hook\imports.hpp">
      <Filter>infinity_hook</Filter>
    </ClInclude>
    <ClInclude Include="infinity_hook\utils.hpp">
      <Filter>infinity_hook</Filter>
    </ClInclude>
    <ClInclude Include="infinity_hook\hde\hde64.h">
      <Filter>infinity_hook\hde</Filter>
    </ClInclude>
    <ClInclude Include="infinity_hook\hde\pstdint.h">
      <Filter>infinity_hook\hde</Filter>
    </ClInclude>
    <ClInclude Include="infinity_hook\hde\table64.h">
      <Filter>infinity_hook\hde</Filter>
    </ClInclude>
    <ClInclude Include="..\commons\debug.h">
      <Filter>commons</Filter>
    </ClInclude>
    <ClInclude Include="..\commons\lbr.h">
      <Filter>commons</Filter>
    </ClInclude>
    <ClInclude Include="..\commons\types.h">
      <Filter>commons</Filter>
    </ClInclude>
    <ClInclude Include="..\commons\xplat.h">
      <Filter>commons</Filter>
    </ClInclude>
    <ClInclude Include="include\headers_kmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\libiht_kmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\commons\bts.h">
      <Filter>commons</Filter>
    </ClInclude>
    <ClInclude Include="..\commons\xioctl.h">
      <Filter>commons</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`kernel/kmd/kmd.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`kernel/kmd/src/libiht_kmd.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/kmd/src/libiht_kmd.cpp
//  Description    : This is the main implementation for the kernel mode driver
//                   of libiht. This driver is used to capture the last branch
//                   records of a given process. This file is very platform
//                   specific and thanks to lyshark for sharing the book
//                   "Windows Kernel Programming" and the code on github.
//
//                   Reference: https://github.com/lyshark/WindowsKernelBook
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files
#pragma warning(disable : 4200 4201 4819 4311 4302 4996)
#include "../infinity_hook/hook.hpp"
#include "../include/libiht_kmd.h"

// TODO: Determine if this function are necessary, skip make description for now
/*
 * Bypass check sign
 */
BOOLEAN bypass_check_sign(PDRIVER_OBJECT driver_obj)
{
#ifdef _WIN64
    typedef struct _KLDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY listEntry;
        ULONG64 __Undefined1;
        ULONG64 __Undefined2;
        ULONG64 __Undefined3;
        ULONG64 NonPagedDebugInfo;
        ULONG64 DllBase;
        ULONG64 EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING path;
        UNICODE_STRING name;
        ULONG Flags;
        USHORT LoadCount;
        USHORT __Undefined5;
        ULONG64 __Undefined6;
        ULONG CheckSum;
        ULONG __padding1;
        ULONG TimeDateStamp;
        ULONG __padding2;
    } KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;
#else // _WIN32
    typedef struct _KLDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY listEntry;
        ULONG unknown1;
        ULONG unknown2;
        ULONG unknown3;
        ULONG unknown4;
        ULONG unknown5;
        ULONG unknown6;
        ULONG unknown7;
        UNICODE_STRING path;
        UNICODE_STRING name;
        ULONG Flags;
    } KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;
#endif
    PKLDR_DATA_TABLE_ENTRY pLdrData = (PKLDR_DATA_TABLE_ENTRY)driver_obj -> DriverSection;
    pLdrData->Flags = pLdrData->Flags | 0x20;
    return TRUE;
}

//
// Infinity Hook related context manipulation functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : create_proc_notify
// Description  : This function is used to create a process notifier. It will
//                be called when a process is created or terminated. If the
//                process is created by a parent in the `lbr_state_list`, the
//                child will also be added to the `lbr_state_list`. If the
//                process is terminated, it will be removed from the LBR
//                monitor list.
//
// Inputs       : proc - the process object
//                proc_id - the process id
//                create_info - the created process info
// Outputs      : void

VOID create_proc_notify(PEPROCESS proc, HANDLE proc_id,
    PPS_CREATE_NOTIFY_INFO create_info)
{
    UNREFERENCED_PARAMETER(proc);
    if (create_info != NULL)
    {
        // Process is being created
        lbr_newproc_handler((u32)(UINT_PTR)create_info->ParentProcessId, (u32)proc_id);
        bts_newproc_handler((u32)(UINT_PTR)create_info->ParentProcessId, (u32)proc_id);
    }
    else
    {
        // Process is being terminated
        // TODO: remove the process? But this feature not implemented on lkm
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : cswitch_call_back
// Description  : This function is used to hook the context switch. It will be
//                called when a context switch happens. If the new process is
//                in the `lbr_state_list`, it will be set up to monitor the LBR
//                of the new process. If the old process is in the
//                `lbr_state_list`, it will be removed from the LBR monitor
//                list.
//
// Inputs       : new_proc - the new process id to be switched to
//                old_proc - the old process id to be switched from
// Outputs      : void

void __fastcall cswitch_call_back(u32 new_proc, u32 old_proc)
{
    lbr_cswitch_handler(old_proc, new_proc);
    bts_cswitch_handler(old_proc, new_proc);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : infinity_hook_create
// Description  : This function is used to initialize and start the context
//                switch hook.
//
// Inputs       : void
// Outputs      : NTSTATUS - the status of the hook

NTSTATUS infinity_hook_create()
{
    // Initialize and hook
    return k_hook::initialize(cswitch_call_back) && k_hook::start() ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : infinity_hook_remove
// Description  : This function is used to stop and remove the context switch
//                hook.
//
// Inputs       : void
// Outputs      : NTSTATUS - the status of the hook

NTSTATUS infinity_hook_remove()
{
    k_hook::stop();

    // Here you need to make sure that the execution point of the system is no
    // longer in the current driver
    // For example, the current driver is unloaded, but the MyNtCreateFile you
    // hooked is still executing the for operation, of course, the blue screen
    // The sleep 10 second method here can be directly improved
    LARGE_INTEGER integer{ 0 };
    integer.QuadPart = -10000;
    integer.QuadPart *= 10000;
    KeDelayExecutionThread(KernelMode, FALSE, &integer);

    return STATUS_SUCCESS;
}

//
// Device related manipulation functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_create
// Description  : This function is used to create a device object and a
//                symbolic link for user interactive helper.
//
// Inputs       : driver_obj - the driver object
// Outputs      : NTSTATUS - the status of the device creation

NTSTATUS device_create(PDRIVER_OBJECT driver_obj)
{
    NTSTATUS status;
    PDEVICE_OBJECT device_obj;
    UNICODE_STRING device_name, sym_device_name;

    // Set dispatch routines
    for (ULONG i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        driver_obj->MajorFunction[i] = device_default;
    }
    driver_obj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = device_ioctl;

    // Create device object
    RtlInitUnicodeString(&device_name, DEVICE_NAME);
    status = IoCreateDevice(driver_obj, 0, &device_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &device_obj);
    if (!NT_SUCCESS(status)) {
        xprintdbg("Failed to create device object\n");
        return status;
    }

    // Create symbolic link
    RtlInitUnicodeString(&sym_device_name, SYM_DEVICE_NAME);
    status = IoCreateSymbolicLink(&sym_device_name, &device_name);
    if (!NT_SUCCESS(status)) {
        KdPrint(("Failed to create symbolic link\n"));
        IoDeleteDevice(device_obj);
        return status;
    }

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_remove
// Description  : This function is used to remove the device object and the
//                symbolic link for user interactive helper.
//
// Inputs       : driver_obj - the driver object
// Outputs      : NTSTATUS - the status of the device removal

NTSTATUS device_remove(PDRIVER_OBJECT driver_obj)
{
    PDEVICE_OBJECT device_obj = driver_obj->DeviceObject;
    UNICODE_STRING sym_device_name;
    RtlInitUnicodeString(&sym_device_name, SYM_DEVICE_NAME);
    IoDeleteSymbolicLink(&sym_device_name);
    IoDeleteDevice(device_obj);
    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_ioctl
// Description  : This function is used to handle the ioctl request from user
//                interactive helper.
//
// Inputs       : device_obj - the device object
//                Irp - the I/O request packet
// Outputs      : NTSTATUS - the status of the ioctl request

NTSTATUS device_ioctl(PDEVICE_OBJECT device_obj, PIRP Irp)
{
    PIO_STACK_LOCATION irp_stack;
    ULONG ioctl_cmd;
    struct xioctl_request* request;
    u64 request_size;
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(device_obj);

    // Copy user request
    irp_stack = IoGetCurrentIrpStackLocation(Irp);
    ioctl_cmd = irp_stack->Parameters.DeviceIoControl.IoControlCode;
    request_size = irp_stack->Parameters.DeviceIoControl.InputBufferLength;
    request = (struct xioctl_request*)Irp->AssociatedIrp.SystemBuffer; // Input buffer

    if (request_size != sizeof(xioctl_request))
    {
        xprintdbg("LIBIHT-KMD: Wrong request size of %ld, expect: %ld\n", request_size, sizeof(xioctl_request));
        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }

    // Process request
    if (request->cmd <= LIBIHT_IOCTL_LBR_END)
    {
        // LBR request
        xprintdbg("LIBIHT-KMD: LBR request\n");
        if (lbr_ioctl_handler(request) != 0)
            status = STATUS_UNSUCCESSFUL;
    }
	else if (request->cmd <= LIBIHT_IOCTL_BTS_END)
	{
		// BTS request
		xprintdbg("LIBIHT-KMD: BTS request\n");
		if (bts_ioctl_handler(request) != 0)
			status = STATUS_UNSUCCESSFUL;
	}
	else
	{
		// Unknown request
		xprintdbg("LIBIHT-KMD: Unknown request\n");
		status = STATUS_INVALID_DEVICE_REQUEST;
	}

    // Complete the request
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_default
// Description  : This function is used to handle the default request from user
//                interactive helper.
//
// Inputs       : device_obj - the device object
//                Irp - the I/O request packet
// Outputs      : NTSTATUS - the status of the default request

NTSTATUS device_default(PDEVICE_OBJECT device_obj, PIRP Irp)
{
    UNREFERENCED_PARAMETER(device_obj);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

//
// Driver manipulation functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : DriverEntry
// Description  : This function is the main entry point for the driver. It will
//                initialize the driver and register all the required services.
//
// Inputs       : driver_obj - the driver object
//                reg_path - the registry path
// Outputs      : NTSTATUS - the status of the driver initialization

NTSTATUS DriverEntry(PDRIVER_OBJECT driver_obj, PUNICODE_STRING reg_path)
{
    NTSTATUS status;
    UNREFERENCED_PARAMETER(reg_path);
    driver_obj->DriverUnload = (PDRIVER_UNLOAD)DriverExit;

    xprintdbg("LIBIHT-KMD: Initializing...\n");

    // Bypass check sign
    // LINKER_FLAGS=/INTEGRITYCHECK
    bypass_check_sign(driver_obj);

    // Create user interactive helper device
    xprintdbg("LIBIHT-KMD: Creating helper device...\n");
    status = device_create(driver_obj);
    if (!NT_SUCCESS(status))
        return status;

    // Register create process notifier
    xprintdbg("LIBIHT-KMD: Registering create proc notifier...\n");
    status = PsSetCreateProcessNotifyRoutineEx((PCREATE_PROCESS_NOTIFY_ROUTINE_EX)create_proc_notify, FALSE);
    if (!NT_SUCCESS(status))
        return status;

    // Init & Register hooks on context switches
    xprintdbg("LIBIHT-KMD: Initializing & Registering context switch hooks...\n");
    status = infinity_hook_create();
    if (!NT_SUCCESS(status))
        return status;

    // Init LBR
    lbr_init();

    // Init BTS
    bts_init();

    xprintdbg("LIBIHT-KMD: Initialized\n");
    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : DriverExit
// Description  : This function is the main exit point for the driver. It will
//                unregister all the registered services and clean up the
//                driver.
//
// Inputs       : driver_obj - the driver object
// Outputs      : NTSTATUS - the status of the driver exit

NTSTATUS DriverExit(PDRIVER_OBJECT driver_obj)
{
    NTSTATUS status;
    UNREFERENCED_PARAMETER(driver_obj);

    xprintdbg("LIBIHT-KMD: Exiting...\n");

    // Exit BTS
    bts_exit();

    // Exit LBR
    lbr_exit();

    // Unregister hooks on context switches.
    xprintdbg("LIBIHT-KMD: Unregistering context switch hooks (may take around 10s)...\n");
    status = infinity_hook_remove();
    if (!NT_SUCCESS(status))
        return status;

    // Unregister create process notifier
    xprintdbg("LIBIHT-KMD: Unregistering create proc notifier...\n");
    status = PsSetCreateProcessNotifyRoutineEx((PCREATE_PROCESS_NOTIFY_ROUTINE_EX)create_proc_notify, TRUE);
    if (!NT_SUCCESS(status))
        return status;

    // Remove the helper device if exist
    xprintdbg("LIBIHT-KMD: Removing helper device...\n");
    status = device_remove(driver_obj);
    if (!NT_SUCCESS(status))
        return status;

    xprintdbg("LIBIHT-KMD: Exit complete\n");
    return STATUS_SUCCESS;
}

```

`kernel/kmd/src/xplat_kmd.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/kmd/src/xplat_kmd.c
//  Description    : This is the cross-platform compatibility layer for the
//                   kernel-mode driver.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

#include "../../commons/xplat.h"
#include "../include/headers_kmd.h"

//
// Cross-platform global variables
const unsigned long g_tag = 'XPLT';

//
// Cross-platform functions

//
// Memory management functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xmalloc
// Description  : Cross platform kernel malloc function. Allocate memory from
//                the kernel heap.
//
// Inputs       : size - size of the memory to be allocated.
// Outputs      : void* - pointer to the allocated memory.

void* xmalloc(u64 size)
{
    return ExAllocatePool2(POOL_FLAG_NON_PAGED, size, g_tag);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xfree
// Description  : Cross platform kernel free function. Free memory from the
//                kernel heap.
//
// Inputs       : ptr - pointer to the memory to be freed.
// Outputs      : void

void xfree(void *ptr)
{
    ExFreePool(ptr);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcopy_from_user
// Description  : Cross platform kernel copy from user function. Copy memory
//                from user space to kernel space.
//
// Inputs       : dst - pointer to the destination memory (kernel space).
//                src - pointer to the source memory (user space).
//                cnt - size of the memory to be copied.
// Outputs      : u64 - number of bytes not copied (0 on success).

u64 xcopy_from_user(void *dst, void *src, u64 cnt)
{
    // Probe and copy the memory
    __try {
        ProbeForRead(src, cnt, 1);
        RtlCopyMemory(dst, src, cnt);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return (u64)-1;
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcopy_to_user
// Description  : Cross platform kernel copy to user function. Copy memory from
//                kernel space to user space.
//
// Inputs       : dst - pointer to the destination memory (user space).
//                src - pointer to the source memory (kernel space).
//                cnt - size of the memory to be copied.
// Outputs      : u64 - number of bytes not copied (0 on success).

u64 xcopy_to_user(void *dst, void *src, u64 cnt)
{
    // Allocate and build the MDL object
    PMDL mdl = IoAllocateMdl(dst, (u32)cnt, FALSE, FALSE, NULL);
    if (mdl == NULL) {
        return (u64)-1;
    }
    //MmBuildMdlForNonPagedPool(mdl);

    // Probe and lock the pages
    __try {
        MmProbeAndLockPages(mdl, UserMode, IoWriteAccess);
        RtlCopyMemory(MmGetSystemAddressForMdlSafe(mdl, NormalPagePriority), src, cnt);
        MmUnlockPages(mdl);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        IoFreeMdl(mdl);
        return (u64)-1;
    }
    IoFreeMdl(mdl);
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xmemset
// Description  : Cross platform kernel memset function. Set memory to a
//                specific value.
//
// Inputs       : ptr - pointer to the memory to be set.
//                c   - value to be set.
//                cnt - size of the memory to be set.
// Outputs      : void* - pointer to the set memory.

void *xmemset(void* ptr, s32 c, u64 cnt)
{
    return memset(ptr, c, cnt);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xmemcpy
// Description  : Cross platform kernel memcpy function. Copy memory from one
//                location to another.
//
// Inputs       : dst - pointer to the destination memory.
//                src - pointer to the source memory.
//                cnt - size of the memory to be copied.
// Outputs      : void* - pointer to the destination memory.

void* xmemcpy(void* dst, void* src, u64 cnt)
{
    return memcpy(dst, src, cnt);
}

//
// CPU core, hardware, register read/write functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlock_core
// Description  : Cross platform lock core function. Raise IRQL to
//                DISPATCH_LEVEL.
//
// Inputs       : old_irql - pointer to the old IRQL.
// Outputs      : void

void xlock_core(void *old_irql)
{
    KeRaiseIrql(DISPATCH_LEVEL, (PKIRQL)old_irql);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xrelease_core
// Description  : Cross platform release core function. Lower IRQL to the old
//                IRQL.
//
// Inputs       : new_irql - pointer to the new IRQL.
// Outputs      : void

void xrelease_core(void *new_irql)
{
    KeLowerIrql(*(PKIRQL)new_irql);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xwrmsr
// Description  : Cross platform write msr function. Write to a MSR.
//
// Inputs       : msr - MSR to be written.
//                val - value to be written.
// Outputs      : void

void xwrmsr(u32 msr, u64 val)
{
    __writemsr(msr, val);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xrdmsr
// Description  : Cross platform read msr function. Read from a MSR.
//
// Inputs       : msr - MSR to be read.
// Outputs      : val - pointer to the value read from the MSR.

void xrdmsr(u32 msr, u64 *val)
{
    *val = __readmsr(msr);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcoreid
// Description  : Cross platform get core id function. Get the current core id.
//
// Inputs       : void
// Outputs      : u32 - current core id.

u32 xcoreid(void)
{
    return KeGetCurrentProcessorNumberEx(0);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xgetcurrent_pid
// Description  : Cross platform get current user process pid function. Get the
//                current user process pid.
//
// Inputs       : void
// Outputs      : u32 - current user process pid.

u32 xgetcurrent_pid(void)
{
    return (u32)(ULONG_PTR)PsGetCurrentProcessId();
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcpuid
// Description  : Cross platform cpuid function. Get the cpuid information.
//
// Inputs       : func_id - cpuid function id.
// Outputs      : void

void xcpuid(u32 func_id, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)
{
    s32 regs[4];
    __cpuid(regs, func_id);
    *eax = regs[0];
    *ebx = regs[1];
    *ecx = regs[2];
    *edx = regs[3];
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xon_each_cpu
// Description  : Cross platform on each cpu dispatch function. Dispatch a
//                function to each cpu.
//
// Inputs       : func - function to be dispatched.
// Outputs      : void

void xon_each_cpu(void (*func)(void))
{
    KeIpiGenericCall((PKIPI_BROADCAST_WORKER)func, 0);
}

//
// Lock functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xinit_lock
// Description  : Cross platform init lock function. Initialize a lock.
//
// Inputs       : lock - pointer to the lock to be initialized.
// Outputs      : void

void xinit_lock(void *lock)
{
    KeInitializeSpinLock((PKSPIN_LOCK)lock);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xacquire_lock
// Description  : Cross platform acquire lock function. Acquire a lock.
//
// Inputs       : lock     - pointer to the lock to be acquired.
//                old_irql - pointer to the old IRQL.
// Outputs      : void

void xacquire_lock(void *lock, void *old_irql)
{
    KeAcquireSpinLock((PKSPIN_LOCK)lock, (PKIRQL)old_irql);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xrelease_lock
// Description  : Cross platform release lock function. Release a lock.
//
// Inputs       : lock     - pointer to the lock to be released.
//                new_irql - pointer to the new IRQL.
// Outputs      : void

void xrelease_lock(void *lock, void *new_irql)
{
    KeReleaseSpinLock((PKSPIN_LOCK)lock, *(PKIRQL)new_irql);
}

//
// List functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xinit_list_head
// Description  : Cross platform init list head function. Initialize a list
//                head.
//
// Inputs       : list - pointer to the list head to be initialized.
// Outputs      : void

void xinit_list_head(void *list)
{
    InitializeListHead((PLIST_ENTRY)list);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_add
// Description  : Cross platform list add function. Add an entry to a list.
//
// Inputs       : new_entry - pointer to the entry to be added.
//                head      - pointer to the list head.
// Outputs      : void

void xlist_add(void* new_entry, void* head)
{
    InsertHeadList((PLIST_ENTRY)head, (PLIST_ENTRY)new_entry);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_del
// Description  : Cross platform list delete function. Delete an entry from a
//                list.
//
// Inputs       : entry - pointer to the entry to be deleted.
// Outputs      : void

void xlist_del(void* entry)
{
    RemoveEntryList((PLIST_ENTRY)entry);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_next
// Description  : Cross platform list next function. Get the next entry in a
//                list.
//
// Inputs       : entry - pointer to the current entry.
// Outputs      : void* - pointer to the next entry.

void* xlist_next(void* entry)
{
    return (void *)((PLIST_ENTRY)entry)->Flink;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_prev
// Description  : Cross platform list prev function. Get the previous entry in a
//                list.
//
// Inputs       : entry - pointer to the current entry.
// Outputs      : void* - pointer to the previous entry.

void* xlist_prev(void* entry)
{
    return (void *)((PLIST_ENTRY)entry)->Blink;
}

//
// Debug functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xprintdbg
// Description  : Cross platform print kernel debug message function. Print a
//                debug message to the kernel debug output.
//
// Inputs       : format - format string.
// Outputs      : void

void xprintdbg(const char *format, ...)
{
    va_list args;
    _crt_va_start(args, format);
    vDbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, args);
}


```

`kernel/lkm/Makefile`:

```
# Makefile for lkm directory

# Path to the Linux Kernel build system
KERNEL_DIR ?= /lib/modules/$(shell uname -r)/build
# Path to the kernel module
SRC_DIR ?= ./src
# Path to the include directory
INC_DIR ?= ./include
# Path to the common directory
COMMON_DIR ?= ../commons

# Module name
MODULE_NAME := libiht_lkm
obj-m += $(MODULE_NAME).o

# Source files
libiht_lkm-objs := \
					$(COMMON_DIR)/debug.o \
					$(COMMON_DIR)/lbr.o \
					$(COMMON_DIR)/bts.o \
					$(SRC_DIR)/xplat_lkm.o \
					$(SRC_DIR)/libiht_lkm.o \

# Include paths
ccflags-y := -I$(INC_DIR) -I$(COMMON_DIR)

# Targets for make
all:
	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean
	$(MAKE) -C $(COMMON_DIR) clean
	$(RM) $(MODULE_NAME).asm

# Helper commands
insert:
	sudo insmod $(MODULE_NAME).ko

remove:
	sudo rmmod $(MODULE_NAME)

mesg:
	sudo dmesg -wH

disasm:
	objdump -M intel -d $(MODULE_NAME).ko > $(MODULE_NAME).asm

```

`kernel/lkm/include/headers_lkm.h`:

```h
#ifndef _HEADERS_LKM_H
#define _HEADERS_LKM_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/lkm/include/headers_lkm.h
//  Description    : This is the header file for the kernel-mode driver. It
//                   contains all the necessary header files for the driver.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

// Include Files

#include <linux/kernel.h>
#include <linux/module.h>

#include <linux/errno.h>
#include <linux/fortify-string.h>
#include <linux/init.h>
#include <linux/kprobes.h>
#include <linux/list.h>
#include <linux/notifier.h>
#include <linux/preempt.h>
#include <linux/printk.h>
#include <linux/proc_fs.h>
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/smp.h>
#include <linux/spinlock.h>
#include <linux/tracepoint.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#include <asm/msr.h>
#include <asm/msr-index.h>
#include <asm/processor.h>

#endif // _HEADERS_LKM_H

```

`kernel/lkm/include/libiht_lkm.h`:

```h
#ifndef _LIBIHT_LKM_H
#define _LIBIHT_LKM_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/lkm/include/libiht_lkm.h
//  Description    : This is the header file for the Linux kernel module of
//                   libiht.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024

//
// Include Files
#include "headers_lkm.h"
#include "../../commons/lbr.h"
#include "../../commons/bts.h"
#include "../../commons/types.h"
#include "../../commons/debug.h"

//
// Library constants

// Check Linux kernel version.
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
#define HAVE_PROC_OPS
#endif

// Device name
#define DEVICE_NAME "libiht-info"

// I/O control macros
#define LIBIHT_LKM_IOCTL_MAGIC 'l'
#define LIBIHT_LKM_IOCTL_BASE       _IO(LIBIHT_LKM_IOCTL_MAGIC, 0)

//
// Type definitions

// Tracepoint table
struct tracepoint_table
{
    const char *name;
    void *func;
    struct tracepoint *tp;
};

//
// Global variables

struct proc_dir_entry *proc_entry;

//
// Function prototypes

void lookup_tracepoints(struct tracepoint *tp, void *ignore);
// This function is used to lookup tracepoints.

void register_tracepoints(void);
// This function is used to register tracepoints.

void unregister_tracepoints(void);
// This function is used to unregister tracepoints.

void tp_sched_switch_handler(void *data, bool preempt,
                                struct task_struct *prev,
                                struct task_struct *next);
// This function is called when the sched_switch tracepoint is hit.

void tp_new_task_handler(void *data, struct task_struct *task);
// This function is called when the task_newtask tracepoint is hit.

int device_open(struct inode *inode, struct file *file_ptr);
// This function is used to open the device.

int device_release(struct inode *inode, struct file *file_ptr);
// This function is used to close the device.

ssize_t device_read(struct file *file_ptr, char *buffer, size_t length,
                        loff_t *offset);
// This function is used to read from the device.

ssize_t device_write(struct file *file_ptr, const char *buffer, size_t length,
                        loff_t *offset);
// This function is used to write to the device.

long device_ioctl(struct file *file_ptr, unsigned int ioctl_cmd,
                    unsigned long ioctl_param);
// This function is used to handle IOCTL requests.

int __init libiht_lkm_init(void);
// This function is called when the module is loaded.

void __exit libiht_lkm_exit(void);
// This function is called when the module is unloaded.

//
// Global variables require function prototypes
// Due to differnt kernel version, determine which struct going to use
#ifdef HAVE_PROC_OPS
static struct proc_ops libiht_ops = {
    .proc_open = device_open,
    .proc_release = device_release,
    .proc_read = device_read,
    .proc_write = device_write,
    .proc_ioctl = device_ioctl};
#else
static struct file_operations libiht_ops = {
    .open = device_open,
    .release = device_release,
    .read = device_read,
    .write = device_write,
    .unlocked_ioctl = device_ioctl};
#endif

// Structures for installing the tracepoint hooks.
struct tracepoint_table traces[] = {
    {.name = "sched_switch", .func = tp_sched_switch_handler},
    {.name = "task_newtask", .func = tp_new_task_handler}
};


#endif // _LIBIHT_LKM_H
```

`kernel/lkm/src/libiht_lkm.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/lkm/src/libiht_lkm.c
//  Description    : This is the main implementation for the Linux kernel module
//                   of libiht. This module is used to capture the last branch
//                   records of a given process. This file is very platform
//                   specific.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

#include "../include/libiht_lkm.h"

//
// Module information

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Thomason Zhao");
MODULE_DESCRIPTION("Intel Hardware Trace Library - Linux Kernel Module");

//
// Tracepoint table helpers

////////////////////////////////////////////////////////////////////////////////
//
// Function     : lookup_tracepoints
// Description  : This function is used to lookup tracepoints.
//
// Inputs       : tp - the tracepoint
//                ignore - the ignore pointer
// Outputs      : void

void lookup_tracepoints(struct tracepoint *tp, void *ignore) {
    int i;

    for (i = 0; i < sizeof(traces) / sizeof(struct tracepoint_table); i++) {
        // xprintdbg(KERN_INFO "LIBIHT_LKM: Lookup tracepoint: %s\n", tp->name);
        if (strcmp(traces[i].name, tp->name) == 0)
            traces[i].tp = tp;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : register_tracepoints
// Description  : This function is used to register tracepoints.
//
// Inputs       : void
// Outputs      : void

void register_tracepoints(void) {
    int i;

    for_each_kernel_tracepoint(lookup_tracepoints, NULL);

    // Register tracepoint handlers in the table
    for (i = 0; i < sizeof(traces) / sizeof(struct tracepoint_table); i++) {
        if (traces[i].tp) {
            xprintdbg(KERN_INFO "LIBIHT_LKM: Registering tracepoint %s\n", traces[i].name);
            tracepoint_probe_register(traces[i].tp, traces[i].func, NULL);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : unregister_tracepoints
// Description  : This function is used to unregister tracepoints.
//
// Inputs       : void
// Outputs      : void

void unregister_tracepoints(void) {
    int i;

    // Unregister tracepoint handlers in the table
    for (i = 0; i < sizeof(traces) / sizeof(struct tracepoint_table); i++) {
        if (traces[i].tp) {
            tracepoint_probe_unregister(traces[i].tp, traces[i].func, NULL);
            traces[i].tp = NULL;
        }
    }
}

//
// Tracepoint handlers

////////////////////////////////////////////////////////////////////////////////
//
// Function     : tp_sched_switch_handler
// Description  : This function is the handler for the sched_switch event. It
//                will be called when a process is switched in.
//
// Inputs       : data - the data
//                preempt - the preempt flag
//                prev_task - the previous process
//                next_task - the next_task process
// Outputs      : void

void tp_sched_switch_handler(void *data, bool preempt,
                                    struct task_struct *prev_task,
                                    struct task_struct *next_task)
{
    lbr_cswitch_handler(prev_task->pid, next_task->pid);
    bts_cswitch_handler(prev_task->pid, next_task->pid);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : tp_new_task_handler
// Description  : This function is the handler for the new_task event. It will
//                be called when a new process is created.
//
// Inputs       : data - the data
//                task - the task
// Outputs      : void

void tp_new_task_handler(void *data, struct task_struct *task)
{
    lbr_newproc_handler(task->real_parent->pid, task->pid);
    bts_newproc_handler(task->real_parent->pid, task->pid);
}

//
// Device proc handlers

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_open
// Description  : This function is used to handle open request for the device
//                process.
//
// Inputs       : inode - the inode
//                file_ptr - the file pointer
// Outputs      : int - status of the open. 0 if success, -1 if fail.

int device_open(struct inode *inode, struct file *file_ptr)
{
    // Reserved for future use
    xprintdbg(KERN_INFO "LIBIHT_LKM: device_open\n");
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_release
// Description  : This function is used to handle close request for the device
//                process.
//
// Inputs       : inode - the inode
//                file_ptr - the file pointer
// Outputs      : int - status of the close. 0 if success, -1 if fail.

int device_release(struct inode *inode, struct file *file_ptr)
{
    // Reserved for future use
    xprintdbg(KERN_INFO "LIBIHT_LKM: device_release\n");
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_read
// Description  : This function is used to read handle request for the device
//                process.
//
// Inputs       : file_ptr - the file pointer
//                buffer - the buffer
//                length - the length
//                offset - the offset
// Outputs      : ssize_t - the size of the read

ssize_t device_read(struct file *file_ptr, char *buffer, size_t length,
                        loff_t *offset)
{
    // Reserved for future use
    xprintdbg(KERN_INFO "LIBIHT_LKM: device_read\n");
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_write
// Description  : This function is used to write handle request for the device
//                process.
//
// Inputs       : file_ptr - the file pointer
//                buffer - the buffer
//                length - the length
//                offset - the offset
// Outputs      : ssize_t - the size of the write

ssize_t device_write(struct file *file_ptr, const char *buffer, size_t length,
                        loff_t *offset)
{
    // Reserved for future use
    xprintdbg(KERN_INFO "LIBIHT_LKM: device_write\n");
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : device_ioctl
// Description  : This function is used to handle ioctl request for the device
//                process.
//
// Inputs       : file_ptr - the file pointer
//                ioctl_num - the ioctl number
//                ioctl_param - the ioctl parameter
// Outputs      : long - the status of the ioctl

long device_ioctl(struct file *file_ptr, unsigned int ioctl_cmd,
                    unsigned long ioctl_param)
{
    struct xioctl_request request;
    unsigned long request_size_left;
    long ret_val = 0;

    // Copy user request
    request_size_left = copy_from_user(&request, 
                        (struct xioctl_request *)ioctl_param,
                        sizeof(struct xioctl_request));
    if (request_size_left != 0)
    {
        // Partial copy
        xprintdbg(KERN_INFO "LIBIHT-LKM: Remaining size %ld\n", request_size_left);
        return -EIO;
    }

    // Process request
    if (request.cmd <= LIBIHT_IOCTL_LBR_END)
    {
        // LBR request
        xprintdbg(KERN_INFO "LIBIHT-LKM: LBR request\n");
        ret_val = lbr_ioctl_handler(&request);
    }
    else if (request.cmd <= LIBIHT_IOCTL_BTS_END)
    {
        // BTS request
        xprintdbg(KERN_INFO "LIBIHT-LKM: BTS request\n");
        ret_val = bts_ioctl_handler(&request);
    }
    else
    {
        // Unknown request
        xprintdbg(KERN_INFO "LIBIHT-LKM: Unknown request\n");
        ret_val = -EINVAL;
    }

    return ret_val;
}

//
// Module initialization and cleanup functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : libiht_lkm_init
// Description  : This function is the main entry point for the module. It will
//                initialize the driver and register all the required services.

//
// Inputs       : void
// Outputs      : int - status of the initialization. 0 if success, -1 if fail.

int __init libiht_lkm_init(void)
{
    xprintdbg(KERN_INFO "LIBIHT_LKM: Initializing...\n");

    // Create user interactive helper process
    xprintdbg(KERN_INFO "LIBIHT-LKM: Creating helper process...\n");
    proc_entry = proc_create(DEVICE_NAME, 0666, NULL, &libiht_ops);
    if (proc_entry == NULL) {
        xprintdbg(KERN_INFO "LIBIHT-LKM: Create proc failed\n");
        return -1;
    }

    // Register tracepoint hooks for context swtich and fork
    xprintdbg(KERN_INFO "LIBIHT_LKM: Registering tracepoints...\n");
    register_tracepoints();

    // Init LBR
    xprintdbg(KERN_INFO "LIBIHT_LKM: Initilizing LBR...\n");
    lbr_init();

    // Init BTS
    xprintdbg(KERN_INFO "LIBIHT_LKM: Initilizing BTS...\n");
    bts_init();

    xprintdbg(KERN_INFO "LIBIHT_LKM: Initilized\n");
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : libiht_lkm_exit
// Description  : This function is the main exit point for the module. It will
//                unregister all the registered services and clean up the
//                module.
//
// Inputs       : void
// Outputs      : void

void __exit libiht_lkm_exit(void)
{
    xprintdbg(KERN_INFO "LIBIHT_LKM: Exiting...\n");

    // Exit BTS
    xprintdbg(KERN_INFO "LIBIHT_LKM: Exiting BTS...\n");
    bts_exit();

    // Exit LBR
    xprintdbg(KERN_INFO "LIBIHT_LKM: Exiting LBR...\n");
    lbr_exit();

    // Unregister tracepoints
    xprintdbg(KERN_INFO "LIBIHT_LKM: Unregistering tracepoints...\n");
    unregister_tracepoints();

    // Remove the helper process if exist
    xprintdbg(KERN_INFO "LIBIHT_LKM: Removing helper process...\n");
    if (proc_entry != NULL)
        proc_remove(proc_entry);

    xprintdbg(KERN_INFO "LIBIHT_LKM: Exit complete\n");
}

module_init(libiht_lkm_init);
module_exit(libiht_lkm_exit);
```

`kernel/lkm/src/xplat_lkm.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : kernel/lkm/src/xplat_lkm.c
//  Description    : This is the cross-platform compatibility layer for the
//                   Linux kernel module.
//
//   Author        : Thomason Zhao
//   Last Modified : July 10, 2024
//

#include "../../commons/xplat.h"
#include "../include/headers_lkm.h"

//
// Cross-platform functions

//
// Memory management functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xmalloc
// Description  : Cross platform kernel malloc function. Allocate memory from
//                the kernel heap.
//
// Inputs       : size - size of the memory to be allocated.
// Outputs      : void * - pointer to the allocated memory.

void *xmalloc(u64 size)
{
    return kmalloc(size, GFP_KERNEL);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xfree
// Description  : Cross platform kernel free function. Free memory from the
//                kernel heap.
//
// Inputs       : ptr - pointer to the memory to be freed.
// Outputs      : void

void xfree(void *ptr)
{
    kfree(ptr);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcopy_from_user
// Description  : Cross platform kernel copy from user function. Copy memory
//                from user space to kernel space.
//
// Inputs       : dst - pointer to the destination memory.
//                src - pointer to the source memory.
//                cnt - size of the memory to be copied.
// Outputs      : u64 - number of bytes not copied (0 on success).

u64 xcopy_from_user(void *dst, void *src, u64 cnt)
{
    return copy_from_user(dst, src, cnt);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcopy_to_user
// Description  : Cross platform kernel copy to user function. Copy memory
//                from kernel space to user space.
//
// Inputs       : dst - pointer to the destination memory.
//                src - pointer to the source memory.
//                cnt - size of the memory to be copied.
// Outputs      : u64 - number of bytes not copied (0 on success).

u64 xcopy_to_user(void *dst, void *src, u64 cnt)
{
    return copy_to_user(dst, src, cnt);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xmemset
// Description  : Cross platform kernel memset function. Set memory to a
//                specific value.
//
// Inputs       : ptr - pointer to the memory to be set.
//                c   - value to be set.
//                cnt - size of the memory to be set.
// Outputs      : void * - pointer to the set memory.

void *xmemset(void *ptr, s32 c, u64 cnt)
{
    return memset(ptr, c, cnt);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xmemcpy
// Description  : Cross platform kernel memcpy function. Copy memory from one
//                location to another.
//
// Inputs       : dst - pointer to the destination memory.
//                src - pointer to the source memory.
//                cnt - size of the memory to be copied.
// Outputs      : void * - pointer to the destination memory.

void *xmemcpy(void *dst, void *src, u64 cnt)
{
    return memcpy(dst, src, cnt);
} 

//
// CPU core, hardware, register read/write functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlock_core
// Description  : Cross platform lock core function. Disable interrupts and
//                save the old IRQL.
//
// Inputs       : old_irql - pointer to the old IRQL.
// Outputs      : void

void xlock_core(void *old_irql)
{
    get_cpu();
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xrelease_core
// Description  : Cross platform unlock core function. Restore IRQL to
//                the new IRQL.
//
// Inputs       : new_irql - pointer to the new IRQL.
// Outputs      : void

void xrelease_core(void *new_irql)
{
    put_cpu();
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xwrmsr
// Description  : Cross platform write MSR function. Write a value to a MSR.
//
// Inputs       : msr - MSR to be written.
//                val - value to be written.
// Outputs      : void

void xwrmsr(u32 msr, u64 val)
{
    wrmsrl(msr, val);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xrdmsr
// Description  : Cross platform read MSR function. Read a value from a MSR.
//
// Inputs       : msr - MSR to be read.
//                val - pointer to the value to be read.
// Outputs      : void

void xrdmsr(u32 msr, u64 *val)
{
    rdmsrl(msr, *val);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcoreid
// Description  : Cross platform get core id function. Get the current core id.
//
// Inputs       : void
// Outputs      : u32 - current core id.

u32 xcoreid(void)
{
    return smp_processor_id();
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xgetcurrent_pid
// Description  : Cross platform get current pid function. Get the current pid.
//
// Inputs       : void
// Outputs      : u32 - current pid.

u32 xgetcurrent_pid(void)
{
    return current->pid;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xcpuid
// Description  : Cross platform cpuid function. Get the cpuid information.
//
// Inputs       : func_id - function id.
// Outputs      : void

void xcpuid(u32 func_id, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)
{
    cpuid(func_id, eax, ebx, ecx, edx);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xon_each_cpu
// Description  : Cross platform on each cpu function. Dispatch a function on
//                each cpu.
//
// Inputs       : func - function to be run.
// Outputs      : void

void xon_each_cpu(void (*func)(void))
{
    on_each_cpu((void *)(void *)func, NULL, 1);
}

//
// Lock functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xinit_lock
// Description  : Cross platform init lock function. Initialize a lock.
//
// Inputs       : lock - pointer to the lock to be initialized.
// Outputs      : void

void xinit_lock(void *lock)
{
    spin_lock_init((spinlock_t *)lock);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xacquire_lock
// Description  : Cross platform acquire lock function. Acquire a lock.
//
// Inputs       : lock - pointer to the lock to be acquired.
//                old_irql - pointer to the old IRQL.
// Outputs      : void

void xacquire_lock(void *lock, void *old_irql)
{
    spin_lock_irqsave((spinlock_t *)lock, *(unsigned long *)old_irql);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xrelease_lock
// Description  : Cross platform release lock function. Release a lock.
//
// Inputs       : lock - pointer to the lock to be released.
//                new_irql - pointer to the new IRQL.
// Outputs      : void

void xrelease_lock(void *lock, void *new_irql)
{
    spin_unlock_irqrestore((spinlock_t *)lock, *(unsigned long *)new_irql);
}

//
// List functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xinit_list_head
// Description  : Cross platform init list head function. Initialize a list
//                head.
//
// Inputs       : list - pointer to the list head to be initialized.
// Outputs      : void

void xinit_list_head(void *list)
{
    INIT_LIST_HEAD((struct list_head *)list);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_add
// Description  : Cross platform list add function. Add a new entry after the
//                specified head.
//
// Inputs       : new - pointer to the new entry.
//                head - pointer to the list head.
// Outputs      : void

void xlist_add(void *new_entry, void *head)
{
    list_add((struct list_head *)new_entry, (struct list_head *)head);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_del
// Description  : Cross platform list del function. Delete an entry from the
//                list.
//
// Inputs       : entry - pointer to the entry to be deleted.
// Outputs      : void

void xlist_del(void *entry)
{
    list_del((struct list_head *)entry);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_next
// Description  : Cross platform list next function. Get the next entry in the
//                list. (Need to manipulate the pointer to the entry manually)
//
// Inputs       : entry - pointer to the entry.
// Outputs      : void* - pointer to the next entry.

void *xlist_next(void *entry)
{
    return (void *)((struct list_head *)entry)->next;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xlist_prev
// Description  : Cross platform list prev function. Get the previous entry in
//                the list. (Need to manipulate the pointer to the entry 
//                manually)
//
// Inputs       : entry - pointer to the entry.
// Outputs      : void* - pointer to the previous entry.

void *xlist_prev(void *entry)
{
    return (void *)((struct list_head *)entry)->prev;
}

//
// Debug functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : xprintdbg
// Description  : Cross platform print debug function. Print debug information.
//
// Inputs       : format - format string.
// Outputs      : void

void xprintdbg(const char *format, ...)
{
    va_list args;
    va_start(args, format);
    vprintk(format, args);
    va_end(args);
}


```

`lib/commons/api.h`:

```h
#ifndef LIBIHT_API_H
#define LIBIHT_API_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/commons/api.h
//  Description    : This is the header file for user-space library APIs. It
//                   contains all the necessary header files for the library.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 10, 2024
//

//
// Global variables

unsigned int MAX_LBR_LIST_LEN = 0x20;
// The default maximum number of LBR entries is 32
// (may vary in different hardware)

unsigned int MAX_BTS_LIST_LEN = 0x400;
// The default maximum number of BTS entries is 1024
// (may vary by the user request)

//
// Library constants (copied from kernel/commons/xioctl.h)

enum IOCTL {
    LIBIHT_IOCTL_BASE,

    LIBIHT_IOCTL_ENABLE_LBR,
    LIBIHT_IOCTL_DISABLE_LBR,
    LIBIHT_IOCTL_DUMP_LBR,
    LIBIHT_IOCTL_CONFIG_LBR,
    LIBIHT_IOCTL_LBR_END,

    LIBIHT_IOCTL_ENABLE_BTS,
    LIBIHT_IOCTL_DISABLE_BTS,
    LIBIHT_IOCTL_DUMP_BTS,
    LIBIHT_IOCTL_CONFIG_BTS,
    LIBIHT_IOCTL_BTS_END,
};

struct lbr_stack_entry {
    unsigned long long from;
    unsigned long long to;
};

struct lbr_config {
    unsigned int pid;
    unsigned long long lbr_select;
};

struct lbr_data {
    unsigned long long lbr_tos;
    struct lbr_stack_entry* entries;
};

struct lbr_ioctl_request {
    struct lbr_config lbr_config;
    struct lbr_data* buffer;
};

struct bts_config {
    unsigned int pid;
    unsigned long long bts_config;
    unsigned long long bts_buffer_size;
};

struct bts_record {
    unsigned long long from;
    unsigned long long to;
    unsigned long long misc;
};

struct bts_data {
    struct bts_record* bts_buffer_base;
    struct bts_record* bts_index;
    unsigned long long bts_interrupt_threshold;
};

struct bts_ioctl_request {
    struct bts_config bts_config;
    struct bts_data* buffer;
};

struct xioctl_request {
    enum IOCTL cmd;
    union {
        struct lbr_ioctl_request lbr;
        struct bts_ioctl_request bts;
    }body;
};

// The above definitions are same as those in "types.h"
#endif // LIBIHT_API_H

```

`lib/demo/kmd-demo/kmd-demo.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34728.123
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kmd-demo", "kmd-demo\kmd-demo.vcxproj", "{956A5241-C397-4C19-AB24-FA7145818386}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{956A5241-C397-4C19-AB24-FA7145818386}.Debug|x64.ActiveCfg = Debug|x64
		{956A5241-C397-4C19-AB24-FA7145818386}.Debug|x64.Build.0 = Debug|x64
		{956A5241-C397-4C19-AB24-FA7145818386}.Debug|x86.ActiveCfg = Debug|Win32
		{956A5241-C397-4C19-AB24-FA7145818386}.Debug|x86.Build.0 = Debug|Win32
		{956A5241-C397-4C19-AB24-FA7145818386}.Release|x64.ActiveCfg = Release|x64
		{956A5241-C397-4C19-AB24-FA7145818386}.Release|x64.Build.0 = Release|x64
		{956A5241-C397-4C19-AB24-FA7145818386}.Release|x86.ActiveCfg = Release|Win32
		{956A5241-C397-4C19-AB24-FA7145818386}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {081ABA99-D735-4019-821B-59C2165A04BA}
	EndGlobalSection
EndGlobal

```

`lib/demo/kmd-demo/kmd-demo/kmd-demo.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/demo/kmd-demo/kmd-demo/kmd-demo.cpp
//  Description    : This is a simple demo for how to use LIBIHT KMD APIs to
//                   enable LBR and dump LBR for a user-space application.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 10, 2024
//

#include "../../commons/api.h"
#include "../../kmd/kmd/kmd.h"
#include <stdio.h>

#define ENABLE_LBR
// #define ENABLE_BTS

int cnt = 10;

void func1(void);
void func2(void);

void func1()
{
    //printf("func1: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func2();
    }
}

void func2()
{
    //printf("func2: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func1();
    }
}

int main() {
#ifdef ENABLE_LBR
    struct lbr_ioctl_request lbr_query = enable_lbr(0);
    cnt = 10;
    printf("%u %llu\n", lbr_query.lbr_config.pid, lbr_query.lbr_config.lbr_select);
    func1();
    dump_lbr(lbr_query);
    printf("%llu\n", lbr_query.buffer->lbr_tos);
    for (int i = 0; i < lbr_query.buffer->lbr_tos; i++) {
        printf("0x%llx 0x%llx; ", lbr_query.buffer->entries[i].from, lbr_query.buffer->entries[i].to);
    }
    printf("\n");
    disable_lbr(lbr_query);
#endif

#ifdef ENABLE_BTS
    struct bts_ioctl_request bts_query = enable_bts(0);
    cnt = 10;
    printf("%d %llu %llu\n", bts_query.bts_config.pid, bts_query.bts_config.bts_config, bts_query.bts_config.bts_buffer_size);
    func1();
    dump_bts(bts_query);
    int bts_tos = 32;
    printf("%d\n", bts_tos);
    for (int i = 0; i < bts_tos; i++) {
        printf("0x%llx 0x%llx %llu\n", bts_query.buffer->bts_buffer_base[i].from, bts_query.buffer->bts_buffer_base[i].to, bts_query.buffer->bts_buffer_base[i].misc);
    }
    printf("\n");
    disable_bts(bts_query);
#endif
    return 0;
}

```

`lib/demo/kmd-demo/kmd-demo/kmd-demo.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{956a5241-c397-4c19-ab24-fa7145818386}</ProjectGuid>
    <RootNamespace>kmddemo</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>C:\projects\libiht\lib\kmd\kmd;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>..\kmd\kmd\x64\$(IntDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>"C:\projects\libiht\lib\kmd\kmd\x64\Debug\kmd.lib";%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="kmd-demo.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`lib/demo/kmd-demo/kmd-demo/kmd-demo.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kmd-demo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`lib/demo/kmd-demo/kmd-demo/kmd-demo.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`lib/demo/lkm-demo/Makefile`:

```
CC = gcc
TARGET = lkm-demo
GDB_DEMO = gdb-demo
LBR_API = ../../lkm/src/liblbr_api.so

all:
		$(CC) -g -Wall -o $(TARGET) $(TARGET).c $(LBR_API)
		$(CC) -g -Wall -o $(GDB_DEMO) $(GDB_DEMO).c

clean:
		rm -f $(TARGET)
		rm -f $(GDB_DEMO)
```

`lib/demo/lkm-demo/gdb-demo.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/demo/lkm-demo/gdb-demo.c
//  Description    : This is a simple demo for how to use LIBIHT GDB plugin to
//                   assist debugging and tracing for a user-space application.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 10, 2024

#include <stdio.h>
#include <unistd.h>

int N = 10;
void func1();
void func2();

void func1() {
    if (N == 0) {
        return;
    }
    func2();
}

void func2() {
    N--;
    func1();
}

int main() {
    int pid = getpid();
    fprintf(stderr, "Current pid : %d\n", pid);
    func1();
    return 0;
}

```

`lib/demo/lkm-demo/lkm-demo.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/demo/lkm-demo/lkm-demo.c
//  Description    : This is a simple demo for how to use LIBIHT LKM APIs to
//                   enable LBR and dump LBR for a user-space application.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 16, 2024
//

#include "../../commons/api.h"
#include "../../lkm/include/lkm.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// #define ENAB LE_LBR
#define ENABLE_BTS

int cnt = 10;

void func1(void);
void func2(void);

void func1()
{
    //printf("func1: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func2();
    }
}

void func2()
{
    //printf("func2: %d\n", cnt);
    if (cnt != 0)
    {
        cnt--;
        func1();
    }
}

void print_usage()
{
    printf("Usage: lkm-demo [pid] [count]\n");
    printf("pid: the pid of the process want to trace, trace it self if it is 0\n");
    printf("count: the number of recursive function call\n");
    printf("Example: lkm-demo 0 10\n");
    fflush(stdout);
    exit(-1);
}

int main(int argc, char* argv[]){
    if (argc != 3)
        print_usage();

    int pid = atoi(argv[1]);
    if (pid == 0)
        pid = getpid();
    cnt = atoi(argv[2]);
    printf("pid: %d, count: %d\n", pid, cnt);
    printf("func1's ptr: %p\nfunc2's ptr: %p\n", &func1, &func2);
    fflush(stdout);
    sleep(1);

#ifdef ENABLE_LBR
    // Enable LBR
    struct lbr_ioctl_request query = enable_lbr(0);

    // Simulate critical logic
    func1();

    // Dump LBR
    dump_lbr(query);

    // Disable LBR
    disable_lbr(query);

    // Print LBR buffer
    printf("LBR TOS: %lld\n", query.buffer->lbr_tos);
    for (int i = 0; i < 32; i++)
    {
        printf("LBR[%d]: 0x%llx -> 0x%llx\n", i, query.buffer->entries[i].from, query.buffer->entries[i].to);
    }
#endif
#ifdef ENABLE_BTS
    // Enable BTS
    struct bts_ioctl_request query = enable_bts(0);

    // Simulate critical logic
    func1();

    // Dump BTS
    dump_bts(query);

    // Disable BTS
    disable_bts(query);
    // Print BTS buffer
    int bts_tos = 0;
    while (bts_tos < 1024 && (query.buffer->bts_buffer_base[bts_tos].from !=0 || query.buffer->bts_buffer_base[bts_tos].to != 0)) {
        bts_tos ++;
    }
    printf("BTS TOS: %d\n", bts_tos);
    for (int i = 0; i < bts_tos; i++) {
        printf("BTS[%d]: 0x%llx -> 0x%llx %llu\n", i, query.buffer->bts_buffer_base[i].from, query.buffer->bts_buffer_base[i].to, query.buffer->bts_buffer_base[i].misc);
    }
    printf("\n");
#endif
    return 0;
}

```

`lib/kmd/kmd-ext/Source.def`:

```def
EXPORTS
	EnableLBR
	DumpLBR
	DisableLBR
	EnableBTS
	DumpBTS
	DisableBTS
```

`lib/kmd/kmd-ext/dllmain.cpp`:

```cpp
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`lib/kmd/kmd-ext/framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // 从 Windows 头文件中排除极少使用的内容
// Windows 头文件
#include <windows.h>

```

`lib/kmd/kmd-ext/kmd-ext.cpp`:

```cpp
#include "pch.h"
#include "kmd-ext.h"
#include "kmd.h"

WINDBG_EXTENSION_APIS ExtensionApis;


////////////////////////////////////////////////////////////////////////////////
//
// Function   : DebugExtensionInitiaize
// Description: Initializes the debug extension.
//
// Inputs     : Version - Pointer to ULONG variable to store the debug extension version.
//              Flags   - Pointer to ULONG variable to store the debug extension flags.
// Outputs    : HRESULT - Indicates the result of the function.
extern "C" HRESULT CALLBACK
DebugExtensionInitiaize(PULONG Version, PULONG Flags) {
	*Version = DEBUG_EXTENSION_VERSION(EXT_MAJOR_VER, EXT_MINOR_VER);
	*Flags = 0;
	return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Function   : DebugExtensionNotify
// Description: Handles debug extension notifications.
//
// Inputs     : Notify   - The type of notification.
//              Argument - The additional argument for the notification.
// Outputs    : None.
extern "C" void CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument) {
	UNREFERENCED_PARAMETER(Argument);
	switch (Notify) {
	case DEBUG_NOTIFY_SESSION_ACTIVE:
		break;
	case DEBUG_NOTIFY_SESSION_INACTIVE:
		break;
	case DEBUG_NOTIFY_SESSION_ACCESSIBLE:
		break;
	case DEBUG_NOTIFY_SESSION_INACCESSIBLE:
		break;
	}
	return;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function   : DebugExtensionUninitialize
// Description: Uninitializes the debug extension.
//
// Inputs     : None.
// Outputs    : None.
extern "C" void CALLBACK
DebugExtensionUninitialize(void) {
	return;
}

struct lbr_ioctl_request lbr_req;
struct bts_ioctl_request bts_req;
bool lbr_enable = 0, bts_enable = 0;

////////////////////////////////////////////////////////////////////////////////
//
// Function   : EnableLBR
// Description: Enables Last Branch Recording (LBR) for a specified process.
//
// Inputs     : pid - Optional parameter indicating the process ID. Default value is 0.
// Outputs    : lbr_ioctl_request - A structure containing the LBR configuration.
extern "C" struct lbr_ioctl_request CALLBACK
EnableLBR(unsigned int pid = 0) {
	if (lbr_enable == 1) {
		return lbr_req;
	}
	lbr_enable = 1;
	lbr_req = enable_lbr(pid);
	dprintf("LIBIHT-WINDBG: enable lbr for pid : %d\n", lbr_req.lbr_config.pid);
	return lbr_req;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function   : DisableLBR
// Description: Disables Last Branch Recording (LBR) for the current process.
//
// Inputs     : None.
// Outputs    : None.
extern "C" void CALLBACK
DisableLBR() {
	if (lbr_enable == 0) {
		return;
	}
	lbr_enable = 0;
	disable_lbr(lbr_req);
	dprintf("LIBIHT-WINDBG: disable lbr for pid : %d\n", lbr_req.lbr_config.pid);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function   : DumpLBR
// Description: Dumps the Last Branch Record (LBR) information for the current process.
//
// Inputs     : None.
// Outputs    : None.
extern "C" void CALLBACK
DumpLBR() {
	if (lbr_enable == 0) {
		return;
	}
	dprintf("LIBIHT-WINDBG: dump lbr for pid : %d\n", lbr_req.lbr_config.pid);
	dump_lbr(lbr_req);
	unsigned long long lbr_tos = lbr_req.buffer->lbr_tos;
	for (int i = 0; i < (int)lbr_tos; i++) {
		dprintf("MSR_LBR_NHM_FROM[ %d ]: %llx\n", i, lbr_req.buffer->entries[i].from);
		dprintf("MSR_LBR_NHM_FROM[ %d ]: %llx\n", i, lbr_req.buffer->entries[i].to);
	}
}

////////////////////////////////////////////////////////////////////////////////
//
// Function   : EnableBTS
// Description: Enables Branch Trace Store (BTS) for a specified process.
//
// Inputs     : pid - Optional parameter indicating the process ID. Default value is 0.
// Outputs    : bts_ioctl_request - A structure containing the BTS configuration.
extern "C" struct bts_ioctl_request CALLBACK
EnableBTS(unsigned int pid = 0) {
	if (bts_enable == 1) {
		return bts_req;
	}
	bts_enable = 1;
	bts_req = enable_bts(pid);
	dprintf("LIBIHT-WINDBG: enable bts for pid : %d\n", bts_req.bts_config.pid);
	return bts_req;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function   : DisableBTS
// Description: Disables Branch Trace Store (BTS) for the current process.
//
// Inputs     : None.
// Outputs    : None.
extern "C" void CALLBACK
DisableBTS() {
	if (bts_enable == 0) {
		return;
	}
	bts_enable = 0;
	disable_bts(bts_req);
	dprintf("LIBIHT-WINDBG: disable bts for pid : %d\n", bts_req.bts_config.pid);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function   : DumpBTS
// Description: Dumps the Branch Trace Store (BTS) information for the current process.
//
// Inputs     : None.
// Outputs    : None.
extern "C" void CALLBACK
DumpBTS() {
	if (bts_enable == 0) {
		return;
	}
	dprintf("LIBIHT-WINDBG: dump lbr for pid : %d\n", bts_req.bts_config.pid);
	dump_bts(bts_req);
	int bts_tos = 32;
	dprintf("%d\n", bts_tos);
	for (int i = 0; i < bts_tos; i++) {
		dprintf("0x%llx 0x%llx %llu\n", bts_req.buffer->bts_buffer_base[i].from, bts_req.buffer->bts_buffer_base[i].to, bts_req.buffer->bts_buffer_base[i].misc);
	}
	dprintf("\n");
}

```

`lib/kmd/kmd-ext/kmd-ext.h`:

```h
#pragma once
#include <windows.h>
#include <dbgeng.h>
#include <wdbgexts.h>
#include <iostream>
#include <stdio.h>

#define EXT_MAJOR_VER 1
#define EXT_MINOR_VER 0
#pragma once

```

`lib/kmd/kmd-ext/kmd-ext.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34728.123
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kmd-ext", "kmd-ext.vcxproj", "{5C4B1993-1291-4BFD-A19E-2A9A23617221}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Debug|x64.ActiveCfg = Debug|x64
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Debug|x64.Build.0 = Debug|x64
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Debug|x86.ActiveCfg = Debug|Win32
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Debug|x86.Build.0 = Debug|Win32
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Release|x64.ActiveCfg = Release|x64
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Release|x64.Build.0 = Release|x64
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Release|x86.ActiveCfg = Release|Win32
		{5C4B1993-1291-4BFD-A19E-2A9A23617221}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4E1D7C08-3206-45CA-974B-38EBDDE7F88F}
	EndGlobalSection
EndGlobal

```

`lib/kmd/kmd-ext/kmd-ext.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{5c4b1993-1291-4bfd-a19e-2a9a23617221}</ProjectGuid>
    <RootNamespace>kmdext</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;KMDEXT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;KMDEXT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;KMDEXT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>..\kmd;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalLibraryDirectories>..\kmd\x64\Debug</AdditionalLibraryDirectories>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
      <AdditionalDependencies>..\kmd\x64\Debug\kmd.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;KMDEXT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>Source.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="framework.h" />
    <ClInclude Include="kmd-ext.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="kmd-ext.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`lib/kmd/kmd-ext/kmd-ext.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="kmd-ext.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="kmd-ext.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source.def">
      <Filter>源文件</Filter>
    </None>
  </ItemGroup>
</Project>
```

`lib/kmd/kmd-ext/kmd-ext.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`lib/kmd/kmd-ext/pch.cpp`:

```cpp
// pch.cpp: 与预编译标头对应的源文件

#include "pch.h"

// 当使用预编译的头时，需要使用此源文件，编译才能成功。

```

`lib/kmd/kmd-ext/pch.h`:

```h
// pch.h: 这是预编译标头文件。
// 下方列出的文件仅编译一次，提高了将来生成的生成性能。
// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。
// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。
// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。

#ifndef PCH_H
#define PCH_H

// 添加要在此处预编译的标头
#include "framework.h"

#endif //PCH_H

```

`lib/kmd/kmd/dllmain.cpp`:

```cpp
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`lib/kmd/kmd/framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // 从 Windows 头文件中排除极少使用的内容
// Windows 头文件
#include <windows.h>

```

`lib/kmd/kmd/kmd.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/kmd/kmd/kmd.cpp
//  Description    : This is the source file for the kernel module driver (KMD)
//                   APIs. It contains the implementation of the APIs.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 21, 2024
//

#include "pch.h" // use stdafx.h in Visual Studio 2017 and earlier
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include "kmd.h"

#define DEVICE_NAME                L"\\Device\\libiht-info"
#define SYM_DEVICE_NAME            L"\\DosDevices\\libiht-info"

#define KMD_IOCTL_TYPE 0x8888
#define KMD_IOCTL_FUNC 0x888

#define LIBIHT_KMD_IOCTL_BASE       CTL_CODE(KMD_IOCTL_TYPE, KMD_IOCTL_FUNC + 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

HANDLE lbr_hDevice;

struct xioctl_request lbr_send_request;

////////////////////////////////////////////////////////////////////////////////
//
// Function     : enable_lbr
// Description  : Enable the LBR feature for the requested process id.
//
// Inputs       : pid - the process identifier
// Outputs      : struct lbr_ioctl_request - the LBR configuration request 
struct lbr_ioctl_request enable_lbr(unsigned int pid) {
    struct lbr_ioctl_request usr_request;
    if (pid == 0) {
        usr_request.lbr_config.pid = GetCurrentProcessId();
    }
    else {
        usr_request.lbr_config.pid = pid;
    }
    usr_request.lbr_config.lbr_select = 0;

    fprintf(stderr, "LIBIHT-API: starting enable LBR on pid : %u\n", usr_request.lbr_config.pid);

    usr_request.buffer = (struct lbr_data*)malloc(sizeof(struct lbr_data));
    usr_request.buffer->lbr_tos = 0;
    usr_request.buffer->entries = (struct lbr_stack_entry*)malloc(sizeof(struct lbr_stack_entry) * MAX_LBR_LIST_LEN);

    lbr_hDevice = CreateFileA("\\\\.\\libiht-info", GENERIC_READ |
        GENERIC_WRITE, 0,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (lbr_hDevice == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "LIBIHT-API: failed to open device\n");
        return usr_request;
    }

    lbr_send_request.cmd = LIBIHT_IOCTL_ENABLE_LBR;
    lbr_send_request.body.lbr = usr_request;
    int res = DeviceIoControl(lbr_hDevice, LIBIHT_KMD_IOCTL_BASE, &lbr_send_request, sizeof(lbr_send_request), NULL, 0, NULL, NULL);

    if (res == 0) {
        fprintf(stderr, "LIBIHT-API: enable LBR for pid : %d\n", usr_request.lbr_config.pid);
    }
    else {
        fprintf(stderr, "LIBIHT-API: failed to enable LBR for pid : %d\n", usr_request.lbr_config.pid);
    }

    return usr_request;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : disable_lbr
// Description  : Disable the LBR feature for the specified process.
//
// Inputs       : usr_request - the LBR configuration request structure
// Outputs      : None
void disable_lbr(struct lbr_ioctl_request usr_request) {
    lbr_send_request.cmd = LIBIHT_IOCTL_DISABLE_LBR;
    lbr_send_request.body.lbr = usr_request;
    fprintf(stderr, "LIBIHT-API: disable LBR for pid : %d\n", usr_request.lbr_config.pid);
    DeviceIoControl(lbr_hDevice, LIBIHT_KMD_IOCTL_BASE, &lbr_send_request, sizeof(lbr_send_request), NULL, 0, NULL, NULL);
    CloseHandle(lbr_hDevice);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : dump_lbr
// Description  : Dump the Last Branch Recording (LBR) for the specified process.
//
// Inputs       : usr_request - the LBR configuration request structure
// Outputs      : None
void dump_lbr(struct lbr_ioctl_request usr_request) {
    lbr_send_request.cmd = LIBIHT_IOCTL_DUMP_LBR;
    lbr_send_request.body.lbr = usr_request;
    fprintf(stderr, "LIBIHT-API: dump LBR for pid : %d\n", usr_request.lbr_config.pid);
    DeviceIoControl(lbr_hDevice, LIBIHT_KMD_IOCTL_BASE, &lbr_send_request, sizeof(lbr_send_request), NULL, 0, NULL, NULL);
}


////////////////////////////////////////////////////////////////////////////////
//
// Function     : config_lbr
// Description  : Configure the LBR for the specified process.
//
// Inputs       : usr_request - the LBR configuration request structure
// Outputs      : None
void config_lbr(struct lbr_ioctl_request usr_request) {
    lbr_send_request.cmd = LIBIHT_IOCTL_CONFIG_LBR;
    lbr_send_request.body.lbr = usr_request;
    fprintf(stderr, "LIBIHT-API: select LBR for pid : %d\n", usr_request.lbr_config.pid);
    DeviceIoControl(lbr_hDevice, LIBIHT_KMD_IOCTL_BASE, &lbr_send_request, sizeof(lbr_send_request), NULL, 0, NULL, NULL);
}

HANDLE bts_hDevice;
struct xioctl_request bts_send_request;


////////////////////////////////////////////////////////////////////////////////
//
// Function     : enable_bts
// Description  : Enable the Branch Trace Store (BTS) for the specified process.
//
// Inputs       : pid - the process identifier
// Outputs      : struct bts_ioctl_request - the BTS configuration request structure
struct bts_ioctl_request enable_bts(unsigned int pid) {
    struct bts_ioctl_request usr_request;
    if (pid == 0) {
        usr_request.bts_config.pid = GetCurrentProcessId();
    }
    else {
        usr_request.bts_config.pid = pid;
    }

    fprintf(stderr, "LIBIHT-API: starting enable BTS on pid : %u\n", usr_request.bts_config.pid);

    usr_request.bts_config.bts_config = 0;
    usr_request.bts_config.bts_buffer_size = 0;
    usr_request.buffer = (struct bts_data*)malloc(sizeof(struct bts_data));
    usr_request.buffer->bts_buffer_base = (struct bts_record*)malloc(sizeof(struct bts_record) * MAX_BTS_LIST_LEN);
    usr_request.buffer->bts_index = (struct bts_record*)malloc(sizeof(struct bts_record) * MAX_BTS_LIST_LEN);

    bts_hDevice = CreateFileA("\\\\.\\libiht-info", GENERIC_READ |
        GENERIC_WRITE, 0,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (bts_hDevice == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "LIBIHT-API: failed to open device\n");
        return usr_request;
    }

    bts_send_request.body.bts = usr_request;
    bts_send_request.cmd = LIBIHT_IOCTL_ENABLE_BTS;
    int res = DeviceIoControl(bts_hDevice, LIBIHT_KMD_IOCTL_BASE, &bts_send_request, sizeof(bts_send_request), NULL, 0, NULL, NULL);

    if (res == 0) {
        fprintf(stderr, "LIBIHT-API: enable BTS for pid %u\n", usr_request.bts_config.pid);
    }
    else {
        fprintf(stderr, "LIBIHT-API: failed to enable BTS for pid %u\n", usr_request.bts_config.pid);
    }

    return usr_request;
}


////////////////////////////////////////////////////////////////////////////////
//
// Function     : disable_bts
// Description  : Disable the Branch Trace Store (BTS) for the specified process.
//
// Inputs       : usr_request - the BTS configuration request structure
// Outputs      : None
void disable_bts(struct bts_ioctl_request usr_request) {
    bts_send_request.cmd = LIBIHT_IOCTL_DISABLE_BTS;
    bts_send_request.body.bts = usr_request;
    fprintf(stderr, "LIBIHT-API: disable BTS for pid : %u\n", usr_request.bts_config.pid);
    DeviceIoControl(bts_hDevice, LIBIHT_KMD_IOCTL_BASE, &bts_send_request, sizeof(bts_send_request), NULL, 0, NULL, NULL);
    CloseHandle(bts_hDevice);
}


////////////////////////////////////////////////////////////////////////////////
//
// Function     : dump_bts
// Description  : Dump the Branch Trace Store (BTS) for the specified process.
//
// Inputs       : usr_request - the BTS configuration request structure
// Outputs      : None
void dump_bts(struct bts_ioctl_request usr_request) {
    bts_send_request.cmd = LIBIHT_IOCTL_DUMP_BTS;
    bts_send_request.body.bts = usr_request;
    fprintf(stderr, "LIBIHT-API: dump BTS for pid : %u\n", usr_request.bts_config.pid);
    DeviceIoControl(bts_hDevice, LIBIHT_KMD_IOCTL_BASE, &bts_send_request, sizeof(bts_send_request), NULL, 0, NULL, NULL);
}


////////////////////////////////////////////////////////////////////////////////
//
// Function     : config_bts
// Description  : Configure the Branch Trace Store (BTS) for the specified process.
//
// Inputs       : usr_request - the BTS configuration request structure
// Outputs      : None
void config_bts(struct bts_ioctl_request usr_request) {
    bts_send_request.cmd = LIBIHT_IOCTL_CONFIG_BTS;
    bts_send_request.body.bts = usr_request;
    fprintf(stderr, "LIBIHT-API: config BTS for pid : %u\n", usr_request.bts_config.pid);
    DeviceIoControl(bts_hDevice, LIBIHT_KMD_IOCTL_BASE, &bts_send_request, sizeof(bts_send_request), NULL, 0, NULL, NULL);
}
```

`lib/kmd/kmd/kmd.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/kmd/kmd/kmd.h
//  Description    : This is the header file for the Kernel Mode Driver (KMD)
//                   APIs. It contains all the necessary header files for KMD.
//                   Mainly the function prototypes for the APIs.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 10, 2024
//

#pragma once
#include "../../commons/api.h"
#ifdef KMD_EXPORTS
#define KMD_API __declspec(dllexport)
#else
#define KMD_API __declspec(dllimport)
#endif
#
extern "C" KMD_API struct lbr_ioctl_request enable_lbr(unsigned int pid);
extern "C" KMD_API void disable_lbr(struct lbr_ioctl_request usr_request);
extern "C" KMD_API void dump_lbr(struct lbr_ioctl_request usr_request);
extern "C" KMD_API void config_lbr(struct lbr_ioctl_request usr_request);

extern "C" KMD_API struct bts_ioctl_request enable_bts(unsigned int pid);
extern "C" KMD_API void disable_bts(struct bts_ioctl_request usr_request);
extern "C" KMD_API void dump_bts(struct bts_ioctl_request usr_request);
extern "C" KMD_API void config_bts(struct bts_ioctl_request usr_request);
```

`lib/kmd/kmd/kmd.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34728.123
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kmd", "kmd.vcxproj", "{1326E79F-0E5B-475C-AA4D-3B9412948C4B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Debug|x64.ActiveCfg = Debug|x64
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Debug|x64.Build.0 = Debug|x64
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Debug|x86.ActiveCfg = Debug|Win32
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Debug|x86.Build.0 = Debug|Win32
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Release|x64.ActiveCfg = Release|x64
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Release|x64.Build.0 = Release|x64
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Release|x86.ActiveCfg = Release|Win32
		{1326E79F-0E5B-475C-AA4D-3B9412948C4B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3C13037E-642C-48BB-BDE8-A4CCCC4312F1}
	EndGlobalSection
EndGlobal

```

`lib/kmd/kmd/kmd.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1326e79f-0e5b-475c-aa4d-3b9412948c4b}</ProjectGuid>
    <RootNamespace>kmd</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;KMD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;KMD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;KMD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;KMD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="framework.h" />
    <ClInclude Include="kmd.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="kmd.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`lib/kmd/kmd/kmd.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="kmd.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="kmd.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`lib/kmd/kmd/kmd.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`lib/kmd/kmd/pch.cpp`:

```cpp
// pch.cpp: 与预编译标头对应的源文件

#include "pch.h"

// 当使用预编译的头时，需要使用此源文件，编译才能成功。

```

`lib/kmd/kmd/pch.h`:

```h
// pch.h: 这是预编译标头文件。
// 下方列出的文件仅编译一次，提高了将来生成的生成性能。
// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。
// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。
// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。

#ifndef PCH_H
#define PCH_H

// 添加要在此处预编译的标头
#include "framework.h"

#endif //PCH_H

```

`lib/lkm/include/lkm.h`:

```h
#ifndef LIBIHT_LKM_H
#define LIBIHT_LKM_H

////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/lkm/include/lkm.h
//  Description    : This is the header file for the Linux kernel module (LKM)
//                   APIs. It contains all the necessary header files for LKM.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 10, 2024
//

#include "../../commons/api.h"

//
// Function prototypes

// TODO: Redefine the functions, current design is bad architected :(

// For LBR

struct lbr_ioctl_request enable_lbr(unsigned int pid);
// Enable LBR for a given process ID

void disable_lbr(struct lbr_ioctl_request usr_request);
// Disable LBR for a user request

void dump_lbr(struct lbr_ioctl_request usr_request);
// Dump LBR for a user request

void config_lbr(struct lbr_ioctl_request usr_request);
// Configure LBR for a user request

// For BTS

struct bts_ioctl_request enable_bts(unsigned int pid);
// Enable BTS for a given process ID

void disable_bts(struct bts_ioctl_request usr_request);
// Disable BTS for a user request

void dump_bts(struct bts_ioctl_request usr_request);
// Dump BTS for a user request

void config_bts(struct bts_ioctl_request usr_request);
// Configure BTS for a user request

#endif // LIBIHT_LKM_H
```

`lib/lkm/src/Makefile`:

```
LIB_NAME = liblbr_api.so
SRC_FILES = api.c
CFLAGS = -fPIC

all:
	gcc $(CFLAGS) -shared -o $(LIB_NAME) $(SRC_FILES)

clean:
	rm -f $(LIB_NAME)
```

`lib/lkm/src/api.c`:

```c
////////////////////////////////////////////////////////////////////////////////
//
//  File           : lib/lkm/src/api.c
//  Description    : This is the source code for the Linux kernel module (LKM)
//                   APIs. It contains the implementation of the APIs.
//
//   Author        : Di Wu, Thomason Zhao
//   Last Modified : July 10, 2024
//

// TODO: Refactor the code, current design is bad architected :(

#include "../../commons/api.h"
#include "../include/lkm.h"
#include <sys/ioctl.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

#define DEVICE_NAME "libiht-info"

#define LIBIHT_LKM_IOCTL_MAGIC 'l'
#define LIBIHT_LKM_IOCTL_BASE       _IO(LIBIHT_LKM_IOCTL_MAGIC, 0)

//
// Global Variables

int lbr_fd;
// File descriptor for opened LBR

struct xioctl_request lbr_send_request;
// Request for sending to LBR

int bts_fd;
// File descriptor for opened BTS

struct xioctl_request bts_send_request;
// Request for sending to BTS


//
// LBR management functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : enable_lbr
// Description  : Enable LBR for a given process ID
//
// Inputs       : unsigned int pid : the process ID
// Outputs      : struct lbr_ioctl_request : the request for LBR

struct lbr_ioctl_request enable_lbr(unsigned int pid) {
    struct lbr_ioctl_request usr_request;
    if (pid == 0) {
        usr_request.lbr_config.pid = getpid();
    }
    else {
        usr_request.lbr_config.pid = pid;
    }

    fprintf(stderr, "LIBIHT-API: starting enable LBR on pid : %u\n", usr_request.lbr_config.pid);

    usr_request.lbr_config.lbr_select = 0;

    usr_request.buffer = NULL;

    usr_request.buffer = malloc(sizeof(struct lbr_data));
    usr_request.buffer->lbr_tos = 0;
    usr_request.buffer->entries = malloc(sizeof(struct lbr_stack_entry) * MAX_LBR_LIST_LEN);

    lbr_fd = open("/proc/" DEVICE_NAME, O_RDWR);

    lbr_send_request.cmd = LIBIHT_IOCTL_ENABLE_LBR;
    lbr_send_request.body.lbr = usr_request;
    int res = ioctl(lbr_fd, LIBIHT_LKM_IOCTL_BASE, &lbr_send_request);

    if (res == 0) {
        fprintf(stderr, "LIBIHT-API: enable LBR for pid %u\n", usr_request.lbr_config.pid);
    }
    else {
        fprintf(stderr, "LIBIHT-API: failed to enable LBR for pid %u\n", usr_request.lbr_config.pid);
    }

    return usr_request;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : disable_lbr
// Description  : Disable LBR for a user request
//
// Inputs       : struct lbr_ioctl_request usr_request : the request for LBR
// Outputs      : void

void disable_lbr(struct lbr_ioctl_request usr_request) {
    lbr_send_request.cmd = LIBIHT_IOCTL_DISABLE_LBR;
    lbr_send_request.body.lbr = usr_request;
    ioctl(lbr_fd, LIBIHT_LKM_IOCTL_BASE, &lbr_send_request);
    fprintf(stderr, "LIBIHT-API: disable LBR for pid %u\n", usr_request.lbr_config.pid);
    lbr_fd = 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : dump_lbr
// Description  : Dump LBR for a user request
//
// Inputs       : struct lbr_ioctl_request usr_request : the request for LBR
// Outputs      : void

void dump_lbr(struct lbr_ioctl_request usr_request) {
    lbr_send_request.cmd = LIBIHT_IOCTL_DUMP_LBR;
    lbr_send_request.body.lbr = usr_request;
    ioctl(lbr_fd, LIBIHT_LKM_IOCTL_BASE, &lbr_send_request);
    fprintf(stderr, "LIBIHT-API: dump LBR for pid %u\n", usr_request.lbr_config.pid);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : config_lbr
// Description  : Configure LBR for a user request
//
// Inputs       : struct lbr_ioctl_request usr_request : the request for LBR
// Outputs      : void

void config_lbr(struct lbr_ioctl_request usr_request) {
    lbr_send_request.cmd = LIBIHT_IOCTL_CONFIG_LBR;
    lbr_send_request.body.lbr = usr_request;
    ioctl(lbr_fd, LIBIHT_LKM_IOCTL_BASE, &lbr_send_request);
    fprintf(stderr, "LIBIHT-API: config LBR for pid %u\n", usr_request.lbr_config.pid);
}

//
// BTS management functions

////////////////////////////////////////////////////////////////////////////////
//
// Function     : enable_bts
// Description  : Enable BTS for a given process ID
//
// Inputs       : unsigned int pid : the process ID
// Outputs      : struct bts_ioctl_request : the request for BTS

struct bts_ioctl_request enable_bts(unsigned int pid) {
    struct bts_ioctl_request usr_request;
    if (pid == 0) {
        usr_request.bts_config.pid = getpid();
    }
    else {
        usr_request.bts_config.pid = pid;
    }

    fprintf(stderr, "LIBIHT-API: starting enable BTS on pid : %u\n", usr_request.bts_config.pid);

    usr_request.bts_config.bts_config = 0;
    usr_request.bts_config.bts_buffer_size = 0;
    usr_request.buffer = malloc(sizeof(struct bts_data));
    usr_request.buffer->bts_buffer_base = malloc(sizeof(struct bts_record) * MAX_BTS_LIST_LEN);
    usr_request.buffer->bts_index = malloc(sizeof(struct bts_record) * MAX_BTS_LIST_LEN);

    bts_fd = open("/proc/" DEVICE_NAME, O_RDWR);

    bts_send_request.body.bts = usr_request;
    bts_send_request.cmd = LIBIHT_IOCTL_ENABLE_BTS;
    int res = ioctl(bts_fd, LIBIHT_LKM_IOCTL_BASE, &bts_send_request);

    if (res == 0) {
        fprintf(stderr, "LIBIHT-API: enable BTS for pid %u\n", usr_request.bts_config.pid);
    }
    else {
        fprintf(stderr, "LIBIHT-API: failed to enable BTS for pid %u\n", usr_request.bts_config.pid);
    }

    return usr_request;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : disable_bts
// Description  : Disable BTS for a user request
//
// Inputs       : struct bts_ioctl_request usr_request : the request for BTS
// Outputs      : void

void disable_bts(struct bts_ioctl_request usr_request) {
    bts_send_request.cmd = LIBIHT_IOCTL_DISABLE_BTS;
    bts_send_request.body.bts = usr_request;
    ioctl(bts_fd, LIBIHT_LKM_IOCTL_BASE, &bts_send_request);
    fprintf(stderr, "LIBIHT-API: disable BTS for pid : %u\n", usr_request.bts_config.pid);
    bts_fd = 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : dump_bts
// Description  : Dump BTS for a user request
//
// Inputs       : struct bts_ioctl_request usr_request : the request for BTS
// Outputs      : void

void dump_bts(struct bts_ioctl_request usr_request) {
    bts_send_request.cmd = LIBIHT_IOCTL_DUMP_BTS;
    bts_send_request.body.bts = usr_request;
    ioctl(bts_fd, LIBIHT_LKM_IOCTL_BASE, &bts_send_request);
    fprintf(stderr, "LIBIHT-API: dump BTS for pid : %u\n", usr_request.bts_config.pid);
}

////////////////////////////////////////////////////////////////////////////////
//
// Function     : config_bts
// Description  : Configure BTS for a user request
//
// Inputs       : struct bts_ioctl_request usr_request : the request for BTS
// Outputs      : void

void config_bts(struct bts_ioctl_request usr_request) {
    bts_send_request.cmd = LIBIHT_IOCTL_CONFIG_BTS;
    bts_send_request.body.bts = usr_request;
    ioctl(bts_fd, LIBIHT_LKM_IOCTL_BASE, &bts_send_request);
    fprintf(stderr, "LIBIHT-API: config BTS for pid : %u\n", usr_request.bts_config.pid);
}

```

`lib/lkm/src/libiht-gdb.py`:

```py
##############################################################################
#
#  File           : lib/lkm/src/libiht-gdb.py
#  Description    : This is the source code for the GDB Plugin.
#                   It contains the implementation of the Plugin.
#
#   Author        : Di Wu, Thomason Zhao
#   Last Modified : July 16, 2024
#


import os
import gdb
import ctypes

# quote the ctypes

class Clbr_stack_entry(ctypes.Structure):
    _fields_ = [
        ('from_', ctypes.c_ulonglong),
        ('to', ctypes.c_ulonglong)
    ]
    def __init__(self, from_, to):
        self.from_ = from_
        self.to = to

class Clbr_config(ctypes.Structure):
    _fields_ = [
        ('pid', ctypes.c_uint),
        ('lbr_select', ctypes.c_ulonglong)
    ]
    def __init__(self, pid, lbr_select):
        self.pid = pid
        self.lbr_select = lbr_select

class Clbr_data(ctypes.Structure):
    _fields_ = [
        ('lbr_tos', ctypes.c_ulonglong),
        ('entries', ctypes.POINTER(Clbr_stack_entry))
    ]
    def __init__(self, lbr_tos, entries):
        self.lbr_tos = lbr_tos
        self.entries = entries

class Clbr_ioctl_request(ctypes.Structure):
    _fields_ = [
        ('lbr_config', Clbr_config),
        ('buffer', ctypes.POINTER(Clbr_data))
    ]
    def __init__(self, lbr_config, buffer):
        self.lbr_config = lbr_config
        self.buffer = buffer

class Cbts_config(ctypes.Structure):
    _fields_ = [
        ('pid', ctypes.c_uint),
        ('bts_config', ctypes.c_ulonglong),
        ('bts_buffer_size', ctypes.c_ulonglong)
    ]
    def __init__(self, pid, bts_config, bts_buffer):
        self.pid = pid
        self.bts_config = bts_config
        self.bts_buffer = bts_buffer

class Cbts_record(ctypes.Structure):
    _fields_ = [
        ('from_', ctypes.c_ulonglong),
        ('to', ctypes.c_ulonglong),
        ('misc', ctypes.c_ulonglong)
    ]
    def __init__(self, from_, to, misc):
        self.from_ = from_
        self.to = to
        self.misc = misc

class Cbts_data(ctypes.Structure):
    _fields_ = [
        ('bts_buffer_base', ctypes.POINTER(Cbts_record)),
        ('bts_index', ctypes.POINTER(Cbts_record)),
        ('bts_interrupt_threshold', ctypes.c_ulonglong)
    ]
    def __init__(self, bts_buffer_base, bts_index, bts_interrupt_threshold):
        self.bts_buffer_base = bts_buffer_base
        self.bts_index = bts_index
        self.bts_interrupt_threshold = bts_interrupt_threshold

class Cbts_ioctl_request(ctypes.Structure):
    _fields_ = [
        ('bts_config', Cbts_config),
        ('bts_data', ctypes.POINTER(Cbts_data))
    ]
    def __init__(self, bts_config, bts_data):
        self.bts_config = bts_config
        self.bts_data = bts_data

# declare the return value
class LBRContent:
    def __init__(self, from_, to):
        self.from_ = from_
        self.to = to

class BTSContent:
    def __init__(self, from_, to, misc):
        self.from_ = from_
        self.to = to
        self.misc = misc

# import the dynamic link

script_dir = os.path.dirname(os.path.abspath(__file__))
lib_path = os.path.join(script_dir, "liblbr_api.so")
my_lib = ctypes.CDLL(lib_path)

# get the funcions and define the arguments

enable_lbr = my_lib.enable_lbr
disable_lbr = my_lib.disable_lbr
dump_lbr = my_lib.dump_lbr
config_lbr = my_lib.config_lbr
enable_bts = my_lib.enable_bts
disable_bts = my_lib.disable_bts
dump_bts = my_lib.dump_bts
config_bts = my_lib.config_bts

enable_lbr.restype = Clbr_ioctl_request
enable_bts.restype = Cbts_ioctl_request

enable_lbr.argtypes = [ctypes.c_uint]
disable_lbr.argtypes = [Clbr_ioctl_request]
dump_lbr.argtypes = [Clbr_ioctl_request]
config_lbr.argtypes = [Clbr_ioctl_request]
enable_bts.argtypes = [ctypes.c_uint]
disable_bts.argtypes = [Cbts_ioctl_request]
dump_bts.argtypes = [Cbts_ioctl_request]
config_bts.argtypes = [Cbts_ioctl_request]

lbr_req = None
lbr_enable = False
bts_req = None
bts_enable = False

def get_function_name(address):
    symbol_output = gdb.execute("info symbol " + str(address), to_string=True)
    lines = symbol_output.splitlines()
    if len(lines) > 1:
        function_name = lines[1]
        function_name = function_name.split(' ', 1)[1]
        return function_name
    return address

def get_gdb_pid():
    inferior = gdb.selected_inferior()
    if inferior is not None:
        return inferior.pid
    return None

class EnableLBR(gdb.Command):
    def __init__(self):
        super(EnableLBR, self).__init__("enable_lbr", gdb.COMMAND_USER)

    def invoke(self, args, from_tty):
        global lbr_req, lbr_enable
        process_pid = get_gdb_pid()
        lbr_req = enable_lbr(process_pid)
        lbr_enable = True
        print("LIBIHT-GDB: enable lbr for pid :", lbr_req.lbr_config.pid)

class DisableLBR(gdb.Command):
    def __init__(self):
        super(DisableLBR, self).__init__("disable_lbr", gdb.COMMAND_USER)

    def invoke(self, args, from_tty):
        global lbr_req, lbr_enable
        disable_lbr(lbr_req)
        lbr_enable = False
        print("LIBIHT-GDB: disable lbr for pid :", lbr_req.lbr_config.pid)

class DumpLBR(gdb.Command):
    def __init__(self):
        super(DumpLBR, self).__init__("dump_lbr", gdb.COMMAND_USER)
    
    def invoke(self, args, from_tty):
        global lbr_req
        print("LIBIHT-GDB: dump lbr for pid :", lbr_req.lbr_config.pid)
        dump_lbr(lbr_req)
        lbr_tos = lbr_req.buffer.contents.lbr_tos
        data_pointer = ctypes.cast(lbr_req.buffer.contents.entries, ctypes.POINTER(Clbr_stack_entry))

        lbr_content = []
        for i in range(lbr_tos + 1, 32):
            lbr_content.append(LBRContent(data_pointer[i].from_, data_pointer[i].to))
        for i in range(lbr_tos + 1):
            lbr_content.append(LBRContent(data_pointer[i].from_, data_pointer[i].to))

        # Print the LBR content from the oldest to the newest 
        # PS: (not the order in the LBR stack)
        print(lbr_tos)
        lbr_content = lbr_content[::-1]
        for i in reversed(range(len(lbr_content))):
            print("Last [", i, "] branch record:")
            print("\t From: ", get_function_name(hex(lbr_content[i].from_)))
            print("\t To  : ", get_function_name(hex(lbr_content[i].to)))
        return lbr_content

class EnableBTS(gdb.Command):
    def __init__(self):
        super(EnableBTS, self).__init__("enable_bts", gdb.COMMAND_USER)

    def invoke(self, args, from_tty):
        global bts_req, bts_enable
        process_pid = get_gdb_pid()
        bts_req = enable_bts(process_pid)
        bts_enable = True
        print("LIBIHT-GDB: enable bts for pid :", bts_req.bts_config.pid)

class DisableBTS(gdb.Command):
    def __init__(self):
        super(DisableBTS, self).__init__("disable_bts", gdb.COMMAND_USER)

    def invoke(self, args, from_tty):
        global bts_req, bts_enable
        disable_bts(bts_req)
        bts_enable = False
        print("LIBIHT-GDB: disable bts for pid :", bts_req.bts_config.pid)

class DumpBTS(gdb.Command):
    def __init__(self):
        super(DumpBTS, self).__init__("dump_bts", gdb.COMMAND_USER)
    
    def invoke(self, args, from_tty):
        global bts_req
        print("LIBIHT-GDB: dump bts for pid :", bts_req.bts_config.pid)
        dump_bts(bts_req)
        data_pointer = ctypes.cast(bts_req.bts_data.contents.bts_buffer_base, ctypes.POINTER(Cbts_record))

        bts_content = []
        for i in range(1024):
            if data_pointer[i].from_ !=0 or data_pointer[i].to != 0:
                bts_content.append(BTSContent(data_pointer[i].from_, data_pointer[i].to, data_pointer[i].misc))

        bts_tos=len(bts_content)
        print (bts_tos)
        print ("BTS Information:")
        for i in range(bts_tos):
            print("Last [", i, "] branch record:")
            print("\t From: ", get_function_name(hex(bts_content[i].from_)))
            print("\t To  : ", get_function_name(hex(bts_content[i].to)))
            print("\t Misc: ", hex(bts_content[i].misc))
        return bts_content



EnableLBR()
DisableLBR()
DumpLBR()
EnableBTS()
DisableBTS()
DumpBTS()
```