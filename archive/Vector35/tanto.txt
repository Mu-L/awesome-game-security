Project Path: arc_Vector35_tanto_f6ifotse

Source Tree:

```txt
arc_Vector35_tanto_f6ifotse
├── A Slice of Modern Program Analysis - Insomni'hack 2025.pdf
├── LICENSE.txt
├── README.md
├── __init__.py
├── helpers.py
├── menus.py
├── plugin.json
├── slice_types
│   ├── __init__.py
│   ├── basic_block_slice.py
│   ├── butterfly_slice.py
│   ├── dynamic_call_graph.py
│   ├── full_call_graph.py
│   ├── scatter_slice.py
│   ├── source_to_sink.py
│   └── variable_slice.py
├── slices.py
├── tanto_preview.png
└── tanto_view.py

```

`LICENSE.txt`:

```txt
Copyright (c) 2021-2025 Vector 35 Inc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
```

`README.md`:

```md
# Tantō
Author: **Vector 35, Inc.**

## Description:
Tantō is a plugin for [Binary Ninja](https://binary.ninja/) that slices programs so you can understand them faster.

![slices](https://github.com/Vector35/tanto/blob/master/tanto_preview.png?raw=true)

For a more detailed explanation of what Tantō does, please check out [this blog post](https://binary.ninja/2022/06/20/introducing-tanto.html).

## Minimum Version

This plugin requires the following minimum version of Binary Ninja:

* 4.0.5336

## License

This plugin has been released under the [MIT license](./LICENSE.txt).

## Metadata Version

2

## Insomni'Hack 2025 Slides

[Here are the slides](./A%20Slice%20of%20Modern%20Program%20Analysis%20-%20Insomni%27hack%202025.pdf) for the talk [@ElykDeer](https://github.com/ElykDeer) gave at Insomni'Hack 2025: ["A Slice of" Modern Program Analysis](https://www.youtube.com/watch?v=I0PoE0IdtmE)

## Original Blog Post / Documentation

[Here's the original blog post](https://binary.ninja/2022/06/20/introducing-tanto.html) announcing Tanto and explaining how to use the original two slice types, Variable Slices and Basic Block Slices.

```

`__init__.py`:

```py
# Copyright(c) 2022-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto

from .tanto_view import *
from .slices import *
from .menus import *
from .helpers import *
from .slice_types import *

from binaryninja import Settings
from binaryninjaui import ViewType

Settings().register_group("tanto", "Tanto Settings")
ViewType.registerViewType(tanto.tanto_view.TantoViewType())

```

`helpers.py`:

```py
# Copyright(c) 2022-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from binaryninjaui import UIContext

from binaryninja import BinaryView
from binaryninja import Function, LowLevelILFunction, MediumLevelILFunction, HighLevelILFunction
from binaryninja import BasicBlock, LowLevelILBasicBlock, MediumLevelILBasicBlock, HighLevelILBasicBlock
from binaryninja import LowLevelILInstruction, MediumLevelILInstruction, HighLevelILInstruction
from binaryninja.log import log_error
from binaryninja.enums import FunctionGraphType

from typing import Union, Optional


BN_INVALID_EXPR = 0xffffffffffffffff

AnyFunction = Union[Function, LowLevelILFunction, MediumLevelILFunction, HighLevelILFunction]
ILFunction = Union[LowLevelILFunction, MediumLevelILFunction, HighLevelILFunction]
AnyBasicBlock = Union[BasicBlock, LowLevelILBasicBlock, MediumLevelILBasicBlock, HighLevelILBasicBlock]
ILBasicBlock = Union[LowLevelILBasicBlock, MediumLevelILBasicBlock, HighLevelILBasicBlock]
ILInstruction = Union[LowLevelILInstruction, MediumLevelILInstruction, HighLevelILInstruction]


def get_disassembly_settings():
  view_context = UIContext.activeContext()
  view = view_context.getCurrentView().widget()
  return view.getDisassemblySettings()


def get_insts(bb: BasicBlock) -> list[str]:  # TODO Results are not str...
  if bb is None:
    return None
  if isinstance(bb, BasicBlock):
    return bb.disassembly_text
  else:
    return bb


def get_basic_block_of_type(instr: LowLevelILInstruction, il_form: FunctionGraphType) -> Optional[AnyBasicBlock]:
  assert isinstance(il_form, FunctionGraphType)
  if il_form == FunctionGraphType.NormalFunctionGraph:
    return instr.il_basic_block.source_block
  elif il_form == FunctionGraphType.LiftedILFunctionGraph:
    return instr.function.source_function.get_lifted_il_at(instr.address).il_basic_block  # Seemingly bugged
  elif il_form == FunctionGraphType.LowLevelILFunctionGraph:
    return instr.il_basic_block
  elif il_form == FunctionGraphType.LowLevelILSSAFormFunctionGraph:
    return instr.ssa_form.il_basic_block
  elif il_form == FunctionGraphType.MappedMediumLevelILFunctionGraph:
    return instr.mapped_medium_level_il.il_basic_block
  elif il_form == FunctionGraphType.MappedMediumLevelILSSAFormFunctionGraph:
    return instr.mapped_medium_level_il.ssa_form.il_basic_block
  elif il_form == FunctionGraphType.MediumLevelILFunctionGraph:
    return instr.mlil.il_basic_block
  elif il_form == FunctionGraphType.MediumLevelILSSAFormFunctionGraph:
    return instr.mlil.ssa_form.il_basic_block
  elif il_form == FunctionGraphType.HighLevelILFunctionGraph:
    return instr.hlil.il_basic_block
  elif il_form == FunctionGraphType.HighLevelILSSAFormFunctionGraph:
    return instr.hlil.ssa_form.il_basic_block
  elif il_form == FunctionGraphType.InvalidILViewType:
    return None
  else:
    log_error(f"IL form {il_form.name} not supported in Tanto")
    return None


def get_function_of_type(func: Function, il_form: FunctionGraphType) -> Optional[AnyFunction]:
  assert isinstance(il_form, FunctionGraphType)
  if il_form == FunctionGraphType.NormalFunctionGraph:
    return func
  elif il_form == FunctionGraphType.LowLevelILFunctionGraph:
    return func.llil
  elif il_form == FunctionGraphType.LiftedILFunctionGraph:
    return func.lifted_il
  elif il_form == FunctionGraphType.LowLevelILSSAFormFunctionGraph:
    return func.llil.ssa_form
  elif il_form == FunctionGraphType.MediumLevelILFunctionGraph:
    return func.mlil
  elif il_form == FunctionGraphType.MediumLevelILSSAFormFunctionGraph:
    return func.mlil.ssa_form
  elif il_form == FunctionGraphType.MappedMediumLevelILFunctionGraph:
    return func.llil.mapped_medium_level_il
  elif il_form == FunctionGraphType.MappedMediumLevelILSSAFormFunctionGraph:
    return func.llil.mapped_medium_level_il.ssa_form
  elif il_form == FunctionGraphType.HighLevelILFunctionGraph:
    return func.hlil
  elif il_form == FunctionGraphType.HighLevelILSSAFormFunctionGraph:
    return func.hlil.ssa_form
  elif il_form == FunctionGraphType.InvalidILViewType:
    return None
  else:
    log_error(f"IL form {il_form.name} not supported in Tanto")
    return None


def get_current_binary_view() -> Optional[BinaryView]:
  view_context = UIContext.activeContext()
  if view_context is None or view_context.getCurrentView() is None:
    return

  return view_context.getCurrentView().getData()


def get_current_source_function() -> Optional[Function]:
  view_context = UIContext.activeContext()
  if view_context is None or view_context.getCurrentView() is None:
    return

  if (function := view_context.getCurrentView().getCurrentFunction()) is not None:
    return function

  if (addr := get_current_address()) is not None and (bv := get_current_binary_view()) is not None and len(functions := bv.get_functions_containing(addr)) > 0:
    return functions[0]


def get_current_il_function() -> Optional[AnyFunction]:
  view_context = UIContext.activeContext()
  if view_context is None or view_context.getCurrentViewFrame() is None:
    return None
  if (function := view_context.getCurrentView().getCurrentFunction()) is None:
    return None

  return get_function_of_type(function, view_context.getCurrentViewFrame().getViewLocation().getILViewType().view_type)


def get_current_il_basic_block() -> Optional[BasicBlock]:
  func = get_current_il_function()
  addr = get_current_address()

  if func is None or addr is None or addr == 0:
    # log_error(f"Could not find function for location {hex(addr)}, {func}")
    return

  if isinstance(func, Function):
    llil = func.get_low_level_il_at(addr)
    bb = llil.il_basic_block.source_block
  else:
    llil = func.source_function.get_low_level_il_at(addr)
    bb = None
  if llil is not None and bb is None:
    try:
      bb = get_basic_block_of_type(llil, func.il_form)
    except:
      # Fail silently because this most often happens at points where the user isn't trying to perform the action (switching tabs, etc)
      return

  if llil is None or bb is None:
    log_error("Couldn't recover basic block. Please try again.")
    return

  return bb


def get_selected_inst() -> ILInstruction:
  view_context = UIContext.activeContext()
  if view_context is not None and view_context.getCurrentView() is not None:
    if (instr_index := view_context.getCurrentView().getCurrentILInstructionIndex()) != BN_INVALID_EXPR:
      if (func := get_current_il_function()) is not None:
        return func[instr_index]


def get_selected_expr() -> ILInstruction:
  def traverser(inst, text):
    if text in str(inst):
      return inst

  expr = None
  view_context = UIContext.activeContext()
  if view_context is not None and view_context.getCurrentView() is not None and (hts := view_context.getCurrentView().getHighlightTokenState()) is not None and hts.valid:
    if (inst := get_selected_inst()) is not None:
      for expr in inst.traverse(traverser, hts.token.text):
        pass
  if expr is not None:
    return expr
  return get_selected_inst()


def instruction_contains_var(var_list, inst):
  for var in var_list:
    if inst.function.il_form in [FunctionGraphType.LowLevelILSSAFormFunctionGraph, FunctionGraphType.MediumLevelILSSAFormFunctionGraph, FunctionGraphType.MappedMediumLevelILSSAFormFunctionGraph, FunctionGraphType.HighLevelILSSAFormFunctionGraph]:
      for i in inst.function.get_ssa_var_uses(var) + [inst.function.get_ssa_var_definition(var)]:
        if inst.instr_index == i.instr_index:
          return True
    else:
      for i in inst.function.get_var_uses(var) + inst.function.get_var_definitions(var):
        if inst.instr_index == i.instr_index:
          return True
  return False


def get_current_address() -> Optional[int]:
  view_context = UIContext.activeContext()
  if view_context is None or view_context.getCurrentView() is None:
    return

  return view_context.getCurrentView().getCurrentOffset()

```

`menus.py`:

```py
# Copyright(c) 2022-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto

from binaryninjaui import Menu, ContextMenuManager, ClickableIcon, UIActionHandler, ViewPaneHeaderSubtypeWidget, UIAction, MenuHelper
from PySide6.QtGui import QImage, QKeySequence
from PySide6.QtCore import QSize
from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout

NEW_SLICE_TEXT = "Create New Slice..."


class OptionsWidget(QWidget):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    super().__init__(parent)
    self.actionHandler = UIActionHandler()
    self.actionHandler.setupActionHandler(self)
    self.contextMenuManager = ContextMenuManager(self)

    self.menu = Menu()
    self.parent = parent

    UIAction.registerAction("Rename Slice")
    self.actionHandler.bindAction("Rename Slice", UIAction(
      lambda context: self.parent.rename_slice(SliceMenu.refresh),
      lambda context: len(self.parent.slices) > 0))
    self.menu.addAction("Rename Slice", "1")

    UIAction.registerAction("Delete Slice")
    self.actionHandler.bindAction("Delete Slice", UIAction(
      lambda context: self.parent.delete_slice(SliceMenu.refresh),
      lambda context: len(self.parent.slices) > 0))
    self.menu.addAction("Delete Slice", "2")

    # TODO : Cheeky tanto image instead of menu icon?
    # self.icon = ClickableIcon(QImage("./tanto.svg"), QSize(16, 16))
    self.icon = ClickableIcon(QImage(":/icons/images/menu.png"), QSize(16, 16))
    self.icon.clicked.connect(self.showMenu)

    layout = QHBoxLayout()
    layout.setContentsMargins(0, 0, 0, 0)
    self.setLayout(layout)
    self.layout().addWidget(self.icon)

  def showMenu(self):
    self.contextMenuManager.show(self.menu, self.actionHandler)

  def contextMenuEvent(self, event):
    self.showMenu()


# This represents the actual 'right click'/dropdown menu within the SliceMenuWidget.
# It gets its state from the parent (the TantoView itself), and there's a `refresh`
# classmethod which iterates all SliceMenu instances and updates their state,
# including if one pane deleted a slice that another was on. All the actions in this
# menu are wired back up to the parent with callbacks to update the display state
# after the main/parent state is updated internally.
class SliceMenu(MenuHelper):
  _instances = []

  def __init__(self, parent, actionHandler):
    super().__init__(parent)
    self.actionHandler = actionHandler
    self.contextMenuManager = ContextMenuManager(self)
    self.parent = parent
    self.index = 0

    # Register special-case action
    UIAction.registerAction(NEW_SLICE_TEXT, QKeySequence("Shift+K"))
    self.actionHandler.bindAction(NEW_SLICE_TEXT, UIAction(
      lambda context: self.parent.create_slice(self.create_slice),
      lambda context: True))
    self.m_menu.addAction(NEW_SLICE_TEXT, "ZLast")

    for (slicer_name, slice_name, slicer) in self.parent.slices:
      self.create_slice(slice_name)

    if len(self.parent.slices) > 0:
      self.parent.switch_to_slice(self.parent.slices[0][1], lambda n: None)

    self._instances.append(self)

  def __del__(self):
    self._instances.remove(self)

  def get_current_slice_name(self) -> str:
    return list(self.m_menu.getActions())[self.index]

  def get_index_of_slice(self, name: str) -> int:
    return list(self.m_menu.getActions()).index(name)

  @classmethod
  def refresh(cls, do_update_status = True):
    for inst in cls._instances:
      try:
        inst.m_menu
      except RuntimeError:
        continue
      existing_slice_names = set(inst.m_menu.getActions())
      existing_slice_names.remove(NEW_SLICE_TEXT)
      actual_slice_names = set([slice_name for (slicer_name, slice_name, slicer) in inst.parent.slices])
      selected_action = list(inst.m_menu.getActions())[inst.index]

      # Remove actions that don't exist
      for slice_name in existing_slice_names - actual_slice_names:
        inst.remove_slice(slice_name, False)

      # Add new actions
      for slice_name in sorted(list(actual_slice_names - existing_slice_names)):
        inst.create_slice(slice_name)

      if selected_action in actual_slice_names:
        inst.update_index(list(inst.m_menu.getActions()).index(selected_action))
      else:
        inst.update_index(inst.index)

      if do_update_status:
        inst.updateStatus()

  def update_index(self, index):
    # TODO : Some how to restore back to the last slice we were looking at?
    # global LAST_INDEX
    self.index = index
    if self.index >= len(self.m_menu.getActions()):
      self.index = 0
    if len(self.m_menu.getActions()) > 1 and self.get_current_slice_name() == NEW_SLICE_TEXT:
      self.index -= 1
    # LAST_INDEX = self.index

  def create_slice(self, name):
    UIAction.registerAction(name)
    self.actionHandler.bindAction(name, UIAction(
      lambda context: self.parent.switch_to_slice(name, self.switch_to_slice),
      lambda context: True))
    self.m_menu.addAction(name, "Slices")
    self.update_index(self.get_index_of_slice(name))
    self.setText(f" {name} ▾ ")

  def remove_slice(self, name, update_index=True):
    self.m_menu.removeAction(name)
    self.actionHandler.unbindAction(name)
    UIAction.unregisterAction(name)

    if update_index:  # When we recalculate
      self.update_index(self.index)

  def switch_to_slice(self, name):
    self.update_index(self.get_index_of_slice(name))
    self.updateStatus()

  def showMenu(self):
    self.refresh()
    if self.get_current_slice_name() == NEW_SLICE_TEXT:
      self.parent.create_slice(self.create_slice)
    else:
      self.contextMenuManager.show(self.m_menu, self.actionHandler)

  def updateStatus(self):
    self.refresh(False)
    if self.get_current_slice_name() == NEW_SLICE_TEXT:
      self.setText(f" {NEW_SLICE_TEXT} ")
    else:
      self.setText(" " + self.get_current_slice_name() + " ▾ ")


class SliceMenuWidget(ViewPaneHeaderSubtypeWidget):
  def __init__(self, parent, actionHandler):
    super().__init__()

    self.menu = SliceMenu(parent, actionHandler)
    self.setParent(parent)
    layout = QVBoxLayout()
    layout.setContentsMargins(0, 0, 0, 0)
    layout.addWidget(self.menu)
    self.setLayout(layout)

  def updateStatus(self):
    self.menu.updateStatus()

  def get_current_slice_name(self) -> str:
    try:
      return list(self.menu.m_menu.getActions())[self.menu.index]
    except:
      return NEW_SLICE_TEXT

  def __del__(self):
    print("SliceMenuWidget deleted!")

```

`plugin.json`:

```json
{
  "pluginmetadataversion": 2,
  "name": "Tantō",
  "type": [
    "ui",
    "helper"
  ],
  "api": [
    "python3"
  ],
  "description": "Tantō slices programs so you can understand them faster.",
  "longdescription": "",
  "license": {
    "name": "MIT",
    "text": "Copyright (c) 2021-2025 Vector 35 Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "platforms": [
    "Darwin",
    "Linux",
    "Windows"
  ],
  "dependencies": {},
  "version": "2.0.2",
  "author": "Vector 35 Inc",
  "minimumbinaryninjaversion": 5336
}
```

`slice_types/__init__.py`:

```py
# Copyright(c) 2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from .basic_block_slice import *
from .butterfly_slice import *
from .dynamic_call_graph import *
from .full_call_graph import *
from .scatter_slice import *
from .source_to_sink import *
from .variable_slice import *

```

`slice_types/basic_block_slice.py`:

```py
# Copyright(c) 2022-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto
from tanto.slices import Slice
from tanto.tanto_view import TantoView

from binaryninja import FlowGraph, FlowGraphNode, Function, FunctionViewType
from binaryninja.enums import HighlightStandardColor, FunctionGraphType

from binaryninjaui import getApplicationFont
from PySide6.QtGui import QPalette, QPainter
from PySide6.QtCore import Qt

# TODO : Work on edges?
# TODO : Add option that blacklists all other switch targets
# TODO : Add highlight options back


class BasicBlockSlice(Slice):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    self.parent = parent
    self.bv = parent.bv
    self.flowgraph_widget = parent.flowgraph_widget
    self.flowgraph_widget_paintEvent = parent.flowgraph_widget_paintEvent
    self.flowgraph_widget.paintEvent = self.helperPaintEvent

    self.excluded_blocks = []
    self.included_blocks = []
    self.func = None

    parent.register_for_basic_block("Include Block in Slice", self.include_block, lambda bv, bb: bb in self.excluded_blocks or bb not in self.included_blocks, "TantoGroup0", 0)
    parent.register_for_basic_block("Exclude Block from Slice", self.exclude_block, lambda bv, bb: bb in self.included_blocks or bb not in self.excluded_blocks, "TantoGroup0", 1)
    parent.register_for_basic_block("Reset Block State", self.reset_block, lambda bv, bb: bb in self.included_blocks or bb in self.excluded_blocks, "TantoGroup1", 2)
    parent.register_for_binary_view("Clear All Block States", self.clear, lambda bv: len(self.included_blocks) + len(self.excluded_blocks) > 0, "TantoGroup2", 3)

  def helperPaintEvent(self, event):
    p = QPainter(self.flowgraph_widget.viewport())

    p.setFont(getApplicationFont(self.flowgraph_widget))
    p.setPen(self.flowgraph_widget.palette().color(QPalette.WindowText))

    text = "Get started by right-clicking a basic block and selecting 'Tanto -> Include Block in Slice'"
    text_rect = p.boundingRect(self.flowgraph_widget.rect(), Qt.AlignCenter | Qt.TextWordWrap, text)   # Calculate the position to center the text
    p.drawText(text_rect, Qt.AlignCenter | Qt.TextWordWrap, text)

  def get_il_view_type(self) -> FunctionViewType:
    if self.func is None:
      return FunctionViewType(FunctionGraphType.InvalidILViewType)
    if isinstance(self.func, Function):
      return FunctionViewType(FunctionGraphType.NormalFunctionGraph)
    return FunctionViewType(self.func.il_form)

  def include_block(self, bv, bb):
    if self.func is None and bb is not None:
      if bb.is_il:
        self.func = bb.il_function
      else:
        self.func = bb.function
    if bb is None or (bb.is_il and bb.il_function != self.func) or (not bb.is_il and bb.function != self.func):
      return

    if bb in self.excluded_blocks:
      self.excluded_blocks.remove(bb)
    self.included_blocks.append(bb)

    self.reset()

  def exclude_block(self, bv, bb):
    if self.func is None and bb is not None:
      if bb.is_il:
        self.func = bb.il_function
      else:
        self.func = bb.function
    if bb is None or (bb.is_il and bb.il_function != self.func) or (not bb.is_il and bb.function != self.func):
      return

    if bb in self.included_blocks:
      self.included_blocks.remove(bb)
    self.excluded_blocks.append(bb)

    self.reset()

  def reset_block(self, bv, bb):
    if self.func is None and bb is not None:
      if bb.is_il:
        self.func = bb.il_function
      else:
        self.func = bb.function
    if bb is None or (bb.is_il and bb.il_function != self.func) or (not bb.is_il and bb.function != self.func):
      return

    if bb in self.excluded_blocks:
      self.excluded_blocks.remove(bb)
    if bb in self.included_blocks:
      self.included_blocks.remove(bb)

    self.reset()

  def reset(self):
    # Update graph, clear all highlights
    for bb in self.func:
      bb.set_auto_highlight(HighlightStandardColor.NoHighlightColor)
      for inst in tanto.helpers.get_insts(bb):
        if isinstance(self.func, tanto.helpers.ILFunction):
          self.func.source_function.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)
        else:
          self.func.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)
    # Update graph, regen graph and highlights
    self.flowgraph_widget.setGraph(self.get_flowgraph())

  def clear(self, bv):
    for bb in self.func:
      bb.set_auto_highlight(HighlightStandardColor.NoHighlightColor)
      for inst in tanto.helpers.get_insts(bb):
        if isinstance(self.func, tanto.helpers.ILFunction):
          self.func.source_function.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)
        else:
          self.func.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)

    self.excluded_blocks.clear()
    self.included_blocks.clear()
    self.func = None

    self.flowgraph_widget.paintEvent = self.helperPaintEvent
    self.flowgraph_widget.setGraph(None)

  def calculate_basic_block_slice(self):
    def reach_up(il_bb, visited):
      if il_bb in visited or il_bb in self.excluded_blocks:
        return []
      visited.append(il_bb)

      result = [il_bb]
      for edge in il_bb.incoming_edges:
        result += reach_up(edge.source, visited)
      return result

    def reach_down(il_bb, visited):
      if il_bb in visited or il_bb in self.excluded_blocks:
        return []
      visited.append(il_bb)

      result = [il_bb]
      for edge in il_bb.outgoing_edges:
        result += reach_down(edge.target, visited)
      return result

    result = set()
    for bb in self.included_blocks:
      result.update(set(reach_up(bb, []) + reach_down(bb, [])))
    return result

  def get_flowgraph(self) -> FlowGraph:
    if self.func is None or len(self.included_blocks) + len(self.excluded_blocks) == 0:
      self.flowgraph_widget.paintEvent = self.helperPaintEvent
      return
    else:
      self.flowgraph_widget.paintEvent = self.flowgraph_widget_paintEvent

    function_slice = sorted(self.calculate_basic_block_slice(), key=lambda block: len(block.incoming_edges) != 0)

    # Highlight features in original graph
    # if self.decomp_slice_highlight:
    for bb in self.func:
      if bb in function_slice:
        # if self.decomp_slice_highlight:
        bb.set_auto_highlight(HighlightStandardColor.CyanHighlightColor)
      else:
        # if self.decomp_slice_highlight:
        bb.set_auto_highlight(HighlightStandardColor.RedHighlightColor)
    # if self.decomp_block_selection_highlight:
    for bb in self.included_blocks:
      bb.set_auto_highlight(HighlightStandardColor.GreenHighlightColor)
    for bb in self.excluded_blocks:
      bb.set_auto_highlight(HighlightStandardColor.WhiteHighlightColor)

    # Create new graph
    new_graph = FlowGraph()
    if isinstance(self.func, Function):
      new_graph.function = self.func
    else:
      new_graph.function = self.func.source_function
      new_graph.il_function = self.func
    nodes = {}
    node_edges = {}
    for basic_block in function_slice:
      new_node = FlowGraphNode(new_graph)

      # Edgy stuff
      nodes[basic_block.index] = new_node
      edges = set()
      for edge in basic_block.outgoing_edges:
        edges.add(edge)
      node_edges[basic_block.index] = edges

      # Copy over lines
      new_node.lines = basic_block.get_disassembly_text(tanto.helpers.get_disassembly_settings())
      for line in new_node.lines:
        line.highlight = HighlightStandardColor.NoHighlightColor

      # Duplicate selection highlight in new graph
      if basic_block in self.included_blocks:
        new_node.highlight = HighlightStandardColor.GreenHighlightColor

      new_graph.append(new_node)

    # Tie edges together, highlight blocks with now-missing children, replace missing children with representational blocks
    for index, node in nodes.items():
      for edge in node_edges[index]:
        if edge.target.index in nodes:
          node.add_outgoing_edge(edge.type, nodes[edge.target.index])
        else:
          node.highlight = HighlightStandardColor.YellowHighlightColor

          for basic_block in function_slice:
            if basic_block.index == index:
              basic_block.set_auto_highlight(HighlightStandardColor.YellowHighlightColor)

    return new_graph


TantoView.register_slice_type("Basic Block Slice", BasicBlockSlice)

```

`slice_types/butterfly_slice.py`:

```py
# Copyright(c) 2024-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto
from tanto.tanto_view import TantoView

from binaryninja import FlowGraph, FlowGraphNode, EdgeStyle
from binaryninja.function import Function, DisassemblyTextLine
from binaryninja.enums import BranchType, EdgePenStyle, ThemeColor


class ButterflySlice(tanto.slices.Slice):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    self.navigation_style = tanto.slices.NavigationStyle.FUNCTION_START
    self.update_style = tanto.slices.UpdateStyle.ON_NAVIGATE

  def get_flowgraph(self) -> FlowGraph:
    if (function := tanto.helpers.get_current_source_function()) is None:
      return None

    new_graph = FlowGraph()
    nodes = {}
    added_edges = set()

    def add_function_node(function: Function) -> FlowGraphNode:
      if function not in nodes:
        new_node = FlowGraphNode(new_graph)
        new_node.lines = [DisassemblyTextLine(function.type_tokens, address=function.start)]
        new_graph.append(new_node)
        nodes[function] = new_node
      return nodes[function]

    def add_callers(function: Function, level: int, max_level: int):
      if level >= max_level:
        return

      current_node = add_function_node(function)

      # Add direct callers (incoming edges)
      for caller in function.callers:
        caller_node = add_function_node(caller)
        edge = (caller, function)
        if edge not in added_edges:
          caller_node.add_outgoing_edge(BranchType.CallDestination, current_node)
          added_edges.add(edge)
          add_callers(caller, level + 1, max_level)

    def add_callees(function: Function, level: int, max_level: int):
      if level >= max_level:
        return

      current_node = add_function_node(function)

      # Add direct callees (outgoing edges)
      for callee in function.callees:
        callee_node = add_function_node(callee)
        edge = (function, callee)
        if edge not in added_edges:
          current_node.add_outgoing_edge(BranchType.CallDestination, callee_node)
          added_edges.add(edge)
          add_callees(callee, level + 1, max_level)

    # Add the middle function and its direct relationships
    add_callers(function, 0, 2)
    add_callees(function, 0, 2)

    # Optionally, add call relationships among remaining nodes (this is within the already added nodes)
    for function in nodes:
      node = nodes[function]
      for callee in function.callees:
        if callee in nodes:
          callee_node = nodes[callee]
          edge = (function, callee)
          if edge not in added_edges:
            node.add_outgoing_edge(BranchType.UserDefinedBranch, callee_node, EdgeStyle(EdgePenStyle.DashLine, 2, ThemeColor.UnconditionalBranchColor))
            added_edges.add(edge)

    return new_graph


TantoView.register_slice_type("Butterfly Slice", ButterflySlice)

```

`slice_types/dynamic_call_graph.py`:

```py
# Copyright(c) 2024-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


import tanto
from tanto.tanto_view import TantoView

from binaryninja import FlowGraph, FlowGraphNode, DisassemblyTextLine
from binaryninja.enums import BranchType

from PySide6.QtCore import QMimeData
from PySide6.QtGui import QDropEvent


class DynamicCallGraph(tanto.slices.Slice):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    self.parent = parent
    self.bv = parent.bv
    self.graph_funcs = set()
    self.excluded_funcs = set()

    self.navigation_style = tanto.slices.NavigationStyle.FUNCTION_START

    parent.setAcceptDrops(True)
    parent.dragEnterEvent = self.dragEnterEvent
    parent.dropEvent = self.dropEvent
    parent.flowgraph_widget.setAcceptDrops(True)
    parent.flowgraph_widget.dragEnterEvent = self.dragEnterEvent
    parent.flowgraph_widget.dropEvent = self.dropEvent

    parent.register_for_function("Include Function in Graph",
                                 self.include_function,
                                 lambda bv, func: self._to_source(func) not in self.graph_funcs,
                                 menu_group="TantoGroup0", menu_order=0)

    parent.register_for_function("Exclude Function from Graph",
                                 self.exclude_function,
                                 lambda bv, func: self._to_source(func) in self.graph_funcs and func not in self.excluded_funcs,
                                 menu_group="TantoGroup0", menu_order=1)

    parent.register_for_function("Include Callers",
                                 self.include_callers,
                                 lambda bv, func: self._to_source(func) in self.graph_funcs,
                                 menu_group="TantoGroup1", menu_order=0)
    parent.register_for_function("Include Callees",
                                 self.include_callees,
                                 lambda bv, func: self._to_source(func) in self.graph_funcs,
                                 menu_group="TantoGroup1", menu_order=1)
    parent.register_for_function("Include All Callers",
                                 self.include_all_callers,
                                 lambda bv, func: self._to_source(func) in self.graph_funcs,
                                 menu_group="TantoGroup2", menu_order=0)
    parent.register_for_function("Include All Callees",
                                 self.include_all_callees,
                                 lambda bv, func: self._to_source(func) in self.graph_funcs,
                                 menu_group="TantoGroup2", menu_order=1)

  def dragEnterEvent(self, event):
    event.accept()

  def dropEvent(self, event: QDropEvent):
    mime_data: QMimeData = event.mimeData()
    for addr in set(str(mime_data.data('application/component_tree_item'), 'utf-8').splitlines()):
      if addr.endswith('F'):
        func = self.bv.get_function_at(int(addr[:-1], 16))
        if func is not None:
          self.include_function(None, func)  # TODO : Validation that get func at returns not none
    event.accept()

  def _to_source(self, func):
    # If the function is an ILFunction, return its source function.
    return func.source_function if hasattr(func, "source_function") else func

  def include_function(self, bv, func):
    func = self._to_source(func)
    self.graph_funcs.add(func)
    if func in self.excluded_funcs:
      self.excluded_funcs.remove(func)
    self.update_graph()

  def exclude_function(self, bv, func):
    func = self._to_source(func)
    self.excluded_funcs.add(func)
    self.update_graph()

  def include_callers(self, bv, func):
    func = self._to_source(func)
    for caller in func.callers:
      self.graph_funcs.add(caller)
    self.update_graph()

  def include_callees(self, bv, func):
    func = self._to_source(func)
    for callee in func.callees:
      self.graph_funcs.add(callee)
    self.update_graph()

  def include_all_callers(self, bv, func):
    func = self._to_source(func)

    def dfs(f, visited):
      if f in visited:
        return
      visited.add(f)
      for caller in f.callers:
        self.graph_funcs.add(caller)
        dfs(caller, visited)
    dfs(func, set())
    self.update_graph()

  def include_all_callees(self, bv, func):
    func = self._to_source(func)

    def dfs(f, visited):
      if f in visited:
        return
      visited.add(f)
      for callee in f.callees:
        self.graph_funcs.add(callee)
        dfs(callee, visited)
    dfs(func, set())
    self.update_graph()

  def resolve_active_callees(self, func):
    result = set()
    visited = set()

    def dfs(curr):
      if curr in visited:
        return
      visited.add(curr)
      for callee in curr.callees:
        if callee in self.graph_funcs and callee not in self.excluded_funcs:
          result.add(callee)
        else:
          dfs(callee)
    dfs(func)
    result.discard(func)
    return result

  def update_graph(self):
    flowgraph = self.get_flowgraph()
    self.parent.flowgraph_widget.setGraph(flowgraph)
    # Optionally, navigate to the current offset.
    self.parent.navigate(self.parent.getCurrentOffset())

  def get_flowgraph(self) -> FlowGraph:
    active_funcs = {f for f in self.graph_funcs if f not in self.excluded_funcs}
    flowgraph = FlowGraph()
    nodes = {}

    for func in active_funcs:
      node = FlowGraphNode(flowgraph)
      node.lines = [DisassemblyTextLine(func.type_tokens, address=func.start)]
      flowgraph.append(node)
      nodes[func] = node

    for func in active_funcs:
      for target in self.resolve_active_callees(func):
        if func in nodes and target in nodes:
          nodes[func].add_outgoing_edge(BranchType.CallDestination, nodes[target])
    return flowgraph


TantoView.register_slice_type("Dynamic Call Graph", DynamicCallGraph)

```

`slice_types/full_call_graph.py`:

```py
# Copyright(c) 2024-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


# This is the most basic slice implementation I could think of. It
# has an initialization step, where it chooses to drop the parent
# but maintains the bv ref, and it has a get_flowgraph step, where
# it generates its basic flow graph and returns it.

import tanto
from tanto.tanto_view import TantoView

from binaryninja import FlowGraph, FlowGraphNode
from binaryninja.function import DisassemblyTextLine
from binaryninja.enums import BranchType


class FullCallGraph(tanto.slices.Slice):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    self.bv = parent.bv
    self.navigation_style = tanto.slices.NavigationStyle.FUNCTION_START

  def get_flowgraph(self) -> FlowGraph:
    flowgraph = FlowGraph()
    nodes = {}

    for function in self.bv.functions:
      new_node = FlowGraphNode(flowgraph)
      new_node.lines = [DisassemblyTextLine(function.type_tokens, address=function.start)]
      flowgraph.append(new_node)
      nodes[f"{function.symbol.full_name}@{function.start}"] = new_node

    for function in self.bv.functions:
      node = nodes[f"{function.symbol.full_name}@{function.start}"]
      for edge in set(function.callees):
        node.add_outgoing_edge(BranchType.UnconditionalBranch, nodes[f"{edge.symbol.full_name}@{edge.start}"])

    return flowgraph


TantoView.register_slice_type("Full Call Graph", FullCallGraph)

```

`slice_types/scatter_slice.py`:

```py
# Copyright(c) 2024-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto
from tanto.tanto_view import TantoView

from binaryninja import FlowGraph, FlowGraphNode, EdgeStyle
from binaryninja.function import Function, DisassemblyTextLine
from binaryninja.enums import BranchType, EdgePenStyle, ThemeColor


class ScatterSlice(tanto.slices.Slice):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    self.navigation_style = tanto.slices.NavigationStyle.FUNCTION_START
    self.update_style = tanto.slices.UpdateStyle.ON_NAVIGATE

  def get_flowgraph(self) -> FlowGraph:
    if (function := tanto.helpers.get_current_source_function()) is None:
      print("No source function")
      return None

    new_graph = FlowGraph()
    nodes = {}
    added_edges = set()

    def add_function_node(function: Function) -> FlowGraphNode:
      if function not in nodes:
        new_node = FlowGraphNode(new_graph)
        new_node.lines = [DisassemblyTextLine(function.type_tokens, address=function.start)]
        new_graph.append(new_node)
        nodes[function] = new_node
      return nodes[function]

    visited = set()

    def add_callers(function: Function, level: int, max_level: int):
      visited.add(function)
      if level >= max_level:
        return
      current_node = add_function_node(function)

      # Add direct callers (incoming edges)
      for caller in function.callers:
        caller_node = add_function_node(caller)
        edge = (caller, function)
        if edge not in added_edges:
          caller_node.add_outgoing_edge(BranchType.CallDestination, current_node)
          added_edges.add(edge)
          if caller not in visited:
            add_callers(caller, level + 1, max_level)
            add_callees(caller, level + 1, max_level)

    def add_callees(function: Function, level: int, max_level: int):
      visited.add(function)
      if level >= max_level:
        return
      current_node = add_function_node(function)

      # Add direct callees (outgoing edges)
      for callee in function.callees:
        callee_node = add_function_node(callee)
        edge = (function, callee)
        if edge not in added_edges:
          current_node.add_outgoing_edge(BranchType.CallDestination, callee_node)
          added_edges.add(edge)
          if callee not in visited:
            add_callers(callee, level + 1, max_level)
            add_callees(callee, level + 1, max_level)

    # Add the middle function and its direct relationships
    add_callers(function, 0, 2)
    add_callees(function, 0, 2)

    # Optionally, add call relationships among remaining nodes (this is within the already added nodes)
    for function in nodes:
      node = nodes[function]
      for callee in function.callees:
        if callee in nodes:
          callee_node = nodes[callee]
          edge = (function, callee)
          if edge not in added_edges:
            node.add_outgoing_edge(BranchType.UserDefinedBranch, callee_node, EdgeStyle(EdgePenStyle.DashLine, 2, ThemeColor.UnconditionalBranchColor))
            added_edges.add(edge)

    return new_graph


TantoView.register_slice_type("Scatter Slice", ScatterSlice)

```

`slice_types/source_to_sink.py`:

```py
# Copyright(c) 2024-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto
from tanto.tanto_view import TantoView

from binaryninja import FlowGraph, FlowGraphNode, DisassemblyTextLine, FunctionViewType
from binaryninja.enums import BranchType, FunctionGraphType


class SourceToSinkGraph(tanto.slices.Slice):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    super().__init__()
    self.parent = parent
    self.flowgraph_widget = self.parent.flowgraph_widget
    self.sources = set()
    self.sinks = set()

    self.navigation_style = tanto.slices.NavigationStyle.FUNCTION_START

    parent.register_for_function("Add Function as Source", self.add_function_as_source, menu_group="TantoGroup0", menu_order=0)
    parent.register_for_function("Add Function as Sink", self.add_function_as_sink, menu_group="TantoGroup0", menu_order=1)
    parent.register_for_function("Reset Function State", self.reset_function_state, menu_group="TantoGroup1", menu_order=2)
    parent.register_for_binary_view("Clear All", self.clear_all, menu_group="TantoGroup2", menu_order=3)

  def get_il_view_type(self) -> FunctionViewType:
    return FunctionViewType(FunctionGraphType.NormalFunctionGraph)

  def add_function_as_source(self, bv, func):
    if isinstance(func, tanto.helpers.ILFunction):
      func = func.source_function
    self.sources.add(func)
    self.update_graph()

  def add_function_as_sink(self, bv, func):
    if isinstance(func, tanto.helpers.ILFunction):
      func = func.source_function
    self.sinks.add(func)
    self.update_graph()

  def reset_function_state(self, bv, func):
    if isinstance(func, tanto.helpers.ILFunction):
      func = func.source_function
    if func in self.sources:
      self.sources.remove(func)
    if func in self.sinks:
      self.sinks.remove(func)
    self.update_graph()

  def clear_all(self, bv=None):
    self.sources.clear()
    self.sinks.clear()
    self.update_graph()

  def update_graph(self):
    flowgraph = self.get_flowgraph()
    self.flowgraph_widget.setGraph(flowgraph)
    if flowgraph:
      self.parent.navigate(self.parent.getCurrentOffset())

  def get_flowgraph(self):
    if not self.sources and not self.sinks:
      return None

    flowgraph = FlowGraph()
    nodes = {}
    edges = set()

    def add_node(function):
      key = f"{function.symbol.full_name}@{function.start}"
      if key not in nodes:
        new_node = FlowGraphNode(flowgraph)
        new_node.lines = [DisassemblyTextLine(function.type_tokens, address=function.start)]
        flowgraph.append(new_node)
        nodes[key] = new_node
      return nodes[key]

    def add_edge(source_func, target_func):
      edge_key = (source_func.start, target_func.start)
      if edge_key not in edges:
        source_node = add_node(source_func)
        target_node = add_node(target_func)
        source_node.add_outgoing_edge(BranchType.CallDestination, target_node)
        edges.add(edge_key)

    def traverse_funcs(func, visited, direction):
      if func in visited:
        return visited[func]

      visited[func] = set()

      if direction == 'down':
        call_edges = func.callees
      else:
        call_edges = func.callers

      for edge in call_edges:
        if edge not in visited:
          visited[func].add(edge)
          if direction == 'down':
            add_edge(func, edge)  # Edge from func to callee
          else:
            add_edge(edge, func)  # Edge from caller to func
          traverse_funcs(edge, visited, direction)

      return visited[func]

    # If both sources and sinks are provided, find paths between them
    if self.sources and self.sinks:
      for source in self.sources:
        for sink in self.sinks:
          paths = self.find_paths_from_source_to_sink(source, sink, set())
          for path in paths:
            for i in range(len(path) - 1):
              add_edge(path[i], path[i + 1])

    else:
      # If only sources are provided, show all paths from them
      if self.sources:
        for source in self.sources:
          traverse_funcs(source, {}, 'down')

      # If only sinks are provided, show all paths to them
      if self.sinks:
        for sink in self.sinks:
          traverse_funcs(sink, {}, 'up')

    return flowgraph

  def find_paths_from_source_to_sink(self, source, sink, visited):
    if source == sink:
      return [[source]]

    if source in visited:
      return []

    visited.add(source)
    paths = []
    for callee in source.callees:
      sub_paths = self.find_paths_from_source_to_sink(callee, sink, visited)
      for sub_path in sub_paths:
        paths.append([source] + sub_path)

    visited.remove(source)
    return paths


TantoView.register_slice_type("Source to Sink Graph", SourceToSinkGraph)

```

`slice_types/variable_slice.py`:

```py
# Copyright(c) 2022-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto
from tanto.slices import Slice
from tanto.tanto_view import TantoView

from binaryninjaui import getApplicationFont

from binaryninja import FlowGraph, FlowGraphNode, Function, FunctionViewType
from binaryninja.enums import HighlightStandardColor, FunctionGraphType
from binaryninja.commonil import Terminal, ControlFlow

from PySide6.QtGui import QPalette, QPainter
from PySide6.QtCore import Qt


class VariableBlockSlice(Slice):
  def __init__(self, parent: 'tanto.tanto_view.TantoView'):
    self.parent = parent
    self.bv = parent.bv
    self.flowgraph_widget = self.parent.flowgraph_widget
    self.flowgraph_widget_paintEvent = self.parent.flowgraph_widget_paintEvent
    self.flowgraph_widget.paintEvent = self.helperPaintEvent

    self.variables = []
    self.func = None

    parent.register_for_variable("Include Variable in Slice", self.include_variable, menu_group="TantoGroup0", menu_order=0)
    parent.register_for_variable("Remove Variable from Slice", self.remove_variable, menu_group="TantoGroup0", menu_order=1)
    parent.register_for_binary_view("Remove All Variables", self.clear, lambda bv: len(self.variables) > 0, "TantoGroup1", 2)

  def helperPaintEvent(self, event):
    p = QPainter(self.flowgraph_widget.viewport())

    p.setFont(getApplicationFont(self.flowgraph_widget))
    p.setPen(self.flowgraph_widget.palette().color(QPalette.WindowText))

    text = "Get started by right-clicking a variable and selecting 'Tanto -> Include Variable in Slice'"
    text_rect = p.boundingRect(self.flowgraph_widget.rect(), Qt.AlignCenter | Qt.TextWordWrap, text)   # Calculate the position to center the text
    p.drawText(text_rect, Qt.AlignCenter | Qt.TextWordWrap, text)

  def get_il_view_type(self) -> FunctionViewType:
    if self.func is None:
      return FunctionViewType(FunctionGraphType.InvalidILViewType)
    if isinstance(self.func, Function):
      return FunctionViewType(FunctionGraphType.NormalFunctionGraph)
    return FunctionViewType(self.func.il_form)

  def include_variable(self, bv, var):
    current_func = tanto.helpers.get_current_il_function()
    if self.func is None:
      self.func = current_func
    if current_func != self.func:
      return

    if var not in self.variables:
      self.variables.append(var)

    self.reset()

  def remove_variable(self, bv, var):
    current_func = tanto.helpers.get_current_il_function()
    if self.func is None:
      self.func = current_func
    if current_func != self.func:
      return

    if var in self.variables:
      self.variables.remove(var)

    self.reset()

  def reset(self):
    # Update graph, clear all highlights
    for bb in self.func:
      bb.set_auto_highlight(HighlightStandardColor.NoHighlightColor)
      for inst in tanto.helpers.get_insts(bb):
        if isinstance(self.func, tanto.helpers.ILFunction):
          self.func.source_function.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)
        else:
          self.func.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)
    # Update graph, regen graph and highlights
    self.flowgraph_widget.setGraph(self.get_flowgraph())

  def clear(self, bv):
    for bb in self.func:
      bb.set_auto_highlight(HighlightStandardColor.NoHighlightColor)
      for inst in tanto.helpers.get_insts(bb):
        if isinstance(self.func, tanto.helpers.ILFunction):
          self.func.source_function.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)
        else:
          self.func.set_auto_instr_highlight(inst.address, HighlightStandardColor.NoHighlightColor)

    self.variables.clear()
    self.func = None

    self.flowgraph_widget.paintEvent = self.helperPaintEvent
    self.flowgraph_widget.setGraph(None)
    # TODO : Call reset?

  def recover_subgraph_edges(self, block_index, function_slice):
    for bb in self.func:
      if bb.index == block_index:
        break
    else:
      # log_error("Could not find basic block")
      return []

    def reach_down(il_bb, function_slice, visited):
      if il_bb in visited:
        return set()
      if il_bb in function_slice:
        return set([il_bb])
      visited.add(il_bb)

      result = set()
      for edge in il_bb.outgoing_edges:
        result.update(reach_down(edge.target, function_slice, visited))
      return result

    return reach_down(bb, function_slice, set())

  def get_flowgraph(self) -> FlowGraph:
    if self.func is None or len(self.variables) == 0:
      self.flowgraph_widget.paintEvent = self.helperPaintEvent
      return
    else:
      self.flowgraph_widget.paintEvent = self.flowgraph_widget_paintEvent

    keep_indexes = set()
    for var in self.variables:
      for bb in self.func:
        for inst in bb:
          if self.func.il_form in [FunctionGraphType.LowLevelILSSAFormFunctionGraph, FunctionGraphType.MediumLevelILSSAFormFunctionGraph, FunctionGraphType.MappedMediumLevelILSSAFormFunctionGraph, FunctionGraphType.HighLevelILSSAFormFunctionGraph]:
            if self.func.is_ssa_var_live_at(var, inst.instr_index):
              keep_indexes.add(inst.instr_index)
          elif self.func.is_var_live_at(var, inst.instr_index):
            keep_indexes.add(inst.instr_index)

    new_graph = FlowGraph()
    if isinstance(self.func, Function):
      new_graph.function = self.func
    else:
      new_graph.function = self.func.source_function
      new_graph.il_function = self.func
    nodes = {}
    node_edges = {}
    nodes_with_lines = []
    function_slice = []
    for basic_block in self.func:
      new_node = FlowGraphNode(new_graph)

      # Edgy stuff
      edges = set()
      for edge in basic_block.outgoing_edges:
        edges.add(edge)
      node_edges[basic_block.index] = edges

      lines = basic_block.get_disassembly_text(tanto.helpers.get_disassembly_settings())
      for line in lines:
        line.highlight = HighlightStandardColor.NoHighlightColor

      # Pruning Basic Block Content
      saved_lines = []
      for inst in basic_block:
        if inst.instr_index in keep_indexes:
          if tanto.helpers.instruction_contains_var(self.variables, inst):
            saved_lines += [line for line in lines if line.il_instruction == inst]
            inst.function.source_function.set_auto_instr_highlight(inst.address, HighlightStandardColor.GreenHighlightColor)
          elif isinstance(inst, ControlFlow) and not isinstance(inst, Terminal):
            inst.function.source_function.set_auto_instr_highlight(inst.address, HighlightStandardColor.YellowHighlightColor)
            for line in [line for line in lines if line.il_instruction == inst]:
              for i in range(len(line.tokens)):
                line.tokens[i].confidence = 0
              saved_lines.append(line)

      new_node.lines = saved_lines
      if len(saved_lines) > 0:
        nodes[basic_block.index] = new_node
        nodes_with_lines.append(basic_block.index)
        function_slice.append(basic_block)
        new_graph.append(new_node)

    # Stitching the edges back together
    for index in nodes_with_lines:
      for edge in node_edges[index]:
        if edge.target.index in nodes_with_lines:
          nodes[index].add_outgoing_edge(edge.type, nodes[edge.target.index])
        else:
          outgoing_edges = self.recover_subgraph_edges(edge.target.index, function_slice)
          for target in outgoing_edges:
            nodes[index].add_outgoing_edge(edge.type, nodes[target.index])

    return new_graph


TantoView.register_slice_type("Variable Slice", VariableBlockSlice)

```

`slices.py`:

```py
# Copyright(c) 2022-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from enum import Enum

from binaryninja import FlowGraph, FunctionViewType
from binaryninja.enums import FunctionGraphType


#########
# Slice #
#########

# The slice class is an abstract class that users can implement to
# create Tanto plugins! Simply implement the functions below, then
# `call TantoView.register_slice_type` with a name for your slice type
# and a reference to your slice class.
#
# Currently you only need to implement `__init__` and `get_flowgraph`,
# You don't need to initialize the parent. This class will be
# instantiated by the user, and only deleted when they manually delete
# it or Binary Ninja exits. You can retain whatever state you want. I
# recommend caching flowgraphs if possible.
#
# Look for example implementations in ./slice_types/


class NavigationStyle(Enum):
  ABSOLUTE_ADDRESS = 0
  FUNCTION_START = 1


class UpdateStyle(Enum):
  MANUAL = 0
  ON_NAVIGATE = 1


class Slice():
  # This is really the only function you need to implement
  def get_flowgraph(self) -> FlowGraph:
    raise NotImplementedError

  # Completely optional to implement, but required for right click options to work within the slice
  def get_il_view_type(self) -> FunctionViewType:
    return FunctionViewType(FunctionGraphType.InvalidILViewType)

  # Config options

  @property
  def navigation_style(self):
    if hasattr(self, "_navigation_style"):
      return self._navigation_style
    return NavigationStyle.ABSOLUTE_ADDRESS

  @navigation_style.setter
  def navigation_style(self, value):
    self._navigation_style = value

  @property
  def update_style(self):
    if hasattr(self, "_update_style"):
      return self._update_style
    return UpdateStyle.MANUAL

  @update_style.setter
  def update_style(self, value):
    self._update_style = value

```

`tanto_view.py`:

```py
# Copyright(c) 2022-2025 Vector 35 Inc
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and / or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import tanto
from tanto import menus

from binaryninjaui import FlowGraphWidget, View, ViewFrame, ViewType, ViewPaneHeaderSubtypeWidget, getApplicationFont, UIContext, UIAction, UIActionHandler, Menu, ContextMenuManager
from PySide6.QtWidgets import QWidget, QVBoxLayout
from PySide6.QtGui import QPalette, QPainter
from PySide6.QtCore import Qt

from binaryninja import BinaryView, Settings, SSAVariable
from binaryninja.log import Logger, log_error
from binaryninja.enums import FunctionGraphType
from binaryninja.function import DisassemblySettings, FunctionViewType, Variable
from binaryninja.interaction import get_choice_input, get_text_line_input

from functools import partial
from typing import Callable, Optional


class TantoView(QWidget, View):
  slice_providers = []
  current_slice = None

  def __init__(self, parent: ViewFrame, bv: BinaryView, slices: list[tuple[str, str, 'tanto.slices.Slice']], logger: Logger):
    super().__init__(parent)
    View.__init__(self)
    self.setupView(self)
    View.setBinaryDataNavigable(self, True)
    self.setParent(parent)
    self.actionHandler = UIActionHandler()
    self.actionHandler.setupActionHandler(self)
    self.contextMenu = Menu()
    self.contextMenuManager = ContextMenuManager(self)
    self.actions = {}

    self.bv: BinaryView = bv
    self.slices: list[tuple[str, str, 'tanto.slices.Slice']] = slices
    self.log: Logger = logger
    self.disassembly_settings = DisassemblySettings()
    self.slice_menu = menus.SliceMenuWidget(self, self.actionHandler)

    self.flowgraph_widget = FlowGraphWidget(self, bv)
    self.flowgraph_widget.setContextMenuPolicy(Qt.NoContextMenu)
    self.flowgraph_widget.focusInEvent = self.focusInEvent
    self.clear_actions()

    # Prevent flowgraph's "No function selected" default message from showing
    self.flowgraph_widget_paintEvent = self.flowgraph_widget.paintEvent
    self.flowgraph_widget.paintEvent = self.helperPaintEvent

    layout = QVBoxLayout()
    layout.setContentsMargins(0, 0, 0, 0)
    self.setLayout(layout)
    self.layout().addWidget(self.flowgraph_widget)

  # TODO : selectable icons for each slice type instead of having to go through the drop down menu
  def helperPaintEvent(self, event):
    p = QPainter(self.flowgraph_widget.viewport())

    p.setFont(getApplicationFont(self.flowgraph_widget))
    p.setPen(self.flowgraph_widget.palette().color(QPalette.WindowText))

    line1 = "Welcome to Tanto!"
    line2 = f"To get started, select \"{menus.NEW_SLICE_TEXT}\" above!"
    text = f"{line1}\n{line2}"

    text_rect = p.boundingRect(self.rect(), Qt.AlignCenter | Qt.TextWordWrap, text)   # Calculate the position to center the text
    p.drawText(text_rect, Qt.AlignCenter | Qt.TextWordWrap, text)

  def getData(self) -> BinaryView:
    return self.bv

  def getCurrentOffset(self, offset: Optional[int] = None) -> int:
    if offset is None:
      offset = self.flowgraph_widget.getCurrentOffset()
    if self.current_slice is not None and self.current_slice.navigation_style == tanto.slices.NavigationStyle.FUNCTION_START:
      current_functions = self.bv.get_functions_containing(offset)
      if len(current_functions) > 0:
        offset = current_functions[0].start

    return offset

  def getSelectionOffsets(self):
    return self.flowgraph_widget.getSelectionOffsets()

  def getDisassemblySettings(self):
    return self.disassembly_settings

  def focusInEvent(self, event):
    super().focusInEvent(event)
    self.setup_actions()

  def getHeaderOptionsWidget(self) -> 'tanto.menus.OptionsWidget':
    return menus.OptionsWidget(self)

  def getHeaderSubtypeWidget(self) -> ViewPaneHeaderSubtypeWidget:
    self.slice_menu = menus.SliceMenuWidget(self, self.actionHandler)
    return self.slice_menu

  def navigate(self, offset: int) -> bool:
    self.setup_right_click_menu()

    # Regen graph based on setting
    if self.current_slice is not None and self.current_slice.update_style == tanto.slices.UpdateStyle.ON_NAVIGATE:
      self.flowgraph_widget.setGraph(self.current_slice.get_flowgraph())

    self.flowgraph_widget.showAddress(self.getCurrentOffset(offset))
    return True

  def getCurrentFunction(self):
    if self.current_slice is not None and self.current_slice.navigation_style == tanto.slices.NavigationStyle.FUNCTION_START:
      if len(current_functions := self.bv.get_functions_containing(self.getCurrentOffset())) > 0:
        return current_functions[0]
    return self.flowgraph_widget.getCurrentFunction()

  def getILViewType(self):
    if self.current_slice is not None:
      return self.current_slice.get_il_view_type()
    return FunctionViewType(FunctionGraphType.InvalidILViewType)

  @classmethod
  def register_slice_type(cls, name: str, slicer: 'tanto.slices.Slice'):
    settings_title = f"Enable {name}"
    description = f"Enable or disable {name}."

    properties = f'{{"title" : "{settings_title}", "description" : "{description}", "type" : "boolean", "default" : true}}'
    Settings().register_setting(f"tanto.{name}.enabled", properties)

    if any([name == slicer_name for slicer_name, _ in cls.slice_providers]):
      log_error(f"Could not register slicer '{name}' due to naming conflict")
      return
    cls.slice_providers.append((name, slicer))
    cls.slice_providers.sort(key=lambda s: s[0])

  def create_slice(self, create_option_callback: Callable[[str], None]):
    if (index := get_choice_input("Select a slice type to create:", menus.NEW_SLICE_TEXT, [slicer_name for slicer_name, _ in self.slice_providers if Settings().get_bool(f"tanto.{slicer_name}.enabled")])) is None:
      return

    slicer_name, slicer_class = [s for s in self.slice_providers if Settings().get_bool(f"tanto.{s[0]}.enabled")][index]
    names = [e_name for e_slicer_name, e_name, _ in self.slices if e_slicer_name == slicer_name]
    for i in range(1, 1000):
      slice_name = f"{slicer_name} {i}"
      if slice_name not in names:
        break
    else:
      self.log.log_alert("Could not generate unique slice name")
      return

    # Change dropdown/menu selection text to new slice
    create_option_callback(slice_name)

    # Unregister old actions
    self.clear_actions()

    # Instantiate slicer class and save it with its names to our shared state from our parent
    self.current_slice = slicer_class(self)
    self.slices.append((slicer_name, slice_name, self.current_slice))

    # Register new actions
    self.setup_actions()

    # Enable the actual flowgraph rendering again and navigate the slice to wherever we currently are in the binary
    self.flowgraph_widget.paintEvent = self.flowgraph_widget_paintEvent
    self.flowgraph_widget.setGraph(self.current_slice.get_flowgraph())

  def switch_to_slice(self, name, change_option_callback: Callable[[str], None]):
    if not hasattr(self, 'slice_menu'):
      return
    self.flowgraph_widget.paintEvent = self.flowgraph_widget_paintEvent
    change_option_callback(name)
    for _slicer_name, slice_name, slicer in self.slices:
      if slice_name == name:

        # Unregister old global actions, register new ones
        self.clear_actions()
        self.current_slice = slicer
        self.setup_actions()

        self.flowgraph_widget.setGraph(self.current_slice.get_flowgraph())
        self.navigate(self.getCurrentOffset())
        return

  def rename_slice(self, change_option_callback: Callable[[], None]):
    i = 0
    name = self.slice_menu.get_current_slice_name()
    for slicer_name, slice_name, slicer in self.slices:
      if slice_name == name:
        break
      i += 1
    else:
      assert False  # This shouldn't be possible; attempted to renaming slice that doesn't currently exist

    if (new_name := get_text_line_input("New Name", "Rename Slice").decode('utf-8')) is not None:
      self.slices[i] = (slicer_name, new_name, slicer)
      change_option_callback()
    if slice_name in self.actions:
      self.actions[new_name] = self.actions[slice_name]
      del self.actions[slice_name]
    self.switch_to_slice(new_name, self.slice_menu.menu.create_slice)

  def delete_slice(self, change_option_callback: Callable[[], None]):
    i = 0
    name = list(self.slice_menu.menu.m_menu.getActions())[self.slice_menu.menu.index]
    for _slicer_name, slice_name, _slicer in self.slices:
      if slice_name == name:
        break
      i += 1
    else:
      assert False  # This shouldn't be possible; attempted to delete slice that doesn't currently exist
    del self.slices[i]
    if slice_name in self.actions:
      del self.actions[slice_name]

    if len(self.slices) == 0:
      self.flowgraph_widget.setGraph(None)
      self.flowgraph_widget.paintEvent = self.helperPaintEvent
      self.flowgraph_widget.repaint()
    change_option_callback()

  def contextMenuEvent(self, event):
    self.contextMenuManager.show(self.contextMenu, self.actionHandler)

  def setup_actions(self):
    # Navigate is called before the view is fully initialized, so we need to check if the slice menu exists
    # TODO : Check if this is actually fixing the same issue as the other hasattr check (circular initialization)
    if not hasattr(self, 'slice_menu'):
      return

    if (current_slice_name := self.slice_menu.get_current_slice_name()) != menus.NEW_SLICE_TEXT:
      if current_slice_name in self.actions:
        for name, action, is_valid, menu_group, menu_order in self.actions[current_slice_name]:
          self.__registrate_action(name, action, is_valid, menu_group, menu_order)
        self.setup_right_click_menu()

  def setup_right_click_menu(self):
    # Right click menu in main view
    if (current_slice_name := self.slice_menu.get_current_slice_name()) != menus.NEW_SLICE_TEXT:
      if current_slice_name in self.actions:
        context = UIContext.activeContext()
        if context is not None:
          view = context.getCurrentView()
          if view is not None:
            # Our contextMenu is not callable, but normal ones are...so we can abuse that
            if callable(context_menu := view.contextMenu):
              self.disassembly_settings = view.getDisassemblySettings()  # Since we know this is the main view area, we can cache this
              context_menu = context_menu()
              for name, _, _, menu_group, menu_order in self.actions[current_slice_name]:
                context_menu.addAction(f"Tanto\\{name}", menu_group, menu_order)

  def clear_actions(self):
    # Remove from Tanto context menu
    for action in self.contextMenu.getActions().keys():
      self.actionHandler.unbindAction(action)
      self.contextMenu.removeAction(action)

    # Remove from flowgraph_widget
    for action in self.flowgraph_widget.contextMenu().getActions().keys():
      # Do NOT unbind the action or we're needlessly removing functionality! (being able to rename and a bunch of other stuff)
      # self.flowgraph_widget.actionHandler().unbindAction(action)
      self.flowgraph_widget.contextMenu().removeAction(action)

    # Remove from menu bar
    for action in UIAction.getAllRegisteredActions():
      if action.startswith("Tanto") and action != "Tanto":
        UIActionHandler.globalActions().unbindAction(action)
        UIAction.unregisterAction(action)
        Menu.mainMenu("Plugins").removeAction(action)

    # Remove from main right click menu
    if (context := UIContext.activeContext()) is not None:
      if (view := context.getCurrentView()) is not None:
        if callable(context_menu := view.contextMenu):
          context_menu = context_menu()
          self.disassembly_settings = view.getDisassemblySettings()  # Since we know this is the main view area, we can cache this

        # Remove old buttons
        for action in context_menu.getActions().keys():
          if "Tanto" in action:
            context_menu.removeAction(action)

  def __registrate_action(self, name: str, action_wrapper, is_valid_wrapper, menu_group: str = "", menu_order: int = 0):
    # Plugin Menu
    UIAction.registerAction(f"Tanto\\{name}")
    UIActionHandler.globalActions().bindAction(f"Tanto\\{name}", UIAction(action_wrapper, is_valid_wrapper))
    Menu.mainMenu("Plugins").addAction(f"Tanto\\{name}", menu_group, menu_order)

    # Right click menu in flowgraph
    UIAction.registerAction(name)
    self.actionHandler.bindAction(name, UIAction(action_wrapper, is_valid_wrapper))
    self.contextMenu.addAction(name, menu_group, menu_order)

  def __register_action(self, name: str, action_wrapper, is_valid_wrapper, menu_group: str = "", menu_order: int = 0):
    current_slice_name = self.slice_menu.get_current_slice_name()
    assert current_slice_name != menus.NEW_SLICE_TEXT  # The update cycle has a bug if this is ever hit - make sure the menu callback is called before initializing/switching to a slice
    if current_slice_name in self.actions:
      self.actions[current_slice_name].append((name, action_wrapper, is_valid_wrapper, menu_group, menu_order))
    else:
      self.actions[current_slice_name] = [(name, action_wrapper, is_valid_wrapper, menu_group, menu_order)]

  def register_for_binary_view(self, name: str,
                               action: Callable[['BinaryView'], None],
                               is_valid: Optional[Callable[['BinaryView'], bool]] = None,
                               menu_group: str = "", menu_order: int = 0):

    def _binary_view_action_wrapper(action: Callable[['BinaryView'], None], context):
      action(tanto.helpers.get_current_binary_view())

    def _binary_view_is_valid_wrapper(is_valid: Optional[Callable[['BinaryView'], bool]], context) -> bool:
      if (bv := tanto.helpers.get_current_binary_view()) is None:
        return False
      return is_valid is None or is_valid(bv)

    self.__register_action(name, partial(_binary_view_action_wrapper, action), partial(_binary_view_is_valid_wrapper, is_valid), menu_group, menu_order)

  def register_for_function(self, name: str,
                            action: Callable[['BinaryView', 'tanto.helpers.AnyFunction'], None],
                            is_valid: Optional[Callable[['BinaryView', 'tanto.helpers.AnyFunction'], bool]] = None,
                            menu_group: str = "", menu_order: int = 0):

    def _function_action_wrapper(action: Callable[['BinaryView', 'tanto.helpers.AnyFunction'], None], context):
      action(tanto.helpers.get_current_binary_view(), tanto.helpers.get_current_il_function())

    def _function_is_valid_wrapper(is_valid: Optional[Callable[['BinaryView', 'tanto.helpers.AnyFunction'], bool]], context) -> bool:
      if (bv := tanto.helpers.get_current_binary_view()) is None or (func := tanto.helpers.get_current_il_function()) is None:
        return False
      return is_valid is None or is_valid(bv, func)

    self.__register_action(name, partial(_function_action_wrapper, action), partial(_function_is_valid_wrapper, is_valid), menu_group, menu_order)

  def register_for_basic_block(self, name: str,
                               action: Callable[['BinaryView', 'tanto.helpers.AnyBasicBlock'], None],
                               is_valid: Optional[Callable[['BinaryView', 'tanto.helpers.AnyBasicBlock'], bool]] = None,
                               menu_group: str = "", menu_order: int = 0):

    def _basic_block_action_wrapper(action: Callable[['BinaryView', 'tanto.helpers.AnyBasicBlock'], None], context):
      action(tanto.helpers.get_current_binary_view(), tanto.helpers.get_current_il_basic_block())

    def _basic_block_is_valid_wrapper(is_valid: Optional[Callable[['BinaryView', 'tanto.helpers.AnyBasicBlock'], bool]], context) -> bool:
      if (bv := tanto.helpers.get_current_binary_view()) is None or (bb := tanto.helpers.get_current_il_basic_block()) is None:
        return False
      return is_valid is None or is_valid(bv, bb)

    self.__register_action(name, partial(_basic_block_action_wrapper, action), partial(_basic_block_is_valid_wrapper, is_valid), menu_group, menu_order)

  def register_for_variable(self, name: str,
                            action: Callable[['BinaryView', Variable], None],
                            is_valid: Optional[Callable[['BinaryView', Variable], bool]] = None,
                            menu_group: str = "", menu_order: int = 0):

    def _variable_action_wrapper(action: Callable[['BinaryView', Variable], None], context):
      var = Variable.from_core_variable(tanto.helpers.get_current_il_function(), context.token.localVar)
      varText = str(context.token.token)
      if "#" in varText:
        var = SSAVariable(var, int(varText.split("#")[-1]))
      action(tanto.helpers.get_current_binary_view(), var)

    def _variable_is_valid_wrapper(is_valid: Optional[Callable[['BinaryView', Variable], bool]], context) -> bool:
      if (bv := tanto.helpers.get_current_binary_view()) is None or not context.token.localVarValid or (var := context.token.localVar) is None or (func := tanto.helpers.get_current_il_function()) is None:
        return False
      varText = str(context.token.token)
      if "#" in varText:
        var = SSAVariable(var, int(varText.split("#")[-1]))
      return is_valid is None or is_valid(bv, Variable.from_core_variable(func, var))

    self.__register_action(name, partial(_variable_action_wrapper, action), partial(_variable_is_valid_wrapper, is_valid), menu_group, menu_order)

  def register_for_address(self, name: str,
                           action: Callable[['BinaryView', int], None],
                           is_valid: Optional[Callable[['BinaryView', int], bool]] = None,
                           menu_group: str = "", menu_order: int = 0):

    def _addr_action_wrapper(action: Callable[['BinaryView', int], None], context):
      action(tanto.helpers.get_current_binary_view(), context.address)

    def _addr_is_valid_wrapper(is_valid: Optional[Callable[['BinaryView', int], bool]], context) -> bool:
      if (bv := tanto.helpers.get_current_binary_view()) is None or (addr := context.address) is None:
        return False
      return is_valid is None or is_valid(bv, addr)

    self.__register_action(name, partial(_addr_action_wrapper, action), partial(_addr_is_valid_wrapper, is_valid), menu_group, menu_order)


# Implements a ViewType; This gets initialized by binaryninja at startup and
# lives for the life of the program. I use this to store state for each file
# since the actual view/pane only lives for the duration you see it. And I'm
# not in the business of losing people's analysis data**! (**See TODO below)

# TODO : Save slices to DB (is there an on-save callback or would I write to
# the plugin metadata thing directly so it shows the 'unsaved changes' dot?)

# TODO : All the FlowGraphWidgets get deleted when the view is closed???
class TantoViewType(ViewType):
  def __init__(self):
    super().__init__("Tanto", "Tanto")
    self.data = {}

  def getPriority(self, bv: BinaryView, filename: str) -> int:
    return 1

  def create(self, bv: BinaryView, view_frame: ViewFrame) -> View:
    # TODO : Drop analysis data on bv close : Register a callback to run on bv close?

    if bv.file.session_id not in self.data:
      self.data[bv.file.session_id] = ([], Logger(bv.file.session_id, "Tanto"))
    return TantoView(view_frame, bv, *self.data[bv.file.session_id])

```