Project Path: arc_badabing2005_PixelFlasher_o7d5th35

Source Tree:

```txt
arc_badabing2005_PixelFlasher_o7d5th35
├── About.py
├── LICENSE
├── Main.py
├── PixelFlasher.crt
├── PixelFlasher.py
├── README.md
├── advanced_settings.py
├── android_devices.json
├── android_versions.json
├── apk.py
├── avbtool.py
├── backup_manager.py
├── bin
│   ├── 7z.dll
│   ├── 7z.exe
│   ├── 7zz
│   ├── 7zzl
│   ├── 7zzs
│   ├── aapt2_arm64-v8a
│   ├── aapt2_armeabi-v7a
│   ├── aapt2_x86
│   ├── aapt2_x86_64
│   ├── avbctl
│   ├── busybox_arm64-v8a
│   ├── busybox_armeabi-v7a
│   ├── busybox_x86
│   ├── busybox_x86_64
│   ├── update_engine_client_r28
│   └── update_engine_client_r72
├── build-on-linux.spec
├── build-on-mac-intel-only.spec
├── build-on-mac.spec
├── build-on-win-arm64.spec
├── build-on-win.spec
├── build.bat
├── build.sh
├── ca_badabing2005.crt
├── check_translations.py
├── compile_po.py
├── config.py
├── constants.py
├── custom_controls.py
├── device_selector.py
├── download_progress.py
├── encode-bitmaps.py
├── factory_image_selector.py
├── file_editor.py
├── i18n.py
├── images
│   ├── Magisk-Backup-Manager.png
│   ├── Magisk-Installer.png
│   ├── PF_promo-banner-dark.png
│   ├── PF_promo-banner-small-dark.png
│   ├── PF_promo-banner-small.png
│   ├── PF_promo-banner.png
│   ├── Package-Manager.png
│   ├── Patching boot.png
│   ├── about-24.png
│   ├── about-64.png
│   ├── add-24.png
│   ├── advanced-config-24.png
│   ├── advanced-config-64.png
│   ├── advanced-gui.png
│   ├── advanced-options.png
│   ├── alert-gray-24.png
│   ├── alert-green-24.png
│   ├── alert-red-24.png
│   ├── all-betas-24.png
│   ├── analyze-24.png
│   ├── analyze-64.png
│   ├── android-24.png
│   ├── apatch-16.png
│   ├── apatch-24.png
│   ├── apatch-48.png
│   ├── axml-24.png
│   ├── backup-24.png
│   ├── backup-64.png
│   ├── basic-gui.png
│   ├── beta-24.png
│   ├── blank.png
│   ├── boot-24.png
│   ├── bootloader-versions-24.png
│   ├── bottom-24.png
│   ├── bug-24.png
│   ├── canary-24.png
│   ├── cancel-ota-24.png
│   ├── cert-24.png
│   ├── check-24.png
│   ├── check-otacerts-24.png
│   ├── circle-gray-24.png
│   ├── circle-green-24.png
│   ├── circle-red-24.png
│   ├── clear-24.png
│   ├── clipboard-24.png
│   ├── cloud-24.png
│   ├── cloud-download-24.png
│   ├── custom-patch-24.png
│   ├── delete-24.png
│   ├── disable-24.png
│   ├── downgrade-16.png
│   ├── downgrade-24.png
│   ├── download-16.png
│   ├── download-24.png
│   ├── e2j-24.png
│   ├── enable-24.png
│   ├── exit-24.png
│   ├── factory-24.png
│   ├── feature-24.png
│   ├── file-menu.png
│   ├── flash-24.png
│   ├── flash-32.png
│   ├── folder-24.png
│   ├── folder-zip-24.png
│   ├── forum-24.png
│   ├── github-24.png
│   ├── google-24.png
│   ├── google_images.png
│   ├── guide-24.png
│   ├── heart-gray-24.png
│   ├── heart-red-24.png
│   ├── help-menu.png
│   ├── icon-1024.icns
│   ├── icon-128.png
│   ├── icon-256.icns
│   ├── icon-256.ico
│   ├── icon-256.png
│   ├── icon-64.png
│   ├── icon-dark-128.png
│   ├── icon-dark-256.icns
│   ├── icon-dark-256.ico
│   ├── icon-dark-256.png
│   ├── icon-dark-64.png
│   ├── import-24.png
│   ├── install-apk-24.png
│   ├── install-apk-64.png
│   ├── install-magisk-24.png
│   ├── install-magisk-64.png
│   ├── j2e-24.png
│   ├── java-24.png
│   ├── json-24.png
│   ├── kernelsu-16.png
│   ├── kernelsu-24.png
│   ├── kernelsu-48.png
│   ├── kernelsu-next-16.png
│   ├── kernelsu-next-24.png
│   ├── kernelsu-next-48.png
│   ├── kill-24.png
│   ├── launch-24.png
│   ├── left-24.png
│   ├── lock-24.png
│   ├── lock-64.png
│   ├── logcat-24.png
│   ├── magisk-16.png
│   ├── magisk-24.png
│   ├── magisk-48.png
│   ├── magisk-64.png
│   ├── magisk-modules-manager.png
│   ├── magisk-settings.png
│   ├── official-16.png
│   ├── official-24.png
│   ├── open-link-16.png
│   ├── open-link-24.png
│   ├── open-link-red-24.png
│   ├── open-url-24.png
│   ├── packages-24.png
│   ├── packages-64.png
│   ├── partition-24.png
│   ├── partition-64.png
│   ├── paste-24.png
│   ├── paste-down-24.png
│   ├── paste-up-24.png
│   ├── patch-24.png
│   ├── patched-16.png
│   ├── patched-24.png
│   ├── permissions-24.png
│   ├── phone-blue-24.png
│   ├── phone-green-24.png
│   ├── pif
│   │   ├── create1.png
│   │   ├── favorites1.png
│   │   ├── favorites2.png
│   │   ├── favorites3.png
│   │   ├── install1.png
│   │   ├── paste1.png
│   │   ├── process_build1.png
│   │   ├── smart_paste1.png
│   │   ├── test1.png
│   │   └── workflow1.png
│   ├── pif-24.png
│   ├── pif-64.png
│   ├── popup-menu.png
│   ├── process_file-24.png
│   ├── push-24.png
│   ├── push-cart-24.png
│   ├── reboot-24.png
│   ├── reboot-64.png
│   ├── reboot-bootloader-24.png
│   ├── reboot-bootloader-64.png
│   ├── reboot-download-24.png
│   ├── reboot-download-64.png
│   ├── reboot-fastbootd-24.png
│   ├── reboot-fastbootd-64.png
│   ├── reboot-irecovery-24.png
│   ├── reboot-irecovery-64.png
│   ├── reboot-recovery-24.png
│   ├── reboot-recovery-64.png
│   ├── reboot-safe-mode-24.png
│   ├── reboot-safe-mode-64.png
│   ├── reboot-sideload-24.png
│   ├── reboot-sideload-64.png
│   ├── reboot-system-24.png
│   ├── reboot-system-64.png
│   ├── restore-24.png
│   ├── right-24.png
│   ├── rooted.png
│   ├── save-24.png
│   ├── scan-24.png
│   ├── scan-all-24.png
│   ├── scrcpy-24.png
│   ├── scrcpy-64.png
│   ├── settings-24.png
│   ├── settings-64.png
│   ├── shell-24.png
│   ├── shell-64-disabled.png
│   ├── shell-64.png
│   ├── shell-root.png
│   ├── shield-24.png
│   ├── shield-64.png
│   ├── shizuku-24.png
│   ├── slot-a-48.png
│   ├── slot-b-48.png
│   ├── smart-paste-up-24.png
│   ├── sos-24.png
│   ├── sos-64.png
│   ├── splash-dark.png
│   ├── splash.png
│   ├── star-green-24.png
│   ├── su-permissions.png
│   ├── sukisu-16.png
│   ├── sukisu-24.png
│   ├── sukisu-48.png
│   ├── support-24.png
│   ├── switch-slot-24.png
│   ├── switch-slot-64.png
│   ├── top-24.png
│   ├── uncheck-24.png
│   ├── uninstall-24.png
│   ├── unlock-24.png
│   ├── unlock-64.png
│   ├── update-check-24.png
│   ├── watch-blue-24.png
│   ├── watch-green-24.png
│   ├── wifi-adb-24.png
│   ├── wifi-adb_alt-24.png
│   ├── wifi-adb_alt2-24.png
│   ├── wild_ksu-16.png
│   ├── wild_ksu-24.png
│   ├── wild_ksu-48.png
│   ├── wrench-24.png
│   └── xml-24.png
├── images.py
├── ksu_asset_selector.py
├── locale
│   ├── en
│   │   └── LC_MESSAGES
│   │       └── pixelflasher.po
│   ├── es
│   │   └── LC_MESSAGES
│   │       └── pixelflasher.po
│   ├── fr
│   │   └── LC_MESSAGES
│   │       └── pixelflasher.po
│   ├── it
│   │   └── LC_MESSAGES
│   │       └── pixelflasher.po
│   ├── zh_CN
│   │   └── LC_MESSAGES
│   │       └── pixelflasher.po
│   └── zh_TW
│       └── LC_MESSAGES
│           └── pixelflasher.po
├── logcat.py
├── magisk_downloads.py
├── magisk_modules.py
├── manage_devices.py
├── message_box_ex.py
├── my_tools.py
├── package_manager.py
├── partition_manager.py
├── payload_dumper.py
├── pf_modules.py
├── phone.py
├── pif_manager.py
├── pyi-hooks-arm64
│   └── hook-wx.py
├── requirements.txt
├── runtime.py
├── set_version.py
├── testkey_rsa4096.pem
├── update_metadata_pb2.py
├── wifi.py
├── windows-metadata.yaml
└── windows-version-info.txt

```

`About.py`:

```py
#!/usr/bin/env python
# coding=utf-8

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import datetime
import wx
import wx.html
import wx.lib.wxpTag
import webbrowser
from constants import *
from runtime import get_bundle_dir
from runtime import check_latest_version
from packaging.version import parse

class AboutDlg(wx.Dialog):
    text = '''
<html>
<body bgcolor="#DCDCDC" style="font-family: Arial; background-color: #DCDCDC;">
<center>
    <img src="{0}/images/icon-dark-64.png" width="64" height="64" alt="PixelFlasher">

    <h1>PixelFlasher</h1>
    <p>By Badabing</p>
    <h3>Version {1}</h3>

    {2}

    <p>Fork the <a style="color: #004CE5;" href="https://github.com/badabing2005/PixelFlasher/fork">project on
    GitHub</a> and help improve it for all!</p>

    <p> Beware! </p>
    <p> If you are asked to donate or pay money for this program, check your source. </p>
    <p> This program is free, will always remain totally free, ad free, even donation free.</p>

    <p>
        <wxp module="wx" class="Button">
            <param name="label" value="Close">
            <param name="id" value="ID_OK">
        </wxp>
    </p>
</center>
</body>
</html>
'''

    def __init__(self, parent):
        wx.Dialog.__init__(self, parent, wx.ID_ANY, "About PixelFlasher")
        html = HtmlWindow(self, wx.ID_ANY, size=(420, -1))
        if "gtk2" in wx.PlatformInfo or "gtk3" in wx.PlatformInfo:
            html.SetStandardFonts()

        # check version if we are running the latest
        l_version = check_latest_version()
        if parse(VERSION) < parse(l_version):
            update_text = f"<p><b>Update </b> <a style=\"color: #004CE5;\" href=\"https://github.com/badabing2005/PixelFlasher/releases/latest\">Version v{l_version}</a> is available.</p>"
        else:
            update_text = "<p> You're up to date! </p>"

        txt = self.text.format(get_bundle_dir(), VERSION, update_text, datetime.datetime.now().year)
        html.SetPage(txt)
        ir = html.GetInternalRepresentation()
        html.SetSize((ir.GetWidth() + 25, ir.GetHeight() + 25))
        self.SetClientSize(html.GetSize())
        self.CentreOnParent(wx.BOTH)


class HtmlWindow(wx.html.HtmlWindow):
    def OnLinkClicked(self, link):
        webbrowser.open(link.GetHref())


```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`Main.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import argparse
import contextlib
import ctypes
import json
import locale
import math
import ntpath
import os
import sys
import time
import traceback
import webbrowser
import threading
from datetime import datetime, timedelta
from urllib.parse import urlparse
import darkdetect
import wx
import wx.adv
import wx.lib.agw.aui as aui
import wx.lib.inspection
import wx.lib.mixins.inspection
import wx.lib.buttons as buttons
from packaging.version import parse

import images as images
import cProfile, pstats

with contextlib.suppress(Exception):
    ctypes.windll.shcore.SetProcessDpiAwareness(True)

from config import Config
from custom_controls import *

# see https://discuss.wxpython.org/t/wxpython4-1-1-python3-8-locale-wxassertionerror/35168
locale.setlocale(locale.LC_ALL, 'C')
# Initialize translations before any UI code executes
from i18n import _, get_available_languages, get_language, set_language, initialize_translations

from advanced_settings import AdvancedSettings
from backup_manager import BackupManager
from wifi import Wireless
from constants import *
from magisk_downloads import MagiskDownloads
from magisk_modules import MagiskModules
from pif_manager import PifManager
from message_box_ex import MessageBoxEx
from pf_modules import (adb_kill_server, auto_resize_boot_list,
    check_platform_tools, flash_phone, live_flash_boot_phone,
    patch_boot_img, populate_boot_list, process_file, kb_stats_ui,
    select_firmware, set_flash_button_state, setup_for_downgrade,
    get_all_dialog_values)
from package_manager import PackageManager
from partition_manager import PartitionManager
from phone import get_connected_devices, update_phones
from runtime import *
from my_tools import MyToolsDialog
from logcat import LogcatDialog
from manage_devices import ManageDevicesDialog


# For troubleshooting, set inspector = True
inspector = False
dont_initialize = False
do_profiling = False

# Declare global_args at the global scope
global_args = None

# Initialize language and translations
lang = get_language()
initialize_translations()

# Links menu data structure
LINKS_MENU_DATA = [
    # Format: (label, image_name, url)
    # Guides
    (_("Homeboy76's Guide"), "guide_24", "https://xdaforums.com/t/guide-november-6-2023-root-pixel-8-pro-unlock-bootloader-pass-safetynet-both-slots-bootable-more.4638510/#post-89128833/"),
    (_("V0latyle's Guide"), "guide_24", "https://xdaforums.com/t/guide-root-pixel-6-oriole-with-magisk.4356233/"),
    (_("roirraW's Guide"), "guide_24", "https://xdaforums.com/t/december-5-2022-tq1a-221205-011-global-012-o2-uk-unlock-bootloader-root-pixel-7-pro-cheetah-safetynet.4502805/"),
    None,  # Separator
    # FAQ and info
    (_("osm0sis's PIF FAQ"), "forum_24", "https://xdaforums.com/t/pif-faq.4653307/"),
    (_("V0latyle's PI API Info"), "forum_24", "https://xdaforums.com/t/info-play-integrity-api-replacement-for-safetynet.4479337"),
    (_("chiteroman's PlayIntegrityFix"), "forum_24", "https://xdaforums.com/t/module-play-integrity-fix-safetynet-fix.4607985"),
    (_("Tricky Store (Support Thread)"), "forum_24", "https://xdaforums.com/t/tricky-store-bootloader-keybox-spoofing.4683446"),
    None,  # Separator
    # GitHub repos
    (_("osm0sis's PlayIntegrityFork"), "github_24", "https://github.com/osm0sis/PlayIntegrityFork"),
    # (_("chiteroman's PlayIntegrityFix"), "github_24", "https://github.com/chiteroman/PlayIntegrityFix"),
    (_("5ec1cff's TrickyStore"), "github_24", "https://github.com/5ec1cff/TrickyStore"),
    None,  # Separator
    # References
    (_("Get the Google USB Driver"), "android_24", "https://developer.android.com/studio/run/win-usb?authuser=1%2F"),
    (_("Android Security Update Bulletins"), "android_24", "https://source.android.com/docs/security/bulletin/"),
    (_("Android Codenames, tags, and build numbers"), "android_24", "https://source.android.com/docs/setup/reference/build-numbers"),
    None,  # Separator
    # Device images
    (_("Full OTA Images for Pixel Phones / Tablets"), "google_24", 'https://developers.google.com/android/ota'),
    (_("Factory Images for Pixel Phones / Tablets"), "google_24", 'https://developers.google.com/android/ota'),
    (_("Full OTA Images for Pixel Watches"), "google_24", 'https://developers.google.com/android/ota-watch'),
    (_("Factory Images for Pixel Watches"), "google_24", 'https://developers.google.com/android/images-watch'),
    None,  # Separator
    # Beta images
    (_("Full OTA Images for Pixel Beta 16"), "android_24", 'https://developer.android.com/about/versions/16/download-ota'),
    (_("Factory Images for Pixel Beta 16"), "android_24", 'https://developer.android.com/about/versions/16/download'),
]

# Help menu URLs and descriptions
HELP_MENU_ITEMS = {
    "issue": {
        "url": "https://github.com/badabing2005/PixelFlasher/issues/new",
        "description": _("Report an Issue")
    },
    "feature": {
        "url": "https://github.com/badabing2005/PixelFlasher/issues/new",
        "description": _("Feature Request")
    },
    "project": {
        "url": "https://github.com/badabing2005/PixelFlasher",
        "description": _("PixelFlasher Project Page")
    },
    "forum": {
        "url": "https://xdaforums.com/t/pixelflasher-gui-tool-that-facilitates-flashing-updating-pixel-phones.4415453/",
        "description": _("PixelFlasher Community (Forum)")
    }
}


# ============================================================================
#                               Class RedirectText
# ============================================================================
class RedirectText():
    def __init__(self, aWxTextCtrl):
        self.out = aWxTextCtrl
        self.logfile_stack = []
        self.original_logfile_path = os.path.join(get_config_path(), 'logs', f"PixelFlasher_{datetime.now():%Y-%m-%d_%Hh%Mm%Ss}.log")
        self.logfile = open(self.original_logfile_path, "w", buffering=1, encoding="utf-8", errors="replace")
        self.logfile_stack.append(self.original_logfile_path)
        set_logfile(self.original_logfile_path)

    def write(self, string):
        global global_args
        if hasattr(global_args, 'console_only') and global_args.console_only and sys.platform != "win32":
            # If --console-only is set, redirect output only to the console
            sys.__stdout__.write(string)
        else:
            # Otherwise, redirect output to the text control, the console (if --console is set), and the logfile
            wx.CallAfter(self.out.AppendText, string)
            if hasattr(global_args, 'console') and global_args.console and sys.platform != "win32":
                sys.__stdout__.write(string)
            if not self.logfile.closed:
                self.logfile.write(string)
                self.logfile.flush()

    # # noinspection PyMethodMayBeStatic
    # def flush(self):
    #     # noinspection PyStatementEffect
    #     None

    def flush(self):
        if not self.logfile.closed:
            self.logfile.flush()

    def close(self):
        if not self.logfile.closed:
            self.logfile.close()

    def set_logfile(self, new_logfile_path):
        """Set a new logfile and close the current one if open."""
        self.flush()
        self.close()
        self.logfile = open(new_logfile_path, "w", buffering=1, encoding="utf-8", errors="replace")
        self.logfile_stack.append(new_logfile_path)
        set_logfile(new_logfile_path)

    def reset_logfile(self):
        """Reset to the previous logfile."""
        if len(self.logfile_stack) > 1:
            self.flush()
            self.close()
            self.logfile_stack.pop()  # Remove the current logfile
            previous_logfile_path = self.logfile_stack[-1]
            self.logfile = open(previous_logfile_path, "a", buffering=1, encoding="utf-8", errors="replace")
            set_logfile(previous_logfile_path)

# ============================================================================
#                               Class GoogleImagesBaseMenu
# ============================================================================
class GoogleImagesBaseMenu(wx.Menu):
    BASE_MENU_ID_START = 5000

    def __init__(self, parent):
        super(GoogleImagesBaseMenu, self).__init__()

        self.parent = parent
        self.load_data()
        self.current_menu_id = self.BASE_MENU_ID_START
        self.progress_window = None

    def generate_unique_id(self):
        unique_id = self.current_menu_id
        while unique_id in[wx.ID_EXIT, wx.ID_ABOUT, wx.ID_PREFERENCES]:
            self.current_menu_id += 1
            unique_id = self.current_menu_id
        self.current_menu_id += 1
        return unique_id

    def reset_menu_id(self):
        self.current_menu_id = self.BASE_MENU_ID_START

    def bind_download_event(self, menu, url):
        if menu is None:
            print(f"Error: menu is None when adding menu item for {url}")
            return
        unique_id = self.generate_unique_id()
        # next line is for debugging
        # menu.SetItemLabel(f"{menu.GetItemLabel()} ({unique_id})")
        def on_download_handler(event):
            self.on_download(url, event, unique_id)

        menu_id = menu.GetId()
        self.parent.Bind(wx.EVT_MENU, on_download_handler, id=menu_id)

    def load_data(self):
        json_file_path = os.path.join(get_config_path(), "google_images.json").strip()
        if not os.path.exists(json_file_path) or self.is_data_update_required():
            get_google_images()
            self.parent.config.google_images_last_checked = int(datetime.now().timestamp())
        try:
            with open(json_file_path, 'r', encoding='utf-8') as json_file:
                self.data = json.load(json_file)
        except FileNotFoundError:
            print("google_images.json file not found.")
            self.data = {}

    def is_data_update_required(self):
        last_checked = self.parent.config.google_images_last_checked
        update_frequency = self.parent.config.google_images_update_frequency
        # don't check for updates if it is set to -1
        if update_frequency == -1:
            return False
        if last_checked is None:
            return True
        current_time = int(datetime.now().timestamp())
        update_threshold = current_time - (update_frequency * 24 * 60 * 60)
        return last_checked < update_threshold

    def get_progress_window(self):
        return self.parent.get_progress_window()

    def download_with_progress(self, url, destination_path, callback):
        progress_window = self.get_progress_window()
        filename = os.path.basename(destination_path)
        gauge, cancel_button = progress_window.add_download(url, filename)

        cancel_flag = {'cancelled': False}
        # Store file handle to ensure proper cleanup
        file_handle = {'f': None}

        def on_cancel(event):
            cancel_flag['cancelled'] = True
            print(f"Download cancelled for: {url}")
            try:
                # Close file handle if it exists
                if file_handle['f']:
                    file_handle['f'].close()
                    file_handle['f'] = None

                # Small delay to ensure file operations complete
                time.sleep(0.1)

                if os.path.exists(destination_path):
                    try:
                        # Close any remaining handles
                        os.close(os.open(destination_path, os.O_RDONLY))
                    except:
                        pass
                    try:
                        print(f"Deleting partial download: {destination_path}")
                        os.remove(destination_path)
                    except Exception as e:
                        print(f"Error deleting partial download: {e}")
            except Exception as e:
                print(f"Error in cleanup: {e}")
            try:
                wx.CallAfter(progress_window.remove_download, url)
            except Exception as e:
                print(f"Error removing download from UI: {e}")

        cancel_button.Bind(wx.EVT_BUTTON, on_cancel)

        def update_gauge(value):
            try:
                if not cancel_flag['cancelled'] and gauge:
                    gauge.SetValue(value)
            except Exception:
                pass

        def download_thread():
            try:
                response = requests.get(url, stream=True)
                total_length = int(response.headers.get('content-length', 0))
                downloaded = 0

                with open(destination_path, 'wb') as f:
                    # Store file handle for cleanup
                    file_handle['f'] = f
                    for chunk in response.iter_content(chunk_size=4096):
                        if cancel_flag['cancelled']:
                            f.close()
                            return
                        if chunk:
                            downloaded += len(chunk)
                            f.write(chunk)
                            if total_length:
                                try:
                                    wx.CallAfter(update_gauge, int(100 * downloaded / total_length))
                                except Exception:
                                    pass
                    # Clear file handle reference
                    file_handle['f'] = None

                if not cancel_flag['cancelled']:
                    try:
                        wx.CallAfter(progress_window.remove_download, url)
                        wx.CallAfter(callback)
                    except Exception as e:
                        print(f"Error in download completion: {e}")
            except Exception as e:
                print(f"Download error: {e}")
                try:
                    wx.CallAfter(progress_window.remove_download, url)
                except Exception:
                    pass
                # Ensure file handle is closed
                if file_handle['f']:
                    file_handle['f'].close()
                    file_handle['f'] = None
                # Small delay before deletion
                time.sleep(0.1)
                if os.path.exists(destination_path):
                    try:
                        os.close(os.open(destination_path, os.O_RDONLY))
                        os.remove(destination_path)
                    except Exception as e:
                        print(f"Error cleaning up failed download: {e}")

        threading.Thread(target=download_thread).start()

    def on_download(self, url, event=None, unique_id=any):
        # debug(f"Download triggered for URL: {url}, Menu ID: {unique_id}")
        def download_completed(destination_path):
            self.parent.toast(_("Download Successful"), _("✅ File downloaded successfully: %s and saved to %s") % (url, destination_path))
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Download Successful", f"File downloaded successfully: {url} and saved to {destination_path}")
            # self.parent.firmware_picker.SetPath(destination_path)
            # self.parent.update_firmware_selection(destination_path)

        filename = os.path.basename(url)
        print(f"User selected {url} for download")
        dialog = wx.FileDialog(None, _("Save File"), defaultFile=filename, wildcard="All files (*.*)|*.*", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
        if dialog.ShowModal() == wx.ID_OK:
            destination_path = dialog.GetPath()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Starting background download for: {url} to be saved to {destination_path}\nplease be patient ...")
            self.download_with_progress(url, destination_path, lambda: download_completed(destination_path))

    def on_refresh_google_images(self, event):
        print("Refreshing Google Images Menu ...")
        self.parent._on_spin('start')
        self.parent.config.google_images_last_checked = False
        # Refresh the Google Images menu
        self.parent.update_google_images_menu()
        print("Completed refreshing Google Images Menu.")
        self.parent._on_spin('stop')

    def on_show_progress_window(self, event):
        if self.progress_window:
            self.progress_window.Show()
        else:
            self.parent.toast(_("No Downloads"), _("ℹ️ No downloads are in progress."))

# ============================================================================
#                               Class GoogleImagesMenu
# ============================================================================
class GoogleImagesMenu(GoogleImagesBaseMenu):
    def __init__(self, parent):
        super(GoogleImagesMenu, self).__init__(parent)

        try:
            self.phones_menu = wx.Menu()
            self.watches_menu = wx.Menu()
            device = get_phone()
            device_hardware = None
            device_firmware_date = None
            download_available = False
            phone_icon = images.phone_green_24.GetBitmap()
            watch_icon = images.watch_green_24.GetBitmap()
            device_icon = images.star_green_24.GetBitmap()
            if hasattr(self.parent, 'firmware_button') and self.parent.firmware_button:
                self.parent.firmware_button.SetBitmap(images.open_link_24.GetBitmap())

            if device:
                device_hardware = device.hardware
                device_firmware_date = device.firmware_date

            for device_id, device_data in self.data.items():
                device_label = device_data['label']
                device_type = device_data['type']
                device_menu = wx.Menu()
                device_download_flag = False

                # Handle OTA and Factory downloads
                for download_type in ['ota', 'factory']:
                    download_menu = wx.Menu()

                    for download_entry in reversed(device_data[download_type]):
                        version = download_entry['version']
                        sha256 = download_entry['sha256']
                        menu_label = f"{version} ({device_label})"
                        menu_id = self.generate_unique_id()
                        download_menu_item = download_menu.Append(menu_id, menu_label, sha256)
                        if download_menu_item is None:
                            print(f"Failed to create menu item with id {menu_id}, label {menu_label}, and sha256 {sha256}")
                        else:
                            download_date = download_entry['date']
                            # Set the background color and the icon for the current device. (background color is not working)
                            if device_id == device_hardware and device_firmware_date and download_date and int(download_date) > int(device_firmware_date):
                                download_menu_item.SetBackgroundColour((100, 155, 139, 255))
                                download_menu_item.SetBitmap(images.download_24.GetBitmap())
                                device_download_flag = True
                                download_available = True
                                device_icon = images.download_24.GetBitmap()
                                if device_type == "phone":
                                    phone_icon = images.download_24.GetBitmap()
                                elif device_type == "watch":
                                    watch_icon = images.download_24.GetBitmap()

                            url = download_entry['url']
                            self.bind_download_event(download_menu_item, url)

                    download_type_menu_item = device_menu.AppendSubMenu(download_menu, download_type.capitalize())
                    if download_type == "ota":
                        download_type_menu_item.SetBitmap(images.cloud_24.GetBitmap())
                    elif download_type == "factory":
                        download_type_menu_item.SetBitmap(images.factory_24.GetBitmap())

                    if device_download_flag:
                        download_type_menu_item.SetBitmap(images.download_24.GetBitmap())

                # Handle Beta downloads if they exist
                if 'beta' in device_data:
                    beta_menu = wx.Menu()
                    for beta_entry in device_data['beta']:
                        version = beta_entry['version']
                        sha256 = beta_entry['sha256']
                        menu_label = f"{version} ({device_label})"
                        menu_id = self.generate_unique_id()
                        beta_menu_item = beta_menu.Append(menu_id, menu_label, sha256)
                        if beta_menu_item is not None:
                            url = beta_entry['url']
                            self.bind_download_event(beta_menu_item, url)
                            beta_menu_item.SetBitmap(images.beta_24.GetBitmap())

                    beta_menu_item = device_menu.AppendSubMenu(beta_menu, "Beta")
                    beta_menu_item.SetBitmap(images.beta_24.GetBitmap())

                # Handle Canary downloads if they exist
                if 'canaries' in device_data:
                    canary_menu = wx.Menu()
                    for canary_entry in device_data['canaries']:
                        version = canary_entry.get('version')
                        sha256 = canary_entry.get('sha256')
                        menu_label = f"{version} ({device_label})"
                        menu_id = self.generate_unique_id()
                        canary_menu_item = canary_menu.Append(menu_id, menu_label, sha256)
                        if canary_menu_item is not None:
                            url = canary_entry.get('url')
                            self.bind_download_event(canary_menu_item, url)
                            canary_menu_item.SetBitmap(images.canary_24.GetBitmap())
                    canary_menu_item = device_menu.AppendSubMenu(canary_menu, "Canary - Factory")
                    canary_menu_item.SetBitmap(images.canary_24.GetBitmap())

                # Handle All Betas submenu
                if 'betas' in device_data:
                    all_betas_menu = wx.Menu()
                    for beta_entry in device_data['betas']:
                        version = beta_entry.get('version')
                        sha256 = beta_entry.get('sha256')
                        menu_label = f"{version} ({device_label})"
                        menu_id = self.generate_unique_id()
                        all_betas_menu_item = all_betas_menu.Append(menu_id, menu_label, sha256)
                        if all_betas_menu_item is not None:
                            url = beta_entry.get('url')
                            self.bind_download_event(all_betas_menu_item, url)
                            all_betas_menu_item.SetBitmap(images.all_betas_24.GetBitmap())
                    all_betas_menu_item = device_menu.AppendSubMenu(all_betas_menu, "All Betas - Factory")
                    all_betas_menu_item.SetBitmap(images.all_betas_24.GetBitmap())

                if device_type == 'phone':
                    device_menu_item = self.phones_menu.AppendSubMenu(device_menu, f"{device_id} ({device_label})")
                    # Set the background color and the icon for the current device. (background color is not working)
                    if device_id == device_hardware:
                        device_menu_item.SetBitmap(device_icon)
                        device_menu_item.SetBackgroundColour((100, 155, 139, 255))
                elif device_type == 'watch':
                    device_menu_item = self.watches_menu.AppendSubMenu(device_menu, f"{device_id} ({device_label})")
                    # Set the background color and the icon for the current device. (background color is not working)
                    if device_id == device_hardware:
                        device_menu_item.SetBitmap(device_icon)
                        device_menu_item.SetBackgroundColour((100, 155, 139, 255))

            phone_menu_item = self.AppendSubMenu(self.phones_menu, _("Phones"))
            phone_menu_item.SetBitmap(phone_icon)
            watches_menu_item = self.AppendSubMenu(self.watches_menu, _("Watches"))
            watches_menu_item.SetBitmap(watch_icon)
            self.AppendSeparator()
            refresh_images_menu_item = self.Append(wx.ID_ANY, _("Refresh images list"))
            self.Bind(wx.EVT_MENU, self.on_refresh_google_images, refresh_images_menu_item)
            self.AppendSeparator()
            show_progress_menu_item = self.Append(wx.ID_ANY, _("Show Progress Window"))
            self.Bind(wx.EVT_MENU, self.on_show_progress_window, show_progress_menu_item)

            if download_available:
                self.parent.toast(_("Updates are available"), _("ℹ️ There are updates available for your device.\nCheck Google Images menu."))
                if hasattr(self.parent, 'firmware_button') and self.parent.firmware_button:
                    self.parent.firmware_button.SetBitmap(images.open_link_red_24.GetBitmap())

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while building Google Images Menu.")
            traceback.print_exc()

# ============================================================================
#                               Class GoogleImagesPopupMenu
# ============================================================================
class GoogleImagesPopupMenu(GoogleImagesBaseMenu):
    def __init__(self, parent, device=None, date_filter=None):
        super(GoogleImagesPopupMenu, self).__init__(parent)

        try:
            if device in self.data:
                device_data = self.data[device]

                submenu_ota = wx.Menu()
                submenu_factory = wx.Menu()
                submenu_beta = wx.Menu() if 'beta' in device_data else None
                download_flag = False

                for download_entry in reversed(device_data['ota']):
                    if download_entry['date'] is not None and (not date_filter or (date_filter is not None and int(download_entry['date']) >= int(date_filter))):
                        version = download_entry['version']
                        menu_label = f"{version} (OTA)"
                        menu_id = wx.NewId()
                        menu_item = submenu_ota.Append(menu_id, menu_label)
                        self.parent.Bind(wx.EVT_MENU, lambda event, u=download_entry['url']: self.on_download(u), menu_item)
                        if date_filter and int(download_entry['date']) != int(date_filter):
                            menu_item.SetBitmap(images.download_24.GetBitmap())
                            download_flag = True

                for download_entry in reversed(device_data['factory']):
                    if download_entry['date'] is not None and (not date_filter or (date_filter is not None and int(download_entry['date']) >= int(date_filter))):
                        version = download_entry['version']
                        menu_label = f"{version} (Factory)"
                        menu_id = wx.NewId()
                        menu_item = submenu_factory.Append(menu_id, menu_label)
                        self.parent.Bind(wx.EVT_MENU, lambda event, u=download_entry['url']: self.on_download(u), menu_item)
                        if date_filter and int(download_entry['date']) != int(date_filter):
                            menu_item.SetBitmap(images.download_24.GetBitmap())
                            download_flag = True

                # Add Beta submenu if beta data exists
                if submenu_beta and 'beta' in device_data:
                    for beta_entry in device_data['beta']:
                        version = beta_entry['version']
                        menu_label = f"{version}"
                        menu_id = wx.NewId()
                        menu_item = submenu_beta.Append(menu_id, menu_label)
                        self.parent.Bind(wx.EVT_MENU, lambda event, u=beta_entry['url']: self.on_download(u), menu_item)
                        menu_item.SetBitmap(images.beta_24.GetBitmap())

                # Add Canary submenu if canary data exists (apply date filter)
                submenu_canary = wx.Menu() if 'canaries' in device_data else None
                if submenu_canary and 'canaries' in device_data:
                    for canary_entry in device_data['canaries']:
                        entry_date = canary_entry.get('date')
                        # only include canary entries that have a parsable date and are not older than the current device firmware
                        if entry_date is not None and (not date_filter or (date_filter is not None and int(entry_date) >= int(date_filter))):
                            version = canary_entry.get('version')
                            menu_label = f"{version}"
                            menu_id = wx.NewId()
                            menu_item = submenu_canary.Append(menu_id, menu_label)
                            self.parent.Bind(wx.EVT_MENU, lambda event, u=canary_entry.get('url'): self.on_download(u), menu_item)
                            # mark as downloadable if it's newer than the installed build
                            if date_filter and int(entry_date) != int(date_filter):
                                menu_item.SetBitmap(images.download_24.GetBitmap())
                                # prefer canary icon but show download badge semantics by setting download icon
                            else:
                                menu_item.SetBitmap(images.canary_24.GetBitmap())

                # Add All Betas submenu if aggregated betas exist (apply date filter)
                submenu_all_betas = wx.Menu() if 'betas' in device_data else None
                if submenu_all_betas and 'betas' in device_data:
                    for beta_entry in device_data['betas']:
                        entry_date = beta_entry.get('date')
                        if entry_date is not None and (not date_filter or (date_filter is not None and int(entry_date) >= int(date_filter))):
                            version = beta_entry.get('version')
                            menu_label = f"{version}"
                            menu_id = wx.NewId()
                            menu_item = submenu_all_betas.Append(menu_id, menu_label)
                            self.parent.Bind(wx.EVT_MENU, lambda event, u=beta_entry.get('url'): self.on_download(u), menu_item)
                            if date_filter and int(entry_date) != int(date_filter):
                                menu_item.SetBitmap(images.download_24.GetBitmap())
                            else:
                                menu_item.SetBitmap(images.all_betas_24.GetBitmap())

            with contextlib.suppress(Exception):
                ota_menu_item = self.AppendSubMenu(submenu_ota, "OTA")
                factory_menu_item = self.AppendSubMenu(submenu_factory, "Factory")
                if submenu_beta:
                    beta_menu_item = self.AppendSubMenu(submenu_beta, "Beta")
                    beta_menu_item.SetBitmap(images.beta_24.GetBitmap())
                if submenu_canary:
                    canary_menu_item = self.AppendSubMenu(submenu_canary, "Canary - Factory")
                    canary_menu_item.SetBitmap(images.canary_24.GetBitmap())
                if submenu_all_betas:
                    all_betas_menu_item = self.AppendSubMenu(submenu_all_betas, "All Betas - Factory")
                    all_betas_menu_item.SetBitmap(images.all_betas_24.GetBitmap())
                if download_flag:
                    ota_menu_item.SetBitmap(images.download_24.GetBitmap())
                    factory_menu_item.SetBitmap(images.download_24.GetBitmap())
                else:
                    ota_menu_item.SetBitmap(images.cloud_24.GetBitmap())
                    factory_menu_item.SetBitmap(images.factory_24.GetBitmap())

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while building Google Images Popup Menu.")
            traceback.print_exc()


# ============================================================================
#                               Class PixelFlasher
# ============================================================================
class PixelFlasher(wx.Frame):
    def __init__(self, parent, title):
        config_file = get_config_file_path()
        self.config = Config.load(config_file)
        self.init_complete = False
        self.wipe = False
        self.downgrade = False
        self.tools = []
        set_config(self.config)
        init_db()
        wx.Frame.__init__(self, parent, -1, title, size=(self.config.width, self.config.height),
            style=wx.DEFAULT_FRAME_STYLE | wx.NO_FULL_REPAINT_ON_RESIZE | wx.SYSTEM_MENU | wx.CLOSE_BOX)

        # Base first run size on resolution.
        if self.config.first_run:
            x = int((self.CharWidth * self.config.width) / 11)
            y = int((self.CharHeight * self.config.height) / 25)
            self.SetSize(x, y)
        self.SetMinSize((600, 400))

        # Make sure position is not -32000, -32000 (minimized)
        if self.config.pos_x == -32000 or self.config.pos_y == -32000:
            self.Center()
            # Update config with centered position
            pos = self.GetPosition()
            self.config.pos_x = pos.x
            self.config.pos_y = pos.y

        # set the language
        if hasattr(self.config, 'language') and self.config.language:
            set_language(self.config.language)
        else:
            set_language('en')

        self.toolbar_flags = self.get_toolbar_config()

        self.Center()
        self._build_status_bar()
        self._set_icons()
        self._build_menu_bar()
        self._init_ui()

        self.redirect_text = RedirectText(self.console_ctrl)
        sys.stdout = self.redirect_text
        sys.stderr = self.redirect_text

        # self.Centre(wx.BOTH)
        if self.config.pos_x and self.config.pos_y:
            self.SetPosition((self.config.pos_x, self.config.pos_y))

        self.resizing = False
        if not dont_initialize:
            self.initialize()
        set_window_shown(True)
        self.Show(True)

    def get_progress_window(self):
        if not hasattr(self, 'download_progress_window') or self.download_progress_window is None:
            from download_progress import DownloadProgressWindow
            self.download_progress_window = DownloadProgressWindow(self)
        return self.download_progress_window


    # -----------------------------------------------
    #                  initialize
    # -----------------------------------------------
    def initialize(self):
        try:
            if do_profiling:
                profiler = cProfile.Profile()
                profiler.enable()
            t = f":{datetime.now():%Y-%m-%d %H:%M:%S}"
            print(f"PixelFlasher {VERSION} started on {t}")
            puml(f"{t};\n")
            puml(f"#palegreen:PixelFlasher {VERSION} started;\n")
            start = time.time()

            print(f"Platform: {sys.platform}")
            puml(f"note left:Platform: {sys.platform}\n")
            # check timezone
            timezone_offset = time.timezone if (time.localtime().tm_isdst == 0) else time.altzone
            print(f"System Timezone: {time.tzname} Offset: {timezone_offset / 60 / 60 * -1}")
            print(f"Configuration Folder Path: {get_config_path()}")
            print(f"Configuration File Path: {get_config_file_path()}")

            puml(":Loading Configuration;\n")
            puml(f"note left: {get_config_path()}\n")
            # load verbose settings
            if self.config.verbose:
                self.verbose_checkBox.SetValue(self.config.verbose)
                set_verbose(self.config.verbose)
            if self.config.first_run:
                print("First Run: No previous configuration file is found.")
                self.config.save(get_config_file_path())
            else:
                print(f"{json.dumps(self.config.data, indent=4, sort_keys=True)}")
                puml("note right\n")
                puml(f"{json.dumps(self.config.data, indent=4, sort_keys=True)}\n")
                puml("end note\n")

            # enable / disable advanced_options
            if self.config.advanced_options:
                self._advanced_options_hide(False)
            else:
                self._advanced_options_hide(True)

            # check codepage
            print(f"System Default Encoding: {sys.getdefaultencoding()}")
            print(f"File System Encoding:    {sys.getfilesystemencoding()}")
            get_code_page()

            # delete specified libraries from the bundle
            print(f"Bundle Directory: {get_bundle_dir()}")
            delete_bundled_library(self.config.delete_bundled_libs)

            # Get Available Memory
            free_memory, total_memory = get_free_memory()
            formatted_free_memory = format_memory_size(free_memory)
            formatted_total_memory = format_memory_size(total_memory)
            print(f"Available Free Memory: {formatted_free_memory} / {formatted_total_memory}")

            # Get available free disk on system drive
            print(f"Available Free Disk on system drive: {str(get_free_space())} GB")
            print(f"Available Free Disk on PixelFlasher data drive: {str(get_free_space(get_config_path()))} GB\n")

            # load android_versions into a dict.
            try:
                file_path = os.path.join(get_bundle_dir(), 'android_versions.json')
                encoding = detect_encoding(file_path)
                with open(file_path, 'r', encoding=encoding, errors="replace") as file:
                    android_versions = json.load(file)
                set_android_versions(android_versions)
            except Exception as e:
                print(f"Error: Unable to load {file_path} {e}")

            # load android_devices into a dict.
            try:
                file_path = os.path.join(get_bundle_dir(), 'android_devices.json')
                encoding = detect_encoding(file_path)
                with open(file_path, 'r', encoding=encoding, errors="replace") as file:
                    android_devices = json.load(file)
                set_android_devices(android_devices)
            except Exception as e:
                print(f"Error: Unable to load {file_path} {e}")

            # clear file_path
            file_path = None

            # load Magisk Package Name
            set_magisk_package(self.config.magisk)

            # load the low_mem settings
            set_low_memory(self.config.low_mem)

            # load Linux Shell
            set_linux_shell(self.config.linux_shell)

            # load firmware_has_init_boot
            set_firmware_has_init_boot(self.config.firmware_has_init_boot)

            # load rom_has_init_boot
            set_rom_has_init_boot(self.config.rom_has_init_boot)

            # extract firmware info
            try:
                if self.config.firmware_path and os.path.exists(self.config.firmware_path):
                    self.firmware_picker.SetPath(self.config.firmware_path)
                    firmware = ntpath.basename(self.config.firmware_path)
                    filename, extension = os.path.splitext(firmware)
                    extension = extension.lower()
                    firmware = filename.split("-")
                    if len(firmware) == 1:
                        set_firmware_model(None)
                        set_firmware_id(filename)
                    else:
                        try:
                            set_firmware_model(firmware[0])
                            if firmware[1] == 'ota' or firmware[0] == 'crDroidAndroid':
                                set_firmware_id(f"{firmware[0]}-{firmware[1]}-{firmware[2]}")
                                self.config.firmware_is_ota = True
                            else:
                                set_firmware_id(f"{firmware[0]}-{firmware[1]}")
                        except Exception as e:
                            set_firmware_model(None)
                            set_firmware_id(filename)
                    set_ota(self, self.config.firmware_is_ota)
                    if self.config.check_for_firmware_hash_validity:
                        if self.config.firmware_sha256:
                            print("Using previously stored firmware SHA-256 ...")
                            firmware_hash = self.config.firmware_sha256
                        else:
                            print("Computing firmware SHA-256 ...")
                            firmware_hash = sha256(self.config.firmware_path)
                            self.config.firmware_sha256 = firmware_hash
                        print(f"Firmware SHA-256: {firmware_hash}")
                        self.firmware_picker.SetToolTip(f"SHA-256: {firmware_hash}")
                        # Check to see if the first 8 characters of the checksum is in the filename, Google published firmwares do have this.
                        if firmware_hash[:8] in self.config.firmware_path:
                            print(f"✅ Expected to match {firmware_hash[:8]} in the firmware filename and did. This is good!")
                            puml(f"#CDFFC8:Checksum matches portion of the firmware filename {self.config.firmware_path};\n")
                            # self.toast(_("Firmware SHA256"), _("✅ SHA256 of the selected file matches the segment in the filename."))
                            set_firmware_hash_validity(True)
                        else:
                            print(f"⚠️ WARNING: Expected to match {firmware_hash[:8]} in the firmware filename but didn't, please double check to make sure the checksum is good.")
                            puml("#orange:Unable to match the checksum in the filename;\n")
                            self.toast(_("Firmware SHA256"), _("⚠️ WARNING! SHA256 of the selected file does not match segments in the filename.\nPlease double check to make sure the checksum is good."))
                            set_firmware_hash_validity(False)
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while extracting firmware info during initialization.")
                traceback.print_exc()

            # check platform tools
            try:
                # If platform tools are not found, see if we're running NixOS
                if  not self.config.platform_tools_path and not sys.platform == "win32" and os.path.exists('/etc/NIXOS'):
                    self.config.platform_tools_path = '/run/current-system/sw/bin/'
                res_sdk = check_platform_tools(self)
                if res_sdk != -1:
                    # load platform tools value
                    if self.config.platform_tools_path and get_adb() and get_fastboot():
                        self.platform_tools_picker.SetPath(self.config.platform_tools_path)

                    # if adb is found, display the version
                    if get_sdk_version():
                        self.platform_tools_label.SetLabel(_("Android Platform Tools\nVersion %s") % get_sdk_version())
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking for platform tools during initialization.")
                traceback.print_exc()

            # load custom_rom settings
            try:
                self.custom_rom_checkbox.SetValue(self.config.custom_rom)
                if self.config.custom_rom_path and os.path.exists(self.config.custom_rom_path):
                    self.custom_rom.SetPath(self.config.custom_rom_path)
                    set_custom_rom_id(os.path.splitext(ntpath.basename(self.config.custom_rom_path))[0])
                    if self.config.rom_sha256:
                        rom_hash = self.config.rom_sha256
                    else:
                        rom_hash = sha256(self.config.custom_rom_path)
                        self.config.rom_sha256 = rom_hash
                    self.custom_rom.SetToolTip(f"SHA-256: {rom_hash}")
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking for custom rom during initialization.")
                traceback.print_exc()

            # refresh boot.img list
            try:
                populate_boot_list(self)
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while populating boot list during initialization.")
                traceback.print_exc()

            # set the flash mode
            mode = self.config.flash_mode

            # set flash option
            self.flash_both_slots_checkBox.SetValue(self.config.flash_both_slots)
            self.flash_to_inactive_slot_checkBox.SetValue(self.config.flash_to_inactive_slot)
            self.disable_verity_checkBox.SetValue(self.config.disable_verity)
            self.disable_verification_checkBox.SetValue(self.config.disable_verification)
            self.fastboot_force_checkBox.SetValue(self.config.fastboot_force)
            self.fastboot_verbose_checkBox.SetValue(self.config.fastboot_verbose)
            self.temporary_root_checkBox.SetValue(self.config.temporary_root)
            self.no_reboot_checkBox.SetValue(self.config.no_reboot)
            self.wipe_checkBox.SetValue(self.wipe)
            self.no_wipe_downgrade_checkbox.SetValue(self.downgrade)
            # self.no_wipe_downgrade_checkbox.Enable(False)
            # self.no_wipe_downgrade_checkbox.Hide()

            # get the image choice and update UI
            set_image_mode(self.image_choice.Items[self.image_choice.GetSelection()])

            # set the state of flash button.
            try:
                set_flash_button_state(self)
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while setting flash button state during initialization.")
                traceback.print_exc()

            # update the custom flash options
            try:
                self._update_custom_flash_options()
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while updating custom flash options during initialization.")
                traceback.print_exc()

            # check for connected devices
            try:
                if res_sdk != -1:
                    print("\nLoading Device list ...")
                    puml(":Loading device list;\n", True)
                    print("This could take a while, please be patient.\n")

                    debug("Populate device list")
                    connected_devices = get_connected_devices()
                    print(f"Discovered {len(connected_devices)} device(s) connected.")
                    self.device_choice.AppendItems(connected_devices)
                    d_list_string = '\n'.join(connected_devices)
                    puml(f"note right\n{d_list_string}\nend note\n")

                    # select configured device
                    debug("select configured device")
                    self._select_configured_device(is_init=True)
                    self._refresh_ui()

                    # Refresh the Devices menu to show detected devices
                    wx.CallAfter(self._build_devices_menu)
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking for connected devices during initialization.")
                traceback.print_exc()

            # check version if we are running the latest
            if self.config.update_check:
                l_version = check_latest_version()
                try:
                    if parse(VERSION) < parse(l_version):
                        print(f"\nA newer PixelFlasher v{l_version} can be downloaded from:")
                        print("https://github.com/badabing2005/PixelFlasher/releases/latest")
                        from About import AboutDlg
                        about = AboutDlg(self)
                        about.ShowModal()
                        about.Destroy()
                except Exception as e:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking for updates")
                    traceback.print_exc()
            end = time.time()
            print(f"Total Load time: {math.ceil(end - start)} seconds")

            # set the ui fonts
            try:
                self.set_ui_fonts()
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while setting ui fonts.")
                traceback.print_exc()

            # update widgets
            try:
                self.update_widget_states()
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking update_widget_states.")
                traceback.print_exc()

            self.spinner.Hide()
            self.spinner_label.Hide()
            self.init_complete = True

            if do_profiling:
                profiler.disable()
                stats = pstats.Stats(profiler).sort_stats('tottime')  # 'tottime' for total time
                stats.print_stats()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error during initialization.")
            traceback.print_exc()

    # -----------------------------------------------
    #           change_logfile
    # -----------------------------------------------
    def change_logfile(self, new_logfile_path):
        """Change the logfile to a new one."""
        self.redirect_text.set_logfile(new_logfile_path)

    # -----------------------------------------------
    #           reset_logfile
    # -----------------------------------------------
    def reset_logfile(self):
        """Reset the logfile to the original one."""
        self.redirect_text.reset_logfile()

    # -----------------------------------------------
    #           get_language_name
    # -----------------------------------------------
    def get_language_name(self, lang_code):
        """Return human-readable language name for language code"""
        return LANGUAGE_NAMES.get(lang_code, lang_code)

    # -----------------------------------------------
    #           on_language_change
    # -----------------------------------------------
    def on_language_change(self, lang_code):
        """Handle language change from menu"""
        if set_language(lang_code):
            # Save the language to configuration
            self.config.language = lang_code
            self.config.save(get_config_file_path())

            # Update menu items
            for code, menu_item in self.language_menu_items.items():
                menu_item.Check(code == lang_code)

            # Update the Language menu text itself
            lang_menu = self.menuBar.FindMenu(_("&Language"))
            if lang_menu != wx.NOT_FOUND:
                self.menuBar.SetMenuLabel(lang_menu, _("&Language"))

            # Display a message to the user
            wx.MessageBox(_("Language changed to %s. A restart is required for translations to apply.") %
                            self.get_language_name(lang_code), _("Language Changed"))

            print(f"Language changed to {lang_code}, a PixelFlasher restart is required.")
            return True
        return False

    # -----------------------------------------------
    #           enable_disable_radio_buttons
    # -----------------------------------------------
    def enable_disable_radio_button(self, name, state, selected=False, just_select=False):
        radio_buttons = self.mode_sizer.GetChildren()
        if isinstance(name, str):
            for child in radio_buttons:
                radio_button = child.GetWindow()
                if radio_button and radio_button.GetName() == f"mode-{name}":
                    if not just_select:
                        radio_button.Enable(state)
                    if state and selected:
                        radio_button.SetValue(True)

    # -----------------------------------------------
    #                  set_ui_fonts
    # -----------------------------------------------
    def set_ui_fonts(self):
        if self.config.customize_font:
            font = wx.Font(self.config.pf_font_size, family=wx.DEFAULT, style=wx.NORMAL, weight=wx.NORMAL, underline=False, faceName=self.config.pf_font_face)

            # device list
            self.device_choice.SetFont(font)

            # boot img list
            self.list.SetFont(font)
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLUE'),wx.Colour('DARK GREY'), wx.Font(font)))

            # console
            self.console_ctrl.SetFont(font)
        else:
            font = wx.Font(9, family=wx.DEFAULT, style=wx.NORMAL, weight=wx.NORMAL, underline=False, faceName='Segoe UI')

            # device list
            self.device_choice.SetFont(wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL))

            # boot img list
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLUE'),wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10))))
            if sys.platform == "win32":
                self.list.SetFont(font)
            else:
                self.list.SetFont(wx.Font(11, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL))

            # console
            self.console_ctrl.SetFont(wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL))
            if darkdetect.isLight():
                self.console_ctrl.SetBackgroundColour(wx.WHITE)
                self.console_ctrl.SetForegroundColour(wx.BLUE)
                self.console_ctrl.SetDefaultStyle(wx.TextAttr(wx.BLUE))

        self._refresh_ui()

    # -----------------------------------------------
    #                  _set_icons
    # -----------------------------------------------
    def _set_icons(self):
        self.SetIcon(images.Icon_dark_256.GetIcon())

    # -----------------------------------------------
    #                  _build_status_bar
    # -----------------------------------------------
    def _build_status_bar(self):
        self.statusBar = self.CreateStatusBar(2, wx.STB_SIZEGRIP)
        self.statusBar.SetStatusWidths([-2, -1])
        status_text = _("Welcome to PixelFlasher %s by Badabing2005") % VERSION
        self.statusBar.SetStatusText(status_text, 0)

    # -----------------------------------------------
    #                  _build_toolbar
    # -----------------------------------------------
    def _build_toolbar(self, flags, destroy=False):
        try:
            if destroy:
                self.tb.Destroy()

            tb = self.CreateToolBar(flags)
            # tb = MultiLineToolbar(self, flags)  # Use the custom MultiLineToolbar class
            self.tb = tb

            tsize = (64, 64)
            null_bmp = wx.BitmapBundle(wx.NullBitmap)
            tb.SetToolBitmapSize(tsize)

            # Install APK
            if self.config.toolbar['visible']['install_apk']:
                tb.AddTool(toolId=5, label=_("Install APK"), bitmap=images.install_apk_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Install APK on the device"), longHelp=_("Install APK on the device"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=5)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=5)

            # Package Manager
            if self.config.toolbar['visible']['package_manager']:
                tb.AddTool(toolId=8, label=_("App Manager"), bitmap=images.packages_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Package Manager"), longHelp=_("Manage Apps / Packages"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=8)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=8)

            # separator
            if self.config.toolbar['visible']['install_apk'] or self.config.toolbar['visible']['package_manager']:
                tb.AddSeparator()

            # Shell
            if self.config.toolbar['visible']['adb_shell']:
                tb.AddTool(toolId=10, label=_("ADB Shell"), bitmap=images.shell_64.GetBitmap(), bmpDisabled=images.shell_64_disabled.GetBitmap(), kind=wx.ITEM_NORMAL, shortHelp=_("Open ADB shell to the device."), longHelp=_("Open adb shell to the device"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=10)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=10)

            # Scrcpy
            if self.config.toolbar['visible']['scrcpy']:
                tb.AddTool(toolId=15, label=_("Scrcpy"), bitmap=images.scrcpy_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Launch Screen Copy"), longHelp=_("Launch Screen Copy"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=15)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=15)

            # Device Info
            if self.config.toolbar['visible']['device_info']:
                tb.AddTool(toolId=20, label=_("Device Info"), bitmap=images.about_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Dump Full Device Info"), longHelp=_("Dump Full Device Info"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=20)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=20)

            # Check Verity / Verification
            # if self.config.toolbar['visible']['check_verity']:
            #     tb.AddTool(toolId=30, label=_("Verify"), bitmap=images.shield_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Check Verity / Verification status"), longHelp=_("Check Verity / Verification status"), clientData=None)
            #     self.Bind(wx.EVT_TOOL, self.OnToolClick, id=30)
            #     self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=30)

            # Partition Manager
            if self.config.toolbar['visible']['partition_manager'] and self.config.advanced_options:
                tb.AddTool(toolId=40, label=_("Partitions"), bitmap=images.partition_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Partition Manager"), longHelp=_("Partition Manager"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=40)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=40)

            # PI Analysis Report
            if self.config.toolbar['visible']['pi_analysis_report']:
                tb.AddTool(toolId=50, label=_("PI Analysis Report"), bitmap=images.analyze_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("PI Analysis Report"), longHelp=_("PI Analysis Report"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=50)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=50)

            # separator
            with contextlib.suppress(Exception):
                if self.config.toolbar['visible']['adb_shell'] or self.config.toolbar['visible']['scrcpy'] or self.config.toolbar['visible']['device_info'] or self.config.toolbar['visible']['check_verity'] or self.config.toolbar['visible']['pi_analysis_report'] or (self.config.toolbar['visible']['partition_manager'] and self.config.advanced_options):
                    tb.AddSeparator()

            # Switch Slot
            if self.config.toolbar['visible']['switch_slot'] and self.config.advanced_options:
                tb.AddTool(toolId=100, label=_("Switch Slot"), bitmap=images.switch_slot_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Switch to the other Slot"), longHelp=_("Switch to the other Slot"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=100)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=100)
                # separator
                tb.AddSeparator()

            # Reboot to System
            if self.config.toolbar['visible']['reboot_system']:
                tb.AddTool(toolId=110, label=_("System"), bitmap=images.reboot_system_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to System"), longHelp=_("Reboot to System"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=110)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=110)

            # Reboot to Bootloader
            if self.config.toolbar['visible']['reboot_bootloader']:
                tb.AddTool(toolId=120, label=_("Bootloader"), bitmap=images.reboot_bootloader_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to Bootloader"), longHelp=_("Reboot to Bootloader"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=120)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=120)

            # Reboot to fastbootd
            if self.config.toolbar['visible']['reboot_fastbootd']:
                tb.AddTool(toolId=125, label=_("Fastbootd"), bitmap=images.reboot_fastbootd_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to userspace fastboot (fastbootd)"), longHelp=_("Reboot to userspace fastboot (fastbootd)"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=125)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=125)

            # Reboot to Recovery
            if self.config.toolbar['visible']['reboot_recovery'] and self.config.advanced_options:
                tb.AddTool(toolId=130, label=_("Recovery"), bitmap=images.reboot_recovery_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to Recovery"), longHelp=_("Reboot to Recovery"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=130)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=130)

            # Reboot to Interactive Recovery
            if self.config.toolbar['visible']['reboot_recovery_interactive'] and self.config.advanced_options:
                tb.AddTool(toolId=135, label=_("iRecovery"), bitmap=images.reboot_irecovery_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to Interactive Recovery"), longHelp=_("Reboot to Interactive Recovery"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=135)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=135)

            # Reboot to Safe Mode
            if self.config.toolbar['visible']['reboot_safe_mode'] and self.config.advanced_options:
                tb.AddTool(toolId=140, label=_("Safe Mode"), bitmap=images.reboot_safe_mode_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to Safe Mode"), longHelp=_("Reboot to Safe Mode"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=140)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=140)

            # Reboot to Download
            if self.config.toolbar['visible']['reboot_download'] and self.config.advanced_options:
                tb.AddTool(toolId=150, label=_("Download"), bitmap=images.reboot_download_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to Download Mode"), longHelp=_("Reboot to Download Mode"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=150)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=150)

            # Reboot to Sideload
            if self.config.toolbar['visible']['reboot_sideload'] and self.config.advanced_options:
                tb.AddTool(toolId=160, label=_("Sideload"), bitmap=images.reboot_sideload_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Reboot to Sideload Mode"), longHelp=_("Reboot to Sideload Mode"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=160)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=160)

            # separator
            if self.config.toolbar['visible']['reboot_system'] or self.config.toolbar['visible']['reboot_bootloader'] or (self.config.toolbar['visible']['reboot_recovery'] and self.config.advanced_options) or (self.config.toolbar['visible']['reboot_recovery_interactive'] and self.config.advanced_options) or (self.config.toolbar['visible']['reboot_safe_mode'] and self.config.advanced_options) or (self.config.toolbar['visible']['reboot_download'] and self.config.advanced_options) or (self.config.toolbar['visible']['reboot_sideload'] and self.config.advanced_options) or (self.config.toolbar['visible']['reboot_fastbootd'] and self.config.advanced_options):
                tb.AddSeparator()

            # Manage Magisk Settings (json file knows this and magisk_modules)
            if self.config.toolbar['visible']['magisk_modules']:
                tb.AddTool(toolId=200, label=_("Magisk"), bitmap=images.magisk_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Manage Magisk modules and settings"), longHelp=_("Manage Magisk modules and settings"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=200)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=200)

            # Download and Install Magisk Manager
            if self.config.toolbar['visible']['install_magisk']:
                tb.AddTool(toolId=210, label=_("Rooting App"), bitmap=images.install_magisk_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"), longHelp=_("Download / Install rooting app like Magisk or KernelSU or APatch or SukiSU or Wild_KSU"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=210)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=210)

            # Magisk Backup Manager
            if self.config.toolbar['visible']['magisk_backup_manager']:
                tb.AddTool(toolId=220, label=_("Magisk Backup"), bitmap=images.backup_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Magisk Backup Manager"), longHelp=_("Magisk Backup Manager"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=220)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=220)

            # Pif Manager
            if self.config.toolbar['visible']['pif_manager']:
                tb.AddTool(toolId=225, label=_("Pif Manager"), bitmap=images.pif_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Pif Manager"), longHelp=_("Pif Manager"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=225)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=225)

            # SOS, Disable Magisk Modules
            if self.config.toolbar['visible']['sos'] and self.config.advanced_options:
                tb.AddTool(toolId=230, label=_("SOS"), bitmap=images.sos_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Remove Magisk Modules\nThis button issues the following command:\n    adb wait-for-device shell magisk --remove-modules\nThis helps for cases where device bootloops due to incompatible magisk modules(YMMV)."), longHelp=_("SOS"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=230)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=230)

            # separator
            if self.config.toolbar['visible']['magisk_modules'] or self.config.toolbar['visible']['install_magisk'] or self.config.toolbar['visible']['magisk_backup_manager'] or self.config.toolbar['visible']['pif_manager'] or (self.config.toolbar['visible']['sos'] and self.config.advanced_options):
                tb.AddSeparator()

            # Lock Bootloader
            if self.config.toolbar['visible']['lock_bootloader'] and self.config.advanced_options:
                tb.AddTool(toolId=300, label=_("Lock"), bitmap=images.lock_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Lock Bootloader"), longHelp=_("Lock Bootloader"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=300)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=300)

            # UnLock Bootloader
            if self.config.toolbar['visible']['unlock_bootloader'] and self.config.advanced_options:
                tb.AddTool(toolId=310, label=_("UnLock"), bitmap=images.unlock_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("UnLock Bootloader\nCaution will wipe data"), longHelp=_("UnLock Bootloader"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=310)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=310)

            # separator
            if (self.config.toolbar['visible']['lock_bootloader'] or self.config.toolbar['visible']['unlock_bootloader']) and self.config.advanced_options:
                tb.AddSeparator()

            tb.AddStretchableSpace()

            if self.config.toolbar['visible']['configuration']:
            # Configuration
                tb.AddTool(toolId=900, label=_("Settings"), bitmap=images.settings_64.GetBitmap(), bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Settings"), longHelp=_("Configuration Settings"), clientData=None)
                self.Bind(wx.EVT_TOOL, self.OnToolClick, id=900)
                self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=900)

            # Create Support
            support_bmp = wx.ArtProvider.GetBitmapBundle(wx.ART_HELP, wx.ART_TOOLBAR, tsize)
            tb.AddTool(toolId=910, label=_("Support"), bitmap=support_bmp, bmpDisabled=null_bmp, kind=wx.ITEM_NORMAL, shortHelp=_("Create Support file"), longHelp=_("Create Support file"), clientData=None)
            self.Bind(wx.EVT_TOOL, self.OnToolClick, id=910)
            self.Bind(wx.EVT_TOOL_RCLICKED, self.OnToolRClick, id=910)

            # tb.EnableTool(10, False)  # False means disabled
            # self.disable_all_toolbar_tools(tb)

            tb.SetToolSeparation(10)
            a = tb.GetMargins()
            # tb.SetMargins(80, 80)
            b = tb.GetMargins()
            tb.Realize()

        except Exception as e:
            print("Exception occurred while building the toolbar:", e)
            traceback.print_exc()


    # -----------------------------------------------
    #          disable_all_toolbar_tools
    # -----------------------------------------------
    def disable_all_toolbar_tools(self, tb):
        tools_count = tb.GetToolsCount()
        for i in range(tools_count):
            tool = tb.GetToolByPos(i)
            tb.EnableTool(tool.GetId(), False)

    # -----------------------------------------------
    #                  OnToolClick
    # -----------------------------------------------
    def OnToolClick(self, event):
        # print("tool %s clicked\n" % event.GetId())
        id = event.GetId()
        if id == 5:
            self._on_install_apk(event)
        elif id == 8:
            self._on_package_manager(event)
        elif id == 10:
            self._on_adb_shell(event)
        elif id == 15:
            self._on_scrcpy(event)
        elif id == 20:
            self._on_device_info(event)
        # elif id == 30:
        #     self._on_verity_check(event)
        elif id == 40:
            self._on_partition_manager(event)
        elif id == 50:
            self._on_pi_analysis_report(event)
        elif id == 100:
            self._on_switch_slot(event)
        elif id == 110:
            self._on_reboot_system(event)
        elif id == 120:
            self._on_reboot_bootloader(event)
        elif id == 125:
            self._on_reboot_fastbootd(event)
        elif id == 130:
            self._on_reboot_recovery(event)
        elif id == 135:
            self._on_reboot_recovery_interactive(event)
        elif id == 140:
            self._on_reboot_safemode(event)
        elif id == 150:
            self._on_reboot_download(event)
        elif id == 160:
            self._on_reboot_sideload(event)
        elif id == 200:
            self._on_magisk(event)
        elif id == 210:
            self._on_rooting_app(event)
        elif id == 220:
            self._on_backup_manager(event)
        elif id == 225:
            self._on_pif_manager(event)
        elif id == 230:
            self._on_sos(event)
        elif id == 300:
            self._on_lock_bootloader(event)
        elif id == 310:
            self._on_unlock_bootloader(event)
        elif id == 900:
            self._on_advanced_config(event)
        elif id == 910:
            self._on_support_zip(event)
        else:
            print(f"UNKNOWN tool id: {id}")

    # -----------------------------------------------
    #                  OnToolRClick
    # -----------------------------------------------
    def OnToolRClick(self, event):
        # print("tool %s right-clicked\n" % event.GetId())
        return

    # -----------------------------------------------
    #                  _on_device_info
    # -----------------------------------------------
    def _on_device_info(self, event):
        try:
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    print(f"Device Info:\n------------\n{device.device_info}")
                else:
                    self.clear_device_selection()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting device info")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_pif_info
    # -----------------------------------------------
    def _on_pif_info(self, event):
        try:
            if self.config.device:
                self._on_spin('start')
                device = get_phone()
                if device:
                    print(f"Current device's Print:\n------------\n{device.current_device_print}\n------------\n")
                else:
                    self.clear_device_selection()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting current device print")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_props_as_json
    # -----------------------------------------------
    def _on_props_as_json(self, event):
        try:
            if self.config.device:
                self._on_spin('start')
                device = get_phone()
                if device:
                    print(f"Current device's properties as json :\n------------\n{device.current_device_props_as_json}\n------------\n")
                else:
                    self.clear_device_selection()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting current device properties as json")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_verity_check
    # -----------------------------------------------
    # def _on_verity_check(self, event):
    #     try:
    #         if self.config.device:
    #             self._on_spin('start')
    #             with contextlib.suppress(Exception):
    #                 device = get_phone()
    #                 if device:
    #                     verity = device.get_verity_verification('verity')
    #                     if verity != -1:
    #                         print(f"\n{verity}")
    #                     verification = device.get_verity_verification('verification')
    #                     if verification != -1:
    #                         print(f"\n{verification}")
    #                 else:
    #                     self.clear_device_selection()
    #     except Exception as e:
    #         print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking verity")
    #         traceback.print_exc()
    #     finally:
    #         self._on_spin('stop')

    # -----------------------------------------------
    #                  _build_links_menu
    # -----------------------------------------------
    def _build_links_menu(self):
        links = wx.Menu()

        # Create a dictionary to store menu_id -> (url, label) mappings
        if not hasattr(self, 'link_urls'):
            self.link_urls = {}

        # Create menu items from the data structure
        for item in LINKS_MENU_DATA:
            if item is None:
                # Add a separator
                links.AppendSeparator()
            else:
                label, image_name, url = item
                menu_item = links.Append(wx.ID_ANY, label)
                # Get the bitmap from the image name
                bitmap = getattr(images, image_name).GetBitmap()
                menu_item.SetBitmap(bitmap)

                # Store the URL and label in our dictionary using the menu item's ID
                self.link_urls[menu_item.GetId()] = (url, label)

                self.Bind(wx.EVT_MENU, self._on_link_clicked, menu_item)
        return links

    # -----------------------------------------------
    #                  _build_menu_bar
    # -----------------------------------------------
    def _build_menu_bar(self):
        # create the main menu object
        self.menuBar = wx.MenuBar()

        # Create the File menu
        file_menu = wx.Menu()

        # Create the Device menu
        device_menu = wx.Menu()

        # Create the Devices management menu (for enable/disable scanning)
        self.devices_menu = wx.Menu()
        self._build_devices_menu()

        # Create the Toolbar menu
        tb_menu = wx.Menu()

        # Create the Dev Tools menu
        tools_menu = wx.Menu()

        # Create the My Tools menu
        self.my_tools_menu = wx.Menu()

        # Create the language menu
        lang_menu = wx.Menu()

        # Create the Help menu
        help_menu = wx.Menu()

        # File Menu Items
        # ---------------
        # Settings Menu
        config_item = file_menu.Append(wx.ID_PREFERENCES , _("Settings"), _("Settings"))
        config_item.SetBitmap(images.settings_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_advanced_config, config_item)
        # separator
        file_menu.AppendSeparator()
        # Exit Menu
        exit_item = file_menu.Append(wx.ID_EXIT, _("E&xit\tCtrl-Q"), _("Exit PixelFlasher"))
        exit_item.SetBitmap(images.exit_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_exit_app, exit_item)
        # Set the ID of the "Exit" menu item on macOS
        # Don't do this, it conflicts with another menu id
        # wx.App.SetMacExitMenuItemId(exit_item.GetId())

        # Device Menu Items
        # ----------------
        # Install APK
        self.install_apk = device_menu.Append(wx.ID_ANY, _("Install APK"), _("Install APK"))
        self.install_apk.SetBitmap(images.install_apk_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_install_apk, self.install_apk)
        # Package Manager
        self.package_manager = device_menu.Append(wx.ID_ANY, _("Package Manager"), _("Package Manager"))
        self.package_manager.SetBitmap(images.packages_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_package_manager, self.package_manager)
        # separator
        device_menu.AppendSeparator()
        # ADB Shell Menu
        self.shell_menu_item = device_menu.Append(wx.ID_ANY, _("ADB Shell"), _("Open adb shell to the device"))
        self.shell_menu_item.SetBitmap(images.shell_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_adb_shell, self.shell_menu_item)
        # Scrcpy Menu
        self.scrcpy_menu_item = device_menu.Append(wx.ID_ANY, _("Scrcpy"), _("Launch Screen Copy"))
        self.scrcpy_menu_item.SetBitmap(images.scrcpy_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_scrcpy, self.scrcpy_menu_item)
        # Device Info Menu
        self.device_info_menu_item = device_menu.Append(wx.ID_ANY, _("Device Info"), _("Dump Full Device Info"))
        self.device_info_menu_item.SetBitmap(images.about_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_device_info, self.device_info_menu_item)
        # Get PIF Print Menu
        self.pif_info_menu_item = device_menu.Append(wx.ID_ANY, _("Pif Print"), _("Get current device's Pif print (osm0sis fork v5 format)"))
        self.pif_info_menu_item.SetBitmap(images.json_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_pif_info, self.pif_info_menu_item)
        # Get Props as json Menu
        self.props_as_json_menu_item = device_menu.Append(wx.ID_ANY, _("Props as Json"), _("Get current device's properties in json format"))
        self.props_as_json_menu_item.SetBitmap(images.json_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_props_as_json, self.props_as_json_menu_item)
        # Dump Screen XML Menu
        self.xml_view_menu_item = device_menu.Append(wx.ID_ANY, _("Dump Screen XML"), _("Use uiautomator to dump the screen view in xml"))
        self.xml_view_menu_item.SetBitmap(images.xml_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_xml_view, self.xml_view_menu_item)
        # Cancel OTA Update Menu
        self.cancel_ota_menu_item = device_menu.Append(wx.ID_ANY, _("Cancel OTA Update"), _("Cancels and Resets OTA updates by Google (Not PixelFlasher)"))
        self.cancel_ota_menu_item.SetBitmap(images.cancel_ota_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_cancel_ota, self.cancel_ota_menu_item)
        # Check otacerts  Menu
        self.check_otacerts_menu_item = device_menu.Append(wx.ID_ANY, _("Check otacerts"), _("Used to see if ROM is signed or not."))
        self.check_otacerts_menu_item.SetBitmap(images.check_otacerts_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_check_otacerts, self.check_otacerts_menu_item)
        # # Verity / Verification Menu
        # self.verity_menu_item = device_menu.Append(wx.ID_ANY, _("Verity / Verification Status"), _("Check Verity / Verification Status"))
        # self.verity_menu_item.SetBitmap(images.shield_24.GetBitmap())
        # self.Bind(wx.EVT_MENU, self._on_verity_check, self.verity_menu_item)
        # Partitions Manager
        self.partitions_menu = device_menu.Append(wx.ID_ANY, _("Partitions Manager"), _("Backup / Erase Partitions"))
        self.partitions_menu.SetBitmap(images.partition_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_partition_manager, self.partitions_menu)
        # Logcat
        self.logcat_menu = device_menu.Append(wx.ID_ANY, _("Logcat"), _("Logcat Viewer"))
        self.logcat_menu.SetBitmap(images.logcat_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_logcat, self.logcat_menu)
        # update_engine Logcat
        self.update_engine_logcat_menu = device_menu.Append(wx.ID_ANY, _("Logcat filter: update_engine"), _("Logcat filtered for update_engine to monitor OTA merging"))
        self.update_engine_logcat_menu.SetBitmap(images.logcat_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_update_engine_logcat, self.update_engine_logcat_menu)
        # Get bootloader versions
        self.get_bootloader_versions_menu = device_menu.Append(wx.ID_ANY, _("Bootloader Versions"), _("Get Bootloader Versions"))
        self.get_bootloader_versions_menu.SetBitmap(images.bootloader_versions_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_get_bootloader_versions, self.get_bootloader_versions_menu)
        # Pi Analysis Report
        self.pi_analysis_report_menu = device_menu.Append(wx.ID_ANY, _("PI Analysis Report"), _("Generate a report of PI Analysis"))
        self.pi_analysis_report_menu.SetBitmap(images.analyze_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_pi_analysis_report, self.pi_analysis_report_menu)
        # Open URL
        self.open_url_menu = device_menu.Append(wx.ID_ANY, _("Open URL"), _("Open a URL in the default browser"))
        self.open_url_menu.SetBitmap(images.open_url_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_open_url_on_device, self.open_url_menu)
        # separator
        device_menu.AppendSeparator()
        # Switch Slot
        self.switch_slot_menu = device_menu.Append(wx.ID_ANY, _("Switch Slot"), _("Switch to the other slot"))
        self.switch_slot_menu.SetBitmap(images.switch_slot_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_switch_slot, self.switch_slot_menu)
        # separator
        device_menu.AppendSeparator()
        # Reboot Submenu
        reboot = wx.Menu()
        self.reboot_system_menu = reboot.Append(wx.ID_ANY, _("System"))
        self.reboot_bootloader_menu = reboot.Append(wx.ID_ANY, _("Bootloader"))
        self.reboot_fastbootd_menu = reboot.Append(wx.ID_ANY, _("Fastbootd"))
        self.reboot_recovery_menu = reboot.Append(wx.ID_ANY, _("Recovery"))
        self.reboot_recovery_interactive_menu = reboot.Append(wx.ID_ANY, _("Interactive Recovery"))
        self.reboot_safe_mode_menu = reboot.Append(wx.ID_ANY, _("Safe Mode"))
        self.reboot_download_menu = reboot.Append(wx.ID_ANY, _("Download"))
        self.reboot_sideload_menu = reboot.Append(wx.ID_ANY, _("Sideload"))
        self.reboot_system_menu.SetBitmap(images.reboot_System_24.GetBitmap())
        self.reboot_bootloader_menu.SetBitmap(images.reboot_bootloader_24.GetBitmap())
        self.reboot_fastbootd_menu.SetBitmap(images.reboot_fastbootd_24.GetBitmap())
        self.reboot_recovery_menu.SetBitmap(images.reboot_recovery_24.GetBitmap())
        self.reboot_recovery_interactive_menu.SetBitmap(images.reboot_irecovery_24.GetBitmap())
        self.reboot_safe_mode_menu.SetBitmap(images.reboot_safe_mode_24.GetBitmap())
        self.reboot_download_menu.SetBitmap(images.reboot_download_24.GetBitmap())
        self.reboot_sideload_menu.SetBitmap(images.reboot_sideload_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_reboot_system, self.reboot_system_menu)
        self.Bind(wx.EVT_MENU, self._on_reboot_bootloader, self.reboot_bootloader_menu)
        self.Bind(wx.EVT_MENU, self._on_reboot_fastbootd, self.reboot_fastbootd_menu)
        self.Bind(wx.EVT_MENU, self._on_reboot_recovery, self.reboot_recovery_menu)
        self.Bind(wx.EVT_MENU, self._on_reboot_recovery_interactive, self.reboot_recovery_interactive_menu)
        self.Bind(wx.EVT_MENU, self._on_reboot_safemode, self.reboot_safe_mode_menu)
        self.Bind(wx.EVT_MENU, self._on_reboot_download, self.reboot_download_menu)
        self.Bind(wx.EVT_MENU, self._on_reboot_sideload, self.reboot_sideload_menu)
        self.reboot_menu = device_menu.Append(wx.ID_ANY, _("Reboot"), reboot)
        self.reboot_menu.SetBitmap(images.reboot_24.GetBitmap())
        # Push File Submenu
        push_file = wx.Menu()
        self.push_file_to_tmp_menu = push_file.Append(wx.ID_ANY, "/data/local/tmp/")
        self.push_file_to_download_menu = push_file.Append(wx.ID_ANY, "/sdcard/Download/")
        self.push_file_to_tmp_menu.SetBitmap(images.push_24.GetBitmap())
        self.push_file_to_download_menu.SetBitmap(images.push_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_push_to_tmp, self.push_file_to_tmp_menu)
        self.Bind(wx.EVT_MENU, self._on_push_to_download, self.push_file_to_download_menu)
        self.push_menu = device_menu.Append(wx.ID_ANY, _('Push file(s) to'), push_file)
        self.push_menu.SetBitmap(images.push_cart_24.GetBitmap())
        # separator
        device_menu.AppendSeparator()
        # Magisk Settings
        self.magisk_menu = device_menu.Append(wx.ID_ANY, _("Magisk"), _("Manage Magisk modules and settings"))
        self.magisk_menu.SetBitmap(images.magisk_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_magisk, self.magisk_menu)
        # Install Magisk
        self.install_magisk_menu = device_menu.Append(wx.ID_ANY, _("Rooting App"), _("Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"))
        self.install_magisk_menu.SetBitmap(images.install_magisk_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_rooting_app, self.install_magisk_menu)
        # Magisk Backup Manager
        self.magisk_backup_manager_menu = device_menu.Append(wx.ID_ANY, _("Magisk Backup Manager"), _("Manage Magisk Backups"))
        self.magisk_backup_manager_menu.SetBitmap(images.backup_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_backup_manager, self.magisk_backup_manager_menu)
        # Data ADB Backup
        self.data_adb_backup_menu = device_menu.Append(wx.ID_ANY, _("Backup /data/adb"), _("Backs up /data/adb.\nThis is useful for backing up Magisk modules.\nNOTE: If a module writes to anywhere other than /data/adb, those paths will not be backed up."))
        self.data_adb_backup_menu.SetBitmap(images.folder_zip_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_data_adb_backup, self.data_adb_backup_menu)
        # Data ADB Restore
        self.data_adb_restore_menu = device_menu.Append(wx.ID_ANY, _("Restore /data/adb"), _("Restore /data/adb from a backup file.\nThis is useful for restoring Magisk modules.\nNOTE: If a module writes to anywhere other than /data/adb, those items will not be restored."))
        self.data_adb_restore_menu.SetBitmap(images.restore_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_data_adb_restore, self.data_adb_restore_menu)
        # Clear Data ADB
        self.data_adb_clear_menu = device_menu.Append(wx.ID_ANY, _("Clear /data/adb/*"), _("Clear up /data/adb/ content (not the directory).\nThis is useful when switching to different root flavor."))
        self.data_adb_clear_menu.SetBitmap(images.delete_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_data_adb_clear, self.data_adb_clear_menu)
        # Start Shizuku
        self.start_shizuku_menu = device_menu.Append(wx.ID_ANY, _("Start Shizuku"), _("Starts Shizuku service on the device."))
        self.start_shizuku_menu.SetBitmap(images.shizuku_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_start_shizuku, self.start_shizuku_menu)
        # Pif Manager
        self.pif_manager_menu = device_menu.Append(wx.ID_ANY, _("Pif Manager"), _("Pif Manager"))
        self.pif_manager_menu.SetBitmap(images.pif_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_pif_manager, self.pif_manager_menu)
        # SOS
        self.sos_menu = device_menu.Append(wx.ID_ANY, _("SOS"), _("Disable Magisk Modules"))
        self.sos_menu.SetBitmap(images.sos_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_sos, self.sos_menu)
        # separator
        device_menu.AppendSeparator()
        # Lock Bootloader
        self.bootloader_lock_menu = device_menu.Append(wx.ID_ANY, _("Lock Bootloader"), _("Lock Bootloader"))
        self.bootloader_lock_menu.SetBitmap(images.lock_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_lock_bootloader, self.bootloader_lock_menu)
        # Unlock Bootloader
        self.bootloader_unlock_menu = device_menu.Append(wx.ID_ANY, _("Unlock Bootloader"), _("Unlock Bootloader (Will wipe data)"))
        self.bootloader_unlock_menu.SetBitmap(images.unlock_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_unlock_bootloader, self.bootloader_unlock_menu)

        # Dev Tools Menu Items
        # ----------------
        # check keybox.xml
        self.check_keybox_menu = tools_menu.Append(wx.ID_ANY, _("Check keybox.xml"), _("Check keybox.xml"))
        self.check_keybox_menu.SetBitmap(images.cert_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_check_keybox, self.check_keybox_menu)
        # Decode binary xml
        self.decode_binary_xml_menu = tools_menu.Append(wx.ID_ANY, _("Decode Binary XML"), _("Decode Binary XML"))
        self.decode_binary_xml_menu.SetBitmap(images.axml_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_decode_binary_xml, self.decode_binary_xml_menu)
        # Get Image Info
        self.get_image_info = tools_menu.Append(wx.ID_ANY, _("AVB - Get Image Info"), _("Get Android Verified Boot Image Info"))
        self.get_image_info.SetBitmap(images.about_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_get_image_info, self.get_image_info)
        # Prepare downgraded patch
        self.prep_downgrade_patch_menu = tools_menu.Append(wx.ID_ANY, _("AVB - Prepare Downgrade Patch"), _("Create Downgrade Patch"))
        self.prep_downgrade_patch_menu.SetBitmap(images.downgrade_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_prep_downgrade_patch, self.prep_downgrade_patch_menu)

        # My Tools Menu Items
        # ----------------
        # Customize My Tools
        self.build_my_tools_menu()

        # Toolbar Menu Items
        # ------------------
        # Top
        tb_top_item = tb_menu.Append(21010, _('Top'), _('Top'), wx.ITEM_RADIO)
        tb_top_item.SetBitmap(images.top_24.GetBitmap())
        if self.config.toolbar and self.config.toolbar['tb_position'] == 'top':
            tb_top_item.Check()
        self.Bind(wx.EVT_MENU, self._on_tb_update, tb_top_item)
        # Left
        tb_left_item = tb_menu.Append(21020, _('Left'), _('Left'), wx.ITEM_RADIO)
        tb_left_item.SetBitmap(images.left_24.GetBitmap())
        if self.config.toolbar and self.config.toolbar['tb_position'] == 'left':
            tb_left_item.Check()
        self.Bind(wx.EVT_MENU, self._on_tb_update, tb_left_item)
        # Right
        tb_right_item = tb_menu.Append(21030, _('Right'), _('Right'), wx.ITEM_RADIO)
        tb_right_item.SetBitmap(images.right_24.GetBitmap())
        if self.config.toolbar and self.config.toolbar['tb_position'] == 'right':
            tb_right_item.Check()
        self.Bind(wx.EVT_MENU, self._on_tb_update, tb_right_item)
        # Bottom
        tb_bottom_item = tb_menu.Append(21040, _('Bottom'), _('Bottom'), wx.ITEM_RADIO)
        tb_bottom_item.SetBitmap(images.bottom_24.GetBitmap())
        if self.config.toolbar and self.config.toolbar['tb_position'] == 'bottom':
            tb_bottom_item.Check()
        self.Bind(wx.EVT_MENU, self._on_tb_update, tb_bottom_item)
        # separator
        tb_menu.AppendSeparator()
        # Checkboxes
        self.tb_show_text_item = tb_menu.Append(21100, _("Show Button Text"), _("Show Button Text"), wx.ITEM_CHECK)
        if self.config.toolbar and self.config.toolbar['tb_show_text']:
            self.tb_show_text_item.Check()
        self.Bind(wx.EVT_MENU, self._on_tb_update, self.tb_show_text_item)
        self.tb_show_button_item = tb_menu.Append(21200, _("Show Button Icon"), _("Show Button Icon"), wx.ITEM_CHECK)
        if self.config.toolbar and self.config.toolbar['tb_show_icons']:
            self.tb_show_button_item.Check()
        self.Bind(wx.EVT_MENU, self._on_tb_update, self.tb_show_button_item)
        # separator
        # Show / Hide Buttons Menu
        tb_buttons_menu = wx.Menu()
        tb_buttons_menu.Append(5, _("Install APK"), "", wx.ITEM_CHECK).SetBitmap(images.install_apk_24.GetBitmap())
        tb_buttons_menu.Append(8, _("Package Manager"), "", wx.ITEM_CHECK).SetBitmap(images.packages_24.GetBitmap())
        tb_buttons_menu.Append(10, _("ADB Shell"), "", wx.ITEM_CHECK).SetBitmap(images.shell_24.GetBitmap())
        tb_buttons_menu.Append(15, _("Scrcpy"), "", wx.ITEM_CHECK).SetBitmap(images.scrcpy_24.GetBitmap())
        tb_buttons_menu.Append(20, _("Device Info"), "", wx.ITEM_CHECK).SetBitmap(images.about_24.GetBitmap())
        # tb_buttons_menu.Append(30, _("Verity Verification Status"), "", wx.ITEM_CHECK).SetBitmap(images.shield_24.GetBitmap())
        tb_buttons_menu.Append(40, _("Partitions Manager"), "", wx.ITEM_CHECK).SetBitmap(images.partition_24.GetBitmap())
        tb_buttons_menu.Append(50, _("PI Analysis Report"), "", wx.ITEM_CHECK).SetBitmap(images.analyze_24.GetBitmap())
        tb_buttons_menu.Append(100, _("Switch Slot"), "", wx.ITEM_CHECK).SetBitmap(images.switch_slot_24.GetBitmap())
        tb_buttons_menu.Append(110, _("Reboot to System"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_System_24.GetBitmap())
        tb_buttons_menu.Append(120, _("Reboot to Bootloader"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_bootloader_24.GetBitmap())
        tb_buttons_menu.Append(125, _("Reboot to Fastbootd"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_fastbootd_24.GetBitmap())
        tb_buttons_menu.Append(130, _("Reboot to Recovery"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_recovery_24.GetBitmap())
        tb_buttons_menu.Append(135, _("Reboot to Interactive Recovery"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_irecovery_24.GetBitmap())
        tb_buttons_menu.Append(140, _("Reboot to Safe Mode"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_safe_mode_24.GetBitmap())
        tb_buttons_menu.Append(150, _("Reboot to Download"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_download_24.GetBitmap())
        tb_buttons_menu.Append(160, _("Reboot to Sideload"), "", wx.ITEM_CHECK).SetBitmap(images.reboot_sideload_24.GetBitmap())
        tb_buttons_menu.Append(200, _("Magisk"), "", wx.ITEM_CHECK).SetBitmap(images.magisk_24.GetBitmap())
        tb_buttons_menu.Append(210, _("Rooting App"), "", wx.ITEM_CHECK).SetBitmap(images.install_magisk_24.GetBitmap())
        tb_buttons_menu.Append(220, _("Magisk Backup Manager"), "", wx.ITEM_CHECK).SetBitmap(images.backup_24.GetBitmap())
        tb_buttons_menu.Append(225, _("Pif Manager"), "", wx.ITEM_CHECK).SetBitmap(images.pif_24.GetBitmap())
        tb_buttons_menu.Append(230, _("SOS"), "", wx.ITEM_CHECK).SetBitmap(images.sos_24.GetBitmap())
        tb_buttons_menu.Append(300, _("Lock Bootloader"), "", wx.ITEM_CHECK).SetBitmap(images.lock_24.GetBitmap())
        tb_buttons_menu.Append(310, _("Unlock Bootloader"), "", wx.ITEM_CHECK).SetBitmap(images.unlock_24.GetBitmap())
        tb_buttons_menu.Append(900, _("Configuration"), "", wx.ITEM_CHECK).SetBitmap(images.settings_24.GetBitmap())
        tb_buttons_menu.Bind(wx.EVT_MENU, self._on_button_menu)
        tb_menu.AppendSubMenu(tb_buttons_menu, _("Show / Hide Buttons"))

        # update tb_buttons_menu items based on config.
        tb_buttons_menu.Check(5, self.config.toolbar['visible']['install_apk'])
        tb_buttons_menu.Check(8, self.config.toolbar['visible']['package_manager'])
        tb_buttons_menu.Check(10, self.config.toolbar['visible']['adb_shell'])
        tb_buttons_menu.Check(15, self.config.toolbar['visible']['scrcpy'])
        tb_buttons_menu.Check(20, self.config.toolbar['visible']['device_info'])
        # tb_buttons_menu.Check(30, self.config.toolbar['visible']['check_verity'])
        tb_buttons_menu.Check(40, self.config.toolbar['visible']['partition_manager'])
        tb_buttons_menu.Check(50, self.config.toolbar['visible']['pi_analysis_report'])
        tb_buttons_menu.Check(100, self.config.toolbar['visible']['switch_slot'])
        tb_buttons_menu.Check(110, self.config.toolbar['visible']['reboot_system'])
        tb_buttons_menu.Check(120, self.config.toolbar['visible']['reboot_bootloader'])
        tb_buttons_menu.Check(125, self.config.toolbar['visible']['reboot_fastbootd'])
        tb_buttons_menu.Check(130, self.config.toolbar['visible']['reboot_recovery'])
        tb_buttons_menu.Check(135, self.config.toolbar['visible']['reboot_recovery_interactive'])
        tb_buttons_menu.Check(140, self.config.toolbar['visible']['reboot_safe_mode'])
        tb_buttons_menu.Check(150, self.config.toolbar['visible']['reboot_download'])
        tb_buttons_menu.Check(160, self.config.toolbar['visible']['reboot_sideload'])
        tb_buttons_menu.Check(200, self.config.toolbar['visible']['magisk_modules'])
        tb_buttons_menu.Check(210, self.config.toolbar['visible']['install_magisk'])
        tb_buttons_menu.Check(220, self.config.toolbar['visible']['magisk_backup_manager'])
        tb_buttons_menu.Check(225, self.config.toolbar['visible']['pif_manager'])
        tb_buttons_menu.Check(230, self.config.toolbar['visible']['sos'])
        tb_buttons_menu.Check(300, self.config.toolbar['visible']['lock_bootloader'])
        tb_buttons_menu.Check(310, self.config.toolbar['visible']['unlock_bootloader'])
        tb_buttons_menu.Check(900, self.config.toolbar['visible']['configuration'])

        # Language Menu Items
        # Get available languages
        languages = get_available_languages()
        self.language_menu_items = {}
        # Create menu items for each language
        for lang in languages:
            language_name = self.get_language_name(lang)
            menu_item = lang_menu.AppendRadioItem(-1, language_name)
            self.language_menu_items[lang] = menu_item
            # Check the current language
            menu_item.Check(lang == get_language())
            self.Bind(wx.EVT_MENU, lambda evt, l=lang: self.on_language_change(l), menu_item)

        # Help Menu Items
        # ---------------
        # Report an issue
        self.issue_item = help_menu.Append(wx.ID_ANY, HELP_MENU_ITEMS["issue"]["description"], HELP_MENU_ITEMS["issue"]["description"])
        self.issue_item.SetBitmap(images.bug_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_link_clicked, self.issue_item)
        # Feature Request
        self.feature_item = help_menu.Append(wx.ID_ANY, HELP_MENU_ITEMS["feature"]["description"], HELP_MENU_ITEMS["feature"]["description"])
        self.feature_item.SetBitmap(images.feature_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_link_clicked, self.feature_item)
        # Project Home
        self.project_page_item = help_menu.Append(wx.ID_ANY, HELP_MENU_ITEMS["project"]["description"], HELP_MENU_ITEMS["project"]["description"])
        self.project_page_item.SetBitmap(images.github_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_link_clicked, self.project_page_item)
        # Community Forum
        self.forum_item = help_menu.Append(wx.ID_ANY, HELP_MENU_ITEMS["forum"]["description"], HELP_MENU_ITEMS["forum"]["description"])
        self.forum_item.SetBitmap(images.forum_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_link_clicked, self.forum_item)
        # separator
        help_menu.AppendSeparator()
        # Links Submenu
        links = self._build_links_menu()
        links_item = help_menu.Append(wx.ID_ANY, _('Links'), links)
        links_item.SetBitmap(images.open_link_24.GetBitmap())
        # separator
        help_menu.AppendSeparator()
        # Open configuration Folder
        config_folder_item = help_menu.Append(wx.ID_ANY, _('Open Configuration Folder'), _('Open Configuration Folder'))
        config_folder_item.SetBitmap(images.folder_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_open_config_folder, config_folder_item)
        if get_config_path() != get_sys_config_path():
            # Open pf_home
            pf_home_item = help_menu.Append(wx.ID_ANY, _('Open PixelFlasher Working Directory'), _('Open PixelFlasher Working Directory'))
            pf_home_item.SetBitmap(images.folder_24.GetBitmap())
            self.Bind(wx.EVT_MENU, self._on_open_pf_home, pf_home_item)
        # Create sanitized support.zip
        support_zip_item = help_menu.Append(wx.ID_ANY, _('Create a Sanitized support.zip'), _('Create a Sanitized support.zip'))
        support_zip_item.SetBitmap(images.support_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_support_zip, support_zip_item)
        # separator
        help_menu.AppendSeparator()
        # update check
        update_item = help_menu.Append(wx.ID_ANY, _('Check for New Version'), _('Check for New Version'))
        update_item.SetBitmap(images.update_check_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_help_about, update_item)
        # separator
        help_menu.AppendSeparator()
        # About
        about_item = help_menu.Append(wx.ID_ABOUT, _('&About PixelFlasher'), _('About'))
        about_item.SetBitmap(images.about_24.GetBitmap())
        self.Bind(wx.EVT_MENU, self._on_help_about, about_item)

        # Add the File menu to the menu bar
        self.menuBar.Append(file_menu, _("&File"))
        # Add the Device menu to the menu bar
        self.menuBar.Append(device_menu, _("&Device"))
        # Add the Dev Tools menu to the menu bar
        self.menuBar.Append(tools_menu, _("Dev Tools"))
        # Add the My Tools menu to the menu bar
        self.menuBar.Append(self.my_tools_menu, _("&My Tools"))
        # Add the Devices management menu to the menu bar
        self.menuBar.Append(self.devices_menu, _("&Devices"))
        # Create an instance of GoogleImagesMenu
        self.google_images_menu = GoogleImagesMenu(self)
        # Append GoogleImagesMenu to the menu bar
        self.menuBar.Append(self.google_images_menu, _("&Google Images"))
        # Add the Toolbar menu to the menu bar
        self.menuBar.Append(tb_menu, _("&Toolbar"))
        # Add Language menu to menuBar
        self.menuBar.Append(lang_menu, _("&Language"))
        # Add the Help menu to the menu bar
        self.menuBar.Append(help_menu, _('&Help'))
        # Add the Test menu to the menu bar
        if self.config.dev_mode:
            test_menu = wx.Menu()
            test1_item = test_menu.Append(wx.ID_ANY, "Test1", "Test1")
            self.Bind(wx.EVT_MENU, self.Test, test1_item)
            self.menuBar.Append(test_menu, 'Test')

        self.SetMenuBar(self.menuBar)

    # -----------------------------------------------
    #                  get_toolbar_flags
    # -----------------------------------------------
    def get_toolbar_config(self):
        # Read the configuration settings from self.config or use default values
        if not self.config:
            # Configuration is not available, use default values
            position = 'right'
            show_text = True
            show_icons = True
        else:
            # Configuration is available, use values from the config
            position = self.config.toolbar['tb_position']
            show_text = self.config.toolbar['tb_show_text']
            show_icons = self.config.toolbar['tb_show_icons']

        flag_pos = 0  # Initialize the position flags to 0
        if position == "top":
            flag_pos = wx.TB_HORIZONTAL | wx.TB_TOP
        elif position == "bottom":
            flag_pos = wx.TB_HORIZONTAL | wx.TB_BOTTOM
        elif position == "left":
            flag_pos = wx.TB_VERTICAL | wx.TB_LEFT
        elif position == "right":
            flag_pos = wx.TB_VERTICAL | wx.TB_RIGHT

        # Combine the flags using bitwise OR
        flags = flag_pos | wx.TB_FLAT | wx.TB_DOCKABLE

        # Check the configuration settings for text and icons
        if show_text:
            flags |= wx.TB_TEXT
        if not show_icons:
            flags |= wx.TB_NOICONS

        return flags

    # -----------------------------------------------
    #                  _on_button_menu
    # -----------------------------------------------
    def _on_button_menu(self, event):
        button_id = event.GetId()
        button_visible = event.IsChecked()
        # print(f"button_id: {button_id} checked: {button_visible}")
        # Handle the logic to show/hide the button in the toolbar based on the button_id and button_visible
        if button_id == 5:
            self.config.toolbar['visible']['install_apk'] = button_visible
        if button_id == 8:
            self.config.toolbar['visible']['package_manager'] = button_visible
        if button_id == 10:
            self.config.toolbar['visible']['adb_shell'] = button_visible
        if button_id == 15:
            self.config.toolbar['visible']['scrcpy'] = button_visible
        if button_id == 20:
            self.config.toolbar['visible']['device_info'] = button_visible
        # if button_id == 30:
        #     self.config.toolbar['visible']['check_verity'] = button_visible
        if button_id == 40:
            self.config.toolbar['visible']['partition_manager'] = button_visible
        if button_id == 50:
            self.config.toolbar['visible']['pi_analysis_report'] = button_visible
        if button_id == 100:
            self.config.toolbar['visible']['switch_slot'] = button_visible
        if button_id == 110:
            self.config.toolbar['visible']['reboot_system'] = button_visible
        if button_id == 120:
            self.config.toolbar['visible']['reboot_bootloader'] = button_visible
        if button_id == 125:
            self.config.toolbar['visible']['reboot_fastbootd'] = button_visible
        if button_id == 130:
            self.config.toolbar['visible']['reboot_recovery'] = button_visible
        if button_id == 135:
            self.config.toolbar['visible']['reboot_recovery_interactive'] = button_visible
        if button_id == 140:
            self.config.toolbar['visible']['reboot_safe_mode'] = button_visible
        if button_id == 150:
            self.config.toolbar['visible']['reboot_download'] = button_visible
        if button_id == 160:
            self.config.toolbar['visible']['reboot_sideload'] = button_visible
        if button_id == 200:
            self.config.toolbar['visible']['magisk_modules'] = button_visible
        if button_id == 210:
            self.config.toolbar['visible']['install_magisk'] = button_visible
        if button_id == 220:
            self.config.toolbar['visible']['magisk_backup_manager'] = button_visible
        if button_id == 225:
            self.config.toolbar['visible']['pif_manager'] = button_visible
        if button_id == 230:
            self.config.toolbar['visible']['sos'] = button_visible
        if button_id == 300:
            self.config.toolbar['visible']['lock_bootloader'] = button_visible
        if button_id == 310:
            self.config.toolbar['visible']['unlock_bootloader'] = button_visible
        if button_id == 900:
            self.config.toolbar['visible']['configuration'] = button_visible

        self.toolbar_flags = self.get_toolbar_config()
        # Rebuild the toolbar with the updated flags
        self._build_toolbar(self.toolbar_flags, True)

    # -----------------------------------------------
    #                  _on_tb_update
    # -----------------------------------------------
    def _on_tb_update(self, event):
        clicked_item_id = event.GetId()
        # print(f"Clicked item ID: {clicked_item_id}")

        if clicked_item_id == 21010:
            self.config.toolbar['tb_position'] = 'top'
        elif clicked_item_id == 21020:
            self.config.toolbar['tb_position'] = 'left'
        elif clicked_item_id == 21030:
            self.config.toolbar['tb_position'] = 'right'
        elif clicked_item_id == 21040:
            self.config.toolbar['tb_position'] = 'bottom'
        elif clicked_item_id == 21100:
            # Button Text
            self.config.toolbar['tb_show_text'] = event.IsChecked()
            if not event.IsChecked():
                self.config.toolbar['tb_show_icons'] = True
                self.tb_show_button_item.Check(True)
        elif clicked_item_id == 21200:
            # Button icon
            self.config.toolbar['tb_show_icons'] = event.IsChecked()
            if not event.IsChecked():
                self.config.toolbar['tb_show_text'] = True
                self.tb_show_text_item.Check(True)

        self.toolbar_flags = self.get_toolbar_config()
        # Rebuild the toolbar with the updated flags
        self._build_toolbar(self.toolbar_flags, True)

    # -----------------------------------------------
    #                  _build_devices_menu
    # -----------------------------------------------
    def _build_devices_menu(self):
        # Clear existing items and mapping
        while self.devices_menu.GetMenuItemCount() > 0:
            self.devices_menu.DestroyItem(self.devices_menu.FindItemByPosition(0))

        # Initialize device menu item mapping
        self._device_menu_map = {}

        # Scan Enabled Devices
        scan_enabled_item = self.devices_menu.Append(wx.ID_ANY, _("Scan Enabled Devices"), _("Scan only enabled devices (faster)"))
        scan_enabled_item.SetBitmap(images.scan_24.GetBitmap() if hasattr(images, 'scan_24') else wx.NullBitmap)
        self.Bind(wx.EVT_MENU, self._on_scan_enabled_devices, scan_enabled_item)

        # Scan All Devices
        scan_all_item = self.devices_menu.Append(wx.ID_ANY, _("Scan All Devices"), _("Scan all connected devices regardless of enable/disable settings"))
        scan_all_item.SetBitmap(images.scan_all_24.GetBitmap() if hasattr(images, 'scan_all_24') else wx.NullBitmap)
        self.Bind(wx.EVT_MENU, self._on_scan_all_devices, scan_all_item)

        self.devices_menu.AppendSeparator()

        # Load devices from devices.json
        devices = load_devices_json()

        if not devices:
            # No devices found in config
            no_devices_item = self.devices_menu.Append(wx.ID_ANY, _("No devices configured"), _("Connect and scan devices to populate this list"))
            no_devices_item.Enable(False)
        else:
            # Add each device as a checkable menu item
            for device_id, device_data in sorted(devices.items()):
                enabled = device_data.get('enabled', True)
                connected = device_data.get('connected', False)

                # Build display name using get_device_display_name
                display_name = get_device_display_name(device_id)

                # Add visual indicator for connected devices
                if connected:
                    display_name = "● " + display_name
                else:
                    display_name = "○ " + display_name

                menu_id = wx.NewIdRef()
                menu_item = self.devices_menu.Append(menu_id, display_name, _("Click to enable/disable device scanning"), wx.ITEM_CHECK)
                menu_item.Check(enabled)

                # Store device_id mapping
                self._device_menu_map[menu_id] = device_id

                self.Bind(wx.EVT_MENU, self._on_device_toggle, menu_item)

        # Manage Devices
        if devices:
            self.devices_menu.AppendSeparator()
        manage_devices_item = self.devices_menu.Append(wx.ID_ANY, _("Manage Devices ..."), _("Manage device entries - delete, rename, enable/disable"))
        manage_devices_item.SetBitmap(images.settings_24.GetBitmap() if hasattr(images, 'settings_24') else wx.NullBitmap)
        self.Bind(wx.EVT_MENU, self._on_manage_devices, manage_devices_item)

        # Force menu bar to refresh
        self.menuBar.Update()
        self.menuBar.Refresh()

    # -----------------------------------------------
    #                  _on_scan_all_devices
    # -----------------------------------------------
    def _on_scan_all_devices(self, event):
        self._perform_scan(scan_all=True)

    # -----------------------------------------------
    #                  _on_scan_enabled_devices
    # -----------------------------------------------
    def _on_scan_enabled_devices(self, event):
        self._perform_scan(scan_all=False)

    # -----------------------------------------------
    #                  _on_device_toggle
    # -----------------------------------------------
    def _on_device_toggle(self, event):
        menu_id = event.GetId()
        device_id = self._device_menu_map.get(menu_id)
        if device_id:
            new_state = toggle_device_enabled(device_id)
            if new_state is not None:
                status = "enabled" if new_state else "disabled"
                print(f"Device {device_id} is now {status} for scanning.")
                self.toast(_("Device Scan"), _("Device %s is now %s for scanning.") % (device_id, status))

    # -----------------------------------------------
    #                  _on_manage_devices
    # -----------------------------------------------
    def _on_manage_devices(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Manage Devices")
            print("==============================================================================")
            puml(":Manage Devices;\n", True)
            dlg = ManageDevicesDialog(self)
            dlg.ShowModal()
            dlg.Destroy()

            # Refresh the Devices menu to reflect any changes
            self._build_devices_menu()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error opening Manage Devices dialog")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_help_about
    # -----------------------------------------------
    def _on_help_about(self, event):
        from About import AboutDlg
        about = AboutDlg(self)
        about.ShowModal()
        about.Destroy()

    # -----------------------------------------------
    #                  _on_advanced_config
    # -----------------------------------------------
    def _on_advanced_config(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Settings")
        print("==============================================================================")
        advanced_setting_dialog = AdvancedSettings(parent=self)
        advanced_setting_dialog.CentreOnParent(wx.BOTH)
        print("Entering Advanced Configuration ...")
        res = advanced_setting_dialog.ShowModal()
        advanced_setting_dialog.Destroy()
        if res == wx.ID_OK:
            # self.Freeze()
            # show / hide advanced settings
            self._advanced_options_hide(not self.config.advanced_options)
            populate_boot_list(self)
            set_flash_button_state(self)
            self.toolbar_flags = self.get_toolbar_config()
            # Rebuild the toolbar with the updated flags
            self._build_toolbar(self.toolbar_flags, True)
            self.update_widget_states()
            # save config
            self.config.save(get_config_file_path())
            # self.Thaw()

    # -----------------------------------------------
    #                  _on_package_manager
    # -----------------------------------------------
    def _on_package_manager(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated App Manager")
        print("==============================================================================")
        self._on_spin('start')
        dlg = None
        try:
            # load labels if not already loaded
            if not get_labels() and os.path.exists(get_labels_file_path()):
                with open(get_labels_file_path(), "r", encoding='ISO-8859-1', errors="replace") as f:
                    set_labels(json.load(f))
            try:
                dlg = PackageManager(self)
            except Exception:
                traceback.print_exc()
                return
            if dlg is None or dlg.device is None:
                self.clear_device_selection()
                return
            dlg.CentreOnParent(wx.BOTH)
            self._on_spin('stop')
            try:
                result = dlg.ShowModal()
                if result != wx.ID_OK:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Closing App Manager ...\n")
            except Exception:
                traceback.print_exc()
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_install_apk
    # -----------------------------------------------
    def _on_install_apk(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Install APK")
        print("==============================================================================")
        device = get_phone(True)
        if not device:
            print("ERROR: Please select a device before attempting APK Installation")
            self.toast(_("APK Install"), _("❌ ERROR: Please select a device before attempting APK Installation."))
            self.clear_device_selection()
            return

        wildcard = "Android Applications (*.apk)|*.apk"
        dialog = wx.FileDialog(self, _("Select one or multiple APK file(s) to install"), wildcard=wildcard, style=wx.FD_OPEN | wx.FD_MULTIPLE)

        if dialog.ShowModal() == wx.ID_CANCEL:
            print("⚠️ User cancelled the file(s) selection operation")
            return     # the user changed their mind
        paths = dialog.GetPaths()
        dialog.Destroy()

        try:
            title = _("APK installation options")
            buttons_text = [_("Install"), _("Cancel")]
            checkboxes=[_("Set ownership to Play Store Market"), _("Bypass low target sdk block")]
            message = _("**APK installation options**<br/>\n")
            message += "\n"
            message += _("This is a summary of available options.<br/>\n")
            message += "\n"
            message += _("1. **Set ownership to Play Store Market** This option sets the ownership to Play Store (as if it was installed from Play Store).<br/>\n")
            message += _("   Android auto apps require that they be installed from the Play Market.<br/>\n")
            message += "\n"
            message += _("2. Starting with Android 14, apps with a targetSdkVersion lower than 23 can't be installed.<br/>\n")
            message += _("   Requiring apps to meet these minimum target API level requirements improves security and privacy for users.<br/><br/>\n")
            message += _("   Malware often targets older API levels in order to bypass security and privacy protections that have been introduced in newer Android versions.<br/>\n")
            message += _("   For example, some malware apps use a `targetSdkVersion` of 22 to avoid being subjected to the runtime permission model\n")
            message += _("   introduced in 2015 by Android 6.0 Marshmallow (API level 23).<br/>\n")
            message += _("   This Android 14 change makes it harder for malware to avoid security and privacy improvements.<br/>\n")
            message += _("   Attempting to install an app targeting a lower API level will result in an installation failure.<br/><br/>\n")
            message += _("   **Bypass low target sdk block** option bypasses that enforcement.\n")
            message += "\n"
            message += _("_If you have selected multiple APKs to install, the options will apply to all APKs._\n")

            print(f"\n*** Dialog ***\n{message}\n______________\n")
            puml(":Dialog;\n", True)
            puml(f"note right\n{message}\nend note\n")
            dlg = MessageBoxEx(
                parent=self,
                title=title,
                message=message,
                button_texts=buttons_text,
                default_button=1,
                disable_buttons=None,
                is_md=True,
                size=[960,520],
                checkbox_labels=checkboxes,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result > 0 and result <= len(buttons_text):
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result - 1]}")
                puml(f":User Pressed {buttons_text[result - 1]};\n")
            else:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Dialog closed or invalid result: {result}")
                puml(f":Dialog closed or invalid result;\n")

            method = result
            if method == 2:
                puml("}\n")
                print("Aborting ...\n")
                return
            print("Selected options:")
            checkbox_values = get_dlg_checkbox_values()
            for i in range(len(checkboxes)):
                print(f"{checkboxes[i]}: {bool(checkbox_values[i])}")
            print("\n")

            self._on_spin('start')
            count = len(paths)
            i = 0
            for pathname in paths:
                i += 1
                debug(f"Installing {i}/{count} {ntpath.basename(pathname)} ...")
                try:
                    device.install_apk(pathname, fastboot_included=True, owner_playstore=checkbox_values[0], bypass_low_target=checkbox_values[1])
                except IOError:
                    traceback.print_exc()
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Cannot install file '{pathname}'")
        except Exception:
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_move_end
    # -----------------------------------------------
    def _on_move_end(self, event):
        if self.resizing:
            # Perform the action only if resizing is complete
            self.resizing = False
            auto_resize_boot_list(self)
        event.Skip()

    # -----------------------------------------------
    #                  _on_close
    # -----------------------------------------------
    def _on_close(self, event):
        self.config.pos_x, self.config.pos_y = self.GetPosition()
        self.config.save(get_config_file_path())
        puml("#palegreen:Exit PixelFlasher;\nend\n@enduml\n")
        wx.Exit()

    # -----------------------------------------------
    #                  _on_resize
    # -----------------------------------------------
    def _on_resize(self, event):
        self.resizing = True
        self.config.width = self.Rect.Width
        self.config.height = self.Rect.Height

        self.Layout()
        event.Skip(True)

    # -----------------------------------------------
    #                  _on_link_clicked
    # -----------------------------------------------
    def _on_link_clicked(self, event):
        try:
            self._on_spin('start')
            menu_item_id = event.GetId()

            # Handle special cases like issue, feature, project items
            special_items = {
                self.issue_item.GetId(): (HELP_MENU_ITEMS["issue"]["url"], HELP_MENU_ITEMS["issue"]["description"]),
                self.feature_item.GetId(): (HELP_MENU_ITEMS["feature"]["url"], HELP_MENU_ITEMS["feature"]["description"]),
                self.project_page_item.GetId(): (HELP_MENU_ITEMS["project"]["url"], HELP_MENU_ITEMS["project"]["description"]),
                self.forum_item.GetId(): (HELP_MENU_ITEMS["forum"]["url"], HELP_MENU_ITEMS["forum"]["description"]),
            }

            # Check if this is one of our links menu items
            if menu_item_id in special_items:
                url, description = special_items[menu_item_id]
            elif hasattr(self, 'link_urls') and menu_item_id in self.link_urls:
                url, description = self.link_urls[menu_item_id]
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unknown menu item clicked, id: {menu_item_id}")
                self._on_spin('stop')
                return

            print(f"Open Link {description} {url}")
            puml(f":Open Link;\nnote right\n=== {description}\n[[{url}]]\nend note\n", True)
            res = webbrowser.open_new(url)
            debug(f"Open Link {description} {url} {res}")

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening a link")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_open_config_folder
    # -----------------------------------------------
    def _on_open_config_folder(self, event):
        try:
            self._on_spin('start')
            open_folder(self, get_sys_config_path())
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening configuration folder")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_open_pf_home
    # -----------------------------------------------
    def _on_open_pf_home(self, event):
        try:
            self._on_spin('start')
            open_folder(self, get_config_path())
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening PixelFlasher working directory")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_support_zip
    # -----------------------------------------------
    def _on_support_zip(self, event):
        timestr = time.strftime('%Y-%m-%d_%H-%M-%S')
        with wx.FileDialog(self, _("Save support file"), '', f"support_{timestr}.zip", wildcard="Support files (*.zip)|*.zip",
                        style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:

            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return     # the user changed their mind

            # save the current contents in the file
            pathname = fileDialog.GetPath()
            try:
                config_path = get_config_path()
                support_zip = os.path.join(config_path, 'support.zip')
                self._on_spin('start')
                create_support_zip()
                debug(f"Saving support file to: {pathname}")
                with open(support_zip, "rb") as binaryfile :
                    with open(pathname, 'wb') as file:
                        byte_array = binaryfile.read()
                        file.write(byte_array)
                print(f"Saved support file to: {pathname}")
            except IOError:
                wx.LogError(f"Cannot save current data in file '{pathname}'.")
                traceback.print_exc()
            finally:
                self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_exit_app
    # -----------------------------------------------
    def _on_exit_app(self, event):
        self.config.save(get_config_file_path())
        self.Close(True)

    # -----------------------------------------------
    #                  OnColClick
    # -----------------------------------------------
    def OnColClick(self, event):
        column = event.GetColumn() + 1
        current_sort_column = self.config.boot_sort_column

        # Determine the sort column and direction based on the clicked column
        if current_sort_column == column:
            # Same column clicked, toggle the sorting direction
            sorting_direction = 'DESC' if self.config.boot_sorting_direction == 'ASC' else 'ASC'
        else:
            # Different column clicked, default sorting direction is ASC
            sorting_direction = 'ASC'

        self.config.boot_sort_column = column
        self.config.boot_sorting_direction = sorting_direction

        populate_boot_list(self, sortColumn=column, sorting_direction=sorting_direction)

    # -----------------------------------------------
    #                  toast
    # -----------------------------------------------
    def toast(self, title, message):
        if self.config.show_notifications:
            notification = wx.adv.NotificationMessage(title, message, parent=None, flags=wx.ICON_INFORMATION)
            notification.SetIcon(images.Icon_dark_256.GetIcon())
            notification.Show()

    # -----------------------------------------------
    #                  _on_xml_view
    # -----------------------------------------------
    def _on_xml_view(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Dump Screen Xml")
        print("==============================================================================")
        try:
            self._on_spin('start')
            device = get_phone(True)
            if not device:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
                self.toast(_("Dump Screen Xml"), _("❌ ERROR: No device selected"))
                self.clear_device_selection()
                return
            timestr = time.strftime('%Y-%m-%d_%H-%M-%S')
            with wx.FileDialog(self, _("Dump Screen Xml"), '', f"screen_dump_{timestr}.xml", wildcard="Screen Dump (*.xml)|*.xml",
                            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    return     # the user changed their mind
                pathname = fileDialog.GetPath()
                device.ui_action(f"/data/local/tmp/screen_dump_{timestr}.xml", pathname)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered in function _on_xml_view")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_cancel_ota
    # -----------------------------------------------
    def _on_cancel_ota(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Cancel OTA Update")
        print("==============================================================================")
        try:
            self._on_spin('start')
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel OTA Update")
            device = get_phone(True)
            if device:
                ota_clean_start_time = time.time()
                res = device.reset_ota_update()
                ota_clean_time = time.time() - ota_clean_start_time
                if ota_clean_time > 10:
                    print(f"ℹ️ Cleaning up previous OTA update took {ota_clean_time:.2f} seconds. Cleaning it again one more time for good measure ...")
                    res = device.reset_ota_update()
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
                self.toast(_("Cancel OTA Update"), _("❌ ERROR: No device selected"))
                self.clear_device_selection()
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while cancelling OTA Update")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_check_otacerts
    # -----------------------------------------------
    def _on_check_otacerts(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Check OTA Certs")
        print("==============================================================================")
        try:
            self._on_spin('start')
            debug(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Check OTA Certs")
            device = get_phone(True)
            if device:
                res = device.exec_cmd("unzip -l /system/etc/security/otacerts.zip")
                print(res)
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
                self.toast(_("Check OTA Certs"), _("❌ ERROR: No device selected"))
                self.clear_device_selection()
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking OTA Certs")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  Test
    # -----------------------------------------------
    def Test(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Test Function")
        print("==============================================================================")
        print("Entering Test function (used during development only) ...")
        # print("Error: ❌ (U+274C, Cross Mark)")
        # print("Warning: ⚠️ (U+26A0, Warning)")
        # print("Info: ℹ️ (U+2139, Information Source)")
        # print("Fatal: ☠️ (U+2620, Skull and Crossbones)")
        # print("Checkmark: ✅")

        # device = get_phone(True)
        # if device:
        #     update_phones(device.id)
        self.clear_device_selection()

    # -----------------------------------------------
    #                  _on_open_url_on_device
    # -----------------------------------------------
    def _on_open_url_on_device(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Open URL on Device")
        print("==============================================================================")
        try:
            device = get_phone(True)
            if device:
                # show a dialog to enter the URL
                title = _("Open URL on Device")
                message = _("Enter the URL to open on the device:")
                dlg = wx.TextEntryDialog(self, message, title, "https://")
                dlg.CentreOnParent(wx.BOTH)
                if dlg.ShowModal() == wx.ID_OK:
                    url = dlg.GetValue().strip()
                    if not url:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: URL cannot be empty")
                        self.toast(_("Open URL on Device"), _("❌ ERROR: URL cannot be empty."))
                        return
                    print(f"Opening URL on device: {url}")
                    puml(f":Open URL on Device;\nnote right\n=== Open URL on Device\n[[{url}]]\nend note\n", True)
                    res = device.perform_package_action(pkg=None, action='open-url', isSystem=False, url=url)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening URL on device")
            traceback.print_exc()
            self.toast(_("Open URL on Device"), _("❌ ERROR: Failed to open URL on device."))

    # -----------------------------------------------
    #                  _on_pi_analysis_report
    # -----------------------------------------------
    def _on_pi_analysis_report(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Device analysis for PIF")
        print("==============================================================================")
        timestr = time.strftime('%Y-%m-%d_%H-%M-%S')
        device = get_phone(True)
        current_debug = get_verbose()

        if not device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: No device selected")
            print("Please select a device and try again.")
            print("Aborting ...")
            self.clear_device_selection()
            return -1

        title = "Device Analysis Report"
        message = _("**This feature will generate a device analysis report that you could optionally post online to get assistance on Play Integrity related issues.**<br/>\n")
        message += "\n"
        message += _("There will be two versions created.<br/>\n")
        message += "\n"
        message += _("1. Unfiltered version, that would have some sensitive information such as Device ID.\n")
        message += _("2. Sanitized version which will filter out sensitive information<br/>\n")
        message += "\n"
        message += _("**Note:** If you're using publicly shared keybox, keep the checkbox `Redact Keybox details` unticked so that the keybox information is included in the report.<br/>\n")
        message += _("If you're using a private keybox, please tick the checkbox `Redact Keybox details` to redact keybox details.<br/>\n")
        message += "\n"
        message += _("**This report will include the following details:**<br/>\n")
        message += "\n"
        message += _("- Device state and other device related details.\n")
        message += _("- Magisk (if available):\n")
        message += _("	- modules list.\n")
        message += _("	- denylist.\n")
        message += _("- TrickyStore (if available):\n")
        message += "	- `/data/adb/tricky_store/spoof_build_vars`\n"
        message += _("	- `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)\n")
        message += "	- `/data/adb/tricky_store/target.txt`\n"
        message += "	- `/data/adb/tricky_store/security_patch.txt`\n"
        message += "	- `/data/adb/tricky_store/tee_status`\n"
        message += _("- PlayIntegrity Fork (if available):\n")
        message += "	- `/data/adb/modules/playintegrityfix/custom.pif.json`\n"
        message += "	- `/data/adb/modules/playintegrityfix/custom.pif.prop`\n"
        message += "	- `/data/adb/modules/playintegrityfix/custom.app_replace.list`\n"
        message += "	- `/data/adb/modules/playintegrityfix/scripts-only-mode`\n"
        message += _("- TargetedFix (if available):\n")
        message += f"	- `{TARGETEDFIX_CONFIG_PATH}/target.txt`\n"
        message += _("	- Contents of every app json configuration referenced in target.txt\n")
        message += _("- PlayIntegrityFix (if available):\n")
        message += "	- `/data/adb/modules/playintegrityfix/pif.json`\n"
        message += "	- `/data/adb/pif.json`\n"
        message += _("- Whether a testkey ROM is used or not.\n")
        message += _("- logcat for PlayIntegrity and TrickyStore related logs.\n")
        message += _("- Playstore and GMS versions.\n")
        message += _("- Droidguard VM list.\n")
        message += _("- If any custom ROM injection apps are installed from:\n")
        message += "    - Xiaomi.eu\n"
        message += "    - EliteRoms\n"
        message += "    - helluvaOS\n"
        message += "    - hentaiOS\n"
        message += "    - Evolution X\n"
        message += "    - PixelOS\n"
        message += _("- Check overlays (if contents of /debug_ramdisk is visible without root)\n")
        message += "\n"
        message += _("**NOTE:**\n")
        message += _("This report will be saved at a location of your choosing, and will **not** be part of PixelFlasher captured logs (even though you see it in the console), so rest assured, if you submit support.zip for PixelFlasher related issues, even if you had generated such report, it will never be included in the support.zip file.<br/>\n")
        message += _("Your privacy is yours to keep.<br/>\n")
        message += "\n"
        message += _("If you continue you'd only be generating the report, and not posting it online.<br/>\n")
        message += _("If you want to post it online, please make sure to remove any sensitive information from the report before posting it online.<br/>\n")
        message += "\n"
        message += _("**Are you sure you want to continue?**<br/>\n")

        checkboxes = [_("Redact Keybox details")]
        checkbox_initial_values = [False]
        dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=[_('Yes'), _('No')],
            default_button=1,
            disable_buttons=None,
            is_md=True,
            size=[915,700],
            checkbox_labels=checkboxes,
            checkbox_initial_values=checkbox_initial_values,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()
        dlg.Destroy()

        option = result
        # option 2 - No
        if option == 2:
            print("User canceled Device Analysis.")
            print("Aborting ...\n")
            return -1
        # option 1 - Yes
        elif option == 1:
            checkbox_values = get_dlg_checkbox_values()
            if checkbox_values is not None:
                for i in range(len(checkboxes)):
                    print(f"{checkboxes[i]}: {bool(checkbox_values[i])}")
                print("\n")
                # enable / disable redaction based on checkbox
                redact_keybox = checkbox_values[0]

            set_puml_state(False)
            if device and device.hardware:
                hardware = device.hardware
            else:
                hardware = "unknown"
            with wx.FileDialog(self, _("Save device analysis"), '', f"{hardware}_analysis_{timestr}.log", wildcard="log files (*.log)|*.log",
                            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    return     # the user changed their mind

                logfile = fileDialog.GetPath()
            try:
                self._on_spin('start')
                config_path = get_config_path()
                tmp_dir_full = os.path.join(config_path, 'tmp')

                print(f"Logging to {logfile}")
                self.change_logfile(logfile)
                t = f":{datetime.now():%Y-%m-%d %H:%M:%S}"
                print("\n==============================================================================")
                print(f" 🚀 {datetime.now():%Y-%m-%d %H:%M:%S} Starting Device analysis for PIF")
                print("==============================================================================")
                print(f"PixelFlasher version: {VERSION}")

                # Device details
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Getting Device details ...")
                print("==============================================================================")
                set_verbose(not redact_keybox)
                self._print_device_details(device)
                set_verbose(current_debug)
                if not device.rooted:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: device is not rooted")
                    print("Perhaps su permissions are not granted to shell process?")
                    print("Please grant su permissions to shell process and try again.\nPixelFlasher should show that the device is rooted.")
                    print("Aborting ...")
                    return -1

                # Testkey check
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking for testkey ...")
                print("==============================================================================")
                self._on_spin('start')
                self._on_check_otacerts(None)

                # SELinux Load timestamp
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking SElinux load timestamp ...")
                print("==============================================================================")
                self._on_spin('start')
                res = device.selinux_load_timestamp()
                print(res)

                # Overlay FS Mount count
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Overlay FS Mount count ...")
                print("==============================================================================")
                self._on_spin('start')
                res = device.mount_count()
                print(res)

                # Magisk Denylist / Enforced
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Magisk denylist ...")
                print("==============================================================================")
                self._on_spin('start')
                cmd = "magisk --denylist ls"
                res = device.exec_cmd(cmd, True)
                print(res)

                # Magisk Denylist / Enforced
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Magisk denylist enforced ...")
                print("==============================================================================")
                self._on_spin('start')
                res = device.magisk_denylist_enforced
                if res:
                    print("Magisk denylist is enforced")
                else:
                    print("Magisk denylist is not enforced")

                # Zygisk enabled
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Zygisk status ...")
                print("==============================================================================")
                self._on_spin('start')
                res = device.magisk_zygisk_enabled
                if res:
                    print("Magisk Zygisk is enabled")
                else:
                    print("Magisk Zygisk is disabled")

                # TrickyStore - spoof_build_vars
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Tricky Store spoof_build_vars ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/tricky_store/spoof_build_vars", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # TrickyStore - target.txt
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Tricky Store target.txt ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/tricky_store/target.txt", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # TrickyStore - security_patch.txt
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Tricky Store security_patch.txt ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/tricky_store/security_patch.txt", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # TrickyStore - tee_status
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Tricky Store tee_status ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/tricky_store/tee_status", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # TrickyStore - keybox.xml
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Tricky Store keybox status ...")
                print("==============================================================================")
                keybox_xml = '/data/adb/tricky_store/keybox.xml'
                res, unused = device.check_file(keybox_xml, True, False)
                if res == 1:
                    keybox_file = os.path.join(tmp_dir_full, "keybox.xml")
                    debug(f"Pulling {keybox_xml} from the phone to: {keybox_file} ...")
                    res = device.pull_file(keybox_xml, f"\"{keybox_file}\"", with_su=True)
                    if res != 0:
                        print(f"Error: Failed to pull {keybox_xml} from the phone.")
                    else:
                        set_verbose(not redact_keybox)
                        res = check_kb(keybox_file)
                        print(f"Result: {res}")
                        set_verbose(current_debug)

                # PlayIntegrity Fork - custom.pif.json
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking PlayIntegrity Fork custom.pif.json ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/modules/playintegrityfix/custom.pif.json", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # PlayIntegrity Fork - custom.pif.prop
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking PlayIntegrity Fork custom.pif.prop ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/modules/playintegrityfix/custom.pif.prop", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # PlayIntegrity Fork - custom.app_replace.list
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking PlayIntegrity Fork custom.app_replace.list ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/modules/playintegrityfix/custom.app_replace.list", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # PlayIntegrity Fork - custom.app_replace_list.txt
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking PlayIntegrity Fork custom.app_replace_list.txt ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/modules/playintegrityfix/custom.app_replace_list.txt", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # PlayIntegrity Fork - scripts-only-mode
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking PlayIntegrity Fork custom.app_replace.list ...")
                print("==============================================================================")
                res, unused = device.check_file('/data/adb/modules/playintegrityfix/scripts-only-mode', True, False)
                if res == 1:
                    print("scripts-only-mode is enabled")
                else:
                    print("scripts-only-mode is disabled")

                # TargetedFix target.txt
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking TargetedFix target.txt ...")
                print("==============================================================================")
                res = device.file_content(f"{TARGETEDFIX_CONFIG_PATH}/target.txt", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")
                    for line in res.splitlines():
                        if line:
                            target = device.file_content(f"{TARGETEDFIX_CONFIG_PATH}/{line.strip()}.json", True, False)
                            if target != -1:
                                print(f"--------------------\n{line.strip()}\n--------------------")
                            else:
                                print(f"--------------------\n{line.strip()} - Not found\n--------------------")

                # PlayIntegrityFix - pif.json
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking PlayIntegrityFix pif.json ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/modules/playintegrityfix/pif.json", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # PlayIntegrityFix - older pif.json
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking PlayIntegrityFix older pif.json ...")
                print("==============================================================================")
                res = device.file_content("/data/adb/pif.json", True, False)
                if res != -1:
                    print(f"--------------------\n{res}\n--------------------")

                # Playstore versions
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking Playstore versions ...")
                print("==============================================================================")
                res = device.exec_cmd("dumpsys package com.android.vending | grep -e versionName -e codePath", True)
                print(res)

                # GMS versions
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking GMS versions ...")
                print("==============================================================================")
                res = device.exec_cmd("dumpsys package com.google.android.gms | grep -e versionName -e codePath", True)
                print(res)

                # Check for conflicting custom ROM injection apps
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Check for custom ROM injection apps ...")
                print("==============================================================================")
                # # Xiaomi.eu
                print("Checking for Xiaomi.eu ROM injection ...")
                res = device.exec_cmd("ls -lR /product/app/XiaomiEUInject", True)
                print(res)
                res = device.exec_cmd("ls -lR /product/app/XiaomiEUInject-Stub", True)
                print(res)
                # # EliteRoms
                print("Checking for EliteRoms ROM injection ...")
                res = device.exec_cmd("ls -lR /system/app/EliteDevelopmentModule", True)
                print(res)
                res = device.exec_cmd("ls -lR /system/app/XInjectModule", True)
                print(res)
                # # helluvaOS
                print("Checking for helluvaOS ROM injection ...")
                res = device.exec_cmd("ls -lR /system_ext/app/helluvaProductDevice*", True)
                print(res)
                res = device.exec_cmd("ls -lR /system_ext/app/helluvaProductSecretStub", True)
                print(res)
                # # hentaiOS
                print("Checking for hentaiOS ROM injection ...")
                res = device.exec_cmd("ls -lR /system_ext/app/hentaiLewdbSVTDummy", True)
                print(res)
                # # Evolution X
                print("Checking for Evolution X ROM injection ...")
                res = device.exec_cmd("ls -lR /system_ext/app/PifPrebuilt", True)
                print(res)
                # # PixelOS
                print("Checking for PixelOS ROM injection ...")
                res = device.exec_cmd("ls -lR /system_ext/overlay/CertifiedPropsOverlay.apk", True)
                print(res)

                # Check for overlay detection
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Check for overlay detection ...")
                print("==============================================================================")
                print("Checking for /debug_ramdisk contents without root...")
                res = device.exec_cmd("ls -lR /debug_ramdisk", False)
                print(res)
                print("Checking for /debug_ramdisk contents with root...")
                res = device.exec_cmd("ls -lR /debug_ramdisk", True)
                print(res)

                # Check for Droidguard VM list
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Checking for droidguard VM list ...")
                print("==============================================================================")
                res = device.exec_cmd("ls -lR /data/data/com.google.android.gms/app_dg_cache", True)
                print(res)

                # logcat for PlayIntegrity related logs
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} Getting pif logcat ...")
                print("==============================================================================")
                res = device.get_logcat("pif", True)
                if res:
                    print(f"--------------------\n{res}\n--------------------")

                # logcat for PlayIntegrity related logs
                print("\n==============================================================================")
                print(f" 🔍 {datetime.now():%Y-%m-%d %H:%M:%S} getting Tricky Store logcat ...")
                print("==============================================================================")
                res = device.get_logcat("tricky", True)
                if res:
                    print(f"--------------------\n{res}\n--------------------")

            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while analyzing the device")
                traceback.print_exc()
            finally:
                print(f"Device Analysis Complete, saved to {logfile}")
                sanitized_logfile = logfile.replace('.log', '_sanitized.log')
                if os.path.exists(logfile):
                    try:
                        import shutil
                        shutil.copy2(logfile, sanitized_logfile)
                        sanitize_file(sanitized_logfile)
                        print(f"Sanitized copy saved to: {sanitized_logfile}")
                    except Exception as e:
                        print(f"❌ Error creating sanitized copy: {e}")
                set_puml_state(True)
                self.reset_logfile()
                set_verbose(current_debug)
                print(f"End Device Analysis.\n")
                self._on_spin('stop')

    # -----------------------------------------------
    #                  _advanced_options_hide
    # -----------------------------------------------
    def _advanced_options_hide(self, value):
        try:
            self.Freeze()
            if value:
                # flash options
                self.flash_both_slots_checkBox.Hide()
                self.disable_verity_checkBox.Hide()
                self.disable_verification_checkBox.Hide()
                self.fastboot_force_checkBox.Hide()
                self.fastboot_verbose_checkBox.Hide()
                self.temporary_root_checkBox.Hide()
                self.wipe_checkBox.Hide()
                self.no_wipe_downgrade_checkbox.Hide()
                # ROM options
                self.custom_rom_checkbox.Hide()
                self.custom_rom.Hide()
                self.process_rom.Hide()
                # Custom Flash Radio Button
                # if we're turning off advanced options, and the current mode is customFlash, hide, it
                self.mode_radio_button.LastInGroup.Hide()
                # Custom Flash Image options
                self.live_boot_radio_button.Hide()
                self.flash_radio_button.Hide()
                self.image_choice.Hide()
                self.image_file_picker.Hide()
                self.paste_selection.Hide()
                # Menu items
                self.partitions_menu.Enable(False)
                self.logcat_menu.Enable(False)
                self.update_engine_logcat_menu.Enable(False)
                self.get_bootloader_versions_menu.Enable(False)
                self.open_url_menu.Enable(False)
                self.switch_slot_menu.Enable(False)
                self.reboot_fastbootd_menu.Enable(False)
                self.reboot_recovery_menu.Enable(False)
                self.reboot_recovery_interactive_menu.Enable(False)
                self.reboot_safe_mode_menu.Enable(False)
                self.reboot_download_menu.Enable(False)
                self.reboot_sideload_menu.Enable(False)
                self.bootloader_lock_menu.Enable(False)
                self.bootloader_unlock_menu.Enable(False)
                self.prep_downgrade_patch_menu.Enable(False)
                #
                a = self.mode_radio_button.Name
                # if we're turning off advanced options, and the current mode is customFlash, change it to dryRun
                if self.mode_radio_button.Name == 'mode-customFlash' and self.mode_radio_button.GetValue():
                    if get_ota():
                        self.enable_disable_radio_button('OTA', True, selected=True, just_select=True)
                        self.config.flash_mode = 'OTA'
                    else:
                        #self.mode_radio_button.PreviousInGroup.SetValue(True)
                        self.enable_disable_radio_button('dryRun', True, selected=True, just_select=True)
                        self.config.flash_mode = 'dryRun'
            else:
                # flash options
                self.flash_both_slots_checkBox.Show()
                self.disable_verity_checkBox.Show()
                self.disable_verification_checkBox.Show()
                self.fastboot_force_checkBox.Show()
                self.fastboot_verbose_checkBox.Show()
                self.temporary_root_checkBox.Show()
                self.wipe_checkBox.Show()
                self.no_wipe_downgrade_checkbox.Show()
                # ROM options
                self.custom_rom_checkbox.Show()
                self.custom_rom.Show()
                self.process_rom.Show()
                # Custom Flash Radio Button
                self.mode_radio_button.LastInGroup.Show()
                # Custom Flash Image options
                self.live_boot_radio_button.Show()
                self.flash_radio_button.Show()
                self.image_choice.Show()
                self.image_file_picker.Show()
                self.paste_selection.Show()
                # Menu items
                self.partitions_menu.Enable(True)
                self.logcat_menu.Enable(True)
                self.update_engine_logcat_menu.Enable(True)
                self.get_bootloader_versions_menu.Enable(True)
                self.open_url_menu.Enable(True)
                self.switch_slot_menu.Enable(True)
                self.reboot_fastbootd_menu.Enable(True)
                self.reboot_recovery_menu.Enable(True)
                self.reboot_recovery_interactive_menu.Enable(True)
                self.reboot_safe_mode_menu.Enable(True)
                self.reboot_download_menu.Enable(True)
                self.reboot_sideload_menu.Enable(True)
                self.bootloader_lock_menu.Enable(True)
                self.bootloader_unlock_menu.Enable(True)
                self.prep_downgrade_patch_menu.Enable(True)

            if self.config.show_custom_rom_options:
                self.custom_rom_checkbox.Show()
                self.custom_rom.Show()
                self.process_rom.Show()
            else:
                self.custom_rom_checkbox.Hide()
                self.custom_rom.Hide()
                self.process_rom.Hide()

            self.Thaw()
            self._refresh_ui()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while setting advanced options")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        wx.YieldIfNeeded()
        if state == 'start':
            self.spinner.Show()
            self.spinner_label.Show()
            self.support_button.Hide()
            self.spinner.Start()
            self.spinner.Refresh()
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
        else:
            self.spinner.Stop()
            self.spinner.Hide()
            self.spinner_label.Hide()
            self.support_button.Show()
            self.spinner.Refresh()
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))

    # -----------------------------------------------
    #                  _refresh_ui
    # -----------------------------------------------
    def _refresh_ui(self):
        # Update UI (need to do this resize to get the UI properly refreshed.)
        self.Freeze()
        self.Update()
        self.Layout()
        w, h = self.Size
        h = h + 100
        self.Size = (w, h)
        h = h - 100
        self.Size = (w, h)
        self.Thaw()
        self.Refresh()

    # -----------------------------------------------
    #                  _print_device_details
    # -----------------------------------------------
    def _print_device_details(self, device):
        m_version = 0
        m_app_version = 0
        start = time.time()

        print('')
        message = '=======================================\n'
        message += f"Selected Device on {datetime.now():%Y-%m-%d %H:%M:%S}:\n"
        message += '=======================================\n'
        message += f"    Device ID:                       {device.id}\n"
        message += f"    Device Mode:                     {device.true_mode}\n"
        if device.mode == 'f.b' or device.true_mode == 'adb':
            message += f"    Device Model:                    {device.hardware}\n"
            message += f"    Device Active Slot:              {device.active_slot}\n"
            with contextlib.suppress(Exception):
                android_devices = get_android_devices()
                android_device = android_devices[device.hardware]
                if android_device:
                    message += f"    Device Name:                     {android_device['device']}\n"
                    message += f"    Device First API Level:          {android_device['first_api_level']}\n"
                    message += f"    Device Version End Date:         {android_device['android_version_end_date']}\n"
                    message += f"    Device Security Update End Date: {android_device['security_update_end_date']}\n"
            message += f"    Has init_boot partition:         {device.has_init_boot}\n"
            message += f"    Device Bootloader Version:       {device.get_prop('version-bootloader', 'ro.bootloader')}\n"
        if device.true_mode == 'adb':
            message += f"    Device is Rooted:                {device.rooted}\n"
            message += f"    /data/local/tmp accessible:      {device.tmp_readable}\n"
            if not device.tmp_readable:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: /data/local/tmp is not accessible, this will affect some features.")
                print("This often is caused by Apatch or KernelSU.\n You can read about it here with possible solutions: https://github.com/badabing2005/PixelFlasher/issues/275#issuecomment-2641278840")
                self.toast(_("Device Analysis"), _("❌ ERROR: /data/local/tmp is not accessible, this will affect some features."))
            message += f"    Device Build:                    {device.build}\n"
            ro_product_first_api_level = device.get_prop('ro.product.first_api_level')
            message += f"    Device API Level:                {device.api_level}\n"
            with contextlib.suppress(Exception):
                android_versions = get_android_versions()
                launch_version = android_versions[ro_product_first_api_level]
                message += f"    Launch Version:                  {launch_version['Name']}\n"
                message += f"    Attestation Version:             {launch_version['Attestation Version']}\n"
                if device.api_level and device.api.level is not None:
                    android_version = android_versions[device.api_level]
                    message += f"    Android Version:                 {android_version['Version']}\n"
                    message += f"    Android Name:                    {android_version['Name']}\n"
                    message += f"    Android Codename:                {android_version['Codename']}\n"
                    message += f"    Android Release Date:            {android_version['Release date']}\n"
                    message += f"    Android Latest Update:           {android_version['Latest update']}\n"
            if device.rooted:
                message += self.get_vbmeta(device)
            if device.true_mode != 'sideload':
                message += f"    Device Architecture:             {device.architecture}\n"
                message += f"    Device Kernel:                   {device.kernel}\n"
                message += f"    Device Kernel Version:           {device.get_prop('ro.kernel.version')}\n"
                message += f"    Device KMI:                      {device.kmi}\n"
                if not device.kmi:
                    message += f"    Guessed KMI:                     {device.kmi_guessed}\n"
                message += f"    CONFIG_KALLSYMS:                 {device.config_kallsyms}\n"
                message += f"    CONFIG_KALLSYMS_ALL:             {device.config_kallsyms_all}\n"
                message += f"    Page Size:                       {device.get_page_size()}\n"
                message += f"    SElinux load timestamp:          {device.selinux_load_timestamp()}\n"
                message += f"    Overlay FS Mount Count:          {device.mount_count()}\n"
                message += f"    oem_unlock_supported:            {device.get_prop('sys.oem_unlock_supported')}\n"
                message += f"    sys_oem_unlock_allowed:          {device.get_prop('sys.oem_unlock_allowed')}\n"
                message += f"    ro.boot.flash.locked:            {device.ro_boot_flash_locked}\n"
                message += f"    ro.boot.vbmeta.device_state:     {device.ro_boot_vbmeta_device_state}\n"
                # message += f"    vendor.boot.vbmeta.device_state: {device.get_prop('vendor.boot.vbmeta.device_state')}\n"
                message += f"    ro.product.first_api_level:      {ro_product_first_api_level}\n"
                # message += f"    ro.boot.warranty_bit:            {device.get_prop('ro.boot.warranty_bit')}\n"
                message += f"    ro.boot.veritymode:              {device.get_prop('ro.boot.veritymode')}\n"
                message += f"    ro.boot.verifiedbootstate:       {device.ro_boot_verifiedbootstate}\n"
                message += f"    PF Bootloader Status:            {device.get_bl_status().upper()}\n"
                message += f"    ro.build.version.security_patch: {device.get_prop('ro.build.version.security_patch')}\n"
                message += f"    ro.vendor.build.security_patch:  {device.get_prop('ro.vendor.build.security_patch')}\n"
                # message += f"    vendor.boot.verifiedbootstate:   {device.get_prop('vendor.boot.verifiedbootstate')}\n"
                # message += f"    ro.warranty_bit:                 {device.get_prop('ro.warranty_bit')}\n"
                message += f"    ro.secure:                       {device.get_prop('ro.secure')}\n"
                message += f"    ro.zygote:                       {device.get_prop('ro.zygote')}\n"
                message += f"    ro.vendor.product.cpu.abilist:   {device.get_prop('ro.vendor.product.cpu.abilist')}\n"
                message += f"    ro.vendor.product.cpu.abilist32: {device.get_prop('ro.vendor.product.cpu.abilist32')}\n"
                message += f"    ro.boot.hw.soc.sec-ar:           {device.get_prop('ro.boot.hw.soc.sec-ar')}\n"
                message += f"    ro.boot.hw.soc.nonsec-ar:        {device.get_prop('ro.boot.hw.soc.nonsec-ar')}\n"
                m_app_version = device.magisk_app_version
                if m_app_version:
                    message += f"    Magisk Manager Version:          {m_app_version}\n"
                    # message += f"    Magisk Path:                     {device.magisk_path}\n"
                    message += f"      Checked for Package:           {self.config.magisk}\n"
                k_app_version = device.ksu_app_version
                if k_app_version:
                    message += f"    KernelSU App Version:            {k_app_version}\n"
                s_app_version = device.sukisu_app_version
                if s_app_version:
                    message += f"    SukiSU App Version:              {s_app_version}\n"
                w_app_version = device.wild_ksu_app_version
                if w_app_version:
                    message += f"    Wild_KSU App Version:            {w_app_version}\n"
                k_next_app_version = device.ksu_next_app_version
                if k_next_app_version:
                    message += f"    KernelSU Next App Version:       {k_next_app_version}\n"
                a_app_version = device.apatch_app_version
                if a_app_version:
                    message += f"    APatch App Version:              {a_app_version}\n"
                a_next_app_version = device.apatch_next_app_version
                if a_next_app_version:
                    message += f"    APatch Next App Version:         {a_next_app_version}\n"
        elif device.mode == 'f.b':
            message += f"    Device Unlocked:                 {device.unlocked}\n"
            if not device.unlocked:
                message += f"    Device Unlockable:               {device.unlock_ability}\n"
            message += f"    slot-retry-count:a:              {device.get_prop('slot-retry-count:a')}\n"
            message += f"    slot-unbootable:a:               {device.get_prop('slot-unbootable:a')}\n"
            message += f"    slot-successful:a:               {device.get_prop('slot-successful:a')}\n"
            message += f"    slot-retry-count:b:              {device.get_prop('slot-retry-count:b')}\n"
            message += f"    slot-unbootable:b:               {device.get_prop('slot-unbootable:b')}\n"
            message += f"    slot-successful:b:               {device.get_prop('slot-successful:b')}\n"
            message += f"    ap-ar-s:                         {device.get_prop('ap-ar-s')}\n"
            message += f"    ap-ar-ns:                        {device.get_prop('ap-ar-ns')}\n"
            message += f"    PF Bootloader Status:            {device.get_bl_status().upper()}\n"
        if device.rooted:
            message += f"    Device Rooted with:              {device.su_version}\n"
            message += f"    SU Version:                      {device.root_version}\n"
            if "apatch" in device.su_version.lower():
                a_version = device.apatch_version
                message += f"      APatch Version:                {a_version}\n"
                message += "      Apatch Modules:\n"
                modules = device.apatch_modules_summary
                message += f"{modules}"
            elif "kernelsu" in device.su_version.lower():
                k_version = device.ksu_version
                message += f"      KSUd Version:                  {k_version}\n"
                message += "      KSUd Modules:\n"
                modules = device.ksu_modules_summary
                message += f"{modules}"
            else:
                m_version = device.magisk_version
                message += f"      Magisk Version:                {m_version}\n"
                message += f"      Magisk Config SHA1:            {device.magisk_sha1}\n"
                message += f"      Magisk Denylist enforced:      {device.magisk_denylist_enforced}\n"
                message += f"      Magisk Zygisk enabled:         {device.magisk_zygisk_enabled}\n"
                message += "      Magisk Modules:\n"
                modules = device.magisk_modules_summary
                message += f"{modules}"
            if "lsposed" in modules.lower():
                message += "      LSPosed Modules:\n"
                message += f"{device.lsposed_modules_summary}"
            message += "\n"
            message += f"{device.get_battery_details()}\n"
        else:
            print('')
        print(message)
        puml(f"note right\n{message}\nend note\n")
        self._check_for_bad_magisk(m_version, m_app_version)
        self._check_for_bad_kernel(device.kernel)
        end = time.time()
        print(f"Device Load time: {math.ceil(end - start)} seconds")

    # -----------------------------------------------
    #                  get_vbmeta
    # -----------------------------------------------
    def get_vbmeta(self, device, message=''):
        try:
            if device.vbmeta is None:
                message += f"    vbmeta:                          UNKNOWN\n"
            elif device.vbmeta.type == 'none':
                message += f"    vbmeta:                          Not Present\n"
            else:
                alert = ''
                message += f"    vbmeta type:                     {device.vbmeta.type}\n"
                if device.vbmeta.type == 'ab':
                    message += f"    Slot A Verity:                   {enabled_disabled(device.vbmeta.verity_a)}\n"
                    message += f"    Slot A Verification:             {enabled_disabled(device.vbmeta.verification_a)}\n"
                    message += f"    Slot B Verity:                   {enabled_disabled(device.vbmeta.verity_b)}\n"
                    message += f"    Slot B Verification:             {enabled_disabled(device.vbmeta.verification_b)}\n"
                    if ( device.vbmeta.verity_a != device.vbmeta.verity_b ) or ( device.vbmeta.verification_a != device.vbmeta.verification_b ):
                        alert += _("    ⚠️ WARNING! WARNING! WARNING!    Slot a verity / verification does not match slot b verity / verification")
                else:
                    message += f"    Verity:                          {enabled_disabled(device.vbmeta.verity_a)}\n"
                    message += f"    Verification:                    {enabled_disabled(device.vbmeta.verification_a)}\n"
                # self.config.disable_verification is a disable flag, which is the inverse of device.vbmeta.verification
                if ( device.vbmeta.verity_a == self.config.disable_verity ) or ( device.vbmeta.verity_b == self.config.disable_verity ):
                    alert += _("    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verity state and device's verity state\n")
                if ( device.vbmeta.verification_a == self.config.disable_verification ) or ( device.vbmeta.verification_b == self.config.disable_verification ):
                    alert += _("    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verification state and device's verification state\n")
                    alert += _("                                     This has a device wipe implications, please double check.\n")
                message += alert
                if alert != '':
                    self.toast(_("vbmeta Warning!"), alert)
            return message
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered while getting vbmeta data.")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _check_for_bad_magisk
    # -----------------------------------------------
    def _check_for_bad_kernel(self, kernel):
        if kernel is None:
            return
        for bad_kernel in BANNED_KERNELS:
            if bad_kernel in kernel:
                print(f"⚠️ WARNING! Problematic Kernel: {kernel} is installed. Play Integrity would possibly fail.")
                print(f"Kernel string: {bad_kernel} is known to be banned.\n")
                self.toast(_("WARNING! Banned Kernel"), _("⚠️ Kernel string: %s is known to be banned.\nPlay Integrity would possibly fail.") % bad_kernel)
                puml(f"#red:Kernel: {kernel} is detected;\n")
                puml("note right:This kernel is known to be banned")

    # -----------------------------------------------
    #                  _check_for_bad_magisk
    # -----------------------------------------------
    def _check_for_bad_magisk(self, m_version, m_app_version):
            bad_m_version = False
            bad_m_app_version = False
            if m_version in KNOWN_BAD_MAGISKS:
                bad_m_version = True
                print(f"⚠️ WARNING! Problematic Magisk Version:         {m_version} is installed. Advised not to use this version.")
            if m_app_version in KNOWN_BAD_MAGISKS:
                bad_m_app_version = True
                print(f"⚠️ WARNING! Problematic Magisk Manager Version: {m_app_version} is installed. Advised not to use this version.")

            if bad_m_version and bad_m_app_version:
                dlg = wx.MessageDialog(None, f"Magisk Version: {m_version} is detected.\nMagisk Manager Version: {m_app_version} is detected.\n\nThese versions of Magisk are known to have issues.\nRecommendation: Install stable version or one that is known to be good.",'Problematic Magisk Versions.',wx.OK | wx.ICON_EXCLAMATION)
                puml(f"#red:Magisk Version: {m_version} is detected\nMagisk Manager Version: {m_app_version} is detected;\n")
                puml("note right:These versions of Magisk are known to have problems.")
                result = dlg.ShowModal()
            elif bad_m_version:
                dlg = wx.MessageDialog(None, f"Magisk Version: {m_version} is detected.\nThis version of Magisk is known to have issues.\nRecommendation: Install stable version or one that is known to be good.",'Problematic Magisk Version.',wx.OK | wx.ICON_EXCLAMATION)
                puml(f"#red:Magisk Version: {m_version} is detected;\n")
                puml("note right:This version of Magisk is known to have problems.")
                result = dlg.ShowModal()
            elif bad_m_app_version:
                dlg = wx.MessageDialog(None, f"Magisk Manager Version: {m_app_version} is detected.\nThis version of Magisk Manager is known to have issues.\nRecommendation: Install stable version or one that is known to be good.",'Problematic Magisk Manager Version.',wx.OK | wx.ICON_EXCLAMATION)
                puml(f"#red:Magisk Manager Version: {m_app_version} is detected;\n")
                puml("note right:This version of Magisk Manager is known to have problems;\n")
                result = dlg.ShowModal()

    # -----------------------------------------------
    #                  _update_custom_flash_options
    # -----------------------------------------------
    def _update_custom_flash_options(self):
        image_mode = get_image_mode()
        image_path = get_image_path()
        if self.config.flash_mode == 'customFlash':
            self.flash_button.Label = _("Custom Flash Device")
        else:
            self.flash_radio_button.Enable(False)
            self.live_boot_radio_button.Enable(False)
            if self.config.flash_mode == 'OTA':
                self.flash_button.Label = _("Sideload OTA")
            else:
                self.flash_button.Label = _("Flash Device")
            return
        self.live_boot_radio_button.Enable(False)
        self.flash_radio_button.Enable(False)
        self.flash_button.Enable(False)
        with contextlib.suppress(Exception):
            if image_path:
                filename, extension = os.path.splitext(image_path)
                extension = extension.lower()
                if image_mode == 'boot':
                    if extension == '.img':
                        self.live_boot_radio_button.Enable(True)
                        self.flash_radio_button.Enable(True)
                        self.flash_button.Enable(True)
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Selected file is not of type .img")
                elif image_mode in ['image', 'SIDELOAD']:
                    if extension == '.zip':
                        self.live_boot_radio_button.Enable(False)
                        self.flash_radio_button.Enable(True)
                        self.flash_button.Enable(True)
                        self.flash_radio_button.SetValue(True)
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Selected file is not of type .zip")
                elif extension == '.img':
                    self.live_boot_radio_button.Enable(False)
                    self.flash_radio_button.Enable(True)
                    self.flash_button.Enable(True)
                    self.flash_radio_button.SetValue(True)
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Selected file is not of type .img")

    # -----------------------------------------------
    #                  _select_configured_device
    # -----------------------------------------------
    def _select_configured_device(self, is_init=False):
        try:
            if self.config.device:
                count = 0
                for device in get_phones():
                    if device.id == self.config.device:
                        self.device_choice.Select(count)
                        set_phone_id(device.id)
                        puml(f":Select Device;\n", True)
                        self._print_device_details(device)
                        self.update_google_images_menu(update_icons_only=not is_init)
                    count += 1
            elif self.device_choice.StringSelection:
                device = self.device_choice.StringSelection
                # replace multiple spaces with a single space and then split on space
                id = ' '.join(device.split())
                id = id.split()
                id = id[2]
                self.config.device = id
                for device in get_phones():
                    if device.id == id:
                        set_phone_id(device.id)
                        puml(f":Select Device;\n", True)
                        self._print_device_details(device)
                        self.update_google_images_menu(update_icons_only=not is_init)
            else:
                set_phone_id(None)
                self.device_label.Label = _("ADB Connected Devices")
            if self.device_choice.StringSelection == '':
                set_phone_id(None)
                self.device_label.Label = _("ADB Connected Devices")
                self.config.device = None
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} No Device is selected!")
                puml(f":Select Device;\nnote right:No Device is selected!\n")
            self._reflect_slots()
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function _select_configured_device")
            traceback.print_exc()

    # -----------------------------------------------
    #                  refresh_device
    # -----------------------------------------------
    def refresh_device(self, look_for_device=None):
        print("Updating connected devices ...")
        if look_for_device:
            selected_device_id = look_for_device
            debug(f"Looking for requested device: {look_for_device}")
        else:
            selected_device = self.device_choice.StringSelection
            debug(f"Checking a previous device choice: [{selected_device}]")
            selected_device_id = None
            if selected_device:
                # selected_device_id = selected_device.split()[2]
                selected_device_id = self.config.device
                debug(f"Looking for previously selected device: {selected_device_id}")
        self.device_choice.Clear()
        phones = get_phones()
        found_device = False
        for device in phones:
            if device:
                device_details = device.get_device_details()
                self.device_choice.Append(device_details)
                if selected_device_id and device.id == selected_device_id:
                    debug(f"Found device: {selected_device_id}, selecting it ...")
                    found_device = True
                    self.device_choice.SetStringSelection(device_details)  # Select the matching device ID
                    self._select_configured_device()
        if not found_device:
            self.clear_device_selection()
        else:
            self._reflect_slots()
            self.update_widget_states()

    # -----------------------------------------------
    #                  clear_device_selection
    # -----------------------------------------------
    def clear_device_selection(self):
        device_id = self.config.device
        self.config.device = None
        selected_index = self.device_choice.GetSelection()
        debug(f"ℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Clearing device selection {self.device_choice.GetStringSelection()} ...")
        if selected_index != wx.NOT_FOUND:
            items = self.device_choice.GetItems()
            del items[selected_index]
            self.device_choice.SetItems(items)
            self.device_choice.Select(-1)
            set_phone_id(None)
            debug(f"ℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Cleared device selection {self.device_choice.GetStringSelection()}")
        phones = get_phones()
        if phones:
            for device in phones:
                if device.id == device_id:
                    phones.remove(device)
                    set_phones(phones)
                    debug(f"ℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Cleared device id: {device_id} from phones list.")
                    break
        self._reflect_slots()
        self.update_widget_states()

    # -----------------------------------------------
    #                  _reflect_slots
    # -----------------------------------------------
    def _reflect_slots(self):
        device = get_phone()
        if device:
            if device.active_slot == 'a':
                self.device_label.Label = _("ADB Connected Devices\nCurrent Active Slot: [A]")
                self.update_slot_image('a')
                set_a_only(False)
            elif device.active_slot == 'b':
                self.device_label.Label = _("ADB Connected Devices\nCurrent Active Slot: [B]")
                set_a_only(False)
                self.update_slot_image('b')
            else:
                self.device_label.Label = _("ADB Connected Devices")
                set_a_only(True)
                self.update_slot_image('none')
            self.update_rooted_image(device.rooted)
            if device.rooted:
                self.update_rooted_with_image(device.root_version)
            else:
                self.update_rooted_with_image('Not Rooted')
        else:
            self.device_label.Label = _("ADB Connected Devices")
            self.update_slot_image('none')
            self.update_rooted_image(False)
            if device and device.rooted:
                self.update_rooted_with_image(device.root_version)

    #-----------------------------------------------------------------------------
    #                          evaluate_condition
    #-----------------------------------------------------------------------------
    # Define the rules engine
    def evaluate_condition(self, condition):
        try:
            if condition == 'device_attached':
                device_id = get_phone_id()
                if device_id:
                    return True
                return False

            elif condition == 'device_mode_adb':
                device = get_phone()
                if device and device.mode == 'adb':
                    return True
                return False

            elif condition == 'device_mode_true_adb':
                device = get_phone()
                if device and device.mode == 'adb':
                    return True
                return False

            elif condition == 'device_is_rooted':
                device = get_phone()
                if device and device.rooted:
                    return True
                return False

            elif condition == 'mode_is_not_ota':
                if self.config.flash_mode != 'OTA':
                    return True
                return False

            elif condition == 'custom_flash':
                if self.config.flash_mode == 'customFlash':
                    return True
                return False

            elif condition == 'custom_rom':
                if self.config.show_custom_rom_options and self.config.custom_rom:
                    return True
                return False

            elif condition == 'custom_rom_selected':
                if self.config.custom_rom_path and os.path.exists(self.config.custom_rom_path):
                    return True
                return False

            elif condition == 'firmware_selected':
                if self.config.firmware_path and os.path.exists(self.config.firmware_path):
                    return True
                return False

            elif condition == 'not_custom_flash':
                if self.config.flash_mode != 'customFlash':
                    return True
                return False

            elif condition == 'dual_slot':
                device = get_phone()
                if device and device.active_slot in ['a', 'b']:
                    return True
                return False

            elif condition == 'slot_a':
                device = get_phone()
                if device and device.active_slot == 'a':
                    return True
                return False

            elif condition == 'slot_b':
                device = get_phone()
                if device and device.active_slot =='b':
                    return True
                return False

            elif condition == 'has_magisk_modules':
                device = get_phone()
                if device.magisk_modules_summary == '':
                    return False
                return True

            elif condition == 'boot_is_selected':
                boot = get_boot()
                if boot:
                    return True
                return False

            elif condition == 'valid_paste':
                image_mode = self.image_choice.Items[self.image_choice.GetSelection()]
                if image_mode in ['boot', 'init_boot']:
                    boot = get_boot()
                    if boot:
                        return True
                elif image_mode in ["vbmeta", "bootloader", "radio", "image", 'dtbo', 'vendor_boot', 'vendor_kernel_boot', 'super_empty']:
                    return True
                return False

            elif condition == 'boot_is_patched':
                boot = get_boot()
                if boot and boot.is_patched == 1:
                    return True
                return False

            elif condition == 'boot_is_not_patched':
                boot = get_boot()
                if boot and boot.is_patched == 1:
                    return False
                return True

            elif condition == 'boot_is_not_downgrade_patched':
                boot = get_boot()
                if boot and 'downgrade_boot' not in boot.boot_path:
                    return True
                return False

            elif condition == 'boot_is_init_boot':
                boot = get_boot()
                if boot and boot.is_init_boot == 1:
                    return True
                return False

            elif condition == 'boot_is_not_init_boot':
                boot = get_boot()
                if boot and boot.is_init_boot == 0:
                    return True
                return False

            elif condition == 'partition_is_boot':
                partition = get_selected_boot_partition()
                if partition and partition == 'boot':
                    return True
                return False

            elif condition == 'custom_image_selected':
                image_path = get_image_path()
                if image_path:
                    return True
                return False

            elif condition == 'custom_image_mode_is_boot':
                image_mode = get_image_mode()
                if image_mode == 'boot':
                    return True
                return False

            elif condition == 'firmware_is_ota':
                return get_ota()

            elif condition == 'firmware_is_not_ota':
                return not get_ota()

            elif condition == 'sdk_ok':
                return get_sdk_state()

            elif condition == 'no_rule':
                return True

            elif condition == 'advanced_options':
                return self.config.advanced_options

            elif condition == 'scrcpy_path_is_set':
                if self.config.scrcpy['path'] != '' and os.path.exists(self.config.scrcpy['path']):
                    return True
                return False

            elif condition == 'is_gki':
                device = get_phone()
                if device and device.is_gki:
                    return True
                return False

            elif condition == 'is_not_gki':
                device = get_phone()
                if device and device.is_gki:
                    return False
                return True

            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unknown condition: {condition}")
                return False

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while evaluating a rule")
            traceback.print_exc()
            return False

    #-----------------------------------------------------------------------------
    #                                   update_widget_states
    #-----------------------------------------------------------------------------
    def update_widget_states(self):
        try:
            widget_conditions = {
                self.sos_menu:                          ['no_rule'],
                self.reboot_menu:                       ['device_attached'],
                self.reboot_recovery_menu:              ['device_attached', 'advanced_options'],
                self.reboot_recovery_interactive_menu:  ['device_attached', 'advanced_options'],
                self.reboot_bootloader_menu:            ['device_attached'],
                self.reboot_fastbootd_menu:             ['device_attached', 'advanced_options'],
                self.reboot_system_menu:                ['device_attached'],
                self.shell_menu_item:                   ['device_attached'],
                self.scrcpy_menu_item:                  ['device_attached', 'scrcpy_path_is_set', 'device_mode_true_adb'],
                self.device_info_menu_item:             ['device_attached'],
                self.pif_info_menu_item:                ['device_attached', 'device_mode_true_adb'],
                self.props_as_json_menu_item:           ['device_attached'],
                self.xml_view_menu_item:                ['device_attached', 'device_mode_true_adb'],
                self.cancel_ota_menu_item:              ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],
                self.check_otacerts_menu_item:          ['device_attached', 'device_mode_true_adb'],
                self.push_menu:                         ['device_attached', 'device_mode_adb'],
                self.push_file_to_tmp_menu:             ['device_attached', 'device_mode_adb'],
                self.push_file_to_download_menu:        ['device_attached', 'device_mode_adb'],
                self.bootloader_unlock_menu:            ['device_attached', 'advanced_options'],
                self.bootloader_lock_menu:              ['device_attached', 'advanced_options'],
                self.install_magisk_menu:               ['device_attached', 'device_mode_true_adb'],
                self.partitions_menu:                   ['device_attached', 'advanced_options'],
                self.logcat_menu:                       ['device_attached', 'device_mode_true_adb'],
                self.update_engine_logcat_menu:         ['device_attached', 'device_mode_true_adb'],
                self.get_bootloader_versions_menu:      ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],
                self.pi_analysis_report_menu:           ['device_attached', 'device_is_rooted', 'device_mode_true_adb'],
                self.open_url_menu:                     ['device_attached', 'device_mode_true_adb'],
                self.prep_downgrade_patch_menu:         ['boot_is_selected', 'boot_is_not_patched', 'boot_is_not_downgrade_patched'],
                self.install_apk:                       ['device_attached', 'device_mode_true_adb'],
                self.package_manager:                   ['device_attached', 'device_mode_true_adb'],
                self.no_reboot_checkBox:                ['device_attached'],
                self.image_file_picker:                 ['custom_flash'],
                self.image_choice:                      ['custom_flash'],
                self.custom_rom:                        ['custom_rom'],
                self.scan_button:                       ['sdk_ok'],
                self.scan_all_button:                   ['sdk_ok'],
                self.wifi_adb:                          ['sdk_ok'],
                self.device_choice:                     ['sdk_ok'],
                self.process_firmware:                  ['firmware_selected'],
                self.delete_boot_button:                ['boot_is_selected'],
                self.get_boot_info_button:              ['boot_is_selected'],
                self.boot_folder_button:                ['boot_is_selected'],
                self.folders_button:                    ['boot_is_selected'],
                self.firmware_folder_button:            ['boot_is_selected'],
                self.live_boot_button:                  ['device_attached', 'boot_is_selected'],
                self.flash_boot_button:                 ['device_attached', 'boot_is_selected'],
                self.paste_selection:                   ['device_attached','custom_flash', 'valid_paste'],
                # self.patch_custom_boot_button:          ['device_attached', 'device_mode_true_adb'],
                self.reboot_download_menu:              ['device_attached', 'device_mode_adb', 'advanced_options'],
                self.reboot_sideload_menu:              ['device_attached', 'advanced_options'],
                self.switch_slot_menu:                  ['device_attached', 'dual_slot', 'advanced_options'],
                self.process_rom:                       ['custom_rom', 'custom_rom_selected'],
                self.magisk_menu:                       ['device_attached', 'device_mode_true_adb'],
                self.magisk_backup_manager_menu:        ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],
                self.data_adb_backup_menu:              ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],
                self.data_adb_restore_menu:             ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],
                self.data_adb_clear_menu:               ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],
                self.start_shizuku_menu:                ['device_attached', 'device_mode_true_adb'],
                # self.pif_manager_menu:                  ['device_attached', 'device_mode_true_adb'],
                self.reboot_safe_mode_menu:             ['device_attached', 'device_mode_adb', 'device_is_rooted', 'advanced_options'],
                # self.verity_menu_item:                  ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],
                self.disable_verity_checkBox:           ['device_attached'],
                self.disable_verification_checkBox:     ['device_attached'],
                self.flash_both_slots_checkBox:         ['device_attached', 'mode_is_not_ota', 'dual_slot'],
                self.flash_to_inactive_slot_checkBox:   ['device_attached', 'mode_is_not_ota', 'dual_slot'],
                self.fastboot_force_checkBox:           ['device_attached', 'mode_is_not_ota', 'dual_slot'],
                self.wipe_checkBox:                     ['device_attached', 'custom_flash'],
                self.no_wipe_downgrade_checkbox:        ['device_attached', 'not_custom_flash', 'boot_is_selected', 'firmware_selected', 'firmware_is_not_ota'],
                self.temporary_root_checkBox:           ['not_custom_flash', 'boot_is_patched', 'boot_is_selected', 'partition_is_boot'],
                self.patch_button:                      ['device_attached', 'device_mode_true_adb'],
                self.patch_magisk_button:               ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched'],
                self.patch_kernelsu_button:             ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_kernelsu_lkm_button:         ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_kernelsu_legacy_button:      ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_not_gki'],
                self.patch_kernelsu_next_button:        ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_kernelsu_next_lkm_button:    ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_apatch_button:               ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched'],
                self.patch_apatch_manual_button:        ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched'],
                self.patch_sukisu_button:               ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_sukisu_lkm_button:           ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_wild_ksu_button:             ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_wild_ksu_lkm_button:         ['device_attached', 'device_mode_true_adb', 'boot_is_selected', 'boot_is_not_patched', 'is_gki'],
                self.patch_downgrade_button:            ['boot_is_selected', 'boot_is_not_patched', 'boot_is_not_downgrade_patched'],
                # Special handling of non-singular widgets
                'mode_radio_button.OTA':                ['firmware_selected', 'firmware_is_ota'],
                'mode_radio_button.keepData':           ['firmware_selected', 'firmware_is_not_ota'],
                'mode_radio_button.wipeData':           ['firmware_selected', 'firmware_is_not_ota'],
                'mode_radio_button.dryRun':             ['firmware_selected', 'firmware_is_not_ota'],
                # Toolbar tools handling by ID
                5:                                      ['device_attached'],                                                # Install APK
                8:                                      ['device_attached'],                                                # Package Manager
                10:                                     ['device_attached'],                                                # Shell
                15:                                     ['device_attached', 'scrcpy_path_is_set'],                          # Scrcpy
                20:                                     ['device_attached'],                                                # Device Info
                # 30:                                     ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],  # Check Verity Verification
                40:                                     ['device_attached'],                                                # Partition Manager
                50:                                     ['device_attached', 'device_is_rooted'],                            # PI Analysis Report
                100:                                    ['device_attached', 'dual_slot'],                                   # Switch Slot
                110:                                    ['device_attached'],                                                # Reboot System
                120:                                    ['device_attached'],                                                # Reboot Bootloader
                125:                                    ['device_attached'],                                                # Reboot Fastbootd
                130:                                    ['device_attached'],                                                # Reboot Recovery
                135:                                    ['device_attached'],                                                # Reboot Interactive Recovery
                140:                                    ['device_attached', 'device_mode_adb', 'device_is_rooted'],         # Reboot Safe Mode
                150:                                    ['device_attached', 'device_mode_adb'],                             # Reboot Download
                160:                                    ['device_attached'],                                                # Reboot Sideload
                200:                                    ['device_attached', 'device_mode_true_adb'],                        # Magisk Modules
                # 210:                                    ['device_attached'],                                                # Magisk Install
                220:                                    ['device_attached', 'device_mode_true_adb', 'device_is_rooted'],    # Magisk Backup Manager
                # 225:                                    ['device_attached', 'device_mode_adb'],                           # Pif Manager
                230:                                    ['no_rule'],                                                        # SOS
                300:                                    ['device_attached'],                                                # Lock
                310:                                    ['device_attached'],                                                # Unlock
            }

            for widget, conditions in widget_conditions.items():
                # Evaluate conditions for the widget using the rules engine
                enable_widget = all(self.evaluate_condition(condition) for condition in conditions)

                # Set the state of the widget
                if isinstance(widget, int):
                    # Check if the widget is a toolbar tool ID
                    tool_id = widget
                    enable_tool = all(self.evaluate_condition(condition) for condition in conditions)
                    self.tb.EnableTool(tool_id, enable_tool)
                elif isinstance(widget, str):
                    # Handle special case for Flash Mode Radio Button Widget
                    if widget.startswith('mode_radio_button'):
                        name = widget.split('.')[1]
                        self.enable_disable_radio_button(name, enable_widget)
                else:
                    # Handle normal widget objects
                    widget.Enable(enable_widget)

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while updating widgets.")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_select_device
    # -----------------------------------------------
    def _on_select_device(self, event):
        try:
            self._on_spin('start')
            choice = event.GetEventObject()
            device = choice.GetString(choice.GetSelection())
            # replace multiple spaces with a single space and then split on space
            d_id = ' '.join(device.split())
            if d_id:
                d_id = d_id.split()
                d_id = d_id[2]
                self.config.device = d_id
                for device in get_phones():
                    wx.YieldIfNeeded()
                    if device.id == d_id:
                        set_phone_id(device.id)
                        self.config.device = device.id
                        self._print_device_details(device)
                        self.update_google_images_menu(update_icons_only=True)
                self._reflect_slots()
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while selecting a device")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _perform_scan
    # -----------------------------------------------
    def _perform_scan(self, scan_all=False):
        # scan_all: If True, scan all devices regardless of enable/disable settings.
        #           If False, only scan enabled devices (respects device filter).
        try:
            startScan = time.time()

            # Determine scan mode text
            if scan_all:
                header = "User initiated Scan (All Devices)"
                scanning_msg = "Scanning for All Devices ..."
                puml_text = ":Scan for All Devices;"
            else:
                header = "User initiated Scan"
                scanning_msg = "Scanning for Devices ..."
                puml_text = ":Scan for Devices;"

            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} {header}")
            print("==============================================================================")

            if get_adb():
                print(f"\n{datetime.now():%Y-%m-%d %H:%M:%S} {scanning_msg}")
                puml(f"{puml_text}\n")
                self._on_spin('start')

                # Perform the scan based on mode
                if scan_all:
                    connected_devices = get_connected_devices(scan_all=True)
                else:
                    connected_devices = get_connected_devices(respect_device_filter=True)

                self.device_choice.SetItems(connected_devices)
                d_list_string = '\n'.join(connected_devices)
                puml(f"note right\n{d_list_string}\nend note\n")

                if self.device_choice.Count == 0:
                    self.device_choice.SetSelection(-1)
                    print("⚠️ No Devices found.")
                    puml(f"note right:No Devices are found\n")
                    self.toast(_("Scan"), _("⚠️ No devices are found.."))
                    self._on_spin('stop')
                    # Refresh the devices menu to show updated connection status
                    wx.CallAfter(self._build_devices_menu)
                    return

                print(f"{self.device_choice.Count} Device(s) are found.")
                self._select_configured_device()
                self._on_spin('stop')

                if self.device_choice.StringSelection == '':
                    # Popup the devices dropdown
                    self.device_choice.Popup()
                    self.toast(_("Scan"), _("✅ Select your device from the list of %s found devices.") % self.device_choice.Count)

                # Refresh the devices menu to show updated connection status
                wx.CallAfter(self._build_devices_menu)
            else:
                print("Please set Android Platform Tools Path first.")

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while scanning")
            traceback.print_exc()
        finally:
            self._on_spin('stop')
            endScan = time.time()
            print(f"Device scan elapsed time: {math.ceil(endScan - startScan)} seconds")

    # -----------------------------------------------
    #                  _on_scan
    # -----------------------------------------------
    def _on_scan(self, event):
        self._perform_scan(scan_all=False)

    # -----------------------------------------------
    #                  _on_select_platform_tools
    # -----------------------------------------------
    def _on_select_platform_tools(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated select platform tools")
            print("==============================================================================")
            self._on_spin('start')
            the_path = event.GetPath()
            if "'" in the_path:
                print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} Warning: Path contains single quotes, which are not supported.")
                dlg = wx.MessageDialog(self, _("The selected path contains single quotes (').\n\nPlease rename the folder to remove the single quotes and try again."), _("Warning"), wx.OK | wx.ICON_WARNING)
                dlg.ShowModal()
                dlg.Destroy()
                return
            self.config.platform_tools_path = the_path.replace("'", "")
            check_platform_tools(self)
            if get_sdk_version():
                self.platform_tools_label.SetLabel(_("Android Platform Tools\nVersion %s") % get_sdk_version())
            else:
                self.platform_tools_label.SetLabel(_("Android Platform Tools"))
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while selecting platform tools")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #            update_firmware_selection
    # -----------------------------------------------
    def update_firmware_selection(self, path):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated update firmware selection")
            print("==============================================================================")
            if not os.path.exists(path):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: file {path} does not exist")
                return -1
            self.config.firmware_path = path.replace("'", "")
            checksum = select_firmware(self)
            if len(checksum) == 64:
                self.config.firmware_sha256 = checksum
            else:
                self.config.firmware_sha256 = None
            self.firmware_picker.SetToolTip(f"SHA-256: {checksum}")
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while selecting firmware")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_select_firmware
    # -----------------------------------------------
    def _on_select_firmware(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated firmware selection")
        print("==============================================================================")
        # path = event.GetPath()
        path = self.firmware_picker.GetPath()
        if not path:
            # User cancelled the selection
            return
        self._on_spin('start')
        self.update_firmware_selection(path)
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_process_firmware
    # -----------------------------------------------
    def _on_process_firmware(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Process firmware")
            print("==============================================================================")
            self._on_spin('start')
            if self.config.firmware_path:
                print("This could take some time, please wait ...")
                process_file(self, 'firmware')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing firmware")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_process_rom
    # -----------------------------------------------
    def _on_process_rom(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Process ROM")
            print("==============================================================================")
            self._on_spin('start')
            if self.config.custom_rom_path:
                process_file(self, 'rom')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing rom")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_image_choice
    # -----------------------------------------------
    def _on_image_choice(self, event):
        try:
            self._on_spin('start')
            choice = event.GetEventObject()
            set_image_mode(choice.GetString(choice.GetSelection()))
            self._update_custom_flash_options()
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while choosing an image")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_image_select
    # -----------------------------------------------
    def _on_image_select(self, event):
        try:
            self._on_spin('start')
            image_path = event.GetPath().replace("'", "")
            filename, extension = os.path.splitext(image_path)
            extension = extension.lower()
            if extension in ['.zip', '.img']:
                set_image_path(image_path)
                self._update_custom_flash_options()
                print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Custom image file {image_path} is selected.")
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The selected file {image_path} is not img or zip file.")
                self.image_file_picker.SetPath('')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while selecting an image")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_select_custom_rom
    # -----------------------------------------------
    def _on_select_custom_rom(self, event):
        try:
            self._on_spin('start')
            custom_rom_path = event.GetPath().replace("'", "")
            filename, extension = os.path.splitext(custom_rom_path)
            extension = extension.lower()
            puml(":Select ROM File;\n", True)
            if extension in ['.zip', '.tgz', '.tar']:
                self.config.custom_rom_path = custom_rom_path
                rom_file = ntpath.basename(custom_rom_path)
                set_custom_rom_id(os.path.splitext(rom_file)[0])
                rom_hash = sha256(self.config.custom_rom_path)

                if len(rom_hash) == 64:
                    self.config.rom_sha256 = rom_hash
                else:
                    self.config.rom_sha256 = None
                self.custom_rom.SetToolTip(f"SHA-256: {rom_hash}")
                print(f"Selected ROM {rom_file} SHA-256: {rom_hash}")
                puml(f"note right\n{rom_file}\nSHA-256: {rom_hash}\nend note\n")
                populate_boot_list(self)
                self.update_widget_states()
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The selected file {custom_rom_path} is not a valid archive.")
                puml("#red:The selected ROM file is not valid;\n")
                self.custom_rom.SetPath('')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while selecting rom")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_mode_changed
    # -----------------------------------------------
    def _on_mode_changed(self, event):
        self.mode_radio_button = event.GetEventObject()
        self.wipe = False
        self.downgrade = False
        self.wipe_checkBox.SetValue(False)
        self.no_wipe_downgrade_checkbox.SetValue(False)
        if self.mode_radio_button.GetValue():
            self.config.flash_mode = self.mode_radio_button.mode
            print(f"Flash mode changed to: {self.config.flash_mode}")
            puml(f":Flash mode change;\n", True)
            puml(f"note right:{self.config.flash_mode}\n")
            self.update_widget_states()
        if self.config.flash_mode != 'customFlash':
            set_flash_button_state(self)
        self._update_custom_flash_options()

    # -----------------------------------------------
    #                  _on_flash_both_slots
    # -----------------------------------------------
    def _on_flash_both_slots(self, event):
        self.flash_both_slots_checkBox = event.GetEventObject()
        status = self.flash_both_slots_checkBox.GetValue()
        print(f"Flash Option: Flash Both Slots {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Flash Both Slots {status}\n")
        self.config.flash_both_slots = status
        if status:
            self.config.flash_to_inactive_slot = not status
            self.flash_to_inactive_slot_checkBox.SetValue(not status)

    # -----------------------------------------------
    #                  _on_flash_to_inactive_slot
    # -----------------------------------------------
    def _on_flash_to_inactive_slot(self, event):
        self.flash_to_inactive_slot_checkBox = event.GetEventObject()
        status = self.flash_to_inactive_slot_checkBox.GetValue()
        print(f"Flash Option: Flash to Inactive Slot {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Flash to Inactive Slot {status}\n")
        self.config.flash_to_inactive_slot = status
        if status:
            self.config.flash_both_slots = not status
            self.flash_both_slots_checkBox.SetValue(not status)

    # -----------------------------------------------
    #                  _on_disable_verity
    # -----------------------------------------------
    def _on_disable_verity(self, event):
        self._on_spin('start')
        self.disable_verity_checkBox = event.GetEventObject()
        status = self.disable_verity_checkBox.GetValue()
        print(f"Flash Option: Disable Verity {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Disable Verity {status}\n")
        self.config.disable_verity = status
        self.vbmeta_alert(show_alert=False)
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_disable_verification
    # -----------------------------------------------
    def _on_disable_verification(self, event):
        self._on_spin('start')
        self.disable_verification_checkBox = event.GetEventObject()
        status = self.disable_verification_checkBox.GetValue()
        print(f"Flash Option: Disable Verification {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Disable Verification {status}\n")
        self.config.disable_verification = status
        self.vbmeta_alert(show_alert=True)
        self._on_spin('stop')

    # -----------------------------------------------
    #                  vbmeta_alert
    # -----------------------------------------------
    def vbmeta_alert(self, show_alert=False):
        device = get_phone()
        if device:
            if self.init_complete:
                device.get_vbmeta_details()
            alert = self.get_vbmeta(device)
            if show_alert and "WARNING!" in alert:
                try:
                    dlg = MessageBoxEx(
                        parent=None,
                        title=_("vbmeta issue."),
                        message=_("Warning!\n%s") % alert,
                        button_texts=[_("OK")],
                        default_button=1,
                        disable_buttons=None,
                        is_md=False,
                        size=(800, 600),
                        checkbox_labels=None,
                        checkbox_initial_values=None,
                        disable_checkboxes=None,
                        vertical_checkboxes=False,
                        checkbox_labels2=None,
                        checkbox_initial_values2=None,
                        disable_checkboxes2=None,
                        radio_labels=None,
                        radio_initial_value=None,
                        disable_radios=None,
                        vertical_radios=False
                    )
                    puml(f"note right\nDialog\n====\nWarning!\n{alert}\nend note\n")
                    dlg.CentreOnParent(wx.BOTH)
                    result = dlg.ShowModal()
                    dlg.Destroy()
                except Exception as e:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
                    traceback.print_exc()
            print(alert)
        else:
            self.clear_device_selection()

    # -----------------------------------------------
    #                  switch_slot_alert
    # -----------------------------------------------
    def switch_slot_alert(self):
        try:
            dlg = wx.MessageDialog(None, _("Before switching slots, please make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"), _('Switch Slot potential concern'),wx.YES_NO | wx.ICON_EXCLAMATION)
            result = dlg.ShowModal()
            if result != wx.ID_YES:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled Switch Slot operation")
                return False
            print("User pressed ok to continue with Switch Slot operation")
            return True
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_fastboot_force
    # -----------------------------------------------
    def _on_fastboot_force(self, event):
        self.fastboot_force_checkBox = event.GetEventObject()
        status = self.fastboot_force_checkBox.GetValue()
        print(f"Flash Option: Force {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Force {status}\n")
        self.config.fastboot_force = status

    # -----------------------------------------------
    #                  _on_fastboot_verbose
    # -----------------------------------------------
    def _on_fastboot_verbose(self, event):
        self.fastboot_verbose_checkBox = event.GetEventObject()
        status = self.fastboot_verbose_checkBox.GetValue()
        print(f"Flash Option: Verbose {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Verbose {status}\n")
        self.config.fastboot_verbose = status

    # -----------------------------------------------
    #                  _on_temporary_root
    # -----------------------------------------------
    def _on_temporary_root(self, event):
        self._on_temporary_root_checkBox = event.GetEventObject()
        status = self._on_temporary_root_checkBox.GetValue()
        print(f"Flash Option: Temporary Root {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Temporary Root {status}\n")
        self.config.temporary_root = status

    # -----------------------------------------------
    #                  _on_no_reboot
    # -----------------------------------------------
    def _on_no_reboot(self, event):
        self._on_no_reboot_checkBox = event.GetEventObject()
        status = self._on_no_reboot_checkBox.GetValue()
        print(f"Flash Option: No Reboot {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:No Reboot {status}\n")
        self.config.no_reboot = status

    # -----------------------------------------------
    #                  _on_wipe
    # -----------------------------------------------
    def _on_wipe(self, event):
        self._on_wipe_checkBox = event.GetEventObject()
        status = self._on_wipe_checkBox.GetValue()
        print(f"Flash Option: Wipe {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:Wipe {status}\n")
        self.wipe = status

    # -----------------------------------------------
    #                  _on_no_wipe_downgrade
    # -----------------------------------------------
    def _on_no_wipe_downgrade(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User selected option no wipe downgrade")
        print("==============================================================================")
        self._on_no_wipe_downgrade_checkbox = event.GetEventObject()
        status = self._on_no_wipe_downgrade_checkbox.GetValue()
        if status:
            # check to see if there id a downgrade patch
            boot = get_boot()
            if not boot:
                wx.MessageBox(_("❌ ERROR: You must first select a boot image"), _("Error"), wx.OK | wx.ICON_ERROR)
                print("\nPlease select a boot image!")
                self.no_wipe_downgrade_checkbox.SetValue(False)
                return -1

            boot_path = boot.boot_path
            directory_path = os.path.dirname(boot_path)
            downgrade_file_name = "downgrade_boot.img"
            downgrade_file_path = os.path.join(directory_path, downgrade_file_name)
            if not os.path.exists(downgrade_file_path):
                wx.MessageBox(_("❌ ERROR: Downgrade patch file not found\nYou must first create a downgrade patch to enable this option."), _("Error"), wx.OK | wx.ICON_ERROR)
                print(f"\nDowngrade patch file {downgrade_file_path} not found!")
                self.no_wipe_downgrade_checkbox.SetValue(False)
                return

            if self.config.flash_mode == 'wipeData':
                wx.MessageBox(_("❌ ERROR: Wipe All Data is selected\nYou must first select another mode to enable this option."), _("Error"), wx.OK | wx.ICON_ERROR)
                print("\nWipe Data is enabled!")
                self.no_wipe_downgrade_checkbox.SetValue(False)
                return

            title = _("No Wipe Downgrade")
            message = _("                 WARNING!!! WARNING!!! WARNING!!!\n\n")
            message += _("THIS IS AN EXPERIMENTAL FEATURE, NO ASSURANCES THAT IT WOULD WORK\n")
            message += _("Do NOT enable this option if you are not downgrading!!!\n")
            message += _("Proceed only if you know what you're doing.\n\n")
            message += _("Do you want to continue to select the No Wipe Downgrade option?\n")
            message += _("       Press OK to continue or CANCEL to abort.\n")
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} {title}")
            print(f"\n*** Dialog ***\n{message}\n______________\n")
            set_message_box_title(title)
            set_message_box_message(message)
            try:
                dlg = MessageBoxEx(
                    parent=self,
                    title=title,
                    message=message,
                    button_texts=[_('OK'), _('CANCEL')],
                    default_button=2,
                    disable_buttons=None,
                    is_md=False,
                    size=(800, 600),
                    checkbox_labels=None,
                    checkbox_initial_values=None,
                    disable_checkboxes=None,
                    vertical_checkboxes=False,
                    checkbox_labels2=None,
                    checkbox_initial_values2=None,
                    disable_checkboxes2=None,
                    radio_labels=None,
                    radio_initial_value=None,
                    disable_radios=None,
                    vertical_radios=False
                )
            except Exception:
                traceback.print_exc()
                self.no_wipe_downgrade_checkbox.SetValue(False)
                return
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()

            if result == 1:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
                self.wipe_checkBox.SetValue(False)
                # self.no_wipe_downgrade_checkbox.SetValue(True)
            else:
                self.no_wipe_downgrade_checkbox.SetValue(False)
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                print("Aborting ...\n")
                dlg.Destroy()
                return
            dlg.Destroy()

        print(f"Flash Option: No Wipe Downgrade {status}")
        puml(":Flash Option change;\n", True)
        puml(f"note right:No Wipe Downgrade{status}\n")
        self.downgrade = status

    # -----------------------------------------------
    #                  _on_verbose
    # -----------------------------------------------
    def _on_verbose(self, event):
        self.verbose_checkBox = event.GetEventObject()
        status = self.verbose_checkBox.GetValue()
        print(f"Console Verbose: {status}")
        puml(":Console Verbose;\n", True)
        puml(f"note right:{status}\n")
        self.config.verbose = status
        set_verbose(status)

    # -----------------------------------------------
    #                  _on_reboot_recovery
    # -----------------------------------------------
    def _on_reboot_recovery(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot Recovery")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_recovery()
                    if res != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to recovery")
                    # Note, if the device ends up in interactive recovery, the user can still reboot to recovery to get the upside down android screen
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to recovery")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #         _on_reboot_recovery_interactive
    # -----------------------------------------------
    def _on_reboot_recovery_interactive(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot Interactive Recovery")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_recovery_interactive()
                    if res != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to interactive recovery")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to interactive recovery")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_reboot_download
    # -----------------------------------------------
    def _on_reboot_download(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot Download")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_download()
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to download")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to download")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_reboot_sideload
    # -----------------------------------------------
    def _on_reboot_sideload(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot Sideload")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_sideload()
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to sideload")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to sideload")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_reboot_safemode
    # -----------------------------------------------
    def _on_reboot_safemode(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot Safe Mode")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_safemode()
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to safe mode")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to safe mode")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  select_file_and_push
    # -----------------------------------------------
    def select_file_and_push(self, destination):
        try:
            with wx.FileDialog(self, _("Select files to push"), '', '', wildcard="All files (*.*)|*.*", style=wx.FD_OPEN | wx.FD_MULTIPLE) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled file push.")
                    return
                selected_files = fileDialog.GetPaths()

            self._on_spin('start')
            device = get_phone(True)
            got_errors = False
            errored_files = []
            if device:
                for selected_file in selected_files:
                    filename = ntpath.basename(selected_file)
                    # push the file
                    res = device.push_file(selected_file, f"{destination}/{filename}", False)
                    if res != 0:
                        print(f"Return Code: {res.returncode}")
                        print(f"Stdout: {res.stdout}")
                        print(f"Stderr: {res.stderr}")
                        print(f"Aborting push for file: {selected_file}\n")
                        self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
                        got_errors = True
                        errored_files.append(selected_file)
                        continue
                if got_errors:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while pushing the following files.")
                    print(f"Error pushing files: {errored_files}")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function select_file_and_push")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_push_to_tmp
    # -----------------------------------------------
    def _on_push_to_tmp(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Push to /data/local/tmp/")
        print("==============================================================================")
        self.select_file_and_push('/data/local/tmp/')

    # -----------------------------------------------
    #                  _on_push_to_download
    # -----------------------------------------------
    def _on_push_to_download(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Push to Download")
        print("==============================================================================")
        self.select_file_and_push('/sdcard/Download')

    # -----------------------------------------------
    #                  _on_reboot_system
    # -----------------------------------------------
    def _on_reboot_system(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot System")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_system()
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to system")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to system")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_reboot_bootloader
    # -----------------------------------------------
    def _on_reboot_bootloader(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot Bootloader")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_bootloader(fastboot_included = True)
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                        self.clear_device_selection()
                        bootloader_issue_message()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
            self.clear_device_selection()
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_reboot_fastbootd
    # -----------------------------------------------
    def _on_reboot_fastbootd(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Reboot Fastbootd")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    res = device.reboot_fastboot()
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to fastbootd")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to fatsbootd")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_lock_bootloader
    # -----------------------------------------------
    def _on_lock_bootloader(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Lock Bootloader")
        print("==============================================================================")
        if not self.config.device:
            return
        title = _("Lock Bootloader")
        message = _("         WARNING!!! WARNING!!! WARNING!!!\n\n")
        message += _("NEVER, EVER LOCK THE BOOTLOADER WITHOUT REVERTING\n")
        message += _("TO STOCK FIRMWARE OR YOUR PHONE WILL BE BRICKED!!!\n\n")
        message += _("       THIS WILL WIPE YOUR DEVICE DATA!!!\n\n")
        message += _("Do you want to continue to Lock the device bootloader?\n")
        message += _("       Press OK to continue or CANCEL to abort.\n")
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} {title}")
        print(f"\n*** Dialog ***\n{message}\n______________\n")
        set_message_box_title(title)
        set_message_box_message(message)
        try:
            dlg = MessageBoxEx(
                parent=self,
                title=title,
                message=message,
                button_texts=[_('OK'), _('CANCEL')],
                default_button=2,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
        except Exception:
            traceback.print_exc()
            return
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()

        if result == 1:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
        else:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
            print("Aborting ...\n")
            dlg.Destroy()
            return
        dlg.Destroy()

        title = _("Lock Bootloader")
        message = _("WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n")
        message += _("Make sure you first read either of the guides linked in the help menu.\n")
        message += _("Failing to follow the proper steps could potentially brick your phone.\n")
        message += _("\nNote: Pressing OK button will invoke a script that will utilize\n")
        message += _("fastboot commands, if your PC fastboot drivers are not properly setup,\n")
        message += _("fastboot will wait forever, and PixelFlasher will appear hung.\n")
        message += _("In such cases, killing the fastboot process will resume to normalcy.\n\n")
        message += _("      Do you want to continue to Lock the device bootloader?\n")
        message += _("              Press OK to continue or CANCEL to abort.\n")
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} {title}")
        print(f"\n*** Dialog ***\n{message}\n______________\n")
        set_message_box_title(title)
        set_message_box_message(message)
        dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=[_('OK'), _('CANCEL')],
            default_button=2,
            disable_buttons=None,
            is_md=False,
            size=(800, 600),
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()

        if result == 1:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
        else:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
            print("Aborting ...\n")
            dlg.Destroy()
            return
        dlg.Destroy()

        try:
            self._on_spin('start')
            device = get_phone(True)
            if device:
                res = device.lock_bootloader()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while locking bootloader")
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device not found.")
            if not self.config.no_reboot:
                print("echo rebooting to system ...\n")
                if device:
                    res = device.reboot_system()
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to system")
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device not found.")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while locking bootloader")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_unlock_bootloader
    # -----------------------------------------------
    def _on_unlock_bootloader(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Unlock Bootloader")
        print("==============================================================================")
        if not self.config.device:
            return
        title = _("Unlock Bootloader")
        message = _("WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n")
        message += _("Make sure you first read either of the guides linked in the help menu.\n")
        message += _("Failing to follow the proper steps could potentially brick your phone.\n")
        message += _("\nNote: Pressing OK button will invoke a script that will utilize\n")
        message += _("fastboot commands, if your PC fastboot drivers are not properly setup,\n")
        message += _("fastboot will wait forever, and PixelFlasher will appear hung.\n")
        message += _("In such cases, killing the fastboot process will resume to normalcy.\n\n")
        message += _("      Do you want to continue to Unlock the device bootloader?\n")
        message += _("              Press OK to continue or CANCEL to abort.\n")
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} {title}")
        print(f"\n*** Dialog ***\n{message}\n______________\n")
        set_message_box_title(title)
        set_message_box_message(message)
        dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=[_('OK'), _('CANCEL')],
            default_button=2,
            disable_buttons=None,
            is_md=False,
            size=(800, 600),
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()

        if result == 1:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
        else:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
            print("Aborting ...\n")
            dlg.Destroy()
            return
        dlg.Destroy()

        try:
            self._on_spin('start')
            device = get_phone(True)
            if device:
                res = device.unlock_bootloader()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while unlocking bootloader")
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device not found.")
            if not self.config.no_reboot:
                print("echo rebooting to system ...\n")
                if device:
                    res = device.reboot_system()
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to system")
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device not found.")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while unlocking bootloader")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_sos
    # -----------------------------------------------
    def _on_sos(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated SOS")
            print("==============================================================================")
            if not self.config.device:
                return
            title = _("Disable Magisk Modules")
            message = _("WARNING!!! This is an experimental feature to attempt disabling magisk modules.\n\n")
            message += _("You would only need to do this if your device is bootlooping due to\n")
            message += _("incompatible magisk modules, this is not guaranteed to work in all cases (YMMV).\n")
            message += _("\nNote: Pressing OK button will invoke a script that will wait forever to detect the device.\n")
            message += _("If your device is not detected PixelFlasher will appear hung.\n")
            message += _("In such cases, killing the adb process will resume to normalcy.\n\n")
            message += _("                        Press OK to continue or CANCEL to abort.\n")
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} {title}")
            print(f"\n*** Dialog ***\n{message}\n______________\n")
            set_message_box_title(title)
            set_message_box_message(message)
            dlg = MessageBoxEx(
                parent=self,
                title=title,
                message=message,
                button_texts=[_('OK'), _('CANCEL')],
                default_button=1,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()

            if result == 1:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
            else:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                print("Aborting ...\n")
                dlg.Destroy()
                return
            dlg.Destroy()

            self._on_spin('start')
            device = get_phone()
            device.disable_magisk_modules()
            time.sleep(5)
            self.device_choice.SetItems(get_connected_devices())
            self._select_configured_device()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in SOS function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_adb_shell
    # -----------------------------------------------
    def _on_adb_shell(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated ADB Shell")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    device.open_shell()
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device not found.")
                    self.clear_device_selection()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting adb shell")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_scrcpy
    # -----------------------------------------------
    def _on_scrcpy(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Scrcpy")
            print("==============================================================================")
            if self.config.device:
                self._on_spin('start')
                device = get_phone(True)
                if device:
                    device.scrcpy()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while launching scrcpy")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_magisk
    # -----------------------------------------------
    def _on_magisk(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Magisk Manager")
        print("==============================================================================")
        self._on_spin('start')
        dlg = None
        try:
            try:
                dlg = MagiskModules(parent=self, config=self.config)
            except Exception:
                traceback.print_exc()
                return
            if dlg is None or dlg.device is None:
                self.clear_device_selection()
                return
            dlg.CentreOnParent(wx.BOTH)
            self._on_spin('stop')
            try:
                result = dlg.ShowModal()
                if result != wx.ID_OK:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                    print("Aborting Magisk Modules Management ...\n")
            except Exception:
                traceback.print_exc()
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_pif_manager
    # -----------------------------------------------
    def _on_pif_manager(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated PIF Manager")
        print("==============================================================================")
        # load xiaomi if not already loaded
        if not get_xiaomi() and os.path.exists(get_xiaomi_file_path()):
            with open(get_xiaomi_file_path(), "r", encoding='ISO-8859-1', errors="replace") as f:
                set_xiaomi(json.load(f))
        # load favorite_pifs if not already loaded
        if not get_favorite_pifs() and os.path.exists(get_favorite_pifs_file_path()):
            with open(get_favorite_pifs_file_path(), "r", encoding='ISO-8859-1', errors="replace") as f:
                set_favorite_pifs(json.load(f))
        self._on_spin('start')
        print("Launching Pif Manager ...\n")

        try:
            dlg = PifManager(parent=self, config=self.config)
        except Exception:
            traceback.print_exc()
            self._on_spin('stop')
            return
        self._on_spin('stop')
        result = dlg.Show()

    # -----------------------------------------------
    #                  _on_rooting_app
    # -----------------------------------------------
    def _on_rooting_app(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Rooting App")
        print("==============================================================================")
        self._on_spin('start')
        dlg = None
        try:
            try:
                dlg = MagiskDownloads(self)
            except Exception:
                traceback.print_exc()
                return
            if dlg is None:
                return
            dlg.CentreOnParent(wx.BOTH)
            self._on_spin('stop')
            try:
                result = dlg.ShowModal()
                if result != wx.ID_OK:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                    print("Closing Magisk Downloads ...\n")
            except Exception:
                traceback.print_exc()
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_backup_manager
    # -----------------------------------------------
    def _on_backup_manager(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Backup Manager")
        print("==============================================================================")
        # device = get_phone(True)
        # device.get_magisk_backups()
        self._on_spin('start')
        dlg = None
        try:
            try:
                dlg = BackupManager(self)
            except Exception:
                traceback.print_exc()
                return
            if dlg is None or dlg.device is None:
                self.clear_device_selection()
                return
            dlg.CentreOnParent(wx.BOTH)
            self._on_spin('stop')
            try:
                result = dlg.ShowModal()
                if result != wx.ID_OK:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                    print("Closing Backup Manager ...\n")
            except Exception:
                traceback.print_exc()
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_data_adb_backup
    # -----------------------------------------------
    def _on_data_adb_backup(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Data ADB Backup")
        print("==============================================================================")
        try:
            device = get_phone(True)
            if device:
                timestr = time.strftime('%Y-%m-%d_%H-%M-%S')
                with wx.FileDialog(self, _("Save /data/adb backup file"), '', f"{device.hardware}_data_adb_{timestr}.tgz", wildcard="Data adb backup (*.tgz)|*.tgz",
                                style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                    if fileDialog.ShowModal() == wx.ID_CANCEL:
                        return     # the user changed their mind
                    pathname = fileDialog.GetPath()
                self._on_spin('start')
                device.data_adb_backup(pathname)
            else:
                self.clear_device_selection()
        except Exception:
            traceback.print_exc()
            return
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_data_adb_restore
    # -----------------------------------------------
    def _on_data_adb_restore(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Data ADB restore")
        print("==============================================================================")
        try:
            device = get_phone(True)
            if device:
                with wx.FileDialog(self, _("Select /data/adb backup file"), '', '', wildcard="All files (*.tgz)|*.tgz", style=wx.FD_OPEN) as fileDialog:
                    if fileDialog.ShowModal() == wx.ID_CANCEL:
                        print("User cancelled file push.")
                        return
                    selected_file = fileDialog.GetPath()
                self._on_spin('start')
                device.data_adb_restore(selected_file)
            else:
                self.clear_device_selection()
        except Exception:
            traceback.print_exc()
            self._on_spin('stop')
            return
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_data_adb_clear
    # -----------------------------------------------
    def _on_data_adb_clear(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Data ADB Clear")
        print("==============================================================================")
        try:
            device = get_phone(True)
            if device:
                title = _("Clear /data/adb/ contents")
                message = _("WARNING!!! This will the clear contents of /data/adb\n\n")
                message += _("Do you want to continue to clear /data/adb/ contents?\n")
                message += _("      Press OK to continue or CANCEL to abort.\n")
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} {title}")
                print(f"\n*** Dialog ***\n{message}\n______________\n")
                set_message_box_title(title)
                set_message_box_message(message)
                dlg = MessageBoxEx(
                    parent=self,
                    title=title,
                    message=message,
                    button_texts=[_('OK'), _('CANCEL')],
                    default_button=2,
                    disable_buttons=None,
                    is_md=False,
                    size=(800, 600),
                    checkbox_labels=None,
                    checkbox_initial_values=None,
                    disable_checkboxes=None,
                    vertical_checkboxes=False,
                    checkbox_labels2=None,
                    checkbox_initial_values2=None,
                    disable_checkboxes2=None,
                    radio_labels=None,
                    radio_initial_value=None,
                    disable_radios=None,
                    vertical_radios=False
                )
                dlg.CentreOnParent(wx.BOTH)
                result = dlg.ShowModal()
                if result == 1:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
                    self._on_spin('start')
                    device.data_adb_clear()
                else:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                    print("Aborting ...\n")
            else:
                self.clear_device_selection()
        except Exception:
            traceback.print_exc()
            self._on_spin('stop')
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_start_shizuku
    # -----------------------------------------------
    def _on_start_shizuku(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Start Shizuku")
        print("==============================================================================")
        try:
            device = get_phone(True)
            if device:
                _script_path = "/storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh"
                _script_exists, _ = device.check_file(_script_path)
                if _script_exists == 1:
                    res = device.exec_cmd(f'sh {_script_path}')
                    if res:
                        print(res)
                else:
                    _pkg_path = device.exec_cmd("pm path moe.shizuku.privileged.api")
                    _pkg = _pkg_path.removeprefix("package:").removesuffix("/base.apk\n") + "/lib/arm64/libshizuku.so"
                    res = device.exec_cmd(_pkg)
                    if res:
                        print(res)
            else:
                self.clear_device_selection()
        except Exception:
            traceback.print_exc()
            return

    # -----------------------------------------------
    #                  _on_partition_manager
    # -----------------------------------------------
    def _on_partition_manager(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Partition Manager")
        print("==============================================================================")
        self._on_spin('start')
        dlg = None
        try:
            try:
                dlg = PartitionManager(self)
            except Exception:
                traceback.print_exc()
                return
            if dlg is None or dlg.device is None:
                self.clear_device_selection()
                return
            dlg.CentreOnParent(wx.BOTH)
            self._on_spin('stop')
            try:
                result = dlg.ShowModal()
                if result != wx.ID_OK:
                    print("Closing Partition Manager ...\n")
            except Exception:
                traceback.print_exc()
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_logcat
    # -----------------------------------------------
    def _on_logcat(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Logcat")
        print("==============================================================================")
        self._on_spin('start')
        dlg = None
        try:
            try:
                dlg = LogcatDialog(self)
            except Exception:
                traceback.print_exc()
                return
            if dlg is None:
                return
            # dlg.CentreOnParent(wx.BOTH)
            self._on_spin('stop')
            try:
                result = dlg.ShowModal()
                print("Closing Logcat ...\n")
            except Exception:
                traceback.print_exc()
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_update_engine_logcat
    # -----------------------------------------------
    def _on_update_engine_logcat(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Logcat for Update Engine")
        print("==============================================================================")
        self._on_spin('start')
        dlg = None
        try:
            try:
                device = get_phone(True)
                if device:
                    device.open_update_engine_logcat()
            except Exception:
                traceback.print_exc()
                return
        finally:
            if dlg is not None:
                dlg.Destroy()
            self._on_spin('stop')

    # -----------------------------------------------
    #          _on_get_bootloader_versions
    # -----------------------------------------------
    def _on_get_bootloader_versions(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Get Bootloader Versions")
        print("==============================================================================")
        self._on_spin('start')
        dlg = None
        try:
            try:
                get_bootloader_versions()
            except Exception:
                traceback.print_exc()
                return
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_switch_slot
    # -----------------------------------------------
    def _on_switch_slot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Switch Slot")
            print("==============================================================================")
            if not self.config.device:
                return
            device = get_phone(True)
            self._on_spin('start')
            if device.active_slot not in ['a', 'b']:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unknown slot, is your device dual slot?")
                return
            print(f"User clicked on Switch Slot: Current Slot: [{device.active_slot}]")
            to_continue = self.switch_slot_alert()
            if not to_continue:
                print("Aborting ...\n")
                return
            self.vbmeta_alert(show_alert=True)
            device.switch_slot()
            if device:
                res = device.switch_slot()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while switching slot")
            if not self.config.no_reboot and device:
                res = device.reboot_system()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to system")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while switching slot")
            traceback.print_exc()
        finally:
            self.refresh_device()
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _open_sdk_link
    # -----------------------------------------------
    def _open_sdk_link(self, event):
        try:
            self._on_spin('start')
            print("Launching browser for SDK download URL: https://developer.android.com/studio/releases/platform-tools.html")
            webbrowser.open_new('https://developer.android.com/studio/releases/platform-tools.html')
            puml(f":Open SDK Link;\nnote right\n=== Android Platform Tools\n[[https://developer.android.com/studio/releases/platform-tools.html]]\nend note\n", True)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening skd link")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_wifi_manager
    # -----------------------------------------------
    def _on_wifi_manager(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Wifi Manager")
        print("==============================================================================")
        self._on_spin('start')
        try:
            print("Opening Wireless Manager ...\n")
            dlg = Wireless(self)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while loading wifi screen.")
            traceback.print_exc()
            self._on_spin('stop')
            return
        dlg.CentreOnParent(wx.BOTH)
        self._on_spin('stop')
        result = dlg.ShowModal()
        if result != wx.ID_OK:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
            print("Closing Wireless Manager ...\n")
            dlg.Destroy()
            return
        dlg.Destroy()

    # -----------------------------------------------
    #                  _on_adb_kill_server
    # -----------------------------------------------
    def _on_adb_kill_server(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated ADB Kill")
            print("==============================================================================")
            dlg = wx.MessageDialog(None, _("This will invoke the command adb kill-server.\nAre you sure want to continue?"), _('ADB Kill Server'),wx.YES_NO | wx.ICON_EXCLAMATION)
            result = dlg.ShowModal()
            if result != wx.ID_YES:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled Killing ADB server.")
                return
            print("User pressed ok kill ADB server")
            puml(":Kill ADB Server;\n", True)
            self._on_spin('start')
            adb_kill_server(self)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while killing adb server")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_custom_rom
    # -----------------------------------------------
    def _on_custom_rom(self, event):
        self.custom_rom_checkbox = event.GetEventObject()
        status = self.custom_rom_checkbox.GetValue()
        self.config.custom_rom = status
        if status:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Enabled Custom ROM")
            puml(":Custom ROM: ON;\n", True)
        else:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Disabled Custom ROM")
            puml(":Custom ROM: OFF;\n", True)
        populate_boot_list(self)
        self.update_widget_states()

    # -----------------------------------------------
    #                  _on_decode_binary_xml
    # -----------------------------------------------
    def _on_decode_binary_xml(self, event):
        try:
            with wx.FileDialog(self, _("Select binary xml file to decode"), '', '', wildcard="All files (*.xml;*.axml)|*.xml;*.axml", style=wx.FD_OPEN) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled binary xml file decoding.")
                    return
                selected_file = fileDialog.GetPath()

				# Decode xml
                if path.exists(selected_file):
                    xml_content = axml2xml(selected_file)
                    print(f"Decoded XML content:\n{xml_content}")
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: binary xml file not found")

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while decoding binary xml")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_check_keybox
    # -----------------------------------------------
    def _on_check_keybox(self, event):
        try:
            # Select keybox files
            total_keyboxes = None

            if wx.GetKeyState(wx.WXK_CONTROL) and wx.GetKeyState(wx.WXK_SHIFT):
                kb_stats_ui(self)
                return

            if wx.GetKeyState(wx.WXK_CONTROL) and wx.GetKeyState(wx.WXK_ALT):
                if self.config.unmarked_entries_path and os.path.exists(self.config.unmarked_entries_path):
                    target_path = self.config.unmarked_entries_path

                with wx.DirDialog(self, "Select reference marking folder", defaultPath=target_path, style=wx.DD_DEFAULT_STYLE) as dirDialog:
                    if dirDialog.ShowModal() == wx.ID_OK:
                        target_path = dirDialog.GetPath()
                        print(f"Selected reference folder: {target_path}")
                        self.config.unmarked_entries_path = target_path
                        self.config.save(get_config_file_path())
                    else:
                        print("Aborting ...\n")
                        return

                kb_add_missing_files(target_path=target_path, check_validity=True, dry_run=False, verbose=True)
                return

            if wx.GetKeyState(wx.WXK_CONTROL):
                update_kb_index_with_crl()
                return

            if wx.GetKeyState(wx.WXK_SHIFT):
                # Directory selection mode - get all xml files recursively
                with wx.DirDialog(self, _("Select directory containing keybox files")) as dirDialog:
                    if dirDialog.ShowModal() == wx.ID_CANCEL:
                        print("User cancelled keybox directory selection.")
                        return
                    selected_directory = dirDialog.GetPath()

                # Find all .xml files recursively in the selected directory
                selected_files = []
                for root, dirs, files in os.walk(selected_directory):
                    for file in files:
                        if file.lower().endswith('.xml'):
                            selected_files.append(os.path.join(root, file))

                if not selected_files:
                    print("No XML files found in the selected directory.")
                    return

                print(f"Found {len(selected_files)} XML files in directory: {selected_directory}")
            else:
                # Multi-File selection mode (default)
                with wx.FileDialog(self, _("Select keybox to test"), '', '', wildcard="All files (*.xml)|*.xml", style=wx.FD_OPEN | wx.FD_MULTIPLE) as fileDialog:
                    if fileDialog.ShowModal() == wx.ID_CANCEL:
                        print("User cancelled keybox.xml check.")
                        return
                    selected_files = fileDialog.GetPaths()

            # Define all possible result categories
            result_categories = {
                'valid': {'count': 0, 'files': [], 'description': 'Not Revoked keyboxes'},
                'revoked': {'count': 0, 'files': [], 'description': 'Revoked keyboxes'},
                'aosp': {'count': 0, 'files': [], 'description': 'Self signed / AOSP keyboxes'},
                'invalid': {'count': 0, 'files': [], 'description': 'Invalid keyboxes'},
                'long_chain': {'count': 0, 'files': [], 'description': 'Long chain keyboxes'},
                'shadow_banned': {'count': 0, 'files': [], 'description': 'Shadow banned keyboxes'},
                'invalid_structure': {'count': 0, 'files': [], 'description': 'keyboxes with invalid structure'},
                'missing_private_key': {'count': 0, 'files': [], 'description': 'Keyboxes with missing private keys'},
                'missing_chain': {'count': 0, 'files': [], 'description': 'Keyboxes with missing certificate chains'},
                'invalid_chain': {'count': 0, 'files': [], 'description': 'Keyboxes with invalid certificate chains'},
                'invalid_private_key': {'count': 0, 'files': [], 'description': 'Keyboxes with invalid private keys'},
                'key_mismatch': {'count': 0, 'files': [], 'description': 'Keyboxes with Private / Public Key mismatches'},
                'missing_algorithms': {'count': 0, 'files': [], 'description': 'Keyboxes with missing algorithms'}
            }

            # Find the length of the longest description for formatting
            longest_desc = max(len(data['description']) for data in result_categories.values())

            total_keyboxes = len(selected_files)

            self._on_spin('start')
            wx.Yield()

            # Process each keybox file
            for selected_file in selected_files:
                wx.Yield()
                res = check_kb(selected_file)

                # Update counts and lists for each result type
                for result_type in res:
                    if result_type in result_categories:
                        result_categories[result_type]['count'] += 1
                        result_categories[result_type]['files'].append(selected_file)

                # Keybox analysis output
                if self.config.kb_index and total_keyboxes < 10:
                    res = analyze_kb_file(filepath=selected_file)

        except Exception as e:
            print(f"Error: {e}")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

            if total_keyboxes is not None and total_keyboxes > 1:
                print("========================================================================")
                print(f"Total keyboxes checked: {total_keyboxes}")

                # Print summary for types with counts > 0
                for result_type, data in result_categories.items():
                    if data['count'] > 0:
                        spaces = ' ' * (longest_desc - len(data['description']) + 1)
                        print(f"{data['description']}:{spaces}{data['count']} / {total_keyboxes}")

                # Print detailed lists for each category with results
                for result_type, data in result_categories.items():
                    if data['count'] > 0:
                        print(f"\nList of {data['description'].lower()}:")
                        for keybox in data['files']:
                            print(f"    {keybox}")

                print("\n")

    # -----------------------------------------------
    #                  _on_customize_my_tools
    # -----------------------------------------------
    def _on_customize_my_tools(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Customize My Tools")
            print("==============================================================================")
            puml(":Customize My Tools;\n", True)
            dlg = MyToolsDialog(self, title=_('Customize My Tools'))
            dlg.ShowModal()
            dlg.Destroy()

            # Rebuild the tools menu
            self.build_my_tools_menu()

        except Exception as e:
            print(f"Error: {e}")
            traceback.print_exc()

    # -----------------------------------------------
    #                  build_my_tools_menu
    # -----------------------------------------------
    def build_my_tools_menu(self):
        try:
            # Clear the existing menu items
            menu_item_ids = self.my_tools_menu.GetMenuItems()
            for item in menu_item_ids:
                self.my_tools_menu.Remove(item.GetId())

            if os.path.exists(get_mytools_file_path()):
                with open(get_mytools_file_path(), "r", encoding='ISO-8859-1', errors="replace") as file:
                    tools_data = json.load(file)

                tool_added = False
                # Rebuild the menu with enabled items
                for i in range(1, tools_data['count'] + 1):
                    # Convert the current number to a string to match the keys in tools_data['tools']
                    tool_key = str(i)
                    tool = tools_data['tools'][tool_key]
                    if tool['title'] == "---":
                        self.my_tools_menu.AppendSeparator()
                    elif tool['enabled']:
                        menuItem = self.my_tools_menu.Append(wx.ID_ANY, tool['title'])
                        self.Bind(wx.EVT_MENU, lambda evt, t=tool: run_tool(t), menuItem)
                        tool_added = True
                if tool_added:
                    self.my_tools_menu.AppendSeparator()

            # Ensure the "Customize My Tools" menu item is kept at the end
            self.customize_my_tools_menu = self.my_tools_menu.Append(wx.ID_ANY, _("Customize My Tools"), _("Add / Edit / Delete Custom menu items"))
            self.customize_my_tools_menu.SetBitmap(images.wrench_24.GetBitmap())
            self.Bind(wx.EVT_MENU, self._on_customize_my_tools, self.customize_my_tools_menu)

        except Exception as e:
            print(f"Error: {e}")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_get_image_info
    # -----------------------------------------------
    def _on_get_image_info(self, event):
        try:
            with wx.FileDialog(self, _("Select Boot Image"), '', '', wildcard="All files (*.img)|*.img", style=wx.FD_OPEN) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled file push.")
                    return
                selected_file = fileDialog.GetPath()

            self._on_spin('start')
            print(f"\n=== Getting AVB image info for: [{selected_file}] ...")
            res = get_boot_image_info(selected_file)
            # for key, value in res.items():
            #     print(f"Key: {key} - Value: {value}")
        except Exception as e:
            print(f"Error: {e}")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_prep_downgrade_patch
    # -----------------------------------------------
    def _on_prep_downgrade_patch(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Prepare Downgrade Patch")
            print("==============================================================================")
            puml(":Prepare Downgrade Patch;\n", True)
            setup_for_downgrade(self)
            self.update_widget_states()
        except Exception as e:
            print(f"Error: {e}")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_show_all_boot
    # -----------------------------------------------
    def _on_show_all_boot(self, event):
        self.show_all_boot_checkBox = event.GetEventObject()
        status = self.show_all_boot_checkBox.GetValue()
        self.config.show_all_boot = status
        print("Show All Boot Images")
        puml(":Show all boot images;\n", True)
        populate_boot_list(self)

    # -----------------------------------------------
    #                  _on_boot_selected
    # -----------------------------------------------
    def _on_boot_selected(self, event):
        try:
            self.selected_partition_label.SetLabel("")
            x,y = event.GetPosition()
            row,flags = self.list.HitTest((x,y))
            boot = None
            for i in range (0, self.list.ItemCount):
                # deselect all items
                self.list.Select(i, 0)
                item = self.list.GetItem(i)
                # reset colors
                if sys.platform == "win32":
                    item.SetTextColour(wx.BLACK)
                elif darkdetect.isDark():
                    item.SetTextColour(wx.WHITE)
                self.list.SetItem(item)
            if row != -1:
                boot = Boot()
                self.list.Select(row)
                item = self.list.GetItem(row)
                if sys.platform == "win32":
                    item.SetTextColour(wx.BLUE)
                self.list.SetItem(item)
                boot.boot_hash = self.list.GetItemText(row, col=0)
                # get the raw data from db, listctrl is just a formatted display
                con = get_db_con()
                if con is None:
                    return None

                query = f"{boot.boot_hash}%"
                sql = """
                    SELECT
                        BOOT.id as boot_id,
                        BOOT.boot_hash,
                        BOOT.file_path as boot_path,
                        BOOT.is_patched,
                        BOOT.patch_method,
                        BOOT.magisk_version,
                        BOOT.hardware,
                        BOOT.is_odin,
                        BOOT.epoch as boot_date,
                        PACKAGE.id as package_id,
                        PACKAGE.boot_hash as package_boot_hash,
                        PACKAGE.type as package_type,
                        PACKAGE.package_sig,
                        PACKAGE.file_path as package_path,
                        PACKAGE.epoch as package_date,
                        BOOT.is_stock_boot,
                        BOOT.is_init_boot,
                        BOOT.patch_source_sha1
                    FROM BOOT
                    JOIN PACKAGE_BOOT
                        ON BOOT.id = PACKAGE_BOOT.boot_id
                        AND BOOT.boot_hash LIKE ?
                    JOIN PACKAGE
                        ON PACKAGE.id = PACKAGE_BOOT.package_id;
                """
                with con:
                    data = con.execute(sql, (query,))
                    package_boot_count = 0
                    for row in data:
                        boot.boot_id = row[0]
                        boot.boot_hash = row[1]
                        boot.boot_path = row[2]
                        boot.is_patched = row[3]
                        boot.patch_method = row[4]
                        boot.magisk_version = row[5]
                        boot.hardware = row[6]
                        boot.is_odin = row[7]
                        boot.boot_epoch = row[8]
                        boot.package_id = row[9]
                        boot.package_boot_hash = row[10]
                        boot.package_type = row[11]
                        boot.package_sig = row[12]
                        boot.package_path = row[13]
                        boot.package_epoch = row[14]
                        boot.is_stock_boot = row[15]
                        boot.is_init_boot = row[16]
                        boot.patch_source_sha1 = row[17]
                        package_boot_count += 1

                # set partition type label
                partition_type = "boot"
                if boot.is_init_boot:
                    partition_type = "init_boot"
                elif boot.boot_path and "vendor_boot" in os.path.basename(boot.boot_path):
                    partition_type = "vendor_boot"
                self.selected_partition_label.SetLabel(partition_type)

                # Check if the original boot_path exists in case pf_home changed.
                original_path = boot.boot_path
                if os.path.exists(original_path):
                    # Path exists, keep it as is
                    pass
                else:
                    # Path doesn't exist, try to reconstruct it with pf_home
                    try:
                        if "boot_images4" in original_path:
                            path_parts = original_path.split("boot_images4", 1)
                            right_side = "boot_images4" + path_parts[1]
                            new_path = os.path.join(self.config.pf_home, right_side)

                            if os.path.exists(new_path):
                                # Update boot path in object and database
                                boot.boot_path = new_path
                                try:
                                    con = get_db_con()
                                    if con is not None:
                                        with con:
                                            con.execute("UPDATE BOOT SET file_path = ? WHERE id = ?", (new_path, boot.boot_id))
                                        print(f"ℹ️ Updated boot path from {original_path} to {new_path}")
                                except Exception as e:
                                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to update boot path in database: {e}")
                    except Exception as e:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error processing boot path: {e}")

                self.config.boot_id = boot.boot_id
                self.config.selected_boot_md5 = boot.boot_hash
                print("==============")
                print("Selected Boot:")
                print("==============")
                puml(":Select Boot;\n", True)
                message = f"File:                     {os.path.basename(urlparse(boot.boot_path).path)}\n"
                message += f"Path:                     {boot.boot_path}\n"
                message += f"SHA1:                     {boot.boot_hash}\n"
                if boot.is_patched == 1:
                    patched = True
                    message += f"Patched:                  {patched}\n"
                    if boot.patch_method:
                        message += f"Patched Method:           {boot.patch_method}\n"
                    if boot.patch_source_sha1:
                        message += f"Patch Source SHA1:        {boot.patch_source_sha1}\n"
                    if boot.patch_method in ["kernelsu", "kernelsu_lkm"]:
                        message += f"Patched With KernelSU:    {boot.magisk_version}\n"
                    if "kernelsu-next" in boot.patch_method:
                        message += f"Patched With KSU-Next:    {boot.magisk_version}\n"
                    elif "sukisu" in boot.patch_method:
                        message += f"Patched With SukiSU:      {boot.magisk_version}\n"
                    elif "wild_ksu" in boot.patch_method:
                        message += f"Patched With Wild_KSU:      {boot.magisk_version}\n"
                    elif "apatch" in boot.patch_method:
                        message += f"Patched With Apatch:      {boot.magisk_version}\n"
                    else:
                        message += f"Patched With Magisk:      {boot.magisk_version}\n"
                    message += f"Patched on Device:        {boot.hardware}\n"
                else:
                    patched = False
                    message += f"Patched:                  {patched}\n"
                ts = datetime.fromtimestamp(boot.boot_epoch)
                if boot.is_odin == 1:
                    message += f"Samsung Boot:             True\n"
                if boot.is_stock_boot == 0:
                    message += f"Stock Boot:               False\n"
                elif boot.is_stock_boot == 1:
                    message += f"Stock Boot:               True\n"

                # get boot image info
                boot_img_info = get_boot_image_info(boot.boot_path)
                if boot_img_info and boot_img_info['Partition Name']:
                    partition = boot_img_info['Partition Name']
                    set_selected_boot_partition(partition)
                    self.selected_partition_label.SetLabel(partition)
                else:
                    set_selected_boot_partition(None)
                    partition = None
                    self.selected_partition_label.SetLabel("")
                if boot_img_info and partition and f'com.android.build.{partition}.security_patch' in boot_img_info:
                    boot.spl = boot_img_info[f'com.android.build.{partition}.security_patch']
                if boot_img_info and partition and f'com.android.build.{partition}.fingerprint' in boot_img_info:
                    boot.fingerprint = boot_img_info[f'com.android.build.{partition}.fingerprint']
                message += f"Date:                     {ts.strftime('%Y-%m-%d %H:%M:%S')}\n"
                message += f"Firmware Fingerprint:     {boot.package_sig}\n"
                message += f"Firmware:                 {boot.package_path}\n"
                message += f"Type:                     {boot.package_type}\n"

                # Get kernel info
                if partition:
                    kernel_build, kernel_date = extract_kernel_info(boot.boot_path)
                    if kernel_build:
                        message += f"Selected Kernel Build:    {kernel_build}\n"
                    if kernel_date:
                        message += f"Selected Kernel Date:     {kernel_date}\n"
                # if there is a boot.img file in the same folder as the boot, get its kernel info too
                boot_dir = os.path.dirname(boot.boot_path)
                stock_boot_path = os.path.join(boot_dir, "boot.img")
                if os.path.exists(stock_boot_path) and stock_boot_path != boot.boot_path:
                    stock_kernel_build, stock_kernel_date = extract_kernel_info(stock_boot_path)
                    if stock_kernel_build:
                        message += f"Stock Kernel Build:       {stock_kernel_build}\n"
                    if stock_kernel_date:
                        message += f"Stock Kernel Date:        {stock_kernel_date}\n"

                if package_boot_count > 1:
                    message += f"\nINFO: Multiple PACKAGE_BOOT records found for {boot.boot_hash}."
                print(f"{message}")
                puml(f"note right\n{message}\nend note\n")
            else:
                self.config.boot_id = None
                self.config.selected_boot_md5 = None
                if self.list.ItemCount == 0 :
                    if self.config.firmware_path:
                        print("\nPlease Process the firmware!")
                else:
                    print("\nPlease select a boot/init_boot!")
            set_boot(boot)
            set_flash_button_state(self)
            self._update_custom_flash_options()
            self.update_widget_states()
        except Exception as e:
            print(f"Error: {e}")
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while selecting boot.")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_get_boot_info
    # -----------------------------------------------
    def _on_get_boot_info(self, event):
        try:
            boot = get_boot()
            if boot:
                info = get_boot_image_info(boot.boot_path)

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting boot info")
            traceback.print_exc()
        return

    # -----------------------------------------------
    #                  _on_add_boot
    # -----------------------------------------------
    def _on_add_boot(self, event):
        # TODO
        return

    # -----------------------------------------------
    #                  _on_delete_boot
    # -----------------------------------------------
    def _on_delete_boot(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Delete Boot Image")
        print("==============================================================================")
        try:
            self._on_spin('start')
            boot = get_boot()
            if boot and boot.boot_id and boot.package_id:
                print("Delete boot image button is pressed.")
                puml(":Delete boot image;\n", True)
                print(f"Deleting boot record,  ID:{boot.boot_id}  Boot_ID:{boot.boot_hash[:8]} ...")
                puml(f"note right\nID:{boot.boot_id}\nBoot_ID:{boot.boot_hash[:8]}\nend note\n")

                # from PACKAGE, find all other package ids that have the same boot_hash
                package_ids = find_package_ids_with_same_package_boot_hash(boot.package_boot_hash)

                # if the array has at least one entry, delete all package_boot records with this boot_id
                if len(package_ids) > 0  :
                    for package_id in package_ids:
                        # Delete PACKAGE_BOOT record
                        delete_package_boot_record(boot.boot_id, package_id)

                # Check to see if this is the last entry for the boot_id, if it is delete it,
                delete_last_boot_record(boot.boot_id, boot.boot_path)

                # Check to see if this is the last entry for the package_id, if it is,
                # delete the package from db and also delete unpacked files from factory_images cache
                boot_dir = os.path.dirname(boot.boot_path)
                delete_last_package_record(package_ids, boot_dir)

        finally:
            set_boot(None)
            populate_boot_list(self)
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_boot_folder
    # -----------------------------------------------
    def _on_boot_folder(self, event):
        try:
            self._on_spin('start')
            boot = get_boot()
            if boot:
                open_folder(self, boot.boot_path, True)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening boot folder")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_firmware_folder
    # -----------------------------------------------
    def _on_firmware_folder(self, event):
        try:
            self._on_spin('start')
            boot = get_boot()
            if boot:
                config_path = get_config_path()
                working_dir = os.path.join(config_path, 'factory_images', boot.package_sig)
                open_folder(self, working_dir, False)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening firmware folder")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_live_boot
    # -----------------------------------------------
    def _on_live_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Live boot")
            print("==============================================================================")
            self._on_spin('start')
            live_flash_boot_phone(self, 'Live')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while live booting")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_flash_boot
    # -----------------------------------------------
    def _on_flash_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Flash Boot")
            print("==============================================================================")
            self._on_spin('start')
            live_flash_boot_phone(self, 'Flash')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while flashing boot")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_paste_selection
    # -----------------------------------------------
    def _on_paste_selection(self, event):
        try:
            config_path = get_config_path()
            factory_images = os.path.join(config_path, 'factory_images')
            package_sig = get_firmware_id()
            package_dir_full = os.path.join(factory_images, package_sig)
            image_mode = self.image_choice.Items[self.image_choice.GetSelection()]
            flag = True
            pasted_filename = None
            if image_mode == 'boot':
                boot = get_boot()
                if boot and boot.is_init_boot == 1:
                    if boot.is_patched == 1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Selected file is not of type boot")
                        flag = False
                    else:
                        # if init_boot and stock, then we want to paste the stock boot.img path
                        print(f"Selected file is stock init_boot, looking for stock boot.img instead ...")
                        boot_dir = os.path.dirname(boot.boot_path)
                        boot_img_path = os.path.join(boot_dir, 'boot.img')
                        pasted_filename = boot_img_path
                elif boot and boot.boot_path:
                    pasted_filename = boot.boot_path
            elif image_mode == 'init_boot':
                boot = get_boot()
                if boot and boot.is_init_boot != 1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Selected file is not of type init_boot")
                    flag = False
                elif boot and boot.boot_path:
                    pasted_filename = boot.boot_path
            elif image_mode == "vbmeta":
                pasted_filename = find_file_by_prefix(package_dir_full, "vbmeta.img")
            elif image_mode == "bootloader":
                pasted_filename = find_file_by_prefix(package_dir_full, "bootloader-")
            elif image_mode == "radio":
                pasted_filename = find_file_by_prefix(package_dir_full, "radio-")
            elif image_mode == "dtbo":
                pasted_filename = find_file_by_prefix(package_dir_full, "dtbo.img")
            elif image_mode == "vendor_boot":
                pasted_filename = find_file_by_prefix(package_dir_full, "vendor_boot.img")
            elif image_mode == "vendor_kernel_boot":
                pasted_filename = find_file_by_prefix(package_dir_full, "vendor_kernel_boot.img")
            elif image_mode == "super_empty":
                pasted_filename = find_file_by_prefix(package_dir_full, "super_empty.img")
            else:
                flag = False
            if not flag:
                return
            if pasted_filename is None:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: file Not Found in {package_dir_full}")
                flag = False
                return
            if flag and os.path.exists(pasted_filename):
                print(f"Pasted {pasted_filename} to custom flash")
                puml(f":Paste boot path;\nnote right:{pasted_filename};\n", True)
                self.image_file_picker.SetPath(pasted_filename)
                set_image_path(pasted_filename)
                self._update_custom_flash_options()
                set_flash_button_state(self)
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: file: {pasted_filename} Not Found in {package_dir_full}")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered while patching with Magisk")
            traceback.print_exc()
        finally:
            if not flag:
                print("Nothing to paste!")
                self.image_file_picker.SetPath('')

    # -----------------------------------------------
    #                  _on_magisk_patch_boot
    # -----------------------------------------------
    def _on_magisk_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Magisk Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'Magisk')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered while patching with Magisk")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_kernelsu_patch_boot
    # -----------------------------------------------
    def _on_kernelsu_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated KernelSU Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'KernelSU')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching with KernelSU")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #          _on_kernelsu_legacy_patch_boot
    # -----------------------------------------------
    def _on_kernelsu_legacy_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated KernelSU Legacy Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'KernelSU-Legacy')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching with KernelSU Legacy")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_sukisu_patch_boot
    # -----------------------------------------------
    def _on_sukisu_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated SukiSU Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'SukiSU')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching with SukiSU")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_wild_ksu_patch_boot
    # -----------------------------------------------
    def _on_wild_ksu_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Wild_KSU Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'Wild_KSU')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching with Wild_KSU")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_kernelsu_lkm_patch_boot
    # -----------------------------------------------
    def _on_kernelsu_lkm_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated KernelSU LKM Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'KernelSU_LKM')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching KernelSU LKM")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_sukisu_lkm_patch_boot
    # -----------------------------------------------
    def _on_sukisu_lkm_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated SukiSU LKM Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'SukiSU_LKM')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching SukiSU LKM")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_wild_ksu_lkm_patch_boot
    # -----------------------------------------------
    def _on_wild_ksu_lkm_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Wild_KSU LKM Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'Wild_KSU_LKM')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching Wild_KSU LKM")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #          _on_kernelsu_next_patch_boot
    # -----------------------------------------------
    def _on_kernelsu_next_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated KernelSU-Next Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'KernelSU-Next')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching with KernelSU-Next")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #          _on_kernelsu_next_lkm_patch_boot
    # -----------------------------------------------
    def _on_kernelsu_next_lkm_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated KernelSU-Next LKM Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'KernelSU-Next_LKM')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching KernelSU-Next LKM")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_apatch_patch_boot
    # -----------------------------------------------
    def _on_apatch_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated APatch Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'APatch')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching with APatch")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_apatch_manual_patch_boot
    # -----------------------------------------------
    def _on_apatch_manual_patch_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated APatch Alternate Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'APatch_manual')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching with APatch Alternate")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_patch_custom_boot
    # -----------------------------------------------
    def _on_patch_custom_boot(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Custom Patch boot")
            print("==============================================================================")
            self._on_spin('start')
            patch_boot_img(self, 'Custom')
            self.update_widget_states()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while patching custom boot")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_flash
    # -----------------------------------------------
    def _on_flash(self, event):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Flash Device.")
            print("==============================================================================")
            self.spinner_label.Label = "Please be patient ...\n\nDuring this process:\n ! Do not touch the device\n ! Do not unplug your device"
            self._on_spin('start')
            self.flash_button.Enable(False)
            res = flash_phone(self)
            if res == -1:
                print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} INFO: Flashing was aborted.")
                print("This could be user initiated or a problem encountered during flashing.")
                device = get_phone()
                if device:
                    mode = device.get_device_state()
                    print(f"Current device mode: {mode}")
                print("You might need to manually reboot your device.\n")
                self.refresh_device()
            self._on_spin('stop')
            self.flash_button.Enable(True)
            self.update_widget_states()
            self.spinner_label.Label = "Please be patient ..."
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while flashing")
            traceback.print_exc()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_clear
    # -----------------------------------------------
    def _on_clear(self, event):
        self.console_ctrl.SetValue("")
        puml(":Clear Console Logs;\n", True)

    # -----------------------------------------------
    #                  update_slot_image
    # -----------------------------------------------
    def update_slot_image(self, slot):
        try:
            slot_image = self.slot_image.GetBitmap()
            slot_image_height = 0

            will_be_visible = False
            if slot == "a":
                self.slot_image.SetBitmap(images.slot_a_48.GetBitmap())
                will_be_visible = True
            elif slot == "b":
                self.slot_image.SetBitmap(images.slot_b_48.GetBitmap())
                will_be_visible = True
            else:
                self.slot_image.SetBitmap(wx.NullBitmap)  # Set the bitmap to None
                will_be_visible = False

            with contextlib.suppress(Exception):
                slot_image_height = slot_image.GetHeight()

            was_visible = slot_image_height > 0

            if (not was_visible and will_be_visible) or (was_visible and not will_be_visible):
                self._refresh_ui()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while updating slot image")
            traceback.print_exc()

    # -----------------------------------------------
    #                  update_rooted_with_image
    # -----------------------------------------------
    def update_rooted_with_image(self, rooted_with):
        try:
            try:
                root_app_version, root_app = rooted_with.rsplit(":", 1)
            except Exception as e:
                root_app = rooted_with
            rooted_with_image = self.rooted_with_image.GetBitmap()
            rooted_with_image_height = 0
            self.rooted_with_image.SetToolTip(f"Rooted With: {rooted_with}")

            will_be_visible = False
            if root_app == "MAGISKSU":
                self.rooted_with_image.SetBitmap(images.magisk_48.GetBitmap())
                will_be_visible = True
            elif root_app == "KernelSU":
                self.rooted_with_image.SetBitmap(images.kernelsu_48.GetBitmap())
                will_be_visible = True
            elif root_app == "KSU-Next":
                self.rooted_with_image.SetBitmap(images.kernelsu_next_48.GetBitmap())
                will_be_visible = True
            elif root_app == "SukiSU":
                self.rooted_with_image.SetBitmap(images.sukisu_48.GetBitmap())
                will_be_visible = True
            elif root_app == "WildKSU":
                self.rooted_with_image.SetBitmap(images.wild_ksu_48.GetBitmap())
                will_be_visible = True
            elif root_app == "APatch":
                self.rooted_with_image.SetBitmap(images.apatch_48.GetBitmap())
                will_be_visible = True
            else:
                self.rooted_with_image.SetBitmap(wx.NullBitmap)  # Set the bitmap to None
                self.rooted_with_image.SetToolTip("")
                will_be_visible = False

            with contextlib.suppress(Exception):
                rooted_with_image_height = rooted_with_image.GetHeight()

            was_visible = rooted_with_image_height > 0

            if (not was_visible and will_be_visible) or (was_visible and not will_be_visible):
                self._refresh_ui()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while updating slot image")
            traceback.print_exc()

    # -----------------------------------------------
    #                  update_rooted_image
    # -----------------------------------------------
    def update_rooted_image(self, is_rooted=False):
        try:
            rooted_image = self.rooted_image.GetBitmap()
            rooted_image_height = 0

            will_be_visible = False
            if is_rooted:
                self.rooted_image.SetBitmap(images.rooted.GetBitmap())
                will_be_visible = True
            else:
                self.rooted_image.SetBitmap(wx.NullBitmap)  # Set the bitmap to None
                will_be_visible = False

            with contextlib.suppress(Exception):
                rooted_image_height = rooted_image.GetHeight()

            was_visible = rooted_image_height > 0

            if (not was_visible and will_be_visible) or (was_visible and not will_be_visible):
                self._refresh_ui()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while updating root image")
            traceback.print_exc()

    # -----------------------------------------------
    #                  _on_show_device_download
    # -----------------------------------------------
    def _on_show_device_download(self, event):
        device = get_phone()
        if not device:
            return
        menu = GoogleImagesPopupMenu(self, device=device.hardware, date_filter=device.firmware_date)
        self.PopupMenu(menu)

    #-----------------------------------------------------------------------------
    #                                   _init_ui
    #-----------------------------------------------------------------------------
    def _init_ui(self):
        # -----------------------------------------------
        #                  _add_mode_radio_button
        # -----------------------------------------------
        def _add_mode_radio_button(sizer, index, flash_mode, label, tooltip):
            style = wx.RB_GROUP if index == 0 else 0
            self.mode_radio_button = wx.RadioButton(panel, name=f"mode-{flash_mode}", label=f"{label}", style=style)
            self.mode_radio_button.Bind(wx.EVT_RADIOBUTTON, self._on_mode_changed)
            self.mode_radio_button.mode = flash_mode
            if flash_mode == self.config.flash_mode:
                self.mode_radio_button.SetValue(True)
            else:
                self.mode_radio_button.SetValue(False)
            self.mode_radio_button.SetToolTip(tooltip)
            sizer.Add(self.mode_radio_button)
            sizer.AddSpacer(10)

        # ==============
        # UI Setup Here
        # ==============
        panel = wx.Panel(self)
        vbox = wx.BoxSizer(orient=wx.VERTICAL)

        fgs1 = wx.FlexGridSizer(cols=2, vgap=10, hgap=10)

        # Add the toolbar
        self._build_toolbar(self.toolbar_flags)

        # 1st row widgets, Android platform tools
        self.platform_tools_label = wx.StaticText(parent=panel, id=wx.ID_ANY, label=_("Android Platform Tools"))
        self.sdk_link = wx.BitmapButton(parent=panel, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.sdk_link.SetBitmap(bitmap=images.open_link_24.GetBitmap())
        self.sdk_link.SetToolTip(_("Download Latest Android Platform-Tools"))
        self.platform_tools_picker = ResizableButtonDirPickerCtrl(
            parent=panel,
            id=wx.ID_ANY,
            style=wx.DIRP_USE_TEXTCTRL | wx.DIRP_DIR_MUST_EXIST | wx.DIRP_SMALL,
            button_label=_("  Browse  ")
        )
        self.platform_tools_picker.SetToolTip(_("Select Android Platform-Tools Folder\nWhere adb and fastboot are located."))
        platform_tools_label_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        platform_tools_label_sizer.Add(window=self.platform_tools_label, proportion=0, flag=wx.ALL, border=0)
        platform_tools_label_sizer.AddStretchSpacer()
        platform_tools_label_sizer.Add(window=self.sdk_link, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        self.sdk_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        self.sdk_sizer.Add(window=self.platform_tools_picker, proportion=1, flag=wx.EXPAND)

        # 2nd row widgets, Connected Devices
        self.device_label = wx.StaticText(parent=panel, id=wx.ID_ANY, label=_("ADB Connected Devices"))
        self.device_label.SetToolTip(_("Double click this label to issue the command:\nadb kill-server"))
        self.wifi_adb = wx.BitmapButton(parent=panel, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.wifi_adb.SetBitmap(images.wifi_adb_24.GetBitmap())
        self.wifi_adb.SetToolTip(_("Open wireless manager dialog."))
        adb_label_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        adb_label_sizer.Add(window=self.device_label, proportion=0, flag=wx.ALL, border=0)
        adb_label_sizer.AddStretchSpacer()
        adb_label_sizer.Add(window=self.wifi_adb, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        self.device_choice = NoScrollComboBox(parent=panel, id=wx.ID_ANY, value=wx.EmptyString, pos=wx.DefaultPosition, size=wx.DefaultSize, choices=[], style=wx.CB_DROPDOWN | wx.CB_READONLY)
        self.device_choice.SetSelection(-1)
        self.device_choice.SetFont(font=wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL))
        device_tooltip = _("[root status] [device mode] [device id] [device model] [device firmware]\n\n")
        device_tooltip += _("✓ Rooted with Magisk.\n")
        device_tooltip += _("✗ Probably Not Root (Magisk Tools not found).\n")
        device_tooltip += _("?  Unable to determine the root status.\n\n")
        device_tooltip += _("(adb) device is in adb mode\n")
        device_tooltip += _("(f.b) device is in fastboot mode\n")
        device_tooltip += _("(sid) device is in sideload mode\n")
        device_tooltip += _("(rec) device is in recovery mode\n")
        self.device_choice.SetToolTip(device_tooltip)
        self.scan_button = wx.Button(parent=panel, label=_("Scan"))
        self.scan_button.SetToolTip(_("Scan only enabled Devices\nPlease manually select the device after the scan is completed."))
        self.scan_button.SetBitmap(images.scan_24.GetBitmap())
        self.scan_all_button = wx.Button(parent=panel, label=_("Scan All"))
        self.scan_all_button.SetToolTip(_("Scan all Devices\nPlease manually select the device after the scan is completed."))
        self.scan_all_button.SetBitmap(images.scan_all_24.GetBitmap())
        device_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        device_sizer.Add(window=self.device_choice, proportion=1, flag=wx.EXPAND)
        device_sizer.Add(window=self.scan_all_button, flag=wx.LEFT, border=2)
        device_sizer.Add(window=self.scan_button, flag=wx.LEFT, border=2)

        # 3rd row Reboot buttons, device related buttons
        # removed

        # 4th row, empty row, static line
        self.staticline1 = wx.StaticLine(parent=panel, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.LI_HORIZONTAL)
        self.staticline1.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT))

        # 5th row widgets, firmware file
        firmware_label = wx.StaticText(parent=panel, label=_("Device Image"))
        self.firmware_button = wx.BitmapButton(parent=panel, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.firmware_button.SetBitmap(images.open_link_24.GetBitmap())
        self.firmware_button.SetToolTip(_("Download image file for current Pixel device."))
        self.firmware_picker = FilePickerComboBox(
            parent=panel,
            dialog_title=_("Select a file"),
            wildcard="Factory Image files (*.zip;*.tgz;*.tar)|*.zip;*.tgz;*.tar"
        )
        self.firmware_picker.SetToolTip(_("Select Pixel Firmware"))
        self.process_firmware = wx.Button(parent=panel, id=wx.ID_ANY, label=_("Process"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.process_firmware.SetBitmap(images.process_file_24.GetBitmap())
        self.process_firmware.SetToolTip(_("Process the firmware file and extract the boot.img"))
        firmware_label_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        firmware_label_sizer.Add(window=firmware_label, proportion=0, flag=wx.ALL, border=2)
        firmware_label_sizer.AddStretchSpacer(1)
        firmware_label_sizer.Add(window=self.firmware_button, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        self.firmware_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        self.firmware_sizer.Add(window=self.firmware_picker, proportion=1, flag=wx.EXPAND)
        self.firmware_sizer.Add(window=self.process_firmware, flag=wx.LEFT, border=2)

        # 6th row widgets, custom_rom
        self.custom_rom_checkbox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Apply Custom ROM"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.custom_rom_checkbox.SetToolTip(_("Caution: Make sure you read the selected ROM documentation.\nThis might not work for your ROM"))
        self.custom_rom = ResizableButtonFilePickerCtrl(
            parent=panel,
            id=wx.ID_ANY,
            path=wx.EmptyString,
            message=_("Select a file"),
            wildcard="ROM files (*.zip;*.tgz;*.tar)|*.zip;*.tgz;*.tar",
            style=wx.FLP_USE_TEXTCTRL,
            button_label=_("Browse")
        )
        self.custom_rom.SetToolTip(_("Select Custom ROM"))
        self.process_rom = wx.Button(parent=panel, id=wx.ID_ANY, label=_("Process"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.process_rom.SetBitmap(images.process_file_24.GetBitmap())
        self.process_rom.SetToolTip(_("Process the ROM file and extract the boot.img"))
        custom_rom_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        custom_rom_sizer.Add(window=self.custom_rom, proportion=1, flag=wx.EXPAND)
        custom_rom_sizer.Add(window=self.process_rom, flag=wx.LEFT, border=2)

        # 7th row widgets, boot.img related widgets
        self.select_boot_label = wx.StaticText(parent=panel, id=wx.ID_ANY, label=_("Select a boot/init_boot"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.show_all_boot_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Show All boot/init_boot"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.show_all_boot_checkBox.SetToolTip(_("Show all boot/init_boot even if it is\nnot part of the selected firmware or ROM"))
        #
        self.selected_partition_label = wx.StaticText(parent=panel, id=wx.ID_ANY, label="")
        font = self.selected_partition_label.GetFont()
        font.MakeBold()
        font.SetPointSize(font.GetPointSize() + 2)
        self.selected_partition_label.SetFont(font)
        #
        self.slot_image = wx.StaticBitmap(panel, pos=(0, 0))
        self.slot_image.SetBitmap(wx.NullBitmap)
        self.rooted_image = wx.StaticBitmap(panel, pos=(0, 0))
        self.rooted_image.SetBitmap(wx.NullBitmap)
        self.rooted_with_image = wx.StaticBitmap(panel, pos=(0, 0))
        self.rooted_with_image.SetBitmap(wx.NullBitmap)
        self.rooted_with_image.SetToolTip("")
        # list control
        if self.CharHeight > 20:
            self.il = wx.ImageList(24, 24)
            self.idx_magisk = self.il.Add(images.magisk_24.GetBitmap())                 # index 0 - magisk
            self.idx_apatch = self.il.Add(images.apatch_24.GetBitmap())                 # index 1 - apatch
            self.idx_kernelsu_next = self.il.Add(images.kernelsu_next_24.GetBitmap())   # index 2 - kernelsu-next
            self.idx_kernelsu = self.il.Add(images.kernelsu_24.GetBitmap())             # index 3 - kernelsu
            self.idx_downgrade = self.il.Add(images.downgrade_24.GetBitmap())           # index 4 - downgrade
            self.idx_sukisu = self.il.Add(images.sukisu_24.GetBitmap())                 # index 5 - sukisu
            self.idx_wild_ksu = self.il.Add(images.wild_ksu_24.GetBitmap())             # index 6 - wild_ksu
        else:
            self.il = wx.ImageList(16, 16)
            self.idx_magisk = self.il.Add(images.magisk_16.GetBitmap())                 # index 0 - magisk
            self.idx_apatch = self.il.Add(images.apatch_16.GetBitmap())                 # index 1 - apatch
            self.idx_kernelsu_next = self.il.Add(images.kernelsu_next_16.GetBitmap())   # index 2 - kernelsu-next
            self.idx_kernelsu = self.il.Add(images.kernelsu_16.GetBitmap())             # index 3 - kernelsu
            self.idx_downgrade = self.il.Add(images.downgrade_16.GetBitmap())           # index 4 - downgrade
            self.idx_sukisu = self.il.Add(images.sukisu_16.GetBitmap())                 # index 5 - sukisu
            self.idx_wild_ksu = self.il.Add(images.wild_ksu_16.GetBitmap())             # index 6 - wild_ksu
        self.list = wx.ListCtrl(parent=panel, id=-1, size=(-1, self.CharHeight * 6), style=wx.LC_REPORT | wx.BORDER_SUNKEN)
        self.list.SetImageList(self.il, wx.IMAGE_LIST_SMALL)
        self.list.InsertColumn(0, 'SHA1  ', wx.LIST_FORMAT_LEFT, width=-1)
        self.list.InsertColumn(1, _('Source SHA1  '), wx.LIST_FORMAT_LEFT, width=-1)
        self.list.InsertColumn(2, _('Package Fingerprint  '), wx.LIST_FORMAT_LEFT, width=-1)
        self.list.InsertColumn(3, _('Patched with version '), wx.LIST_FORMAT_LEFT, -1)
        self.list.InsertColumn(4, _('Patch Method  '), wx.LIST_FORMAT_LEFT, -1)
        self.list.InsertColumn(5, _('Patched on Device  '), wx.LIST_FORMAT_LEFT, -1)
        self.list.InsertColumn(6, _('Date  '), wx.LIST_FORMAT_LEFT, -1)
        self.list.InsertColumn(7, _('Package Path  '), wx.LIST_FORMAT_LEFT, -1)
        self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLUE'), wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10).Bold())))
        if sys.platform != "win32":
            self.list.SetFont(wx.Font(11, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
        self.list.SetColumnWidth(0, -2)
        grow_column(self.list, 0, 20)
        self.list.SetColumnWidth(1, -2)
        grow_column(self.list, 1, 20)
        self.list.SetColumnWidth(2, -2)
        grow_column(self.list, 2, 20)
        self.list.SetColumnWidth(3, -2)
        grow_column(self.list, 3, 20)
        self.list.SetColumnWidth(4, -2)
        grow_column(self.list, 4, 20)
        self.list.SetColumnWidth(5, -2)
        grow_column(self.list, 5, 20)
        self.list.SetColumnWidth(6, -2)
        grow_column(self.list, 6, 20)
        self.list.SetColumnWidth(7, -2)
        grow_column(self.list, 7, 20)
        # Initialize column width to header column size
        column_widths = []
        for i in range(self.list.GetColumnCount()):
            column_widths.append(self.list.GetColumnWidth(i))
        # Create a new list (will be by value and not by reference)
        self.boot_column_widths = list(column_widths)
        #
        self.folders_button = DropDownButton(parent=panel, id=wx.ID_ANY, bitmap=images.folder_24.GetBitmap(), label=_("Open Folder"), pos=wx.DefaultPosition, style=0)
        self.boot_folder_button = self.folders_button.AddFunction(_("Open boot files folder"), lambda: self._on_boot_folder(None), images.folder_24.GetBitmap())
        self.firmware_folder_button = self.folders_button.AddFunction(_("Open Working Directory"), lambda: self._on_firmware_folder(None), images.folder_24.GetBitmap())
        #
        self.patch_button = DropDownButton(parent=panel, id=wx.ID_ANY, bitmap=images.patch_24.GetBitmap(), label=_("Patch"), pos=wx.DefaultPosition, size=self.folders_button.BestSize, style=0)
        self.patch_button.SetToolTip(_("Patch the selected item"))
        self.patch_magisk_button = self.patch_button.AddFunction(_("Patch with Magisk"), lambda: self._on_magisk_patch_boot(None), images.magisk_24.GetBitmap())
        self.patch_kernelsu_button = self.patch_button.AddFunction(_("Patch with KernelSU"), lambda: self._on_kernelsu_patch_boot(None), images.kernelsu_24.GetBitmap())
        self.patch_kernelsu_lkm_button = self.patch_button.AddFunction(_("Patch with KernelSU LKM"), lambda: self._on_kernelsu_lkm_patch_boot(None), images.kernelsu_24.GetBitmap())
        self.patch_kernelsu_legacy_button = self.patch_button.AddFunction(_("Patch with KernelSU Legacy"), lambda: self._on_kernelsu_legacy_patch_boot(None), images.kernelsu_24.GetBitmap())
        self.patch_kernelsu_next_button = self.patch_button.AddFunction(_("Patch with KernelSU-Next"), lambda: self._on_kernelsu_next_patch_boot(None), images.kernelsu_next_24.GetBitmap())
        self.patch_kernelsu_next_lkm_button = self.patch_button.AddFunction(_("Patch with KernelSU-Next LKM"), lambda: self._on_kernelsu_next_lkm_patch_boot(None), images.kernelsu_next_24.GetBitmap())
        self.patch_sukisu_button = self.patch_button.AddFunction(_("Patch with SukiSU"), lambda: self._on_sukisu_patch_boot(None), images.sukisu_24.GetBitmap())
        self.patch_sukisu_lkm_button = self.patch_button.AddFunction(_("Patch with SukiSU LKM"), lambda: self._on_sukisu_lkm_patch_boot(None), images.sukisu_24.GetBitmap())
        self.patch_wild_ksu_button = self.patch_button.AddFunction(_("Patch with Wild_KSU"), lambda: self._on_wild_ksu_patch_boot(None), images.wild_ksu_24.GetBitmap())
        self.patch_wild_ksu_lkm_button = self.patch_button.AddFunction(_("Patch with Wild_KSU LKM"), lambda: self._on_wild_ksu_lkm_patch_boot(None), images.wild_ksu_24.GetBitmap())
        self.patch_apatch_button = self.patch_button.AddFunction(_("Patch with APatch"), lambda: self._on_apatch_patch_boot(None), images.apatch_24.GetBitmap(), False)
        self.patch_apatch_manual_button = self.patch_button.AddFunction(_("Patch with APatch Alternate"), lambda: self._on_apatch_manual_patch_boot(None), images.apatch_24.GetBitmap(), False)
        # self.patch_custom_boot_button = self.patch_button.AddFunction(_("Patch custom boot/init_boot with Magisk"), lambda: self._on_patch_custom_boot(None), images.custom_patch_24.GetBitmap())
        self.patch_downgrade_button = self.patch_button.AddFunction(_("Create Downgrade Patch"), lambda: self._on_prep_downgrade_patch(None), images.downgrade_24.GetBitmap(), False)
        #
        self.delete_boot_button = DropDownButton(parent=panel, id=wx.ID_ANY, bitmap=images.delete_24.GetBitmap(), label=_("Delete"), pos=wx.DefaultPosition, size=self.folders_button.BestSize, style=0)
        self.delete_boot_button.SetToolTip(_("Delete the selected item"))
        #
        self.add_boot_button = DropDownButton(parent=panel, id=wx.ID_ANY, bitmap=images.add_24.GetBitmap(), label="Add", pos=wx.DefaultPosition, size=self.folders_button.BestSize, style=0)
        self.add_boot_button.SetToolTip(_("Add a new boot item"))
        self.add_boot_button.Disable()
        self.add_boot_button.Hide()
        #
        self.get_boot_info_button = DropDownButton(parent=panel, id=wx.ID_ANY, bitmap=images.about_24.GetBitmap(), label=_("Info"), pos=wx.DefaultPosition, size=self.folders_button.BestSize, style=0)
        self.get_boot_info_button.SetToolTip(_("Get information about the selected item"))
        self.get_boot_info_button.Hide()
        #
        self.live_boot_button = DropDownButton(parent=panel, id=wx.ID_ANY, bitmap=images.boot_24.GetBitmap(), label=_("Live Boot"), pos=wx.DefaultPosition, size=self.folders_button.BestSize, style=0)
        self.live_boot_button.SetToolTip(_("Live boot to the selected item"))
        #
        self.flash_boot_button = DropDownButton(parent=panel, id=wx.ID_ANY, bitmap=images.flash_24.GetBitmap(), label=_("Flash Boot"), pos=wx.DefaultPosition, size=self.folders_button.BestSize, style=0)
        self.flash_boot_button.SetToolTip(_("Flash just the selected item"))
        #
        boot_label_v_sizer = wx.BoxSizer(wx.VERTICAL)
        boot_label_v_sizer.Add(window=self.select_boot_label, flag=wx.ALL, border=0)
        boot_label_v_sizer.AddSpacer(10)
        boot_label_v_sizer.Add(window=self.show_all_boot_checkBox, flag=wx.ALL, border=0)
        boot_label_v_sizer.AddSpacer(10)
        boot_label_v_sizer.Add(window=self.selected_partition_label, flag=wx.ALL, border=0)
        boot_label_v_sizer.AddStretchSpacer(1)
        slot_root_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        slot_root_sizer.Add(window=self.slot_image, proportion=0, flag=wx.ALL, border=0)
        slot_root_sizer.Add(window=self.rooted_image, proportion=0, flag=wx.ALL, border=0)
        slot_root_sizer.Add(window=self.rooted_with_image, proportion=0, flag=wx.ALL, border=0)
        boot_label_v_sizer.Add(slot_root_sizer, proportion=0, flag=wx.ALL, border=0)
        image_buttons_sizer = wx.BoxSizer(orient=wx.VERTICAL)
        image_buttons_sizer.Add(self.patch_button, proportion=1, flag=wx.LEFT, border=2)
        image_buttons_sizer.Add(self.delete_boot_button, proportion=1, flag=wx.LEFT, border=2)
        image_buttons_sizer.Add(self.add_boot_button, proportion=1, flag=wx.LEFT, border=2)
        image_buttons_sizer.Add(self.get_boot_info_button, proportion=1, flag=wx.LEFT, border=2)
        image_buttons_sizer.Add(self.folders_button, proportion=1, flag=wx.LEFT, border=2)
        image_buttons_sizer.Add(self.live_boot_button, proportion=1, flag=wx.LEFT, border=2)
        image_buttons_sizer.Add(self.flash_boot_button, proportion=1, flag=wx.LEFT, border=2)
        list_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        list_sizer.Add(self.list, proportion=1, flag=wx.ALL|wx.EXPAND)
        list_sizer.Add(image_buttons_sizer, proportion=0, flag=wx.ALL|wx.EXPAND)

        # 8th row widgets (Flash Mode)
        mode_label = wx.StaticText(panel, label=_("Flash Mode"))
        self.mode_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        # _add_mode_radio_button(sizer, index, flash_mode, label, tooltip)
        _add_mode_radio_button(sizer=self.mode_sizer, index=0, flash_mode='keepData', label=_("Keep Data"), tooltip=_("Data will be kept intact."))
        _add_mode_radio_button(sizer=self.mode_sizer, index=1, flash_mode='wipeData', label=_("WIPE all data"), tooltip=_("CAUTION: This will wipe your data"))
        _add_mode_radio_button(sizer=self.mode_sizer, index=2, flash_mode='dryRun', label=_("Dry Run"), tooltip=_("Dry Run, no flashing will be done.\nThe phone will reboot to fastboot and then\nback to normal.\nThis is for testing."))
        _add_mode_radio_button(sizer=self.mode_sizer, index=3, flash_mode='OTA', label=_("Full OTA"), tooltip=_("Flash full OTA, and have the choice of flashing patched image(s)."))
        _add_mode_radio_button(sizer=self.mode_sizer, index=4, flash_mode='customFlash', label=_("Custom Flash"), tooltip=_("Custom Flash, Advanced option to flash a single file.\nThis will not flash the factory image.\nIt will flash the single selected file."))


        # 9th row widgets (custom flash)
        self.live_boot_radio_button = wx.RadioButton(parent=panel, id=wx.ID_ANY, label="Live Boot", pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.RB_GROUP)
        self.live_boot_radio_button.Enable(False)
        self.live_boot_radio_button.SetToolTip(_("Live Boot to selected boot / init_boot"))
        self.flash_radio_button = wx.RadioButton(parent=panel, id=wx.ID_ANY, label=_("Flash"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.flash_radio_button.SetValue(True)
        self.flash_radio_button.Enable(False)
        self.flash_radio_button.SetToolTip(_("Flashes the selected boot / init_boot"))
        custom_advanced_options_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        custom_advanced_options_sizer.Add(window=self.live_boot_radio_button, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        custom_advanced_options_sizer.Add(window=self.flash_radio_button, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        # 2nd column
        # https://android.googlesource.com/platform/system/core/+/refs/heads/master/fastboot/fastboot.cpp#144
        image_choices = [ "boot", "init_boot", "bootloader", "cache", "dtbo", "dts", "odm", "odm_dlkm", "product", "pvmfw", "radio", "recovery", "super", "super_empty", "system", "system_dlkm", "system_ext", "system_other", "userdata", "vbmeta", "vbmeta_system", "vbmeta_vendor", "vendor", "vendor_boot", "vendor_dlkm", "vendor_kernel_boot", "vendor_other", "image", "SIDELOAD" ]
        self.image_choice = NoScrollChoice(parent=panel, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize, choices=image_choices, style=0)
        self.image_choice.SetSelection(-1)
        self.image_file_picker = ResizableButtonFilePickerCtrl(
            parent=panel,
            id=wx.ID_ANY,
            message=_("Select a file"),
            wildcard="Flashable files (*.img;*.zip)|*.img;*.zip",
            style=wx.FLP_USE_TEXTCTRL,
            button_label=_("Browse")
        )
        self.paste_selection = wx.BitmapButton(parent=panel, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.paste_selection.SetBitmap(images.paste_24.GetBitmap())
        self.paste_selection.SetToolTip(_("Depending on the flash selection, paste the appropriate path as custom image."))
        custom_flash_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        custom_flash_sizer.Add(window=self.image_choice, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        custom_flash_sizer.Add(window=self.paste_selection, flag=wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, border=2)
        custom_flash_sizer.Add(window=self.image_file_picker, proportion=1, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)


        # 10th row widgets, Flash options
        self.advanced_options_label = wx.StaticText(parent=panel, id=wx.ID_ANY, label=_("Flash Options"))
        self.flash_to_inactive_slot_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Flash to inactive slot"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.flash_to_inactive_slot_checkBox.SetToolTip(_("This option when checked will flash to the alternate slot (inactive).\nKeeping the current slot intact."))
        self.flash_both_slots_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Flash to both slots"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.flash_both_slots_checkBox.SetToolTip(_("This option when checked will flash to both slots."))
        self.disable_verity_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Disable Verity"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.disable_verity_checkBox.SetToolTip(_("Disables Verity"))
        self.disable_verification_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Disable Verification"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.disable_verification_checkBox.SetToolTip(_("Disables Verification"))
        self.fastboot_force_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Force"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.fastboot_force_checkBox.SetToolTip(_("Force a flash operation that may be unsafe (will wipe your data)"))
        self.fastboot_verbose_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Verbose"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.fastboot_verbose_checkBox.SetToolTip(_("Set fastboot option to verbose"))
        self.temporary_root_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Temporary Root"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.temporary_root_checkBox.SetToolTip(_("This option when enabled will not flash patched boot\nInstead it will flash unpatched boot.img, but boot to Live Patched boot\nHandy to test if Magisk will cause a bootloop.\n\nPlease be aware that this temporary root will not survive a subsequent reboot.\nIf you want to make this permanent, just Flash Boot the patched boot image."))
        self.no_reboot_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("No reboot"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.no_reboot_checkBox.SetToolTip(_("Do not reboot after flashing\nThis is useful if you want to perform other actions before reboot."))
        self.wipe_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Wipe"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.wipe_checkBox.SetToolTip(_("This will invoke data wipe operation at the end of custom flashing.\nOne use case would be when disabling verification for the first time."))
        self.no_wipe_downgrade_checkbox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("No Wipe Downgrade"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.no_wipe_downgrade_checkbox.SetToolTip(_("WARNING!!! This is a highly experimental feature.\nThis will attempt to downgrade the device without needing a data wipe.\n"))
        self.advanced_options_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        self.advanced_options_sizer.Add(window=self.flash_to_inactive_slot_checkBox, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        self.advanced_options_sizer.Add(window=self.flash_both_slots_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.disable_verity_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.disable_verification_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.fastboot_force_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.fastboot_verbose_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.temporary_root_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.no_reboot_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.wipe_checkBox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)
        self.advanced_options_sizer.Add(window=self.no_wipe_downgrade_checkbox, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=2)

        # 11th row widgets, Flash button
        self.flash_button = wx.Button(parent=panel, id=-1, label=_("Flash Device"), pos=wx.DefaultPosition, size=wx.Size(-1, 48))
        self.flash_button.SetFont(wx.Font(wx.NORMAL_FONT.GetPointSize(), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, wx.EmptyString))
        self.flash_button.SetToolTip(_("Flashes the selected device with chosen flash options."))
        self.flash_button.SetBitmap(images.flash_32.GetBitmap())

        # 12th row widgets, console
        console_label = wx.StaticText(parent=panel, id=wx.ID_ANY, label=_("Console"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.spinner = wx.ActivityIndicator(panel, -1, size=(80, 80), style=0)
        self.spinner_label = wx.StaticText(parent=panel, id=wx.ID_ANY, label=_("Please be patient ..."), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.spinner_label.SetForegroundColour((255,0,0))
        self.spinner_label.SetFont(wx.Font(wx.NORMAL_FONT.GetPointSize(), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, wx.EmptyString))
        self.support_button = wx.Button(parent=panel, id=wx.ID_ANY, label=_("Support"), size=wx.Size(-1, 32), style=0)
        self.support_button.SetBitmap(images.support_24.GetBitmap())
        self.support_button.SetBitmapMargins(wx.Size(10, -1))
        self.support_button.SetToolTip(_("Create encrypted and optionally sanitized support.zip file\nWhen sanitized all sensitive data is redacted.\n\nThis file is absolutely required when asking for help."))
        console_v_sizer = wx.BoxSizer(orient=wx.VERTICAL)
        console_v_sizer.Add(console_label, flag=wx.ALL, border=0)
        console_v_sizer.AddSpacer(10)
        console_v_sizer.Add(self.spinner, flag=wx.LEFT, border=10)
        console_v_sizer.AddSpacer(10)
        console_v_sizer.Add(self.spinner_label, flag=wx.ALL, border=0)
        console_v_sizer.Add((0, 0), proportion=1, flag=wx.EXPAND, border=0)
        console_v_sizer.Add(self.support_button, proportion=0, flag=wx.ALL|wx.EXPAND, border=0)
        self.console_ctrl = wx.TextCtrl(parent=panel, id=wx.ID_ANY, style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_RICH2, pos=wx.DefaultPosition, size=wx.DefaultSize)
        self.console_ctrl.SetMinSize((400, 200)) # set a minimum size of 400 x 200 pixels
        set_console_widget(self.console_ctrl)
        if not self.config.customize_font:
            self.spinner_label.SetFont(wx.Font(wx.NORMAL_FONT.GetPointSize(), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, wx.EmptyString))
            # self.console_ctrl.SetFont(wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
            font = wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, faceName="Courier New")
            self.console_ctrl.SetFont(font)
            if darkdetect.isLight():
                self.console_ctrl.SetBackgroundColour(wx.WHITE)
                self.console_ctrl.SetForegroundColour(wx.BLUE)
                self.console_ctrl.SetDefaultStyle(wx.TextAttr(wx.BLUE))

        # 13th row widgets, debug and clear button
        self.verbose_checkBox = wx.CheckBox(parent=panel, id=wx.ID_ANY, label=_("Debug"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.verbose_checkBox.SetToolTip(_("Enable Debug Messages in the console."))
        clear_button = wx.Button(parent=panel, id=-1, label=_("Clear Console"), pos=wx.DefaultPosition)

        # add the rows to flexgrid
        fgs1.AddMany([
                    (platform_tools_label_sizer, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0), (self.sdk_sizer, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL),
                    (adb_label_sizer, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0), (device_sizer, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL),
                    # removed
                    # (wx.StaticText(panel, label="")), (wx.StaticText(panel, label="")),
                    (firmware_label_sizer, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5), (self.firmware_sizer, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL),
                    (self.custom_rom_checkbox, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5), (custom_rom_sizer, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL),
                    (boot_label_v_sizer, 0, wx.EXPAND), (list_sizer, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL),
                    # (wx.StaticText(panel, label="")), (wx.StaticText(panel, label="")),
                    (mode_label, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5), (self.mode_sizer, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL),
                    (custom_advanced_options_sizer, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5), (custom_flash_sizer, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL),
                    (self.advanced_options_label, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5), self.advanced_options_sizer,
                    (wx.StaticText(panel, label="")), (self.flash_button, 1, wx.EXPAND),
                    # (wx.StaticText(panel, label="")), (wx.StaticText(panel, label="")),
                    (console_v_sizer, 0, wx.EXPAND), (self.console_ctrl, 1, wx.EXPAND),
                    (self.verbose_checkBox), (clear_button, 1, wx.EXPAND)
        ])

        # this makes the second column expandable (index starts at 0)
        fgs1.AddGrowableCol(1, 1)

        row_count = fgs1.EffectiveRowsCount
        # this makes the console row expandable (index starts at 0)
        fgs1.AddGrowableRow(row_count - 2, 1)

        # add flexgrid to vbox
        vbox.Add(fgs1, proportion=1, flag=wx.ALL | wx.EXPAND, border=10)

        # set the panel
        panel.SetSizer(vbox)

        # Connect Events
        self.device_choice.Bind(wx.EVT_COMBOBOX, self._on_select_device)
        self.scan_button.Bind(wx.EVT_BUTTON, self._on_scan)
        self.scan_all_button.Bind(wx.EVT_BUTTON, self._on_scan_all_devices)
        self.firmware_picker.Bind(wx.EVT_FILEPICKER_CHANGED, self._on_select_firmware)
        self.platform_tools_picker.Bind(wx.EVT_DIRPICKER_CHANGED, self._on_select_platform_tools)
        self.device_label.Bind(wx.EVT_LEFT_DCLICK, self._on_adb_kill_server)
        self.sdk_link.Bind(wx.EVT_BUTTON, self._open_sdk_link)
        self.wifi_adb.Bind(wx.EVT_BUTTON, self._on_wifi_manager)
        self.custom_rom_checkbox.Bind(wx.EVT_CHECKBOX, self._on_custom_rom)
        self.custom_rom.Bind(wx.EVT_FILEPICKER_CHANGED, self._on_select_custom_rom)
        self.disable_verification_checkBox.Bind(wx.EVT_CHECKBOX, self._on_disable_verification)
        self.flash_both_slots_checkBox.Bind(wx.EVT_CHECKBOX, self._on_flash_both_slots)
        self.flash_to_inactive_slot_checkBox.Bind(wx.EVT_CHECKBOX, self._on_flash_to_inactive_slot)
        self.no_reboot_checkBox.Bind(wx.EVT_CHECKBOX, self._on_no_reboot)
        self.wipe_checkBox.Bind(wx.EVT_CHECKBOX, self._on_wipe)
        self.no_wipe_downgrade_checkbox.Bind(wx.EVT_CHECKBOX, self._on_no_wipe_downgrade)
        self.disable_verity_checkBox.Bind(wx.EVT_CHECKBOX, self._on_disable_verity)
        self.fastboot_force_checkBox.Bind(wx.EVT_CHECKBOX, self._on_fastboot_force)
        self.fastboot_verbose_checkBox.Bind(wx.EVT_CHECKBOX, self._on_fastboot_verbose)
        self.temporary_root_checkBox.Bind(wx.EVT_CHECKBOX, self._on_temporary_root)
        self.flash_button.Bind(wx.EVT_BUTTON, self._on_flash)
        self.verbose_checkBox.Bind(wx.EVT_CHECKBOX, self._on_verbose)
        clear_button.Bind(wx.EVT_BUTTON, self._on_clear)
        self.image_file_picker.Bind(wx.EVT_FILEPICKER_CHANGED, self._on_image_select)
        self.image_choice.Bind(wx.EVT_CHOICE, self._on_image_choice)
        self.list.Bind(wx.EVT_LEFT_DOWN, self._on_boot_selected)
        self.delete_boot_button.Bind(wx.EVT_BUTTON, self._on_delete_boot)
        self.add_boot_button.Bind(wx.EVT_BUTTON, self._on_add_boot)
        self.get_boot_info_button.Bind(wx.EVT_BUTTON, self._on_get_boot_info)
        self.live_boot_button.Bind(wx.EVT_BUTTON, self._on_live_boot)
        self.flash_boot_button.Bind(wx.EVT_BUTTON, self._on_flash_boot)
        self.process_firmware.Bind(wx.EVT_BUTTON, self._on_process_firmware)
        self.process_rom.Bind(wx.EVT_BUTTON, self._on_process_rom)
        self.show_all_boot_checkBox.Bind(wx.EVT_CHECKBOX, self._on_show_all_boot)
        self.paste_selection.Bind(wx.EVT_BUTTON, self._on_paste_selection)
        self.support_button.Bind(wx.EVT_BUTTON, self._on_support_zip)
        self.list.Bind(wx.EVT_LIST_COL_CLICK, self.OnColClick)
        self.Bind(wx.EVT_CLOSE, self._on_close)
        self.Bind(wx.EVT_SIZE, self._on_resize)
        self.Bind(wx.EVT_MOVE_END, self._on_move_end)
        self.Bind(wx.EVT_BUTTON, self._on_show_device_download, self.firmware_button)

        # Get the widths of all buttons and figure out the max width
        all_controls = [
            {'control': self.platform_tools_picker, 'type': 'picker'},
            {'control': self.scan_button, 'type': 'button'},
            {'control': self.scan_all_button, 'type': 'button'},
            {'control': self.firmware_picker, 'type': 'filepickercombo'},
            {'control': self.process_firmware, 'type': 'button'},
            {'control': self.custom_rom, 'type': 'filepickercombo'},
            {'control': self.process_rom, 'type': 'button'},
            {'control': self.patch_button, 'type': 'button'},
            {'control': self.delete_boot_button, 'type': 'button'},
            {'control': self.folders_button, 'type': 'button'},
            {'control': self.live_boot_button, 'type': 'button'},
            {'control': self.flash_boot_button, 'type': 'button'},
            {'control': self.image_file_picker, 'type': 'picker'}
        ]
        button_widths = []
        # Calculate widths
        for item in all_controls:
            if item['type'] == 'button':
                button_widths.append(item['control'].GetBestSize().width)
            elif item['type'] == 'picker' and item['control'].GetPickerCtrl():
                button_widths.append(item['control'].GetPickerCtrl().GetBestSize().width)
        max_width = max(button_widths) if button_widths else 100
        # Apply the max width to all buttons
        for item in all_controls:
            if item['type'] == 'button':
                item['control'].SetMinSize(wx.Size(max_width, -1))
            elif item['type'] == 'picker':
                item['control'].SetButtonWidth(max_width)
            elif item['type'] == 'filepickercombo':
                item['control'].SetButtonWidth(max_width)

        # Update UI
        self.Layout()


    # -----------------------------------------------
    #                  update_google_images_menu
    # -----------------------------------------------
    def update_google_images_menu(self, update_icons_only=False):
        try:
            if update_icons_only:
                device = get_phone()
                device_icon = images.star_green_24.GetBitmap()
                empty_bitmap =wx.NullBitmap

                if device:
                    current_device = device.hardware
                else:
                    current_device = "UNKNOWN_DEVICE"

                for menu in [self.google_images_menu.phones_menu, self.google_images_menu.watches_menu]:
                    for item in menu.GetMenuItems():
                        # Clear the icon
                        item.SetBitmap(empty_bitmap)

                        # If the item's label matches the current device, set the icon
                        if current_device in item.GetItemLabelText():
                            item.SetBitmap(device_icon)
            else:
                self.google_images_menu.reset_menu_id()
                menu_index = self.menuBar.FindMenu(_("&Google Images"))
                if menu_index is not None and menu_index != -1:
                    self.menuBar.Remove(menu_index)
                    self.google_images_menu = GoogleImagesMenu(self)
                    self.menuBar.Insert(menu_index, self.google_images_menu, _("&Google Images"))
                else:
                    print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Couldn't find Google Images Menu")
            self.Refresh()
            self.Update()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while updating Google Images Menu")
            traceback.print_exc()


# ============================================================================
#                               Class MySplashScreen
# ============================================================================
class MySplashScreen(wx.adv.SplashScreen):
    def __init__(self):
        wx.adv.SplashScreen.__init__(self, images.Splash_dark.GetBitmap(), wx.adv.SPLASH_CENTRE_ON_SCREEN | wx.adv.SPLASH_TIMEOUT, 20000, None, -1, wx.DefaultPosition, wx.DefaultSize, wx.NO_BORDER)
        self.Bind(wx.EVT_CLOSE, self._on_close)
        self.__fc = wx.CallLater(1000, self._show_main)

    def _on_close(self, evt):
        # Make sure the default handler runs too so this window gets
        # destroyed
        evt.Skip()
        self.Hide()

        # if the timer is still running then go ahead and show the
        # main frame now
        if self.__fc.IsRunning():
            self.__fc.Stop()
            self._show_main()

    def _show_main(self):
        frame = PixelFlasher(None, "PixelFlasher")
        frame.Show()
        with contextlib.suppress(Exception):
            self.Hide()
        if self.__fc.IsRunning():
            self.Raise()


# ============================================================================
#                               Class App
# ============================================================================
class App(wx.App, wx.lib.mixins.inspection.InspectionMixin):
    def __init__(self, global_args, *args, **kwargs):
        self.global_args = global_args
        super(App, self).__init__(*args, **kwargs)

    def OnInit(self):
        # see https://discuss.wxpython.org/t/wxpython4-1-1-python3-8-locale-wxassertionerror/35168
        self.ResetLocale()
        wx.SystemOptions.SetOption("mac.window-plain-transition", 1)
        self.SetAppName("PixelFlasher")
        print(f"global_args.config: {self.global_args.config}")

        if self.global_args.config:
            init_config_path(self.global_args.config)
        else:
            init_config_path()

        t = f"{datetime.now():%Y-%m-%d_%Hh%Mm%Ss}"
        pumlfile = os.path.join(get_config_path(), 'puml', f"PixelFlasher_{t}.puml")
        set_pumlfile(pumlfile)
        puml(f"@startuml {t}\nscale 2\nstart\n", False, "w")
        puml("<style>\n  note {\n    FontName Courier\n    FontSize 10\n  }\n</style>\n")

        if inspector:
            frame = PixelFlasher(None, "PixelFlasher")
            # frame.SetClientSize(frame.FromDIP(wx.Size(MAIN_WIDTH, MAIN_HEIGHT)))
            # frame.SetClientSize(wx.Size(MAIN_WIDTH, MAIN_HEIGHT))
            frame.Show()
        else:
            # Create and show the splash screen.  It will then create and
            # show the main frame when it is time to do so.  Normally when
            # using a SplashScreen you would create it, show it and then
            # continue on with the application's initialization, finally
            # creating and showing the main application window(s).  In
            # this case we have nothing else to do so we'll delay showing
            # the main frame until later (see ShowMain above) so the users
            # can see the SplashScreen effect.
            #
            splash = MySplashScreen()
            splash.Show()
        return True


# ============================================================================
#                               Class GlobalArgs
# ============================================================================
class GlobalArgs():
    pass


# ============================================================================
#                               Function parse_arguments
# ============================================================================
def parse_arguments():
    # sourcery skip: inline-immediately-returned-variable
    parser = argparse.ArgumentParser(description="Process command-line arguments")
    parser.add_argument("-c", "--config", help="Path to the configuration file")
    parser.add_argument("-l", "--console", action="store_true", help="Log to console as well")
    parser.add_argument("-lc", "--console-only", action="store_true", help="Log to console only")
    args  = parser.parse_args()
    return args


# ============================================================================
#                               Function ask
# ============================================================================
def ask(parent=None, message='', default_value=''):
    dlg = wx.TextEntryDialog(parent, message, value=default_value)
    dlg.ShowModal()
    result = dlg.GetValue()
    dlg.Destroy()
    return result


# ============================================================================
#                               Function Main
# ============================================================================
def main():
    # Parse the command-line arguments and store them in the global object
    global global_args
    try:
        global_args = parse_arguments()
    except SystemExit:
        # Handle the case where parsing arguments fails
        print("Failed to parse command-line arguments.")
        return

    app = App(global_args, False)
    if inspector:
        wx.lib.inspection.InspectionTool().Show()

    app.MainLoop()


# ---------------------------------------------------------------------------
if __name__ == '__main__':
    __name__ = 'Main'
    main()

```

`PixelFlasher.crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIDKzCCAhOgAwIBAgIUYIRGzv8e03vx107/JWQp/MI+GwAwDQYJKoZIhvcNAQEL
BQAwFzEVMBMGA1UEAwwMQmFkYWJpbmcyMDA1MB4XDTI0MDcxNDEzMjMwMVoXDTI1
MTEyNjEzMjMwMVowFzEVMBMGA1UEAwwMUGl4ZWxGbGFzaGVyMIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmxbQHvRwgER0TJDEtPurapZS5/r7pCudJNqr
kv54C+FaVK0TVnLefjfwxeR1ILu6kjis8/OMWAE5lvoLlXrnXrC3buipiESwZE4q
DtA8aUS0kKn6DbJaYcNrsYSglq3xNJ1SskX6uH5R3WHeJ0PJJcXystnE1e+GOsBh
qbJOoJy1VpacHnVXg1tMM8Un92X1aYDMj6HOBNhRQicHkhWHx+7WvOHqDM9j6wpR
39dyov3Hd+R0cs+zAaXKdBLCBqD3N9/UAKd+S/b+BA08tsdmq+ud1EG3oZYLa7Ze
f9MhwlW/ba3MRHBnqylV1dmtYFFzsCjOCNIQeHFic7sjNn9NawIDAQABo28wbTAf
BgNVHSMEGDAWgBTOCWAMovsa2+SS21Sog9rk7liIWzAJBgNVHRMEAjAAMAsGA1Ud
DwQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQUzDaSWtxu3qIh
DRSnUMONx2aX2XUwDQYJKoZIhvcNAQELBQADggEBAClrh6pMNSmcGERatopjH6sQ
32E6nEZuQkCX+x48JoaDUWSHVfCteCy4KraJ/ina3UyLWXNW6qvuYUraY98KI+eY
DzNzRETY3g/cRMxvswbm81ZPki282J9LxlunFaOvwQnbtLJsIg+8Tj/aD/YBvs2h
E06+/VzoDZ8aQaIth8TPZ1e3HrzDn4oNsG0CnfnZ3QtdcpSKgi/sFdMui8NAmIjd
zsCoRfYw5hPeZem11KJ2+dv3bDIC0AKy6Opd0YE164lHUGL46Y15uzm536rHjiZA
sQArmuwWNAKs0gvYYGEBoYCgkPOmh8LUtCrNCKC3dAN7neUmlwjpsVic1K8RbFE=
-----END CERTIFICATE-----

```

`PixelFlasher.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import os
os.environ["PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION"] = "python"

import Main
Main.main()

```

`README.md`:

```md
<div id="toc">
  <img src="/images/icon-dark-128.png" alt="PixelFlasher Icon" align="left" />
  <ul style="list-style: none;">
    <summary>
      <h1>PixelFlasher</h1>
    </summary>
  </ul>
</div>

[![License](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) [![Github Releases](https://img.shields.io/github/downloads/badabing2005/PixelFlasher/total.svg?style=flat)](https://github.com/badabing2005/PixelFlasher/releases)

<BR>

## Table of contents

- [Table of contents](#table-of-contents)
- [Description / Features](#description--features)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
  - [Release Files](#release-files)
  - [Supported platforms](#supported-platforms)
- [Status](#status)
- [Build it yourself](#build-it-yourself)
- [Usage](#usage)
  - [Basic Mode](#basic-mode)
  - [Expert Mode](#expert-mode)
- [Translations](#translations)
  - [Contributing Translations](#contributing-translations)
  - [Translation Limitations](#translation-limitations)
  - [Available languages](#available-languages)
- [Credits](#credits)
- [Troubleshooting](#troubleshooting)
- [Disclaimer](#disclaimer)

## Description / Features

As the name suggests this is an application to flash (update) Pixel™ phones (possibly all Google™ made phones/tablets, YMMV.)  
PixelFlasher at its core is a UI layer (with bells and whistles) on top of adb / fastboot commands, hence **many of its features can be used on non Pixel devices as well.** (YMMV).  
The executable which can be found in [releases section](https://github.com/badabing2005/PixelFlasher/releases) is self contained single file and does not require Python™ to be installed on the system.

The application has two modes, normal mode (basic) and advanced mode (expert).

**Basic mode:** Should suit most users. Some of the features in basic mode are:

- Simple UI interface, click and go. No more command line, no more placing all files in one directory.
- `boot.img` / `init_boot.img` management UI, select the boot / init_boot file to patch and click the patch button.
Fully Automated patching with Magisk (without manual steps) and perform upgrades without losing root.  
No more manually extracting files transferring to the phone, patching / re-flashing and doing multiple reboots.  
No more setting airplane mode and clearing storage to retain Safetynet / Play Integrity passing.
- Display details of `boot.img` (or `init_boot.img` for Pixel 7 or newer devices).
  - SHA1 checksum.
  - Origin (file it was extracted from).
  - Whether it is patched or not, and if it is patched.
    - What version of Magisk was used to patch it.
    - On what device it was patched.
    - Date of patching.
    - The SHA1 of the source boot.img file.
  - Option to Live boot from a choice of boot.img or patched image.
  - Flash just the boot / init_boot image.
- Choose to keep data or wipe data while flashing (Full OTA flashing always keeps data).
- Ability to flash even if multiple devices are connected to the computer.
- Option to flash to inactive slot (Full OTA always flashes to inactive slot).
- Display information about the phone.
  - ID
  - Hardware model.
  - Device architecture.
  - Current installed firmware (build).
  - If it is rooted and with which tool and version.
  - Which of the supported rooting applications are installed and their respective versions.
  - List installed Magisk modules.
  - Connection mode (Adb | Fastboot | Sideload | Recovery).
  - Bootloader version.
  - Active slot.
  - Android OS API version.
  - Convenient quick links to download Android platform tools or device firmware.
  - And a lot more...
- In app download of all Pixel phone / watch firmware images and full OTA images (past an present).
- Rooting Application installation UI, [screenshot](images/Magisk-Installer.png). Supported versions:
  - Magisk stable (official)
  - Magisk beta (official)
  - Magisk debug (official)
  - Magisk Release (official)
  - Magisk Pre-Release (official)
  - KitsuneMagisk Fork
  - KernelSU
  - KernelSU-Next
  - Apatch
  - SukiSU
  - Wild_KSU
  - Magisk zygote64_32 canary
  - Special builds that disable modules (used to recover from bootloops due to bad modules).
    - Magisk special v27001
    - Magisk special v26401
    - Magisk special v25203
- Magisk Backup Manager, [screenshot](images/Magisk-Backup-Manager.png).
  - List all Magisk backups currently on the device.
  - Highlight the one that is backup of the current installed version.
  - Delete backups.
  - Manually add backup from PC.
  - Auto Backup: PixelFlasher figures out what needs to be backed up, and if it finds it on the PC, it creates the backup.
- Magisk settings management, [screenshot](images/magisk-settings.png):
  - Enable / disable Magisk modules, this comes in handy to disable suspect modules before an upgrade.
  - Install Magisk module (zip selection).
  - Direct install common Magisk modules:
    - osm0sis [PlayintegrityFork](https://github.com/osm0sis/PlayIntegrityFork)
    - [TrickyStore](https://github.com/5ec1cff/TrickyStore)
    - [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext)
  - Enable / disable Zygisk.
  - Enable / disable Magisk denylist.
  - Add / remove application to Magisk denylist (through PixelFlasher's App Manger).
  - Grant / deny / SU permissions to an app, with control of (through PixelFlasher's App Manger):
    - Enable / disable notifications
    - Enable / disable logging
    - Grant until (Forever, 10 min, 20 min, 30 min, 60 min)
  - Revoke SU permissions
- Display Android Platform Tools (SDK) version and warn / block if the version is old.
- Install APK (an app) file from the computer onto the device.
- Wireless Manager, to wirelessly connect to adb debug or adb wireless with pairing support.
- Advanced features are hidden to keep the interface simple and easy to follow.
- Easily open ADB shell to the device.
- Support for Genymotion Scrcpy to mirror Android devices (video and audio) via USB or over TCP/IP, and allows to control the device with the keyboard and the mouse of the computer.
- A lot of checks and validations for smooth operation with quite verbose console output to inform about every step of the operation.
- Automatic check for program and Magisk module updates.
- App Manager, [screenshot](images/Package-Manager.png):
  - Disable (Freeze)
  - Enable
  - Uninstall
  - Add to Magisk Denylist
  - Remove from Magisk Denylist
  - SU Permissions
  - Install APK
  - Download APK
  - Launch
  - View Application Permissions
  - Kill
  - Clear Application Data
  - Multi-Select
  - Show Package Details.
  - Add / remove app to Magisk denylist.
  - Control app's superuser permissions, [screenshot](images/su-permissions.png).
  - Export Application list
  - Filtering
- Configurable Toolbar
- Pif Manager (see a bit outdated but still valid [UI Workflow](https://xdaforums.com/t/pixelflasher-a-gui-tool-for-flashing-updating-rooting-managing-pixel-phones.4415453/post-87412305))
  - Automatically detect Pif related installed modules and manage.
    - Pull / Modify / Push Pif prints to device
    - Cleanup DroidGuard
    - Push keybox.xml
    - Edit TrickyStore Target
    - Process an image file to extract Pif print
    - Process build prop(s) to extract Pif Print
    - Check / Auto-check Play Integrity.
      - Play Integrity API Checker
      - Simple Play Integrity Checker
      - Android Integrity Checker
      - TB Checker
      - Play Store
      - YASNAC
    - Automatically get Pixel Beta Pif ()
    - Get Xiaomi Pif
    - Get TheFreeman193 random Pif
    - Conversion tools
    - Built in json validation
- PI (Play Integrity) Analysis Report to troubleshoot PI related issues.
  - Magisk (if available):
    - modules list.
    - denylist.
  - TrickyStore (if available):
    - `/data/adb/tricky_store/spoof_build_vars`
    - `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)
    - `/data/adb/tricky_store/target.txt`
  - PlayIntegrity Fork (if available):
    - `/data/adb/modules/playintegrityfix/custom.pif.json`
    - `/data/adb/modules/playintegrityfix/custom.app_replace.list`
    - `/data/adb/modules/playintegrityfix/scripts-only-mode`
  - PlayIntegrityFix (if available):
    - `/data/adb/modules/playintegrityfix/pif.json`
    - `/data/adb/pif.json`
  - Whether a testkey ROM is used or not.
  - logcat for PlayIntegrity and TrickyStore related logs.
  - Droidguard VM list.
  - If any custom ROM injection apps are installed from:
    - Xiaomi.eu
    - EliteRoms
    - helluvaOS
    - hentaiOS
    - Evolution X
    - PixelOS
  - Check overlays (if contents of /debug_ramdisk is visible without root)
- My Tools, add / remove and manage personal tools to be launched from within the app.
- Dev Tools
  - Check keybox validity (one or many)
    - If the certificates in the keybox are on revocation list.
    - If they are AOSP certificates
    - If they are expired or expiring soon.
    - If they are long chained.
    - If any of the certificate issuers are on shadow banned list.
  - AVB Image info tool
  - AVB downgrade preparation tool.

**Expert mode:** (should only be turned on by experienced users). In addition to the basic features, you get:

- The ability to flash custom ROM (with or without patching `boot` / `init_boot`)
- Option to flash to both slots.
- Option to flash to inactive slot.
- Options to disable verity and or verification.
- Ability to change the active slot.
- Ability to live boot to custom `boot` / `init_boot` (temporary root).
- Ability to boot to recovery, fastbootd, safe mode, download mode and sideload.
- Ability to flash custom image: boot, recovery, radio, kernel, ...
- Ability to sideload an image.
- Lock / Unlock bootloader.
- Option to gain temporary root (good for testing or checking things out).
- SOS Disable Magisk modules to get out of bootloop.
- Force option when flashing.
- Option to skip rebooting.
- Option to wipe.
- Partition Manager:
  - Erase single or multi partitions.
  - Dump / create backup of single or multi partitions and save to PC.

## Prerequisites

- [Android SDK Platform-Tools](https://developer.android.com/studio/releases/platform-tools.html).
- USB Debug turned on in Developer Options and authorized for your computer. (see excellent guide links in credits section below).
- Android Pixel phone [factory image](https://developers.google.com/android/images) or Android Pixel phone [full OTA image](https://developers.google.com/android/ota).
- Bootloader unlocked phone if you want to root or flash Factory image (see excellent guide links in credits section below).
  **Note:** Stock OTA sideloading does not require an unlocked bootloader.
- On Windows: The latest [Google USB drivers](https://developer.android.com/studio/run/win-usb?authuser=1%2F) installed in adb and fastboot modes.
- On MacOS: [Allow USB Accessory to connect](https://support.apple.com/en-us/102282) (very important!).
- On Linux: [User needs to be added](https://developer.android.com/studio/run/device#setting-up) to `plugdev` group.
  Arch distro users, you might want to check [this](https://github.com/badabing2005/PixelFlasher/issues/283).

## Installation

PixelFlasher doesn't have to be installed, just double-click it and it'll start.  
Check the [releases section](https://github.com/badabing2005/PixelFlasher/releases) for downloads.  

### Release Files

[![Windows](https://img.shields.io/badge/-Windows_x64-blue.svg?style=for-the-badge&logo=windows)](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher.exe)[![Linux](https://img.shields.io/badge/-Linux-red.svg?style=for-the-badge&logo=linux)](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher_Ubuntu_24_04)[![MacOS](https://img.shields.io/badge/-MacOS-black.svg?style=for-the-badge&logo=apple)](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher_macos.dmg)[![Other variants](https://img.shields.io/badge/-Other-grey.svg?style=for-the-badge)](#release-files)[![All versions](https://img.shields.io/badge/-All_Versions-lightgrey.svg?style=for-the-badge)](https://github.com/badabing2005/PixelFlasher/releases)

File|Description
:---|:---
[PixelFlasher.exe](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher.exe)|Windows standalone x64 binary (recommended for **Windows**)
[PixelFlasher-arm64.exe](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher-arm64.exe)|Windows standalone arm64 binary (recommended for **Windows arm64**)
[PixelFlasher_win_2019.exe](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher_win_2019.exe)| Built with Windows 2019, to be used on older Windows)
[PixelFlasher_MacOS.dmg](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher_MacOS.dmg)|Universal MacOS (11+) standalone executable (recommended for **MacOS**)
[PixelFlasher_MacOS_legacy.dmg](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher_MacOS_legacy.dmg)|x86_64 MacOS standalone executable (to be used on older MacOS devices)
[PixelFlasher_Ubuntu_24_04](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher_Ubuntu_24_04)| Built on Ubuntu 24.04 Linux standalone x64 binary (recommended for **Linux**)
[PixelFlasher_Ubuntu_22_04](https://github.com/badabing2005/PixelFlasher/releases/latest/download/PixelFlasher_Ubuntu_22_04)| Built on Ubuntu 22.04 Linux standalone x64 binary

### Supported platforms  

- Windows
- macOS. Download the DMG or Install via [Homebrew](https://brew.sh) by a single command:

  ```bash
  brew install badabing2005/pixelflasher/pixelflasher
  ```

- Linux (See [this](https://github.com/badabing2005/PixelFlasher/issues/23) if you're having issues with a Linux build.)

## Status

Scan the [list of open issues](https://github.com/badabing2005/PixelFlasher/issues) for bugs and pending features.

**Note**
This is my first wxPython based project. I got ideas and inspiration from [nodemcu-pyflasher](https://github.com/marcelstoer/nodemcu-pyflasher).  
If you have constructive feedback as for how to improve the code please do reach out to me.

## Build it yourself

If you want to build this application yourself you need to:
**Setup**

- Download or clone the repository.
- Install [Python 3.x](https://www.python.org/downloads/) and [Pip](https://pip.pypa.io/en/stable/installing/) (it comes with Python™ if installed from `python.org`)  
_See note below if building on MacOS._
- Install virtualenv `pip3 install virtualenv`
- Create a virtual environment with:
  - On Windows: `virtualenv --python <PATH_TO_PYTHON_EXE> venv`
  - On Linux / MacOS: `python3 -m venv venv`
- Activate the virtual environment with:
  - On Windows: `.\venv\Scripts\activate`
  - On Linux / MacOS: `. venv/bin/activate`
- Run `pip3 install -r requirements.txt`

**A note on Linux:** As described on the [downloads section of `wxPython`](https://www.wxpython.org/pages/downloads/), wheels for Linux are complicated and may require you to run something like this to install `wxPython` correctly:

```bash
# Assuming you are running it on Ubuntu 20.04 LTS with GTK3
pip install -U \
    -f https://extras.wxpython.org/wxPython4/extras/linux/gtk3/ubuntu-20.04 \
    wxPython
```

If you're building on Fedora, take a look at [this](https://github.com/badabing2005/PixelFlasher/issues/262) (Credit to @xChAmeLIoNz).

**A note on Windows**
If you run into troubles installing wxPython on Windows, you can download wxPython wheel file matching your version of Python™ from [here](https://wxpython.org/Phoenix/snapshot-builds/?C=M;O=D)
Look for `cp310` if your python™ version is 3.10
You install it with `pip`, for example this would be the command to install 3.10 version.

```bash
pip install wxPython-4.1.2a1.dev5308+2258f215-cp310-cp310-win_amd64.whl
```

**A Note on MacOS**
Don't install Python™ on MacOS, instead
`brew install wxpython`, this will install Python™ 3.9.12, the installed wxPython will only work with this version of Python.
If python 3.9.12 is not in the system path, you can find it here:  
`/usr/local/Cellar/python@3.9/3.9.12/Frameworks/Python.framework/Versions/3.9/bin`  
It is advised that you add this to your system `PATH`
On MacOS, you should also install `create-dmg`

```bash
brew install node graphicsmagick imagemagick 
npm install --global create-dmg
```

**Build**
Run `build.bat` on Windows or `build.sh` on Linux / MacOS.

## Usage

### Basic Mode

![Image of PixelFlasher GUI](/images/basic-gui.png)

1. First thing to do is select Android™ Platform Tools, you'd have to select where it is installed (unpacked).
You can download the latest Android™ Platform Tools by clicking the ![Image of link](/images/open-link-16.png) next to it.  
If you have multiple versions, you can select another version, although it is best to always use the most recent version (The selected version will be identified and displayed.)  
2. Hit the `Scan` button to detect connected devices, the application will detect all connected devices  
(in adb, fastboot, sideload, recovery modes) and populate the combo box (2).
3. Select your device from the list in the combo box.
The following information about the connected device is displayed.  
    - (1st field) Rooted devices will be identified with a checkmark ✓.
    **Note:** If you want PixelFlasher to detect root, or automatically use Magisk to patch boot.img, you need to grant root permissions to `shell` in Magisk.  
    ![Image of shell root access](/images/shell-root.png)
    - (1st field) Non-Rooted devices will be identified with a ✗.
    - (1st field) Devices in fastboot mode will be identified with a ? (in fastboot mode, root status cannot be determined).
    - (2nd field) (adb), (f.b), (sid) or (rec) to indicate connection mode adb / fastboot / sideload / recovery.
    - (3rd field) Device ID.
    - (4th field) Device hardware.
    - (5th field) Current running firmware (in fastboot mode current firmware cannot be determined).
4. Next select the full OTA (recommended) or factory zip file (don't unzip), the application will recognize the phone model from the image name and validate the SHA-256 checksum.  
You can download both OTA and factory images by clicking the ![Image of link](/images/open-link-16.png) next to it.
**Note:** Because both firmware package and full OTA are complete images, you can upgrade to any newer version without worrying about jumping versions (downgrades with factory image are possible only with wipe data).
⚠️ Do not rename the downloaded file or extract parts of it, just point to the downloaded zip. PixelFlasher does validations to ensure you don't accidentally flash the wrong image to your device.
5. Process the full OTA or factory image.
PixelFlasher will extract `boot.img` (or `init_boot.img` for Pixel 7 or newer devices) file from the image and populate it in the list below (5).  
6. Select `boot.img` (or `init_boot.img` for Pixel 7 or newer devices) from the list, the selected file can be patched (6), or flashed (10).
7. Optional: Select this option if you want to patch the `boot.img` (or `init_boot.img` for Pixel 7 or newer devices) with Magisk, Apatch, KernelSU or KernelSU-Next. If rooting application is not already installed on your phone, PixelFlasher will install it for you.
Your phone does not need to be rooted to create a patched file.
This would be the typical choice for monthly updates.  
This option will allow updating the phone without losing root (not even temporarily).  
**Note:** See note above for granting root permissions to `shell`.  
Whether the phone is rooted or not, the whole process is without any manual step.  
8. If you want to flash (10) a patched `boot.img` (or `init_boot.img` for Pixel 7 or newer devices) select the newly added entry.  
The following details are listed.  
    - ![Image of patched-boot](/images/patched-16.png) Indicates that the selection is patched.
    - **SHA1** is (shortened for display only) sha1 of `boot.img` (or `init_boot.img` for Pixel 7 or newer devices)
    - **Source SHA1** (shortened for display only) SHA1 of source `boot.img` extracted from the image (This should be the same as SHA1 of an unpatched `boot.img`)
    - **Package Fingerprint** is just the filename portion of the image (without the extension).
    - **Patched with Version** indicates the version of Magisk / KernelSU / Apatch used to patch the image (if applicable).
    - **Patched Method** indicates what method PixelFlasher used to create a patch (possible options: `root`, `app`, `uiautomator`, `manual`)
    - **Patched on Device** indicates the device model that performed the patching. You should always use patched images that match the model of the device that it will be flashed on.
    - **Date** is the either the date the `boot.img` was extracted, or the date it was patched.
    - **Package Path** indicates the file from which `boot.img` (or `init_boot.img` for Pixel 7 or newer devices) was extracted.
9. Select the Flash Mode, PixelFlasher will automatically select applicable flash mode based on the selected image type.
    - If full OTA image is selected in step 4:
      - **Full OTA**: Will flash full OTA image in sideload mode.
      Features of this mode:
        - This will always flash to **inactive slot only**, (hence why the option to flash to both slots is disabled) similar to how OTA updates happen on the phone.
        - It will always be **Keep Data**, there is no option for **Wipe**, hence why the option is disabled.
        - If something goes wrong during flashing, the active slot is unaffected and the phone boots back to active functional slot.
        - If you flash to both slots (ie flash twice in a row) then both slots would be bootable.
        - Your phone's bootloader does not have to be unlocked to be able to flash full OTA image (stock boot only).
        - You cannot downgrade with OTA, the version being installed has to be equal or higher.
    - If factory firmware is selected in step 4:
      - **Keep Data**: In this mode `-w` flag is removed from the flash scripts so that data is not wiped. This is commonly known as `dirty flashing`.
      - **WIPE all data**: As the text suggests, this will wipe your data, use it with caution!  
      If this mode is selected PixelFlasher will ask for confirmation during the flashing phase.
      - **Dry Run**: In this mode, the phone will reboot to bootloader, and then mimic the flash actions (i.e. reboot into bootloader) without actually flashing anything (it prints to the console the steps it would have performed if dry run was not chosen).
      This is handy for testing to check if the PixelFlasher properly is able to control fastboot commands.
10. Optional: Open Magisk Modules Manager and disable (uncheck) modules known to cause issues during upgrades (highly recommended). (The list below has never caused issues for me, so I keep them enabled YMMV).  
![Image of PixelFlasher GUI](/images/magisk-modules-manager.png)
11. **Flash Pixel Phone** This is the final step, to actually flash the phone in the selected `Flash Mode`.  
**Note**: Unlike the previous versions of the PixelFlasher, all the options are dynamic, i.e. depending on what you select before clicking the Flash button, there is no more concept of prepared package.
PixelFlasher will first present you the selected options and ask for your confirmation if you want to proceed with flashing.
12. Monitor the **console** output and observe the performed actions and their outcomes.
13. In case of trouble, click on **Support** button to generate encrypted and optionally sanitized (redacted) support logs archive.

### Expert Mode

To enable the export mode use the **File Menu | Advanced Configuration** and select `Enable Advanced Options`
![Image of PixelFlasher GUI](/images/advanced-options.png)
![Image of PixelFlasher GUI](/images/advanced-gui.png)

In this mode the following additional options are exposed (green bounding boxes), below notes are more for enumeration than a guide, as they should be trivial and obvious to an expert.

1. Option to Change the Active Slot (the inactive slot is automatically selected).  
Options to reboot to Recovery, Download, Safe Mode.
2. Options to Lock / Unlock bootloader, Option to disable Magisk modules when bootlooping, partitions manager.
3. Apply Custom ROM. This replaces the factory ROM image with the selected file.  
PixelFlasher extracts `boot.img` (or `init_boot.img` for Pixel 7 or newer devices) from the ROM image and displays below for selection or patching.
Please make sure to read the documentation of the chosen ROM, as each custom ROM instructions could be different.  
To be clear, this is what PixelFlasher does internally when this mode is selected, please understand it, and don't use it if the selected ROM guide does not fit the bill.
You've been warned!
    - Keeps stock bootloader and radio images.
    - Replaces the stock ROM image with the selected custom ROM image.
    - Flashes in the chosen `Flash Mode` just like a stock image, i.e. bootloader, custom ROM and radio images in the original order that they were in the stock firmware.
    - Patching `boot.img` (or `init_boot.img` for Pixel 7 or newer devices) can be performed if the option is selected. You can select any of the listed files.
    - Flash Mode is similar to basic flash mode described above in step 7.  
4. Custom Flash. select this to switch from flashing a Factory Image to flashing a single file.
5. Browse to select a a valid image file (.img or .zip).
Or select a boot.img from the list above and click on the paste button to paste the selected boot.img into the file selection.
Choose the dropdown to select image type.  
    - boot (can be flashed to Live or boot) - Expected file type .img
    - bootloader - Expected file type .img
    - init_boot - Expected file type .img
    - dtbo - Expected file type .img
    - product - Expected file type .img
    - radio - Expected file type .img
    - recovery - Expected file type .img
    - super_empty - Expected file type .img
    - system - Expected file type .img
    - system_ext - Expected file type .img
    - system_other - Expected file type .img
    - vbmeta - Expected file type .img
    - vbmeta_system - Expected file type .img
    - vbmeta_vendor - Expected file type .img
    - vendor - Expected file type .img
    - vendor_boot - Expected file type .img
    - vendor_dlkm (the device will be put into fastbootd mode during this operation) - Expected file type .img
    - image - Expected file type .zip
    - SIDELOAD - Expected file type .zip  
Select the appropriate flash options.
**Note:** For Tensor devices (Pixel 6 or newer devices) When `Flash to both slots` option is selected, Pixelflasher flashes each slot individually to overcome a Google bug that fails with the option `--slot=all`

## Translations

PixelFlasher currently includes French and Spanish translations, which were created using online translation tools. While these translations are functional, they may contain inaccuracies or awkward phrasing.

### Contributing Translations

If you'd like to help improve existing translations or add support for a new language:

- Use `locale\en\LC_MESSAGES\pixelflasher.po` as your template for translation.
- Submit your corrections or new language translations as a pull request.

### Translation Limitations

Please note the following about translations in PixelFlasher:

- Not all strings are translated; some will never be translated while others may be added in the future.
- Standard output (stdout) and console logs will never be translated.
- UI sizes and positions may be disrupted by languages that require more space (or much less space) for text elements - these UI adjustments won't be made to accommodate different languages.

Your help improving translations is greatly appreciated!

### Available languages

- French `fr`, used online translation (it could be imperfect)
- Spanish `es`, used online translation (it could be imperfect)
- Traditional Chinese `zh-rTW`, thanks to [EdwardWu](https://github.com/bluehomewu)
- Simplified Chinese `zh_CN`, thanks to [LittlenineEnnea](https://github.com/LittlenineEnnea)
- Italian `it`, thanks to [bandrea83](https://github.com/bandrea83)

## Credits

- First and foremost [Magisk](https://github.com/topjohnwu/Magisk/releases) by [John Wu](https://github.com/topjohnwu) which made rooting Pixel™ phones possible, without it none of this would have mattered.
- Big thanks to [[ryder203]](https://www.t-ryder.de/), [[t-ryder]](https://xdaforums.com/m/t-ryder.3705546/) for his valuable ideas, feedback and testing. Your contributions are very much appreciated.
- [[Homeboy76]](https://xdaforums.com/m/homeboy76.4810220/), [[v0latyle]](https://xdaforums.com/m/v0latyle.3690504/) and [[roirraW-edor-ehT]](https://xdaforums.com/m/roirraw-edor-eht.2560614/) at [xda](https://xdaforums.com/) for their excellent guides [[here](https://xdaforums.com/t/guide-november-6-2023-root-pixel-8-pro-unlock-bootloader-pass-safetynet-both-slots-bootable-more.4638510/#post-89128833/), [here](https://xdaforums.com/t/guide-pixel-6-oriole-unlock-bootloader-update-root-pass-safetynet.4356233/) and [here](https://xdaforums.com/t/november-6-2023-ud1a-231105-004-magisk-stable-v26-4-released-unlock-bootloader-root-pixel-8-pro-husky-safetynet.4633839/) and many more] on Pixel™ series phones (The guide concepts are generic and can be applied to any Pixel devices).
This program could not have been possible without their easy to follow guides.  
I strongly encourage all beginners to follow those guides rather than use this program, it is important to understand the basic steps involved before diving into one click tools or advanced tasks.
- Marcel Stör's [nodemcu-pyflasher](https://github.com/marcelstoer/nodemcu-pyflasher) source code which jump started my introduction to [wxPython](https://www.wxpython.org/) and eventually this program.
- [wxPython Team](https://wxpython.org/) for their cross-platform GUI toolkit for Python.
- [JackMcKew](https://github.com/JackMcKew) for pyinstaller Github Actions.
- Endless counts of [xda](https://xdaforums.com/) members and their posts that tirelessly answer questions and share tools. Too many to enumerate.
- Artwork / graphics / icons, designed and supplied by: [[ryder203]](https://www.t-ryder.de/), [[t-ryder]](https://xdaforums.com/m/t-ryder.3705546/) based on [material-design-icons](https://github.com/google/material-design-icons/blob/master/LICENSE)
- vm03's [payload_dumper](https://github.com/vm03/payload_dumper) source code to extract images from payload.bin files.
- [osm0sis](https://github.com/osm0sis) for the creative and pioneer approach to beta pif print extraction, [banned kernel list](https://xdaforums.com/t/module-play-integrity-fix-safetynet-fix.4607985/page-518#post-89308909) and endless other contributions that are too many to enumerate.
- [capntrips](https://github.com/capntrips) for code / tools and mentoring provided to create features like `Downgrade Patch` and `Cancel OTA Update`.
- [Vagelis1608](https://github.com/Vagelis1608) for building [canary / beta factory image catalog](https://github.com/Vagelis1608/get_the_canary_miner/blob/main/catalog.json) and graciously sharing.

## Troubleshooting

If you need support or assistance, please first [search Github issues](https://github.com/badabing2005/PixelFlasher/issues?q=) and [XDA Forums](https://xdaforums.com/search/) to see if it is already reported / resolved, if not, please **generate and provide a support file** from within PixelFlasher.
You can hit that big Support button on the main screen, or select it from the Help menu.
The generated support.zip file is encrypted and optionally sanitized (redacted) to keep your sensitive information (username device id ...) private.

- If your anti-virus program is telling you that PixelFlasher is a malware, or you are concerned in any way, please check [this post](https://xdaforums.com/t/pixelflasher-a-gui-tool-for-flashing-updating-rooting-managing-pixel-phones.4415453/post-89090938) about false positives.

## Disclaimer

```text
********************************************************************************
PLEASE DO YOUR PART AND READ / SEARCH / RESEARCH BEFORE USING THIS PROGRAM
AND/OR ATTEMPTING ANY MODIFICATIONS ON YOUR DEVICE.
THIS PROGRAM ASSUMES THAT YOU ALREADY KNOW HOW TO AND HAVE ALREADY UNLOCKED
YOUR BOOTLOADER, ALREADY ROOTED YOUR DEVICE, AND KNOW HOW TO USE ANDROID SDK
PLATFORM-TOOLS, ETC.
THIS TOOL IS SIMPLY MY QUICK WAY OF UPDATING THE FIRMWARE WHILE ROOTED WITH
MAGISK, WITHOUT LOSING DATA / REQUIRING A WIPE.

MODIFYING YOUR DEVICE COMES WITH INHERENT RISKS, AND IT'S NOT MY RESPONSIBILITY
IF YOU LOSE YOUR DATA OR BRICK YOUR DEVICE. THE TOOL I SHARE HAVE WORKED FOR ME,
BUT THAT DOESN'T MEAN THAT YOU MAY NOT RUN INTO PROBLEMS. **BACKUP YOUR DATA.**
********************************************************************************
```

```

`advanced_settings.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
import images as images
import webbrowser
import sys
from runtime import *
from constants import *
from i18n import _


# ============================================================================
#                               Class AdvancedSettings
# ============================================================================
class AdvancedSettings(wx.Dialog):
    def __init__(self, parent, *args, **kwargs):
        wx.Dialog.__init__(self, parent, *args, **kwargs, style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)

        self.SetTitle(_("Advanced Configuration Settings"))

        # Top Part:
        top_panel = wx.Panel(self)
        top_sizer = wx.BoxSizer(wx.VERTICAL)

        # advanced options
        advanced_options_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.advanced_options_checkbox = wx.CheckBox(parent=top_panel, id=wx.ID_ANY, label=_("Enable Advanced Options (only enable this if you know what you're doing)"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.advanced_options_checkbox.SetToolTip(_("Expert mode"))
        advanced_options_sizer.Add(self.advanced_options_checkbox, proportion=0, flag=wx.ALL, border=5)
        top_sizer.Add(advanced_options_sizer, proportion=0, flag=wx.EXPAND, border=5)

        # static line
        staticline = wx.StaticLine(parent=top_panel, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.LI_HORIZONTAL)
        top_sizer.Add(staticline, proportion=0, flag=wx.EXPAND, border=5)

        top_panel.SetSizer(top_sizer)

        # Middle Part: Scrolled panel with widgets
        scrolled_panel = wx.ScrolledWindow(self, style=wx.VSCROLL | wx.HSCROLL)
        middle_sizer = wx.BoxSizer(wx.VERTICAL)

        fgs1 = wx.FlexGridSizer(cols=2, vgap=10, hgap=10)
        # this makes the second column expandable (index starts at 0)
        fgs1.AddGrowableCol(1, 1)
        # this makes the height expandable
        fgs1.AddGrowableRow(0, 1)

        # Magisk Package name
        package_name_label = wx.StaticText(parent=scrolled_panel, label=_("Magisk Package Name"))
        self.package_name = wx.TextCtrl(parent=scrolled_panel, id=-1, size=(-1, -1))
        self.package_name.SetToolTip(_("If you have hidden Magisk,\nset this to the hidden package name."))
        self.reset_magisk_pkg = wx.BitmapButton(parent=scrolled_panel, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.reset_magisk_pkg.SetBitmap(images.scan_24.GetBitmap())
        self.reset_magisk_pkg.SetToolTip(_("Resets package name to default: %s") % MAGISK_PKG_NAME)
        package_name_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        package_name_sizer.Add(self.package_name, proportion=1, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        package_name_sizer.Add(self.reset_magisk_pkg, proportion=0, flag=wx.LEFT|wx.ALIGN_CENTER_VERTICAL, border=5)

        # Spoofed apps package names
        self.spoofed_apps_label = wx.StaticText(parent=scrolled_panel, id=wx.ID_ANY, label=_("Spoofed Apps Package Names"))
        self.spoofed_apps_label.SetToolTip(_("The listed package names are spoofed apps that PixelFlasher will look for."))
        self.spoofed_apps = wx.SearchCtrl(scrolled_panel, style=wx.TE_LEFT)
        self.spoofed_apps.ShowCancelButton(True)
        self.spoofed_apps.SetDescriptiveText(_("Example: xz.jft.fn, otgs.werg.dflkjh"))
        self.spoofed_apps.ShowSearchButton(False)

        # only add if we're on linux
        if sys.platform.startswith("linux"):
            # Linux File Explorer
            file_explorer_label = wx.StaticText(scrolled_panel, label=_("Linux File Explorer:"))
            file_explorer_label.SetSize(self.package_name.GetSize())
            self.file_explorer = wx.TextCtrl(scrolled_panel, -1, size=(300, -1))
            self.file_explorer.SetToolTip(_("Set full path to File Explorer.\nDefault: Nautilus"))
            file_explorer_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
            file_explorer_sizer.Add((20, 0), proportion=0, flag=wx.ALL, border=5)
            file_explorer_sizer.Add(self.file_explorer, proportion=0, flag=wx.LEFT, border=10)

            # Linux Shell
            shell_label = wx.StaticText(parent=scrolled_panel, label=_("Linux Shell:"))
            shell_label.SetSize(self.package_name.GetSize())
            self.shell = wx.TextCtrl(parent=scrolled_panel, id=wx.ID_ANY, size=(300, -1))
            self.shell.SetToolTip(_("Set full path to Linux Shell.\nDefault: gnome-terminal"))
            shell_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
            shell_sizer.Add((20, 0), proportion=0, flag=wx.ALL, border=5)
            shell_sizer.Add(self.shell, proportion=0, flag=wx.LEFT, border=10)

        # Offer Patch methods
        self.patch_methods_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Offer Patch Methods"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.patch_methods_checkbox.SetToolTip(_("When patching the choice of method is presented."))
        self.recovery_patch_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Patching Recovery Partition"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.recovery_patch_checkbox.SetToolTip(_("Enabling this will show an option to patch a recovery partition.\nThis should be kept disabled unless you have an old device.\n(most A-only devices launched with Android 9, legacy SAR)"))
        self.keep_temp_files_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Keep Temp Files"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.keep_temp_files_checkbox.SetToolTip(_("Enabling this will keep temporary files used for patching.\nThis is useful for debugging purposes.\nIt is recommended to keep this disabled."))

        # Use Busybox Shell
        self.use_busybox_shell_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Use Busybox Shell"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.use_busybox_shell_checkbox.SetToolTip(_("When creating a patch, if this is checked, busybox ash will be used as shell."))

        # Enable Low Memory
        self.low_mem_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("System has low memory"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.low_mem_checkbox.SetToolTip(_("Use this option to sacrifice speed in favor of memory."))

        # Extra img extraction
        self.extra_img_extracts_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Extra img extraction"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.extra_img_extracts_checkbox.SetToolTip(_("When checked and available in payload.bin\nAlso extract vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"))

        # Show Notifications
        self.show_notifications_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Show notifications"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.show_notifications_checkbox.SetToolTip(_("When checked PixelFlasher will display system toast notifications."))

        # Always Create boot.tar
        self.create_boot_tar_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Always create boot.tar"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.create_boot_tar_checkbox.SetToolTip(_("When checked, PixelFlasher always creates boot.tar of the patched boot file.\nIf unchecked, only for Samsung firmware boot.tar will be created."))
        self.create_boot_tar_checkbox.Disable()

        # Check for updates options
        self.check_for_update_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Check for updates"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.check_for_update_checkbox.SetToolTip(_("Checks for available updates on startup"))

        # Check for Minimum Disk space option
        self.check_for_disk_space_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Check for Minimum Disk (5Gb)"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.check_for_disk_space_checkbox.SetToolTip(_("Enforces minimum disk space of 5 Gb to allow flashing.\nThis avoids storage related issues."))

        # Check for Bootloader unlocked option
        self.check_for_bootloader_unlocked_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Check for bootloader unlocked"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.check_for_bootloader_unlocked_checkbox.SetToolTip(_("Checks to make sure bootloader is unlocked before flashing."))

        # Check for Firmware hash validity option
        self.check_for_firmware_hash_validity_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Check for firmware hash validity"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.check_for_firmware_hash_validity_checkbox.SetToolTip(_("Checks for sha256 portion to be in the image filename to detect Pixel compatible image."))

        # Keep temporary support files option
        self.keep_temporary_support_files_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Keep temporary support files"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.keep_temporary_support_files_checkbox.SetToolTip(_("It keeps the temporary support files.\nUseful for inspecting what data is included in support.zip."))

        # Check if Magisk modules have updates
        self.check_module_updates = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Check Magisk modules for updates"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.check_module_updates.SetToolTip(_("It checks if the module has updates.\nDisable this if you don't want to check for updates or\n if some module update server has issues and delays the process."))

        # Show custom ROM options
        self.show_custom_rom_options = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Show custom ROM options"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.show_custom_rom_options.SetToolTip(_("Make sure you check if your ROM is supported."))

        # Sanitize support files
        self.sanitize_support_files = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Sanitize (Redact) support files"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.sanitize_support_files.SetToolTip(_("The support files are always encrypted.\nThis option redacts sensitive information from the support files.\nBut impedes support and is not recommended."))

        # KB Indexing
        self.kb_index_cb = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Keybox Index"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.kb_index_cb.SetToolTip(_("This will enable keybox indexing.\nThis is useful if you process multiple keyboxes.\nWhich can be used to analyze keyboxes and compare them to previously processed ones.\nThis can help in identifying duplicate keyboxes"))

        # Force codepage
        self.force_codepage_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Force codepage to"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.force_codepage_checkbox.SetToolTip(_("Uses specified code page instead of system code page"))
        self.code_page = wx.TextCtrl(parent=scrolled_panel, id=wx.ID_ANY, size=(-1, -1))

        # Delete Bundle libs
        self.delete_bundled_libs_label = wx.StaticText(parent=scrolled_panel, id=wx.ID_ANY, label=_("Delete bundled libs"))
        self.delete_bundled_libs_label.SetToolTip(_("The listed libraries would be deleted from the PF bundle to allow system defined ones to be used."))
        self.delete_bundled_libs = wx.SearchCtrl(scrolled_panel, style=wx.TE_LEFT)
        self.delete_bundled_libs.ShowCancelButton(True)
        self.delete_bundled_libs.SetDescriptiveText(_("Example: libreadline.so.8, libgdk*"))
        self.delete_bundled_libs.ShowSearchButton(False)

        # Override KMI
        self.override_kmi_label = wx.StaticText(parent=scrolled_panel, id=wx.ID_ANY, label=_("Override KMI"))
        self.override_kmi_label.SetToolTip(_("This will override the Kernel Module Interface (KMI) to the specified value.\nThis is useful for devices with custom kernels.\nThe value will be passed to KernelSU as the KMI value."))
        self.override_kmi = wx.SearchCtrl(scrolled_panel, style=wx.TE_LEFT)
        self.override_kmi.ShowCancelButton(True)
        self.override_kmi.SetDescriptiveText(_("Example: 5.15.131-android14"))
        self.override_kmi.ShowSearchButton(False)

        # Use Custom Font
        self.use_custom_font_checkbox = wx.CheckBox(parent=scrolled_panel, id=wx.ID_ANY, label=_("Use Custom Fontface"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.use_custom_font_checkbox.SetToolTip(_("Use custom font for monospace fonts\nMight require PixelFlasher restart to properly apply to the Console window."))

        # Font Selection
        fonts = wx.FontEnumerator()
        fonts.EnumerateFacenames(wx.FONTENCODING_SYSTEM, fixedWidthOnly=True)
        font_list = fonts.GetFacenames(wx.FONTENCODING_SYSTEM, fixedWidthOnly=True)
        self.font = wx.ListBox(parent=scrolled_panel, id=wx.ID_ANY, size=(300, 100), choices=font_list)
        self.font_size = wx.SpinCtrl(parent=scrolled_panel, id=wx.ID_ANY, min=6, max=50, initial=self.Parent.config.pf_font_size)
        self.sample = wx.StaticText(parent=scrolled_panel, id=wx.ID_ANY, label=_("Sample "))
        fonts_sizer = wx.BoxSizer(wx.HORIZONTAL)
        fonts_sizer.Add(self.font, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=0)
        fonts_sizer.Add(self.font_size, proportion=0, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=5)
        fonts_sizer.Add(self.sample, proportion=1, flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=5)
        self.font.SetSelection(-1)
        self.font_size.SetToolTip(_('Select font size'))
        self._onFontSelect(None)

        # scrcpy 1st row widgets, select path
        self.scrcpy_path_label = wx.StaticText(parent=scrolled_panel, id=wx.ID_ANY, label=_("scrcpy Path"))
        self.scrcpy_link = wx.BitmapButton(parent=scrolled_panel, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.scrcpy_link.SetBitmap(bitmap=images.open_link_24.GetBitmap())
        self.scrcpy_link.SetToolTip(_("Download scrcpy"))
        self.scrcpy_path_picker = wx.FilePickerCtrl(parent=scrolled_panel, id=wx.ID_ANY, path=wx.EmptyString, message=_("Select scrcpy executable"), wildcard=_("Scrcpy executable (*.exe;*)|*.exe;*"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.FLP_USE_TEXTCTRL)

        self.scrcpy_path_picker.SetToolTip(_("Select scrcpy executable"))
        self.scrcpy_h1sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
        self.scrcpy_h1sizer.Add(window=self.scrcpy_path_label, proportion=0, flag=wx.EXPAND)
        self.scrcpy_h1sizer.AddSpacer(10)
        self.scrcpy_h1sizer.Add(window=self.scrcpy_link, proportion=0, flag=wx.EXPAND)
        self.scrcpy_h1sizer.AddSpacer(10)
        self.scrcpy_h1sizer.Add(window=self.scrcpy_path_picker, proportion=1, flag=wx.EXPAND)

        # scrcpy 2nd row flags
        self.scrcpy_flags = wx.SearchCtrl(scrolled_panel, style=wx.TE_LEFT)
        self.scrcpy_flags.ShowCancelButton(True)
        self.scrcpy_flags.SetDescriptiveText(_("Flags / Arguments (Example: --video-bit-rate 2M --max-fps=30 --max-size 1024)"))
        self.scrcpy_flags.ShowSearchButton(False)

        # build the sizers for scrcpy
        scrcpy_sb = wx.StaticBox(scrolled_panel, -1, _("Scrcpy settings"))
        scrcpy_vsizer = wx.StaticBoxSizer(scrcpy_sb, wx.VERTICAL)
        scrcpy_vsizer.Add(self.scrcpy_h1sizer, proportion=1, flag=wx.ALL|wx.EXPAND, border=5)
        scrcpy_vsizer.Add(self.scrcpy_flags, proportion=1, flag=wx.ALL|wx.EXPAND, border=5)
        #
        scrcpy_outer_sizer = wx.BoxSizer(wx.HORIZONTAL)
        scrcpy_outer_sizer.AddSpacer(20)
        scrcpy_outer_sizer.Add(scrcpy_vsizer, proportion=1, flag=wx.EXPAND, border=10)
        scrcpy_outer_sizer.AddSpacer(20)

        # Set Widget values from config
        self.advanced_options_checkbox.SetValue(self.Parent.config.advanced_options)
        self.package_name.SetValue(self.Parent.config.magisk)
        self.spoofed_apps.SetValue(self.Parent.config.spoofed_apps)
        self.patch_methods_checkbox.SetValue(self.Parent.config.offer_patch_methods)
        self.recovery_patch_checkbox.SetValue(self.Parent.config.show_recovery_patching_option)
        self.keep_temp_files_checkbox.SetValue(self.Parent.config.keep_patch_temporary_files)
        self.use_busybox_shell_checkbox.SetValue(self.Parent.config.use_busybox_shell)
        self.low_mem_checkbox.SetValue(self.Parent.config.low_mem)
        self.extra_img_extracts_checkbox.SetValue(self.Parent.config.extra_img_extracts)
        self.show_notifications_checkbox.SetValue(self.Parent.config.show_notifications)
        self.create_boot_tar_checkbox.SetValue(self.Parent.config.create_boot_tar)
        self.check_for_update_checkbox.SetValue(self.Parent.config.update_check)
        self.check_for_disk_space_checkbox.SetValue(self.Parent.config.check_for_disk_space)
        self.check_for_bootloader_unlocked_checkbox.SetValue(self.Parent.config.check_for_bootloader_unlocked)
        self.check_for_firmware_hash_validity_checkbox.SetValue(self.Parent.config.check_for_firmware_hash_validity)
        self.keep_temporary_support_files_checkbox.SetValue(self.Parent.config.keep_temporary_support_files)
        self.check_module_updates.SetValue(self.Parent.config.check_module_updates)
        self.show_custom_rom_options.SetValue(self.Parent.config.show_custom_rom_options)
        self.sanitize_support_files.SetValue(self.Parent.config.sanitize_support_files)
        self.kb_index_cb.SetValue(self.Parent.config.kb_index)
        self.force_codepage_checkbox.SetValue(self.Parent.config.force_codepage)
        self.delete_bundled_libs.SetValue(self.Parent.config.delete_bundled_libs)
        self.override_kmi.SetValue(self.Parent.config.override_kmi)
        self.code_page.SetValue(str(self.Parent.config.custom_codepage))
        self.use_custom_font_checkbox.SetValue(self.Parent.config.customize_font)
        self.font.SetStringSelection(self.Parent.config.pf_font_face)

        if self.Parent.config.scrcpy and self.Parent.config.scrcpy['path'] != '' and os.path.exists(self.Parent.config.scrcpy['path']):
            self.scrcpy_path_picker.SetPath(self.Parent.config.scrcpy['path'])
        if self.Parent.config.scrcpy and self.Parent.config.scrcpy['flags'] != '':
            self.scrcpy_flags.SetValue(self.Parent.config.scrcpy['flags'])

        if sys.platform.startswith("linux"):
            self.file_explorer.SetValue(self.Parent.config.linux_file_explorer)
            self.shell.SetValue(self.Parent.config.linux_shell)

        # add the widgets to the grid in two columns, first fix size, the second expandable.
        fgs1.Add(package_name_label, 0, wx.ALIGN_CENTER_VERTICAL)
        fgs1.Add(package_name_sizer, 0, wx.EXPAND)

        fgs1.Add(self.spoofed_apps_label, 0, wx.ALIGN_CENTER_VERTICAL)
        fgs1.Add(self.spoofed_apps, 1, wx.EXPAND)

        fgs1.Add(self.patch_methods_checkbox, 0, wx.EXPAND)
        fgs1.Add(self.recovery_patch_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))
        fgs1.Add(self.keep_temp_files_checkbox, 0, wx.EXPAND)

        if sys.platform.startswith("linux"):
            # only add if we're on linux
            fgs1.Add(file_explorer_label, 0, wx.EXPAND)
            fgs1.Add(file_explorer_sizer, 1, wx.EXPAND)
            fgs1.Add(shell_label, 0, wx.EXPAND)
            fgs1.Add(shell_sizer, 1, wx.EXPAND)

        fgs1.Add(self.use_busybox_shell_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.low_mem_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.extra_img_extracts_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.show_notifications_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.create_boot_tar_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.check_for_update_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.check_for_disk_space_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.check_for_bootloader_unlocked_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.check_for_firmware_hash_validity_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.keep_temporary_support_files_checkbox, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.check_module_updates, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.show_custom_rom_options, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.sanitize_support_files, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.kb_index_cb, 0, wx.EXPAND)
        fgs1.Add((0, 0))

        fgs1.Add(self.force_codepage_checkbox, 0, wx.EXPAND)
        fgs1.Add(self.code_page, 1, wx.EXPAND)

        fgs1.Add(self.delete_bundled_libs_label, 0, wx.EXPAND)
        fgs1.Add(self.delete_bundled_libs, 1, wx.EXPAND)

        fgs1.Add(self.override_kmi_label, 0, wx.EXPAND)
        fgs1.Add(self.override_kmi, 1, wx.EXPAND)

        fgs1.Add(self.use_custom_font_checkbox, 0, wx.EXPAND)
        fgs1.Add(fonts_sizer, 1, wx.EXPAND)

        middle_sizer.Add(fgs1, proportion=1, flag=wx.EXPAND)
        middle_sizer.Add(scrcpy_outer_sizer, proportion=0, flag=wx.EXPAND, border=5)
        scrolled_panel.SetSizer(middle_sizer)
        scrolled_panel.SetScrollRate(10, 10)

        # Bottom Part: OK and Cancel buttons
        bottom_panel = wx.Panel(self)
        bottom_sizer = wx.BoxSizer(wx.HORIZONTAL)
        bottom_sizer.Add((0, 0), proportion=1, flag=wx.EXPAND, border=5)
        self.ok_button = wx.Button(parent=bottom_panel, id=wx.ID_ANY, label=_("OK"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        bottom_sizer.Add(self.ok_button, proportion=0, flag=wx.ALL, border=20)
        self.cancel_button = wx.Button(parent=bottom_panel, id=wx.ID_ANY, label=_("Cancel"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        bottom_sizer.Add(self.cancel_button, proportion=0, flag=wx.ALL, border=20)
        bottom_sizer.Add((0, 0), proportion=1, flag=wx.EXPAND, border=5)
        bottom_panel.SetSizer(bottom_sizer)

        # Main Sizer
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        main_sizer.Add(top_panel, 0, wx.EXPAND | wx.ALL, 5)
        main_sizer.Add(scrolled_panel, proportion=1, flag=wx.ALL | wx.EXPAND, border=20)
        main_sizer.Add(bottom_panel, proportion=0, flag=wx.EXPAND, border=5)

        self.SetSizer(main_sizer)
        self.Center()
        # self.Layout()

        # Disable horizontal resizing
        self.SetMinSize(wx.Size(-1, self.GetSize().y))
        self.SetMaxSize(wx.Size(-1, self.GetSize().y))

        # Connect Events
        self.ok_button.Bind(wx.EVT_BUTTON, self._onOk)
        self.cancel_button.Bind(wx.EVT_BUTTON, self._onCancel)
        self.font.Bind(wx.EVT_LISTBOX, self._onFontSelect)
        self.font_size.Bind(wx.EVT_SPINCTRL, self._onFontSelect)
        self.reset_magisk_pkg.Bind(wx.EVT_BUTTON, self._onResetMagiskPkg)
        self.patch_methods_checkbox.Bind(wx.EVT_CHECKBOX, self._on_offer_patch_methods)
        self.use_custom_font_checkbox.Bind(wx.EVT_CHECKBOX, self._on_use_custom_fontface)
        self.Bind(wx.EVT_INIT_DIALOG, self.on_init_dialog)
        self.scrcpy_link.Bind(wx.EVT_BUTTON, self._open_scrcpy_link)
        self.Bind(wx.EVT_CLOSE, self._onCancel)
        # self.Bind(wx.EVT_SIZE, self.on_resize)

        # Enable / Disable Widgets
        self.enable_disable_widgets()


    def on_init_dialog(self, event):
        # Autosize the dialog without exceeding 90% of the screen
        screen_width, screen_height = wx.GetDisplaySize()
        debug(f"Screen Size: {screen_width} x {screen_height}")
        screen_max_width = int(screen_width * 0.9)
        screen_max_height = int(screen_height * 0.9)
        self.max_width = min(screen_max_width, 914)
        self.max_height = min(screen_max_height, 1250)
        debug(f"Max Dialog Size: {self.max_width} x {self.max_height}")
        self.SetMaxSize(wx.Size(self.max_width, self.max_height))
        self.SetSizeHints(self.GetMinSize(), self.GetMaxSize())
        self.SetSize((self.max_width, self.max_height))
        self.CenterOnParent()
        event.Skip()


    def on_resize(self, event):
        # Get the current size of the frame
        frame_size = self.GetSize()

        if frame_size.width > self.max_width or frame_size.height > self.max_height:
            # Adjust the size to the maximum allowed size
            new_width = min(frame_size.width, self.max_width)
            new_height = min(frame_size.height, self.max_height)
            self.SetSize((new_width, new_height))
        event.Skip()


    def enable_disable_widgets(self):
        if self.patch_methods_checkbox.GetValue():
            self.recovery_patch_checkbox.Enable()
        else:
            self.recovery_patch_checkbox.Disable()
        if self.use_custom_font_checkbox.GetValue():
            self.font.Enable()
            self.font_size.Enable()
            self.sample.Enable()
        else:
            self.font.Disable()
            self.font_size.Disable()
            self.sample.Disable()


    def _on_offer_patch_methods(self, event):
        self.enable_disable_widgets()


    def _on_use_custom_fontface(self, event):
        self.enable_disable_widgets()


    def _onFontSelect(self, evt):
        facename = self.font.GetStringSelection()
        size = self.font_size.GetValue()
        font = wx.Font(size, family=wx.DEFAULT, style=wx.NORMAL, weight=wx.NORMAL, underline=False, faceName=facename)
        self.sample.SetLabel(facename)
        self.sample.SetFont(font)
        self.Refresh()

    def _open_scrcpy_link(self, event):
        try:
            sys.stdout.write(f"Launching browser for scrcpy download URL: {SCRCPYURL}\n")
            webbrowser.open_new(SCRCPYURL)
            puml(f":Open scrcpy Link;\nnote right\n=== scrcpy\n[[{SCRCPYURL}]]\nend note\n", True)
        except Exception as e:
            sys.stdout.write(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening skd link\n")
            traceback.print_exc()

    def _onResetMagiskPkg(self, e):
        self.package_name.SetValue(MAGISK_PKG_NAME)


    def _onCancel(self, e):
        self.EndModal(wx.ID_CANCEL)


    def _onOk(self, e):
        try:
            if self.advanced_options_checkbox.GetValue() != self.Parent.config.advanced_options:
                sys.stdout.write(f"Setting Enable Advanced Options to: {self.advanced_options_checkbox.GetValue()}\n")
            self.Parent.config.advanced_options = self.advanced_options_checkbox.GetValue()

            if self.patch_methods_checkbox.GetValue() != self.Parent.config.offer_patch_methods:
                sys.stdout.write(f"Setting Offer Patch Methods to: {self.patch_methods_checkbox.GetValue()}\n")
            self.Parent.config.offer_patch_methods = self.patch_methods_checkbox.GetValue()

            value = self.spoofed_apps.GetValue()
            if value is None:
                value = ''
            if value != self.Parent.config.spoofed_apps:
                sys.stdout.write(f"Setting Spoofed Apps to: {value}\n")
                self.Parent.config.spoofed_apps = value

            if self.recovery_patch_checkbox.GetValue() != self.Parent.config.show_recovery_patching_option:
                sys.stdout.write(f"Setting Patching Recovery Partition to: {self.recovery_patch_checkbox.GetValue()}\n")
            self.Parent.config.show_recovery_patching_option = self.recovery_patch_checkbox.GetValue()

            if self.keep_temp_files_checkbox.GetValue() != self.Parent.config.keep_patch_temporary_files:
                sys.stdout.write(f"Keep Temp Files to: {self.keep_temp_files_checkbox.GetValue()}\n")
            self.Parent.config.keep_patch_temporary_files = self.keep_temp_files_checkbox.GetValue()

            if self.use_busybox_shell_checkbox.GetValue() != self.Parent.config.use_busybox_shell:
                sys.stdout.write(f"Setting Use Busybox Shell to: {self.use_busybox_shell_checkbox.GetValue()}\n")
            self.Parent.config.use_busybox_shell = self.use_busybox_shell_checkbox.GetValue()

            if self.low_mem_checkbox.GetValue() != self.Parent.config.low_mem:
                sys.stdout.write(f"Setting Low Memory to: {self.low_mem_checkbox.GetValue()}\n")
            self.Parent.config.low_mem = self.low_mem_checkbox.GetValue()
            set_low_memory(self.low_mem_checkbox.GetValue())

            if self.extra_img_extracts_checkbox.GetValue() != self.Parent.config.extra_img_extracts:
                sys.stdout.write(f"Setting Extra img extraction to: {self.extra_img_extracts_checkbox.GetValue()}\n")
            self.Parent.config.extra_img_extracts = self.extra_img_extracts_checkbox.GetValue()

            if self.show_notifications_checkbox.GetValue() != self.Parent.config.show_notifications:
                sys.stdout.write(f"Setting Show notifications to: {self.show_notifications_checkbox.GetValue()}\n")
            self.Parent.config.show_notifications = self.show_notifications_checkbox.GetValue()

            if self.create_boot_tar_checkbox.GetValue() != self.Parent.config.create_boot_tar:
                sys.stdout.write(f"Setting Always create boot.tar: {self.create_boot_tar_checkbox.GetValue()}\n")
            self.Parent.config.create_boot_tar = self.create_boot_tar_checkbox.GetValue()

            if self.check_for_update_checkbox.GetValue() != self.Parent.config.update_check:
                sys.stdout.write(f"Setting Check for updates to: {self.check_for_update_checkbox.GetValue()}\n")
            self.Parent.config.update_check = self.check_for_update_checkbox.GetValue()

            if self.check_for_disk_space_checkbox.GetValue() != self.Parent.config.check_for_disk_space:
                sys.stdout.write(f"Setting Check for Minimum Disk Space to: {self.check_for_disk_space_checkbox.GetValue()}\n")
            self.Parent.config.check_for_disk_space = self.check_for_disk_space_checkbox.GetValue()

            if self.check_for_bootloader_unlocked_checkbox.GetValue() != self.Parent.config.check_for_bootloader_unlocked:
                sys.stdout.write(f"Setting Check for Minimum Disk Space to: {self.check_for_bootloader_unlocked_checkbox.GetValue()}\n")
            self.Parent.config.check_for_bootloader_unlocked = self.check_for_bootloader_unlocked_checkbox.GetValue()

            if self.check_for_firmware_hash_validity_checkbox.GetValue() != self.Parent.config.check_for_firmware_hash_validity:
                sys.stdout.write(f"Setting Check for Firmware Hash Validity to: {self.check_for_firmware_hash_validity_checkbox.GetValue()}\n")
            self.Parent.config.check_for_firmware_hash_validity = self.check_for_firmware_hash_validity_checkbox.GetValue()

            if self.keep_temporary_support_files_checkbox.GetValue() != self.Parent.config.keep_temporary_support_files:
                sys.stdout.write(f"Setting Keep temporary support files to: {self.keep_temporary_support_files_checkbox.GetValue()}\n")
            self.Parent.config.keep_temporary_support_files = self.keep_temporary_support_files_checkbox.GetValue()

            if self.check_module_updates.GetValue() != self.Parent.config.check_module_updates:
                sys.stdout.write(f"Setting Check Magisk modules for updates to: {self.check_module_updates.GetValue()}\n")
            self.Parent.config.check_module_updates = self.check_module_updates.GetValue()

            if self.show_custom_rom_options.GetValue() != self.Parent.config.show_custom_rom_options:
                sys.stdout.write(f"Setting Show custom ROM options to: {self.show_custom_rom_options.GetValue()}\n")
            self.Parent.config.show_custom_rom_options = self.show_custom_rom_options.GetValue()

            if self.sanitize_support_files.GetValue() != self.Parent.config.sanitize_support_files:
                sys.stdout.write(f"Setting Sanitize Support Files options to: {self.sanitize_support_files.GetValue()}\n")
            self.Parent.config.sanitize_support_files = self.sanitize_support_files.GetValue()

            if self.kb_index_cb.GetValue() != self.Parent.config.kb_index:
                sys.stdout.write(f"Setting Keybox Indexing options to: {self.kb_index_cb.GetValue()}\n")
            self.Parent.config.kb_index = self.kb_index_cb.GetValue()

            if self.package_name.GetValue():
                with contextlib.suppress(Exception):
                    if self.package_name.GetValue() != self.Parent.config.magisk:
                        sys.stdout.write(f"Setting Magisk Package Name to: {self.package_name.GetValue()}\n")
                        set_magisk_package(self.package_name.GetValue())
                        self.Parent.config.magisk = self.package_name.GetValue()

            if sys.platform.startswith("linux"):
                with contextlib.suppress(Exception):
                    if self.file_explorer.GetValue() != self.Parent.config.linux_file_explorer:
                        sys.stdout.write(f"Setting Linux File Explorer to: {self.file_explorer.GetValue()}\n")
                    self.Parent.config.linux_file_explorer = self.file_explorer.GetValue()

                with contextlib.suppress(Exception):
                    if self.shell.GetValue() != self.Parent.config.linux_shell:
                        sys.stdout.write(f"Setting Linux Shell to: {self.shell.GetValue()}\n")
                    set_linux_shell(self.shell.GetValue())
                    self.Parent.config.linux_shell = self.shell.GetValue()

            self.Parent.config.force_codepage = self.force_codepage_checkbox.GetValue()
            if self.code_page.GetValue() and self.code_page.GetValue().isnumeric():
                self.Parent.config.custom_codepage = int(self.code_page.GetValue())

            value = self.delete_bundled_libs.GetValue()
            if value is None:
                value = ''
            if value != self.Parent.config.delete_bundled_libs:
                sys.stdout.write(f"Setting Delete bundled libs to: {value}\n")
                self.Parent.config.delete_bundled_libs = value

            value = self.override_kmi.GetValue()
            if value is None:
                value = ''
            if value != self.Parent.config.override_kmi:
                sys.stdout.write(f"Setting Kernel KMI to: {value}\n")
                self.Parent.config.override_kmi = value

            font_settings_changed = False
            if self.use_custom_font_checkbox.GetValue() != self.Parent.config.customize_font:
                sys.stdout.write("Enabling Custom Font\n")
                font_settings_changed = True
            if self.font.GetStringSelection() != self.Parent.config.pf_font_face:
                sys.stdout.write(f"Setting Application Font to: {self.font.GetStringSelection()}\n")
                if self.use_custom_font_checkbox.GetValue():
                    font_settings_changed = True
            if self.font_size.GetValue() != self.Parent.config.pf_font_size:
                sys.stdout.write(f"Setting Application Font Size to: {self.font_size.GetValue()}\n")
                if self.use_custom_font_checkbox.GetValue():
                    font_settings_changed = True
            self.Parent.config.customize_font = self.use_custom_font_checkbox.GetValue()
            self.Parent.config.pf_font_face = self.font.GetStringSelection()
            self.Parent.config.pf_font_size = self.font_size.GetValue()

            value = self.scrcpy_path_picker.GetPath()
            if value is None:
                value = ''
            if value != self.Parent.config.scrcpy['path'] and os.path.exists(value):
                sys.stdout.write(f"Setting scrcpy path path to: {value}\n")
                self.Parent.config.scrcpy['path'] = value

            value = self.scrcpy_flags.GetValue()
            if value is None:
                value = ''
            if value != self.Parent.config.scrcpy['flags']:
                sys.stdout.write(f"Setting scrcpy flags to: {value}\n")
                self.Parent.config.scrcpy['flags'] = value

            # update the runtime config
            set_config(self.Parent.config)

            if font_settings_changed:
                self.Parent.set_ui_fonts()
        finally:
            self.EndModal(wx.ID_OK)

```

`android_devices.json`:

```json
{
    "menari_lte": {
        "device": "Pixel Watch 4 (LTE)",
        "android_version_end_date": "October 2027",
        "security_update_end_date": "October 2029",
        "first_api_level": "36",
        "bootloader_codename": "menari",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "menari_btwifi": {
        "device": "Pixel Watch 4 (Bluetooth/Wi-Fi)",
        "android_version_end_date": "October 2027",
        "security_update_end_date": "October 2029",
        "first_api_level": "36",
        "bootloader_codename": "menari",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "rango": {
        "device": "Google Pixel 10 Pro Fold",
        "android_version_end_date": "October 2032",
        "security_update_end_date": "October 2032",
        "first_api_level": "36",
        "bootloader_codename": "deepspace",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "blazer": {
        "device": "Google Pixel 10 Pro",
        "android_version_end_date": "August 2032",
        "security_update_end_date": "August 2032",
        "first_api_level": "36",
        "bootloader_codename": "deepspace",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "frankel": {
        "device": "Google Pixel 10",
        "android_version_end_date": "August 2032",
        "security_update_end_date": "August 2032",
        "first_api_level": "36",
        "bootloader_codename": "deepspace",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "mustang": {
        "device": "Google Pixel 10 Pro XL",
        "android_version_end_date": "August 2032",
        "security_update_end_date": "August 2032",
        "first_api_level": "36",
        "bootloader_codename": "deepspace",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "tegu": {
        "device": "Google Pixel 9a",
        "android_version_end_date": "May 2032",
        "security_update_end_date": "May 2032",
        "first_api_level": "35",
        "bootloader_codename": "tegu",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "seluna": {
        "device": "Pixel Watch 3 (LTE)",
        "android_version_end_date": "October 2027",
        "security_update_end_date": "October 2029",
        "first_api_level": "33",
        "bootloader_codename": "seluna",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "solios": {
        "device": "Pixel Watch 3 (Bluetooth/Wi-Fi)",
        "android_version_end_date": "October 2027",
        "security_update_end_date": "October 2029",
        "first_api_level": "33",
        "bootloader_codename": "solios-seluna",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "comet": {
        "device": "Google Pixel 9 Pro Fold",
        "android_version_end_date": "September 2031",
        "security_update_end_date": "September 2031",
        "first_api_level": "34",
        "bootloader_codename": "ripcurrentpro",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "komodo": {
        "device": "Google Pixel 9 Pro XL",
        "android_version_end_date": "September 2031",
        "security_update_end_date": "September 2031",
        "first_api_level": "34",
        "bootloader_codename": "ripcurrentpro",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "caiman": {
        "device": "Google Pixel 9 Pro",
        "android_version_end_date": "September 2031",
        "security_update_end_date": "September 2031",
        "first_api_level": "34",
        "bootloader_codename": "ripcurrentpro",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "tokay": {
        "device": "Google Pixel 9",
        "android_version_end_date": "September 2031",
        "security_update_end_date": "September 2031",
        "first_api_level": "34",
        "bootloader_codename": "ripcurrentpro",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "akita": {
        "device": "Google Pixel 8a",
        "android_version_end_date": "May 2031",
        "security_update_end_date": "May 2031",
        "first_api_level": "34",
        "bootloader_codename": "akita",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "eos": {
        "device": "Google Pixel Watch 2 (LTE)",
        "android_version_end_date": "October 2026",
        "security_update_end_date": "October 2028",
        "first_api_level": "33",
        "bootloader_codename": "eos",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "aurora": {
        "device": "Google Pixel Watch 2 (Bluetooth/Wi-Fi)",
        "android_version_end_date": "October 2026",
        "security_update_end_date": "October 2028",
        "first_api_level": "33",
        "bootloader_codename": "aurora-eos",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "husky": {
        "device": "Pixel 8 Pro",
        "android_version_end_date": "October 2030",
        "security_update_end_date": "October 2030",
        "first_api_level": "34",
        "bootloader_codename": "ripcurrent",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "shiba": {
        "device": "Pixel 8",
        "android_version_end_date": "October 2030",
        "security_update_end_date": "October 2030",
        "first_api_level": "34",
        "bootloader_codename": "ripcurrent",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "felix": {
        "device": "Pixel Fold",
        "android_version_end_date": "June 2026",
        "security_update_end_date": "June 2028",
        "first_api_level": "33",
        "bootloader_codename": "felix",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "tangorpro": {
        "device": "Pixel Tablet",
        "android_version_end_date": "June 2026",
        "security_update_end_date": "June 2028",
        "first_api_level": "33",
        "bootloader_codename": "tangorpro",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "lynx": {
        "device": "Pixel 7a",
        "android_version_end_date": "May 2026",
        "security_update_end_date": "May 2028",
        "first_api_level": "33",
        "bootloader_codename": "lynx",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "r11": {
        "device": "Google Pixel Watch (LTE)",
        "android_version_end_date": "October 2025",
        "security_update_end_date": "October 2026",
        "first_api_level": "30",
        "bootloader_codename": "r11",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "r11btwifi": {
        "device": "Google Pixel Watch (Bluetooth/Wi-Fi)",
        "android_version_end_date": "October 2025",
        "security_update_end_date": "October 2026",
        "first_api_level": "30",
        "bootloader_codename": "r11btwifi-r11",
        "has_init_boot": true,
        "is_pixel_watch": true
    },
    "cheetah": {
        "device": "Pixel 7 Pro",
        "android_version_end_date": "October 2025",
        "security_update_end_date": "October 2027",
        "first_api_level": "33",
        "bootloader_codename": "cloudripper",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "panther": {
        "device": "Pixel 7",
        "android_version_end_date": "October 2025",
        "security_update_end_date": "October 2027",
        "first_api_level": "33",
        "bootloader_codename": "cloudripper",
        "has_init_boot": true,
        "is_pixel_watch": false
    },
    "bluejay": {
        "device": "Pixel 6a",
        "android_version_end_date": "June 2025",
        "security_update_end_date": "June 2027",
        "first_api_level": "32",
        "bootloader_codename": "bluejay",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "oriole": {
        "device": "Pixel 6",
        "android_version_end_date": "October 2024",
        "security_update_end_date": "October 2026",
        "first_api_level": "31",
        "bootloader_codename": "slider",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "raven": {
        "device": "Pixel 6 Pro",
        "android_version_end_date": "October 2024",
        "security_update_end_date": "October 2026",
        "first_api_level": "31",
        "bootloader_codename": "slider",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "barbet": {
        "device": "Pixel 5a",
        "android_version_end_date": "August 2024",
        "security_update_end_date": "August 2024",
        "first_api_level": "30",
        "bootloader_codename": "barbet-b9",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "redfin": {
        "device": "Pixel 5",
        "android_version_end_date": "October 2023",
        "security_update_end_date": "October 2023",
        "first_api_level": "30",
        "bootloader_codename": "redfin",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "bramble": {
        "device": "Pixel 4a (5G)",
        "android_version_end_date": "November  2023",
        "security_update_end_date": "November  2023",
        "first_api_level": "30",
        "bootloader_codename": "bramble-b5",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "sunfish": {
        "device": "Pixel 4a",
        "android_version_end_date": "August 2023",
        "security_update_end_date": "August 2023",
        "first_api_level": "29",
        "bootloader_codename": "sunfish-s5",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "coral": {
        "device": "Pixel 4 XL",
        "android_version_end_date": "October 2022",
        "security_update_end_date": "October 2022",
        "first_api_level": "29",
        "bootloader_codename": "coral",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "flame": {
        "device": "Pixel 4",
        "android_version_end_date": "October 2022",
        "security_update_end_date": "October 2022",
        "first_api_level": "29",
        "bootloader_codename": "flame",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "bonito": {
        "device": "Pixel 3a XL",
        "android_version_end_date": "May 2022",
        "security_update_end_date": "May 2023",
        "first_api_level": "28",
        "bootloader_codename": "bonito",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "sargo": {
        "device": "Pixel 3a",
        "android_version_end_date": "May 2022",
        "security_update_end_date": "May 2022",
        "first_api_level": "28",
        "bootloader_codename": "sargo",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "crosshatch": {
        "device": "Pixel 3 XL",
        "android_version_end_date": "October 2021",
        "security_update_end_date": "October 2021",
        "first_api_level": "28",
        "bootloader_codename": "crosshatch",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "blueline": {
        "device": "Pixel 3",
        "android_version_end_date": "October 2021",
        "security_update_end_date": "October 2021",
        "first_api_level": "28",
        "bootloader_codename": "blueline-b1c1",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "taimen": {
        "device": "Pixel 2 XL",
        "android_version_end_date": "October 2020",
        "security_update_end_date": "October 2020",
        "first_api_level": "26",
        "bootloader_codename": "taimen",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "walleye": {
        "device": "Pixel 2",
        "android_version_end_date": "October 2020",
        "security_update_end_date": "October 2020",
        "first_api_level": "26",
        "bootloader_codename": "walleye",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "marlin": {
        "device": "Pixel XL",
        "android_version_end_date": "October 2018",
        "security_update_end_date": "October 2018",
        "first_api_level": "25",
        "bootloader_codename": "marlin",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "sailfish": {
        "device": "Pixel",
        "android_version_end_date": "October 2019",
        "security_update_end_date": "October 2019",
        "first_api_level": "25",
        "bootloader_codename": "sailfish",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "ryu": {
        "device": "Pixel C",
        "android_version_end_date": "October 2018",
        "security_update_end_date": "October 2018",
        "first_api_level": "23",
        "bootloader_codename": "ryu",
        "has_init_boot": false,
        "is_pixel_watch": false
    },
    "angler": {
        "device": "Nexus 6P",
        "android_version_end_date": "September 2018",
        "security_update_end_date": "September 2018",
        "first_api_level": "23",
        "bootloader_codename": "angler",
        "has_init_boot": false,
        "is_pixel_watch": false
    }
}

```

`android_versions.json`:

```json
{
    "1": {
        "Name": "Android 1.0",
        "Codename": "",
        "Version": "1.0",
        "Release date": "September 23, 2008",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "2": {
        "Name": "Android Petit Four",
        "Codename": "Petit Four",
        "Version": "1.1",
        "Release date": "February 9, 2009",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "3": {
        "Name": "Android Cupcake",
        "Codename": "Cupcake",
        "Version": "1.5",
        "Release date": "April 27, 2009",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "4": {
        "Name": "Android Donut",
        "Codename": "Donut",
        "Version": "1.6",
        "Release date": "September 15, 2009",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "5": {
        "Name": "Android Eclair",
        "Codename": "Eclair",
        "Version": "2.0",
        "Release date": "October 27, 2009",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "6": {
        "Name": "Android Eclair",
        "Codename": "Eclair",
        "Version": "2.0.1",
        "Release date": "December 3, 2009",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "7": {
        "Name": "Android Eclair",
        "Codename": "Eclair",
        "Version": "2.1",
        "Release date": "January 11, 2010",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "8": {
        "Name": "Android Froyo",
        "Codename": "Froyo",
        "Version": "2.2 – 2.2.3",
        "Release date": "May 20, 2010",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "9": {
        "Name": "Android Gingerbread",
        "Codename": "Gingerbread",
        "Version": "2.3 – 2.3.2",
        "Release date": "December 6, 2010",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "10": {
        "Name": "Android Gingerbread",
        "Codename": "Gingerbread",
        "Version": "2.3.3 – 2.3.7",
        "Release date": "February 9, 2011",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "11": {
        "Name": "Android Honeycomb",
        "Codename": "Honeycomb",
        "Version": "3.0",
        "Release date": "February 22, 2011",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "12": {
        "Name": "Android Honeycomb",
        "Codename": "Honeycomb",
        "Version": "3.1",
        "Release date": "May 10, 2011",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "13": {
        "Name": "Android Honeycomb",
        "Codename": "",
        "Version": "3.2 – 3.2.6",
        "Release date": "July 15, 2011",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "14": {
        "Name": "Android Ice Cream Sandwich",
        "Codename": "Ice Cream Sandwich",
        "Version": "4.0 – 4.0.2",
        "Release date": "October 18, 2011",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "15": {
        "Name": "Android Ice Cream Sandwich",
        "Codename": "Ice Cream Sandwich",
        "Version": "4.0.3 – 4.0.4",
        "Release date": "December 16, 2011",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "16": {
        "Name": "Android Jelly Bean",
        "Codename": "Jelly Bean",
        "Version": "4.1 – 4.1.2",
        "Release date": "July 9, 2012",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "17": {
        "Name": "Android Jelly Bean",
        "Codename": "Jelly Bean",
        "Version": "4.2 – 4.2.2",
        "Release date": "November 13, 2012",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "18": {
        "Name": "Android Jelly Bean",
        "Codename": "Jelly Bean",
        "Version": "4.3 – 4.3.1",
        "Release date": "July 24, 2013",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "19": {
        "Name": "Android KitKat",
        "Codename": "Key Lime Pie",
        "Version": "4.4 – 4.4.4",
        "Release date": "October 31, 2013",
        "Latest update": "October 2017",
        "Attestation Version": "Not Supported"
    },
    "20": {
        "Name": "Android KitKat",
        "Codename": "Key Lime Pie",
        "Version": "4.4W – 4.4W.2",
        "Release date": "June 25, 2014",
        "Latest update": "",
        "Attestation Version": "Not Supported"
    },
    "21": {
        "Name": "Android Lollipop",
        "Codename": "Lemon Meringue Pie",
        "Version": "5.0 – 5.0.2",
        "Release date": "November 4, 2014",
        "Latest update": "November 2017",
        "Attestation Version": "Not Supported"
    },
    "22": {
        "Name": "Android Lollipop",
        "Codename": "Lemon Meringue Pie",
        "Version": "5.1 – 5.1.1",
        "Release date": "March 2, 2015",
        "Latest update": "March 2018",
        "Attestation Version": "Not Supported"
    },
    "23": {
        "Name": "Android Marshmallow",
        "Codename": "Macadamia Nut Cookie",
        "Version": "6.0 – 6.0.1",
        "Release date": "October 2, 2015",
        "Latest update": "August 2018",
        "Attestation Version": "Keymaster 1.0"
    },
    "24": {
        "Name": "Android Nougat",
        "Codename": "New York Cheesecake",
        "Version": "7.0",
        "Release date": "August 22, 2016",
        "Latest update": "August 2019",
        "Attestation Version": "Keymaster 2.0"
    },
    "25": {
        "Name": "Android Nougat",
        "Codename": "New York Cheesecake",
        "Version": "7.1 – 7.1.2",
        "Release date": "October 4, 2016",
        "Latest update": "October 2019",
        "Attestation Version": "Keymaster 2.0"
    },
    "26": {
        "Name": "Android Oreo",
        "Codename": "Oatmeal Cookie",
        "Version": "8.0",
        "Release date": "August 21, 2017",
        "Latest update": "January 2021",
        "Attestation Version": "Keymaster 3.0"
    },
    "27": {
        "Name": "Android Oreo",
        "Codename": "Oatmeal Cookie",
        "Version": "8.1",
        "Release date": "December 5, 2017",
        "Latest update": "October 2021",
        "Attestation Version": "Keymaster 3.0"
    },
    "28": {
        "Name": "Android Pie",
        "Codename": "Pistachio Ice Cream",
        "Version": "9",
        "Release date": "August 6, 2018",
        "Latest update": "January 2022",
        "Attestation Version": "Keymaster 4.0"
    },
    "29": {
        "Name": "Android 10",
        "Codename": "Quince Tart",
        "Version": "10",
        "Release date": "September 3, 2019",
        "Latest update": "February 2023",
        "Attestation Version": "Keymaster 4.1"
    },
    "30": {
        "Name": "Android 11",
        "Codename": "Red Velvet Cake",
        "Version": "11",
        "Release date": "September 8, 2020",
        "Latest update": "February 2024",
        "Attestation Version": "Keymaster 4.1"
    },
    "31": {
        "Name": "Android 12",
        "Codename": "Snow Cone ",
        "Version": "12",
        "Release date": "October 4, 2021",
        "Latest update": "March 2025",
        "Attestation Version": "KeyMint 1.0"
    },
    "32": {
        "Name": "Android 12L",
        "Codename": "Snow Cone v2",
        "Version": "12.1",
        "Release date": "March 7, 2022",
        "Latest update": "March 2025",
        "Attestation Version": "KeyMint 1.0"
    },
    "33": {
        "Name": "Android 13",
        "Codename": "Tiramisu",
        "Version": "13",
        "Release date": "August 15, 2022",
        "Latest update": "March 2025",
        "Attestation Version": "KeyMint 2.0"
    },
    "34": {
        "Name": "Android 14",
        "Codename": "Upside Down Cake",
        "Version": "14",
        "Release date": "October 4, 2023",
        "Latest update": "Present",
        "Attestation Version": "KeyMint 3.0"
    },
    "35": {
        "Name": "Android 15",
        "Codename": "Vanilla Ice Cream",
        "Version": "15",
        "Release date": "September 3, 2024",
        "Latest update": "Present",
        "Attestation Version": "KeyMint 3.0"
    },
    "36": {
        "Name": "Android 16",
        "Codename": "Baklava",
        "Version": "16",
        "Release date": "June 10, 2025",
        "Latest update": "Present",
        "Attestation Version": "KeyMint 4.0"
    }
}

```

`apk.py`:

```py
# This file is part of Androguard.
#
# Copyright (C) 2012, Anthony Desnos <desnos at t0t0.fr>
# All rights reserved.
#
# Androguard is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Androguard is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Androguard.  If not, see <http://www.gnu.org/licenses/>.

import io
from struct import pack, unpack
from xml.sax.saxutils import escape
from datetime import datetime

from xml.dom import minidom

######################################################## AXML FORMAT ########################################################
# Translated from http://code.google.com/p/android4me/source/browse/src/android/content/res/AXmlResourceParser.java
# Ref: https://github.com/tracer0tong/axmlprinter/blob/master/apk.py

UTF8_FLAG = 0x00000100


class StringBlock:
    def __init__(self, buff):
        self.start = buff.get_idx()
        self._cache = {}
        self.header = unpack('<h', buff.read(2))[0]
        self.header_size = unpack('<h', buff.read(2))[0]

        self.chunkSize = unpack('<i', buff.read(4))[0]
        self.stringCount = unpack('<i', buff.read(4))[0]
        self.styleOffsetCount = unpack('<i', buff.read(4))[0]

        self.flags = unpack('<i', buff.read(4))[0]
        self.m_isUTF8 = ((self.flags & UTF8_FLAG) != 0)

        self.stringsOffset = unpack('<i', buff.read(4))[0]
        self.stylesOffset = unpack('<i', buff.read(4))[0]

        self.m_stringOffsets = []
        self.m_styleOffsets = []
        self.m_strings = []
        self.m_styles = []

        for unused in range(0, self.stringCount):
            self.m_stringOffsets.append(unpack('<i', buff.read(4))[0])

        for unused in range(0, self.styleOffsetCount):
            self.m_styleOffsets.append(unpack('<i', buff.read(4))[0])

        size = self.chunkSize - self.stringsOffset
        if self.stylesOffset != 0:
            size = self.stylesOffset - self.stringsOffset

        # FIXME
        if (size % 4) != 0:
            print("ooo")

        for unused in range(0, size):
            self.m_strings.append(unpack('=b', buff.read(1))[0])

        if self.stylesOffset != 0:
            size = self.chunkSize - self.stylesOffset

            # FIXME
            if (size % 4) != 0:
                print("ooo")

            for unused in range(0, size / 4):
                self.m_styles.append(unpack('<i', buff.read(4))[0])

    def getRaw(self, idx):
        if idx in self._cache:
            return self._cache[idx]

        if idx < 0 or not self.m_stringOffsets or idx >= len(self.m_stringOffsets):
            return ""

        offset = self.m_stringOffsets[idx]

        if not self.m_isUTF8:
            length = self.getShort2(self.m_strings, offset)
            offset += 2
            self._cache[idx] = self.decode(self.m_strings, offset, length)
        else:
            offset += self.getVarint(self.m_strings, offset)[1]
            varint = self.getVarint(self.m_strings, offset)

            offset += varint[1]
            length = varint[0]

            self._cache[idx] = self.decode2(self.m_strings, offset, length)

        return self._cache[idx]

    def decode(self, array, offset, length):
        length = length * 2
        length = length + length % 2

        data = bytes()

        for i in range(0, length):
            t_data = pack("=b", self.m_strings[offset + i])
            data += t_data
            if data[-2:] == b"\x00\x00":
                break

        end_zero = data.find(b"\x00\x00")
        if end_zero != -1:
            data = data[:end_zero]
        return data.decode('utf-16')

    def decode2(self, array, offset, length):
        data = bytes()

        for i in range(0, length):
            t_data = pack("=b", self.m_strings[offset + i])
            data += t_data
        return data.decode('utf-8')

    def getVarint(self, array, offset):
        val = array[offset]
        more = (val & 0x80) != 0
        val &= 0x7f

        if not more:
            return val, 1
        return val << 8 | array[offset + 1] & 0xff, 2

    def getShort(self, array, offset):
        value = array[offset / 4]
        # if ((offset % 4) / 2) == 0:
        if offset % 4 == 0:
            return value & 0xFFFF
        else:
            return value >> 16

    def getShort2(self, array, offset):
        return (array[offset + 1] & 0xff) << 8 | array[offset] & 0xff

    def show(self):
        print("StringBlock", hex(self.start), hex(self.header), hex(self.header_size), hex(self.chunkSize), hex(self.stringsOffset), self.m_stringOffsets)
        for i in range(0, len(self.m_stringOffsets)):
            print(i, repr(self.getRaw(i)))

class SV :
    def __init__(self, size, buff) :
        self.__size = size
        self.__value = unpack(self.__size, buff)[0]

    def _get(self) :
        return pack(self.__size, self.__value)

    def __str__(self) :
        return "0x%x" % self.__value

    def __int__(self) :
        return self.__value

    def get_value_buff(self) :
        return self._get()

    def get_value(self) :
        return self.__value

    def set_value(self, attr) :
        self.__value = attr

class BuffHandle:
    def __init__(self, buff):
        self.__buff = buff
        self.__idx = 0

    def size(self):
        return len(self.__buff)

    def set_idx(self, idx):
        self.__idx = idx

    def get_idx(self):
        return self.__idx

    def readNullString(self, size):
        return self.read(size)

    def read_b(self, size) :
        return self.__buff[ self.__idx : self.__idx + size ]

    def read_at(self, offset, size):
        return self.__buff[ offset : offset + size ]

    def read(self, size) :
        if isinstance(size, SV) :
            size = size.value

        buff = self.__buff[ self.__idx : self.__idx + size ]
        self.__idx += size

        return buff

    def end(self) :
        return self.__idx == len(self.__buff)

ATTRIBUTE_IX_NAMESPACE_URI  = 0
ATTRIBUTE_IX_NAME           = 1
ATTRIBUTE_IX_VALUE_STRING   = 2
ATTRIBUTE_IX_VALUE_TYPE     = 3
ATTRIBUTE_IX_VALUE_DATA     = 4
ATTRIBUTE_LENGHT            = 5

CHUNK_AXML_FILE             = 0x00080003
CHUNK_RESOURCEIDS           = 0x00080180
CHUNK_XML_FIRST             = 0x00100100
CHUNK_XML_START_NAMESPACE   = 0x00100100
CHUNK_XML_END_NAMESPACE     = 0x00100101
CHUNK_XML_START_TAG         = 0x00100102
CHUNK_XML_END_TAG           = 0x00100103
CHUNK_XML_TEXT              = 0x00100104
CHUNK_XML_LAST              = 0x00100104

START_DOCUMENT              = 0
END_DOCUMENT                = 1
START_TAG                   = 2
END_TAG                     = 3
TEXT                        = 4


# Utility functions for handling different XML formats
def is_axml_format(raw_buff):
    """Check if the buffer contains AXML binary format"""
    if len(raw_buff) < 8:
        return False
    try:
        magic = unpack('<L', raw_buff[:4])[0]
        return magic == CHUNK_AXML_FILE
    except:
        return False

def is_plain_xml(raw_buff):
    """Check if the buffer contains plain text XML"""
    try:
        # Try to decode as UTF-8 and check for XML declaration or root element
        text = raw_buff.decode('utf-8', errors='ignore')
        return text.strip().startswith('<?xml') or text.strip().startswith('<')
    except:
        return False

def is_android_packages_binary(raw_buff):
    """Check if this is Android's binary packages.xml format"""
    try:
        # Check for characteristic patterns in Android packages binary format
        text = raw_buff.decode('utf-8', errors='ignore')
        # Look for key indicators of the binary packages format
        indicators = ['packages', 'version', 'keysets', 'keyset', 'key-id']
        found_indicators = sum(1 for indicator in indicators if indicator in text)

        # If we find multiple indicators but it's not plain XML, it's likely binary packages format
        if found_indicators >= 2 and not text.strip().startswith('<?xml') and not text.strip().startswith('<'):
            return True
        return False
    except:
        return False

def detect_xml_format(raw_buff):
    """Detect the format of XML data"""
    if is_axml_format(raw_buff):
        return 'axml'
    elif is_plain_xml(raw_buff):
        return 'xml'
    elif is_android_packages_binary(raw_buff):
        return 'android_packages_binary'
    else:
        return 'unknown'

class AXMLParser:
    def __init__(self, raw_buff):
        self.reset()

        self.buff = BuffHandle(raw_buff)

        # Check if this is actually an AXML file by verifying magic header
        if len(raw_buff) < 8:
            raise ValueError("File too small to be AXML format")

        magic = self.buff.read(4)
        file_size = self.buff.read(4)

        # AXML files start with magic number 0x00080003 (CHUNK_AXML_FILE)
        magic_int = unpack('<L', magic)[0]
        if magic_int != CHUNK_AXML_FILE:
            raise ValueError(f"Not an AXML file - invalid magic header: 0x{magic_int:08X}")

        self.sb = StringBlock(self.buff)

        self.m_resourceIDs = []
        self.m_prefixuri = {}
        self.m_uriprefix = {}
        self.m_prefixuriL = []

        self.visited_ns = []

    def reset(self):
        self.m_event = -1
        self.m_lineNumber = -1
        self.m_name = -1
        self.m_namespaceUri = -1
        self.m_attributes = []
        self.m_idAttribute = -1
        self.m_classAttribute = -1
        self.m_styleAttribute = -1

    def next(self):
        self.doNext()
        return self.m_event

    def doNext(self):  # sourcery skip: remove-redundant-if, split-or-ifs
        if self.m_event == END_DOCUMENT:
            return

        event = self.m_event

        self.reset()
        while True:
            chunkType = -1

            # Fake END_DOCUMENT event.
            # if event == END_TAG:
            #     pass

            # START_DOCUMENT
            if event == START_DOCUMENT:
                chunkType = CHUNK_XML_START_TAG
            else:
                if self.buff.end():
                    self.m_event = END_DOCUMENT
                    break
                chunkType = unpack('<L', self.buff.read(4))[0]

            if chunkType == CHUNK_RESOURCEIDS:
                chunkSize = unpack('<L', self.buff.read(4))[0]
                # FIXME
                if chunkSize < 8 or chunkSize % 4 != 0:
                    print("ooo")

                for unused in range(0, int(chunkSize / 4) - 2):
                    self.m_resourceIDs.append(unpack('<L', self.buff.read(4))[0])

                continue

            # FIXME
            if chunkType < CHUNK_XML_FIRST or chunkType > CHUNK_XML_LAST:
                print("ooo")

            # Fake START_DOCUMENT event.
            if chunkType == CHUNK_XML_START_TAG and event == -1:
                self.m_event = START_DOCUMENT
                break

            self.buff.read(4)  # /*chunkSize*/
            lineNumber = unpack('<L', self.buff.read(4))[0]
            self.buff.read(4)  # 0xFFFFFFFF

            if chunkType in [CHUNK_XML_START_NAMESPACE, CHUNK_XML_END_NAMESPACE]:
                if chunkType == CHUNK_XML_START_NAMESPACE:
                    prefix = unpack('<L', self.buff.read(4))[0]
                    uri = unpack('<L', self.buff.read(4))[0]

                    self.m_prefixuri[prefix] = uri
                    self.m_uriprefix[uri] = prefix
                    self.m_prefixuriL.append((prefix, uri))
                    self.ns = uri
                else:
                    self.ns = -1
                    self.buff.read(4)
                    self.buff.read(4)
                    (prefix, uri) = self.m_prefixuriL.pop()
                    #del self.m_prefixuri[ prefix ]
                    #del self.m_uriprefix[ uri ]

                continue

            self.m_lineNumber = lineNumber

            if chunkType == CHUNK_XML_START_TAG:
                self.m_namespaceUri = unpack('<L', self.buff.read(4))[0]
                self.m_name = unpack('<L', self.buff.read(4))[0]

                # FIXME
                self.buff.read(4)  # flags

                attributeCount = unpack('<L', self.buff.read(4))[0]
                self.m_idAttribute = (attributeCount >> 16) - 1
                attributeCount = attributeCount & 0xFFFF
                self.m_classAttribute = unpack('<L', self.buff.read(4))[0]
                self.m_styleAttribute = (self.m_classAttribute >> 16) - 1

                self.m_classAttribute = (self.m_classAttribute & 0xFFFF) - 1

                for unused in range(0, attributeCount * ATTRIBUTE_LENGHT):
                    self.m_attributes.append(unpack('<L', self.buff.read(4))[0])

                for i in range(ATTRIBUTE_IX_VALUE_TYPE, len(self.m_attributes), ATTRIBUTE_LENGHT):
                    self.m_attributes[i] = self.m_attributes[i] >> 24

                self.m_event = START_TAG
                break

            if chunkType == CHUNK_XML_END_TAG:
                self.m_namespaceUri = unpack('<L', self.buff.read(4))[0]
                self.m_name = unpack('<L', self.buff.read(4))[0]
                self.m_event = END_TAG
                break

            if chunkType == CHUNK_XML_TEXT:
                self.m_name = unpack('<L', self.buff.read(4))[0]

                # FIXME
                self.buff.read(4)
                self.buff.read(4)

                self.m_event = TEXT
                break

    def getPrefixByUri(self, uri):
        try:
            return self.m_uriprefix[uri]
        except KeyError:
            return -1

    def getPrefix(self):
        try:
            return self.sb.getRaw(self.m_uriprefix[self.m_namespaceUri])
        except KeyError:
            return ''

    def getName(self):
        if self.m_name == -1 or self.m_event not in [START_TAG, END_TAG]:
            return ''

        return self.sb.getRaw(self.m_name)

    def getText(self) :
        if self.m_name == -1 or self.m_event != TEXT :
            return ''

        return self.sb.getRaw(self.m_name)

    def getNamespacePrefix(self, pos):
        prefix = self.m_prefixuriL[pos][0]
        return self.sb.getRaw(prefix)

    def getNamespaceUri(self, pos):
        uri = self.m_prefixuriL[pos][1]
        return self.sb.getRaw(uri)

    def getXMLNS(self):
        buff = ""
        for i in self.m_uriprefix:
            if i not in self.visited_ns:
                buff += "xmlns:%s=\"%s\"\n" % (self.sb.getRaw(self.m_uriprefix[i]), self.sb.getRaw(self.m_prefixuri[self.m_uriprefix[i]]))
                self.visited_ns.append(i)
        return buff

    def getNamespaceCount(self, pos) :
        pass

    def getAttributeOffset(self, index):
        # FIXME
        if self.m_event != START_TAG:
            print("Current event is not START_TAG.")

        offset = index * 5
        # FIXME
        if offset >= len(self.m_attributes):
            print("Invalid attribute index")

        return offset

    def getAttributeCount(self):
        if self.m_event != START_TAG:
            return -1

        return len(self.m_attributes) / ATTRIBUTE_LENGHT

    def getAttributePrefix(self, index):
        offset = self.getAttributeOffset(index)
        uri = self.m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI]

        prefix = self.getPrefixByUri(uri)

        if prefix == -1:
            return ""

        return self.sb.getRaw(prefix)

    def getAttributeName(self, index) :
        offset = self.getAttributeOffset(index)
        name = self.m_attributes[offset+ATTRIBUTE_IX_NAME]

        if name == -1 :
            return ""

        return self.sb.getRaw( name )

    def getAttributeValueType(self, index) :
        offset = self.getAttributeOffset(index)
        return self.m_attributes[offset+ATTRIBUTE_IX_VALUE_TYPE]

    def getAttributeValueData(self, index) :
        offset = self.getAttributeOffset(index)
        return self.m_attributes[offset+ATTRIBUTE_IX_VALUE_DATA]

    def getAttributeValue(self, index) :
        offset = self.getAttributeOffset(index)
        valueType = self.m_attributes[offset+ATTRIBUTE_IX_VALUE_TYPE]
        if valueType == TYPE_STRING :
            valueString = self.m_attributes[offset+ATTRIBUTE_IX_VALUE_STRING]
            return self.sb.getRaw( valueString )
        # WIP
        return ""
        #int valueData=m_attributes[offset+ATTRIBUTE_IX_VALUE_DATA];
        #return TypedValue.coerceToString(valueType,valueData);

TYPE_ATTRIBUTE          = 2
TYPE_DIMENSION          = 5
TYPE_FIRST_COLOR_INT    = 28
TYPE_FIRST_INT          = 16
TYPE_FLOAT              = 4
TYPE_FRACTION           = 6
TYPE_INT_BOOLEAN        = 18
TYPE_INT_COLOR_ARGB4    = 30
TYPE_INT_COLOR_ARGB8    = 28
TYPE_INT_COLOR_RGB4     = 31
TYPE_INT_COLOR_RGB8     = 29
TYPE_INT_DEC            = 16
TYPE_INT_HEX            = 17
TYPE_LAST_COLOR_INT     = 31
TYPE_LAST_INT           = 31
TYPE_NULL               = 0
TYPE_REFERENCE          = 1
TYPE_STRING             = 3

RADIX_MULTS             =   [ 0.00390625, 3.051758E-005, 1.192093E-007, 4.656613E-010 ]
DIMENSION_UNITS         =   [ "px","dip","sp","pt","in","mm","","" ]
FRACTION_UNITS          =   [ "%","%p","","","","","","" ]

COMPLEX_UNIT_MASK        =   15


class AXMLPrinter:
    def __init__(self, raw_buff):
        # First detect the format of the input
        format_type = detect_xml_format(raw_buff)

        if format_type == 'xml':
            print("\nℹ️ This appears to be plain xml format.\nNo conversion needed.")
            # Already plain text XML, just store it
            self.buff = raw_buff.decode('utf-8') if isinstance(raw_buff, bytes) else raw_buff
            self.xmlns = False
            # No AXML parser needed for plain XML
            self.axml = None
            return
        elif format_type == 'android_packages_binary':
            # This is Android's binary packages format - cannot be parsed as XML
            print("\nℹ️ This appears to be Android's binary packages.xml format, which cannot be converted to readable XML.\nThis is a proprietary binary format used by Android's package manager.")
            # Empty buffer since we can't parse this format
            self.buff = ""
            self.xmlns = False
            # No AXML parser needed
            self.axml = None
            return
        elif format_type == 'axml':
            # Process AXML binary format
            self.axml = AXMLParser(raw_buff)
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR Unknown XML format - not AXML binary, plain XML, or recognized Android binary format")

        self.xmlns = False
        self.buff = ''

        while True:
            _type = self.axml.next()
#           print "tagtype = ", _type

            if _type == START_DOCUMENT:
                self.buff += '<?xml version="1.0" encoding="utf-8"?>\n'
            elif _type == START_TAG:
                # self.buff += '<' + self.getPrefix(self.axml.getPrefix()) + self.axml.getName() + '\n'
                self.buff += f'<{self.getPrefix(self.axml.getPrefix())}{self.axml.getName()}\n'
                self.buff += self.axml.getXMLNS()

                for i in range(0, int(self.axml.getAttributeCount())):
                    self.buff += "%s%s=\"%s\"\n" % ( self.getPrefix(
                        self.axml.getAttributePrefix(i) ), self.axml.getAttributeName(i), self._escape( self.getAttributeValue( i ) ) )

                # Modify by liyansong2018
                # self.buff += '>\n'
                self.buff += '>'

            elif _type == END_TAG :
                # self.buff += "</%s%s>\n" % ( self.getPrefix( self.axml.getPrefix() ), self.axml.getName() )
                # self.buff += "</%s%s>" % ( self.getPrefix( self.axml.getPrefix() ), self.axml.getName() )
                self.buff += f"</{self.getPrefix(self.axml.getPrefix())}{self.axml.getName()}>"

            elif _type == TEXT :
                # self.buff += "%s\n" % self.axml.getText()
                # self.buff += "%s" % self.axml.getText()
                self.buff += f"{self.axml.getText()}"

            elif _type == END_DOCUMENT :
                break

    # pleed patch
    def _escape(self, s):
        s = s.replace("&", "&amp;")
        s = s.replace('"', "&quot;")
        s = s.replace("'", "&apos;")
        s = s.replace("<", "&lt;")
        s = s.replace(">", "&gt;")
        return escape(s)

    def get_buff(self):
        return self.buff

    def get_xml(self):
        if not self.buff:
            return ""
        return minidom.parseString(self.get_buff()).toprettyxml()

    def get_xml_obj(self):
        if not self.buff:
            return None
        return minidom.parseString(self.get_buff())

    def getPrefix(self, prefix):
        if prefix is None or len(prefix) == 0:
            return ''

        return f'{prefix}:'

    def getAttributeValue(self, index):
        # Only process if we have an AXML parser (not plain XML)
        if not self.axml:
            return ""

        _type = self.axml.getAttributeValueType(index)
        _data = self.axml.getAttributeValueData(index)

        if _type == TYPE_STRING:
            return self.axml.getAttributeValue(index)

        elif _type == TYPE_ATTRIBUTE:
            return "?%s%08X" % (self.getPackage(_data), _data)

        elif _type == TYPE_REFERENCE:
            return "@%s%08X" % (self.getPackage(_data), _data)

        elif _type == TYPE_FLOAT:
            return "%f" % unpack("=f", pack("=L", _data))[0]

        elif _type == TYPE_INT_HEX:
            return "0x%08X" % _data

        elif _type == TYPE_INT_BOOLEAN:
            if _data == 0:
                return "false"
            return "true"

        elif _type == TYPE_DIMENSION:
            return "%f%s" % (self.complexToFloat(_data), DIMENSION_UNITS[_data & COMPLEX_UNIT_MASK])

        elif _type == TYPE_FRACTION:
            return "%f%s" % (self.complexToFloat(_data), FRACTION_UNITS[_data & COMPLEX_UNIT_MASK])

        elif _type >= TYPE_FIRST_COLOR_INT and _type <= TYPE_LAST_COLOR_INT:
            return "#%08X" % _data

        elif _type >= TYPE_FIRST_INT and _type <= TYPE_LAST_INT:
            return "%d" % int(_data)

        return "<0x%X, type 0x%02X>" % (_data, _type)

    def complexToFloat(self, xcomplex):
        return (float)(xcomplex & 0xFFFFFF00) * RADIX_MULTS[(xcomplex >> 4) & 3]

    def getPackage(self, id):
        if id >> 24 == 1:
            return "android:"
        return ""

```

`avbtool.py`:

```py
#!/usr/bin/env python3

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright 2016, The Android Open Source Project
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
"""Command-line tool for working with Android Verified Boot images."""

import argparse
import binascii
import bisect
import hashlib
import json
import math
import os
import struct
import subprocess
import sys
import tempfile
import time
import contextlib
import traceback
import rsa
import datetime


# Keep in sync with libavb/avb_version.h.
AVB_VERSION_MAJOR = 1
AVB_VERSION_MINOR = 3
AVB_VERSION_SUB = 0

# Keep in sync with libavb/avb_footer.h.
AVB_FOOTER_VERSION_MAJOR = 1
AVB_FOOTER_VERSION_MINOR = 0

AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = 1

# Configuration for enabling logging of calls to avbtool.
AVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')


class AvbError(Exception):
  """Application-specific errors.

  These errors represent issues for which a stack-trace should not be
  presented.

  Attributes:
    message: Error message.
  """

  def __init__(self, message):
    Exception.__init__(self, message)


class Algorithm(object):
  """Contains details about an algorithm.

  See the avb_vbmeta_image.h file for more details about algorithms.

  The constant |ALGORITHMS| is a dictionary from human-readable
  names (e.g 'SHA256_RSA2048') to instances of this class.

  Attributes:
    algorithm_type: Integer code corresponding to |AvbAlgorithmType|.
    hash_name: Empty or a name from |hashlib.algorithms|.
    hash_num_bytes: Number of bytes used to store the hash.
    signature_num_bytes: Number of bytes used to store the signature.
    public_key_num_bytes: Number of bytes used to store the public key.
    padding: Padding used for signature as bytes, if any.
  """

  def __init__(self, algorithm_type, hash_name, hash_num_bytes,
               signature_num_bytes, public_key_num_bytes, padding):
    self.algorithm_type = algorithm_type
    self.hash_name = hash_name
    self.hash_num_bytes = hash_num_bytes
    self.signature_num_bytes = signature_num_bytes
    self.public_key_num_bytes = public_key_num_bytes
    self.padding = padding


# This must be kept in sync with the avb_crypto.h file.
#
# The PKC1-v1.5 padding is a blob of binary DER of ASN.1 and is
# obtained from section 5.2.2 of RFC 4880.
ALGORITHMS = {
    'NONE': Algorithm(
        algorithm_type=0,        # AVB_ALGORITHM_TYPE_NONE
        hash_name='',
        hash_num_bytes=0,
        signature_num_bytes=0,
        public_key_num_bytes=0,
        padding=b''),
    'SHA256_RSA2048': Algorithm(
        algorithm_type=1,        # AVB_ALGORITHM_TYPE_SHA256_RSA2048
        hash_name='sha256',
        hash_num_bytes=32,
        signature_num_bytes=256,
        public_key_num_bytes=8 + 2*2048//8,
        padding=bytes(bytearray([
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*202 + [0x00] + [
                # ASN.1 header
                0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
                0x00, 0x04, 0x20,
            ]))),
    'SHA256_RSA4096': Algorithm(
        algorithm_type=2,        # AVB_ALGORITHM_TYPE_SHA256_RSA4096
        hash_name='sha256',
        hash_num_bytes=32,
        signature_num_bytes=512,
        public_key_num_bytes=8 + 2*4096//8,
        padding=bytes(bytearray([
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*458 + [0x00] + [
                # ASN.1 header
                0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
                0x00, 0x04, 0x20,
            ]))),
    'SHA256_RSA8192': Algorithm(
        algorithm_type=3,        # AVB_ALGORITHM_TYPE_SHA256_RSA8192
        hash_name='sha256',
        hash_num_bytes=32,
        signature_num_bytes=1024,
        public_key_num_bytes=8 + 2*8192//8,
        padding=bytes(bytearray([
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*970 + [0x00] + [
                # ASN.1 header
                0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
                0x00, 0x04, 0x20,
            ]))),
    'SHA512_RSA2048': Algorithm(
        algorithm_type=4,        # AVB_ALGORITHM_TYPE_SHA512_RSA2048
        hash_name='sha512',
        hash_num_bytes=64,
        signature_num_bytes=256,
        public_key_num_bytes=8 + 2*2048//8,
        padding=bytes(bytearray([
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*170 + [0x00] + [
                # ASN.1 header
                0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
                0x00, 0x04, 0x40
            ]))),
    'SHA512_RSA4096': Algorithm(
        algorithm_type=5,        # AVB_ALGORITHM_TYPE_SHA512_RSA4096
        hash_name='sha512',
        hash_num_bytes=64,
        signature_num_bytes=512,
        public_key_num_bytes=8 + 2*4096//8,
        padding=bytes(bytearray([
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*426 + [0x00] + [
                # ASN.1 header
                0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
                0x00, 0x04, 0x40
            ]))),
    'SHA512_RSA8192': Algorithm(
        algorithm_type=6,        # AVB_ALGORITHM_TYPE_SHA512_RSA8192
        hash_name='sha512',
        hash_num_bytes=64,
        signature_num_bytes=1024,
        public_key_num_bytes=8 + 2*8192//8,
        padding=bytes(bytearray([
            # PKCS1-v1_5 padding
            0x00, 0x01] + [0xff]*938 + [0x00] + [
                # ASN.1 header
                0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
                0x00, 0x04, 0x40
            ]))),
}


def get_release_string():
  """Calculates the release string to use in the VBMeta struct."""
  # Keep in sync with libavb/avb_version.c:avb_version_string().
  return 'avbtool {}.{}.{}'.format(AVB_VERSION_MAJOR,
                                  AVB_VERSION_MINOR,
                                  AVB_VERSION_SUB)


def round_to_multiple(number, size):
  """Rounds a number up to nearest multiple of another number.

  Arguments:
    number: The number to round up.
    size: The multiple to round up to.

  Returns:
    If |number| is a multiple of |size|, returns |number|, otherwise
    returns |number| + |size|.
  """
  remainder = number % size
  if remainder == 0:
    return number
  return number + size - remainder


def round_to_pow2(number):
  """Rounds a number up to the next power of 2.

  Arguments:
    number: The number to round up.

  Returns:
    If |number| is already a power of 2 then |number| is
    returned. Otherwise the smallest power of 2 greater than |number|
    is returned.
  """
  return 2**((number - 1).bit_length())


def encode_long(num_bits, value):
  """Encodes a long to a bytearray() using a given amount of bits.

  This number is written big-endian, e.g. with the most significant
  bit first.

  This is the reverse of decode_long().

  Arguments:
    num_bits: The number of bits to write, e.g. 2048.
    value: The value to write.

  Returns:
    A bytearray() with the encoded long.
  """
  ret = bytearray()
  for bit_pos in range(num_bits, 0, -8):
    octet = (value >> (bit_pos - 8)) & 0xff
    ret.extend(struct.pack('!B', octet))
  return ret


def decode_long(blob):
  """Decodes a long from a bytearray() using a given amount of bits.

  This number is expected to be in big-endian, e.g. with the most
  significant bit first.

  This is the reverse of encode_long().

  Arguments:
    blob: A bytearray() with the encoded long.

  Returns:
    The decoded value.
  """
  ret = 0
  for b in bytearray(blob):
    ret *= 256
    ret += b
  return ret


def egcd(a, b):
  """Calculate greatest common divisor of two numbers.

  This implementation uses a recursive version of the extended
  Euclidean algorithm.

  Arguments:
    a: First number.
    b: Second number.

  Returns:
    A tuple (gcd, x, y) that where |gcd| is the greatest common
    divisor of |a| and |b| and |a|*|x| + |b|*|y| = |gcd|.
  """
  if a == 0:
    return (b, 0, 1)
  g, y, x = egcd(b % a, a)
  return (g, x - (b // a) * y, y)


def modinv(a, m):
  """Calculate modular multiplicative inverse of |a| modulo |m|.

  This calculates the number |x| such that |a| * |x| == 1 (modulo
  |m|). This number only exists if |a| and |m| are co-prime - |None|
  is returned if this isn't true.

  Arguments:
    a: The number to calculate a modular inverse of.
    m: The modulo to use.

  Returns:
    The modular multiplicative inverse of |a| and |m| or |None| if
    these numbers are not co-prime.
  """
  gcd, x, _ = egcd(a, m)
  if gcd != 1:
    return None  # modular inverse does not exist
  return x % m


def parse_number(string):
  """Parse a string as a number.

  This is just a short-hand for int(string, 0) suitable for use in the
  |type| parameter of |ArgumentParser|'s add_argument() function. An
  improvement to just using type=int is that this function supports
  numbers in other bases, e.g. "0x1234".

  Arguments:
    string: The string to parse.

  Returns:
    The parsed integer.

  Raises:
    ValueError: If the number could not be parsed.
  """
  return int(string, 0)


class RSAPublicKey(object):
  """Data structure used for a RSA public key.

  Attributes:
    exponent: The key exponent.
    modulus: The key modulus.
    num_bits: The key size.
    key_path: The path to a key file.
  """

  MODULUS_PREFIX = b'modulus='

  # def __init__(self, key_path):
  #   """Loads and parses an RSA key from either a private or public key file.

  #   Arguments:
  #     key_path: The path to a key file.

  #   Raises:
  #     AvbError: If RSA key parameters could not be read from file.
  #   """
  #   # We used to have something as simple as this:
  #   #
  #   #  key = Crypto.PublicKey.RSA.importKey(open(key_path).read())
  #   #  self.exponent = key.e
  #   #  self.modulus = key.n
  #   #  self.num_bits = key.size() + 1
  #   #
  #   # but unfortunately PyCrypto is not available in the builder. So
  #   # instead just parse openssl(1) output to get this
  #   # information. It's ugly but...
  #   args = ['openssl', 'rsa', '-in', key_path, '-modulus', '-noout']
  #   p = subprocess.Popen(args,
  #                        stdin=subprocess.PIPE,
  #                        stdout=subprocess.PIPE,
  #                        stderr=subprocess.PIPE)
  #   (pout, perr) = p.communicate()
  #   if p.wait() != 0:
  #     # Could be just a public key is passed, try that.
  #     args.append('-pubin')
  #     p = subprocess.Popen(args,
  #                          stdin=subprocess.PIPE,
  #                          stdout=subprocess.PIPE,
  #                          stderr=subprocess.PIPE)
  #     (pout, perr) = p.communicate()
  #     if p.wait() != 0:
  #       raise AvbError('Error getting public key: {}'.format(perr))

  #   if not pout.lower().startswith(self.MODULUS_PREFIX):
  #     raise AvbError('Unexpected modulus output')

  #   modulus_hexstr = pout[len(self.MODULUS_PREFIX):]

  #   # The exponent is assumed to always be 65537 and the number of
  #   # bits can be derived from the modulus by rounding up to the
  #   # nearest power of 2.
  #   self.key_path = key_path
  #   self.modulus = int(modulus_hexstr, 16)
  #   self.num_bits = round_to_pow2(int(math.ceil(math.log(self.modulus, 2))))
  #   self.exponent = 65537

  def __init__(self, key_path):
    """Loads and parses an RSA key from either a private or public key file.

    Arguments:
      key_path: The path to a key file.

    Raises:
      AvbError: If RSA key parameters could not be read from file.
    """
    # Load the private key.
    key = rsa.PrivateKey.load_pkcs1(open(key_path).read())
    self.exponent = key.e
    self.modulus = key.n
    self.num_bits = key.n.bit_length()
    self.key_path = key_path

  def encode(self):
    """Encodes the public RSA key in |AvbRSAPublicKeyHeader| format.

    This creates a |AvbRSAPublicKeyHeader| as well as the two large
    numbers (|key_num_bits| bits long) following it.

    Returns:
      The |AvbRSAPublicKeyHeader| followed by two large numbers as bytes.

    Raises:
      AvbError: If given RSA key exponent is not 65537.
    """
    if self.exponent != 65537:
      raise AvbError('Only RSA keys with exponent 65537 are supported.')
    ret = bytearray()
    # Calculate n0inv = -1/n[0] (mod 2^32)
    b = 2 ** 32
    n0inv = b - modinv(self.modulus, b)
    # Calculate rr = r^2 (mod N), where r = 2^(# of key bits)
    r = 2 ** self.modulus.bit_length()
    rrmodn = r * r % self.modulus
    ret.extend(struct.pack('!II', self.num_bits, n0inv))
    ret.extend(encode_long(self.num_bits, self.modulus))
    ret.extend(encode_long(self.num_bits, rrmodn))
    return bytes(ret)

  def sign(self, algorithm_name, data_to_sign, signing_helper=None, signing_helper_with_files=None):
    """Sign given data using |signing_helper| or rsa (removed openssl).

    rsa (removed openssl) is used if neither the parameters signing_helper nor
    signing_helper_with_files are given.

    Arguments:
      algorithm_name: The algorithm name as per the ALGORITHMS dict.
      data_to_sign: Data to sign as bytes or bytearray.
      signing_helper: Program which signs a hash and returns the signature.
      signing_helper_with_files: Same as signing_helper but uses files instead.

    Returns:
      The signature as bytes.

    Raises:
      AvbError: If an error occurred during signing.
    """
    # Checks requested algorithm for validity.
    algorithm = ALGORITHMS.get(algorithm_name)
    if not algorithm:
      raise AvbError('Algorithm with name {} is not supported.'
                    .format(algorithm_name))

    if self.num_bits != (algorithm.signature_num_bytes * 8):
      raise AvbError('Key size of key ({} bits) does not match key size '
                    '({} bits) of given algorithm {}.'
                     .format(self.num_bits, algorithm.signature_num_bytes * 8,
                            algorithm_name))

    # Hashes the data.
    hasher = hashlib.new(algorithm.hash_name)
    hasher.update(data_to_sign)
    digest = hasher.digest()

    # Calculates the signature.
    padding_and_hash = algorithm.padding + digest
    p = None
    if signing_helper_with_files is not None:
      with tempfile.NamedTemporaryFile() as signing_file:
        signing_file.write(padding_and_hash)
        signing_file.flush()
        p = subprocess.Popen([signing_helper_with_files, algorithm_name,
                              self.key_path, signing_file.name])
        retcode = p.wait()
        if retcode != 0:
          raise AvbError('Error signing')
        signing_file.seek(0)
        signature = signing_file.read()
    else:
      if signing_helper is not None:
        p = subprocess.Popen(
            [signing_helper, algorithm_name, self.key_path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
      else:
        #   p = subprocess.Popen(
        #       ['openssl', 'rsautl', '-sign', '-inkey', self.key_path, '-raw'],
        #       stdin=subprocess.PIPE,
        #       stdout=subprocess.PIPE,
        #       stderr=subprocess.PIPE)
        # (pout, perr) = p.communicate(padding_and_hash)
        # retcode = p.wait()
        # if retcode != 0:
        #   raise AvbError('Error signing: {}'.format(perr))
        # signature = pout

        # Load the private key.
        with open(self.key_path, 'r') as key_file:
          key_data = key_file.read()
          key = rsa.PrivateKey.load_pkcs1(key_data)
        # Perform the raw RSA operation.
        signature = rsa.transform.bytes2int(padding_and_hash)
        signature = rsa.core.decrypt_int(signature, key.d, key.n)
        signature = rsa.transform.int2bytes(signature)
        return signature

    if len(signature) != algorithm.signature_num_bytes:
      raise AvbError('Error signing: Invalid length of signature')
    return signature

def lookup_algorithm_by_type(alg_type):
  """Looks up algorithm by type.

  Arguments:
    alg_type: The integer representing the type.

  Returns:
    A tuple with the algorithm name and an |Algorithm| instance.

  Raises:
    Exception: If the algorithm cannot be found
  """
  for alg_name in ALGORITHMS:
    alg_data = ALGORITHMS[alg_name]
    if alg_data.algorithm_type == alg_type:
      return (alg_name, alg_data)
  raise AvbError('Unknown algorithm type {}'.format(alg_type))


def lookup_hash_size_by_type(alg_type):
  """Looks up hash size by type.

  Arguments:
    alg_type: The integer representing the type.

  Returns:
    The corresponding hash size.

  Raises:
    AvbError: If the algorithm cannot be found.
  """
  for alg_name in ALGORITHMS:
    alg_data = ALGORITHMS[alg_name]
    if alg_data.algorithm_type == alg_type:
      return alg_data.hash_num_bytes
  raise AvbError('Unsupported algorithm type {}'.format(alg_type))


def verify_vbmeta_signature(vbmeta_header, vbmeta_blob):
  """Checks that signature in a vbmeta blob was made by the embedded public key.

  Arguments:
    vbmeta_header: A AvbVBMetaHeader.
    vbmeta_blob: The whole vbmeta blob, including the header as bytes or
        bytearray.

  Returns:
    True if the signature is valid and corresponds to the embedded
    public key. Also returns True if the vbmeta blob is not signed.

  Raises:
    AvbError: If there errors calling out to openssl command during
        signature verification.
  """
  (_, alg) = lookup_algorithm_by_type(vbmeta_header.algorithm_type)
  if not alg.hash_name:
    return True
  header_blob = vbmeta_blob[0:256]
  auth_offset = 256
  aux_offset = auth_offset + vbmeta_header.authentication_data_block_size
  aux_size = vbmeta_header.auxiliary_data_block_size
  aux_blob = vbmeta_blob[aux_offset:aux_offset + aux_size]
  pubkey_offset = aux_offset + vbmeta_header.public_key_offset
  pubkey_size = vbmeta_header.public_key_size
  pubkey_blob = vbmeta_blob[pubkey_offset:pubkey_offset + pubkey_size]

  digest_offset = auth_offset + vbmeta_header.hash_offset
  digest_size = vbmeta_header.hash_size
  digest_blob = vbmeta_blob[digest_offset:digest_offset + digest_size]

  sig_offset = auth_offset + vbmeta_header.signature_offset
  sig_size = vbmeta_header.signature_size
  sig_blob = vbmeta_blob[sig_offset:sig_offset + sig_size]

  # Now that we've got the stored digest, public key, and signature
  # all we need to do is to verify. This is the exactly the same
  # steps as performed in the avb_vbmeta_image_verify() function in
  # libavb/avb_vbmeta_image.c.

  ha = hashlib.new(alg.hash_name)
  ha.update(header_blob)
  ha.update(aux_blob)
  computed_digest = ha.digest()

  if computed_digest != digest_blob:
    return False

  padding_and_digest = alg.padding + computed_digest

  (num_bits,) = struct.unpack('!I', pubkey_blob[0:4])
  modulus_blob = pubkey_blob[8:8 + num_bits//8]
  modulus = decode_long(modulus_blob)
  exponent = 65537

  # We used to have this:
  #
  #  import Crypto.PublicKey.RSA
  #  key = Crypto.PublicKey.RSA.construct((modulus, long(exponent)))
  #  if not key.verify(decode_long(padding_and_digest),
  #                    (decode_long(sig_blob), None)):
  #    return False
  #  return True
  #
  # but since 'avbtool verify_image' is used on the builders we don't want
  # to rely on Crypto.PublicKey.RSA. Instead just use openssl(1) to verify.
  asn1_str = ('asn1=SEQUENCE:pubkeyinfo\n'
              '\n'
              '[pubkeyinfo]\n'
              'algorithm=SEQUENCE:rsa_alg\n'
              'pubkey=BITWRAP,SEQUENCE:rsapubkey\n'
              '\n'
              '[rsa_alg]\n'
              'algorithm=OID:rsaEncryption\n'
              'parameter=NULL\n'
              '\n'
              '[rsapubkey]\n'
              'n=INTEGER:{}\n'
              'e=INTEGER:{}\n').format(hex(modulus).rstrip('L'),
                                      hex(exponent).rstrip('L'))

  with tempfile.NamedTemporaryFile() as asn1_tmpfile:
    asn1_tmpfile.write(asn1_str.encode('ascii'))
    asn1_tmpfile.flush()

    with tempfile.NamedTemporaryFile() as der_tmpfile:
      p = subprocess.Popen(
          ['openssl', 'asn1parse', '-genconf', asn1_tmpfile.name, '-out',
          der_tmpfile.name, '-noout'])
      retcode = p.wait()
      if retcode != 0:
        raise AvbError('Error generating DER file')

      p = subprocess.Popen(
          ['openssl', 'rsautl', '-verify', '-pubin', '-inkey', der_tmpfile.name,
          '-keyform', 'DER', '-raw'],
          stdin=subprocess.PIPE,
          stdout=subprocess.PIPE,
          stderr=subprocess.PIPE)
      (pout, perr) = p.communicate(sig_blob)
      retcode = p.wait()
      if retcode != 0:
        raise AvbError('Error verifying data: {}'.format(perr))
      if pout != padding_and_digest:
        sys.stderr.write('Signature not correct\n')
        return False
  return True


def create_avb_hashtree_hasher(algorithm, salt):
  """Create the hasher for AVB hashtree based on the input algorithm."""

  if algorithm.lower() == 'blake2b-256':
    return hashlib.new('blake2b', salt, digest_size=32)

  return hashlib.new(algorithm, salt)


class ImageChunk(object):
  """Data structure used for representing chunks in Android sparse files.

  Attributes:
    chunk_type: One of TYPE_RAW, TYPE_FILL, or TYPE_DONT_CARE.
    chunk_offset: Offset in the sparse file where this chunk begins.
    output_offset: Offset in de-sparsified file where output begins.
    output_size: Number of bytes in output.
    input_offset: Offset in sparse file for data if TYPE_RAW otherwise None.
    fill_data: Blob with data to fill if TYPE_FILL otherwise None.
  """

  FORMAT = '<2H2I'
  TYPE_RAW = 0xcac1
  TYPE_FILL = 0xcac2
  TYPE_DONT_CARE = 0xcac3
  TYPE_CRC32 = 0xcac4

  def __init__(self, chunk_type, chunk_offset, output_offset, output_size,
              input_offset, fill_data):
    """Initializes an ImageChunk object.

    Arguments:
      chunk_type: One of TYPE_RAW, TYPE_FILL, or TYPE_DONT_CARE.
      chunk_offset: Offset in the sparse file where this chunk begins.
      output_offset: Offset in de-sparsified file.
      output_size: Number of bytes in output.
      input_offset: Offset in sparse file if TYPE_RAW otherwise None.
      fill_data: Blob as bytes with data to fill if TYPE_FILL otherwise None.

    Raises:
      ValueError: If given chunk parameters are invalid.
    """
    self.chunk_type = chunk_type
    self.chunk_offset = chunk_offset
    self.output_offset = output_offset
    self.output_size = output_size
    self.input_offset = input_offset
    self.fill_data = fill_data
    # Check invariants.
    if self.chunk_type == self.TYPE_RAW:
      if self.fill_data is not None:
        raise ValueError('RAW chunk cannot have fill_data set.')
      if not self.input_offset:
        raise ValueError('RAW chunk must have input_offset set.')
    elif self.chunk_type == self.TYPE_FILL:
      if self.fill_data is None:
        raise ValueError('FILL chunk must have fill_data set.')
      if self.input_offset:
        raise ValueError('FILL chunk cannot have input_offset set.')
    elif self.chunk_type == self.TYPE_DONT_CARE:
      if self.fill_data is not None:
        raise ValueError('DONT_CARE chunk cannot have fill_data set.')
      if self.input_offset:
        raise ValueError('DONT_CARE chunk cannot have input_offset set.')
    else:
      raise ValueError('Invalid chunk type')


class ImageHandler(object):
  """Abstraction for image I/O with support for Android sparse images.

  This class provides an interface for working with image files that
  may be using the Android Sparse Image format. When an instance is
  constructed, we test whether it's an Android sparse file. If so,
  operations will be on the sparse file by interpreting the sparse
  format, otherwise they will be directly on the file. Either way the
  operations do the same.

  For reading, this interface mimics a file object - it has seek(),
  tell(), and read() methods. For writing, only truncation
  (truncate()) and appending is supported (append_raw() and
  append_dont_care()). Additionally, data can only be written in units
  of the block size.

  Attributes:
    filename: Name of file.
    is_sparse: Whether the file being operated on is sparse.
    block_size: The block size, typically 4096.
    image_size: The size of the unsparsified file.
  """
  # See system/core/libsparse/sparse_format.h for details.
  MAGIC = 0xed26ff3a
  HEADER_FORMAT = '<I4H4I'

  # These are formats and offset of just the |total_chunks| and
  # |total_blocks| fields.
  NUM_CHUNKS_AND_BLOCKS_FORMAT = '<II'
  NUM_CHUNKS_AND_BLOCKS_OFFSET = 16

  def __init__(self, image_filename, read_only=False):
    """Initializes an image handler.

    Arguments:
      image_filename: The name of the file to operate on.
      read_only: True if file is only opened for read-only operations.

    Raises:
      ValueError: If data in the file is invalid.
    """
    self.filename = image_filename
    self._num_total_blocks = 0
    self._num_total_chunks = 0
    self._file_pos = 0
    self._read_only = read_only
    self._read_header()

  def _read_header(self):
    """Initializes internal data structures used for reading file.

    This may be called multiple times and is typically called after
    modifying the file (e.g. appending, truncation).

    Raises:
      ValueError: If data in the file is invalid.
    """
    self.is_sparse = False
    self.block_size = 4096
    self._file_pos = 0
    if self._read_only:
      self._image = open(self.filename, 'rb')
    else:
      self._image = open(self.filename, 'r+b')
    self._image.seek(0, os.SEEK_END)
    self.image_size = self._image.tell()

    self._image.seek(0, os.SEEK_SET)
    header_bin = self._image.read(struct.calcsize(self.HEADER_FORMAT))
    (magic, major_version, minor_version, file_hdr_sz, chunk_hdr_sz,
    block_size, self._num_total_blocks, self._num_total_chunks,
    _) = struct.unpack(self.HEADER_FORMAT, header_bin)
    if magic != self.MAGIC:
      # Not a sparse image, our job here is done.
      return
    if not (major_version == 1 and minor_version == 0):
      raise ValueError('Encountered sparse image format version {}.{} but '
                      'only 1.0 is supported'.format(major_version,
                                                      minor_version))
    if file_hdr_sz != struct.calcsize(self.HEADER_FORMAT):
      raise ValueError('Unexpected file_hdr_sz value {}.'.
                      format(file_hdr_sz))
    if chunk_hdr_sz != struct.calcsize(ImageChunk.FORMAT):
      raise ValueError('Unexpected chunk_hdr_sz value {}.'.
                      format(chunk_hdr_sz))

    self.block_size = block_size

    # Build an list of chunks by parsing the file.
    self._chunks = []

    # Find the smallest offset where only "Don't care" chunks
    # follow. This will be the size of the content in the sparse
    # image.
    offset = 0
    output_offset = 0
    for _ in range(1, self._num_total_chunks + 1):
      chunk_offset = self._image.tell()

      header_bin = self._image.read(struct.calcsize(ImageChunk.FORMAT))
      (chunk_type, _, chunk_sz, total_sz) = struct.unpack(ImageChunk.FORMAT,
                                                          header_bin)
      data_sz = total_sz - struct.calcsize(ImageChunk.FORMAT)

      if chunk_type == ImageChunk.TYPE_RAW:
        if data_sz != (chunk_sz * self.block_size):
          raise ValueError('Raw chunk input size ({}) does not match output '
                          'size ({})'.
                          format(data_sz, chunk_sz*self.block_size))
        self._chunks.append(ImageChunk(ImageChunk.TYPE_RAW,
                                      chunk_offset,
                                      output_offset,
                                      chunk_sz*self.block_size,
                                      self._image.tell(),
                                      None))
        self._image.seek(data_sz, os.SEEK_CUR)

      elif chunk_type == ImageChunk.TYPE_FILL:
        if data_sz != 4:
          raise ValueError('Fill chunk should have 4 bytes of fill, but this '
                          'has {}'.format(data_sz))
        fill_data = self._image.read(4)
        self._chunks.append(ImageChunk(ImageChunk.TYPE_FILL,
                                      chunk_offset,
                                      output_offset,
                                      chunk_sz*self.block_size,
                                      None,
                                      fill_data))
      elif chunk_type == ImageChunk.TYPE_DONT_CARE:
        if data_sz != 0:
          raise ValueError('Don\'t care chunk input size is non-zero ({})'.
                          format(data_sz))
        self._chunks.append(ImageChunk(ImageChunk.TYPE_DONT_CARE,
                                      chunk_offset,
                                      output_offset,
                                      chunk_sz*self.block_size,
                                      None,
                                      None))
      elif chunk_type == ImageChunk.TYPE_CRC32:
        if data_sz != 4:
          raise ValueError('CRC32 chunk should have 4 bytes of CRC, but '
                          'this has {}'.format(data_sz))
        self._image.read(4)
      else:
        raise ValueError('Unknown chunk type {}'.format(chunk_type))

      offset += chunk_sz
      output_offset += chunk_sz*self.block_size

    # Record where sparse data end.
    self._sparse_end = self._image.tell()

    # Now that we've traversed all chunks, sanity check.
    if self._num_total_blocks != offset:
      raise ValueError('The header said we should have {} output blocks, '
                      'but we saw {}'.format(self._num_total_blocks, offset))
    junk_len = len(self._image.read())
    if junk_len > 0:
      raise ValueError('There were {} bytes of extra data at the end of the '
                      'file.'.format(junk_len))

    # Assign |image_size|.
    self.image_size = output_offset

    # This is used when bisecting in read() to find the initial slice.
    self._chunk_output_offsets = [i.output_offset for i in self._chunks]

    self.is_sparse = True

  def _update_chunks_and_blocks(self):
    """Helper function to update the image header.

    The the |total_chunks| and |total_blocks| fields in the header
    will be set to value of the |_num_total_blocks| and
    |_num_total_chunks| attributes.

    """
    self._image.seek(self.NUM_CHUNKS_AND_BLOCKS_OFFSET, os.SEEK_SET)
    self._image.write(struct.pack(self.NUM_CHUNKS_AND_BLOCKS_FORMAT,
                                  self._num_total_blocks,
                                  self._num_total_chunks))

  def append_dont_care(self, num_bytes):
    """Appends a DONT_CARE chunk to the sparse file.

    The given number of bytes must be a multiple of the block size.

    Arguments:
      num_bytes: Size in number of bytes of the DONT_CARE chunk.

    Raises:
      OSError: If ImageHandler was initialized in read-only mode.
    """
    assert num_bytes % self.block_size == 0

    if self._read_only:
      raise OSError('ImageHandler is in read-only mode.')

    if not self.is_sparse:
      self._image.seek(0, os.SEEK_END)
      # This is more efficient that writing NUL bytes since it'll add
      # a hole on file systems that support sparse files (native
      # sparse, not Android sparse).
      self._image.truncate(self._image.tell() + num_bytes)
      self._read_header()
      return

    self._num_total_chunks += 1
    self._num_total_blocks += num_bytes // self.block_size
    self._update_chunks_and_blocks()

    self._image.seek(self._sparse_end, os.SEEK_SET)
    self._image.write(struct.pack(ImageChunk.FORMAT,
                                  ImageChunk.TYPE_DONT_CARE,
                                  0,  # Reserved
                                  num_bytes // self.block_size,
                                  struct.calcsize(ImageChunk.FORMAT)))
    self._read_header()

  def append_raw(self, data, multiple_block_size=True):
    """Appends a RAW chunk to the sparse file.

    The length of the given data must be a multiple of the block size,
    unless |multiple_block_size| is False.

    Arguments:
      data: Data to append as bytes.
      multiple_block_size: whether to check the length of the
        data is a multiple of the block size.

    Raises:
      OSError: If ImageHandler was initialized in read-only mode.
    """
    if multiple_block_size:
      assert len(data) % self.block_size == 0

    if self._read_only:
      raise OSError('ImageHandler is in read-only mode.')

    if not self.is_sparse:
      self._image.seek(0, os.SEEK_END)
      self._image.write(data)
      self._read_header()
      return

    self._num_total_chunks += 1
    self._num_total_blocks += len(data) // self.block_size
    self._update_chunks_and_blocks()

    self._image.seek(self._sparse_end, os.SEEK_SET)
    self._image.write(struct.pack(ImageChunk.FORMAT,
                                  ImageChunk.TYPE_RAW,
                                  0,  # Reserved
                                  len(data) // self.block_size,
                                  len(data) +
                                  struct.calcsize(ImageChunk.FORMAT)))
    self._image.write(data)
    self._read_header()

  def append_fill(self, fill_data, size):
    """Appends a fill chunk to the sparse file.

    The total length of the fill data must be a multiple of the block size.

    Arguments:
      fill_data: Fill data to append - must be four bytes.
      size: Number of chunk - must be a multiple of four and the block size.

    Raises:
      OSError: If ImageHandler was initialized in read-only mode.
    """
    assert len(fill_data) == 4
    assert size % 4 == 0
    assert size % self.block_size == 0

    if self._read_only:
      raise OSError('ImageHandler is in read-only mode.')

    if not self.is_sparse:
      self._image.seek(0, os.SEEK_END)
      self._image.write(fill_data * (size//4))
      self._read_header()
      return

    self._num_total_chunks += 1
    self._num_total_blocks += size // self.block_size
    self._update_chunks_and_blocks()

    self._image.seek(self._sparse_end, os.SEEK_SET)
    self._image.write(struct.pack(ImageChunk.FORMAT,
                                  ImageChunk.TYPE_FILL,
                                  0,  # Reserved
                                  size // self.block_size,
                                  4 + struct.calcsize(ImageChunk.FORMAT)))
    self._image.write(fill_data)
    self._read_header()

  def seek(self, offset):
    """Sets the cursor position for reading from unsparsified file.

    Arguments:
      offset: Offset to seek to from the beginning of the file.

    Raises:
      RuntimeError: If the given offset is negative.
    """
    if offset < 0:
      raise RuntimeError('Seeking with negative offset: {}'.format(offset))
    self._file_pos = offset

  def read(self, size):
    """Reads data from the unsparsified file.

    This method may return fewer than |size| bytes of data if the end
    of the file was encountered.

    The file cursor for reading is advanced by the number of bytes
    read.

    Arguments:
      size: Number of bytes to read.

    Returns:
      The data as bytes.
    """
    if not self.is_sparse:
      self._image.seek(self._file_pos)
      data = self._image.read(size)
      self._file_pos += len(data)
      return data

    # Iterate over all chunks.
    chunk_idx = bisect.bisect_right(self._chunk_output_offsets,
                                    self._file_pos) - 1
    data = bytearray()
    to_go = size
    while to_go > 0:
      chunk = self._chunks[chunk_idx]
      chunk_pos_offset = self._file_pos - chunk.output_offset
      chunk_pos_to_go = min(chunk.output_size - chunk_pos_offset, to_go)

      if chunk.chunk_type == ImageChunk.TYPE_RAW:
        self._image.seek(chunk.input_offset + chunk_pos_offset)
        data.extend(self._image.read(chunk_pos_to_go))
      elif chunk.chunk_type == ImageChunk.TYPE_FILL:
        all_data = chunk.fill_data*(chunk_pos_to_go // len(chunk.fill_data) + 2)
        offset_mod = chunk_pos_offset % len(chunk.fill_data)
        data.extend(all_data[offset_mod:(offset_mod + chunk_pos_to_go)])
      else:
        assert chunk.chunk_type == ImageChunk.TYPE_DONT_CARE
        data.extend(b'\0' * chunk_pos_to_go)

      to_go -= chunk_pos_to_go
      self._file_pos += chunk_pos_to_go
      chunk_idx += 1
      # Generate partial read in case of EOF.
      if chunk_idx >= len(self._chunks):
        break

    return bytes(data)

  def tell(self):
    """Returns the file cursor position for reading from unsparsified file.

    Returns:
      The file cursor position for reading.
    """
    return self._file_pos

  def truncate(self, size):
    """Truncates the unsparsified file.

    Arguments:
      size: Desired size of unsparsified file.

    Raises:
      ValueError: If desired size isn't a multiple of the block size.
      OSError: If ImageHandler was initialized in read-only mode.
    """
    if self._read_only:
      raise OSError('ImageHandler is in read-only mode.')

    if not self.is_sparse:
      self._image.truncate(size)
      self._read_header()
      return

    if size % self.block_size != 0:
      raise ValueError('Cannot truncate to a size which is not a multiple '
                      'of the block size')

    if size == self.image_size:
      # Trivial where there's nothing to do.
      return

    if size < self.image_size:
      chunk_idx = bisect.bisect_right(self._chunk_output_offsets, size) - 1
      chunk = self._chunks[chunk_idx]
      if chunk.output_offset != size:
        # Truncation in the middle of a trunk - need to keep the chunk
        # and modify it.
        chunk_idx_for_update = chunk_idx + 1
        num_to_keep = size - chunk.output_offset
        assert num_to_keep % self.block_size == 0
        if chunk.chunk_type == ImageChunk.TYPE_RAW:
          truncate_at = (chunk.chunk_offset +
                        struct.calcsize(ImageChunk.FORMAT) + num_to_keep)
          data_sz = num_to_keep
        elif chunk.chunk_type == ImageChunk.TYPE_FILL:
          truncate_at = (chunk.chunk_offset +
                        struct.calcsize(ImageChunk.FORMAT) + 4)
          data_sz = 4
        else:
          assert chunk.chunk_type == ImageChunk.TYPE_DONT_CARE
          truncate_at = chunk.chunk_offset + struct.calcsize(ImageChunk.FORMAT)
          data_sz = 0
        chunk_sz = num_to_keep // self.block_size
        total_sz = data_sz + struct.calcsize(ImageChunk.FORMAT)
        self._image.seek(chunk.chunk_offset)
        self._image.write(struct.pack(ImageChunk.FORMAT,
                                      chunk.chunk_type,
                                      0,  # Reserved
                                      chunk_sz,
                                      total_sz))
        chunk.output_size = num_to_keep
      else:
        # Truncation at trunk boundary.
        truncate_at = chunk.chunk_offset
        chunk_idx_for_update = chunk_idx

      self._num_total_chunks = chunk_idx_for_update
      self._num_total_blocks = 0
      for i in range(0, chunk_idx_for_update):
        self._num_total_blocks += self._chunks[i].output_size // self.block_size
      self._update_chunks_and_blocks()
      self._image.truncate(truncate_at)

      # We've modified the file so re-read all data.
      self._read_header()
    else:
      # Truncating to grow - just add a DONT_CARE section.
      self.append_dont_care(size - self.image_size)


class AvbDescriptor(object):
  """Class for AVB descriptor.

  See the |AvbDescriptor| C struct for more information.

  Attributes:
    tag: The tag identifying what kind of descriptor this is.
    data: The data in the descriptor.
  """

  SIZE = 16
  FORMAT_STRING = ('!QQ')  # tag, num_bytes_following (descriptor header)

  def __init__(self, data):
    """Initializes a new property descriptor.

    Arguments:
      data: If not None, must be a bytearray().

    Raises:
      LookupError: If the given descriptor is malformed.
    """
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (self.tag, num_bytes_following) = (
          struct.unpack(self.FORMAT_STRING, data[0:self.SIZE]))
      self.data = data[self.SIZE:self.SIZE + num_bytes_following]
    else:
      self.tag = None
      self.data = None

  def print_desc(self, o):
    """Print the descriptor.

    Arguments:
      o: The object to write the output to.
    """
    o.write('    Unknown descriptor:\n')
    o.write('      Tag:  {}\n'.format(self.tag))
    if len(self.data) < 256:
      o.write('      Data: {} ({} bytes)\n'.format(
          repr(str(self.data)), len(self.data)))
    else:
      o.write('      Data: {} bytes\n'.format(len(self.data)))

  def encode(self):
    """Serializes the descriptor.

    Returns:
      A bytearray() with the descriptor data.
    """
    num_bytes_following = len(self.data)
    nbf_with_padding = round_to_multiple(num_bytes_following, 8)
    padding_size = nbf_with_padding - num_bytes_following
    desc = struct.pack(self.FORMAT_STRING, self.tag, nbf_with_padding)
    padding = struct.pack(str(padding_size) + 'x')
    ret = desc + self.data + padding
    return bytearray(ret)

  def verify(self, image_dir, image_ext, expected_chain_partitions_map,
             image_containing_descriptor, accept_zeroed_hashtree):
    """Verifies contents of the descriptor - used in verify_image sub-command.

    Arguments:
      image_dir: The directory of the file being verified.
      image_ext: The extension of the file being verified (e.g. '.img').
      expected_chain_partitions_map: A map from partition name to the
          tuple (rollback_index_location, key_blob).
      image_containing_descriptor: The image the descriptor is in.
      accept_zeroed_hashtree: If True, don't fail if hashtree or FEC data is
          zeroed out.

    Returns:
      True if the descriptor verifies, False otherwise.
    """
    # Deletes unused parameters to prevent pylint warning unused-argument.
    del image_dir, image_ext, expected_chain_partitions_map
    del image_containing_descriptor, accept_zeroed_hashtree

    # Nothing to do.
    return True


class AvbPropertyDescriptor(AvbDescriptor):
  """A class for property descriptors.

  See the |AvbPropertyDescriptor| C struct for more information.

  Attributes:
    key: The key as string.
    value: The value as bytes.
  """

  TAG = 0
  SIZE = 32
  FORMAT_STRING = ('!QQ'  # tag, num_bytes_following (descriptor header)
                  'Q'    # key size (bytes)
                  'Q')   # value size (bytes)

  def __init__(self, data=None):
    """Initializes a new property descriptor.

    Arguments:
      data: If not None, must be as bytes of size |SIZE|.

    Raises:
      LookupError: If the given descriptor is malformed.
    """
    super().__init__(None)
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (tag, num_bytes_following, key_size,
      value_size) = struct.unpack(self.FORMAT_STRING, data[0:self.SIZE])
      expected_size = round_to_multiple(
          self.SIZE - 16 + key_size + 1 + value_size + 1, 8)
      if tag != self.TAG or num_bytes_following != expected_size:
        raise LookupError('Given data does not look like a property '
                          'descriptor.')
      try:
        self.key = data[self.SIZE:(self.SIZE + key_size)].decode('utf-8')
      except UnicodeDecodeError as e:
        raise LookupError('Key cannot be decoded as UTF-8: {}.'
                          .format(e)) from e
      self.value = data[(self.SIZE + key_size + 1):(self.SIZE + key_size + 1 +
                                                    value_size)]
    else:
      self.key = ''
      self.value = b''

  def print_desc(self, o):
    """Print the descriptor.

    Arguments:
      o: The object to write the output to.
    """
    # Go forward with python 3, bytes are represented with the 'b' prefix,
    # e.g. b'foobar'. Thus, we trim off the 'b' to keep the print output
    # the same between python 2 and python 3.
    printable_value = repr(self.value)
    if printable_value.startswith('b\''):
      printable_value = printable_value[1:]

    if len(self.value) < 256:
      o.write('    Prop: {} -> {}\n'.format(self.key, printable_value))
    else:
      o.write('    Prop: {} -> ({} bytes)\n'.format(self.key, len(self.value)))

  def encode(self):
    """Serializes the descriptor.

    Returns:
      The descriptor data as bytes.
    """
    key_encoded = self.key.encode('utf-8')
    num_bytes_following = (
        self.SIZE + len(key_encoded) + len(self.value) + 2 - 16)
    nbf_with_padding = round_to_multiple(num_bytes_following, 8)
    padding_size = nbf_with_padding - num_bytes_following
    desc = struct.pack(self.FORMAT_STRING, self.TAG, nbf_with_padding,
                      len(key_encoded), len(self.value))
    ret = (desc + key_encoded + b'\0' + self.value + b'\0' +
           padding_size * b'\0')
    return ret

  def verify(self, image_dir, image_ext, expected_chain_partitions_map,
            image_containing_descriptor, accept_zeroed_hashtree):
    """Verifies contents of the descriptor - used in verify_image sub-command.

    Arguments:
      image_dir: The directory of the file being verified.
      image_ext: The extension of the file being verified (e.g. '.img').
      expected_chain_partitions_map: A map from partition name to the
          tuple (rollback_index_location, key_blob).
      image_containing_descriptor: The image the descriptor is in.
      accept_zeroed_hashtree: If True, don't fail if hashtree or FEC data is
          zeroed out.

    Returns:
      True if the descriptor verifies, False otherwise.
    """
    # Nothing to do.
    return True


class AvbHashtreeDescriptor(AvbDescriptor):
  """A class for hashtree descriptors.

  See the |AvbHashtreeDescriptor| C struct for more information.

  Attributes:
    dm_verity_version: dm-verity version used.
    image_size: Size of the image, after rounding up to |block_size|.
    tree_offset: Offset of the hash tree in the file.
    tree_size: Size of the tree.
    data_block_size: Data block size.
    hash_block_size: Hash block size.
    fec_num_roots: Number of roots used for FEC (0 if FEC is not used).
    fec_offset: Offset of FEC data (0 if FEC is not used).
    fec_size: Size of FEC data (0 if FEC is not used).
    hash_algorithm: Hash algorithm used as string.
    partition_name: Partition name as string.
    salt: Salt used as bytes.
    root_digest: Root digest as bytes.
    flags: Descriptor flags (see avb_hashtree_descriptor.h).
  """

  TAG = 1
  RESERVED = 60
  SIZE = 120 + RESERVED
  FORMAT_STRING = ('!QQ'  # tag, num_bytes_following (descriptor header)
                  'L'    # dm-verity version used
                  'Q'    # image size (bytes)
                  'Q'    # tree offset (bytes)
                  'Q'    # tree size (bytes)
                  'L'    # data block size (bytes)
                  'L'    # hash block size (bytes)
                  'L'    # FEC number of roots
                  'Q'    # FEC offset (bytes)
                  'Q'    # FEC size (bytes)
                  '32s'  # hash algorithm used
                  'L'    # partition name (bytes)
                  'L'    # salt length (bytes)
                  'L'    # root digest length (bytes)
                  'L' +  # flags
                  str(RESERVED) + 's')  # reserved

  FLAGS_DO_NOT_USE_AB = (1 << 0)
  FLAGS_CHECK_AT_MOST_ONCE = (1 << 1)

  def __init__(self, data=None):
    """Initializes a new hashtree descriptor.

    Arguments:
      data: If not None, must be bytes of size |SIZE|.

    Raises:
      LookupError: If the given descriptor is malformed.
    """
    super().__init__(None)
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (tag, num_bytes_following, self.dm_verity_version, self.image_size,
      self.tree_offset, self.tree_size, self.data_block_size,
      self.hash_block_size, self.fec_num_roots, self.fec_offset, self.fec_size,
      self.hash_algorithm, partition_name_len, salt_len,
      root_digest_len, self.flags, _) = struct.unpack(self.FORMAT_STRING,
                                                      data[0:self.SIZE])
      expected_size = round_to_multiple(
          self.SIZE - 16 + partition_name_len + salt_len + root_digest_len, 8)
      if tag != self.TAG or num_bytes_following != expected_size:
        raise LookupError('Given data does not look like a hashtree '
                          'descriptor.')
      # Nuke NUL-bytes at the end.
      self.hash_algorithm = self.hash_algorithm.rstrip(b'\0').decode('ascii')
      o = 0
      try:
        self.partition_name = data[
            (self.SIZE + o):(self.SIZE + o + partition_name_len)
        ].decode('utf-8')
      except UnicodeDecodeError as e:
        raise LookupError('Partition name cannot be decoded as UTF-8: {}.'
                          .format(e)) from e
      o += partition_name_len
      self.salt = data[(self.SIZE + o):(self.SIZE + o + salt_len)]
      o += salt_len
      self.root_digest = data[(self.SIZE + o):(self.SIZE + o + root_digest_len)]

      if root_digest_len != self._hashtree_digest_size():
        if root_digest_len != 0:
          raise LookupError('root_digest_len doesn\'t match hash algorithm')

    else:
      self.dm_verity_version = 0
      self.image_size = 0
      self.tree_offset = 0
      self.tree_size = 0
      self.data_block_size = 0
      self.hash_block_size = 0
      self.fec_num_roots = 0
      self.fec_offset = 0
      self.fec_size = 0
      self.hash_algorithm = ''
      self.partition_name = ''
      self.salt = b''
      self.root_digest = b''
      self.flags = 0

  def _hashtree_digest_size(self):
    return len(create_avb_hashtree_hasher(self.hash_algorithm, b'').digest())

  def print_desc(self, o):
    """Print the descriptor.

    Arguments:
      o: The object to write the output to.
    """
    o.write('    Hashtree descriptor:\n')
    o.write('      Version of dm-verity:  {}\n'.format(self.dm_verity_version))
    o.write('      Image Size:            {} bytes\n'.format(self.image_size))
    o.write('      Tree Offset:           {}\n'.format(self.tree_offset))
    o.write('      Tree Size:             {} bytes\n'.format(self.tree_size))
    o.write('      Data Block Size:       {} bytes\n'.format(
        self.data_block_size))
    o.write('      Hash Block Size:       {} bytes\n'.format(
        self.hash_block_size))
    o.write('      FEC num roots:         {}\n'.format(self.fec_num_roots))
    o.write('      FEC offset:            {}\n'.format(self.fec_offset))
    o.write('      FEC size:              {} bytes\n'.format(self.fec_size))
    o.write('      Hash Algorithm:        {}\n'.format(self.hash_algorithm))
    o.write('      Partition Name:        {}\n'.format(self.partition_name))
    o.write('      Salt:                  {}\n'.format(self.salt.hex()))
    o.write('      Root Digest:           {}\n'.format(self.root_digest.hex()))
    o.write('      Flags:                 {}\n'.format(self.flags))

  def encode(self):
    """Serializes the descriptor.

    Returns:
      The descriptor data as bytes.
    """
    hash_algorithm_encoded = self.hash_algorithm.encode('ascii')
    partition_name_encoded = self.partition_name.encode('utf-8')
    num_bytes_following = (self.SIZE + len(partition_name_encoded)
                          + len(self.salt) + len(self.root_digest) - 16)
    nbf_with_padding = round_to_multiple(num_bytes_following, 8)
    padding_size = nbf_with_padding - num_bytes_following
    desc = struct.pack(self.FORMAT_STRING, self.TAG, nbf_with_padding,
                      self.dm_verity_version, self.image_size,
                      self.tree_offset, self.tree_size, self.data_block_size,
                      self.hash_block_size, self.fec_num_roots,
                      self.fec_offset, self.fec_size, hash_algorithm_encoded,
                      len(partition_name_encoded), len(self.salt),
                       len(self.root_digest), self.flags, self.RESERVED * b'\0')
    ret = (desc + partition_name_encoded + self.salt + self.root_digest +
           padding_size * b'\0')
    return ret

  def verify(self, image_dir, image_ext, expected_chain_partitions_map,
            image_containing_descriptor, accept_zeroed_hashtree):
    """Verifies contents of the descriptor - used in verify_image sub-command.

    Arguments:
      image_dir: The directory of the file being verified.
      image_ext: The extension of the file being verified (e.g. '.img').
      expected_chain_partitions_map: A map from partition name to the
          tuple (rollback_index_location, key_blob).
      image_containing_descriptor: The image the descriptor is in.
      accept_zeroed_hashtree: If True, don't fail if hashtree or FEC data is
          zeroed out.

    Returns:
      True if the descriptor verifies, False otherwise.
    """
    if not self.partition_name:
      image_filename = image_containing_descriptor.filename
      image = image_containing_descriptor
    else:
      image_filename = os.path.join(image_dir, self.partition_name + image_ext)
      image = ImageHandler(image_filename, read_only=True)
    # Generate the hashtree and checks that it matches what's in the file.
    digest_size = self._hashtree_digest_size()
    digest_padding = round_to_pow2(digest_size) - digest_size
    (hash_level_offsets, tree_size) = calc_hash_level_offsets(
        self.image_size, self.data_block_size, digest_size + digest_padding)
    root_digest, hash_tree = generate_hash_tree(image, self.image_size,
                                                self.data_block_size,
                                                self.hash_algorithm, self.salt,
                                                digest_padding,
                                                hash_level_offsets,
                                                tree_size)
    # The root digest must match unless it is not embedded in the descriptor.
    if self.root_digest and root_digest != self.root_digest:
      sys.stderr.write('hashtree of {} does not match descriptor\n'.
                      format(image_filename))
      return False
    # ... also check that the on-disk hashtree matches
    image.seek(self.tree_offset)
    hash_tree_ondisk = image.read(self.tree_size)
    is_zeroed = (self.tree_size == 0) or (hash_tree_ondisk[0:8] == b'ZeRoHaSH')
    if is_zeroed and accept_zeroed_hashtree:
      print('{}: skipping verification since hashtree is zeroed and '
            '--accept_zeroed_hashtree was given'
            .format(self.partition_name))
    else:
      if hash_tree != hash_tree_ondisk:
        sys.stderr.write('hashtree of {} contains invalid data\n'.
                        format(image_filename))
        return False
      print('{}: Successfully verified {} hashtree of {} for image of {} bytes'
            .format(self.partition_name, self.hash_algorithm, image.filename,
                    self.image_size))
    # TODO(zeuthen): we could also verify that the FEC stored in the image is
    # correct but this a) currently requires the 'fec' binary; and b) takes a
    # long time; and c) is not strictly needed for verification purposes as
    # we've already verified the root hash.
    return True


class AvbHashDescriptor(AvbDescriptor):
  """A class for hash descriptors.

  See the |AvbHashDescriptor| C struct for more information.

  Attributes:
    image_size: Image size, in bytes.
    hash_algorithm: Hash algorithm used as string.
    partition_name: Partition name as string.
    salt: Salt used as bytes.
    digest: The hash value of salt and data combined as bytes.
    flags: The descriptor flags (see avb_hash_descriptor.h).
  """

  TAG = 2
  RESERVED = 60
  SIZE = 72 + RESERVED
  FORMAT_STRING = ('!QQ'  # tag, num_bytes_following (descriptor header)
                  'Q'    # image size (bytes)
                  '32s'  # hash algorithm used
                  'L'    # partition name (bytes)
                  'L'    # salt length (bytes)
                  'L'    # digest length (bytes)
                  'L' +  # flags
                  str(RESERVED) + 's')  # reserved

  def __init__(self, data=None):
    """Initializes a new hash descriptor.

    Arguments:
      data: If not None, must be bytes of size |SIZE|.

    Raises:
      LookupError: If the given descriptor is malformed.
    """
    super().__init__(None)
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (tag, num_bytes_following, self.image_size, self.hash_algorithm,
      partition_name_len, salt_len,
      digest_len, self.flags, _) = struct.unpack(self.FORMAT_STRING,
                                                  data[0:self.SIZE])
      expected_size = round_to_multiple(
          self.SIZE - 16 + partition_name_len + salt_len + digest_len, 8)
      if tag != self.TAG or num_bytes_following != expected_size:
        raise LookupError('Given data does not look like a hash descriptor.')
      # Nuke NUL-bytes at the end.
      self.hash_algorithm = self.hash_algorithm.rstrip(b'\0').decode('ascii')
      o = 0
      try:
        self.partition_name = data[
            (self.SIZE + o):(self.SIZE + o + partition_name_len)
        ].decode('utf-8')
      except UnicodeDecodeError as e:
        raise LookupError('Partition name cannot be decoded as UTF-8: {}.'
                          .format(e)) from e
      o += partition_name_len
      self.salt = data[(self.SIZE + o):(self.SIZE + o + salt_len)]
      o += salt_len
      self.digest = data[(self.SIZE + o):(self.SIZE + o + digest_len)]
      if digest_len != len(hashlib.new(self.hash_algorithm).digest()):
        if digest_len != 0:
          raise LookupError('digest_len doesn\'t match hash algorithm')

    else:
      self.image_size = 0
      self.hash_algorithm = ''
      self.partition_name = ''
      self.salt = b''
      self.digest = b''
      self.flags = 0

  def print_desc(self, o):
    """Print the descriptor.

    Arguments:
      o: The object to write the output to.
    """
    o.write('    Hash descriptor:\n')
    o.write('      Image Size:            {} bytes\n'.format(self.image_size))
    o.write('      Hash Algorithm:        {}\n'.format(self.hash_algorithm))
    o.write('      Partition Name:        {}\n'.format(self.partition_name))
    o.write('      Salt:                  {}\n'.format(self.salt.hex()))
    o.write('      Digest:                {}\n'.format(self.digest.hex()))
    o.write('      Flags:                 {}\n'.format(self.flags))

  def encode(self):
    """Serializes the descriptor.

    Returns:
      The descriptor data as bytes.
    """
    hash_algorithm_encoded = self.hash_algorithm.encode('ascii')
    partition_name_encoded = self.partition_name.encode('utf-8')
    num_bytes_following = (self.SIZE + len(partition_name_encoded) +
                          len(self.salt) + len(self.digest) - 16)
    nbf_with_padding = round_to_multiple(num_bytes_following, 8)
    padding_size = nbf_with_padding - num_bytes_following
    desc = struct.pack(self.FORMAT_STRING, self.TAG, nbf_with_padding,
                      self.image_size, hash_algorithm_encoded,
                      len(partition_name_encoded), len(self.salt),
                       len(self.digest), self.flags, self.RESERVED * b'\0')
    ret = (desc + partition_name_encoded + self.salt + self.digest +
           padding_size * b'\0')
    return ret

  def verify(self, image_dir, image_ext, expected_chain_partitions_map,
            image_containing_descriptor, accept_zeroed_hashtree):
    """Verifies contents of the descriptor - used in verify_image sub-command.

    Arguments:
      image_dir: The directory of the file being verified.
      image_ext: The extension of the file being verified (e.g. '.img').
      expected_chain_partitions_map: A map from partition name to the
          tuple (rollback_index_location, key_blob).
      image_containing_descriptor: The image the descriptor is in.
      accept_zeroed_hashtree: If True, don't fail if hashtree or FEC data is
          zeroed out.

    Returns:
      True if the descriptor verifies, False otherwise.
    """
    if not self.partition_name:
      image_filename = image_containing_descriptor.filename
      image = image_containing_descriptor
    else:
      image_filename = os.path.join(image_dir, self.partition_name + image_ext)
      image = ImageHandler(image_filename, read_only=True)
    data = image.read(self.image_size)
    ha = hashlib.new(self.hash_algorithm)
    ha.update(self.salt)
    ha.update(data)
    digest = ha.digest()
    # The digest must match unless there is no digest in the descriptor.
    if self.digest and digest != self.digest:
      sys.stderr.write('{} digest of {} does not match digest in descriptor\n'.
                      format(self.hash_algorithm, image_filename))
      return False
    print('{}: Successfully verified {} hash of {} for image of {} bytes'
          .format(self.partition_name, self.hash_algorithm, image.filename,
                  self.image_size))
    return True


class AvbKernelCmdlineDescriptor(AvbDescriptor):
  """A class for kernel command-line descriptors.

  See the |AvbKernelCmdlineDescriptor| C struct for more information.

  Attributes:
    flags: Flags.
    kernel_cmdline: The kernel command-line as string.
  """

  TAG = 3
  SIZE = 24
  FORMAT_STRING = ('!QQ'  # tag, num_bytes_following (descriptor header)
                  'L'    # flags
                  'L')   # cmdline length (bytes)

  FLAGS_USE_ONLY_IF_HASHTREE_NOT_DISABLED = (1 << 0)
  FLAGS_USE_ONLY_IF_HASHTREE_DISABLED = (1 << 1)

  def __init__(self, data=None):
    """Initializes a new kernel cmdline descriptor.

    Arguments:
      data: If not None, must be bytes of size |SIZE|.

    Raises:
      LookupError: If the given descriptor is malformed.
    """
    super().__init__(None)
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (tag, num_bytes_following, self.flags, kernel_cmdline_length) = (
          struct.unpack(self.FORMAT_STRING, data[0:self.SIZE]))
      expected_size = round_to_multiple(self.SIZE - 16 + kernel_cmdline_length,
                                        8)
      if tag != self.TAG or num_bytes_following != expected_size:
        raise LookupError('Given data does not look like a kernel cmdline '
                          'descriptor.')
      # Nuke NUL-bytes at the end.
      try:
        self.kernel_cmdline = data[
            self.SIZE:(self.SIZE + kernel_cmdline_length)].decode('utf-8')
      except UnicodeDecodeError as e:
        raise LookupError('Kernel command-line cannot be decoded as UTF-8: {}.'
                          .format(e)) from e
    else:
      self.flags = 0
      self.kernel_cmdline = ''

  def print_desc(self, o):
    """Print the descriptor.

    Arguments:
      o: The object to write the output to.
    """
    o.write('    Kernel Cmdline descriptor:\n')
    o.write('      Flags:                 {}\n'.format(self.flags))
    o.write('      Kernel Cmdline:        \'{}\'\n'.format(self.kernel_cmdline))

  def encode(self):
    """Serializes the descriptor.

    Returns:
      The descriptor data as bytes.
    """
    kernel_cmd_encoded = self.kernel_cmdline.encode('utf-8')
    num_bytes_following = (self.SIZE + len(kernel_cmd_encoded) - 16)
    nbf_with_padding = round_to_multiple(num_bytes_following, 8)
    padding_size = nbf_with_padding - num_bytes_following
    desc = struct.pack(self.FORMAT_STRING, self.TAG, nbf_with_padding,
                      self.flags, len(kernel_cmd_encoded))
    ret = desc + kernel_cmd_encoded + padding_size * b'\0'
    return ret

  def verify(self, image_dir, image_ext, expected_chain_partitions_map,
            image_containing_descriptor, accept_zeroed_hashtree):
    """Verifies contents of the descriptor - used in verify_image sub-command.

    Arguments:
      image_dir: The directory of the file being verified.
      image_ext: The extension of the file being verified (e.g. '.img').
      expected_chain_partitions_map: A map from partition name to the
          tuple (rollback_index_location, key_blob).
      image_containing_descriptor: The image the descriptor is in.
      accept_zeroed_hashtree: If True, don't fail if hashtree or FEC data is
          zeroed out.

    Returns:
      True if the descriptor verifies, False otherwise.
    """
    # Nothing to verify.
    return True


class AvbChainPartitionDescriptor(AvbDescriptor):
  """A class for chained partition descriptors.

  See the |AvbChainPartitionDescriptor| C struct for more information.

  Attributes:
    rollback_index_location: The rollback index location to use.
    partition_name: Partition name as string.
    public_key: The public key as bytes.
    flags: Descriptor flags (see avb_chain_partition_descriptor.h).
  """

  TAG = 4
  RESERVED = 60
  SIZE = 32 + RESERVED
  FORMAT_STRING = ('!QQ'  # tag, num_bytes_following (descriptor header)
                  'L'    # rollback_index_location
                  'L'    # partition_name_size (bytes)
                  'L' +  # public_key_size (bytes)
                  'L' +  # flags
                  str(RESERVED) + 's')  # reserved

  def __init__(self, data=None):
    """Initializes a new chain partition descriptor.

    Arguments:
      data: If not None, must be a bytearray of size |SIZE|.

    Raises:
      LookupError: If the given descriptor is malformed.
    """
    AvbDescriptor.__init__(self, None)
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (tag, num_bytes_following, self.rollback_index_location,
      partition_name_len,
      public_key_len, self.flags, _) = struct.unpack(self.FORMAT_STRING,
                                                      data[0:self.SIZE])
      expected_size = round_to_multiple(
          self.SIZE - 16 + partition_name_len + public_key_len, 8)
      if tag != self.TAG or num_bytes_following != expected_size:
        raise LookupError('Given data does not look like a chain partition '
                          'descriptor.')
      o = 0
      try:
        self.partition_name = data[
            (self.SIZE + o):(self.SIZE + o + partition_name_len)
        ].decode('utf-8')
      except UnicodeDecodeError as e:
        raise LookupError('Partition name cannot be decoded as UTF-8: {}.'
                          .format(e)) from e
      o += partition_name_len
      self.public_key = data[(self.SIZE + o):(self.SIZE + o + public_key_len)]

    else:
      self.rollback_index_location = 0
      self.partition_name = ''
      self.public_key = b''
      self.flags = 0

  def print_desc(self, o):
    """Print the descriptor.

    Arguments:
      o: The object to write the output to.
    """
    o.write('    Chain Partition descriptor:\n')
    o.write('      Partition Name:          {}\n'.format(self.partition_name))
    o.write('      Rollback Index Location: {}\n'.format(
        self.rollback_index_location))
    # Just show the SHA1 of the key, for size reasons.
    pubkey_digest = hashlib.sha1(self.public_key).hexdigest()
    o.write('      Public key (sha1):       {}\n'.format(pubkey_digest))
    o.write('      Flags:                   {}\n'.format(self.flags))

  def encode(self):
    """Serializes the descriptor.

    Returns:
      The descriptor data as bytes.
    """
    partition_name_encoded = self.partition_name.encode('utf-8')
    num_bytes_following = (
        self.SIZE + len(partition_name_encoded) + len(self.public_key) - 16)
    nbf_with_padding = round_to_multiple(num_bytes_following, 8)
    padding_size = nbf_with_padding - num_bytes_following
    desc = struct.pack(self.FORMAT_STRING, self.TAG, nbf_with_padding,
                      self.rollback_index_location,
                      len(partition_name_encoded), len(self.public_key),
                       self.flags, self.RESERVED * b'\0')
    ret = desc + partition_name_encoded + self.public_key + padding_size * b'\0'
    return ret

  def verify(self, image_dir, image_ext, expected_chain_partitions_map,
            image_containing_descriptor, accept_zeroed_hashtree):
    """Verifies contents of the descriptor - used in verify_image sub-command.

    Arguments:
      image_dir: The directory of the file being verified.
      image_ext: The extension of the file being verified (e.g. '.img').
      expected_chain_partitions_map: A map from partition name to the
          tuple (rollback_index_location, key_blob).
      image_containing_descriptor: The image the descriptor is in.
      accept_zeroed_hashtree: If True, don't fail if hashtree or FEC data is
          zeroed out.

    Returns:
      True if the descriptor verifies, False otherwise.
    """
    value = expected_chain_partitions_map.get(self.partition_name)
    if not value:
      sys.stderr.write('No expected chain partition for partition {}. Use '
                      '--expected_chain_partition to specify expected '
                      'contents or --follow_chain_partitions.\n'.
                      format(self.partition_name))
      return False
    rollback_index_location, pk_blob = value

    if self.rollback_index_location != rollback_index_location:
      sys.stderr.write('Expected rollback_index_location {} does not '
                      'match {} in descriptor for partition {}\n'.
                      format(rollback_index_location,
                              self.rollback_index_location,
                              self.partition_name))
      return False

    if self.public_key != pk_blob:
      sys.stderr.write('Expected public key blob does not match public '
                      'key blob in descriptor for partition {}\n'.
                      format(self.partition_name))
      return False

    print('{}: Successfully verified chain partition descriptor matches '
          'expected data'.format(self.partition_name))

    return True

DESCRIPTOR_CLASSES = [
    AvbPropertyDescriptor, AvbHashtreeDescriptor, AvbHashDescriptor,
    AvbKernelCmdlineDescriptor, AvbChainPartitionDescriptor
]


def parse_descriptors(data):
  """Parses a blob of data into descriptors.

  Arguments:
    data: Encoded descriptors as bytes.

  Returns:
    A list of instances of objects derived from AvbDescriptor. For
    unknown descriptors, the class AvbDescriptor is used.
  """
  o = 0
  ret = []
  while o < len(data):
    tag, nb_following = struct.unpack('!2Q', data[o:o + 16])
    if tag < len(DESCRIPTOR_CLASSES):
      clazz = DESCRIPTOR_CLASSES[tag]
    else:
      clazz = AvbDescriptor
    ret.append(clazz(data[o:o + 16 + nb_following]))
    o += 16 + nb_following
  return ret


class AvbFooter(object):
  """A class for parsing and writing footers.

  Footers are stored at the end of partitions and point to where the
  AvbVBMeta blob is located. They also contain the original size of
  the image before AVB information was added.

  Attributes:
    magic: Magic for identifying the footer, see |MAGIC|.
    version_major: The major version of avbtool that wrote the footer.
    version_minor: The minor version of avbtool that wrote the footer.
    original_image_size: Original image size.
    vbmeta_offset: Offset of where the AvbVBMeta blob is stored.
    vbmeta_size: Size of the AvbVBMeta blob.
  """

  MAGIC = b'AVBf'
  SIZE = 64
  RESERVED = 28
  FOOTER_VERSION_MAJOR = AVB_FOOTER_VERSION_MAJOR
  FOOTER_VERSION_MINOR = AVB_FOOTER_VERSION_MINOR
  FORMAT_STRING = ('!4s2L'  # magic, 2 x version.
                  'Q'      # Original image size.
                  'Q'      # Offset of VBMeta blob.
                  'Q' +    # Size of VBMeta blob.
                  str(RESERVED) + 'x')  # padding for reserved bytes

  def __init__(self, data=None):
    """Initializes a new footer object.

    Arguments:
      data: If not None, must be bytes of size 4096.

    Raises:
      LookupError: If the given footer is malformed.
      struct.error: If the given data has no footer.
    """
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (self.magic, self.version_major, self.version_minor,
      self.original_image_size, self.vbmeta_offset,
      self.vbmeta_size) = struct.unpack(self.FORMAT_STRING, data)
      if self.magic != self.MAGIC:
        raise LookupError('Given data does not look like a AVB footer.')
    else:
      self.magic = self.MAGIC
      self.version_major = self.FOOTER_VERSION_MAJOR
      self.version_minor = self.FOOTER_VERSION_MINOR
      self.original_image_size = 0
      self.vbmeta_offset = 0
      self.vbmeta_size = 0

  def encode(self):
    """Serializes the footer.

    Returns:
      The footer as bytes.
    """
    return struct.pack(self.FORMAT_STRING, self.magic, self.version_major,
                      self.version_minor, self.original_image_size,
                      self.vbmeta_offset, self.vbmeta_size)


class AvbVBMetaHeader(object):
  """A class for parsing and writing AVB vbmeta images.

  The attributes correspond to the |AvbVBMetaImageHeader| struct defined in
  avb_vbmeta_image.h.

  Attributes:
    magic: Four bytes equal to "AVB0" (AVB_MAGIC).
    required_libavb_version_major: The major version of libavb required for this
        header.
    required_libavb_version_minor: The minor version of libavb required for this
        header.
    authentication_data_block_size: The size of the signature block.
    auxiliary_data_block_size: The size of the auxiliary data block.
    algorithm_type: The verification algorithm used, see |AvbAlgorithmType|
        enum.
    hash_offset: Offset into the "Authentication data" block of hash data.
    hash_size: Length of the hash data.
    signature_offset: Offset into the "Authentication data" block of signature
        data.
    signature_size: Length of the signature data.
    public_key_offset: Offset into the "Auxiliary data" block of public key
        data.
    public_key_size: Length of the public key data.
    public_key_metadata_offset: Offset into the "Auxiliary data" block of public
        key metadata.
    public_key_metadata_size: Length of the public key metadata. Must be set to
        zero if there is no public key metadata.
    descriptors_offset: Offset into the "Auxiliary data" block of descriptor
        data.
    descriptors_size: Length of descriptor data.
    rollback_index: The rollback index which can be used to prevent rollback to
        older versions.
    flags: Flags from the AvbVBMetaImageFlags enumeration. This must be set to
        zero if the vbmeta image is not a top-level image.
    rollback_index_location: The location of the rollback index defined in this
        header. Only valid for the main vbmeta. For chained partitions, the
        rollback index location must be specified in the
        AvbChainPartitionDescriptor and this value must be set to 0.
    release_string: The release string from avbtool, e.g. "avbtool 1.0.0" or
        "avbtool 1.0.0 xyz_board Git-234abde89". Is guaranteed to be NUL
        terminated. Applications must not make assumptions about how this
        string is formatted.
  """
  MAGIC = b'AVB0'
  SIZE = 256

  # Keep in sync with |reserved| field of |AvbVBMetaImageHeader|.
  RESERVED = 80

  # Keep in sync with |AvbVBMetaImageHeader|.
  FORMAT_STRING = ('!4s2L'   # magic, 2 x version
                  '2Q'      # 2 x block size
                  'L'       # algorithm type
                  '2Q'      # offset, size (hash)
                  '2Q'      # offset, size (signature)
                  '2Q'      # offset, size (public key)
                  '2Q'      # offset, size (public key metadata)
                  '2Q'      # offset, size (descriptors)
                  'Q'       # rollback_index
                  'L'       # flags
                  'L'       # rollback_index_location
                  '47sx' +  # NUL-terminated release string
                  str(RESERVED) + 'x')  # padding for reserved bytes

  def __init__(self, data=None):
    """Initializes a new header object.

    Arguments:
      data: If not None, must be a bytearray of size 8192.

    Raises:
      Exception: If the given data is malformed.
    """
    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE

    if data:
      (self.magic, self.required_libavb_version_major,
      self.required_libavb_version_minor,
      self.authentication_data_block_size, self.auxiliary_data_block_size,
      self.algorithm_type, self.hash_offset, self.hash_size,
      self.signature_offset, self.signature_size, self.public_key_offset,
      self.public_key_size, self.public_key_metadata_offset,
      self.public_key_metadata_size, self.descriptors_offset,
      self.descriptors_size,
      self.rollback_index,
      self.flags,
      self.rollback_index_location,
      release_string) = struct.unpack(self.FORMAT_STRING, data)
      # Nuke NUL-bytes at the end of the string.
      if self.magic != self.MAGIC:
        raise AvbError('Given image does not look like a vbmeta image.')
      self.release_string = release_string.rstrip(b'\0').decode('utf-8')
    else:
      self.magic = self.MAGIC
      # Start by just requiring version 1.0. Code that adds features
      # in a future version can use bump_required_libavb_version_minor() to
      # bump the minor.
      self.required_libavb_version_major = AVB_VERSION_MAJOR
      self.required_libavb_version_minor = 0
      self.authentication_data_block_size = 0
      self.auxiliary_data_block_size = 0
      self.algorithm_type = 0
      self.hash_offset = 0
      self.hash_size = 0
      self.signature_offset = 0
      self.signature_size = 0
      self.public_key_offset = 0
      self.public_key_size = 0
      self.public_key_metadata_offset = 0
      self.public_key_metadata_size = 0
      self.descriptors_offset = 0
      self.descriptors_size = 0
      self.rollback_index = 0
      self.flags = 0
      self.rollback_index_location = 0
      self.release_string = get_release_string()

  def bump_required_libavb_version_minor(self, minor):
    """Function to bump required_libavb_version_minor.

    Call this when writing data that requires a specific libavb
    version to parse it.

    Arguments:
      minor: The minor version of libavb that has support for the feature.
    """
    self.required_libavb_version_minor = (
        max(self.required_libavb_version_minor, minor))

  def encode(self):
    """Serializes the header.

    Returns:
      The header as bytes.
    """
    release_string_encoded = self.release_string.encode('utf-8')
    return struct.pack(self.FORMAT_STRING, self.magic,
                      self.required_libavb_version_major,
                      self.required_libavb_version_minor,
                      self.authentication_data_block_size,
                      self.auxiliary_data_block_size, self.algorithm_type,
                      self.hash_offset, self.hash_size, self.signature_offset,
                      self.signature_size, self.public_key_offset,
                      self.public_key_size, self.public_key_metadata_offset,
                      self.public_key_metadata_size, self.descriptors_offset,
                      self.descriptors_size, self.rollback_index, self.flags,
                      self.rollback_index_location, release_string_encoded)


class Avb(object):
  """Business logic for avbtool command-line tool."""

  # Keep in sync with avb_ab_flow.h.
  AB_FORMAT_NO_CRC = '!4sBB2xBBBxBBBx12x'
  AB_MAGIC = b'\0AB0'
  AB_MAJOR_VERSION = 1
  AB_MINOR_VERSION = 0
  AB_MISC_METADATA_OFFSET = 2048

  # Constants for maximum metadata size. These are used to give
  # meaningful errors if the value passed in via --partition_size is
  # too small and when --calc_max_image_size is used. We use
  # conservative figures.
  MAX_VBMETA_SIZE = 64 * 1024
  MAX_FOOTER_SIZE = 4096

  def generate_test_image(self, output, image_size, start_byte):
    """Generates a test image for testing avbtool with known content.

    The content has following pattern: 0x00 0x01 0x02 .. 0xff 0x00 0x01 ..).

    Arguments:
      output: Write test image to this file.
      image_size: The size of the requested file in bytes.
      start_byte: The integer value of the start byte to use for pattern
          generation.
    """
    pattern = bytearray([x & 0xFF for x in range(start_byte, start_byte + 256)])
    buf = bytearray()
    c = int(math.ceil(image_size / 256.0))
    for _ in range(0, c):
      buf.extend(pattern)
    output.write(buf[0:image_size])

  def extract_vbmeta_image(self, output, image_filename, padding_size):
    """Implements the 'extract_vbmeta_image' command.

    Arguments:
      output: Write vbmeta struct to this file.
      image_filename: File to extract vbmeta data from (with a footer).
      padding_size: If not 0, pads output so size is a multiple of the number.

    Raises:
      AvbError: If there's no footer in the image.
    """
    image = ImageHandler(image_filename, read_only=True)
    (footer, _, _, _) = self._parse_image(image)
    if not footer:
      raise AvbError('Given image does not have a footer.')

    image.seek(footer.vbmeta_offset)
    vbmeta_blob = image.read(footer.vbmeta_size)
    output.write(vbmeta_blob)

    if padding_size > 0:
      padded_size = round_to_multiple(len(vbmeta_blob), padding_size)
      padding_needed = padded_size - len(vbmeta_blob)
      output.write(b'\0' * padding_needed)

  def erase_footer(self, image_filename, keep_hashtree):
    """Implements the 'erase_footer' command.

    Arguments:
      image_filename: File to erase a footer from.
      keep_hashtree: If True, keep the hashtree and FEC around.

    Raises:
      AvbError: If there's no footer in the image.
    """
    image = ImageHandler(image_filename)
    (footer, _, descriptors, _) = self._parse_image(image)
    if not footer:
      raise AvbError('Given image does not have a footer.')

    new_image_size = None
    if not keep_hashtree:
      new_image_size = footer.original_image_size
    else:
      # If requested to keep the hashtree, search for a hashtree
      # descriptor to figure out the location and size of the hashtree
      # and FEC.
      for desc in descriptors:
        if isinstance(desc, AvbHashtreeDescriptor):
          # The hashtree is always just following the main data so the
          # new size is easily derived.
          new_image_size = desc.tree_offset + desc.tree_size
          # If the image has FEC codes, also keep those.
          if desc.fec_offset > 0:
            fec_end = desc.fec_offset + desc.fec_size
            new_image_size = max(new_image_size, fec_end)
          break
      if not new_image_size:
        raise AvbError('Requested to keep hashtree but no hashtree '
                      'descriptor was found.')

    # And cut...
    image.truncate(new_image_size)

  def zero_hashtree(self, image_filename):
    """Implements the 'zero_hashtree' command.

    Arguments:
      image_filename: File to zero hashtree and FEC data from.

    Raises:
      AvbError: If there's no footer in the image.
    """
    image = ImageHandler(image_filename)
    (footer, _, descriptors, _) = self._parse_image(image)
    if not footer:
      raise AvbError('Given image does not have a footer.')

    # Search for a hashtree descriptor to figure out the location and
    # size of the hashtree and FEC.
    ht_desc = None
    for desc in descriptors:
      if isinstance(desc, AvbHashtreeDescriptor):
        ht_desc = desc
        break

    if not ht_desc:
      raise AvbError('No hashtree descriptor was found.')

    zero_ht_start_offset = ht_desc.tree_offset
    zero_ht_num_bytes = ht_desc.tree_size
    zero_fec_start_offset = None
    zero_fec_num_bytes = 0
    if ht_desc.fec_offset > 0:
      if ht_desc.fec_offset != ht_desc.tree_offset + ht_desc.tree_size:
        raise AvbError('Hash-tree and FEC data must be adjacent.')
      zero_fec_start_offset = ht_desc.fec_offset
      zero_fec_num_bytes = ht_desc.fec_size
    zero_end_offset = (zero_ht_start_offset + zero_ht_num_bytes
                      + zero_fec_num_bytes)
    image.seek(zero_end_offset)
    data = image.read(image.image_size - zero_end_offset)

    # Write zeroes all over hashtree and FEC, except for the first eight bytes
    # where a magic marker - ZeroHaSH - is placed. Place these markers in the
    # beginning of both hashtree and FEC. (That way, in the future we can add
    # options to 'avbtool zero_hashtree' so as to zero out only either/or.)
    #
    # Applications can use these markers to detect that the hashtree and/or
    # FEC needs to be recomputed.
    image.truncate(zero_ht_start_offset)
    data_zeroed_firstblock = b'ZeRoHaSH' + b'\0' * (image.block_size - 8)
    image.append_raw(data_zeroed_firstblock)
    image.append_fill(b'\0\0\0\0', zero_ht_num_bytes - image.block_size)
    if zero_fec_start_offset:
      image.append_raw(data_zeroed_firstblock)
      image.append_fill(b'\0\0\0\0', zero_fec_num_bytes - image.block_size)
    image.append_raw(data)

  def resize_image(self, image_filename, partition_size):
    """Implements the 'resize_image' command.

    Arguments:
      image_filename: File with footer to resize.
      partition_size: The new size of the image.

    Raises:
      AvbError: If there's no footer in the image.
    """

    image = ImageHandler(image_filename)
    if partition_size % image.block_size != 0:
      raise AvbError('Partition size of {} is not a multiple of the image '
                    'block size {}.'.format(partition_size,
                                            image.block_size))
    (footer, _, _, _) = self._parse_image(image)
    if not footer:
      raise AvbError('Given image does not have a footer.')

    # The vbmeta blob is always at the end of the data so resizing an
    # image amounts to just moving the footer around.
    vbmeta_end_offset = footer.vbmeta_offset + footer.vbmeta_size
    if vbmeta_end_offset % image.block_size != 0:
      vbmeta_end_offset += image.block_size - (vbmeta_end_offset
                                              % image.block_size)

    if partition_size < vbmeta_end_offset + 1 * image.block_size:
      raise AvbError('Requested size of {} is too small for an image '
                    'of size {}.'
                    .format(partition_size,
                             vbmeta_end_offset + 1 * image.block_size))

    # Cut at the end of the vbmeta blob and insert a DONT_CARE chunk
    # with enough bytes such that the final Footer block is at the end
    # of partition_size.
    image.truncate(vbmeta_end_offset)
    image.append_dont_care(partition_size - vbmeta_end_offset -
                           1 * image.block_size)

    # Just reuse the same footer - only difference is that we're
    # writing it in a different place.
    footer_blob = footer.encode()
    footer_blob_with_padding = (b'\0' * (image.block_size - AvbFooter.SIZE) +
                                footer_blob)
    image.append_raw(footer_blob_with_padding)

  def set_ab_metadata(self, misc_image, slot_data):
    """Implements the 'set_ab_metadata' command.

    The |slot_data| argument must be of the form 'A_priority:A_tries_remaining:
    A_successful_boot:B_priority:B_tries_remaining:B_successful_boot'.

    Arguments:
      misc_image: The misc image to write to.
      slot_data: Slot data as a string

    Raises:
      AvbError: If slot data is malformed.
    """
    tokens = slot_data.split(':')
    if len(tokens) != 6:
      raise AvbError('Malformed slot data "{}".'.format(slot_data))
    a_priority = int(tokens[0])
    a_tries_remaining = int(tokens[1])
    a_success = int(tokens[2]) != 0
    b_priority = int(tokens[3])
    b_tries_remaining = int(tokens[4])
    b_success = int(tokens[5]) != 0

    ab_data_no_crc = struct.pack(self.AB_FORMAT_NO_CRC,
                                self.AB_MAGIC,
                                self.AB_MAJOR_VERSION, self.AB_MINOR_VERSION,
                                a_priority, a_tries_remaining, a_success,
                                b_priority, b_tries_remaining, b_success)
    # Force CRC to be unsigned, see https://bugs.python.org/issue4903 for why.
    crc_value = binascii.crc32(ab_data_no_crc) & 0xffffffff
    ab_data = ab_data_no_crc + struct.pack('!I', crc_value)
    misc_image.seek(self.AB_MISC_METADATA_OFFSET)
    misc_image.write(ab_data)

  def info_image(self, image_filename, output, atx):
    """Implements the 'info_image' command.

    Arguments:
      image_filename: Image file to get information from (file object).
      output: Output file to write human-readable information to (file object).
      atx: If True, show information about Android Things eXtension (ATX).
    """
    image = ImageHandler(image_filename, read_only=True)
    o = output
    try:
      (footer, header, descriptors, image_size) = self._parse_image(image)
    except AvbError as e:
      o.write('Error: {}\n'.format(e))
      return

    # To show the SHA1 of the public key.
    vbmeta_blob = self._load_vbmeta_blob(image)
    key_offset = (header.SIZE +
                  header.authentication_data_block_size +
                  header.public_key_offset)
    key_blob = vbmeta_blob[key_offset:key_offset + header.public_key_size]

    # initialize dictionary to store info
    info = {}

    if footer:
      o.write('Footer version:           {}.{}\n'.format(footer.version_major,
                                                        footer.version_minor))
      o.write('Image size:               {} bytes\n'.format(image_size))
      # add info to the dictionary
      info['Image Size'] = '{}'.format(image_size)
      o.write('Original image size:      {} bytes\n'.format(
          footer.original_image_size))
      o.write('VBMeta offset:            {}\n'.format(footer.vbmeta_offset))
      o.write('VBMeta size:              {} bytes\n'.format(footer.vbmeta_size))
      o.write('--\n')

    (alg_name, _) = lookup_algorithm_by_type(header.algorithm_type)

    o.write('Minimum libavb version:   {}.{}{}\n'.format(
        header.required_libavb_version_major,
        header.required_libavb_version_minor,
        ' (Sparse)' if image.is_sparse else ''))
    o.write('Header Block:             {} bytes\n'.format(AvbVBMetaHeader.SIZE))
    o.write('Authentication Block:     {} bytes\n'.format(
        header.authentication_data_block_size))
    o.write('Auxiliary Block:          {} bytes\n'.format(
        header.auxiliary_data_block_size))
    if key_blob:
      hexdig = hashlib.sha1(key_blob).hexdigest()
      o.write('Public key (sha1):        {}\n'.format(hexdig))
      # add info to the dictionary
      info['Public key (sha1)'] = '{}'.format(hexdig)
    o.write('Algorithm:                {}\n'.format(alg_name))
    o.write('Rollback Index:           {}\n'.format(header.rollback_index))
    # if header.rollback_index is epoc date, convert it to a string
    if header.rollback_index > 0:
      try:
        rb_date = datetime.datetime.fromtimestamp(header.rollback_index)
        o.write('Rollback Index Date:      {}\n'.format(rb_date))
        info['Rollback Index Date'] = '{}'.format(rb_date)
      except ValueError:
        o.write('Rollback Index Date:     (invalid date)\n')
    o.write('Flags:                    {}\n'.format(header.flags))
    o.write('Rollback Index Location:  {}\n'.format(header.rollback_index_location))
    o.write('Release String:           \'{}\'\n'.format(header.release_string))

    # add info to the dictionary
    info['Algorithm'] = '{}'.format(alg_name)
    info['Rollback Index'] = '{}'.format(header.rollback_index)

    # Print descriptors.
    num_printed = 0
    o.write('Descriptors:\n')
    for desc in descriptors:
      desc.print_desc(o)
      # Add descriptors to the dictionary
      with contextlib.suppress(Exception):
        info['Hash Algorithm'] = '{}'.format(desc.hash_algorithm)
      with contextlib.suppress(Exception):
        info['Partition Name'] = '{}'.format(desc.partition_name)
      with contextlib.suppress(Exception):
        info['Salt'] = '{}'.format(desc.salt.hex())
      with contextlib.suppress(Exception):
        printable_value = repr(desc.value)
        if printable_value.startswith('b\''):
          printable_value = printable_value[1:]
        printable_value = printable_value.replace('\'', '')
        printable_value = printable_value.replace('\"', '')
        if len(desc.value) < 256:
          info[desc.key] = '{}'.format(printable_value)
        else:
          info[desc.key] = '{}'.format(desc.value)

      num_printed += 1
    if num_printed == 0:
      o.write('    (none)\n')

    # info['descriptors'] = [desc.print_desc() for desc in descriptors]

    if atx and header.public_key_metadata_size:
      o.write('Android Things eXtension (ATX):\n')
      key_metadata_offset = (header.SIZE +
                            header.authentication_data_block_size +
                            header.public_key_metadata_offset)
      key_metadata_blob = vbmeta_blob[key_metadata_offset: key_metadata_offset
                                      + header.public_key_metadata_size]
      version, pik, psk = struct.unpack('<I1620s1620s', key_metadata_blob)
      o.write('    Metadata version:        {}\n'.format(version))

      def print_atx_certificate(cert):
        version, public_key, subject, usage, key_version, _ = (
            struct.unpack('<I1032s32s32sQ512s', cert))
        o.write('      Version:               {}\n'.format(version))
        o.write('      Public key (sha1):     {}\n'.format(
            hashlib.sha1(public_key).hexdigest()))
        o.write('      Subject:               {}\n'.format(subject.hex()))
        o.write('      Usage:                 {}\n'.format(usage.hex()))
        o.write('      Key version:           {}\n'.format(key_version))

      o.write('    Product Intermediate Key:\n')
      print_atx_certificate(pik)
      o.write('    Product Signing Key:\n')
      print_atx_certificate(psk)

    # return the dictionary
    return info

  def verify_image(self, image_filename, key_path, expected_chain_partitions,
                  follow_chain_partitions, accept_zeroed_hashtree):
    """Implements the 'verify_image' command.

    Arguments:
      image_filename: Image file to get information from (file object).
      key_path: None or check that embedded public key matches key at given
          path.
      expected_chain_partitions: List of chain partitions to check or None.
      follow_chain_partitions:
          If True, will follows chain partitions even when not specified with
          the --expected_chain_partition option
      accept_zeroed_hashtree: If True, don't fail if hashtree or FEC data is
          zeroed out.

    Raises:
      AvbError: If verification of the image fails.
    """
    expected_chain_partitions_map = {}
    if expected_chain_partitions:
      for cp in expected_chain_partitions:
        cp_tokens = cp.split(':')
        if len(cp_tokens) != 3:
          raise AvbError('Malformed chained partition "{}".'.format(cp))
        partition_name = cp_tokens[0]
        rollback_index_location = int(cp_tokens[1])
        file_path = cp_tokens[2]
        with open(file_path, 'rb') as f:
          pk_blob = f.read()
        expected_chain_partitions_map[partition_name] = (
            rollback_index_location, pk_blob)

    image_dir = os.path.dirname(image_filename)
    image_ext = os.path.splitext(image_filename)[1]

    key_blob = None
    if key_path:
      print('Verifying image {} using key at {}'.format(image_filename,
                                                        key_path))
      key_blob = RSAPublicKey(key_path).encode()
    else:
      print('Verifying image {} using embedded public key'.format(
          image_filename))

    image = ImageHandler(image_filename, read_only=True)
    (footer, header, descriptors, _) = self._parse_image(image)
    offset = 0
    if footer:
      offset = footer.vbmeta_offset

    image.seek(offset)
    vbmeta_blob = image.read(header.SIZE
                            + header.authentication_data_block_size
                            + header.auxiliary_data_block_size)

    alg_name, _ = lookup_algorithm_by_type(header.algorithm_type)
    if not verify_vbmeta_signature(header, vbmeta_blob):
      raise AvbError('Signature check failed for {} vbmeta struct {}'
                    .format(alg_name, image_filename))

    if key_blob:
      # The embedded public key is in the auxiliary block at an offset.
      key_offset = AvbVBMetaHeader.SIZE
      key_offset += header.authentication_data_block_size
      key_offset += header.public_key_offset
      key_blob_in_vbmeta = vbmeta_blob[key_offset:key_offset
                                      + header.public_key_size]
      if key_blob != key_blob_in_vbmeta:
        raise AvbError('Embedded public key does not match given key.')

    if footer:
      print('vbmeta: Successfully verified footer and {} vbmeta struct in {}'
            .format(alg_name, image.filename))
    else:
      print('vbmeta: Successfully verified {} vbmeta struct in {}'
            .format(alg_name, image.filename))

    for desc in descriptors:
      if (isinstance(desc, AvbChainPartitionDescriptor)
          and follow_chain_partitions
          and expected_chain_partitions_map.get(desc.partition_name) is None):
        # In this case we're processing a chain descriptor but don't have a
        # --expect_chain_partition ... however --follow_chain_partitions was
        # specified so we shouldn't error out in desc.verify().
        print('{}: Chained but ROLLBACK_SLOT (which is {}) '
              'and KEY (which has sha1 {}) not specified'
              .format(desc.partition_name, desc.rollback_index_location,
                      hashlib.sha1(desc.public_key).hexdigest()))
      elif not desc.verify(image_dir, image_ext, expected_chain_partitions_map,
                          image, accept_zeroed_hashtree):
        raise AvbError('Error verifying descriptor.')
      # Honor --follow_chain_partitions - add '--' to make the output more
      # readable.
      if (isinstance(desc, AvbChainPartitionDescriptor)
          and follow_chain_partitions):
        print('--')
        chained_image_filename = os.path.join(image_dir,
                                              desc.partition_name + image_ext)
        self.verify_image(chained_image_filename, key_path, None, False,
                          accept_zeroed_hashtree)

  def print_partition_digests(self, image_filename, output, as_json):
    """Implements the 'print_partition_digests' command.

    Arguments:
      image_filename: Image file to get information from (file object).
      output: Output file to write human-readable information to (file object).
      as_json: If True, print information as JSON

    Raises:
      AvbError: If getting the partition digests from the image fails.
    """
    image_dir = os.path.dirname(image_filename)
    image_ext = os.path.splitext(image_filename)[1]
    json_partitions = None
    if as_json:
      json_partitions = []
    self._print_partition_digests(
        image_filename, output, json_partitions, image_dir, image_ext)
    if as_json:
      output.write(json.dumps({'partitions': json_partitions}, indent=2))

  def _print_partition_digests(self, image_filename, output, json_partitions,
                              image_dir, image_ext):
    """Helper for printing partitions.

    Arguments:
      image_filename: Image file to get information from (file object).
      output: Output file to write human-readable information to (file object).
      json_partitions: If not None, don't print to output, instead add partition
          information to this list.
      image_dir: The directory to use when looking for chained partition files.
      image_ext: The extension to use for chained partition files.

    Raises:
      AvbError: If getting the partition digests from the image fails.
    """
    image = ImageHandler(image_filename, read_only=True)
    (_, _, descriptors, _) = self._parse_image(image)

    for desc in descriptors:
      if isinstance(desc, AvbHashDescriptor):
        digest = desc.digest.hex()
        if json_partitions is not None:
          json_partitions.append({'name': desc.partition_name,
                                  'digest': digest})
        else:
          output.write('{}: {}\n'.format(desc.partition_name, digest))
      elif isinstance(desc, AvbHashtreeDescriptor):
        digest = desc.root_digest.hex()
        if json_partitions is not None:
          json_partitions.append({'name': desc.partition_name,
                                  'digest': digest})
        else:
          output.write('{}: {}\n'.format(desc.partition_name, digest))
      elif isinstance(desc, AvbChainPartitionDescriptor):
        chained_image_filename = os.path.join(image_dir,
                                              desc.partition_name + image_ext)
        self._print_partition_digests(
            chained_image_filename, output, json_partitions, image_dir,
            image_ext)

  def calculate_vbmeta_digest(self, image_filename, hash_algorithm, output):
    """Implements the 'calculate_vbmeta_digest' command.

    Arguments:
      image_filename: Image file to get information from (file object).
      hash_algorithm: Hash algorithm used.
      output: Output file to write human-readable information to (file object).
    """

    image_dir = os.path.dirname(image_filename)
    image_ext = os.path.splitext(image_filename)[1]

    image = ImageHandler(image_filename, read_only=True)
    (footer, header, descriptors, _) = self._parse_image(image)
    offset = 0
    if footer:
      offset = footer.vbmeta_offset
    size = (header.SIZE + header.authentication_data_block_size +
            header.auxiliary_data_block_size)
    image.seek(offset)
    vbmeta_blob = image.read(size)

    hasher = hashlib.new(hash_algorithm)
    hasher.update(vbmeta_blob)

    for desc in descriptors:
      if isinstance(desc, AvbChainPartitionDescriptor):
        ch_image_filename = os.path.join(image_dir,
                                        desc.partition_name + image_ext)
        ch_image = ImageHandler(ch_image_filename, read_only=True)
        (ch_footer, ch_header, _, _) = self._parse_image(ch_image)
        ch_offset = 0
        ch_size = (ch_header.SIZE + ch_header.authentication_data_block_size +
                  ch_header.auxiliary_data_block_size)
        if ch_footer:
          ch_offset = ch_footer.vbmeta_offset
        ch_image.seek(ch_offset)
        ch_vbmeta_blob = ch_image.read(ch_size)
        hasher.update(ch_vbmeta_blob)

    digest = hasher.digest()
    output.write('{}\n'.format(digest.hex()))

  def calculate_kernel_cmdline(self, image_filename, hashtree_disabled, output):
    """Implements the 'calculate_kernel_cmdline' command.

    Arguments:
      image_filename: Image file to get information from (file object).
      hashtree_disabled: If True, returns the cmdline for hashtree disabled.
      output: Output file to write human-readable information to (file object).
    """

    image = ImageHandler(image_filename, read_only=True)
    _, _, descriptors, _ = self._parse_image(image)

    image_dir = os.path.dirname(image_filename)
    image_ext = os.path.splitext(image_filename)[1]

    cmdline_descriptors = []
    for desc in descriptors:
      if isinstance(desc, AvbChainPartitionDescriptor):
        ch_image_filename = os.path.join(image_dir,
                                        desc.partition_name + image_ext)
        ch_image = ImageHandler(ch_image_filename, read_only=True)
        _, _, ch_descriptors, _ = self._parse_image(ch_image)
        for ch_desc in ch_descriptors:
          if isinstance(ch_desc, AvbKernelCmdlineDescriptor):
            cmdline_descriptors.append(ch_desc)
      elif isinstance(desc, AvbKernelCmdlineDescriptor):
        cmdline_descriptors.append(desc)

    kernel_cmdline_snippets = []
    for desc in cmdline_descriptors:
      use_cmdline = True
      if ((desc.flags &
          AvbKernelCmdlineDescriptor.FLAGS_USE_ONLY_IF_HASHTREE_NOT_DISABLED)
          != 0):
        if hashtree_disabled:
          use_cmdline = False
      if (desc.flags &
          AvbKernelCmdlineDescriptor.FLAGS_USE_ONLY_IF_HASHTREE_DISABLED) != 0:
        if not hashtree_disabled:
          use_cmdline = False
      if use_cmdline:
        kernel_cmdline_snippets.append(desc.kernel_cmdline)
    output.write(' '.join(kernel_cmdline_snippets))

  def _parse_image(self, image):
    """Gets information about an image.

    The image can either be a vbmeta or an image with a footer.

    Arguments:
      image: An ImageHandler (vbmeta or footer) with a hashtree descriptor.

    Returns:
      A tuple where the first argument is a AvbFooter (None if there
      is no footer on the image), the second argument is a
      AvbVBMetaHeader, the third argument is a list of
      AvbDescriptor-derived instances, and the fourth argument is the
      size of |image|.

    Raises:
      AvbError: In case the image cannot be parsed.
    """
    assert isinstance(image, ImageHandler)
    footer = None
    image.seek(image.image_size - AvbFooter.SIZE)
    try:
      footer = AvbFooter(image.read(AvbFooter.SIZE))
    except (LookupError, struct.error):
      # Nope, just seek back to the start.
      image.seek(0)

    vbmeta_offset = 0
    if footer:
      vbmeta_offset = footer.vbmeta_offset

    image.seek(vbmeta_offset)
    h = AvbVBMetaHeader(image.read(AvbVBMetaHeader.SIZE))

    auth_block_offset = vbmeta_offset + AvbVBMetaHeader.SIZE
    aux_block_offset = auth_block_offset + h.authentication_data_block_size
    desc_start_offset = aux_block_offset + h.descriptors_offset
    image.seek(desc_start_offset)
    descriptors = parse_descriptors(image.read(h.descriptors_size))

    return footer, h, descriptors, image.image_size

  def _load_vbmeta_blob(self, image):
    """Gets the vbmeta struct and associated sections.

    The image can either be a vbmeta.img or an image with a footer.

    Arguments:
      image: An ImageHandler (vbmeta or footer).

    Returns:
      A blob with the vbmeta struct and other sections.
    """
    assert isinstance(image, ImageHandler)
    footer = None
    image.seek(image.image_size - AvbFooter.SIZE)
    try:
      footer = AvbFooter(image.read(AvbFooter.SIZE))
    except (LookupError, struct.error):
      # Nope, just seek back to the start.
      image.seek(0)

    vbmeta_offset = 0
    if footer:
      vbmeta_offset = footer.vbmeta_offset

    image.seek(vbmeta_offset)
    h = AvbVBMetaHeader(image.read(AvbVBMetaHeader.SIZE))

    image.seek(vbmeta_offset)
    data_size = AvbVBMetaHeader.SIZE
    data_size += h.authentication_data_block_size
    data_size += h.auxiliary_data_block_size
    return image.read(data_size)

  def _get_cmdline_descriptors_for_hashtree_descriptor(self, ht):
    """Generate kernel cmdline descriptors for dm-verity.

    Arguments:
      ht: A AvbHashtreeDescriptor

    Returns:
      A list with two AvbKernelCmdlineDescriptor with dm-verity kernel cmdline
      instructions. There is one for when hashtree is not disabled and one for
      when it is.

    """
    c = 'dm="1 vroot none ro 1,'
    c += '0'                                                # start
    c += ' {}'.format((ht.image_size // 512))               # size (# sectors)
    c += ' verity {}'.format(ht.dm_verity_version)          # type and version
    c += ' PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'             # data_dev
    c += ' PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'             # hash_dev
    c += ' {}'.format(ht.data_block_size)                   # data_block
    c += ' {}'.format(ht.hash_block_size)                   # hash_block
    c += ' {}'.format(ht.image_size // ht.data_block_size)  # #blocks
    c += ' {}'.format(ht.image_size // ht.data_block_size)  # hash_offset
    c += ' {}'.format(ht.hash_algorithm)                    # hash_alg
    c += ' {}'.format(ht.root_digest.hex())                 # root_digest
    c += ' {}'.format(ht.salt.hex())                        # salt
    if ht.fec_num_roots > 0:
      if ht.flags & AvbHashtreeDescriptor.FLAGS_CHECK_AT_MOST_ONCE:
        c += ' 11'  # number of optional args
        c += ' check_at_most_once'
      else:
        c += ' 10'  # number of optional args
      c += ' $(ANDROID_VERITY_MODE)'
      c += ' ignore_zero_blocks'
      c += ' use_fec_from_device PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'
      c += ' fec_roots {}'.format(ht.fec_num_roots)
      # Note that fec_blocks is the size that FEC covers, *not* the
      # size of the FEC data. Since we use FEC for everything up until
      # the FEC data, it's the same as the offset.
      c += ' fec_blocks {}'.format(ht.fec_offset // ht.data_block_size)
      c += ' fec_start {}'.format(ht.fec_offset // ht.data_block_size)
    else:
      if ht.flags & AvbHashtreeDescriptor.FLAGS_CHECK_AT_MOST_ONCE:
        c += ' 3'  # number of optional args
        c += ' check_at_most_once'
      else:
        c += ' 2'  # number of optional args
      c += ' $(ANDROID_VERITY_MODE)'
      c += ' ignore_zero_blocks'
    c += '" root=/dev/dm-0'

    # Now that we have the command-line, generate the descriptor.
    desc = AvbKernelCmdlineDescriptor()
    desc.kernel_cmdline = c
    desc.flags = (
        AvbKernelCmdlineDescriptor.FLAGS_USE_ONLY_IF_HASHTREE_NOT_DISABLED)

    # The descriptor for when hashtree verification is disabled is a lot
    # simpler - we just set the root to the partition.
    desc_no_ht = AvbKernelCmdlineDescriptor()
    desc_no_ht.kernel_cmdline = 'root=PARTUUID=$(ANDROID_SYSTEM_PARTUUID)'
    desc_no_ht.flags = (
        AvbKernelCmdlineDescriptor.FLAGS_USE_ONLY_IF_HASHTREE_DISABLED)

    return [desc, desc_no_ht]

  def _get_cmdline_descriptors_for_dm_verity(self, image):
    """Generate kernel cmdline descriptors for dm-verity.

    Arguments:
      image: An ImageHandler (vbmeta or footer) with a hashtree descriptor.

    Returns:
      A list with two AvbKernelCmdlineDescriptor with dm-verity kernel cmdline
      instructions. There is one for when hashtree is not disabled and one for
      when it is.

    Raises:
      AvbError: If  |image| doesn't have a hashtree descriptor.

    """
    (_, _, descriptors, _) = self._parse_image(image)

    ht = None
    for desc in descriptors:
      if isinstance(desc, AvbHashtreeDescriptor):
        ht = desc
        break

    if not ht:
      raise AvbError('No hashtree descriptor in given image')

    return self._get_cmdline_descriptors_for_hashtree_descriptor(ht)

  def make_vbmeta_image(self, output, chain_partitions_use_ab,
                        chain_partitions_do_not_use_ab, algorithm_name,
                        key_path, public_key_metadata_path, rollback_index,
                        flags, rollback_index_location,
                        props, props_from_file, kernel_cmdlines,
                        setup_rootfs_from_kernel,
                        include_descriptors_from_image,
                        signing_helper,
                        signing_helper_with_files,
                        release_string,
                        append_to_release_string,
                        print_required_libavb_version,
                        padding_size):
    """Implements the 'make_vbmeta_image' command.

    Arguments:
      output: File to write the image to.
      chain_partitions_use_ab: List of partitions to chain or None.
      chain_partitions_do_not_use_ab: List of partitions to chain which does not use A/B or None.
      algorithm_name: Name of algorithm to use.
      key_path: Path to key to use or None.
      public_key_metadata_path: Path to public key metadata or None.
      rollback_index: The rollback index to use.
      flags: Flags value to use in the image.
      rollback_index_location: Location of the main vbmeta rollback index.
      props: Properties to insert (list of strings of the form 'key:value').
      props_from_file: Properties to insert (list of strings 'key:<path>').
      kernel_cmdlines: Kernel cmdlines to insert (list of strings).
      setup_rootfs_from_kernel: None or file to generate from.
      include_descriptors_from_image: List of file objects with descriptors.
      signing_helper: Program which signs a hash and return signature.
      signing_helper_with_files: Same as signing_helper but uses files instead.
      release_string: None or avbtool release string to use instead of default.
      append_to_release_string: None or string to append.
      print_required_libavb_version: True to only print required libavb version.
      padding_size: If not 0, pads output so size is a multiple of the number.

    Raises:
      AvbError: If a chained partition is malformed.
    """
    # If we're asked to calculate minimum required libavb version, we're done.
    tmp_header = AvbVBMetaHeader()
    if rollback_index_location > 0:
      tmp_header.bump_required_libavb_version_minor(2)
    if chain_partitions_do_not_use_ab:
      tmp_header.bump_required_libavb_version_minor(3)
    if include_descriptors_from_image:
      # Use the bump logic in AvbVBMetaHeader to calculate the max required
      # version of all included descriptors.
      for image in include_descriptors_from_image:
        (_, image_header, _, _) = self._parse_image(ImageHandler(
            image.name, read_only=True))
        tmp_header.bump_required_libavb_version_minor(
            image_header.required_libavb_version_minor)

    if print_required_libavb_version:
      print('1.{}'.format(tmp_header.required_libavb_version_minor))
      return

    if not output:
      raise AvbError('No output file given')

    descriptors = []
    ht_desc_to_setup = None
    vbmeta_blob = self._generate_vbmeta_blob(
        algorithm_name, key_path, public_key_metadata_path, descriptors,
        chain_partitions_use_ab, chain_partitions_do_not_use_ab,
        rollback_index, flags, rollback_index_location, props, props_from_file,
        kernel_cmdlines, setup_rootfs_from_kernel, ht_desc_to_setup,
        include_descriptors_from_image, signing_helper,
        signing_helper_with_files, release_string,
        append_to_release_string, tmp_header.required_libavb_version_minor)

    # Write entire vbmeta blob (header, authentication, auxiliary).
    output.seek(0)
    output.write(vbmeta_blob)

    if padding_size > 0:
      padded_size = round_to_multiple(len(vbmeta_blob), padding_size)
      padding_needed = padded_size - len(vbmeta_blob)
      output.write(b'\0' * padding_needed)

  def _generate_vbmeta_blob(self, algorithm_name, key_path,
                            public_key_metadata_path, descriptors,
                            chain_partitions_use_ab, chain_partitions_do_not_use_ab,
                            rollback_index, flags, rollback_index_location,
                            props, props_from_file,
                            kernel_cmdlines,
                            setup_rootfs_from_kernel,
                            ht_desc_to_setup,
                            include_descriptors_from_image, signing_helper,
                            signing_helper_with_files,
                            release_string, append_to_release_string,
                            required_libavb_version_minor):
    """Generates a VBMeta blob.

    This blob contains the header (struct AvbVBMetaHeader), the
    authentication data block (which contains the hash and signature
    for the header and auxiliary block), and the auxiliary block
    (which contains descriptors, the public key used, and other data).

    The |key| parameter can |None| only if the |algorithm_name| is
    'NONE'.

    Arguments:
      algorithm_name: The algorithm name as per the ALGORITHMS dict.
      key_path: The path to the .pem file used to sign the blob.
      public_key_metadata_path: Path to public key metadata or None.
      descriptors: A list of descriptors to insert or None.
      chain_partitions_use_ab: List of partitions to chain with A/B or None.
      chain_partitions_do_not_use_ab: List of partitions to chain without A/B or None
      rollback_index: The rollback index to use.
      flags: Flags to use in the image.
      rollback_index_location: Location of the main vbmeta rollback index.
      props: Properties to insert (List of strings of the form 'key:value').
      props_from_file: Properties to insert (List of strings 'key:<path>').
      kernel_cmdlines: Kernel cmdlines to insert (list of strings).
      setup_rootfs_from_kernel: None or file to generate
        dm-verity kernel cmdline from.
      ht_desc_to_setup: If not None, an AvbHashtreeDescriptor to
        generate dm-verity kernel cmdline descriptors from.
      include_descriptors_from_image: List of file objects for which
        to insert descriptors from.
      signing_helper: Program which signs a hash and return signature.
      signing_helper_with_files: Same as signing_helper but uses files instead.
      release_string: None or avbtool release string.
      append_to_release_string: None or string to append.
      required_libavb_version_minor: Use at least this required minor version.

    Returns:
      The VBMeta blob as bytes.

    Raises:
      Exception: If the |algorithm_name| is not found, if no key has
        been given and the given algorithm requires one, or the key is
        of the wrong size.
    """
    try:
      alg = ALGORITHMS[algorithm_name]
    except KeyError as e:
      raise AvbError('Unknown algorithm with name {}'
                    .format(algorithm_name)) from e

    if not descriptors:
      descriptors = []

    h = AvbVBMetaHeader()
    h.bump_required_libavb_version_minor(required_libavb_version_minor)

    # Insert chained partition descriptors, if any
    all_chain_partitions = []
    if chain_partitions_use_ab:
      all_chain_partitions.extend(chain_partitions_use_ab)
    if chain_partitions_do_not_use_ab:
      all_chain_partitions.extend(chain_partitions_do_not_use_ab)

    if len(all_chain_partitions) > 0:
      used_locations = {rollback_index_location: True}
      for cp in all_chain_partitions:
        cp_tokens = cp.split(':')
        if len(cp_tokens) != 3:
          raise AvbError('Malformed chained partition "{}".'.format(cp))
        partition_name = cp_tokens[0]
        chained_rollback_index_location = int(cp_tokens[1])
        file_path = cp_tokens[2]
        # Check that the same rollback location isn't being used by
        # multiple chained partitions.
        if used_locations.get(chained_rollback_index_location):
          raise AvbError('Rollback Index Location {} is already in use.'.format(
              chained_rollback_index_location))
        used_locations[chained_rollback_index_location] = True
        desc = AvbChainPartitionDescriptor()
        desc.partition_name = partition_name
        desc.rollback_index_location = chained_rollback_index_location
        if desc.rollback_index_location < 1:
          raise AvbError('Rollback index location must be 1 or larger.')
        with open(file_path, 'rb') as f:
          desc.public_key = f.read()
        if chain_partitions_do_not_use_ab and (cp in chain_partitions_do_not_use_ab):
          desc.flags |= 1
        descriptors.append(desc)

    # Descriptors.
    encoded_descriptors = bytearray()
    for desc in descriptors:
      encoded_descriptors.extend(desc.encode())

    # Add properties.
    if props:
      for prop in props:
        idx = prop.find(':')
        if idx == -1:
          raise AvbError('Malformed property "{}".'.format(prop))
        # pylint: disable=redefined-variable-type
        desc = AvbPropertyDescriptor()
        desc.key = prop[0:idx]
        desc.value = prop[(idx + 1):].encode('utf-8')
        encoded_descriptors.extend(desc.encode())
    if props_from_file:
      for prop in props_from_file:
        idx = prop.find(':')
        if idx == -1:
          raise AvbError('Malformed property "{}".'.format(prop))
        desc = AvbPropertyDescriptor()
        desc.key = prop[0:idx]
        file_path = prop[(idx + 1):]
        with open(file_path, 'rb') as f:
          # pylint: disable=attribute-defined-outside-init
          desc.value = f.read()
        encoded_descriptors.extend(desc.encode())

    # Add AvbKernelCmdline descriptor for dm-verity from an image, if requested.
    if setup_rootfs_from_kernel:
      image_handler = ImageHandler(
          setup_rootfs_from_kernel.name)
      cmdline_desc = self._get_cmdline_descriptors_for_dm_verity(image_handler)
      encoded_descriptors.extend(cmdline_desc[0].encode())
      encoded_descriptors.extend(cmdline_desc[1].encode())

    # Add AvbKernelCmdline descriptor for dm-verity from desc, if requested.
    if ht_desc_to_setup:
      cmdline_desc = self._get_cmdline_descriptors_for_hashtree_descriptor(
          ht_desc_to_setup)
      encoded_descriptors.extend(cmdline_desc[0].encode())
      encoded_descriptors.extend(cmdline_desc[1].encode())

    # Add kernel command-lines.
    if kernel_cmdlines:
      for i in kernel_cmdlines:
        desc = AvbKernelCmdlineDescriptor()
        desc.kernel_cmdline = i
        encoded_descriptors.extend(desc.encode())

    # Add descriptors from other images.
    if include_descriptors_from_image:
      descriptors_dict = dict()
      for image in include_descriptors_from_image:
        image_handler = ImageHandler(image.name, read_only=True)
        (_, image_vbmeta_header, image_descriptors, _) = self._parse_image(
            image_handler)
        # Bump the required libavb version to support all included descriptors.
        h.bump_required_libavb_version_minor(
            image_vbmeta_header.required_libavb_version_minor)
        for desc in image_descriptors:
          # The --include_descriptors_from_image option is used in some setups
          # with images A and B where both A and B contain a descriptor
          # for a partition with the same name. Since it's not meaningful
          # to include both descriptors, only include the last seen descriptor.
          # See bug 76386656 for details.
          if hasattr(desc, 'partition_name'):
            key = type(desc).__name__ + '_' + desc.partition_name
            descriptors_dict[key] = desc.encode()
          else:
            encoded_descriptors.extend(desc.encode())
      for key in sorted(descriptors_dict):
        encoded_descriptors.extend(descriptors_dict[key])

    # Load public key metadata blob, if requested.
    pkmd_blob = b''
    if public_key_metadata_path:
      with open(public_key_metadata_path, 'rb') as f:
        pkmd_blob = f.read()

    key = None
    encoded_key = b''
    if alg.public_key_num_bytes > 0:
      if not key_path:
        raise AvbError('Key is required for algorithm {}'.format(
            algorithm_name))
      encoded_key = RSAPublicKey(key_path).encode()
      if len(encoded_key) != alg.public_key_num_bytes:
        raise AvbError('Key is wrong size for algorithm {}'.format(
            algorithm_name))

    # Override release string, if requested.
    if isinstance(release_string, str):
      h.release_string = release_string

    # Append to release string, if requested. Also insert a space before.
    if isinstance(append_to_release_string, str):
      h.release_string += ' ' + append_to_release_string

    # For the Auxiliary data block, descriptors are stored at offset 0,
    # followed by the public key, followed by the public key metadata blob.
    h.auxiliary_data_block_size = round_to_multiple(
        len(encoded_descriptors) + len(encoded_key) + len(pkmd_blob), 64)
    h.descriptors_offset = 0
    h.descriptors_size = len(encoded_descriptors)
    h.public_key_offset = h.descriptors_size
    h.public_key_size = len(encoded_key)
    h.public_key_metadata_offset = h.public_key_offset + h.public_key_size
    h.public_key_metadata_size = len(pkmd_blob)

    # For the Authentication data block, the hash is first and then
    # the signature.
    h.authentication_data_block_size = round_to_multiple(
        alg.hash_num_bytes + alg.signature_num_bytes, 64)
    h.algorithm_type = alg.algorithm_type
    h.hash_offset = 0
    h.hash_size = alg.hash_num_bytes
    # Signature offset and size - it's stored right after the hash
    # (in Authentication data block).
    h.signature_offset = alg.hash_num_bytes
    h.signature_size = alg.signature_num_bytes

    h.rollback_index = rollback_index
    h.flags = flags
    h.rollback_index_location = rollback_index_location

    # Generate Header data block.
    header_data_blob = h.encode()

    # Generate Auxiliary data block.
    aux_data_blob = bytearray()
    aux_data_blob.extend(encoded_descriptors)
    aux_data_blob.extend(encoded_key)
    aux_data_blob.extend(pkmd_blob)
    padding_bytes = h.auxiliary_data_block_size - len(aux_data_blob)
    aux_data_blob.extend(b'\0' * padding_bytes)

    # Calculate the hash.
    binary_hash = b''
    binary_signature = b''
    if algorithm_name != 'NONE':
      ha = hashlib.new(alg.hash_name)
      ha.update(header_data_blob)
      ha.update(aux_data_blob)
      binary_hash = ha.digest()

      # Calculate the signature.
      rsa_key = RSAPublicKey(key_path)
      data_to_sign = header_data_blob + bytes(aux_data_blob)
      binary_signature = rsa_key.sign(algorithm_name, data_to_sign,
                                      signing_helper, signing_helper_with_files)

    # Generate Authentication data block.
    auth_data_blob = bytearray()
    auth_data_blob.extend(binary_hash)
    auth_data_blob.extend(binary_signature)
    padding_bytes = h.authentication_data_block_size - len(auth_data_blob)
    auth_data_blob.extend(b'\0' * padding_bytes)

    return header_data_blob + bytes(auth_data_blob) + bytes(aux_data_blob)

  def extract_public_key(self, key_path, output):
    """Implements the 'extract_public_key' command.

    Arguments:
      key_path: The path to a RSA private key file.
      output: The file to write to.

    Raises:
      AvbError: If the public key could not be extracted.
    """
    output.write(RSAPublicKey(key_path).encode())

  def append_vbmeta_image(self, image_filename, vbmeta_image_filename,
                          partition_size):
    """Implementation of the append_vbmeta_image command.

    Arguments:
      image_filename: File to add the footer to.
      vbmeta_image_filename: File to get vbmeta struct from.
      partition_size: Size of partition.

    Raises:
      AvbError: If an argument is incorrect or if appending VBMeta image fialed.
    """
    image = ImageHandler(image_filename)

    if partition_size % image.block_size != 0:
      raise AvbError('Partition size of {} is not a multiple of the image '
                    'block size {}.'.format(partition_size,
                                            image.block_size))

    # If there's already a footer, truncate the image to its original
    # size. This way 'avbtool append_vbmeta_image' is idempotent.
    if image.image_size >= AvbFooter.SIZE:
      image.seek(image.image_size - AvbFooter.SIZE)
      try:
        footer = AvbFooter(image.read(AvbFooter.SIZE))
        # Existing footer found. Just truncate.
        original_image_size = footer.original_image_size
        image.truncate(footer.original_image_size)
      except (LookupError, struct.error):
        original_image_size = image.image_size
    else:
      # Image size is too small to possibly contain a footer.
      original_image_size = image.image_size

    # If anything goes wrong from here-on, restore the image back to
    # its original size.
    try:
      vbmeta_image_handler = ImageHandler(vbmeta_image_filename)
      vbmeta_blob = self._load_vbmeta_blob(vbmeta_image_handler)

      # If the image isn't sparse, its size might not be a multiple of
      # the block size. This will screw up padding later so just grow it.
      if image.image_size % image.block_size != 0:
        assert not image.is_sparse
        padding_needed = image.block_size - (image.image_size%image.block_size)
        image.truncate(image.image_size + padding_needed)

      # The append_raw() method requires content with size being a
      # multiple of |block_size| so add padding as needed. Also record
      # where this is written to since we'll need to put that in the
      # footer.
      vbmeta_offset = image.image_size
      padding_needed = (round_to_multiple(len(vbmeta_blob), image.block_size) -
                        len(vbmeta_blob))
      vbmeta_blob_with_padding = vbmeta_blob + b'\0' * padding_needed

      # Append vbmeta blob and footer
      image.append_raw(vbmeta_blob_with_padding)
      vbmeta_end_offset = vbmeta_offset + len(vbmeta_blob_with_padding)

      # Now insert a DONT_CARE chunk with enough bytes such that the
      # final Footer block is at the end of partition_size..
      image.append_dont_care(partition_size - vbmeta_end_offset -
                             1 * image.block_size)

      # Generate the Footer that tells where the VBMeta footer
      # is. Also put enough padding in the front of the footer since
      # we'll write out an entire block.
      footer = AvbFooter()
      footer.original_image_size = original_image_size
      footer.vbmeta_offset = vbmeta_offset
      footer.vbmeta_size = len(vbmeta_blob)
      footer_blob = footer.encode()
      footer_blob_with_padding = (b'\0' * (image.block_size - AvbFooter.SIZE) +
                                  footer_blob)
      image.append_raw(footer_blob_with_padding)

    except Exception as e:
      # Truncate back to original size, then re-raise.
      image.truncate(original_image_size)
      raise AvbError('Appending VBMeta image failed: {}.'.format(e)) from e

  def add_hash_footer(self, image_filename, partition_size,
                      dynamic_partition_size, partition_name,
                      hash_algorithm, salt, chain_partitions_use_ab,
                      chain_partitions_do_not_use_ab,
                      algorithm_name, key_path,
                      public_key_metadata_path, rollback_index, flags,
                      rollback_index_location, props,
                      props_from_file, kernel_cmdlines,
                      setup_rootfs_from_kernel,
                      include_descriptors_from_image, calc_max_image_size,
                      signing_helper, signing_helper_with_files,
                      release_string, append_to_release_string,
                      output_vbmeta_image, do_not_append_vbmeta_image,
                      print_required_libavb_version, use_persistent_digest,
                      do_not_use_ab):
    """Implementation of the add_hash_footer on unsparse images.

    Arguments:
      image_filename: File to add the footer to.
      partition_size: Size of partition.
      dynamic_partition_size: Calculate partition size based on image size.
      partition_name: Name of partition (without A/B suffix).
      hash_algorithm: Hash algorithm to use.
      salt: Salt to use as a hexadecimal string or None to use /dev/urandom.
      chain_partitions_use_ab: List of partitions to chain with A/B or None.
      chain_partitions_do_not_use_ab: List of partitions to chain without A/B or None.
      algorithm_name: Name of algorithm to use.
      key_path: Path to key to use or None.
      public_key_metadata_path: Path to public key metadata or None.
      rollback_index: Rollback index.
      flags: Flags value to use in the image.
      rollback_index_location: Location of the main vbmeta rollback index.
      props: Properties to insert (List of strings of the form 'key:value').
      props_from_file: Properties to insert (List of strings 'key:<path>').
      kernel_cmdlines: Kernel cmdlines to insert (list of strings).
      setup_rootfs_from_kernel: None or file to generate
        dm-verity kernel cmdline from.
      include_descriptors_from_image: List of file objects for which
        to insert descriptors from.
      calc_max_image_size: Don't store the footer - instead calculate the
        maximum image size leaving enough room for metadata with the
        given |partition_size|.
      signing_helper: Program which signs a hash and return signature.
      signing_helper_with_files: Same as signing_helper but uses files instead.
      release_string: None or avbtool release string.
      append_to_release_string: None or string to append.
      output_vbmeta_image: If not None, also write vbmeta struct to this file.
      do_not_append_vbmeta_image: If True, don't append vbmeta struct.
      print_required_libavb_version: True to only print required libavb version.
      use_persistent_digest: Use a persistent digest on device.
      do_not_use_ab: This partition does not use A/B.

    Raises:
      AvbError: If an argument is incorrect of if adding of hash_footer failed.
    """
    if not partition_size and not dynamic_partition_size:
      raise AvbError('--dynamic_partition_size required when not specifying a '
                    'partition size')

    if dynamic_partition_size and calc_max_image_size:
      raise AvbError('--calc_max_image_size not supported with '
                    '--dynamic_partition_size')

    required_libavb_version_minor = 0
    if use_persistent_digest or do_not_use_ab:
      required_libavb_version_minor = 1
    if rollback_index_location > 0:
      required_libavb_version_minor = 2
    if chain_partitions_do_not_use_ab:
      required_libavb_version_minor = 3

    # If we're asked to calculate minimum required libavb version, we're done.
    if print_required_libavb_version:
      print('1.{}'.format(required_libavb_version_minor))
      return

    # First, calculate the maximum image size such that an image
    # this size + metadata (footer + vbmeta struct) fits in
    # |partition_size|.
    max_metadata_size = self.MAX_VBMETA_SIZE + self.MAX_FOOTER_SIZE
    if not dynamic_partition_size and partition_size < max_metadata_size:
      raise AvbError('Parition size of {} is too small. '
                    'Needs to be at least {}'.format(
                        partition_size, max_metadata_size))

    # If we're asked to only calculate the maximum image size, we're done.
    if calc_max_image_size:
      print('{}'.format(partition_size - max_metadata_size))
      return

    # If we aren't appending the vbmeta footer to the input image we can
    # open it in read-only mode.
    image = ImageHandler(image_filename,
                        read_only=do_not_append_vbmeta_image)

    # If there's already a footer, truncate the image to its original
    # size. This way 'avbtool add_hash_footer' is idempotent (modulo
    # salts).
    if image.image_size >= AvbFooter.SIZE:
      image.seek(image.image_size - AvbFooter.SIZE)
      try:
        footer = AvbFooter(image.read(AvbFooter.SIZE))
        # Existing footer found. Just truncate.
        original_image_size = footer.original_image_size
        image.truncate(footer.original_image_size)
      except (LookupError, struct.error):
        original_image_size = image.image_size
    else:
      # Image size is too small to possibly contain a footer.
      original_image_size = image.image_size

    if dynamic_partition_size:
      partition_size = round_to_multiple(
          original_image_size + max_metadata_size, image.block_size)

    max_image_size = partition_size - max_metadata_size
    if partition_size % image.block_size != 0:
      raise AvbError('Partition size of {} is not a multiple of the image '
                    'block size {}.'.format(partition_size,
                                            image.block_size))

    # If anything goes wrong from here-on, restore the image back to
    # its original size.
    try:
      # If image size exceeds the maximum image size, fail.
      if image.image_size > max_image_size:
        raise AvbError('Image size of {} exceeds maximum image '
                      'size of {} in order to fit in a partition '
                      'size of {}.'.format(image.image_size, max_image_size,
                                            partition_size))

      digest_size = len(hashlib.new(hash_algorithm).digest())
      if salt:
        salt = binascii.unhexlify(salt)
      elif salt is None and not use_persistent_digest:
        # If salt is not explicitly specified, choose a hash that's the same
        # size as the hash size. Don't populate a random salt if this
        # descriptor is being created to use a persistent digest on device.
        hash_size = digest_size
        # Change the code to be cross-platform
        # with open('/dev/urandom', 'rb') as f:
        #   salt = f.read(hash_size)
        salt = os.urandom(hash_size)
      else:
        salt = b''

      hasher = hashlib.new(hash_algorithm, salt)
      # TODO(zeuthen): might want to read this in chunks to avoid
      # memory pressure, then again, this is only supposed to be used
      # on kernel/initramfs partitions. Possible optimization.
      image.seek(0)
      hasher.update(image.read(image.image_size))
      digest = hasher.digest()

      h_desc = AvbHashDescriptor()
      h_desc.image_size = image.image_size
      h_desc.hash_algorithm = hash_algorithm
      h_desc.partition_name = partition_name
      h_desc.salt = salt
      h_desc.flags = 0
      if do_not_use_ab:
        h_desc.flags |= 1  # AVB_HASH_DESCRIPTOR_FLAGS_DO_NOT_USE_AB
      if not use_persistent_digest:
        h_desc.digest = digest

      # Generate the VBMeta footer.
      ht_desc_to_setup = None
      vbmeta_blob = self._generate_vbmeta_blob(
          algorithm_name, key_path, public_key_metadata_path, [h_desc],
          chain_partitions_use_ab, chain_partitions_do_not_use_ab, rollback_index,
          flags, rollback_index_location, props, props_from_file,
          kernel_cmdlines, setup_rootfs_from_kernel, ht_desc_to_setup,
          include_descriptors_from_image, signing_helper,
          signing_helper_with_files, release_string,
          append_to_release_string, required_libavb_version_minor)

      # Write vbmeta blob, if requested.
      if output_vbmeta_image:
        output_vbmeta_image.write(vbmeta_blob)

      # Append vbmeta blob and footer, unless requested not to.
      if not do_not_append_vbmeta_image:
        # If the image isn't sparse, its size might not be a multiple of
        # the block size. This will screw up padding later so just grow it.
        if image.image_size % image.block_size != 0:
          assert not image.is_sparse
          padding_needed = image.block_size - (
              image.image_size % image.block_size)
          image.truncate(image.image_size + padding_needed)

        # The append_raw() method requires content with size being a
        # multiple of |block_size| so add padding as needed. Also record
        # where this is written to since we'll need to put that in the
        # footer.
        vbmeta_offset = image.image_size
        padding_needed = (
            round_to_multiple(len(vbmeta_blob), image.block_size) -
            len(vbmeta_blob))
        vbmeta_blob_with_padding = vbmeta_blob + b'\0' * padding_needed

        image.append_raw(vbmeta_blob_with_padding)
        vbmeta_end_offset = vbmeta_offset + len(vbmeta_blob_with_padding)

        # Now insert a DONT_CARE chunk with enough bytes such that the
        # final Footer block is at the end of partition_size..
        image.append_dont_care(partition_size - vbmeta_end_offset -
                               1 * image.block_size)

        # Generate the Footer that tells where the VBMeta footer
        # is. Also put enough padding in the front of the footer since
        # we'll write out an entire block.
        footer = AvbFooter()
        footer.original_image_size = original_image_size
        footer.vbmeta_offset = vbmeta_offset
        footer.vbmeta_size = len(vbmeta_blob)
        footer_blob = footer.encode()
        footer_blob_with_padding = (
            b'\0' * (image.block_size - AvbFooter.SIZE) + footer_blob)
        image.append_raw(footer_blob_with_padding)
    except Exception as e:
      # Truncate back to original size, then re-raise.
      image.truncate(original_image_size)
      raise AvbError('Adding hash_footer failed: {}.'.format(e)) from e

  def add_hashtree_footer(self, image_filename, partition_size, partition_name,
                          generate_fec, fec_num_roots, hash_algorithm,
                          block_size, salt, chain_partitions_use_ab,
                          chain_partitions_do_not_use_ab,
                          algorithm_name, key_path,
                          public_key_metadata_path, rollback_index, flags,
                          rollback_index_location,
                          props, props_from_file, kernel_cmdlines,
                          setup_rootfs_from_kernel,
                          setup_as_rootfs_from_kernel,
                          include_descriptors_from_image,
                          calc_max_image_size, signing_helper,
                          signing_helper_with_files,
                          release_string, append_to_release_string,
                          output_vbmeta_image, do_not_append_vbmeta_image,
                          print_required_libavb_version,
                          use_persistent_root_digest, do_not_use_ab,
                          no_hashtree, check_at_most_once):
    """Implements the 'add_hashtree_footer' command.

    See https://gitlab.com/cryptsetup/cryptsetup/wikis/DMVerity for
    more information about dm-verity and these hashes.

    Arguments:
      image_filename: File to add the footer to.
      partition_size: Size of partition or 0 to put it right at the end.
      partition_name: Name of partition (without A/B suffix).
      generate_fec: If True, generate FEC codes.
      fec_num_roots: Number of roots for FEC.
      hash_algorithm: Hash algorithm to use.
      block_size: Block size to use.
      salt: Salt to use as a hexadecimal string or None to use /dev/urandom.
      chain_partitions_use_ab: List of partitions to chain.
      chain_partitions_do_not_use_ab: List of partitions to chain without A/B or None.
      algorithm_name: Name of algorithm to use.
      key_path: Path to key to use or None.
      public_key_metadata_path: Path to public key metadata or None.
      rollback_index: Rollback index.
      flags: Flags value to use in the image.
      rollback_index_location: Location of the main vbmeta rollback index.
      props: Properties to insert (List of strings of the form 'key:value').
      props_from_file: Properties to insert (List of strings 'key:<path>').
      kernel_cmdlines: Kernel cmdlines to insert (list of strings).
      setup_rootfs_from_kernel: None or file to generate
        dm-verity kernel cmdline from.
      setup_as_rootfs_from_kernel: If True, generate dm-verity kernel
        cmdline to set up rootfs.
      include_descriptors_from_image: List of file objects for which
        to insert descriptors from.
      calc_max_image_size: Don't store the hashtree or footer - instead
        calculate the maximum image size leaving enough room for hashtree
        and metadata with the given |partition_size|.
      signing_helper: Program which signs a hash and return signature.
      signing_helper_with_files: Same as signing_helper but uses files instead.
      release_string: None or avbtool release string.
      append_to_release_string: None or string to append.
      output_vbmeta_image: If not None, also write vbmeta struct to this file.
      do_not_append_vbmeta_image: If True, don't append vbmeta struct.
      print_required_libavb_version: True to only print required libavb version.
      use_persistent_root_digest: Use a persistent root digest on device.
      do_not_use_ab: The partition does not use A/B.
      no_hashtree: Do not append hashtree. Set size in descriptor as zero.
      check_at_most_once: Set to verify data blocks only the first time they
        are read from the data device.

    Raises:
      AvbError: If an argument is incorrect or adding the hashtree footer
          failed.
    """
    required_libavb_version_minor = 0
    if use_persistent_root_digest or do_not_use_ab or check_at_most_once:
      required_libavb_version_minor = 1
    if rollback_index_location > 0:
      required_libavb_version_minor = 2
    if chain_partitions_do_not_use_ab:
      required_libavb_version_minor = 3

    # If we're asked to calculate minimum required libavb version, we're done.
    if print_required_libavb_version:
      print('1.{}'.format(required_libavb_version_minor))
      return

    digest_size = len(create_avb_hashtree_hasher(hash_algorithm, b'')
                      .digest())
    digest_padding = round_to_pow2(digest_size) - digest_size

    # If |partition_size| is given (e.g. not 0), calculate the maximum image
    # size such that an image this size + the hashtree + metadata (footer +
    # vbmeta struct) fits in |partition_size|. We use very conservative figures
    # for metadata.
    if partition_size > 0:
      max_tree_size = 0
      max_fec_size = 0
      if not no_hashtree:
        (_, max_tree_size) = calc_hash_level_offsets(
            partition_size, block_size, digest_size + digest_padding)
        if generate_fec:
          max_fec_size = calc_fec_data_size(partition_size, fec_num_roots)
      max_metadata_size = (max_fec_size + max_tree_size +
                          self.MAX_VBMETA_SIZE +
                          self.MAX_FOOTER_SIZE)
      max_image_size = partition_size - max_metadata_size
    else:
      max_image_size = 0

    # If we're asked to only calculate the maximum image size, we're done.
    if calc_max_image_size:
      print('{}'.format(max_image_size))
      return

    image = ImageHandler(image_filename)

    if partition_size > 0:
      if partition_size % image.block_size != 0:
        raise AvbError('Partition size of {} is not a multiple of the image '
                      'block size {}.'.format(partition_size,
                                              image.block_size))
    elif image.image_size % image.block_size != 0:
      raise AvbError('File size of {} is not a multiple of the image '
                    'block size {}.'.format(image.image_size,
                                            image.block_size))

    # If there's already a footer, truncate the image to its original
    # size. This way 'avbtool add_hashtree_footer' is idempotent
    # (modulo salts).
    if image.image_size >= AvbFooter.SIZE:
      image.seek(image.image_size - AvbFooter.SIZE)
      try:
        footer = AvbFooter(image.read(AvbFooter.SIZE))
        # Existing footer found. Just truncate.
        original_image_size = footer.original_image_size
        image.truncate(footer.original_image_size)
      except (LookupError, struct.error):
        original_image_size = image.image_size
    else:
      # Image size is too small to possibly contain a footer.
      original_image_size = image.image_size

    # If anything goes wrong from here-on, restore the image back to
    # its original size.
    try:
      # Ensure image is multiple of block_size.
      rounded_image_size = round_to_multiple(image.image_size, block_size)
      if rounded_image_size > image.image_size:
        # If we need to round up the image size, it means the length of the
        # data to append is not a multiple of block size.
        # Setting multiple_block_size to false, so append_raw() will not
        # require it.
        image.append_raw(b'\0' * (rounded_image_size - image.image_size),
                        multiple_block_size=False)

      # If image size exceeds the maximum image size, fail.
      if partition_size > 0:
        if image.image_size > max_image_size:
          raise AvbError('Image size of {} exceeds maximum image '
                        'size of {} in order to fit in a partition '
                        'size of {}.'.format(image.image_size, max_image_size,
                                              partition_size))

      if salt:
        salt = binascii.unhexlify(salt)
      elif salt is None and not use_persistent_root_digest:
        # If salt is not explicitly specified, choose a hash that's the same
        # size as the hash size. Don't populate a random salt if this
        # descriptor is being created to use a persistent digest on device.
        hash_size = digest_size
        with open('/dev/urandom', 'rb') as f:
          salt = f.read(hash_size)
      else:
        salt = b''

      # Hashes are stored upside down so we need to calculate hash
      # offsets in advance.
      (hash_level_offsets, tree_size) = calc_hash_level_offsets(
          image.image_size, block_size, digest_size + digest_padding)

      # If the image isn't sparse, its size might not be a multiple of
      # the block size. This will screw up padding later so just grow it.
      if image.image_size % image.block_size != 0:
        assert not image.is_sparse
        padding_needed = image.block_size - (image.image_size%image.block_size)
        image.truncate(image.image_size + padding_needed)

      # Generate the tree and add padding as needed.
      tree_offset = image.image_size
      root_digest, hash_tree = generate_hash_tree(image, image.image_size,
                                                  block_size,
                                                  hash_algorithm, salt,
                                                  digest_padding,
                                                  hash_level_offsets,
                                                  tree_size)

      # Generate HashtreeDescriptor with details about the tree we
      # just generated.
      if no_hashtree:
        tree_size = 0
        hash_tree = b''
      ht_desc = AvbHashtreeDescriptor()
      ht_desc.dm_verity_version = 1
      ht_desc.image_size = image.image_size
      ht_desc.tree_offset = tree_offset
      ht_desc.tree_size = tree_size
      ht_desc.data_block_size = block_size
      ht_desc.hash_block_size = block_size
      ht_desc.hash_algorithm = hash_algorithm
      ht_desc.partition_name = partition_name
      ht_desc.salt = salt
      if do_not_use_ab:
        ht_desc.flags |= AvbHashtreeDescriptor.FLAGS_DO_NOT_USE_AB
      if not use_persistent_root_digest:
        ht_desc.root_digest = root_digest
      if check_at_most_once:
        ht_desc.flags |= AvbHashtreeDescriptor.FLAGS_CHECK_AT_MOST_ONCE

      # Write the hash tree
      padding_needed = (round_to_multiple(len(hash_tree), image.block_size) -
                        len(hash_tree))
      hash_tree_with_padding = hash_tree + b'\0' * padding_needed
      if len(hash_tree_with_padding) > 0:
        image.append_raw(hash_tree_with_padding)
      len_hashtree_and_fec = len(hash_tree_with_padding)

      # Generate FEC codes, if requested.
      if generate_fec:
        if no_hashtree:
          fec_data = b''
        else:
          fec_data = generate_fec_data(image_filename, fec_num_roots)
        padding_needed = (round_to_multiple(len(fec_data), image.block_size) -
                          len(fec_data))
        fec_data_with_padding = fec_data + b'\0' * padding_needed
        fec_offset = image.image_size
        image.append_raw(fec_data_with_padding)
        len_hashtree_and_fec += len(fec_data_with_padding)
        # Update the hashtree descriptor.
        ht_desc.fec_num_roots = fec_num_roots
        ht_desc.fec_offset = fec_offset
        ht_desc.fec_size = len(fec_data)

      ht_desc_to_setup = None
      if setup_as_rootfs_from_kernel:
        ht_desc_to_setup = ht_desc

      # Generate the VBMeta footer and add padding as needed.
      vbmeta_offset = tree_offset + len_hashtree_and_fec
      vbmeta_blob = self._generate_vbmeta_blob(
          algorithm_name, key_path, public_key_metadata_path, [ht_desc],
          chain_partitions_use_ab, chain_partitions_do_not_use_ab,
          rollback_index, flags, rollback_index_location,
          props, props_from_file,
          kernel_cmdlines, setup_rootfs_from_kernel, ht_desc_to_setup,
          include_descriptors_from_image, signing_helper,
          signing_helper_with_files, release_string,
          append_to_release_string, required_libavb_version_minor)
      padding_needed = (round_to_multiple(len(vbmeta_blob), image.block_size) -
                        len(vbmeta_blob))
      vbmeta_blob_with_padding = vbmeta_blob + b'\0' * padding_needed

      # Write vbmeta blob, if requested.
      if output_vbmeta_image:
        output_vbmeta_image.write(vbmeta_blob)

      # Append vbmeta blob and footer, unless requested not to.
      if not do_not_append_vbmeta_image:
        image.append_raw(vbmeta_blob_with_padding)

        # Now insert a DONT_CARE chunk with enough bytes such that the
        # final Footer block is at the end of partition_size..
        if partition_size > 0:
          image.append_dont_care(partition_size - image.image_size -
                                 1 * image.block_size)

        # Generate the Footer that tells where the VBMeta footer
        # is. Also put enough padding in the front of the footer since
        # we'll write out an entire block.
        footer = AvbFooter()
        footer.original_image_size = original_image_size
        footer.vbmeta_offset = vbmeta_offset
        footer.vbmeta_size = len(vbmeta_blob)
        footer_blob = footer.encode()
        footer_blob_with_padding = (
            b'\0' * (image.block_size - AvbFooter.SIZE) + footer_blob)
        image.append_raw(footer_blob_with_padding)

    except Exception as e:
      # Truncate back to original size, then re-raise.
      image.truncate(original_image_size)
      raise AvbError('Adding hashtree_footer failed: {}.'.format(e)) from e

  def make_atx_certificate(self, output, authority_key_path, subject_key_path,
                          subject_key_version, subject,
                          is_intermediate_authority, usage, signing_helper,
                          signing_helper_with_files):
    """Implements the 'make_atx_certificate' command.

    Android Things certificates are required for Android Things public key
    metadata. They chain the vbmeta signing key for a particular product back to
    a fused, permanent root key. These certificates are fixed-length and fixed-
    format with the explicit goal of not parsing ASN.1 in bootloader code.

    Arguments:
      output: Certificate will be written to this file on success.
      authority_key_path: A PEM file path with the authority private key.
                          If None, then a certificate will be created without a
                          signature. The signature can be created out-of-band
                          and appended.
      subject_key_path: Path to a PEM or DER subject public key.
      subject_key_version: A 64-bit version value. If this is None, the number
                          of seconds since the epoch is used.
      subject: A subject identifier. For Product Signing Key certificates this
              should be the same Product ID found in the permanent attributes.
      is_intermediate_authority: True if the certificate is for an intermediate
                                authority.
      usage: If not empty, overrides the cert usage with a hash of this value.
      signing_helper: Program which signs a hash and returns the signature.
      signing_helper_with_files: Same as signing_helper but uses files instead.

    Raises:
      AvbError: If there an error during signing.
    """
    signed_data = bytearray()
    signed_data.extend(struct.pack('<I', 1))  # Format Version
    signed_data.extend(RSAPublicKey(subject_key_path).encode())
    hasher = hashlib.sha256()
    hasher.update(subject)
    signed_data.extend(hasher.digest())
    if not usage:
      usage = 'com.google.android.things.vboot'
      if is_intermediate_authority:
        usage += '.ca'
    hasher = hashlib.sha256()
    hasher.update(usage.encode('ascii'))
    signed_data.extend(hasher.digest())
    if subject_key_version is None:
      subject_key_version = int(time.time())
    signed_data.extend(struct.pack('<Q', subject_key_version))
    signature = b''
    if authority_key_path:
      rsa_key = RSAPublicKey(authority_key_path)
      algorithm_name = 'SHA512_RSA4096'
      signature = rsa_key.sign(algorithm_name, signed_data, signing_helper,
                              signing_helper_with_files)
    output.write(signed_data)
    output.write(signature)

  def make_atx_permanent_attributes(self, output, root_authority_key_path,
                                    product_id):
    """Implements the 'make_atx_permanent_attributes' command.

    Android Things permanent attributes are designed to be permanent for a
    particular product and a hash of these attributes should be fused into
    hardware to enforce this.

    Arguments:
      output: Attributes will be written to this file on success.
      root_authority_key_path: Path to a PEM or DER public key for
        the root authority.
      product_id: A 16-byte Product ID.

    Raises:
      AvbError: If an argument is incorrect.
    """
    EXPECTED_PRODUCT_ID_SIZE = 16  # pylint: disable=invalid-name
    if len(product_id) != EXPECTED_PRODUCT_ID_SIZE:
      raise AvbError('Invalid Product ID length.')
    output.write(struct.pack('<I', 1))  # Format Version
    output.write(RSAPublicKey(root_authority_key_path).encode())
    output.write(product_id)

  def make_atx_metadata(self, output, intermediate_key_certificate,
                        product_key_certificate):
    """Implements the 'make_atx_metadata' command.

    Android Things metadata are included in vbmeta images to facilitate
    verification. The output of this command can be used as the
    public_key_metadata argument to other commands.

    Arguments:
      output: Metadata will be written to this file on success.
      intermediate_key_certificate: A certificate file as output by
                                    make_atx_certificate with
                                    is_intermediate_authority set to true.
      product_key_certificate: A certificate file as output by
                              make_atx_certificate with
                              is_intermediate_authority set to false.

    Raises:
      AvbError: If an argument is incorrect.
    """
    EXPECTED_CERTIFICATE_SIZE = 1620  # pylint: disable=invalid-name
    if len(intermediate_key_certificate) != EXPECTED_CERTIFICATE_SIZE:
      raise AvbError('Invalid intermediate key certificate length.')
    if len(product_key_certificate) != EXPECTED_CERTIFICATE_SIZE:
      raise AvbError('Invalid product key certificate length.')
    output.write(struct.pack('<I', 1))  # Format Version
    output.write(intermediate_key_certificate)
    output.write(product_key_certificate)

  def make_atx_unlock_credential(self, output, intermediate_key_certificate,
                                unlock_key_certificate, challenge_path,
                                unlock_key_path, signing_helper,
                                signing_helper_with_files):
    """Implements the 'make_atx_unlock_credential' command.

    Android Things unlock credentials can be used to authorize the unlock of AVB
    on a device. These credentials are presented to an Android Things bootloader
    via the fastboot interface in response to a 16-byte challenge. This method
    creates all fields of the credential except the challenge signature field
    (which is the last field) and can optionally create the challenge signature
    field as well if a challenge and the unlock_key_path is provided.

    Arguments:
      output: The credential will be written to this file on success.
      intermediate_key_certificate: A certificate file as output by
                                    make_atx_certificate with
                                    is_intermediate_authority set to true.
      unlock_key_certificate: A certificate file as output by
                              make_atx_certificate with
                              is_intermediate_authority set to false and the
                              usage set to
                              'com.google.android.things.vboot.unlock'.
      challenge_path: [optional] A path to the challenge to sign.
      unlock_key_path: [optional] A PEM file path with the unlock private key.
      signing_helper: Program which signs a hash and returns the signature.
      signing_helper_with_files: Same as signing_helper but uses files instead.

    Raises:
      AvbError: If an argument is incorrect or an error occurs during signing.
    """
    EXPECTED_CERTIFICATE_SIZE = 1620  # pylint: disable=invalid-name
    EXPECTED_CHALLENGE_SIZE = 16  # pylint: disable=invalid-name
    if len(intermediate_key_certificate) != EXPECTED_CERTIFICATE_SIZE:
      raise AvbError('Invalid intermediate key certificate length.')
    if len(unlock_key_certificate) != EXPECTED_CERTIFICATE_SIZE:
      raise AvbError('Invalid product key certificate length.')
    challenge = b''
    if challenge_path:
      with open(challenge_path, 'rb') as f:
        challenge = f.read()
      if len(challenge) != EXPECTED_CHALLENGE_SIZE:
        raise AvbError('Invalid unlock challenge length.')
    output.write(struct.pack('<I', 1))  # Format Version
    output.write(intermediate_key_certificate)
    output.write(unlock_key_certificate)
    if challenge_path and unlock_key_path:
      rsa_key = RSAPublicKey(unlock_key_path)
      algorithm_name = 'SHA512_RSA4096'
      signature = rsa_key.sign(algorithm_name, challenge, signing_helper,
                              signing_helper_with_files)
      output.write(signature)


def calc_hash_level_offsets(image_size, block_size, digest_size):
  """Calculate the offsets of all the hash-levels in a Merkle-tree.

  Arguments:
    image_size: The size of the image to calculate a Merkle-tree for.
    block_size: The block size, e.g. 4096.
    digest_size: The size of each hash, e.g. 32 for SHA-256.

  Returns:
    A tuple where the first argument is an array of offsets and the
    second is size of the tree, in bytes.
  """
  level_offsets = []
  level_sizes = []
  tree_size = 0

  num_levels = 0
  size = image_size
  while size > block_size:
    num_blocks = (size + block_size - 1) // block_size
    level_size = round_to_multiple(num_blocks * digest_size, block_size)

    level_sizes.append(level_size)
    tree_size += level_size
    num_levels += 1

    size = level_size

  for n in range(0, num_levels):
    offset = 0
    for m in range(n + 1, num_levels):
      offset += level_sizes[m]
    level_offsets.append(offset)

  return level_offsets, tree_size


# See system/extras/libfec/include/fec/io.h for these definitions.
FEC_FOOTER_FORMAT = '<LLLLLQ32s'
FEC_MAGIC = 0xfecfecfe


def calc_fec_data_size(image_size, num_roots):
  """Calculates how much space FEC data will take.

  Arguments:
    image_size: The size of the image.
    num_roots: Number of roots.

  Returns:
    The number of bytes needed for FEC for an image of the given size
    and with the requested number of FEC roots.

  Raises:
    ValueError: If output from the 'fec' tool is invalid.
  """
  p = subprocess.Popen(
      ['fec', '--print-fec-size', str(image_size), '--roots', str(num_roots)],
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE)
  (pout, perr) = p.communicate()
  retcode = p.wait()
  if retcode != 0:
    raise ValueError('Error invoking fec: {}'.format(perr))
  return int(pout)


def generate_fec_data(image_filename, num_roots):
  """Generate FEC codes for an image.

  Arguments:
    image_filename: The filename of the image.
    num_roots: Number of roots.

  Returns:
    The FEC data blob as bytes.

  Raises:
    ValueError: If calling the 'fec' tool failed or the output is invalid.
  """
  with tempfile.NamedTemporaryFile() as fec_tmpfile:
    try:
      subprocess.check_call(
          ['fec', '--encode', '--roots', str(num_roots), image_filename,
          fec_tmpfile.name],
          stderr=open(os.devnull, 'wb'))
    except subprocess.CalledProcessError as e:
      raise ValueError('Execution of \'fec\' tool failed: {}.'
                      .format(e)) from e
    fec_data = fec_tmpfile.read()

  footer_size = struct.calcsize(FEC_FOOTER_FORMAT)
  footer_data = fec_data[-footer_size:]
  (magic, _, _, num_roots, fec_size, _, _) = struct.unpack(FEC_FOOTER_FORMAT,
                                                          footer_data)
  if magic != FEC_MAGIC:
    raise ValueError('Unexpected magic in FEC footer')
  return fec_data[0:fec_size]


def generate_hash_tree(image, image_size, block_size, hash_alg_name, salt,
                      digest_padding, hash_level_offsets, tree_size):
  """Generates a Merkle-tree for a file.

  Arguments:
    image: The image, as a file.
    image_size: The size of the image.
    block_size: The block size, e.g. 4096.
    hash_alg_name: The hash algorithm, e.g. 'sha256' or 'sha1'.
    salt: The salt to use.
    digest_padding: The padding for each digest.
    hash_level_offsets: The offsets from calc_hash_level_offsets().
    tree_size: The size of the tree, in number of bytes.

  Returns:
    A tuple where the first element is the top-level hash as bytes and the
    second element is the hash-tree as bytes.
  """
  hash_ret = bytearray(tree_size)
  hash_src_offset = 0
  hash_src_size = image_size
  level_num = 0

  # If there is only one block, returns the top-level hash directly.
  if hash_src_size == block_size:
    hasher = create_avb_hashtree_hasher(hash_alg_name, salt)
    image.seek(0)
    hasher.update(image.read(block_size))
    return hasher.digest(), bytes(hash_ret)

  while hash_src_size > block_size:
    level_output_list = []
    remaining = hash_src_size
    while remaining > 0:
      hasher = create_avb_hashtree_hasher(hash_alg_name, salt)
      # Only read from the file for the first level - for subsequent
      # levels, access the array we're building.
      if level_num == 0:
        image.seek(hash_src_offset + hash_src_size - remaining)
        data = image.read(min(remaining, block_size))
      else:
        offset = hash_level_offsets[level_num - 1] + hash_src_size - remaining
        data = hash_ret[offset:offset + block_size]
      hasher.update(data)

      remaining -= len(data)
      if len(data) < block_size:
        hasher.update(b'\0' * (block_size - len(data)))
      level_output_list.append(hasher.digest())
      if digest_padding > 0:
        level_output_list.append(b'\0' * digest_padding)

    level_output = b''.join(level_output_list)

    padding_needed = (round_to_multiple(
        len(level_output), block_size) - len(level_output))
    level_output += b'\0' * padding_needed

    # Copy level-output into resulting tree.
    offset = hash_level_offsets[level_num]
    hash_ret[offset:offset + len(level_output)] = level_output

    # Continue on to the next level.
    hash_src_size = len(level_output)
    level_num += 1

  hasher = create_avb_hashtree_hasher(hash_alg_name, salt)
  hasher.update(level_output)
  return hasher.digest(), bytes(hash_ret)


class AvbTool(object):
  """Object for avbtool command-line tool."""

  def __init__(self):
    """Initializer method."""
    self.avb = Avb()

  def _add_common_args(self, sub_parser):
    """Adds arguments used by several sub-commands.

    Arguments:
      sub_parser: The parser to add arguments to.
    """
    sub_parser.add_argument('--algorithm',
                            help='Algorithm to use (default: NONE)',
                            metavar='ALGORITHM',
                            default='NONE')
    sub_parser.add_argument('--key',
                            help='Path to RSA private key file',
                            metavar='KEY',
                            required=False)
    sub_parser.add_argument('--signing_helper',
                            help='Path to helper used for signing',
                            metavar='APP',
                            default=None,
                            required=False)
    sub_parser.add_argument('--signing_helper_with_files',
                            help='Path to helper used for signing using files',
                            metavar='APP',
                            default=None,
                            required=False)
    sub_parser.add_argument('--public_key_metadata',
                            help='Path to public key metadata file',
                            metavar='KEY_METADATA',
                            required=False)
    sub_parser.add_argument('--rollback_index',
                            help='Rollback Index',
                            type=parse_number,
                            default=0)
    sub_parser.add_argument('--rollback_index_location',
                            help='Location of main vbmeta Rollback Index',
                            type=parse_number,
                            default=0)
    # This is used internally for unit tests. Do not include in --help output.
    sub_parser.add_argument('--internal_release_string',
                            help=argparse.SUPPRESS)
    sub_parser.add_argument('--append_to_release_string',
                            help='Text to append to release string',
                            metavar='STR')
    sub_parser.add_argument('--prop',
                            help='Add property',
                            metavar='KEY:VALUE',
                            action='append')
    sub_parser.add_argument('--prop_from_file',
                            help='Add property from file',
                            metavar='KEY:PATH',
                            action='append')
    sub_parser.add_argument('--kernel_cmdline',
                            help='Add kernel cmdline',
                            metavar='CMDLINE',
                            action='append')
    # TODO(zeuthen): the --setup_rootfs_from_kernel option used to be called
    # --generate_dm_verity_cmdline_from_hashtree. Remove support for the latter
    # at some future point.
    sub_parser.add_argument('--setup_rootfs_from_kernel',
                            '--generate_dm_verity_cmdline_from_hashtree',
                            metavar='IMAGE',
                            help='Adds kernel cmdline to set up IMAGE',
                            type=argparse.FileType('rb'))
    sub_parser.add_argument('--include_descriptors_from_image',
                            help='Include descriptors from image',
                            metavar='IMAGE',
                            action='append',
                            type=argparse.FileType('rb'))
    sub_parser.add_argument('--print_required_libavb_version',
                            help=('Don\'t store the footer - '
                                  'instead calculate the required libavb '
                                  'version for the given options.'),
                            action='store_true')
    # These are only allowed from top-level vbmeta and boot-in-lieu-of-vbmeta.
    sub_parser.add_argument('--chain_partition',
                            help='Allow signed integrity-data for partition',
                            metavar='PART_NAME:ROLLBACK_SLOT:KEY_PATH',
                            action='append')
    sub_parser.add_argument('--chain_partition_do_not_use_ab',
                            help='Allow signed integrity-data for partition does not use A/B',
                            metavar='PART_NAME:ROLLBACK_SLOT:KEY_PATH',
                            action='append',
                            required=False)
    sub_parser.add_argument('--flags',
                            help='VBMeta flags',
                            type=parse_number,
                            default=0)
    sub_parser.add_argument('--set_hashtree_disabled_flag',
                            help='Set the HASHTREE_DISABLED flag',
                            action='store_true')

  def _add_common_footer_args(self, sub_parser):
    """Adds arguments used by add_*_footer sub-commands.

    Arguments:
      sub_parser: The parser to add arguments to.
    """
    sub_parser.add_argument('--use_persistent_digest',
                            help='Use a persistent digest on device instead of '
                                'storing the digest in the descriptor. This '
                                'cannot be used with A/B so must be combined '
                                'with --do_not_use_ab when an A/B suffix is '
                                'expected at runtime.',
                            action='store_true')
    sub_parser.add_argument('--do_not_use_ab',
                            help='The partition does not use A/B even when an '
                                'A/B suffix is present. This must not be used '
                                'for vbmeta or chained partitions.',
                            action='store_true')

  def _fixup_common_args(self, args):
    """Common fixups needed by subcommands.

    Arguments:
      args: Arguments to modify.

    Returns:
      The modified arguments.
    """
    if args.set_hashtree_disabled_flag:
      args.flags |= AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED
    return args

  def run(self, argv):
    """Command-line processor.

    Arguments:
      argv: Pass sys.argv from main.
    """
    from runtime import get_verbose

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title='subcommands')

    sub_parser = subparsers.add_parser(
        'generate_test_image',
        help=('Generates a test image with a known pattern for testing: '
              '0x00 0x01 0x02 ... 0xff 0x00 0x01 ...'))
    sub_parser.add_argument('--image_size',
                            help='Size of image to generate.',
                            type=parse_number,
                            required=True)
    sub_parser.add_argument('--start_byte',
                            help='Integer for the start byte of the pattern.',
                            type=parse_number,
                            default=0)
    sub_parser.add_argument('--output',
                            help='Output file name.',
                            type=argparse.FileType('wb'),
                            default=sys.stdout)
    sub_parser.set_defaults(func=self.generate_test_image)

    sub_parser = subparsers.add_parser('version',
                                      help='Prints version of avbtool.')
    sub_parser.set_defaults(func=self.version)

    sub_parser = subparsers.add_parser('extract_public_key',
                                      help='Extract public key.')
    sub_parser.add_argument('--key',
                            help='Path to RSA private key file',
                            required=True)
    sub_parser.add_argument('--output',
                            help='Output file name',
                            type=argparse.FileType('wb'),
                            required=True)
    sub_parser.set_defaults(func=self.extract_public_key)

    sub_parser = subparsers.add_parser('make_vbmeta_image',
                                      help='Makes a vbmeta image.')
    sub_parser.add_argument('--output',
                            help='Output file name',
                            type=argparse.FileType('wb'))
    sub_parser.add_argument('--padding_size',
                            metavar='NUMBER',
                            help='If non-zero, pads output with NUL bytes so '
                                'its size is a multiple of NUMBER '
                                '(default: 0)',
                            type=parse_number,
                            default=0)
    self._add_common_args(sub_parser)
    sub_parser.set_defaults(func=self.make_vbmeta_image)

    sub_parser = subparsers.add_parser('add_hash_footer',
                                      help='Add hashes and footer to image.')
    sub_parser.add_argument('--image',
                            help='Image to add hashes to')
    sub_parser.add_argument('--partition_size',
                            help='Partition size',
                            type=parse_number)
    sub_parser.add_argument('--dynamic_partition_size',
                            help='Calculate partition size based on image size',
                            action='store_true')
    sub_parser.add_argument('--partition_name',
                            help='Partition name',
                            default=None)
    sub_parser.add_argument('--hash_algorithm',
                            help='Hash algorithm to use (default: sha256)',
                            default='sha256')
    sub_parser.add_argument('--salt',
                            help='Salt in hex (default: /dev/urandom)')
    sub_parser.add_argument('--calc_max_image_size',
                            help=('Don\'t store the footer - '
                                  'instead calculate the maximum image size '
                                  'leaving enough room for metadata with '
                                  'the given partition size.'),
                            action='store_true')
    sub_parser.add_argument('--output_vbmeta_image',
                            help='Also write vbmeta struct to file',
                            type=argparse.FileType('wb'))
    sub_parser.add_argument('--do_not_append_vbmeta_image',
                            help=('Do not append vbmeta struct or footer '
                                  'to the image'),
                            action='store_true')
    self._add_common_args(sub_parser)
    self._add_common_footer_args(sub_parser)
    sub_parser.set_defaults(func=self.add_hash_footer)

    sub_parser = subparsers.add_parser('append_vbmeta_image',
                                      help='Append vbmeta image to image.')
    sub_parser.add_argument('--image',
                            help='Image to append vbmeta blob to',
                            type=argparse.FileType('rb+'))
    sub_parser.add_argument('--partition_size',
                            help='Partition size',
                            type=parse_number,
                            required=True)
    sub_parser.add_argument('--vbmeta_image',
                            help='Image with vbmeta blob to append',
                            type=argparse.FileType('rb'))
    sub_parser.set_defaults(func=self.append_vbmeta_image)

    sub_parser = subparsers.add_parser(
        'add_hashtree_footer',
        help='Add hashtree and footer to image.')
    sub_parser.add_argument('--image',
                            help='Image to add hashtree to',
                            type=argparse.FileType('rb+'))
    sub_parser.add_argument('--partition_size',
                            help='Partition size',
                            default=0,
                            type=parse_number)
    sub_parser.add_argument('--partition_name',
                            help='Partition name',
                            default='')
    sub_parser.add_argument('--hash_algorithm',
                            help='Hash algorithm to use (default: sha1)',
                            default='sha1')
    sub_parser.add_argument('--salt',
                            help='Salt in hex (default: /dev/urandom)')
    sub_parser.add_argument('--block_size',
                            help='Block size (default: 4096)',
                            type=parse_number,
                            default=4096)
    # TODO(zeuthen): The --generate_fec option was removed when we
    # moved to generating FEC by default. To avoid breaking existing
    # users needing to transition we simply just print a warning below
    # in add_hashtree_footer(). Remove this option and the warning at
    # some point in the future.
    sub_parser.add_argument('--generate_fec',
                            help=argparse.SUPPRESS,
                            action='store_true')
    sub_parser.add_argument(
        '--do_not_generate_fec',
        help='Do not generate forward-error-correction codes',
        action='store_true')
    sub_parser.add_argument('--fec_num_roots',
                            help='Number of roots for FEC (default: 2)',
                            type=parse_number,
                            default=2)
    sub_parser.add_argument('--calc_max_image_size',
                            help=('Don\'t store the hashtree or footer - '
                                  'instead calculate the maximum image size '
                                  'leaving enough room for hashtree '
                                  'and metadata with the given partition '
                                  'size.'),
                            action='store_true')
    sub_parser.add_argument('--output_vbmeta_image',
                            help='Also write vbmeta struct to file',
                            type=argparse.FileType('wb'))
    sub_parser.add_argument('--do_not_append_vbmeta_image',
                            help=('Do not append vbmeta struct or footer '
                                  'to the image'),
                            action='store_true')
    # This is different from --setup_rootfs_from_kernel insofar that
    # it doesn't take an IMAGE, the generated cmdline will be for the
    # hashtree we're adding.
    sub_parser.add_argument('--setup_as_rootfs_from_kernel',
                            action='store_true',
                            help='Adds kernel cmdline for setting up rootfs')
    sub_parser.add_argument('--no_hashtree',
                            action='store_true',
                            help='Do not append hashtree')
    sub_parser.add_argument('--check_at_most_once',
                            action='store_true',
                            help='Set to verify data block only once')
    self._add_common_args(sub_parser)
    self._add_common_footer_args(sub_parser)
    sub_parser.set_defaults(func=self.add_hashtree_footer)

    sub_parser = subparsers.add_parser('erase_footer',
                                      help='Erase footer from an image.')
    sub_parser.add_argument('--image',
                            help='Image with a footer',
                            type=argparse.FileType('rb+'),
                            required=True)
    sub_parser.add_argument('--keep_hashtree',
                            help='Keep the hashtree and FEC in the image',
                            action='store_true')
    sub_parser.set_defaults(func=self.erase_footer)

    sub_parser = subparsers.add_parser('zero_hashtree',
                                      help='Zero out hashtree and FEC data.')
    sub_parser.add_argument('--image',
                            help='Image with a footer',
                            type=argparse.FileType('rb+'),
                            required=True)
    sub_parser.set_defaults(func=self.zero_hashtree)

    sub_parser = subparsers.add_parser(
        'extract_vbmeta_image',
        help='Extracts vbmeta from an image with a footer.')
    sub_parser.add_argument('--image',
                            help='Image with footer',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--output',
                            help='Output file name',
                            type=argparse.FileType('wb'))
    sub_parser.add_argument('--padding_size',
                            metavar='NUMBER',
                            help='If non-zero, pads output with NUL bytes so '
                                'its size is a multiple of NUMBER '
                                '(default: 0)',
                            type=parse_number,
                            default=0)
    sub_parser.set_defaults(func=self.extract_vbmeta_image)

    sub_parser = subparsers.add_parser('resize_image',
                                      help='Resize image with a footer.')
    sub_parser.add_argument('--image',
                            help='Image with a footer',
                            type=argparse.FileType('rb+'),
                            required=True)
    sub_parser.add_argument('--partition_size',
                            help='New partition size',
                            type=parse_number)
    sub_parser.set_defaults(func=self.resize_image)

    sub_parser = subparsers.add_parser(
        'info_image',
        help='Show information about vbmeta or footer.')
    sub_parser.add_argument('--image',
                            help='Image to show information about',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--output',
                            help='Write info to file',
                            type=argparse.FileType('wt'),
                            default=sys.stdout)
    sub_parser.add_argument('--atx',
                            help=('Show information about Android Things '
                                  'eXtension (ATX).'),
                            action='store_true')
    sub_parser.set_defaults(func=self.info_image)

    sub_parser = subparsers.add_parser(
        'verify_image',
        help='Verify an image.')
    sub_parser.add_argument('--image',
                            help='Image to verify',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--key',
                            help='Check embedded public key matches KEY',
                            metavar='KEY',
                            required=False)
    sub_parser.add_argument('--expected_chain_partition',
                            help='Expected chain partition',
                            metavar='PART_NAME:ROLLBACK_SLOT:KEY_PATH',
                            action='append')
    sub_parser.add_argument(
        '--follow_chain_partitions',
        help=('Follows chain partitions even when not '
              'specified with the --expected_chain_partition option'),
        action='store_true')
    sub_parser.add_argument(
        '--accept_zeroed_hashtree',
        help=('Accept images where the hashtree or FEC data is zeroed out'),
        action='store_true')
    sub_parser.set_defaults(func=self.verify_image)

    sub_parser = subparsers.add_parser(
        'print_partition_digests',
        help='Prints partition digests.')
    sub_parser.add_argument('--image',
                            help='Image to print partition digests from',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--output',
                            help='Write info to file',
                            type=argparse.FileType('wt'),
                            default=sys.stdout)
    sub_parser.add_argument('--json',
                            help=('Print output as JSON'),
                            action='store_true')
    sub_parser.set_defaults(func=self.print_partition_digests)

    sub_parser = subparsers.add_parser(
        'calculate_vbmeta_digest',
        help='Calculate vbmeta digest.')
    sub_parser.add_argument('--image',
                            help='Image to calculate digest for',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--hash_algorithm',
                            help='Hash algorithm to use (default: sha256)',
                            default='sha256')
    sub_parser.add_argument('--output',
                            help='Write hex digest to file (default: stdout)',
                            type=argparse.FileType('wt'),
                            default=sys.stdout)
    sub_parser.set_defaults(func=self.calculate_vbmeta_digest)

    sub_parser = subparsers.add_parser(
        'calculate_kernel_cmdline',
        help='Calculate kernel cmdline.')
    sub_parser.add_argument('--image',
                            help='Image to calculate kernel cmdline for',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--hashtree_disabled',
                            help='Return the cmdline for hashtree disabled',
                            action='store_true')
    sub_parser.add_argument('--output',
                            help='Write cmdline to file (default: stdout)',
                            type=argparse.FileType('wt'),
                            default=sys.stdout)
    sub_parser.set_defaults(func=self.calculate_kernel_cmdline)

    sub_parser = subparsers.add_parser('set_ab_metadata',
                                      help='Set A/B metadata.')
    sub_parser.add_argument('--misc_image',
                            help=('The misc image to modify. If the image does '
                                  'not exist, it will be created.'),
                            type=argparse.FileType('r+b'),
                            required=True)
    sub_parser.add_argument('--slot_data',
                            help=('Slot data of the form "priority", '
                                  '"tries_remaining", "sucessful_boot" for '
                                  'slot A followed by the same for slot B, '
                                  'separated by colons. The default value '
                                  'is 15:7:0:14:7:0.'),
                            default='15:7:0:14:7:0')
    sub_parser.set_defaults(func=self.set_ab_metadata)

    sub_parser = subparsers.add_parser(
        'make_atx_certificate',
        help='Create an Android Things eXtension (ATX) certificate.')
    sub_parser.add_argument('--output',
                            help='Write certificate to file',
                            type=argparse.FileType('wb'),
                            default=sys.stdout)
    sub_parser.add_argument('--subject',
                            help=('Path to subject file'),
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--subject_key',
                            help=('Path to subject RSA public key file'),
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--subject_key_version',
                            help=('Version of the subject key'),
                            type=parse_number,
                            required=False)
    sub_parser.add_argument('--subject_is_intermediate_authority',
                            help=('Generate an intermediate authority '
                                  'certificate'),
                            action='store_true')
    sub_parser.add_argument('--usage',
                            help=('Override usage with a hash of the provided '
                                  'string'),
                            required=False)
    sub_parser.add_argument('--authority_key',
                            help='Path to authority RSA private key file',
                            required=False)
    sub_parser.add_argument('--signing_helper',
                            help='Path to helper used for signing',
                            metavar='APP',
                            default=None,
                            required=False)
    sub_parser.add_argument('--signing_helper_with_files',
                            help='Path to helper used for signing using files',
                            metavar='APP',
                            default=None,
                            required=False)
    sub_parser.set_defaults(func=self.make_atx_certificate)

    sub_parser = subparsers.add_parser(
        'make_atx_permanent_attributes',
        help='Create Android Things eXtension (ATX) permanent attributes.')
    sub_parser.add_argument('--output',
                            help='Write attributes to file',
                            type=argparse.FileType('wb'),
                            default=sys.stdout)
    sub_parser.add_argument('--root_authority_key',
                            help='Path to authority RSA public key file',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--product_id',
                            help=('Path to Product ID file'),
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.set_defaults(func=self.make_atx_permanent_attributes)

    sub_parser = subparsers.add_parser(
        'make_atx_metadata',
        help='Create Android Things eXtension (ATX) metadata.')
    sub_parser.add_argument('--output',
                            help='Write metadata to file',
                            type=argparse.FileType('wb'),
                            default=sys.stdout)
    sub_parser.add_argument('--intermediate_key_certificate',
                            help='Path to intermediate key certificate file',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--product_key_certificate',
                            help='Path to product key certificate file',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.set_defaults(func=self.make_atx_metadata)

    sub_parser = subparsers.add_parser(
        'make_atx_unlock_credential',
        help='Create an Android Things eXtension (ATX) unlock credential.')
    sub_parser.add_argument('--output',
                            help='Write credential to file',
                            type=argparse.FileType('wb'),
                            default=sys.stdout)
    sub_parser.add_argument('--intermediate_key_certificate',
                            help='Path to intermediate key certificate file',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--unlock_key_certificate',
                            help='Path to unlock key certificate file',
                            type=argparse.FileType('rb'),
                            required=True)
    sub_parser.add_argument('--challenge',
                            help='Path to the challenge to sign (optional). If '
                                'this is not provided the challenge signature '
                                'field is omitted and can be concatenated '
                                'later.',
                            required=False)
    sub_parser.add_argument('--unlock_key',
                            help='Path to unlock key (optional). Must be '
                                'provided if using --challenge.',
                            required=False)
    sub_parser.add_argument('--signing_helper',
                            help='Path to helper used for signing',
                            metavar='APP',
                            default=None,
                            required=False)
    sub_parser.add_argument('--signing_helper_with_files',
                            help='Path to helper used for signing using files',
                            metavar='APP',
                            default=None,
                            required=False)
    sub_parser.set_defaults(func=self.make_atx_unlock_credential)

    args = parser.parse_args(argv[1:])
    try:
      result = args.func(args)
      return result
    except AttributeError:
      # This error gets raised when the command line tool is called without any
      # arguments. It mimics the original Python 2 behavior.
      parser.print_usage()
      print('avbtool: error: too few arguments')
      if get_verbose():
        traceback.print_exc()
      # sys.exit(2)
    except AvbError as e:
      sys.stderr.write('{}: {}\n'.format(argv[0], str(e)))
      if get_verbose():
        traceback.print_exc()
      # sys.exit(1)

  def version(self, _):
    """Implements the 'version' sub-command."""
    print(get_release_string())

  def generate_test_image(self, args):
    """Implements the 'generate_test_image' sub-command."""
    self.avb.generate_test_image(args.output, args.image_size, args.start_byte)

  def extract_public_key(self, args):
    """Implements the 'extract_public_key' sub-command."""
    self.avb.extract_public_key(args.key, args.output)

  def make_vbmeta_image(self, args):
    """Implements the 'make_vbmeta_image' sub-command."""
    args = self._fixup_common_args(args)
    self.avb.make_vbmeta_image(args.output, args.chain_partition,
                              args.chain_partition_do_not_use_ab,
                              args.algorithm, args.key,
                              args.public_key_metadata, args.rollback_index,
                              args.flags, args.rollback_index_location,
                              args.prop, args.prop_from_file,
                              args.kernel_cmdline,
                              args.setup_rootfs_from_kernel,
                              args.include_descriptors_from_image,
                              args.signing_helper,
                              args.signing_helper_with_files,
                              args.internal_release_string,
                              args.append_to_release_string,
                              args.print_required_libavb_version,
                              args.padding_size)

  def append_vbmeta_image(self, args):
    """Implements the 'append_vbmeta_image' sub-command."""
    self.avb.append_vbmeta_image(args.image.name, args.vbmeta_image.name,
                                args.partition_size)

  def add_hash_footer(self, args):
    """Implements the 'add_hash_footer' sub-command."""
    args = self._fixup_common_args(args)
    self.avb.add_hash_footer(args.image,
                            args.partition_size, args.dynamic_partition_size,
                            args.partition_name, args.hash_algorithm,
                            args.salt, args.chain_partition,
                            args.chain_partition_do_not_use_ab,
                            args.algorithm, args.key,
                            args.public_key_metadata, args.rollback_index,
                            args.flags, args.rollback_index_location,
                            args.prop, args.prop_from_file,
                            args.kernel_cmdline,
                            args.setup_rootfs_from_kernel,
                            args.include_descriptors_from_image,
                            args.calc_max_image_size,
                            args.signing_helper,
                            args.signing_helper_with_files,
                            args.internal_release_string,
                            args.append_to_release_string,
                            args.output_vbmeta_image,
                            args.do_not_append_vbmeta_image,
                            args.print_required_libavb_version,
                            args.use_persistent_digest,
                            args.do_not_use_ab)

  def add_hashtree_footer(self, args):
    """Implements the 'add_hashtree_footer' sub-command."""
    args = self._fixup_common_args(args)
    # TODO(zeuthen): Remove when removing support for the
    # '--generate_fec' option above.
    if args.generate_fec:
      sys.stderr.write('The --generate_fec option is deprecated since FEC '
                      'is now generated by default. Use the option '
                      '--do_not_generate_fec to not generate FEC.\n')
    self.avb.add_hashtree_footer(
        args.image.name if args.image else None,
        args.partition_size,
        args.partition_name,
        not args.do_not_generate_fec, args.fec_num_roots,
        args.hash_algorithm, args.block_size,
        args.salt, args.chain_partition,
        args.chain_partition_do_not_use_ab,
        args.algorithm,
        args.key, args.public_key_metadata,
        args.rollback_index, args.flags,
        args.rollback_index_location, args.prop,
        args.prop_from_file,
        args.kernel_cmdline,
        args.setup_rootfs_from_kernel,
        args.setup_as_rootfs_from_kernel,
        args.include_descriptors_from_image,
        args.calc_max_image_size,
        args.signing_helper,
        args.signing_helper_with_files,
        args.internal_release_string,
        args.append_to_release_string,
        args.output_vbmeta_image,
        args.do_not_append_vbmeta_image,
        args.print_required_libavb_version,
        args.use_persistent_digest,
        args.do_not_use_ab,
        args.no_hashtree,
        args.check_at_most_once)

  def erase_footer(self, args):
    """Implements the 'erase_footer' sub-command."""
    self.avb.erase_footer(args.image.name, args.keep_hashtree)

  def zero_hashtree(self, args):
    """Implements the 'zero_hashtree' sub-command."""
    self.avb.zero_hashtree(args.image.name)

  def extract_vbmeta_image(self, args):
    """Implements the 'extract_vbmeta_image' sub-command."""
    self.avb.extract_vbmeta_image(args.output, args.image.name,
                                  args.padding_size)

  def resize_image(self, args):
    """Implements the 'resize_image' sub-command."""
    self.avb.resize_image(args.image.name, args.partition_size)

  def set_ab_metadata(self, args):
    """Implements the 'set_ab_metadata' sub-command."""
    self.avb.set_ab_metadata(args.misc_image, args.slot_data)

  def info_image(self, args):
    """Implements the 'info_image' sub-command."""
    result = self.avb.info_image(args.image.name, args.output, args.atx)
    return result

  def verify_image(self, args):
    """Implements the 'verify_image' sub-command."""
    self.avb.verify_image(args.image.name, args.key,
                          args.expected_chain_partition,
                          args.follow_chain_partitions,
                          args.accept_zeroed_hashtree)

  def print_partition_digests(self, args):
    """Implements the 'print_partition_digests' sub-command."""
    self.avb.print_partition_digests(args.image.name, args.output, args.json)

  def calculate_vbmeta_digest(self, args):
    """Implements the 'calculate_vbmeta_digest' sub-command."""
    self.avb.calculate_vbmeta_digest(args.image.name, args.hash_algorithm,
                                    args.output)

  def calculate_kernel_cmdline(self, args):
    """Implements the 'calculate_kernel_cmdline' sub-command."""
    self.avb.calculate_kernel_cmdline(args.image.name, args.hashtree_disabled,
                                      args.output)

  def make_atx_certificate(self, args):
    """Implements the 'make_atx_certificate' sub-command."""
    self.avb.make_atx_certificate(args.output, args.authority_key,
                                  args.subject_key.name,
                                  args.subject_key_version,
                                  args.subject.read(),
                                  args.subject_is_intermediate_authority,
                                  args.usage,
                                  args.signing_helper,
                                  args.signing_helper_with_files)

  def make_atx_permanent_attributes(self, args):
    """Implements the 'make_atx_permanent_attributes' sub-command."""
    self.avb.make_atx_permanent_attributes(args.output,
                                          args.root_authority_key.name,
                                          args.product_id.read())

  def make_atx_metadata(self, args):
    """Implements the 'make_atx_metadata' sub-command."""
    self.avb.make_atx_metadata(args.output,
                              args.intermediate_key_certificate.read(),
                              args.product_key_certificate.read())

  def make_atx_unlock_credential(self, args):
    """Implements the 'make_atx_unlock_credential' sub-command."""
    self.avb.make_atx_unlock_credential(
        args.output,
        args.intermediate_key_certificate.read(),
        args.unlock_key_certificate.read(),
        args.challenge,
        args.unlock_key,
        args.signing_helper,
        args.signing_helper_with_files)


if __name__ == '__main__':
  if AVB_INVOCATION_LOGFILE:
    with open(AVB_INVOCATION_LOGFILE, 'a') as log:
      log.write(' '.join(sys.argv))
      log.write('\n')

  tool = AvbTool()
  tool.run(sys.argv)

```

`backup_manager.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import gzip
import shutil

import pyperclip
import traceback
import wx
import wx.html
import wx.lib.mixins.listctrl as listmix
import wx.lib.wxpTag

import images as images
from runtime import *
from i18n import _

# ============================================================================
#                               Class ListCtrl
# ============================================================================
class ListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)


# ============================================================================
#                               Class BackupManager
# ============================================================================
class BackupManager(wx.Dialog, listmix.ColumnSorterMixin):
    def __init__(self, *args, **kwargs):
        wx.Dialog.__init__(self, *args, **kwargs, style = wx.RESIZE_BORDER | wx.DEFAULT_DIALOG_STYLE)
        self.SetTitle(_("Magisk Backup Manager"))
        self.backupCount = 0
        self.all_cb_clicked = False
        self.device = get_phone(True)
        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            wx.MessageBox(_("❌ ERROR: You must first select a valid device."), _("Error"), wx.OK | wx.ICON_ERROR)
            self.Close()
            return

        self.sha1 = self.device.magisk_sha1
        self.message_label = wx.StaticText(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        self.message_label.Wrap(-1)
        self.message_label.Label = self.sha1
        self.message_label.SetFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, "Arial"))

        self.all_checkbox = wx.CheckBox(self, wx.ID_ANY, _("Check / Uncheck All"), wx.DefaultPosition, wx.DefaultSize, style=wx.CHK_3STATE)

        self.searchCtrl = wx.SearchCtrl(self, style=wx.TE_PROCESS_ENTER)
        self.searchCtrl.ShowCancelButton(True)

        self.il = wx.ImageList(16, 16)
        self.idx1 = self.il.Add(images.official_16.GetBitmap())
        self.sm_up = self.il.Add(images.SmallUpArrow.GetBitmap())
        self.sm_dn = self.il.Add(images.SmallDnArrow.GetBitmap())

        self.list  = ListCtrl(self, -1, size=(-1, -1), style=wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.BORDER_NONE)
        if sys.platform == "win32":
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLACK'),wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10).Bold())))
        self.list.SetImageList(self.il, wx.IMAGE_LIST_SMALL)
        self.list.EnableCheckBoxes(enable=True)
        itemDataMap = self.PopulateList()
        if itemDataMap != -1:
            self.itemDataMap = itemDataMap
        listmix.ColumnSorterMixin.__init__(self, 6)

        self.delete_button = wx.Button(self, wx.ID_ANY, _("Delete"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.delete_button.SetToolTip(_("Delete checked backups"))
        self.delete_button.Enable(False)

        self.add_backup_button = wx.Button(self, wx.ID_ANY, _("Add Backup from Computer"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.add_backup_button.SetToolTip(_("Select a boot.img and create a backup from it.\nWARNING! No verification is done if the selected file is stock boot image or even for the correct device."))

        self.auto_backup_button = wx.Button(self, wx.ID_ANY, _("Auto Create Backup"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.auto_backup_button.SetToolTip(_("Checks current boot partition,\nFf it is a Magisk Patched with SHA1\nand the boot.img is available, then it\nAutomatically creates a backup of boot image."))

        self.close_button = wx.Button(self, wx.ID_ANY, _("Close"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.close_button.SetToolTip(_("Closes this dialog"))

        vSizer = wx.BoxSizer(wx.VERTICAL)
        message_sizer = wx.BoxSizer(wx.HORIZONTAL)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        message_sizer.Add(self.message_label, 0, wx.ALL, 20)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        hSizer1 = wx.BoxSizer( wx.HORIZONTAL )
        hSizer1.Add( (10, 0), 0, wx.EXPAND, 10 )
        hSizer1.Add(self.all_checkbox, 0, wx.EXPAND, 10)
        hSizer1.Add( (0, 0), 1, wx.EXPAND, 10 )
        hSizer1.Add(self.searchCtrl, 1, wx.RIGHT, 10)
        buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        buttons_sizer.Add(self.delete_button, 0, wx.ALL, 20)
        buttons_sizer.Add(self.add_backup_button, 0, wx.ALL, 20)
        buttons_sizer.Add(self.auto_backup_button, 0, wx.ALL, 20)
        buttons_sizer.Add(self.close_button, 0, wx.ALL, 20)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        vSizer.Add(message_sizer, 0, wx.EXPAND, 5)
        vSizer.Add(hSizer1, 0, wx.EXPAND, 10)
        vSizer.Add(self.list , 1, wx.ALL|wx.EXPAND, 10)
        vSizer.Add(buttons_sizer, 0, wx.EXPAND, 5)

        self.SetSizer(vSizer)
        self.Layout()
        self.Centre(wx.BOTH)

        # Autosize the dialog
        self.list.PostSizeEventToParent()
        self.SetSizerAndFit(vSizer)
        self.SetSize(vSizer.MinSize.Width + 80, vSizer.MinSize.Height + 400)

        # Connect Events
        self.searchCtrl.Bind(wx.EVT_TEXT_ENTER, self.OnSearch)
        self.searchCtrl.Bind(wx.EVT_SEARCH, self.OnSearch)
        self.searchCtrl.Bind(wx.EVT_SEARCHCTRL_CANCEL_BTN, self.OnCancel)
        self.delete_button.Bind(wx.EVT_BUTTON, self.OnDelete)
        self.add_backup_button.Bind(wx.EVT_BUTTON, self.OnAddBackup)
        self.auto_backup_button.Bind(wx.EVT_BUTTON, self.OnAutoBackup)
        self.close_button.Bind(wx.EVT_BUTTON, self.OnClose)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self.list)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.OnColClick, self.list)
        self.list.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.list.Bind(wx.EVT_LIST_ITEM_CHECKED, self.OnItemCheck)
        self.list.Bind(wx.EVT_LIST_ITEM_UNCHECKED, self.OnItemUncheck)
        # for wxMSW
        self.list.Bind(wx.EVT_COMMAND_RIGHT_CLICK, self.OnRightClick)
        # for wxGTK
        self.list.Bind(wx.EVT_RIGHT_UP, self.OnRightClick)
        self.all_checkbox.Bind(wx.EVT_CHECKBOX, self.OnAllCheckbox)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    # -----------------------------------------------
    #              Function PopulateList
    # -----------------------------------------------
    def PopulateList(self):
        info = wx.ListItem()
        info.Mask = wx.LIST_MASK_TEXT | wx.LIST_MASK_IMAGE | wx.LIST_MASK_FORMAT
        info.Image = -1
        info.Align = 0
        info.Width = -1
        info.SetWidth(-1)
        info.Text = "SHA1"
        self.list.InsertColumn(0, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "Date"
        self.list.InsertColumn(1, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "Firmware"
        self.list.InsertColumn(2, info)

        res = self.device.get_magisk_backups()
        itemDataMap = {}
        query = self.searchCtrl.GetValue().lower()
        if res == 0:
            self.backupCount = len(self.device.backups)
            self.message_label.Label = f"{self.backupCount} Backups\n{self.sha1}"
            i = 0
            items = self.device.backups.items()
            for key, data in items:
                alltext = f"{key.lower()} {str(data.firmware.lower())}"
                if query.lower() in alltext:
                    index = self.list.InsertItem(self.list.GetItemCount(), key)
                    if data.value:
                        itemDataMap[i + 1] = (key, data.date, data.firmware)
                        row = self.list.GetItem(index)
                        self.list.SetItem(index, 1, data.date)
                        self.list.SetItem(index, 2, str(data.firmware))
                        if self.sha1 and self.sha1 == data.value:
                            row.SetTextColour(wx.RED)
                        self.list.SetItem(row)
                        self.list.SetItemData(index, i + 1)
                    # hide image
                    self.list.SetItemColumnImage(i, 0, -1)
                    i += 1
            self.message_label.Label = f"{str(i)} / {self.backupCount} Backups\n{self.sha1}"
        self.list.SetColumnWidth(0, -2)
        grow_column(self.list, 0, 20)
        self.list.SetColumnWidth(1, -2)
        grow_column(self.list, 1, 20)
        self.list.SetColumnWidth(2, -2)
        grow_column(self.list, 1, 20)

        self.currentItem = 0
        if itemDataMap:
            return itemDataMap
        else:
            return -1

    # -----------------------------------------------
    #              Function Check_UncheckAll
    # -----------------------------------------------
    def Check_UncheckAll(self, state):
        # Set this so that we skip processing OnItemChecked, OnItemUnchecked events
        self.Set_all_cb_clicked (True)
        itemcount = self.list.GetItemCount()
        [self.list.CheckItem(item=i, check=state) for i in range(itemcount)]
        if state:
            print("checking all Backups\n")
            self.EnableDisableButton(True)
        else:
            print("Unchecking all Backups\n")
            self.EnableDisableButton(False)
        self.Set_all_cb_clicked (False)

    # -----------------------------------------------
    #                  onSearch
    # -----------------------------------------------
    def OnSearch(self, event):
        query = self.searchCtrl.GetValue()
        print(f"Searching for: {query}")
        self.Refresh()

    # -----------------------------------------------
    #                  onCancel
    # -----------------------------------------------
    def OnCancel(self, event):
        self.searchCtrl.SetValue("")
        self.Refresh()

    # -----------------------------------------------
    #                  OnAllCheckbox
    # -----------------------------------------------
    def OnAllCheckbox(self, event):
        cb = event.GetEventObject()
        # print("\t3StateValue: %s\n" % cb.Get3StateValue())
        if cb.Get3StateValue() == 2:
            cb.Set3StateValue(2)
            self.Check_UncheckAll(False)
        elif cb.Get3StateValue() == 1:
            self.Check_UncheckAll(True)
        elif cb.Get3StateValue() == 0:
            self.Check_UncheckAll(False)

    # -----------------------------------------------
    #                  OnItemChecked
    # -----------------------------------------------
    def OnItemCheck(self, event):
        if self.Get_all_cb_clicked():
            return
        print(f"{event.Item.Text} is checked")
        self.Update_all_checkbox()

    # -----------------------------------------------
    #                  OnItemUnchecked
    # -----------------------------------------------
    def OnItemUncheck(self, event):
        if self.Get_all_cb_clicked():
            return
        print(f"{event.Item.Text} is unchecked")
        self.Update_all_checkbox()

    # -----------------------------------------------
    #         Function Get_all_cb_clicked
    # -----------------------------------------------
    def Get_all_cb_clicked(self):
        return self.all_cb_clicked

    # -----------------------------------------------
    #         Function Set_all_cb_clicked
    # -----------------------------------------------
    def Set_all_cb_clicked(self, value):
        self.all_cb_clicked = value

    # -----------------------------------------------
    #          Function Update_all_checkbox
    # -----------------------------------------------
    def Update_all_checkbox(self):
        i = 0
        for index in range(self.list.GetItemCount()):
            if self.list.IsItemChecked(index):
                # print(f"{self.list.GetItem(index).Text} item is checked")
                i += 1
        # print(f"Checked items count: {i}")
        if i == 0:
            self.all_checkbox.Set3StateValue(0)
            self.EnableDisableButton(False)
        elif i == self.backupCount:
            self.all_checkbox.Set3StateValue(1)
            self.EnableDisableButton(True)
        else:
            self.all_checkbox.Set3StateValue(2)
            self.EnableDisableButton(True)

    # -----------------------------------------------
    #                  EnableDisableButton
    # -----------------------------------------------
    def EnableDisableButton(self, state):
        self.delete_button.Enable(state)

    # -----------------------------------------------
    #                  OnClose
    # -----------------------------------------------
    def OnClose(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Close.")
        self.EndModal(wx.ID_CANCEL)

    # -----------------------------------------------
    #                  OnDelete
    # -----------------------------------------------
    def OnDelete(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Delete.")
        i = 0
        for index in range(self.list.GetItemCount()):
            if self.list.IsItemChecked(index):
                self.DeleteBackup(index, False)
                i += 1
        self.Refresh()
        print(f"Total count of backups deleted: {i}")

    # -----------------------------------------------
    #                  DeleteBackup
    # -----------------------------------------------
    def DeleteBackup(self, index, do_refresh = True):
        sha1 = self.list.GetItem(index).Text
        print(f"Deleting backup {sha1}")
        self.device.delete(f"/data/magisk_backup_{sha1}/", True, True)
        if do_refresh:
            self.Refresh()

    # -----------------------------------------------
    #                  OnAddBackup
    # -----------------------------------------------
    def OnAddBackup(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed on Add Backup")
        with wx.FileDialog(self, _("boot / init_boot image to create backup of."), '', '', wildcard="Images (*.*.img)|*.img", style=wx.FD_OPEN) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                print("User cancelled backup creation.")
                return
            # save the current contents in the file
            file_to_backup = fileDialog.GetPath()
            file_sha1 = sha1(file_to_backup)
            print(f"\nSelected {file_to_backup} for backup with SHA1 of {file_sha1}")
            try:
                self._on_spin('start')
                res = self.device.push_file(f"{file_to_backup}", '/data/adb/magisk/stock_boot.img', with_su=True)
                if res != 0:
                    print("Aborting ...\n")
                    self._on_spin('stop')
                    return
                # run the migration.
                res = self.device.run_magisk_migration(file_sha1)
                print("Checking to see if Magisk made a backup.")
                magisk_backups = self.device.magisk_backups
                if magisk_backups and file_sha1 in magisk_backups:
                    print("✅ Good: Magisk has made a backup")
                else:
                    print("It looks like Magisk did not make a backup.\nTrying an alternate approach ...")
                    self.ZipAndPush(file_to_backup, file_sha1)
                    if res != 0:
                        print("Aborting ...\n")
                        self._on_spin('stop')
                        return

                # Refresh the list
                self.Refresh()

                self._on_spin('stop')
            except Exception as e:
                print(f"Cannot backup file '{file_to_backup}'.")
                traceback.print_exc()
                self._on_spin('stop')

    # -----------------------------------------------
    #                  ZipAndPush
    # -----------------------------------------------
    def ZipAndPush(self, file_to_backup, file_sha1):
        print(f"Zipping {file_to_backup} ...")
        backup_file = os.path.join(get_config_path(), 'tmp', 'boot.img.gz')
        with open(file_to_backup, 'rb') as f_in:
            with gzip.open(backup_file, 'wb', compresslevel=9) as f_out:
                shutil.copyfileobj(f_in, f_out)
        if not os.path.exists(backup_file):
            print(f"ERROR: Could not create {backup_file}")
            return -1
        # mkdir the directory with su
        res = self.device.create_dir(f"/data/magisk_backup_{file_sha1}", True)
        if res != 0:
            return -1
        # Transfer the file with su
        res = self.device.push_file(f"{backup_file}", f"/data/magisk_backup_{file_sha1}/boot.img.gz", with_su=True)
        if res != 0:
            return -1

    # -----------------------------------------------
    #                  OnAutoBackup
    # -----------------------------------------------
    def OnAutoBackup(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed on Auto Create Backup")

        config_path = get_config_path()
        if self.sha1:
            patched_sha1 = self.sha1
        else:
            # extract the current slot's boot.img
            res, file_path = self.device.dump_partition()
            if res != 0:
                print("Aborting ...\n")
                return
            # pull the file locally
            extracted_boot = os.path.join(config_path, 'tmp', 'extracted_boot.img')
            res = self.device.pull_file(file_path, extracted_boot)
            if res != 0:
                print("Aborting ...\n")
                return
            # extract the sha1
            print("Extracting SHA1 from dumped partition ...")
            patched_sha1 = extract_sha1(extracted_boot, 40)
            print(f"Source SHA1 embedded in dumped partition is: {patched_sha1}")

        if patched_sha1:
            try:
                self._on_spin('start')
                print(f"Checking to see if we have a copy of {patched_sha1} ...")
                source_init_boot = os.path.join(config_path, get_boot_images_dir(), patched_sha1, 'init_boot.img')
                source_boot = os.path.join(config_path, get_boot_images_dir(), patched_sha1, 'boot.img')
                if os.path.exists(source_init_boot):
                    print(f"Found {source_init_boot}, creating backup ...")
                    file_to_backup = source_init_boot
                elif os.path.exists(source_boot):
                    print(f"Found {source_boot}, creating backup ...")
                    file_to_backup = source_boot
                else:
                    print(f"ERROR: Did not find a local copy of source boot / init_boot with SHA1 of {patched_sha1}")
                    print("Cannot create automatic backup file, you can still manually select and create one.")
                    print("Aborting ...\n")
                    self._on_spin('stop')
                    return

                res = self.device.push_file(f"{file_to_backup}", '/data/adb/magisk/stock_boot.img', with_su=True)
                if res != 0:
                    print("Aborting ...\n")
                    self._on_spin('stop')
                    return
                # run the migration.
                res = self.device.run_magisk_migration(patched_sha1)
                print("Checking to see if Magisk made a backup.")
                magisk_backups = self.device.magisk_backups
                if magisk_backups and patched_sha1 in magisk_backups:
                    print("✅ Good: Magisk has made a backup")
                else:
                    print("It looks like Magisk did not make a backup.\nTrying an alternate approach ...")
                    self.ZipAndPush(file_to_backup, patched_sha1)
                    if res != 0:
                        print("Aborting ...\n")
                        self._on_spin('stop')
                        return

                # Refresh the list
                self.Refresh()
                self._on_spin('stop')
            except Exception as e:
                print("Cannot create automatic backup file, you can still manually select and create one.")
                traceback.print_exc()
                print("Aborting ...")
                self._on_spin('stop')
                return
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The dumped partition does not contain source boot's SHA1")
            print("This is normal for older devices, but newer devices should have it.")
            print("Cannot create automatic backup file, you can still manually select and create one.")
            print("Aborting ...")
            return

    # -----------------------------------------------
    #                  GetListCtrl
    # -----------------------------------------------
    # Used by the ColumnSorterMixin, see wx/lib/mixins/listctrl.py
    def GetListCtrl(self):
        return self.list

    # -----------------------------------------------
    #                  GetSortImages
    # -----------------------------------------------
    # Used by the ColumnSorterMixin, see wx/lib/mixins/listctrl.py
    def GetSortImages(self):
        return (self.sm_dn, self.sm_up)

    # -----------------------------------------------
    #                  OnRightDown
    # -----------------------------------------------
    def OnRightDown(self, event):
        x = event.GetX()
        y = event.GetY()
        # print("x, y = %s\n" % str((x, y)))
        item, flags = self.list.HitTest((x, y))
        if item != wx.NOT_FOUND and flags & wx.LIST_HITTEST_ONITEM:
            self.list.Select(item)
        event.Skip()

    # -----------------------------------------------
    #                  getColumnText
    # -----------------------------------------------
    def getColumnText(self, index, col):
        item = self.list.GetItem(index, col)
        return item.GetText()

    # -----------------------------------------------
    #                  OnItemSelected
    # -----------------------------------------------
    def OnItemSelected(self, event):
        self.currentItem = event.Index
        # print("OnItemSelected: %s, %s, %s, %s\n" %
        #                    (self.currentItem,
        #                     self.list.GetItemText(self.currentItem),
        #                     self.getColumnText(self.currentItem, 1),
        #                     self.getColumnText(self.currentItem, 2),
        #                     self.getColumnText(self.currentItem, 3),
        #                     self.getColumnText(self.currentItem, 4),
        #                     self.getColumnText(self.currentItem, 5)))
        event.Skip()

    # -----------------------------------------------
    #                  OnColClick
    # -----------------------------------------------
    def OnColClick(self, event):
        col = event.GetColumn()
        if col == -1:
            return # clicked outside any column.
        rowid = self.list.GetColumn(col)
        print(f"Sorting on Column {rowid.GetText()}")
        event.Skip()

    # -----------------------------------------------
    #                  OnCheckAllBoxes
    # -----------------------------------------------
    def OnCheckAllBoxes(self, event):
        self.Check_UncheckAll(True)

    # -----------------------------------------------
    #                  OnUnCheckAllBoxes
    # -----------------------------------------------
    def OnUnCheckAllBoxes(self, event):
        self.Check_UncheckAll(False)

    # -----------------------------------------------
    #                  OnGetItemsChecked
    # -----------------------------------------------
    def OnGetItemsChecked(self, event):
        itemcount = self.list.GetItemCount()
        itemschecked = [i for i in range(itemcount) if self.list.IsItemChecked(item=i)]
        print(f"Package: {itemschecked} is checked.")

    # -----------------------------------------------
    #                  OnRightClick
    # -----------------------------------------------
    def OnRightClick(self, event):
        # print("OnRightClick %s\n" % self.list.GetItemText(self.currentItem))

        # only do this part the first time so the events are only bound once
        if not hasattr(self, "popupDelete"):
            self.popupDelete = wx.NewIdRef()
            self.popupRefresh = wx.NewIdRef()
            self.popupCheckAllBoxes = wx.NewIdRef()
            self.popupUnCheckAllBoxes = wx.NewIdRef()
            self.popupCopyClipboard = wx.NewIdRef()

            self.Bind(wx.EVT_MENU, self.OnpopupDelete, id=self.popupDelete)
            self.Bind(wx.EVT_MENU, self.OnPopupRefresh, id=self.popupRefresh)
            self.Bind(wx.EVT_MENU, self.OnCheckAllBoxes, id=self.popupCheckAllBoxes)
            self.Bind(wx.EVT_MENU, self.OnUnCheckAllBoxes, id=self.popupUnCheckAllBoxes)
            self.Bind(wx.EVT_MENU, self.OnCopyClipboard, id=self.popupCopyClipboard)

        # build the menu
        menu = wx.Menu()
        menu.Append(self.popupDelete, _("Delete Backup"))
        menu.Append(self.popupRefresh, _("Refresh"))
        menu.Append(self.popupCheckAllBoxes, _("Check All"))
        menu.Append(self.popupUnCheckAllBoxes, _("UnCheck All"))
        menu.Append(self.popupCopyClipboard, _("Copy to Clipboard"))

        # Popup the menu.  If an item is selected then its handler
        # will be called before PopupMenu returns.
        self.PopupMenu(menu)
        menu.Destroy()

    # -----------------------------------------------
    #                  OnpopupDelete
    # -----------------------------------------------
    def OnpopupDelete(self, event):
        self.DeleteBackup(self.currentItem)

    # -----------------------------------------------
    #                  OnPopupRefresh
    # -----------------------------------------------
    def OnPopupRefresh(self, event):
        self.Refresh()

    # -----------------------------------------------
    #                  OnCopyClipboard
    # -----------------------------------------------
    def OnCopyClipboard(self, event):
        item = self.list.GetItem(self.currentItem)
        pyperclip.copy(item.Text)

    # -----------------------------------------------
    #                  Function Refresh
    # -----------------------------------------------
    def Refresh(self):
        print("Refreshing the backups ...\n")
        self._on_spin('start')
        self.list.ClearAll()
        itemDataMap = self.PopulateList()
        if itemDataMap != -1:
            self.itemDataMap = itemDataMap
        self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        wx.YieldIfNeeded()
        if state == 'start':
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
            self.Parent._on_spin('start')
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.Parent._on_spin('stop')

```

`build-on-linux.spec`:

```spec
# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(['PixelFlasher.py'],
             pathex=['.'],
             binaries=[('bin/7zzs', 'bin')],
             datas=[
                ("images/icon-64.png", "images"),
                ("images/icon-dark-64.png", "images"),
                ('bin/busybox_arm64-v8a', 'bin'),
                ('bin/busybox_armeabi-v7a', 'bin'),
                ('bin/busybox_x86', 'bin'),
                ('bin/busybox_x86_64', 'bin'),
                ('bin/aapt2_arm64-v8a', 'bin'),
                ('bin/aapt2_armeabi-v7a', 'bin'),
                ('bin/aapt2_x86', 'bin'),
                ('bin/aapt2_x86_64', 'bin'),
                ('bin/avbctl', 'bin'),
                ('bin/update_engine_client_r28', 'bin'),
                ('bin/update_engine_client_r72', 'bin'),
                ('android_versions.json', '.'),
                ('android_devices.json', '.'),
                ('testkey_rsa4096.pem', '.'),
                ('locale', 'locale')
             ],
             hiddenimports=['_cffi_backend'],
             hookspath=[],
             runtime_hooks=[],
             excludes=[
                'bin/busybox_arm64-v8a',
                'bin/busybox_armeabi-v7a',
                'bin/busybox_x86',
                'bin/busybox_x86_64',
                'bin/aapt2_arm64-v8a',
                'bin/aapt2_armeabi-v7a',
                'bin/aapt2_x86',
                'bin/aapt2_x86_64',
                'bin/avbctl',
                'bin/update_engine_client_r28',
                'bin/update_engine_client_r72'
             ],
             win_no_prefer_redirects=False,
             win_private_assemblies=False,
             cipher=block_cipher,
             noarchive=False)

pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)
exe = EXE(pyz,
        a.scripts,
        a.binaries,
        a.zipfiles,
        a.datas,
        name='PixelFlasher',
        debug=False,
        strip=False,
        upx=True,
        console=False,
        icon='images\\icon-dark-256.ico',
        bootloader_ignore_signals=False,
        disable_windowed_traceback=False,
        target_arch=None,
        codesign_identity=None,
        entitlements_file=None)

```

`build-on-mac-intel-only.spec`:

```spec
# -*- mode: python -*-

block_cipher = None

a = Analysis(['PixelFlasher.py'],
            pathex=['.'],
            binaries=[('bin/7zz', 'bin')],
            datas=[
                ("images/icon-64.png", "images"),
                ("images/icon-dark-64.png", "images"),
                ('bin/busybox_arm64-v8a', 'bin'),
                ('bin/busybox_armeabi-v7a', 'bin'),
                ('bin/busybox_x86', 'bin'),
                ('bin/busybox_x86_64', 'bin'),
                ('bin/aapt2_arm64-v8a', 'bin'),
                ('bin/aapt2_armeabi-v7a', 'bin'),
                ('bin/aapt2_x86', 'bin'),
                ('bin/aapt2_x86_64', 'bin'),
                ('bin/avbctl', 'bin'),
                ('bin/update_engine_client_r28', 'bin'),
                ('bin/update_engine_client_r72', 'bin'),
                ('android_versions.json', '.'),
                ('android_devices.json', '.'),
                ('testkey_rsa4096.pem', '.'),
                ('locale', 'locale')
            ],
            hiddenimports=['_cffi_backend'],
            hookspath=[],
            runtime_hooks=[],
            excludes=[
                'bin/busybox_arm64-v8a',
                'bin/busybox_armeabi-v7a',
                'bin/busybox_x86',
                'bin/busybox_x86_64',
                'bin/aapt2_arm64-v8a',
                'bin/aapt2_armeabi-v7a',
                'bin/aapt2_x86',
                'bin/aapt2_x86_64',
                'bin/avbctl',
                'bin/update_engine_client_r28',
                'bin/update_engine_client_r72'
            ],
            win_no_prefer_redirects=False,
            win_private_assemblies=False,
            cipher=block_cipher)

pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)
exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          name='PixelFlasher',
          debug=False,
          strip=False,
          upx=True,
          console=False,
          icon='images/icon-dark-256.icns')
app = BUNDLE(exe,
             name='PixelFlasher.app',
             version='8.15.0.0',
             icon='./images/icon-dark-256.icns',
             bundle_identifier='com.badabing.pixelflasher')

```

`build-on-mac.spec`:

```spec
# -*- mode: python -*-

block_cipher = None

a = Analysis(['PixelFlasher.py'],
            pathex=['.'],
            binaries=[('bin/7zz', 'bin')],
            datas=[
                ("images/icon-64.png", "images"),
                ("images/icon-dark-64.png", "images"),
                ('bin/busybox_arm64-v8a', 'bin'),
                ('bin/busybox_armeabi-v7a', 'bin'),
                ('bin/busybox_x86', 'bin'),
                ('bin/busybox_x86_64', 'bin'),
                ('bin/aapt2_arm64-v8a', 'bin'),
                ('bin/aapt2_armeabi-v7a', 'bin'),
                ('bin/aapt2_x86', 'bin'),
                ('bin/aapt2_x86_64', 'bin'),
                ('bin/avbctl', 'bin'),
                ('bin/update_engine_client_r28', 'bin'),
                ('bin/update_engine_client_r72', 'bin'),
                ('android_versions.json', '.'),
                ('android_devices.json', '.'),
                ('testkey_rsa4096.pem', '.'),
                ('locale', 'locale')
            ],
            hiddenimports=['_cffi_backend'],
            hookspath=[],
            runtime_hooks=[],
            excludes=[
                'bin/busybox_arm64-v8a',
                'bin/busybox_armeabi-v7a',
                'bin/busybox_x86',
                'bin/busybox_x86_64',
                'bin/aapt2_arm64-v8a',
                'bin/aapt2_armeabi-v7a',
                'bin/aapt2_x86',
                'bin/aapt2_x86_64',
                'bin/avbctl',
                'bin/update_engine_client_r28',
                'bin/update_engine_client_r72'
            ],
            win_no_prefer_redirects=False,
            win_private_assemblies=False,
            cipher=block_cipher)

pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)
exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          name='PixelFlasher',
          target_arch='universal2',
          debug=False,
          strip=False,
          upx=True,
          console=False,
          icon='images/icon-dark-256.icns')
app = BUNDLE(exe,
             name='PixelFlasher.app',
             version='8.15.0.0',
             icon='./images/icon-dark-256.icns',
             bundle_identifier='com.badabing.pixelflasher')

```

`build-on-win-arm64.spec`:

```spec
# -*- mode: python -*-

block_cipher = None

a = Analysis(['PixelFlasher.py'],
            pathex=['.'],
            binaries=[('bin/7z.exe', 'bin'), ('bin/7z.dll', 'bin')],
            datas=[
                ("images/icon-64.png", "images"),
                ("images/icon-dark-64.png", "images"),
                ('bin/busybox_arm64-v8a', 'bin'),
                ('bin/busybox_armeabi-v7a', 'bin'),
                ('bin/busybox_x86', 'bin'),
                ('bin/busybox_x86_64', 'bin'),
                ('bin/aapt2_arm64-v8a', 'bin'),
                ('bin/aapt2_armeabi-v7a', 'bin'),
                ('bin/aapt2_x86', 'bin'),
                ('bin/aapt2_x86_64', 'bin'),
                ('bin/avbctl', 'bin'),
                ('bin/update_engine_client_r28', 'bin'),
                ('bin/update_engine_client_r72', 'bin'),
                ('android_versions.json', '.'),
                ('android_devices.json', '.'),
                ('testkey_rsa4096.pem', '.'),
                ('locale', 'locale')
            ],
            hiddenimports=[
                '_cffi_backend',
                'wx',
                'wx.adv',
                'wx.lib',
                'wx.lib.agw',
                'wx.lib.agw.aui',
                'wx.lib.inspection',
                'wx.lib.mixins',
                'wx.lib.mixins.inspection',
                'wx.lib.mixins.listctrl',
                'wx.lib.buttons',
                'wx.lib.wxpTag',
                'wx.stc',
                'wx.html',
                'wx._core',
                'wx._adv',
                'wx._html',
                'wx._stc',
            ],
            hookspath=['pyi-hooks-arm64'],
            runtime_hooks=[],
            excludes=[
                'bin/busybox_arm64-v8a',
                'bin/busybox_armeabi-v7a',
                'bin/busybox_x86',
                'bin/busybox_x86_64',
                'bin/aapt2_arm64-v8a',
                'bin/aapt2_armeabi-v7a',
                'bin/aapt2_x86',
                'bin/aapt2_x86_64',
                'bin/avbctl',
                'bin/update_engine_client_r28',
                'bin/update_engine_client_r72'
            ],
            win_no_prefer_redirects=False,
            win_private_assemblies=False,
            cipher=block_cipher)

pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)
exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          name='PixelFlasher-arm64',
          version='windows-version-info.txt',
          debug=False,
          strip=False,
          upx=True,
          target_arch='arm64',
          console=False,
          icon='images\\icon-dark-256.ico')

```

`build-on-win.spec`:

```spec
# -*- mode: python -*-

block_cipher = None

a = Analysis(['PixelFlasher.py'],
            pathex=['.'],
            binaries=[('bin/7z.exe', 'bin'), ('bin/7z.dll', 'bin')],
            datas=[
                ("images/icon-64.png", "images"),
                ("images/icon-dark-64.png", "images"),
                ('bin/busybox_arm64-v8a', 'bin'),
                ('bin/busybox_armeabi-v7a', 'bin'),
                ('bin/busybox_x86', 'bin'),
                ('bin/busybox_x86_64', 'bin'),
                ('bin/aapt2_arm64-v8a', 'bin'),
                ('bin/aapt2_armeabi-v7a', 'bin'),
                ('bin/aapt2_x86', 'bin'),
                ('bin/aapt2_x86_64', 'bin'),
                ('bin/avbctl', 'bin'),
                ('bin/update_engine_client_r28', 'bin'),
                ('bin/update_engine_client_r72', 'bin'),
                ('android_versions.json', '.'),
                ('android_devices.json', '.'),
                ('testkey_rsa4096.pem', '.'),
                ('locale', 'locale')
            ],
            hiddenimports=['_cffi_backend'],
            hookspath=[],
            runtime_hooks=[],
            excludes=[
                'bin/busybox_arm64-v8a',
                'bin/busybox_armeabi-v7a',
                'bin/busybox_x86',
                'bin/busybox_x86_64',
                'bin/aapt2_arm64-v8a',
                'bin/aapt2_armeabi-v7a',
                'bin/aapt2_x86',
                'bin/aapt2_x86_64',
                'bin/avbctl',
                'bin/update_engine_client_r28',
                'bin/update_engine_client_r72'
            ],
            win_no_prefer_redirects=False,
            win_private_assemblies=False,
            cipher=block_cipher)

pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)
exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          name='PixelFlasher',
          version='windows-version-info.txt',
          debug=False,
          strip=False,
          upx=True,
          console=False,
          icon='images\\icon-dark-256.ico')

```

`build.bat`:

```bat
python .\compile_po.py
pyinstaller --log-level=DEBUG ^
			--clean ^
            --noconfirm ^
            build-on-win.spec

```

`build.sh`:

```sh
#!/usr/bin/env bash

# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

rm -rf build dist
VERSION=8.15.0.0
NAME="PixelFlasher"
DIST_NAME="PixelFlasher"

pushd "$(dirname "$0")"

if [[ $OSTYPE == 'darwin'* ]]; then
    if [[ $(arch) == 'arm64' ]]; then
        echo "Building macOS Universal Binary"
        specfile=build-on-mac.spec
    else
        echo "Building for macOS"
        specfile=build-on-mac-intel-only.spec
    fi
else
    echo "Building for Linux"
    specfile=build-on-linux.spec
fi

if ! command -v python3 &> /dev/null
then
    PYTHON=python
else
    PYTHON=python3
fi
$PYTHON ./compile_po.py

pyinstaller --log-level=DEBUG \
            --noconfirm \
            $specfile

if [[ $OSTYPE == 'darwin'* ]]; then
    # https://github.com/sindresorhus/create-dmg
    echo "List before creating DMG"
    ls -l ./ dist/
    chmod +x dist/$NAME.app/Contents/MacOS/$NAME
    create-dmg "dist/$NAME.app"
    echo "List after creating DMG"
    ls -l ./ dist/
    mv "$NAME $VERSION.dmg" "dist/$DIST_NAME.dmg"
fi

popd
ls -l build/ dist/


```

`ca_badabing2005.crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIDDTCCAfWgAwIBAgIUG8IsWabGyCjhtULTwryYRiAnw5UwDQYJKoZIhvcNAQEL
BQAwFzEVMBMGA1UEAwwMQmFkYWJpbmcyMDA1MB4XDTI0MDcxNDEzMjE0OVoXDTI3
MDUwNDEzMjE0OVowFzEVMBMGA1UEAwwMQmFkYWJpbmcyMDA1MIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxLfwi9WCL31RUrkUsr5EC4Icbce7VwFMkAi9
j5jAelBjOaifjm3IkpE36ysDgN/BZwuwHOOgZF+30KWETm2hTtJlgL4aO6T+JbqA
l0XeWTHz9o9KMhcrXMitBE2QKf2ewfgbpQ+S6p7tk9yywUFr4R1K4gexyhQKpogm
GmKbksG7XJQoVeVj3mLjtpQdeHhNuGghmmKiZMx+4HTH5p/jdF53ikCWiaoMK+oN
0LjFORXrFfXOhuv1gWr1HbD2iXb9EKwddUTF0fl20upyv5M3zlamfREqnCz5HXxJ
uGNdiDk3Gs7Revd6EgP+hIIQrLv2dwwBowPPA53X+0wvXPa/mwIDAQABo1EwTzAM
BgNVHRMEBTADAQH/MAsGA1UdDwQEAwIChDATBgNVHSUEDDAKBggrBgEFBQcDAzAd
BgNVHQ4EFgQUzglgDKL7GtvkkttUqIPa5O5YiFswDQYJKoZIhvcNAQELBQADggEB
AEkwQhlOURaXxdxDiQCgk4Y6JKejY7E8cmdoZJiEZ6DxmMvqie0j32dI5ttii8og
imgR6MXVtjJgHdMaSnUzzvg1ePmMURQimKjaEWIz+k18Hrcj1TyUBp6DFEbSaKfj
0xmmSfkP3TlSd2MSV+tQHWuv4csdFjmv+UuhWOvBpRwEvmb6V+IX+i7A1ohAxnFO
LX0qzVxs+33/0iBaRxXl7lZ6VYh+jfCZ6CrYEut6dR+TwIDA0/0Z4/4Hg6MkTuzM
N5AzycYrvP/lEM4g6MhCpasH7MT2d/i0MMQQfAA1cPYyaASjDrsYc+l2rDyH7tuU
H7kne0e2aWC9TY9hvA9mgMI=
-----END CERTIFICATE-----

```

`check_translations.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

"""Audit translation catalogs against the English reference."""

import argparse
from collections import Counter
from pathlib import Path
import sys

import polib


# -----------------------------------------------
#           entry_key function
# -----------------------------------------------
def entry_key(entry):
    return (entry.msgctxt or None, entry.msgid, entry.msgid_plural or None)


# -----------------------------------------------
#           format_key function
# -----------------------------------------------
def format_key(key):
    context, msgid, plural = key
    parts = [msgid]
    if plural:
        parts.append(f"[plural: {plural}]")
    if context:
        parts.append(f"(context: {context})")
    return " ".join(parts)


# -----------------------------------------------
#           load_entries function
# -----------------------------------------------
def load_entries(po_path):
    try:
        catalog = polib.pofile(str(po_path))
    except (OSError, IOError) as exc:
        sys.exit(f"Failed reading {po_path}: {exc}")
    return [entry for entry in catalog if not entry.obsolete]


# -----------------------------------------------
#           analyze_catalogs function
# -----------------------------------------------
def analyze_catalogs(locale_dir, reference_path):
    reference_entries = load_entries(reference_path)
    reference_keys = {entry_key(entry) for entry in reference_entries}

    reports = []
    for po_path in sorted(locale_dir.rglob("pixelflasher.po")):
        if po_path.resolve() == reference_path.resolve():
            continue
        target_entries = load_entries(po_path)
        target_keys = [entry_key(entry) for entry in target_entries]

        missing = sorted(reference_keys.difference(target_keys))
        extra = sorted(set(target_keys).difference(reference_keys))
        duplicates = sorted({key for key, count in Counter(target_keys).items() if count > 1})

        if missing or duplicates or extra:
            reports.append((po_path, missing, duplicates, extra))

    return reports


# -----------------------------------------------
#           print_reports function
# -----------------------------------------------
def print_reports(reports):
    if not reports:
        print("All translation catalogs match the English reference.")
        return

    for po_path, missing, duplicates, extra in reports:
        print(f"== {po_path} ==")
        if missing:
            print("  Missing entries:")
            for key in missing:
                print(f"    - {format_key(key)}")
        if duplicates:
            print("  Duplicate entries:")
            for key in duplicates:
                print(f"    - {format_key(key)}")
        if extra:
            print("  Extra entries (not in English):")
            for key in extra:
                print(f"    - {format_key(key)}")
        print()


# -----------------------------------------------
#           parse_args function
# -----------------------------------------------
def parse_args(argv=None):
    parser = argparse.ArgumentParser(description="Compare translation catalogs against English.")
    parser.add_argument(
        "--locale-dir",
        type=Path,
        default=Path(__file__).resolve().parent / "locale",
        help="Root locale directory containing language subfolders.",
    )
    parser.add_argument(
        "--reference",
        type=Path,
        default=Path(__file__).resolve().parent / "locale" / "en" / "LC_MESSAGES" / "pixelflasher.po",
        help="Path to the English reference pixelflasher.po file.",
    )
    return parser.parse_args(argv)


# ============================================================================
#                               Function Main
# ============================================================================
def main(argv=None):
    args = parse_args(argv)
    locale_dir = args.locale_dir
    reference_path = args.reference

    if not reference_path.is_file():
        sys.exit(f"Reference catalog not found: {reference_path}")
    if not locale_dir.is_dir():
        sys.exit(f"Locale directory not found: {locale_dir}")

    reports = analyze_catalogs(locale_dir, reference_path)
    print_reports(reports)


if __name__ == "__main__":
    main()

```

`compile_po.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

from i18n import compile_translations

if __name__ == "__main__":
    print("Compiling all translation files...")
    compile_translations()

```

`config.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import contextlib
import json
import os
import sys

from datetime import datetime
from constants import *

# ============================================================================
#                               Class Config
# ============================================================================
class Config():
    def __init__(self):
        self.flash_mode = 'dryRun'
        self.firmware_path = None
        self.firmware_is_ota = False
        self.platform_tools_path = None
        self.device = None
        self.phone_path = '/storage/emulated/0/Download'
        self.magisk = MAGISK_PKG_NAME
        self.width = MAIN_WIDTH
        self.height = MAIN_HEIGHT
        self.magisk_width = MAGISK_WIDTH
        self.magisk_height = MAGISK_HEIGHT
        self.pif_width = PIF_WIDTH
        self.pif_height = PIF_HEIGHT
        self.boot_id = None
        self.selected_boot_md5 = None
        self.custom_rom = False
        self.custom_rom_path = None
        self.disable_verification = False
        self.disable_verity = False
        self.fastboot_verbose = False
        self.temporary_root = False
        self.no_reboot = False
        self.fastboot_force = False
        self.advanced_options = False
        self.update_check = True
        self.version = VERSION
        self.flash_both_slots = False
        self.flash_to_inactive_slot = False
        self.verbose = False
        self.pos_x = POS_X
        self.pos_y = POS_Y
        self.data = None
        self.show_all_boot=False
        self.first_run=False
        self.first_run_date = None
        self.last_run_date = None
        self.force_codepage = False
        self.custom_codepage = None
        self.customize_font = False
        self.pf_font_face = 'Courier'
        self.pf_font_size = 12
        self.dev_mode = False
        self.offer_patch_methods = False
        self.use_busybox_shell = False
        self.linux_file_explorer = ''
        self.linux_shell = ''
        self.firmware_has_init_boot = False
        self.rom_has_init_boot = False
        self.show_recovery_patching_option = False
        self.pf_home = None
        self.firmware_sha256 = None
        self.rom_sha256 = None
        self.boot_sort_column = 0
        self.boot_sorting_direction = 'ASC'
        self.low_mem = False
        self.extra_img_extracts = False
        self.show_notifications = False
        self.create_boot_tar = False
        self.delete_bundled_libs = ''
        self.check_for_disk_space = True
        self.check_for_bootloader_unlocked = True
        self.check_for_firmware_hash_validity = True
        self.google_images_update_frequency = 1
        self.google_images_last_checked = None
        self.enable_dg_clean = False
        self.enable_bulk_prop = False
        self.enable_pixel_img_process = False
        self.override_kmi = ''
        self.keep_temporary_support_files = False
        self.check_module_updates = True
        self.show_custom_rom_options = False
        self.sanitize_support_files = False
        self.language = 'en'
        self.keep_patch_temporary_files = False
        self.kb_index = False
        self.unmarked_entries_path = None
        self.spoofed_apps = ''
        self.force_ksud_mount_selection = False
        self.pif_chunk_size = 8*1024*1024  # 8MB default
        self.pif_chunk_overlap = 200        # 200 bytes default

        self.toolbar = {
            'tb_position': 'top',
            'tb_show_text': True,
            'tb_show_icons': True,
            'visible': {
                'install_apk': True,
                'package_manager': True,
                'adb_shell': True,
                'scrcpy': True,
                'device_info': True,
                'partition_manager': True,
                'pi_analysis_report': True,
                'switch_slot': True,
                'reboot_system': True,
                'reboot_bootloader': True,
                'reboot_fastbootd': True,
                'reboot_recovery': False,
                'reboot_recovery_interactive': True,
                'reboot_safe_mode': True,
                'reboot_download': True,
                'reboot_sideload': True,
                'magisk_modules': True,
                'install_magisk': True,
                'magisk_backup_manager': True,
                'pif_manager': True,
                'sos': True,
                'lock_bootloader': True,
                'unlock_bootloader': True,
                'configuration': True
            }
        }

        self.pif = {
            'auto_update_pif_json': False,
            'auto_check_play_integrity': False,
            'auto_run_migrate': False,
            'test_app_index': 0,
            'disable_uiautomator': False,
            'auto_fill': False,
            'force_first_api': False,
            'first_api_value_when_forced': "25",
            'sort_keys': True,
            'keep_unknown': True,
            'spoofBuild': True,
            'spoofProps': False,
            'spoofProvider': False,
            'spoofSignature': False,
            'spoofVendingSdk': False,
            'spoofVendingFinger': False,
        }

        self.scrcpy = {
            'path': '',
            'flags': ''
        }

        # KSU Asset Selection Mode
        # 0 = Equal or highest lower, if not matched, lowest higher (default)
        # 1 = Highest Available
        # 2 = User selectable based on matches found
        self.ksu_asset_selection_mode = 0

    @classmethod
    def load(cls, file_path):
        conf = cls()
        print("Loading configuration File ...")
        try:
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding="ISO-8859-1", errors="replace") as f:
                    data = json.load(f)
                    conf.data = data
                with contextlib.suppress(KeyError):
                    conf.first_run_date = data['first_run_date']
                with contextlib.suppress(KeyError):
                    conf.device = data['device']
                with contextlib.suppress(KeyError):
                    conf.firmware_path = data['firmware_path']
                with contextlib.suppress(KeyError):
                    conf.firmware_is_ota = data['firmware_is_ota']
                with contextlib.suppress(KeyError):
                    conf.platform_tools_path = data['platform_tools_path']
                with contextlib.suppress(KeyError):
                    conf.flash_mode = data['mode']
                with contextlib.suppress(KeyError):
                    conf.phone_path = data['phone_path']
                with contextlib.suppress(KeyError):
                    conf.magisk = data['magisk']
                with contextlib.suppress(KeyError):
                    conf.width = data['width']
                with contextlib.suppress(KeyError):
                    conf.height = data['height']
                with contextlib.suppress(KeyError):
                    conf.magisk_width = data['magisk_width']
                with contextlib.suppress(KeyError):
                    conf.magisk_height = data['magisk_height']
                with contextlib.suppress(KeyError):
                    conf.pif_width = data['pif_width']
                with contextlib.suppress(KeyError):
                    conf.pif_height = data['pif_height']
                with contextlib.suppress(KeyError):
                    conf.custom_rom = data['custom_rom']
                with contextlib.suppress(KeyError):
                    conf.custom_rom_path = data['custom_rom_path']
                with contextlib.suppress(KeyError):
                    conf.disable_verification = data['disable_verification']
                with contextlib.suppress(KeyError):
                    conf.disable_verity = data['disable_verity']
                with contextlib.suppress(KeyError):
                    conf.fastboot_force = data['fastboot_force']
                with contextlib.suppress(KeyError):
                    conf.fastboot_verbose = data['fastboot_verbose']
                with contextlib.suppress(KeyError):
                    conf.temporary_root = data['temporary_root']
                with contextlib.suppress(KeyError):
                    conf.no_reboot = data['no_reboot']
                with contextlib.suppress(KeyError):
                    conf.advanced_options = data['advanced_options']
                with contextlib.suppress(KeyError):
                    conf.update_check = data['update_check']
                with contextlib.suppress(KeyError):
                    conf.version = data['version']
                with contextlib.suppress(KeyError):
                    conf.flash_both_slots = data['flash_both_slots']
                with contextlib.suppress(KeyError):
                    conf.flash_to_inactive_slot = data['flash_to_inactive_slot']
                with contextlib.suppress(KeyError):
                    conf.verbose = data['verbose']
                with contextlib.suppress(KeyError):
                    conf.pos_x = data['pos_x']
                with contextlib.suppress(KeyError):
                    conf.pos_y = data['pos_y']
                with contextlib.suppress(KeyError):
                    conf.boot_id = data['boot_id']
                with contextlib.suppress(KeyError):
                    conf.selected_boot_md5 = data['selected_boot_md5']
                with contextlib.suppress(KeyError):
                    conf.force_codepage = data['force_codepage']
                with contextlib.suppress(KeyError):
                    conf.custom_codepage = data['custom_codepage']
                with contextlib.suppress(KeyError):
                    conf.customize_font = data['customize_font']
                with contextlib.suppress(KeyError):
                    conf.pf_font_face = data['pf_font_face']
                with contextlib.suppress(KeyError):
                    conf.pf_font_size = data['pf_font_size']
                if conf.flash_to_inactive_slot:
                    conf.flash_both_slots = False
                if conf.flash_both_slots:
                    conf.flash_to_inactive_slot = False
                with contextlib.suppress(KeyError):
                    conf.dev_mode = data['dev_mode']
                with contextlib.suppress(KeyError):
                    conf.offer_patch_methods = data['offer_patch_methods']
                with contextlib.suppress(KeyError):
                    conf.use_busybox_shell = data['use_busybox_shell']
                with contextlib.suppress(KeyError):
                    conf.linux_file_explorer = data['linux_file_explorer']
                with contextlib.suppress(KeyError):
                    conf.linux_shell = data['linux_shell']
                with contextlib.suppress(KeyError):
                    conf.firmware_has_init_boot = data['firmware_has_init_boot']
                with contextlib.suppress(KeyError):
                    conf.rom_has_init_boot = data['rom_has_init_boot']
                with contextlib.suppress(KeyError):
                    conf.show_recovery_patching_option = data['show_recovery_patching_option']
                with contextlib.suppress(KeyError):
                    conf.pf_home = data['pf_home']
                with contextlib.suppress(KeyError):
                    conf.firmware_sha256 = data['firmware_sha256']
                with contextlib.suppress(KeyError):
                    conf.rom_sha256 = data['rom_sha256']
                with contextlib.suppress(KeyError):
                    conf.low_mem = data['low_mem']
                with contextlib.suppress(KeyError):
                    conf.extra_img_extracts = data['extra_img_extracts']
                with contextlib.suppress(KeyError):
                    conf.show_notifications = data['show_notifications']
                with contextlib.suppress(KeyError):
                    conf.create_boot_tar = data['create_boot_tar']
                with contextlib.suppress(KeyError):
                    conf.delete_bundled_libs = data['delete_bundled_libs']
                with contextlib.suppress(KeyError):
                    conf.check_for_disk_space = data['check_for_disk_space']
                with contextlib.suppress(KeyError):
                    conf.check_for_bootloader_unlocked = data['check_for_bootloader_unlocked']
                with contextlib.suppress(KeyError):
                    conf.check_for_firmware_hash_validity = data['check_for_firmware_hash_validity']
                with contextlib.suppress(KeyError):
                    conf.google_images_update_frequency = data['google_images_update_frequency']
                with contextlib.suppress(KeyError):
                    conf.google_images_last_checked = data['google_images_last_checked']
                with contextlib.suppress(KeyError):
                    conf.enable_dg_clean = data['enable_dg_clean']
                with contextlib.suppress(KeyError):
                    conf.enable_bulk_prop = data['enable_bulk_prop']
                with contextlib.suppress(KeyError):
                    conf.enable_pixel_img_process = data['enable_pixel_img_process']
                with contextlib.suppress(KeyError):
                    conf.override_kmi = data['override_kmi']
                with contextlib.suppress(KeyError):
                    conf.keep_temporary_support_files = data['keep_temporary_support_files']
                with contextlib.suppress(KeyError):
                    conf.check_module_updates = data['check_module_updates']
                with contextlib.suppress(KeyError):
                    conf.show_custom_rom_options = data['show_custom_rom_options']
                with contextlib.suppress(KeyError):
                    conf.sanitize_support_files = data['sanitize_support_files']
                with contextlib.suppress(KeyError):
                    conf.language = data['language']
                with contextlib.suppress(KeyError):
                    conf.keep_patch_temporary_files = data['keep_patch_temporary_files']
                with contextlib.suppress(KeyError):
                    conf.kb_index = data['kb_index']
                with contextlib.suppress(KeyError):
                    conf.unmarked_entries_path = data['unmarked_entries_path']
                with contextlib.suppress(KeyError):
                    conf.ksu_asset_selection_mode = data['ksu_asset_selection_mode']
                with contextlib.suppress(KeyError):
                    conf.spoofed_apps = data['spoofed_apps']
                with contextlib.suppress(KeyError):
                    conf.force_ksud_mount_selection = data['force_ksud_mount_selection']
                with contextlib.suppress(KeyError):
                    conf.pif_chunk_size = data['pif_chunk_size']
                with contextlib.suppress(KeyError):
                    conf.pif_chunk_overlap = data['pif_chunk_overlap']

                # read the toolbar section
                with contextlib.suppress(KeyError):
                    toolbar_data = data['toolbar']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['tb_position'] = toolbar_data['tb_position']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['tb_show_text'] = toolbar_data['tb_show_text']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['tb_show_icons'] = toolbar_data['tb_show_icons']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['install_apk'] = toolbar_data['visible']['install_apk']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['package_manager'] = toolbar_data['visible']['package_manager']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['adb_shell'] = toolbar_data['visible']['adb_shell']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['scrcpy'] = toolbar_data['visible']['scrcpy']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['device_info'] = toolbar_data['visible']['device_info']
                    # with contextlib.suppress(KeyError):
                    #     conf.toolbar['visible']['check_verity'] = toolbar_data['visible']['check_verity']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['partition_manager'] = toolbar_data['visible']['partition_manager']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['pi_analysis_report'] = toolbar_data['visible']['pi_analysis_report']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['switch_slot'] = toolbar_data['visible']['switch_slot']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_system'] = toolbar_data['visible']['reboot_system']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_bootloader'] = toolbar_data['visible']['reboot_bootloader']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_fastbootd'] = toolbar_data['visible']['reboot_fastbootd']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_recovery'] = toolbar_data['visible']['reboot_recovery']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_recovery_interactive'] = toolbar_data['visible']['reboot_recovery_interactive']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_safe_mode'] = toolbar_data['visible']['reboot_safe_mode']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_download'] = toolbar_data['visible']['reboot_download']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['reboot_sideload'] = toolbar_data['visible']['reboot_sideload']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['magisk_modules'] = toolbar_data['visible']['magisk_modules']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['install_magisk'] = toolbar_data['visible']['install_magisk']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['magisk_backup_manager'] = toolbar_data['visible']['magisk_backup_manager']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['pif_manager'] = toolbar_data['visible']['pif_manager']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['sos'] = toolbar_data['visible']['sos']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['lock_bootloader'] = toolbar_data['visible']['lock_bootloader']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['unlock_bootloader'] = toolbar_data['visible']['unlock_bootloader']
                    with contextlib.suppress(KeyError):
                        conf.toolbar['visible']['configuration'] = toolbar_data['visible']['configuration']

                    # read the pif section
                    pif_data = data['pif']
                    with contextlib.suppress(KeyError):
                        conf.pif['auto_update_pif_json'] = pif_data['auto_update_pif_json']
                    with contextlib.suppress(KeyError):
                        conf.pif['auto_check_play_integrity'] = pif_data['auto_check_play_integrity']
                    with contextlib.suppress(KeyError):
                        conf.pif['auto_run_migrate'] = pif_data['auto_run_migrate']
                    with contextlib.suppress(KeyError):
                        conf.pif['test_app_index'] = pif_data['test_app_index']
                    with contextlib.suppress(KeyError):
                        conf.pif['disable_uiautomator'] = pif_data['disable_uiautomator']
                    with contextlib.suppress(KeyError):
                        conf.pif['auto_fill'] = pif_data['auto_fill']
                    with contextlib.suppress(KeyError):
                        conf.pif['force_first_api'] = pif_data['force_first_api']
                    with contextlib.suppress(KeyError):
                        conf.pif['first_api_value_when_forced'] = pif_data['first_api_value_when_forced']
                    with contextlib.suppress(KeyError):
                        conf.pif['sort_keys'] = pif_data['sort_keys']
                    with contextlib.suppress(KeyError):
                        conf.pif['keep_unknown'] = pif_data['keep_unknown']
                    with contextlib.suppress(KeyError):
                        conf.pif['spoofBuild'] = pif_data['spoofBuild']
                    with contextlib.suppress(KeyError):
                        conf.pif['spoofProps'] = pif_data['spoofProps']
                    with contextlib.suppress(KeyError):
                        conf.pif['spoofProvider'] = pif_data['spoofProvider']
                    with contextlib.suppress(KeyError):
                        conf.pif['spoofSignature'] = pif_data['spoofSignature']
                    with contextlib.suppress(KeyError):
                        conf.pif['spoofVendingSdk'] = pif_data['spoofVendingSdk']
                    with contextlib.suppress(KeyError):
                        conf.pif['spoofVendingFinger'] = pif_data['spoofVendingFinger']

                # read the scrcpy section
                scrcpy_folder = ''
                with contextlib.suppress(KeyError):
                    scrcpy_data = data['scrcpy']
                    with contextlib.suppress(KeyError):
                        scrcpy_folder = scrcpy_data['folder']
                    with contextlib.suppress(KeyError):
                        conf.scrcpy['path'] = scrcpy_data['path']
                    with contextlib.suppress(KeyError):
                        # handle legacy folder instead of path situation.
                        if scrcpy_folder and not conf.scrcpy['path']:
                            if sys.platform == "win32":
                                conf.scrcpy['path'] = os.path.join(scrcpy_folder, 'scrcpy.exe')
                            else:
                                conf.scrcpy['path'] = os.path.join(scrcpy_folder, 'scrcpy')
                            scrcpy_folder = ''
                    with contextlib.suppress(KeyError):
                        conf.scrcpy['flags'] = scrcpy_data['flags']
            else:
                conf.first_run = True
                conf.first_run_date = f"{datetime.now():%Y-%m-%d %H:%M:%S}"
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: encountered an exception during configuration file loading.")
            print(f"Exception: {e}")
            print("Deleting the configuration file to recover ...")
            os.remove(file_path)
        return conf

    def save(self, file_path):
        if self.flash_to_inactive_slot:
            self.flash_both_slots = False
        if self.flash_both_slots:
            self.flash_to_inactive_slot = False
        data = {
            'device': self.device,
            'firmware_path': self.firmware_path,
            'firmware_is_ota': self.firmware_is_ota,
            'platform_tools_path': self.platform_tools_path,
            'mode': self.flash_mode,
            'phone_path': self.phone_path,
            'magisk': self.magisk,
            'first_run_date': self.first_run_date,
            'last_run_date': f"{datetime.now():%Y-%m-%d %H:%M:%S}",
            'width': self.width,
            'height': self.height,
            'magisk_width': self.magisk_width,
            'magisk_height': self.magisk_height,
            'pif_width': self.pif_width,
            'pif_height': self.pif_height,
            'custom_rom': self.custom_rom,
            'custom_rom_path': self.custom_rom_path,
            'disable_verification': self.disable_verification,
            'disable_verity': self.disable_verity,
            'fastboot_force': self.fastboot_force,
            'fastboot_verbose': self.fastboot_verbose,
            'temporary_root': self.temporary_root,
            'no_reboot': self.no_reboot,
            'advanced_options': self.advanced_options,
            'update_check': self.update_check,
            'version': VERSION,
            'flash_both_slots': self.flash_both_slots,
            'flash_to_inactive_slot': self.flash_to_inactive_slot,
            'verbose': self.verbose,
            'pos_x': self.pos_x,
            'pos_y': self.pos_y,
            'boot_id': self.boot_id,
            'selected_boot_md5': self.selected_boot_md5,
            'force_codepage': self.force_codepage,
            'custom_codepage': self.custom_codepage,
            'customize_font': self.customize_font,
            'pf_font_face': self.pf_font_face,
            'pf_font_size': self.pf_font_size,
            'dev_mode': self.dev_mode,
            'offer_patch_methods': self.offer_patch_methods,
            'use_busybox_shell': self.use_busybox_shell,
            'linux_file_explorer': self.linux_file_explorer,
            'linux_shell': self.linux_shell,
            'firmware_has_init_boot': self.firmware_has_init_boot,
            'rom_has_init_boot': self.rom_has_init_boot,
            'show_recovery_patching_option': self.show_recovery_patching_option,
            'pf_home': self.pf_home,
            'firmware_sha256': self.firmware_sha256,
            'rom_sha256': self.rom_sha256,
            'low_mem': self.low_mem,
            'extra_img_extracts': self.extra_img_extracts,
            'show_notifications': self.show_notifications,
            'create_boot_tar': self.create_boot_tar,
            'delete_bundled_libs': self.delete_bundled_libs,
            'check_for_disk_space': self.check_for_disk_space,
            'check_for_bootloader_unlocked': self.check_for_bootloader_unlocked,
            'check_for_firmware_hash_validity': self.check_for_firmware_hash_validity,
            'google_images_update_frequency': self.google_images_update_frequency,
            'google_images_last_checked': self.google_images_last_checked,
            'enable_dg_clean': self.enable_dg_clean,
            'enable_bulk_prop': self.enable_bulk_prop,
            'enable_pixel_img_process': self.enable_pixel_img_process,
            'toolbar': self.toolbar,  # Save the toolbar settings as well
            'pif': self.pif,  # Save the pif settings as well
            'scrcpy': self.scrcpy,  # Save the scrcpy settings as well
            'override_kmi': self.override_kmi,
            'keep_temporary_support_files': self.keep_temporary_support_files,
            'check_module_updates': self.check_module_updates,
            'show_custom_rom_options': self.show_custom_rom_options,
            'sanitize_support_files': self.sanitize_support_files,
            'language': self.language,
            'keep_patch_temporary_files': self.keep_patch_temporary_files,
            'kb_index': self.kb_index,
            'unmarked_entries_path': self.unmarked_entries_path,
            'ksu_asset_selection_mode': self.ksu_asset_selection_mode,
            'spoofed_apps': self.spoofed_apps,
            'force_ksud_mount_selection': self.force_ksud_mount_selection,
            'pif_chunk_size': self.pif_chunk_size,
            'pif_chunk_overlap': self.pif_chunk_overlap
        }
        with open(file_path, 'w', encoding="ISO-8859-1", errors="replace", newline='\n') as f:
            json.dump(data, f, indent=4)
            f.close()

```

`constants.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

APPNAME = 'PixelFlasher'
CONFIG_FILE_NAME = 'PixelFlasher.json'
VERSION = '8.15.0.0'
SDKVERSION = '33.0.3'
MAIN_WIDTH = 1400
MAIN_HEIGHT = 1040
MAGISK_WIDTH = 1400
MAGISK_HEIGHT = 1040
PIF_WIDTH = 1150
PIF_HEIGHT = 840
POS_X = 40
POS_Y = 40

KNOWN_BAD_MAGISKS = ['7dbfba76:25207', 'e5641d5b:25208', '2717feac:25209', '981ccabb:25210', '69529ac5:25211', 'e2545e57:26001', '26.0:26000', 'a8c4a33e:26103']
PIF_UPDATE_URL = 'https://raw.githubusercontent.com/chiteroman/PlayIntegrityFix/main/update.json'
OSM0SIS_PIF_UPDATE_URL = 'https://raw.githubusercontent.com/osm0sis/PlayIntegrityFork/main/update.json'
TRICKYSTORE_UPDATE_URL = 'https://raw.githubusercontent.com/5ec1cff/TrickyStore/main/update.json' # non-existent, just a placeholder
TARGETEDFIX_UPDATE_URL = 'https://raw.githubusercontent.com/VisionR1/TargetedFix/main/update.json'
PIF_JSON_PATH = '/data/adb/pif.json'
XIAOMI_URL = "https://sourceforge.net/projects/xiaomi-eu-multilang-miui-roms/rss?path=/xiaomi.eu/Xiaomi.eu-app"
FREEMANURL = "https://codeload.github.com/TheFreeman193/PIFS/zip/refs/heads/main"
SCRCPYURL = "https://github.com/Genymobile/scrcpy/releases/latest"
MAGISK_PKG_NAME = 'com.topjohnwu.magisk'
MAGISK_ALPHA_PKG_NAME = 'io.github.vvb2060.magisk'
MAGISK_DELTA_PKG_NAME = 'io.github.huskydg.magisk'
KERNEL_SU_PKG_NAME = 'me.weishu.kernelsu'
KSU_NEXT_PKG_NAME = 'com.rifsxd.ksunext'
SUKISU_PKG_NAME = 'com.sukisu.ultra'
WILD_KSU_PKG_NAME = 'com.twj.wksu'
APATCH_PKG_NAME = 'me.bmax.apatch'
APATCH_NEXT_PKG_NAME = 'me.garfieldhan.apatch.next'
ZYGISK_NEXT_UPDATE_URL = 'https://api.nullptr.icu/android/zygisk-next/static/update.json'
ANDROID_CANARY_VERSION = 'CANARY_r03'
TARGETEDFIX_CONFIG_PATH = '/data/adb/modules/targetedfix/config'
CANARY_MINER_CATALOG_URL = 'https://raw.githubusercontent.com/Vagelis1608/get_the_canary_miner/refs/heads/main/catalog.json'

# https://xdaforums.com/t/module-play-integrity-fix-safetynet-fix.4607985/page-518#post-89308909
BANNED_KERNELS = [
    '-AICP',
    '-arter97',
    '-blu_spark',
    '-CAF',
    '-cm-',
    '-crDroid',
    '-crdroid',
    '-CyanogenMod',
    '-Deathly',
    '-EAS-',
    '-eas-',
    '-ElementalX',
    '-Elite',
    '-franco',
    '-hadesKernel',
    '-Lineage-',
    '-lineage-',
    '-LineageOS',
    '-lineageos',
    '-mokee'
    '-MoRoKernel',
    '-Noble',
    '-Optimus',
    '-SlimRoms',
    '-Sultan',
    '-sultan'
]

SHADOW_BANNED_ISSUERS = [
    'DUMMY_PLACEHOLDER_FOR_FUTURE_USE'
]

# Language names for the language selection menu
LANGUAGE_NAMES = {
    'en': 'English',
    'ar': 'العربية (Arabic)',
    'cs': 'Čeština (Czech)',
    'da': 'Dansk (Danish)',
    'de': 'Deutsch (German)',
    'el': 'Ελληνικά (Greek)',
    'es': 'Español (Spanish)',
    'fr': 'Français (French)',
    'he': 'עברית (Hebrew)',
    'hu': 'Magyar (Hungarian)',
    'it': 'Italiano (Italian)',
    'ja': '日本語 (Japanese)',
    'ko': '한국어 (Korean)',
    'nl': 'Nederlands (Dutch)',
    'pl': 'Polski (Polish)',
    'pt': 'Português (Portuguese)',
    'ro': 'Română (Romanian)',
    'ru': 'Русский (Russian)',
    'sv': 'Svenska (Swedish)',
    'uk': 'Українська (Ukrainian)',
    'vi': 'Tiếng Việt (Vietnamese)',
    'zh_CN': '简体中文 (Simplified Chinese)',
    'zh_TW': '繁體中文 (Traditional Chinese)'
}

```

`custom_controls.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
import wx.lib.buttons as buttons
import os
import json
import traceback
import webbrowser
import contextlib
from datetime import datetime
from runtime import get_device_images_history_file_path, detect_encoding, puml, get_phone
from i18n import _


# ============================================================================
#                               Class FilePickerComboBox
# ============================================================================
class FilePickerComboBox(wx.Panel):
    def __init__(self, parent, dialog_title=_("Select a file"), wildcard="All files (*.*)|*.*"):
        super(FilePickerComboBox, self).__init__(parent)

        self.history_file = get_device_images_history_file_path()
        self.dialog_title = dialog_title
        self.wildcard = wildcard
        self.history = []

        self.combo_box = wx.ComboBox(self, wx.ID_ANY, style=wx.CB_READONLY)
        self.browse_button = wx.Button(self, wx.ID_ANY, _('Browse'))

        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.combo_box, 1, wx.EXPAND)
        sizer.Add(self.browse_button, 0, wx.EXPAND)
        self.SetSizer(sizer)

        self.browse_button.Bind(wx.EVT_BUTTON, self.on_browse)
        self.combo_box.Bind(wx.EVT_MOUSEWHEEL, self.on_mousewheel)

        if os.path.exists(self.history_file):
            try:
                encoding = detect_encoding(self.history_file)
                with open(self.history_file, 'r', encoding=encoding, errors="replace") as f:
                    self.history = json.load(f)
                    self.combo_box.SetItems(self.history)
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: encountered an exception during device_images_history_file loading.")
                print(f"Exception: {e}")
                print("Deleting the device_images_history_file to recover ...")
                os.remove(self.history_file)

    def SetButtonLabel(self, label):
        self.browse_button.SetLabel(label)

    def SetButtonWidth(self, width):
        current_size = self.browse_button.GetSize()
        self.browse_button.SetMinSize(wx.Size(width, current_size.GetHeight()))
        self.browse_button.SetSize(wx.Size(width, current_size.GetHeight()))

    def GetButtonWidth(self):
        return self.browse_button.GetSize().GetWidth()

    def GetPickerCtrl(self):
        # Return the browse button to make the interface compatible with wx picker controls.
        return self.browse_button

    def on_browse(self, event):
        file_dialog = wx.FileDialog(self, self.dialog_title, wildcard=self.wildcard)
        if file_dialog.ShowModal() == wx.ID_OK:
            file_path = file_dialog.GetPath()
            if file_path not in self.history:
                self.history.insert(0, file_path)
                self.combo_box.Insert(file_path, 0)
                if len(self.history) > 16:
                    self.history.pop()
                if self.combo_box.Count > 16:
                    self.combo_box.Delete(self.combo_box.Count - 1)
            self.combo_box.SetValue(file_path)
            wx.PostEvent(self.combo_box, wx.CommandEvent(wx.EVT_COMBOBOX.typeId, self.combo_box.GetId()))

    def SetPath(self, path):
        if path and path != '' and path not in self.history:
            self.history.insert(0, path)
            self.combo_box.Insert(path, 0)
            if len(self.history) > 16:
                self.history.pop()
            if self.combo_box.Count > 16:
                self.combo_box.Delete(self.combo_box.Count - 1)
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(self.history, f)
        self.combo_box.SetValue(path)

    def on_combo_box_change(self, event):
        path = event.GetString()
        if path == '':
            path = self.combo_box.GetValue()
        if not os.path.exists(path):
            self.history.remove(path)
            self.combo_box.Delete(self.combo_box.FindString(path))
        if path in self.history:
            self.history.remove(path)
            self.history.insert(0, path)
            self.combo_box.Delete(self.combo_box.FindString(path))
            self.combo_box.Insert(path, 0)
            self.combo_box.SetValue(path)
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(self.history, f)

    def Bind(self, event, handler):
        if event == wx.EVT_FILEPICKER_CHANGED:
            self.handler = handler
            self.combo_box.Bind(wx.EVT_COMBOBOX, self._on_combo_box_change)

    def _on_combo_box_change(self, event):
        self.handler(event)
        self.on_combo_box_change(event)

    def GetPath(self):
        return self.combo_box.GetStringSelection()

    def SetToolTip(self, tooltip_text):
        self.combo_box.SetToolTip(tooltip_text)

    def on_mousewheel(self, event):
        # Stop the event propagation to disable mouse wheel scrolling
        event.StopPropagation()


# ============================================================================
#                               Class NoScrollComboBox
# ============================================================================
class NoScrollComboBox(wx.ComboBox):
    def __init__(self, *args, **kwargs):
        super(NoScrollComboBox, self).__init__(*args, **kwargs)
        self.Bind(wx.EVT_MOUSEWHEEL, self.on_mousewheel)

    def on_mousewheel(self, event):
        # Stop the event propagation to disable mouse wheel scrolling
        event.StopPropagation()


# ============================================================================
#                               Class NoScrollChoice
# ============================================================================
class NoScrollChoice(wx.Choice):
    def __init__(self, *args, **kwargs):
        super(NoScrollChoice, self).__init__(*args, **kwargs)
        self.Bind(wx.EVT_MOUSEWHEEL, self.on_mousewheel)

    def on_mousewheel(self, event):
        # Stop the event propagation to disable mouse wheel scrolling
        event.StopPropagation()


# ============================================================================
#                               Class DropDownLink
# ============================================================================
class DropDownLink(wx.BitmapButton):
    def __init__(self, parent, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW):
        super().__init__(parent, id, bitmap, pos, size, style)
        self.Bind(wx.EVT_BUTTON, self.OnButtonClick)
        self.popup_menu = wx.Menu()

    def OnButtonClick(self, event):
        self.PopupMenu(self.popup_menu)

    def AddLink(self, label, url, icon=None):
        item = self.popup_menu.Append(wx.ID_ANY, label)
        if icon:
            item.SetBitmap(icon)
        self.Bind(wx.EVT_MENU, lambda event, url=url: self.OnLinkSelected(event, url), item)

    def OnLinkSelected(self, event, url):
        # Handle the selected link here
        print(f"Selected link: {url}")
        open_device_image_download_link(url)


# ============================================================================
#                               Class DropDownButton
# ============================================================================
class DropDownButton(buttons.GenBitmapTextButton):
    # def __init__(self, parent, id=wx.ID_ANY, label='', pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
    #     super().__init__(parent, id, wx.NullBitmap, label, pos, size, style)
    def __init__(self, parent, id, bitmap, label, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        super().__init__(parent, id, bitmap, label, pos, size, style)
        self.Bind(wx.EVT_BUTTON, self.OnButtonClick)
        self.popup_menu = wx.Menu()

    def SetBitmap(self, bitmap):
        if bitmap.IsOk():
            self.SetBitmapLabel(bitmap)
        else:
            print("Invalid bitmap")

    def OnButtonClick(self, event):
        self.PopupMenu(self.popup_menu)

    def AddFunction(self, label, function, icon_bitmap=None, enabled=True):
        item = self.popup_menu.Append(wx.ID_ANY, label)
        item.Enable(enabled)
        if icon_bitmap:
            item.SetBitmap(icon_bitmap)
        self.Bind(wx.EVT_MENU, lambda event, function=function: self.OnFunctionSelected(event, function), item)
        return item

    def OnFunctionSelected(self, event, function):
        # Call the selected function here
        function()

# ============================================================================
#                     Class ResizableButtonDirPickerCtrl
# ============================================================================
class ResizableButtonDirPickerCtrl(wx.DirPickerCtrl):
    # Custom DirPickerCtrl with ability to easily resize the browse button.

    def __init__(self, parent, id=wx.ID_ANY, path="", message="Select a folder",
                    style=wx.DIRP_USE_TEXTCTRL|wx.DIRP_DIR_MUST_EXIST,
                    button_label=None, button_width=None):
        super().__init__(parent, id, path, message, style=style)

        # Set button label if provided
        if button_label is not None:
            self.SetButtonLabel(button_label)

        # Set button width if provided
        if button_width is not None:
            self.SetButtonWidth(button_width)

    def SetButtonLabel(self, label):
        if self.GetPickerCtrl():
            self.GetPickerCtrl().SetLabel(label)

    def SetButtonWidth(self, width):
        if self.GetPickerCtrl():
            current_size = self.GetPickerCtrl().GetSize()
            self.GetPickerCtrl().SetMinSize(wx.Size(width, current_size.GetHeight()))
            self.GetPickerCtrl().SetSize(wx.Size(width, current_size.GetHeight()))

    def GetButtonWidth(self):
        if self.GetPickerCtrl():
            return self.GetPickerCtrl().GetSize().GetWidth()
        return 0

# ============================================================================
#                     Class ResizableButtonFilePickerCtrl
# ============================================================================
class ResizableButtonFilePickerCtrl(wx.FilePickerCtrl):
    # Custom FilePickerCtrl with ability to easily resize the browse button.

    def __init__(self, parent, id=wx.ID_ANY, path="", message="Select a file",
                    wildcard="All files (*.*)|*.*", style=wx.FLP_USE_TEXTCTRL,
                    button_label=None, button_width=None):
        super().__init__(parent, id, path, message, wildcard, style=style)

        # Set button label if provided
        if button_label is not None:
            self.SetButtonLabel(button_label)

        # Set button width if provided
        if button_width is not None:
            self.SetButtonWidth(button_width)

    def SetButtonLabel(self, label):
        if self.GetPickerCtrl():
            self.GetPickerCtrl().SetLabel(label)

    def SetButtonWidth(self, width):
        if self.GetPickerCtrl():
            current_size = self.GetPickerCtrl().GetSize()
            self.GetPickerCtrl().SetMinSize(wx.Size(width, current_size.GetHeight()))
            self.GetPickerCtrl().SetSize(wx.Size(width, current_size.GetHeight()))

    def GetButtonWidth(self):
        if self.GetPickerCtrl():
            return self.GetPickerCtrl().GetSize().GetWidth()
        return 0


# ============================================================================
#                    Function _open_device_image_download_link
# ============================================================================
def open_device_image_download_link(url):
    try:
        with contextlib.suppress(Exception):
            device = get_phone()
            if device:
                hardware = device.hardware
            else:
                hardware = ''
        print(f"Launching browser for Google image download URL: {url}#{hardware}")
        webbrowser.open_new(f"{url}#{hardware}")
        puml(f":Open Link;\nnote right\n=== {hardware} Firmware Link\n[[{url}#{hardware}]]\nend note\n", True)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening firmware link")
        traceback.print_exc()

```

`device_selector.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
from i18n import _


# ============================================================================
#                               Class DeviceSelectorDialog
# ============================================================================
class DeviceSelectorDialog(wx.Dialog):

    # ============================================================================
    #                               Function __init__
    # ============================================================================
    def __init__(self, parent, devices, title=_("Select Device"), message=_("Select a device:"), select_device=None):
        super().__init__(parent, title=title, style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER)

        self.devices = devices
        self.selected_device = None
        self._select_device = select_device

        self._create_ui(message)
        self._bind_events()
        self._size_and_center()
        self.Bind(wx.EVT_CLOSE, self.on_close)

    # ============================================================================
    #                               Function _create_ui
    # ============================================================================
    def _create_ui(self, message):
        main_sizer = wx.BoxSizer(wx.VERTICAL)

        # Message
        message_label = wx.StaticText(self, label=message)
        main_sizer.Add(message_label, 0, wx.ALL | wx.EXPAND, 10)

        # Device list
        self.device_list = wx.ListCtrl(self, style=wx.LC_REPORT | wx.LC_SINGLE_SEL)
        self.device_list.AppendColumn("Device", width=200)
        self.device_list.AppendColumn("Filename", width=500)

        # Populate the list
        selected_index = None

        for i, device in enumerate(self.devices):
            index = self.device_list.InsertItem(i, device.get('device', 'Unknown'))
            self.device_list.SetItem(index, 1, device.get('zip_filename', ''))
            self.device_list.SetItemData(index, i)
            if selected_index is None and self._matches_select_device(device):
                selected_index = index

        # Select first item by default
        if selected_index is not None:
            self.device_list.Select(selected_index)
            self.device_list.EnsureVisible(selected_index)
        elif self.devices:
            self.device_list.Select(0)

        main_sizer.Add(self.device_list, 1, wx.ALL | wx.EXPAND, 10)

        # Buttons
        button_sizer = wx.StdDialogButtonSizer()

        ok_button = wx.Button(self, wx.ID_OK, _("OK"))
        ok_button.SetDefault()
        button_sizer.AddButton(ok_button)

        cancel_button = wx.Button(self, wx.ID_CANCEL, _("Cancel"))
        button_sizer.AddButton(cancel_button)

        button_sizer.Realize()
        main_sizer.Add(button_sizer, 0, wx.ALL | wx.ALIGN_RIGHT, 10)

        self.SetSizer(main_sizer)

    # ============================================================================
    #                               Function _matches_select_device
    # ============================================================================
    def _matches_select_device(self, device):
        if not self._select_device:
            return False

        target = self._select_device

        if isinstance(target, dict):
            if device is target:
                return True
            target_device = target.get('device')
            target_filename = target.get('zip_filename')
        else:
            target_device = target
            target_filename = target

        def normalize(value):
            if value is None:
                return None
            if isinstance(value, str):
                return value.strip().lower()
            return str(value).strip().lower()

        device_name = normalize(device.get('device'))
        filename = normalize(device.get('zip_filename'))

        if isinstance(target, dict):
            target_device_normalized = normalize(target_device)
            target_filename_normalized = normalize(target_filename)
            return (
                target_device_normalized is not None and target_device_normalized == device_name
            ) or (
                target_filename_normalized is not None and target_filename_normalized == filename
            )

        normalized_target = normalize(target_device)
        return normalized_target is not None and (
            normalized_target == device_name or normalized_target == filename
        )

    # ============================================================================
    #                               Function _bind_events
    # ============================================================================
    def _bind_events(self):
        self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_item_activated)
        self.Bind(wx.EVT_BUTTON, self.on_ok, id=wx.ID_OK)

    # ============================================================================
    #                               Function _size_and_center
    # ============================================================================
    def _size_and_center(self):
        self.SetSize((750, 850))
        self.CenterOnParent()

    # ============================================================================
    #                               Function on_item_activated
    # ============================================================================
    def on_item_activated(self, event):
        # Handle double-click on list item
        self.EndModal(wx.ID_OK)

    # ============================================================================
    #                               Function on_ok
    # ============================================================================
    def on_ok(self, event):
        selection = self.device_list.GetFirstSelected()
        if selection != -1:
            device_index = self.device_list.GetItemData(selection)
            self.selected_device = self.devices[device_index]
            self.EndModal(wx.ID_OK)
        else:
            wx.MessageBox(_("Please select a device."), _("No Selection"), wx.OK | wx.ICON_WARNING, self)

    # ============================================================================
    #                               Function on_close
    # ============================================================================
    def on_close(self, event):
        self.EndModal(wx.ID_CANCEL)

    # ============================================================================
    #                               Function get_selected_device
    # ============================================================================
    def get_selected_device(self):
        return self.selected_device

# ============================================================================
#                               Function show_device_selector
# ============================================================================
def show_device_selector(parent, devices, title=_("Select Device"), message=_("Select a device:"), select_device=None):
    """
    Show device selector dialog and return selected device.

    Args:
        parent: Parent window
        devices: List of device dictionaries with 'device', 'zip_filename', 'url' keys
        title: Dialog title
        message: Message to display above the list
        select_device: Preferred device (dict or string identifier) to pre-select if available

    Returns:
        Selected device dictionary or None if cancelled
    """
    if not devices:
        wx.MessageBox(_("No devices available."), _("Error"), wx.OK | wx.ICON_ERROR, parent)
        return None

    dialog = DeviceSelectorDialog(parent, devices, title, message, select_device=select_device)

    try:
        if dialog.ShowModal() == wx.ID_OK:
            return dialog.get_selected_device()
        else:
            return None
    finally:
        dialog.Destroy()

```

`download_progress.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
from i18n import _

# ============================================================================
#                               Class FilePickerComboBox
# ============================================================================
class DownloadProgressWindow(wx.Frame):
    def __init__(self, parent):
        wx.Frame.__init__(self, parent, title="Downloads Progress", style=wx.DEFAULT_FRAME_STYLE | wx.FRAME_FLOAT_ON_PARENT)

        self.parent = parent
        self.SetSize((800, 500))

        self.panel = wx.Panel(self)
        self.main_sizer = wx.BoxSizer(wx.VERTICAL)

        self.scrolled_window = wx.ScrolledWindow(self.panel)
        self.scrolled_window.SetScrollRate(0, 10)

        self.download_sizer = wx.BoxSizer(wx.VERTICAL)
        self.scrolled_window.SetSizer(self.download_sizer)

        self.main_sizer.Add(self.scrolled_window, 1, wx.EXPAND | wx.ALL, 10)
        self.panel.SetSizer(self.main_sizer)

        # Dictionary to store download items (URL -> (gauge, cancel_button, sizer))
        self.downloads = {}

        # Center the window on parent
        self.CenterOnParent()

    def add_download(self, url, filename):
        if url in self.downloads:
            return self.downloads[url][0], self.downloads[url][1]

        item_panel = wx.Panel(self.scrolled_window)
        item_sizer = wx.BoxSizer(wx.VERTICAL)

        # URL and Filename
        label_sizer = wx.BoxSizer(wx.HORIZONTAL)
        url_label = wx.StaticText(item_panel, label=_("Downloading: %s") % filename)
        label_sizer.Add(url_label, 1, wx.EXPAND)

        # Progress bar and cancel button
        gauge_sizer = wx.BoxSizer(wx.HORIZONTAL)
        gauge = wx.Gauge(item_panel, range=100, size=(-1, 20), style=wx.GA_HORIZONTAL | wx.GA_SMOOTH)
        cancel_button = wx.Button(item_panel, label=_("Cancel"), size=(70, -1))

        gauge_sizer.Add(gauge, 1, wx.EXPAND | wx.RIGHT, 5)
        gauge_sizer.Add(cancel_button, 0)

        item_sizer.Add(label_sizer, 0, wx.EXPAND | wx.BOTTOM, 5)
        item_sizer.Add(gauge_sizer, 0, wx.EXPAND)

        separator = wx.StaticLine(item_panel)
        item_sizer.Add(separator, 0, wx.EXPAND | wx.TOP | wx.BOTTOM, 10)

        item_panel.SetSizer(item_sizer)
        self.download_sizer.Add(item_panel, 0, wx.EXPAND | wx.ALL, 5)

        self.downloads[url] = (gauge, cancel_button, item_panel)

        self.download_sizer.Layout()
        self.scrolled_window.FitInside()

        # Show the window if it's the first download
        if len(self.downloads) == 1:
            self.Show()

        return gauge, cancel_button

    def remove_download(self, url):
        if url in self.downloads:
            gauge, cancel_button, panel = self.downloads[url]
            panel.Destroy()
            del self.downloads[url]

            self.download_sizer.Layout()
            self.scrolled_window.FitInside()

            if not self.downloads:
                self.Hide()

```

`encode-bitmaps.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

"""
This is a way to save the startup time when running img2py on lots of
files...
"""

import os
from wx.tools import img2py

command_lines = [
    "-a -F -i -n about-24 images/about-24.png images.py",
    "-a -F -i -n about-64 images/about-64.png images.py",
    "-a -F -i -n add-24 images/add-24.png images.py",
    "-a -F -i -n settings-24 images/settings-24.png images.py",
    "-a -F -i -n settings-64 images/settings-64.png images.py",
    "-a -F -i -n backup-24 images/backup-24.png images.py",
    "-a -F -i -n backup-64 images/backup-64.png images.py",
    "-a -F -i -n blank images/blank.png images.py",
    "-a -F -i -n boot-24 images/boot-24.png images.py",
    "-a -F -i -n bottom-24 images/bottom-24.png images.py",
    "-a -F -i -n bug-24 images/bug-24.png images.py",
    "-a -F -i -n custom-patch-24 images/custom-patch-24.png images.py",
    "-a -F -i -n delete-24 images/delete-24.png images.py",
    "-a -F -i -n exit-24 images/exit-24.png images.py",
    "-a -F -i -n feature-24 images/feature-24.png images.py",
    "-a -F -i -n flash-24 images/flash-24.png images.py",
    "-a -F -i -n flash-32 images/flash-32.png images.py",
    "-a -F -i -n folder-24 images/folder-24.png images.py",
    "-a -F -i -n forum-24 images/forum-24.png images.py",
    "-a -F -i -n github-24 images/github-24.png images.py",
    "-a -F -i -n guide-24 images/guide-24.png images.py",
    "-a -F -i -n Icon-256 images/icon-256.png images.py",
    "-a -F -i -n Icon-dark-256 images/icon-dark-256.png images.py",
    "-a -F -i -n install-apk-24 images/install-apk-24.png images.py",
    "-a -F -i -n install-apk-64 images/install-apk-64.png images.py",
    "-a -F -i -n install-magisk-24 images/install-magisk-24.png images.py",
    "-a -F -i -n install-magisk-64 images/install-magisk-64.png images.py",
    "-a -F -i -n left-24 images/left-24.png images.py",
    "-a -F -i -n lock-24 images/lock-24.png images.py",
    "-a -F -i -n lock-64 images/lock-64.png images.py",
    "-a -F -i -n magisk-16 images/magisk-16.png images.py",
    "-a -F -i -n magisk-24 images/magisk-24.png images.py",
    "-a -F -i -n magisk-48 images/magisk-48.png images.py",
    "-a -F -i -n magisk-64 images/magisk-64.png images.py",
    "-a -F -i -n official-16 images/official-16.png images.py",
    "-a -F -i -n official-24 images/official-24.png images.py",
    "-a -F -i -n open-link-24 images/open-link-24.png images.py",
    "-a -F -i -n open-link-red-24 images/open-link-red-24.png images.py",
    "-a -F -i -n packages-24 images/packages-24.png images.py",
    "-a -F -i -n packages-64 images/packages-64.png images.py",
    "-a -F -i -n partition-24 images/partition-24.png images.py",
    "-a -F -i -n partition-64 images/partition-64.png images.py",
    "-a -F -i -n paste-24 images/paste-24.png images.py",
    "-a -F -i -n paste-up-24 images/paste-up-24.png images.py",
    "-a -F -i -n smart-paste-up-24 images/smart-paste-up-24.png images.py",
    "-a -F -i -n paste-down-24 images/paste-down-24.png images.py",
    "-a -F -i -n patch-24 images/patch-24.png images.py",
    "-a -F -i -n patched-16 images/patched-16.png images.py",
    "-a -F -i -n patched-24 images/patched-24.png images.py",
    "-a -F -i -n process_file-24 images/process_file-24.png images.py",
    "-a -F -i -n reboot-24 images/reboot-24.png images.py",
    "-a -F -i -n reboot-64 images/reboot-64.png images.py",
    "-a -F -i -n reboot-System-24 images/reboot-system-24.png images.py",
    "-a -F -i -n reboot-system-64 images/reboot-system-64.png images.py",
    "-a -F -i -n reboot-bootloader-24 images/reboot-bootloader-24.png images.py",
    "-a -F -i -n reboot-bootloader-64 images/reboot-bootloader-64.png images.py",
    "-a -F -i -n reboot-fastbootd-24 images/reboot-fastbootd-24.png images.py",
    "-a -F -i -n reboot-fastbootd-64 images/reboot-fastbootd-64.png images.py",
    "-a -F -i -n reboot-download-24 images/reboot-download-24.png images.py",
    "-a -F -i -n reboot-download-64 images/reboot-download-64.png images.py",
    "-a -F -i -n reboot-recovery-24 images/reboot-recovery-24.png images.py",
    "-a -F -i -n reboot-recovery-64 images/reboot-recovery-64.png images.py",
    "-a -F -i -n reboot-irecovery-24 images/reboot-irecovery-24.png images.py",
    "-a -F -i -n reboot-irecovery-64 images/reboot-irecovery-64.png images.py",
    "-a -F -i -n reboot-safe-mode-24 images/reboot-safe-mode-24.png images.py",
    "-a -F -i -n reboot-safe-mode-64 images/reboot-safe-mode-64.png images.py",
    "-a -F -i -n reboot-sideload-24 images/reboot-sideload-24.png images.py",
    "-a -F -i -n reboot-sideload-64 images/reboot-sideload-64.png images.py",
    "-a -F -i -n right-24 images/right-24.png images.py",
    "-a -F -i -n scan-24 images/scan-24.png images.py",
    "-a -F -i -n scan-all-24 images/scan-all-24.png images.py",
    "-a -F -i -n shell-24 images/shell-24.png images.py",
    "-a -F -i -n shell-64 images/shell-64.png images.py",
    "-a -F -i -n shell-64-disabled images/shell-64-disabled.png images.py",
    "-a -F -i -n scrcpy-24 images/scrcpy-24.png images.py",
    "-a -F -i -n scrcpy-64 images/scrcpy-64.png images.py",
    "-a -F -i -n shield-24 images/shield-24.png images.py",
    "-a -F -i -n shield-64 images/shield-64.png images.py",
    "-a -F -i -n sos-24 images/sos-24.png images.py",
    "-a -F -i -n sos-64 images/sos-64.png images.py",
    "-a -F -i -n Splash images/splash.png images.py",
    "-a -F -i -n Splash-dark images/splash-dark.png images.py",
    "-a -F -i -n support-24 images/support-24.png images.py",
    "-a -F -i -n switch-slot-24 images/switch-slot-24.png images.py",
    "-a -F -i -n switch-slot-64 images/switch-slot-64.png images.py",
    "-a -F -i -n top-24 images/top-24.png images.py",
    "-a -F -i -n unlock-24 images/unlock-24.png images.py",
    "-a -F -i -n unlock-64 images/unlock-64.png images.py",
    "-a -F -i -n update-check-24 images/update-check-24.png images.py",
    "-a -F -i -n wifi-adb-24 images/wifi-adb-24.png images.py",
    "-a -F -i -n slot-a-48 images/slot-a-48.png images.py",
    "-a -F -i -n slot-b-48 images/slot-b-48.png images.py",
    "-a -F -i -n rooted images/rooted.png images.py",
    "-a -F -i -n watch-green-24 images/watch-green-24.png images.py",
    "-a -F -i -n watch-blue-24 images/watch-blue-24.png images.py",
    "-a -F -i -n phone-green-24 images/phone-green-24.png images.py",
    "-a -F -i -n phone-blue-24 images/phone-blue-24.png images.py",
    "-a -F -i -n disable-24 images/disable-24.png images.py",
    "-a -F -i -n enable-24 images/enable-24.png images.py",
    "-a -F -i -n download-16 images/download-16.png images.py",
    "-a -F -i -n download-24 images/download-24.png images.py",
    "-a -F -i -n uninstall-24 images/uninstall-24.png images.py",
    "-a -F -i -n launch-24 images/launch-24.png images.py",
    "-a -F -i -n kill-24 images/kill-24.png images.py",
    "-a -F -i -n clear-24 images/clear-24.png images.py",
    "-a -F -i -n check-24 images/check-24.png images.py",
    "-a -F -i -n uncheck-24 images/uncheck-24.png images.py",
    "-a -F -i -n clipboard-24 images/clipboard-24.png images.py",
    "-a -F -i -n push-24 images/push-24.png images.py",
    "-a -F -i -n push-cart-24 images/push-cart-24.png images.py",
    "-a -F -i -n json-24 images/json-24.png images.py",
    "-a -F -i -n xml-24 images/xml-24.png images.py",
    "-a -F -i -n alert-red-24 images/alert-red-24.png images.py",
    "-a -F -i -n alert-gray-24 images/alert-gray-24.png images.py",
    "-a -F -i -n pif-24 images/pif-24.png images.py",
    "-a -F -i -n pif-64 images/pif-64.png images.py",
    "-a -F -i -n heart-red-24 images/heart-red-24.png images.py",
    "-a -F -i -n heart-gray-24 images/heart-gray-24.png images.py",
    "-a -F -i -n import-24 images/import-24.png images.py",
    "-a -F -i -n cancel-ota-24 images/cancel-ota-24.png images.py",
    "-a -F -i -n factory-24 images/factory-24.png images.py",
    "-a -F -i -n cloud-24 images/cloud-24.png images.py",
    "-a -F -i -n star-green-24 images/star-green-24.png images.py",
    "-a -F -i -n e2j-24 images/e2j-24.png images.py",
    "-a -F -i -n j2e-24 images/j2e-24.png images.py",
    "-a -F -i -n save-24 images/save-24.png images.py",
    "-a -F -i -n kernelsu-16 images/kernelsu-16.png images.py",
    "-a -F -i -n kernelsu-24 images/kernelsu-24.png images.py",
    "-a -F -i -n kernelsu-48 images/kernelsu-48.png images.py",
    "-a -F -i -n kernelsu-next-16 images/kernelsu-next-16.png images.py",
    "-a -F -i -n kernelsu-next-24 images/kernelsu-next-24.png images.py",
    "-a -F -i -n kernelsu-next-48 images/kernelsu-next-48.png images.py",
    "-a -F -i -n sukisu-16 images/sukisu-16.png images.py",
    "-a -F -i -n sukisu-24 images/sukisu-24.png images.py",
    "-a -F -i -n sukisu-48 images/sukisu-48.png images.py",
    "-a -F -i -n wild_ksu-16 images/wild_ksu-16.png images.py",
    "-a -F -i -n wild_ksu-24 images/wild_ksu-24.png images.py",
    "-a -F -i -n wild_ksu-48 images/wild_ksu-48.png images.py",
    "-a -F -i -n apatch-16 images/apatch-16.png images.py",
    "-a -F -i -n apatch-24 images/apatch-24.png images.py",
    "-a -F -i -n apatch-48 images/apatch-48.png images.py",
    "-a -F -i -n cert-24 images/cert-24.png images.py",
    "-a -F -i -n downgrade-16 images/downgrade-16.png images.py",
    "-a -F -i -n downgrade-24 images/downgrade-24.png images.py",
    "-a -F -i -n check-otacerts-24 images/check-otacerts-24.png images.py",
    "-a -F -i -n wrench-24 images/wrench-24.png images.py",
    "-a -F -i -n java-24 images/java-24.png images.py",
    "-a -F -i -n folder-zip-24 images/folder-zip-24.png images.py",
    "-a -F -i -n restore-24 images/restore-24.png images.py",
    "-a -F -i -n analyze-24 images/analyze-24.png images.py",
    "-a -F -i -n analyze-64 images/analyze-64.png images.py",
    "-a -F -i -n shizuku-24 images/shizuku-24.png images.py",
    "-a -F -i -n beta-24 images/beta-24.png images.py",
    "-a -F -i -n canary-24 images/canary-24.png images.py",
    "-a -F -i -n all-betas-24 images/all-betas-24.png images.py",
    "-a -F -i -n permissions-24 images/permissions-24.png images.py",
    "-a -F -i -n google-24 images/google-24.png images.py",
    "-a -F -i -n android-24 images/android-24.png images.py",
    "-a -F -i -n axml-24 images/axml-24.png images.py",
    "-a -F -i -n open-url-24 images/open-url-24.png images.py",
    "-a -F -i -n logcat-24 images/logcat-24.png images.py",
    "-a -F -i -n bootloader-versions-24 images/bootloader-versions-24.png images.py",
]

if __name__ == "__main__":
    # first delete the existing images.py
    if os.path.exists("images.py"):
        os.remove("images.py")

    # create images.py with proper header
    with open('images.py', "w", encoding="ISO-8859-1", errors="replace") as f:
        header = """
# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

#----------------------------------------------------------------------
# This file was generated by encode-bitmaps.py
#
from wx.lib.embeddedimage import PyEmbeddedImage

#----------------------------------------------------------------------
SmallUpArrow = PyEmbeddedImage(
    b"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAADxJ"
    b"REFUOI1jZGRiZqAEMFGke2gY8P/f3/9kGwDTjM8QnAaga8JlCG3CAJdt2MQxDCAUaOjyjKMp"
    b"cRAYAABS2CPsss3BWQAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
SmallDnArrow = PyEmbeddedImage(
    b"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAEhJ"
    b"REFUOI1jZGRiZqAEMFGke9QABgYGBgYWdIH///7+J6SJkYmZEacLkCUJacZqAD5DsInTLhDR"
    b"bcPlKrwugGnCFy6Mo3mBAQChDgRlP4RC7wAAAABJRU5ErkJggg==")

        """
        # header = "#----------------------------------------------------------------------\n"
        # header += "# This file was generated by encode-bitmaps.py\n"
        # header += "#\n"
        # header += "from wx.lib.embeddedimage import PyEmbeddedImage\n\n"
        f.write(header)

    # add all the images
    for line in command_lines:
        args = line.split()
        img2py.main(args)


```

`factory_image_selector.py`:

```py
import os
from urllib.parse import urlparse

import wx


def show_factory_image_dialog(parent, title, instruction, root_label, nodes, size=(850, 620), download_button=False):
    dialog = wx.Dialog(parent, title=title, size=size)
    instruction_label = wx.StaticText(dialog, label=instruction)
    tree_ctrl = wx.TreeCtrl(dialog, style=wx.TR_DEFAULT_STYLE | wx.TR_SINGLE)
    root = tree_ctrl.AddRoot(root_label)

    def add_nodes(parent_item, items):
        if not isinstance(items, list):
            return
        for node in items:
            if not isinstance(node, dict):
                continue
            label = str(node.get('label', ''))
            item = tree_ctrl.AppendItem(parent_item, label)
            if 'data' in node:
                tree_ctrl.SetItemData(item, node.get('data'))
            children = node.get('children') or []
            if children:
                add_nodes(item, children)

    add_nodes(root, nodes)
    tree_ctrl.Expand(root)

    button_sizer = wx.BoxSizer(wx.HORIZONTAL)
    ok_button = wx.Button(dialog, wx.ID_OK)
    cancel_button = wx.Button(dialog, wx.ID_CANCEL)
    download_btn = None
    button_sizer.AddStretchSpacer()
    button_sizer.Add(ok_button, 0, wx.RIGHT, 5)
    if download_button:
        download_btn = wx.Button(dialog, wx.ID_ANY, "Download")
        button_sizer.Add(download_btn, 0, wx.RIGHT, 5)
    button_sizer.Add(cancel_button, 0)
    ok_button.Enable(False)
    ok_button.SetDefault()
    if download_btn:
        download_btn.Enable(False)

    def update_button_states():
        selected_item = tree_ctrl.GetSelection()
        if selected_item and selected_item != root:
            item_data = tree_ctrl.GetItemData(selected_item)
            is_valid = item_data is not None
            ok_button.Enable(is_valid)
            if download_btn:
                url = item_data.get('url') if isinstance(item_data, dict) else None
                download_btn.Enable(is_valid and bool(url))
        else:
            ok_button.Enable(False)
            if download_btn:
                download_btn.Enable(False)

    def on_tree_selection(event):
        update_button_states()

    tree_ctrl.Bind(wx.EVT_TREE_SEL_CHANGED, on_tree_selection)

    def on_download(event):
        if not download_btn:
            return
        selected_item = tree_ctrl.GetSelection()
        if not selected_item or selected_item == root:
            return
        item_data = tree_ctrl.GetItemData(selected_item)
        if not isinstance(item_data, dict):
            return
        url = item_data.get('url')
        if not url:
            return
        parsed = urlparse(url)
        filename = os.path.basename(parsed.path) if parsed.path else ''
        if not filename:
            filename = "download"

        launched = wx.LaunchDefaultBrowser(url)
        if launched:
            wx.MessageBox(
                f"Opened in your browser. Use it to download:\n{filename}",
                "Download in Browser",
                style=wx.OK | wx.ICON_INFORMATION,
                parent=dialog,
            )
        else:
            wx.MessageBox(
                f"Unable to open default browser for:\n{url}",
                "Download Error",
                style=wx.OK | wx.ICON_ERROR,
                parent=dialog,
            )

    if download_btn:
        download_btn.Bind(wx.EVT_BUTTON, on_download)

    dialog_sizer = wx.BoxSizer(wx.VERTICAL)
    dialog_sizer.Add(instruction_label, 0, wx.ALL, 10)
    dialog_sizer.Add(tree_ctrl, 1, wx.EXPAND | wx.ALL, 10)
    dialog_sizer.Add(button_sizer, 0, wx.ALIGN_CENTER | wx.ALL, 10)
    dialog.SetSizer(dialog_sizer)
    update_button_states()

    selected_data = None
    if dialog.ShowModal() == wx.ID_OK:
        selected_item = tree_ctrl.GetSelection()
        if selected_item and selected_item != root:
            selected_data = tree_ctrl.GetItemData(selected_item)

    dialog.Destroy()
    return selected_data

```

`file_editor.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import sys

import wx
import wx.stc as stc

from runtime import *
from i18n import _

# ============================================================================
#                               Class FileEditor
# ============================================================================
class FileEditor(wx.Dialog):
    def __init__(self, parent, file_path, language='batch', width=1500, height=600):
        super().__init__(parent=parent, title="File Editor", style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER, size=(width, height))

        self.file_path = file_path
        self.language = language
        self.width = width
        self.height = height
        self.create_widgets()
        self.load_file()
        self.SetSize((self.width, self.height))

    def create_widgets(self):
        # sourcery skip: merge-duplicate-blocks, merge-else-if-into-elif, remove-pass-elif, remove-redundant-if
        self.text_ctrl = stc.StyledTextCtrl(self, style=wx.HSCROLL)
        if sys.platform == "win32":
            if self.language == "batch":
                self.text_ctrl.SetLexer(stc.STC_LEX_BATCH)
                self.text_ctrl.StyleSetSpec(stc.STC_BAT_DEFAULT, "fore:#000000")
                self.text_ctrl.StyleSetSpec(stc.STC_BAT_COMMENT, "fore:#008000")
                self.text_ctrl.StyleSetSpec(stc.STC_BAT_WORD, "fore:#000000,bold,back:#FFFFFF")
                self.text_ctrl.SetKeyWords(0, " ".join(["if else goto echo set", "cd dir rd md del", "call start exit rem"]))
                self.text_ctrl.StyleSetForeground(stc.STC_BAT_COMMAND, wx.Colour(0, 128, 192)) # command color
                self.text_ctrl.StyleSetForeground(stc.STC_BAT_LABEL, wx.Colour(0, 128, 192)) # label color
                self.text_ctrl.StyleSetForeground(stc.STC_BAT_COMMENT, wx.Colour(0, 128, 0)) # comment color
                self.text_ctrl.StyleSetForeground(stc.STC_BAT_WORD, wx.Colour(0, 0, 255)) # keyword color
                self.text_ctrl.StyleSetForeground(stc.STC_BAT_HIDE, wx.Colour(128, 128, 128)) # color for hidden text
                self.text_ctrl.StyleSetForeground(stc.STC_BAT_IDENTIFIER, wx.Colour(255, 128, 0))  # variable text color
                self.text_ctrl.StyleSetForeground(stc.STC_BAT_OPERATOR , wx.Colour(255, 0, 255))  # operator text color
            elif self.language == "json":
                self.text_ctrl.SetLexer(stc.STC_LEX_JSON)
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_DEFAULT, "fore:#000000")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_NUMBER, "fore:#007F7F")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_STRING, "fore:#7F007F")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_PROPERTYNAME, "fore:#007F00")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_ESCAPESEQUENCE, "fore:#7F7F00")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_KEYWORD, "fore:#00007F,bold")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_OPERATOR, "fore:#7F0000")
        else:
            if self.language == "batch":
                self.text_ctrl.SetLexer(stc.STC_LEX_BASH)
                self.text_ctrl.StyleSetSpec(stc.STC_SH_DEFAULT, "fore:#000000")
                self.text_ctrl.StyleSetSpec(stc.STC_SH_COMMENTLINE , "fore:#008000")
                self.text_ctrl.StyleSetSpec(stc.STC_SH_WORD, "fore:#000000,bold,back:#FFFFFF")
                self.text_ctrl.SetKeyWords(0, " ".join(["if else elif fi echo set", "cd dir rd md rm", "exit"]))
                self.text_ctrl.StyleSetForeground(stc.STC_SH_OPERATOR , wx.Colour(0, 128, 192)) # operator color
                self.text_ctrl.StyleSetForeground(stc.STC_SH_STRING  , wx.Colour(205, 146, 93)) # label color
                self.text_ctrl.StyleSetForeground(stc.STC_SH_COMMENTLINE, wx.Colour(0, 128, 0)) # comment color
                self.text_ctrl.StyleSetForeground(stc.STC_SH_WORD, wx.Colour(0, 0, 255)) # keyword color
                self.text_ctrl.StyleSetForeground(stc.STC_SH_IDENTIFIER, wx.Colour(255, 128, 0))  # variable text color
            elif self.language == "json":
                self.text_ctrl.SetLexer(stc.STC_LEX_JSON)
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_DEFAULT, "fore:#000000")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_NUMBER, "fore:#007F7F")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_STRING, "fore:#7F007F")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_PROPERTYNAME, "fore:#007F00")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_ESCAPESEQUENCE, "fore:#7F7F00")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_KEYWORD, "fore:#00007F,bold")
                self.text_ctrl.StyleSetSpec(stc.STC_JSON_OPERATOR, "fore:#7F0000")

        self.text_ctrl.SetCaretForeground(wx.BLACK)
        self.text_ctrl.SetMarginType(1, stc.STC_MARGIN_NUMBER)
        self.text_ctrl.SetMarginWidth(1, 30)

        font = wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        self.text_ctrl.StyleSetFont(wx.stc.STC_STYLE_DEFAULT, font)

        self.open_folder = wx.Button(self, label=_("Open Folder"))
        self.open_shell = wx.Button(self, label=_("Open Shell"))
        self.save_button = wx.Button(self, label=_("Save and Continue"))
        self.cancel_button = wx.Button(self, label=_("Cancel and Abort"))
        if sys.platform in ["win32", "darwin"]:
            self.open_folder.SetToolTip(_("Open Folder in working directory"))
            self.open_shell.SetToolTip(_("Open command shell in working directory"))
        else:
            self.open_folder.SetToolTip(_("Open Folder in working directory\nNote: PF_FILEMANAGER needs to be set."))
            self.open_shell.SetToolTip(_("Open Terminal shell in working directory"))
        self.save_button.SetToolTip(_("Save the file and continue."))
        self.cancel_button.SetToolTip(_("Cancel and Abort."))

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.text_ctrl, proportion=1, flag=wx.EXPAND|wx.ALL, border=10)
        sizer.Add(wx.StaticLine(self), proportion=0, flag=wx.EXPAND|wx.LEFT|wx.RIGHT, border=10)

        button_sizer = wx.BoxSizer(wx.HORIZONTAL)
        button_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        button_sizer.Add(self.open_folder, proportion=0, flag=wx.ALL, border=5)
        button_sizer.Add(self.open_shell, proportion=0, flag=wx.ALL, border=5)
        button_sizer.Add(self.save_button, proportion=0, flag=wx.ALL, border=5)
        button_sizer.Add(self.cancel_button, proportion=0, flag=wx.ALL, border=5)
        button_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        sizer.Add(button_sizer, proportion=0, flag=wx.EXPAND|wx.LEFT|wx.RIGHT|wx.BOTTOM, border=10)

        self.SetSizer(sizer)
        self.SetSize((1600, 900))  # set initial size of the editor window
        self.SetMinSize((400, 300))  # set minimum size of the editor window

        self.open_folder.Bind(wx.EVT_BUTTON, self.on_open_folder)
        self.open_shell.Bind(wx.EVT_BUTTON, self.on_open_shell)
        self.save_button.Bind(wx.EVT_BUTTON, self.on_save)
        self.cancel_button.Bind(wx.EVT_BUTTON, self.on_cancel)
        self.Bind(wx.EVT_CLOSE, self.on_cancel)
        # self.Bind(wx.EVT_SIZE, self._on_resize)

        # fix horizontal scroll bar
        self.text_ctrl.SetWrapMode(wx.stc.STC_WRAP_NONE)
        self.text_ctrl.SetUseHorizontalScrollBar(True)

        # disable vertical scrolling on mouse wheel
        self.text_ctrl.SetUseVerticalScrollBar(True)
        self.text_ctrl.SetScrollWidthTracking(True)
        self.text_ctrl.SetScrollWidth(1)

        # center the dialog
        self.CenterOnParent()

        # set tab width
        self.text_ctrl.SetTabWidth(4)

        # set indentation
        self.text_ctrl.SetIndent(4)

    def load_file(self):
        with open(self.file_path, 'r', encoding='ISO-8859-1', errors="replace") as f:
            contents = f.read()
            self.text_ctrl.SetValue(contents)

    def on_open_folder(self, event):
        open_folder(self.Parent, self.file_path, True)

    def on_open_shell(self, event):
        open_terminal(self.Parent, self.file_path, True)

    def on_save(self, event):
        with open(self.file_path, 'w', encoding='ISO-8859-1', errors="replace", newline='\n') as f:
            f.write(self.text_ctrl.GetValue())
        self.EndModal(wx.ID_OK)

    def on_cancel(self, event):
        self.EndModal(wx.ID_CANCEL)

    def _on_resize(self, event):
        width = self.Rect.Width
        height = self.Rect.Height
        print(f"width: {width}\nheight: {height}")
        event.Skip(True)

```

`i18n.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.
"""
Internationalization support for PixelFlasher.

This module provides functions for translating text in the application.
It uses a simple catalog-based approach that works with f-strings.
"""

import os
import gettext
import locale
import logging
import builtins
import json
import polib  # For compiling PO files to MO files

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

# Global variables
translations = {}
current_language = None
fallback_language = 'en'
string_catalog = {}
locale_dir = None  # Store locale directory globally for access by get_locale_path

# ============================================================================
#                               Function translate_text
# ============================================================================
def translate_text(text, lang=None, **kwargs):
    """
    Translate a string using the specified language (or current language) and apply formatting.

    Args:
        text: The string to translate
        lang: Specific language to use (default: None, which uses current_language)
        **kwargs: Format parameters to apply to the translated string

    Returns:
        Translated and formatted string
    """
    global current_language, translations, string_catalog

    # Use specified language if provided, otherwise use current language
    if lang is not None:
        target_lang = lang
    else:
        target_lang = current_language

    # If 'en' is specified as the target language, or if we need English regardless of
    # the current language setting, return the original text
    if target_lang == 'en':
        translated = text
    # Otherwise translate according to requested language
    elif target_lang in translations:
        # Get the translated text
        translated = translations[target_lang].gettext(text)
        # If the translation is empty, fall back to the original text
        # This handles cases where msgstr is empty in the .po file
        if not translated:
            translated = text
    else:
        translated = text

    # Apply formatting if kwargs are provided
    if kwargs:
        try:
            return translated.format(**kwargs)
        except KeyError as e:
            logging.warning(f"Missing key in translation format: {e}")
            return translated
    return translated

# Alias for cleaner code
_ = translate_text

# Always set up a fallback translation function immediately
builtins.__dict__['_'] = translate_text

# ============================================================================
#                               Function get_locale_path
# ============================================================================
def get_locale_path():
    """Return the path to the locale directory."""
    global locale_dir
    if locale_dir is None:
        locale_dir = find_locale_dir()
    return locale_dir

# ============================================================================
#                               Function get_translation_for_language
# ============================================================================
def get_translation_for_language(lang_code):
    """
    Get a gettext translation object for a specific language.

    Args:
        lang_code: Language code to get translation for

    Returns:
        gettext.NullTranslation: Translation object for the language, or NullTranslation if unavailable
    """
    global translations

    # If we already have this translation loaded, return it
    if lang_code in translations:
        return translations[lang_code]

    # Try to load the translation
    try:
        locale_dir = get_locale_path()
        translation = gettext.translation('pixelflasher', localedir=locale_dir, languages=[lang_code], fallback=True)
        translations[lang_code] = translation
        return translation
    except Exception as e:
        logging.warning(f"Failed to load translation for {lang_code}: {e}")
        return gettext.NullTranslations()

# ============================================================================
#                               Function get_text_in_language
# ============================================================================
def get_text_in_language(text, lang_code):
    """
    Get a translated text in a specific language regardless of the current language setting.

    Args:
        text: The text to translate
        lang_code: The language code to translate to

    Returns:
        str: The translated text, or the original text if translation is unavailable
    """
    if lang_code == 'en':
        return text

    translation = get_translation_for_language(lang_code)
    return translation.gettext(text)

# ============================================================================
#                               Function get_system_language
# ============================================================================
def get_system_language():
    """Get the system language code."""
    try:
        # Get the user's preferred language
        lang, _ = locale.getdefaultlocale()
        if lang:
            # Strip encoding if present and convert to lowercase
            return lang.split('.')[0].split('_')[0]
    except Exception as e:
        logging.warning(f"Could not determine system language: {e}")

    # Default to English if we can't determine the system language
    return fallback_language

# ============================================================================
#                               Function find_locale_dir
# ============================================================================
def find_locale_dir():
    """Find the locale directory, checking multiple possible locations."""
    base_dirs = [
        # Standard location relative to the script
        os.path.dirname(os.path.abspath(__file__)),
        # Relative to the current working directory
        os.getcwd(),
        # Check for a dedicated locale directory in parent folders
        os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'locale'),
    ]

    for base_dir in base_dirs:
        locale_dir = os.path.join(base_dir, 'locale')
        if os.path.exists(locale_dir) and os.path.isdir(locale_dir):
            logging.info(f"Found locale directory at: {locale_dir}")
            return locale_dir

    # If no existing directory is found, create and return the default one
    default_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'locale')
    os.makedirs(default_dir, exist_ok=True)
    logging.info(f"Created default locale directory at: {default_dir}")
    return default_dir

# ============================================================================
#                               Function setup_i18n
# ============================================================================
def setup_i18n():
    """Set up internationalization for the application."""
    global translations, current_language, fallback_language, locale_dir

    try:
        # Find the locale directory
        locale_dir = find_locale_dir()

        # Get available languages by looking at directories in the locale folder
        available_languages = []
        if os.path.exists(locale_dir):
            for lang_dir in os.listdir(locale_dir):
                if os.path.isdir(os.path.join(locale_dir, lang_dir)):
                    # Check if this directory contains LC_MESSAGES with our domain
                    mo_path = os.path.join(locale_dir, lang_dir, 'LC_MESSAGES', 'pixelflasher.mo')
                    po_path = os.path.join(locale_dir, lang_dir, 'LC_MESSAGES', 'pixelflasher.po')
                    if os.path.exists(mo_path) or os.path.exists(po_path):
                        available_languages.append(lang_dir)

        logging.info(f"Available languages: {available_languages}")

        # If no languages are available, try to compile .po files if they exist
        if not available_languages:
            try:
                compile_translations()
                # Recheck available languages
                for lang_dir in os.listdir(locale_dir):
                    if os.path.isdir(os.path.join(locale_dir, lang_dir)):
                        mo_path = os.path.join(locale_dir, lang_dir, 'LC_MESSAGES', 'pixelflasher.mo')
                        po_path = os.path.join(locale_dir, lang_dir, 'LC_MESSAGES', 'pixelflasher.po')
                        if os.path.exists(mo_path) or os.path.exists(po_path):
                            available_languages.append(lang_dir)
            except Exception as e:
                logging.warning(f"Failed to compile translations: {e}")

        # Set up translations for available languages
        for lang in available_languages:
            try:
                # Use fallback=True to prevent FileNotFoundError
                translations[lang] = gettext.translation('pixelflasher', localedir=locale_dir, languages=[lang], fallback=True)
                logging.info(f"Loaded translation for {lang}")
            except Exception as e:
                logging.warning(f"Error loading translation for {lang}: {e}")

        # Always ensure we have a fallback translation
        if not translations or fallback_language not in translations:
            # Create empty translations directory structure if it doesn't exist
            lc_messages_dir = os.path.join(locale_dir, fallback_language, 'LC_MESSAGES')
            os.makedirs(lc_messages_dir, exist_ok=True)

            # If fallback language is not available, set up a NullTranslations
            translations[fallback_language] = gettext.NullTranslations()
            logging.info(f"Using NullTranslations for {fallback_language}")

        # Try to get the system language, but fall back if necessary
        system_lang = get_system_language()

        # if current language is not already set, Set current language to system language if available, otherwise fallback
        if current_language is None or current_language == '' or current_language not in translations:
            if system_lang in translations:
                current_language = system_lang
            else:
                current_language = fallback_language
                logging.info(f"System language {system_lang} not available, using {fallback_language}")

        # Install the translate function
        builtins.__dict__['_'] = translate_text

        logging.info(f"Translation system initialized to language: {current_language}")

    except Exception as e:
        # Last resort if anything goes wrong during setup
        logging.error(f"Translation setup failed: {e}")
        # Ensure we have a working translation function
        builtins.__dict__['_'] = lambda s: s

# ============================================================================
#                               Function compile_translations
# ============================================================================
def compile_translations(specific_po_file=None):
    """
    Compile PO files to MO files using polib.

    Args:
        specific_po_file: If provided, only compile this specific PO file.
            Otherwise, compile all PO files in the locale directory.

    Returns:
        bool: True if at least one file was compiled successfully, False otherwise
    """
    locale_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'locale')

    if not os.path.exists(locale_dir):
        logging.warning(f"Locale directory not found: {locale_dir}")
        return False

    # If a specific PO file was provided, compile only that file
    if specific_po_file:
        try:
            if not os.path.exists(specific_po_file):
                logging.error(f"PO file not found: {specific_po_file}")
                return False

            mo_file = os.path.splitext(specific_po_file)[0] + '.mo'

            # Create the directory if it doesn't exist
            os.makedirs(os.path.dirname(mo_file), exist_ok=True)

            # Load and compile the PO file
            po = polib.pofile(specific_po_file)
            po.save_as_mofile(mo_file)
            logging.info(f"Compiled: {specific_po_file} → {mo_file}")
            return True
        except Exception as e:
            logging.error(f"Failed to compile {specific_po_file}: {e}")
            return False

    # Otherwise, compile all PO files in the locale directory
    success_count = 0
    fail_count = 0

    # Walk through all language directories
    for lang in os.listdir(locale_dir):
        lang_dir = os.path.join(locale_dir, lang)
        if os.path.isdir(lang_dir):
            # Look for LC_MESSAGES directory
            lc_messages_dir = os.path.join(lang_dir, 'LC_MESSAGES')
            if os.path.isdir(lc_messages_dir):
                # Process all .po files in LC_MESSAGES
                for filename in os.listdir(lc_messages_dir):
                    if filename.endswith('.po'):
                        po_path = os.path.join(lc_messages_dir, filename)
                        mo_path = os.path.join(lc_messages_dir, os.path.splitext(filename)[0] + '.mo')

                        try:
                            # Load the PO file and compile to MO using polib
                            po = polib.pofile(po_path)
                            po.save_as_mofile(mo_path)
                            success_count += 1
                            logging.info(f"Compiled: {po_path} → {mo_path}")
                        except Exception as e:
                            fail_count += 1
                            logging.error(f"Failed to compile {po_path}: {str(e)}")

    logging.info(f"Compilation complete. Success: {success_count}, Failed: {fail_count}")
    return success_count > 0

# ============================================================================
#                               Function get_available_languages
# ============================================================================
def get_available_languages():
    """Get a list of available language codes."""
    global translations
    return list(translations.keys())

# ============================================================================
#                               Function get_language
# ============================================================================
def get_language():
    global current_language
    # if current_language is not set, try to load it from PixelFlasher.json file
    if current_language is None:
        from runtime import get_config_file_path, init_config_path
        init_config_path()
        config_file = get_config_file_path()
        try:
            with open(config_file, 'r', encoding='utf-8', errors='replace') as f:
                data = json.load(f)
                current_language = data.get('language')
                logging.info(f"Got language {current_language} from PixelFlasher.json")
                set_language(current_language)
        except Exception as e:
            logging.warning(f"Failed to load language from PixelFlasher.json: {e}, defaulting to English.")
            set_language('en')
    return current_language

# ============================================================================
#                               Function set_language
# ============================================================================
def set_language(lang_code):
    """Set the current language for translations.

    Args:
        lang_code: The language code to use (e.g., 'en', 'fr')

    Returns:
        bool: True if language was set successfully, False otherwise
    """
    global current_language, translations

    # No change needed if already using this language
    if lang_code == current_language:
        return True

    # If language is already loaded, just switch to it
    if lang_code in translations:
        current_language = lang_code
        logging.info(f"Changed language to {lang_code}")
        return True

    # Try to load the requested language
    try:
        locale_dir = find_locale_dir()
        translation = None

        # First try loading the exact language code
        try:
            translation = gettext.translation('pixelflasher', localedir=locale_dir, languages=[lang_code])
        except FileNotFoundError:
            # If the language has a region suffix (e.g., 'pt_BR'), try the base language ('pt')
            if '_' in lang_code:
                base_lang = lang_code.split('_')[0]
                try:
                    translation = gettext.translation('pixelflasher', localedir=locale_dir, languages=[base_lang])
                    logging.info(f"Using base language {base_lang} instead of {lang_code}")
                    lang_code = base_lang  # Update lang_code to what was actually loaded
                except FileNotFoundError:
                    pass

        # If still no translation found, try to compile from .po file
        if translation is None:
            # Check for a .po file we could compile
            po_path = os.path.join(locale_dir, lang_code, 'LC_MESSAGES', 'pixelflasher.po')
            if os.path.exists(po_path):
                try:
                    # Compile the .po file to .mo and try loading again
                    if compile_translations(po_path):
                        translation = gettext.translation('pixelflasher', localedir=locale_dir, languages=[lang_code])
                except Exception as e:
                    logging.error(f"Failed to compile and load translation for {lang_code}: {e}")

        # If translation was loaded successfully, store it
        if translation:
            translations[lang_code] = translation
            current_language = lang_code
            logging.info(f"Changed language to {lang_code}")
            return True

        # If we get here, we couldn't load the translation
        logging.warning(f"Language {lang_code} not available, falling back to {fallback_language}")

        # Ensure we have a fallback translation if none was loaded
        if fallback_language not in translations:
            translations[fallback_language] = gettext.NullTranslations()

        current_language = fallback_language
        return False

    except Exception as e:
        logging.error(f"Error setting language to {lang_code}: {e}")

        # Ensure we have a fallback translation if none was loaded
        if fallback_language not in translations:
            translations[fallback_language] = gettext.NullTranslations()

        current_language = fallback_language
        return False

# ============================================================================
#                               Function initialize_translations
# ============================================================================
def initialize_translations():
    """Initialize translations for the application."""
    logging.info("Initializing translation system")
    setup_i18n()
    # Verify that the '_' function is properly installed
    if '_' not in builtins.__dict__:
        logging.warning("Translation function not properly installed, using dummy")
        builtins.__dict__['_'] = lambda s: s
    logging.info("Translation initialization complete")

```

`images.py`:

```py

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

#----------------------------------------------------------------------
# This file was generated by encode-bitmaps.py
#
from wx.lib.embeddedimage import PyEmbeddedImage

#----------------------------------------------------------------------
SmallUpArrow = PyEmbeddedImage(
    b"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAADxJ"
    b"REFUOI1jZGRiZqAEMFGke2gY8P/f3/9kGwDTjM8QnAaga8JlCG3CAJdt2MQxDCAUaOjyjKMp"
    b"cRAYAABS2CPsss3BWQAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
SmallDnArrow = PyEmbeddedImage(
    b"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAEhJ"
    b"REFUOI1jZGRiZqAEMFGke9QABgYGBgYWdIH///7+J6SJkYmZEacLkCUJacZqAD5DsInTLhDR"
    b"bcPlKrwugGnCFy6Mo3mBAQChDgRlP4RC7wAAAABJRU5ErkJggg==")

        #----------------------------------------------------------------------
about_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'8UlEQVR42r2WQQrCMBBFc5yew4UbwUOI9CDZeBIRcVf0BMW1txDcGBBSazZjJqZSi7Q/oU3g'
    b'wdA289P8zqRC9IzZVmcWaSktykIe5a/xvUyEDp+4aCUcooCF7IO5pQ5I3sBz8qHkMiJxF9m3'
    b'chqJ/N+e1yMK1D+eIIaujhXdtXFwjBjfXv3ghPWpImOMg2PwTTLY2OVB0+b8dHAMG+4Lhiai'
    b'FJ0K7WWx/xAgoERI8tvDOEJEYIFIkwneokgBBZscKVDCn2mkgIQLjau3EQArmb7tAmkV852m'
    b'y/Xl4BhuFUma3eTtOsmBk+TITHLoj/3b8gZa8l+kxFk2KQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
about_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAETUlEQVR4Xu1bTVbbMBCWbB5s'
    b'0wMQkhNAbgC7km6SExROQHyCwAlsTtD0BE0XDd2VnqC5QUI4QL1tm1gdOc4j5EmWZGvkBNCK'
    b'R2RZ8803v5IpeeWDvnL5yRsAbwx45Qg4M4FOOKn9JaTBiN+Al9YYYTWP0iMGfxNKpyRhDwlZ'
    b'TLk+vgfNe1d6QQXgfTgBYb0Opd5HQlgDhKoZCDYEYMZJMv8MgKTAYAzrAKSa9vauCCMdEPrE'
    b'xqaBJfceIeNvvXpgY731NawBsKS434G40ocXcG1jjBiADUZBfWBrcSsAANVPPboX2tK4Wjg6'
    b'Jozd2gCiFABc6/+o3weK9tSbRpkxHPXq3TIrFwYgpTz1P8HLwdarHHS8z+Znw6AZF9lFIQDa'
    b'4eSEUP8Loq2bygK+YXE2Cppj0weNAciE/2EY0kz3VWw+W7RMQTACYEn7PRDeTngrJmXuU/E+'
    b'WzRNzEEbgO2xeRVsdDzqHbZUs1a/awPwIZqFFXp7XXlW87SjgxYA5+EM0lnCnd7ODMZI9y6o'
    b'D1UbVgKAYfc8tYUXb4Qt2rDsW2LIEd6VBuA8fOhRSiHLszgYudzM4lBYJnjPphS5DMgc3y/r'
    b'8d4VAMAyFQtyAWjfPvYh5762qPvlUu4AIFBSX4+uDm9kMuQDED2C9hFivksAFCyQApBlfJz+'
    b'9odbAKDZtGjKmipSAFCcn30otVZkjAV3wVEkmixnQDTjcb/iSk9LPp1JU3CGTW0AMu8/gQdM'
    b'eng6G6lsjswMhAxAtf+KIAAAzkTdZiEAyxaXz0velzMkSZGEAbMLaG7ybg/WGEAu8HN9cag1'
    b'jjGLLZkjFAKAHgEch8EUaElCJGZANOPav8BSv9NM8EkIYYksBAC99q+CAYQMIBRebipVzACs'
    b'GmD19goAAEEj0clSNU6wAgAMnSByB6gSAMQdomoSoW0HIEuFf7+kKGCUCnPB21i9AL64cwbI'
    b'W+XVlMOuAcjpCkkBQDUDxwDICqE0Qcyz83Y04yVxw7ovcApA/knRW1M0T7svoS2uOixVngy1'
    b'Q4TS2JUJKFriSh+wYodtX5AdjU3X2Qf/4/cHTy36mylov6U6KlcygG8I5djKoqSipfI6wc8a'
    b'Mbr7ABbsUpdYWPqKZNViwJMpIJ0U6WpBa57ZpSkjANCigpZgWpNiSHpaJldrjQBIa4TlDTGc'
    b'IzMtGaWTYrgUcalzKaKQD1h/aAtvihUSXjsMijDHuDlSjABwo5zNuya0L82AZ2yoMDrwfOKA'
    b'LbqqWJ8HrLEPEC2WnSNcwW+NYlo0fgooz24OSDIoI3wpE8gBwu59oucvsib4alkrDNgEA4ER'
    b'MZzsRPvJ/Lasxjf3igLA6iX8kBU+mTnJPpkx+nokrRcovSfJ/Kvp/V8Tg0IFYH0jPGr8If5p'
    b'ancePU5/Y8vviGAT04SxB0pozD+cgs9jYkyhrUYBE7S3ca4zBmyj8NajwLYKiZ4H7KLgqGFw'
    b'lwD5DzNbNV8N5FBCAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
add_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'2ElEQVR42mNgwAPSdmdpAHETEB8G4vdA/B+K30PFQHIaDKQCqMGbkAwkhDcRbRFQYRoQ/yDB'
    b'cBgG6UkjZHgTGQaj4yZ8Lv9PJZyGLcx/UNGCHyhxQkyEZu7J/X/j9U0wBrGJiXhk1xPU0HCs'
    b'+f+vX7/AGMQm0icaREds4/FWuAUgNtERDs0wtLLgMANaDkUJc1BQgAwD4RkXZsMtALFh4iA1'
    b'eOLkPQMu20GRCTOQEAapxWUOXSygeRDRPJJpnkxpm9FoXlTQpbCjeXFNlwqHLlUmXSp9ajdb'
    b'AJgG8q1SZjunAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
settings_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABfElEQVRIS7WVjVHCQBCFoQOp'
    b'QOwAOogVqBUYKhAqACpAK1ArECoQK9AOTAlQAbyPuYWbg2Q2E7Izb8L97dt/up2Wpduy/k4Z'
    b'wVjEC2Ej9JoYkRKg+E+YCllQPNL3VvgUirpkMcGjHn9VKFjr7P5aBK9SNA9eGGljAox7F/Jg'
    b'KQqRX2Eg3DUNEYpJ7I3wIRD7TPgORI09aD0HGIoHP8JLsJ69mbAVqC4LWxw6fpvHwdnTp6wP'
    b'KFMUFwKxvyS7aLP0Xp1Opkfoh5XwILCOhcrjDOPehCWHXoK+7lJNFIBHjhPAS2DlGytHyTqQ'
    b'ZhdY8WjiJch1GRITlNPVJB6BwMqZNeeU+dJLwKOY5GBdYjUE5gnkeOfOgYeAkUIvIUPzzusB'
    b'DwmRJTkNEaMED87OvQSxdRYZSA6lGCxPK2ym/bmXoK/L/0nMq5aQ06AbLwHK7E+IMf4s5AkD'
    b'SS8ExgwNRyHUSnJqcTwqKFcSeyZ1PEgfEzJCh5CLp2sTVOXgeLYH3BZQGWtAeDoAAAAASUVO'
    b'RK5CYII=')

#----------------------------------------------------------------------
settings_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAE3klEQVR4Xu2bi3ETMRCGkw6g'
    b'g6MCoAJMBUAHpgKgAkwFhAq4VEBSAaYCoAJMBdAB7Ddz55GVlXbvZMtKnJ3RMLnTY/fXvw/p'
    b'zPnZicv5idt/dg/APQNOHIESF3gg2L2R1kUYfpO/+9uCawkACzHyq2LoX3n28BQAWIqRnxOG'
    b'PpLnm9sAQgkD3oqBHxNGPpfn67sCAIa+H/z6k/wLxdl9nhEHNPkhD+lLLMBVXgxjAIZ3zYjF'
    b'gE40/R4ZigFPnBbEfWEFIDQjFgBQHAbsU17JZFf7nLBkrhwAUFeL8iXrMbapLJED4Iso+9Kw'
    b'FmMupF1Lw10eS1s5EGqGBSUMwL/xZ0AIhfhA3EgJ4wBg4wDq4F2sGIAx5Hot6D2V56mIvhzG'
    b'xQbAlg8KaAc3NLWABQDjOmm/ogkwHABSQnr8M3HMUUCYCwBRHBrn5N9dAWAhhsTZwIrkWhyw'
    b'xjTJAHyZWkCr+HKRPFU/4DqvpTVTDeZcIFfrs1vsKMaERQ1AjaDldjQXQKsyIQeAtwoEAHYU'
    b'43EXT5nczGEpB4AWyfexO54Auo91XHNYWcByA9ciQSfcpqkToQUAulMDdIMRm4HuVok8xgh2'
    b'm5gwCoXQOwdqrEfmGdfVhli1iGOZM9e1OH7N3R8VHACwi/g5MYJ3mvSDofRFYNIzaQTN8VlO'
    b'waW8TN02heOKg6mHASlFuRBZJV6WHna8rle6josBKQBwA06MmpTeCbL7sMAS3Am3mi0lDOhk'
    b'1fiMgCIbaQBQIp6jOPMXZ5QSAFBA2yWCU67SWwwgAZQmpF+O0wBsyVo65K7YrLWKXMBSTnuP'
    b'UeMdI8pfSuuDjigM/T3Gj8Pi8hoACdq4KMGaoJv8TlHKgKkgpHwbP8ZoT3pNrQmQGLuUBgih'
    b'rOQPstgNqQkAu3uIO0bPJgAMKXMTd64JAMYDwrFEDZi1APDm9UODc6NwqgEA/ki6jP3y0MZq'
    b'8+MCOym6BgC5itECgQi/lvZz8N9O/uXqHUbNFcrxfhzcMgAoSaWnnR1gExllTtbYqR5rAADY'
    b'U1mwkjFq2oq23VsxMgwgMX67+zysBQBrLaShsBULoD3VnefU6I0vcbG0xbEmACyKwqRDKrSU'
    b'TD3hWexay0LMqQJaGwCMtlLi1JMkcSB1KmW9naAXo34MAKzL1qk6war4K1RoZ/bIPHWxDHPd'
    b'ryzKcnDx+P+4IO6U+xjbHAMsAAiA+K1XLJdayUTJjFKTAVAV+i8Ny/rBb70AeM4YSRBqAQBN'
    b'U5/ZNUO9LLB2P5xbTa81AMB4dsnK/6GyxABAQOmULOSFp67IzlsDACvq56h+IS8vAyAAsZPG'
    b'jY/lSql5d9yhBgAorF2een187AcbmGsKk+I1YBZ1xjbL1AAAJbzX3FNBmdp/Z/cZXAsAq1iZ'
    b'asic/hsZxIXITo1RCwAUnhKx5xhojVHPGDUBQMHwQ2uoMLtS4tvMlZvjSt6rv2mqDUB8cFmL'
    b'YvzIspfWSZsb3TGQmh+aw7TwP3JkU2ptANgpSmEEw7U8b53uQuZgMDurzbOQ5/xK/bc00qkq'
    b'xwAgpUv4nMMNBZQlvXTgsDNbWgXAmzbZWc8PLpIAtQqAt3rMHnU9tGgVAG8cmHp9dgOTVgHA'
    b'/3OXHBhCdFe/93l2fuzTKgDoBwtytQGRP3dadOHQMgAuA0o7nTwA/wEope1BJY2q2QAAAABJ'
    b'RU5ErkJggg==')

#----------------------------------------------------------------------
backup_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAgElEQVRIS2NkoDFgRDZfZFHX'
    b'eqBAAIV2HngdV+YIMwPFAtFFXf8pNBysHWgB3FysFsAUwCwE8UmxfOAtoDSYcPtgcdd5hv8M'
    b'BpRYAIzEDW/iygKxRjIlBuPSixLJNLdgNB/Agng0H+BNbKP5gJi8OFofEA4lghmNsBH4VQyv'
    b'+gAAqPOEGZDRrC8AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
backup_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAACmElEQVR4Xu1bUU4CMRBtWfzH'
    b'BP32BuAN8ATqASTuDeRDjV/6Z8QPuAEEDqCeQDiB3kA+jZi4nya61KmyieCuXdOO2Umnn7Sd'
    b'zLzOzs57S6XwfEjP4xe5AKj0OpWyeK2XyqUKBcBm77PoOTwZ5fHVCMBar10XgbgCYxt5DBZo'
    b'TaTieNcEhBmAQfsWgmoUKLC/uBJNm0erv23IA8ALGCCR+mmBAgC/xpgHAPUXyIu2lgFAyoAQ'
    b'kO1/P+314cWOUlIXy4WRnEDWPHbGYGUAA8AZwI+A3zVAt5mTpQKmO8W0hikpllnzqHUQqwii'
    b'Ou3SOAPgoA94IEiEkiSy5wLV4eWpVOrMZVr+ny3ZnTYPW1ZkSG+uDi4OpJA1IAWESJEaPzeP'
    b'uyawjWTIZID6PANA/QRt/ecMsEWQ+n5jBmhFeCV4PxVC7UOwhN4Cov8Wr7SisBVZvQbXBu0e'
    b'GNDBUxx9aIVDWwD87gQhA1gUpZj7ic9YbFBz/PEiMLIGhfIgBaz5M5g5j4ovFgAsirIoyqKo'
    b'36JoX0p18716zUSpliacwLpdvS5rHrUCgnGsIojttzP7DIADUdT7/wdQJkMjeAS2rMjQFx1+'
    b'6xBjhJoC3wdxHD6GJxMrAJxVo4IaMgoiBfXbmVsMgDMoiRriDMhzcNXeeUMG5W3g+5RE0fEy'
    b'Y02L1ZgB8++C+jVIcfzQLZaDMAIAmiCLohSPHlsTJIMJFhscgVa+8MVFSvg7vRL1ZWRg3bX+'
    b'LWseG0ksAFgUZVGURVG/RVHvawB28XZmH+st4MxBbEMMgLUqPGzfpTU42CfnxL4U99O9o00r'
    b'TfCLCgf67iC1EcFXqfBp7/izE80aRjaYbJxfeiKhB8CN0UkZ7jOYFOHPFp3asbr213sAPgD0'
    b'bMlQmpVT3QAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
blank = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAANSURBVBhXY2BgYGAAAAAFAAGKM+MA'
    b'AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
boot_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwY'
    b'AAAE7mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlk'
    b'PSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9i'
    b'ZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRk'
    b'ZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJo'
    b'dHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNj'
    b'cmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hh'
    b'cC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHht'
    b'bG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1s'
    b'bnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0'
    b'PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHht'
    b'cDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIiB4bXA6Q3Jl'
    b'YXRlRGF0ZT0iMjAyMi0xMi0wNFQxMzoyMDo1MiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIw'
    b'MjItMTItMDRUMTM6MzU6NTUrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjItMTItMDRU'
    b'MTM6MzU6NTUrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JN'
    b'b2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmI3YTgzYzhjLTYwMGUtYTQ0ZC05'
    b'ZTk2LTQwMWVkYTMxMTczNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpiN2E4M2M4Yy02'
    b'MDBlLWE0NGQtOWU5Ni00MDFlZGEzMTE3MzUiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0i'
    b'eG1wLmRpZDpiN2E4M2M4Yy02MDBlLWE0NGQtOWU5Ni00MDFlZGEzMTE3MzUiPiA8eG1wTU06'
    b'SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2'
    b'dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmI3YTgzYzhjLTYwMGUtYTQ0ZC05ZTk2LTQwMWVkYTMx'
    b'MTczNSIgc3RFdnQ6d2hlbj0iMjAyMi0xMi0wNFQxMzoyMDo1MiswMTowMCIgc3RFdnQ6c29m'
    b'dHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIi8+IDwvcmRmOlNl'
    b'cT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6'
    b'eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjJGo4UAAAFPSURBVEiJtZQxS8NAFMd/1yba'
    b'HnSwIAjOTg4ODi5+A/cOjrr6EUyX+wwOgrpIQXHQuQg6OAriJLgIgiCIm4Tq2TyHJjQtwSYh'
    b'94dHeHd/7se9ey9KRHApL52EgVKAyjJqI1EZgBIRwkCtApfAyj/eD2BbG7kuAqjF396MwwEW'
    b'gfMwUM0ygLWc/nYB7wSgiBpFzN4sg9/9mV5aB24rAwwvOuOk0SZ6OOn5Jn9rzwRET1fjpOZR'
    b'3zrYB/YqA2SU6CXv4bkAEyWaaxE9nioLvjZi8wCSQSv6vzgDdrWR0BUA4I3RgN4Ad9rIV9WA'
    b'tIbAPdAHjrSR12SjzKBlqQ5sAAHwHAZqp2pAWvPAcRioDlRXoiy9A8subpBoCVhwCQDQrgF1'
    b'JSJYa6t/g98BfrOlkhscAp/AAPhOhWXU4xEgqYjidTvlT6KP19iEuItcyvUb8Ac4l3coveQP'
    b'6wAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
bottom_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAv0lEQVRIS+2SwQ2DMAxFyQYd'
    b'iY7CBmWSsgHdpCuxAdgllqzIrr8PkTiQSwSx37OdlKHzKp35Q1bwqgUtaGEZAcPfFTzTDklQ'
    b'gYZL8ZAEEVhwWBIJNHwi6lrJT9q/yLj+CVr4h4B7hXLeiEg8gQVnthbwdyixBB7cEoQSSyBV'
    b'8cx5LHq1HciZm+ON6EGZWwP3OpAwMyd6Ra3D68Co5fx1C9zRyME9omuNSN54WBUY8Ltffcnd'
    b'BWBhubDsM83RKfoAyGMsGSISC9UAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
bug_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'lUlEQVR42rWVsUvDQBTGDzoUOgnt0P4RXQudWrvaCk4u7v0frE6CgiB1chOkOAidFKXqIN3q'
    b'oIu4FEXoUihpgkZaSDuc74UXOdK7NJeSgx8cL9/7vuReSBiTrHF5Nwt8ASNgnSkWXiMNarMs'
    b'7AJxFeDEFKhINBW65umqOgFJ4MkX0gHeiXufOWqTTGdBwxowFkxUGKjVNU/5nmAZqE3pBLQ1'
    b'zD3aQYZ1uosu0Itg7tEjD/SqiwHOCqYqHDGgFUNAS3ZUBZn4Z/+SO5bNZ7OZC+6xpjAuBM2i'
    b'LGuaPLz+m3tgTRGwITNOAzVgT9Zk7ZzwSeeFT7tvLrjHmiLgiLzSYkA/hhn0xQAjhgBDDMjT'
    b'8VzIxGbtgNtnd/z3/NEF91hTGF+RVz78kG+eF4cMNUXAZtBbVJQ12afXCwFYUwQUZcYN4AMY'
    b'qs7U3Drk1vaxC+4Dzn5IXg0xYB7DkOdiQBMwgW/AXsHUJg/0aqrmkIj4RcWeRNj/QQ741DBH'
    b'bU73r5YBbkOYoybDoi5oLtHnfCCYDqhWWtb/B12EOtM0M+fCAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
custom_patch_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABuElEQVRIS82UT07CUBCHZygm'
    b'umNpUkx6BLwB3EBWgm7gBkXrWl1blRvARmGnN5AbwA3UAPvuNEH7nCltfW364FU0sRv+pPm+'
    b'eTO/eQh//OBv8Hu2VWp3X7ws1saCgVOuEuRBANSb7myUlmwsGDp7twDCZjBJamnJjwTDU7MH'
    b'WPAa7rTD4KFTfqKPapYkt2AJx9ayFdj1wX8tAJ7Tj1LUHvkkuQQSnAcaAwMVwIUQwiL5gS+w'
    b'fXQ9fQz/18uRDGcAovAIyq3hZ9JwZ/v85e7MrBxfzScRVesEaXhUXZigUILdaCZyyWsFWfCB'
    b'vWu9w7bH2b93TJtmQEmiFPmi3byZ97UFKjgaRlC1QGoV7UAwDyH6b59bnfTCKU+gagtv7U7x'
    b'gwWVuFIFXDlkVeVQLFq8SIner4BnCuScU1rqPNCgamMxpghaPohOnPs18ExBMhkwovjV+EX5'
    b'SghaowFXtihLwvk2BI7zwJWCMHry+o/CoSrTIkdzZUwTcGrD972j3xalQIbz3XLozi7jdmn2'
    b'PH2SxB5Qgp45KRE8elneXFUrtFrEAkTsc+V5QVqCwYnZSt8lm4rWXnb/XvAFy7IRKHw15OYA'
    b'AAAASUVORK5CYII=')

#----------------------------------------------------------------------
delete_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'u0lEQVR42mNgwAO+OJtpAHETEB8G4vdA/B+K30PFQHIaDKQCqMGbkAwkhDcRbRFQYRoQ/yDB'
    b'cBgG6UkjZHgTGQaj4yZ8Lv9PJZyGLcx/UNGCHyhxQmKEEh3xyK7/TyOsQa2IxR3h0AxDKwsO'
    b'M6DlUAR2t/7/NTni/9fUKPwYqAakFocF7xlw2f7zwtn/v379IgqD1OIyhy4W0DyIaB7JNE+m'
    b'tM1oNC8q6FLY0by4pkuFQ5cqky6VPrWbLQBg3J+x6adKhwAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
exit_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAD/SURBVEhL7ZU9CgIxEIWjaGOjhaWo'
    b'txFB2209xZ4ihRfyFy0Ej2FhJdhoq9/EJNX+BEkKwQePNxtm5pnZkVV5ng/gSin1qiN5J9gm'
    b'DgcFa6SwYRHJH6LBaEApFKMbcpS4Anut9dLGwXC/bPd5jIum1WT4G3jwDpswgx175BHlJVM/'
    b'QlwvbxJzRLLyBqzyA5OuxC1zUgES+8gE1v2DJc8Dkzu1PYkrR8T5GTE53zD5FtWOCEy5RdCI'
    b'GIu2sdz8gMwlNlcpG1EoqB8jrtcGmk2KOSJpLkZbZMZlnvIc0+BC8wz1zR2ijKgMybfo9w3S'
    b'fzJpnPSjLyNaWJNQXK0GQKk3rYGQwm35SYcAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
feature_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'6ElEQVR42r2UsQ2DMBBFLfbIClCglJS0CDFHivRMwCBUDAEbELosgCdIUhGRbwkkCjjO9imW'
    b'XoPt/+yzOKWI8X1eA5CDGmgwL+jlm5kLlMvAxhgMm9AjzJrYNjwDH0b4ilmb2ZzcJnwriRWj'
    b'5oND+LZcASXIPcJXckpQCwhqSqAFBJoSzBJQgklAMFGCUUAwUoJGQNBQgkJAUJz9aL1HeH/a'
    b'/LAgBG+HcLMn5Paj1KHZpbYd1dykBY8TWvbJ/z5wsopRnspH0DEEnY/gAm7gfoCZu0iUKtoJ'
    b'jyTfItkpTSL94CV4LZTcfT/L6qPsUxQ23QAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
flash_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hk'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAf9JREFUSIm1lsFLVUEU'
    b'xn/zqmfRjVoUaJAQLdq4CKuFJAiCugh5pkarUGnXyoW4FN7T/6D/QYJyoRIuVBCMh8h9tmiZ'
    b'vZ3FU0gXusm6p4V3vPOuM3PfondguHPnnPnOx7kz37lKRGim5ZqKDlz2OZVSeWAUKACdQFvs'
    b'+glUgCXgo4j8doKIiHUAL4AqIBnjO1Bw4liAFTALRDbAgS4qlvUIKAGqkQSzPsb7a4Qef9Gb'
    b'IC6LlTkgr/rYlpBTT4IoXS4TPA/s+tgfbfBVQv5kfJMq0KJxzWM6CjxwHYbxQbZuBnS4/Ibd'
    b'B4b1i5lgyLVDKeTdNDcaANdW0BPzHnS6ot++pBxc45kmVVtlR/u6xrlT3eNeasvjc3JaKpRS'
    b'x8D1NHgux9+TTXavtvAw7av9Imzt54mF04mIBFBfIqsoTb2mbAMHeFNyKkGkJ2ZADQjSkUM9'
    b'RPuHZyW5FXA7f4V2gIMjKp8+J6VIWS2hnRzT92TIwvwc6xIiEiLPu/niiZ23HdMlB5uETPyM'
    b'2T/yhC7riZngA2cXLdPGZrjkcVeBhQsJROQUmMLxsbUdHBKulJ3sBZg05buu4YjIIjDnSzBR'
    b'9PaQkogs16045LqERfR6nzqVNAKKNCLXRqICGeIXj2/AoAvn/CbbLG6ZIyQt827s+gHsAIvA'
    b'gq9lehP8D2v6X8U/tYmf5Lh+9lQAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
flash_32 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'I0lEQVR42mNgoBL4f0qDFYhZGAYCAC02AeK/QPx2ICxnAuKTQPwfiB8PhANSoZaD8F56Wy4I'
    b'xK+QHDCN3g6YimQ5CBfS03JDaMJDdoA3vSxnBOLjaJaDsDK9HJCAxfLfdCkHgJbwA/FLLA64'
    b'QS/fT8JiOQhvpIfl+kD8B4cDeumR8A7jsByE1wJxARacC8Qc1HBANB7LCWEpSi3nA+LnZFp+'
    b'H1RfUOqAPgp870ep5Tp4Eh4hvJUacb+fTMt/UFwyQuOe3KBvolYzKwdH9ppPIOFx0rpcKKRZ'
    b'wiPSAdNplvCIdMBemiQ8EhzwmCYJj0jLuQck4aHVivRPeEgOCB2QhIfkgNoBSXhIDlhE94SH'
    b'5oATdE94aA64QveEh+YAZiBmo4ZZALf4w4DAVHiZAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
folder_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'aklEQVR42mNgGAWDAvy9YeoCxA+A+D8O/BaIcyix4B4ew5FxBbkW/CcBXwbiCwTwbiB2ItcC'
    b'YvEXIGakpQUgzDJqwagFoxYMJwv+0MgCZpgFm2hg+EPk0pQViHWB2A6I7amATYCYe3hUxwAr'
    b'dnC7mS/L8gAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
forum_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'BUlEQVR42mNggIKn9qkzgPgqNvwMiJ/Yp0jC1Oqtf2+ou/r1Vd3Vr3Dg16UM6ABowDYg/o8H'
    b'y8EtWPfOWnfVy/94cA9BC57ap/xDxqgWvLcGuvQf0CBkTLwFQAMXPXdIM0bGTxxS2RBB9IFT'
    b'b80bY73Vr+EYGCzbSbGgm4FEALRk2agFoxaMWjCYLADifUBcAMNPQbRdCi9SYScFLIsKdFe/'
    b'RMKvzpJU2NG8NKW6BcBKJRSIK2AYWNGcwWnB+g9yumvedAFLUOx4zWsfgpEGLKJ1gGH/E5sF'
    b'VAPPHFJ7aGrBC4c0bqAvntDMAkhQpYY8pakF9imMwEjfTTMLoBGuCbRAghy9AFpyQv2MtXWY'
    b'AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
github_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAC'
    b'KklEQVR42qWWQUsbQRiGE4QgevBHCFIFQeihIigIQuuvUOpJrAVBf0C9eVRbiuRkL9rG6lHx'
    b'qGA0iho0SCGgYiLNIcZS0WR3dj+/d7PbbsYdN7suPCT5Zt733ZmdnUkk4nNttVEXM8HEmTWb'
    b'uF3rioS5WNjADDEZhnzI2H0b6jVvZZJ1GMtA0+pn3sPchDB3gLZHZd7J3L7A3AEenbJ5E/PL'
    b'6ZQZN+j3uqDTDwZtv1KboS3z0aDCJvcdM9xt8GpyB0y7hdc/BWmaZlFK65RPCCod63SXq4Lv'
    b'Vo3bnH74Ld3AJ8e8hflTE7D2P6BeoJEC4NmCgBF56FffggdA4zGNIwhIuIv7gyZVylrgAGj2'
    b'35lyQAIBWXfx/HPwu3eAVgrIIuC+Zv5XwwdAKwXcI0C4i/nv4QOglQIEAoruYnbGCB0ArRRQ'
    b'RECq5iG/NUmrhAioeD7kFAJm5eWVWwo+Tbllz2U6i4C+f69+u/3ZQXSxIKh8529c/qvRxVdh'
    b'aTwC+hAQZQ6tJTonqJjSabe3OtRkN9HZVHWvkY1RO5s0KPlGuVfBM+psFwOMiYbLOIck9Zo7'
    b'Ku7qTwJQe2ZHhdeAvKPOo3HnNdFDiTe5I90aUf6H8HyzMX3PBMx7nQcxZgMd0sMm3Z7olgnC'
    b'VPOvMIdHTHXoNDLLski1N3mYQ9vod2ziob9nCo5QtZpcxgVbEw3yz6KZGd3rN9d5BAdsuMJ8'
    b'YWaYBWaRV9kq+qCvyucRr7Y6G5Wvn08AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
guide_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'UklEQVR42mNgoAdQO3aLDYhXAvFfIP5PBfwFiKuRLfChksHomAdmQRaNLBCDWZBLjAaPc/f/'
    b'R1569N/+zD3qWhBy8eH/6x+//v/16xccH3v76b/T2XuUW+AOdPWHHz/Ahr789v3/qXef/7//'
    b'DuHf//ztv/6J25RZkHntCdiwva8//tc5DjHM4tTd/4+/fAOLl958RnkQeZ9/8F/rOKpL1zx/'
    b'B7ZgysPX1ItkGAZZdvXjF7AF1befU9cCDSBe9/w92PBbn77+16M0DtDxOmjQgOLAmRqpCBkX'
    b'AyMUZDgoVYHiheoZDRY085+8oU1Ojrr86P/GF+//uwLzBk0soHlZFH/l8f/Zj9/QxgdGJ+/8'
    b'//LzJzgOTgOLC6pboAtM76CyCGTBjlcfaBNEoGI6/8ZTQgUcVgtyaB3JITSygB9mAQ8Qn6Gy'
    b'4XOwtS4YgZiJCpgRZiYAT0uhuVnE6AwAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
Icon_256 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAABmJLR0QAAAAAAAD5Q7t/AAAR'
    b'VUlEQVR42u2dy28kVxnFe8PeWxZI/hO8ADasAmuIBRsIm1lEidgQ89gAimSkCPHUSDySDBJ0'
    b'gAwQEJiAYAgCHPEIIY8xIMJkksn0zNie8fjVfrXd7h67uKdUPerp2P2orset+n5XOjuPp/vW'
    b'd35173dulSsVBoPBYDAYDAaDwfB3NBqNSadpp1mnqtO8U80pQChD1aLaq0a1qJqcxKHJG37K'
    b'acZpzqmuyd/f3w+azWbQarWCdrsdHB0dhTo+Pg4YjDSHaqxTb6o91aBqUTUZgaEe1apqdgoH'
    b'xzf92c6d/eDgIJxoTM4oAhxUq6rZrpXCWWAw2PQTETVD04uqIiyGZxQZCKph1XIXDFTjEzj+'
    b'3j19tXOnx/SMMsOga2VQNd0z6Da+CKmlE4NhYajWu1YFtkCwt7c36VR1CieBuz3D8qpAHpAX'
    b'Ik9Mlt38s051LYPu3LlDBTAYbsgL8oS84TRTRuNPOS1oyaN9EIPBePuQN+QReUWeKYv5Z7TE'
    b'EeFY7jMYg7cF0WogKPRqwH34CScdiGC5z2DE2BZEq4E5eamIS/6aTkdx12cw4q8G5CF5qTBb'
    b'AvdBp9XMUHeTwWCMP6KkQA3Cad/Nf0Z7Fx2FFL0QQslInor6AmcwP0JAAPMjBAQwP0JAIMeG'
    b'H+ZHKD8I5NMY3N3dnXKqHx4eckEQykHynjwoL2Zt/gmnWud0H0IoH8mD8qI8mSUA9C40LgBC'
    b'HkhedJ6cy8r84dn+zuu5EEL5Sl6UJ+XNLPb9d9/agxDyQ/KkvJlqP8D98oXO+X6EkF+SN+XR'
    b'tMw/y9IfIYNbAfcLJxU3kPcj5P/5gCganEwSAFWW/ggVaitQTfLuT+MPoeI1BCcTuftz4Aeh'
    b'Qh4QqiZy96fxh1DxGoJjrwJ2dnbY+yNU4F6APBzX/BNO7P0RKnAvQB6Wl+MAIDzyy0QiVFzJ'
    b'w/JyHADUyP0RKv65AHl5VPNPaelA8w+h4jcDo23A1CgAOEvzD6FSNQPPsvxHiG0Ay3+E2AYM'
    b'6P7rHyGEyqGh0wD3Q3P6U0RMGkLlkTwtbw8DgPCxXyYNofIo6gPUB5l/UnsF/WliJg2h8kie'
    b'jvoApz8bsL29Pd15+AchVC7J2/J4PwDM6hXDTBZC5ZO8LY/3A0D47D+ThVD5JG/L4/0AME8C'
    b'gFA5pT8lJo/3A0CNBACh8iYB8ng/AAQA4BQ1rgZHG/O5qnX170Fz4eVUxbUudxIgj/cFABHg'
    b'KZP31heD9h/fkat2Z98VrH7gPZlp86GPB/VPPxxsf2U22HvqXLB/4dchJO64OqEmiqmBAGCS'
    b'AMAwWn/gQyEcBIaDv84DBQAAACwB4LQVw863vxECgZoBAADAGAC6tXb/+4OtRz8bbhuoHwAA'
    b'AIwBoBcG6iMcvvE6teTBU4EAAADkJvUN2CJ4CoCtrS0mCQBk1kQEBPk8DwAAAIBXKwK2BgAA'
    b'ABgFQEdKD4gSAQAAMAqATozIagAAAACjAOiI6BAAAADDAJAUG1J3AAAAGAUAEAAAAMA4AIAA'
    b'APAHAFcAABAwAAA9DoxOEADIFwJfnqUGExAAAACF1d7Pz1OHAAAAWFbz4kvUYloAqNfrTBIA'
    b'8PzJwvuCNjeq2NIfBwEAAKDQ2nr0M9QjAAAAlrX/lz9TkwAAALAVoDYBAAAwqd2nzlGXAAAA'
    b'WFZreZHaBAAAgANCCAAAAJOiFwAATACg8cR7g/qnHk5EeicfvQAAAAAKBAB9hqS/l+6eOl2n'
    b'Y7ZaTm889EAhXzBKjQIAAJCQ1FgTEIoEA84FAAAAkBIMtDKgGWgAAJubm0wSADgVBOod+Hww'
    b'iDoFAAAgZWlrwDYAAAAAowCQ1DTUHde/vy3wdeoUAACALHR4+ZJ3EFDTkloFAAAgI2nJzaEg'
    b'AAAAjAIgLCi37OaNQQAAABgFgO64Pp0q5FQgAAAAGatx4VnOAwAAAGAVAJIvqwCdVaBeAUDy'
    b'S90rs7kDQJ/B1/nx6XwA9Xq6tre3+wOg3W6jk+QJAHydn8OlG/4kAdTrqQIAACA1+fLwUPPy'
    b'/6jXOADY2NhgkgBA/OLyJBI8ePUl6hUAAICs1fjdswAAAAAAqwCQ8fx4KOhP1CsAAABZq7VV'
    b'9+MwUPVJ6hUAAIA8BAAAAAAAAAAAAAAAAAAAAAAAMAWAxx/8Tu56ce5F6hUAAIA8dN9je7nr'
    b'+883qVcAAACsAuC3FwEAAAAAZgHw6luH1GscAKyvrzNJACC2ZDwA4Le2trYAAABIR1p6+wCA'
    b'15db1CsAAABZ65u/P/ACANQrAAAAOejB7zZyN/8HvwYAAAAAyFxL6y0v7v4zP9ynVgFA8rpx'
    b'+avBPy+8M1fpM/g6Pz/7hx/7f21DqFcAkLie/M9Pgnf/9CO5Sp/B1/n56LcanAEAAADAIgB8'
    b'6f6TAAAAAJCx6nv+3P1JAAAAADAa/dEABAAAwPDSX1IjkloFAKnoiX/nDwB9Bl/m4xVPjv3e'
    b's/9f4gjwWABYW1sLWq0WOkG+AMCHufDtzi+pDzHS92jWg6OV8yfqzvofSlvH9XodAACA+PJp'
    b'z9+b/4/yPY6WvxsEr91/oo6uPwYAEADolpb8PnX7e3XJLf+H/S7txvKp5g8B4FYBAAABgMj4'
    b'j7juuq/Gj7P81x2+HwDYAiDzANA+33fj330F2Pzwy//29kJf80v6GQCATAFgc7cVPP9aM/jS'
    b'r/bDJ+qKYPyOFteGX/4fX3lkIADUIAQAqLQAkGG0tH/mhYPQ8D48xhtX+vzDfm8t7QeZPwRA'
    b'iesYABQYAB8+/3S4LI+ropq8nwSyYWO/4NIDA81/fPXzAAD5CYD3Pf50KU0cV4La0I0/19kf'
    b'5u5f5ggQAAAAk3f/QbGflQgQAAAAm3f/AbGflQgQAACA0mjYzv8wsZ+VCHAgAFZXVzE7AChV'
    b'7j9M7GclAgzj3s1NAAAAiitFlknHflYiQAAAAAqvoc/8Dxn7WYoAAQAAKLR0PDnp2M9SBAgA'
    b'AICJE39h7Dfi3d9CBAgAAEAh9YVn9ke6VkeLZ0c2v4UIEAAAgEI2/fSgUpJP+1mNAAEAACi1'
    b'+cPYzzXy4gKg7BEgAAAAhVr2j2r+OLGfpQgQAACA0jX8umO/4zcejG1+CxEgAAAApYr6xo39'
    b'rEWAAAAAeP1ev1Fe7JlE7GctAhwIgNu3b2P2UwHwYwCQ1iu9L7j9/s5h7GsTN/azFgFKGxsb'
    b'/QFweHiIThAASOeu//KV5ljXpb21MLb5wwjQ/R4LdQwAAEDu0ktHv+ee6NNdf9zrMk7s163D'
    b'g00AAAAAQBYd/hurzUSuSXv9uUTMHwLASB0DAACQyx0/SeOHcnfscWK/3ggQAAAAAJDCHl+v'
    b'Hk9iqd+rO7eeTuzuf3TtMQAAAABAUqZXV//SYjO96+Hu/uPGfvckAA4mAAAAAIC4L+j8QSNs'
    b'6qVq+i4lEfvdkwC4XgIAAAAAYMg7vM7py/DjRnhx1Nq5nKj5LUWAAAAADP0Unu7qatzJ6M//'
    b'Nx+zpxn7WYwAAUDBAfCJ35wPDTmO1JSTmXuVRqMuabU3/5a4+S1FgACg4ADQZ7B8DZKK/axG'
    b'gAMBsLKygtkBgJdKMvazGgFK6+vrAAAAFEwJx35WI0AAAAAKqaRjP6sRIAAAAIVTGrGf1QgQ'
    b'AACA4jX+Uoj9rEaAAAAAFEppxX5WI0AAAADMx36WI0AAAADMx36WI0AAAADMx36WI0AAAACK'
    b'cfdfPpe6+S1GgAAAAPgf+zWWMjF/uAVw5wu0CshK+m4AAAAAgBxjv7x0fOUR/1cAt27dwuwA'
    b'IL/YL6FXfPsoXw4cAYCYevxf+QNAn4HYr3jyKW1YW1vrD4Bms4lOkC8AKOv8tm//srR3/8O9'
    b'RW/mGQAAAP+0v5FJ7JeH1Pzzaa4BAADwTneWzpXz7u+gJrgBAAAAAE6RlselbfytPefdfAMA'
    b'AOCVjq5+rrSxn4/zDQAAgDdq1S+W9u6v7wYAAAAA6KPjy+WN/XydcwAAAIj9DMV+AAAAEPsZ'
    b'jv0AAAAg9jMc+40EgJs3b2J2AEDsV6LYDwAAAGI/w7EfAAAAxH6GYz8AAAD8if3cXbKUsZ9b'
    b'1RTlGgAAAJBP7Of2x8R+AAAAWARAmWM/l2gU6VoAAACQfeyXwSu+if0AAAAg9ss29nOnGYt2'
    b'PQAAAMg29nPn4ksZ+7nnGIpYxwAAABD7GYr9AAAAIPYzHPsBAABA7Gc49uvV6urq6QBYXl7G'
    b'7AAgERH7AQAAQBOwXL2GAsZ+ACAxAJz3AADnuRYnbTdWsnm5iP6fos/VQAAcHBygE+QLALgW'
    b'b1f75o8yif3KMFcAAACUTlk8YnxYfxUAAAAA4KOO33wk9divLHMFAABA6ZT23b+5ewMAAAAA'
    b'4KNkzrRjvzLNFwAAAKWS9uapxn6NDQCAAIC3CUCKEaB+d9nmCwAAACJAQ7EfAAAARICGY79e'
    b'3b59+3QALC0tUVQAwHwEWKbYDwAAACJAw7Ffr7TKBwAAgAjQSOzXK3kcAAAAIkAjsd/IANjf'
    b'36e4AIDJCLCMsd/IANjZ2aG4TlBtYzF4YfFirtJn4FqkEwGWNfbrVqPRGAiAGgBAFiPAssZ+'
    b'3ZK35fF+AJiv1+sUFzIVAZY59uvW9va2ADDfDwDVzc1NiguZigDLHPt1S96Wx/sBYFZHBSku'
    b'ZCUCLHvs13sMWB7vB4BpvRqcAkMmIkADsV+3VlZWBIDpfgCYJApEViJAC7FfR/K0vC2PV/qN'
    b'xcXFOkkAKnsEaCH2600A5O3KoOF+aG5jY4MiQ6WOAC3Eft2Sp+XtYQAwc+vWLYoMlTYCtBL7'
    b'dUuelreHAcCUU3hqSPsGhHzUOHf/g53rpuZKXpan5e3KMMP9YE0Hgig05KNk4NiNv8Unzc2X'
    b'vCxPV4Yd7ofP6sUBFBvyUc3NV+I1/i59LDjYWzc3X/KyPD0KANgGIG/VWvlFLADo31mbq5GX'
    b'/2wDkO+KEwEq9rM4Vzr+O9LyvzcNoOCQbzp6a/QIUNsGi3OlV4AN1f0/AQATWjroCSKKDnkF'
    b'gDc/OVrs54BhcZ7k3Wj5P1GJM9w/rNIMREWPAK3Ffj3Nv2ol7nD/ePLGjRvB3t4ehYcKGQFa'
    b'jP0keVbelYcr4wz3S6p6jJDiQ0WLAK3GfpI8K+9Wxh3ul4SrAHoBqGgRoMXYr7P3l2fl3UoS'
    b'QyQhEUBFigCtxn6SvJrI3b9nFVDnXAAqSgRoNfaTR+XVxO7+XRCY5XQgKkIEaDX265z6c16d'
    b'qaQx3C9e0GuFKETkcwRoNfaTN+XRSlrD/fIpNRe2trYoRuRlBGg19pMno8bfVCXNoeWFlhmc'
    b'DUC+RYBWYz95MdWl/wkQmNPbgylK5FMEaDX2kxflyUpWw/1nE041DgghXyJAq7FfdOCnJk9W'
    b'shxRP6Culw1SnCgTALj9vTr8J8li7CfvRZHfVCWPcf369Wmn8JljChShbJ/zl/fkwUqew32A'
    b'M0AAoVzMf6biwwACCBk1PxBAyLj5eyFAYxCh5Bt+Xpu/pzFY19tIdDYZITSe5CV5KveG3wgQ'
    b'mHKq6YWEu7u7XESEYkjekYfkJXmqUqThPvCE05zOJ+sRRS4oQsMreqxX5p+TlypFHe7Dz2jv'
    b'opcU6MwyFxeh0yWPyCvRfn+mUoYRbQkWRDR1MrnQCL1d8kZ0118o3JJ/hNVAXQ8v6PFFLjpC'
    b'jdAL8kTU6JuplHm4LzjpVNUSR91NmoTIcpMv6vAHkScmK1aGvuy1a9eqTuGehxUBsnTHV82r'
    b'9uUBU8bvHW4C7oJgaWkpPPBAsxCVsbm3vr4e1njH+Kr9CuMuCCacZpxqnVUBMEBFN71quOtu'
    b'X4tqfALH94fBlNPZDgxEzbW1tXDpBBCQz4ZXjapWu+70taiWp3B2fBiImnNOdU2q3n+mE1Ka'
    b'aC2rNOnAAWVpckm1pxqM/gR3x/D1qFZnMH16PYNpp9loHzXfWSkglKFqUe1Vo1qcZk/PYDAY'
    b'DAaDwWAwPB//BwDowsk0AV40AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
Icon_dark_256 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAACvYSURBVHhe7Z0JfJxVuf9/7zJ79qZb'
    b'0jZtoRW4rN0R4SKieLVC2RUBxatcERRcwYsL/u/fq8jnivqXexX5o4KAAoogIqCIbBVamqal'
    b'srWlTdM2SdskTZpllne5z/POOyFNk3QmmeWdzPOF05k57ySTmTm/33nOed5zXgiCIAiCUIIo'
    b'7m1Rs3TZMr9t2z7bho/ekGJTnaIoTknCNYKQKcn2Q23LKfyIWpJN7SquKoqxZs1LcecJRUxR'
    b'GQAJPWBZ1gz6Lo6hh0dSmUdfzBy6raPbKrqdRkWlQl9Y8osThImS7EzcB4BFpZ3qOt3bHXTL'
    b'5Q16zquqqratXbMmRo+LAk8bwLLly3XDMOfT3dOoLCdBL6KywDStiGlZqm1ZMC0bZAqw+dYR'
    b'vCt6NoDkPUGYEI5IBpWigHp/KCrdqio0ulWcW9XSNLWPDGEzlfX0xHX0I09puvbWmpdeMpI/'
    b'6z08ZwAkeo1EfxzdXUliP8uy7JNM04wYpgmqB90nwXNIxs9OSfwghxaEnDNS+1PJDDRNg65T'
    b'oVu630d1jXTwGTr8UDDob1r9wmqOIDyDZ2SzePGSWvo4zyHRX0oCX2EYRjCeMEj0hit4/rBF'
    b'6IK3SRkDDxvYEHRdh9+n822UHr9A9ffT4YcbG19ud36gwBRcTosWL+Gx/JUk8g+T2GfHEwkk'
    b'SPimyZ9k8oMUhGIl1XFpmgIfGYHf5+MIoYPa9b3UtG9rXLfujeQzC0PB1OUK/2oav19Ogq+J'
    b'xuJOiM8fmIhemIyk2jYPEYIBPxtCLz2+m1r7DxsbC2MEeVcaCX8G3VxDwr8qHk+4wk8Oi0T3'
    b'QimQHCaAjEB1jMDv9x0gI7iTqm5Z37huV/Jofsir5Ej8l5EL3kRj+/nRaMwJ9aW3F0qV5HSB'
    b'7QwNgsEAzxVsV6B8izrGuzZt2pCXycK8qI+Ev4Buvksh/nkDJHx6g44LivYFIRkRsBYoEkAo'
    b'6OfswZNUfS1FA68nn5E7NPc2Z5D4L6de/95YLL60t2/AmdXnXl/ELwhJUlrgOTDOfKmKcoSm'
    b'qVfMrKvb29ba2pg8mhtyJkMSfhnd3GKY5qcH+qOIUa8v4b4gHB6eLAxwNBAOshk8RFUfb1rf'
    b'2JM8ml1yEgGQ+I+0Yd+fiBvnc6+fcHt9QRAOD2uFT3xLJEw+oehoGhL888yZdaspGtjnPiVr'
    b'ZF2VJP5TycHuikbjc/sHos5Eh0hfEDInpZ1wKIhAwNdNdy+nSOARPpYtshoBkPhXWZb964GB'
    b'6EwWvzPWd48JgpAZKe3wyXFE0OfTL5xZV7eFIoFNzoEskDUDIPF/1LKsX/X1R8s4ty8hvyBk'
    b'B9YSD6Mt21bJBM4jE9hOJrDBPTwhsmIArvjv7OuL+mNxEb8gZBtnXsDghXCWQiZwNplAczZM'
    b'YMIGkAz7qecX8QtCTnFMwFkN65jAOTNmznyzrW1iw4EJGQBP+PGYn8N+Eb8g5J5BE7BtxZ80'
    b'gQ1kAuNeRzBuAyDxH2nb9kM84SdjfkHIH44J0HCA4DmBVdOmT3+uvb2t2TmYIeMyABJ/Oef5'
    b'o9H4CanZfkEQ8gdrjicGVVX1+f2+42bOqP9NW9vujLcic/bPGwffS8SNU0X8glA4WHuswUTC'
    b'WEId8i/c6ozIOAKg3v9yGoN8m8/w4z34RP6CUDj4ZCEeDvj9+tF1dfW7Ml07kJF+SfwLaNz/'
    b'bG9v/ww5t18QvEFq7UAkEkpYlnXmxg1Nz7qHDkvaQ4DlK1aw2r8bi8VF/ILgIViLrMl4POFT'
    b'Ve0/jjr6xLR1nfYTaZzxMV7P3z8QE/ELgsdIzgfEYFnmaaGQ9q9u9WFJS8kU+s+gMOMFGvfP'
    b'pwhADEAQPIgzFAj4EQkHu+nuiRuaGre7h0Yl3QjgWt7Gi3fyEfELgjdhbbJGE4ZRqarK593q'
    b'MTlsFoBP+LEs66f9/dEQb9Ut+hcE70I9vxMJ+P2+k6ZNn/FMe3sbX7ZsVNKJAK6Ox43q5Aae'
    b'bo0gCJ6ENcpapUjAT1HADW71qIxpAG7vf3k0JhN/glAssFb59HwKBM48adHio93qETlcBHAl'
    b'uUlNat9+QRCKA9asYRh+uvuZZM3IjGoAfK0+vlwXO4kgCMVHMgqwLz3xpEWz3apDGNUAbOAc'
    b'wzBn82mGEv0LQnHBmmXtUqmih5cmaw9lRANYcfIKlZzjI7wXGc8oCoJQfLB2WcOKoqw68aQl'
    b'ult9ECMaQDxuHE/h/zsTyR92awVBKCZYu5wRsCxrmW2b73WrD2K0IcBKwzCcvL8gCMULa5iH'
    b'Aqqqvs+tOohDDGDZsuU6hQ5n8SWKnJkAQRCKGB4GGDwcuODY407gq3UdxCEGYJjmfHrySalr'
    b'+AmCULywhlnLto0pPp+vwa0eZKQhwGkUMkQsS3p/QZgMsJZN0wzZsM9xqwYZyQCW05Nl9l8Q'
    b'JgmsZd5JmOL5hW7VIAcZwNJlywL05EUJZ8dRCf8FYXKQuqiI/YHjTzip0q10OMgALMvidf8L'
    b'OAKQ4b8gTA5Yy6xpgq8vWOFUuhxkABQpHGOaVsSW8b8gTCqceQDLLLdM8z3JmiTD5wCONC1L'
    b'Ff0LwuSC5wEsPq9HUea5VQ7DDWCebfHKP3EAQZhsWLbFacGw+9Bh2BDAniPpP0GYnNDwnuf5'
    b'3nnMcSfwMmGHwam+ZcuW+xOG8dSB3v53xeOy+89Q+KPoSwB7DxT4Qykjc/a597NMqkUEqPCq'
    b'ET+9Vd4vjgu/a2kOxQ136z5dQ1kk1GPZ9rxXNjR1cv3g97pk6bKwYRhrDxzoP4ZzhsLbRA1g'
    b'0RwDx80lFygg8V0BWK3kAOO6ouPIcAOIUevYT4UbSS/1EgN0Zy9FgrvotpPPB+EDDPUK/NJ8'
    b'PmmYfpC9SIyheFBVFRXl4S4aBhzRtL6xi+sGv7/FS5ZWmaa5pbunbwqFCW6twDQ3K/jRNb34'
    b'5Adb6QPLovoywISBjqcXwPdMNRDK7vfD+k5pnImR+PcbFnqpHfTRSyXo4L6Eic0xA7uob9hD'
    b'JvG6YaM5NVwkY+BF5xFqTSOuORU8gaoqqKwo69I07Yh1L6892ACWLFlaTT3/1u6e3mqZBziY'
    b'5m0KbruuF1eubIOqaAeJJV+YdgL7/roQ/r+R1EK5/Qu4UfAQUHGbB/9r0rtOULtg62FD2E3D'
    b'xE4ygXYyhpcHDGxOWPgLPeZcMv/wNPqhoPuzgjfgdQEV5ZGuQMB3xNo1axwDGJwELESjLhqo'
    b'FfPnw5dCdSLiQhTn9fNTWOScMTLohbkkqHCfoFMD8lOJUE/yjpAPp5QHcE5NCF+fWY6fzirH'
    b'03UR/LI2iE+HNNTTZ7aDfqiZfm6Afp/gTYZmAfz0XQ1PCwrCIGwOqcIGkTIGH4m9UlNxQtiP'
    b'ldUhfIMM4Rf15Xh4ehhfjuiYTsd5uLCbniuzS4WGr+3xdlw2KHgaH/AOgnzFb0HICG4yHDVw'
    b'tMDGwIYwK6Dh1IogvjijDPeQGXBkcK5fxU56DkcFvNuEkF+ck4HIiEc0AEHIFmwIqSEET5nW'
    b'kxlwZHALGcGTMyL4bFhDO9WzEWR3OlPIFDEAIaekzIBLWFWwpMyPr1JU8NTMCL4Q1tHiRgRC'
    b'YRADEPIG65wTBT4KQY8L+/AligYemx7GxTQ04DmCGB1/OzgV8oEYgJB3hhrBivIg/rOuDD+p'
    b'CTji3y7RQF4RAxAKRtIIbFTqKi6oCeMBGhZc5EYD4gP5QQxAKDicSuTJwGPCfnx7Zhn+b6Xf'
    b'OYegsCdelwZiAIJn4Gigxqfik1MjuH1KELvpsZxElFvEAARPwdkCXk+wqjqEe2qD2EMm0J88'
    b'JOQAMQDBc/BwgCcE31cZwr1kAnvFBHKGGIDgSVKTgO8dYgJyofrsIwYgeJahJnBnTRCtVnI1'
    b'opA9xAAET5MygQ9Uh3BzpR8tnDIQsoYYgOB5WPK6AlxYE8KVIc05dVjOGMwOYgBCUcAdf5Wu'
    b'4craMJZoyS3MhIkjBiAUDXyewLygjq/UBMkA5GzBbCAGIBQVHAmcWh7A9WW6c7agMDHEAISi'
    b'giXvVxVcVB3C0ZoiZwpOEDEAoejgswUbAjqurfRjj0QBE0IMQChOFODdFQGc6VPRJR4wbsQA'
    b'hKKEO/5an4ZLKnzoscUBxosYQBGhUbfno/Evb6Qx3sJbe6eKRoXz6alSjKwoC+AUXUGv+1jI'
    b'jMHvfemyZdXxeGJrd09fNe8eKrxN83YFP76WLwzSTo6pFiT9ZNF/ax+fgfbfRqBWupUZY0NX'
    b'VWcSLUC3VT4dNT4f6CEZQrKeMd3vvxhaAfdgv9rXh+v2x9Hg/v3C6JSXhbsikdARL7344sFX'
    b'BhIDGJ1CGwB/SRa96m2PlOHzPwoBUybwF1Cvn5L2MTAxU7ExRVPwjrAfx5SFMC3gw/xwCBFd'
    b'c6IENgMvtwb607F1IIHzd/c5W40PXvZWGJHhBjB4obv6+vqQaVrXxmIJamHCULr3K/jAijgW'
    b'L+wjMea/l0lK1kLT5mo8trYCDdMDqAqOr1QGAqigUk6l1x9Esy+IDVoAzxgqftsdw11dfdi4'
    b'bz/2R2POPvKVFCUENRp80B/hVSMo01TsiSbw14SNqvx/PUVFwO+L+v2+H+3auTPKj2UOoGhw'
    b'WzbPfnGENs6iUFGp6FTY6WtI2bNpONBAQp9bFsGs8kqsi1ThxgEN79++H597rQVP7ulET8Ic'
    b'nDPwEvSuEKTQ//Qy6vvpPfFjIX3EAIRBuMfnS59Wk9Dn+n2YU1mBPwYr8ZG2AVzzegte7Ox2'
    b'luOqHA54CBb9wqCOE2g84HRrQtqIAQgjwqLiaGEW9a4NFBk8RkbwwR3duGNHG7oTCSca8Aoc'
    b'FE31aVjhV7BHQoCMEAMQDg8ZwVwyglnlFbixT8VNW1vRGo05k4RegDUfoL/v5HByGCCkjxiA'
    b'kBYsKx4ezA0GcLcSxre370VrLOaZSIBnJ+b4qTnTnyNXIE4fMQAhI3ieYK5Px31KEHfs7EC/'
    b'aTrnERQavqz1rICO0zUV/RIEpI0YgJAxbAINuo5b4zr+0N7liaib/wROB87Xgc5klZAGYgDC'
    b'OLExw+/HdfsTeLNvoOBDATYAnpM4PqAlHwhpIQYgjJsgKS3uC+CBvQcQt6yCnyPAax0agnxZ'
    b'EXGAdBEDEMYNy6xeVfCDmIK3+qOeiALC7p8gE4HpIQYgTAjub6HqeLEnOriIqFDwq1drKt5B'
    b'rZrXBQiHRwxAmDCVmoLH+wz0mmZBhwGcCZjq1zGHTCAqo4C0EAMQJkw5lT/bGg0DCn9eAO+X'
    b'UE5/Qsx9LIyNGIAwYVJLSvcmCn/hLoV6/jJYYgBpIgYgZAdVxStRs+DZAA5AItSq5RqC6SEG'
    b'IGSFAAlvc8xwLt5RSNh8KsiMhPSQT0rICrwTT68jv0L2/9Sg6eWn6NKs00U+KSErsAH0KGoy'
    b'E1BYD5DzgDJADEDICj4qHZaNAwbPARTWAUT/6SMGIGQFFp1KwveZr0JPrKGytiDFF38ZmrWf'
    b'/ppChyHFweCnJLsCj443dgW2cPuj03HND8vQMNd7349hWwjT3/ilk69HXc08WHYhTsZVnJWK'
    b'j7/+J/xs812Y5Zvm1gspZFvwcSAGkAZWDLZeCeXc+6HXLqDHhTob34ax9g5g9TVAmP4O4SCG'
    b'G4AMAYQsYUH1lWOWpqPBjGOOlShAMTDbjCHYvw+2tOy0kI9JyAq2HYcanAo9VEN9cIEiFCdU'
    b'smAOdFDLlkuEpIMYgJAd7ATUQDmUgi8JtmFFe6hlh90aYSzEAITsYHRBr5xHvXDhd+SxjT76'
    b'11moLBwGMQAhK9AIAKEZJ0DVOfQulAMosOL9sGP7KRKRIUA6iAEIE8c2oQQ1+Cvq6UHhhgA8'
    b'/Ij3tsPqe4tathhAOogBpAN1aLwnvk8xoakJ6Ep+C7+m89r8hxQ4vB4J2+qHXnsWAtUNsO0C'
    b'rsNTVBgDXbB6yQAUGQKkg5wHkAbNu4EbPmni7DMUp5fJ98fD82r8nTzyVxvfvUNDQ517wCNY'
    b'vZtRdeqPUbvoCnpUuLajqDo633gc+x5eBa1azgEYCTkRaDzss2BfNAWxM+phF2iWm6/TF/jr'
    b'Lij3dwC1Hgrc7ASZ0wDqz3scoalHUzRQqN342JhNtD5/KwY2fpOGJGIAIyEnAo0DtkMeUdZr'
    b'KmZzUfmS2nks9Jr82oWcXhsNK7odkYWfRKBmPom/gHvxcpRE5hPds4mi/1q3UjgcYgBpwv2+'
    b'Surjnpjv57XQazqvTfc9hTUANXIUqo//MFStsPakUFNO9HXA7ttBX1TIrRUOhxiAME5sWP07'
    b'Ub3s36n3P6KwvT+jqoh2NcPqeInuB9xK4XCIAQjjgMTftwXli29C1VEr3brCYpsJRPe9yYkA'
    b'wnOxkmcRAxAyJCn+8NGfRe2SK6HqQaoq8BacigLLiKFv+9+gBg8//md7iBlA8zZr5LKXhnkl'
    b'4iGDb1OyAKNj77MQuGgKKs+cXbjOhb6S7r+0IHZ/B5RCZQGsOIm/GeVLbnLEr4eqnZn3QsPp'
    b'v749r2HX786GpmpUwfsTjU4sAdRPUfHxD1XApx/8hfJ+oltb4rj90V6UBzjt6x6YJEgWQBgH'
    b'NuzYZuroOzHlzDsx7eTPkfirPCF+B+qw+tv/ARxoOaz4mbadFr54WQ2u+Ugd/u3CmbhySPnU'
    b'xXX4wLsq0NVK760EogAxAGEMLNjxHU7IH1pwDerO+yuqj70ICoX9BT3jbyjURZvGAA5seQJq'
    b'WZVbOTrN3TbOOdOPs95ZDWhJhfO/TuF/KNLq7KEQgWpKQP9iAMJwSAFWFHZ0M6z+rQjOvQwz'
    b'Vj2JGe++CeHpx9FxkoVXxE8oioZo53Ykdj8ORSNRj4HFI9tOG5+9ZCpqavyAeehQ10xY+MeW'
    b'AbpXGtIQAxBI0Cb9fyAp+t4tUALTETnuRsw892nMPPM7KJ97GlRfyDnRxjEID8GRyIGda6FE'
    b'95IbjH3+f8sOC5+7PIJTTqx03eBQTDKFrS1RYGwvmTSIARQV1Gid3pcbbwaFx+pcrDjd9ME2'
    b'OpOhfT8JvpvG9uZe6NUnIXLsDZj2oT+g/tz7MOPU61E252So/nBS+B6cGFYUFYn+DvS8ej+0'
    b'yNgLJBI8XUEh/ydWTUUwMvqeBRYZQ2ePhUCJrCUaHOZIFmB0PJEFIPY/uQmxO9+Akulmtzwv'
    b'plZA8c+GGpwGLUwlMhW+ynkI1h5Fj2sQqGogsUegagFH7MkxvrfbAc/+d7z5JPY9fDb0qrHP'
    b'/ef03i1frsIXPlYPVeVhjHtgKFS/Y1c/zv3CNuzoACKTcEWxLAYaB14wANvuhbnhX+Dfdzz1'
    b'ZJnNviskakXTofjKnNl7zV9GlYojIMVZN+8K3vnei+S758m/eD+aH/sS7NYH6b2NHgH0xmzM'
    b'rFbxxx/Ow5xZoRHH/g66grVNXVh2cQtmNWjQJmF8LAYwDrxgAJbVBv+ObyFivZskmumKu9T3'
    b'yUJ3RT74FRfnd83m1d38IlofPB2+iiOoZnS1Nm8zcc/3puOSD00fdezvoKt45sV9OP1jOzFn'
    b'HpmjWz2ZkPMAihaFxuKmMx63rUSGhX+GC88FDO3pi1P83PsbsV50bPw1+ETEsZrxzh4bK88I'
    b'4P3vSmNWj8yhq5vNtTRSgIwYgFB0cOqvp2UN4q/9BIr/SLf2UNjnzA4b16bSfmP1/qR407Dw'
    b'j62lkwJkxACEokJRNcR792Lvmv+BXl7DNckDI7Bjp4WrLonglEWjp/2GUmopQEYMQCgieBhk'
    b'Yd+rfwB2/wGKPsWtPxSD50kNBVeePxWhcHpblZdaCpARAxCKBs5kHGjdiK7nPgO9Yp5bOzK7'
    b'dli4+YuVOH5hWVq9P88r7OmMo2WPjXJ/qcwAiAEIRYIT+h9ox+5nb0YgGKSK0Rf99MdtHLlA'
    b'w0Xvr4XqIzGnoX9WQntHDI0bTQQlAhAED6GosIw4dq/9OZTW30Pxz6HK0VW9d5eFG6+owdx6'
    b'MorRcv6HoKA/mjz5iZcElwpiAIK34SV6toX2V36H/r9/E3o5n/E3uqhbD9g467QAVp5Wk/zZ'
    b'dCnBFCAjBiB4GN6QQ0XHlqfR8cQVCNSOPe7ntF98H6f9alFbe5i031BI8aWYAmTEAASPwuJX'
    b'0LXtBbQ/cRVC1fVUNfbgfEerjSsvDuP0pVXpi9+lFFOAjBiA4D1I+AoNxLu2r0bL7y9EwBen'
    b'lhpxD44MdeBAjAzggqkIlWV+heJSTAEyYgCCt+BtfSmW3/fmX7DzkcsRDvqgaLzTz+iK5jH7'
    b'rmYL/3FtJU48qiyDiT+XEk0BMmIAgmfgU3x5zULbhvux+/4PkfgpEtDHFj/T56b9LvlALTQf'
    b'G4h7IF3oR0oxBciIAQiegFf3JQa6sOOF29Dx8CcQmTbPDfsPr+a9u2x8+dJqzJ89xlLfMSnN'
    b'FCAjBiAUFJ7l55N8ettfw5ZHv4iBv38V4foFdIC74sOLeU+fjTNO8eGcd2eY9htKiaYAGTEA'
    b'oUDwRJ8OM9GP1g0PYut9K6G13Qf/lIVpR/Cc9hugcTun/aZPC2Q88+9QwilARgxAyDvc43Pv'
    b'fqBtE7b86WvY9/vLUBZSoYUWJlWdJjtI/FecH8IZy6rSCRZGpVRTgIwYgJA3eJKPxR/t3o2W'
    b'F3+GrXcvAbb9BJF6Er7KO3ukr2KTh+z9trPar6ychgvj6f1dSjUFyIgBCDmHRe8s5unb44T7'
    b'b/7mo+h95vMor5wLPUIhfwa9foqdzRa+cXUFlhxbPiHxl3IKkBEDEHKDczIPdal0yz1+a9P9'
    b'eO2+y5xwP2w1IziVen1nRV/m4o0mgLoGFR/9YC10PzXhCeifFVCqKUBGDEDIHq7oube3ElH0'
    b'7G5Cy+qf4vW7z0HHIx9DxHjDCfcVrWxcvX6K9p3U+19RjYUN4XGm/YZSuilARgxAGD8seE7j'
    b'adST030WPafzOMx/46Fr8NYvVqDv+S+g3Lcf4ToSvl4xIeEz+/psnH6yD6vOmEKtNwshewmn'
    b'ABkxACENSBopsXMPz4InbCOOWO8edL31HHatvQuvPXglttx9Gjoeugy+fY+ifOp8+Gt4gi80'
    b'YeEz/Bv69li47qNTxp/2G0qJpwAZMYBiYrCL4jsTKCTmkUrqpJyUyFM9O28tbhkxxPkyXLua'
    b'kufpr/k5Xn/oarxx78XY8fMz0fPUVQjsfwrlFbUIz1oI1T+DXiuZ7ssWO9ptfPy8MN6zvDpr'
    b'v7aUU4AMffNJ5MIgo+ONC4O0w7f9a4iYp8NW+PLV48P5bvn6APw+6O7Qy3yzyBP9nUhE98OM'
    b'9dHTDMQOtDnX3o/tb4bZ1w50PQ/sB/yVgF5WRiZRCVWjHt7pS3LXbjjtxzP/q++dg5N5l98J'
    b'j/0J+gyiURMf/sqbeHyDhRllBfpy84hcGWgceOPSYHH0/v1ImK83AL63RZsR1Jub0R7Ee0nI'
    b'9EZo1E7399Avtxzxk/ph9+8C+jfD7qVn0MvoEXq5crqvV1FkECLBU+FFO3lsIvyRb99m4WtX'
    b'VeCbV82GrlNNNl6/BK4FOBwxgHHglYuDdj35KgbufA1KrVsxDni1rROZO5AJqBVOJYuaz79X'
    b'1ADd53wYPZHDf6cpFLY9cNqPP/dnfzIXC48gR8pG78+UwLUAhyOXBitWqM2rSjn1xkc4++KN'
    b't2gRKsFUOZLG6tOg+mpJ+9XUu3NX73fCeZZYsiMorPgZTvt9619rsHBuNtJ+QyntFCAjBlBk'
    b'FF6O+aWj38apyzntV+OE7FmlxFOAjBiA4Gl62y18IVtpv6GQ4ks9BciIAQiepXmfjctWhfGe'
    b'k7OX9htKqacAGTEAwZM4nf0BG/92QS3KJ7jabzRKeRVgCjEAwXPweLxlu4UbP12B5cdX5ET8'
    b'nOEo5VWAKcQABM8RNYCKmSouW5mF1X6jQb+2lFcBphADEDxHW4uF73yqGu+Yl+2031AkBciI'
    b'AQieYv+AjRWLdZzLq/20HIbmNKwo9RQgM/je5UzA0fHEmYD0lXT/pQWx+zug1E5e327eZuGB'
    b'W6fjgvdPy83Yn6Hv0DRsfP3H2/Cd2w9QRX4+z5mzNWfCsZDqklOBx4EYQH5o7rRx8bsC+OnX'
    b'56Ky0pc7AyBM+t1rX+lGL0Uc2T6/aDgK/f54wsYP7tmLtZtNlAXcAwVADGAciAHkHtY6z/w/'
    b'e9dsnLq8CqAeOufwoqJ8oKt47R/7ccZntlP7SUYBhULWAgiehMX/lU+WY8UJFTmc+BsGm0yu'
    b'iwkMdMfx4/t2om234rmMgxiAUHDiPBdXpeDys2vhC1CTJN1MGujtPL+uA/99XwxzGpKLrLyE'
    b'GIBQcFpbLPy/q6vxT7zUN4fj/ryjKujoiOH7d7VBq/UVbPQ4FmIAQkHhtN+yRTrOO9NN+02m'
    b'3p/403N78PhzNmaVe1H+YgBCgelus/Hly6agbmYwf2P/fEBmtr2lFzfdvhe19clNVL2IGIBQ'
    b'MJq7bFz4LwG8N0er/QoGdfZWwsJv/tSGrW/pKPPwVmNiAEJBcIb6+218+sKpqKzKbc4/71Dv'
    b'v+GNbtxwazfqGzRPe5sYgFAQWnZYuO5jZXjniTla7VcoFAUDfQbu+G0rGYEfPo8rTAxAyDsJ'
    b'k/4JK7hiVS2CYW3ypv3meC/tNxwxACHv7Kbe/7+ursKxC8ok7VdgxACEvHIgZuP4YzVc8N4p'
    b'ULO1v7+H8HrabzhiAEJe6dxt46sfn4I59SFJ+3kAMQAhbzTvt3He+wN43ymTbBfOIkr7DUcM'
    b'QMgLzlC/y8bVF01FTTUpRNJ+nkAMQMgLnPb73OURSft5DDEAIec4aT/qJT+xaiqCkcmX9nuh'
    b'sXjSfsMRAxByDqf9brmuEsctzOKFPb2AqqCzI4Yf3tMGdUpxpP2GIwYg5JTemI1j/0nDRWfV'
    b'QtWpuU2m3p/gtN+jT9uYXVGM8hcDEHJMx24L/z6J037f+tm+okr7DUcMQMgZzd02zjkzgLMm'
    b'adrvgSfasHmrVlRpv+GIAQg5wZno77Tx2UumoqZm8qX9Nr7Zja/8V0/Rpf2GIwYg5ISWlmTa'
    b'75QTKydx2s/HG/4WNWIAQtYxOO1nT+603233JtN+xY4YgJB1du2wcOv11TjhqPKk+ClkzmnJ'
    b'9ZU9UkyCtN9wBt+DXBhkdOTCIOnDJ/1w6/nlN6bhHXPDMHM8889N1edTUD89RPrM8ZdDBnDP'
    b'wy249IYONMwrzpl/uTLQOBADSB9uOX6K+iv8vejuNZzLYuWS7XstfOrsKvzghmPgz9WlxBmK'
    b'NLbv6MX7rtqMrqgfkSKd+ZcrAwk5hfXOUcCungh6zEp0G7ktRn8V5tZXQOehQK6gXz1Z0n7D'
    b'EQMQckKQwvKwP/eFu/xjjohA5VU4Oez9J0vabzhiAELRkhqpVpbRmCNXAUAq7ffg5Ej7DUcM'
    b'QChaTIv+KVNQFs5h70+/2kn73RedFGm/4YgBCEVL1ACWL9AwfQoNynNhAKm036/aoNBr5HCW'
    b'oWCIAQhFS0/cxqxpOmqq2AByEwI8xqv9/mZjTpGu9jscYgBC0ZKIA1Nr1NycB8Rpv5Ze/J+f'
    b'Fdcmn5kiBiAULz025tf7s58CpF/3dtqvuDb5zBQxAKGIsXH0/HD2U4CDab/i2+QzU8QAhKIk'
    b'ZynAg9J+FF1McoWIAQhFSc5SgPTrJnPabziD7zDpqMqkTHUIk4+cpAAnedpPoehGofc4dK3P'
    b'EAOwkws3xAGEIiBXKcDJnvbjLn5EAxDdjwF/XilzZJccvJ+vQv+k7mevrRc1WU8Blkjabzhv'
    b'RwDJpkUjq2x9opMI+pRsy4ZtWIUtvLXW4DdW4mQzBUi/ohTSftyPqOSY1pAt2gY/vSVLl0YM'
    b'w1x74ED/0YbJezoJg5AtJqpNJGbQx8WfWL57Yfc1fW02fF2amADRvM3EH/67DivPqJ34duO6'
    b'gqZNXTjp/LdQ3xCctDP/mqY6+wEoinJE0/rGQzYE8ZMB/O1Ab//J8XjuN3IoNmyDIoD+whqj'
    b'Etag8DX1Sxwewu7YbuLZu2bj1OXVAH0344Ya+kDUwJdveRO33W+iYZLO/PMn5Nc1RCKhHsu2'
    b'572yoamT6wff7do1a2hUhd2aylUTdNRJCAtPrdALWkT8SbKaAqRfURJpP57kJ21T77/JtOxe'
    b't/bgYJIO7uAxgiB4maylACd52m84PARQVXX1q69s4M7eYbjlbWOXGDIyEATPkc0U4GRP+w1F'
    b'VVROAfa7Dx2GG8AWGgJYjgcIgkfJSgqwxNJ+fBKQyhkT297mVjkcPAQAXqUwoY+fLAieZaIp'
    b'QPqxUlntl4KH9pqqHVA17Sm3yuEgA1A1tY3Ev1nTtIlGVoKQQya4CpCMo1RW+zGsZdY09esx'
    b'wzB63GqHgwxg7Zo1MTKARp+u0SNxAMF7pDqmca8C5LRfCa32S2JDJ01TFPDHDU3ru91Kh5He'
    b'/ktJt5BhgOA9JpwCpB8rpdV+DGtZT0b1b7pVg4z0CTxLbtEn6UDBi0woBVhiab8Uzvhf0wbI'
    b'Ch52qwY5xADIKd4ix1iv6zo5hgwDBG8x0RRgKaX9GNYwa5mCgI5EItHsVg9yiAGsWfOSQQbw'
    b'hN+n0yOJAgRvMe4UYIml/d5GAWuZNP3gplc2DJ4BmGK0QdCj5BoD2njTLIKQK8aTAqSn8mrK'
    b'Ukr7pWAN8wSgZVlPulUHMaIB+P36Rho3rPb5fDIMEDzGOFKAFC5s2tKDr3y/B3VzJn/aLwVr'
    b'108aVlV1jaKof3arD2JEA3jx7y9aFDLcxz/MM4iC4AVSfVFGKUB6XiJq4hcPtdIv8DmXLi8V'
    b'WLs+Pw/l7d83rV9nJGsPZrQhAH9uD1Po0MLhgwQBghcYVwqQQuDVTZ34/i8HMGeeWkK9P5zQ'
    b'X9e0Lrr/K7f6EEY1gHXrXt5Hw4BfBwMlNGASPE3GKUAK/fd3xfCje6j3ry6dtF8K1i5FAQ80'
    b'rW9scasOYVQDcLnd59M79dI4XUrwOBmnAEnxTzy/F7/7s4WGqtKSP2uW03+Gaf3arRqRMZXd'
    b'uO7lLaqq3hUMBJwJBUEoJBmlACn037m7H9+5cy9q6kop7cfeaLu9P/74yob1T7vVI5JO136b'
    b'3693UiQgcwFCYUk3BUiHeQu3B59ow4ZXVVQE3PoSgDXKWvX7fXHLsm92q0flsAbgRgH/EwwG'
    b'2FEEoYCkmQJ00n7d+PzN+1E3hzout7oUYI0Gg87Y/ycbN6x/zq0elXQH9z/2+/S3yFVkKCAU'
    b'hFSzO2wKkI4Npv1QWmk/J+9PGvXpehfdv9WtHpO0DICiAN4n4KYQRQEUDbi1gpA/0k4Blmja'
    b'j2Fthqj3Jx/4QdP6xu1u9ZikrWYygbt1XftdOCQTgkL+SSsF6KT94iWZ9mNNsjY1TXs+Hk98'
    b'z60+LJl25zcEAv62gAwFhDyTVgqQFP/E83tKLu3HWmRNUvifME3zxtdefSXqHjosGRkARQGb'
    b'aShwfSgcdLYYEgsQ8sVhU4Bu2u8///+ekkr7sQZZi6xJ0ubVGzc0PZs8kh4ZD+jJBO7SNe22'
    b'CL+gWycIOWesFCBVJdN+rdj4moaKoFtfAvCnwVpUFeWR9Y3rfpasTZ+MDcDlBp9ffy4cCspQ'
    b'QMgTNo5bEIEa0pzenq/nN1h8Kv4xNO1XIk0yOe4Pct7/ZXp4abI2M8aVJGlt3R2vq6t/Tte1'
    b's+l7qUoYfC1B9iJByA3d+4F/XqpBtQzsbO3H7rYolQG0UuHQ/47ftmLtZhVTKkujHbL4OSsX'
    b'DPoHLMu6fEPT+s3uoYyY0Ke1aPGSUy3Lfrivf6A6FouLCQg5g8f+29oHgL4YPRqhnVWGMW+K'
    b'H1YJdP/OpF/Az6E/L/E9v2l94yPJI5kzYcWSCawiB/pNX1/UH4uLCQi5g7VtjdBkuUZVSiPu'
    b'T834RyIhfsMfJfHflzwyPiZ8nhQNB16vq6/f5vNpKyka0AzTFBMQcgI3K44EhpdSaW5DxM8b'
    b'9nyCxD/qOv90ycqJkmQCrwyagE0mYIgJCEI2GQz7qedn8a9vXPdL99CEyNqZ0q4JbPLp+ln0'
    b'MCQTg4KQHVITfuHkmP+ybPT8KbJmAIw7HFjt8+nvVhXVyQ7wQEVsQBAyJ6WdSDjEs/18Sa9L'
    b'SPwP8rFskVUDYMgEdtTV1f9R92kn6ZrWwMMBy7IkGhCEDOBen8/wK4uEKPT3rSb9nE3if8E9'
    b'nDWybgAMmUAnmcAD9AYqKRpYZls2ZHJQENJjcLKvLMSbej5EkcCFTevX7XIPZ5WcK3LR4iWX'
    b'0xu6ORaLz+gfiEk0IAijwMLnJb28qs/v9/WRTj4/ntN7MyEnEcBQKBrYQNHAI7qu11M0cDSP'
    b'a0zTojdbOukbQRiLlBZ4lr8swqf2+v5C4j+XxD/i1XyySV4lSNHAZeRyN8UTxvxoNIZEQjIF'
    b'QunCnSGrn/fw4228fLreSXq43jBid76ycRNvgZJz8q4+MoEZdHMNDQWuiscTNdFYHIaRfK/i'
    b'BUIpwD0+w1t38+69FO73kvDvpM7x+03rGw+5gm8uKZjkyAiOpJureSEDRQKuEZjOOEiiAmEy'
    b'kmrbfMUeFj71/Cz8u6m1/7Cxcd0b7tPySsGV5hrBlZZlf9gwjNnxRMIZGpgm26SYgVDcsOhZ'
    b'ZnyVXr7WJof7ZAAd1K7vpaZ9W+O6wgg/hWfUtXjxklr6qM6hD+wjZAbvJDMIxckI6Bb0ePCD'
    b'FD8QvEwyvE92XKrKvb3uXJ+fRJ9QVXU91d9Bhx9pbHy53fmBAuM5Oa04+WQ1Hk8cT3dXkujP'
    b'IvGfZJpmhM8j4CEC3XcNgZ/t/EOIMQj5ZaT2x4Lnk3c4xNfplu4PKKryqqooj9GTHqa2u3FD'
    b'0/pE8me8gadls2z5cp1EP5/unkZlORnCIioLTNOKmJal2pYFk8yAzy3gk42Sa8HdL4VuUl+P'
    b'IEwERySDSqGendROwnZy9pp7S8VSNXWAnrad7r9IT1xH5SnbQvP69S/zJgaexNMGMJyly5YF'
    b'SOwzSOfH0EOeO5hHhjCHbqfTbTXdTqPCO0LSQ2j0D18cXRAmBPXsvAjHTD4Cp6zaKZTvdG93'
    b'0C2X10lMr5Oi2te9/PIAPS4KisoARmPZsuV+6v15Mzi+ljnZs2MAZeQDbAqCMFG6SOi9FFLy'
    b'tiO8HDdOUYCxZs1Lcfe4IAiCIAhC0QD8L6rYslNDp1sVAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
install_apk_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABgWlDQ1BJQ0MgUHJvZmlsZQAA'
    b'KM+VkTlIA0EYhb/EE4mkMIWIxRZqZRoVsZQoiqAgSYRELdzdHArZNexGbCwFW8HCo/EqbKy1'
    b'tbAVBMEDxNbGStFGZP1nIyQIERwY5uPNvMfMGwgeFEzLrR8Gyy458fGYlkrPak3PNNNIGGjV'
    b'Tbc4lRhLUnN83BJQ601UZfG/0ZrJuiYENOFhs+iUhBeEB1dLRcU7whFzUc8Inwr3OnJB4Xul'
    b'G2V+UZz3OagyI04yPiIcEdbyVWxUsbnoWMIDwl0Zy5b8YKrMGcVriq3CivlzT/XCUNaeSShd'
    b'ZifjTDDFNBoGKyxRoERUVlsUl7jsx2r4O3z/tLgMcS1himOUZSx034/6g9/durn+vnJSKAYN'
    b'T5731g1NW/C16Xmfh573dQR1j3BhV/zLBzD0LvpmRevah/A6nF1WNGMbzjeg/aGoO7ov1ckM'
    b'5nLweiLflIa2a2iZK/f2s8/xHSSlq8kr2N2Dnrxkz9d4d3N1b3+e8fsj9g0kV3KHsxy6YAAA'
    b'AAlwSFlzAAALEwAACxMBAJqcGAAAA59JREFUSEvdVWtIFFEUPvfOzLq76eYraYsCszdCQeKr'
    b'P71/VJaE9KSsv/3qRwiFGPWjqAgCJehPRSVE9JJeP9oe9DK1KHpCWpFFma6mqbvOzsy9nTsz'
    b'q83q5M+gb/fumTnn3POde869d+Gf4c6TSmI/jopHz6tcfV0NdQ3lEziwjNKCM6+uNJSnxljH'
    b'fEaM6WgiFKQWD814WJp/pquuYfMsfO8vKTjVas10wpXgUsMWKgEs1nhnNqf9Ow2mTWOMmTaC'
    b'FLIkfwLmP6KQcS2EGKHV+bWGaUwAteUwrCk4zVQWnhtjPcffvuiY1t2pitQxOIAa1eFlU0d2'
    b'VO2u0aC90C24gCvBhfqyqQbv3c25Dj/DMVBVhsu1FmwwDuEfMZQGjr6Ki/Vrck3DCHAlMKBv'
    b'CQBLpYTqhYuy9KygT8cK6ZwT3T9G0RcsH697vQq+c79B+pfZ04bBtQfnH5cgQWwxPmqWxhUK'
    b'fu+vLb520353wEFwoX71VAOiZTIJ1A4YbduweXtRHbWsrvABVw76pclHVd6+VYKkurKiq+9s'
    b'm7NEDCL7se4HNNa1D7uJm8iEb5SBroRE2fdKMRcTPCx0cTgIOOGZ+Ct2SioBsUutXUMla6FC'
    b'iiF2EzVHvADIACxNzMU001+9q5YtfQIB2u3tRtATTThfUzm0NkeAGQQ+v4/A148R6OnUoRtH'
    b'25cB4CKmBeuQoJS4PKh1EjjAzQzb21S4ca4dusMatLzphdeNv+BNYx9cPfsNBiIMJHt1ZjYj'
    b'IJHA6YV5tDb3Q1qmxFsx8xiuZsacAGQGFTB0AF0fSt+sZRyiADYSCezGclOKAMFJPli+YTwZ'
    b'm6ZAbl4qTJntRwIPrNwYNCtvkojY3LDrzuU/oyYQ0CaCHNjKF3jRcdHI7JljIDkgQw4GnpTj'
    b'xcw5pGcpJonQCR/OGXLJz625ytPZM7YPXh0OAj+dXKWQzLy1RaE9Eng/CDPDa0E0UkgxBJzv'
    b'ImzSp3VFoUMKycjz0WCF6WRj5M4g7j7bJYVjLzfp/Fc1By1AuOc6IUk3MDx+YktRV0pAjsgk'
    b'ZYeX5JwsKazGrgxHQomGsHDeASMjefoVPG89loY9WF9869j64tAxZAgJDV7bfcmeiZfcggu4'
    b'EggM6D1eFHEfjy3FGvDZLBfVWET4uOKvBBxvT/w1fbCJ8YMElIiDhNXlaBs8nCPjrwQr5p3o'
    b'ouCtloj/nkwDl201/pulXEPdbUq8Navya9ts9X8JgN8prXBpKQpOLgAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
install_apk_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABgWlDQ1BJQ0MgUHJvZmlsZQAA'
    b'KM+VkTlIA0EYhb/EE4mkMIWIxRZqZRoVsZQoiqAgSYRELdzdHArZNexGbCwFW8HCo/EqbKy1'
    b'tbAVBMEDxNbGStFGZP1nIyQIERwY5uPNvMfMGwgeFEzLrR8Gyy458fGYlkrPak3PNNNIGGjV'
    b'Tbc4lRhLUnN83BJQ601UZfG/0ZrJuiYENOFhs+iUhBeEB1dLRcU7whFzUc8Inwr3OnJB4Xul'
    b'G2V+UZz3OagyI04yPiIcEdbyVWxUsbnoWMIDwl0Zy5b8YKrMGcVriq3CivlzT/XCUNaeSShd'
    b'ZifjTDDFNBoGKyxRoERUVlsUl7jsx2r4O3z/tLgMcS1himOUZSx034/6g9/durn+vnJSKAYN'
    b'T5731g1NW/C16Xmfh573dQR1j3BhV/zLBzD0LvpmRevah/A6nF1WNGMbzjeg/aGoO7ov1ckM'
    b'5nLweiLflIa2a2iZK/f2s8/xHSSlq8kr2N2Dnrxkz9d4d3N1b3+e8fsj9g0kV3KHsxy6YAAA'
    b'AAlwSFlzAAALEwAACxMBAJqcGAAADNlJREFUeF7tmnt0FNUZwL87M/tIsiEkkAcBeZiA0vAw'
    b'YoiiSAEPVFEELB4fBR8FBfWID6jYVm050NbHUWmtYlWo1nLQo6dAxEJB6LEKJCGQ8AgQCSRI'
    b'gJgA2U2yz5m5/b6Z2WST7GY3yS7HP/JLZmfuY+797ne/+93HLvTSSy+99NJDtu55hm0v/NUA'
    b'Ixhzdu1flvFVyTLJCPYIZtx7zKa98/8BoumVO/M+OGREBeVo5aemk/bdGVzwpSmqi6mcgyhY'
    b'QRKtl/pZhtTkX/WU28galM1FCwaA6nmrf0LOLyaMXu4yortN1BSwsfiBaarimTfn+g3zjKgW'
    b'vjn4Wnydq+wWRW2apYIzXwHfFRidyEHFG0chBLwLThHEGgHiiwXJVpBsyd46eczvGuj9QP5V'
    b'eM8bDKQDs/I//siI6hFRUwCxce99HwiitGlm3kebKVxetc5acX7HI15+4QkZnMMZKMC5ouXl'
    b'9IG1M+0hEIqUQOLxZ8xC3zXJ8Ve9NWnMCjulFOxbmKcozc/Pyl8/R8saBUj1UUMSk15WFd9i'
    b'et5StDDv6LnP97qU06tl3jAcuBcbTz1OOmf6H9ef214Il0EG+yCXcmZlbdPe/ZsL50+naFlu'
    b'Wiaw+De0PFHCqDF6bCqcv0QR3FN8cv0khTuTgAkgMKqGowLwkz7CgdkFvFTKikoTuNUriWlb'
    b'mWopv2vCx8/rmaJDVC2AwE6V3b7amVrjsSXUkGaHAs12FZimiM6hLFxh4LiogupDK0EFqsxj'
    b'9qhnZwomffhEE9G4R4WCwgWTXXL1ei54BY4tEbH1Vceb4JVny2HP9ouQPaoPJKeaNEsICvW6'
    b'DLBz8w+w4vEKrXeuHJkAkkVA+8Hho7pumrdwYsWG9w8e1l/oOVGzgD0HX7e55Zq3sa9FaiHT'
    b'7B3gwDcNcKbKBZXHHVC2T/NlIaGh0uzgsPbV0xjywGfrquCHWi+OIrQkLEvhLvCqtau/Kl1O'
    b's0hUiJoCzjtLHpeZ42rGWo2KzHlUXjKKrsdlj7Rq91CQf4hPZDDnoQwtPPn2TEhJs1DLtTCJ'
    b'64OmVLv75HNGRI8JPygjYE/Zn+Oqm74sVdmlEWj45O6MFF0J9bU+zez7p5uM2NCQn/B58Z3z'
    b'bkhKsUB8ApUWKCYunCDxQqI0etRt418/b0R2m6hYQJ27JB8XOCOouMDGE9Tw1AFmSMs0GzGd'
    b'Q1ZgwqwDh1oh3hasfxjW4Oqn8LqpRkSPiIoCPNCYDwy9l9ZTbRVAqGjCdEUKKUHB/HRv2/s6'
    b'Ki6oPIJjghHsEVFRgMrVkcbSBv9EvISYXqRoRVGu1mvvGcFsrMtsLnxkCofmHCyMzKAF6nN/'
    b'Bf7+DwwHVt6lvJyLnFmrZ+WvLTCiuk1gud1m/a45wzh40X/rdq4bLj3qBkZzONkGVaf7CP8G'
    b'yJ9GkP8g2uYNVg46SibxRPfcyZ9WaAk9IDoK+HbKNnRM03TB/QpoLTowrD8T3c+rhbi1zFa/'
    b'+No7Zs2lDUa3aa05DNv2/bqfy3d6PIhcMJsGFN2W+1qdkQT/3P3T7QDuWwIbElvQKnjcoeF9'
    b'n8zNy5mtrY93Hfp9H7uzcgIwRYo3pe6flvvmWS1rGCJyggVFD9xo95Tsd/HqL53K6S8croOl'
    b'mwsfapmGuIrbt8vW+Ba0OYLYWvTYNXWNhcVO9dS/XUp1QYPrSNnmwnl3aolhCKuArw/+weZW'
    b'6j+UWcNgjj6OY1tVsGe6lbNrd5T8JlnLhOtefat7+UA3IKSnDobKs1+LDvn033xwcQTXttw+'
    b'lNLR363U/n3rviWDjOwhCasAp/fsTSo0Z+m69veziO7OOdjuqRirxTFBZB1PNmLOkLTrlNLq'
    b'd6708cZcCutDkJok4ErB2VfmjbdRfGeEVYDK3Gm68wnMimFssElKSPAHo7yxDIvf5ERmjWMo'
    b'pd4xgcOQOkRJ1Z9DE1YBuMJTafLp2L+03TVprUZZ0AdcZgsw2irhXhk3YIEtbwGHbNhxGVYB'
    b'ZFa0FQ1agwGqH73AZfYBdNSEoE9C6ULUHUGfhLcARDu6CwptdRAmog8InomidVHbQnEC7fPx'
    b'Hviqlr99uF0eAis2mtcuoYtEpIBQ/g2dX8D7QXwAas7dBOBy4BqOOsmQVVUYNDdwuFTnBfsF'
    b'GWQvDSe9KI8bl1T4DhkUNdrrRkdsx3WmBxMD29piciRcCAEjICIFhLQAwwBQWsX/6Id69+J5'
    b'GVY+cRSe+XkZfHfQCZIo4pgV4fsTCjw98wgsvmMfPDpjH6xZcZJXluvpe7bZYcWjR6GpERXh'
    b'ZPDh66fhT0sqoKFeMQ5XDeiwEBGYCe/dd8ARKSDkDGcIRKsAxtoeWNKQqDzWDJXH7dDgkOFI'
    b'iV077CRkWYZGbyM8+nwWrHp/LDgcbvaXlyqgGRutoDutOtmAVqJC4c4LfGdBDdy9aDBkDBLR'
    b'iloFwZK0wnAn2iPnE5kFGPcO+F0ArgMMeXTw0YsOuKz4Isy4dzDc+9gw2P5JLTQ2oJJQm/6c'
    b'V2RZYNT4JMi7OR3Ofd8MniYVhwIKJQlQUeri7646zh56ejjkXJfQeirWDhwJlBJSxHBEpICQ'
    b'+E2S7pzMUA/TUTgda+/cWAtjsIE545LA3uSCczVO7YDTT3WFB4p2XYTP11Vjvn6QkChovayi'
    b'8t74bTlmFCB3QgqYLJi53ThsWQeINBUHjo2u0TMFGHBO5zckj2ERWOrZk058UqHyyCU4VnpB'
    b'iz9xuLnNjPXeK6dg1ZITcNO0DHh4aTaYbZhspE+ZMVC7795RD7L2/YAW7EC3u96gRwrAXjCe'
    b'UD7W2jJFZnCszKE919XJan2tV+mXZoaS/9Whh8chYPisZS+PhHU7cuH+JwZCxhDtNB0vvaV3'
    b'LciEh5/Ngg3vVkLVMTdH39kG2gvQXVW8OK7au+DIiUgBoezLP/fjSgzF0yWk2aypQYXP156B'
    b'abMzYcHSYezBZwYLd9w3BA6XNMD5c76W9xJsAtiS8EFUtDNDaoWCzo8QLSqMn0IrWTOsf/sU'
    b'a7xEy28tqQ0CQ4cRSsSATglFRAoIPQ367zgetWfMiP/OJs4nTk+H8ZP7gWTCCYKpLOe6RJiI'
    b'pt5s9/G4OAlunp4BcTZJN3mjAvpMG2CBW+cO1NYFKakMlr82Cvoki3Cm2sv1PtdB69OmHTSE'
    b'UNJ1IngrYRVAS85Q06A+7kkY6jatJdiTAKkDBbbohaHwk3E2UNCpKTj9DbzSCoteHAYjxlhZ'
    b'+hUAi17IhiHD0bsbPU+oqI1rJyXC/KeGQkIf3NFhsWNvjIPHXsqGrBwL4yo1yFCWsTvzyg0+'
    b'AF9wCdss1IITNoOimk/rIgbWQTEq+GTXJQppK8IAZZOpMhHza3H+BH3sa2ZMH2T2uGkl/DkI'
    b'KpcLujJ1n4BbMSyLdp+6z/HLoQ8IXFq5URd6T7QBY5npjBEISVgFpPUdt0ditlK94tZLYn2O'
    b'pifl7qc8uqbbFeWXM5DAuGDpftqnBcmLilFLj+4RZl7/0QmJpXxjxBqXChLYaqxixhYtuhPC'
    b'KiAve6HHZs6+3wSpxQJY8AULmFnyAQtLv/uGkUtx1Y7QV8GXGbKHY8f0L4njpUEPmFjKfwWw'
    b'Yr+bwQQpx23mofdOzf1jvZahEyIW/NDRT0ynHFtHU2uz+t98OCfrYdqeaHzy7ez3ZHZuAW2d'
    b'Lw8cTKzftrk3bPmZEQG88QehoHz5GEXxmTISxx65YfRSWoiEJSoSf1G8MK9J/m6vyl0dh0LU'
    b'oeMZCyRIWbNnjl+30YjsNlGR9va894qtbNCDItgc+u9+OhvglN7ZFQoqk1x/gtfMMpdFo/FE'
    b'ZzV2mS1Fjw/zyPVTueBc7FHrrm1fPONiowjJb2EzXKin9nVzdPSCzC4u5iCnG3EGHMxCSqXA'
    b'E96UhKSdM/PfLzcSekxUFeBnU9H9q5vlk08awRZQATWSY9Swubeuwbk7OBu+nXRAZd5rjKAB'
    b'hzhx8MbZ+Z/ONiKiRkwGrCDw+BDDgKlxtfpJchC+3PYS/boiiEzaMjiyHxh0kdh4LP9iv6t0'
    b'5jpi1VnG/UcBqY1Wu53rIbr8qBRALSfTCfYtRKyIiQL8pzVdhuu/Eei494gdsbIAoy+7CFMM'
    b'CyCxuvF+N4iVArDcoD2I26bQDRNMaDi4tQz2Jm4EY2ISMVGArHhrOvYgzm8szpORco3XiOjA'
    b'9KkrFUmIc3X0AQxU1XvOCESVmCjAIqV+hstil35IQuA8jlWZhL7rJ456sdNNCq701goMp3x9'
    b'LCD0w8h4LDNlPYWiTUwUMGPcO4fjxUH3mITkSpHFg8gSms0s/a/Z6VNWGFlCMnv8hjVWYcBK'
    b'3M83UMNNQtK5ODHzl7fnrf3KyBJVYuppdpe/mmB3VY0UQKqfPm51lREdEf/Z/1wmZ55BVsn2'
    b'3aTRK7WTp1566aWXXqIKwP8B2GH9E3kb7IUAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
install_magisk_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'GUlEQVR42mNgQAOii7o8gfgpEP8nAT8CYg8GYgBQ4RMSDYfhJ8Ra8J9cPMIsKDy2/X/7uUME'
    b'MUgdTM+vX7+Yibbg/MunIA0EMUgdkgUcZFvw7tuX/6vvXAbTeCzgx2s4yIu4LKg5tRcsDqLx'
    b'WCBEyAIOXBZkHd4CFgfReCzgI2QBL4UWsBGyQIBCCxgJWcCHbMG3nz/++2xf+t9+0/z/Kism'
    b'gsVBNIgPEv/24weKBQRTELY4KD62A2umAomj+4AYCzBS0U8gLkKzBJS5fpITRLjyAciwnMNb'
    b'weJpBzf9//7zJ644YCbkAyZckQwydOO9ayiGY7GAlZAFrBQWFcRbQJPCDjmSycEkRfKQrnBo'
    b'XumT02wBqffEZh4AkxElV2NfgXgAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
install_magisk_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAACwklEQVR4Xu2bQVLCMBSGX2jZ'
    b's1DHJd6AG6g30AOI9gayEMeVunLUhXqCOnoAvYHeQLyBS0dYdOkM0Jg4ogULNi9p08jrjiEv'
    b'r/+Xl5e0zWMw5xebc/1gBEAtvKj58N6o+JVaEUDjQRz1goNHE760ACyGZw3wIQQODRM3g+jj'
    b'EYbQ6gbtDsL20wQNYCE8WWOedyf6KGTUZwlkjG++be3fYyCgAMiQr/r9B4sjP6k16g+rK1HQ'
    b'ilQhoAAs3Z5ucM7k6Jfm4sBbveb+peoNoQAs3J4fMs6PVJ3l3P6622wHqj5QABZvzkLhaEfV'
    b'WZ7tOcB9r9neVPVBAFSJyfYUATQFKAf8ToIMOmJfcIWZUgibbWGzlrSzngSxN4AQn5qDsP6N'
    b'rQLYGyAACAJpqxB2ACgCEANgdA7a9k8RYHsEbPu3EgEiickHqdXxdZw/Z32cdT4J6grQtU+C'
    b'txUBv3aSKssYAUh5GFMBSBGQIEBTwMYypDuHde1pCtAU+CFAOYByAIKAbhKybU9JMO8kKD+b'
    b'M5/XpwVXzNm2SD4bY/+Ll6oM+PE0m8og7rwGBy/yf90Iyj0CjH89FnD6g+r66Otv6QFIwsYg'
    b'TIh3IgJGIaYNIUW8UwC0ImGKeOcAoCDMEO8kACUIf4h3FkAmCBnEOw1gJoSM4p0HkApBQfy/'
    b'ADAGQfxIbnKyPJo4sRHKIkTuE2Q71fN9/wZAFkhpbQiA66/FsSM/sqMIKGMEiHPnM5/ndUc9'
    b'aZ/2PsH6lyGTAjF9EQA6K0yHpem0eIHH5c8vAPguJlnlZ8Muu829lmr/qE9jZSyZEcIDUTFy'
    b'XQiAz5edXv9JOKurOsypfbFFU1LEV9ncQ06CVLqNRNlcUGjZ3PeeXBZOeiCrx+xEwtfuEyte'
    b'6kDlgMnhWQ5P6rFfaYhSukKKKPlw+MLAi3QqRkcajABQideytZ17AB+xJCNuqSb/eAAAAABJ'
    b'RU5ErkJggg==')

#----------------------------------------------------------------------
left_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAq0lEQVRIS83VwQ2AIAwFUNnA'
    b'ERjFDVzBFZxEN3IER9LWAOEAbVPaRBNOxv9A2xom5ys450818CTMFP0tsMFpZ1gn94o1J4gQ'
    b'eidg5xANgJteYF1p9ySiBcTICCBCRgEWsQBIpAVwlSe5Xz68F4D9gYjZqMDGO6rm+8KtgG64'
    b'BUCGjwJs+AggCtcCER7Mw65US692tY2Gw27NpUg1hhaQNJtZmZKY6f+3JbkDLyQxMBm8anwF'
    b'AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
lock_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'wElEQVR42mNgIAC+OJuxAnEOEJ8H4l9QfB4qxspACQAawAfEh4D4Pw4MkuOjxILVSIZtB+Ik'
    b'KN6OJL6aXMONkQxpxSLfiiRvTI4FTVDNT4GYBYs8C1QOpKaJHAvmQzVvwqNmHVTNEnIsWADV'
    b'vIESNfS1AKjQDogf4UmWhDBIrx0+C+5TYDgM38dnwX9q4BFswdeEUDCmiQXf1674/+vXLzAG'
    b'salqwdcof7jhMAwSGzoW0DyI6BLJoxmNboUd1YtrAE2GUQuzQaCBAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
lock_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADzUlEQVR4Xu1b3XEaMRBeifG7'
    b'/Zbx+QFXYK4D0gHpAFcQU0GSCuwOQiqwOzCp4HAFucyETN5yzyZI2YXDY7gTXul0WAnSk8fo'
    b'Z/fT/mtPwIEPceD8w6sAkEH3GGDeXYEv8O8/eQq/8te4jL0BQExL+fhegxggo8Q8Mr41NEyE'
    b'0BOl1Jd9AdI6ACvG5x80wLCWacO1I2E3F2o2alsqWgUgg6QnJNyWN+7CS6EVvE1hNnVZzFnT'
    b'GgBZ53QgtPhsc+smgrUSCMKPCYch2zmtAFDe/L0P5tcMoSSkbUiCdwBI54WcZzvEfoqHTpTQ'
    b'X2Eh0PIvCujIntRwgQaS7ETpHSp3ieqwQBD8egvvADzIUzR44qNBFMdaHY1SyAuTqD7I5BoN'
    b'5pVpfU/NLm3FfNd8rwBk8KYrZIduv+LitNDv0sXPOw7xGZz1hdSkQpWBUnDuUwr8AiCTK9zw'
    b'eptqF5dmkgSUjlGqZjccIDlzvAIwFck9xpb9rYNzFHvUXbPYmwidyuRbjU0oUA1OOMxx5vgF'
    b'QCZ4QZvD5fbXO5jsCQJ64gJoHSDeAChdH+n/xrDR/e21ZSxBgdTmnh5dokcA6g1XE6NVutTf'
    b'VQD8BUb+AFhFfpXbQn1tdAbagYpaaQGX6WI25uj4S3MaEfd8c5O4RgCiBEQVaKRmQdqAZUmr'
    b'89gvE5ju0hZoTGKqQRD90tRYDSuGDCtHeFZO/0d0C0qsuGF2TZzykp3c/L2M0ynPXzEezigw'
    b'5kDvwMs31mRbiWcbeb5v/GzrBlYAGGJ93zw03S9H13vO3YQNgCkq4x60z3k20acFAOYcfZ/M'
    b'cc6yyT/4ABhCXQ5B+55jEypHALi3Y4r1uev3OS9KgEW2GFWAK5pRBaIXqK/4cCWoZh49juSY'
    b'RBWGJMp569CNYIE1rk+gjsbPK7uZ4U3BBYWQAdj53O0r3A4WAM6rjg9jGy4AzAcNrAJRKbza'
    b'QsPUh1ABmGKamnJ4aJp2/wcAnN2C0NRM5TRCBYD9qGl4FGWDESoAwCEs6yRDoYFqjs6Dc451'
    b'TdCHdcZDOW6QnsSdDSAxFjIAS+DrCCyrzfS22Ij5fwKAJ9nWAltm9DGGwj0fjK/3DV4CnJWb'
    b'uTACEAsi/P6BWBFiqhV4coPc4xrNizYg2oCDtwH8tly+EVx1gVda1hopa0uLW3kcJVoxS6NG'
    b'SIraQh7tPI8Tx2U3OCUrwQ7br0vYKrDm2GfS4hlFbJHBTnLLBkprAFaSQE1S88GySUqLrmdG'
    b'rLbDz+xyBfAd1OLO5TsCJwCsKAx8cgQg8AtqnbwoAa1DHPgBfwHkTDxf072RiAAAAABJRU5E'
    b'rkJggg==')

#----------------------------------------------------------------------
magisk_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAANjr9RwUqgAAACBj'
    b'SFJNAACHDwAAjA0AAPmTAACE5QAAe4IAAOt1AAA/tAAAIlh1a16cAAAEDWlDQ1BJQ0MgUHJv'
    b'ZmlsZQAASMeNVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Y'
    b'yc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58'
    b'853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99D'
    b'wntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+'
    b'fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOn'
    b'z5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+k'
    b'rbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrL'
    b'e3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMO'
    b'Wy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++'
    b'DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D'
    b'+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyy'
    b'E2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdR'
    b'tuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHk'
    b'Vw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKR'
    b'O8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r'
    b'+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86Ei'
    b'lU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqW'
    b'muroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjP'
    b'ygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8B'
    b'oJ98VUXmXbEAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOWxu2j4AAACMZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAASRkBAOgDAABJGQEA6AMA'
    b'AFBhaW50Lk5FVCA1LjEuOQACAACQBwAEAAAAMDIzMAGgAwABAAAA//8AAAAAAABf2JFReNPH'
    b'KwAAAwxJREFUOE9dk0toXHUYxX///73pvGfuzOReXFiSCEWCYEoGjbqwUAlVrJDQlZhkZVXI'
    b'QpAIEbpRFKoTF8XOJlCRTHUjRLHQ1tg8FmpbncYHjZpAiEnRTHPznLkzk3nc+3eRJgS/1cfh'
    b'fIfD4XyC/01zNp0qeN5ATWgnQbXtoWLJp9ypiJRj6/1v3znMF/vLQ5dH/K5S523PHWzRmvQe'
    b'b4NFAkiglQpfyyQrjXrD1LSMJsRwvm9oF0ADMLNpP0p9aXvuwLmWdvnJiR7C+Vl6qz9ykmWa'
    b'jWO80/0agVJRfrttPxVEdATPnBovj0+4EgClzq8JcfqNYoFTiwuYsTg7Zoqk9w9xL0/BStEc'
    b'M3hhcZ6zTpE1IV7C8z4EkGY2nQIGEYJkA9onx8jdvEHcsNjEYJM4ccMk98MEj01/TqIOCAEw'
    b'aGbTnVqot3sYeDoiFP86BpXSUY7kf6dwtAUcm0KTxZqvler1b7jmHudK0kKFGqCQwK4W6u0e'
    b'UWC5KM4FTTK5EKO3EiwWbayHG+RVgNGrVTI3LO774rzZGeYaDhKBgLAwxz5ygJCNx3VfG8bu'
    b'Ea4ubTNn7FIxN1EIwnaC9m0fp9sMbH+VF6t/YyIB4eyFCOB6TNe36Iom6OoI8Udpntzkr/w8'
    b'+Qtz5QWe6QjzRDTBdH0LXO+gAVqot/tlwAoqxd37q5TqJTJ/3uHezE8kn3ycaMIgP/E9Ob1G'
    b'Xta4tHGPYCgIUgIsSGAKQOg6VSPC6Mpf+HbKfPzeuzxSUxxTOhfe/4C4U+PTlXlqRgR0fd/3'
    b'pDCz6RRK3QL0Aorj/iCXTvRghmM8+2of/qYmpkezLG/Z9M18xXK9RmDPfgMhuqS91+0MQBTB'
    b'7VKRz367iVOtYASCNEdj2M4OF3IzzFUr+8cAF+3+oVkNIHTm+RmU6gAeDUvJdzvrlAubbK2u'
    b'oWJhbntFvlhfxdIOrF9BytfL4xPugZx5ecT3oJ6DgG6jsPIbuH4fG0YEC4GCBnARTRu2X3mr'
    b'yuFvPBDKpjtRagDEc0DrA3gJmEKIMbt/aPYw/z8cpjvnvOQMzAAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
magisk_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAE'
    b'FElEQVR42pWWjU9TVxjG+0/AWAXWUj5ah0wNQ3BkH2RilmzLxIEMZQ5wtnwoGGYFoQgIFGjX'
    b'DpSvodb13kuxKIoEnS6goAwHbmoyl5CZmI24hQ02zZQyHH127qGdN9db6k7y5J6c932f3+k5'
    b'955TmWyZFmBvjCKqJrpKNEMEj/j+EFElUYTs/zaPcZ/A0J/6+ZpnNdcSzQsNMpg8VDLpWGE3'
    b'ItRehyrS/4DJF0P+Jsr1Z270FoR2WcH8eAuz83NIc1ZggVPgEPseWtl34eLCsLmnCjOuRzg+'
    b'eRMhnEUIqvFlrvMmBRIVdB7EY/ci+LZr9Bz62CTc4WLwC6eBg01G4dfnaWxhcRF5ndW0RgDR'
    b'ic01wmXRGvMx9WEizN+NUJO2HyZgZVPwExeNWS4KDez7sE3eoLHa8UGam1NfIATwXmoh4Ixw'
    b'PU37M/FP2lqUVX+MGzO/4supO9AzmRTAaxeThUv37mLit3uoPpBFc2sN28V7ctZrHkHkFgaj'
    b'ShrxjXYD5tJjkUOW6ue/7iO5az/ucqsoIIkzYOrhA2R3VMG1JRZjumRElJqk3q5wHlAhDiQU'
    b'tSI89RDe0pejWZ+Bckczdo6cxSCbiDE2HvlXB6DnPkPL3gxs3GsguYeRUNwqBajkAZeFg0F2'
    b'E9qZbmji2rByTTt9atKasMbWBDO7GTXMFtJvhjq1CZqX25dy4ttwjD0hBRjmAdPiwOzJr/BO'
    b'Qwc06zwQ8nzBYsF2RodMJhcKs/XJBIj5JlMHpnsuSgGmZeL15/Wtsx/3CaSJ60LhERuKGBtW'
    b'MlYk2EsRay9HNOnvIWPFnx9HC+fAA5I7TmqkvnLZU4NfNMDk4DB/cpCqs7sb8qNGBO9IR7Bu'
    b'K4LztiFYmwG5rQFHSMybV+dgaK0UQHiIQa7fiUjGgsmecxh29iHQVg/FhlcRHh6OsPhYhK2L'
    b'pX3Fxtdp7ArJue0cQBjzKeT7tGLA7zLPqfhkk00lCNm2CUprOTS1empEDXdnIbCzBgHHjFAV'
    b'fPQf5EVjCZSWMoRkpiDIXCIGXOYBVeKfFWTaB8WbZNYREVC9tAqrDUVovDUK5WvroXwjEc3f'
    b'X8PaskKoVsfQHD6Xr5HYAwMPiJTaHDlrpu+7dqQf03MPsXv0PJ21Sq2GYWIIf8y7UHF9CJ9c'
    b'u4DnGJOvYzzK+zWflkpIuXgCbiy11AGOAnhlD/fRsbnHC3il76gv81PiC8YllXjg+iVqlj3Y'
    b'uwSIjETx2AUsut3IHOr1Zf6IXxnxiZrj68biT9P6m1egiomGcn0cWm6PU8gyN1yO3wtHrLjT'
    b'nVAkJSI07W2onYeXM6/zd6vtIJqTKuZfRXlpri9jl8+Z+7j0z4hNnj+4BwE2o5R571Nr/owg'
    b'NVEZ0Qj/VQoM//ScwgZ//yb+BTOAYyqbeEyTAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
magisk_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABGdBTUEAANjr9RwUqgAAACBj'
    b'SFJNAACHDwAAjA0AAPmTAACE5QAAe4IAAOt1AAA/tAAAIlh1a16cAAAEDWlDQ1BJQ0MgUHJv'
    b'ZmlsZQAASMeNVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Y'
    b'yc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58'
    b'853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99D'
    b'wntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+'
    b'fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOn'
    b'z5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+k'
    b'rbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrL'
    b'e3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMO'
    b'Wy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++'
    b'DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D'
    b'+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyy'
    b'E2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdR'
    b'tuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHk'
    b'Vw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKR'
    b'O8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r'
    b'+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86Ei'
    b'lU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqW'
    b'muroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjP'
    b'ygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8B'
    b'oJ98VUXmXbEAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAAjmVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAEkZAQDoAwAASRkBAOgD'
    b'AABQYWludC5ORVQgNS4xLjExAAACAACQBwAEAAAAMDIzMAGgAwABAAAA//8AAAAAAABSSf4x'
    b't/ln+QAAEE1JREFUaEOlmmtwFNeVgL97u2d6HprRSGL0REgCyyAEtiAYL05sB2NwADtJKXZi'
    b'G2KnNqnESWVrU0BtvFu768R5uQzEjnftWsfZZMugTWLHkHVCTPCLtQEbA8YIsHgIJNB7Br1H'
    b'Gmmm+979oZEsjYQiZ7+q+dHnnNt1zu3T95y5twX/T8K/edKLbRcDC9G6ClgIlKB1GPCnzAYQ'
    b'IgpcAj5EiOPAh5hmc/Te78TTbvmxEOmCmRKu2T4HpdYCq4Ab0Lo03WZahGgEjgCvI+Wfohs2'
    b'N6WbzISPHUC4ZnshSj2E1vcAC9L1fwUaOIMQL2LIZ6P3b25NN5iOGQcQrtnmR+kHgIfRek66'
    b'XgBxoB+BGwih0eN0XQhsIIjGk/J6EkJcAh5Dyh3RDZsH0tVTMaMAwjXbFqP0o2j9+fFyDSS0'
    b'xhDQjSQbWEGSyxicRJKbcjOCoApFIQ4HcdELhFBoDW4xhQtC7EKKR6IbtpxKV6UzxeiJhHdu'
    b'W4dSzwAlozIBRJQCZTPHdNOK4Nt08VVZS56I0Kxn80O1jF1YANxLnH+UR8gX7bTrfP7DWcxz'
    b'IosCFE12AqRJrpTpT6URKb8V3bjllYniich0wXjCO7Y+iFL/Pd55CUScJMtdbp6tXMH+9Q+y'
    b'/5bPcY4ASSzC1LJE7OZheZwyNItQPCyPcp14mVxOEdcWl40gh1ZWs3/tAzxdcSNLTJOIY6c7'
    b'U4pSvw7v2PrARPFEjHTBKOEdWx9E66eAzPHyiHL4UnY+j9+0lvULlpDl9VOcmU1dVxdPd8Jt'
    b'piCLbvJFJ53MY4mIcbfci8DknP4UDyaWsn7uEr64+AayfBncMHsuy7LyiHZHODo0gF9MCMMD'
    b'rPJXr2kd3P3qifGKUaZ8AuEdW9eh9c+A4KhMAH0AyuHzpRVcX/jRqimE4Lbia3hHuXhVVQJu'
    b'DCKsFK2sFC0IetB42aMXckK4uWXOvLGxAJ8onsdn58wHxyY+Oa+DaP2z8M5tayeKR5gUQO7O'
    b'bYvR+pn0mU8AFVrzx4v1XDz5Lo29XePVlGWHWez18aoKMcgswE0RXeTSBbjoJ5c9Tia3+gLM'
    b'Cc2aMPZc9xXaat/l5UsNFAPJCVoYeefVM7k7ti5KV0wIILxzm19r/ej4nCc1Iz1S8o1IB+tP'
    b'H6H4/EmePv42w7Y9ZhPy+FiSkUmHA0kswEEhcJCATRKLVqVYHMgiYHnGxg0mEzx1bD/l9ae4'
    b'69R7fO1KlG4p058CQKnW+vvhmp+OVndIDwCtH0hfKgEiQnCrbbP24llwEny6o41j547z6oWP'
    b'VjnLdDHbFyChVUqSJI6VCmZkToeUJt8fwDJdY+P2nKvlfH0tN3e0gT3MXQ3nWOY4RKZaXqEa'
    b'5WwcLxgLILdmWyHw8HjlGEKweHiI7P5ucHkpjjTx1Y52vl97kPor7QC4DJOg5eGwlgySAQyT'
    b'wMTGABLEdIAGJEHLg8swAfiwo4Xvn3qHb7a1ktfZCm4vs/q6WJgYhqkDAHg4vHN7wejFWABa'
    b'6YemqrAAKM27lpe20CxQNloa3Flfx7xIK784+S5DySQuwyDsC4AwadcjOW4jGV0cW8kBTLI8'
    b'fqQQxIaHeLr2EDdEWlh9sQ5tuMCxac0Kc8TtwVJT1mrQuhStvjF6KRltzLS+e4LhOPK05uiA'
    b'm/+69jpigRDCscnsi/LI+TMcvlDLy2c/AKAiJ58sw+JDHQZAa4mTyuZaNYtit4eKnHwAdtW9'
    b'T0PDaf7lbB3+WDfCSdCbmc1z8xZR128SSi9r49H6nnDN9tmMPYGRrrIi3W6UpKkp6oSf9Oby'
    b'g5tWUl88F+WyqKg/zvYPa3ni2BscbbvMovzZrMzM4W0nhE3JmAtxruVtJ8gtoTAVeUUcaLrA'
    b'r97fz+Ona5nbeBLH5eFsSTn/etNt/KwzTGGvIGlMEwBUoNQ6ACNc84QXpTYBlelWpPodlxS4'
    b'keTvtXjZ7+OD+QX0FeSiglnM67zCwlg/P3cSrChdQKZhsq+5kdVGD70iiImNg8Uv7Xk8dP3N'
    b'eCwPj7+xi+/WHqE01s2x8kpeWngdPyqoYNf5EAuOGLA0iXZrlJ5UE0YRQNx/92f+aPirV89F'
    b'810glG4FcAXNLcLNOn8Gp9tscve4iPRZvGBl8Xp+Pu8XFxOyDAo6Wzgy0E9VWQVvRTuosluR'
    b'wsRA0648nAhWsa5sAbsP7KHy4knaQ7N4sqSSp9ylvNScg3nQQ+FrBnKpw8aFPmzlUIuD/2oh'
    b'gA942fBXr7kZrR9K144yiGaFsLjfyqfW20fTKUlmlyD3jISTbs41e3khkU23O8SVwTbqh7qI'
    b'uXwUDEXJFBqQnFEhGjKuoa6pjvqGNg70zuG5i2G6D/vJeNtFQZ3A3S3o8Wuq1moeDOVy3O7n'
    b'NPZ0AWQh5Gsy9TdwWuJaUaJ9rC3003xTApKgfeAyNLPaoPItg+7f+jj1ZiE1F3vY29dBRGQx'
    b'gJsYbtpkFr/vaeXXF2KceK2Q3t96qTxokNMOLlOjfYAtaP3UMGvzAxThI85oPZkOXSVT/2Gn'
    b'QRBHodDcbRXw6RsVjYttZK9AJEeyUfs0plcTeFMSbrFAQiseerVFLxYtekQWbrIIvCUwfRrt'
    b'HUlwkQTRI6hfmuDOZfA5Vz5KK4b+YgACEBUyvW2Yin4UfTpJgfbx46w5zF+b4NSqOLGgRhma'
    b'pNR0BBTR+4cJLHBwa0G7dhHBIqo9tOMipAWBSpvIvcNEMxRJqXEMTX+m4vTaOMvX2HwvWEJY'
    b'e+jWSbqnDWAsrUoNf/XqfwKyJhp8hEr97pBBiqWXAuHhJo+P7OIhmsrjnC5PYlXarL5BcnuF'
    b'heFW1CqbfDR+oYhjUoeHFi1Z6bFYU+YheK1NXfkwlyuTXLPM4evzvfyDbw6LRBABnFb9/MLp'
    b'RgCuSe/AuGshhkT4+cc7gNzxJuNRQCeKHa4i7nPNxkFhIBnEplXE6cUhA4N+leTFRAc1KsYV'
    b'ISlHUaCTaDSXhUUTgrDWfFkG+IKVh08YDGiHTGFSqL34MLBRSAS/SjTxdbuVWRhp7qcHQ/uk'
    b'djqdkb5QU+vEGNQ2AoGNwoPBtTrAMh2ix07yyNBltusYcaUJ9/RxpW+Qw7g5jEV/3yA5vf30'
    b'a81jqo8fxy8xYDssE1mU6wwsJMmU8zFtc0L1AwIx2eFJGP7q1d+6agppjUCjpaRVJ7jdCFIo'
    b'PTipGuug+UOyjS8mGjktNfn9cQIH3sd65RDWqXosrfC1RPDuPYjrWB3WcAJvXg5H3YLddicL'
    b'hUGZ9I/tUbiQnFR9fM9uByFx6VQ1FmKq2Qch2g1/9Zr7gaJ03Siujk5cPi+XpSakk3zSzMaN'
    b'wERyzOmhOtFIvyEpGBjCt+ctzP95FxJJ5LlmBArjchvyvXOQdDCPnsMQCk/pbCKWydt2L7fL'
    b'DIqkFwEMaMUTiUZeJ0GWA2a0C5XhndT1jyHEOcNfvWb1VdsIw0AODeNqascdzuFVPcQcbTNf'
    b'BtDA1kQjB2WS/GEH794DmG+eQAc9EM7EWV5B4vYbsctLEF4TmbRBgHG2GWmANXc2bQaEVJJb'
    b'zWxi2uGXicv8QPcQRmKdbUAF/Th+H+JqbZEQBwx/9ZpK4NPpOgChNcrvxWyL4G6LInJnsduI'
    b'M6wGqSPGEyJG1sAQvv1HMF87hnCb2OVFdN29CrXiepxQECc7k+Sia+ick4fVcQVzcBh5vhnD'
    b'60IW5nHKArdOstuJ8APRS5aj8X9wBoQgUVaEUHrq9AEQ4gXDX70mBNybrhtDCJycLFznL+M/'
    b'cQaP18M+NcirPe3kXmzFv/8IxoFahKMZvCafxD1r+MTcMhoGBjBdJlrAgG3zpfIFNOWFGGi4'
    b'hKcnjrjQjNUfw5aCl5w+3ksMUNjRTWD/EbRpEF9aAUJe3XkAIZ4U4Z1by1F6H3DVzVktJcJ2'
    b'8B7/EPcbhxFNPdAzDAwDJiLooW9JGfrOW/j3dfdwobWFh1+soaisBAyDlkuXePa+v6U4N5+v'
    b'7X6exO/fIPtkCzo2NLJIGG50yA1FIRK33Uh8SQXakNPPPqIBIe4w/F9cG0ep5Vd7D0ilElKS'
    b'LMpDzS8lWZRNX34AV1kBelEpV25ejLp1Gc+s+iyrr7mOp04coPPtIwR3/y+uw6dIBLxkzC/j'
    b'28tXsTCcxx6/oi03QEZhNoPF2XQvKMT6ZBXxVX/D8LUlIwuons55QIh9SNfzxuDv/mz7q9dk'
    b'A+unHzESSF+Gl7lzS1m+tIqLJTk0lRcTKC3mP2/6DF9YtJymnk4erT2E73wTxrk2xGASY2Ep'
    b'rSW53DdvEcuK5rIkJ5dTlk1LaS4LPnE91bet4mI4QMTnwa1GW4hpXdFI8VR046b3RtYnKf8E'
    b'nEm3mgrLUZwdGmD93Ap+v24jv1uxlrfW3MfnFy4DoLm3i6FkEiOZRHhd4HNhJmz6h4foiPUC'
    b'sGpeJS+vf4A37/wKNZ/7CgGvj7rhOL6ZOQ9Qh5CvMLrARjdsbkKIF9OtpsItBEkNz9UdJceb'
    b'wRcWL6cib/aYvm84Tr9yYCiBNgQYEhkfImk7xIaHxuzyAyGqCkuobb3EP1+oJTu1UzED50GI'
    b'F6IbNjUzoUJI+Wxqf35aNJApJW8NxfjJob1cifVN0NvKAaUgYYOUIAUkbbRSqNHKmuJ4SwOP'
    b'HNsPUjLi/oycb0DIZ0cvxwKIbtjcCjw2ZjgNGphluvlF9DL/dvQNBhPDYzqfyz3SQUoJWoPS'
    b'aJeJZUgyxu3IXeqK8sN3/sz7ySFypYGeifMjPBbduGlkM2pSjZZiB0LsniC7CgLIcVk82nCa'
    b'nR8cxE7lb7Y3g0zTRHtc4CiwFY7fg8vykO3NACAa6+VHh15hV38nuaZr5s4L8RJS7hwvmhBA'
    b'dMOWASHEI0DjePnVMBCEDBffOP0OL508DEB+MITH8uD4vAhbAZqBoJ9rM4LkBoJ0D8Z47NBe'
    b'notcImxaH8N5GhDikeiGTYPjxZO6pMjGLSeRxreAnnRdOjr1Ugtp8u3j+3np5GFCXj9LM7Pp'
    b'D3gg4YDHRVdWgOXZefQNDvKjA6/w0+bz5Li86bebjh4h5DejGzefTldMecAxuGtfvb/6jrbU'
    b'EerIOdE0+IUgJuBgeyPu4WHahwZoaGvDd+ICelYQ9ckqwlkhDlyu5+n2BsIua6bzDtCLEH8X'
    b'/fKWKVN7ygAABnfvO+GvvqMV9MrUScm0WEIQA/4QbaFd2fiGEpgfnEXPDqNXVPGuneD4QA+5'
    b'pjt96HT0pJyfkPfjmZRC44l+ecvzSHnfTN4JnQoix3QBGhUKQrYfp6wQx+clDIQN13Q7nhMR'
    b'NCDlvdM5z18KACC6cctepLwLIXal66ZCAobWOBl+VF4O9rxitPwYCQMgxO8Qxl3RjZv/nK5K'
    b'56opNJ7BXfsi/rs/80cQTQgWXW0bcgwtwDQwEkmSc4vRrtEq+xcQohEhvospH41u2DSjE/uP'
    b'OTUQrtlekPapQdo9UpcC5OAwymNNskhDg6hD8AJS/jy6YVNbusF0TH/raQjXbC9O+9ijbEQz'
    b'7pZCjFTjKRENCP0eyNeRxivRDd9pTreYCX91AKOEf/OkZ+RzG12BFlWpc4ZSYBZajxzICTEA'
    b'RFOLQR2IEwjqhGk2Re79+486vL+C/wPO04FVSMf8GgAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
magisk_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAANjr9RwUqgAAACBj'
    b'SFJNAACHDwAAjA0AAPmTAACE5QAAe4IAAOt1AAA/tAAAIlh1a16cAAAEDGlDQ1BJQ0MgUHJv'
    b'ZmlsZQAASMeNVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2bVjShtLp/3d02bpZJNtoi6GT27s6Y'
    b'ycw4M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58'
    b'853vnnvuuWfvBei5KluWnhQBFgzXlopZ8bnDR8SeFUjCQ9ALg9ArK46VqVYnAZunhbvare8h'
    b'4b2v7Opu/8/WW6eOApC4D7FZd5QFxMcA+NOKZbsYXz/y40ddy8NeDP02Boj4RQ83fex6eM7H'
    b'rzHNjJRDfBqxoKhyHfES4pG5GN+MYT8G1vqL1KC2poheLqq22dB0Ggv3Hub/2Rb0VjjfNnz6'
    b'nPnpQ/gexrW/UpfzHh5FvKTIhWnEjyC+1tZmKwG+bblZCfFjAMntrflaBvFOxKWGfaDm+0na'
    b'aqsU4ndOqDPPIt6C+LwxV5kKxl5VnBzmDLYjvq3SspffIQBO1NzyjD+W22+b0pQ/L9eo03zB'
    b'yyPi1+fNQ5Lvk/vMaU8XQp8n1Fwl4C+9JB+sIh5E/AvVi5I/F/eP5VaDGMiQoVcm/blInjps'
    b'vYx31ZmSPy/RXdxQfyxZbGgHyoH+E9UuSQG+ZumsRjE2Pmm3pJqv50dlu1D0ffJVatQC/3wb'
    b'ZhMyUDBhDnsFDFgDESQoQhbfFthoaYAGOjIUrRQZil+hZhcb58A88hq0mc3BvsqU/sjIX5P5'
    b'uM60CuSGPoIWsir8jqwa0+Xwq4VccxM/fiw3Aj8mGSBpsgefvWSS7CPjZAJE8hR5muwneWQn'
    b'yN71sdXYirx4bqz7eRlnpEw3i7pzaHdBxv5nVJi4pq5ZWRxsDUeWU/YLmnL5jb9iudJYbqJs'
    b'xTM6da+c87/y1/ll7Ff41UjB/8iv4m/ljrWYd2WZhtnZsObuqgzadMYt4KMxixOLO+bj4smv'
    b'Hoz8LJMzz1/pu3iyYSwORqyXBfpq5VYFTo1EbPqH9B/p5fR76Q/Tv3Fvc59yX3Ofc19wl0Dk'
    b'znLnuG+4C9zH3Jexvdq8htb3nkUexu1ZuuUaq1LICluFh4W8sE14VJiM/AkDwphQEnagZev6'
    b'vsXni2dPg8PYh/npPpevi1VA4n6sAG2Tf1UNVRocZUqH1ZsBxzdogpFkiIyR8obqHvdqPlSk'
    b'Cql8KgNiamdqIjWWOujhcNbUDrRNYF+4ozqVTVZKXXrMu08gZ1rHba2puuLudPpJMYNXGxXL'
    b'hjI6Isq6LjKTI9rUoXab1kfBuzf9I/2mxO7DxJbLEec+A7DvTzz7vou4Iy2AJQdg4PGIG8az'
    b'8oF3Ac48obTsdnBHJBLfAjiNPbv9r74snl8/dTo38RzreQtg7c1O5+/3O521D9D/KsBZ/V+g'
    b'n3xVg3tulQAAAAlwSFlzAAALEwAACxMBAJqcGAAABrJpVFh0WE1MOmNvbS5hZG9iZS54bXAA'
    b'AAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlk'
    b'Ij8+DQo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9i'
    b'ZSBYTVAgQ29yZSA3LjEtYzAwMCA3OS5hODczMWI5LCAyMDIxLzA5LzA5LTAwOjM3OjM4ICAg'
    b'ICAgICAiPg0KICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkv'
    b'MDIvMjItcmRmLXN5bnRheC1ucyMiPg0KICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0'
    b'PSIiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpl'
    b'eGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1sbnM6eG1wPSJodHRwOi8v'
    b'bnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2Vs'
    b'ZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90'
    b'b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9t'
    b'bS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVz'
    b'b3VyY2VFdmVudCMiIHRpZmY6T3JpZW50YXRpb249IjEiIGV4aWY6UGl4ZWxYRGltZW5zaW9u'
    b'PSIyMDAwIiBleGlmOlBpeGVsWURpbWVuc2lvbj0iNjAwIiB4bXA6Q3JlYXRlRGF0ZT0iMjAy'
    b'MS0xMS0wNlQxOTo0NjoyNyswODowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjEtMTEtMDZUMTk6'
    b'NDk6MDUrMDg6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjEtMTEtMDZUMTk6NDk6MDUrMDg6'
    b'MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90'
    b'b3Nob3A6SUNDUHJvZmlsZT0iR2VuZXJpYyBSR0IgUHJvZmlsZSIgeG1wTU06SW5zdGFuY2VJ'
    b'RD0ieG1wLmlpZDphMmFmMDA1Ny0yMTk4LTVkNDItYWRjNC01MDgzMmE1ZDc4N2UiIHhtcE1N'
    b'OkRvY3VtZW50SUQ9InhtcC5kaWQ6MDMxODgzNWUtZWFkZi1mYTQ4LThkMDctZTc2ODkwODdk'
    b'OWQxIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6MDMxODgzNWUtZWFkZi1m'
    b'YTQ4LThkMDctZTc2ODkwODdkOWQxIj4NCiAgICAgIDx4bXBNTTpIaXN0b3J5Pg0KICAgICAg'
    b'ICA8cmRmOlNlcT4NCiAgICAgICAgICA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0'
    b'RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDMxODgzNWUtZWFkZi1mYTQ4LThkMDctZTc2ODkw'
    b'ODdkOWQxIiBzdEV2dDp3aGVuPSIyMDIxLTExLTA2VDE5OjQ4OjE2KzA4OjAwIiBzdEV2dDpz'
    b'b2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjMuMCAoV2luZG93cykiIHN0RXZ0OmNo'
    b'YW5nZWQ9Ii8iIC8+DQogICAgICAgICAgPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBz'
    b'dEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmEyYWYwMDU3LTIxOTgtNWQ0Mi1hZGM0LTUwODMy'
    b'YTVkNzg3ZSIgc3RFdnQ6d2hlbj0iMjAyMS0xMS0wNlQxOTo0OTowNSswODowMCIgc3RFdnQ6'
    b'c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIzLjAgKFdpbmRvd3MpIiBzdEV2dDpj'
    b'aGFuZ2VkPSIvIiAvPg0KICAgICAgICA8L3JkZjpTZXE+DQogICAgICA8L3htcE1NOkhpc3Rv'
    b'cnk+DQogICAgPC9yZGY6RGVzY3JpcHRpb24+DQogIDwvcmRmOlJERj4NCjwveDp4bXBtZXRh'
    b'Pg0KPD94cGFja2V0IGVuZD0iciI/Pur4LEQAABjCSURBVHhevVsJnBTVnf5eVd89FzPTPczI'
    b'fTMccsglYkDl9IhiPEENUdZkjTECZt39uWaNJr9EBNREN4lZPDiiq4aAiggEOQIIiCL3cA/D'
    b'cEzDnD3T0z3dXfv9q2tgBgamB3Q/qO6q1/Xqvf/3/mdVjcJ3DN/COa0Rj/Xkbh8YRg9+t+WW'
    b'w/1Mfju4CSJQqpTfp7gVcX8voHZAV7sD902Ttu8M3wkBvgWzelPACdzG8rAvv7MTv7QQSp3m'
    b'5zf8/ozb0sCk6bsSP3x7+NYI8L33cgrqondQ2B9xu5ZN9av7bUG0ZD23ucpmW1Ry78+rrfYr'
    b'whUT4Hv3ZQ+i0Ycp9OPculrN3y2U2s/tFeWwvVly989rrNbLwhUR4Jv/0p0U+nluYuP//1Bq'
    b'NzTtGZrGIqulxbgsAnwLZ+UhFp9Nwe+xmi6JCLcKcyjZDPi4NYVAg3MyuNnN1iSg1F+h69MD'
    b'9087YbUkjRYT4Fvw0jjEjTcofBurqUnUGAbcSuEMh9AozGSE0EWFcNhwYy68JCFunQlz7wzP'
    b'elQFcRVqUWB4sABuk4A09g1b17oklDoKTU0NTJqx3GpJCi0igCo/HfH4TO422U8aS+IxIBZF'
    b'psOF0lgM/6LX4Gm1AXnqCL3iGYrnx9z4rfipkcs9nit9oGOuKsL92hKeU44wslBkdMZz8aFY'
    b'EHchTddRGQkBuh1+Tb+I/piI0yRmBCbPmGMdNwvd+m4WvnkzReV/yd0LhJeGKq5SRTSMB7Py'
    b'MGvgDXhu0I0Y4krB08cKcb3uQG+1jWfJqtagrzpMIrpiJVyoZu/nmAI8pr1H4eno+akQxTLj'
    b'OjwXS8MnQ8bhN4NvwugMPyJV5dhcXQ6dJNib1gjFOY71ThybWrNoeVKakBQBvvkz/8gL/9Q6'
    b'bARz1Y04qVdYdM1oPDFsDLr5cpHicKJLdi6OFx/BvwftuEbLQXe1leelkIQz6MTP3xsd0Ibr'
    b'+QdtDVpRg+MkSJGS9+N3YVK0DabndsRPht6IVKeL12qNCZ17oY/NhYUnj5AiBddFzcK4NmXi'
    b'mJzqRSs+sRouimYJsFa+SeEF5RQgiyuyZuREjOraG3bu10PXNNjicSw8ugfLND9VvJbOrZg9'
    b'UihwEb1Cb1yvqnGz9hGFT6MXCGK/MQzfM/oB0Vr8dsBIdMj0W1djYqHb0Lt1W9yYloW/HN0H'
    b'gwRcItkY5J04JqVm0YoV1nGT0KzvJkHhp1P4J63DCyAWXEfV7+two6s/L9F4Hnq3bgfYHSgz'
    b'NHwez2dLiASIY6zAMBXAIFXCNokTgjg+k4hKI+/q8qJ7zlVWe2Pkk4SBvKY42nOutAkYxgz6'
    b'rYvOX3BRAvzzZo7jBcThNQlRvlKu8IfHijC6cB/mbluf+OE8+FPTcW8aM2EjirV0bmGWAcqc'
    b'tosev5zRoNzcV6RTYsAqI4M8RDG6VQ6yPKnmNRpCer6+dS2mHDmABSeO4ww17mKGYCIef4my'
    b'jLGOLkCTBPgXzMrjIrzB3Yt4Gto9hZ9WVYXbvl6HW06exJN7NmPjkX2JExrAbbPj6lZUY0aH'
    b'I4ad659qEaDxX4yb7Cv+i9ExpuIgbOa5fbNaw8Yxzsfn+3fg2f1fYfzxY5i4bQMerqlGyaVD'
    b'pGYYxhv+BbNbW8eN0CQBRjw+h6t/0Tgflg+q39SCXbDF6tCl+CAeC4Xw6JYVCAQrzXMaolMG'
    b'NYC+wEXdTggsiFLxnSTEyX0xpgQJbtF/OtUO0uc8FFeU4qatq/Cf1TVoR0foqg3isQNSOErP'
    b'S6KdEY/NtvYb4QIC/PNfmkjh7rYOm0QFV+aZygp0PbYPcbsbTsboB4uOYkd1BeZuXSMiNEJO'
    b'Srr5XWOufb2TjNPf2/kp6Y6QYvCfbp4jAmV7G6t/lAS+vnkVUFuDuwsP0blGObYLvQoL8Hgw'
    b'iNJLa4Es2H30abdbR2fRiADfwtkeqssL1uEloHA1CdCjEVPYuM2Jfod2YXptGE8f2o51B3cn'
    b'TrOQ4nRLF6q3zhVPYYusV5waoHNPCJGrRJlLpGKHTIl2nS59GmDlvu34zbECvEBhexbu5ZiO'
    b'RBQIV6O3aF1zBCTwgv+9lxtduBEBKh6Tqi6JwsbAYY+XE0h0NydSV4tHCig4s7WntqzEqaoK'
    b'8zdBuotjUqijFPa0eWvANCKKrKFOmDEJCDMjzOJuggAnvXw9jpadxhSqvlOzYfKeHdDpIySS'
    b'SM8Yxzvm9iRObA6G0cuIRKdYRybOEuD76xwvzfpx6/CScEUN/DE9E4V5naFTcEGMWtCjcDcW'
    b'0jNvDtfgT1tWIcYLCrK9abjOTZXm8UH6/XoC4hRWSEgghn1CDu3/Nm86Mj2iKQyQTKdf2bQS'
    b'J2MRfFhUiPYnDnCsBDkaTe9A2254nuencU7JwfiZ7905Zxk7pwGxmNh+8/U8aW9Vq3DotAMv'
    b'9R+I8jTfWRJELe+gZ36+KohfHt2NZXu+NtszuELjc5gP0GF+SSFjEJ8QoxGI85J1FIfoxxfI'
    b'NM8ZzQzQy0xS8PcdmzH75EG8WlqOsds3cgyX2a7XhRDIzMOv+14NnLLDI6lEMlZgGN0RjZ31'
    b'BecIkDs5yYBEx1xxdNthw2tGGp4eMQqH87pCj9RAo2q6SMYTm1ZjWiiMW75ahb2nis1uozr0'
    b'IEMx5vipKEMHtoRNAmSjZ2Mp3AHvswqUAUZ06CZd8PWxw7hn+zo8Gwzhkc2rzaxSI0Ei/L52'
    b'+XhyxEjMC6eiW4GNc+LEklaCc7KaBDBbknt4churWch0S+wGoikGei5y4U8sWK6/9lq8PXw8'
    b'CnPaI0KbTK04gWc3rcXd1UFMWf8JzlRXoX+bjrg1w4etcY0lcXvzWmLHCQJA9W+HAH3jQ9l5'
    b'6J3bHscZ8m7csBQ/5jV+8cUquIOnEWZOcYhm96cRE5A/ZDAWhLzI/8CFcKs4ArpcLUkYxnWU'
    b'WdJSSwMMTOBnUvfwRNlvkFM70nq36cif50Z0tws/zGqL7sNHYMboW/HB8AmopA3P+moT+pw4'
    b'ghlrJdcHpvYYSG2P4BuWwgKZcv2ibTVyTPV/KH8QaiJhPLZ2CR4+WYT/2roRgVbZePe6m/Fz'
    b'XrvzsOH4cfpVyN3uRv7b1JgjCs52Udxk1plJw0kSxsuOGZS9E0f/il8dZb85lFGU39jzUOcM'
    b'Y3upAe8xDZ7tdmQftsEZsmG5w4X3s1phTod2SM3KxCh68IqyADbVhnBDt77YdvwIquvqcKu2'
    b'E7uNPnCoGNqrMvwuNhh9M/JwV/5AzF7zMdrv3YqhNUG8360H7qJJfGjPwpcBDzp+40TuCgfc'
    b'm+xQ9KVH+0VxZ38bbtGz8G68At5k9UApjYXSPEWP2Bp10Z1khDGoeQTotjY5e+CgCuL+7QH0'
    b'WsBwmCGOgdcM8QSDq5ppINImjgPtue55UfwwpQqlsUr07DwABtX4xeICBOxLsCo+CCmUoq86'
    b'gLaRMfhlh3xUBctxvHAn0+B0zA8ychTr6FqowU6iVRmFo6ob4ge5dKpCYdeUIJZ0z0Vq3I5R'
    b'kQOMMeeq0UtCsRLT9N7KN3/WKDonpljJQQjY4uyO1hpVMLgT/g+8cB6mJSWcdgKi73UcI0wy'
    b'OOeyblT2EbU4nlvN0lnuBmjYqa3DTrRh9h9GNqowJD6YWUAMZ+J1yC1KgbbWifRDjPXsbzhJ'
    b'MEuEBi4bivpe1SeG1FtDWOXtg93RypYRINC0kbwk9bAl4FxCjNVtSMBMdxYOjmTyKlrXMBmX'
    b'iZIQI40npxpodYShcB6rv1JJiMTqFYoZ8mJkR/KAIvMhEc/nb21OedDqTRfSj7OB/Q32N71T'
    b'A+HZiXZL9R9RjaddfvgVHaHJeovRW6Pqy+Oq5EFhQ5a0d+hX4earNOy6MwTF3EBWvUlQAFWi'
    b'YKukFEIWWSxmOIxQqjBXrFikEZfI3+wVVHWppy52S5h2ryjrrok1mOxzYoImRZ7BRRFWkoVM'
    b'gpuB7sKrPKtrEcqNOjPLy1IO/NbWGe2712HXQ9WMpxSCdkr3YPoDxSaxUyHmzP1hnOoYgZth'
    b'UHCStWGQel1p2HDcsh8PfyvqGkbZXRHTwUlf8xpUd/Oa5TSptoY51oCOcTzLsdOVDVHOJcA5'
    b'JQdzBerRXvdOHCN3TJq+9dIEJNQMpeCDba2oBwZyqH5jtFQUp5fjnz2qEehkwMGMNuo3UNEx'
    b'hiMDIwiMCmFkN4V+mosrHzNvo+WrqKnJcjvjKIvgr7jkOawtbra5kdY2ig09mRxdxdpRbiXk'
    b'sXLsFsMh+pHTw2pwf5YTv7d3RWcthdcQkwKWRkuwxqhtJgqc95vicvnmvbif1+hiNTWLAE+e'
    b'qnkwx5VvaqkMb6MqlxkRrI2dxmdGKbbFw1xZg+FNxzDdg/4qHYdjYbwTPY29pI05IyZzadO4'
    b'7+J2mBngImqBk3Z8Da/2gC0brXUHvoyXY2M8ZJKWQXIGak6MVZm4Ts9Gmqw8RxeRQuz3SGg3'
    b'PiABvosS0ES7UgXK986LR7mbtBlQE6kuCp+7e6O1cppaIKDlmlstW4KcsLSncpKyPz9yFL+I'
    b'naGAilWAohkrJh1Ri8A4CdFxgpudR0Kw/PuDzY+77W3gpOBB2reNfVJ4PSdHiZu9EuOKBhXG'
    b'a9CldrdZYTSdzV1UKxhgWwip0Q5w8gdiQVPgesiEovxkekLfYEcu1V3OeZgT+wU1w8ezU3Xd'
    b'LJ2djCKHuMJ7KVABzek402ebCMXfsnlONs/9ad0p/Kx2D4opnFwrk9eUSChj1AsvkDnsiVVx'
    b'L5ZcKnsepH+iNk0GZrwzd7Ayeoa+LaGC50MC0uLIcQwIF+BTmoafggqcB4uQsngVUv76KVpt'
    b'3AZPbRgeFk3pX3yD1PeWIXXpOjgKT3AYhRzW/u8aIeTX7sXyupMNRD4HGbuWo31K7Tq7ymfn'
    b'WI+mZmhBMXb55s3czFA4yGpqGryGCktmQy/ssJu3wsWR7XD1QL6WRiLOxWCdnH5SdwK3RwpN'
    b'9U2Xmyas6T1rvoT9nVXMEpkL2Km4gWrEhrPqo2T6+gIYPobCSJTRg6XxQ6NRM7QflKbMhy5C'
    b'6XJHJ9xAsxANqIedY22NlWFweB+TKA0a56ciiWhgOEi6ZGGXglJfiAk0/wqK0K9rcBw6xn16'
    b'eavxjcgx2q/c2U0MJHZ6KB7E7XVFsFHwNG5G3IBn1SbY3/oHjI5MeNJJgJvWns56xMXwRzJM'
    b'Ujy8aium1blpcPz3Unj+udUc1icEcoSp9CPHaA71N8Hlu4K+4fecg6yQacsyt8MsvzlXs3Pz'
    b'KJF+4gSbRZwrb7idcO/Yjzjt1M8hX41X4i1OTExBVkMM4kOqq6xYpmgLN8+mb2BfuAZGZ6vU'
    b'qGAgjdBFdspBeNQghEcOotCtGF8jzG0leWC/LtlwvLkS7q92MztUHIuOjsJ+Ej1lrrKMVcMx'
    b'XoscxjyjxnzSYHBO7u37YHhdiNvF5JpZ/QQKde+dYzuTObM0vBQU2Y1lpMG5vQB6OIy6nGwz'
    b'5n5ABxSPV6MdHVURV+iRumKqvm4+FvNs2wvHXz4F2mQkLhKoQmzCEIR+cBNqh/fn9VLNLXJN'
    b'L0QHdIeucyW/Yd6cQs1Id0HfuBuqQw7qWmdT9YH9DImjGPsDRhgzKfxvY+Xw01fIgrh37oMe'
    b'KENtvx7MFGX5kyBAaawGF8wcxbQuuWKI7Gt0XCnzPkZdv26oHZBv+oRAXFJjBS9/j3JLDzPj'
    b'+3oP7PNXUK1Zs7NNFVcg9KOxODa4N3x2BsAYbZmk1l9X1DZAYvPWfw3v/NUw2jCoyTnUjMiD'
    b'41DbuyvOcGXT2afU7GckHpXT5j1bd8G28yCqJt3MwommZP6eBAGa9j3d+4Oxkkf8kIdJ3VoV'
    b'U4h1aQvX4jVw7jkE5XIwNCq46M0dgVJk7D8K1z++gG3pZiCLjk2EP1RK4cfg2LCrcV+GH3tL'
    b'SqDLREVw/o/TzvVgDZ7q0gcbM5yIejQ41xUAmZwSfYT+z12wV1Uihc40WheFNxpDenUt7IXH'
    b'4V2yGtqR46im8DGvx9TUpIQ3y2H1K/NMRoKVZO1G84ckYHC1bJXV8Hy6DvoSdvX4WO6xSA8y'
    b'h+eqGbLqLq6yePWiCtROHYuiwfn425CxCEbr8ODbf0Q7uwuhXkxASYLzUBGOVVVg6aPT4aD5'
    b'3LTmb8hbR014h5rQgf7BxhKXmqDKQlxh7qdyrAoWYJWnEPv+aFSPH4FYKoUXjTGRFAErAg/M'
    b'GGMWz947x+RQo0abPyQBYTlODx7p3hHo1RU6CxFVXGqGMKoVv3lcXkvHl4Pqh8ahuE8nLBgw'
    b'Cnf0GYK52zdgc1ER/C/+D+yVNXDuOgjH3I9QesM16OLz4UcDr8dAVwr+rDPR6poLV3EA6gC3'
    b'KIWjj0Atx4iT5AGdEJ50G2quG2DORbHNmp313QyU9nrNouUbExqwYFYvxuqvuNuyZIqrZ1Bg'
    b'PRJBDR1Q8HQp2jFfEI8cb5WGMzlZCDk0LOz7PdzXf7j5sKTvx3Nh0GGlz/lAHhgk7LU0hKKn'
    b'78OQnt3x0S1TkOZy49O92zBh8zKAqt72VCm0skpUUXtKGYk65rZGMDPNtHcl/sdyJckLz+RP'
    b'0/sHJk3bY4ZP8w1MeQmxpeDkFe3yFEm4pWc+Jl8/AoX9uuLo1V1wrI2Pwtuw5JqxpvACecJT'
    b'EqmFy1RVTtZJM6EPEWRSiLW1QZQEE0+Uxvfohw3XT8TQzCwUMRIU9u+KttcPwWv3TEavzh0R'
    b'oBnK2OeEbwGUWifCy65JgAml5lp7LYaIUFBVhsf7DsfqEXdgdqd++HPPodg7/kHc2mtg4iSi'
    b'uLI0QRo9t/i/eigKodNfyMtVDZ8uD+vQDR/fOgUbRt6F9dxWUjuyHR58XFaC7IYXMJHk6ps4'
    b'J+s5AnR9EWd14QP+JJDByXwVrsHb2zdiWMfuePK68Zg65AZ0P++tkdKQ3N3gf4ZS2M4NLW1a'
    b'qNYkp7y28c3tLE+KScS13E5VleOebavhZfHUWNwWCC8vYuu2xdbROQIC9z1ZzR9ftQ5bBNHC'
    b'HE7qtZOH8daW1YnGJlAVkbqLYZEh02hIAPeVEMDfQnX1r8s0RqC6EjPWfWzuS75xDi0Q3oR6'
    b'JXDfE2dZbjAL/mTT3iQJjZ9tJwmxank38NFdG7Fq/85E4wUQqrgxjjMGJ5oEsmtmbwabG03J'
    b'RJimMWv9MiyrKmWV2PA9wRYKr9QOZbe9ZR2ZaDRayb3TaliBPWMdthhmTLXZMfaLpdhzSoqU'
    b'xvDKI2+ZvRQrpsAWYtw383cgzZl4+NkQb29Zg98VFcDP/vXBrsXCC5R6puTeJxJPci1cQHfJ'
    b'pBniC961DlsMP1cwytD02Jq/43hFmdWaQKZbbqcYTJ9JxNmkhSABMQ8FZzRpZT0Wr8finVuo'
    b'VRuQRe267JUXKLUgMHn6EuvoLC7UN0Lp2jR2KLIOWwSZpNzM+Jw2+x8kobTm3Gv9uaksiiR3'
    b'YMVmJjYWpOKLpDInsDkavRqz5sAu3L5lOTVHboTV47KEL6TWTbeOGqFJAkrun35CKTWVuw2W'
    b'KXlIpxyawtuni/HcmsWoDCe0Tl6ZkzdI6pizm/c5BJIIZbpRkuLGGKcXGW55RgBsPFKAkes/'
    b'4vk2Oj2Zpgh+OcIjRgIeCdzf9J/eNEmAoGTyjM+YLc2wDlsMkwSu3KsnDuH51YtZJoSRQw0Y'
    b'7vSgNNXNBMh6hEVNMPKyAGZ4A9KzzddiNxwuwLXUHqarNKlLvhzdLJTSplH1V1qHF8CaRdOo'
    b'+dvyL7wTx9Iok3t34HzIxFO5givKSxAsOYF+rduh8PQJbKg4g8wd+xOOsCaMODPH8p4dcZuv'
    b'Dcqqg7hp4yeW8HKT5Qqg1IsseH5tHTWJpHTKP2/264YR/Yl12GKImp2K1eFat7wkCWyvroL/'
    b'rcVQhSXmvcHwv7KoGZAPOx3jCeb7KSTNI77C7H2ZUOoPFL7Zd54uagINUfLAtH/lBV+yDlsM'
    b'MQc/bX8Ds8WvwyGm/wxneSyhWTUaKQ5Ec/1mOixpUjZ9h/xxxBUJr2my8km98JUUAYLAA089'
    b'xQvLY7TLcowikNzglCxOKshYro+rXwWj+1WIsnIUZyj2eBlu7hzE4WnaE7T5f7NamkXSBAgC'
    b'k2e8zAHGURuSupF6KcRy5H3BSkRp+3GpCCUaXAmUOsL4PY7CtyidbxEBApKwQtn0IRxw4eWu'
    b'l9y0jGawnm/THtFOLX44fSE0NZ/F3NDA5GkX9fYXwxVpnG/+S7dz5V7g1stqSgLWkFxx7/L1'
    b'CI0ccvkaoNRObs9w1c9Wdy3FFREg8P/vK24jUjeFAjzBLfGC30XReDi9vMq8Ld5iKFXA7WXY'
    b'HW8H7nlc3ky6bFwxAfXwv/uy14hGv08S5E9nr2NTw7eGLJw3nJS1ya68+QxTW8c+8qezi0vu'
    b'/VnjGweXiW+NgIbwzZ+VT8nGU7hxPLya34x5lzGUMv+eRv54ehm5+rRk0nTzNta3ie+EgIbw'
    b'LZzlZ+CUN9DlbdTu/JbXROWN6UweJ7REKSkWpHQUgQt5XMDvnUxj95ZMelLaviMA/we/523z'
    b'GdTVqQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
official_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'70lEQVR42mNgQAOa276xAPEJIF4ExOZQvAgqxsxACAAV5QHxfxw4B5cmWSBOA+J5QPwFjwEg'
    b'uVlAnATEMsgGFOPRhAsXIxsQRUiDwY5v/7W3o4hFIRuQik+z2/7v/x99+vV/2s0fyOIpMM2g'
    b'UP6GT/Pjz7/+3/nw878rkI0kB9JjCjLgGrKG/LPf/yed+I6h2X4vVguugQwwRXbB6gc//n/9'
    b'8et/25Uf/5/g1wxxAdQbKTAJXWBA7Xr68/+vX3g1I8IAWyyADAG5wHYv3piJomo6kIF6Yw5Z'
    b'KZGEvJBNTGaC5caF0BgygbKPE5UbSQUAXjQPko+KbNAAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
official_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'Y0lEQVR42mNgwAM0t32TBuJ7QNwGxDJI4jJQMZCcFAO5AKh5KRD/h+I/QLwKiv8giS8h13Bb'
    b'JEMIYWtiDWUEYnUgTgLi6yRYcA2I44BYBZ/h7UD8lgRDceGXQNxCKLwpxcuwWdBNRQt6sFlQ'
    b'RqpB3ge//2+98uO/wQ4MuTJsFnSQYrjvoe//X3399f/Xr1//qy78QJdvRzc8hFTDX36BGH7n'
    b'w8//tnsw1PwD4mCY4VZA/J0cwx9//vXfZf93XGq/gcxmgKZhDAWBh7//X3j3x3+7vbgNd8Nt'
    b'ODx/wHzwDV1yx5Of8CCw30uW4RAfQIMpGBpucAUhR77/f/cNYuDdjz9JNRwRB2g5GUVhKJIl'
    b'JBiOmYrw5QOYJY8+EW04znyAMydb7v7232gn5TmZ5mURqIZ6Q7PSFMkiUH2QSPX6gC41GoF4'
    b'+Q3Ey0HhC2XDxBdTUunDWhWtIDaaeDMQ3wViSYaBBACNaoDjcjYxzQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
open_link_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'7UlEQVR42mPoPuwlA8T7gfg/EXgFAxRA9T0ipIeBBMNB+BcQM0It8CdGDwOawC0g3oADrwPi'
    b'aCQfsANxP5qaj/gsABnOykAmAOqtIOSDDVQ0/CPVLMBieAU0uCi3AJvhUHHKLcBlOFUswGc4'
    b'VL4fKv6IZAsIGY6UhEH5RIYkC4gxHJsmoiwgy3BiLSDVcFCOhxYrKwhaQI7LocUK4VQEFCsl'
    b'J1iISqZAvggQ/yU5zEmwgA2Ib0AtKSUxE24gNohAloiQUYRsoGppOmgsoKjCQTKcFWoWyVUm'
    b'sfgWeo22j4RKn1S8D9b8oIUlIDNlAFg+9jMs6bgeAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
open_link_red_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAFtSURBVEhLrZaxSgNBEIb3AiGdlZAi'
    b'plCwOUELOyvzBqKFgpC3UC5PoJDHEEELwScwnbU2aQJaBDsrOyMkfpOdHIZkL7vrfTCZmb3b'
    b'/9/bPZIkk+bWhjHm5vXj+5BcyF6jdp8M386k1nnPzGtK76JCeIkrxwgnWu+vEheSl0pjorWs'
    b'cEDq226BMfHAE9xKg1GNdE1sSq+0MF3TekpuoOI7CPxIHwqGGeJX2ubIFs3olyXOYr+0nDOI'
    b'Yol4h9Sz3T8NlomzC3IuOdEGPuJClIGH+Lt8MD4MNvBcecb4EfnAyGsqwcRHe82NiM/u1zmZ'
    b'XnLi/QSeK1/AyyBUnPvPiRFxt9IgcuUnzKkSp4UGiF/EbAvkuk4DxNdJuViA+BxFTyDfJwOE'
    b'x8RljLjgNEBwRNol6tTd6WAEhWcgJsSntlEUGpTBX4OUg61qHY1qpLYL+8n0JeXV3tbayL+K'
    b'JwZa2pcKC+7JFrWlsEPlYTVN+xcs9sPXJJYAdgAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
packages_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACOUlEQVRIS7VVTVbiQBCupuPg'
    b'Em+gC3FmxxH0BngAeWThz05zAocTiDvFBREPIDcYbjC6coZZyA1k6U+anqo2FTttA3k86fd4'
    b'JJ3091V9X1VFwJKXWDI+FCY4euhuaxmcAegxHrq+qDbiIsHNJdgfdmslIU9BQz0HKKAvEhVd'
    b'/AhHs4imEjQfu5VyYoCbCFBhED2BSJQAM0mXgPZLoFrxRjj2EX0iIOBvSXAstD6xgfnwZbVh'
    b'zhwOe138I3KztBA/O5t7LZckR2DpXJuWNhPQcyMfyGOLaKS1iDpbe/2PBNMrBF/XUv72RW2T'
    b'2QS8f/Cnd2LLJpTaYG+yDA7/9W4/GelJwyYwQQWYwYdP5AP5NcD3dui4ITj4e1MXQt9merpG'
    b'WkRE4CmAMZrfKmnVRxUejSda7JJUhuBde/mLcTKQN0nVkhmZRhRqgFO8XsefAX4tq3j1GWpp'
    b'nxj/EDikXsmZjJWBZwE8RhLRtqPYALUOlYSK2yccfSYRH/QR8LOjYa+J7FSapiRfg+Tc6RPW'
    b'Pxfg3AzsqDkAkibdJ0Ppuv+yoqLym3xyFViUgHkHE1DRVTW8ow2fAosSxGjufed7o+3L0PbQ'
    b'JaAUMW1xN4Ek5MjmeeRMgDESrPEZz6iQZCSVIK0YK6XFXelK4OsHBIzsUe6dpm7rY1G3Lzcb'
    b'EROgoWtuBXE/uFN19rjON1pWhpjZyMrS9MO070KxD05+YnoryGnC7HYuAb+Zzivq6NGXfjKn'
    b'RVZ0v3AGRQHd9/4DVs4qKHQwJj0AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
packages_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAFW0lEQVR4Xu2bS2LTMBCGpSY8'
    b'lnCDdEGBFXCDcgLaA7QkCwo7yAlKTkC7o2XRUA5AuUFuQFgBZUGOYJYFu2LGj+DKsjQjP9qS'
    b'ekcjyzOfNL9mxkaKBb/kgvsvrgBc7YAFJ3BuIfDs+OChlN0nyH8pDN+/vT+YncdatA6g//Pg'
    b'1o2wsy2U6IPDt+ZOS7Ejw2i3bRCtASh1XF92ALF3Z3PY1m5oBcCLrwerqtM5AKd6RMcCMGz4'
    b'dmVzTBzvPaxRAInj3TdCqId+FsqpjMIhhMXE7373XY0AQIFbkp2nEOev3CaQRoxlFI2a0Ida'
    b'AZDjPOczGDBQQmyTwqMBfagFADp+809nDRyB7Z5TdsLi7q1sxjZsfTt8JZfi+52XOhXD/Xub'
    b'O86BhAGVAVSN8wwA2hrvoD8dhIBHpOMCfRBqt6pQegOIHe92XkKcr7lMtf2eB5CNizVEwNxU'
    b'EFG47qsPbAA+cc4FkI3f+v5hTUqFO6LnhOyZSJEB1O145pBpB+jOcvQB6ltWIkUC4JHIOBeM'
    b'AyAb+/zH4Rvi0RooJQf7dzeOXIY4AaT08Zj6l7e7ZmX8TtkB+ek4+oBHrEskrQBg5XuQwn5u'
    b'ynl0jAvgrFB2Ib22Z5mQQC3bBNIK4PnxIebvhCOJseTaUF8A5FNIiiMortbLLCwFkCrwR3/X'
    b'aHdyAfiIMejBepkeGAGkCQk6v0pzw38UFYCP4zmrZvCcZZOVRgCsY8ff9/hOCgBGPjCBYzAw'
    b'JWdlglgAkK7+T7vwyalLfKhcbAAYafYkrRYnqXCj/foVnFyLlsfLgyD/QwHA1o8P21Kp1zYH'
    b'kGYkoimkqxgmPaqzpnEVU+EACqPR7xvROO+YRbzH8LyBFQDcjPSsTuW304vjwz65nDUQKBRD'
    b'pn6hYTWVlDu/u+GuvqKOpC2A592uFUA2ma9uIAAMu+snnT6Uw5SEa3IqouG7lQGE4b+LeCwW'
    b'xLAYAoS6vExQeOVsYjzE7mNa20xOlRIj/TjjnA6m49B8CkAVJpbEAxGpX6YmhSvF5KSrBP0w'
    b'xjlz18RzmJoozloANAFC/OzlAjAPC045a4hz+NORqRfIOB0Edo90kbRqgG5HFQCaPlDiO7vF'
    b'GOdpsxVfqpCbMK48o9EdoMMkHLEzMGikV3CcONefeaEAoHFJotKF/MFYxU3A4MeZE7lmK61r'
    b'7DhmTXrT6g7IDLBVmZlSM+I8gPR3LJX4AmKF1euZ68LtALTOUWbPwKEjYudnrhVl1etlBEA4'
    b'GYs5waIAMOYESGwRAFjfD/7PAIw5QeGITZKuQgfrMmtAafpqEon/YQfMoDSKmxXqVL23pa/n'
    b'DgAMKDQWCNI9H2I8Bh3dW9v8tiq0kRBIjPF/O1snAFfCVAcAR4dITk9FONAbFLYVqwNA2vnB'
    b'FHm1/Flyurey8chmizMVTltehRTTMCn5M5YqADiFEbTNXu/f2RhVAhAnGUmXiFbOEt7O+gDg'
    b'OA4mk08Q5w7I0yOUs9lw62duXACM9wJxYXTSjUZ6s7RsF7AA4CRp3x13Q9+t/GahpAJwCZz2'
    b'fFLCpNvMBpBNkPT93G9nkwMDWlthhN/7zfCfLgDMnuL8pYh7QYojvAFkU7HeC6T6UAYAtu7A'
    b'+B2x2bPSwogDojKA7GHM9wK4E3qaofg3/AjD9SFGLY5nz64NAE7o816AsVqYJhu7xIw5CkNr'
    b'BXBWH6ifuZHM9xI4ysyNAJjrA/8rcc1m89sgimPUMY0C0PSBlkglN9Ua5zYYrQBgCGVQ9taX'
    b'uqLcca0CQOMsiVRjcX5hdkDekPx/mlIq/MSpJrmrfCEB1OlElblaD4EqxjZx7xWAJqhepjkX'
    b'fgf8BVBCbm4ViPjTAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
partition_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAhElEQVRIS2NkoDFgpLH5DPSz'
    b'oDtc6z/IN6Urr1FkKbo5cMPoagGyZbjYuOKOKB8MuAXEpDxYXGKNA0I+oLkF+FLa4IgDYoKA'
    b'olREcwtISfvoYU5RHGDzGdUswGY4KDXBLECXJzkf0NwCXGmfakFEVQtonkxpYgElhuLTS1H1'
    b'SIyjaG4BAIELECiIeXl+AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
partition_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADZSURBVHhe7dXBCQJBEETR0XBMyEiM'
    b'wkg2IdPRSx1s6Ev30K5Q/11KWBmlYGsWAACwdVEGz/vtrY/B43il3/83lf9/VdqiAKUt+wJa'
    b'Izj9fBcjWEABSlsUoLSVru5Zt8A0boEEBShtMYLK4KwRzEaqo3I+r4DSFgUobaWjMz1S0xjB'
    b'AgpQ2qIApa3WLbD7vCs7NzuTW6CAApS2GEFlMDWCHd/DtXsuI5igAKUtRlAZTI1gNkIV2bnZ'
    b'mZXf5xVQ2qIApS1uAWUwteK/wi1QQAFKW/YFAAAAV2t9AJCHiFiB+t2+AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
paste_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwY'
    b'AAAE7mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlk'
    b'PSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9i'
    b'ZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRk'
    b'ZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJo'
    b'dHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNj'
    b'cmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hh'
    b'cC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHht'
    b'bG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1s'
    b'bnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0'
    b'PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHht'
    b'cDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIiB4bXA6Q3Jl'
    b'YXRlRGF0ZT0iMjAyMi0xMi0wNFQxMzoyMDo1MiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIw'
    b'MjItMTItMDRUMTM6MjY6MzArMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjItMTItMDRU'
    b'MTM6MjY6MzArMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JN'
    b'b2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjFjM2RkYzQzLWU0M2ItZjY0Zi1h'
    b'N2Y4LWMyMGRlY2Q5ODdiOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxYzNkZGM0My1l'
    b'NDNiLWY2NGYtYTdmOC1jMjBkZWNkOTg3YjkiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0i'
    b'eG1wLmRpZDoxYzNkZGM0My1lNDNiLWY2NGYtYTdmOC1jMjBkZWNkOTg3YjkiPiA8eG1wTU06'
    b'SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2'
    b'dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjFjM2RkYzQzLWU0M2ItZjY0Zi1hN2Y4LWMyMGRlY2Q5'
    b'ODdiOSIgc3RFdnQ6d2hlbj0iMjAyMi0xMi0wNFQxMzoyMDo1MiswMTowMCIgc3RFdnQ6c29m'
    b'dHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIi8+IDwvcmRmOlNl'
    b'cT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6'
    b'eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvADZN8AAAJCSURBVEiJ1Za9a1NRGMZ/5+Ym'
    b'9ZYm0prQEhrEDyxGEhG6GW0cqsTFQQQtdisOdhAnXUUcFMRBEXF06B/gB5lagxRE2gpxyFBK'
    b'1QxSvNKoSRPS3OQ4JNck5N58QBx8xvfreZ/znvPeK6SUdEIwXogB94EQoANPgHupmFbulKt2'
    b'Ufwk8BpQaiYfcAcYBG53yhdSSoLxgguYB45bxESAQ0D22gHF/fxz5RMQBkrAgkW8DjxOxbR0'
    b'I8ELYLZdJzMBhVsTCisZydxa+5PxDYBexJOKaVlT9hWAsT0w4Rb4NdGSlPghSeiShXSlxedx'
    b'VvMOD1Xz9CIAp6E+AxXg+kGFC36FJV1yM9nc5beC5EbSuvOoV3D3mIOsAZGEYZqdUB9cE0Zc'
    b'1tLtsM/VqtiEJUHYI5gctk9qxF4nXBy3j7W8poqAZyccvNUl34v270RzwJRXwTtg34DtO3Aq'
    b'cHZUAN0psYPlEfUT/xfBkArLUZXlqArwBrrYRb1AAO5axVRMK0EfFfwsQdniwvWFYDUjOfPO'
    b'4PKHMpndf0CwvQsVCes5ydzHZpK+EEyPCi6NV0tt1EiC8cII9DjkL3nJ7EqZ36X2cRs5CfAS'
    b'iPSkIJ2nY/EGhKBHBae8ggchB7rFflrLSJb0ql0VYEiuthC835ZkjdYPypRPENAEAjhnsZ82'
    b'dyRPNyt/iz8MO5j2u141EqwDR+JbkvhWa3d+zUFAs1eW/CXZMerFoz6xaPpMgpn9g2L1a77z'
    b'L4wVzo8p5Aw46hZMDotF4JHp+wPIjbMtMph3MwAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
paste_up_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAUtaVRYdFhNTDpjb20uYWRvYmUueG1w'
    b'AAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5'
    b'ZCI/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRv'
    b'YmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRkZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAg'
    b'ICAgICAgIj4NCiAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5'
    b'LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4NCiAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91'
    b'dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRj'
    b'PSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJo'
    b'dHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDov'
    b'L25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9i'
    b'ZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJB'
    b'ZG9iZSBQaG90b3Nob3AgMjMuMyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTEy'
    b'LTA0VDEzOjIwOjUyKzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMi0xMi0wNFQxMzoyNjoz'
    b'MCswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0xMi0wNFQxMzoyNjozMCswMTowMCIg'
    b'ZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcE1NOklu'
    b'c3RhbmNlSUQ9InhtcC5paWQ6MWMzZGRjNDMtZTQzYi1mNjRmLWE3ZjgtYzIwZGVjZDk4N2I5'
    b'IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjFjM2RkYzQzLWU0M2ItZjY0Zi1hN2Y4LWMy'
    b'MGRlY2Q5ODdiOSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjFjM2RkYzQz'
    b'LWU0M2ItZjY0Zi1hN2Y4LWMyMGRlY2Q5ODdiOSI+DQogICAgICA8eG1wTU06SGlzdG9yeT4N'
    b'CiAgICAgICAgPHJkZjpTZXE+DQogICAgICAgICAgPHJkZjpsaSBzdEV2dDphY3Rpb249ImNy'
    b'ZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MWMzZGRjNDMtZTQzYi1mNjRmLWE3'
    b'ZjgtYzIwZGVjZDk4N2I5IiBzdEV2dDp3aGVuPSIyMDIyLTEyLTA0VDEzOjIwOjUyKzAxOjAw'
    b'IiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjMuMyAoV2luZG93cyki'
    b'IC8+DQogICAgICAgIDwvcmRmOlNlcT4NCiAgICAgIDwveG1wTU06SGlzdG9yeT4NCiAgICA8'
    b'L3JkZjpEZXNjcmlwdGlvbj4NCiAgPC9yZGY6UkRGPg0KPC94OnhtcG1ldGE+DQo8P3hwYWNr'
    b'ZXQgZW5kPSJyIj8+/RV+AwAAAkxJREFUSEvtVE9IFFEc/t4b3XVNpzIXFinKipWkLCoITOjP'
    b'besgHiKSOikd6tAhpKsEHaJrlwIhOnToFEoFFbUnL1GggZEEUlCga2m2lDu7s9P3m9kJW2dJ'
    b'drZbH3zze+/3mN/3ft+bNwo1wK5HP1oYRsk95Nm3JxrHJC/QpVg1ZrNWdGeT+sLhYdKsUxh9'
    b'8innyJplWSdDCbD48OBre/l91q3nosDh5UkbIhKJRB6uySJakGK4TooFGfImeS3ZpArTK4qv'
    b'BDvBrf0GjNK8IlhcWn9KJtwEsI48RkYX8uiR8qc2a0wteULH4wpzFpArAslmBbcDFokwXCT3'
    b'yrwMPeQO8vv5dt18e6Y4yXEXmR85YNR/ZbGhN3Yd5wUSQ0mN7k0KE98cnN7WoHyBuwznZFwJ'
    b'/Vs0rnRovFxwMPjKLmU9jB810J32ciJw50PRzOSQ49dk+Yd8Rh6JBqCDbbXFVh9Net5BOuPg'
    b'3kf2XobyDIsvS3EZ+wLSIi5s17h/yHB3UY7PPx1cmrDxnCLlCDhI1y6BdpzVL7TIiYSDpu3u'
    b'pgPvQZepcHDjmr5grK8HFrlfk1EQj7rvycN1TkkHnY/ZP3G1U6O3zdPMc/kF7ZjzLmUgYvTm'
    b'SKtGaxTI8obN0/XecdvkUlbWeQ5ORYFqIEX2PSssMuTJgalUbKz6agEombqBjJPu2ddUwA5w'
    b's6YCRsB3UVOBIPwX+Cv+ucAfFy2VUNjN30QY3Jj+/W/t40V74Au8YyLp5UNjhlwih0XAt6h/'
    b'a2O4nftgnXaGEW8G/ALWUcMu2uFD5gAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
smart_paste_up_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAUtaVRYdFhNTDpjb20uYWRvYmUueG1w'
    b'AAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5'
    b'ZCI/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRv'
    b'YmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRkZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAg'
    b'ICAgICAgIj4NCiAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5'
    b'LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4NCiAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91'
    b'dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRj'
    b'PSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJo'
    b'dHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDov'
    b'L25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9i'
    b'ZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJB'
    b'ZG9iZSBQaG90b3Nob3AgMjMuMyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTEy'
    b'LTA0VDEzOjIwOjUyKzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMi0xMi0wNFQxMzoyNjoz'
    b'MCswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0xMi0wNFQxMzoyNjozMCswMTowMCIg'
    b'ZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcE1NOklu'
    b'c3RhbmNlSUQ9InhtcC5paWQ6MWMzZGRjNDMtZTQzYi1mNjRmLWE3ZjgtYzIwZGVjZDk4N2I5'
    b'IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjFjM2RkYzQzLWU0M2ItZjY0Zi1hN2Y4LWMy'
    b'MGRlY2Q5ODdiOSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjFjM2RkYzQz'
    b'LWU0M2ItZjY0Zi1hN2Y4LWMyMGRlY2Q5ODdiOSI+DQogICAgICA8eG1wTU06SGlzdG9yeT4N'
    b'CiAgICAgICAgPHJkZjpTZXE+DQogICAgICAgICAgPHJkZjpsaSBzdEV2dDphY3Rpb249ImNy'
    b'ZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MWMzZGRjNDMtZTQzYi1mNjRmLWE3'
    b'ZjgtYzIwZGVjZDk4N2I5IiBzdEV2dDp3aGVuPSIyMDIyLTEyLTA0VDEzOjIwOjUyKzAxOjAw'
    b'IiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjMuMyAoV2luZG93cyki'
    b'IC8+DQogICAgICAgIDwvcmRmOlNlcT4NCiAgICAgIDwveG1wTU06SGlzdG9yeT4NCiAgICA8'
    b'L3JkZjpEZXNjcmlwdGlvbj4NCiAgPC9yZGY6UkRGPg0KPC94OnhtcG1ldGE+DQo8P3hwYWNr'
    b'ZXQgZW5kPSJyIj8+/RV+AwAAA1JJREFUSEutVFtIVFEUXfdOaU9nCqMH5ECZIdUMpRJUNBQR'
    b'ROhUED0opRj6qEaLFKESJOgjyo+gn9KokRBqPpKRfppeTo+fJJiIrKGHGRRp5UwvnNHxtve5'
    b'9+q8vEi2YN29z7n77nXPPmcfCf8BhcV/ZpLxEZcR93R2TGnjeYas2X/Gly+x7PwF0jdyVxNz'
    b'Jpjgu303qvC7WCy2eVwClLze5Y73v3kn8gkMxoFjx+NgkaysrFtjKhGVYBOZM0QuQS/xAvF0'
    b'wUJpMPR2JHkiaCW4eN4EMsag5Lx0P3GOmACmEtcRs/siWKNQ/u1bZbx8pQqtXyuhhwoWjQIF'
    b'+RLECihJFplDRDuPU7CGuJD488A+efqlK0PPybcRBy5fME38HgZqTsYn0HiQiJoqGatWSgi+'
    b'ULBj2yRJF2gms5f90bB7u4zaozKePlPgOkyFTsCTOyas2qDOscDVlqGc3l5E6TTF9E3exY85'
    b's4HFiyTMm5u+NQ8eKXjwUEHLjSFtZgRDKdtAyfs5Ofu6AC8RB10ybnhM4i9S8emzgqraOO4F'
    b'0jfVlB4uysXIeExnztCcf4dMZRc/nVHAtkRC8YqxNbnZDIQj1GE56nhWrviOH6KW+iaLdZ86'
    b'IcOp9d7AAHCfat7Tq+BRoBmPH15Dd3cQeXl25Flt2LXnHCZPAhyrZeTmAr9+K/hKx9O5M85S'
    b'vzgH7YNaTxZgem/2K9TeSSwrK+OgYbrdbmHNZrMSCoWSYqPRGOfpI/YQSynO+C7yeDzw+Xyw'
    b'Wq3wer2w2+1oaGgQ40gkApfLpUWqUA89LMRZRNHEhgJtbeqlGA6HRVK/3y/88vJy1NXVIRAI'
    b'oKurS8Qw4sntITCqAH/Y3t4u/MrKSmEtFougzWZDMBgUc7plmDJcPBkF+C+rq6tFGRhUb7Ea'
    b'ntdXw6UbC0YVSASL6QlLSkqEGIsyHQ6HmDfEaKeIXiWRNnnY51PU2NiYFM/UcxG3UJzxJqdC'
    b'rzf/eVNTEyoqKsTYCIYCfFIygcvidDq1kTGSOnnTRglLC9XDnIj9e6llE7C8qBTuI15tlIyz'
    b'54dv263Uya26wGsyBexnAgVqnoppllLMz7+ujdLwnviDWJ8oUGSdL3V8+CgWMi5QHlAebpyP'
    b'nR1TWv8CZu2CDFeLcLsAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
paste_down_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAUtaVRYdFhNTDpjb20uYWRvYmUueG1w'
    b'AAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5'
    b'ZCI/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRv'
    b'YmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRkZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAg'
    b'ICAgICAgIj4NCiAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5'
    b'LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4NCiAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91'
    b'dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRj'
    b'PSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJo'
    b'dHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDov'
    b'L25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9i'
    b'ZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJB'
    b'ZG9iZSBQaG90b3Nob3AgMjMuMyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTEy'
    b'LTA0VDEzOjIwOjUyKzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMi0xMi0wNFQxMzoyNjoz'
    b'MCswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0xMi0wNFQxMzoyNjozMCswMTowMCIg'
    b'ZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcE1NOklu'
    b'c3RhbmNlSUQ9InhtcC5paWQ6MWMzZGRjNDMtZTQzYi1mNjRmLWE3ZjgtYzIwZGVjZDk4N2I5'
    b'IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjFjM2RkYzQzLWU0M2ItZjY0Zi1hN2Y4LWMy'
    b'MGRlY2Q5ODdiOSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjFjM2RkYzQz'
    b'LWU0M2ItZjY0Zi1hN2Y4LWMyMGRlY2Q5ODdiOSI+DQogICAgICA8eG1wTU06SGlzdG9yeT4N'
    b'CiAgICAgICAgPHJkZjpTZXE+DQogICAgICAgICAgPHJkZjpsaSBzdEV2dDphY3Rpb249ImNy'
    b'ZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MWMzZGRjNDMtZTQzYi1mNjRmLWE3'
    b'ZjgtYzIwZGVjZDk4N2I5IiBzdEV2dDp3aGVuPSIyMDIyLTEyLTA0VDEzOjIwOjUyKzAxOjAw'
    b'IiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjMuMyAoV2luZG93cyki'
    b'IC8+DQogICAgICAgIDwvcmRmOlNlcT4NCiAgICAgIDwveG1wTU06SGlzdG9yeT4NCiAgICA8'
    b'L3JkZjpEZXNjcmlwdGlvbj4NCiAgPC9yZGY6UkRGPg0KPC94OnhtcG1ldGE+DQo8P3hwYWNr'
    b'ZXQgZW5kPSJyIj8+/RV+AwAAApFJREFUSEvVVk1oE0EUfrOJm6SJTTUJLbXWWkprS22lVIpF'
    b'UTyIUVBQRAh6UkS8eBARBEG91qsIRcGDetBDBVFRiqZgvRQFBRWlIogtaLSW+pekuxm/tz9q'
    b'NpsYQy5+8PbNzu5838x7s29WUBnovPX9BNxxmB+Wg43BNr/YUpOFL4m/CoD8INw58y4P44qg'
    b'4Zyk5K4mZcW1d7kZ9IU3xsTE2dWBOfMVSwAkIbhLsG6+d6AZtgAmDyxXxPCbXBptXgkNRgSl'
    b'ddIfz8rLuE1wX0+YUn11Ym9LUDzY3eLP2AKv4Vq5XQyJpQod61Bo4rOk/Y90q9cdMR9RKkMR'
    b'hHBGsfoM8gbMq2OhoMZAYeSSHxGLlKQrbzkF+ajF+nhcW8gcB3LGGr7YAgYOtSp0dcBDR9vz'
    b'ug1M/5B0+IlO9yDixIaoMMZd7PdYPQY4rKRIWThgsWo1ykREdd0rhlrhVIGeWkH9i1wHFSCM'
    b'ee5scn3XiKXgFXTdxvqB010KbW80Nefx+D7C8SFTuEIbAcxxfVShKJLK+KIRrU3iYmIHkjxS'
    b'VKASMMmqUW0Wbh6273k8cKNyNhdYgaqDxWDFc1ApdJdoVlXA45LrqgjceS+pd1SjdWMaIbHC'
    b'sutCiOoIpKydNsepdaCqIXLD/y+Q96HFGwR1o0yUwp7m33Mamc5Rb1jQw0+Shl79qrLeoZUe'
    b'jevZYL1P2AIv8aDdfF4avEPYX5hMyzMgDXqJBlC37CqL041wuhFOO3oWrxH2dBLLzHFloxP1'
    b'34sh31B6/izhTM5oC5p8/8bqwN2pjDzyVCfN8QXzwXO+z3OqPqSerFggm81uVVX1plPEIveD'
    b'3DjXKt5FTM5+0xKfAPk2NPlPYnzyq4zY5EREPwFqgNRHw15ZYQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
patch_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'uklEQVR42r2WW0vDMBTHC/us6hw+KFNXv4KKgrK5KU4Q9qqoc3gBL+AFr4Ppgwh73IMDfRHB'
    b'tkmOSdfGpEvaZoiFP4yS/f7JOTnn1LIiD8wOZaiqVA5V3kp42BoqN/hPJmkxg9eoQJAds96O'
    b'rK1pTUQ4qcwAejjpwEKO6EwUcL2JBC9Ofnnvb47ruuC1n0BlEgPvN5HCUsx/eh9dYPBQgQkP'
    b'Vwq4bBIkB0i54EbhGhMTVa3gBgBqXSjhofD+xiAG3+E183fIdqqCo8v6IHCmrJw0hYkIx/V1'
    b'wI3UJxlVXzvBRNr58gQ3JSsFM7jKRIy5D5wbAXRVB3Rz6P8mZdsMrrvjeHe1d5rHU/4O3R71'
    b'Et8frpyVorfIBtslCnN8KDe4bvjv8N4apG0r8RW6NE7DMgzo7pie5MwPEcsJ3wQLp1CMZnAp'
    b'yU6Q5Onf09CLoKp4M3i4060i4J1KH5xX/GsTYD4rm/BCM1QUzuvm5V40yfNWYSJ8sBnbVliu'
    b'grUub3ZGWhzDXvtZ3Ri7HSClKanZqaaYTrZQjCTaViJwzUyIgce1FS08YR5D4sikJqh5Hg//'
    b'l6Gv+Gxx/+Kz5QdQz10QG9IlyQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
patched_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'4UlEQVR42qWTSw6CMBCGaziUJ0LW6srgCcCdr/hasPAsaOJOiV5CCVF3DeO0NNBiaRNo8iWE'
    b'yf93ZjpDiDgQuA4SIS+kT2qH/UNS5ID06kEmPiIgyGQTIc6k+Lo00YgVE41YNRFpg5bQ+3Ca'
    b'4oG7IqIuaMmTGFKEfD/lNIirPjWZ0FsM9H4xi5VOh4M3v3nrA32gcDECmA/5d5lJ0ZO/Z1YN'
    b'NhOgyQlgOeYm9BpDvvMLg5n31d+uKyE520swNhEzYeUYm9jxGVPLIGFPzIMUdRllpnHaLlMl'
    b'1qxzalnnSBb/AG4MZJlxybinAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
patched_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'GklEQVR42r1WywrCMBAM+K0+T4qg/Qa9Kb5RT14VtQjqQU+KCn6PDYlrutbio2m3YBoYKMt2'
    b'Js1uZ8PY14JaOqUwUnAUyixiuTkK3HsnFZXskk8U4A1WSL71lTvRimjItSIB5HqRCPIfkRDy'
    b'XxEiuS9CIP8U8YoDhjBiXgeYEri92syUQI5aNIS0hyBXYyp5ntp2TzRLwDlH3DvVeORRIkhY'
    b'z4I42CBOa3y+d6145DoRuejjrsV158fEeYOxgOMqMIK3fArM2orMQVJf4LjCmFwOgGor4XVo'
    b'FNWxZEBctupL9nhEbk2othKjyI5X5ApQbSVem05bIOc9apta735u6kcrm7YKnojZmbVr4wMn'
    b'kZGZyNAPuLbwf1xbHmk/FK+1FBjlAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
process_file_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'xUlEQVR42q2WzytEURTHZ5j8LINEKZtBiRkL0mimJpEoKbLxH0g2rCzsSJFRrMTCyn/gRyHs'
    b'ZGVBSpMNSiG/8iPl5/fWeXXnOve+92a8+vR65577PXfOuffc8Xj+4blpa/ICPwiAIAiBSmFP'
    b'V1iIjoFz8MNQnc6KB8CtRtiiPhXxUrBuI2wR1InkgXbQCLIlu8jvhUNxQRUnLgp0KTlNkD0M'
    b'HhWBF/BpCFDMict53QGZoAbcS/Z30Ee1KAFrjPhV0i5ixJ9BBcgBJ8rkeWVhReBD8Rk3iQtG'
    b'aWyGWd0Ik9prafwhKT34OFQEzkAWBf5iAhwAnzS/UxkfVqOrOewn+6ahgPtgEEyBV8m+/ecE'
    b'UyF7wR5IgAzQ4mI7yoUttztIBfRecCn+BBrcnNgoeHMh3pxKW2h1ECShbQmMYAxMEhGbIN9g'
    b'jtqKl7pqvkl8lhGJa4LsWvnGuwyskj2qE48YUhCTarIodhd9+8AQHSrLt0sXYNkQYJq5C3rA'
    b'keInTrJfd3ncGQLEJd9ccKzZRWHd6gttdkmH4r+ljIseFjIVN2AQX2L8ux2L04Ra5ueuWMVk'
    b'/EUb2QCntuLShDpxvYkWm/ZfDeX5BdRu7ZOXZ4cpAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hk'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAUZJREFUSInd1bFKXEEU'
    b'ANAzj5BtLYSQEMWAdrFInWwREvwCP8DSD7DYL/AXxFaLWC0k5A9CipBAUtukCtFCBMXCsJub'
    b'Ymdxsq64u07lheHdGd6bw3vMuzdFhEkjpdRGF30c4Qe+oBsRx2MfioipBto4RxSjhw9YvXb/'
    b'tEBGXhXI+yLvYRvNnYAC6eR8AV+LN3o3RGYGxoDzOCmQrapARnYL4BKPmomP0GTxrcgfYqM2'
    b'8GtkvlYbOBuZP0vT/Gi3RUqphaeYy0v9qsC4qP2J7iGQ8BFP8Bd/sBMR+7WAB/n6olj7jmpA'
    b'kzcs43GtzYfAnkHtGMZiTWBYpA5cFalTpGoFsCi1vwvkTVUgI88N+mzgJ1byegftOwN5s2V8'
    b'zsiFQZ8Ng5Y4EzKuaTTYxKH/G/tMyI3FLqXU4DXe4iWW0MJ6RHya9BD9A8FiWZm3urVZAAAA'
    b'AElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACdeAAAnXgHPwViO'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAA5FJREFUeJzt209oXFUU'
    b'x/HPnSq1xpSmtdYurIJaBBehYEm6EtwJrkoQm1Jx5cKVG3dqdaMb6U5UihtRF+LCUsGKW5cq'
    b'KPgHVFBsCWixaSva2iTHxZuJaczMe8/Jy81M8oNLePPOSX73y7s3c+89L0WEHEopPYL3sRUX'
    b'sYBZzOA3/ITv2u3LiLjQiI9cACClNI23sKUkdAHf4lN8go8j4o9VMRERWRumMYeo0f7CaUzh'
    b'xr7+fm4AfUDotBm8iLGBBdCGcKQPCKGYP17AyEACaEN4FNf6gBA4i8MDCaDCk3AR5yqCOImb'
    b'Bg5ADwizmMQInsOlChA+x76BA7AChFlMLLu/Bx9VgPAz7hk4AEsgnMfBLvdbeBbzJRDOdYOQ'
    b'vZMVIGyvEPNMhSfhm5V+V/YOriKoNytAOLU8L+tX4dVUSulW/IjtJaHHIuLtzkWrUVdrqIg4'
    b'j9cqhJ5IKe3qXAwNgLY+qBCzG093LoZmCEBKqaVYSu8sCb2AOyPi8lA9ARGxoJjtyzSGowzf'
    b'EIAfKsZNMZwAzlaMezCltGsYAVyqGHcDJjcyADiw0QGMb3QAezY6gJ1D9UWIxTXB4fbl2LLb'
    b'o4rJr6OrQwegroZxCNTSJoDcBnJrE0BuA7m1CSC3gdzaBJDbQG5tAshtILcS7sdeXMWf7c9n'
    b'FScp130WQ7hwSHgDT1aMvxwRZScvA6WWeuvn0ZTSjqbM5FALv9fM2deEkVxqqXaQsFR3NGEk'
    b'l1r4qmbO7U0YyaWWoiT11xo5u5uxkket9r+20zVyhgtA++epGjm3NWEklzoAzuCXijlDNweI'
    b'iGt4tWLO3ubsrL0Wt8VTSmOKo+Wy4oKrGG1DG3gtLoaieCHh+Qo5W7G/MUdrrOWrwdfxRYW8'
    b'hxrwkkXXAYiIeTymfH1wtDFHa6z/7AdExPd4qiRvIqV0qBlLa6sVN0Qi4h0cL8k9mVIa6RWQ'
    b'Ulr/S+eS8tMTepeensG2LrkHFYXOR3KX0fbsY4Ua3OOKt7a6QfgMdy/LmfDvrtLceoZQtRD5'
    b'CVzpAeEKXlacv08u6XysdwjVAxnH1yVDYkbxWstK99YlhHrBbMMr+LsERLe27iD8vyTua0+A'
    b'Aw+hv2QO4L2SSbIbhGO5O983gCUg9uMlRZlqHQjTuQGsapFUSmkLDuHhdhvX+/RpHo9HxLur'
    b'ZqKmGq0SSyndohgmD+BexZb6XdiBmxWvt8xhKiI+bMxID/0DSBGQ5AqDWnwAAAAASUVORK5C'
    b'YII=')

#----------------------------------------------------------------------
reboot_System_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hk'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAgFJREFUSImt1U+ITXEU'
    b'wPHPeTP+lQViQZow/kQWbJlZEIoSyZ6VhWwo5W+vFwvJXsoCk41iIbGQFYlMxr+NZqkRZYEk'
    b'TWaOxb2j53lP5s079evec+7vnO899/zOPZGZ/lfiTPQbdwtj+IAXwlPdbuWJ/NjUZzKAOshd'
    b'zK4zj+GuipN5Ol9PCQBRiz7cKyG3sbm8H8N5nMpqjkNl0tGR1XyE7Tie1dyl2xoMogvHcT1q'
    b'UWk7g2YStZiPt5hXmo5mNS90DFBCLuFAqY6apqetT9SaYLBOm+6n/Z0FpJEGfVtnAXxt0Jd2'
    b't9oZEb0Yzcx3/x1+nme+WC7NAePGZOZfCzMxgo0N9sW4iZnN/Jqtphlk5o+IeI6eiDiMxGe8'
    b'wXwciYiVWIi5GMeezHzfGKtpDSJiHV5gH1ahFy+xFqPYjeHSfxhPsKBZrFY1+ISNuILViq7t'
    b'wyvMwH0sUzTWSLl/VlNA1OIOFpVpjgoXM3NA8X8REcfwODMPtniZf8pEBut/W9IQBn6rmefa'
    b'CTwhFQw12BZOJeDfgC7XFKdkQno6CshTOYwbdbbeiIiOAcrrIcUIhDlqRYE7BshqfsJWFHM1'
    b'XY6zsQKiFsfiTPS3C/hjHkQtluMqNuA7HmAnvqnYkafz4ZQAJaSiGBpHsKLuUVuQlhMtalER'
    b'NklbFF29BDNU7J0M5BcY7t8Bt1Vl2QAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
reboot_system_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACdeAAAnXgHPwViO'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABsJJREFUeJzl23uM3UUV'
    b'B/DP2VIKlCK18lSIAhKgKFZLoGogkWjFZ6KIgICgBg0oPiIRiO3ldkkxiJaQqFghgIUSIxAB'
    b'URB84x+KD4oKTTBQHwRQebRQSml3j3/M73a3uN179969uzfLN/nl95uZM/M7871nZn5zztzI'
    b'TJOBqMd7cANmYC0G8TQexX+wBqux2gyr8tx8qit6TBYBEPU4Cd/FtCaig3gAdwt3SndkLZ8d'
    b'Fx0mkwDGRMJwPI+7cI293Jxn5Ka23z/ZBNA2CQ08huVmuLSdYdITBEAsiROlFdojgTKPXGqm'
    b'r+YXc33L7+0VAiDqcTyuw3YdNPMIzs5a3tTSO3uJAJpawjo8i71baOoKfCZr+fxoQn1jV7G7'
    b'yMV5vXAKBl5UtBYLzXSgsBjPNGnqE/hN1GPf0YR6zgIaeJElrNVnYS7K324pXxp72ORqvLNJ'
    b'U//AMVnLv41U2HMW0MAwS3hCn7cP7zzk+fk43o1FynfCtrAvfhn1OGCkwp61gAaiHrtkLdeN'
    b'KrMkzpEubtLUAzjyxW31PAGtIupxJT7WROyWrOX7h2f07BBoA19SVonR8L6ox8nDM6YMAVnL'
    b'/+JbLYh+PS6KOY3ElCGgwg9akNnNCz7XSEw1An6HJ1uQOysujllMMQKyloO4vwXR2Tb4CFOM'
    b'gAojfvCMgOOYmgT8q0W5o+OimDP1CIimS2ED29nkyKlHQPNvgSGkeS9tAjjspU7AHlOPgNbn'
    b'AHh5J66n3sSgB/BJEGZvVZZm2drdtnHcdoMRsQM2Z+bmcWlwgtDxEIiIBRHxJzyHxyNi9zHW'
    b'nx4Rh3eqR7voaAhExAzcglco3ti12AX/HkMzl+FoHNKJLm0jM9u+cDCyut7VRv2vVHXX4gxM'
    b'70Sfdq5OJ8GHlYDmrvgAfgQRsT9OxfeUYOfx+Dt+hbMxFw9WdSlWczKuiIj98GHF63s1tq/a'
    b'ulsJpO6ubHuPUizvpuxkIuuUQZxuyApOV+aVJ6v0R3Fl9XwZrqqe11f3Y6r7GsX7O6/q+CPY'
    b'iGtxXyXz0LD3/HjY88JO9O94EszMq7C8Sn4Tr8K9VXqdoe3pWrxVCWzOx96Z+VPFo/tEZg6g'
    b'HzOxoOrwobi1qr+zYjXwlqocDupE/44IiIhDI+IEfF751XbAx/HPSmSDYsKUiM7lVXoVPh0R'
    b'21c6vFDJHKX88iuUjt1oaEK9lC2e3+WoV887d9KHTi3gEizKzOcUbwxlYmzMLW9WOgXrM/Nr'
    b'VXo1zscJVdmsiJiOWQqJa3CS0uGdKplHsXnYcyMAuqGTDnRKwBwcEhH3KEEKtl4CFxmK3Lwm'
    b'Ip5UOraqyntDdT8Ynx1W92GFqJ9X72joOnvYc4OYLQ7OdtApAbdV9/mKaQ/gGvy1yh/A76vn'
    b'fZQOnKnM+JRVY7DSY3esrPJr+JQyzhsRnZ0MEdCwFDgrovj32kGny+BSbMI7lAlvWWbeExGr'
    b'lDlhtRKsmI+b8Qscq5jttZl5V0Sco4z3i5Txvx5vwl+qvKW4HXfgdQrBKxRCbsJtmdksULpN'
    b'hCXmGrSXPhuVz1nC0wak7Ww0rco7z9NjXW8j4o34iWKmx2Tmz9pVtFsIF/i28hXWCp7JWu7S'
    b'UsMRN+CDVfJR7Jc5eqx+MtBnbA6EWVGPXVuUvVeZtf+M9/Zi56FPtBRIGI5RDxw0kJkXZub0'
    b'zHx9Zv6hDd0mBH1aCyQMIezTHVUmB3363DfGOnt2RZNJQp9F1hjL/j3t1jVtJgF91dJ2a1PJ'
    b'IUwtAkC4eQx1xuTy6nUUAvZ0u6EdXDNMsTkAeUZuEr7RYp29uqjPhGNoM7S95Vo7XHBALI/p'
    b'XdNogrGFgDw3n6pOYDbDDI87sIs6TSi23g4f7HL8sWmt9LYu6TPh2IqA/FAOmOYEzfYHWY6X'
    b'TAX8n0Mkv5wPCmc2qXdE9MeCLuk0oRjRI5SL8zrFK7NtDPpOXBIzRxOJerS0dZ5MbNMllrVc'
    b'gmWj1J1rvRtjWew4UmH0x+F4KJbEiR3q2FWM6hPMWn5BuEAJQIyEhdb5dVwY+w/PjP44wqA7'
    b'MUda0csktBQej3qcpvj0Z2xDZCOW2dFSG8xVfHgvG1Y+IJySi/P6DvUdd7R8PiD64zCDVho9'
    b'ivuY4qwcaez3JAljOiARy2JH6/QrAc52vgZ7joS2TohEPQ5SQlUL23hnT5HQ0RGZ6I95Bp2n'
    b'HDuNMVQdEE7Pxbmi7ZePE8bljFDU40CcpsTxX9litQGcmrVc2VSyixjXv8zE92Oa+y1Qoj/H'
    b'4jCjL7WTTkJX/zMU9dhZn3nSfOm1ikv91cqJksZqsRnHZS1/2DVFRsH/AO4OKN8jGjRjAAAA'
    b'AElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_bootloader_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hk'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAehJREFUSImt1c2Lj1EU'
    b'wPHP+ZEpKZTSeJnIsPCykKWZxSB/gY2FYkXWCn8AO+vJ1iwm0hSxZTEkr4NkYYooYSFlKObF'
    b'sXBnuvMzi5/xnLrde8+9z/k+5557z4nM1KlE6McIZvART3EfI5k+LfhRZv5TI/vJCTKrNk1e'
    b'J3f9tf9fAQXSV0GuVeNp8jzZ+i9ABTlTxhvJh5VHw7OQRQMWAK4hP1eQU40CCuRiBfhJrm11'
    b'fIU6k0fVeBmONg143zY/2DTga9t8c8w+tIjYgG0YzcypeldEBLbjZba9zIhYjvWZOR6hCxuw'
    b'qizPVAFyBzcxMD9weov+Ppb8HVj7cK6aR71eH9F77MBURDyJiOMRcQ/HyvobHI6IZxHRFxEP'
    b'I+IILhQnhyNiCM8j4uych9URjWASPXiMPXhRXP7lT/75gglsxUr8wNtyJBtxufRnM/Mb5nnw'
    b'GEtwEt04jRUYxDs8wG2sxiW8xlVM4xbGi52xWeMQ5A2sK385icFMQxqSpaXfXenGaA7QKgZr'
    b'6W7K+CzgEuq73dMoINM4rlS6LRGiMUKVaj9UmXB/Yxm2SrU7yY8F8IbcWvRnyP7/BhRjveTd'
    b'Avle6myWkrgoyEJFo0WeIF+1FfZFQeZSRbtEaGEAB7AXm9CFQ5lGO43xb4+lwiK7QKG7AAAA'
    b'AElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_bootloader_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACdeAAAnXgHPwViO'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABuZJREFUeJzlm22MlNUV'
    b'x3//YZGXZanrgkjaIo2v0RiCVZDGFgu0aKNGCVpZAuJLfGuqJkZp0yJt07htIbRfWqEbaVoV'
    b'RI1RsS3Kt1YMNtUoEdHY+lJAEFAXENhdlj39cM7sjuPOzDM7OwwznOTJvc+559459/+cc577'
    b'3HNHZkYlSOJy4ElgCLAX6AbagB3AbuB94K24Xjfj07LoUSkAACSagb8AgwqIdgNbgBeB9cDz'
    b'Znw2IEqYWUUvsGawLjAr4joEthZsNtjgkn6/0gCUAEL62gH2c7DGqgUgQJhTAggG1gb2M7D6'
    b'qgQgQLgW7HAJIBjYNrBZVQlAAkvYC7Y9IRCtYEOrDoA8ILSBXQRWD7YIbF8CEF4BG1d1APQB'
    b'QhvY5Kz2MWB/TwDCB2CnVx0AGSDsAbswR3sK7KdgRwqAsD0XCBWfZAIQRiaQuTeBJbzZ11gV'
    b'n+AAAvVQAhCeye5X0aXwQJLEKOC/wMgCovPMeCR9kyqrVkeRzNgDPJhAdJlEU/qmZgAIejqB'
    b'zGjg7vRNzbgAgEQK/5Q+qYDop8CpZuyvKQswoxt4M4FoIzAXas8FAP6TUG421CYA2xLKTZVo'
    b'qkUA9iWUqwMuOp4BAJh4vAMw4XgHYMzxDsBJNbUQgp5vgllx25jV3IAHvzR1FARAUhMwHNhm'
    b'A4CWpFHAITM7UMIYI4BGM9taqj59uoCkOkkPSNoJ7AH+B2yRdEaxPyCpSdI0SSlJD+OZn/n9'
    b'VVjSAuBDYHV/x8ikXDHgG8CPgTHAL4DtwFlAczGDSxqKp78WAScAX8dNsKOf+gKci5tyZwlj'
    b'9FAuADYC7VFfA2yIetJlZprWAJcA5wAL4x6g3+YP/CnKYoJdTuoTADPrpHeyU4HvAi8QE5A0'
    b'VtJySaskfTPdT9IVkp6WtDT8dGM0jQZG0Qtqe8ifL2mNpD9KGh+8Rkk/kbRC0j2ShgR/pKQ7'
    b'6HWfQ8EfIelHkv4g6VJJwyT9UlKLpJmSWiWdnBOB3FtMbAAs41oDDA7QNmXwDwCnBlDdGfwn'
    b'gK9F/R8x5sK4nwl8GX+Kafm38CTpr4GPgZ3BX4QH4Tey9FmJu9PLwP5oPwz8Ltr3AQejfl+u'
    b'eeZbB6TNdF1M+FrgAWAGcB7wPLAglLseuAsQcCvwLHA17qvg6W+AoVEeBm6K9mXAUjzGTIv6'
    b'pXjWGGACMAf3/b8BLcHvAq4AJgG/Cfm60OsIUA/8KmR355xlHgv4Z6D3HeDGqH+GB0UDLo7J'
    b'G7AKf2Kbou89wW+O8qngt8T9jAC2M0CZHvwfAotxS9oavLXAY1GfhFuaAa24tRieOu8AXsPP'
    b'G3TggXso/t2fM0OUzwK+FOVXgLFRr8fNnUD7exn1BqBOUgo3cYARUaYXJMOiHBTyir6XBX88'
    b'bvJb8MBpuLWkd3i6gHlRH0zvBuhHwJ3AlQHeCcBuM2s3s0fNLB17vkB1uRqAE6NcmcH7AI8N'
    b'8/H9t+HBfw04HZgYyozCzfCdaP+WpLsy5M8C3sZft++FPLjfDsKBWRJlI/ButL+Socsk3DIA'
    b'mvAHtRl3R+gFPz/lcYGP+HzQOYD7ZiPwSQZ/F3AycFuW/IOhVDow3go8EvWtMfnMoPlSTORA'
    b'3HdllLMyZDuiPIi/nfZmjNGGW4EBO5PkE/JZQDPw/UDybaDVzD4EkDQd99duYImZ7ZK0An9D'
    b'XII/qd+aWaekH8QYD+FPezew2sz+JekqPMBtA1rM7BNJ38b9fD1wA/CCmf1V0jW4WzwF3A6s'
    b'NLNXJU0Fbg5g/hw6rcYXYAVJYOfiPt4RqBJIWjbPjNr6csIBWAHcklB+v1nBzEtVUYrilpQN'
    b'Uk9wrAlK4QGtGBpXDkUqRSmSJRIy6avlUKRSlF7XF0OnlEORSlEKP5K6q4g+o8ujSmUoFa+2'
    b'tUX0qS0AonymiD65v62rkNIArMOXp0mo5mIAZhwGfp+wz9jCItVDPdviEo34NlihwwUdQEOA'
    b'VvXUsx9g/oeE+xP0GQKcWTaNjjJlb4gsB15N0G9aGXSpCH0OADOOANdR+Ptgbtk0Osr0hS0x'
    b'M94B7ijQb7LElPKodHQpR16AR/HNyXzUKlGfT0Cqgk/nAsdPlxU4eroObFiOvhfGQec5lT5G'
    b'm3eOCc7gLgbrzgPCv8FOy+ozGT/ibviR92MWhGRC2AKw9jwgtIO1gDXgf2poy2o/ZkFILohN'
    b'ANtcwCV24H9r6avtmAShOGFsGNhSsM4CQOS6jjkQ+tcJOzsCYNWDUFpnbCLY4wWCZC4Q5lV6'
    b'8mYD9IcJiTPxTPF8PO2dhI4A881YVbICJdCAnhKTGARMwZOdl+Gp7XwJ2IqDUNZjchIj8ITp'
    b'BcAZ+Jb6eDzxOhzP7nYBs814rmyK5KH/A7hsklgxExJoAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_fastbootd_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7eAAAO3gGHS9U9'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAkxJREFUSImt1U+IVlUc'
    b'xvHP785rZGOL/mj/mKYiMFMX4k5aRdMQUeHWXQa1EdoEgfV6vb6ZDATismVBSAiVLiqwcGFE'
    b'MVhhIWMEtUgsg/4RiUNzfy3uHXjnbZCcuQ9cuOfhnOd77rnnd05kpv+rA3FgOuVRXMFP+Aqf'
    b'450yy0vLjYlrAbSQqZTHsXbIXsD7heKlfva/XhUAqqgewXHcgPcwhfEW9Br2llnWUFxzOsos'
    b'P8ITIV4os9yJB3EGY3gRb1dRFSv+guV0KA6tnzc/h5shxMv7ct/BzgBQRfU6nm2b//T07lvR'
    b'El1Fs0PvvQULuzsFhLgw3E453TXgzxHr3iX/ICKux0F8mJknh/xJPIAiMz/4T3DElsz8Zl2s'
    b'e3TCxC277PoWanWOAtZgDk/ibnyi2ePP4SJ+xqvYgh9wm2ZrvouHsBvnM/OtxczeyGRuRI1N'
    b'GOBEG/Y9zmInDrfBF3CP5siYxTPYhiWVPAqo8SN24Hes1+zrm9r2WqzBhrbvrZpivR3zmMRd'
    b'VwMsdjyCj/FLO8s5XMIpnMbDmsrd1C7VJL7DRpwfDoz99p9tQ6W8ctnlmZmcOaEj9dpnK4Qw'
    b'bnyrZu07UYEvh42Ud3QVDkWIN0e8yU4BKU/isyHv/k4B7cXwNP5uvY2DGGzuDABllnN4HH8h'
    b'avXRKqo7IyKqqF4ZxGDbSgFLjopBDLbX6jewGX/gUzyGXzFVZvnFqgBQRXVdiOdT7tGcR4v6'
    b'rVBM9bN/ZlWARR2LY2PnnJvWVO0OTGCsUDzVz/7ssoOW0b/OPcpOb+wFsgAAAABJRU5ErkJg'
    b'gg==')

#----------------------------------------------------------------------
reboot_fastbootd_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACdeAAAnXgHPwViO'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAB8RJREFUeJzlm3+MVFcV'
    b'xz/nuXSHLiz9YcsWQ1MFogJipRFtxKQWKoX+SI0Vm66C29pWu2KLoQVMZt++t7tNadNaumoM'
    b'2gYj+COUxJ9VqP2BCKQ20WJbqi1aDZG1CG3ZhRZhmOMf9zxmXHf3vTc7sz/GbzK59917zr3n'
    b'nXvur3PeiKoyHAglbFb0QcADXrfiQ8Cr9vubIH9S9EXgj7763ZWQQ4ZLAQChhKsVvSsB6Ung'
    b'BWA78Gtgq6/+m+WQYVgVABBKuFLRu1OyvQU8Jsh6RX/mq58rtf9hVwBAKOEdit5TInsXsK6W'
    b'2rWrdNXrsdS9MCIUABBIsAK4dxBNHAYeqKPu3hW64mhSphGjAIBQwuWK3j/IZvYDt/nqP5KE'
    b'eEQpACCQ4HbgfkD6qH4NyAHnJmjqu8CtcYull1rCCsNX/wHgdqD3yBwE5o1l7FSgDYgz86XA'
    b'rnZpnzIQ0YizgAihhMsUXYuzhAMe3vysZp+L6gMJJuFGeX5MU10e3mVZzb7QV+WIs4AILdrS'
    b'Kcgy4J8e3qXFLw/gq78fWCBIK/9rLcU4L0/+yUCCmX1VjlgLiBBIUB93CgwkuBNYE9PUK8Ac'
    b'X/2DxYUjXgFJEUjwEHBDDNlTwDxf/XxUMGKnQAlYCcTdFy4RpLm4oGoUYKb9zTg6RTs6pGNy'
    b'9Fw1CgDw8H6cgGx8jtzqAk8VIU/+Gdx5IQ5NgQQNUGUKsMVtTwLSjCA3QZUpwLA3CZGi10J1'
    b'KmBfQrpZ7dI+rRoVkNh1lic/9/9aAYp+oOoUIMjhFOSzqk4BpLAAoKHqFCBIGgWcXZO6A5Ez'
    b'gUnAPlUtyVcvIrXAaaraUwr/QKih5qUuupbXUXc8Q2acIKc8S4qOA8YUkY9BVRP9gLnA73B3'
    b'bwV2JOU1/vmWtgJHgPvS8PfR3lTggl5lY4D1OLdZU5J20kyBxcAHLf914FNJGUWkGXhMRCYA'
    b'nwDqgGMp+u7d3iTc1fb6XlX1wMeBt+GUEIs0Ctho6SuqukxV9ydhEpElQKc9rgKiC0tJkR0R'
    b'qQd2Ae8AFojINVGdqh4CNtljoumZZg04YmlGRD4NvIxzTC4GxgJbVHWbiNQAzcCHgTeAx3FT'
    b'RnBWEykjLyJNwLOq+gd7uTnAF3CnuU5VPSgiHvBF4CLgSeCHONf3+cDFwAbjnQbMA6ZZ+8kU'
    b'nGLObaIw/xV3934JF5A4gYvfzQC+avUHcWZ4C+6CosBEoMny/7a0B3gnMBM3LaL2t1q/7b36'
    b'bTQFK9BmNJfiwmXFdHPLvQa8YelfgEXAbcA1wNXAL3HTaTbwIaNrBs4G1lGwnkPAOMvvAHba'
    b'82esvVqgA9gMXCYiFwJfMr7rTKnNprSoPYC7jNencBtMFi9MYQFX4TT7E3vOAFtwI99tdbcA'
    b'C01ABX6KW5h2G50Ad1jdImCW5TcCfwb+YTSfs/J7LL3b+nzC+rrJym8FzrL8TqP5nj1fXG4L'
    b'qLM0mltNuBX3a8DNVnYCF75+n738VcBqU5aHG+3XjPZdwAHL54AzgJPq3uISK58Y1dv54/3A'
    b'adYewATgHMu/ZTRRnKB4v+8XaRRwuqWRG3m6peNxixS4kNVe4Nu4EQW3X0cCb6BwXe0AfmX5'
    b'Z4xvsojsxUV1oLBjLMd9H3CWpbVW/hXcoewkbh14FWiwumjLHhgppsAKe/mf2/ONFBacvKW7'
    b'cVZQvBjdDDxn+SdwlvSvovq9uGlyYy++LdbPb3qVX4+balG/M4FfFNWftHR7kvdKsw2+29J6'
    b'S9fjrGIC8CzwSWAtbgQacaP0KC589XfcFrhGVY+KyEeBz+N2gk5V7RaRh62tBbiFLLB+rgNC'
    b'3Ej/SFW/b2eB2cDTqvq8iNxgA7QPtytdiNs9YpE4MCIi23HH4Q2q+tlETKMANaGE8xQVD68H'
    b'txjl8uSjbeZILbUnPLwcsBX4AfCd4RK2EpBWWo9QWOHjsNlX/9pKCjTU8EjnQJgcTzK64FE4'
    b'TSXB+ZUSZLjgAS+moJ/YKZ218WSjB54gu1PQSzfdSb7PGTXwcF6exMiROyeeavTAU3Qb7vCQ'
    b'FNVlAb76x3HX2UQQZGI81eiBByBImsNNQzzJ6IEH0KItj+PO87FQ9LyKSjTEOHUdFiTJZ+sA'
    b'762QLMOCUwpo0ZZNOKdjHGZVTpyhR2+HyJeB4zE8DW3SNqNC8gw5/ksBvvrPC3JnHFOefGPl'
    b'RBpa9OkPCCR4BOfg6A8HgGmV+h/PUKI/n+AS4LcD8J0LPBjXeCBBfRzNcKNPBfjqv5khcyXw'
    b'+wF4lwYStPVXGUrYCPw1kGDOIGWsKAZ0ia2RNROOcWwzLuTUHzZmyDSv1JWnjtOBBEuAh3FB'
    b'ysMe3oKsZp8ul9DlRKxPcJ2sG9NF17cY+EPkA0B2OtMf2sOepTi3eLF1HfbwFmY1u2vQEpcZ'
    b'iZ2ioYSNin4D57ntDy8DU+h7anUDC331d6aWsoJI9bl8IMEFuG8Driixvx6zhB0l8pcdJf1f'
    b'IJBgEXAf8J4S+uwBFvnqD7TLDBlK+kjKV/9RYIYgV+PCWmkwHtgSSvixUvouNwb9jxERkVZa'
    b'P4KL6C7GvWASHPXwrshqdtugBBgkyvqXmUCC03FBystxIa6pMSxHgSt99Z8qmxApUdH/DAUS'
    b'vF2Qi4DZik7BxRUmA2fiYodn4D68uNxXP5Vvslz4D+ARyhnNLLTBAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_download_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hk'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAlFJREFUSImt1cuLHFUU'
    b'BvDfqQ7JIgEfqKCLQYkRdKNDduoIxgco/dj4BwiiINGViAYDYVyqKzdBfKAGXWQx0k0xg0hw'
    b'YRYKkQ6ITBwlASUQMSAECTFh6rionqS7GYPT1oGCe75763x8p746NzLTf43o9xdELGEd53AS'
    b'32Epu93fN31nKwRjJMvYNQavi1hWVW9kr/fD/yKAKMuHVdXKiGSAfaP1Ot4yHB7MQ4cqKLZc'
    b'HdluH1cUT8k8kN1uT+Z9OIEWDpif/ywWF4uZFWwWUZa3yPxJ5s01EK9mp/NOYwQQg8F7eGGU'
    b'XsbcTC26TpwYW28X8WyzBJlnp/InmyVotS5MIXdtG88i4gH8nZmr16sTEffiTGZemthYWTlp'
    b'ba1t//5zI2RdZl59sIovcD+Kqb1trrnuc8xtcuYefDyOTbfoTxzDy/gxIt6PiNci4kN8iVMR'
    b'8T3O45HRmcci4tuIeB5HcHFC7bhNI2JVPVtuxa/Ygd24DUuYxxX8gVBbcQ924hJ+w5XMfG6j'
    b'5rSCr9VD7BXchDexjI/wtnq4HcdpfIUb8C5O4SguYG1CgX6/xB0iKlV1WVEczk7niIZiw0Xz'
    b'MomgqobqXjYSBYYTSMTtTRWvCYriU4x/6blGCbLd/lnE0atI5u6oHdIMAYh4Se0euFFZ7muU'
    b'INvt81qtJ1Dfq1X1QZTlHoh+//Xo9xdmJZj80QaDu/EJHsRFEcdkdvCXzKez1/tmJgUbkd3u'
    b'L4bDBbyIs6PisEvE8ixK/vVGi8XFwt69j8p8XOZDuBM7ZD6zFSX/AASR/KSWK+n0AAAAAElF'
    b'TkSuQmCC')

#----------------------------------------------------------------------
reboot_download_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACdeAAAnXgHPwViO'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAB79JREFUeJzlm3uMVUcd'
    b'xz/fc3dhgW4ppS2vWkmh2BQjQanQJq1NbcHN7r2bRjBCH4ASbIoiahqjSYsSrdVGIaa1ldqm'
    b'gKXqqsveuwIFNDHFxlaF1KjUiC3R1nallEex3ef5+cfMZQ/r7j1nH3f3cv0mJ/P6zcxvvvf3'
    b'm5kzc4/MjJGAcrk6zH4KjAZOAiFwAngNOAocAV4kDF+ksvIFq609XhQ9RooAADU1LUPaCqRi'
    b'REPgENJ+YC+trU/bkiWnh0SHkSQA+kVCFK3APsy20NLSZKtXdwy4/5EmAAZMQh6vI20mCDYN'
    b'xE1KggAA5XJLMdvGwEgAN49soqrqAVu48D+J+y0VAgCUy30MsyeBikE08yqw1jKZnyfqs5QI'
    b'gFhLOAWcBqbGN6QfUF39GbvhhtZCYsGAtCwiLJ1+Cul2oKtH0UmkRVRVzQLuBd4q3JCt4tSp'
    b'36i5+bJCYiVnAXn0sISTmC2y+vrnzpRns5OAJ4CPxDT1D+DDlskc7q2w5Cwgj4glHEO6OTp4'
    b'AMtkWjh4sBa4B7dP6AuXAb9WNjuzt8KStYA8tGvX+VZTc6qgTDZ7N/Ctwg3pEBUVC3q2VfIE'
    b'JIWy2ceAT8SIZS2TqY9mlKwL9BtB8EXcKlEIGWWzt51VrXgaDS+sru4NzB5OIPodNTZOzCfK'
    b'hgAAgmBHAqmLSaXWnalSRHWGHwcOPI/0ZgLJNcpmq6HMCLD160PM/pJAdAJwK5QZAQCY9brh'
    b'6UVuMZQjAdIrCeU+pMbGieVHQPxSmEcFqdSC8iPALCkBAHPLj4Ag6A8Bc8qPgP5ZwKT/dwIu'
    b'HMzRU2kilTqE2ad8akKP0mrCsHvMQdCW6G1Q0gRgEtBiZkW5oIj0NR6YaGYvDaKN0cAcM3s+'
    b'VtjMCj7AOqAdMKAT2A5Ux9UbyAPcjTvzzw2ijauBf3l9x8fJJ3GBDwKVuOuqncByr2Tcu/dA'
    b'MBl3VfbOINoYDVzi4wUPRCHZTvDPPvwTsAo4DiyTdNGA1CuMH/kw8bl+T5jZfuAVoM3M2uLk'
    b'kxBw1IctZtYJvIxj+XpJ4yRtkvRLSWsBJF0r6XuSLpQ0XdITkj4paaqknZK2SnqfD9OSlkm6'
    b'z/t+XuFW39Y0L/e0pFt8XkrSFyRtl/SwpPf4/ApJqyRtAC4gqRUl8Kk7cP70uE/v8enP4k5l'
    b'LfKsw80TBtwM3O/jP/HpLtxW9a8+/0Sk7leBOT6+ERDwh0h5JzAXuBFnhQdxh6G/83pt6aHL'
    b'a0nmjCQWMNaH7T4c7cOLgKXAYWA+8CZQD/zYl1+OmzMALjWzvcBvvdLbff47QLOPvxuo8vFO'
    b'4Frg/cA+4Cbc8fhK4BngOt/PKeAqSTOA24C/A7W+j84EY0tEQHUP2Wk+nASMAh71y80RYBbQ'
    b'5MuvAN7w8ct9OA5nQS/79Fbgaz7eRTcBAW7yBfg28CvcDzALWAT8Hljt+x8FXO/rfNe3/zbO'
    b'gmKRhID8NdRYSbMjgznow2rvh+/16QM+vAm408cnSbrLy9yPW1UAjkX6aaebgAq6La8aSOMG'
    b'CvBNH78OR0QHzufBWeVK4LyIfGEkmAMacT51Eud7BvwCmEm3b+b3CVkc88d8ugP4I91++Zhv'
    b'c4NPfxlY6ON7gY/6+D7gFh9vw1mHAV/HXYl1Ad/w7Yd0z1PRJ8RthgqPLwEBe3s0/Cow05ft'
    b'juS3Awt6kPZp3L7BgP3AGF++zedtADIRIu+JtDcP5yr59FGcNe6KDLDNx1cA//Tx077MgOVx'
    b'44vdCku6FHd+NhU3yWzLb4f90vU53Mbjh2b2rM+fA3zAzB6XNBZYCzxoZqd9+RrgSuAB/4su'
    b'B571g7gTeM7MdkqaDqzBucyDZnbY7z8yuP3JbD/QLcAMnKvsBmqAQ2aWn4T7Hh/Z7GzCcArQ'
    b'htnbPv8ElZWGWRuSy6utPWGus7KCaGr6Pm5GTYK3LJM5v5gKDTeCfr4/V2vHjgvixc4dBAkv'
    b'EiI1goJ/ODjXECAluUiI4l1F0WSEEODW6eSQJhdHlZFBQDp9BPh34hpheHHRtBkBBH5pyyWu'
    b'IZUXAQCYNcXIRXFJvMi5A0dAS8tu3C4sCcpsDgBs9eoOpIcS1plSRH2GHd2vw0GwOeGeYKY2'
    b'b66MFzs3cIYAq609Thjem6DOaKZMmVVEnYYVZx+ItLc/QveBRiHcWBRtRgBnEWBLlnQRBB8n'
    b'7o7d7NZiKjWc+J8jMaur+xtwV0y9+WpuvqY4Kg0vej0TtEzmSczWF6wZho9qz55xhUS0a1fJ'
    b'vzr3eShq9fUbkDYWqDub1tafqaFhTG+FyuWupqPjJeVySwetZRFR8FTY0unPA1+h75OgRVRV'
    b'PaMdO2ZEM9XUNB93DzARs22lTEKy6/FcbgVmj9B9KdITbUgbMbsPaTZmu4HxkfIupNstnX5q'
    b'CHQeUiT+t7iam+cQhtuBqwqIvY47z+/N90uShMR/kbG6uhdoa5uHu6np6zu9yfQ+eIBUKbrD'
    b'gL4XUHPzlYThJtw1VX9RUpYwqA8mlM3OBb4ELCbhXZxHF9JKS6e3DbjzIcKQfDGixsZZpFIr'
    b'cFdU0wpLn0EXZndYff32eNHiYUg/mVFDQ4oxY66hq6sGqQZ3319onhlxEor6zZAaGs5j1Ki5'
    b'wDykK3BfcE3H3ebmV4tOpMWWTjf33VLx8F8xtuaSXOOXMAAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
reboot_recovery_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hk'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAgZJREFUSImt1U+IjVEY'
    b'x/HPeWfCQkIsRppMSCzI1vjTTExRYqFsLZixsFJkoqSsZKm4xsa/DaVIo5QoSv6OWCBF8r8Q'
    b'khjmPhbvNV435F73qVPv85zO7/uc857nPCki/LOtSwtkTmAIL3ELV5Sd0Bevfrck1QT4CenH'
    b'6EJ0CP3YqhR3/g8APWk+zlQgp9BZ+R6S7NJim+1Rhqx2dZTiEpaiVylWaDYL19Ek9HruqB0p'
    b'q38Hv7OeNAH3MR6ETfbH7sYBckgJ3RVvUFlrfUf0JwvXC94ITdY0FpB5VhXpavQOPlT5bc1F'
    b'P6WUoR1NEXGhZsBI13wxTdnYXNCQiBgemIwBeYVOLs7VO5qrcniDSbiHjpTSapzHItxEB57j'
    b'NiZiJt5jBp7gBu5GxLEfgtX/YEwl+1FYicfowk7Mkb8/n7EQLXiLD9iMp5iPb0XBakAzrsrL'
    b'/3JF5Dh6cRbvUMIR7MG4CvRhZU3C16Jgim6nMUlSFgaFvfbHYTVaSqkNJ9EVES+LGcNcPwo6'
    b'M4CaARHxCLOr45kwUBVrqVX8b5bJHELxQWptLGBfPMDwtRKmSik1DpDbBvltgLF6dDYWUIrX'
    b'MkuQ99VwwPo0HfSkLdalBfUCfu0Ha9M0TQ5iHj7hHJbjo7Jl+uLi/wFgR8q80C1sxPTCTF2Q'
    b'P3e0HNQhLJa0C1MwUtmqWiDfAcFy7COezKmHAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_recovery_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACdeAAAnXgHPwViO'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAByRJREFUeJzd23mMXVUd'
    b'B/DPedNSWmihLLKIVQLi0pjaiFBISEWCdUEwgA0g1KIwU6EQgxL1D8FgQsSqVE1hptQgbQAX'
    b'FgEXGogBEYmYaDCyGBCqgux0Aek68/OPcx6zMJ333sy8med8k/vu2X73/M73/s7vnvs776aI'
    b'MC5oTydIbsIUbEQPNuBZ4UUV6/CY5DHJQ66K9c1QI40bAdCRzsBqtNVo2YNH8XvhLpOttSJe'
    b'Gw0VxpcAGiGhL7ZI7sZ1wm26Yvtwux9/AhguCVU8J1mpYvlwpklrEABL0unCGsMjgexHltts'
    b'mdXx33qFWocAaE8LJddj0giu8ozkQp1xSz2NW4sAalnCJryGA+u40irbXODa2DJUo8owVGwu'
    b'OuNGyVnoHlCzUY8FNjsMl+DVGlc6xy7u15FmDdWo9Sygiv6WsBELdMUf36g/N+2n4sf4aI0r'
    b'/Uu346yKJwarbD0LqKLXEl4Wju83eLgmnnegT0i+Lq8TdoZZ2tzrnHToYJWtawFVXJhm+EFs'
    b'GrJNR7oY365xpUdNMW/gtVqfgHrRkX6Ez9VodbuuOKlvQetOgcbxFfkpMRROtCSd2bdg4hDQ'
    b'FS8JV9dsF75nadq7mp04BED4RR2t9rXNF6uZiUXAQR7EKzXbJef7fJrORCPg0ujBI3W0nGmy'
    b'zzDRCIBk0AXPmxBOZSIS0OPpOlvOtzTtPfEISDUfhVVMst28iUdA7bVAL5K5E4+A+i2AHnMm'
    b'HgHRAAEV+008AnoaICDsNZLQU2ui4lFJR8nN7FcXpos+4baKrQ29DaaUEt6DfbEuIv45YoXH'
    b'GXVPgZTSYvwHD+MerEsprU0pTWuOamODRnzAedgfj+MEBD6CE5ug15ihEQJ+Vc5/wJ3YXPK7'
    b'jKpGY4xGnODL5fwiFmMansUdkFI6FsfjKVwbETtSSnNxGl5HV0Q8l1KagwvwAr4jL1zOlDdG'
    b'75ADGx/AGXKs77M4BGtxH5ZiL/mGLMQVeD9OKrIH49P4aUTUfjGKiLoOtMtm/5ocsg7ML3Xn'
    b'lPwj5fwlHI1teKkM5F68vQw4yvG7QkLgARyK7SV/eBnkVjxRyq8odZvk197ALX2ud7A8RQOn'
    b'1DOuRqbA5D7pF8o5pZTacDmexLFlsO/CV4vMPFwn37UlmI7l8l7gMWVwcEhEPIFrS/4ofBw/'
    b'lAOek/BgIWQ6VpV298sWRg6fP9wnXRsNWMCXZWZX45slfTFml/Qz+Ad24Dj5Dm1Gwu7Ysyj7'
    b'aiHm5CJ3FtaV9ExchedxWSn7i2x1T2EG1pfB7YrzsUchPzBV9k+BeaNtAbuV8/oyUPKmxB4l'
    b'PRW3yqb/QCmfUsor8tphT9lCuvGhIrdLaa+QcjJW9OmvR7aw+RGxSfY9z0fElohYEREb9Vrn'
    b'qbI/oNcqhkQjBOxXzrvi7yV9jN6nwFTZKS4rxzPy3V8m35XfyvNzRjkvLXJ/k02bbNYbZZP/'
    b'dylrwxb8KaX0ydJflZwqqqu51X30rM/BNzAFbi0d/US+s1Vndg/u1uuIQl4zLBtQthafGlB2'
    b'XyHp6JLfgDmlv4Pk6VJtu0Xv+mPTAN3uKOVPyz4lMLeucTVAwDW4He8r+UWyV54tz93v4iZ5'
    b'XlZkU/0WfiM7vQOLXEcpW4F9SlnC93HEgD6PwBrZMc7He/FrtA9ot5f82HyrbJ2Bg+oZV4pz'
    b'zcYBwlbVeVOxQZsQtkql7Gobqr21IsqS/HR5GnVjWkRsqykX7brkZ3w9eFVXzBi+ms1BSmmS'
    b'7H/2KUU/j4iF9chWGoqgMN3Zac9GFWw2ImKHvKjahJt543W4Jibp8YrUQG+TzJKdVUshIk4Z'
    b'jlxFpa6NhL4SbxtOR62Kim5/bUgi2b9JuowLKlZZp3dtXxth36ZpMw6o5AdifqWtCxOOgPx7'
    b'W90SyVuapcx4IBMQ7tS79q6FCeYDoCu2S1bUKXNA89QZe1T6pFaq588FHKojTa7d7P8DvQTk'
    b'f1pfUofMFOGwpmk0xugfD1ivE3+uQ+rDTdJnzNGfgJ9Ft+Q0tbaYI/+9ZCLgzRGhznhcOK+G'
    b'3JGWpKOao9LYYvCQ2Mq4Xrh0SMlwjUVpYGiqPy5MLffqPBA7jwmujMtw5RCys01zs4vS1EFr'
    b'29MHbfWkJen0kanYXAwdFO2Ki/ANvUHH/ggLvO4+HemQfuUd6UjJXdhbWNPKJNS3Pd6eFks6'
    b'5WDoYNiKK+1wuYrZKu7UGy6HbslZOuPGEWs8yqj//wFL0hzhBjkwuTM8JwdDB5v7LUlC/fsC'
    b'nfGQ3RwuR3939p3e/gYfPLS14nQY3vcCHendkuXCgmH02VKWMLIPJr6Q5urxNXlLqpHIYrdw'
    b'tpWxZvidjw5G54uR9nSYisXCInlzoh50Y5GuuGHkCgwfo/vJzMLUZqaj8LFyzDG0nxl3Epr7'
    b'zdD5aXfbzFVxON6JWXiHvEtcfVrsEE61Mn7ZPEV2jv8BnBRPSbmXKoMAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
reboot_irecovery_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAKgSURBVEhLrZVdSFRBFMfPXCPFgmwt'
    b'whBJVo16MKKXPsxQaqEg8iGoxx7M9SF6CBKlIIKewseg1nrpC6IgKKIg6AMqoug7okQqotQC'
    b'KbUvM3en35l7d9mwYPe6f/jNnDl7d86dc+fMGGut5KztZrV4ch4rCR/hCdyTFL6j9hP2JOUX'
    b'QOUHuYw103c4aUD17ZGEfe48gfIPoIqbBtoroEEuQnNgJ8XIQamQvbLPphjzLmGUsLdp10MX'
    b'9iaZJouxH0CRWHwDclr2Gzd3uBX8S3Ezh7YXIm5sZbf02G4jtTbCsq7j0gcaba+8cQ+EUdwk'
    b'aNv8gYzz8at0GSVQDrOgFMLLujSlNZ2EbfNwDjLYCi2sRJcYXp70B1ZaMQ/nAoweOAb16g0t'
    b'K6OB5ctKtZE6W4P5FEol+aVZXkcmsIv4+Df1mby00xTLL6kk92VubLQ+6mwURmBM5p3pwP0Y'
    b'tEIrdYdNFV1BlMkeQYl8v9Mq/Q3d2K9AU7YFbsAa0GeaYACewVxYBCOwEN7DQ3jJxGfpnTz5'
    b'TWspFYGJId1N+va6s1rgHcTgACwBPX/GoBEq4DNo3nXlH0ArXFOckddePiwzTKqPIC/k6+hP'
    b'fPdBy/8u6CTnoAuuwjDoXj8Fh2A2aFCtHf2PAX3ljIxtk0v08/kpRZBxOEwFnvR/zl3GmGq6'
    b'CxAjRRrUKX0WLWXiZfQr8Cz3XfmJSd9CffbkKi003TXZ0rQUTFpoJ+izT7yqoC+IPDli++gz'
    b'24pQUU1oMJqy0t9gB6RzVyZxd4EURH6AhB3CWofl36uWIms3tc6Om053TYbU3xdOq6nhiD2O'
    b'tRJ+wDXYCN/YxBu42G9h56XJN5pedYNcGlZ2MfJX4StUkP9fmX6gJgKtpQhX0euxXkyQzbkH'
    b'EfkDA3MNu8/om+8AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
reboot_irecovery_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAAJ10AACddAWJ4eeMAAAhqSURBVHhe3ZsJbBRVGMe/t+VQKiCX'
    b'CCIqYAtUgxg5VJQriAeiEUJEBUHbbZFDg/GOoIagCEI9kBZQBIJGBRS8IIiKgkZRE4xCESV4'
    b'ICAg91Eoff7/M2+6u+3u7GxBO9M/+e07dra775vvfW/egdJaS5UorPqJkoXI1Qb7QCnYC7aJ'
    b'lp0Ski3IF+Eask5e1ntQPuWqOgNQueo2vM4DaVY5sWicDWA1jLNCaspyma4PWu+cpKrWAJR3'
    b'I0TrKLziY6RzYZAlUqiP29Wpq+oNQFXOCI62wxgz0WXyK9NN/GEAKk8Nxt2cj1xljEAxjuTL'
    b'EZks8/Qhuyq5/GMAKqwG4W4uQK6GXVEpbcXfGCMFerEpu8pfBqDcPWE/YPBrbpXcNVuOyWiZ'
    b'o4+aclyFTOofFeg3cAeHIHfCrijTPowFfeHiGciPAwes2sTKllqyBvGlpSnHlf88wFGsJ7B/'
    b'90W0/5pvWcpRTXH7XkPuWrsioX6HKXvLbP2LKcfIfx7gKOIJu2GIPjGNp2bpHegIN+Cax1Hi'
    b'c0IitYQJV0m2amPKMfKvBzgao+rJC5p9P7Fy1QN4fdYuJNQGPHN2Lf+3/G8Ar8pVr+D1LruQ'
    b'UEvhSTeZvCX/doHU9RBw9xSR/ogtd5i8pRgDqEzppjLkO3AQrEW5l3nL/yrUuxArZphSYmmZ'
    b'KqNUI1OKGAANboU3lyGoXArSwWWoXqnay4X2FQGQlndNzk1N8Hxwn8nHeECO1fDyKpEYl/G1'
    b'Wsg3eP3HLrhIyUi5W9VlNtoATUwaKyVnmZz/NV5zOFxvF1zVAFPq25mJNsBak5bXtyYNhpTE'
    b'feCpIC0DmZQZQP8shUgK7FKZ5umNwuElOCqVP00umbozGEZ7gKCxI/AHsmCdASi2Q/lO+50A'
    b'SSUdCh3VkOPSNcYAlN4k6+ENi9H4IlMVNHk1AI3VsexJEMNgGBVXWoVoKVmli+RVU/K/7EnU'
    b'66bkLi0LIx6gMGkQGVoBjcElSNIpeEBImlboAoFXaQoG0NIw0gUyZQKSx6xCrMYjHjxl8v5X'
    b'rmoMb77FlBqY1JaWuiCy3BaS4pQMoCAk7QAfmrbgs7+xPsjy3AXQ9mFI/gI/gc/AFtQtB3WQ'
    b'D6xSiQH3gLPBJtAP0HWuAf1BYJWKAT4w6ZdgGThilURqmTSQSsUAu026E7A70PW3gfcAu0hP'
    b'MBHkACvQIO0IJoHxgN7Dug5gNuC1DUENMAzcDNLAo2ARqA1qgmzwNOgB+P694EnQGUwBTUAf'
    b'8BJIBxcBvt+e35dUDIJWIMzQE4COwzgTKMO8HHBdnkvWzHc372WbMmdiTO8HV4BjYBfgLG0V'
    b'OA9wmOI15HMwxeS/Aly45D4fy1yPoNcVA05wWD8J8D3+DU57mecGCFNyAWAXZX6A0zY3UvGA'
    b'mial/jYpDK24bD0RbAY9ARubCR4G/ExXMBc0BHmA8/B8wL3Aq4Aze2uNH8T8HLsol4PrwYuA'
    b'C570Ks73aRD+jdmAWgMO21lr+ZxBmmI+qVIxwOkmpcWdL+8E2gIOi6cBxgda/03QDXBX5lcw'
    b'GrCxVwN60INgCaC4j8fhlK7McbsE0MDO+kRvMBXwvMAKwNhDD+DmyCjA37IDUHyPv4PytH2e'
    b'igGc1SLuwLJRFDcl6ttZy0DvALo+3Zn1PPzAen4PG3QmoIewC/UAFIMor6f4AEOmA+f7eD09'
    b'jN2NDWfs2YH8UTAd8E473sk5/iV2tswrXJWKAZqalBbeaGetu+qMAmwog+Jkw1bAByfmOWp8'
    b'Atg/65mUd4/6EdC1Kd5NNogu/wcrIHYxetJaeMiNSPl95Zfu6HUUu5XzOz1tsKZigGYm5Z39'
    b'HnBvjpZ/AqwENAwDGt2c/ZDdgOLzA/szAyS3sqhWgMZZDdh4Z9eHjR/Eu4uUx2foxh3Ac4Df'
    b'6zTUWs+L0jqT0uiOdzrXugtfZoFon2wUmAWWgotNmbNFRuUswL7LH8kfPRLQsHTVZ8BHgEGv'
    b'uflcrqmjmzc2dTTG86Azyw4sA+4PMjB2BxzaPgThctcxwPKQxTmA3snKFtHXJELpHKsBzfCR'
    b'4qKDmdaO7P7Sevt0SOlDJenFvZp8aq+yzpC91id8KnQPGnwwYDdiO+rg53IYdpXSYWstkGO8'
    b'Fx2QQs0+7Cuh8ezvjD+NrQqRt9H4QSbvqhCcz/v8mX1vuGIk95XQWA6dfKhiWxYBdjNPCmGQ'
    b'Sb6REK0a1sqR7wQj8MmvPhgIPB+WCuGfl42EiEJyrslVC4UQLn4weW9S1pS42iiEmMlHTOfZ'
    b'Prl0gi20gCpkD4j2lNaTqp0B7FdnYpJcQdos9SDbADwXEHn2TqZqFgMoHjZW1qOpFzlzgmqh'
    b'yGQoJDPx6uWZoI3kqujFkUArYgD7pDUXGZKpNroMT2tWC0UMQO2xzgdwquuuUIAOTyVRrAHe'
    b'0icQC25Fzn1+oO3jJdVBsQagCvQmNJCLGG7qInmKixyBV0UDUDP1AhhhvCnFl5ZZMlRVPFUW'
    b'LR5z9bniG4CaqbkhOs0uxFWW1MHUc6xyVotjFVadpFg2WwcWfKzEBqAK9Vi8cs0v/kqQlr5y'
    b'WL7AsNja1NjKVV0QS7iE3QjXzPezEbwdlg6rYWgQRwguc8cTNyumSYlMhEmzAJ8sneVyisF1'
    b'iHUE3mfyflo8T3XA3eTZG7c9t+2Aa3Px+r4vjeDeBaJVoNdJurVfx9XfRP9Pj/OERIEvzY/d'
    b'wbsHRCtXtcXdzLdiQOrylSdUzgCORqiOUiqPIMctKa7te9UJGG84Rhqu+VepTs4AjsIqA51p'
    b'GBrFzRJuTngR1+6HYqTxdqbvP9KpMYCjQSpNGljbYNcZuK3lFmeq3Ain1gDlNVKdIcekI0zA'
    b'4Mn/eMEl9fMB9xac0aIEnjMQ3eF95P9nifwLb3TqwPr/yY0AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
reboot_safe_mode_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7DAAAOwwHHb6hk'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAi9JREFUSImt1UGIzWsY'
    b'x/HPc0bUjXCTUMRFLlnMNVMYlBGK2MiKu7CyugsppeytdLdSNnemKDJKUrebLKxwzhx1i4Sl'
    b'UEqhcZvGee7i/5/852Rkzpyn/ovn977v833/z/u+zxOZ6YdtNHZJI/iCN3iMByaM2Jpvv7Uk'
    b'ZgT4CrmD+RX1i3RHOKcv/61Or80sOrbkfRzAp2KLbuGzcBhNjThPfI2bmZ19dTuz7mxmyodW'
    b'5iOPsi6zLrPhaqZaZnaQoumsEUvwDD+Xyhl9eaF7AKjHJeFk6Y2bsGrmZ/A9q6lXvLnmONFd'
    b'QMurNmV/dwHhQ5uyZgogIpZGxGDFXxMR2yr+wog4EBGLI2JP29re4XuaWCf0C/1ajky5eriJ'
    b'0xX/OrZX/GNolfoIeipj/+Cn9uvcnqIr2BkReyPiCcbwe0Tci4jdGFeUh1/wGn9HxJ8RcRmb'
    b'cbycu2Ay4Jw2wAC24BQ+YpGi5ozhHX4tdz6O3fiADYqy8R6H8AIT0wH+ww28RG+5q0tYXY7V'
    b'MIQF6MEy3MdGLEUdg2Uai7PJuttYgZY0jov6c7g8uE14mrN4jZN/8FuBA00MQ2Y+6TTwpNXK'
    b'gFVbPtugUwE9hlBNwaruAnrzuXStoq0lonsACH8oriMs0rRn2hUdAfrynbQPRV9tuexxrAeN'
    b'OGs0dnUKmNoPRmMd/pIGMCbdLVvhJ+Fg2S5nASikmoaTOI31lYGOIN/paFHTNKhlL3YoXvM8'
    b'4ehMIP8DyyIE0uS4mVQAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
reboot_safe_mode_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACdeAAAnXgHPwViO'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAB7VJREFUeJzlm31snVUd'
    b'xz/fe9uNbutGV/dKZANkEpY6+jLGlGSIhjFjNCYDmdtwvChG0QiR+AJOnDjDjGyIyDY0ESdD'
    b'wibOkQAZ0ZBpSF/3ommnzjmHG+iUttvQlq735x/ntPe53e3zPL3tbS/Xb3LT85zzO7/nd77n'
    b'd16e3zmVmTEmaNGHMXYA44FOIAV0IF7DOAkcBQ5hHGI8B6iy9nyYoTEjAKBZnwB+CiQjJFNA'
    b'G+K3pNjDBF7kcjszEiaMLQEwFBKC6AJewngCsYta68n19WNPAORKQh9eB7Yyjk25DJPCIACg'
    b'SSsQ28iNBIBOjE2M47u8x96MW6lwCABo0Y0YTwIlw9ByHPEFauwXcYQLiwCI8oRTwBlgdgxN'
    b'P+I0n+ca6woTSuRgYn5RZ09hrAZ6B5R0IpZSyjxgLXA6QtPtlPM7mnVhmFDheUAfMj2hE1hK'
    b'rdX3l9drBkl+grg+QtMxxAeoscPZCguXAOgj4RFSLGOhNZ4roATNfA34JuHefAKxJBsJhU0A'
    b'QL0ms8hOhcq06B6MDRGa2jjLVQN1FT4BcdGiH2PcGiojfkWNfTSYVXiTYK4wvoxbJcJkPkKL'
    b'VgWzioeAWvsX8FiknPEQDarseyweAgDEL2NITSPJF/urFM0cAPhV4SQwNUKwnS7m8D47XVwe'
    b'gKWA1hiCFZzHSii2IeCQdcNzDozlUJwE/D2WlFhCgyqLjwBFLIVplJDkquIjIBWbAIDq4iMg'
    b'ajOUiQXFR0D8IQAw4/+dgKnDCT0VJow2xB0+XZFRJsqxjHBbd+ydoKSpwGXA38zseIjcOGAh'
    b'MMHM9sTQOx2oAurNXKxf0ixgLtBmZh0xdEwDZpvZgThtyYCZRf6Ae3CxeMOFosoGkVsEHPdy'
    b'rwHlITrLgJe9rAHrff463EGIAWtj2Habt+0Pcdoy8Bc5BCS9G3gQEPA86WOsbLgJF7D8J1Br'
    b'ZmFxuxLgysDz1ZImAXf7dwHEiexOwh2vhQY/B0UMhpeS7qX5EbIf93JPx/SsloDuM8CnAs9n'
    b'gdIYOmZ7+V/n4gFxVoFGXK8Dgc9IqUzStyTtlLRZ0hzcgSbAXEkfksMdXmaD7+EguoFjvrET'
    b'gR8GdJwysx5J5ZIek7RX0l2B91dKug+412f91+dXSHpQ0rOSbo9sXcyeupl0z3zG563CjfNG'
    b'n/8csCAgdxi436d3+7/3D9C7H3gCaA7Uu9X/PeZltgfKDFgJnAe0DcjfiYsgNwAdpOeXutC2'
    b'xXUV4FHSrjobN+7qgAeAHuAIMM/LtALXeNn9Pr8X+MEAnX8EtgIbfb12oNan24AZXncrUA28'
    b'AbwErPYyu4DP+fTTwDKffgC4y6evH+4k+EnchPUlYAVQAXwM575bgEP+RaX+h+/RDpxbz8WN'
    b'9TeBxweof4cn5je44bUbKPdlpb7RJcBWM9sn6VXgUmCJl1kXNBXXIeBWhunejpfD2hdnDliP'
    b'm5x6cC4PcBGwATfu6nDjuAe3tOHTE3y6Czez1+JWB2etVI6L3CSBvTgifg5M9iITA/qmSqoC'
    b'LseRPcXnzwE+69PjA+88hFuRVnDuCVMG4hBguPW93RsAcBI4H8f6BuAS35i+3psI/BW3XFbi'
    b'Gv8C8PWA3ov7X2DWDnwQt8z26ZgGnPDp+3BeVILr1SM+fyf0h8IXAv/26XcB1wIHvd6Q1kWP'
    b'/W+TOdkcxfVSk3/uxrFswEP+7/O+7o4BdZcH9N7p874z4H2rAvK3AC8GnrtwHldFemPWSXqD'
    b'djXwj4B8OzAzrH2RW2FJwrnSe3GXEbaY2UlJM4HrPBHvx0Vi+jZNB8zsCkllwBrgQtw6vSeg'
    b'd63vqa+Y2YlA/gW4CewV4FncRudO3Jj+mZk1ebnFQA1uIrwNeMbMWiVd5EnsBXaY2Z9C22cN'
    b'zEfMIkE38B8AjA4Mo5RuEj6vig4IZ0vS93Euea+ZPRwmWyiQNbIF8emY8qeptcmDFUqaAnSZ'
    b'WffImJd/JIb4/VzOfp0/WKGZdb6dGg9uFXhjSDVShF44eLshgcU6SEjDeGeebBkTJEhxcEg1'
    b'jJl5smVMkOBKjhLYoUVCTMubNWOAhF/adg+hTrERAIhdsWsY0/NlzFjAEWC8ALwas0aRzQGA'
    b'v2z8aKwaxqw82jPqSH8L/F4VvMVhoi8XdAPlw7mhXUhIfw5XWTtibYw640kxL38mjS4y4wF/'
    b'YTPuuzuq1rV5smfUkUnADdZLkpuIPmFdmTeLRhnnRoSusD+j/jDTYFjEPi3Oj0mji+whsRp7'
    b'EvhGaM0Uj3NQE0Nl6jXop3OhYPCYYK2tQ2wMqTufHnbyisqyljZqISUcoUkrhmljXhEeFK2x'
    b'u1H/4UY2LGUce2nWJRm5zVpEgj1AJWJbIZMQ73i8RWswNuNCz9nQDWyki/WUMd/vLKcEynsx'
    b'VlNnTw3b4hFG/Jui+7SAFNtJh8az4XVcbD7b2C9IEuJfkam2A7xFHfA93MFHNswke+MBkoU4'
    b'HHK7K9ysy4BNuKPzoaKgPGF4l6WbVI34KrCc9KWGOOjFuIU625b7y0cGI3NbvEHzSLIGd4x+'
    b'QcxavcDN1Nr24RuQO0b2uvwzSnIxizGWIZbh7guEzTNjTkJ+/1+gVZPoopoUdYhLcUdkc3EH'
    b'q32rxVnEcmrsufwZMjj+BxwJQB6lpiNBAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_sideload_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAA7eAAAO3gGHS9U9'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAnJJREFUSImtlE9IVFEU'
    b'xn/fm1EwW4QUolSWhknOSCq0aFkNQ4SEBJJOpkW0CtoEQX8QIXdBi1ZtyhkdRYLIFm5qV4gl'
    b'Vo5N2CYQCkrC6I+Zle+0mCeN+oLS+eDCO9/lnB/n3HufzIx/VU8sFHVRP2Ie4x3Yc5MeBxzn'
    b'TmtifNovR/8DAOhuCUckBoGCLHsBGDLpYntvamJNAIBErOaAYYPAOuAuEAEKgQXDrk5Vpi90'
    b'dJgL4Px3deB4MvXANWtAnGtLTjQ6QdsFjAEBofPbXoUHOjvlrLoDP91qqtvk5P2cBIoAMC61'
    b'9U105QwAEI+FboBOe+Ev16V8VSP6m2SMZoXBgMPJnAJwnLfZoUE0pwDD/bzEENt9z0BSGTBt'
    b'ZnNeXGxm773vjcCMWeYaZuWooqhg8+VIRT4BbQBwHRlmSxewG5gA9gOtnvcka/8eUOyTVwn0'
    b'Lvf9RjQFmLfKJV0DiiQdlZQAZoA6SSOS9kgakNQAXAfmVkxj+YgkNQJ1QCmZl7oeKAE+eJ2V'
    b'Al+AaWAnsAWYBV4ChWZ2KrueXwffgCPAI+AN8MMrPgzUe94kEAUeAvPAiDei7ys66G4Jpbwi'
    b'SMy7pq72ZGrIB7wqBRFBjDCAGcisFsgZwJHZsyWOVJKr4hkAJJZaVpZTwOvK9H0yh7SoHbkE'
    b'yMzobqmpkmyMzLU0zA239aXTuQA4AO19qUlzOAR8BYSc/pvNVaVIih8LX0k0V9euqYNFxWM1'
    b'9UAcrBr4BDYMOgjMuI4TOdEz/nRNAIDbTaH82aDOSpwBtmZtfQRF2pKpsTUB/oCaArN5k1GZ'
    b'7UPsJfNLCJjscHvvi1HfJB/9BqZlDZr+3xWzAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
reboot_sideload_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAACelAAAnpQFH3Iki'
    b'AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAB/xJREFUeJzdm3tw1FcV'
    b'xz/nt3lBeZSCBWppqxBKYZMWQaYjzkihSIHWZ8UmmxfMCCoW60xth1EHHaZare3wsFpQcDck'
    b'YaTtjJ06WvsCbCktZdS8IBStqU5BGBBoCJBk8zv+ce/GTdxkf78lm4T9zuzk3vM799zzO/ec'
    b'c3/3EVFVBgORkuBqVDYBDnDGkk8DJwROuGgzQlPA5bDjtNWFqo5+kA49ZLAMABApKViL8kMP'
    b'rJ1AI8hrqrzcPjLnxZVbDl7oDx0G1QAAlaHChxV91Gezi6i8JI6Gb3h/3PPzdu+Optr/oBsA'
    b'IFxc8G0RfpJi8+MKW3OQjcXVdWeSs3fHkDAAQCRU8CDw2GWIOKewIRBwHiutrG312mjIGAAg'
    b'Egp+C+SJy5Mix0Tcb5ZVNTzjiXsoGQAgXBJ8QFSeACTB4/8AUeDaZHJUJdI+MufryZKlk5qa'
    b'6UNFVcMG4AGg58icUnRBZ17HFEHXA326uYiW555v2x+5r2Byn3xDzQNiCBcX3C/CRownnFSR'
    b'Oyuq6upjz7cXTbsu4GRHgDuTiDqOugvLaxobEz0cch4QQ0VN/WZE70f4N+rOj395gBU7m441'
    b'T21YJPB9/t9b4jERcXbvKLs1mOjhkPWAGKpL8kcl+wqMlAQfQuXHSUT9I0fb5xTVHDkVTxzy'
    b'BvCKyuKCbSqs6JNJ2dN8c8OCdevUjZGGbAj4RTbtDwN9rxeEeTceCa6OJ2WMAYpqjpwS0Z8n'
    b'4xPhkV8XFUyK1TPGAADSqb/1wDbScVgbq2SUAd6dduht4FRSRlgeXhacABlmAJvcDnlgzSPb'
    b'+QpkmAEARPmbJz70XshAA7jCvzyyFoZD0/MzzgCOiuetM9GsT2acAcD1bgBHZ2acAVxxznnm'
    b'VQozzgABHx7gwISMM4Cq49kACmOz0qnMoCC74x2i2asAEPdqUadrZ0lhhOJmx3NnzGowVaQU'
    b'AiIyU0SeFpFGEdluaY6I5ItIoAfvXBF5UUQSHoCIyDgR2Sgir6WiS5yckIgcEJFlvhqqqq8f'
    b'MAk4i9mFaQc6gADwsqWt6cH/V0uv7EXeWvv8tF9d4mSMAS5aOav9tE3FA+YBo235FmCsqnYC'
    b'e4D1QKQHf+zUp6UXeRswR1+e9/J7QlXPAFts1fM0CJBKEnw/rjxNVf9uyz8CbiduO1tEpgDD'
    b'bLU1jn4bMB54XVVbReQiZgRjz6cDc4A3VbXJ0oZZ+dnAflVtsfQAMDWuX3+GTMHdBHgJ427H'
    b'gOuBq4AjlvZlIAd43tZjvx9gck44jnbI8p4Faq38ezChpZjwWmjph+Pa/RMYZftu7NHPYl/v'
    b'k2LMjbdKKLAPkwP+bOtLgW/YciPwF1v+DvB5W34UWGfLt2BG/4CV3YgJiacwYfOqpX8NmAu8'
    b'att9Cqiy5d0Yz1RgflpzgIjkA8OBUkv6hFVmv61fAO4DXGuMDXHNl9q/19gXOgG8B+Qa0TIF'
    b'mA7sUtWvAn8CbheRLOCjwCvAHVbGeOCLmIH4NPCc33cBn9OgiAjwAibT74WupedszJFVDDdi'
    b'YvE9TCyD8ZKJtnwP8CawEDNq0uN5s+3rJkwOWQ08iBnxRyzPWCAPeMf2HevHV17zmwTzgI8A'
    b'y23yuc7SL2JGFcyUdA4Tn/viFLseE+sAu4DfYLwjtkt7DcYjAIoxoTEdOIlJfgCvA5+N6zMW'
    b'CvuBWXH9eEcK8V9L96TTjsnCL9j6L4BNPXhiCW1NAtqsuPrngPoePD8FHk8gbwtwIAH9UFqT'
    b'IFCAcd8O4CjwBUvfDLxlR28M8AfgDeC7mGxfjgm5jcBxoMnSRmFmkD3AbcDHLX8bUI0JgQ9j'
    b'ZpXf2fZHrbFutX0+BzxpB2eun/eRcKhwgaiKuJ0trhOIdjpuVFynBSArIOcDndpxKa89umJb'
    b'U28fMlc0JFwcPI+Zx73g2fLq+nvTqdBAwyHZcVJ3TErOcmXBQTntmVu4IY26DAocEQ575lbG'
    b'b16Sn5tGfQYcjiq1PvhlxOi8pPdzriQ4auZS78hyPpQmXQYFzlVR3YuPNbR0dmaWB3xpV0M7'
    b'5qPFWwOH8WnUZ8BhFkPi/MpzC3UmpEuZwYADUF5V+wpm7y4pXHRicq4rB13LYSXxrm1PiFml'
    b'ZQy6DFBRXfc0ZmelbwiF6VRooNFtQ8QJOGswy9veoUyIFM+YkU6lBhLdDFBaWdsg8JCHZqF0'
    b'KTTQSHg0FgkVPIPZb+sNJ7PkUn66/o9nIJFwT7BtRG4ZZvupN1zb4Q7blEx4dUn+qFQVGygk'
    b'NMDKLQcvtHXk3o3Z6k4IES2PhArX9/Y8EioMRTXv3cpQcE5vPEMBfZ4Ob102e3Ru9qVnQRb0'
    b'IaO6rSN39cpdB7s+pyOhYBnIdsxO7znHdReV7mx8q//U7j8kPR7fump2dl5L21NJLiKfBPne'
    b'8I5p21pzDpeL8ku6e9c5UVlcVlO3vzcBgwXP9wMiocIQ6JP872A0EY4Ck0kcWh+4LouX76x/'
    b'w7+a6YOvCxLhopk3SSD6M7TrhMcvWhBdXF7VsC/F9v2OlG6IhEOFSwR9HJiWQp8tjuqS0pqG'
    b'vmaZAUNKN0Qqqut+3zy1YYaqfgZ422fzka7IHytDwTuSs6Yfl39HSER2FM2Y64pUAMuAkR5b'
    b'tjoqS0tr6vZengKXh369JLV11ezhea1t81XlLtBFwJQkTVrV4e6KHfV7+k0Jn0jrLbGdxTeP'
    b'i0r2LFfkYyiTgUkIk4AxKLnA1cBZQe8qq27wtzfZT/gvTbBXR5yYiJwAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
right_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAApUlEQVRIS82V2wmAMAxF21Ec'
    b'zQ3cxBVcyQ0cwQ20kQppFfMGC+JPOSepNzWn4JWD+SlCcNSiL/ZvBFMpZi/PwjhScQcAnyt4'
    b'KO+NkIgEGD56d6CBQ3OsDrRwlsACJwVW+KcAwxlpJLc8Bg2iCBKv9TrJWMKNZV8QmSKrhBRA'
    b'RRYJS2CRsAVaiUjQS9wvuzsh8E1W78tOOw/iI5KKwgVNQRH/5EZwAvDTMBnH5D7WAAAAAElF'
    b'TkSuQmCC')

#----------------------------------------------------------------------
scan_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'YUlEQVR42rWWP0sDQRDFb+FKIVWs0gQkfWo7q0i4OkX0C6S0MNiIpaVdQAKpTCcpLfwSgo1E'
    b'mxBi7FKlinK+gbew6O7hzZ4Hv2bvzZvbfzOXJCWeo7vtGXgC9eQ/HhhfgRw8g/0qjVugC+6Z'
    b'QHgDjRjTGrgEC8f0J6/AaMw74KPA2DLRmPfBl2PyCE7AAbh2xkelvx4Bh+CTBhuQBTZZZZ6C'
    b'FxpsQdujOWYS43m3B5pFCXrO9AeKpZ0zNgsJZhS8y2wUCVaMn4YEawrGymM9ZvwyJLDLM1Qm'
    b'GDJ+FxLsKDiPTJCHBEsKbiOXaB0STClYKcxTHg6Jn4VEGQVzRYKBs4e9ImFTLoxn3PCCdT3v'
    b'2ryYOS9qWvbrDEuDGNx4Zr2xp0dKTYy5rUFS9E5ZBO24FMe+5mRM/lCypax3NOaGDSVkvGBD'
    b'qsV0tQZbozV9YOtsVdmP62zyvza56iTyu3JRNvYbNALYHGB7Q2IAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
scan_all_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAAuGVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAGAAAAABAAAAYAAAAAEA'
    b'AABQYWludC5ORVQgNS4xLjExAAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAA'
    b'lgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAAAGNdRzso9yOwAAAydJREFU'
    b'SEudlV1IU2Ecxp9z5j7VZW5+VKaSzvkxRqJImjfNSOqqDyHoC0oiI6MuogjK49dFWhim+zCx'
    b'TNlVWlAX0oVBoBVRRKLWMLswpVpLF7rNbW6nC9vh7HWbq9/deZ7n/T+85/C+B/gH1Po7HbJm'
    b'lVNj6k8nvXDQpBAJj+97itM7JZ221Vs0JnMG6YeCIoVQaLsGipZXZkusiw+v2V2jmwFAHLPV'
    b'm6Vs1E6ePfmJzPMJW1DYPaS0u0Y65+z3Dnl832JIHwAkMenesm0fxc+PxrKkFyBkgVrffvrL'
    b'ryaT12eL+AoTZRWf568Mq0idz5oBqs7WOov14t3A8HhJ0bwqqaVBu3mwMDPxytNAThFbObk9'
    b'7UlO0OL1yDUYq8DQLBiwgga5X61vr+X7Ofq2PjBgFa2VEzqzI+Tuw1LcMyKUNGe6wYCl66Vs'
    b'nuHuHjJT2ju5P0d/+0Go4YXdQwnargENqXOoOm9eBQMWDNisjqZ20l8PSVOGBwxYctfcN7Au'
    b'PT4PACJBsn+jbNclfiga/KyLBgDr4qOgtVyB0zOVAgBxYu3nt9XlXn4oGuLE2mkAcHgsaXyd'
    b'K/D6ftIAkCDd+YofiJbAOq/vp4CvcwUUOD3soYkGFr6gZ65AKEjyAYDd9XJHUCJK7K7RUqzO'
    b'8fN1riBWpJ4FgCX3h4gnMxTFPSPCJfdYNgDIRKoffI8rSN1w7AYA0JQ0eI9RsOB8ccvjs9IA'
    b'kBx3oIP0Ocp6LdnlfTPxpK4zO6gcfVtfgbG3mvQKTH276XopCwaspDnTXdwzIiQzEdGZHZSi'
    b'tXICDFhl6773fC/P0FUjaJD7wYClGAGbazBW8X2Eu00D6MwO6sPcwfFfjmf5+HvBpcQfPkFT'
    b'ooqvC52Xfy+/VqwmKaiSWpip2suNxIjIBYktFVPzzuFsUucjFCj92xTXayznLnSTHiIV6MwO'
    b'6uWXPPfyykzIdyoSbFrZknBqMEFaXvv+9F4b6QcIWwAA+cb7udO2ujH3ylchAMglJbZU+ZE6'
    b'SUzam7EzVe/I/H+hMfWnS5uzXKE+cjSs+aORjNccn8lS1qtlQpVLLikeJ/31+AMRkw+dYHnT'
    b'5wAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
shell_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAC9SURBVEhL7ZX9EYIwDMWrEziCIziC'
    b'o7ihIziCbqAjuAG810s4GoPQRvmL3927tM01H1Bo2qjhBN2hLqgbdIY+oMPb0KInlNmJJXT8'
    b'khx7n4croe1FKeL8vYOpBAdITxQt52HsI2pNYuMMeI6WJFUJiE0yRxFn6Ut+iX2LbcLrgNVf'
    b'Ia3+CM3hxclYx2RwLHRW4iIcj+cDY8fXyrEYThChiLPql6wnRStoFXmILeAlwf+4t6lGvFcu'
    b'0MYSUuoBiROS3Z98TuQAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
shell_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAINSURBVHhe7Zo9TsQwEIUNJ6CmgRtA'
    b'RQUSR4CGCgm4AZwAUVJxBLgB3ACQqGjgBlDRwg2WeXhWCo6txIm9zqznk57Gu9q1Mi+JfyYx'
    b'iqIoiqIoAdZIl6RH0jdpJkj3pHPSYJD8G8nXuSQhh01SNHDQ16FE4QqOYp/k60iyTkktVjm6'
    b'bHNcJjY4/iNkwBbHZcJ7UkMGVIMawLFaqjdghaPLLcmdNj5J77Y5eTCNYyHX5IF0aJvdwAB3'
    b'HsXCSAq9j1/HAI7VogZwrJaxBvgGm7mwDXVH4skx1oAz0p1ttsDaG9vQSZuQ4hYQbUKqMUCs'
    b'CSkHQZEmpDQAiDMhtQFAlAk5DABiTMhlABBhQk4DQJcJN7ZZjtwGAJjwZJstDjgWYxEGoDiB'
    b's+0DRZai5DYAyaMQ4bvXf0hXtlmOnAZ0JX9BQpmqKLkM6JN8aHBcKDFF0b5FxUHJ0/55ncKu'
    b'/RTFCyXxxe05Y47/j6FFUSQfeo8A33sfUIJX6p9+NBugI+6iSZGiqJjLvkkqA0QmD1IYIDZ5'
    b'MNYA0cmDsbMAlrK+5AFWeaElcItrY/bIzeiF0Y4xx1OaBaZCkVlAJGoAx2qJGQTxbkDx3VtP'
    b'TkhurSFqEMTrse4gIl3e6lPoFnjmuExE54Sipc9JiRpUgMUfPki+DiUJT6lDJble4JVzaVcD'
    b'tt5IHMcefeYVRVEURakBY34Ba6khpKQMrF0AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
shell_64_disabled = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAMDSURBVHhe7Zo9qNNQFMerlX6kbdJS'
    b'KvaB6ObgK27iULBDtYM4iDwdHRXB1Um0uIhLUcRNcFURnXRyKNhBnN6ig5MOeZEuLUm/oFA8'
    b'x5w+bZPYj5ua3OT+4PI/N6Ftzp97z03SGxEIBAKBILwcIHWkXq9vgZTNHne04Pr3KLbF0QBM'
    b'vNfrXYLwXjqdLphH+ULX9R+yLN+G0NGIKOkMmPxoNLouSdLDWCyWosPcEY/HsyA7hmEka7Xa'
    b'brPZNMwzfzhIOk85kUjcpZh7MpnMTRDbaWxrgKZpFygMDKqq3qBwBosBOPxTqdRZ6gYGRVG2'
    b'MTfq7mM3AspQOI5RHBiokFumgVMNCA3CANLQIgwgDS2WW2FYKq6AvDR7Fm5Ba5uhbzkM7YkZ'
    b'WrgK+b2i+DerGmD5Ar+x6vWLGkAaWtaeAqDLvCdY+DzuNste/xSWEYDJ4w85NnykJqN8C4sB'
    b'LWi4KjiCj9R+N2FtA2hov4HGtQlMRTAIJjCvArybwGwAwrMJrhiA8GqCawYgPJrgqgEIbya4'
    b'bgCyigkgnv7rtBEDkGVN8JqNGTCl2+1epNCXbHIEbEHyz7PZ7Hk6ZKHT6XwCwVtqz9hUDViY'
    b'PJz/msvlLtNU8QzXDVg2eTh/zuvkkUOkrsCSPH4WZJ0Vgemdg2sjgCV5RFXVpyC27xUWNKZl'
    b'1BUDWJP3EmYDeE4eYTKA9+QRJgM0TXvAc/KIZY9QpVI5CbJj9iy8bjabXyiOTCaTo5lMJmEY'
    b'xvf51u/3PxYKhWvLJp/P5/ei0ehxu+/6V5Nl+dHfe39WuX5E/DNEGlqEAaShZaUagE9vg8Hg'
    b'J3V9iSRJR+Ah6wx157HUADsDcIvsLq/bY50YDoe9ZDJ5AvKbWZUsyyAuKaVSaRuWt1N0KBC0'
    b'2+33jUbjGXX3sa0BxWLxHYWBQVGUDxTO4FQEW6PR6D7F3AN3pC9gSr+l7gy2u8VxGlSr1W8Q'
    b'ftZ1/TTtuuYO3C4/Ho/vwN3i4/m5P8VSBOfBogji6atrBv77Bg2BQCAQCLghEvkFW6DJCx02'
    b'RZMAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
scrcpy_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAR7SURBVEhLhVZdbFRFFD4zc+/+tNtd'
    b'kaJESUEfKCWYJgQ0mBo0tvUnanzyN+mrQaiWpvQJ8edJgRa6qFHjiy9GfDC+NbS0MdHY+FCi'
    b'0RhFAwlqIGmhpS3b3bt3ZvzO3C3dbnfbr53cO2dmzvnON2fmrqB1cHK0t1mIwkNWiBYh1FZL'
    b'Rlhj/hZC/u5R7KeexwculaZWRc0AA+OHn9C22GNF+AiRqeepljRGLEkrCQHxLucEeaMy9If6'
    b'Ok997xZWYFWAoZGjG4tqdlCLYpchQ8La0shq8IhAIGGFkcb/LLXY2H/guXfno9EIKwKcGOnZ'
    b'Rir8VouglR1Hf2ukWQFlYxMpdfeLBx57+5+SaXntmXPHNi36U6NGhK1k1mCNFaLmsEAQ/4d0'
    b'/q6nXnvmnQW2SGcHCurGoKGw1a7hnLHeqBHFtrn41PslQ5TBwPnuJ0NRHOZNtFaTtiEp6WNw'
    b'tTjVJGMhtSlijcc58LrQ18n9vZ1DP7oMNIVvgD3Hp6SXpntTzeTLhOtXoprzuErSltROiqkU'
    b'MkBpCOOFIujmcTk42r8Dhv1chEWdo+0bH6RX9vRS2r+fArCqdFkpUdEsUlN6F7269zCCPEB5'
    b'nXdBtdSdp871NclQ5vZZoet4Mg8oqchXcQq0oFtBlMN6ukvI4qkY3j0KQk3GsLj2TkOLu6Wl'
    b'sCViucyUA4XYh4LWrhnsC4eq2jBmMJchcSaYjC2VuJaiRWIzt7pRBtgvFOYwUVJz407ysGlK'
    b'KDRsuPBg9/HOT7ZHT09C/zu2Y7GlhWAGOSj3zuWMvd0sTox3fxnS4stc2xyV4PCFXT10X+MO'
    b'upmbgQWn2V0LWGAipkp5PNmBWTckN9AfV3+hs79mERiCSUiEJdJ4Z1R719492IO2SCSkaIv0'
    b'5/QFyhcCl/pcfoZu5m9QLj9P92zY5rS+ePUizd6CPTdLs7nrNHllgsYun3WHirPHvwugrPeN'
    b'OD72eheuhi/KTyezDlBRTmMMWGtQivV08OHTlA8KdHTsIFiiPF1BCIrhGVd1jj3IRwGgkW/i'
    b'z0tcUhPozpf5Rx4SC1KUUGlKyoxrXOPswIOEaT9NGS9DDX6G6nFuEl79snOWBs7Qm/apflL2'
    b'dQz9RVaNlxVRTQTFAs5KCJlwSUsEg0c84AxPZMrMWSYG7tfhNzs++Nf1cQtmoYflnS/PZAn4'
    b'uLir4OufP0H7FFnAOYIwY74YeKO5EJh5BFGAtkP85gL0t2fHBcU/Z3FqJoLavl64RNOFy+Sz'
    b'DGjM2H0PwH6JOUNoL9vf+fEkv9+2J4LMEWm9CWZbCx7OQcL3wT4KwDPZeTkpYdVIXbDprVJ3'
    b'JeEPv3uvKWeufaUp2FdeVeVg81JjuExKHWH9MRUkX+p7enA6spRlwDj06LEriaChU9r4R1BX'
    b'uz1ZQSECL4rYuy6j4JnYyYzZ8my5c0aV5REGxnrb8I04RBR24Azj4ipJcfsbzT0xBVmHseXZ'
    b'vvas07wSNQMs4fT5I01aFHbjSm+xRm/mAPj5cg0H6bc41V3o7jj+X2lqFRD9D3gYzEv8Twk0'
    b'AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
scrcpy_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABEfSURBVHhe1VsLkFTVmf7vPfd2T/e8'
    b'mBEVAkKMVhZJuVIspjBxk2VFefhIULOVaJkSn0kMRjRB2NIxRSW7G7XEoDFLFlwxpcnuVtCs'
    b'RFEIWco1EonBAYOKGxkgCAjymn7f1/7ff+7tx0x3zwz0kORrTt9z/vP6X+c/59weDDrJ+Mkj'
    b'P1RH/jvrt3Ylxvue3wqabaretx59d9fsz1xHU78+yZeGJwnDroDH1twzMW8enmAFiamu6Yz1'
    b'yD+PDN8zlT3O96kNbQwKjjl+frdtxh3fpU02Ne8umMc2tfunbrt1xn27ZaBhQsMV8Mr//Fxt'
    b'zr1+Qd7Mf94zUp9m4SYHqhAjUlxr8oyY0qfA8CgI2NiBdCPTUMKMkAKDDG6qKNbLmS1GIfZs'
    b'R9C6eu7Mrrd168ahYQp47PlvdwZ28OVccOQaX7nnu8pnWV0yvGgKlqgISO3JEx+wYbBiDAjO'
    b'CQi4HChdb3iK4n684JO1hvzEjzdect6q/6QvNGSpnLAC1i3dYG3/xLr5KePQN7zAGwPLQTBm'
    b'X1sYwoEESmhtrQDNf8BECA/PEAUIFb0ZJsbQZfEcKMVnT/HUpqSbvP+qzD+uGnNV2wkpQs93'
    b'nFj20r1XpowjiwqWNyUwPV7aPBxzbEI4Zlxbtz6KCqgDDAvhWR/CsM9aNj2bvcJ+JVaIzfva'
    b'Zd/bLA2PA8elgMfX/FNr1jy4LGPkvuRYWbYczG5xgtTa+o0EVgVGNEIFFJcTlpgfz9pO+9KP'
    b'Jv568ZV/d01GVwweQ1bAo893TcnEen/sm9kJWlBtGZ/XtF6xmmEA9GEHz2XwsrDc+Lo2d+xN'
    b'N1+2YGdYMygMSQHL1yyee9g+uCyvcrZiq0cC/kkVEMLgeGN7LXsNt3XW/Eu/2x2SB8SgFfDg'
    b'i3fdYFiFFa7hcIkFDVx+ons0xEmUtgbAiRkkUiPtsfPmfvbuJzS1PgalgAdeuPMGJ55eYfIi'
    b'VL7Fovr8KYS15dvbnwFYIptaqMMY9Q83TFv4XyG1JgZUwPdfvG9uwdr/uKcctrpiDaMLPAD7'
    b'ODAoHdZEtFwQ4BoB7CgylBv7wMwmpy/43ANbpaIG6nK/dPU9f5NP9L7qmykbgmM7kk2XZ2gU'
    b'w7LFMUoR/kTBZwkogWNCnGPCCG/cBXNn3VkzMNb036f/d8loJ555NqCMFp5pInODBB9uQAmO'
    b'So0+bPT82/Y9W7BHV0VNBRxM73rIU9mxZCri3VYfXFkLYqk/ayVgefJdg88jAR+YHDt/8XNb'
    b'nlwQVvZDVa9bumbhnKw6tipQLDYP5Bv6tNk4Ny2h8UugBIMVIBuzZ+c6vZEX3DJz8RthVRH9'
    b'POCF9SvbHCvzXbKcoqWxnyM1msGTAdwuAsNpOuYfWxySKtBPAdu9rV91jfw5FGDZmKLFv0zR'
    b'SzDYg7144fIfrFt4eUgqokIBK1/8TmfO6J3n8RnbxzrC6U62u9AV6gJtiqFy0IhiynCoGBIg'
    b'YXTfyFPeS93e++s9eDFRRIUCUkb2y/wYgw54YVFNIKwpKMdnxSDJGgtrjgcQ/HiF17xoPpDK'
    b'eUAO9RF/uGo7hj/9iaP/Ok0IIYoKeOXpJ1SWUtcE7C7CVDV5mGbxOatJNVPSbOPUTpYR48aK'
    b'NYwTYngIGXbwLGygmGFTs9nJfHQyTyOED1xM5WUKpwg4bIEvn+Na3jx2k6ZqFFs9tqbrwl51'
    b'4OXAxBm/uhiO69BnzryaJo//FG+J3M40aP3bL9Hv9r9ITXaCu9VRXgMBI+W9DM36+E30iVFT'
    b'yPPx9smnl37/DG0+/EtqVvKqUfgpB04zyk0cbs6dfs5tV3TtB63oAXy3/7xniZ40oQp4WkrG'
    b'Wqgl1kmtTadRa+xUtkIrHU7nyHdDqYdZeMBn63rkULvdQc2xdmqLd1Br/BSygySxjcj1eIn6'
    b'mhGcByLgRYqrvA7Xzs4JSVoB3b9aGzOVM1s7MGwIJVRRRHgeKAcmyPGEqRwm5V1D+mPYom7r'
    b'Qo7XnIaiN4PnVMVzOQjoj/MKP32OSyy8j/MLp/JxTS4bfKxz7UxxNxAu17vrzioY+bPkBCXk'
    b'OujTAEWsMYe/0gWf3KFKcxzgGSSoQZwSoHqTPJ6b7cHG4MQCA0Uv4D7oEXjOhCef+ucWkEQB'
    b'zPNUj/DqmnvJAh68BSG8lpmFZwXmORi7TOS4zB9tlXoY2iELvMHsoUD9gFGw0sENW5/58MGg'
    b'joxhPYr+x1Ijj56PvEhp+u4kBBGNwbESAaxIgpY5eZxcdkFPtkowUYvZxgNnNtPkL7kNap5K'
    b'KWzEgHFS+Wwz8trMlv9xLfgghK/RRBSMSp5JLMDxIJqUp9eZKhADDWLaEqo31tPrq3DfFnp2'
    b'cMGf8ORl2/GpoJqPXvuwcvzceINvfVof9bjhzjVkkX2X/R1C6yMUl0saqAlURWlggLcooU+p'
    b'l87r5SEyCrUcmohWAa85z/D4wMcSd37BVPJ6i5mt9n5eOiBJFR80wu0lgm3ZvOZdUR20K4wg'
    b'mEbCM4pjSCrRAR3KNK1UU9kGKO+n2xtkWZXXfJ93gCieSCgTIFPqC2AslnXKlp+9o0z7VHVW'
    b'zGo+S08QxYESIheVGj71Hc1+CCpKgr86/Rxq4RMhlCj3JuEgTAIeWcbAE4ljQ9l2ii0NSdfp'
    b'dnq2Uhu0Rz9dh33eoc7YGXRa+1gpgx3Pd+hw7gALxrG8CIyBPhEvgKiHCkGv8dOrVpKZzRcU'
    b'zx+qEpXljUtADQLM9kNbKVNIaSJjfOeZdO3EG/mIYFKukKa8k6GCq1PezXI5Srnis1CklVIl'
    b'LWpbXod+ack3mafRxROvofamEdrTmLlD6QO0q/ctZjIufMGZJR5UiQkhAn9CjIwn1y8594Cx'
    b'ozvPZ0HIDiVX6yDW4RqvkKPZ59xMk8ddKOVIXXuP7qFDvR9w5C+wotAWtWBA5yVTbA1Es/Sl'
    b'VWvDOQzBS81SSepsG0sjk6dyU7Zw2GTNtp/Syzt/QTEzWRQeP9FFSgCMUDiUAke9eWDJmEnG'
    b'U7965KN7afsbDuXa5WdpHjQcswr4KMlH0ITqoKsmfZXGt58tVLBcu0+joVUbGl6E3fb+6/TM'
    b'lh/xMZcVEtJNEbquAn6fX332eeaGacFO1/F2lRroxtXBwY5vXCn/ID33xjJ674M3eD5HBhRA'
    b'E1GKlnHVxA30UY0Xr87LFZs/0l2+wlTeDxbnDNjke5gE39d2vkyr3vwROXzTUxyEVLnAaIS8'
    b'dh+hAVBgwmgOrr1sOhlPd/2H2nPhq1vcWHqizFzZtiqwHFxuhF+DJ57yaTp39GQa1X4GR2Ws'
    b'v/KJSnnNg8k+pNiNbWZB9g2pwxYKYTzPE2Vq9qPe0TJC0gpAPOg5+B51v/9beuvIK3wltrhN'
    b'jOu5LbpgLjxUNAL68TNSDH+aCi0r589ccr1QHlo7/+mcSn1JToOyDKRdTehobHPi46+X5vYG'
    b'3wxPo4TdylrHhah0nkBL5NAFlxFsVZPGTeMY8rdyUgyb0erNP6et+zdTjJWDX6DEeOjHH7Gq'
    b'Qol9hK/hGbeXjub3k2kr3objpHh+rRzMjW8N7PeAnoLVEymADWflk3d+69LvL5G2Jll/xBC6'
    b'+cCQP2Rgi8kPkmaCLRqnjHeEDmZ30QeZHbQ38y7ty2yXtJ/TXuSz/Mz9gXZnu+lA6n0ZB56E'
    b'Wb3Aoz1Heui97Ju0M7eddmTf5fz/UQ8/e7jck3+H89vpj0zbV9hJ6eAIxWNJso048wDRw6Uj'
    b'z1AKHhsySUI+FB5AzvcKvGWEynIouxGdS02GCtiJ3ZvjA1xcGRbnS0nKvNOahk2KtymD22k2'
    b'0I+fLITJJ9G4amKFxjjZHM1teUqZ3Rtvfywu67ErXusVIVzoYesCPHa0npLXeUZbMPJt5cUL'
    b'g/WAehAm5KfzygQFiZXKGISHai/VBGRhMbREgmsjRe1KSxMFdvmKA1UojEygAasjRf11wrsE'
    b'e8fI7LhNaCN9br3k29u42WbNwvBCu6hmUtySI3f0GkV2ITzDT4RSrhIVbg1h5Vkq94WMznQO'
    b'AZuunH2LnOZEAYBFyfXRmsQdvkyRDUa5aBoog18kMITgLRbnL524D1egXrGS9LrWo0B52P7E'
    b'9aWT7gPvwAMpgi8Fm5JBx2pN0fMJzKy70nLtQnTeLuvXWGi+K4C5RPgwiTXLUqQhZIFIeECq'
    b'ooygNuc4JylXHWwzRq0NSSUF3HHFkndso0XWxbACURvbHwMrGDmseBZPmBGB+AsJ6x/hUyzJ'
    b'rWB5AG10VAH0CIAoDB8uhnasAM4hHEp/dt3FX9sXksIxQngF82H9k9jwAbJHgkQC45KF8wOO'
    b'r+LqnOAJcG0RCAopExKl0reWVsigSVud+sLwbf60PR4WBRUKGBk/+xemH3sHW2JfVFHokAGm'
    b'FO/dB9J76M2dG6m7ZyNt6XmNtu58jXoLH8q2JyJDEaEkCIwl4SAy6nQZ0ArRkFxVRhHXWCY/'
    b'WHXbzMWvhURB2VAaS9cuuiVtHlpGBt/vA73fIigC4lo6e0LATwjpfC9fl8Ofs3hvt1VCzgJa'
    b'ARzAWDDkAQlqDO0PGpHgUd1AvMHLVKbpk3ddurRimVd4ADDZnP7v5Jq/xsUHQw/HbmCya7c2'
    b'tVNbUxs1WS2UsJrJwiFKhChFeKAoaBlt6GBl5puX9xUe6KeACy+6yLHyzXcYQRtfJnhSbDHM'
    b'mGauMdD39IBilkVxGxcZvXXJ+udJZD6eLdrOypVQTNKew+cAvGFbN9zYh4nMiK6QVIF+CgC+'
    b'dcWDmyy3bSnepw/beSDcCSx2TVvh+IwDkWao3NrlwhcxFJ48Ht9P3n3blfftDSkVqKoAYKya'
    b'uNB24xvxU5LWOttEnph9KBxUhx6FLy98oVLMhRUm1gfPgWXACZaFhbmlWFkIuLOU6urDIDuI'
    b'r7hz1gMrQkI/1FTAF6dflx3hj76RnNg+fdcCNNvlxjgRyGj8pQVmZkTBUUXxIakS3J6/+9Mr'
    b'wa6/YaR35u1hsSpqKgC4ecaibZRKzFRBMuWJugdU+dARSiH7POejSC/kYqbv3EKsDvYQnGZN'
    b't2lv0hp18/Wz76r7F+R1FQAsmrOku8P+yDxWQnE7rMvA8YKHLHoCF5CkIAnK0XV6GYZ9qgAL'
    b'xPTsfSoTnzHvonvfDck1UWeoSix/+f7rjxT2POIZ6RY4oETXBjiELK9IIg6M4txh5I0CcP9X'
    b'Wpyqzg3h43vtbGLG/AH+RDZCOMXg8PAz3zzPbc2+4FjZ0bxHMr+aCwSoRgFD1dp5xBHCfF+g'
    b'n+03d7fGRl9362cXDkp4YMAlUI475jzY3V74yAWmm1yLv8eB5fSf0f2pIOpiAyhK+O3PdBTO'
    b'+NRQhAeG5AER1r661tqaWrvAMdL3cqhtwl+U6Z2iNBxyg1kiUVyp50Wl2BPNoI/QeDcZ85o/'
    b'jPktC78+81+WS9UQUTb00PHI6kWTsnZ+sWHnL3eNHFO0N4gsvDwGszQGc8+oUADiAP75iuxC'
    b'8/IR7oiuGy+7t+ohZzCoNeeQ8Ngv77k6bWYXeEH+fPzvMQgvP3qGLgqUchoysQQ9jVqMSD/W'
    b'jigTL0T5Qqt8Y5XykvffMet7J/z+oiEKADa+tU29uvsn03yVuykICpe4ptOBC1U0QbkVI+AF'
    b'ZfnP6H0hewIsHlikXKOHbw4vWX7LinmzvlNxpT0RNEwB5Vj2fNfpuZgzxzOzlwe+O8E3go/5'
    b'+K+yuJOLWHpiuD2OwkBJWL5/8Nrmu6Fv+dYO07Zet52257xDzc/e/sW7Sz9LNwjDooByPLXm'
    b'oZajsaPnZwtHm5VlTsVfZvDqneL6acP32P5YKgzbTgZe4P7WChJ7cvncb1oTyffPTo3fNuNz'
    b'X8mGQw0Lhl0B1dD9mx61ecMGSh/KyF+ctCdi9PdXX0Jjzh2H8H4SQfT/jBmEceDMLiMAAAAA'
    b'SUVORK5CYII=')

#----------------------------------------------------------------------
shield_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABu0lEQVRIS9VWwVXCQBCdITy9'
    b'YgGgdCAd4M3gQUqQCshWAFSQpAJjBerB6M0W6ACMBcgZXxhngfA2m02y74kH95Rksv/v/Pkz'
    b'CcIfL7TFv/YX/QY2fQJaIcFDLDqRzd5KgqG/aK3BGQLiGIAu84A4B6KwjshIIIG/0ZkQwB2D'
    b'tupOyiBBSmn4JrpL/d0cgZTBQefWFthAHG0onalEOYJBkDD271fsdQ64/4GAi60Z4JgZRCeU'
    b'inWjOWZHTTNxj0WwBX8S3ZXrf3iI6B+ToBRcklRlsOD4heIj6Wv1XoYqwTm+YoKzDCPnIjdI'
    b'3vlBXwZl87x4HcHWvedb2XA24HLnPPbaPSPBTZDwrAFPBolIvIrzQF7vSaBMc61zIs5gZM7A'
    b'T4aI8JgFVRI5PkwF1cD5ZDBS51NOou1wQ+dL3aSS6G4pgLP+QOlVLLrcG7tVGHaqTGom25cV'
    b'KxrAD3VTYwUCUxYmMNPpedD19IlqHNcWUhTxEafxuD3TA6UfHJNUZZlkli6RrVyAQfg5UWeM'
    b're6VNdBB9nLxJ7PQ0Ut2WJj1SkV2diV0dz0iG3HJWT2fwiaSfVG32/qvog6oLP4DtWLrGSIJ'
    b'Gq4AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
shield_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAEH0lEQVR4Xu2bTVYiMRDH07Qf'
    b'Wy8wDtxgvIHuBBfCCYQTjJyA8QTqCUZPMLgQ3OkNxhvA4AGGpU9tYhV0K2g3qSSV8CH9ns/3'
    b'tKmu/y9VlaTSBOKLX8EX1y9mCqBc7mw9Poqtm5tCd1YDMRMA+/ud3TAMD6UUVRC+BT8Xg0F0'
    b'MgsQXgGg8Fxu7VQI+SNtxAHIXRCIy1Zr+8JXRDgHgGH+9BSWhQh+Zgn/LDa4h3vPfYBwBmAk'
    b'fA1FH8dhbjSoEBFnURSdu0oPdgAp+W0kPOVDTuoEGwBVfnNR4K4TVgDM8psLBU+dMAKAwp+f'
    b'w8bYNMalysiOTZ3QAuAwv42Ec9QJEgBf+c1FQadOKAGUSg9/6fM3lwQuO8F9q/VtZ5o1AoCe'
    b'5HJnFnZgMTVV4wqAalRKpVUErFJAFSXz/P9VDViyIgidowB6BfIXNeqWKQK60DXaw20xrE0a'
    b'VAjLAuBNfDLyVAjLAOCTeB0Iiw4gUzxCKBb/HQdBAD3G7GuRAViLRyyLCoBF/KICYBO/iABY'
    b'xXMB+A+G8PTG9cUufpEAOBEPALpQBAuWDRFyR6gPragaNCgP4YFVjXBxJR5cYOgIFYu9WxC1'
    b'qxA0FN9ubzfxPugh/CZCcCgeFstw1gg+7VlFwMFB7xQM4fFW1jUhPrmJAMGp+NiPC0iBmlMA'
    b'AKeSjPzHB02B4EO8wPOC6+vtuhUASIEyGPqTbWR6nqVA8CI+9remOmFWNkXj4y+cCqdcZAg+'
    b'xQvYPhdUp8pKAHFR68DvvB2Eh8Zg8HKZ5RBlY6Mxs5BmALRHAkAohLFv6mknTQS/+OFTlAWQ'
    b'DEBdB8Zl6UFwJB6nwMziPOEtJaxodUAfgivx4Ekf8n9Hlf/kCMAb6WmQgJgeCQ7Fk8NfC4B+'
    b'FAzNpx5OOhaP1R+bp3eU6CYVwcQQYXWX8sxJCK7FgwNNmPsrFPFaEYA3j94TCG+pxt/vG0Hw'
    b'IJ5c/N4SVVcMcXOUZrYLf8zrPk/nftz8bG5GlWaz0Kd+TisF4ijIQxTgwmjeLqz8FWruG0cA'
    b'fpB6KOGTEGXjk+aPdgSMFUTC8tgbgu7GRrSjE/pWEWBXEPmhUFd9rBGAxvSWyPzC0aKUst5u'
    b'fz8ztW6cAskD9VeIpq5+/pxp3o9bsgYwKorkHiCfetjtQd7XTfKeHUCcDpTmKQsAk/k+68Es'
    b'EeAzHTDs19ejE9uRt54Fsog6XO5C91me2BQ89lkgC0Kp1IHvBA33DFxHaqmtd458Yk2BcYfi'
    b'7TO+vFC1cRTzXcqoRmlumDzHGYDEGYwGKcNTwunShP+jN76jeqtVgC9QubucA3gH0auCqCMV'
    b'CBQOy5sr7lz3MgtQxgl6CvkgyMFhS+7o/TV8/PqLgHPFlyvXI/7RR28RkAZn1GARfd+inSyE'
    b'KKM/j/fMNALmAcgrqBSbX7ff/2MAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
sos_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwY'
    b'AAAE7mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlk'
    b'PSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9i'
    b'ZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4xLWMwMDAgNzkuOWNjYzRk'
    b'ZSwgMjAyMi8wMy8xNC0xMToyNjoxOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJo'
    b'dHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNj'
    b'cmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hh'
    b'cC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHht'
    b'bG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1s'
    b'bnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0'
    b'PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHht'
    b'cDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIiB4bXA6Q3Jl'
    b'YXRlRGF0ZT0iMjAyMi0xMi0wNFQxMzoyMDo1MiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIw'
    b'MjItMTItMDRUMTM6MjY6NTkrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjItMTItMDRU'
    b'MTM6MjY6NTkrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JN'
    b'b2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmFkODgzM2IzLWRjMDctZGQ0NS1h'
    b'ZGZlLWZjMTk0ZTIxZDQ1MCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDphZDg4MzNiMy1k'
    b'YzA3LWRkNDUtYWRmZS1mYzE5NGUyMWQ0NTAiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0i'
    b'eG1wLmRpZDphZDg4MzNiMy1kYzA3LWRkNDUtYWRmZS1mYzE5NGUyMWQ0NTAiPiA8eG1wTU06'
    b'SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2'
    b'dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmFkODgzM2IzLWRjMDctZGQ0NS1hZGZlLWZjMTk0ZTIx'
    b'ZDQ1MCIgc3RFdnQ6d2hlbj0iMjAyMi0xMi0wNFQxMzoyMDo1MiswMTowMCIgc3RFdnQ6c29m'
    b'dHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIzLjMgKFdpbmRvd3MpIi8+IDwvcmRmOlNl'
    b'cT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6'
    b'eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pl5YidgAAAGYSURBVEiJ7ZVPKERRFMZ/M/NS'
    b'09vORvI3C6HIYu7GQrkkUXZKyoqslWyslIWysxEbNrKcWIzyko3FmyyMkCKF7GQhNyWMxTsv'
    b't9dTs1GzmFOv83X+fN95593bS5RKJf7Tkv/KXhWoCIHEW392ENgEGqz4FzDpev6u0aod2AG6'
    b'Ir1FYML1/CujVVpqRgDHqikkgY0IOUAKqBO8EkOOxFYETwNjEXKAegdotIpuBb8DBcEdltCB'
    b'4CFgwcq1iD8BFi2BC1vx1PX8s5hJw+907Xr+MYDRqimSC+05rAnNIdh3ClgyWr3I9Huu5+dj'
    b'xP6yD/E9RqstwTfAmgMcErzyqNUwa7Tqdz3/qEyBA2AeqAemrHhvEhgn2Nu2PI+SHCp3fBlk'
    b'GFgXjn1JDTiu578Cy2Gx0Sonk9SUKyAieSAvHN0EG0k5RqsM0GnVZiK93+LbjFZ9IbZzRqsE'
    b'kAXSEm8Nmx3gHKiNGepO/CXQTHAsFyI1l+LngNUYjvskvzsP7RPIEdxuhLQY01y0BJ8ITqNt'
    b'D8BMovrDqQpUvsAPhxNojGC31l4AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
sos_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAGf0lEQVR4Xu1bXVIbRxCeWcnG'
    b'MaQKn8ACnGeLEwROEHhErlTgBJgTYE5gOAFypSweI5/A3CB6jyHrE3irAk4E1ky690esduen'
    b'Z3aXFIGtolSFZmd6vvn6d1qc3fOH3/P9swcAHhhwzxG4NRX4ctxZfPT4UYdz0ZGSLTIuFwMW'
    b'PJfwyZgMpeCf4S/E8/j+50+nt3UujQLw90mnM5HBBizyC2O8A5uCzZKfIYA0Cph4991WGAPT'
    b'xFM7AHjSj58Eu0yyDdh0tw6hQUhgBB897X3aq2O+/By1AZBQvLXBOduHBfC0m3giUJ+9hVdn'
    b'/bomrwWAv359sRa0xFv7icsRjAnB+UZc8kgw8ZnBJw/kc1QRLhPgJGNr5g3KkZT8qA4gKgGA'
    b'pz43196XTL7WCBzBAiMwdKdStD4svPoDALA/MZvmgu2A8Z8sYAzne2eb9hn1I7wBiHV9rnUM'
    b'U4OuKx+ga7BO3bROxHSdP+F7jQGVo6uxWH+2E0Y+QHgBcPH+hy64s9+sus7lm/mt8wMfwbJ3'
    b'Lt6vbINdQaBNjzfYzgCkm/+oP5EZOSOg6LMqAFwOln+325ZkBWDcqivjnABI6BjA5unuDaz2'
    b'jq+xuhysoHoh06hPdDWeLLmoAxkAgs7rhPRmwdfByke7RyguK0fzvfNVKmJkAL4OXrw1WHvj'
    b'ej4sSFyrRFXzecjegQSABxULQt+cCtoQxkRXlQswFowyHYY1kfo6D0MBZRPsz9A20AqAj96r'
    b'FuWMH0om1gj2I4SxQ1+25dYmqZ4VgIvB8msQCKK8u/dQVM8IQGr4wA01Fts3jaqVBUYALk+W'
    b'9yFWf1OzlHF4jNndTC4gY9daRefVYlqCMTMADkEIAaQI9Prgeiz6Jj/dgMoZWaAFII34kP7T'
    b'J+CTpaTAwXdd1ALzeSEDSGNpyRCuHXABbteWFc7AHoFnOcSkC8L0kty6oooegLLxm/Gt6UlZ'
    b'gUDrPx5/O3CJzrJtEWOPEJh1lGfW5cnKMeTU29k88P3eQu/8UO2dNNwt+WGNLqUxApS8yvqL'
    b'Jz8eTzZ9Nn8DgjoajFnF5AeVSikSqBBigiUyAKoUFOlvqs0pTss7Q8sLmsrypSC8MdJTvaOT'
    b'X6kCZf23x9fABMzZO1NBa0iFs7kUJ2p1b8U8Qkz4uqrarASgGIcj3Z72ztZ1ll5hMJ2zMpsX'
    b'AYCRBdOiiI2RJTugyUo1DCgUITjrz2+d7egBKBUtyMmIbePZ9y6GDd8pqqTOEKoBKHgAtOSm'
    b'knTRd9vGUzedH1cKyiwqRh2vBIBKH+3pVCiC6MBRZKRGllHHKwGg0kfnr01+1+f08Z2SIXRV'
    b'S814DQMKOUBNdPPdfAxAQ2pZixGk0q0KAMXAzMYyKovVDCgXI10DD6ufdgWjGGfo/PrULpUr'
    b'SsoKETEQYtpQMrfgTCBEKUZQQVBkiFaAFSU1OgAuoaTOE8D/IwhWVqtebeMVu5AtzO5uboYs'
    b'BtAllNdmg8ULCZ3OYdTYakm4HyynrrYIksIAXXE0SbHZO9WdQ9km6UN5r3QYEW63213SjXCF'
    b'nIBWHCnfFFMzWTwALQA6Nch1fDg0P0CnBxebVHXwvISBUhvvY+0BLm1nLlNNBtNSEitkeBTO'
    b'GsbYDGOuyQKr0C7tNKZVjTdF/0VRFHnXzxqj4OYXa4XQPMVfJm01dW08xaRKUfT/UBa3XZYa'
    b'GaCMwSuqwa2+TjDAVgBQ4FK1x2cXSHsaxaG6y4b5oqbPcvBOCKe/aqtHUgFwvacvyHzjh+Nq'
    b'U1v8mAzgHdjoIljvMLkkaZ1eX12HKHTVy1FbrpAJSAIgZYH3ba3N+qtOWHUvQWaCJVLMz0MG'
    b'IAGB3q6SW4RERdXm/FTPrWnKCQAvr0AwRLqTJTZI5V93zj+cAEi8QtwhNnP1ZKBm5eqwAwuw'
    b'TW6H0hThrQLZi+ROsQqnf7MWrU3OZ/OxGSYblsJASueIrXZPWVuZDs+86JZnFNf0BiCbiOCu'
    b'huAFoE2W3uCc2po1EG4X0mxMupR5AabEVe8eKwMQ24WkYGm9KYahSdMS/A4AP/BHElkuMP3x'
    b'hJSwYd7RbToFntRrQGFYLQBM9bX5fqLaNp7JXCsABSAojKAcEo6Jmx+u/hFHttCWOmGjAGST'
    b'Y9jLW6ILKONPZhwKKLF1PnVts3fdfKyNPi/5vJMZttQGvEzmAF2fyQV4hD+c4gGPqO00PrLk'
    b'37k1AKoK2tT7DwA0hexdmfeBAXflpJqS819gdftuhNAllQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
Splash = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAwwAAAGQEAYAAABT1DspAAB+kUlEQVR42uzdD7gdZX0gfq1r'
    b'qbWsP5b6Y13qIqJlWVcppYqWFYqIrmJEpIiYsJQiRYgsSwFtpBQp0IQi0mAhZZEFioGlGCkm'
    b'lAaKLNBolSImCARIDAExYMg/Qsjfe2fPm9w3F+cyzJxzz5kzM+dzvw/P58nlnDkz77953/d7'
    b'zrmvWrkixKteVa6//MvbPPD3tvnlc7b5rVnb/PGD21yxYpsbN24zSUiSJEmSJEmSbL5xXzzu'
    b'k8d987iPHvfV4z573Hcvb7+/pBfa57e3ecUVsUDWvj1Ekqw/J0SSbPpaiCQZ2i1EkgzfFyJJ'
    b'kiu2hh8/fvz48ePHjx8/fvz48ePHjx8/fvz48TMYPyP74nGfPO6bx330uK8e99lXrnhpxH34'
    b'uC9fuwTD3r+1zVtv3ebw0MZ3hHhJ4sCPHz9+/Pjx48ePHz9+/Pjx48ePHz9+/PjxM+6f4cdD'
    b'JEnch4/78tv8h1t/cd++cgmGX/mVbX714m1u3rxxlxCtK1u2NVpXtjVIkiRJkiRJkmQvHdmX'
    b'j/v0cd9+m5dc8ov7+n1LMLztbdt84IEXzwrROvHTtoYKJEmSJEmSJEmyCp67NZK4jx/39X9x'
    b'n7+0BMO737PNnz+7YWIIFUSSJEmSJEmSZB2M+/rb9vmfW77N/d7b4wRDfIG1azeeHUJFkCRJ'
    b'kiRJkiRZRzdeHSImGtaubTfR0OZXIf382Y1XhGidwKqtQZIkSZIkSZIka2zc9495gKJfnVTw'
    b'jzc/8MCGI0MoaJIkSZIkSZIkm2jMA/zi32jI/mPQOQmGr1784hdDKFiSJEmSJEmSJAfBmBfY'
    b'lie4+OI2Ewx7/9Y2N29OTtwaCpYkSZIkSZIkyUHwyK2RxDzBNt/1roIJhltv3bhTCAVJkiRJ'
    b'kiRJkuQgumFrxETDnNk5CYZ9fnubw0PJI1sjSZ7dGiRJkiRJkiRJcpAcyRPEvMEv5hHGJBi+'
    b'fuXGvUMoOJIkSZIkSZIkmSQxbxDzCKkEww4jfwV69arhZ0MoMJIkSZIkSZIkmSQxbxDzCDGv'
    b'MJJgOOCAtTuGaD1h6dYgSZIkSZIkSZLcbswjxLzCSILhy+esPzWEAiJJkiRJkiRJkmONeYSY'
    b'VxhJMNx886ZLQiggkiRJkiRJkiQ51phHiHmFkQTDQw8N7RJCAZEkSZIkSZIkybHGPELMK4wk'
    b'GJ5bPnxFiNYDH98aJEmSJEmSJEmS2415hJhXGEkwbNyYnLk1FBRJkiRJkiRJkhzrSB4h5hVG'
    b'EgwKhiRJkiRJkiRJ5hvzChIMJEmSJEmSJElyHAmG+VuDJEmSJEmSJEkyUwkGkiRJkiRJkiTZ'
    b'hQTDfVuDJEmSJEmSJEkyUwkGkiRJkiRJkiQpwUCSJEmSJEmSJCUYSJIkSZIkSZJkLRIM85J7'
    b'W/+RJEmSJEmSJElmKsFAkiRJkiRJkiQlGEiSJEmSJEmSZD8SDHduDZIkSZIkSZIkyUwlGEiS'
    b'JEmSJEmSpAQDSZIkSZIkSZKUYCBJkiRJkiRJkrVIMNy6NUiSJEmSJEmSJDOVYCBJkiRJkiRJ'
    b'khIMJEmSJEmSJEmyHwmGWVuDJEmSJEmSJEkyUwkGkiRJkiRJkiQpwUCSJEmSJEmSJPuRYLhh'
    b'a5AkSZIkSZIkSWYqwUCSJEmSJEmSJLuQYLhqa5AkSZIkSZIkSWYqwUCSJEmSJEmSJCUYSJIk'
    b'SZIkSZKkBANJkiRJkiRJkqxFgmHG1iBJkiRJkiRJksxUgoEkSZIkSZIkSUowkCRJkiRJkiTJ'
    b'fiQYLtkaJEmSJEmSJEmSmUowkCRJkiRJkiTJLiQYLtwaJEmSJEmSJEmSmUowkCRJkiRJkiRJ'
    b'CQaSJEmSJEmSJNmPBMM5W4MkSZIkSZIkSTJTCYaGuXnzP93x2l+uvz9/9uAPvvs95bv88A+9'
    b'+L53Jclzu3380wf9RsuPHLbgA3OSZMVJn/nNCT9sdZj3HTftyO8kyer3n77lpEuT5PnXnP++'
    b's/5Nkqxdctm+Fx+cJOvuuP6dV5+bJOsfnHvsnN2TZNMdD6750S1JMrR09R2rrtU+SZIkSZIk'
    b'SUowUIKhkQmGXvvczUf8+Yf+rpWgOOsLvzP5hSR54YorH/nrE5Nk477zlt99tUQESZIkSZIk'
    b'yTonGKZsDdZUCYaaO/TBX3rPL7U65uIT/+ekX28lIG76+tcu27tVLq97eOmDj7bq+YThO4Zn'
    b'aeckSZIkSZIk+68EgwSDBEONXHHgp7/5sfeOJh62TP/psieXa/ckSZIkSZIkq5BgOD05rfUf'
    b'a6oEw2C6+r4pbzv1N5Jk49P/esG/zNUPSJIkSZIkSfZeCQYJBgmGBrpq6LR7TnxXkmy66sF3'
    b'PLBYvyBJkiRJkiQpwUAJBnbgmuXnffFLLYcuWHHHc5P1E5IkSZIkSZK9SDCctDVYUyUY+Eo+'
    b'N/ETXzn4T5Nkw+S79rt9sv5CkiRJkiRJsnMlGCQYJBgG2LWHXJJMnZUkwys2bd50g/5DkiRJ'
    b'kiRJUoJBgkGCge38keg9Tv/dz93TSjS8+4Wj1p6nH5EkSZIkSZLsJMFwfHJc6z/WVAkGjseV'
    b'N5+w+jNfSpKh2aueWnmH/kSSJEmSJEkyWwkGCQYJBo5NNNz7R9+c+MHWJxr2fuGwtWfrVyRJ'
    b'kiRJkiSLJBgmbg3WVAkGdvWrk/Y9/fmTprUSDes237T5eP2LJEmSJEmS5KgSDBIMEgzM/2PQ'
    b'R/7VbdNO179IkiRJkiRJvlKC4citwZoqwcBeuuEj3zl17mX6GUmSJEmSJEkJBgkGCQa24XOv'
    b'm/A3v/fxJBl6zbNrnjlKfyNJkiRJkiQlGCQYJBgkGNiGa/b60x+c/qv6G0mSJEmSJCnB8NIE'
    b'w6FbgzVVgoFluvHM739x3mn6HUmSJEmSJDmISjBIMEgwsGNXHv2Hm476aKv97TE0f+hW/Y8k'
    b'WXHv+ul9X72/ZfLQQ4d94hX82solc2coL5IkSZJsP8FwyNZgTZVgYF/++POJdy2+Yzf9jyRZ'
    b'USe/eONjtxRILETPfOHWBZOVG0mSJEnmKcEgwVBJn5t62Ib3/m2SrDj+M2+Z8C+987mbjvjT'
    b'D30jSZYv+dhvHPCPEgWduuoNJ/2v/36y/keSrJy7Dn+t5YNLJv/JL7eRYJi46ZLlByk/kiRJ'
    b'kmw/wfD+rcGa2pQEw9ADT+4w/ajyy2/45k07b2y9w3HLo8/utmxKkmzc/MMZP1ibJC9ee/O1'
    b'N85KkuePmDr/z37WSlAc95n/OOG7EgtpN6165NQfn6kfkiQr4tlrTv3nGW0kFjY//MARZ2x9'
    b'/s7DFyk/kiRJksxTgkGCQYJhPOV9w092evyyJHnhkq+fednOrU9EnPvJXzrk3w5ugmHtbpfs'
    b'8xfz9UOSZJ89ePhNm05suezxHU74bBsJhiWLbvj8R5UfSZIkSXaeYNhva7CmNibBcN+Tr5l+'
    b'RP3Kf/icDZdteGPrEw+HfvOm689uJRx2mHD57318cBIMzx182L9+4Futcpi/eermg/RHkmSf'
    b'vGz5slm7tZFYiN795NkXvFn5kSRJkmRRJRgkGCQYeujQF1cmK76fJKtP/MJbJj8xOImGjet+'
    b'OP0Hq6pbL/dujVGXXhnC+EEOogvuCzF2XOiVq08Modx75kc2z1z9upbrFu766Q0dJBhmPnPk'
    b'VWuVI41jxjHS+GB8IElKMEgwSDBUyTcM3Tl0bZKs3eeS5VNnND/B8MJOf7PDXx3Wv/KOCYNp'
    b'80IkyQHfCZEku781RL6T/3OIJLn+uBDGFbLJTvpMiOLjw3iNC3Dl3yNn/ezWGTt2kFiIXrjy'
    b'qNumKEcax4xjpPHB+ECS7DzB8M6twZramATDvKXJ9MMaWE9vGj51uLVhvfbI6cdeuFdzEwwr'
    b'13/usWO+Xn75Xj8xRJLsvTpE9ybKE74SovUOoHtDGGfIJjnp0yFKXHivD6Hcu+7hG17/xEMt'
    b'hx4+/PA/HEeC4YQXDvuR+qFxzDhGGh+MDyTJwkowSDBIMPTB4dmb7t50SpKsOu2UD/3hpOYl'
    b'GJbv9MHvvOdfW9c5Yf1OL57Z+/KME9leT5jjJyFWHxvCeENaeFt4V8Z5S/c+5/JxJBaiH960'
    b'57P3KU8ax4xjpPHB+ECSlGCQYJBgqEN9PfLE+xY/29qQ3/9D73nvHzYv0bDp7Adn/+i05k2c'
    b'Z1wcwnhDWnhbePfdk9Ye9a8PdiGxsPnhB444o+Xew48OSTDQOGYcI40PxgeS5DgSDHtuDdbU'
    b'xiQY7l26efqhg1Nva1/91ckXbG5eguHFjbMPmnVZ78pt9dEhypswRyd9KoTxhmyCsT+XtvBe'
    b'G0K5j9t3DJ+75YSWixdNmdyNTy4sXnT4yT9TrkWdcVGI8u+/dbXX8wbjGEnjA0myn0owSDBI'
    b'MFTALW948qQnDm7gH3ue+L/Wfu303pVbnMCWvVFwwD+FMN6QFt4W3n3z3BXzbz2mC4mF6F1P'
    b'vv2825SrBIMEg3GMNM8xPpAkx59g2D3ZrfUfa2pjEgx3LV0//cODV3+rXnfSpf+9QV+VtOaB'
    b'8yZ+6T/0rrzuXXXvintX9W/DwLhD1t9Jvx+ixIX3yLil/Dt07y1TX3hTyxWP7nzMf+higuGq'
    b'Zeu/PlX5FnXG1BkXzJgqcVA4wTAyzhjHSJrnkCSbqASDBIMEQ4Vct991r/v625uTYFh1yOQf'
    b'/ME/Ny/BsPfqEMYb0sLbwrt0r3zm9P99ZRcTC9FzVtx360TlK8EgwWAcI81zjA8kyfEnGHbZ'
    b'GqypjUkwzF26ZvpBg1d/G2+9/9XfP6g5CYYVx3zmP0y4p3fltfScEH3YKPhkCOMN2QRjfy5t'
    b'4b0shHJv2/02nvKzdVv/GPPMT/5zDxIMR65d8cBU5VzUGeeGkDioyrzBOEbS+ECS7KcSDBIM'
    b'EgwVcmjGml1Wv745CYbnTjr8gx/8QO/L7YDbQ5Q3cY4bK8Yd0sLbwrskb31yzdS39yCxEH33'
    b'xrufOUo5SzBIMBjHSPMc4wNJUoJBgkGCoQEun/3Rv33/W+qfYFi+5mMLD/zz3pfX9YeFKOGr'
    b'kVaGGP3khHGHtPC28O6xh617w4+P7mFiIX4i4k3DVw69VnlLMEgwGMdI8xzjA0ly/AmGnbYG'
    b'a2pjEgy3LV01/cDBrccVF0y89LBPNeeTDGWV25RnQvQusXD9oSGMM2STnPSJECUuvJ8Kodxz'
    b'3Xn4rqFbWs5fvPy07/YwwfD445tP+rLybtcZ54SQOCicYBgZZ4xjJM1zSJJNVIJBgkGCoYod'
    b'89oTnvzM5yUYOvXWN4ZIkgl/EaLzCXJMWCydEsL4Qlp4W3iX5kmrbr1zRg8TC9G5S+//88OU'
    b'twSDBINxjDTPMT6QJLuXYHjd1mBNbUyC4Zalz05/3+DW42PzLnjDV+Y2KMHQ5/JcenqIVuJh'
    b'pxCtjZGzQoz13sUhkmT1+0MYT8hBcNLHQ5S48B4ZZ5R/hjsPHbS+NV4nTz/2uuN+t4QEw2XL'
    b'rrzyzcq9XeN9UwKhYIJhZJwxjpE0zyFJNtGxCYbXbA3W1MYkGG5eumz6foNbj8d+92/e/eL0'
    b'JDnoA+ef98La+qt/kqyqkz4WosSF96MhlHum5/78qOvnl5BYiJ664qTZy5R7u874YgiJg8IJ'
    b'hpFxxjhG0jyHJNlEJRgkGCQYKuin/v309S/uWP/Ewsc+f9HcdRfplyQtvC28c3zzphueO7Hl'
    b'+kc+cuT5JSYYDl17/P0nKv+qJxgO+McQo/21bk6bFcI4RtI8hyQpwUAJBgmGXtffR7ZcOdx6'
    b'5+bBf3bBunU71T/BcPSCvz7mxYP0S5IW3hbeOV7300cvOb7ExEL07Rsn/uxp5V/1BEN8PeVv'
    b'HCNpfCBJ1iDBMLwxBOtqYxIMNy5dOn2fwau/peuee//Qac35aqTJf3f1U+v30S9JVtdJHw1R'
    b'4sJ7fgjlHk32fvGyx/dsOfRQ8olfKjGxsPnhsz7571rnMTR8xJb91EO7zjgtRIkJhpHXU/7G'
    b'MZLGB5Jk9ZRgkGCQYKiQt09dcN/mic1JMJz7/lkPbDhSvyRp4W3hnZFguHvJeX9yfR8+ufD4'
    b'49d97jeUvwSDccw4Nn4XXBFitFzSrt47hHKi8YEkOUgJhrUhWFcbk2CYuXTx9HcOXv1NXfHt'
    b'3TfMak6C4apz/u+OGx/ofbktuCxEa0J7f4jeu3qvEPU7715dR6/sV7lEq1ousd5ufXWI1sbb'
    b'qSFaC8j/FiJJJnw5xDj+GOnIcSb/eojR41e9XDo1Xm9pC++GlmO7JoeuOXHeLn1ILERnL73y'
    b'3BnqoVPjuFBagmHk9ZS/cawXLj02xNj7arwP9qp84/06Hj++bjyPqs/T+j0/zKqnvZ8L0Xm9'
    b'xOdnzYdi/cR5vPGhu+NDbPfXvy9EkkybGaLz6zjgH0KMPj8eTz+zHqmSvdoXKOu80/Xf7jgc'
    b'+2ns9/pZPZVgaJhPnnjnQbt+rP4+f94Th/z1zMGptw3J5l2Hr2vdiJ/5yqx1VzUnwXD7eQu+'
    b't/koE+e8BVJZ512XDZs4UVUu24wTrTjB7le5pI3nU/eJoI25kt08NH/T7q0N/sWP7/lHv9bH'
    b'BMPFyw68YrZ5owSDBMMgjWNxfjFlUYjRDY2q3Febfr/tdIO5avOfrIREup6qsnFd9vjQ6Xoo'
    b'9st+1WN8fW8EsR5pUj/t9jgU76PjTSCZ7w1KgmF5K1hbf+d3/s8NR/x+/Z259NEdZl8yOPV2'
    b'+9kL7t58RHMSC9GfrPr5h4cO7H35TfpQK8pcWH8vRPfOf9q1rbiufxOzpUe3YmL/+8Hq3Vux'
    b'R2vBPydE+eUw4c9C9P/6Z0wOMf534JVtrLfr3x2iPuNv3cePupmc9NxO3zq6j4mF6PErXvft'
    b's8wbOzWOU6UlGEZeT/kbx4o4ZyhEa8NwYSseq899tOn326bOf3I3QP+/Vvy70XbZ9PEh73zi'
    b'uqPs82r7HfQj57fgklZMH5z7ifVIs+7j471fl91fzffqrQSDBIMEQx/dvO+WC4bvaA3Yv3LZ'
    b'fS826G8vfPRdf3nIutaNYcvNQ1OGH7CwrvrGeiy/QduwStuvBURccDZtQR0TNlXfiLIxV1Ji'
    b'4dWbL1x9ZstVC3f59AsVSDC8//mH7jvEvFGCQYKhzuNYeiOsX/Ooqtxv67YR2tT5T9EN0Nhu'
    b'YztueoKh7vXd9PuQ9Ugz7+Odttt+tYdBfyNW8xIMT4VgXW1MgmHxo6+ZfWHz6+sbe/3zUeGr'
    b'Ipr2yYXT//9v3LT+kvLKcdIHQ5R447s7RPevIx63XxOw6/cOUX4/WHBhiD4uGE4IUd71rn5T'
    b'iNY7Kx8OMTgL6rLLedDGj6qbXPSzO2dcWYHEQnTHDSuePsm8sVNjfx708cM41p/rXXp4iMHb'
    b'mK76fK6ogzb/6Xd/Kmt8iP0x/fqxPTalvmL7rft9w3pkMO7j8bhFz6Pf/XVQ10lNUYJBgkGC'
    b'oQ8uOOTJXbZcnCQf/K9/ceq6XZuXYLj++Hnf23SghXXdFl5xYRAnnE2tv+3vaPnTEOVP5OPr'
    b'DupCumoLMwmGHicWdl6/fumHW25++PDD/7ACiYWR8xh+dviNm08zb5RgkGCo8zjWr/mDRIPE'
    b'Qj82/qreT9LXM2d9CPPZqiYWrEcGaz1S9cTC9m8UGHnjofmdBAMlGCQYcnxkytOnb3kwSQ79'
    b'5kX7rzuneYmF6GOnLTt2y2YL6/FO/Pr1zrxpV4fofb31eyJT1gTGRL7aE3sJhh4nGG5eesqX'
    b'n6rQJxceffywP/pH80UJBgmGJoxj/f7kp3fIV3O8kADqb4Jh0D5hVJf7k/XIYK9Hsu4DVfuE'
    b'kXld0xIMi4cfH17MutqYBMOjC5PZFzSnXu5++pHzNs9qJRb+rtmJhaP/7dcWv7hP+eU76QMh'
    b'Slyo3XnvHffe2fvrmrN2zpo5a/u4AX/egnMXnNf961q9c4itC4+f92PhMeP4GcfNOL739Rev'
    b'00Q+J6F1ZYj+jc9NHT/6bbL32kPuP7RCiYXo0sdec9x7Wp677JYr76igp/784Ovvqn79xnG0'
    b'aeN2XR30cazs66/dd/5/O8TovKSselk6YemhSyco/5f5xPDW+W/T+kec7w5af4z1WXb/sh6x'
    b'HhnPPCqu8/u1Hs9MMJjX1VoJBgkGCYYeuOasF983vFeSXHTVnLM3PNLchELay++94+aNky2s'
    b'u+3kXwvRh49uj5Rrt69nyo+nLJjy4z5+JVJJ9dav66yrMaFm/Ki5S4f32/Lm1kb5A4tmfP53'
    b'K5hgqLrHPjfx5lskGCQYjGN1ekNGbd5pXXI/Mg+qRj1IwJX0TviR9l61+4N+aD3ycuv6qiac'
    b'zOualmB4KATramMSDA8t3Dz73PqU+/Or1u81vF/rvK+ed8im1kfMPv6Ni9++bubgJBaii499'
    b'9sChXcov/0m/F6LEhfVtIcq7vtU7hmi9w+DnIfqwEDo2xPivI5Zb3z6RcXaI3tfXnBUhqvsO'
    b'xthf4r8r8w6wkfYd27vxo54mh61Y+w+XSBS07SOPn3ni58IEfWjJptnVr+d4X6jbfaipGse2'
    b'WbX7WuXeaV3SfTYeX7m/vEsPCdHc8UH/Knceaz1iPdLOdU35UYgK/k2akes3r6u3EgwSDBIM'
    b'bbjliqEThlsLqgXve3LHLa3z+8vH57x6w/eT5KPP/eVd684cvIRC9MSfX3Xmi+strJs6UezW'
    b'RGvCl0LUN0FS9UTQ9ndQjUwcY3spev4xARPLq+4JLeNHyS7bMvmF1n0xWfbojsf8uoRB2+67'
    b'5oHv7Vyf+pZgkGCo4jh2/Z4hur8RNvlXQ4y2w3h/jeWQZ3xeVTZ6YznVpR7aNV1fefUT6zM+'
    b'Ps6jur3xGY/b9PFh4P+2Ro/7l/WI9Ugj/+i9BENDEwwPhGBdbUyC4cGF62efXX75rb1h/VXD'
    b'+7eW+3s/tXZL6xMIs77/gws3XZEkf37Tt27bMHFwP5mQ522n/2je5jf1r92XvrC+JUT/rnfy'
    b'r4Tow0TxhyHaP98ZE0P04SuR/iREefXS7+tcelCI7l3P6h1CjNZ72dcVX9/4UQ+TM5+ZcvXb'
    b'JQradvaSdV/6Zv3qu+zxLr6e+b5xrIgH/H2I9u+jsZ0tmBKid+cXy6/d8+zaBvzIPLJX1zft'
    b'shAlviN6pBx7VW9xfhXbR2wvdek3Vd+4jPUX282cZ0Nk12esj/i4OE/t94Z6Wf3LesR6pNEJ'
    b'BvO6WivBIMFQSb888+433HJ3knxt3ty7Nr5/HL527iEb902SqUu+vfOGq5Pk/GV/v+eGLybJ'
    b'F371+unrWxO8E//L1ze+uDxJPvGWr+66bq5EQbsesfCvzl3XKr9NR29eNfw1C+uyjBOdfk2k'
    b'i15/nGD26zx7vUHQ7/qIE/myJr5lT+zL2lC0MTdO1288etlJrY3y9Q/fd8QfSxgUduih5BOv'
    b'avm6F1ctfqMEgwSDcaybXr9HiOxPZMaNzLLmCXnzh34lGprSHuNGc9n1l048ZNVj/P2gjA9F'
    b'Pxnd7XE99qd+X2+8vkFZH1qPSDB05Y9sj9yXzeualmCYF4J1tSkJBhv49fDvXv8vb950XP/b'
    b'/aT/GqLEhfVNIfp/3XOeCtGHd6h8IUT++U3+NyH68JHWI0OUVw/x9cp+p9eqoRDN7W/bF+TG'
    b'j0qbXPHUXtMmSxi07dSnT7x0x/rWe9njXtnjet00jr1yuVz/5hDVPc9YnqW/EeO0EPVvj1Wt'
    b'zyk/CNH/9ld2feRtvPeq3VXtupfuF8J6xHqkXv207U8eTQ8xui/Rbv+O42VZ4wJ7qwSDBIME'
    b'A9v2Uz+6dPKLOyXJhp03nT58ioV1v63aRn6/FspFEx/dtux3Hva7/ZVdv72ecNqY6zCxsNML'
    b'G398n0RB26555IpPPdkqx6c2LV95kARD0zUPYjvGeUxp7/wf2RCqe3u0MVWPjcuyx424wd+3'
    b'T3yXfL3WI9YjPf2q5JGEqfs/20sw3BWCdVWCgWU497oF79j8zuq0+0m/G6LECdUNIapz/avW'
    b'hyh/Ah1fb+m+IUbP44BvhejDO/Emhyiv3OPrlZ5AGbB+N+OIEMaPynj38ClDx7Y2yu/6yWv+'
    b'+I8kDNr26OWv+bvd6j/fjP1SIiEnwWAexAr3q17dX8tuj5N/KYT2U5X6GLMx+S8h+nf90y4O'
    b'0Yc/9vymENYj1iP16KdjPqEwsp53v2c7SjBIMEgwsLBf+OXrL14/y8S5qjfaOJEt/Y+ZjSzs'
    b'+rXh1OsJX9M3Aqre3nq9cWD8aM/k3atu+s7OEgVt++hjM49/oVWO9w1N2HCxjVAJBuMY+z+P'
    b'69W8It63+7WRHd/wol1VY+MyvhGpX9df9gZ82fN26xHrkV4kkIyj7E6C4bYQrKsSDOyFE37z'
    b'K+9cd0mSPHPK6qOGplev3U96b4gSF9bXhqjuOFB2efRtAnRGiMEp56XvCFGddhbPp6x30Bg/'
    b'+uy9Q29e/0hro3zxY3sd91MJg7bda/Xpd5/TnPnmjMNCSCDkJhjMg9iGsVxL2ygc6cdNGx/i'
    b'vOH6N4bQrvq1Lpj8qhDVKYeyP2Hdq/5lPWI90st19ao1IYyb7EwJBgkGCQbm+s/3Pnrk5jtM'
    b'nOuysI4Trb2fCdHcjZsFJ4ToXzmX9lVUI/VY1fZW940640cxk4k/n3jDRImCtr3tJw+c+XCr'
    b'HOcOXzy8gwSDBINxjM1PMMx5NET1vupjUBMO/dq4rFp5l10OZSUYrEesR5qwrmZTEwy3hGBd'
    b'lWBgN736yruP2Xh/9dt96QvrK0NUv1xmHBqieRs28br6Va6x/su63ti+B73/LTguhPGjdB/a'
    b'dMxzu23948Snfuq3JAzadXjzutsWvrN5882m3l+6vhFhHsQKzy96NZ9atTxEdfvlAd8MMXr9'
    b'8Xyb2q76tXG5dM8Qg3vf6vV6xXrEeqQJ62o2SwkGCQYJBo7xL++fvXZD6xMLQ2uH3z18g4lz'
    b'3RfWTfnKpAl/HKL/5Xn9TiH6txCumvH86trvjB+vbHLe0zv+1Q0SBW170U93+coFzZ1vSjBI'
    b'MAxCgiFuJMXrjff/vPvitKkhRuulqHGe05SNpSn3hKhPf43n26sNxEFZB2x/p/uA37d63b+s'
    b'R6xHmpgIpAQDJRgkGBri+W+++boNxyfJljOHDhr+molzUxbWceJQ969MqsqCz8Zaf5RgKNm1'
    b'L17w+FWtjfKhh5JPvErCoLDrHnnz7/+oVX6Pbnzq52+QYJBgMA+q8icFYjs+eThEeRtUg/KJ'
    b'0Dhvq/sbW+JGrgRDvd/p3rQEg/uw9UgT3rjHpicYbgjBuirBwE786jn/cMSGZ1uJhclD+w1f'
    b'WL92P+l3QpQ4sbgsRP3KacYhIWq4AB4576qU47TzQphglz6h71G/M368vMmsJVdM+YCEQdse'
    b'/ewF1z3V/PlmXe8npScYzIP66pwHQrTemf6dEM3/21RVnV81Zd60/R3cI+W2amkI66S0sb4H'
    b'/b7V6/5lPWI90sR+yno7NsFwbQjWVQkGFvED37lgyrodWu/ISb6726Y969/uJ/12iBInFtND'
    b'KK+ev7Pif4ZQfuxtvzN+/KLJTmvO++5BEgVtu/jRh/7gy+EdPFtuffG45s83ZxwcwriUm2Aw'
    b'DyrV63cI0doI/rsQ2l/uBuhIPy6rfuK8rinlFxNWZZdj1ceHqpZH2fetXpeD9Yj1SBP7Keut'
    b'BIMEgwTDAPnxay7efV2rnfxg5uJdN29sTru3sG7PpW8KUf138i04IoT2RgmGUrxx6KZN57Y2'
    b'yuc/fsgf/b2EQdvuuerNd6wanPmmBIMEQxXGsThPaNrGdVM3mFY9HqK59RUTW3PuCzG489aY'
    b'6JNgkGCwHnEf56AnGK4MwboqwcCX809+54Y16+9Okude9/x1Qzc2r92XfkO+KET9y23GgSEq'
    b'uOAdOS/tjWX0O+PHNpP3P/eGby2WKGjbOxbfdNqrWuV41fBHhvYfnPlm2feP2E/j69ZF86De'
    b'eP1rQ7gv1nW+teqREEky5R9DNLd84/XF67VOGqz7Vq/7l/WI9Yj9DFZNCQYJBgmGBvqJx746'
    b'fd1dSXLrIw/cvOnp5rd7N+TOnHZ2iOpN3E5+MYT2RhP6UhMME36+x/XhjzqfsOyyK6vo8oX7'
    b'H31N9RIMw2tfuPDBQwdvvtm0jRrzoHqMYxILzexXc74XorlfbTXhf4ToX6LBPEeCgdYjEgzs'
    b'T4JhegjWVQmGwfSDG/7i2XV7JMmly+futfFNSfL8LS8+O7R+cNr9pHeFKPGGfEGI+pZXPP+q'
    b'T+Dm3B1Ce2Nv+53xox4max455VO/VaEEw0VPzvuLzYNbHzP2D1HiRs3I6+kPgzmOxfmA+2Gz'
    b'+9Wq+0OMntfePwvRoETD50OMXqfxwX3LesR6RD9lk5RgkGCQYKihH/7taUetOyhJLnn3P8zb'
    b'8GySPHPo6ncPnWph7YZcbOF2wP8JUYM/njeysCx7IWZCb0Jv/KiQt2066LlXVyixsP7haz/5'
    b'f1vnde+GjT87T4JBgsE8qIx5S9U3mmP5R2N7zXPm1hgtT/3q5et/ypwQzZnPnPx8COOD+5b1'
    b'iPWIfsqmJxguCsG6KsHQTCfdfvn7Xjyq9dHwd8+7YtNOSbLii2svHJqlvUcn/ZcQJd6Qzw1R'
    b'v3KadmaIGi7EVocY3PbG3vY740fFXfbC2Q8eWKEEw5HPHH31a9XLjP1ClLhRM/J6+sVgjWNl'
    b't7PMP9478saMOI9acFCI7l9vLFf96uVd9b0Qo+dd9084zLkzhPHBfct6xHpEP2UzlGCQYJBg'
    b'qGAiYcYx//TajYe3FjCvXvrQlo8kydD9wzsNuwG4IddkwVr3hVieU74dwgaA8cOEvgyTXVfe'
    b'eft5FUgsLH10h2P+beu8rts8tPZi9SLBYBzr5TgWN5L7vYFcdruTYOisnczcHKI+n9BNJ66M'
    b'D+5b1iPUT9nMBMN5IVhXJRiq7cRNl9354oQkmfraW87aMCVJZl/8w302zU2SJw977sihXbTf'
    b'Tp30n0OUeEM+K0T1y2XVXSFaC5jrQ9Q/wbD9K5NGrqtf5Tpj3xAlTuhHXk9/N34MosmEZ+Zf'
    b'u3MFEgy7rbj3H45VH8ZB41gZ49jMdSH6N9+Ir192PcZy1a+6U44nrwxR/fntgv1DGB/ct9yH'
    b'3cf1U9ZbCQYJBgmGDvzk719ywboHkuRzf3PVkhdXJcmf/ceb7tqwQ5L89XG3v2njnqOJgwe/'
    b'+OS9W1qfSHhht/Xzh4a0Tzfkcp12WojmfTQ1Lhj7Va5lb3xM+fsQ+rnxY0ATDBc8+ezUmX1M'
    b'LNy16JbPL2qdz4VDSzbfqz5sbBjHyhjH4n2v9E8s9LmdSTD0xie2Rv/aVb/rwTynmfct6xH3'
    b'cesRVj/BcHYI1tWmJBimv/G+c7/d2qi/d7eF79t8Tu/9wUWLX715SZL8MFmydMubkuSRZU9f'
    b'taX1EZ+fnrfirqF3Jsnq49edMNT6CO7Qq4cuHD5JO6uapd+QzwxR3fKI59f078CcMztE88t3'
    b'wudC6OfGj8E0mbv4Hf/j5/1LMAw/u/Yd99+qHtLO2DtEiRs1I6+n/AdjHCv7evb+aYj+12Oc'
    b'1+hXvfWJjSFaG6bfDFGBPxI+0t6ND+5b1iPu49YjrLMSDBIMlXTmzIXfn32Y+qQbcjuuuiNE'
    b'+V+JFBfm/XrdeN1ll3fZC9C4INbvjR8DlWBY9ciMTz3RhwTD9KVTzlVPEgzGsb6MY2XfX6ed'
    b'GkK/GlRje+7XV4rG1zU+6F/WI+7j1iOUYKAEgwQD3ZD7blwgl/7R7pEJdNnvvNv+lUnPhWh+'
    b'u7MRYPwYKK/ddOPKV/chsbD54cMO/4PW69+xfu2Th6sHG6HGsUFIMMxcG6L/9Vj2O+r1q5d/'
    b'o058p3bZ7dD44L5lPeI+bj3CZiUYTg/ButqYBMPVC+fNPlR9spiTfjNEiTfkU0NU5/rj+ZS9'
    b'EJrwRyHGns/Jz4Tow1cmzQpRXrnPeEeIEt/h9o0QrQXwLSH0e+NHw53/wh0/vrgPCYajf7b0'
    b'b+5X/lUb/+LrKf/BGMfKnj9UZVyOn8zUr/rrgr1D9CHBYHxw37IecR+3HmGNHZtgOCUE62pj'
    b'EgxXLrx79ofVJ4s56W0hSrwhTw7R/+tedVOI0Yle6QvyjHJ4YnmI8hfK278yaaRcel3+C/YK'
    b'0YdPjOwZQr83fjTb5LUrN9/xQImJhacXHveZj7Ve/6LNJ645TvnnGcch455xrBfXU5X5TFnO'
    b'fDaE+UTVLHt+bXxw37IecR+3HmGdlWCQYJBgoBtyTW/I004M0YfvKh553apN5Ld/ZdLPQpRX'
    b'D/GTHIO2IdKrhFlcKBk/BjzBcOCzB123S4kJht2f+/Df76HcJRjMgwYxwdCv9hXve2W/IaPX'
    b'1z3nxhDlveGjKf3K+OC+ZT1iPaLe2KwEw4nDJwyfyLramATDjIV3zj5YfbKYrdvxW0u9IZ8Q'
    b'on/XG1+/7Ank9k8IzFx13aqZxc93wmdD9OErk2bOuW7OzN7Xx8ynZz418+n+1Ue/22OnLnj7'
    b'gj0WvD1JpnwjxEsWZHuEMH4MusmUp/aZNlRCYuHex2/73D+2Xve0odM2fUS5FzX209I2akoe'
    b'F8yD+juOlX0/jeVXVn3FeVS/5ke97lfp9hjv82XNy7plWYmfXrc/85zBuG9Zj1iPWI+w30ow'
    b'SDBIMNDCuiY35LggPeBvQ/ThjyCOTFybnhDp1H7VS9U34J5Y9sTTTywbPb+8DRUTem5NMMxe'
    b'/MX/+aHeJxiGl6256XtTlLeNGvOgKo1jZV9PWdcV74f9TiyUnWAY8x3uI/OlaSdMO37aCdW7'
    b'L5Y9vp380xDGB/ct6xHrEf2UTUswHBOCdbUxCYavLbxt9vvVJ4s56S0hSrwhHxui/OucdmyI'
    b'Pryzb6R8x3v+U64J0YevTHoyRO/rZ+aSEP3fMIgLixm7hWglWK4K0bvrfmJxiNY7E68KMdpO'
    b'J/xhiA4WJiPnbfwYbJPlj9x51Fd6mGC47Im9zlqtnDs19tPSNixKHhfMg/o7jvVrvrD3kyG6'
    b'197i/TceLx6/3/OEXverTttjLJ84b4vnt+DNIXrX3tL11JR6MM8ZzPuW9Yj1iPUI+6UEgwSD'
    b'BAMtrCt+Q46v168JYpywdWsB168FdpxwNq09FjVOsOPGTZw4FzVeV7RX9WhCP+Ceu2nxqoN7'
    b'mFgYemjoE69qvc5NLz79kzcpbxs15kFVHMeqtkEWN6riecXrj8b5Rfp+WbV5QNUTDO2+8SU9'
    b'n8mqn6x6iomMfid+ujXPNs9x37IesR6xHmG1EgxHhWBdbUyC4ZKFt87eX32ymKXfkI8O0fvr'
    b'WjUjRGuBe02IPiw8dw3R/eua+XiI/r0zMZZrr+rtiUdDVO+dinWxV+1u0MaP2jr3hfUPPdLD'
    b'BMPRT9/2tbXKebzGftrUccE8qL/jWLxPuy/Ws1/VJcHSb7d/Qtj44L5lPWI9op+yAUowSDBI'
    b'MNDCuqI35GnHhOjDO/ZGEhq93ojv1wL05CdC9L7+5lwRwgTdhN6Evi3XrTrwzt17kFgY+cql'
    b'4XM2TV2xWDnbqDEPqsM4Fu/X7o8SDE20rH5knjPY9y3rEesR6xH2L8FwWAjW1cYkGC5aeMvs'
    b'd6tPFnPSb4Qo8YZ8ZIjeXU88ft8WPD2+vuiCnUL07zrnXBai99c585EQJuqFJ/S7hDB+DKrJ'
    b'O5897xsn9iDBsOvyXW86RPl2y9hPmzoumAdVYxzr93yoX8Z5Q6/rtVf9quz2WDenHR3C+OC+'
    b'Va7WI9Yj1iPstRIMEgwSDLSwrsgNedUlIfr3lUgnLwrR/An/mK9MGil3E3sTehP6CiQYJj81'
    b'86LXdjGxcN9jd3/28tbxj92ydMPuytdGjXlQHcexOD8ZtPtfr+cNEgwlf/f8H4Qob95pnuO+'
    b'ZT1iPWI9wv4mGD4SgnW1MQmGqQtnzd5XfbKYpd+QDwvR/euYdlSI/m20P3F/iPLrb9WFIVqJ'
    b'lf8dog+JlcdClHe9c6aH8J2omRP6nUMYPwbV5MbF9552TfcSDMNLVp91z2XKtdvGftrUccE8'
    b'qFrjWL/nCb12yt+EyL7+nv0R0x71KwmGVGLhv4cYbcfGB/etKmg9Yj1iPcJuK8EgwSDBQAvr'
    b'Pt+Q4/EGZQKVN9Ht21cmjbx+WdcbEzoW4ib0fEmCYdnCHT/9XBcSDFf9ZMkX/kfruIcO7z50'
    b'hXK1UWMe1IRxbMGOIZqzIVa0XffqDSgSDD3+I84j5dCvxIJ5jvuW9Yj1iPUI+5tgODAE62pj'
    b'EgznLrxh9jvVJ4s56d+HKPGG/JEQ3Tv/CZNC9OEdVSOvW7X6PHlhiD58kuOJEK2F4Lkhyr/u'
    b'mfeHaO47NHMX4iP9eMFrQxg/Bs7jNy1f9UgXP7lw1bpbHt1XufbKGW8IUeJCf+T1lL9xLPjE'
    b'vSH6N38a7zxjzoUh2r/euvSrsttj1eq3auOVeY77lvWI9Yj1CMtQgkGCQYKBFtZ9uiGXPdGt'
    b'y8QiLqTjQq30r0waSXBUZYJftw2UogvwaYeHGK1v48eAe+26Yx95qAsJhuN++qaLd1SeNmrM'
    b'gwZpHIvto1/zhqLzivHe77o9H+hVv4pv1GjqPKaq8xnjg/uW9Yj1iPUIq5VgeF8I1tXGJBjO'
    b'Xnjd7L3UJ4tZ+g354BCdn++CV4fo34Rq2mEhql+vM14fon/lNPP7IapTHrHdxPqb8JkQFf7O'
    b'4ZHzi+c754IQxo/xjh+Ndcmqs79zyjgSC6seOfjIP2sdZ/LG7y9/rfJs2vgcX0/5G8deySfu'
    b'CjF63yk74RBfb8qlIbpfTnFeUtd+Fesnvu7JD4eobmIoXa/xfGM9rDorhPGhLuOD+5b1iPWI'
    b'9Qh7qwSDBIMEA0nW2LjAjRPFuKCJGxxxwhotupA/4Oshxj4/LrDj60Tj69dlwc1qmez27H0z'
    b'7xxHgmH3Z6+duaNyJDnW9P0xfV8r+pUZ0Xh/Td//lHd3EhBxAzCWb9wYTNdDuxtycf6TN6+J'
    b'CYS4kap+SOsRkp0kGPYd3md4X9bVxiQYzlp49ew91SdJkoNgcsxPd774dR0kFuY/uva4t7WO'
    b'8+Etp794g3IkSZIkybKVYJBgkGAgSZL9TTBc+5M3/PGmDv6Y89KVyT9NVH4kSZIkWZ0EwztC'
    b'sK42JsHwxYVXzt5dfZIkOQgmSxce85n/1kaC4drFy/74o63n7z30+Jb7lB9JkiRJ9ksJBgkG'
    b'CQaSJNkfJ2zea80eHXxy4aoXjnnwBuVHkiRJktVLMOwxvPvwHqyrjUkwnLZwxuw3q0+SJBvt'
    b'hetOXXhKGwmGE55cO20/5UaSJEmSVXFsgmHXEKyrjUkwnLLwa7PfpD5Jkmy031t1x11zCyQW'
    b'1j78vSM+33r8xA13/ux+5UaSJEmSVVGCQYJBgoEkSfbFZMef73jDjgUSDLs/c9jV5ykvkiRJ'
    b'kqx+guGNIVhXG5NgOGnhJbPVJ0mSJEmSJElWVgkGCQYJBpIkSZIkSZJkFxIMrw/ButqYBMMJ'
    b'Cy+c/Qb1SZIkSZIkSZJVVYJBgkGCgSRJkiRJkiTZhQTDa0OwrjYmwXDcwqmzd1SfJEmSJEmS'
    b'JFlVJRgkGCQYSJIkSZIkSZLjTzAMbf1hXW1MguGYhefN3kF9kiRJkiRJkmRVlWCQYJBgIEmS'
    b'JEmSJEl2IcGwPgTramMSDEcvPGf2a9UnSZIkSZIkSVZVCQYJBgkGkiRJkiRJkmQXEgwrQrCu'
    b'NibBcMTCKd9O1CdJkiRJkiRJVlUJBgkGCQaSJEmSJEmSZBcSDMtCsK42JsFw+MIzv71ZfZIk'
    b'SZIkSZJkVR2bYFg6tGRoKetqYxIMExae9u2N6pMkSZIkSZIkq6oEgwSDBANJkiRJkiRJsgsJ'
    b'hkdDsK42JsHwkYWnfHut+iRJkiRJkiTJqirBQJIkSZIkSZIku5BgmB+CJEmSJEmSJEkyWwkG'
    b'kiRJkiRJkiTZhQTD90OQJEmSJEmSJElmK8FAkiRJkiRJkiS7kGC4NwRJkiRJkiRJkmS2Egwk'
    b'SZIkSZIkSbILCYa5IUiSJEmSJEmSJLOVYCBJkiRJkiRJkl1IMMwOQZIkSZIkSZIkme3YBMOs'
    b'oZuGZpEkSZIkSZIkSWYrwUCSJEmSJEmSJLuQYJgZgiRJkiRJkiRJMlsJBpIkSZIkSZIk2YUE'
    b'w1VDVw5dRZIkSZIkSZIkma0EA0mSJEmSJEmS7EKC4bIQJEmSJEmSJEmS2UowkCRJkiRJkiTJ'
    b'LiQYLglBkiRJkiRJkiSZrQQDSZIkSZIkSZLsQoLhghAkSZIkSZIkSZLZSjCQJEmSJEmSJMku'
    b'JBjOCUGSJEmSJEmSJJnt2ATDF0OQJEmyU++5NUSSXH5diFGf2CXE4JXH/BNCJMnEn4bIVvtp'
    b'llPXhciu75lHhtCvSJIkyTorwUCSJNnlxMLubw0x1r1/HKI1AZsXQrmk1Y6aZUwkZNV3TBDo'
    b'VyRJkmSTEgynhSBJkmS7Xn5tiPyN9HtuCTE45RKvNzfBoB01yolPhniFBMNIf9GvSJIkyfoq'
    b'wUCSJNklZx4eIn8jdP5xISQYJBgkGIokGPQrkiRJsk4JhhNbcRJJkiTbdeVtrZibJFMOCPGS'
    b'r3BZEKK1oXplK64avHK558ZW3FQgwaAdNcqJT4R4hQRDwf6gX5EkSZIVXgdLMJAkSVKCgVVN'
    b'MJAkSZKsU4LhuBAkSZJkd7xnZogCCQbl1Sgn/iTEKyQYrgihnEiSJMk6K8FAkiTZJZ94TYjR'
    b'jdMsO5643RIiSWZ+OESSTH02xOhGbpbxdWevCzF6nKYmGNLlNOW/hsgun1iOsXx6PgEfOb/4'
    b'erF+8uqx7PPMK7/4+/i4XiUYut2v8o6X1T/Sz+t3PRVt53n1FM0qj9h/jfMkSZIslmCYGIIk'
    b'SZLtes+1IQpspLd53MsvCzH6nfN5x88zHmfKe0PUt1x6VU4H/FmI1gbxmhDdu/6TvxJi/PWX'
    b'Ps/5h4UY/3nG48Tjtns+E94VYvQ4sX1lJhhG6qvs9pN3vFjvK28KMf56q3o9RcdbTyRJkhxM'
    b'JRhIkiQrupE+dVmI7m1Ip617giFuAE9cFKK65TTzkBC9O79opxvY8Xm9SmDVLcEQ+12321Us'
    b'lyVbozr1FOtBgoEkSZLdSTAcEYIkSZLtes+VIQpshOYcZ8n6EMXfGX359BBjPXlaiNZG4o9C'
    b'vMyG9EdC1Kdc0k55T4jiG6oTHwsx6oT/EqL482O5dloOWe84j+cx9akQY+sxnm/R6yt6Pitn'
    b'hmj/nfDpcuz0nfRFy7Pb7afo8XrVjmK77Vb7qUo9kSRJcjCVYCBJkqzYRvrsFSHyEwtxg7jo'
    b'+cXjxo3supVLu8eLG7955RQTOnkbxTFR0265R2ceGGJ0wza+btHnx+flXXfR4xY9XtFyjPWS'
    b'ldCqa4IhJgS6df3x/7fbbvLOMyYU884zjgPdrieSJElKMGxLMBwagiRJku16z2UhCmyE5hzn'
    b'8otDvEKC4U9DDF65RE/+ixD55bPyqhDFj7tkTYj8jddYP2WXY7yevHKM5Z13vMIJlTbLceb+'
    b'IQpsXBcsx263n6LH67Sf5fXf7YmgkfaWd7yJC0N0v713u55IkiQ5mI5NMBwcgiRJku16zyUh'
    b'CmyEduk4J58fojWhuyxE88slmnecqY+H6Px8p/xWiFd4R/9/DtG/8sy7/pnvDtH/csxN1FwY'
    b'ovz2U/R4Rc8v7fz9QxRIBI2cx3jrqdPzjMYERa+OT5IkyWYrwUCSJFmxjfSYMCj6FSbxcXFj'
    b'PG5wNq1cur1xm2XcoO/Whna7G9Px/LMc74Zz0eOMtxwnPhyivgmG8V7/eI9f1nnGRKUEA0mS'
    b'JLuTYHh/CJIkSbbrPReFKLARWvB4sxeHGMcfo/1xiNaG+b4h6l8uRY+z8pIQvT/f+fuFKH7c'
    b'JU+HaH0y4NEQrU9C/KcQnddv5obwBSH6X47xPDo9z171q7KuPzcxMHIeTaknkiRJDqYSDCRJ'
    b'khVNMETjRvYBXwrR+cZz3NBud2O8bgmGss43b4M4GhMK3U4k9DrBMN5yrHuCYbzXX1aCoSr1'
    b'RJIkSQmGbQmGfUOQJEmyXe85L0SBDcFxvs7Md4ZoJQx+M0T7G9B7/zBEK9Gwd4j6lEtZ5Vv0'
    b'deLjso4z9aEQxetjyn8K0drQPSfEaD3H1yl6XvH5/S7HeB6dnmevzres6x9v+6lbPZEkSXIw'
    b'lWAgSZKsWYIhbUwUxA3qoomG+ImIpiUYxps4Kfo6Sx4PMfb58fe5nygZSRCtnBqiexvX3Uow'
    b'ZF2fBEO1EgxVqSeSJElKMGxLMLwzBEmSJNv1nnNCFNi47PF5zN8rRPFPOMTHV71cVp4bIv84'
    b'M/cK0fn5Xn52iM7Pt+jzlzwSov3zy00wjLx+XvvIO87sB0N0Xo4TfxSi8/PsVb8qq5/mJhhG'
    b'ziPr+bF99LqepvxmiPHXE0mSJAdTCQaSJMmGJRja3ZDP2+isWrnkJU5O/tMQnZ/veI8/3gTF'
    b'eDeci24Ix69myjpO3HjutN3lHV+CoVi/61U9RQ/4kxASDCRJkuxWgmHPobcP7UmSJMl2vees'
    b'e6bcc1aBjcuc4yyZv+SBJfNbE7WzVk5Zedb4zyt3o3PkvKteLtGZb5+5x8y3d/+6ih43Pi7r'
    b'OJdPCdG9642e/KUQBRIMI6/frePNf/v8Pea/vfh5Fr3+oufZ7fbT7eP1ut9NeVuI6tdTHK/i'
    b'4yf+MMRoO2u3P3breN0+L5IkSabmWxIMJEmS1dpITx8nboTFje2YgMjbUCu6MdmtREbZG7p5'
    b'77yO7/yOG4vxPNIWLacJbwuRf16zH5h9/+wH8o8XXzer/OOGcdwQLfq3Nbq9cd/tcpRgaC/B'
    b'0G49xXEi3a7icaY+MPX+qQ90v56K1n/e+NXt43X7vEiSJJmXYNgtBEmSJNv1njNDFNi47NJx'
    b'xuvU+0LUp1zSzt8tRP5XyIzXePz4ekXPr1fnNfFfQ7zChvCZIYqf58l/EqL75znhrSHGf57d'
    b'bj+9ao9pcxMMI+fRlHrKa5ftXne3jtft8yJJkuQvKsFAkiQ5YAmGuOG28vQQ9U0w9DrRcMAX'
    b'QrSfWIjO/n6I7p3PzN1DtN5pfV+I7iUYYjvI22gu/I73kdfPu34JhvY2tLtdT1PeEqJ7CSsJ'
    b'BpIkSQmGbQmGXYbeOLQLSZIk2/WeU+855Z5TC2xc5hxn5SkrJ688pfUJg++FGN3o7vgdym8J'
    b'0dqg3jVEfculaLldftrlp15+Wivh8K8h2k8oxOfH43Xr+mM9tFtv8fnp42YdL55/p+fbbvnF'
    b'cps9b/a9s+eNPV7WcYqeZ7fbT1ntMXdDO6Nee9XOs+pp4g9CvEKCoWA9xfElrz0Xvc5uHa/b'
    b'50WSJMnU/HRMguENIUiSJFk1l9wZorUxeVKIfFeeEEK5zd8pRHY5xXKtSj2WfT55Zp1nLFf9'
    b's971NPFfQrxCguGUEO33t/i8mbuEGH//He/xun1eJEmS3KYEA0mSJEkOqN1OMJAkSXLQEwyv'
    b'C0GSJEmSbKorjw2R/9VKs+8IobxIkiSZMa+UYCBJkiTJanvPCSG6d7wp/z5EfoIhJiLUA0mS'
    b'JAslGLZsDZIkSZJkVdz+x5r/OEQrQfDrIZJk5o4hWgmIY0IkyZKbQ4w+b+WRIVqfRLg1RJKc'
    b'/PkQ+YmFeHzlT5IkyVdSgoEkSZIka5Jg6LUTfiPEaGJC+ZMkSbK9BMPGECRJkiTJqtjrxMLE'
    b'e0K0FoiHh1DeJEmSLKYEA0mSJElW3Nm3hEiSqXNDjCYE2k0k7P2DEEly8tafJLnn6BDKlyRJ'
    b'kt1KMKwJQZIkSZKsmz/aGKKVODgixOi/lQ9JkiR7oQQDSZIkSZIkSZLsQoJheQiSJEmSJEmS'
    b'JMlsxyYYntqydMtTJEmSJEmSJEmS2UowkCRJkiRJkiRJCQaSJEmSJEmSJNmPBMPjIUiSJEmS'
    b'JEmSJLMdm2B4KARJkiRJkiRJkmS2EgwkSZIkSZIkSbILCYb7Q5AkSZIkSZIkSWYrwUCSJEmS'
    b'JEmSJCUYSJIkSZIkSZJkPxIM80KQJEmSJEmSJElmK8FAkiRJkiRJkiS7kGC4MwRJkiRJkiRJ'
    b'kmS2YxMMt4UgSZIkSZIkSZLMVoKBJEmSJEmSJEl2IcFw85ZZW24mSZIkSZIkSZLMVoKBJEmS'
    b'JEmSJEl2IcFwQwiSJEmSJEmSJMlsJRhIkiRJkiRJkmQXEgzXhiBJkiRJkiRJksxWgoEkSZIk'
    b'SZIkSXYhwXBFCJIkSZIkSZIkyWwlGEiSJEmSJEmSZBcSDNNDkCRJkiRJkiRJZivBQJIkSZIk'
    b'SZIku5BguDAESZIkSZIkSZJktmMTDOeFIEmSJEmSJEmSzFaCgSRJkiRJkiRJdiHBcPaWs7ac'
    b'TZL19fn3P7//8+9Pklk3z5o16+YkuX2v2/e8fS/lQpIkSZIkSXZTCQayDRctDpEku781xKhn'
    b'PBlC+VTFmFhI11NTru+aG6+54ZobR9td/Lf6J0mSJEmSpAQDWfGN3fTGdXTZrctmL7u1+PHi'
    b'4+Pz48Z40ecfPilE8xMcl665dNWla4onCmK5fvbXPvurn/21JDn/lPMnn39Kc8oj1rcEF0mS'
    b'JEmSJKuVYDg9BMmX8/BPhxjd2D3/xBAvSRDcGKL48eLj233+oodCvGSD+Schmlvu+z8T4iUJ'
    b'hgFvh7G+B6X+SZIkSZIkWU0lGMgCfnfXEKMbujHRkPX7vOPdvnuIsRvn8flxwzgaEwrzbwzR'
    b'emf+r4QYfV48Tvp58XXSr//8PiFanwxYHmJs4iQev2jCI77eNdeGyD9+fHwsv/Txlt0UYmwC'
    b'J/389OumEzDpxxWt5/i66fqJv886716XSzQ+X4KBJEmSJEmS1UownLJl8pZTSL7US5eFGN3Q'
    b'veaqEKP/P70RveiBRfcvemDsceZfFyL7K5ay7PR5s64LMfr6z7/j+b2ef0drY/tTIV6S2Bj5'
    b'9xmLznjsjEUvs7F+fIjs8km/7md/OUT71xePF8+j6PPj4/PKOev8b981RPvlG59XVrlEY71m'
    b'tUeSJEmSJEmyDCUYyFcwbsjnJRDyEhBZpjfS0wmBLNMbzOkN9qKJkqznZV33d3f57hu/u0v+'
    b'RnpMWCybuey6ZTNHHxf/nT5uVnm1myho93nxfPISM1nlvv1vb6Sus9flkj6Pou2GJEmSJEmS'
    b'7G2C4YQQJIO3vzHE2A3i9OO+u1OIl3xl0c9C5B//jIUhXrJRfHWI/OfFx21PFIwcJ+958by2'
    b'JwxGzjvr8Zc+HSL//MZs0OdcR/q4Wec//6oQL5MoyLnOos9Ll2NW/aZNfwKk7HJJn3fRdkOS'
    b'JEmSJEl2UwkGso0EwGf/TYjRDd206Q3lvA38shMM7X4FUNrzjw2Rf9y4wT/e8y87wVC0HNP1'
    b'Vna5SDCQJEmSJEmymgmGY0KQg+2yGSHGvyF/6ZIQ2a9zxoIQL9koviJE/vnFx23fiB45Tt7z'
    b'xvxNgF8KMfr8PK/5Woj8486/IsT4zz8eZ0yiIOc6iz6v03JM11vW83pVLt99fYj22w1JkiRJ'
    b'kiTZTSUYyAIbvYf/fojR32cZEwrpjeXn3xyiegmGuFE93vJqSoIh1nPe8WNiJq/eelUuJEmS'
    b'JEmSZDUTDEeGIAfbwz8Z4iV/bPeSEPnPe36XEEmy/5MhRp9/++tDjH38GT8K0f7rzLosxOjz'
    b'jh8Okf+8848K8ZIN7JHXL3pdWf9/zEb69BDFzz/rPOJxxiRscs4n63npxy26M0Tx8886btbj'
    b'e1Uu8bzj4+O/9V+SJEmSJEmWqQQDWWDDud0N3EsfD5G/UZx+XPrx0fTGdExYpJ8XEw3xeXED'
    b'On196QRITKjEBEc0nQApO8GwbHqIsceP5xufF8ux3QRDNF5vXj2M+ZsUIwmbssslfT6xPPRj'
    b'kiRJkiRJ9jfBcFgIcjC95qIQL9m4/XiI9o8zb2uM3WBedlGI0cc9/4YQrcTAphDZf8th0W0h'
    b'xr7OpY+GyH7erEtCjH1ePN4ZPwyR/7ck4uOyrnfMRvpFIbIfH8+r6PFv3yHEK/zx6SNDjD4+'
    b'vv6YBENOvcXzSidgovH3sZ3E+iu7XOL1Zl0/SZIkSZIkWYYSDGSFjAmIvI3otHGjOz4vb+M7'
    b'y/j8dl+/bOP5pRM23TYmYrISPFUpB/2HJEmSJEmS1UgwfDgESZIkSZIkSZJkthIMJEmSJEmS'
    b'JEmyCwmGA0OQJEmSJEmSJElmK8FAkiRJkiRJkiS7kGB435b9tryPJEmSJEmSJEkyWwkGkiRJ'
    b'kiRJkiTZhQTDPiFIkiRJkiRJkiSzlWAge+iss0IkyRn/N8So5384RJLMPz2EcuJgmu4Xi64M'
    b'4bq0B+VGkubBzfeaKSFGy2XumhDjP+6arT+j5d+t47I7xvqI9R7bgXp0/STZrATDXlv23LIX'
    b'Odie8Z0z/umM7+S76LJFX1t02djnX3rvpXdfem+S7P7WENkuO2nZictOUt4cTNP9Yf7kEK5L'
    b'e1BuJFlnzYPbW2/E8pj1xVlnzvri+I8bj5Mub+2zGqbrJ7YD9ej6SbLOSjCQL+P5B59/0PkH'
    b'Zy+I4kQwa2GUfnx6wZCVmOBgOnfF3OVzVwzexqoEQzHjONPtDQjtoZkbecqFZNXG86bPgzu9'
    b'T/cqwRDP5/jVx688fvXoukb7rFeCoWn12O58RTsmybonGHYPQTI467QQL5kA3h4i/3ljNspO'
    b'CKE8+fKef2CIwWsvTe0n3b6u9DgU/609MLj/ohAvWbArF5LG876uF4rep+O6oun3d3ZnfWm+'
    b'QpKsshIMZBcmgIsuCdF6Z8adIcYurI5/LsTo8+c+HaL468fnxePnPS8ePz4vbmAXfZ143nEi'
    b'GF83XmfWceL/j8cpOmFOPz7vddqtv8M/EGL0umJ5xNdJX3/R64zHSU+Y43HmPR5i7PPXLA0x'
    b'tn1ltZfxLjziecTzTZdH/Hes52XHhSh+/XnHy9pYKLoBkdWu8vpRLN9YnlnnF+ujW+0p3R46'
    b'3ViJ15c+Xnz9ov0mXt81p4bILo/4/4uWR7f7Ybvl1u3rSo+b8bxi/0mPj+22o/R9In2+8fpj'
    b'uWRdf+yf6cRkevyJxuvPGx+yxv90PXWrXaTHpXT9x99njaNZ95H09Wa1v3bPNz0OxeOmx8N0'
    b'+4iPK6t9xOenzzPv+mK5tfu8vHqI1x3PK15HVvtKPz5v3Mg7n7qNE+Ptl7FdpMeBou0v/by8'
    b'+UC358Hp46TrPx6n03adLt90e2j3fj3e+3RWgiFr/lL0+tudj6fbW/p64uvG8izaLrL6Y7of'
    b'Zb1e0fEzvd7JG3eKznfT7Sc+Pm9ek9eO2l1ftrseyLu/5o3zVZmv9Or6xzu/yLtP5a0DSXJw'
    b'Egy7hiAZnHVqiJdMGP4xxNjHxd/nfdfs9gXEyHHzXn/+cSFe5jtrJ4bIft7xz4QYffz2xETq'
    b'cVkLwSz3fyxEa8J3UYji55t3nWM2mkeO02m9Fb2ueD3piWHW68ffx+dtXwiNlHdWO0jXd7pd'
    b'FbXT8kif1/aF78jv09cT/71mSYjR48R2l3583vHmLg3Rfr3H10/XT1Z7jp6/f4ix1xPPLysh'
    b'kr7eXrendvt9nlnllx4P8oyPzyqPfvfDXl1Xul+2e/ys+0PW8fPaZVY5tHu/yTqvrHEoPj7r'
    b'+rPG/6LG8aDd9p01jqTHk1iu10wO0b3xNN0vY32lx7t+t4/0ceLzsl439od2y7vo/bxoP4rn'
    b'WfTxWfeppo0T7fbLeN5F78PRdH/JazfdngfH8y/an4rOB9LnlTf/Knq/7tZ9Omt+Nt71RNH5'
    b'+LxHQmT3g6x6zVuH5I037c6j8/pNp+NO3jiSPp92+3tWeyq6vmx3XdXu+iKr/1RlvtLu9fd6'
    b'ftHtdkCSTVOCgexCgqHXG+bpiVxcCKYfFyf8ea+fNQHL2qBMbxRmLTz7nWCIC9SiC7CsDdCs'
    b'10/XQ7sLu6wFTK8norFcsjYGi25IZG2sZL1uXLi2e91ZG0N5Gwnpdt3uwjHdr3rdnjrduCma'
    b'oMzqt+mNgfjvdsu7X/2wV9eVtTDPOu+sDey8Dc/YL4rWd9b5djreFr1PdNrv233drPLNqo+s'
    b'ja28Dbh4fZ32x6zyzqqfrPts3jg83vaRVc5Zx2133Gz3fp6VwM0qn/j66XrOGleyNobqNk50'
    b'u1+mrz+v3xad33TaDvL63Zh3go+8USBdTllv9MhqB1kbnPH46XGh03bf6X066/yy5uNZG96d'
    b'3h/Sb8jIWl8UHZ/aHU+zxvN232BVNFGYlcjKqq90eWe90Spr3hrLt9cJhqzxI2scK7ou6Pd8'
    b'ZbzX36v5Rd79JN2+svoVSTY/wbBzCJLBWSeFeMkEcE6I/OeNWShMDNG98zj890J0/rjz9wvx'
    b'kgnhbSGyX3/ZkSHyryv+e8xEsKTyKnr90TWPhMh//UXnhXiZDYKR52cdP75+3nV1u710amzf'
    b'2yfmI+UZ//+8B0O8zAR+5HF55ZF33fH4x/8sRPv9Lt2urzkxRPbj5y4Okf06vWpP3a6XLMds'
    b'wIxcb9HyKNp/y+qHvb6u9HnH1xnvuNir+06n4236+LG/tXudvW4XWeNoVvtPn19e/2/XrPKO'
    b'5TPe8+92+yh6n293PtDuuJ53ve0+Pn1/yHp83caJbvfLrHlLur0Wfdx420HWuNjp68d2mtcP'
    b'0vfPvHIt+z6dfl7sj+Ntp0XvD3GcTLfnvP5SlkXb0ZjEY875d9p+8sbHTseR8d7n2x2Xyl4n'
    b'dzpf6fT6ez2/yOvfRdsXSTZNCQayBgmGrA24uDBrd+Hd6UIob4JVtQRD0fpKl0fRxEm7Fp24'
    b'djvBEDfu48I1PaFu93zTG1Jj3jE1MrHO2yAY89HoVD20u9GR9fx2vwJsvO0p3Q/7lWBot11l'
    b'tfP0ONOrfli03Hp1Xb0e7+Prxf6Rvt7MrwzocYKhU8tqF0U34Ho9jnZa3kU3qLrdPtIJ4fT4'
    b'1quEaLvHy0o0j3c8rNs40at+mTcvTG8wd2sjrGj5d2scy9pQ7fT+2a8EQ97zipZX0cfFcSBr'
    b'XhjLtdM3kuTVX7z+ol+N1a15QdEN6W7VT3oe2+sEw3j7cVXmK72+/l7NL7pdHyQpwUBKMHR9'
    b'oyP9joi4MMx6J1vWxqwEQ3cSDPF5Rc16R1Wv2kvWhkVsR/H/R9t9p228nryN/awNo7yN/nbf'
    b'UZs+j3g97dZTr9tT3RIM7Z5/r8utV9fVq/E+b/xI98N0OfQ6wbD9u5Xb7Cf9SjBkPa+uCYZe'
    b'tY+sd2jG8Tj9Ttui7/jsdYIh7/FlJxjKGid61S/T9Zx+B3+6fXTrnetlJxiynifBUKxcY+Ig'
    b'az445ivMOvyES/p6t//NnJH1THq8k2AoN8FQtflK2QmGbs0vJBhISjDEBMPrQ5AMzjo+xEsm'
    b'CH8fIv95YyYiR4YY//nE42yfEB8Qov3zjP9/+4bH7BDZj19zf4j860qf3/aJ4DiP22l9Hf/T'
    b'EPnPi+XY7nXF8x9vvfaqvaSv65rjQhRvF7E8222fsdzz2uOYrzQZOb9FU0K8zEfeHwpR/Pzz'
    b'rrdX7SmdIBlvfXZaL+2W37z7QhTvv/0qt15dV6/G+zi+Fi2PoufR7ng73vrp9v00jk95z0uP'
    b'J1ntv1fjaF55L5sQovPz71X7yHp8fL3z9w3R+XjfrftZu48vOh7WbZzoVb+M85T0+Jq+3u1/'
    b'e6PkeU2n/Sre3/PqYbzzml7fp9t9XtFxv9P7Q9rYb8b8zYI2yzHW55g3oIy0w/G2o3b7e6ft'
    b'J2+91O1xpGg9dnp/TVu1+Uqvr79X84tO7xMkWXclGMgaJRiyNo7T/86bWKevK29hWfTxWRPB'
    b'uGGcd9zxllfWxD7r9bPON+v1O11g5S3Y211wdbrAz2oXWRv66evLW/C322/a3XDZ/sf1Cran'
    b'djdM0o/Lak/tbpR0O8FQNHGS3kBsN/HY6YKo1+XWq+vq1XhfdIMitr/0eN7ugj2vvWf196Lt'
    b'tNMNyHZft9120a8EQ9Z9IOvx6fG9V+0ja2Mv/fyiG7p1SzDUbZzodb9Mbxym20Hexmmv20HR'
    b'+VVWwiTr8f1KMBS9T/c7wVC033frDShFx5121wdj3nGf0S+z2k9WfaWvO29emX581gZ9tzfm'
    b's+ZdeevBqs9Xil5/1eYXEgwkJRhiguE1rXgtOdheM7EVx7QmTr/bipdMnPZ/OERrwnVziNbE'
    b'6HutuG/s88dMRCa04rDund+sY1px7Mt8dHnk/LLOK+3xT4YY+/wzvhVi7P/fvrAYef308eLr'
    b'xuMUPW768eMtr6zjn793K/YZPY/M73jNeP2580OMfXx8vVgusX3E38fXyzrfrHaWLq92yyFe'
    b'b/q4sX3H84y/T9dDup7jv9PlGX8fj5s+Tvx9p/0kXV+xPNLtPP47q/7j9cbzjceN/z/r9bP6'
    b'QXx++vy63Z7jeee9fvp1lh3Sig+PPZ/Y3uLz0u1ve2Lu9Fac2b1+2K1y69V1pcfVvH5btB1n'
    b'jdexXtP3m/R1ZZ1HLIf0cdPlEF+naLtK9+v473jcrPG/3ftr0XaRPq9O62G8xuNltdf0eJ91'
    b'nyh6Px9v+8i7H7T7/KK2Ww/tPj5dvlntsW7jRK/7Zbyeduc9ZbWDeeHne9n9Jn2/Ttdn1ry3'
    b'aHsZr53ep9s9v/Q4tH3DtcPHpftBep6UdV2xvtotp6z6S7frducFWeuhdH/PWp/E8SKv/aTn'
    b'y3njSFY5FR1HitZju/OudLlUdb7S7vVXZX5RtH7T55t3HiRZdcckGDYPhSAH26J/TG/+R0Lk'
    b'Pz/rcZ265t4QLzMBnBWi/ePE52Vd59YJ4O+2JkxHh8g/7ry7Q4w+L2viH493zdEhuldeyw4M'
    b'0ZrQfTNE9uvPvS9E+/WVd31jEjI55bbo1BBjJ+rp8223HOJxj38iRH49xOvKOu92rzvWa2xn'
    b'nfaT+Px0+WS196LtOt2+Y7sZb3tKv+5423O8nqx63L4hNlLfWe0g6/y3b+SMHL9b41Wvy63b'
    b'1xXb+/YF4chx271fpF8n1t/57wzxCn8cfeT6Y7kVPY+scWz7gnXkdfOuO2v8SddXHAfG2z7y'
    b'Xnd7QjRnHCnrvhuPl9V+s64j1l/W+fe6faTH7zHvcB05/17Nn/Lqod3Hp/t70ftr1ceJsvpl'
    b'+j4S73+9nkcX7Y9F5xmxv2TdtzttL2Xfp9s9v/Q4FO30ce22s/GWX6zfrNeL9R4fV3R9kDWu'
    b'ZbWj+PuseVNe/RSd14x3HClaj53Of9P1WbX5SrvXX5X5RdH6Tbejbt+PSbJsJRjIGpqVYOjW'
    b'hko8Tt7Crd2N7ryJfK+M15H1+uMtx1gf8Xnjvc5elVcsh261k25fd6+N5xfPN29BUVY5lv36'
    b'6XrrtByqVm79uq6qned4x+90PXXrPlD1+0S7CYa8jb1Oy61X7SOdYNj+iceK9pO69r+yxs9O'
    b'21d6A7xXG+51uW847/6O/90a9/Pm8Z2+Tl4CqC71HM9vvOubqs1X6j6/GPT7MUkJBpIVMP3O'
    b'iF69A63uGwidbhhVfaOcJFnNBENVTW+UtfuJRzaz/ZaVQCTL/OR5tzb8y/oEDAfLuM50PybZ'
    b'/ATD+hAkq+Cik0K0JrRHhmhNQG4M8TLf8XlnCOUV3f6d+yPlFcsv7ZjvDv0/IZQfSfIXnX9w'
    b'iJdJMFTsPON8IN7n4n1tzHeO7x9CvTbNNXeEGK3/a44M8TJ/G2nk98qNTXBMgmFkvB7vcdPj'
    b'Z+xXyp3dGKdjO43/Vj4k664EA1nDDY3t39X4vRDKKe3h7w1R/G9pxAWECR5Jss4JhrgBlvWd'
    b'0/GNC+p1sDZct79TduSNF8qJEgwSDCRJ9jbBsCIEySq45pYQrYny+0OMGn+vnF7ZRceFGFt+'
    b'0WX7hFBOJMnO7sdVO894X6v6ebK3mu9wkNt7t9ZJ6XWEfkSSZLYSDCRJkiRJkiRJUoKBJEmS'
    b'JEmSJEn2I8GwLARJkiRJkiRJkmS2EgxkD100MUSSnPG3IUZ13STZnnPvCDE6nlxzaIjuH3/W'
    b'oSGSZM1NIZR7VUzfT+J9Rj3+ovP3CzF6/cveEWJwrj9eb7z+WB5VOb/YHuP4lW7Xl14VYvDq'
    b'rWnz31iP6frt9n2L7IXp8SneV5t6Pyx6vb2eh5Y9XyLJ3icYloQg2Q3n7xMiSXZ/a4hRXTfJ'
    b'pnrG/w4xfq85JMTocWcdEmJ0PImPG+/5LjoixNjxKo5j6rUa5tWPetzm/j8KMXr9sd8MyvWf'
    b'v1uI7o8T3fLw3wkxtp1G4//X7+vlsj1CZNdr9NIrQigv1mMeV/f7SNH7YdHr7dU8tOz5Ekn2'
    b'yrEJhkdCkOyG8/cK8TIb7a6bZEPN22Ap6hlfDzF63FkHhsj+/+P1/F1DJMnxC0K0NozeHEJ9'
    b'VrVdxftMU+tx7s0h8q83bewn8frnXRdicNpJvN54/bE8qjovStfrogkh9Pe6mb4/Hf5bIUbH'
    b'nzVXhRg7HnXaz8leGudX2zfcKzKOdtov8+6HRa+31/PQsudLJNltJRhIG+2um2Tlx4W6LOxo'
    b'wdzNhJcNAuMf65dgKHp/0s8pwVCf65VgIEkJBrJrC4f0BCR+9DL+Pv3OiKwFZXyHWlxYxONE'
    b'4++LvvMyvjPq0stCjL5zKr5ep+/k6/Z1571TMx4vWvSdfP+vvfOPtayq7rjUIiK1U0rIlLbE'
    b'WgVCLeWXaC1FtLQxljZ0khpCgBgyIaCEGMpT+kMKZkatFUpnDLVTFIaYCWlgaqnB9GlJSuxQ'
    b'HUVmOoWGzCQgxiGIM/AYZsaZV3p7t+9+732s8xZ773P2uT/e/WT98cl7d5999l577bX3Xuvc'
    b'c3U/e7304l2n+u11nt7VTztu6p/+n/rEaG5/N743yKC89BbTp+q1dtf04GDrs3anv2WXsQ3u'
    b'tOlX5WPzVp979uz5E3sAGvWTzG0lGNQv66ekT41rzB+k2ktpu099Ijv1frF1w9q5yku/tn7d'
    b'N9YP609VnzcvdB+Vi41P6oE5d943nYdWf9YOrb16fkX1Wju37bD9q+vHcvufuk7Y+3tPkjbd'
    b'n6TuJ9Se3H2OHbdUO/Xmb6x+z169fnjzdVj7Q69fdh9b6hsZ9n52nVM/pKeYH2y635BeZW9W'
    b'r3afbPelufPc26969ujtiz2/qXpi+2HrL+x8tuMfWzdK7aeGbY+l/L63fqp86nkxtV/2G17W'
    b'7uy8aHpOaGp/sfvKDr19bup6OKoEQ2k7iu2XlpsfsXpTfbn7BN3HWzdj7UsdFwinM8HwaBAI'
    b'YeDM3wdJf6XH7L1BBtdvf0uQRQvSd4MMGKtP5eY+H6TaPv1/1W8EWRS46f2t9tv7rV0ZZHj9'
    b'7h98zX12vS9IvL4YpQfbz1g9G88LUtWbLad6cl/xErt/ZQPY01vquGw+N0i1nP6vcuqnZ3de'
    b'PR6fWRmkWl/M7jx9TJt+vfnhvpPbsUvVY++7elsQfx7njncppvoFj1bv1u9FX7nU00ddeylt'
    b'93XXodj9YuuGrU/2kqpHbx7Z8VU7U9e7puOTW670PPT64+nXzkNr36ms68e0/qaOT/8d8uuC'
    b'pNtrrn019U9Wj55d2fU/Nm7e+MeYO57WXu289tpt7aGt/aFnpzF7l73l6m/LF4MsEYiPrHPy'
    b'123tN3L9h7XvuvPcjpf0Y/upeWrrkf3E9OzZu22/2qNx8NZlzw833U8N2x5L+/1S62ds3c+1'
    b'e9v+un5Z/iRmf1771A7v3Beb96nrYd39f2zfMmw7St0HLRc/4unP8/+i1avd19jPY+2L7Ysg'
    b'nCaSYIDw0fSNjhco0oJqN3bewqcNly3vHaRSF35vo+MF4G29bfc7FthoGoiz+vA2pqLdINgN'
    b'mzYoqRs776DjbXSGFQC3+tC46X6xjVis/piePTuZVv1au9N1nn68dsfsNzYfvYPopCQYYv32'
    b'AnFev2P2Usrucyl/6QVEchOs1s51na1f9dqDlheA9MbXO3h5643Xz9IJhlLzMHW8vQRZqQRp'
    b'rh+z/ff2JV4iM9W+vPbrPl5Cou0EQ2qAJXX82/J/sUC16rXtK70/9Nbr1MBx3XFNDVCqH7Fx'
    b'bGu/UTfwmDvPU/Wh+S29a3w9v2PtxfPbMT17fsCrr+5+alT22Jbfb/u86CUSbb3eulw3wZCq'
    b'd89fefPOttPT67gnGEa1f1hufsTuZ7z+xPyG9+CjNy6x/TmEJBhCguFbQSCcbq49LsiijVjv'
    b'79x6tp8YZIkAynuD+Net+vUgizY67wxSLVc5EG4I4te7/tYgfr3D6rdtt9e/XKr+yoHw2CD5'
    b'5dSu/oauNy6xdqSOX2WD09ObV+/M3wWJ12vb3d8grQvSXM+ys8oBpHff1PtMm349u4v5g9R6'
    b'Yve3eovpozQ9v5B6vdW7/IhXXvM51Q5i5UrZfVtMtV9bTuuCV+/spiDxcfPG1/rVtudzrFyp'
    b'edi2/ef6r1Q7SF3/YvsH3Sd2/9g+ItW+6voJr52rvxtkUeCr93dbfrGu/6s8OfquIPHrSu8P'
    b'rV6lr1z/m6s39df6fdlNXbsovd9Itbum89zOFzsOdn5rXO3+3s5328+YvZSah3X3U6Oyx7bm'
    b'fVvnxbrrsvWPdc9pnt7t+PYD173+2PG18936K88v1t0XlZ7n47Z/WO5+xPPvsXKyy0qir9fv'
    b'2LyBEJJggLBRoKatA2Xq/XO/Yu0tmG33WxtHu2FNPeDlMrYxtgfW1A1L6kYyNcAyrAB4Wxtg'
    b'u9GsPLnc25B6G7Jp02/TAHusnuxXNRRK7I0qwVA6gJNarqnd103o6b72AJc7vrl+PjVAUWq9'
    b'8xIepcax1Dy0B1KtK7Y/0VefDDnBULf/qQm+UvbVdkBC9/VeQaJ5lhvIbjvBkGoHpfeHXiA4'
    b'l7mJPM0vz+9p/GKJ3rb3G8NKMMQCtl5g1vt/agDYBh7lp+1+230FXuF99qjssS2/39Z5sW69'
    b'9pzUdL/oBZ69QLb3/9xA9rgnGEa1f1hufsRLDNj5nZo4i/kXtWPYD2pBSIIBQhIMQ00waOHU'
    b'9THaJz7a7rc9EHpPpjRl7MkMuzH17l/qQOpdN+kJBqvv2MbYHgCmTb9tJxhS571Yet5NS4Kh'
    b'qd3X7a89aOtzMfVJWxIMZeahDrSV3+QwT2CK9onLSU8weNdNSoLBBlq0H/ISDrEnpMc9wdB0'
    b'f+glmHLXnaYBXc/f2XbFvpFaer8xrARDLMBq2ys9eAFbu1+OJeS8fYf1d23rbVT22JbfH7cE'
    b'g9Vv0wSD942D2DcV7Dcbcr+JMq4JhnHZPywXPxKzM89uYg8Cqb2e/nO/WQjhdCYYHurKNyCc'
    b'bs6sD7JoAf1MkPx6tq/syglLbAgy77/5zK6cXS1XCWR9riu3j2+/1T71p/IO8HODNB+/uc8E'
    b'WeIVAb37V34UrVfe1mPb2f/GReT+q7d25Tv54ye9Na3XtlvjOqz5o37Y9tp2TJt+vXnxzNFB'
    b'ms8vz47HhXX9YVO9p9pBrr3UtftU2oPfxnOCNF83cv289ZveuNW179LzOVau1Dycvasrd6fP'
    b'w1z7r2uPMTuo23/ZX8yuU+2wlF8ovf5p/Gw9df1C037WvX/p/aHVh+btqNcVzcPKqzeN3bW9'
    b'32h7fYrNR93fBmTtdfZz+f9Y/2y52Pin6qOu3kZlj235/bbOi3X3i2tXBEn34zHafYTabe9j'
    b'1yGvHf1vFPU+L70vavt8NS77h+XiRzw99RM2hcZN9mntsum+BcLlRBIMECZs3GMBcG0I7Odt'
    b'JxjsApe6YHobmGH327ZfG41SgVK7kbEBu1hgTf1K3ah5/U4NhHnj7LVjVAmG1EBcrB3Tpl/Z'
    b'deWJ9Igdev2LBVRy57/0oHpKJfyWS4KhlN2n0rZHB9Km9mvXl1ii1Zb3DoTe+HrtiCWi2xrH'
    b'UvMwN2CZeyCtGyBO3T+k+g8vYd80UDPqBEPqfJ7UBEPp/WHuep1ab6n9Rszu2t5vlFqfUue5'
    b'DdjaRIiXkPbsov9KEWfdT01Ma5ztfrt0gmFU9tiW32/rvOitd6X8fW7i1u47pD9vX+HZR2q7'
    b'xjXBMOz9gzcvlosfiT2gU3lzgbOf1n1j/qH0vgVCEgwQLnPqQGM3WP2v4PYWOLH/DtjEJ0dK'
    b'BQi0gHtfsdTGQLT1jrrf3ka27jcnUg8gTZ8Usxsdq9e6T9bE6k3d8LedYLBPuKif+r/0Zdvr'
    b'bVSnTb9ef7WxV312o5/6BJSuUzs1n2z9MX2lPuE5LQmG0nafGyBUvapP46r/1w0A2+v1ufcK'
    b'Ei8AZsfXtsfan2e3w/omStN56K0vuk761/Xeq3dSD8h2fDx9pe4fvG+m2P57+4vUhNS4Jhhs'
    b'f2UPut6bJ7nfdBlVgqH0/tB7cMOux9Kf/rZPkNb9Zq19Utaub6l+qq39Rt31qe489+wj1n/v'
    b'mzmx9d67TvqXXlWPtbvSCYZR2WNbfr/t82Lqepe7n2j6TfnYPil2jov543FNMLS9f8hdNybd'
    b'j6TeJ/ZAjZ2HdjxE67fH5Rt9EI5ngmE2CIQwcNfZQboLzN8GeZXfFNgapLsQ3xpkcP32Y4Ms'
    b'sSGI3Nfeb/NpQZq3s79g9sqNS7+98rN3BGk+jqu/GWTRBujXguTXo3FQvz19bDwzSHcD84kg'
    b'zfWs+qSPmF3o/6njnUuNt/QYs7dUfUybfmP9Ta0/dzy8fq09JsiiA3rv71J2U9cfNtV75aDV'
    b'a0duubbsPma/1n/Z+SC9qH2xcfbWF2+e6D4xf2zH117n2bnuG9NTqXEsPQ+tXXrXeeMZG/+Y'
    b'P2y6f0i1a/mDZ44IUm7/0tQv1PUT1t95lF5idtSW/8u157b3h7nzxtsnll4nrT8c9n6u7vpU'
    b'd57H7Nhrr+5XCfCtCeLfR/XF5o3qkZ/I9Z9t76ea2mNbfr/t86LGT/Zcaj9cSm+x8bDjmnqO'
    b'S9VParnS56u29g+568ak+xHvPrnt0/28fbc3PrF9EYTTRBIMEGZQC5YWai2w49petbPpwXjS'
    b'+h1LMJTaKEsPpfShDUrT8Vou82La9Kt+qn11A9NNx2PS7G9a1oNS9hs7SNe9T2qAROXG9UDW'
    b'dB621b/S/nC5rUPj4n8nhaX2h57dtDW/27rPsObXpLQjd/0bt/kyLHuclHVt0sZvWjlpdjSu'
    b'duglGOqud6XXSwinK8Hwlfn7578CIYSTz+1v3H7M9jdWNxi753cf2j2PfiCE08eZW4IsSjCc'
    b'uvmkzae252/RO4QQQgghHAa1r+1/4+XkIOgFwmGwmmC4NwiEEE4O564P0t1QvCVI9yu+pwSp'
    b'fqVW/0dvEMJp5cxfB1mUYOj5zab1bj8yyBIJBvQOIYQQQggLctcpQQb72PU3BlniFVxrgqAv'
    b'CIdBEgwQwmVD912OvQ0HeoIQkmAgwQAhhBBCCCeX3r6z/1uO64KgJwhJMEAIYYONhrh7fxD0'
    b'AiGE9omv0n5S3ySzfhi9QwghhBDCNt5gYPed+j96gnAcEgxfCgIhhBBCCCGEEEIIIYQQQuiT'
    b'BAOEEEIIIYQQQgghhBBCCEkwQFiCu94UpNOZ+VSQAdHP8ubsZ4MMxnvjW4JMrn3MXRtk0A/b'
    b'3vV/FqTT2b0nCOOPn1qaW24M0umsPSJI9X6aN4wLdod+li/tOsK8H85+ZPOJQQbr+bTrhfUI'
    b'QgghhHBSEgx3BIFwurntUJAlfqwS/Sxrbl4ZZDDeMzcHmVz7WPWrQfwfv9LnjD9+ainOfjKI'
    b'bz/9H1HrlWNcsDv0s3yp9bD/4+C99RL9lOWuE4JU55fm3bTqhfUIQgghhHC8SYIBwikMoCiw'
    b'7AXQh831Hw0yej0vlwSD1z4boFAgg3mPn0oJKK55OUj3SdrVQbrffPlBkMHfjAt2h35IMMBX'
    b'D4ynJgrkb1f/W5CBv8X+WI8ghBBCCCcjwXB7EAinm9v2BVkigDLh/dp1XJBFAfS/DDL6dp37'
    b'H0FGr+fNxweJ62fc7WO52i8c7jjL/vsBxd78QP/YHf5l+og/qMc180EWJRh68wf9YH8QQggh'
    b'hMuJJBggzAigKEBvD4yrfiXI4MAz98Eg8ftsuS5I9eCkgLvuo/s27Y+ehLP30f3F2U8Eqdaj'
    b'fm08IUi1PulBn3t62P1kkKoebWBfVH1ewmT9dUH8/uk+sYN9qQSD6tH1al9snKR3Xad2p46z'
    b'Z0+eXq1defpWfzS+XkBR463+2vIan9zAwLDmSS5lx3a8Pb178yqmR/VT1P9LB3ptf2ziT+Pp'
    b'2Ym1X42H5zc9Oyg93m3ZZardqr32vvpb7ZL+vfqkb+uX1G7r/3L7NSq78/ywt76oHXZ9sfPQ'
    b'Wzdi9hbzu3Xb5wVM7Xrp2anKq72l7dSzH2vHqQHeUvsFu95bf2r9i7XbVH9Ryp+rH3Y/YfVq'
    b'12PPPrz1OrYfaurn2vY3ba9HXvs9e/f2h6XXI89e257nEEIIIYQkGCAcowSDPQh4TA1QeAdX'
    b'e/CxCY7c/sTaa2kPiDowe+3yqPI2cOAd3D16B3CrR5swsQfs2EGyVILB+zwWQLT6TU1M1B1n'
    b'qwerRx3QveutfXgBVOnRzp9xmyel/ESsfV4AJneeeeVKfYMnd17a62U/nt+0eig93m3ZZd0n'
    b'bmP31d9eoNXWl+uPx9XuvCe9Y/5cf6v9CsjZdqUG+mN+t2n7Yv46dzybPgmvAHnuel7anmL7'
    b'Bc/fSr+p+7LY/Crlz3P9qDd/Usdb/i9VD6n7i7b8zbDWI+8bD6nzqfR6pPrtONmEU2k9Qggh'
    b'hBCOLsFw2/yt87dBON3ctifIEgeya9dfs/7aavnZG2f/YvbGJQ4aK3a9cdeKQbndO3c/sXvn'
    b'Egeb3v1svZuP3bxi87GLDiJfW/2vq79Wv1+2vpmPz/z5zMfj16nf/YP9LwcZ9Mf2T+2M6c3T'
    b'c2p/5i6Zu3jukm5g6Zogfjn1M9aeVP2ktlt66gdcj9943Mbjq+Vy7aKu/caucwMFPb2oXtsu'
    b'ax+e3jRe9oBtx2/U8ySXar/6F2uf7CJWzuu37mPnWe78idHOG7Uv1b/Y8ZCe1B+Nc1vjXdou'
    b'cyn/b9eB2H21nsTGI2Yftrynp1HbnV0/+4FgZz7Zflm/av2uZ7ee3dnxKt0+z9/G1lVrJ169'
    b'qawk1g6u2b/mYLVf3v7G0+uw9wteuzV/bfnYvC7lz71xTl3XU6+z9u7pQ9eP2t8Maz3y2i/9'
    b'2P2M+tHWepTqlzw79+wRQgghhHBcWE0wfDIIhNPNbT8IssQT6DuC+Net+sUgiw4QRwcZfK6/'
    b'+weRrwbx69P9KoGcmv2y95/50yDx6yoH0o8G8cvr81i7PT2XHs/UfqeWS223rU/2UbdcU/uN'
    b'XWfLb1wRJN8+tlwZxC+//qog4ztPhuVPbDnZWz/Q1tOTV6/03Fa/bXvsOMXsuB8YuShI+nWl'
    b'xru0XbbFVD3bcmvmgjT3w6O2O/Uj1e/Yflk/nWpPqX63dPs8fxuzN2ufqet3qf2N9Bhr77D3'
    b'C7uODFJ/X9b2+loJVPeuz12P7XXqd+44ptpRW/5mWOuRLR9bV9paj7xxiq2L1m5T7QZCCCGE'
    b'cFQkwQBhwQBtLFDjBeByGTtQl04w5B6QUwMBTRMMqk96tgEQ96v0Q0ow6AAZ00Nq4GbYCYa6'
    b'gZBc2sDFqOdJKjW+Cjja+R99JUbDAIpnX169Hr2AadMEQ6p/aWu8S9tlLhWIVz02YOR+Yygx'
    b'wRAbj7qJrVJ2VzdwmEsFtGMBPxt4TfW7pdtX19/WnV+l1gf5iZi+xm2/kGrfpf152wmGuvqw'
    b'duTZZ9v+pu31KLd8W+uRp5fsV5cOKeENIYQQQkiCAcIJTDD03+EcOXBZTmqCodQB2btO/VE/'
    b'RTsuw0oweE8M6gCdGgibtASDAnep9mwDCqOeJ6mJhcqPTvYCyNb+7PiXCvR6+s9NAKU+wTqs'
    b'BEOp8S5tl3X9rF0PrH2kPmE9LgmGVLurm2CQPnLHP7VfuX63rfZNWoLB3r/tBEOp/ULMvtvy'
    b'55OSYCjlF1LbM6z1qFSCoel6FNuvpjL2TSAIIYQQQhIMEC6jVyTFnojM/er1qF4VFDsQxg46'
    b'qa/QqHtAtgf8mB5H9Yokr7wNXDQNGI1bgiH2KprSrygYNr1XQXivPKgb6I0FuL1XL3j39+gl'
    b'YkaVYCg13qXtMpU2YRAbx7qvSGorwVDK7uomGOomdmLzVHZl7S32TZW22jduCYbYK1vsq6JS'
    b'Ewyj3i/E5k1b/nxUCYbYPtV+E6VUQD9VL8Naj0olGJquR3XnG4QQQgjh5CcYbpq/cf4mCKeb'
    b'27637clt31viK8pHbn7t5iPTy2/5YJBBuV1H7Hx51xFLHBx718faNXfh3PvnLqzfL7W/f3D6'
    b'lyDx69Y8v2bPmucXHUg/NjMz8zG/vD6Plff0FuunrX/9lUF8fdmAn9ceq5/cdsf0aNth/569'
    b'fvYjs9e3Z7+x6+raZa59xOx51PMkdx71392eqB9vPDYes/HojccsenLy34P4/bHtSB3nVNp5'
    b'5vm/3PkzrPEubZeprARYnXnt9dvTc+54pPqBUdudrS92/9Tx0v9Vn7UDb50eVvty7b3u/PLa'
    b'k2p3nh698sPeLzT1Y235c2+cY/aWax+p45I7jm35m2GtR7nl216PUvWe699UT6pdQQghhBC2'
    b'RRIMECYclOzBQIF5e4BJDdwrIF5553fv4KoDg/7uP/GeeCDxqECX1171x95n9yO7v737kaoe'
    b'+q+K6F3nvWNcBzbbHtVry9t6bQLBC3CpnAJmqscLMA07weC1OzdgNW4JBo2vZx8aD9HOm2HN'
    b'ExtI1XW5+vUCEHb+aF5ZvXj99uaZ/lb9ufWOe4KhrfFuyy5zE266v+6jfur/ow74jdru5PdU'
    b'v72/9KX+qj36POanPLvS9aNq36gSDJ4/9PYDuXba1n6hrQRDW/7ce7DAm1d17UOB5dRxtOPh'
    b'7TumNcHQ1noU23/rOt3Xjl/qflLzj/MchBBCCEefYLghCITTzW1PBFkUuL4iSPeAcE0Q/4A5'
    b'8ydBuge2C4LE73PfT8Svzx5It1wSpHn/1B/vfmqXvW7nwSCDfnrXr/7nIAM9xtojvbo/tvpc'
    b'kEF56Vf/965TP3dvCVIdJ288YuWsffQP0pF+qt1eO9uy39T2VQIaieOXax8x/bY1T2y7ZHd1'
    b'9Wztxeuf9KJ5ERsP6X3VLwRZIgHX+7/qteVK2ZHVl+cXcufPsP1iW3YZu58db9tu9VPtj+k5'
    b'dzxy/cCo7U7+MbY+2fbIv+fqYeNRQUbXvlx/W2p+2f5ID14/9Lldp2P2V3q/UHddS503bflz'
    b'lff8WT/R1dA+5Ee8+Wv3U7F507a/aXs9yi0/rPUodZxy7dWzIwghhBDCYZEEA4QFArmxg1oq'
    b'VU/pemMBBt0vNTFS6vpSem2rHW3pu2kgf1LnSal+1p0nlW+MFLaTtuatAlTitPnZtvxiabtM'
    b'bf+k6H1c7E73H1f/Pu7tG/V6Pmnr9HLx55Pqd6ZtPbLzItcuVH5S/Q6EEEIISTBACCFs+MS7'
    b'nmBDP8MJALb1jREIIYQQQgghhBBCEgxKMFwXBEIIYV3u3B+km1CYD9INaF8eZIkfe/xAEPTV'
    b'NufOC9J9QvCxIIO/0Q+EEEIIIYQQQghhM5JggBDCwlQg23un7uxVQdAThBBCCCGEEEIIISTB'
    b'ACGE8FWemOfJeQghhBBCCCGEEEI4HQmGq4JACCGEEEIIIYQQQgghhBD6JMEAIYQQQgghhBBC'
    b'CCGEEEISDBBCCCGEEEIIIYQQQgghHEWC4YogEEIIIYQQQgghhBBCCCGEPkkwQAghhBBCCCGE'
    b'EEIIIYSwQILhkiAQQgghhBBCCCGEEEIIIYQ+STBACCGEEEIIIYQQQgghhJAEA4QQQgghhBBC'
    b'CCGEEEIIR5FgWBUEQgghhBBCCCGEEEIIIYTQJwkGCCGEEEIIIYQQQgghhBCSYIAQQgghhBBC'
    b'CCGEEEII4SgSDBfOv3/+QgghhBBCCCGEEEIIIYQQQp8kGCCEEEIIIYQQQgghhBBCSIIBQggh'
    b'hBBCCCGEEEIIIYSjSDBcEARCCCGEEEIIIYQQQgiXD1/87IY3r/tSp/P878388Ydf1+m8NHv/'
    b'P953zOTf/9DxT3/9qZ2dzr67N11552OdzoFntp798PWMNxwOSTBACCGEEEIIIYQQQphBBYYV'
    b'KI7xhctv3nDDbw8/oJ3L1P6ICpgrwD3u46Z2//DZC373nHcMAvKTfn/Zl+rVfZivkAQDhBBC'
    b'CCGEEEIIIYRjRgWGFdDN5d7Tr/75y/57/PpVtz/i/kcf3DN7HgmGYd9fepddDbtfkATDKxMM'
    b'5wWBEEIIIYQQQgghhBAuxX13bbrizh2Lnhi/oBs4/ulquUMrnn7gqW6gd+66W55Ye001IH/g'
    b'+1tPe/gj49Ov1Pbt//aDz86+q9N5rnPRX/3Oh+N6GBeqff0Af28cp+X+ELZBEgwQQgghhBBC'
    b'CCGEELaQYEgN4B8+Ze+hvUcP6hFTExD2OiUA2kow1NWD2vXCpTd//obf6nT2rLz0OxfdObhe'
    b'fyshowRNrN2qd+9pV//cZf+16Jsivb/tfWMBfo3HSw/cf899Rw36ZRMqql/16LrcBINo9aH2'
    b'xsbBtvPFT29407q74uUOHnr8uh13D/Rj22fHI9Y/axdef3RflbPtwc+QYIAQQgghhBBCCCGE'
    b'kARDjwqc2gC+DajaAK8Cu7HAuq03NTDfNMFgA/b6OzXArgC0F8DX315gWwHz5FdTmQRELMHg'
    b'JRRsP1LtwF5n64/RC8Cn2qMtZ/URY6x/3jd1LNVvm4AYt2/0QBIMEEIIIYQQQgghhBC2nmBQ'
    b'oNQ+ke4FzmNPmNuArBdgtwHdpq8osvdV/eqP/raBafU/9gS6PvfKeYF96cWWt+WU4LD68vQa'
    b'e0WRAt5ewkafpyZ4vASD1Yfab/XsJXDqJhhiepCdxuzRS6B59U7KK8Ng3QTD2UEghBBCCCGE'
    b'EEIIIYRLcd+GTZff+UiNH3d+29U/e9m2biB159ZTHr7Kr78SYP/y/Xffd0T9cqms++PO0sfh'
    b'E/c+3w0vNtbv8++d+aMP/1S1fn0u/VUC+0c9vfmpR/x6pX+v3lJ688bX9mvu2lseW/sqdqDx'
    b'tPXH7FH3iZWT/Xj3lz5j/bP17jn+0q0XfcGvV3aSqjc43iTBACGEEEIIIYQQQghhgwSDTRxY'
    b'vnDxzZ+74R3pAdUX12w4Yd0di55c712vz/dvefD7s2cv8SqhhgF+L3Fg+6PAd+VHnp3Atm23'
    b'+qNAdGoCI5ZgiPXP6jWWYNDn6lfqK41SEwyx+6cmUuomGGLjlZpAqVuv1QcJBhIMEEIIIYQQ'
    b'QgghhBBOXYIhNaBqn6C3iYPYk+NKIOjJ99Qn4Us/ie8lOvq/FTD3+Id2bIh/40Pt1ueiTTyU'
    b'SjDYdngBfhv4VmJBCQrbXhIMJBhIMCxOMJwWBEIIIYQQQgghhBBCuBT33b7pkju/tSigen43'
    b'UPqa+HUql3qdLf/Svfd/8d6Xq0/SH/ifrW9+eHXzflUCyZF69XnsOpswePETG1au25Deb+k7'
    b'dt/DK/c+u+eQX+8LH7h53Q1v9+s9dMTT9zz1n9V69z/04JOzpzfXm+3X3DW37Fh7pV+v7ltJ'
    b'pNS0x7p2G+ufrXfvqVf/zGXfjddr7aKUHcPhkgQDhBBCCCGEEEIIIYQtJhi8gHgs0K6Egn23'
    b'feVd94X6lRooVyDfBuy9QL/9XP2y9R7c8/iVO25f4hVJJhGg+mPlbHmbmElNXCjxELOD3ARD'
    b'/9VWTmLElvcC96NOMHiJEI1n3cQUJMEAIYQQQgghhBBCCOGyTzDkUoFlL3Bt6b373wuol0ow'
    b'5NJLmNhERP+VQ73yepJf/48lAkRdX/kx7V4gXgH03HptOSVyVN7rT90Eg6jPvd+m8L5JMeoE'
    b'Qz/Q3NO77Z/0ZftPgmG5JhhOCgIhhBBCCCGEEEIIIVyK+9Zt+sCdW9ID73uOu/SbF/1DN5B+'
    b'1S3b117RfWJ9xd7v79mXfr8Xb9xw3Lolnuz/8fzTdz/1ULl+5SYUnj9v5g8+9H/dwPfXH3xi'
    b'9lS/3oM/ePzyHbdWA9CLAtGf+p2rB3pVff1EQO//tl7p0dNPP/HR+/yle+7//L2H4vXq/mqX'
    b'N54qZ+9/YPvWEx++vFqv9NV/wr+nF/t/qxe1O9UeVV/dcjG78Pone0ztT2q9cLxJggFCCCGE'
    b'EEIIIYQQwjGmDWCnBobHlQpElw4oK+GgenMTObEEiThpehn1OHt6I8FAggFCCCGEEEIIIYQQ'
    b'QtgSFSC3T9LHnmiHcJT2GiunRELlNxtaTuDAYSUYTgwCIYQQQgghhBBCCCEcJvfdumnVnQ8N'
    b'qFfx9H9b4JSr33DZd9ATHE8+9/JCImzuylseWfvBqj2LKtf/Rs65M7//of9Ff5NKk2A4dOjw'
    b'jiAoBkIIIYQQQgghhBDCYVKB1sqPFvcSC4eP3rtzz3PoCY4nbUIs+hsePXvHrieTyiMor9BL'
    b'MPzoucPnBEFBEEIIIYQQQgghhBAOkweffPziHZ/udA58e+vKhy8e/I1+4CTbseWP9z294alZ'
    b'9DTxCYZeHkF5hV6C4bHHDv1SEBQEIYQQQgghhBBCCCGEEMIqlUdQXqGXYPjylw9eGAQFQQgh'
    b'hBBCCCGEEEIIIYRwiW+q9PIIyiv0Egw337T/qCDdgscHgRBCCCGEEEIIIYQQQgghHFB5BOUV'
    b'egmGd7977ntBUBCEEEIIIYQQQgghhBBCCKuc2xNECYbz39NLMBz1+gW+8Pzhy4OgKAghhBBC'
    b'CCGEEEIIIYQQdjqHrwmixMLcnPIKvQTDa3r8wh0H/jBI98IVQSCEEEIIIYQQQgghhBBCOM08'
    b'cEkQJRi+cIfyCibBcNZZcxcFQWEQQgghhBBCCCGEEEIIIex05i4NogTD2W93Egzi7OyBc4Kg'
    b'OAghhBBCCCGEEEIIIYRwKr+5cGoQJRZmZ20+wUkwnHHGAufnD98TpFvh0UEghBBCCCGEEEII'
    b'IYQQQricqbyA8gQLPP2MxASD+De3vnRxEBQKIYQQQgghhBBCCCGEEE4DlRdQnsDLI0QSDEe/'
    b'YYGPPrr/riAoFkIIIYQQQgghhBBCCCFcjlQeYCEvsO3RV+YJshMM4lvfusAfPnvg00FQNIQQ'
    b'QgghhBBCCCGEEEK4HKi4v/IAr8wL+PmDxASD+M7fXOBL+w7cFKTTOfwTgRBCCCGEEEIIIYQQ'
    b'QgjhJFFxfsX9X5kHiOcNMhMMNtHwo+f2bwrCQEAIIYQQQgghhBBCCCGEk8D99wdRYuFHz+Um'
    b'FhomGMSTTtZvNLz0viDdBt4bhAGCEEIIIYQQQgghhBBCCMeCvbi94viK6y/w5JPr5gkaJhjE'
    b'179+gbfdtsD5+QNvCsLAQQghhBBCCCGEEEIIIYQjeQVSL06vuP0r4/iK69fPDxRKMFiefsYC'
    b'v/rA3PlBuh15W5Bux04KwsBCCCGEEEIIIYQQQgghhEV4ZpBBHH7uwiBKLHz1gVfG7cvlA1pK'
    b'MFieedYCN2xY4J49c88G6X4l4+Ugnc7BU4N0OodeG2SgkMPfCIKBQAghhBBCCCGEEEIIIZwS'
    b'Ki7ei5Mrbq44uuLqirMvxN0lisOfdVbb8f8hJRgsX/e6BZ7/ngXefNMC/2nzAh977JUKOXxo'
    b'gVIUhBBCCCGEEEIIIYQQQricqbi4RHFzxdEVV1ecXXH34cX7/x9XRY9FZcel5wAAAABJRU5E'
    b'rkJggg==')

#----------------------------------------------------------------------
Splash_dark = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAwwAAAGQCAYAAAADROdqAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAP+lSURBVHhe7P177PdpXp+HfXdnZmdn'
    b'T8zGy4KNqY2xwUAqCKQs1E1qG5q6aZsSH0DCqaF2khIUq2oruZXa1I4VVKlqBQpO7SpxorpS'
    b'D7aaOn8kseWqqi1XVeu6h6TG4EMCLHaBPbAnWHZhdvtcv53r2Wte3J/v88yYWdN6L+nmfXq9'
    b'3/f9uT+f32/2YXZm3/Dud7/79lp48cUXv/a55577nmeeeeY/+2j9mkfr7W94wxve+IiXFZ/h'
    b'Ue726U9/+sEWcmD9xKnWebWF3PKpT33qxtlOvep3DmztNFtOs1a/mtM8e+9B3+7Rvs7dPaFx'
    b'tXCVuwLt7vGk+dLeWmlsnVXu9Vkzd0V1wjdDznznn6gOX33nPk3t5EP7sP6stQ7GcG+eOPdk'
    b'n8TOtVdaK519uufOOc3YnHrW/g4C9yinueAsfSA2f+ozB+ZXWw3snNWaF3P3aldY6904q/dP'
    b'jtXflft+wHn2WDPfGfe4mlnIO8+4+3K+J+1VvXROWQ00B+4Jp35yzrf3NKs59bXWwLh0FqjB'
    b'ej7ozJ23ebjSSZ9/Wb0xdK/THrAac7Lf485h+T20z3itEIs1dWVnmIPNgzVRc/JPVFN2hv31'
    b'wfikMW8Othc2dxWf9ND86vWtVcs6fWf2LJ0HG0PnL0/TX1pfv+xM2L57s+qDMTwpx3r0M/Op'
    b'l1566aO/+Iu/+Hcf2b/4C7/wC3/iwx/+8P/rQfQqeFV/YHj0h4QXnn322e9/05ve9B3PP//8'
    b'i5/85Cdvjw7w8AP86BAPB8Pee1j8zclJJ6s3Lld9jeU0r/21V1S3bF811ravs079za3uaebD'
    b'1nYf2L7TvkCeWGsONg9XOll9udIDOXs7wzpcaURte3fOqdd4rdhb1In69p78U4/c64Xtv2Jn'
    b'XPUb10I10Pw9rTXZPrmnsbazoFroTNnZV/OeZr6c8qd+UQ9oqm0NdiZUe+q/8sEYnpRr/3Kq'
    b'Nfdq5si93pNOVi+rk3v6J9WuZkLrnQNXNf2ltaeZCae5pzpczRRnX81p//aCfXCvftrjSbXO'
    b'sw6nvDNqoblyT2dOdkZ92BlX/lWuWC9qnjSjeVh9OfVWu33VQfu1srHc0+HLVU5986Wzy9P0'
    b'raaz2rdzruLTrOavcq3Bxv7h+bnnnrs988wzj+2jPzR86BOf+MT/5tF/hv9vfuhDH/r4y/K7'
    b'PNUfGN75zne+8dEG//oLL7zw+x5t/OyjTdjs4Q8K4sHl3gOAWvtqYXNbK9ujf2K17ZHWoPXq'
    b'W7+aI1sr9u6Me/lSzdbKzqr2Xq1s/WnizpXNXfVL55x6r2a1Z3PQ+qkGp7i6E6feJ82F08zV'
    b'Q+ctW7vaj/hKC/fqOwuaO9XBmWW1xrDznV1rTa40sLqyPe3dOeCsk7ac+u7NPXGa377Nqa+F'
    b'9shJu7r2n3ywp/Xi3PbAPd1aaY91uepbH65iaY+YO9krTno45WBnbe3eHLjKS+tiDuwrnbUz'
    b'm5etg7nG7YHTXNk5ou6kNz71miv39LL7yOaftCf5K82p1nytVN+aeageTrpTXJ2YUweNdw6c'
    b'cmBf6/rlKg/Wdo5sX/VyiuWku5opxvZau+qFK4116Exo/KQavOlNb7o9+s/05H/x537u5/4X'
    b'L7300j/7Mz/zM5/9D/UHnvgHhkd/WPjWt7zlLf/2oz+lvP3R0Ie/owBuKhzGQ619EtW1V1or'
    b'nb177ZzTjM2d9OWernNBTecYN3/KCblFrb5sbue2/jS5ZfVyNav+vV6oTlZvXK76GstpXvtr'
    b'r6hu2b5qrG1fZ536m1vd08yHre0+sH2nfYE8sdYcbB6udLL6cqUHcvZ2hnXY2tJZcJpzmmG8'
    b'Vuwt6kR9e0/+qUfu9cL2X7EzrvqNa6EaaP6e1ppsn9zTWNtZUC10puzsq3lPM19O+VO/qAc0'
    b'1bYGOxOqPfVf+WAMT8q1fznVmns1c+Re70knq5fVyT3909ZOULe22qua/tLa08yE09xTHa5m'
    b'irOv5rR/e8E+uFc/7fGkWudZh1PeGbXQXLmnMyc7oz7sjCv/KlesFzVPmtE8EPMHhze/+c34'
    b'H330n/F/56M/NPzvH4oHzv8lxJd517ve9QPveMc7/sKnPvWpt3/kIx85/mGBjd182UO2r6Cz'
    b'Zs9awHfBnoP4tMc9vb4a/as5rdkD1vTRtA7mZfcg3tzOFWe5qiv973Lac8XW7LEPC+pq1Un9'
    b'nQudB/jkXNaMeQ5z2PYW54C9xVxnbeySjcE5LNi6WIeT3xw4h7z7nnLta27nFftF3x77yXvf'
    b'5sAYmlvaoy3NnfzNudir+5lbv5Y8OKN0FqwGv/Nhe7oHWMde9e4e4M8pSx3gWzOuvcfOKcSs'
    b'zj3tob/nIr46k3l71FanBsyLentc0n7zq+t8uBfbA/juu5Dr76HV2asv6rpgNU+DPdWf5p04'
    b'7XfV033wT+drr/726TeW7YGn8Qt5Fu8Fdq/G5upbX6wDvpra9nU2UMNvfKL5zqx1BjjTfGtw'
    b'ip2lvjmsd1dOWqgvaES/OXpcRc2pVqh1HhA3bwzmXcTWir3ts7c5MNearH51xvpgrAV8F+wc'
    b'8X2pq2b1zqivRh3/aAH/+f6ll156+xd8wRf8hUf/uf9ffSgceOatb33ry+4r+cIv/ML/3dvf'
    b'/vbv/tjHPnbjv4LUjd3UuAcpp7hzxINv3VgfjKE5fOPijNbUbh5O80Gt9avalaZUW82VL0+r'
    b'7Tme9kzL9jQGc2LdXGtLNfrthdZW0xj6F4vS/l3VEot7XO0F5mrVG8POgPrQHtapp7N5VmPs'
    b'FdWBM0+5U170O++k6ztoHuxhURfiU1/1p+e1pl8L9UE9y1nV7JnKxtJZcup1SWN95vRcPQ9Y'
    b'U1fIl9MMNWuvNCxrzZOzLq1D+6qD1cK9vuqsn75DY304zTj52Pbol/Zt/WpObbmqEd/Ty5Wm'
    b'e6vRt967E3zzxsUYu6uz6tfqS3Ot6Z/OB5uX1Z56sT4fNL8aY7GvOm21jTcv1ZT2sTwHdr/3'
    b'nufko5dTHxCLteYWZyz2yim2T7/LvNQvq8W6D/7WoT5UB8Y9L6iprW7rUH+x1vfiPO0Vq3NW'
    b'z7Ia84u51vBdwD9mwN8UeMc73vGe55577ut/7ud+7n/9UAjHPzC8+93v/neef/75/8pHP/rR'
    b'h3+IGRx6dXAxJz0Q1C/mtTunrBZ27umXIJZFnmW+OnPSH9jq2t8efNdJY/4eapft9SM87VNd'
    b'a9UCvstYzDurGuesZn9hSXtrr87T+TvHeLXNGZdqrZvTl/rSPmhc23n6cIpLY895Tw+nXKFe'
    b'TWduXtv61f7WsNX150X0O7f1Uq0+tr3F2ikv+qcZ5vr7Qq76sNUSd+bG7cc/1ZadAc3Vuvqz'
    b'J+qEeM/evpP+yrL22YB56mS1p3o1UE3rtdYaw1VOOgeqdzVfWtPuXkBszjvurNXDaa8n7e+3'
    b'q3a/A2uw88zDyVdvXB/Wvze7cVmd4Lufvs+mTtt9xT7Z+PQse36X2t2HnLYabPXrd21fNa3p'
    b'r0Zf0MmpDvau1vhp9drWjIFca2CtXOXau7P07dVfzcYnzFdbOsffb+ur0zaPbW2tfmke2xlg'
    b'TtSrqxaMd46Q4z/v84eGF1544Ssf/RngGx79oeF/9XL5gV/yB4Z3vetd3/+2t73tu/g7C/5h'
    b'Aa42OGG+dXyWD7g1uap3SX3YX5ygprFrae6k2Ry++5XVwL39PXdZDf7uZdycbB6//acesbdn'
    b'qv40w1/kYJ9zqt+Z7VPX/tOZsdaM9f0BLo319xydAacZnkUrzYO1aja3ev3Sfml/66u1zlzv'
    b'uHusHvYMJ40zrfntGrdnc62Bsf2sndWaOagO1MrWtCfd1vV3736rYK3zxB4x1p7OX1aP3X3M'
    b'tWZsH7RuzbV926+F+qLWPsBvbF3Ml2q2Tnya0T1ErZzqtbA557Kuzm1tcxvLSets/dYLeWv+'
    b'fkOv7798ZPudD/aoWbuQr2bPt31bs0esO6fLXGtqr2gP2APOUGNu2Z7d/0l1aLz5k35/X4J+'
    b'e2R96tA55qB6sH6aszntyQf3Md99YfXSfPuufFBPTh/wXcZq6kt92Fp/p5/6xRp6ft7UYfXt'
    b'M6+vNSfWAL/acspfaTzL+vdAow7rHxre/va3f+Wzzz774qM/NPz5h+IjXvEHhne+853/xBd8'
    b'wRf8a/ydBf72xA7aBxZ1akHfQ2tdzQO+6De3WOtcaXxl3RfMwfqsPWP33P21chV35p7FnL7o'
    b'X+U7B6pfTv2rI3ZdzV76XMupts/ZfcyrqbWu7Q/+PR2YB3OwOtgZUF+u5rigs67mrga7mtbU'
    b'l9bry/a1Bsa13m9n1e4e4l/YBE11xvbrF/Va0Ldve8RaNfiu9j0pBmdBrQuu7uoqbk5Lzbsz'
    b'D+rVmFvUnHz7rjhp7O+ePdu9ePMnnlRnxn5LsPOLtVJ9rRCzwDrLdypqaln2mOuM7gPNY83V'
    b'itrFXL8V97HHnFppvqsY11Zzqu/zuHouNSerTsjXWiduTf9Ea+6lD/Y3XqyrVUOuP/OlPdK+'
    b'5u1tj/bK19on6kpztdUxD8x1T6kvp9zOwu68+tC4/atxjjGc9lvINd859ZerWaff0Yu1tYBv'
    b'7JydVx9Wc1XXX8i1d7XmXv5Dwzc9esb/y8c//vG/9VDz35LEvzr1LW95y4f4B5z5tyE5BBwE'
    b'HrR1OG28Wv3Wi3lob/X3NFi40pdqV2cNNn+KV3/Vv6iz52rWzmhu+5r3Y66GHH9C1pq3D4il'
    b'82D1Jy2oWe2pz3Mum+s8a+vDaVZrp/6rOfisvauTheak8Um3OalGWoer96jOOmytc09Qb6/z'
    b't79xNa1vTYhZfQbz9cvVHNkZ1q7yJ6j37mD1nQfOvLKlua1vTU4zCvXNnXjaOdXp9z7AvDPa'
    b'44ydJbuvqLUXTrOak2ru9Ug1J9oHO6d9xrXS+F7NXtA2175ivay2+yzWTprmVoctm2vcGWAs'
    b'nXnqK9T61w2t7F7Q2Sesrd0aPI3uKrc1OenBvJA//d7XllMNH8x3FliHnQety+q6H+yectIs'
    b'fc/ifK05OP3eXl33BXtl66Bm99u5a63B1qU6fTXNlc6ptSbba6351Rs/+jMB/5sNH/vZn/3Z'
    b'L/jQhz70qcf/b5Nnn332X38kfPyHBYdpyTnEujWwdqK69btk9zGuBjYW9J1xsrsnWJPTfp1j'
    b'7Cz1WqDeuY1PPVczCrXOwMe2x7w6rb8Y9i/81qFzZGeD+/IDuj3E1sVc9wLOYk5rH3Zn1Fbf'
    b'ue2R7kF9Z8HOAe/KPjhZe82BvjO5qyexs7D2W9P3fRqz7GudBdb0nQsbdzbg269fPVQP6qHW'
    b'BZ1hDrZOrO9clzkwpwZbvTotqNHX2sMyZ91c2V6tWD9xby5Q3360rvY7Y+2ye2LNuR+rP6OA'
    b'rjP10XRGcZZsv0u6Z2fuHKC+P1vGztweYudW64LtAfugerWnHjBvL3QWvs+8eeg+5hY19sJp'
    b'nv1bu9d3glp71W/eWmMwB9Vf0TNxV+Y6E3autSsNVHOvtjS3vTtnY6CnffrOxW/f7sG3e09v'
    b'7V5+Z0J7WnMfrP7qOg+r1hwYu3gO56ln+Z6v6ExQb//SnHurPdWcb217qjEv1RrbA8440ecQ'
    b'58HmO1fMmd/e1sjtjI9//OO8l7c9+vPBv0H88HcY+F9wfsc73vGRR39YeJb/KlJpc9nBHkBa'
    b'x17pN9dYzNtT1J9q0Po9beer4wPmpZ16nzQLqq3u1Kum2ntzrmaA5y6nPueZg847ceqXzilq'
    b'Tvs4Y2eZA23rsjPt67z2m29dVgfcJRi3H5xhDPdypbNabx6qaU7u6WU18rRa6+S4E+ypXlqH'
    b'nQnmtPsz516iVlozX43+2taufKycdHLSlc7rnD7b1pbOrVbM2VsfTv2tg7mTBfXttSZP6r/X'
    b'W1YL1Z/ym+s+W2P1d6QaLLRXrO+s0hlymgudpV/d9pzie35zpXP8/cZd1IfOgc7aPe5pwby0'
    b'B+pD55xmnupiTqvfftk5atYHNU+is+71bh1O80/zgLi/L09sj3QmdI45uIqbv8pd0Xmg9ipf'
    b'3Kd+9zz5cK9nUVN/9Y3rN4btF3Pee3P6pfknzdSHk9aaqNEX+/jfaXjLW97y0kc+8pG3P/yG'
    b'ePSnh+9/dOhn+fextqGDYDcy3jycNl69OZdsDBvvfHGm9c7Sb69c5ZfVGK/defU9x3KaAcTt'
    b'h8446eWUA2JrcKWT3UNO+p1rXB/s7Qx8NPwQnWYX653ZvlM/WvfAuqx1lprObL/+Qu6UL9ad'
    b'ddKTP2Henu13ZuEXU/Xa1ao5zQB7dhY0f1Vv7Ky1Pau/TGH7T/HmwFngHpuzp/nFWjX49nZf'
    b'8i7p3vg+W/s6i3torb3FHBb0sS5r7a/VB7XQ3hOdCyd999Hqt98l+upbk87Sf5LWfYzB+NSn'
    b'XuypXk3nNYaNgdjcWtiZy9aI9e11weqx66sp5tu/up2tnuXs1uprq5fq+JkoarFSn5q/v81j'
    b'XeS3/x7qXZsD50p9WN3WS89ZiK/2weqjga2Zdz531JxWrTnj5vFbK6257IP2NyftA/Usfay+'
    b'NL81IAebB/XO0Bbi5vT91rYf7FGL9d7NAb49sH61xVr71z9xbx7wNxEenfMZ/pzw8NP3/PPP'
    b'f8fP//zPPxSLg7D1izHDT4fUAn5rq7NeqpFqtk7sS3Bm6zvLGHs1tz1qatuLPWlYnXPy0fgL'
    b'kZxzu9oHaqovnWGvmo2rswbO0K9Vr2+sHojbZ029qOkPkXp1ndXepT3Fec6Qzt1aZ1k7zeh+'
    b'9myfbG112O2Bfh+dUb84gzvtX2yr7Z7Q2s5Fo05O+26fcXvxm9u50BlQjbVq9NE5fyHnQsPd'
    b'yOrVyale6/nsO+nNYd3fnP1Ylzp7WyvW9UHN5mH7oTMATXtbA+LOOZ2p97va7Xc+Vh/qL8x3'
    b'BrbzxP7uuTprcLW3fc2Juc7V16I59W4PmlqoD813prE5dM4qxNaK8fZU29knu7OJXc2dsA7t'
    b'6Twwpn76Bsj3D93m9NWf6kVtayfdaY57wGmOkGOpXwvWO6N++0FtNVBf/fYaq21NNod29Z2z'
    b'f/1R2x59MG69VL/ahfz2C3lr2nt73rN7huavUAPqsORZV72bN7anc++hTuuczuPPB29605u+'
    b'440vvvjiP/LIedF/K5KCQtwl9e2F/gUQiw5bjbOaU9u5J38t7Bxt89VD56hbH4j7i6d05pUP'
    b'W2MWVt+8d9e97NWKsVpnls7p3P7wdj5LTedbM5bq4RSDM041MI9VW33nnOrmlvbds6DfuxH3'
    b'cnVv92juHujseTXQ43/48gzGzuz5oL7aQv30vO2D+tSusO+kJ4fvKubQ9PeHdB40dq6+sfOu'
    b'Zp36wD455asX4qveE9Z2LjELtFeoxzqjdLY0dr79ru67NWh9fZes3zmyPbL67cXfPme52tsY'
    b'X/s02tWtVh/U1WfZZ21j2Zw+tst+FtTqX0F9Z4GxVNPa9pfujW/cHn3z0rpL3YnTnKsYqscS'
    b'q4PWumTr5V68tZ7jdE7Y/Ol39bIzdg9x/+5x0rTe2eqb3xjUWdOH+jxb450h+I3VL813pns4'
    b'52qeudagc6H9rTUP21eouYr9nSNoW7d/c/Wrc4G19bEs/nzAnxPe+Oyzz/7z/OuTbCwdCDaz'
    b'OlTMX9F5ndMeZ55yoL46fP5DRnukWsA3bl7I7R7Q+ac6+MOsTjZ2j9P+UL266q1vvHYhf0/D'
    b'vCfttRacezXzRPfANt45jfHVXv2CwXbm6ZestRP9D9adv7a4p377zG8O376THqqT6qzL1YzG'
    b'Cz3tayzdB+vMzRmvr63+Hs6TztCiUec8fDXL7tlZpbPK5rXkWVd6UKMPJz05teqkcc/gelrU'
    b'nn5+rDWnba1nAWtFjfrto4dY2xqcctL9OkNbqsXf3trW4Err7xTntd+4+i5n6rdfzdP4xs5Y'
    b'zLVmD+y+Jx3WJY31O0t2/+1ZH5rf83SeMWt/v1sv9p5ojb727hxR5/9zwxnVe649n5ru234W'
    b'sbb416bTDDjNlMad3d8D5JwNasy74KRvHfTbD/Xdo/HqpbF91Tc2pw9X87a3MWys5lQ3b05O'
    b'OaHmkvr36Fx7iDe3FvBd6PUXavw5gT8w/OM4irTbjPUA1oTYWjHXGfrt2TyYa/6kW9q/GnPN'
    b'70yWue2X9mwvmIPOY+1MtdXIxnDSdN+tQ/e0Zs7znTTO6vzSWO1q4NSPT7771i/bJ517mqXW'
    b'X7Lq6lfXfmisppxmNWfeuJA3V/9K5xzwL0Cdfa+/1lld5q3ps2R1oNaasb62fu3OZzUH5mH1'
    b'xKz6Yp85rTmscXXrw/4FH5yh5jTf3An7Tti3e0B9df4/M4zVaE95V/da1OhD9TsX6lMnrlas'
    b'nWjNXuf0XeBbh+oAf/fY/2eA2Fs2rgZr3JyW2s4khubg1Ke2mKuGRV979aE1rDnrmy9qpHVq'
    b'vX//g7Pgd59iDltfu+cA6wvavtOdR91lvLOsnXqLvad8rRqXd2O9NIfv3rC/54G66zQPnLH1'
    b'nWPc/GrWbq4z9KmdZrZf1Loaty7bDydte1rX1qd+stBea4V4c7Iz1ekbS/OtGXsm2fOc4sVZ'
    b'sHqwXp2Wv8vwxmeeeeZLcFpk0G5mHbam3l7R72wgv38R3vntWd+52GobV2esbjFfPTR29nKq'
    b'kevzEbvQ1RZjZ9lTGq8eWm8eOheIza1WXs3+xC7Y2a1B98SvvjUgtt9aZ8H2VX/VWz2oMa9v'
    b'v31iTZ/3Xo1zNtd8Z4h1a8agdnOnOa+Gztg5u1e1YH37QD10zhWdtfuWzl1LH+uUL439D0Bq'
    b'/Rn2P5AXYvfYmdW2jm2fqLe+tL990F7YvcV9wTmrPe1dOgPUv5pel/jzYh7fGKoF/8OhOtnY'
    b'eaU53y2xvdb0jcHZ5jfWr1UD7ZFTDk46tVszdk/QP9XkNAvMu5854s3pl90b7PfOO2Mx55zu'
    b'W725+iddoV46o99hMe5MctXpV4tvT325ipvvH4Tu6U819nQt6q2pL2qw+lCttj9LoOY001mt'
    b'61dvvPvZD513or3bJ2rM9c7BflCjvrXSPavtkntx96vGfHlSHTwHYBt3L1EDvGP+F6Af2Te+'
    b'DQccoAhrzrU1faBeVrP9J72o5aCrg+b00XdGfVDn7JN1QXPGLnOFvFSndnuI7Vkrp97Olp29'
    b'bN3YWV3L7nPSNFe9+dab67yTBvDVdjYYdw6oX1+Ir+rOaV3sM9de/Ob1O1taO+nItQbEq5Hm'
    b'xbqz1neeuvWB2By0v/4V/fk9+bvf4h61Qty+1qS9C/nW/ItFY+vm1rqnts/ofGtAbXuq1xfj'
    b'5k+anXUPtN3L/lrzLuDZuJPWBb+90jx29/HOiaW6/gXcHHSesQvMg7rmdl/7oDOaB+eQ15eN'
    b'YWe5yilXvXPVuIf1zasvxLw/aU/nbB6wO3Nzxic6E4yBXOv4O2t9F9jbmdCena8v5PpddzZ+'
    b'tYU6d1oN1j6sM4u5aq60i3udtNb0a6Hvv3npGbDV6FsnNoddfee0dtXfeGctq1XP0sf6bkDf'
    b'PFQP+C4wj1UrV75Uj3UGy5yYrw6MZfPYzoFTzpn2mVPXWdaNq/EPDM8oEhu92OIALdQ/sXOY'
    b'3T31O8ec2iftQf3U33xnkutc7P7SUGOfqN186WzYufWdg2/c2tarAzXGcqUhL1e+Wn3tqd86'
    b'tFau9gFnmO+8Kx/scxm3hm1+bUEn1NU4Y2dVD8bNdw6sprP0qy/Oav1eT3/uqLOH+7h/Oc1t'
    b'T7G/OvZTL9TV9GcG3583FnktdI45NWIeyPd5O+v0+we6R2m9dOaVxnxxn9bw7e2s9Y2rL5ur'
    b'Xqtfurd1cuZP9Z2zMaz2StNz15fm0O87fBr2WbDMutrfGkv8ZncWtA+/NSBuL3R2/eIs6lez'
    b'rdVXo357+vNmrZru1br7iLnqqjEn1KzbW/2ptnM7E78x2CfWa1k7X6ydsLca5ziLVYw7c2fU'
    b'h/rgDG150r5ijJ73D/aRc87u3Vg9nPKds7nWirr1C30ni9a/1pTOc1/pjP2ZFnvUOgdbvxhv'
    b'HjoLnCP3esHeneE5mj9p1bmgtlqp1nsCLOvRvX/2/2ukEByo7YJTzfzihwr0sCfLGa72El9x'
    b'2sOcfc4s5jYP9l99TNDe2vo9G37XFfaj0ZfO7wsUe9pHru/VXDX1wRjbmcxZLXWWfnvBuhry'
    b'+rDzgH3gpKvtXNjacsqBfdY7Z+kM/NU0t/PgVIedpX+apbb6Zee13/xq4CpG64wTzvVn+aQn'
    b'VmMMpz3UGoN7qJfmtP09U3/3BH33b62QV2Ncu/3VnXKCb19166szJ/hqtr59+HKlrV5O/fqd'
    b'44Jqr/rNA7HrhDV72uvvpubwjf39R+z8nafPYp4zRV+9tKczls5aWmvvaU45nek0a63nBOzG'
    b'sD83aDpbTjmgxz7j0pq/E4i7V3sbS/POV1OtNfC5dpaodfb60DxczYJq8H1WaS919bA1MFdr'
    b'nz6s3rg0Z29n2Avmt7b6xlBf2lu2j+VMtWqMeZ9qRb/WGdU5Y1G7ev3tq0ZOWnLOtN5e64V4'
    b'c3A1y5zxokbw+SarvfLtI/fwFTehsL50QzjV1WD9IcF6OJe/zMEckNNf1IM93Q/MdYb+KQf1'
    b'6W2/Mewcn+/08bav/fhqN29N/4Qa/dI+56y2dWsn7K2GnKuxPqDXB+6o7xr85Q3u4apusb6a'
    b'xvidZQzaombPqO8cZ5rT2m8O9K35nQAx2Ns+ILZWdkY1pxk7G789Yl62b9k9sX7/YH2t9+tC'
    b'rw/NA3aXWmlNqtG3Xl3ZfRfqLurVuodU07o90J7Nt68+GBdjvw+1u0dj/M4E36EL1BlrF/Zm'
    b'7UxjIHc1y98HajqnqzXYvD5nad7aqQe05Psty86A5jqvueqL+Vr6xBn1rdfqCzr7ltVCtb6/'
    b'1Xkf5rWnfU790J7O8XeC+dPdWzv1NgetN98ZJ/8EtVrQd/7OqG9d1ML2tke/dTEn1dpbPRDb'
    b'Y70/H+aJyYva7qffeUDManyF2i775GruQp6FRvBP3/LOaF9rzbm3dWtYa+WUa9w5+M6rD6ee'
    b'Yr99teq14Gx+ZoAavj9/go9WPXQe+c9+IY9oMyjSX7trD0QvPtaa+HGqYfVDdt/G5tRXV9oj'
    b'xGJd9LXt3xkuayyfRWtdv5DfGT63mH+1tM89XLKzW2/vvi/7th+MN79z3Kd7ahfyp3nqW8Nn'
    b'2XPSyGmu+M32O5TO9D0v9rQP3M+asZhrf3usmVvQiDPkapaQM18tWNMXtWV7oRrr1Wl3FpAz'
    b'33p71bRe2q9eiDe3c7oXq99ya8vuu77wHfVnH4tuzwGnvDHWXixrf36l3257sDvPtXmxx5+b'
    b'Uu1a+4hZ+MU8WOs8c+3lDKe8vnGhtjNXq0YdbH1nn2YYWzNXnXQvdd6xtfrO03dmrXXQ51tQ'
    b'4zzjpTX7a9unv7OI7Vl2hjHLd0uu32/ndS5+v391WNA3ls6GrYOzxLi57gXt0ZKrBnbO1qF9'
    b'nWXv9je2zt2cntU7a4+ot9bZnkeIT3uDNRfcmyPqd3+WOq0/K+JzUe9zqIf6YL1zwPikh6s8'
    b'VKN/qq/dmcbUW1vd/qyc+k4zWPRWI48n9nAO0W5jBwg5NrFmf/EQ5F1Qu33uzzJetkfM3+uF'
    b'ago582hY/UXknvb3B659ZfPE6ptTJ52j1px+ezhLf3CqWZ0a89XZB9axvmu1WjGnL+bZ13y1'
    b'0h5oX2P9ja+s/u4n1Kmpk872DEC+euMu89Dza62BPvlqaqV91YP7dF592H5if8kYn3quatqi'
    b'Ruxf7Wme2uaNtdaKOe6gveIziprOci/9tV1wOge0ri+cj9U5J3q+1W2uz3bSuh9g239vHznN'
    b'PGF+9e5p3fN2T6zL+N4+rH63Yq296JzXPaoB61ffyglq1u2v3no1LHV9Bs+1M8Q6OKN09hX+'
    b'fFRLrpBzqSvGtV2n/dWCGnXuY6zWnLF1aE1/+623Blsv6uWkVeMy9h6JzYEWOgNac1Y127v6'
    b'WtifdcF3bqnWujn3M+53Yr4z1WnBOtZlr5z0UB/sFf216rAuIFeNlp/BWnthe8wv1Zf2w8lX'
    b'4wysOVc5ncH+1lZ3VdP3d8Pyyt+Gj0DkhtrldCDoBwrtv5rVX8inmcQ7t5rtQXe1V3nS2dzv'
    b'ao77ABoWMc/TeWrUWzN/NV86x97GJ78Qn/Zozp7muk8x9p0Y19LLsm7sWp25svNPGmcs9lrr'
    b'jOZOvSfQoXeOGPvLBVZ36mF5FuvmrZlTV1pnifNal6sZWJfxCfLOq6Z7nPA8V3PhVDvtYc6Z'
    b'+7tDmu/+arDknasF851XrHVe+817Bnzr6mHzrQn1nbMzakFfLdZ9tPx8SGdal/ZC9xE11Fz2'
    b'tLc5F8/GWeyxH+7NAnVAzTku884FrM/uvOph494V5+08cA7sfnDKOUcr3Qt89+CczmovoKfW'
    b'vcS+qxnNgT7WBeo9u+vV4F72dn7ZPdWZx3aGvjXZnvpa/c6C1cppr1rr1cFpXuesb4zdHjXY'
    b'9sIphn5T5ux3Ld1bu7PbZ1zNyd8ZJ7vak1ULuy90ljVy5v25oebPILazteAcZ5XqnCk74wp1'
    b'7rEztb5LZ5FrL7R3OfVr3Xt5/PVs0RjbTfcAxm7QTevXFnLtc19wZuugxl5R13zrxXmrFz6Y'
    b'U162D7s5Y/216KrtDLEOaq5o786FzTUG4vXbbw1a7yKvvj4fZ39ZSTXgDCEGdazuZ02rX9QB'
    b'/kkjJ2312+8vG8E3VmdPa2KtbF/rJ70zzbe+fjX11zLz3vtSe8LzYDvHuS5juZpZrXpje7Cr'
    b'ETVwqpdqQW1n7zywbs2/8BhzB2qgejVa8uo656TFqneZ89tkgdbeYg2uZoI6NdD62tbAHvAv'
    b'yizye0fg7+HFPrBu75Py0Fptscd1mr0Wqm8ezIN1lnPBnL40D8adCe7f968O9I0XZ6mpltrO'
    b'NbdaoU6u1jzQK2pAqw7IdRbomwdnkvNsxtAeV/fpfFiNVs3OI3aVzqiucX2Wfu8JyNeC/dK4'
    b'MxvrX91TZ4C10hy+Pdvb/WDrQI66c4zFnlPt5Dfn7xOe1X5nYOUUS/P2e3f4an1fzW/vCXRq'
    b'1Vz1ofOvEUBcnAX2EXM2f/+WfgPF3jeeioDAVQ2+uXu9UI09nWdcfS1Yk8bV4e8FbO+y2tVT'
    b'V1MfjOmphb5AUdM9dj9wxglqp7pzrdVuTp09sjOk/fbVSuvG/nAC1vdjn1ZN6azFGduPZZnX'
    b'QvWydXGONEbXPbbmKu3pL5HqnFGc3WXemcBMfbAu+tWcoK6Gnv2O97w9w8lSV2OvueZZ/UVl'
    b'3ueq1notrI/WRdx7r98+aK8+Vh1xMa4Wqy/7swDq9K/y+qd+/Gqk34S16qzB9jrz9E5Y+MZP'
    b'mnOFtc7ye3Mf8F1B99OS85w784RzoTOqr2ZBR/00B+taTj0snw+fuhaufl/W6oN62Z9fcL66'
    b'xl3WgLjnAmLvncVeu9/2rQXqPbe2e7vEGI06cH/znK+afksnnKkv5rTQupzqVzPNY1meTU1r'
    b'+r1fa/qArnNO+zpLv5zen0tOPnM6F9a33jy05nnqg/HW/f5EjTps6/jeT2vqxfml8VXd3MnS'
    b'0/2s7XnMF3Ot0UdsX+csavRhf1bA/Y2FvP0Pu6wIXwFsvZtfbVI6qw9qDznnAPa0f/fdGLw0'
    b'2Rm10Bmgf+orzaF1DtYa8c4x1yX47YfG+q1DZ1HrTNie6tRuTzXtt2d/cUF14rt2DlSn74z9'
    b'6M2D2l3VSM9UC1dnEeouaF391tTvLFDbni5z0ny/Z/dYXxrj70yo5qre3o3bA8RXM9sH+C5j'
    b'Mb9/wSJ32t89u3d1zTujs/HJY6sV885UY9wcqC1owJ7VWNeeoGavPuxe0Fr7XO3Xilrzqz9R'
    b'PVSvRSOrFTSnWYLf3wvOtA98t+Zc+/sEyBvjQ+fCxstVX3naGT2752qvOTBvrvP127c50O++'
    b'gN65WO+Oevdr7AxjqBa/87XVS/NrizoWZ+yZ3MuYJY17JnP3amAeTn2yfavDer6e07s8sXsT'
    b'o8c312/dPJx6Rb+2M3um9ok594bT/t23da21e3vA1jsLqLs2D70zwN+ZV71aatu3M0BdtfhA'
    b'bM475g6tizq1YFytsbn1rdsrxtbtkcb2P7zpNhlv82pObI24OXwuyFks2A/TPHp97Mb2mTt9'
    b'EGVr+5L0se7XVU458CzWe97q7+n0+4MIO8Ne6UwxB+qb08e6wLsxthfMLeTVgP2dg73y/TZK'
    b'61qWd+N+3QN/9za3+dbw7QfjZeuNO4u13yRYU69vTdu+ztUX/eaqcyaosY7deuN7VOcc3ot5'
    b'bM9gHvSfZr/tvWJ1zBbzexY1PQeWuP1ib2tqm+v807zOsLazNwZ1S3P6/n7sz1X3Efydu3p9'
    b'qU+9vWDdfOvNoTvtUXv6ve6SU+zzw9Ve9mhhzwerZakD/H77gO+MLrFujxacb874lHeR6zNf'
    b'oVafBc4HNcZQ337x97E9nVO/Om19NOaMoXnA+l1bK+bdT8g5E037rJE7/R5Tb93c1TzjzZXW'
    b'V+d59p363FBN+6VnA+Mr1J307uXyXNpqQd3OhObBXnL6a62x9KuH1qV12JozfKdAbmdL+8EZ'
    b'YN/GaKpbrKk1V1/bPHD/jcE5nbc4Rx0L1oJzHn6aVnDa4JSTDu4PKPmdXZzZmg+/enNaV9lc'
    b'49WCH/pJ0+f1mcztL5Ount0YzGNdoLZ18XxXbO/SWYCmPdrqmq/1bBs707latWq01rT1RR1s'
    b'vnpita09Df1O+z6di3UecfVSjb5zwLizl9Xb05+DrkLcHmnu1CPbv1qgtqhvzTnmtM4k7h7W'
    b'udf2QTXmsac8dO6y/SddZ8nm6LuapW982qu+9Juy3p/5036szWNZ/Y5PtN9V/cbQ2F6sS8gX'
    b'tc2bE2dJZzYv9le3M5xvTq351nctpx59MPYbFuf1ry9912jJib55V2eKeRc4235Q19gcaM2X'
    b'6gB/zw/V+axqO1e/emm8tYW6S9Z3T/OrvzqLfVqeR786IWcdnHdPu7XV92df6Dt9X8Y9g1i3'
    b'Vm311Uj3kc3Z096dDcb2e6ebB5/xtBfLvN8hub0X/Opd0jlQLXj/7gH10aHXt2/ngrE6+0pz'
    b'nbXztqbfvKxGWw2s7rRfIYfujTgVOGiX6J+Ggvn2QPP1jVnG0B8ec6Ceun2wFtDunM6CfoD2'
    b'qlG/eeLdrxr82s3D9mG3fvK3v3Fz+rVdV1TDnM7XB+Pqu9TWkhd87t48thr7oPOA2FWcoW/d'
    b'ftep/6SH6o2lGv32tg+aL+TbV+uMLsBW5y9jsVcab3614h7WsQv56szV9j2LenL9GQR1xqC/'
    b'FvxdIPjUXUJenRrAcgbr1rZXyKuDWvuqB+PWe+4rPRa9vmzOma7moJa8d76/H9UBvrH7dR/j'
    b'E6d8Z7eu71zfBXmX9D1Ba9AYv88H5Ozvglp92D2oOYfzuMd+h+2zx6VWvXnjzrFXPf7mzXUG'
    b'6JP3nO2vFqz5fYAzOwuI8V2izrq91SzWqmcJeZffwAnzavVlZ4J79ZmBXDWLfZ2P77J+hX3t'
    b'aZ8+7w1f1IE6tdsL9aWa1lZLDOZaxxI3ZyxbF++afHvJd0a/2ersU6tfiPtO7S+dIc4G95fW'
    b'Crnu5Txse9qLb311Qt5ZsHUw5wxZLfEu8+7RnH55xU/Iitt0OnRfuqDbl8Rqv1gDP5Rqt6d6'
    b'aq23l1lq9dVo9ftBmHOOM4oaUFPshc5oHqxhmydXrKk99Xjf1kVNtWB/Z+Eb+y5Ev7MX57jM'
    b'2XPqNVed8F7IOc/Ys7GE/PaDun4DzjTGZzZLPey8xtXoi+/CWmeC+c7bb9CzGAu+C+wzx8ye'
    b'qVpQo6/tmWrVAD772Y/td7fYj85z4tsPxq23z9gaS+qf8Kz2O9czw85XI61DfSBGwzIWc0JN'
    b'vbGcfG3P236eb7W7J1BzCTr7Wff6gHo1OwuqdWZniLUT6vtsaNXXB/X1r2aD2uUqD1vbmP3I'
    b'ufq+YM+s357VFPJqAF/qAzF3xxnsA+cTm6t1thbWP2mgceeDs81f/UwKfvVbp8ZiztI+/NLY'
    b'eVc5fS3UL6dZ+C5Ac3of+tj2WLMOakS/OWAfe52zkG+f+nKKme1zNLfvovO7D9BjneUMaR5a'
    b'g63jn6yoF/uE2s6C5jlD+/B3mXeG1lx1Yq57nTT32LOBM52rb61L9O1pfWe94t+SZLIN9+r4'
    b'5l18QP2IVgvE4AO3bg3Iucrqt5f9mW2veXXm3d+4GDun8wr54l6Alpi1Oud0ZnuvzgU8H3n1'
    b'xPq7T+n83XNrnb/ahfz2gDG258Inbw307bcOzeO7zMHpuamj83s86akXY7Tq18LuD8TkO9N4'
    b'c0JPlzk11UJrQOz3IO099UM15op31hnouvrdqTOG9tUKsasYX33L9ji/7Fl9DqDmmXeGvjGW'
    b'nL6cfM/pzPXRqTUHaqypU4P13bZfTbXQc9jTOjR2Jn0sYme4r3pnylUeyLngVBdq3Wf32LVa'
    b'9e1TU1vs7xwh5xLr2KuZxqf3VQutL9Xh717bR6xme2tFrXOI1fjudw+orpjvOdpvTr/61QI1'
    b'ML91ztg50J72bb2QO+2x72+x5mJO56+Pxt857Sk7h7hUv37j7gPdy59vYy05l+ivpmxOLXSP'
    b'avDJVWsd2+/P5QyWbG1nXtEe6Gxn7Bn6e1D9lc8C4mKteeZCc+pOc3x/ng+qXU5nkM5XRw7/'
    b'VAPzj3ffgcbrd4hYh92o9GFhfzg7B+3q4d78zvKF3KN6qA/s4w+hVvDR+wxSX71a0JJzgc+q'
    b'RVcNy2cy7ixrWuaQP91hz4jvXo3haj9p7F7NNWaWM1zmpHptUatV07mgz6LmMoaeB7YO1laz'
    b'eaDWGTun8da65Emz+l7VdElnls23B9/55tHvEnz37TutVW9OnMV+6k7fCvh9dF4h7xJ9+1oT'
    b'auxZ0LlHZ2h7/z1vn7903lrxDsCasfttD1zN9b6g1lnM7rmgvnvXnuaJOiBvjbw1853Jefb+'
    b'gVznA/r2w86rxv76WxPvBZwj9e13xs4Ra+h8PvtYcNW7deOFvJrupV/rImbZIydfXW3ngNrt'
    b'eZIOeuen/lry/SbWAvPQdS4Yo+08rX7pXOobN4d1hjV9oO7ZSvuBOjrnsfrtrL6oxYoz9J3b'
    b'/ayTY+1dqanfGCuNteS05Kovfbflqh/b/dSZ1zdW2+dbqnWZF87pOyFvD2CNsb5z62LO/tX6'
    b'DbAAS77v15wx6GPtrcYeqa619tY+/DMMV6x4tR2Kf1qCxksGa+T3csCYuvtrAX/rpTnnmmtP'
    b'dfjOlFMOure1Kx1LTh8Qvj8sVzPAPnXmwR7rnWde2yXoNqfvnK1t3SX122u+/fesEJvjHhfm'
    b'tcf55rtfa1J/NSxnNy/eN6yF9uJr9TtrtQs5f5acsetEa+7XHmv1iz0nWz2+NTBWY8346ucf'
    b'HcufGegcUKdvTesMsF4ddHbtCed5/8adp4/dWY23rz+z3gmszthZrZuvBuu8zgV8486B1kpz'
    b'fTewM6xtrjH+zqgtaNlzIe/MWmb0mc2Js8irAd8voLfPBTsLNgZ13UO/s2S1ana2GpY94DPx'
    b'DOZPvSfMq7e3v296Z0Vt/cZA3Fpn+J48twvab24h788QVh/qo8M3Xss50Hieand//ebQup9z'
    b'sOSsOw/sNW9Ne9oDWj/5gO8C6q7FvPrqen9gvXPBvFSzbC/WO78CTVc5zZPmfA8nnTCr8+pz'
    b'RjGPrU5b3Mea53CeM/RPsay/s1s/Yd0zgOd3OVOIH/4rSRa1u4AaGMPWgBwX4CWcNO4j3ddY'
    b'a4151vuQahfnXdXF+VIf7HfW1czWrJsTayx/AFmitjn95sD7cEbr5LsvtN4e1p6x785YjTm5'
    b'6gVqrUPnQPfXdwZ292KRa19zxuaglmWfvrG03nXSCnk1UH85aV2wM1YLxoDfJcbb47061/za'
    b'7guN+25WB/2lrE7N/qL0Z8E61j4X1Bd7xL6dYc0cqPt7xXmyMZjrvQj34F3oqzvR+btX51Jz'
    b'Dpa56vXVn2ZSY7W2UDvVzfV5u5f19uK73+bFurPA2eaqcVZrgs/5sNVaO2FdiH134jyXNG6+'
    b'e/YMxfzOO9E7B89HvP1P2k/sw/ot2d8atK9z9p5ak84FZ26voENjD9YZm5fOxkffHM9HbB/L'
    b'/dXVdhXn+z4KtVrQp6d5Y+fjV+t861ANUNsl+NXCk2LoDFGnfRoNqNtvt6ipZfX9gXnwvfWO'
    b'9n2z7Gm+qIF771PQuo+LPnKeyR7y985A3D6xfuoF60KNXPM9yy7OZY+84gQU3NAG/dpSvXVy'
    b'XsJp053jjMWZzHCZs37VS9591dlvHrR9Gdarw6/dvHp917L9Jw1sHUsvC7/3ytmtqwf10H71'
    b'J+3OaYwtxJxj707bM2Jdzl66B37f96lHrRbUNSenvXtGwDd29X7VgD3WGmu7wPn63h1279Ee'
    b'sKfsTJdzTjE92CehxvfL8jk6w5liXVq3x7jvV656hdi8vnM73zxLbWl80piT1qkV8qe9zBfr'
    b'1fcbxO+9uMrGsLk9C7iPvvS70z/tsTOJnSfNtWa+/Ve+3xpoOws2hmrxT5rN2QP49rW/PdVL'
    b'6zsfnNXVfH3nY13m9e0B8/rSfPV97+bROfd092Ad1Ndvbme4nLE186x+o+DPAjSPb39xjmzd'
    b'uHn32OWcztz89kB9NdB72Xla0W+/vneEz/JnFts8YDcH9ljDumRjIdd528/ijD5vtVdUx2KG'
    b'4J/yzu/7g2q3F4tezAsxNNc5gGX1DkUdyz4h57szhr63Ym73qdW3F9s5OxOci/XuzJedRf3h'
    b'JG3QvxqEX52YrxaNS1YD1LevdE5ftj3O9APygn0RLGe2p6iT9miF+Eor+2HU75KeVS3gq6te'
    b'qHsn1O3V7scmnWlt+9vDHt5vsaf5zmu9ms3b4z2AeZe01xp+6Uzrasw35/vaZyTXOe313lsn'
    b'j+1zgDPXttczsFrHZ6k1rm8MngvI70xoj3PVlWqqO6Gms+XU47cJva9qnYc1fxVDc2IO8Lsv'
    b'oHXGWsE3drb2Ct8n+F2d5vQ85tCoN4buid8YOt8ZwB6eQfDR9Jz9dqCztLuv5z/VrnxAb4/U'
    b'b/3UWwue/TTvNKe9i3o19aF+51ZXS957qqa9Qs0F6lnVa0968D7MS+f4Tbiu3r916Ux8Y33X'
    b'9uGrLearV9dZ+s2XU68zrfke4KQXa0/TB/iNQR20zqzG2O7XPrCubd0Zfd+bE/usn2a2Zg7q'
    b'w1Vdy96exeUduocQ96ynuWjwd0a1pX322iPu2Xcr9mPtbT9++672AGdVz97ktTtb6wJ0XYXZ'
    b'zqleX6xvvzrr4gzmv+KfYbCA1W+9tLYb30OtvZ2xOS1UB8TdF98PVLs90hnVwfZsfWdJNYBO'
    b'rR8Ey3nkCrmdvTONO7s+rGb3IYfGZQ5O880BszpPDbSnebDGLGt7J9L56u1RZ97Yulaa7x73'
    b'cPb6tfrS2fbsfsZYf2moqzUvnYVvjXsyL/7CKMb9RdW9pHsIPst3or/nYXWm9at92rO0p78A'
    b'wXzj05yruSz0+41p9dlXrTnYeGvesXlyLCDHaqy9+ubVWLdWK/isvuedUT01wXcV9Ceds6zh'
    b'G7O2zzoLrKl3HqvntG6shtUZYE7t9p6wV6rfOWrN9xvp+yn2YKmpx/Y9ta++/aDvnK5yyp/m'
    b'QLXqrXM+fFbrxZxaffKnXmzvytXeYl5brbhH843x1+6S9Z8Us0f32Vj0rWGrd4FarBpYa90F'
    b'1Pou7DdezLe+Wmcv5Pddws5itXby4aQt5PfZumRzWGeDvt+pVv2yNXobcwfm9vsl577i77fW'
    b'as27wBzWWNQAec8j7XFG79GcOmKX9D0//IFhmxSANdA2B/heljVsL8caq7599liHasVZYq39'
    b'LnML+dVDY3P7EUjzakG/52yuc7fPJVex78e4e0Fz+GLetTqXOTUnnCEbgzEz+k3B7iXm15eT'
    b'vvucaA9+e8S9yLv6jlcP6u11WdMXtfpA3Lyxy1x5mrxrZ8m+D1CvD8bttwbkmbU5VmfgG6Nn'
    b'OVN9QdszdpaY8z31Zwrr2v1hc/p7lvYIdfdUf+ozp7az1re3fa7SO2ndeb4L49b1d6Zzqj1Z'
    b'UNOfDeh+rRm37jOYU786l7la8vrtkd5T6bzOwL+6O2gfGDcHG3cP2JlwNaO2+2P1vbPTHWrb'
    b'q18LrbO4CzWu0rwzwDuE5tXWNxb3Xq350jrP7Pu2X59a+60BvstYmt+9xbms3Qf0mdNa46vv'
    b'tHvb137R3/21UP2VprnOOp3D3Fr17cN2neYYQ3Pma7mvvbN7c60ZN+dzWivOwNYXZzFDzX77'
    b'+LX6aoq1Qg7Yo7M7b+l5ZP3tbd38WuY+WMWPE48sSyH1LvKtafeBFnrsx+q3Bn4M1qA9jaU1'
    b'UeMcNTu3GGM9hxZ2D2juVN89wHO4oPG9OVvnfPu+VkPs+yXvUoetD2ul/e09QV3aA/bZa42Y'
    b'Z9o6tL96n1/t+oJerb36rUt1WHVCvnSevnnB7zdFvOeX7teZPSOYtx/bPcQ67Gxj91lWD9Xh'
    b's6z1jM5Uf9IA+c7WF3Pm/U76M3CqE2NhNbLvZOvQvPPA52iOeWipeQ7Zu+lM9zCn3xg6T9Sd'
    b'5qgn7v7Na3c2MT3VeF/m7MFe1YBc76uzir0Lefvcy/nk7vVJ9c6AfS8FnX2gX0s/s3bOziJG'
    b'5/6A1Qc1UM3Os6ZWu6iztzOAuvNPbE09yxj67FJd9++yDupZ6qG+emyfefXOqC/61qFzS/vA'
    b'nvY1lt3fZe7qvk51YuB5yath0QPOBzT69mpF/c5QZ13aXx2cZrS3enxjnxG/dWn+ykJ1UB+s'
    b'u7d7mLcm1TQPaKVzeDetSd8j+tV0786D08+07x+tC04xVGvsMhY06tXY9/AUHKgiH5q1hyV3'
    b'ZR0K+ls3z1w/aDX1O2971SxXms172XDVg08eq69Oqrd2T+Mcac/m3Vf2rsDY92Wuyzm+460J'
    b'Pjmxzw+9vqh3jhbqS/cWdM0TdxXr+iz9ardve4w37x1J9c0L+c6Q1aoB/H5/WPX1hbh1IK4P'
    b'xLuWvst7WHdvYv3Nd6Y6cmpBXw2g2d8t29O4veT1tUC+33l71u7sntk+Y2fVx9KDvz9/+C5q'
    b'3hGQ6wytNbXW9BsLcXOdA8ald24/q9rOBO9mNTufmPzpGUB/70t8d0D9pKlfTvt0/84F4lMO'
    b'iPF9bnNaa/gu8G77HLB3vhatc4ytiTXobNhYTnOAPKvzViPWWPsc7QdifW1Z3b17gebsMef9'
    b'ixo47W2dmnXfU/VqnAXm9DtHbWPwZ8CafaAG1kfjd8fijJ0PxmCe5R4sa1J9+/F71lMNC55r'
    b'8+aMtX2/0Lmy70C780v3sbczwdrmxbyzO8cctH/9au0XtdX0/qA9+tag9c0X5sKVHojv7VvQ'
    b'tV77mZ0e0SYHuwm1Nnbj2tUa+0BgDtuPxdwJf2hO0FfrfFdz4odM3lU91F/Ubg/sXoU8dX0h'
    b'5x15Hs7oOdH2DohZvVexX3/3kfqL89tvrgt2zsarta6lht+Pvhba3zyYO+VPdueSd5kzv2cC'
    b'8o1l+0+c9jjRPD7rST1SDb44o/2neeTsa63fp6g1pz3N2BrfMzPJV8M69ZrDmgfj7SGu1nrz'
    b'5vxZI2eexfmqdVZxBtivzpmd0aVGmi+dab1nk+5hXU115Grhag54xpN+c/Z1nlgT9dWac09i'
    b'69U6p71AvrVTHaxZXx2oleo5n3Vs57i6l3SmfSc9vmvZWudDe6oT9/P7FPe1bq7sLOP2kPP3'
    b'Beysvlu0LumsfnvqjbdPzYnq1Git7Twwt+fZfYhPuZ1Nrncj7bencfvMg1pwD6jWM4O9nbHs'
    b'fGNnuw+rs/HV0MMylq2rWW3vmSVqT/n262P9XVi9WLt6J53ZZyXfGjhf2zo+/acakG8/dXPm'
    b'zekbX2mLelAjjdVxH52HfchXrO9gm23Ub14r+F5+NcagHuuSzjvlzV3NWl+I22OdXPcEfXvU'
    b'u6A9+H544GVDdVji5qQfo6jXbw/+foBqa9sDOweI7cfn/Czmm/ed+mxaarJzwZw69zB2rntJ'
    b'Z6mh3v5qOhPUmlPfHqkO1Ow7Ubd7gfmi3mUO0HZ+e9G4R3ubAyw58+b0Qc2pTr7vGHyvpfX2'
    b'ArE+s/RPOWnNeeA+1o1PbB9079P3CeRcsj5r9zanFrvPZo99rUF7nbU+2L9zVgdqxBpng2q3'
    b'F5wpxN23dfvVGEu1+P25Fd+Lc2rt1bbvpGGRr64a8B7Y1xlgn7n2kFNf0KgXNc23D397oH0u'
    b'Y1CPZbXeWmNQz/KuF2eV5ur3Z9S5QI7lOyZfXb8/taXaWtgasXPEnPsb+zPZGe0D487QZ0ln'
    b'yL15oNbnF2ejdZWNwVntA6w5wN/3YO2K1r0z6FzA32e5whnu75z6ak6oKe1zcR4WNXOlOfXY'
    b'nU/sjGraqw9bF+fuLNHfXGN6O6cWmqNPa67asj8f21vIoVdTjB//Q8/SwUKuOusOsa7GPNS3'
    b'5hL89u1sYvAjAXLbo86clyXtaZ+0Zn71rZmDq7w52JnYrlOfFqy3xp3wnL5oaEwdOqd+Z9JD'
    b'7DIH6mo31/dzBTPbd3qn0DlqesZin71g7PmtaZ3hXNDCVS96Vs+xM/RBf2e1R8y1B18L1qs9'
    b'zQJz1FliX6lW1O3ZxbjfWPfCOqOYP2Gvdazz5Wrm2s660gO+zwgb28+i5ixjqQ5aK87AstzL'
    b'GJxj3DwQtw71239vQWPnwyk2hzUHux/w3sxD6108v77YZy9Y7xxRZ63fLPHVN8Tq75fVG4M5'
    b'te0R/a11XvOgf/oGsbsfbAzr95mJXUtrLPc1xi/mwRq2Ouv73Pp91ubFeWr1gRi/GmM1xvpi'
    b'DtRUp3Z7idVL9UUt+JzmnGEdf5ca7k5/Uefd7LsG+5zhKmrtxzoTrMvG0Jy+1ucndl2dw57u'
    b'rV89+d4rEO9s452jD8arZXkn+EBNmmN1f/DdPQ32OMM+YmqsztoYtt7esjptfUGrXv8Vf4eh'
    b'TTwwtg2yQ7UsL4oDn1DHWsz1RZnTOpcYnZeM1qVWmteqOelbW5zhCzEn20PNu/S85sXnLejR'
    b'uIp7aLff/cDe9qjfOYCeWLtaUQPY3QdWA8xT35r3ie+M6liwM4lZvQPz0Dw+yxku0Ba16rX7'
    b'7l3V6atRb97voLTXBT2HONuctjOE3Oax5o2tNbe+z25sTs0Jzu8ce2Rnucj1m1ALzIPqr+4T'
    b'7JON+0zO7h7NE+uL+yxX+eJ8Fn6XOS3gF+tFLXgvWPIuY2jeHOAzu/ubg+bNEZsD78p6Qefd'
    b'g2ft/K0xz5x7schhqWPBHFRnf3117d9ezwDG6tWC/s6G9XuW3hU14t6P+sbFPjWdz6zmoXVr'
    b'rt3XHutgvzWortinvnXP1uf3rtsj9m7upGGmeSyrs4m1nkMdqzrPZ14L7of17prrkvbjs+w1'
    b'rqY4Ry1ou4d0FnXvwGcC6t0fq2/v6rX60HzPgu/7aA3/3t1C9YDes0FrQGyuutPcezln9F4E'
    b'3332PO0/5YW55FjOUO9dATkh1xiMqe1ZrWFPfejUlp7Hvsf/OwwewmYfBPBBraiFDtW3zmqs'
    b'r17ffNkeHgJOWnKeGx/s9xK7ijoWUMev9qoPrBkDvufdO1TfnvYCtT4voKne51UHxOoB3/2l'
    b'9dVvDOawxdha6/g9l6CtnkXMGdXbq3axjj3hTHG+WFejT97ZYKwP6kCdOc9UrVTTPBCzfJ+n'
    b'3ObFvBhj95mr9exirXnP6rvRB3x6PEtngzHWmWjVAzVnmEdrTgtqQX3jRY017c7Ed7ar92bd'
    b'HjFuHr95fefqi5qd7x0UY3Xba3111l1Qv/iehF77+x1e3U99wJets7rf9qjrPM+w+0O/m6f5'
    b'hvStexZ85+N3ATVjeunT18LJOqO0x32J3ad9+I2x7I+WfJ9bjTXRp948sfvbKz4j0GPfzvYO'
    b'1VQL+M45zQP8zpE9k5DvuVn2Yc25zHd2qQa/tj3qilppX/vJ+66ac8neg/r2LNWKOnP7PuG0'
    b'F/faPRpj0WCd53IGfu2TsNe5+sVZmwf1LL8Joc+Z4izYec4Rtbu/Opbzu48x1HZBddB+Vp/H'
    b'XHth50n7m5f2QWdU/zBBcYt+PDbWorEHHQexr8PFHrQsNX58LGMtGuvbs3vYD85DY16/sdRX'
    b'w3Jv6mqcowX11YgaZvU+1Z+0WvfoXHtdwFz9Wvv0rZmHatbaB+3ZmvFiDp0aFrHvUI3PYCzV'
    b'uF9prr53XTrLdyv4/a7oJwZqrJ25PUDOGNta6Wyts9xn+83bs7NPMT3dozSPtmdyVmc23969'
    b'l95J9c7vTHFe+8xB57CIXXLSexYWdc8AanqvzqC2z+W+4Ex9qV96trJ3snPbV9+aWmvGPXuf'
    b'70pv7WRbZ9bOczW2r76sljtYjTSPXy3WZZ55RS1sTTyPc8zxnM50vvN6B2Cfca0LTfvUFM/S'
    b'/Z9GC/qbNy7GJ/2p11yfc59Fjb1AruxcY/vL1k56F3hf0H1OqKuexfPpU2OmM8ztHsT2FWJ7'
    b'xDsD69t3wjmsfhftvTdH7alPfLe9x+r1jQuxOX2ftXfaBVrAd35pfuv6nVPN1rE+JxC3F4i7'
    b'B5DzeajZ0/cJrQH1nd8zbc2ceee5fDdd1QKx+eZka7IaILfP8PBfSXKd4ILdxGUs3by15hdr'
    b'O9dlrEZaN17UWPPF9mOBe3Na6/5ivf347RNnm/dOzYM1bH1oP8vncC9ia4B1vr41/eZZfc9g'
    b'3kVt789aQdc5+FCtmrKz1fhsgk++ufa6j3Wt+xH7g4fvfL8R2F6svn1Ye6yB+7S+qOmzdZZ1'
    b'fBY18+ql+fY1h+1e6oR4c2BvUUfeVTqnWv210rhzO6OQJ8fd6APPSewS6s0Tu5rTl+qMAU2/'
    b'O1Hb+tWZ6gu57tUerXuI8c7znbffPnyWGr8x2OdyBrb9i7nW1Ntr7TQH37wQX33/ntO8NWKf'
    b'q3ms+1VbzIO+P5uF2knb+dWYP9VZ5LXWtdUAtnqtdWgPtqizp3dlDd97N9/3IOs3VusM+71P'
    b'tdZFv7P2XcP2AbF91Uq/7a2hd8HOAnvUMc+aNK6+Wmzng1otNNd86Yx78zoD63unx3fTnNr6'
    b'C3l61VRHjlW/Oahevxpni+8Prb5nR6ftKua6l9befU/W7NFX74LVmwdirTWsz1Gt+PxYcIZs'
    b'7AxnG3e/Wt93Ia7OvR/0/B9RJPiuxm5wss6orvgyWL7oYkz9CvtZV/vhd8FJI53hJRJbWzrz'
    b'6oU37jyfu6v4kZT2ir3UWPrFWOtexD13+5zrXtrVNN4Z+u4n9vWOPQeQ6/IuXMTNSzWgjkVO'
    b'H+qr23eolc52nlTb2VrrG/cZtrbWemkNXw1zpXPVA3mW70EdVNc+9cbY9kFr9cF9vOv27tz2'
    b'A779+trWvVPzQk7sNbd3YL+a5u0BfevuzfJ5sM2rFWL3Aqzvzxx4xq2311ksML/P17i9+C61'
    b'1qE+qAXnsXY/Ne0/3Ql91RBLZ7iY0T3UQHWCj96c/mlGc/gsn8s8EPccUN+Z5FzmnIHts8LW'
    b'Rd85gHW2+I0saqFn2buE1sEzkrcGWHvVtE+Lpueyxzq0x7p91ZFjqWPfvUNi93MWdA4Qm9Oq'
    b'b9/OIN5zQXVAfJqze13R+Wqx5nnO5l3U92yg1np7fB41Wqgvvd/uR7x6Ys6qjuV+V3361Jvf'
    b'nrWufhPNt1/MsbxTV+HMzrBWrTnrJ9sZLPWlZ9h3vJhzD32t70nQsMhb27ne3SvOUdGpkc1o'
    b'8CAOMVZrjNW/ogdAK/Zurhacje2Zr+atD86g33xnsDxnfSDW927E3mpqXdUVtZ1rzhhLXd+Z'
    b'PItacy7pfu01731YE33zasAZLO+JJfU9o/vUF3I7Wy1r89WKdWb3rkAdsffMskfd6tun3hi2'
    b'Xo0057mIq+scfHQ8h1jHoqmvvjk1q2X5PoBYX5xnj/e5OiCnznixXh34fM35HELNXrnaA9S3'
    b'56R3b++i93cP5gp+78nl7Kv9q5E+N3pnNtYv3ddlb3vYjxysVl17QL3ss4K2z7N9QN++2yvs'
    b'71mA2IXGuv7mtCz2xnpOc86zn+UM8N52rvPA3kKud96Zsj29H336urexud57OZ2nZ7GfnHv1'
    b'vN6NcXuFHLFnaE0fe7XsB+dL91MLtauBU53zbd0Y7N/e5uD0fkC94Ltn5+weQp6lf9Je5Vy+'
    b'O5b10vi0B752a+0FatVfYc3vA/yuTjSv3/PRu2fxrNCerr4LZvjuzLXPs9pLrfVa86LWPmcY'
    b'r16qObH1K7+Qq0arvj3W4aR9/K9VPRUdROzF+jEWX4LWeZ2l9SWAc8hrXY1F/VrPtnF7YWex'
    b'1IL9ooa++sarAeZZA/J9ZnXOYVUPp559JuvuD87SNg/G0Dn2uHon0lnO1teWzWPrU5POAc60'
    b'ud4rVl/dvkeWd+QzinlnU6vPLGJX62J+e+FKC32O0hx6n4c8i5xztC51osZ7ZEH7zLP2fgp5'
    b'6s4C7w+cB91PrahjWasGn2f2uXtPWvUbAz772w/Wse4N2t1Lvc9R/faCentbw+9ZYGcKeWvO'
    b'BM+1PWo2FudB39XS/ToD39lQHX5rZfuAZ+geLme6wF5jz67Gva2D8dZq9T3L6U7IsTpn31/j'
    b'7ts+0VfjGQC/MRhbYyb2NFeNq3uxoGc1J8xunVjcj7oac90HiPWx1rX0k+/9tAffvc2Vzu5Z'
    b'tORdwCz3AqxnMC7kybkE3xowY3O7D7gPtgvab866/YDvnZg/9aDRh2rE+imvtc89q3V/2B79'
    b'E+Rbu4qdc3pHnqt7qQHrYux7cUF7seZr12f5zdmvBvDJeXbvD4hlfb8l49aF3L3naI/1zcnm'
    b'+y2fep405+FG9uOTDvZCeolSvxu3F2sN6+yN1YixL8YYe8oZu05Y8/KcY6++2pMFfPXSWK3z'
    b'wdw9y9ozmFMHp5zPpA/E5pwJ5E5n68cP1Ktzrth3sp7P3u6lDtTpL5zJfffM+D0z8WlJ/fZ3'
    b'hufzTNK9tc5wMacx9d4ZOeh8Zyz2i3G19Z1pz/b3/AWNZ7ya7TtgqafePbpX6Rw01dm/y1rn'
    b'GwM5zyS+w+rx7dl+l1Qr5rqkvWJ9+6Q9q8Va73cE3nf7YeOTvjNFnXVi9fqg9Z6JnWPNGSx1'
    b'aFitQX3omQqz+wzda6HmMobu3zM7o30usY+cvqt3ceqjjm1N2+dVg+1Zt+dk0bPMycY7j+U+'
    b'V+xd2Qf2GnsXvit72qfWmtgr1rGewVnm7ekc81iWqGnfYk/3AOd1n9JzbG97zPVdYVk+I7R2'
    b'ovNL856J2DN0bs/leVzWsC5p7DxYjXOYbU+fcc/XffGdrUVvHTrL+aAeOkO/M4Sa8/B932JP'
    b'95HOtVddF1TbvHcEapxDbA56zs6T3gv11sQ8tnpwZtkcvQ9vz5foMDfD3+Fq9MEe5vSBt45t'
    b'vjnjQsw8e4w9b+lsVmNwDmjV+uLU+rzE7WkMnmPzxbmsp4E5naVv/6kG+n1XPpec7m01zOlc'
    b'6TNgd29X91fjvt2//d2/oOm+y+kcapuHzjnN9fuwtv1yej57oDOF+t4zvjF19ifGot19dq5a'
    b'+8Dz+CxAzdVY8N3fPbsfflfPtrPsM9cZQKzGXGNzQG51QE70m9sZznWp3dza+sWaPjiHJe21'
    b'h7U6Mde+sjOk86ppzLst7YfOEGLeM9Z5/T7AvHHz1oC8S6r1fPjkteb6ve2cBU2t2s5j+TNi'
    b'XDpfjT6rPyvU1Pgc2ObtNwfOMrZmLO0HffeH9jhHnTX01kRfS53F+fsMPpd1cp1jniXUq4fW'
    b'9U859d1HHw3Poi8+H6s9oG77rIN97VWnhdad1yX0UD9BzQX2Ee8cILZmj+9EvXlt9ybHImcf'
    b'2Ku2s7AnnNU6sXQWsB+++Wq7lz5g0WOti1pwtjpWId7ziH3msWrFmvuAPbXNrw56BvVgHciz'
    b'T/vEHLb9PReWWMyr314gXp2sXt0r/hmGxSY0LnO7PCyXow60ndEFXihacu11gXp1fcF9Kb1I'
    b'2VmAr9YFV73ktx/Inz6KnUNs3Vr1gG9cH+o7S19tc/sB2V9NqQau9hNz6qoH4q7FeTvHvGzc'
    b'uy7keWbn7L7dR9/8aoG881z2VG+uqG1fZ+G7zAHPgLYz9Z0DWLT2tbbfYnu05FnsD9vfc536'
    b'gZqYcx5U5xx7WtOHzmTW3ke1nQGtAbE176R07/rtg8Z9Pvz276LmIq6ufmNwZmc7xxic6/Js'
    b'1asx3/Or03JH3pM5sGfniTqsd9Kc2Lf9xvT6vsm53L9nXw3LvYxFrTBHvecFrFrrYh5OZ9y6'
    b'vlBXU615sFasO9PYc/sspecT9eTM6ztHjXt1LejAOrE5Ie4M5i/kob3qzWF9JsFvneUee35r'
    b'1Vsr1s2r01+a67zOre8878F+rD51zi9oO1etvjX7pTpj2Fl7r8X81nsmaizi0/sFNcVnpA/f'
    b'c7B2jr3uiRbfRV1rL3F9V2lcPThze7qX1mdpDvR37taxLOcAee+kqLMHOq9285yjfvdwUbev'
    b'PO4zUGgB61DzasyDNR9CqjWGPqwLnfPK9kIvUesMcY/q3KvPZF7swTJDyNHXejG2hmU1J87t'
    b'LGyfVb97nriaIe3FZ+mX0/xqqHPunl3rAs/QPcVn0UdDjNWH5gHfGlirBvBZnhHbs3T/nYfW'
    b'eeqN1bYGxmrUYdnL/Zr3bPYYgzprhbh3Ju5fqJur3xzY2zOI+e1xHgufM4E68/ra09mdZQ7b'
    b'+7Gmra5+tWJOv2xv9yzGvkefwXsh11knnOFegs9iZu+mfvXkgb27l75z2oev3kXN80P3Mr81'
    b'FmihPjhDPbOKep+je9gHzrFfnZjvHmp8fjBH7AI0u58+NPYcPcPWWftM1LeH2L5Cjj1Ynk2q'
    b'x3cfsY51gTN69t1/78r+3qm9pTn01XW+81g+V3UsY+zmYJ9XnfM8K7me2+d2Vn3Ad6/WsPRa'
    b'w+qLOf3FPiyrz9A57gP2uE45e823HzobvKPinM703qQ1fel7bK0asF6/mpNea639sDPIq/eO'
    b'jV3GatGtdq3fDhADsfdkDvCrAeLOFLXmarvn9pzy+K7iHiyf03Orbw0fyHsG68btw8LjL9pB'
    b'0KGsPpR0SGv4rNOh7VkNPhi3t3qXM5kH6PVr3U+r36UWnI1lpueQzmqPOnMLGhazT3OB3s5m'
    b'+ZzQnu6D3/1Z7qcP2NWBOv3qpedw5s4WteRY7InWe8V3AXlr1kENObCmrlo1W++58T2L1O88'
    b'ITaHVYM1J+bUWDPP3u1rL/hu0DgDtH2W0jk+I+wc2DtQI+StqWu/WnL1Pdvmxbo1LHX1LtFX'
    b's7p9Bq25tfbpazsXXz3sjK15z1Df+YCO1RyYZ/VujJlnXpzjXsQnW7rvnsv99F1Cnr1Yna0e'
    b'tM5ZqG9+93CeOmyfsfvvvvZp1QF91emvTqxD6/XR9E6IfU99X9SqEWethc21T8i1R021nIO4'
    b'ufYAcTW1av0OgZz5kxaf1b231zp5NaDvLCwa71MdOAvaD+5RPZDfZ1HnrGVnnGb6HIAldl6t'
    b'GnxjlzlozrgYd4Za56jheb0/UV/rgtbEOjmXWGPJ1TsrvofOPc0Ae9W01+WM4rxaNM7uXFGL'
    b'hn3cC7ov7DMIfhc6/dZP72ZngfuBGulcsM4ir+9Z1bJ3+/Rr6RNj+h5mvuc97/n0Bz/4wZfL'
    b'r8QhCPG9gPKKYfFXd+qF7mEfSz05OPV2n9U1/0N//Mce/Nebn/yB//TL3qvjFx+d8UPPvenR'
    b'mW+3Dz773O1n3/js7aeeee72vjc8c/uZlz71aL10++gnfuH2gY9+9PYzH/7w7aOPLPROfH7o'
    b'vWBbEzX3tObJsfzQeTd95+0Hc61b2+9AnT51cC/pzGJeup9+vyXmGluDxtUCvuz8xby2erGP'
    b'3J6lOvxq9QF/76i4r9YcbAxXuSsN/p4X7NHqG4u+NehdgL19J7VQ7Qn11v1uzUvnatkX7GHp'
    b'l86yd3NATsvszqoejFm7Z3POkua3xxya3vVJZ36tPpiD5k/+vb6eR101cIrtkfrO0XpH7CXO'
    b's27tSfsaO7tzNha17rMa42JPZ8rmOscaq89E/t7+aqB5LTmW/s7CNgZ1ztOeeq3p2ys7W9Cd'
    b'+vVhNdC452lu+4x31onWfQ5yLPcDZ2GXzbfXvBrnFOOd3d4r0LhPZ2O9G5a16owX8nt+sVe/'
    b'9yNXc8GaezgL9M07nxiqBeeYd0974aTBP91Nz9M+8qc71sd6Tmtg7aSXarDWiFvzDFCNvOJ5'
    b'vumbvunT73//+x8PtNAHaTM4VNTba4854p3lDHX61pfq9Z1rf/3O+cwfGM5zfzn5mf/h173s'
    b'vX584oW33t7/pudvf+XN77j99U+94fa3P/zR20/81E89/kPE4n2xvF/uqO9D6/sqxmi01dhv'
    b'3RirL/ZV33Ps/va3z1x9ZwC5Pp85MC7OELXOgO2zp736zbd/6+0trRubw/a+sMtqzOmD97wz'
    b'2mt+Z1zlxbh11tVdQrXFmLo+c/puFnXY07mg81YDW7cXqy/4nEefeu8fe8K8WrC370dfNqd1'
    b'hnX92p6FHHGtEJtrL/7uTV6M1fks1uyDzoH6u9fW5JQnZz/sPnDqw/ouOst5rcspp14fWj9h'
    b'z9Po1WHdu3saX1HtCWt7FuJTr/thexcbg9oruif+6d11bv3VnXqhe9jHUk8OTr3dZ3XNO0e7'
    b'WmvG7L3vUl/w1e2z2VM219niDPOsfWdFPVSDv7MWNfe05smxOAv0frYfzLVu7d5d4VMH95LO'
    b'LOal++m7J3HflzVoXC3gy85fzGurF/vI7Vmqw69WH/Af3sH+HYbHhYh3EBhjuymox3KovozO'
    b'hcY7x1ov0rnL7lnN/z/9geEEf4j4v7/txdtfur3p9h+87wO3H3vvex8/v7Z3x8KXUx7Lvff9'
    b'kTtpgRjMbV3/6ttide5awPZMxObUUhPnLc7r7KVzr3DPK6ypq965zakxZwzYnkdrr9gr+P15'
    b'6Ex97fY21l8ttu/kai9ofMrTX3yXV/PAHKs68EzivNM9NrfsHs431j9B3TtB4x1p7beuhZ2/'
    b'56bG8rnEGerVWoPT3lLNnnNnta90hrr2Oftef3v0a1k9H6tnhVOPefXQs6iVnYGV1e1ZmAvV'
    b'gbOcx5LOsG7/6jw3+d0bqhf1gO3s1pwH2MZiz0LOZ4dT75Nwdve+t9+9+dbVEDvn3rsX8pyh'
    b'75O1M+WUUy/VsDqbmvtZJ7f5zgNyRb29nW28s5yhTt/6Ur2+c+2vf5pjrufYczsT3Gdruwd5'
    b'Z+yzOAOsOx+6x6nX2WJeNl52DsszmNOSxxZj91Ar9ls3xuqLfdX3HO7/mVt4hEJF0CGij6Xu'
    b'BW8PqJHTHOrOUdvZ5jwwq71qtdC+fxB4/uM/e/vm9/2d23/nff/x7d984aXb//w/+eW3//LX'
    b'f93ti7/oix7uzfsq5Mzfe4dbI8ZnLqi92kd8J6vpXHAuVEtvz2XNmdZOOrXYnnOfQYh9Tlfn'
    b'29+cdnXugTXnPKzPLZ3hPuB5hNhce7SAf9oDyPcunGH/1Vz14mzqfcZaOfVSZ/ksi3Ww3rk+'
    b'QzUs772xs8wB+7o3S02pdvuxvUdr6sA+rPFqtJ4b1IO+Z8Pa72ytOLPanpXcCerO9TxqnbM1'
    b'Zxbq9nk+QEvcswD1asT9tILvHub17W8v4PeO4N5ZyHVWIe5s8Dm35rzFs7i/fbI96MC5ja/2'
    b'O83cGste7PYQe9btv4Ka52sP3OsDtGqwux92Zxh3n8XzwEl3mgvkeiZ8l++udB97d0HvB13n'
    b'cN/m7EGvteZyFr6czgHOMwa01eNT7zcKzu+eoJ48PcbNdT8wpt7VvVjgfTgXrLkH1n1cUN0J'
    b'e5ntHqWzwNg+1p6re5rfOrHPZVxbzLuaAy2Qt7959hLrWp9Zzd4BPPwvPQMiDw7dRMix0Gif'
    b'pFejTpwFW7fPl8fyIfDbuzPsOT3sPwjwh4cv/9D7b//d9//o7X/54rO3P/SPfu3tK37Db3i4'
    b'E9Byb73TWu6OmndZ2s8i1mcBueqgOVjfpR7wW2P1vVa777v7gnW/c+vu0b2EnAuseW+L/c5a'
    b'PIN157qHPdurrqC50i/Wu0fvYEHjM+J7PmM45YRe+3hmddB57fNudpYzwFpzPSfL2D1E33zr'
    b'zvXc0DrguydYR7+6zsGelqDtLCH27lqrRn/rxKCVxu2B1cJpPhg3v5qyNXyWzy7mT/OtcSfN'
    b'+b6ty86VzvR+ibEu98D6LjvD2OVzGJdTzj3EGdW1z3NKde671hp4R2Cums7D335YPQvftT21'
    b'1k495qBa78dY7AH7nNF4+6R3Ad1T2/fpTDhpQb3Ypwa/71s25wx72w/oPf+ekWXNWN88ONe6'
    b'qGvePs8B+s3RY1/r3dd6dS5wRnUbe1/49ok6sIbdGdrO0nYmZ7e/c/BdYuwsqBZqTzn3Y9kr'
    b'+mj6zZivVjxLbedimUfOvcvq8eHR/p89gD6iCtuIbVwcCs5QW1uIOTDsZbS289Bii7PVuf5B'
    b'hT88/FM/9aO3P/HcJ27/8jf8w7ff+Ot//eOPo3fnPXnX+N4hqFXn6gzwnbSvsfOls4xle/F7'
    b'PiAnncGy3x6t+X7r6I3R+RwuobY5fHvBvfV7ZvuL8Vr0nbV5a1ho3bw5wG/c591ae7fW57Fm'
    b'3bNAfVC354J7sT0s9rZfq9a6NXNLe8S471Gd+wC+GuueSV33bK+oUUfsTPP26O8MuNIYcy7m'
    b'msen5h3JVT8LnyXtg52HX3Z2n7N56F7k1ZjD9q7NnbT4G8OpT6rtPo2hea0LsPs+1Qm+M/Gx'
    b'UOtdOst+aurUEPt+WWpr3Ue7VMNc41NO2NOcZznRPp8H6PEsWGp9JjjFrqVno25sL3hm6N61'
    b'npe4M5vr2hrWJac+cj2n79BYjTHgu6ixwHttHaj3zpfqWc58Up/4Hjx76TxA86SzLPY6C5oD'
    b'4vpAzDrt11mt+yzOUyM+Y/dyGbuvcd8vOLd90PxiDesZO9Oe9ur7fOj3LpyhdQ8X9PzUf8lt'
    b'UtxDYR2m7eW6yLu6ET6HtUfULsxCi/Uh8bW7CrF7n2b/gwh/cPiWn37v7X/2pk/e/sX3fP3t'
    b'xRdffHxvWO6Je2b1PvduvVPyau0373sDrfguxT5wFnQWfr8b8u1Ru3gOteqMrbNOz90l6Lo3'
    b'izmd1Tq+i7jPb16/+Lzk6ws+s9xXuj/gG+/ZwHpnGGvdw17A91monepaa3vW5fSc0J6r2s5F'
    b'5xI1zfs+3btz9H1Oe9B2hhb6DKczkWO1tzn9amRz3ifnw+79YdW4rOmz7GfJ0/j2g/m9K/Bc'
    b'0H4w1tKH7+r5up85uNKA52ltNdRa71zRb02/vYV8z1nbHvtqXWp3qS17z6shx3l2vlYNNAfe'
    b'o2wdXw01IFe/36L9e54+w5NwttY99Hv3aPSx+tA5neUyV8j3eXo/5k/z+nzEol4rfR4tdfO9'
    b'v/Z2H3POKPa5zLm253T+kxbffL8L+lcn1E+c8s4WY5dzsT0LtC7V4Pd9nvp8jtWrbQ1rHux1'
    b'dS+xl1XUO9O52p7DHOA7r3Ox1qA91lpn/uP/SpIFHqgP4ZA2YtU8DHm01Il6Vmd0zqLWmSw/'
    b'0s64monenJj7PJ/5g8N3/uR/fPu3vuTF2z/yVb/58d1Bf5jN9R7xvXeW72Xvlxo5tM4D+6/y'
    b'YsyMfZ/G7E3O/JXtXCDvc6opzbs/cefoW+sc4y5wLpb96T3dN6jV9xxibe+gfYC/e+gzD5+6'
    b'tBfap162zxqWRc55nau2y5w6fCD2Gcn1DqCzxBnQPL4176S91tSx9pl3tlo1WHo8J3brjfF9'
    b'PsF332ph5+Fvr31yr9536GxQ5xLyrtZ6LnN9Lmv6YAz1AU11zmqORWxvZ/hc6lrDt8+5fXYw'
    b'p985as1D6yzmstASO88+6Ay06pyhDtR6Jude6VyLOfq0ztxaIeedOttYPTn89jsTyDd2zvZz'
    b'Hs9kT9fOJ2Z53+Sgd+SyBtax9DrLdwHk1BmDs4xrN6+2ZyPnTDDvOaB7mhNqzuus1VoHbdln'
    b'qx52HjTWv7LAPN8N9B7IQ8+Ar3VdQa3vq74wy/2o6Qs589XtHEFDjefw/nqPxRzWd+sea6H1'
    b'7lGqZ6Z3KPRVA70X7e4r1NWAvs/IrIcTVbTDXGisacm5ls0ZOw/u5VqDziPXyyKmTk6/+c/z'
    b'St790Q/d/ief+ujtn/nGr78999xzD3fkXWn1wTvc+6y2+WK+Hy59vj8tOfOneduvX8uyxkeO'
    b'vzSHz+oZapljzR+aXc7oDzd56JkFrX2tuWfr+l3m9vk8H2jVgr3Q52Vtr7H6+ptbPb7zyUHz'
    b'ndN+c84pzTuns+uLOXA+dC/1tT072s6xx5waMF89vrNbU1ur3/1X1/sDcqw+HzGow/Y52s88'
    b'75LVnkWNOjWe99Sz7D6yd7h+Me+czttca2KO5dnFuwAtOs7XeZ2xNZf9gO+yxl5q1Wh7p/rq'
    b'jXtnYg2cV5pzH6znYBljq2+u2qV59d4Ry7y2Z1CPT0914AznyEkrap0L7GnPaZZ0X/FZuo9+'
    b'9c7GuohZzriiZ7vSda5x7xKwappjne7AGlAv5qF6dFjmgPu5rnInPA8w0/WknoUe6H5Y72fv'
    b'v/Od1zoYe0bntBfah+9ep3cD5rA9H5YFvWNz0vik8XlW52q+/gn0r7jtHUpsTusFGLuxy5yo'
    b'B3p8eMDu/GpWqy/G9Fh3Dr2f5xr+bsPv//BP3f7Q13317S1vecvje+sdk/Nu9V1+1ODdgznf'
    b'+y4/YHy05u2T5rD2lfY4B9Dy/qmzzIux/Rtj+/34rM5SjzXXXlGr3hlArnO3Vsh3xmle80Js'
    b'Dqv2qt8ZPLtng+r1wTuyV78aIIeWPL7v0rirOXTOqsYYqLfHnJbl3uqkszavtjXmWANr3pV7'
    b'WOsMND6P5wFj/SuosZjVGNyj/c60Bu0HYt+FWO+8zhXnnjT4zsF3D3xr9rJ6Vu8IrBsXcs6B'
    b'9p707EFdvbg32NuZWpc0xzr1gT5799nEXhZ1qMa51oq1tazFGmjJAXfAImYffevk2mN+fXWb'
    b'73nwjU/PBGqqLZ2tj66+cfvNNW+PkPc57i2p31nk3Qt6h/3mpHcnxOZa6/upvveJhh5yarTm'
    b'PQex9Gzku6AzPIdWul99erSey5gZzmGJ+9a2Ts/miF3Fvczb0zzzoJr2FHLWZXNXfdsD9J16'
    b'yZ3u2GWsbb/+3rd52BkLWvvf6JDFi6NGgzo3c8NaHwqfDcAXCs5wNqizxiLXCzLPHGdJZ9fC'
    b'Sf95Pgt/aPgnf+rHbv+Dr/7y21vf+tbjHer3nlm8H98d9K711Za+e+tqmyvE7RN7xd7uzRmr'
    b'wTeubV8xD51VnTkgvzNaB+o+T+fL9ht3fyx5F/HOcY/Ngzl79V2+X3y50oJnY5nD7nNWp3at'
    b'i15z9Akx9D6s24elVr/z7QNisW7f1np+c/ju7x76QNxnOdXxWcxRw3Iu/dBe52nFXv1aQC/2'
    b'styjbL699sGeT4veHjTN2++CPcP2nvYnt+9lLXVm7P0u6qH16tH4XvBZ1qurnrV31Dlg3Xng'
    b'PHKAnuU8a87pbK2rM8GcMVQH+t3zhDWs2Is1j9+4qAfqje0zZ797ku/M1Z+wZ/uc1xi8A8H3'
    b'3vHtW41Yc04XNHZ/8D1r12+ftCZ9P/Yv9vhcWueBM4zROJtV7frWexZQ19lqjaH3bY+r89DZ'
    b'A9bJY9V2zvasTl+9OWNoTj00dp/qrF31CDnYPDins4X7htaqr1a/ln7Wwz/DwIJ9Gfqitnp0'
    b'5oj74bCccwUa8aHM9QzNtacafWz9z3Off/x9P3H7vt/8ZQ9/aADvt/fMu2X1nsvpztsPaljO'
    b'6Tz12HvfQq3fIPjtgbONRS1WzVrrsDO8A5c6LVRPfpd5dVvrXDXY5ot3xdmWqzlAzZmr8zmZ'
    b'7b2qs0+ttjVjsV+/1p7u6Swwt30+N7RmX2cU+1rDd4Z0T1DTvu67/s6HanaO80/Ld4uvNeec'
    b'7S/GaFxQLfN2JpBrD9DTGfWB2Dy2Gmzzizl7tH3f4LzOMQf41eCrVe+zyen5QT1noOZZ2t+5'
    b'gN85+Oaat4ec8zqrc/wmndE7UQ/q1ekXa85rP6gnr4bzVWcetEDes6mvRUvd+16N+6DD9jn1'
    b'qbmnfbLzqtsezwDkzIN68+7pKuqwPT/gA3Gfu1rQFmfszN7JaR989Wt3lpDTUmMP+7qKWrCH'
    b'pa76agHf+fcsC4jBuPBM5r2b6vB3npa8q6j1fQEa56vXeq8sZ0N1ezfuAbsPeS30ubrQuMC7'
    b'MFedbK+5PpuLPDMfTkegoNaB1sUcg314Yq36fXhovbntXQ1Wv5dRPbEP+3leHd/4/r9z+299'
    b'1ZffnnnmmYe7ZPX9ifcMa4F6Pzh8cmDeHHVsfdA2Vy1gnY8FvwtQb01ah84rrbenz3P6vhf0'
    b'nlFNZ2jJFbTWoL6o6c/Dwlzqap1zpS/V6junvcbmqrEPrJvDtg7Enlfw+27VwNUe4D2zzGvN'
    b'tVfIuZ/1fT+td8/T/NUQy8m3R59e9sf63Kfnr3+COks6r33uKfbtt2TeGXBvDtirv/X2bD8x'
    b'e5ln4bOkeuurrX7fq9+Mc9oL2t5/rTgD65mhOnLut/vCqQca9xz4WOvYzmis1uc3j919NwZz'
    b'4GzZPtheYs+wue0zVy303anpQq9/db/m1LaHmZ0LaqVnuNJAZ4B1cvjWjNfH9hnUi7nmN3ZW'
    b'z7xUj47nh9P8xVp17qkFZ+mz2Efrc3bOntk+2L18Z2AO29zG+FjPAdax7m/Ne7FvZzXfHNDr'
    b'AvPouuxBhzUHxpwLK9at2Q/G+rC95NGbt5eY9RBZNEljN67tAB+kG4D95oybk+aw67PQsEf3'
    b'7jxt82D+8zwdv+2jH7j9M1//ta+4U/Bu/cio+S4A/14Nmsfue3E/Fr6rsXVz0L2AWu3WoXMb'
    b'g3lrcOXzzLtf7wHYH5+6ZzEGLIucyzx4V8aLNeu1zjMnu8/Wm7OfxbN13ml2aa33gPUuTrPW'
    b'bq15ludqTl+9Oeid+r5AjfOLs8Q+bJ+l+4A9zatzpj6zuoc56yzrWH017d37BTTFexBnsjpv'
    b'94XdD6rp2n3VwZ4Ta659rQO1Ux3wWda15vXJs9fpjmv17dMH/VMvaN2jd94enxla1192brXG'
    b'p/5TX8+EdYmxdwVacM76nUGveaG+vcDs1oxl9Vo1no3YOeKz7lzi6uy92rt9oNY51ms9l1QH'
    b'vSPyW+v9g/1YamKfs8S4fWJOrO/zCzX727t5l8/WmvTsPp/zOlc8m77LGNzLJfa2z6WuerCG'
    b'Bfyek/M7Q+xBh3Wmc+w3ti7GnUvO1X4WGu/ReSxj8JzN9+5Bjbb7wCvVj+gwF5Bvrpt7KWrV'
    b'gPPAzaHaaqQHhz24/VAf0Jo7zf48Z/hnGn7fh3/y9p5/+Gse7s875B1wjy64epe9d1Zz0pg5'
    b'LOf6vsFc9dbJ7fzqTnvjuxfLZ6gGTn1gn7MF37zfrfX21oI9Ls5jL3F99c6zpq/1XYk+eZ+3'
    b'866WGNO/zwbkxD4sGu326DvbZb5aaIzOc0hjLMt5jbcO2L0XqK5acqU578Ie887RmhN9as4g'
    b'dzoXvjHW3p3taizOcD7g2y+dZw9wRvRYcp1vHtoDajoPvXnovJ7JPFSvr+4Ud0Z9aiyfx16w'
    b'LsY+s3rn6RuDPdZ2D311+uxhH8s61iXWWMZgLNu78ZXefQHf5zcH1ZTm+uydg28efOeneast'
    b'1lj2d8ZpXjXYU695a9hSPUv0sfaY49ml9eraD9RY1Utz+Pv9sMw5b7GmVdf33W+ehS/NuUBL'
    b'Lwt2VvP9LswLeXAmWpZ0T31gTvcp5J3rvrIxmHNfrBrP3nmuJz0LdvuEmnWszyPOuIcz9N1D'
    b'H8tclj64j70P/9CzD22xg1ge8FSvtSb6nV2dfa5TXO7VwBzWWSfd57mGPzT8S5/66O1d73rX'
    b'47vzzuv3h2PvWW2xT9TvDHWta/WX1rDu4xmlOqgv7QfPYt7FbNEn7w8aPnQPc6AW2z3dy2VO'
    b'ts7qu2Amixwzu9QZ44MxeH4wB/rY7lfNFe4D9YUZOx+rdnuqrUWnlucwdh7gQ7Xinlh98D2J'
    b'M62rV6N1lvQcUB8ty/vvjH0nLGfbxxJrPmufGZztM6jt3KXzq9N3ta4PrS+eQzrTfugM8r4X'
    b'F+wcLXn09lRHrjFUg98ZWFdR195qu2C1PR+cekTNCbQ7A9xPjKvFt6fa04z2yfZYW9s5coqd'
    b'wfIbdZlfrTH0u+ZuRV8doCFmtU5+fz7cp1jTF31r289s6Rk7r6h3ht+MvT07WnTNSc9hfmOp'
    b'FmusX72+lr09B6y2M4zVltaNfa7ivNbs6Vw00Hll98JnZq15rP3tg82vlfpA3JxzVme+mGsN'
    b'n2W/vs8ivqt+l/KKf+hZ2wHkaLRGvsOBmnl9rEvN6aOxz8MZS196e/DV2dO+z/PaeefHPnL7'
    b'r3/Zlzy+T+66dw+8F/O+V5Y6rHHz4IzmgNgctu/+HvbtPp6xoPH7tuZ5gBzP02dC31lYljP0'
    b'wR7XPoMzqmlO37n64KyepdC/Fp0/W7DnUSvEzXkOZ2GdYU3f3vZ3b2ec+rBozTvDWBr3HQl1'
    b'ljOtaXv24pz2SHt9nr4Dcj076NtLvLPVYD2X89FVq49tn3n85junsRpp7Kztld3rFJvzfrwX'
    b'8+B82XrngH4tizn6Luu1zIfu631v79VZWK1pzW3dPQHf2Hs5aY13Hj32iXV9IGah9Vm7n+hj'
    b'7XWe78ta9ynWoGczR0z+hBptaT9n2fO31xz2NAs8A3afrZzma1nbo16cK/qrc9ZqjXcP9xf7'
    b'oTPIe18LOev2OxO/c/S3Tm9jddjVErvAXrCvPbAzwPflLHyfQdZvv5D3Dqr3XN6Z/dWd9gdj'
    b'2Rh/30V7T++JHmfoe27QFjTkvSuWflHTGfjVdQ44D+x9eAKSBF3Nt1EL9cFe8m6wepf1nW+u'
    b'WAP1q+FiT7rmPs/T8y0fef/t67/6qx6/DxdgeX8nfK/g3WOrN68OTjl810Ju321/8GHPaA/W'
    b'H0R98ix6sPs9dVZ9Z+prnXeiOqjO3tZWj/UM1HtWNYBvrK71Pvcp3n7tPr/W3va7Z+ugBXzr'
    b'QA8Q9znVFc8Mp3prYJ24ueqI2bd5c57NOVjPYG79Yo3ls1XrKtTNYe3recg7h7xz2seyF6yd'
    b'9O6JdS40V60ac8x07mr1YfuwXXteljP0xffAAmvV2Ivd3uZaA2us7t27A/Nivv3gcxlj7W2P'
    b'ud6lNf3THuRY7oNVr+9M0EJzzZfm3VOobQ48i/mdT35zQm/fkTN859IaeeM+66LGOvbKB+8P'
    b'zBkDOWPnYvXtZ/lM1d5j684BZ3nP0LPgu79z7G+PVLNzwLvvM4gaUOMMte1Rf8rZK/VL57tg'
    b'Y/HcLHqNsWLP6sxB923c7wRLnmUM5qy3B/Zdir76qznOUq8t1TgD2g8898NpLLDaZKxGzC0M'
    b'tN/lDPuxPAxa9aV9ooY+fawvzhzYq/08rw3+q0l/8JlPPvwvQQt32mUOTu8CfAdXecB3SfX9'
    b'VrB+P+2jRl7U6teKffql3xrgq9FvD7ku6yxiIfbsQI29GrdHPZBrXY39O1cteTS9H/LOsd9e'
    b'sGYvuF9t+8ybs+75QW3rpTH7omH17O6zebmaLdZ8bqiW+i7rnqns2dDyzPjqyZ32kM5V13qx'
    b'l4V2+3rfosaasXg+8p59NeTdY7HXOWDsnM7UQjULe7qvOtbeOZBjuT/YZy+oMW7dJfon6z0J'
    b'MzyXM4nVoAdil+Dbe6J3j9a9m5PN42PVeA5RC91HjLHOko3x+xzW1LF6dpZ1rXfmWVjOab+5'
    b'neHzbZ+oE2epZ/99BuvGgu9+alg9o3O1XWoBa3+pvthrj2dW5z12Hjn3I3+aK/a1H7/51qA1'
    b'wfdO3c89TzMKPWpY9K2+dTH2PYD7WutdeD6gZg/UB+riTBc4x1znnXr16WvOvsbt37lbp2as'
    b'9WzgbGq17SvkHndXyPKiu8EJB6t9GDqH2hjUGV/heVj90Fn1T+ck/6T5n+eaX/fxj92+8Td/'
    b'xeM7ZoEWesf1oT3mr+rSWcA7V+cyV/b9W8dSw/YM1vV7Lug5rNsjavyOjdWevtdqfI76xurA'
    b'3taNQT2xe0rnqGm/99b9Owdfy/Iuzbk3q7PcC7TNFecI8ebAXq316tyj5zyBzj513gG0Fx+t'
    b'z1U29lugh+VMdVrna7s34HufcLWvPWiZob+zdt2bx9IH5jrbHOjT27r67kHe5yFP7ELbZyWn'
    b'ZVFzVmdom3N2Y8+yeWtAbTVgvpBTB9VC9fiez7rxnpvV/TibPdjWwBq0ztz2Oluom7NHrWeC'
    b'zoTO2Jr3COacqa759kJr+JxDncu61IfOEzTeRdcJ+ql1jufwzuzVt6bf78ml1lrnA7XazlBr'
    b'DfCtNd93ANQ9t3Pao0XjHe1zQnvX2iPWyLuEWu/KmnNKa7I5Y87eZ9f3mQpxZ4Jx8/iuqx7y'
    b'LtBWu71b6zrtwaImasjxfMR9dnBW+8BeaX33qLbz3vCe97zn0x/4wAceJ/1gFuv1tfqA3w+w'
    b'faDfmj1Yc2v1WdCPQc1izw/98R8j+kzydeMNt//zD/xnXvaF8533feHReuenX7q9+eVzv+kT'
    b'H3+wv9L4my9+4e33/7//9uN3ANxp32/fBaDzfdqz71fsM9d56mHnbA3fGNSD9fYYs5gJ7aF+'
    b'dY6dUR9LH3hWqV46D+p3nr21+ifIs79nAfRaZwC+eudZA3NA3vO8GqpvP9b9q9Hv3kDsOdE4'
    b'Sz1x67XiDLXmtL2H8mprnqk5fM9rvn61PZuzgJh12u/0bux3n/a2Jqf3I+Y7p3fuPGuNzTnf'
    b'mr5ziaW15VSzd+dVa66szro9sr1XemKeU4ib4x7E/u6l1juU+rB1cF5n4oN3L2qaA3Lbu7RX'
    b'/Wmec05nLdTufR/OxK+2Vh126YzltIeQ6711Rns8Qzmdo9jPwj/FYA7UWINTbXP17b3SCXHv'
    b'1hx01vae+kA9tEdbrZDzHcPu0zmwM6ztO7zay9qeHcxL9aCPvff8rNaMoc/Z2XI1W+w52SdR'
    b'Xe/Lfd7wjd/4jZ/+0Ic+9JBgeQg30T9Bvg+HVrqRtc5RS669q1vah391aeCsz9UfGL7me3/9'
    b'y/5nz9dn87l6Xv6H0t72lrfc3vHm529f/Gj9hjc9e/tHn/n07es/9cnb878C/hDxiRfeevtv'
    b'3N52+w9/5Ed+ybPoY/3YoR+a9Nnx+8GbE/2do46FX046NfrNGUPrQnzSLO2Bnrk9WO/InxlQ'
    b'ax3LIm//xmJvUd9ZoLY10d887BmKuSuNvs/rfPK9J3JAzDJetobPzL1z4+rra+3tubTQXtm9'
    b'QJ0QO3Pn4VffWs+DhT0bGO8sOWmxzDIH5N1HDXYxrwbqA/5pPn5jLTlj64t179w+wHo3ztLq'
    b'VwOb77uE+nLSbO4KNO5dzDtr7022/xQDOeeJvvO11dl3uqP62PZLe9Utm9ffHvdoTB2wV/vo'
    b'V9sZcJq7VtSB+dWAOmfoNxb7Owd7dZ89b/vMdY5szln6Wufv3sAMa57BnDTnjKu9AG33Ib5i'
    b'teBe4H4nHVjbPchbu4L66U6ks3defeurw+4dkfeeRa0Ybx7su8qD89G4/+4JarCtm9d/+Neq'
    b'ggMt+pJaF3LmH4a8fBBovjXzUt0J8z3s9uwLWK5mv170HPguY+50NS+99NLtwx/96O0n3v+B'
    b'2//tJ/7u7U//Rz9++0N/8723/9JPfOj2Bz/9ttu/98KLt08+z9+P+PsD/yzDf/4L3vJwl569'
    b'PvS7wXrv1fvsLnuoqT/1gTE95Jxhr7ELtLC1pTX9zja/WOfZXP0mXeDzNqZfrOt3b3XE7dk7'
    b'dRX1aws5lr1qiNnDemlu+8CzeCfU8K1Vu3ch5rQ+L5Cjz/NJZ6tda6/ak86asbZ7eR5nqBNr'
    b'7TE21x58zgXtAe8O1ID9uzcwY7UuY+ro8D3XKWYVZxRyLmfoew5iWe29fZpXW+x1pjm/j9bw'
    b'4eoeWX236sGc+tZWd9KAec9mXOynvnuoV2OsVg3LXp5Vnc9mDNUCvt9ca+2pZnulffbqV9e5'
    b'0Fgd1uewrk+t82BrLPvAuPl7d2MOWx0+C03vmVjUknNtbG9zrcnpzt1TqHlGUe8sZ7Oqq+9z'
    b'rbZWf89lnv3USWdAfbAOWGY4X1vQuMBn3znQnGx86q3Gd7WzTmdUgwX95rHViLG2esDvst5Y'
    b'iDmX71+N/onWWb/k7zD0IL4kch5ErOtTV9s5snm1gO2D6Hc/cAZoq3Oe+zAH/vqf+HGyD/7r'
    b'xxtuX/0v/Lpf8iycxfPB6bnAM2NX8653vnj7PV/4ztu3f/rn/778V5d+/oW33v7p/89Hbx/5'
    b'yEce4j6j525srvhsWqju1FNaY6/OA+MT1apZvXOgc8H9wL5a62o6F7ZnsSanOeS6j7XO3Rqc'
    b'YiDH6js0b485IIbqak/f9WqdK8S9W6jGes94mlUfe/VMolba/2rYfd2j+dO+avm7i1/9Vb9p'
    b'tG+4/Qf/4Q89xDyHzy9od7bWGnFzWnNwqgP5J2lBneDve6qm8/ad9hs49cqpZmzOuJBzv/r3'
    b'eoQ859NHK/Z0VueoJdfe1S3tw/e893BeZ6/vjN4F7D72gJrNg31ac2B8BXX26/fdGad+ctS6'
    b'x+bAXmz3MF/ar6+uPtZzQr9ZMXZO9zUn+jtHHQu/nHRq9JszhtaF+KRZ2gM9c3uw3hEaaK91'
    b'LIua/RtL+0V9Z4Ha1kR/87BnKObUiLF6n9f55Pf9w2lW2Ro+M/bOjc2ha6/W3p5LC+qMYfeC'
    b'x/McwGKomG/dPKsXUa2r8eIDiAd0HmidYb3z8E8XpyXXfT4XsG/vxnOUjaXPAfj0f/DDH7n9'
    b'ib/5o7fv/vBLt7/+wttfrn7uePPHf/b2Vf+JL33wPR+Wu+d8i8/hOt0Dvu+Gmr49ou8MUFMd'
    b'ZwFy6rRPwh6Wcxb367cKWGJ9V3HmqQd6D9qdAe7rvROb0+qL5xXqYr69UM3mTjq/d8A615yc'
    b'4j77qX519vp9Z56lC+pLz9m7gOrJsba/cfvuWVD7j33z197+t//KG2//9vc987Dw//h/+7P/'
    b'ph96tH3nxbnegffZOxG1WP3Os7e4P9zrb697V6cV4u6N717NF2fss9lnr/2N7eWc9KuBqx5Q'
    b'2+fDJ+dMtdBe2Fiacw6ot471edtTH5jh2fWbt7Yz1Js3Fn3rnQWrX6y1D+t9OqfvpLoTzgLn'
    b'mOuihrVejLunllzz5vShs6VasAfb51W33yEQs3znavXJ710t5tizut0L3I+lpjpyztPfutYZ'
    b'+u7v8g6oe3/V60tz5lvHRwNqsfqC373tEe9TzfZDY+vOsd9YLfNaa10fiM3Zuz1grVoWewC2'
    b'/T4PmPc8YA6cxbKOdba5xxNNlDbWMtRB4CasHgh6AKDuxwL26YN1YmzX8jSazxU+S+/Gl4b1'
    b'+XpGe3onQtx5P/6+993+4I+///bvv+XF2yff/Ln9ryl941uef7Desedm7fMAud6DOrW1PHu1'
    b'+GpZ9u4MYveD1rRwlbO3ed/DvkNy9lQPnqOrGuJCzHzzaqvbnOchdnmezbmI+121Xlpn6ZvH'
    b'WrMOjeu7R+PFGnR+2X7izmoeiPeewPnLaZaWezvN6Bx97GkWWFvNW97yltv3/XOfeDn6LH/1'
    b'b3/m/yGwfZxHyDXfus/f9w7bD9RZzhNnN9d4rVzNMqa+3z3Ls3p281AtvrY+ffjMad65zbXH'
    b'uSyhBuaI7TN2BtSvDojNbV7UiNrmfHc+J5zmYe3tHKwzNg/eE2vfj75W7K0enGGvtb4bqAas'
    b'mcPaA8bbo9WH3cu6a/OLdffqOYB8Z5xs3xU4SxpjnekCNe3jLN6Dd/+kHn30PZe9fRfG9mi3'
    b'R5rfBdZPFo0x2LcaZ0ljNXJ6vlqwrvU+m/ed27MW7FFXjbP0q2FZq+08wTe336E+eW01zrMO'
    b'ztsl66/+s5Me4WUrLOaBmgdbnTHWOe2lr3NqzQM5znPCuaWzWN3zc4V77tnAs1zZcu89fPzj'
    b'H7/9j/6jv3v7d9/w/Of0n234z33sAw//FYoT3jn0eXwPvHPfZZ/H56PmDPv7fTlDPcs7AnMs'
    b'uPo2V28MansWcV+pL2hY9nOGpXOxu3/jxWcSZ3k2e9V5X9474Huu9huf9lcHndc8kKfuvs5z'
    b'ZmeYk86Bap0D3m1ZbfVA7JkAW192jqjfnLZ1F3jPgqa5b/svfN3tC7/gs/vLj7z3M2d1Jpxm'
    b'iVr19lQDxHsPJ+zfOc5uvbN2rjowB+13tce6WPMOrJO3l5r1fu+w/eA+zpCN73GaK9ScpQ7c'
    b'F8z350mYad1ZrD6ns1jWBZ+8c9QAPhA7q/5qq8dHd5oBasC9ndWfXWe0Bu0HYvvUO9e6C+w1'
    b'hvaynOe521/6Xqw7X/YsrVPrHtSY2edhUSOnnkVeK2pBuzmWPcYsn2VnSnvw0QG+C5xlDNWW'
    b'7qslJ+7V+WBeH07920vNs2ihmhPUOrd4lmrWQue3x7tqHdC4ZGdoO8PYevNal7XSHNbvofdV'
    b'3EcetPcGtKFDye9LJDYnzPLwgO+CnSH22KflDNYKsbPw27+zX0/cy72hOVgNa8/oe7Cmdf3C'
    b'L/zC7V/78Z+6/dAbP/s/qvZ687aXfvH2Re9+9+NziWcC3oG16qj3+4Hq+r2xWjPut1UNfvfd'
    b'WAv41QExvqv67nnyO0+IqTtP3MezbR+Y7zncq7NEnTV9l/MEv/NOGugM1ul5relb8/msQX9u'
    b'/baN1eGzwNrSnPr2izVRA61VA9bQ29OzYPv+mtcH/PY7w953P/o5+pe+80MP9eXHf/IXX/Ze'
    b'ee7Oc74/N7t3sc8erAvIuYp1bb8bLTXtsvmTZjlpyLGY12+rWmuweu4IW00h3+/TXLHWPWFj'
    b'sNd3A+aw9aG63b97dq/6neNzFmKWs7pOWvL6LGfqL83vPWrB/Vrz2feuWNKZ7QV19myMrnlo'
    b'L+c2LuRc4jM6txi7l6vz7TPGkuP5fEYX9K7t2btov+uE/Z0P+s4D9mWtTo06fWsnPefRSmf1'
    b'GYW8loXeOc11ARrmYc1h1RsL+WqJpbq9C+f1TECO1Tlgfv0TOw86zzp7w84ibr+xvnnw7qn3'
    b'GZ0Nzqp9XLXBDQBbH/qSrbPoc7UG9Dxs9vJh1GDVSHPqfCDnLJ1RDfmd/3riR9R9+zxA3ByW'
    b'2HPrFzXAHsT8nYY/+v6P3T7x/Jsf8q83/NuSfu2v+oce/H0e7b5fwEffnsXn7Yztoeaszhe1'
    b'nQHNd554787t7JOPdb7n3l7rWPPu3ec74SzA9lmKun4r7S2dVx/2HMzb82tBWzrL3urcA7v7'
    b'CftaoxffGd0fOkftVez7dVmzDuSh+e3xfGqldRZopXeC9p//jt94u/ibdbeffN/PPd6DPvTu'
    b'6yK2ZgxacIZW7RXO8+z4XXuWQq7sntidS6zPAnPFHHM8Q3Ev9wH3IodPnzF0hn3Y9a2b71ww'
    b'h22fdbG/qLNvZ8D2qGF5FnvA3vYb24Mtjb2nYg7rnKV7YEGdMdTvvallj74r87B66tVKa+0H'
    b'8i5QgzWHta/3VS2oc5krarBd7QF9tYt6zmO/vnXiE+7p8vz2s/DtJ9a6L1DHt96aqAHr21fb'
    b'pb7Y55zOYhXzCz3OsI7dWVsnZvne1S3qWt/ZLOJFvTVn1d/lLG19z2p/8b2LWnU9Iz5L3+dh'
    b'vWKKyYoZbLw1sF4NG/SA1MgB9WVz6MmZ7x7mjWVjOOVeT3pm8aylOfzTfS2d63P99Ad/5vZv'
    b'PvxPwH1u+HUvPH/5PMW4PziA3ecg9tnxrVOzzxzWvDU56YU8OfbxTObt6RlgZz3JQn0ht5rV'
    b'uVfPI2rJ42th49XUbw605IF7wTcWe/rzq8YZxfqpBvZWg/VnHL/5xvaqVa8v+j4TOEdt9VvD'
    b'B5/5pC3UeyaXtd7dV37Fl99+37ec/+4CvO8DH3k8X+uMnqdn6F7bC9aFWnPt68+Bua3br5Xq'
    b'AJ/lTNC3D2tua50F7td93MMeuJpjr2yf9H1p0TG3enP66ou57YWTftn9tPrM3W9Dy2IP9zGn'
    b'nnw11QI17d6JNahO0PVMzjDnvaGzr/tjfTbo7OJs686VzmeW88U9q4POtQ76nkvQNddZ6p3h'
    b'XCBnzFoNS6xj/Z7UE+PvvGJdDWfC0us8WAv4p5jFvOaK8d59z8LaWZ4NsH1eNUv1gI4+8H6g'
    b's8kR63eGPfjbawzGzYmzS2diWaJv3tjZ2wu7h/nqqml+F1DbmY/vkSJ0QGMa1bQO9Qv5nbe5'
    b'q1oxbq25qx7y+p9L2M8l+vsMPT+r9wxq9LXk1LL+3Z/+4O0Tn6N/luFL8q+mZe+eaz+w1svm'
    b'fKZizmUOjNtTvTrOs/nNgXrQV9NYS545/gJrfmlOTecWa2Vj6b6yZzD2vVgj3/724JM73RPP'
    b'6yxQKzvTXzCdYU1bOht2nsv8KacF8v7Cl+qq1Vdr7Dv2Pljm3Bu6B779QOw5+GeA/nu//50v'
    b'V868//2f+V/d7/Ju8J2PZVkzXtDKap1fH+o70xwzmlt/c/ZgQQ1oob70rqV3AWigexZiZ7jK'
    b'5rHqfW/m++ygTp8F7Tl9L6Demjl11szrgxoWZ2IP92kdmgfy5mrLaQ45fdBX0wXdU9zv6hsC'
    b'Ylc1m3OGy+8CXx2WPfHBGWjV+OzG9nUekFvIuewT+0TN5oGc+3WWOWjeGcatCTH9an1m8D2A'
    b'OumM5sFZ7WURn3LFPatbjXWWeud5fhbYjy3GqwXj7evZzG8PkEPrWdT0bOTaUx2s7qTvEvbd'
    b'/QSf2s40B/SLudY3px7fWfD4n2HwQP1IFGl7GCHuqga7mG+N3CkPpxit/sb6zjP+XOB54N6+'
    b'nquajffs+KfZH/rIR25/4Y2f+TcYvd582UufuDxjP2ggv9qeX9/vrblaP1x0xOo6G4g7gz5/'
    b'sMhtT+cC9X771drrPHPgfP3GoF62fkX72oO11n09u1osz+hz7gw4Pa+9nc3y2cmrYS3b7xnM'
    b'rQX85sFac8XcVZ/5fX6Xz3PqY/VunAHqAN+50FnWWv8t3/S1t2/6zT/34J94/0dut4997GMP'
    b'vjNY3uHC7D6f+5d+Fy56sM6vzxL1UC39je0HYxaQd7/Sumfcb8zlfs7FB+vQWvOA7z0Ve6yh'
    b'IwatWGu+34h7sp4EM6rvXP3OYh+WsVri03OBMwBrDxCznMvaeq01rO/yVNvl2U7nZ9V3oena'
    b'XLXFGOvz2CPmemdq9w7wje0TZ5jbPbT6sj1quqyB5zSP3T2xXWpY9LeHZyzUWJ5LnT3d31WM'
    b'0e5scta3D5zX5Rysizz07sDYPqh+UXOqb7/LHDQHmyc2t5z6pLWdgzUHancesTm/Y1bn1Io9'
    b'7Qd7W9e+4T3vec+nP/jBDz4WYPdlNCfUejhoDzQvrWNPLx6f2dRK63C1v3n5oT/+Y4/+72fP'
    b'8PrwhtvXfO+vf8UZoM/gM6FhWet57Yc+A3moTr75133p7X/86Y++HL1+fOStb7/9kz/8Ey9H'
    b'n8Fngb5L0Leu/6t+1a+6/abf9Jtu73jHOx56+B8O/Ft/62/d3v/+9z/WsHp3xXkLvb1L7e6v'
    b'FXNgrblyyttjHh9OsT4Ys/ZZN98Yu7PKqWYPYP0WRb29atqzM6u1hr03tzj7W77lW24vvPDC'
    b'4xjL3tJnBuf8pb/0l24f/vCHH2LW1d1srvuYU6O/s6yJd9MZ7RdzPN+//8d+w+1X/0Ov/Atr'
    b'+Qv/j7ff/sU/+n99xX74xlpr4n7tw977WQBy7WkN//QexfneU/VqnW+teSBWI2pP3x72lNcH'
    b'YrWC/63f+q0P70CqcYa09y/+xb/48D9Yqd5nLr0HNc7oHvULsf3qWOrwu4c4z/3saS92+2Dz'
    b'7RXjUy/5aveZt+eKavE7B6xbO53ZutRXK9S+6Iu+6PaN3/iNr5iJhdNdCb9r+J1zelbt0tzp'
    b'7IClBp4DPJc1dNWCdWcVz0itvlzlrmY5B6vvjN6JEG8ev/N3jvHJB/vNe1/ELPdD472oxe+c'
    b'5u3B7pk7Q936sLXS2fs+wV6svcbqrt4znHrMgfv22VaDr859sJ4X3vBN3/RNn/7ABz7wEOxm'
    b'+nKKwVx7Qb85qB6MpT1X2taAeF+0ms/VHxj8X3q+OuMVnlktllzz+mIO+64XX7z9mS984XX/'
    b'X4H+xAtvvf1Tf+fDj/+/oHI6P3g+67/9t//22x/4A3/g9nVf93UP8fLX/tpfu/2ZP/Nnbn/2'
    b'z/7Z2y/+4i++4hm14DxYTb+B5u2VU83YnHEh5w9U/ase8/qcT9882NNZ5sRctaz+gIP9YI/+'
    b'Pa1Uf+Ub27/13osQa5v/c3/uz92+9Es/8z8M+Gr4nb/zd97+xt/4G49/yWnBvTzf+p7Bc1RT'
    b'zIP9nXNiddjv+LZvvv3R77r+ZxfgB/+dd95+8N/6Pz349ID9PhuxOam2qDvV26+uc5trDKsF'
    b'ddLe0h44/bwC1ndZjVjvHva31/rf6zfWffR3f+gZTs8FV7F6n7f5ff9QzUIetuYs643bg3/V'
    b'692CWn0wht0Lqlu/80QNtGYPdp8B2gfq+evQD/7gD76cfXr469Pv+T2/58Hv3oW4Z/EM9QF/'
    b'v9FqsM5orH/C+ml/MGb1261uffCd911Cfdk5nQf2XNUaiz1gnz60Dpu/ios1n9V9tIDPund3'
    b'0jnSXlb1svnd2xhLLI2xu7d0nrYzoe9ZCw9zX/YfqIhiNzRXtn4Pte3BZ9HrMq9t7t4HS51L'
    b'AvPonfX3g6uLx/fZmheeg7znXw158Nk++JGP3D72hle8ytcF/k1Jzz333OPz79n2mbA8y7PP'
    b'Pnv7vu/7vodf0ld/WICv+Zqvuf2RP/JHbn/6T//px39x9xkX855Dv/sDfmdYUyunPr8n96hm'
    b'9Vf17g2+W/L4LvXuib9Q8yzuZw5OPeROdXOLs61f6ZjVeY2x9Gn9XtX4jGpYrwXnY/1Z87zm'
    b'Qdvc6S6hOdkakDMP9beXv6P23//On3k5c82P/+RLr5gDxJ0HnL06f09Az9d77jtYrXQmNZY5'
    b'rOvUv7rWnHPVt3lynh1OM6n7TEBdVmv/a8FZLOfsPGv1PT9+zyKnHPgdF7S9D9j9FvLuUcvq'
    b'rI27P5aFRuu9O0utvrrWa0/fIb77sqQxtncK7gHtM98c/uZeC/TvOUr3OPlYqA/EV3fvneE7'
    b'x1U625r6+py/2mrAWjW1Qp2zuU6gcT4LnTnr1lZrTt36q4H6y70aUPduXMy3Bt0Pv89t3j5s'
    b'tc7WN8+Szfdu+97I2dd+6+5z0vTM5NsD7SHnIv7sb4rBg4sNUNuDq3EDc4LWGrr2bb51wO+F'
    b'Vy+tAfp9jtebvoy+4LV9BnNibH812D4zPnv+7Tdc/Hsaf5l505vedDyf34Hn84zE3/u933v7'
    b'tm/7tof4afiKr/iK2w/8wA88/h+K61zA17qXufpYF1zpinm/VWKec/XWNgfkobXNGYM5LKs1'
    b'aC++S30xX+7pRQ2rcbHXGnG/d78BaK++/Vhn/HLAPH/OPdPpZ0/Yt2fAdxU1+sBcvw3oDNFX'
    b'9899+1fe3vTck5/17/70zz5YerrAc4A5cP/1q4Hmq6+1p++RXGfVR2OdRewzV+e78B1B6/R1'
    b'WatlUSuN1Yi1znstuK9n5/nA+dSt7Xm0ztBCtbB1MLbGgtU2bw70zbdWOtt3Vejzm+i+xurr'
    b'Q3WyvjNOWmf17qn3+wT33Vk9s+uXg85h/p4FzHdfrNrOkNPdgz3OPOFefp+d4z209zTHntbo'
    b'dS52+5x7mmdOSz/PSOw71RZ0Lu/EPVyrcy2bM2YGfmdpyXlOMd8ewF+d4Pt8+J1xhZred8+C'
    b'NWddVkvdvbT7LZBvz77nta/4tySVxorFgbXqT33NeTgPBsTVUtNvb/3TbHOAv/2fCzyD+y+n'
    b'/OmsxtScaSz2YX/i9rn5A8Oz+Q/xtbxX8Tl4j/wdid/7e3/vQ/xq+Mqv/MrbN3/zNz++Bxf7'
    b'uSfgN69vTbv91cF+c61Be43B+FQrzhW0xOxrH2xvZ7qHmvZVJ5vbXlb3p9Z+MV+d9+Uc6DdA'
    b'fXvwsca1rxVmsq/z/f3S/VzEC3l7rJMT/dbV95sB67W/8cu/7PZf+yee/HcX4Kff95n/yhJ9'
    b'PQN0P7B+tTd0BnnnarvUWGfxdwa/5Eu+5OHv9v2aX/Nrbr/6V//qB0uOVf/X/tpf+1DHrqZ9'
    b'2C511XQGlpillvX8888/nNFz60OfSfta8Zvu9w5+3+B+LOrdk9jvE1qDe3ln6Z8wj/VMztIK'
    b'ms5pb/Pt129d2G/nGWP3jmq9z+6h7Uxy7uO7wFe7udq9d3L6rxVnyL1Z1k77kttZ0JxnrnXG'
    b'zuKOeN7TMzuz+S7wjo3FfmcXtWoad7YxFsyrqY49sC5YHVirbQ90bi1QI+7c1sEai3N5x2Kf'
    b'GuiMnSfuK/jktrc592isrV/aDzuvvr3ev6iz/vgfejbZYulwUd/a6pxnfLpw2D6sOXBOc+BL'
    b'tE9d+Vz+Q8+yZwDPvmcW630WIO5zGZfv+Yovu/1Xf/7p/oPJ3wvfeXv77cd+/L0P/p5PX0vu'
    b'G77hG25/6k/9qYfcq+VP/sk/efv+7//+l6Nfem/u0f3BnPRsaqvBnt7H5neudX3q/cWLLRur'
    b'WQv3vpHm8PeM4CzmgHmw1l5z0BmiVlpzlhh3jnVyq//zf/7PP/wHwlcL//3yH/mRH3nwO9O9'
    b'dx+wJvqbbx/5fR/OrlUD+v/Gv/Kfuv1jX/PKf+bniq/7zh+9/dzPXf9blE7nc29rez4xru6k'
    b'KfwHc97Nr0S++7u/+/ZX/spfeTn6DD7T6bn4Zxheyzf2u3/377798A//8IPvTO+pe4D7dv/V'
    b'tgbEfCvqQE17mzvNqpblt2p+sU86H7ZerrTmmtcXc/ZY9/dUf36c1Z8rsLc4h5p7NCfkfttv'
    b'+22v+Z9h+PZv//aXo1fuKeTcv9aarKbfQPP2yqlmbM64kPObqH/VY17f99M82NNZ5pZqWZ5B'
    b'OrtznqSV6q98Mdd7p957Efs2D8Tm1XWetA7Eftf9vjvj5GOJWcZgLObB/s45sTpntufxv1ZV'
    b'duCp7rAO9IPa/sa+DBd0BqtzhVh9e9Ubg+eA06zPFd275116vlMd0LRmT/OfePi/rz/PPvPs'
    b'K57L/bU9G3zxF3/xg30t8P91dA+WP1TiHuT1wbMAefuNC7HfpbGazdeSx3e2vmdZvXXQNtfv'
    b'FuyrFjb2jC7AOhvbBfXtMwbnNNd9oDPE2ul3AVrvpmz8WmBG92IfaE76ftwbnTNc5qV71McS'
    b'88ydgf9bvunrnvoPCx/46Bse/rBAH9Tqd09pzX3NLeTVQfWtVfP/C/QZFp/rtfI0f11z31MO'
    b'zJvDtmd/Lsi1br8WzLPQtraz+rtl+07srNW1V6255rvMaXemvWo6x59naa89PKO96M2Bszvz'
    b'tfD2t7/9Ze8zMIfV2YC/e7QOxmpbN+5sl3M7nzyY2/sCe50j9phvHdt9nOv32n3ao9WH+rBn'
    b'tN5ncAb+6ezGLjT2X/n2G997hu3Buoxr4cp3Fngen8sz4NPDqg9rQY0Qu5rvzz95l7HY1zks'
    b'eKzn35LEv84Senls4gOxrJHvJrIbgzlj8VD1myutQzU7B3YW/l/7n/4olYf49eOVf4dBet7S'
    b'M4Lnhz7D6sypJ2Z9xW/5fbePfuk/+5CTZ5574faGZ557Ofrl4Y3/x3/69t4f5+/YfBbP0A/f'
    b'mH+rxB/+w3/4If9q+ct/+S/fvud7vudh1t4PnHKwdwbmWsP2mzd/1Q9+/08z7wQadfaLcxY1'
    b'1u3X37N0JthnXR+MoX2dUw0+e/v7oVQnp7P0HPBa/w7D7/pdv+vx//d3z17cr/uqb3zlw/YL'
    b'uf5OVMO/wvPf+8HfePuSd730kH8S/4f/59tu/8K//Jn/j/nuUXoOrL60pi1b216w9iv57zB8'
    b'13d91+2v/tW/+nJ0/X7M/71+Y70bIN6/Frq/tf0Z37NB+0H92q3B5utr99sUZ1zhjPXBOc6m'
    b'tr8TyJkX4p0FzgM1+nKV21lgXqvvjN/6W3/r7Y/9sT/24L8a3vve995+x+/4HY/nOPfkA3Hz'
    b'3A8Qs/bdnGaYa77azijVgz3S+vbvHuaKtZ2DZfntn7DnCr+jndk+81rA9nuT1ZWdgxX1p1rP'
    b'CNX0Pd9Dvb1le7v/auFqhn1azw2tnWjdnod/hoGA5YMCQulQ86e6GmgdGquzpzOvZqgtxupa'
    b'19+e1xv22z05X59R7p3t6vzOcp/Hs1/44tuzb37HK9Yv9x8W4Bc++ckH6/6ewR8eFhjvv4L1'
    b'1dB//7mznb+55gV/4+pa49u3BvXb5w8OsctZzlPrzC5wBpjTQmdpQd+7BXI7Y58F1LHql8a7'
    b'r0v06dn9rGHdx98trem/Vph7mnGVB8/jkvVPNa1nd4/Gav6L3/q1T/2HBfjh9z53vKNlc/S4'
    b'N/Ssp36hdk9DzVm/EuHc3lefGfpM+FfP+GrwPpynv3uLP6Pu3bo57dVztB/qU3ORd0axZh+x'
    b'dFap9tSHb2zdZ93fS8au057k7KnVp67mlBNzhXrz1b8WOt9Z2M7tnrsfOe4EqOFX2wXWWGC+'
    b'tL7a/X0C+N0DGmPVQL+rzvHssLPIn75H8s62p750n6s57XFu82uX6tduz9YaA35t3+vSHuvO'
    b'W3h29wMtnOYbn2qy+au9wbzfLDz8V5I8FAUPpRjrKj28tAecq784Vx3rtM/mwN7W1HLRPuSp'
    b'9/Xk3n7WsPtcPj9LWsc3VmP8YN/0yr9d+nrw7Btfun3yk5/9Lz95pp5ncz/90z/9YF8LP/VT'
    b'P/UwS+oz37j+ierAGOsPJd+L38zOs2/7q4f2QPdx7axFjUuMnQnNmcf2XKxCrXPsdZ3ojGrM'
    b'M9P87tm5zdd/rThX67skdr41sPb/Ze8/4G3bysJsfKGoiI2OYkQRERQbYERR1MQCJvZ/xN6w'
    b'xgIGY0fFjphYP2vA8lkAsUaxxyjS7NL9IQY1CFIMIqJi/d9n3vOc+5z3jrnP2Wufc7l88bm/'
    b'cd/+jjHmnHudvfZaay6H1Fa6p66zefgZfVBHB26j+qUf85JNv1T+6Hn/cEHvOTcYB3XzOvSD'
    b'9jw22OrtAdjWX1/puqVrvlx7mH08TrO3P3PQ4whd46S9Zk/wmpqQ29r+XCuNNW/SPNH2GumY'
    b'Pxfoog+qW4tvVQf4zTN30phr07/CXOu0z4o9i7ay8zpndUDvsFZm7uxtfNriNenPvnFza7d+'
    b'Hlv8jRtrD3HO/jw03+tZH8wejanXV6xtD/SZP+fAnj7XBo3RS3uuTdt+jjm/dvNnjsxcwaYO'
    b'lM1pzFHc3/TD3pz28Ro6f5ekFhgU9ea2MX5t9Flrfoc5zTUmjcnF6rHt0V7XBczd9XSNe8P9'
    b'dM34i7b5Mw7//Dp3PKddWV760pdu8y/XcM7H9eN+nvKUpxz+5m+O+0I5PtRoT/tJj1f/sQRr'
    b'kCtdsKmZvUvnAXtgt1/7r2r8YV09kEJz1ZsLzQFsfT3mYExf+4I9QH36HNTNWPv7eIHumtEB'
    b'P/HVXqw5FuoZ6vPYOsfEOWeOuvFZi83wXII9gPnRP/4/3OnwGpdwG9XyvBde/TNib9dhb1j5'
    b'QNsYw7U2Bvhg79oCa819ZcH9zrWfZR/26vFxDvCcmwfmTl97gDEwd+bs9QLm1m+sOrQefcbB'
    b'mLpxr5Hmo/f692cf6OEc9kOaX580F91Rn6gTY9AXaY0x/drSnGOhltF12c91dH59Dv32kZUt'
    b'1CnrL+bAXk5/5r1uobWF+MyZdtc0+8z62lAfeq8lpfmtndeTtthvD3tZvzcXfqXo07+qBfxd'
    b'V/Oao18JzRV0/PoaE3wdZcY6X5lze82ct20AJLsodakO5q2wXn1CrBcs0po5D8wD35zOJe01'
    b'Y1ea7qXor67dtTI8NrXBfG3jfDfCP9z4TTffleTV/v6Fh78795Yk1yfo+lwnkvyHP/zhm30a'
    b'nv3sZx+e8IQnnLOu2Ss9nccBHJPa5hXtmaddXzFnVQ/G9uLg+sD82vr0t5fXf/WC32sC5s9L'
    b'+2oL9kpKc+nbdZXmzZyuDV9rV/u5VJyn6wLnYOBXdl0MdalP3Zr2n3rt27/p7Q6f/D6nv1vZ'
    b'C1/0l1ufeayg/efxIkae6zBXn3vR3/hJx769ro94nLpG9yru+yz7aK29Vn2rl9Z0bTN/rx6s'
    b'a476lIDufJ1z0prVHL0+2osc86qv5sPmXNHL2CrPPu2rJNdY62qrmzvXDvgvB3NOsf/F/NqA'
    b'3VypT336Zp39m4/P+YzNPKg+12eP9oH6VpiH9Oe1PqU9Zg40T32ug7rVWohPP7q9jOtvnrH2'
    b'mDnqq17Auma9ueKerZGZV9qHgb33swr+7DmHMez20gbt6d9Wa4EQdCOlzRw2Q2dh5ug31gFK'
    b'0G9twbdai7Sf9e39isD53T/g6xpFX4e5MO3qQPymt3ojlHOeK8fr/O1Tz2nX7I21VBfXyfjW'
    b'b/3Wwy/+4i+ei1wcPlz2gAc8YHuysddXjDNcB8wfIGPVzVVCdehcvb7r94FhMueF9lhhjTrY'
    b'Y+rEzal0PfUxrFU3Bu0LMw74XH/j6M1Tb0wdKk/62b5U7NF5nMPrYLUGbFG31jz9M24vpDH4'
    b'3I+9+TntdLzghVffeGIy+7uurs91aEOP66ypVIfqc97rG6t9r66ls+6h/dXncVLWX8wp9bWv'
    b'few151oN60p7APrqZ9e6+qB56s0v9an7cweNt6e075SyypH2cq19TBD05p4WvlNI6GM/pKOs'
    b'7M6PzTrrW+lKcu3RIXux6jDzAFk/YCurr+JivHmAzZh7MFYJjcNJduv1GTd2MRtpvRKUYK5o'
    b'z5z2WV2He72x65t5qxhYW73xrsF1zF4MYv7cNi74LniENamNoX70rfDchd48LwawR+NiP7Fn'
    b'c/VBH3ykPfb0VwTsYa6htntc+YSY4ySMv9YbvsPhH/7pyn9x2w1f+ozza0V23Svd9f3t3/7t'
    b'4T/9p/90+KzP+qwL7mwy+eM//uPDf/kv/+XwQR/0QYdnPvOZm49e9vGYtL9xfUqxFr+5RX/p'
    b'9dbe/uBB9dY7h8OY8yphpVtjnxWdz3xw3XtzTj/M2B7kNbcPLO0311Dwkdvje7F5L0bXhN4H'
    b'R+h56jrNL9j455rw79VWvsPbv/Xh3d/m6m9rPg0vfukNtpsDOC+9HEXfXB/MXFjlQeeBvbzr'
    b'M6yZ4TFhzJ9bOcv+eqzs6dzOD5XGxFpzJr1GJ+0D7aNuTv2uQZ+6/r1jVR3MZ7DO+fNl/p4E'
    b'9NpgPRCrjT5rGgdsfStdW2rP2KXCnc+kj38y97iyXVuPf5nrtEd72WPG2t8B6sT3+iB7bhky'
    b'62T61dtzRWOrepk52Pr2eoN5M3dVQ2/7d35ysa3xfLXXrO010XprSvPB3EIcv9jrYv1OypHG'
    b'1YmbU19zt9uq8sVtFzjTWE6KE7tW4+QYVy8Xy7Ovsr5J69vnne//Poen3uJPN/tK8a/+8qaH'
    b'p33dr56zrr1uRv9hwF5hjXWT6efbWN/4Pj95ePmr3eac58pxy99/wOH3fuNXLph/tc76pg63'
    b'uMUtDne4wx0Ot7rVrQ6v+qqvenjJS15yeNaznrU9YWg+8lL6w8xVb7zoh9bOfP3V64OZAyfV'
    b'qwM2A3uvtnVl+q0Xa9WhPfuAVH8hp/+QmCezrjlTGp8/B2e55SVf3GZvmOtQl1UcmgOuWVnf'
    b'1IFvHn70t9zxcNtb/cM5z6Xzy0967cOnfulvnF9P5630XHjeGrMOpi3mTx1mDPiW5V/4hV/Y'
    b'9OsbH//xH3/4jd/4jXPWhXt2L0oG+zj2ywH544XHBpwL9HdOcF7OV/0rjCNl5htrf7G2PVp/'
    b'KTF17eZAY4DEvhirPkrnad8y+5ujf2XPmLQXX9x2zG1VuWvfO73TO2296O98nRecu7GZs8K6'
    b'/nxD6+xlPyU0f6XDzJX693LEeDmpH8z+ldK+q7zGy+wj+OaxBPvYU6lv0n8DYa7DenvVp10d'
    b'tFcS0F27NA9mrb7JKnax/Nlbec1RuIo2sZG6MTFeyGne7MMBAPMY5jCstQbU64POo14f2HPW'
    b'XgmYem8d4D/0rMV1OYoXZte86idvePu7Hv7xNW59zrpycIekFz//jy9YO7jOrrFrF+L4GS98'
    b'4QsPT3ziEw///b//98OP/uiPHn7pl35pe7JAzGvEHsqL9ZfmdU79SAbzeD7Mg/a2RlYxa7Wb'
    b'A8bMA3VtzvmMMybTb75Sans8pTX2s2d7iz7zrW9u/VDdPKQDyLHnsbS2fYvzSG31xmcfJD79'
    b'qznh37/XXY56sgDP/N/XvNWh8yqZh/OIxJ7XC9K8rkldvzkw82cMtK+PuEZgnbUBn9f+WfbR'
    b'XxR6fOb8K6glb65PvX2U5M5+qzzkKg+cr3YxxmguurnNmTFrajcu2vYAffPfOaXUtveqD/ae'
    b'bq4S7HUWVj0u1tO1tbbrEnz9+bYOWl+/zHx1/UV7+n2ckVWtcXuD/5Y2f66j+dD4RJ+1Yp/6'
    b'vJZm3qyFi/nQGdVnDLsDkH2ssIfHhbj1oA2NF3wMdZk9GoNVTdG/qpX6u64b3P3ud//nF7/4'
    b'6g/pXRC4qmAubKL/pDiYow4Xi6kjVycCZo9KUL8uXmF4o5fe7PDUh/zKOesaVusSfGXGwZzZ'
    b'A533VN72gx55+NsbXfsL4y43Nzz83eG5D7/nBZ8rqJRpS9cNzTMGez7z6y/WTS6lbua0V+tm'
    b'nz179po6EmYuNKe5MmPNmfnYYF5Z1ajP3MnF+oE5+qE17XE5vriNXjxOdA7oOvZiZfpWttj3'
    b'Zje72eF/ftutDzd6jXOBU/L5/+11Dz/+M79+rbWA8891TPbiq/Wad1IM+OK2Y15h+Id/+IfD'
    b'T/7kT57vuceMXyy/fM/3fM92YwRw3dZ2D/j4R/vYVxhO+uK21Xqnr/nQtUH7rGr3erVm+qDx'
    b'VQxWdvMm5sml9oVVz1W8/SYztjcf9l4u/Nt/+28P3/It33LOunSe85znbF/cBu0HzlnmumDP'
    b'hz2lMdnLgZlXZg3SJwb69JsPrQH9ol9mLnOo79EaWNmAj+FjvHmNT5pTWVq/0sGaxgW9a5Lm'
    b'CHHzppTWGZe9OnOaP2thlV/suZKyPWHgLUmzGdTXwms1Wdiw8kH9MntA+6x00LZ2xhjvcv9/'
    b'd3jqLa+btyR1LaB9KX70Ytwfbm25wz0/+fD3b/bJ18nnF17/L3/68Fs//sXXWq86uDbXWQmr'
    b'/D0bfY/WlFX9pcxXCase6jBrLqVWvxiHxlZ97CEX63Up9qpHcxufvtav8qV5sNfn2CcM/+E/'
    b'/Iftl7nZTy7FBnyN6Zfpbz7y/p9wj8Onve/p74wkH/1VNzz8+m8+edPnHPzs94lQ59UHrSuX'
    b'6m9fQD/2CQNv3Xjnd37nTW//+QtEff2jkLge5TwWMB8bGdAcOOs1BrMndO6J/lUdrGLtt5Lm'
    b'TE6qMd/6MmPaK1a9Zv7MWfWz9iSom3O0rn3nPLVnDI79pmefMFysPz4hZk6l1EZe7OdAVvZJ'
    b'2KP4s6O//VY0D9389r2U2EqH1iE9Fo2DNpzUT+y7khdj9rVWGivtPeeafVY9pm+VX1orq76w'
    b'6oWtf1Wnbzsjs0hbpl2MNYc+nRjm5A5tpbo95iCObA60rnK76K5ZxpXjqjm6D+avXQlznbDS'
    b'7eOQN7nzPa+zJwvwzy943NXy3LpWexJ8c/3VHY3BtAGfQxvsoQ7W1xZ8My76kc3RLrXtM/tB'
    b'a5GrHHE+6Rz+QiWr+Z2rMfW9tTnnjNunvcX8vRztVS3MvPY4Burbo/0Zs7924/qshZW+ymHc'
    b'7nZvfKYnC8AtVWXOV7nnY8jU26+x6bcfGDsL9HCA17FzYNdHnj7GXn194C8Vq7XrOwvOZ197'
    b'Imf/rhuIo69ytaffWuu6b8CH7gBzlbDqO33axhjt6Si1W7+SxF3/HvaA6tI50B2rOR3F3Mbs'
    b'eVp45cwec576XaN2JRhnmA/zyfDUWweV5s5rsNSPtH7m6hds52gPaA/m1m6P1ihbhz7r5pMF'
    b'OY1tX32V+juMTd9krtW8lb89Vv1mjxXkEJ+5SAcx4+rG6pPa1iv1FXtd8JYkOKlYf/X6YObA'
    b'SfXqgM3AXtWKvtJ+0Px73O/eV/5Dzy+96eHpX/eY8+sH9ZWUrnP69+w3eat/czj866+7zp4s'
    b'8PmFl//8+x/+7HnPO7+GrmeutezlrWrwAf6pnyShPqgftGVVKzMGe/V7ffZ0aO1E/6ydPpg5'
    b'0rgxPlzOh81f+7Vf+3DjG9/48Fqv9VpbDm8x4w49fK6Ex4E5jz2g/cQYnFTH8B/E1sDP/dzP'
    b'nfkVhs5ZCZ3vUmLq0hwgxmA/3/ol73B4z7u89FzkOO720f97+0JE1zXng64H5jpbY49L7SUz'
    b'l1cY+Mv8aeEVhnvc4x4XzD/XVLmidTDtsuor2sdeY/MtSZO99RRz9Nd2fUrgRhZv8AZvcLjp'
    b'TW96uMlNbrINfhl73dd93cPLX/7y7WcW+aIXvejw53/+59tfvvll9iScQ1321qJv0nWCudJ6'
    b'wcfb9t7kTd7kcOtb33rbF49D3HWIt9WS/7KXvWy7mx4/B+zpuc997nZ77b/+67/e6v1l1P6V'
    b'sOebEONDz8e8JempT33q4cM+7MOuNVfnBB4Xbne722375cYBPN6y37//+7/f9sjj7J/92Z8d'
    b'/uiP/ujwJ3/yJ9daL9JfmMH+/YVcpj3XYk986qA9/WX2BvbCuUS+zuu8zvYdUFyPfDkr5+55'
    b'V/2OwD6hc0B1mXOfFG8fmH2nNHYS5ldvrbq83uu93vbvKJJjwPnk8e4v/uIvDrxTx71L+0t7'
    b'NrbKlYvFwDiyT7gabx/9MH17ueffkrQZI2Hqe75ivJhzsR71w8wve7XSOp4wPO2Wz930KwVP'
    b'GJ72kKvvkrRaU9c71yrWTazjTiy3fadPPvzdm3zMdfZkAW728t87POWR971g/a51tafuA/9H'
    b'fuRHnrOuZvZRNgaPetSjtgcjMK/wj897vud7Lutn7oQcPmj92Mc+9pznmnVbax/90L5zHl6u'
    b'5sH0YvnGG4Of+Imf2B54p791e7GCj3+ouKPHXe5yl8NbvuVbHt70Td90+0XkJHjw45cj/mH8'
    b'vd/7ve2L83gg7BxzLZWwWgs0d3LWuyTJao7V+lY5ezS/edh3/9dve/j+L7rwH4jT8pKXXfXc'
    b'/yOffq055vr4ZaH/CKyYtZdio+sXfcfeJcknDDD7r+Ze+aDxVQxWdvPkrE8YYPYE54WuZZUL'
    b'M8ad4t7+7d/+8OZv/ubb4BdN1rlXv4Jr43/9r/91ePKTn3z4nd/5ncPjH//4wwte8IKLrq1x'
    b'wL/ywV4vsVbJHnhb2lW/X2yPQezztNDnD//wD7fHI/bFXbF4ctR5oLp0jTP32CcMHNdP+qRP'
    b'OmddAz352XzXd33X7d8A9s2TokuBJw+Pe9zjDr/yK79y+OVf/uXtiWBx7VMWfGB86mBN44LO'
    b'+mcN/15w7rg+3/qt33r7d4Rfli8GT/Y4Z095ylMOv/7rv354+tOffsH8ztP5ZnzqYK60/va3'
    b'v/12relbSXnMYx6zXUeyygd0jsE973nPw3u8x3ts/XlM3IMnC2/3dm+37KMP9vzSuOiD1q16'
    b'KWXmwoyDvtqtgQs+wzALSmOrxsWc9tGuf+UTfBNz1WX6Zt97fOa9Dk+9Dp4w+AoDdP65Pljl'
    b'ycxH/qs7vP3h1e76xYeXv/rp/9E7K7d+1hcefufxP3etdYrrlbmXpz3taees0/GO7/iO5//y'
    b'Cqvj8p3f+Z3nfzk5LTw4v//7v//hT//0mlefupe5D2ylPsDmgeIHfuAHNvsYuFvUl37pl276'
    b'3CfUt7cW/orFft7v/d7v8DZv8zab/yz84z/+4/aPGU/cfvVXf3Wz9+YH7Il50vWqn+UVhmc8'
    b'4xkX9IQ55x5zLXv12pX8Ze2/f9OdDrd7/bM9YfiVJ7/24VO+9Dc33d4y1wBdB1SX5kJ7yuy9'
    b'6sc/jqf5wkXx9pOwWp90XeTMdZT2MNbcVX31szxhmLfuLZ1H5tyArZ8nBfxiyYdv+SXscsMc'
    b'/IL9Iz/yI9u+/aPLZK5Nau/FkBNexXzv937vw33uc5/DO7zDO5zzXl54AsFd9fjlml9KYa5n'
    b'tfbGj/3QM0+e+T4hoTfjAz7gAw6f/umfvr0qdBa4vTj/hvzgD/7gpp+0D+zVnmHlt0cl1Cc8'
    b'OWBPXKO8unVWeNXhx3/8x7fBkwnYW8NJ6wLjhRz+zfuar/mac56T+YZv+IbDwx72sGvNWXgC'
    b'9YEf+IGHT/mUT7nkxw3+2MeTK+j65z6mLSflocuez/z6S3uXS6kz55rXva5iNiTJJsTaVF0b'
    b'Zg7s6UBupZjX+CrHAca1ked92/+vPJ2zdP1dM5xUwy8lt32Lexze9IO/7/Aq9/i2V8iTBd6O'
    b'9Oxn/Mb5dXb9yu6vOcaPpX9RZXQe4C9rX/mVX7n9ZfwYeMXmsz/7s89ZVzP3AZXGux7+oXzg'
    b'Ax+4+Y+Bl6f5wrriPJOuQcnbi/gH63/8j/9x+KIv+qLL8mQB2Bd/NeMfV26Byy8D0mPi8HgI'
    b'unnF3FXsNMw+nVvwzaG/888eSpjzIO/1b97uzE8W4PdzS9U5xwpzkK6x0rj1tTtag12MnQV6'
    b'2Fu9fnDerkcak5kjJ+VgN34Mrq8D7D39nU+dt9/wZP7hD3/44ad/+qcPn/EZn3FFniwA67jb'
    b'3e62/QLFEwa+CJOfZelaAd11rtYO6ta1B5JfLn/qp35qexy7Uk8WgL8k80vcIx/5yO0VWb6P'
    b'4+Y3v/n59bim7oexip0W3jZlD+BV2x/6oR/a/g0665MF4G0uPI5zffALcNe+2sfEHLFOrNdn'
    b'HyXXzHd913dt1yhvvbocTxaAY/Npn/Zp2xMu/ijGq01dQ9cI9SE7hBzHaeFVE3o5T/sgeSvm'
    b'933f9x2+4iu+4lR/ZPCt/e3lmqcs+BpvzsXynQvb+Tq/A1oH2sahetG//UaGMRsB/tlAu/nm'
    b'uYBivjnF3NYp7QdKaZ/ZV11JbeNXEubpWjsv/r21GIMbX/XL3xu9+dsf3uzd73+4zYf+4uEG'
    b'd/+mw9++1ltdp29BKrf680cd/s//+fNNn+uf+y3mrfZ7qfQ9m3tz8R7Qr//6rz9nnR5+CX63'
    b'd3u3870rO2f3YUw+4iM+4nCnO93pnHV6vuzLvmx7JYW+zif1MWfXhGT9j370o7cHZF5huFLw'
    b'flz+MvPd3/3d2wOqa4HqrGnqM155Vi6lDzmOwpr0uT6or2sHdP4h/YqPv+aDymfh2c+9+oOU'
    b'DvornbfzuzZQX/mgdbOXcxRs/PaY8dOwWtOqv3rzO29zoDa6uTMPVr7T4hz0sRdyztu4NQyu'
    b'lU/91E/d/ir+1V/91Zftyfylwts2+YWWv6je9ra33XxdK1Qv7hHmPq1hfzwu/Nf/+l8Pb/zG'
    b'b7z5riv48s///J//83ZsebVxtY/uQVa+S4FXzpiDel795skCf42/3PC21gc/+MGHL//yLz/c'
    b'6EY3Oue9Nt2H64L662OYp87gHH7t137t9kvysa/WXwrMyatPP/uzP7s9IfEPgkBM5l5WA1w/'
    b'4zTwKoBvwQJ70JcYT0bvete7brHTwGdvujbRB10/zLUb12+u/g5Rdw9QH0w/oM+8uR5o7FXa'
    b'oMknFcJcALH2qi7mrOZZ9YParSvGWnNS/pWAVfIXa37AHdgO7O2DQq/7eofXe72bHm556zc8'
    b'vMFt3/xw2zve/XD7f/3Bhzd/j8853P4+jzrc8kN+5fDP7/TfDn9z2489/P0NXucV9kQBeHXh'
    b'hU/70WudG7jU43uWczDn9bwCUv8jHvGIC7719bR8/ud//vkHZno6aqs7r+t4/dd//cP97ne/'
    b'TT8G3jbwa7/2a+f7OZ826BN0Piz4oAc9aHuydCnvK71c8NfDH/uxH9ve0wldl3TtMn1zT8fQ'
    b'YwbY6NPvXMb07+lgD6S68Y/54DsfXvM1rsk9C89/0TXvWXZ90Hmn7DoLcWKO+qQ9LtbvLNgf'
    b'2bmg86k3Z0p7lOZYO3u1/ljsYw97woyt5vnMz/zM7dWEy/XX2mP51//6X29/OX7bt33bc55r'
    b'9jL3NvfhPoGYcZ6M8Evme73Xe232KwoeC3nb2Or49/you5fTwhMG4DGQt8JeyT/QAG+H44mD'
    b'nz2ba3c/jtW+8Omfkhr+2s5bhf79v//3m++6gH9rv/iLv/jwzd/8zdsxZB1wzPql+sVgzrd4'
    b'i7c4Z11zTfOHw4c+9KGX/PmTCW8jW61trluwnbv5MOs79M2aYi451RvrWM2/6n/+KZ7BKdtU'
    b'iGmvYmXGoXM4YJULzTNXOWmP8znXbnnZ+d+v8+LDLT70CefHze/z+Atsxs0+5HGH1/3A/3l4'
    b'nQ/85cNr3PunD6/6bx55+Kd3/I7Dy9/yiw9//a8+4vC3N7r9K/QJwuRmf/WYwx8/+39tx3Me'
    b'b89F/Xs5Z2FeD/TTp+S99bx8OD8wdqm80Ru90eETPuETrtUX6RD3o/zcz/3c7e0Gx8BbkfjL'
    b'nNiT+brPgo+7U3Af8Q/5kA85571u4QH3G7/xG7dXVlZrnMcI0DtkVX+p8FcietmjffW3v3rz'
    b'p85At5e6sTd549sePuP9z3Yb1fL8F71kk3O+ietSh5k349YgW69PmnclaF/XAHM+Yo2rk9cB'
    b'rtccbcF21H9W7Fnd/qt5+Cv05Zz/LPCkhVca+suSdF+s1zXX373yGPTt3/7thzd7szfb7Fck'
    b'T3rSk7YPfHfd0LVD9WPgL8i8RYXHvovdQOJywZMxXkVZnYPqK4hZN/Ow+fD3937v9x5uectb'
    b'nvNetzA/X8DIH92E9bpm0Xa/ypP2dzH6xBm4eQpvvT3Lee0NQub6ZC+mbQyMN6++5kJ95k0d'
    b'tGXaE/vCq6hAA8hOsNd0L9a+gN08+888c5TGZ96KvdqrtHPyX7hUeHXhr5780O0YzvM2bUGv'
    b'DdM+LRe7DrT51tdv+qZv2vRj4O4XvKROP+ZUwmq/SP4i0ff1nxbeiuRfrVYwr2txXl6tYp9+'
    b'MdYrCtb1hV/4hedvMwhI1zuPmUP7cmDPHqNV75VPuk507fZCGvusjzr7e5XLW9/xVod/8653'
    b'O7z7u9zl8O73vOv5ga/j377b2x/+zT2VV8XJO1fzb8/Frb35zW52rvs1axf17lPcY8exzGMn'
    b'2J2zeUrnbq49GgNztKU+a49hzif2n3PMXO5exFswri/wxw1+MZqveMx9FGNI47wqy12drg/w'
    b'CjPrcm1dJ7rjrHC3Hx6zub3tdclHfdRHHd7lXd5l091b9zP3pu0xgKnzyzp/4b+unvjswZNX'
    b'nnjyV3335SjTltVeLwVeWRE+S8QrOX2L1DHwCgN0Laxvrm3Gwb0j1Y3t0T7q9YG99K/61p71'
    b'hdh2hGzCwOkwyYb6OgFo129de0n7mWeufpk+a81vXWMXkH7/wqVx87/4ucMfPPMZ27F0gMe8'
    b'PkD3PFxOOo9yNQ8x7i7B3UGOgZe1P+/zPu+cdQ3db+Fl1S/4gi84Z50e7orE7d3sP5k+8/jQ'
    b'2JX8UOFp4cPe3HaOtbnGecywGaCvsWOZPaG+zgvTbt1KJ1cdebe73PnwPm9/eT67IA/55Jce'
    b'vvMBf3P4zs/+26vlzviO//TXh+94wFXjKknud+A/V4O++a+Sn/L+V/3Dde5JqHtl7XMv6nvH'
    b'RHks9u280LmMC3nNN6ZvFYPqsMo5Fj5HZb+y17u56Az+qn99gg+hcrefeTxd78S9KvnrLHeQ'
    b'uT7AX/25LXPX3b24Zlj5TsMP//APb59deEXAzTnmK6rgXk7alzVIBk/0+HD6Xv51DZ9F4XMw'
    b'feuVY4KvezkW/g2lnlfKeMXItySfBd+SNM9F1zvXjN0aZKk9a61RrwT7tU59ytU87YkPuXxK'
    b'RcAksVj2JmqddnXj5jRezLNG35TmrJg9/4VL44aHvzs894nfdv64chxXx7n+GW/tWbGH86mL'
    b'ft6axPv655enXCq+YuDau5/OB5/4iZ941G0agbcifd3Xfd21enY+qY8P9nG7u+sT7IEPc/J+'
    b'Zu29c6+NVF/t+TR0DnT6rXqjO7Sbry7T5gnll3/SK/avcZfCV37Pyy74RlqYexH8Zebwy/Kx'
    b'2OtS5tVerVNfa7D11T/r1es7Lc7haE99Ul3w8T0O3Gf/+gSPJXe84x3Pr3m1H+ixQ2fwF+/r'
    b'C/wSz1tRWbdrnWt2X3Nvr0zwS7WfGwP34v5KbeLmIPkcJW+DvRy/IF9O+LAxd7+auJe53+7r'
    b'GPjcH+8o4InYSd+tcBp8SxKwNsCuT//FsM7a9ljJvTzsi81JjmPm6pftCYOOSgbFc0Ew89TJ'
    b'bZ52e/jpdH3QnPqnbm+kujknxdrnXzgZ3op0i2d/1VW/1D5vs3ss1Vf0PPQcnBX6zPOHvbce'
    b'3gJwzD225XM+53O2B1X34Nydk9vpffInf/LmPwbufsFdkcD+zifOrY+/Cq5eATktfKvzb//2'
    b'b293FuGtErzKwTeqngXu6sEDr8dItPU1BtM+Lfaex008hurG1K3VD7Of3Ovf3uXwZm+wvp/9'
    b'9YVH/urrHZ729Ks//Dn3MH3oHhul9JhdDubc9O9dSop5SnLQkV1X4+3jX2FhymNpf+n87V9/'
    b'4e5iZ4FvPGZcTj76oz/6guM31zz3Brylifd7n5XnP//52/co8B09z3rWs87fkvI08AcibhrB'
    b'Gl07+knnY+7nlQk+BN1z1fNzMWkdt23le0DOCv/O8qWn/BvCKzx80SffQ3AWuJsYT2LB9Yo2'
    b'+5mxle9S+LZv+7bL+jlA35IEHvfSczHjtVd7wTfr0NtzlXMS5FkDSqhezr8laU7SAhvL1I3P'
    b'POnC/KuV8ylX/4A0Rx3sVR9MG7bac/q/cHFu9pJfOjzpCRe+53bvuBbteQ6nfRro6Xne628O'
    b'IBn/7//7/24fhDsG/tow/9Lh3EB/3orU+5qfBt+KBK67eyidl1/IeSJzLHwB18d8zMdsn334'
    b'2I/92MNnfdZnbU+O+Afkfd7nfba/Xj3kIQ/Z/kpyDNxlw2+5FHTtudfax7JX22M5czq/sa5n'
    b'Be/3/vKP+6tz1vWTf7zqYfXbH/lH5/fi6H4ZoK+Y6zFRnpXO1Tl7y+Qyc5uDrt1e+vGtXhVp'
    b'7uWiPdFXc7gm5O/+7u9u33p7MfgSSe5Cxh8V+IWeLxnjLUC8hYJvmuV2j3yvAjd58Buoj4Wf'
    b'e77DRTy2Hk/XXx9r4dW2Y+AxmbdC8aV+PN58+Id/+PYZKF415W2N7A8fr1jyB42L/QLKL6o8'
    b'8QDXJ9qr81TflYAndi960YuO/n6gPXjs5rsautfVXuaezefW3zz2Hwtf8Mu54ZV4vieCX/C5'
    b'6QcfyuZVJ84r34vBl+odA2vk+nD9SAcx/e5dafy0XO7bAPt5xLk+cZ2Nu6dSP/Kk/TXu0EaC'
    b'tY1B65qrXvTtfsrDpkqgqM2qz3xirYVVjsN/QBj2nVKapz65wL+I/wvX5jX/8c8Of/QrDzn/'
    b'lgaPX3XB51hhbHVuLpW9enyr9QhvSeKtSezjGHjQ41WECXPyQOm32J6W1Re0Sfcz98YHtPhi'
    b'pGPgFQW+o+EBD3jA9vkOj4nnx+P2ghe8YHuixXuTj/0cCG/Tsp97qM3ANjb3eQyrXuiMzq0+'
    b'mbHZBz78/e98eO3jboR1nfG1P3yzw3Of+7xtza7bvenT3/32GIH5oDwL9nOe1dz1kdt5iTFW'
    b'r0yLPmtnTvudltmTdcDsqU2eenPw773KwF/Yv/Vbv/XwwR/8wdvPOZ9T4q02/NWWX4h9PObf'
    b'SL61mXzi/HWUX+COfZzjBgrcd989zeM2bVg9Ll4K3Pb64z7u47Y/XPiLFf07B49VvOrAnaX4'
    b'gwYf9EVy209fkS0cg9Ua6+u56Pm4nPDEhg9e/8f/+B+3NfPkjg8VcytbPvPAq9F8GdtqraeB'
    b'9dPb4+Z+tC8Gt/g9Fs7b+77v+27nhs+NCNckg/n5d5fzzG3GOW973zB+EjxxnHcwEva7t89L'
    b'2f+VxlcYVucD2/V3zHOoDdil9Stmj/ZeMeOzTtrzgrckTfB3EQ44aRJjpXFprbpz+SAmcz7z'
    b'1I1XTt+/sM+r//NLDy9/zH+84KXhHsPicYd5PhjWNO8szDW4LvtPCc985jO3lxyPgVcP5gea'
    b'6c1fd/hryrH0C9ro5yjuTR3ue9/7bvK08A8ZT354RWP2nXMb4x8D/mHhL52n5d3f/d23L4ei'
    b'r/1WOPdJOZcC9Q5tmT73ir3ad9fkwH7jN77t4T998OW7jeqV4M9feoPDj/z0751f/0Sf0r1W'
    b'757NW/21/lLxF3z7OY/0l1Rj6M4tjakzQJ9Yb472WWi9/dp3tR5j/hFMHve4x223/wR+ueAJ'
    b'Op8l4Ek6j1V/8Ad/cP6XL7BfR3sz+AXuLG9VfKu3eqsL5rG/4BNix96Ck73yC6T9kQ7tOT9/'
    b'oeeVBm6swF+12afft8Mdi3hrJdeRde0n09f9XA74Bnye5PHleHyfDq/QOifnh8d7zjv/nnDr'
    b'7mNfwRW/IHTuQ5t5ezzkzne+8/b4fAzskX/3+kRvwpwO+B//439sr4ofAz8T7YV0zpN81wU8'
    b'OeffRl7d4+10z33uc88/YfdDz16TgO06kfhnTLv7MK++k3Kdo/rKV+o7KadzbV/chtOxwgJz'
    b'sNsE+OGA9jC/Y9aBsaI955p5clLOas5/4Rpe7QZ/f3i13/y0w3Oe8yfnPNfAsfP8eFxPOr7E'
    b'sPXN3GOYv1xIe7vOxrnHMz/Ux8CrCPOv+rx959gvSeNtBrznE7pGmcfJvfALOG9LOAb+oeUf'
    b'Vnr12ChXc/JzzAPfMQ/29OWYdS7B1u9jBcw1HEPnot+cv3N0HbCan5jxz/rIy/OBuCvJAx/2'
    b'moeXvexl2178WXH9c5+Vxib4T4pfDN6ywi8nXLdI/trKUK8fvbGpz8F9/7l+WNtqnfquBKvj'
    b'MefSnrn6+cApb+NgL7wFkC8ccw/uC8yvrN483ppz7NtAfMJg764bvTF49Vd/9XPa6eDVA6Hv'
    b'HBPmxK/kyQZ/pecPIO///u9/+Kqv+qrza+vjyQr7u4/VfMfAd+F80Rd90fZHFntPKdg82eHV'
    b'3mNfEYLeypaecy/a9ZP3oR/6oees08GTWP7Q1TXTm+H86gX7f/7P/7l9sd9p4e2tfCi7Pd3P'
    b'9Gkbv9xwbvnCQ54w3ete99o+nM2/cby6x9vpuEkKr4jw8/y85139uU/W1HWK6+2aXbfSWKV1'
    b'taX19UNjYC2jfZXSPDF+g7vf/e7/zF+VWwAmt2GlMVjlQnVZ9VCHmT/Z6wn2Mq5+j/vd+/C0'
    b'Wz53811JXudZp//heEXz6v/814dXfeInHp71B79//vhJj+c8xjJzkNAcXmY+Bl7O5S809LJ3'
    b'50f6j6zzQm3usczLxcd85uCFL3zh9hYk1sCDAn/NOwb68FfE/gWCdStdr/sC18+TFP6ROS28'
    b'X5q/aEF7T136pEz4h4IP2p0GznW/m6HMNZjDLzzH3HGKtfUXLvupI9W1YZU3fXDXt7vz4REP'
    b'ulq/vvI7z7rx4aO/4Enn7ww294SE6XOPgM2YP0tv+IZvePiFX/iFTb++wB8B+mWHrpV1w2qf'
    b'yJ/7uZ876hrjr53PeMYzzlnXzCPOL865x6yXrhfUm6/eX5D18UFkbg95WrjhwfzDCNjXdQCS'
    b'X5z4pf208Mv1d3zHd2z63Je280zMNV571mlXija/3J3lxhjAX915stC5q0vnB3Luf//7H33T'
    b'DB7veOva3GeZPj6nwqvMx9wZic+98UoOPWdfdP7d0LdaB7ct5fH9tN9dwb97v/qrv7r1pA+o'
    b'O486kn+nv+ZrvmbzXw54JZC3EPJEnA/XuwZh3tW/38qyiqGD/vYC4zD7wYy3t0yfNebLKmfi'
    b'ed5+S5hJBvUju6jGpLnQfG2YdeYJc5sL2IBPf33SucpW9y8fe17CZxb+6TEfff77FjhW8/z0'
    b'uE7d3MrteCfnLPRacD7PPbr/cDovILUZvHTI1/gfAy+/88Eu/mLKl5QdCx9g7AeiWB/0AaIY'
    b'J3bsHUl67/fO0fnRjbEW/UjGD/zAD2z2aeAvln4JT+ddcbH4xaC+a56PHeC+pt/a9jAHyV9S'
    b'v+S+x/019brkK7/npduTBdc+94q98nWvzUG+stF1z8eMy4H99iDuEPX5b5XHeg7ykLMHPmiu'
    b'OY0f+7kjbvLQOaG2Pz/OyytZx8AvyDw2QPvP/Sgd2kqG69nDHFjlnVR7KfChZl4d6hyzp2s2'
    b'5sDP4+qxt/5evSXMawzcu/Mj+ZzKMU8W+KXZt33R039vAXtK5nLo45WlY/7QxprBXifhGi4H'
    b'nBc+F8SHuHk73N6/0fjcc49Bz0XX1ZwJPVbzzF7WNm/OX2Y/mLXaq95gjud+W1ELoRM31hyY'
    b'dTMPSa9KRg/EZM6NTT66PhdvP1nVXm1cLf6Fq+HWqTf/68cd/s/PftThj//42ee81xw/pce3'
    b'x7W6mNdcdFjlXyrUMuwF2vqmbtxaxkMf+tCj7yjCX1h4/6n/2J2Wn/iJn9hemmUdUh1WMfbA'
    b'P+bHfJsqrxjy8veq72puj58xf974HMgf//Efb77TwLd30qu9BR/99+KnxXpk/0HDbn/0yZzb'
    b'NTHe413f9vCWt335ucj1k0c+5iaHpz7t6tuortDvsfAYzHxt4uiO6yurvSi5BuY/vuYei8dl'
    b'/gMuxrsm9a4FOXVt89oXjAvxzmcP7mBzzG1XeeWVP4jMecD+gu3bLk4LT8C/93u/93Cf+9zn'
    b'fM/uA9BrQ+2Zx4D+fmBOz9XE3GPhbTa+K4NhP9c07Qlvc+HzDsfAH2PA3q5B31wPtt8SfVp+'
    b'8id/cpO9hud80DmNCbXHfAcJn7mA9nY/2jLtY+Hnh1fzeYLDqwrM5X4qOybsF4jtrRfwGa8N'
    b'q77GGT0fYozaVf3eOsxvzF76am+fYZgBUZ+LaM4qtrJXNeaZ09E+SA6S0l7z5KjL+Tnj+78d'
    b'nizc+jnfePj9//7Z2z8yPXaw0v0FD/BVr91jb197HIO19Gpvr4VijuvpvPzVgLsmeb2cBvZ+'
    b'7Ps/eSvS6q5I/QeudE/o/fr608BLub7n1J6r44KuPaW5fsjwNPA2MP/BnnMwus+zQB97tWf9'
    b'4PHWr951KRl8uP0r73t573l/udluo/qIP9r07su9YIM+/YDe/UN1a5XXR9zDiu7PcRZ8/Jv/'
    b'3ij1SXXzpDWgvcpzQGtmPQPfsR+o5bsVSnsqAXnMHxCEv3J/yZd8yXZrad6i6ech7N95Cz7o'
    b'OiqNl1mzyjmWRz/60Vtfxwrmm2so3Gb3GOzlv4GzN7ZzO//d7na3TZ6WJz7xidf6twp9b84V'
    b'xPjD02nvmMQTBm/f614Zc27Y858GevB2u8c//vHn92LPvf7Tt5djP9GefVe/n8x6cvA5jLUP'
    b'4G/djLd2on/WM/ertHH1QrITzLgxMNZcxoyXmdNcdHupGxdi/eWkktjGqPm/EZ4ovO7f/8Hh'
    b'ho/7qMNv/NIPnr9jxep4Kjs89urmTL86mHcs9pn9Ko1xDfgPOyCNM57ylKdc8Dad6wI+A9C7'
    b'Zjh8AITVntT9K8tp4X2uYJ9i/7kmRv2A5BaOp4UvmfOBbfYu+M6KPZA9/2Bs74F4dR6wP+z9'
    b'3urwOje+cK3XN772kTfdbtMrrN+9ILsf949v5smsRfq4en1j7sEhJ8WOgXqPHSjB3vh6vMyx'
    b'tmvYW4819mkPmLZgM1bX+aUw+0N1IY+bKBz7tiThVVPuKsR72/mcFX81756qw9y3+1zVXOlr'
    b'ls+z+KTJOZGrcy/m4Vd/9rOveWX/tPC5gM5hTzGG5I8fx3xRG39wes5znnOt3t2L+5m+DmJ8'
    b'Ezdf9HYaeLLADUbowbFFgvNpK8/Kd33Xd22f83Cu9kXvPsF411Jag27OrDOHUWZ9wdd/u6CP'
    b'8aU56kjGzBXnNk5v+5+/SxKgm6Tf2KRxRh/krLEXoK/sPR+DPn1wcIh5Hjxj1kLz/2/l1Q9/'
    b'fbjlH37Z4Q9/9KMP/+tZzzznvfo4VUof/NBPOpY95oBdfVVzWujXNWHPNfeiNt+5XdO3f/u3'
    b'H/UL8DHwVqS+FDvX7H7mGssxb0eCP/mTa+52Rc+eg6nPdYE5rHF1//OL0a/at5dzAbLn86y4'
    b'x55/fUU/Qxu6tn/1r97w8ID/3yvBbVQf/aRtv6zbY9l9de/6YXVMpg/2/NcXWJ/7Ul/trXnH'
    b'QE9Ge0ydQU6vP2umDj42zb7aMx+arx/JX+35pfDmN7/54YY3vOHmPy2dB2qjd5388nfMW0xW'
    b'3OpWt9q+qIt7/PO2T2/JDMy5x14Ox5VzoH/u41J6XwxuJjHr6Ytv1Rffah1/9EdXvzp4DP15'
    b't7+6AxvucIc7bPK08ISmd0aiJ9gX6fUuPh51Da71mFe/bn3rW5/vBfRzfv0M5zgW3mnBHxPp'
    b'1T1hO1/nRhKDzq0PaW1zQX/11ZDqoq+5qxrjXU/9Ys5Ev/nbeMd3fMd/9q0pJkEnmLFJJ/MA'
    b'zvqTepg7a5p7UgxWPsD/zvd/n8NTb3H6+8qfluvbXZJueIN/ONz6ud92+IPf+skTv3p/HtuC'
    b'X1/PLRDzQULs1Z7H3iWJDz7xYeH2mjiXdG0r+Dbi7//+79+NXw54KxJ3spjHfB6bvX25B+5l'
    b'/fqv//qbfhr4R42f6csBd8p5m7d5m3PWpcGtbPte5RXunfGzP/uzR98lyc+m9Hgyel2ujrPH'
    b'ePq/9nPf8fCB73TNV/xfH/mP33Djwy8/5rc3vfvoPtXnPpEcG36WPUbmGTOXJ37X97skwWrf'
    b'6oB97F2SvMbowaBn+0LtGRNsjq06kKvOL/1v8iZvsn37LL9IM/jLO/7Xfu3X3gZ/deXb3pG8'
    b'jci3bJwVH2dL1wbdF19Ixnm43DAHHzTlOxv4EDdzuY7OX+Y6ZZWvj7skcdemY+C7IH7mZ37m'
    b'fC+kP0vI+ufctXlcZ6/HwC2/5/f5oDs36OPfIb4V/LTw78elfDP5pcLtSE/7HR58HxCf/4Me'
    b'v+5XH7fa5cPKx8Bna3jr8Or42R/0wYwVc1Zx6y5W37ma37qp9/qD6uaJ+dDHfGuc61p6b6vq'
    b'hIwmQSec/pk7aVxpP2x18+qDlX2xg2MN8v+2Jwyv9s8vO9zq+d99+F+/81PbL68eB47Z3sVR'
    b'TvLPXrDXz/yzPmEAe026Jqhe6j/21oCXCg90vS+6P5jMv7fe6eOXAf/RfGWDl+y5lza4t+pz'
    b'78feVpVbXvqEob3nMXO+PmY0T/1t3+YtDj/8ZZvregu3Uf2oz/+98x/Kg9W+tZuj3VhzoDZP'
    b'GPjr7/UJnzC49u5J8Al+zvuxT0r5hYv3YNun86DP4wfO33gl8NdTfvG76t/f7ZbN/HX9FQWP'
    b's9zyuXuZesHPL9z84n2l4Fuu+XAxv1S7DvAYrtZmTF3mzz3f/XHsbVU/8iM/8vCkJz1pm2f+'
    b'W4rOQNdWNgd4W9ETnvCETT8tPV/QvoAtfIiXW5S+MsKdCbl9bY+l51IbkB/wAR9w9BOGj/iI'
    b'jzj/hYpAb8+tc8HUhTVBffZQV5qz6rXqLY21j/r0gX7G3M9KArroNweu3ulV4HCDYBIHo4Vg'
    b'sVBnrFjXvjDr7e0wbv18oIbmMlynscrDtZf2/zn4jMItX/bLh5s/7TMPL/jRex1+4xe+5/Ci'
    b'F71oi3mcetFAzy14/JDqjekr/rDIKudYzp+/q1itR+qbNV2fNt+qepb3kJ6Eb0ViLtfImjz2'
    b'+gCdmL5ew7zFoLmvTPQvn+6x4HNvZ9ljj1374O+czrc6B8LbOb70vq9xzrr+wm1UfbLQn9/u'
    b'ax4Xcxx7tAbmz/b1Cdfoftzn3APMf39OA316PMHjWJ/Ux/FrHm8f4sO+/EWTVw95Hz/3j39F'
    b'PlkA14jsY5C4XwdxvjjNf1+uBLwS/A3f8A3bl7VxzObbrXptut657v58MGDmnBbvErX6nWYe'
    b'IyU4v/IstC/MObAdx37R6PUBf36UsJLsU/u08Fja71kBe4K960Pv9ce1MK+H5gO2OehKctpX'
    b'9CGdqz3rr08djHdtPZZAfteBbty6C3qekxs2a0IbTMxrfidlwsbAuBifGwHs5qM7tIkxmGvm'
    b'qV+Vsen/X4InCK/xTy8+3ObFj9ieJLzkJ97r8KQf+5zDk37rsYe/+Zu/ueBYgDb0uDXeHPWT'
    b'4p6zxprjPJcLenXtgs91Tjnnx+b4fOmXfuk5z+WDV3O+7uu+7vz6GP2Z8hrVRhZtJG9BeGWl'
    b'a2efHIPi3j1HxzKPaXv22oRK81wHvMe73uVw5ze+nt9G9Vdvcnja06/+DFL3LtjQfYnHxX2r'
    b'z2PhuD7TtYp7KpdjHz02HF9tcA1ca4zpZ+DjCfRHf/RHb2/v4kkCb8+4vuFa5zXlft0bkjgf'
    b'uL/f/e531GecTgNv0eKY8YeY93qv9zq/DlD3unfdcy/axo6FG4XwGC9dC0wb5nzkrPJOy2of'
    b'vQaR5PBKxisrvO3Ofbgv9Now7dPAh7G5i2J7zN4y5/F4z7nJW9Ux6ofVYwp9S/t1rvYyh9G5'
    b'kK4Te84HxqSxQs75ldlMXaluE32d1BygRw+kuaI9JSjxMQoxejOMWztzobFrZn/lhCcHr/mP'
    b'Lzrc+qU/e7jNc7/hcLOnfvrh737+Aw5/9EPvdfjNn3rI4cm//bjzd+PpsTy//3M+aWwVP8mH'
    b'7AUI2PomK99pcR6Y+t6czQPsDt7uc8wXk53E/II2jglzzfVod+1TP+03Y17fcL9Idfftg5b+'
    b'y8E8fvTWV734eMex/vL7nu3OL1cabqP6bY949rYXjxt7YnCdlblf860lpq4frLGfx+f6hnvo'
    b'PhzSnMuJ//74eOfP+Ar83GL4UY961Pbed141vD7jsTrpmLl3JHee4wvZ+kv0lYLPd/CKA1/C'
    b'yfv/md/j3vXqA89R4yft7WL4byzQp3MBdudTzhrHsTiP2Kt9zXllfsLQPRaPozpon5Z+fhfQ'
    b'29vRx0Tnn7lSvZhbyPUxZdrOs8I5iLfWGn0zDvrMn5gvF+TzGQYOmhNJm7fptMG6Vd6UxoQT'
    b'4T9M6rPOByipbs+J9XCP+937in+G4c4vvM3hJS/4yHPWyVy1q8Or/cOfn3vd458PN/yHvzi8'
    b'yj+9/HCDv7/qAenvXnr4p7//q8Pf//WLDy//6784vOylL7nql9CXbO9ZBI9F9yf6GlOv3+Nd'
    b'n3prVxAHa+jVcwiz/iyfYeh7a53TNZQ9vxjv+vlQIR+qOvbuIoUnIB/7sR97wXEozo9c0XUB'
    b'987mPbyvjPCkifdng/thf/Padc/HfoaBD6RyC9n2BvtL5/Naxdb38R/6TofP/7Dj7mF/XfGV'
    b'P3TTww/8yNXveWbN7onhfqS+7t0cdGgNNAeO/dDz3/7t3x6+/uu//oJ+ruFY7MNnVvj2WW16'
    b'znVPiJ/lGlt9sH5FY+j3vve9Dw9+8IMv24eTrxR+iFZYO3S/c2/V+TArfyx513d91813peHx'
    b'5QEPeMD2PQHgesF1FePG+OzFMZ9h4DajnNP267GQk+LG+DA79/w/hnd8x3fcvkG58zDm4wD8'
    b't//2384/Fr+ywWcS+BK1HkP16eNDz1/zNV+z2aeBtwbe//73P2etz13ngpnTf3uktTD/7Svm'
    b'rXKLfvPbv7ntP/ON9feUxvckbLofej7vuCrYRBvXp669B3Gwhl7+gy179fZuD3WYB9V4pfo9'
    b'PvNeh6fe8rlb3pWCJwxP+JafP2ddDfOv6HFYrVv0ibY+c1c56oCtH9kcQGc9cLE1TRu9Ne6r'
    b'54e75hzD6sN4e8wcbH36u0YkHwhjXC7ue9/7XuvOEh6PwjpkrhnwcScS3uv8ygj/oHPu9vA8'
    b'IDk2l+NDz+L5VYceV+cVvjzqg//d3a7ykXvNujauEpt9tXU1xLa+eK85d0Lo1V/tBocv+ojL'
    b'9wTkRX95g8N7f9ofn7//ffflMdQWdPO6p/pnjujnnHBuTovnf87Vx4W9dVRHNl9fddHPYJ6Z'
    b'f+xdklbXGP2cu+sB/fxiyZ1XGru+wrninLl26HHveWP056s2Nzr4nM/5nOvklRTee84tWVff'
    b'ou8xV5++Y++SxHXA9SDO2zk6F8wcj+NZPvTMEwDOF/S8FP2vzE8YeALAuwB67FY/28BngY55'
    b'wsAfRLiOnMN+UN/8GTAPffqnFGzBb84eja96aZt3Ug5gu1apbh8lucDe5WrPOUg0meHJ0Vfw'
    b'iZOU+uynzkKIrRbvXHv9HNj1CT77XrPRC3tdCa5axfl1uDaGNrAe14TP/MrWNFebnM4j+sDj'
    b'K+peAK0D4vqqg8dyL37NMb4m5nxI9WOYveRifY3NtTnoe6c73enwqZ/6qeeilwduX9cv1fHY'
    b'aUN1j2PXpf7KjvvpEO2en2Owp3Opg3OIcxm3hvclP+InnnDV+PXDD/3Y4w+P/MlfPzz8x5+w'
    b'6Q//sav8P/7Eq+yrBzmbD3lVDr4fuso2jv6In3ji4ed+9Q+3OS4XD3zojbYnC91j99k9Tb/D'
    b'WiVUh+bDjJ+WORd9PQ/YDnzVZeY3T5+6a4auv/7LhfPa3zVov8VbvMX219ErMfeVwL0Aa17t'
    b'Sanuean9Uz/1U4f3fd/33W4q8dd/fWW/Kf1VX/VVt7tl8eFo5ncIevcB2JWnhScp1tq/vfTJ'
    b'jKO7nvpPCz38N37uz774G3tlhPW7H/8tBf3u/3Lv094+3iC1i+swzujazJnM2Myxj8N8mT7X'
    b'2WMEe2vA7xzmVDqA3l5rcP6L22yqxE+i2IT4XKB57YWub2KOedZ1w43NdVgLyqLPfvx35bnm'
    b'uHRPUj/rQuo3BlPawzqxR+cAfKxD7AP6O6cDVnWr/oz26LrEYzHrT4tz2Md1QY9jcV7rzNHP'
    b'W5Ae9KAHLdd9FvjOgs/6rM/a5gClOJ/rwp5rsOa0X6V/fcTz44B5TM4K/TyW2lNyLTo/WCPE'
    b'+rMhrYGZg3Rv6KwBeYub32SLXw5++1k3Pjzm8U+6YM4V7sE1IbFds7in9tHXOn1nxXmU7Tt1'
    b'7dZM36qemPHi9beKXSpdg7QfutceeYwv/uIvPrzGa1yeO27x9i7egvWDP/iD2y/I9OYtFPyx'
    b'g1tDf9RHfdThwz/8w7c7CT3/+c8/V3V6XPvca2Gvq2PpMWLw1ia+IPO93/u9t88bXMknDrzV'
    b'6yEPecjhJje5yTZ3z7cS/LnUVh6DP0/uV+a11vk6f/3Hwjz+rDOwnaPgv9JP3K4k7s8B7Mnj'
    b'zEA/K/bjGMLqcVOcX911Nb9+c6G1e1BnL9fUtVlvf2R9s7++5qvXD+Z6bckFe5tf3AYUtdlK'
    b'r08bkExQm3hzYGXPi766fZQ9uWI/48be+X7vc3jqLa/sZxje6oW3OTz+W37+/Jq7N8G3Wi+4'
    b'N3XBZ6z1+t3nrDVfu/5i71UvZOcD82bfVa2xYz/D4Euv7QXae37oeupD/5RP+ZTtuxKuFJ/0'
    b'SZ+0vT+165SVPY8dPj7k9+hHP3qzTwPfzsn7MqF7b29oDGbuqu5S/MBdqB74wAees66GnHkt'
    b'AXVneX+598gHJMdSfYX+uX5wH81B97oxt77m6X+3d7nL4Tsf8Ddb7Kx84Bf8w+EZv/8Hm975'
    b'Ab1zd20ea2gNzP3s8QZv8AZHfQ9D35Ikzt+17M1vTmsmM8c9m2tv5eX64rY+plQCOr8o8+Hc'
    b's8DP8A//8A9vtxTl7ZzYnUP0Cd818UZv9EbnrEunj7Mw55h+Jf7qoO01xnv1OYY8seHL6K4E'
    b'fDcHn5npNQ+uSVzvsZ9h4Fx86Id+6NbjpJ8h7F4n+go3Wjj2MwycLz/D0Pk7r3CHKZ5Mnhau'
    b'eb5Pp3uA2p2nPtfUOrGmOXs1vGLVbxU3NnsweGXrmLck8W/PZ3/2Z29618D51SfE5vE1H6yf'
    b'Omi337yGjKlPH+hn7D0WIX08BHxi3FxZ9YD6NpsnDH/+539+tXEu6GQmtdgcqL84waoXcm7E'
    b'vNl3VWtMnYE+7XKPz7z3lX/C8KI3PDz+m3/u/PpgrmNF89kvuA/3D+6vUlb2PHbmMOoHYlAf'
    b'tLas5lv185we+4TBD3fBnAOw57UEq1x5szd7s+2uJVfyg4h/+qd/un3hE28jYR2sx2Oi7bFx'
    b'rfUBtyb1Q32n5a3e6q02uZpnMv3qswa597OI7NpPwhzq7XXsl2r5/vK5FvsWczr/ZOawp9XP'
    b'kFKfGPuo//DOhy/5qP1vVr9UHv4rNzk86JsufJ/zxdYAq7i6WGOutIZXzI750LNPGOYaBN/0'
    b'K7uemXPSNYbffNA2/3J86Bk6B3QO+K7v+q4TP79zMXg14Qu+4AsOz33uhZ+5Yx6vReebazn2'
    b'SRG/gPLKgL09dtB5VzRX7FOdx9v3eZ/32Z44cOeoy8nLX/7y7cvYuIuR83mtdC363/3d3/1M'
    b'TxiE3j0nyPqga2BufWd5wtDPnNhb3LcxXvH+xE/8xHPRS4fjw7VsH/ZEbyQ4D8w1TBvsAa2F'
    b'5s9adeeeterHfnEbj288Yeja0Oea5vqb0zhSus5VjrWdp8w4nJSDVJ/+kyA+195a943+KjgF'
    b'h4naSnWLofnK1jYm2vWZZy14Usq0wT6dt3Lre128Jenc+pm3o8w9zjWDe+wPhjp5+pCrenyt'
    b'BX0Te7hWdWEtDPOaD+gw6ztX+50W97E3J2ub8wE+a1rH+165m8eVvmsJv2jxQSrXXrBZr8fV'
    b'Pbofc3iy4Z2xTgt3LenepWtBd16HPo9r6/WZ44DuQR+sfILPcRZmn87n+pEeb32gbn7rGOYj'
    b'1TvMB2zl7W9zjf9YuI3qtz/i6s9COJ+6cuqch1UcurfqSkf3ehbao/0dzsMwB1a2Nf35AHMA'
    b'vbkOY8fSPn2cYS7XIbw15iwfMOVDsLzViD84tD/zqyNX+5prOQ32aQ90BzTnYn5jtbnXPX8x'
    b'vs997nP4hE/4hAv+cnxWePtX79DEmjo3THm5YC6PAfg4CY0hu56zQp85j4/Dhe/LOAb+DfHn'
    b'rY/9zuU8SP3qPtbO2F6tMXBOwOdjmjnWmm/OWbDnCudxfgZr9Fg791wfmC/tAe6tPuu1Qb0+'
    b'8uZcE+ebzH7tIz2HzTt/pHE2iPTk2XArOHegHNBaD4IxJeA31lqpztza9cu8sJy/84En9Ipz'
    b'bo3uretw/a6l+5o+j5/7UzcurV3NVfDNNaGvekxJjj2nTi15DnysFd1Yz9NpoZY+DOeF9nVu'
    b'dSG/MWy+POlt3uZtNvtK82Ef9mHnf3no2l1Xj7txfYCfL5U5Br7syL7df/t7TIk3x7WAPcDc'
    b'mQPWIzsH9DyB89rvrNDPdUF729+4OSuaqy7tyX7U7Tftt7nd327yLDz4ETc9vOAFLzzfG5TO'
    b'g+1Y5RkTcvyZsocS7FPfscy+XVOvCfKMWeM1hL/Xk7lKdetK48jLhX2hvZHcCnm1lkuBOxV+'
    b'7ud+7vaec3u4d4/XPG9dx7Hzgn0A3X6zZ/N6XmBVo650H7xyyltC+ezF5XriwGOtx6fHpWvu'
    b'2i4nHrPOBexX317OsbRXe0/J24qO4Xa3u9057eq52re610FjDEGfx0G9tfqkde0nxJxrVX8a'
    b'nIP1qK/61adeqd41oYtx194amHp/xromdK/1eQzbQ8hrfeef2IO4WM9c24eehUSbARKfB1La'
    b'AJzAemTzxbj9obZ9Vn2hda0xj176ql+12k2/opzbLuvo2sC1FGNK14+9rflcn+bpY+hjzPPj'
    b'MfU4Cj5jQE1z26f1+LCRxl0rELMnoDd+LK6nw7mcT51Y85sDPADyzaTXJV/2ZV92eK3Xeq1z'
    b'1oXHiePj8XX9oIT5lfWXSt+SJB4XWcVYB+vSt5LiXqydcWB/7hHZfOsZx0KfHkfBj69rcl6G'
    b'8xrv2lZr0la2T+d2LW9527N9foHbqP7oz1z9QWfXCMynreyapHsn3pz2AM83mCfTPi1zjcW1'
    b'QOPoxKytXshrrjb7mfk9R6fFXvZ2HujczPGmb/qmm/8YHvawh13wlhqY+wDnBuPu+UY3utFm'
    b'nxZqGe0N+tWJO2ascvZZ2eTyxW+f8Rmfsf0h59i3rcod7nCHrac/g+Lccw3HYh/mcmgT6zzT'
    b'nms7FueqPiUwF99Tcwz8Yc1X4u0L7AHwoXvtYTuvUozNPI/H6nyBNR2l/tadlq4HnMf5RZv1'
    b'ds5KY+IewTwwB6neOPTYgn2smfnY9gLj9GE037z2YjCHeUjjjguuXos8cGCRTdBF3Rg4oZvr'
    b'JvE79AOxztHNGduDvFmP1H+142pxRbnIHKyFfXXf4BpdvwPMnzVgDszj1ZicPxZXUZ1cz3f7'
    b'gH59PZfonYtc++p3HEvX2bnaH928rlcdWCu/vHPP/WPgPfbH4FuTPK6u1fW77tpIffyDegx8'
    b'qI96+7en6EM65vlGtofnHGZvpRCf54OBf3U9H0vnpbfr8pgDPvTVGuWkHPcBjRuzFm5+85sd'
    b'XvVVL+xxWh74sNe81ncuIKszn7Z6/fMYY7tG65ov6LXPyuyP7RDjc15z3Avx7stjD6s5AP/s'
    b'e1roterROVjLMZ8fkPl9Ap1zby/6kTxZuMUtbrHZp8Vrg96dSz9yzmsclNb682I/bPtI+/3u'
    b'7/7u4SM/8iMP3/qt33rOc3puf/vbb9K1OVzT5aLrBvs7rzqscqfvWDymMOdTksMNbf7kT/5k'
    b's0/Da77max7e4R3eYdO75u7B64PBXPO8i/mtheaIcXuZ07lWtO9pmbXOoR/ZeT32+B3aBZ/+'
    b'1rsXUFrbPPTaYm6POXmd/2J9zNdvbX0T/Oc/w4BhYgvUbYS0BtQryXMj0p72sAY6z8R5C7Z+'
    b'pEO0ia96Xgmcr3R9wHHRpwR0B1hTX3UvWutlr58Yt9ZBvz7wzzowZ8bR2wuqnxXnUtK3eqV7'
    b'KLz0fde73vWcdTr4YBpvFXjc4x53znM6eGvSu7zLu2x6j0fX3WPZffzmb/7mpp8W3hrx5m/+'
    b'5ud7eX6qd050f17n8avdWnVQgrFCnEEvBnF/DmbuaXBe175aD6xs551rqI1kva1vrhA355a3'
    b'uNkmj+W3n/Wah8c87vfO93OtjM6j7XpW/pnvcRJjnuPmXw7oO+cE1tLh/IAt6s1TB9fbNbeX'
    b'mH8sq3rnrORGBcfA/f3/9//+39s83Y+y8+/p/IX9WJxXHTzWYFzbc1rbnDJr1PE7hGPwHd/x'
    b'Hds4Bv4YxGfUmKNrUZ++Y7HWnu3ltTdzpDX1HwO9HCf1In7sF8RxdyV606Nor362pWua9WIO'
    b'0qHtsVzV4nPUPgbm2uujzVrYa2OAH5/rVteWlQ9aN/uAtsdZaT7059RjBvjMa7/ZExqvhFl/'
    b'/gkDDdAZJoBxfW0A6NbodzHWQvNgbx7Qj5w52j1Qwrz6zd3Gufh1QdcLrqHUdq2suyfc82Eu'
    b'ctrkIFsnzRPqAZ86sn216Tl7WDdrWqvs9XQs1ruWOQ90DuJee+q3ve1tt7/yHwMf1Hvwgx+8'
    b'9eGWbdjHwKsb/jLhflw3w32BNnPygbWnP/3p5yKno19KZ0+Hxwg/NKatnLlK9mBMjIE9yGmP'
    b'OedZaK9JfTPuOryu7CP4HI1ZA57D2fvWtzjul0b5yu/+q+2Xp7km6Fxdm+swro2cfbDdg5jD'
    b'eVLvXMfSuZ0TX9fqOtWlOSusQU6dfbT/SX3OinPDsU8YeCsSa+41tVqzMfGY4nu3d3u3TT8G'
    b'6v0Zde7+zJbaXQsQW+WzTnKNzRyw1/d93/dt3z1xDDe+8Y3PaVfjnF4PzjvXfRraB3rO5r70'
    b'y7SPhR7OZz/nNqaO/7GPfexmnxbuasWXENrb603sD55j6TpAvT6g3h5gHB/6PHdF3+xxGujd'
    b'Nc0+tfszAsbcu/6pe420F7o5E/fcHpdK64B5XHfPkXmuS792qb19hsFGBNDBBtKmYs0KYoye'
    b'cMeEuPOag69M2xyHdvuf10ftdYXzK93DtF03Q93j4ckGY5XE1aXxCX7o8ZaeK/vqL+SYpz1l'
    b'48dCD9bZtcCcR1vM5S9OX/IlX3L0e3v5Wn0+eMwanv3sZ2/2Mbz+67/+4XM+53POr0tJX3RH'
    b'9+X5OfbtUPe61722AfRbzQN7x65+fK7HtdnHnoAf32pAa8TYMbSv1Fe/uA8wx3XrA6/5ud7+'
    b'jFSaf5tbHf+FXQ//lZsenv6MZ266cyJdn3M7L0xbWj+ZP0+A7TxI93NW6Af0Z9SuDtpIfdI1'
    b'EXcI+eRA6zvPsVBPb0bX5Rr0HfslWX7OyT6eH233VboO6nkl8yz0GDF/96r0OKj3fEDzBL1r'
    b'BX3u017o3Eab25ceA080PE9C766HOeZ6TsOsnesX5535cz3H4rFHtqfzIR28Ss5tc08LPflj'
    b'l19C6JzdE8eavM6r3XV5fBxgDNqnNfrKtMlpr9PSNQG9eg25pjlP9VkP+pC9LudxJN859JlT'
    b'Ot/qXKA7un7q7M3oPOjkNsaYmLN1nYkWM4SYJ7020Ex99lEyGgN8XayQM2uMdw09aPY1X6pf'
    b'Uc6tSVyHa1V6IrH1SW32Rm7XT7w9YcYZHiMlwzzrPXb6Z05pzsT+rRfs6TsN1M459+ZZwX36'
    b'+S6HY+DuEt/93d99fm/AFwQde9cJ7ufOrf88Ju7NtfdnqHPy5W18cdMxfNVXfdX29iRwLuer'
    b'3nU4t8NrcK6NAcS5Bd+nfdqnnb/eJp1T2fmOxVp6oVe2/2rt/dnquu1BHEnMvPYs2MSoud1t'
    b'rs45LdxG9Tse8YdbL/uB64G5JnPAHGmf1ov+KRnd81no3NC57G8cm3nd42qt6o55bjoXaE//'
    b'aXAehrZz0peh79hvZ+cPGnz+of2UgA76qzO449BNb3rTzX8MzuV89tZXP48pvHrprZuBXM6X'
    b'NuCD5ky9+UJsvlJwKfDqL4N65650rr15j4E+zoHuNYvP6wWcE7/jLGug3rnaF2Z/JN9T8ZM/'
    b'+ZObfVrufOc7b6+y3/CGN9zs9nYuhrgeZH9uWO9cs3303/Oe99w+fyf4yTFvj4vFT8L1M5f7'
    b'QLLu2dfc5pFTe0Kf6bdGqW7MYV3rzb8YzUP2epz12q4BqgM52znUsEi9i+7ibaRf3ZPuAdI3'
    b'ezCKJ6Z++xZ8HeCcYH3nQPZAXVEWawbWyjqUpXuBqV8s3/is01avTY3Hzfqep/bUV1td2Ryk'
    b'dn1nZc7nOe21Uwl84Pg//+f/vOnHwFuQ/IsVfZHYx3w5jHzpl37p9oU94M8JuCdk98F4wQte'
    b'cNQ3PgO/iHznd37n4T3e4z2u1Rfd4R7BmJiDH5TU8KG4r/iKrzj80i/90vaEAR9Yr/R8zb5n'
    b'pWvtnpyP9TBcM6C739aCNqBba29QrwR05n3rNz7uDklf8/CbHP7s+c+/1nxK6L6a5zrMNSbq'
    b'5lEvve6gsc59Wjp/ob/7cC1I5kJ3jSvMgymNaQO+vV6XSvux7s7R/vj4WT0W3v4B9uy66V0/'
    b'wzXwRWh8YPgs2M+ezifGGHxbM09Q+Db5b/7mbz6813u91/ZWLI+Nde2pX13w9XoA3gLDOC3e'
    b'grpzei07Nxg7FvcH9MHWZ9/anfti1/dpsCeyPZHV5RGPeMT5mtPCOf7Gb/zG7XtG2rP6iq6l'
    b'62R4LG5+85tv1/CP//iPH7792799++ydWCPU9VrBnjmnxfXQA6kP8HkNTcxfzd2fBeqRc929'
    b'NlcSrNXnXM11ng5j0HWoQ3Ohcecp+Bjnj4ZJLaoPOsEeLmT2sBYbvQejOQwPODke6PYSe4FS'
    b'jHkgrkuYd64XH6N702/uKl+0zZvHj6Eu1QtraK3oq+7xswaca4+u7aS8i+E8DNehrxK6Pt6K'
    b'9EVf9EVH/aUKeBsQ7/t0Pub2vOE/9hd43pr0gAc8YOsl3QuoI83jrVC8r/0YeNLwTd/0TYcH'
    b'PehBh1vf+tbn98EQded2aHs++SvT273d222fCeFbZXkFhg/G+dcnsBaoA21k9941HIvXBSBd'
    b'q7Zjz2e+o/RYNQ+sbw3X3Vu9yemfMLzoLw/bbVRPwrlcD4P1db+N166OdF/UMsA8c5THQv2q'
    b'B3Pjcx2uRVtmPbJ56saxTzqXlwOPl2tjlOc85znntNPDX+29UYG93YNzum8kv6R//ud//vat'
    b'0GfFfTivuvMj53WCzbcrf8M3fMPhMY95zPYYw9ui+CZ9WNWK8zjM5fHxa7/2azf9tDzzmc/c'
    b'+tiLOef1BM05Fuvt1T0omX/GwGPRtR1L96QOq73+0R/90eEnfuInNv0Y+HbsRz3qUduTB/vO'
    b'vU2IO1rD3bze//3f//D//D//z+GXf/mXD5/3eZ93wXUz8wXd44fOMSRH+1hm7ezbdTi/vg5r'
    b'kOqrNSpXzGu2Nn2cf0Kefcmbun1ci1LIMXfGBP/2oedNOXeBm1y/GEMSV9cvzXOYTz90R9FH'
    b'jvNa6/r0gfn1m1v7qhVs9pWGuYS5nV+qA3EvKIbrJs8h9ZErvVCa3+MlxPUztF2D4GfYmxh5'
    b'6IDdC9CexqH9zgLzOBf9mQvovzcHXxPfb/48DdzO8uu//us33f4eAyVx3mt7DLxNipde6dO9'
    b'2Fu9fh7sf+iHfmjzHQvz8jX4vELCgz9vYaA/OJ/nWPs2t7nN9irCx37sxx7+63/9r4df+7Vf'
    b'O/zAD/zA9k2tvIIz8XoRe7kvUEL9x2J/6fzCvnoNOa/rmzX2Mw/cG9Lz1lryOKY3POKWqg98'
    b'6I0Pf/M3f3N+TaDu/JfiX9E8zy++ea6rz97HsKrF57HjODqPa+maGMTVe9zn+pqjrQ7mnwXX'
    b'5rq7Vjn2nvfA+8S///u/f3sCzv3v29+9MC+vUH7Ih3zI9ssff5m9XDCP+0K6L2WP54S1v+d7'
    b'vufhi7/4i7d1/eqv/ur2ePFxH/dx21tCeftS+zuHg18WP+mTPunwIz/yI0d/l8Vv/dZvbWtk'
    b'HvqjOw+gu5fLAb3az+OjzzjzN6bOes6Cxw7ou9pr5wP+gs/jzLHw7wFPEHk1gH8T7nSnO10w'
    b'L6gjifHElrx/9+/+3Xa3QZ50cAth3trGv0P8kaV4zFy/ujH3g79zqR9Da9vLeQvzNz7zrdGH'
    b'rE8/6N+rA49vc5tjjDyxX/MKdo+jWKdeCVvPq36g/5l79YrNkFvCVVK9cRaovFbTq3LK9Nmv'
    b'PnvoZ/TkTMzb6w3G7nG/ex+eeos/3XxXiju/8DaHx3/zz12wJnXX40md6xP1Hn9Qby40B7TN'
    b'RXp+sHu+jElj5gK6zP7FGBjXd+yX8vDtnXxYa86H7vom/JWK92see8cS3q/JL8UT9+ae+Mf6'
    b'2L/ucfejD/7gDz785V/+5fm+PS/gPPpf53Ve5/BjP/Zjhzd4gzfY4peD5z//+dta/LAm//Dz'
    b'AUpeeual4r5ycCm89Vu/9fk9eL6U7ss9eY0Dr1Yccw97PhfCXxbFnp0f6ut1vsqD2UepDq3V'
    b'f6c7vtnhJx989ZcdXSq/+cwbHz7ui550/hUk+szePVbinEqG9PjixwZ8Yj/jxjoPvyDwJPO0'
    b'cF37LefQdXSd6p1TrGHM+PTVVme4J+blVcNjrjGeaPNEoGtB9hgDklt78qT62Fc25SUvecn2'
    b'QVXeZsPnIvi55Gfyjne84+Eud7nL+fN5ubjHPe6xzenewHNVH/KhD33oBef2UmEf3DqWx3N+'
    b'aeVY8ZjGt9L7odpj4WeHJywvfOELz3muxnV7joT3yX/Lt3zLOevS4cPY97nPfc4fmx4fpDrD'
    b'nKKf64Ynfsfe7tR/F4trANdRnPsjPuIjLsurUsLnI/ieB76pnPPA3JxXfgZ4JQH9NPA2N15R'
    b'dz8cq3ksjelDf7/3e7/tbcSnhcc3XjGnh3Suea736FrM8/GBmH20lWINtFdzYFWHzWiP0hxY'
    b'HU98fTxrXB9ye+QxOJtIdaA5uBDZGuYA63NCMc5gkcVcF+8gt31cg/MZQ4fWXRdcNdsFa3I9'
    b'SGxjYMw814js8WjcGlBvLr6ecKhurMcDH3bnF9dcn7n0sbfxuRZp/TE4n7q4BofHl7ciHftk'
    b'gX8QHv7wh2+6cyFdg+eD8chHPvLoJ0I8qfnsz/7sTe85FveC3+PKPxC8BaHH+azwFqW3fdu3'
    b'3f4BYvBdFfxSgv+0TxbE4wMeu+4NsN3jWekcziva8zr3GM41ECemH4lPucK+zHXrW179+ZTT'
    b'8FXf89LzH2rvurp26N6cc+rdj/mu3Rz8qzzRRs7YaWgf5tauDl0LuM7VsbDWPUn7oRMzjm2v'
    b'Y7AXg14Oe+pH8hkn/rp+Vl7v9V5v+0zDp3/6p2+/zPD5IH7R4wYG83hdDlj7PKZSH/s8Fp4g'
    b'8OVqvKWRxxq/K+asTxbg53/+55dPFuaxcv2rfZ4G6tvL819bGkee5VqcOCd0DmkcmPsHf/AH'
    b't7eQXS44f3wHCK9Ec155RYkPSt/udrc79ZMFcB+u3euyezGHmPpZ8JjZB9tRX3XA1q8PPMf6'
    b'WjsfNwSbmH5rzLG+0kHO6lpvrXnAPOitRVeCufVtORY5ahf8jm5MaQ54Io3rl/Y2R33SWPt4'
    b'4JHM55rMOannleHaT360V+uqdI3Irrd1+rHt21x8tZtvD6T+nqOVLXt5XYP9wTzn1T6WWW9f'
    b'9cJbkXhf7THQi7frsC909olkfnRzPM78NYX8uYZLxbsmeRyF3u3p3PDbv/3bZ/rQ9ZWGdTug'
    b'e0F6LOtHP5Z5rMB5pHPWT57nsn6wp73MmxD3OiHnNrc83S8/P/jLNzk84/evfoWka7Gf8xsH'
    b'cyauA2kv7BWzl/NYezlwLeAczqMu+gHpgB4HhrXud9Yqm6P/GNoLPLYdPWa8CviKZP7ifKl0'
    b'X9oeO+T1FR6H+bK3eZ5dd33uo77TYq29tSuJeU143Yg15h9D51rJuU/X6s8Df3jiNuHXR7p2'
    b'jqHXocdxtTdi2sdCH3ow0J0H1D1+0NyeY3zmtQc0F91rBIzZszHAD/bs/I4y/V0jOv2p9/ia'
    b'5zxg/7J9DwO0CNBb3I0q3VR9Kz+ou4jVYmob7+h61NsHvQcGe8u7cJorBnO71tqijnTd1eH8'
    b'ms/pysaluUJej4Gszl+lF446YE+fkn6uq2sw3/nm+k7LrNdGVuctNLxH8li4i8STnvSkbf2s'
    b'nX3a3z11Tnzk+4rEMXCPa95qUDoXeLwBH69scOej6yOsr+v3WCK12Y97av5ZoZdSvfPhQ3rd'
    b'9vot+htDh+bqa883vfbHOnbZbqP6yD/c9M6DjnRoMwd0DWIew2ML1OgnB9T1M2TqtU+Lc4jH'
    b'SNDNmVLdvPZR95x2j6V19joGesxeq7kcT3ziEw+/8zu/cy5y3fJd3/Vdh/vd737nrNPh9cUe'
    b'wPM1939949u+7dvOf1cOuE7XDVOedS97fbSJdz0+RpSzrkHsz5wM+yK1uxZ8vGWQV6+e97zn'
    b'bf7rG66T4XXo45p7Yrjvs0AfsM+0izHnX4G/j03S/oyT4oBtrrajeHzMB/s3t31E3fw9mnf+'
    b'FYZicyDWuLYLXaHfPuZqI513zlU/sgd15jIm5iDP69fBMwZm6AND1wra7s1Bfi98/drEa09d'
    b'u0O/zB5KaUzdHgywBzRmbnuu6o9h1Wf6tL/wC7/wWr98Xyp//ud/vr2n1TnA/SjnfMAx+dZv'
    b'/dat/hj4MCBf6NY5qoN2Ya18+Oz6BmvmmLBmfxbqk9V+zwq9PGZgXyTzi3nmEq/deHtoT10b'
    b'3uZNLv0bar/qh26y/TWY+h4zpNj/UmgfhnsQexvz3EyIS/XTQm/n0tZXtGec9cpqHTNvlePc'
    b'7XUM7e06u1akNpLPQR373SnHwp3beP/3U57ylKO/+Iz1e510f1D9+gK3c+YzFdBzUrny9/Hg'
    b'tNDDYyRTd05tcG71s2B/hj/z+sU9uh6o5HMHfCj9Wc961ua7PuFj09yPPvbkkOaehnl8GPP6'
    b'aA5od4B1XSvDfGSHdcbm4xQ+sdelYN0q35jzI9WlduPsa3uFYRaqA5vANzczG6oX7dmfiZvb'
    b'GLIPWs5jTXONgX5R33pu2pWFOTo/eMxWa2N4YaEjzdff+pMw76TjYUxfY+jGm8dgLfRnWDNz'
    b'CrGue8ZPg/P03HcdSHLufe97H977vd978x3Df/kv/2X7jADzAD2dW30VYy1/8Rd/cXjIQx6y'
    b'2cfAXVG4W0TnkM41edjDHra9v5m/Fl1fcL3uBek56jUhns9joS/Y0+NHT9chrgWQjq6r8dZb'
    b'a98VxN/yjS/tCcML/+IGhx//2atfzWLQ1/n1dT79oARjzdUvxDgu7eFxwldqz9gxMJ9zuVbX'
    b'0P76zAHXDKs6bfuD57K0zzHMWvshXYPHXvsZz3jGUR/APBbuTPTABz5wWxeDuw2dFtfvfpHu'
    b'R6b9ioTbcfYzXa7NY9D1X4l109Njhd7h3JXmoV+Oa9JBT+A4aNePDvUjGc997nO3Jw3H3Njg'
    b'StG1Czb763FTXg6ck/4Mf55L5/UYagO+DiHuuRHj+BzNQbaPOVMH8zw+9c06+5ErzTGOpJd9'
    b'7L35t4yrMAg2ABJt2ibFBeifOasFMey7l1/ZTZrvMK89jG369v/rBteD9NiVxl0fkCv1C/u3'
    b'dtLanovqPUYOfI6J8eZB9faRmXsWVvWz981udrMz3fXh13/9189/rwJ7WUmve5nr4g4sx97x'
    b'Ar7kS75k20fnZcxrwrjz/+Iv/uL2WQi+ROn6AOtija5vteZi7Fjo6Zyda54vMG6+eIzxzZ+X'
    b'xgB7zincUvXVL/Fz4l/0sNfY7kxFH7CfNnROY0jXBNXBems69EN9Yn9YxY/FXu2P7uOZx1zM'
    b'Me4QbXrMNWOXxs/CnK/z2L/HlrXz1sGv+7qv23xXEj7EyuMH33LssfyZn/mZU90+0725L/bg'
    b'vupXviJhj7wlkz+WsMfVOuf6ARsdOa+502LPSs5/rwHnUgp67WOY/ZiDwb46H3bj6oLN3bH4'
    b'glNuFsIfv17RuHbXyR48rmAc2dF9nQb7MYfHC91+83g5l3mAbV7Xqt/e0HqHNAb2dF0MdHuB'
    b'NeqtnTFl12iNedL1Nn97S5JQ1EJjNtTuIpo/DyBxh35rWqeubD6DxSP1gzH9ezHtK07mc49d'
    b'V9fnfub6VtI6dIcYox96Y81FNq5tfWXrtI1XF3PUa8PMP4b5AyLMw1+Z+PzCMfC2AT/o7Byu'
    b'f+6htrrXOx+8O8vbEHhrEg/a9O1c7hXpXOj18z7U+9///tt9zF9R753myRJfPAWsvcfHtcLc'
    b'F+g7Bvp0LsC2f3WYOb2u8NkLVmvE55j5t7zFzc5pJ/Mbz7zx4bFPePKm+3NrP7G3x4+hv/qs'
    b'V2dQqw8Jq/0Sh+Ypz4r9O0992g7PDzRezJXmOUdZ+Y5hrw/zsm7PhT7G937v924/m1fiVUDu'
    b'yMQveT5+gceAJ6M//dM/vfkuFXq0j9CPoe/3f//3t8e7VwTc9IHbWfOWTNbqcRbPgcfBmBIf'
    b'tOa09Oeqc8Gqv+uExtWPgXp7+hiBPX9+HKu5PNfEOJ/civx93/d9tw+Qe5vt6xKeuPA9Ebw6'
    b'xpp7Lbo/bYfn4ixQ7/Gxl3b9xnq8iz5rBJu9eG6wW1+79cYrHcX12L/HZNaeFHNe6Brs7/k4'
    b'/6FnsNACF6G/DUDdPP1Cvv3PT3iuxtE5m6Mf7CHala6huef1c32uNK4Xug72tVqr+e6fQZz8'
    b'9oL2Q3fUhh5fwG9ffe3t2trDem3XC/oamz06X+c6BupX8+Pnftp8Icyx8P5XPjDnesU19zzp'
    b'a577Jo8+3D/6WLjDE29Nop89nQvp/F1H/dy3nS/T4R9U7tRyli/ouRR4OZtvembdPFl53OMe'
    b't/ldk8N1lmmfBedwPuH4NdZzCat1gTXWldYq1W91i0u7heBXf89Lt3+grfM805vrCdBrr+YD'
    b'6wCJ3X6w0pGgblymfQzOMfuzJ+f1nAh+YzB7aIO5feyxn/bUj6FrqgT7ep46v7m8dYZvteVt'
    b'Q9adFd5CQk9+yds7hqe9WxNrba/u0f0w+NJKvu2Xt3E++Yr+GhAAAP/0SURBVMlXP/G9kvCz'
    b'wn4/8RM/cXt84zMa4HXk+S/4XbfoOyu9fgF9tY65hurEzoJzqiu9DttfH3R9PdfqvMLAZ/L4'
    b'TgveUsdb664knNvHPvax281K3uM93mObm+9zYP2sde/adn+eC1AeA3O1T48Ttsdwnr8eb9Zq'
    b'rXmtq25u8xmzvpKY6LcH0N+8+pFd54xJ56o+ucHd7373f+YkOVmT2hCMuTiwbmIvpAeo6Jfm'
    b'gzqS+WYP44zGtMED9c73f58r/sVtb/WiNzw84Vt+/px1zX6gx8t1YncPxpunvz701fFvDzjJ'
    b'rr+9wDxG+yJX58BzYx9zwZoHPehBmw2tF2qAmDrwoMVf0sC+lZ/xGZ+xfTnMpeLc1PISPt9G'
    b'6l9T8DHA/nNPDI9B44C80Y1utH2/At/Uuoe1UpsPwfKgucoBfFNneL1bh+SLc7g39ju/8ztv'
    b'X/bEPc/NO4Y//dM/PTz96U/f7gz1m7/5m5vuWspcj5J1dc3awIc1b3WrW226mHMS3h7QeewP'
    b'cw2C3XOo9Do2v/EeN/3qgP2hH/iOhy/7mJNf0v+BX77J4Su+5QkX1NtjtSaYOXOd5sHqZ3D2'
    b'6Tz6oTWAzStf8wuuZq164dvS73vf+256+1a3tr0YHuv+bO1hjynFfkj24TU281aQA5/3eZ+3'
    b'fUAU2zqlOiB7XqBxdO5N/0Ef9EHbX3I5tqeBP0j8yq/8yvYtu17z8zro3PCABzxg+04HmWsT'
    b'H2dXPQoxc5ybL5Lk/vs8xrzlW77l9l0Lx36Hi/zhH/7h9jjDHaf4QwR/fZ64hvkYfNL6gZy3'
    b'f/u3317RXeEe1UGb4871gO1crsPc1qBbK+bzvRQ8AZLm22MFcV654gvT2r+6PabPxw6YtSvw'
    b'883b97znPbdjxndn9Ho6LVxjfAki5/b3fu/3Dr/xG7+xnduutWv3uBoTY+oM/nDIN42fFr51'
    b'mlfqwHlWa2gczJmclGPMeHPn45117hPaqz2U+Fq3Ot9znpXP3BXnv+nZJIaTrnACWG0G2UVq'
    b'I61dLWY1rzVg7Zxzr3/99/jMex2eesvnnqu6MvCEgW96Zj7oOkG/+8HuGl2zTJ91Mv3Yq16t'
    b'63lb1VvbmtlPsOnjOTHPWOtmT8CvNIbs9YFsr/q07QPorEUaA2pc7+pYWI+sDp3PNRgDe5pn'
    b'DrRmr6c5l0p7ItWNOQ9+1sU3OPPgz7f38iSLL7fjScVrvuZrbk90/uqv/mrL40GdX/iw+Sbo'
    b'F73oRds3tGKXzuE8XYPzro4L1Aetbe+iv7X6BLu9QB1/55zrIs96qF7MVafPF3z6PQ4f/177'
    b'Txi4jeq/+bT/c3jBC15wrXmgcyob13a+HodZi22+crVX5aS+nofmIz3u9BbXZYy85oJxY64L'
    b'1OtHL3Pd07b2JD/0mAj29KNTa/3so73SoTVypzvdafsFmycRPJHh55E/NHDzBX4GkTxJf85z'
    b'nrN9QSQ/i9TbC9A9lnPNnW/WqMOMwYw7BxCbvZDWAvvhyx95MsHbRdmbX+KFTi+/qRjJHyz5'
    b'6zaPMwwef2C1N+cT9NXeXa+45j2ot/dKMuipD/RrA3rXLc2Z2MNac51TsMH43Ddgr9YFxpCu'
    b'EdTtP6mfb0vn27n58lGePPBvB/+OcH55Sy7XLv3494LBueUx78/+7M+24dvZXIusbFjl6GuO'
    b'x1uftC86OTD325zWiHNM/8zVZqDvsZoDWjdzqrsWc6cuqx7dh5I8c6e8wMcTBm4LaQGYtLeo'
    b'+gAbmlc5F0jezLWvYM8LoDnGu8ZVL/R34gnDlX6F4YW3OTw+rzB0Da4P5tpkL9cLHL02+3b/'
    b'Qu3srTRmH31KfbCKA/6ZC/pl2ujzPDWn/eY5xW4cWjtpzB76tAs+56t+Uo3g7/khV6xpr/Yx'
    b'F19rZ96kdeiud4W97NfeU2+uNmj3uIg50w/WKfWB9h7Ema/Xd3us6vER6xzTB9YinaPx0np1'
    b'66sjH/51dzvc7Q77bwP78h+4yeGHfuyJ5/v0Otcn6nNt5jHQyyrPHPX6tKFxwV7lTFoDXXNr'
    b'kJ5LcsRc40gGfuunLdYW89sLzG1M1Kcf5hrK9NVGn/u1Pznz/AN+hvZkxtDpMY+5dvOrK63t'
    b'upTQWplzgXnFXrOffmlsHh+YawPt2UtWuUh66QP8zmMOcqLfHKgO6Kv+6LWV+LSNT4yvzifS'
    b'Y2MvpXpzYPp7LqG6rHKmbw9ynLvot9c8bjLrVzbgs5+o21/ZPOtWx6g6svXSWvMm068+a5yj'
    b'NnFA7s2j3tz2gFXfKcU80N+c7UyxGMBJc5gN5zBPuzo1jPaV2a++go0f7NecvRNYeV3TNcv0'
    b'aSPnOt2nulLdWsbcv/1mnf76oOfZ89R8a8Q6ctWBPHpNX+3ZH5xj+silnz7i5tjT+VoL6K1z'
    b're51rh1qz1jnbN8p1e2/N0DdXPr2+HWNygl+x9wzuO6535mvziC3MWwGtAc0D2lcOePS8yqt'
    b'nX2Q7QXq5mCju1fzGfV5DQA+/chSW91a85GAzmCet77d/pMFbqP6Ez/35PN1SGo8786z6r+S'
    b'5jUXqnusZ614bMB1WK+sz34T/MZaV7CZr0xf9davaoX5mBuUsJrLtRnD5zzKrl8d2VzR15iS'
    b'mrkfRtcoc13Yzqk9dW1qrLeuzNrGrTWONGfm1mc+YLsn8zsf9Hgr8Tns2Tp91kp7QHO1J86B'
    b'9DoFawC9Q+ytz9opJ+0Bs4d9pX1mXnNXeYA++1lXKeZOf3WYNnAMqVv11j/RZ277Gtuby3xr'
    b'oTVef55nBxDzGqLGtQt51ol682DmQX3kzxpi04+vayaGz9zS3nu9mgP2LNrIzoPuWozVNyG2'
    b'Hc0mtPkenRBmrn7oQW1+a5oPxsybcaAvtE9PwHXOYq3o7kHwzfVpm6+uXZ+6+y/u32M+64Fz'
    b'zbDePGlf6yqpnfn4nQumbb6yefSb+UjX0Zj1c39S3fjMwa5c1U+56uFxwI+038yFHjNl6Xz2'
    b'cggxB8zzANrz3OpvPrq9PJ7WFddUas/zpL4nZw77APzG2h999mmuPR2dA7k69p1zYsy5JtTM'
    b'OfnCwJNuqfrAh93o/Nssisedfg6Y/aV21znrZK9P/eiuA5oH9oa5XrBesO3hGgU/vlkPjTkH'
    b'0mGOunVdk2Dbi/iMXayPMdHfmJJ5jMvsYczjRMz5XB+6Ne1ljT7nK8Qc7WlN+zaPYc5qH7Xb'
    b'A7Tn+gDdIfR3z+idDx0558Mv2AxojnWgrh+qIx2uwfWDfUC99YKt35g+14xuD2PgudFG2qO+'
    b'eQ6rQ/3k26dDOgeYX/SxfnVGzy92dc+ntvFJc9qHubCh0l7TJ8bB9WH3mDVf7Nd6pDXQ+uao'
    b'z7h10P0Ym3noXTOYpwTtDmiOPlhdd9UB3Xr19vD4ibo9sC/4pmdkk9oYkC2W6Zs9pl+wOwp1'
    b'Xrwy+wm2Mca8kK8rug9PILgG44x5csxpHWAzrDMPudI9ZtqAbv2cU7u9ZfZovkxf+xizFsxV'
    b'zh8eaL/6Rd/siY1ee+bAzAFs9VnjudJWt79+df3Sc60E9OZbs8ptPzE+ryUwH9k5ZOZrK5tL'
    b'f69L/J4zMG/VvzHlXGt76Xc+7PYp7UHcXNep3TH9nVumr/l746RbqnIb1cc8/vcuWCP4czrR'
    b'T948VvUxek5AG4jbR1vZPHKw8Zsjsx7bc7OHNQyPpXMYQzrsZX5zkMak+oQasYdDG+oHY91b'
    b'195awceYeaDEx/D4tod6jyW97DtzGY0hRb111ji3zPmEnO6lrGL4nI8xbeYxV8y7lHnbr+Cb'
    b'kDN7t272wO4awBykcYZrcD2ibb62fVtrv9oMwQ/WYnP8PFfmKs0Hz69j5mA337zqDtfIME69'
    b'w/XVZ25j+qbOAOdB9no0Tsw6pTQHWg+dU9m5ldDe5njcW1sJ6MTrg/ZDZ/S4gHXNbT/96Nao'
    b'u1d7Nrf9ZPZyjjJzmucQ/NvMFoEHawueO7E9gPiu1eTcBgB7ToRu/fRrO4c++9anDfo8iAW/'
    b'VL+SuB7nY52O0rzme1znsex+ZfYmhj4lw+OK1O9c6CuIiTldVyHX3tpgXW0GuQ5tcE3ags9e'
    b'E2qImWOPzum69ZsvzS+sw/zazXU+ME8J5jPwr+bG5xrBnLluqd65hLjHsHOqa4NytTfRb62+'
    b'2uLxqN96qV5mDj3qa8/Ow8DudWNufYAfH5J6h32sA+eudGgrb3WL1930FdxGlRznts75tBsD'
    b'dO36zetaAT/Hwb5QaV1rK40JPuPWmOfxl+rAXAywhxK6TnV7NH/2lRnDtk60Zx42cwr2zJH6'
    b'AdseHs+iTax9rKkPsI0B0iGt02+Nx9icSgdYj3Tv+ponPT7QfuZ2vpN6eSxmjr7WNG8yc2Hm'
    b'NoZunP1oV4K2A5TEmle7zH5eG4x5fYtrAqQ5DuJz3TDXVlvZYXwPe3cOwJ61xo01vtdj1kB/'
    b'dnocYNUH9BurzWgOrHyAXaZtP3+2PH9IMN++5gE2fmPQ/sZb1zhYh+z51wfWNFYaB/q4fqDG'
    b'2FzH7FebnK1LN+0iRb0T2ETZeiCXmPG5WJhz4NfXvvisd+7mEdNvHcx9XGk6/2peY8i5T2kM'
    b'0PE5BL8DenwnHgek/Rn28xiDvs4F1kElw7m7BvI9J9pAPrqjOfZ1vQ7z1MFcc6D7KNY5Zp5+'
    b'aL/6YO6PQaz+1gtxcx1dg3Z7Crr9icG0lYLdOZHq0Llk2kB+1yKrWuext/vTb75rbwwp06et'
    b'rn/OA9ZV9li1XgnEoL5iHGkfUb/NrV5jk5Mf/OWbHp7x+8/c8qid63EfxhuT6vbAZ42yfob5'
    b'2ujNb6w5gj1l1+so9nXs5UFjjp5PpD3AnlAfNVCfOnhcZr06VBf3ynAO0Q/tzdC2Rj/MeWet'
    b'sebIzGO4N2jvxqGx5s+axgBf927PmWuecTDHmL49zJXalQxjqyHo5BVt63t8Vkz/nMM+0Pns'
    b'O/EYif3aQ0mv9of6V5jfAT2HYgzQ7Wn/2mINPvSe1/bQb54x472GOvBJj6F1zbO+NcUaYD32'
    b'U1pXSaz9GdR2XnOrK1uL3uMD2M0DdNeELuY5VpDj+mCVq2/mdR0OcI17nD8rJjmBzWWvCROw'
    b'YeLUrCasv/OIPqQnjWG+ucbEvOkHbXtfF6zW4L6R4J70uT5y1Yt1ZeZR67B3fea0l37zy6xj'
    b'zDxtYwWfPwRgHihh9gPiDpl52ivZOFSH5qxi4Ny1Gc3XZy7Ys0Naj7ROv73MMQ7GOX8z33Pa'
    b'fP3ktQaUxrXBns0XbPzSXH/+kNbN3itcAzS/uvsT5iHW2ubgYx34yAV012aNYJtXaS46gx72'
    b'MU9u9wYX9gRuo/odj3zWBT0Z9rS/7MWa4xrqc6/QOpg9lWAfBj3EvGIeQ6oDNbNOrPUcuF7z'
    b'G9OGrre5SuNKY+5HG8hhzBjS9UD9supXqLc/OQxr6kdC+zi3PZoH2g5Bp+ZiayPeHujNbc8J'
    b'efaH9pm2erG2PaT56NrsSduYVHdehn77Tfb8xfPg3NR47OoDZHuit35Pp5+1+Fd9tC82p3Fp'
    b'3N7iPmYPbYc923f63APo63w9ZmBvICb6kKt849Jac5HkeYxXmGuOa21NffaErsE+YN4Kaqxr'
    b'L1jVmIP02DbP4wn21nYP9jBX6dijx1RWvvbYvumZwYSAbpEHEtuFGrMGCa03pg/s4cHGNhdm'
    b'jX7sVcz4SZh/nZCpPEagruw+PCYM9zj3pd2Y9aBOjH7z+Aq6o/Xm4HNYawy8OFd9wVrQZ43Y'
    b'01ztgs0cDJh5zgH2V9p35uhD73z4aqPrU9df25weCyUxR9dHLj5r7KeE9lK3F+jvPjxOpfU9'
    b'jkpie37rkPj0i/lgrD5ovpjTXI9J56qN9HiBPkBWl9lDqos5leCx8Tgz5vHSD2/5xn+3yfJV'
    b'P3ST7d75s65Q77z2qt65YHUsKhnzGgdtpLn0QoI9qDXW3OZoA7ZUhxmzt306iK3o3IWa6YP6'
    b'7DnnW9UZc436lPpai+7wHIP5jvaGua5ZqzSOLNrEZn5z62OYu8orxvT33DRmH/PaX9m41J41'
    b'4PHA1/OhjuycDPwd+s1REhP07q3ziv3UgT7z58PaOZdr7T6sm/M1DtgM8x2gBHOg/kmPG2g7'
    b'WI9rkNrqSHOp0zZWnK+5ok/dc6Gv4DPOXOrUMfCR47D31AFpvhh36GtvdJk2sCZ8rYHmos+h'
    b'H8hDt091oC8Yw9ZnrtL1CH5jUh2Ig7Xa5m2+fnEb2BhWRTM2c9TFulWe9aA+fQW/ObKqg9p8'
    b'D8PTroMvbvObnjngrnGua8Vejj1g7lEdyXxcOO1hnNGYNlxsnZ0DTopPeTFO6ovtGtGb2xr9'
    b'9aEjYZULyO4diHuc6t/LUy/k1ec8Pf7NaS+oH8zt/KBtHjS3friU2GTmozPAmMfGPEaPYePS'
    b'fubpg/aYmA8n9azO6PnSj5zn5iTmfJ3rrne58+FVr+rzKq9yLucq95Of9geHv/mbq2+12lrn'
    b'BOvtZ8/axqF99Im1pfX21F4dE22PiX7kPFb6QQn1m1ub4dyTeb1Ybw2SmNKYeeTMdZoHq/6z'
    b'T+fRD9j6V1L0TT+savZ0wSe9dqrPGnEuqY1cHSv0WVeaI/ZondI8ZOcCe6lD41B/84u+9kf2'
    b'+OzVinFz5lrhYj1K+6FP2mul16fNgF7H5og+Bnswt7GTMNc5Z75+Br3BGn3GYfZR6pu5YIzh'
    b'eWi+edqtrz5tdeVcK/a8ZtQBW32FcWtr93qy70nzWaMtq54Ma5Gzr/H2V67yAFnb+JZtM4pN'
    b'ZKyoX918a/WxcLC3YENrWtc4gz767YNurflS/4xdKVwro3uddD1d355sX4eQg818xloH5qib'
    b'q+0A640jO8B48zg/9mgv4+odrQfsDq8dYM0r//TRz2tFW508cb312ac+ME8/cq/vyqdObPoZ'
    b'9rK24HPvxVx7zLi2knz0zjFjDln5yG0P0ddc8Frr+ZH65rz4ph+w9ZkDrak9dVBHEnMdgM2Q'
    b'5lba0/zf+d2nHX7zt59y+PXffPLhN37rKvlbT96+8RRaO3Xn4jitaL5zaos92q8+c/HZo/Ep'
    b'jYE20nNp3DXjYxR9sxfYrzXNt6bx1fFpvHX2V4f2nxiDmd9Y6RxgHbJz1G4v5MyD+hu3znPQ'
    b'PtCa+tpD9PW6h1Vt6407mqPt+sQ5jE36GNC+om7PxpH60ac911LsIRfr5dBWzv6tmfUFe+4d'
    b'rJv5HjvzsGeutrp2j7vxYi4DyGnfiXND68Q4+2sfdeKuSemc5lBrLj5z7CXtDdj2qY2ctVBf'
    b'+1sPU5/91BnGuy/oPsA8a6R6Y/YH69rTOKM9PI76GfrAHvVB+1rHIP9VemINQKV6m07d+tIc'
    b'+5g7a7ShG6jfHuoy/TNm/ZXEGZhrNb/+uR5s9jv3DK31IgRsYupFv1gPziXmzl7M1Tpoj64F'
    b'mgfkWG9v0F8f6PNa1FcJxLzIJ/jI3S7qnfUhHUCNdQx7d+Cfx2z2mDpStNsb9nLB9c844NPv'
    b'8XLoZ4ASpp/hfI1B50VnPfqsmeCfOer6V/XGqrdGv3Z71KcNzQHz1JWMeazNK83pNQozX1tp'
    b'X6T2nMv4zAN8vXYYsspVNsYwph+m3lyldZPZj+PisdHXPrXbmxrt1jUXmifq5s2aVR9ojxUz'
    b'X/DZU9SnH1Y+e+N3DnX9E/weX23RJ16r+O1l79aZZ85q3tajW28tzL7a5JOnznCt9jXuAHLU'
    b'rZvY03W0h/mda9UHe87TPo0pHdqdH9yPkIOtdLC2ufb2Je76wRigm1Pw2RvsK9MWe3cOsScg'
    b'm9OY4HNoux72O+PguhjmeGzQV3PIjMH0dV7RJncVa4/moNfuEOOArC34Ju2rDfoY0yczxz2j'
    b'c/zNxbYHcpUP2oKu7/xnGEAJUyfZpurioqypbj6y8dbMk9oN6Cv2akwfo2z2tVtcfs6tZ663'
    b'62RfgN114m9e8Ti1R+uNYTtAeRLt5Q822NNYwddc4+YDvtbrh5VP8O/FWmdc3Tp9MH3WaoM5'
    b'2PVVgjkz35zWzj4wdXPsoS36rWtPrwftSjhJ9zpzOI9xwe+10WGN2A+ao13wky/NQ9eG+tqn'
    b'9WAMSYxjs6oD+7dGfZWP7XzNnWsQ+0N16dqAPrWNM08lnDS3azO3tF69Pv0MbWOgH+b6QL2+'
    b'uUbroHXmWa+NDvpFu3H7MUdzZ151wVcbtCubM+chho2/57M16sStraQW7G1+c/Q7B3bnM26N'
    b'ueYUc6wxru4wD1yjdB70DkASm3X4YK7L3PpAu/7O0xr99AYlcfWJfZqjT7oGh5hb2fPIWK1R'
    b'zMHX9TKwratUX8XFeboW521N67T1UQvWgTF99pbOwfoc7SHk4HeNDv3mVBp3uMbGrZX2Mk9m'
    b'v1Uc3EfPJbRmxqilRh3M1wZrzK8t7QvaSIZ1zdM2zrAnsv2l8fYCfdsTBhu0ACzCdvPFPGOe'
    b'QCBmb6V+wGf/iTnQHoKtT3/7Ks3jv+uCzu2Qub7iOqW2x9Y6j3FzjE1pvLIx/VA/uvZk+ttD'
    b'XUmu/aS9keyHnNY2X/AZW43+wNqvvdCBPI9p+8lqPa2dc8DsAeSW9ps/S7Xb3x71dR57ui5r'
    b'9CuNOcpJ/kqhl/1ktSaoH2YM2xzXrW1u7Q590F6NY89+M2a+ecI50d+Y9dJ49ebh6zUHvT6s'
    b'mzXOL42jz/gq12vDfqseYo5718eoT9yTOQxRn9IeyMbmfKXzug6HPmidPmkPaC6xrqG4HnOs'
    b'08c8c00OQDa3GGM0po+hDfbE5rz23PZ6qg7UWSvWGWu8unlThznPxOMi1s85keauakTdHkpZ'
    b'9QZzpcdNuzVIc9Qn5oq97GtPdW1ztO2N3p7NbWwlGzcfyQDt5s18MXdeq4Df9ULrrOk83bOS'
    b'eLFGf3vah2FfcA2usTUw54Dpc079zlOI6Wdoi3b7VJrrHns89iDHfuau5gQkY/bVzyC/aM85'
    b'YPYW17/pbWoTwG9MnSH4PWEu2Hp7lNbKytda48wz+zNab50+L6qt7vwbhq48zNehz/XWD93P'
    b'iuaCx7x17dl8cr0Aofmtaw1Mn3b71OeY5wm94AP9s944srUrvdI9Ku0D5unv8VthXuP10Q9J'
    b'H3Pw6dc2d8YAW8wz7s/Sqr/or+ze9QP6rGWQLx6Tk+YQ11e0la4F2/nUpTZ611C/A/D3uOyt'
    b'2x76G5815DVX7OF+Vzk9FsjqzjPX4eg6jJOr1KcE/M0R89tHH/MYaw1c6rGYGG9effU7pz7n'
    b'KMTqa4/WiesG/NabK/UhzZt+bDHPMX3Nhfob6xz+rJkLxOfxb3yFcX++nA9f7Z5zIaatrk1+'
    b'42AvfNVrKwu++ptrvbSffm31+meOedAe9cPMc9hnXk/K9kOv3Rqx1r4Ocj3G0hiyvWuDvonz'
    b'INtfX+vaD6Yf6dCW5ranEvbqWrOq68+GWCfaSvaK1Afq2kpozgSfP0/2QHbMns0D60Ffc/Rh'
    b'm7eiNcA+ZfaB2Rfb4znnMRdprj6wR68jc+nJwD7/CoOYZBG4cH2NgfmM2UvZGvXm66utz4NA'
    b'zAHWI+eBukBerV5RVutWeoGLfvfiHsQe9ZljHyWsfD0e+qtDLw5An0PQqXXom+cG8DFaD7Xb'
    b'Q4lv2vqU6uaAx1fpMB/qF3vpQ05f6+3X/BUeV2uVYozR4wfWOp/gl87bXHtJY62BVT/nUwq2'
    b'Q+YawOOPjTRnT5pXWovedYIx65qDrjRejDc2e4k9kNMvzNs8sFd9lerQHJg1jU2MOd9evj2N'
    b'zZxVTSHeOaac/bWtgVkPjQN2r9/mgn3JmbXO55DqXiP4fGxCdx5zsfWBa6K+1+JefvsZ8zoR'
    b'dOLtAe0Pxudc5rXnzC34GOZrl1WdGHP+5tpz9janxxrMg+rEta1xWFvweW7Qm6Nu7YyDc0xm'
    b'HnQtQI5zy16dczM6nz51+zd3xif6uB7MLdPnHGJcH3KvF7QWpl2M2c8B6uQw9FtjrJjnqG/q'
    b'zYHqE+pcoz9XgN8B7dm5muM1UZ+YjzQ+faDE158D14a/PUr7oFfCjNkDew7jSubf8u9+97tv'
    b't1W1GCwAfNjKyV4N7Pnaa/Zd2VAf7Plh9uC2qlft7qrAVQb+c7Wbrh/OmVf70Q1cxVWuqw7l'
    b'VeGrem+JhK+Kp9/jv/nnNun8KwmuTV/96L1QzAXt+pFe8PWjS332Nr9oN3+vn7Hq5pxUB82f'
    b'PrGueRfLr13sVWY/0X+x/tgey2Kefmta3xpzpzQGrV0x+8nsI3v50FivQyB31mKvelDbBzlp'
    b'r8leDNtrXGZu17GnC7ZrmxAz3rrZZ2UDvjl/mf69HgzW4HHUZ299cy51c9SV3Zf5rQNsqA+m'
    b'39qT8mdfa2AVE3OKcWIcF3WlPvddnFfZ42oPfM1RX2FN681tjz1WfffqVrkTa1e078yZc4HH'
    b'Zh4jJazmmrH2XtWelA+zZsbB2pOgbm9OaN85J9RuLuz5JuYxWrOnS3u1tlJqG2eUk+qMif5V'
    b'D6jfnx197b+ieeirnifFem3KzFVH+phw0jrrW8XBvit5MWZfa6Wx5rb3av3o9qlf9Fkr5MzH'
    b'QJh5oL19D8OLX/zizegkKyjqwlaL0ofsg44+/YI9e4H9wBx12fPNXqBfqW6PvYM0/ejtP/to'
    b'r3SwXj/9AZvR+WauPfTV39zVXqD5YI00PuvnHPqKsdkHyfDiXGHNHuypF/eqj/7Gkb3e5DR9'
    b'kGL+KtY1wuwz81eYY02Zte03c+FiPayffVZ1gN9ri7jHdebaq5w0R/2wioE+MIfRHJj1Uzff'
    b'+otdlzO2VzNznWf1M11Wvon15iGtcy3NmflgvrF5vRZzCnmtR570c1m7/ZojM3eVA6u8Smm9'
    b'/ulr7WSvBvZ87TX7rmyoD/b8MHuI/llbu7X6AV9rwdzWQ/1Tgnn66kf354BhLmjXj1xdV+hS'
    b'Xx+XmgPazd/rZ2yvz14dGJ956mBd8y6WX7vYq8x+ov9i/Ve1oB8J5tRWB+0pjYH+PWY/mX1k'
    b'Lx8a63UI5M5a7FUPH++g8faa7MWw5+PvzO069nTBdm0TYsZbN/usbMCHvn2GwQQcJoD6LFIH'
    b'a7ShPhdovLY+pXUMIWYv82Dae9jLXOU8sObN+clrjPra9ula0Duf+uzDsIc+c0TbHoCvee0F'
    b'xpuHNK9Yd1Jc34ytWPVpf6RUB+sc/HCKx7k1s582UqizX/0T6hxiP3Xrm+MafSBpng9M9rGu'
    b'9auY9TLzHfpX+e2jbH5j5uoT+wjxngfzzXO0D7rHSL8+86U6tBfSfHSHvmKNNN761qrPMXuB'
    b'53kvFx06z6Vg3kn5xBiuoWtx/j1m3Bp7MvQDsVVNczu/NK5ur9lP2kNdW7TrR589W2/uygez'
    b'tuytA1Z+e+G3trZoO/SZL9OW2asS7GX/5nROaS0YV67is2fhmjDuzznMPtD6PibonzVzLuMn'
    b'ydbUry61uwelfWrvrWdvTmv0gbn1wcyfg+NlvHkr2A+0V9FHXPTV75yAdGgXbGpLcxqfeULO'
    b'qm+HazRWqZ91A34fs2aOPmylMaDHrJX6rLN2zy/aSHORtWHqrWO4NkB2GC+z3lr90Hrk9hmG'
    b'BmAWWwD1gzaYp5x67Ql+RulJtl7UZw3M/jOHuD0bmz2RDmOr3vWt8tAZ9pXmuFcwH5x/Un/7'
    b'6Js15ptb6dzoq17SuL2ar17fah0T8uu3r/4OUBpHSvPqbz/tlQ4cj2nLrNOu9AfTH2B87dHe'
    b'5q56ahfjzQF9gN8Ycsambq5M23rrqoP5yNnTXPP1zwcvmLWy15Me06907B136y42iv3178Wh'
    b'uqx8Ymz2qN11MYxpC/6Vb/aD9hD1VWxibNY7tDvv1B3SutKeoE2t/srqzYH5M73H7FNdpg/p'
    b'fO2NPtcxfw4aqy7Ue93by8cr81ePV469x5sVrVUX/TNWHXnSz/msI1dbsJtvzcwr5EzsYa31'
    b'05bpa8/GVn7Gpe5b2gfsA8Za017Q+hmDVS/0iz0+QqX7an91axjVnQNdmo8sxmTGBf/qeq6U'
    b'eW0Zrw/wuyak+oyV2quYPvsxZE+nRnv23GPWKzu/tD+gr/JE3wVXtU0uVmwMOnH9oN+eYA6y'
    b'+f0BM9+c5pXGlJ2HgU1v49I6ayb2ANekPvvJjLVGqpu7mouxN4/5s2/7+A8J7OUXbHvMOjBu'
    b'zklYx7AX1H8xzGl+e0H7mFefa+261UXbwfXS67E9rVN2LiHmPLXNnTXmQWuVnMfW6FMHbH3F'
    b'OvNAffbE7sC3GtJ657ZO1JHmNwfJWK29mD+ZfufQP9cj+Ih5nq0DdWT97enQN+ezvzS3NF/2'
    b'dKHG3hw39faqD/Q7RLv59tGG5gDzzhywntHerW+dOrgX86B6e0w/57G9iGPrm5K4PVY+qA6N'
    b'zxg0Rk/lShdsZfOgea1n9Oetg5jHQruydfgm+BmwioPxPdob2T4n9T5pvtnDoV85c9HNnXtv'
    b'zazDhplXCcYZqzhYP2nfVc7s177o1ilBW1b6Xq7oQzZnSlAnr8cXuA7RGc4J2uajN17bXkpo'
    b'bOZN2tccfOjargOMgTntAZ1zL7ey9bO2NYAt1Zsj+toTfWV36G8cvX6GPWpfcFtVdGkBzEZg'
    b'fnPaAy6WM/srHTO/GLPHrOFCMCbGRb3+9tEu2sTVp7S2v3hCa6BzqENzBJ+DvdnLXCV+xvxl'
    b'qNJamHldR/WJsdlfP7I5xqF+9MatMwfZH+qTsMa+gOzc0vnU61Pu1RIz76RexbpVPthzXjeF'
    b'/BnHtk/7QecSfAx96tozt5jnsNcKY4yTep60XzDf+dSlvpV/VWMusenXp94++hmgFHOtrV6f'
    b'tqgbB/RVnnbPO5g/H/v072FPB7nVa4O9TurpObXHHu2pbo3Sgd18cb/6rINKhvXNkcbUmzPj'
    b'DPuC/Wds6uaKcVCu8tQ5tsStm7lIj8nsrQ/67wjoB3PBx19rm9d6aKw0B2aevSftj77KMe46'
    b'WyPt0Zg9pw/bgQ3NMca56ONXc9sHsFc+aUy/Nc0Te0D7rWpmvfN0Lpm1op9hnTpD8JV5fMy3'
    b'prY+sM+sYTS2p89cdKlPHdC16wf7gTGvOWgv5MztcWjMOFinT3vqMOvsj27M/Nlj1mqrNx+w'
    b't+4GTQCLwJgPLvVrz1qxtnm1zbV+xsyX6jBtawBpf9A23lj9sMprv1m7GsbAXvaYvfSZZ0zM'
    b'n7nNq35SjPPoPLNv0Z5+wNdafeIcDjC3+Qzj0FzQbh/Bbr8y652nufo68LWWAeZKc6C9jM2c'
    b'YkysnT2mjWwtMWj+Xq25MvMA38zHVp89oPFZK+bMPMC39w/9rFnpMPsx6pNZo13/pH0upac5'
    b'9c8c6fzqxtsLVv0aN59BfMZOwprVHDDj2v6bgN450FujLc2ftdhgvfqk8ZmnXYitapDNR28f'
    b'a+qrDermrn5BQnqdY8vs12O6h7nmWK8fufolVpyTnPYo9pt5gO6AzgszV+wns8dqzateHqNJ'
    b'c40jGc7lkPZpHsy89qpvxfS3715d562ubB1y/vyZK9izXhvdUcwxv3bptWwO7OmAXnvGAV9Z'
    b'9agU6/AzvJZmP6iv/RzQfsrZC1s/w2Mi7WGO/UC71z3on0Omz3lk2rDK115JclyH19n5zzBA'
    b'm7RA//xhtrY9gDzjM2a/WeschZj5oJx9zTEuzWsPR+PNM1dWPU6ifcX5lNA8Yytat8pvTF/z'
    b'Js2D1jtgSqgurQF0rwFAdj5pnTkM6/XLXo9LgTx7a+sDpLoxsW6vXl/rlc0xXswF481f1RTj'
    b'nQsqG9MGJZg/Y81ZxdRnvXM58Jsj+kEJzbO+ucab1/rJam58XqMOe5hfewX+5rZG8FUaV864'
    b'EHdMpm+v9iRmTR/bW7vXBz89qDNHX9Em1oEfCdWLeeozR9vYpfQEeyLn0N/jAficR6Yt9iHW'
    b'ntDjBebYC90c/cjqgg31iTFA124P+8rF+jTfPq1ZzTHzmgP6K5vbev3Q8zPz7d16qGSYZ68Z'
    b'75h99ddWl+rGV73EnuZC8xpD2seYUlqDXt/EOKzqpg3zZwSIt34yfc112KO0bi9Xaa45QGza'
    b'M3+PGa/dPkiPiX5jUL10XciZ17gxbXAeRvPqU6pLY8r6Rf2CM45zlVQfaNsc0DtJc/TPPhNz'
    b'S/ugm1Pb3jNXsJV7DzTqF6N9wbmmH/SR07km9dkPZm77tB+jsVVdezqgMetBH5hT34wXbXOa'
    b'u0dzqe+c7a8PmidTb1wbZm3rpDnWTYxZb435jTW38UKscdBXZh3MGsHPaB9ztacE60rrZkza'
    b'Y+rUzDmgMcfEHHWZ/pljX3Vl84yDfrBffaJ/1s65wD7F3OabM3Otn31a3z5QP8N6fXuQ59Cu'
    b'nDR/9l3VmgurtbWm/bSnr2jbE5pjbXvAXl+kfnSHTNs++qyt31hz6hf99oDq1sy4fYzLXj40'
    b'D5oj+pwD2Tx7KBuzZuZAdXs6po/cSqlemle5l19/813jrGvOpPsq+I2dNod5HNrE9+Y31372'
    b'0u+Qi+mdy16AT3vOIdVXmE99e8NJtat50fdq6p85q7nBntI6/dbOmHbzKvskAxpXB/T2lplH'
    b'DkOf+qxtXvOlNeaev61qByBNqr/YDLZmV23cXPObU5860pzmSuOA7ijk2RO0rZ89JvjMFetl'
    b'9nB0nlKfeaI+ZXvMGDQ+dQe0Fh+yPvWZD6s41GcOura52qAEcyfNqS57T/L2MLa3BuXsoW+u'
    b'oXOit27VG07q0x7mzVzZi+O3BxjXb6w6Oeiz16r/7Nd4Y5UT64zPOfCbs8pTTr82WN8cfdpK'
    b'/K2dmLuHtXt99LfPXl7lXFvXrDQHKs3RB/VD377RPgX/7DXz5hzNc7QPNEfQ/ZlubvUye8LK'
    b'7hyA3bFixk7KE3VrO1yX+lzX1Jvv0DZWqQ7mtkdz2w9qG6++F5f2Vqqb2x6TvVhrZ+9pS2tW'
    b'dZdK+4g9hX7as792/eSit0Z9SkB31Bb02Zsx3xLkPK1tnbL5joJtjvmw0hnWq5uDbgzU9Zun'
    b'lGmX9turm71X/VwDtE726qd+0lz2c67Gpw3TN6WYh4RV3Niebg02eq8l6RwXvCWpSaLPhtpI'
    b'fYJt46J/1piLbQyUsOdH7xB727O6uerGYPaR9pBVLnZzoD7zsRm11c2fcYasdHLnKM2rLtYQ'
    b'c8C0J/ZoHF1/pTmzl/nmWHNS/gTf9LcnKPXLns2gRimzn6z6z5z2naN+aZ+VPmntis6hrh/2'
    b'6qd/rqWjueaJNjkn5YG+9my9NK+Q09rJ7GX+7AP6ydnL15aZv4c1ler8Mt0eSnNa03mm39zZ'
    b'T7+0BxibedJ4Jcxee3Pu6a6zdaBv9tGnrK+5lcSlOXvM+KzZq9+bR7+2sdrQevVK8pD6rIOV'
    b'b/ZvDLAd9tcPzuXQB81d1alD/daX5lp7Uq5x5cWwf2Vrtcu0Xc8cYO7sWQmN1a9NfJUvfdJN'
    b'rP3U20N95jdHCcataWza0l6TztfeMG2YfbCtZWDXZ35jstJnnn0A316f5lRO2g/spw7Y9dUG'
    b'fc1XRxqXxpTqwDXTfLAnYzVXfefvkqRD8IMFHeY2R6aujTQfVnaH1J75k5UP9vyl+wLnQhoz'
    b'rux6ZOY57AOzJ0PUmzultcU+5pX6zeto70ohR1b98THMa2+Zdea3RtBX85jvfB2gnPXtjd8+'
    b'5tWWGZP23YMc86xVtt7+gr7qr7+5sw80Ltat+kJrra8O9ph+0GefzrOac+Vr373+gt71FPyr'
    b'/rDKnX1nDuCzZ3s3v3Un9VDOPidhLnnm2qdcrKfz2qejc1RnFOtlFQf9yFU/fUqYMdA3qb/5'
    b'QKxzriA+61bznmX+lX8vVoiZB60TbGX7Tf+K6cc2H+mo3zz1MusYoN66Wb+yZx995tbffONK'
    b'MW5O4/ikPfRjq08ps6eQ15pZJyt/fej27zz1N3+VY7z5q1r1xqE5+Fd9mg/EWgfkWOOYOaLf'
    b'Pu1vrazsVR3YF8yD5uq7lNrpUzqgOdbMuL7mgjmz16q+GIPmqTcu+Pb6OMcF3/QMNm1zsIAB'
    b'5hR7mdf6mb+qh9ZIfe2tLvgcs3drkPqU6uZoy15fqN88hz5p78Y7JuavaifGV+zN2/7K5lQC'
    b'8dlLsDv0SXVpLqC3/6rGeOm6YKUrV3Nqq5M7fWXl65xA3D7mqnctBX/nLu3fHs2fdfW3fvZq'
    b'Xu32huqFvA59BXv2mvNYo79SXcg1X7316qU5pb2bc7Fc9dXaJvY1NteIPvutZOv1t8/0IRuH'
    b'1spe39YjZ53Uj26uA9qnYNdnPcNa0L+iNTLnLfqQ5K3maQ7on7mOmadejHWAEuw30ddYc+tf'
    b'9YU9P1CPXwlIfdA50Guvek6f/aC1YL/mgH7ziTVX2tfc1siej4GPYY4YM2+PGa/tfHv1s07m'
    b'Oierur21rvYGnQOsxe+Q1refunXNk/Yy13x9s49+0FZK7dYhG1O3X6V1rQVzoD51MKe+kyCv'
    b'fduvveYcMwfQG4OZay990171QNd/wTc9N0nwKx3S2KpWmreiC5rrUTrMM0f28jrEuDrUrm5c'
    b'3V7mlFUdPvWJfvMds6Z251jRuPrsB/rM6yjtA82f6LPvrJ3x2mUV0660T3NaN2ugemunPInT'
    b'9EDvmqR+qC7kNA/ZXsZmrxWzF6i3p/0YsqoBc1Zx+4B9xf6NT/RZ13zoPMo5Vv1n3ylLY4zZ'
    b'r/7mKh1l5ZOuU+pDX9n1Ff17a5h15um3t37rpq2+N99qns4Bs1c5Kb+9Z4wB9UvroLHSPns5'
    b'QD8HeepFP5gnxuqzxypPzFmxVzelMeTMq41e8HdY3zxj6sW85kjt1byT5rSvqM9eMv3YDOoY'
    b'tcuMi/5S38yF6et8SsFu3Sp39tMP5pujPu2pA/YcjQt+IT7t9nfAai7rm6eE+qHzda76mw97'
    b'fmtX/fDZs3XGQX3WibpylYMP2xhgr3zTriTm0FaaMzGH+PYmuCaeVAjGkNUvVgfWOMDFAD7s'
    b'6YP69YH+Va0Qm33ML9rNFevAfuZVMvb6GNNWwvQp26P5k8Zm7modK+qfa501xpEzNuc2rmzc'
    b'Ocwzpl5bzBXroX6wftUHOge0V3Vkhz4wr32gecZbI8bVjSGtabzUz+gcUL80p7n6kc0XfbMG'
    b'Zr9Vzuy78rdu9iKncVn5W6NUh9kbWX2V217QmpMg356zF9QP5k7w6a9krNZxUmzPZ9+5huoT'
    b'cu236usa7GlOe7aueeYgHfgdYJ4xfSs5mf0Y+Ep96NC5wHhr67O3NE/MKzNvFV/1B23j7WXd'
    b'KiYzhl4buapbzSXoxGH2EuP46gdr2mNKR/NWmFNW+fYxf/ZtHJT2rnSsaA9y2q89lO1jrtir'
    b'OejTB/Za1ZyUP3VzGehi31K7PdoLGgNtfUhym7PCfs21FpQwezUm00eN/fbyHebCnAtWPbRn'
    b'j4vV78WBmDo0d8bkmtvPXIUFSguQDiDuwLeS6qAE/Ep1mLn2gdlLvz5Y+dQbc9gTqQ7mTlms'
    b'kZWutG/RtzcnuDaZfYjhm71Av76uBV171X/WFGMrVjHnYjh389SVqzlh1sw8fY3NuQT/SfXV'
    b'J9Y6pDX6q4NxUcfvKNqtkZWv9Svdms7bPuh7dv1l9sbu0Df7gnHsWV9mPqx86Pph1Qtmzcyh'
    b'Bz6kujknxQDfij0/zF4Oa6pLa5rHKObBjGnPHHVAX/km9kKqi/X1q7eXvllPzhxAngOMYSuh'
    b'OStmvz2aVx2w9YE68lLyS3NaC7OP1N987PqQjQP2qg5ap8/cDnz1r5g9QR/or6+0Dt0851Xq'
    b'q59R2ktaC7XbB13b+MTcFfY9CeeA9kE3toqDfjCmb0qoLvicq+DrGkS786lbs9KVs5fMmDX4'
    b'5hy1rcGeMaWs/K1Xh+agO8R5Zt5q/vYtez1qA3mrHjNPVvVg7/ZrTD8De3vCYACaLOgOaZPW'
    b'nlRnbnOgcVnldh4wZ8UqV3lSHRh3wMq2pz4xz7n0Ke3fOJgjM1dfpX57tce0BV/r0Vd9VrVQ'
    b'f+usYegH8/Vrl+bDtPcgz56Vxjp3h6C3rjVl9hL8xZj+xtHtM+tAH/HVHLMO3WH+rIXmib2s'
    b'bbz29BtDFnNkxmvP+ov1Uzdn2vXPPtj6Hdj2AH3QHvpqz3pjJ0nz1Y3ZoxiT5jZmrX5jyPZF'
    b'N0f/7HOS3zrkqof+6tNnTftI+9UvrS3mKttH2nM1DxL/7D2ZOej2sVdzKo3DSbnNE3yzB2hf'
    b'rJ9DmmNM3RjUrh9mruh3gDqxxsv0z/7W7rGKXaym7OV1PUqGa9V2wN66p4Tq1tl76iuMdZ5Z'
    b'X/+E2Oxh/SpfWgfOAdXLXs5e/sS85rMGbH2rNa9i1livb8VJ9dIec02leeYK+mqO9tM2r3pz'
    b'oTEw5ijThpN6XfCWpBavGuGbzfTNxoUcx6Q+e5mrLrO/OWW1Bnus+mHXV4jPGpnzNHdVZ75S'
    b'zJly1UPwzT57rPLa217tqb6y9UnrZeZI/eqtb49pk9MaWPWTWQ/NITb7Sf1zjvpq2wO9dqVD'
    b'u1KsZwg52uoMdIdxY82B5tUH9QE21LeHPdXbU9Cdo35zK82ZuaLPGqhvr/+qF35je7mNNzZt'
    b'wW5Osc9Ef2P22Os180Fbae0Kctpbe1WziqHXP2ONQ+eQlU7OlDOvuY2BcetFe+Z3ntZczC/O'
    b'B60p5lwsD/CZV2lu++hf9ZHmi3NYr88x8yfWQHtM9NvP/pOT/K5ztaa92CpXVvOchq7VebqG'
    b'lVSXvb0W56kfvb1WNdC57XGadcw++hj2hNkPjIFxZHWwl6x61qdunTagO2Dm1+/QnpBbP3p7'
    b'waquNG4/h+B3aBtvXutmfm1Z+dX3+hPvHBN9yGu9JalNbSa1zSvE2ry5DjDWXOOtUZ/YB2Yf'
    b'aLw0z/6r3MbVHWJsMuvMaW5j9mxvadx67Oau+k5mTntNjJnHIE8d5hqgdmvLtMtJPacf8HUO'
    b'df2lOcQd2oLt2KP5pT2tR5pfqd686pUybZi9qju0V6zWIVPfi9kDup6JNcqZV5sc7NZM3Xzt'
    b'+gTbMWtOormzFrTrqz37a+/1genvEHJqS2tnnz3ayxrnW81jrLp5+js3NI7evtWbI+bra67M'
    b'HsrmlFnr0K+tPvtoI82TVe9V/YzNnFmH3ro99vqB9Y2p27f9V3lgHKrDrEXWp4501Bb0OX9t'
    b'MF+/cvr38oCYcagu5E9/7VVf9NowbVj1XeUVa2YutjHn3+vVXPXWarfHzJHmi/bM64BVv1k3'
    b'WdWI88KcA/B1iDrSHuoT47DXY086oH2gefgrHdLa6jBtsBZ/+5QZQ9enLufvkgQmOEQdSXEb'
    b'wMyH5u3Fle3XmtJ8WdW2rjX6Zw1+bXTz2kcaa81KQvMmxlb1DuPI9jEX6ldXmld/Y8ado/nN'
    b'ldqtB3uIenP0ITvX7CPoHUC+fcD6+tX37PazFprXXPTmT/A5rIO9uuql9e0D2PrI65h+MH8O'
    b'QZ/1sKcX/K2XaZsjrZvgIybTLvrt5xBq5xzE7dncs+I8lXOOk+Yj39qZZ5+L9eqc9pJV7+rN'
    b'nz3atzUTY+artzdMG+pTbw/RV7nqJ8Qd2kCNOmjXB6s8mf7mNg+m33xon+bt+aW9pDXtsZcj'
    b'7WUdQ//ss9d3xvUx9ElrQdv8SedsX2l/9OZDfYA+57GnA/by7NeeMw+srxTs6aterBd1/NZM'
    b'36pGG2ncYZ+y8slevv3E3h3Gm6cfqT2ZvQqxvXh99Ztfqb/6rIH6oHZ7OsTY7LunQ+1VLehn'
    b'APHmTV2sIdZRWrt9D0PZKwJ8TuAo1tQ/9eas+jGAmEOMQXWwdi9f9JmvXtoDjM81Tb15pf3R'
    b'W1f078XBXheTMHsQa3wPcva+RbL1rhOfUr8+hrSHfn3OJ60De05mL3OaWx+D/I5Zo5RV3OHc'
    b'0F71m1dfmbmVxmo3f+rN75DqZdait9ZY/frAPKi+Vzdz6rNGjEtr1Vf9pH3RHcV8a40jV71W'
    b'nBSDztG+6K1Vr98axqrPzBV1Y9Bcac0K8zvHXg/86A7wG0abA/UJMXvs2TDrZNaZD8Tq14b6'
    b'tWHOo7+sfGA/ethn9iuuR9m+7TVpzNpS23p9yvrbR90YTBvUm2OPxvStHvPtW10ak/YV5zAP'
    b'2zi+5ppnLswcaN6sn7lQnzqSfFj1WtEcpLp9pk8dzEE6hLw9P9RXzDcPaa9Z2xypz14rGp86'
    b'182qvjpxc5D6wDxj//RP/7TZgt8B7aNPzLO36Kt/lQftaXzVrwPs33rAXs2zlzt91uqvfa0n'
    b'DEACY++XRsA3a9u4uaCNbJ199K1qxVh7qNduffs1D7xQ9BtrvrJ91R3Ng/qgOrRW2kP/7KPd'
    b'3OrW+QMFSmg+zFrjDnzWc6zaCxov+hq3p/r01wfo5kNjYl2ZfcrMJa+5c77ZX5thvHnqgM4A'
    b'j53DHGiefdRF/17uqifUd9KDrPmtUwft1smMKfG1x0m/HEBz7de+xvfsQsz4qgfgc9RfHRq3'
    b'D+Bj1Afmt8/Ktg7pqF3680xs1jemvzmwpwO59pg01v6gbo4Dvzq0xnhroTkyY9qAPnsVYwV7'
    b'1XNVj2/mO2DOPeWEfHspofnNAft3ADnTB+itF33WXQz79GcW23rjq174S2u0zfFxsT21i/my'
    b'sq0X9NqdY9Xf3FWOPoe2sI9VXW3kjEn1iTHrHSu/8xnj/E1bXbAd9qnf+urQ3JOYOdO2n1Kc'
    b'q3GG8zZenTEhXtnc1hrTB9bAql6bmKO+PU6K2bc5nUsdVn0aRzdnytkLpk1u57jqGrrwH3Ix'
    b'kWETC5WzueC3zh7+cg76Bbu++ctpdXNct/bsic5oLWg3hnS0h/GJvdVhL1d/+56mvpjbc4au'
    b'TQ8Gx68PxrO3fVbYg5yO9jAOylkjje8xY60H49MPxE6qX82/qgH9rTcPn/GL5ewx16Jd/xz1'
    b'S/1Afa8B/wETdH2tbc5JtMa6Wdt+jbcGkKwVX5m1rVlhzP5g38bsBat+zQds85WFXPORzFkf'
    b'VBd9ztfejcHs1SHkOvRbv5LqgD772mNF49bas3WzR/PmYzoQb46gNyYru8wapXn2lVkP9gDy'
    b'Wbe6snHPPyDxmVua44DZ17Hq05+bGbOmsqM5k+aAOd27cdYg7p24Ne0jjdtz5hmXPbt+ejhm'
    b'fv3IFdYYR7o/YsZnHqgbA3wzF7t6j9+qb/OhteaXlY8a+1T22Our3b1ji7r5yA57rWrAOEO7'
    b'NQ5onsw4+kk5K1Z9ZVXX+cqeXb96fz4Aqe3QD8QcxTgYwzf11mnrQ676lPZBb776De5+97v/'
    b'84tf/OLNAIuKvinFZmAczDOXAzj/4UDX197mWNsaaA60FmZ+MQ/ZuY1J52i8ftG3ipWL5dWP'
    b'9Ie8NSs5aRzMqT1jE+Ow14vRNa5oreDzB8p+Qq41s3Zlw17NSr9Ynqx8YK2or3qtYrLqPfMv'
    b'RueCvfmwZy6cFN/rBfWt4tCe7cWYjwPQeq8NsMdd7nKXw+1vf/tNf+xjH3t43vOed0F/Jcze'
    b'MHNlVasu5uO/4x3vePiYj/mYzTb3gQ984Gbbq7q9Vn1XzBpo3fSZXwmtkZkDrYXWT/3jP/7j'
    b't3Mgj3vc4w4/+7M/e75W7nrXu17rXElz7Q/OoTTm4ws0vidh6rBnS2tEH7L/ftljxcyzZ3vp'
    b'gz0/4Jv/bjbPOFI/Utpv+s21boJv7te8Vc30rez+XEP1zgOdS+pr/szVBnNX7NWXzlPqn/PJ'
    b'9K/msQ+S4fVe/6pWW1b++tC9lvTBrMNe9ZjXIZjLmH1h9hbrGlcve34wNvvIrGtsj9b0Wp3z'
    b'yGpucwW7x675jHm+pT0mnWM1X2My8425z+lf5V/rCYOYDCc2GHn6YeaL8clJ+TPGmH1qNz51'
    b'xuqHpjH11RytAW0w3rrmr3LL7Nk+YO9V3Fj1+sA6qB8aK+05mfPJnMe4/umztr76Z9588NIP'
    b'+sRaMbf99mpmLrL66ocdHU7qARfLL6va5s665kHrlerakz1/67QZez9T6mCt/mLMuDXAk4UH'
    b'P/jB531/9Vd/dbjvfe97eOlLX7rZpXWzT23XgK0fOWvQ+6DKL8Nf/dVffS56dZ973/vem26P'
    b'os8+HKf5IC3YMNcA5rVGfeZOZo71oN8c1wZI/civ/MqvPNztbnfbYvCwhz3s8CM/8iPnrKvz'
    b'V+eKJxqrc+XxKJ3PHnKSb68OW4yDeea6luaj62tvc6xtDTQHWgszv5iH7NzGpHM0Xr/oW8XK'
    b'xfLqR3ruWrOSk8bBnNozNjEOe70YXeOK1gq+/owWcq2ZtSsb9mpW+sXyZOUDa0V91WsVk1Xv'
    b'mX8xOhfszYc9c+Gk+F4vqG8Vh/ZsL8Z8HIDW7z1GQusa28uRmSurWnUxf5VbjFdvrvoe22tQ'
    b'NkCqT/TPSQBdP7RH861pnAOPbY5Ub765PgiYp6QfYK/6grXFPOugF4097Kkujc/c2oDNmPXm'
    b'dQ9gn46JNUponsf5JIg758TarrPrmzRvry++xmYf/ZXuw9pZM+2ymscencPe0Li+5oL+0nyw'
    b'x975MV9prDl7Osw6bNHP0I9Un/4ybajPWn3Yok4Mfc6z0s1TV77Zm73Z+Rx47dd+7c0H1jva'
    b'ozVibLKqsVd9q54ye7sea3xMQRor2PqUvWbm3DN3JVc6fRz67d05WnspkLc6V3e4wx3Oz+OA'
    b'+ViMf29+ddnzCXqPHRhnDuexj3bl6t8KerZ2D3Ogec7lkJVvVQfI9gFzWyPmNkffrC+Nt75+'
    b'sae6+JjtuWgMWgedDxrby8U387E9f/r2aiftB9jNW8VXWEeuObNWff6cmz9ztY2LMePNc059'
    b'gG5Me54j85X4zcE3h6jbB/A5X3OnXcxXB3KbP2vNg9ZAj/Ee5M46wOfw8Vt/wd866Lz2KM0n'
    b'VxupjZx19przzTmItycYb551jXXeC26ralN9NoZOctKE0tjMb98eeLgUXeqjN4N+6sTNcW7o'
    b'yYOTes967P4j4jyCbv/Wotfeg9o+yLU/+jxe9rKGmL7mNe6QVY+ZA9rmd5+NdUjt9sXnBVm/'
    b'OrJ96q8E+tSvXj80R5zD9VwMa62bttTPmMd45oMxaQ76Xlwftr7mM4wZ1++ezVcH7VKfNeZr'
    b'O1Y9Kx3Q61sJ/JW6kO9frK0tq/nUuyZ1sU7perRPi/OoO4SY9vQbU3aU9i+eU3s1z1xlY+qt'
    b'qT7B37lf9rKXndOuhhjnqvWtmXIP12Cetj7kRF9zp0+mTs+5ptYomzN9zQf9q77QOh8rSuvJ'
    b'QTrsgVQXc9XpzeAa0Y89+4A+86C6kGOevaD7sFdpHVTOXJm5oG6vVQ5r6XytEXxz3ton1ddu'
    b'TXtaq5w19U2MtUbpuTSGNA76wXnUgfqet1Utcp7PxsA655jx5qEjex12XvRpT6wD+5k387Gb'
    b'z7zT19q9fq5Xu7QXWN8etYEa+3l87YOvcyldu3ExXuzfYW2pz5ye7/O/GRGUFkw5fU6ArV6/'
    b'drGWDe/RueihjX7BBs71WM2zwvqecHtrgzboa2zlU9K/9aA+87XFWpgx7NkXalsza8X6Dln5'
    b'O6c+6Vob7xrUZ8x8ejCcx5g/DOjWwEpHkj/XI3vHtDn4Gc5nnhK/MakO83pufO4Rqos+5OwH'
    b'c05oX+PY6HNOMAb9OSjWzFpozzlH7dbOPuaYz+AYgX57oP/ar/3a4dGPfvRm8+ThoQ996OFZ'
    b'z3rWFlvRWkCq41eqr2KVMm3pPKscfK6hc3mdg/vXbgy8huoDe4t2r3uoXsglZp06o2vAnpjv'
    b'2mHvXGGbD/adPnRzZVXntQvGWwPGAd3RWplxaL/6zGt86u0n6sbVBb0xmbY1K7nqK8bdf+t6'
    b'TCrbE9oXf3Oa2xpj0jz9jQNx65q7N4xX9pwx7LPnB39u7AHYDmlc7Cf21ndSTWPTN3s0hmy8'
    b'P4vdJ2h3H/jaD+xpX2P6J51fZq1gM6f99Tnqh+aA9swrzVGqO8fUldKaSY8xzJ6lPfZ6UjPr'
    b'5uO3cX3Ge/5O6i/EtXs9NAfsJ1vvfobBoibZRF+b1reKQ3u2F2MeEGi9B8LceWBkZcPsDebu'
    b'9Witupi/yi3Gq0/fxVj1b930dQ6lXGqOflgda3XzVrml/aH9m9s8/OYhjfUHtPE9CVOHPVta'
    b'A+hep8TYa69b+0xmnth/zrPnR/faV5LTPPTpR0r7Tf/MnTSutB92e8P0rWzXKtWdr5LB3sV+'
    b'zYP6QRvMXbFXXzrP6jMM97rXvc7XI1frha6j8+Az1vr6V7XacpLfHl5LsNfPfDHOvtm/fPd3'
    b'f/fhUY961KaTP/vC7C3O0bh62fODseZ4feHreQB8F6Nz0QvwzXlWc9tfv2B73Gc+Qz8Yg/aQ'
    b'1stqvmlD52gfj1nrVrr56sYFe+8amLnS3jPH+VwfNE/fXl3z1JG9LrBnT32dt3XGoee1fvuo'
    b'S3PUzQPt5khjzYFpr87pCmvMQfb42Kf9Zw00XqwVbfNbs8pTB2uU9a0w1vMIs4fgg8YrG5Pm'
    b'QHW5lB4y61tTZi/jUy/mqsvMg1W/7dEQh84GoY3aALCbK5ycYv6qF6x6ABctMS9ebddo3cqe'
    b'PqW4FnPM1w/2UTe3+2s+WLPK1Qf4yZuSAeZpS23rwPxSH7nYsx/MPPCYn5TfuRna1DhfR89f'
    b'88RYc4C61ij3fNRr28scmP3FulX9nu0Q7dWaV71E22Mongf7aQO2/fC3P6yuDeNKYo1P7Aur'
    b'GiR+fdVBW1iTPZtjb2jNzKNen3nzmK0w114T40hB1zZm3gpjzWU0VoyJtnmrGvsXfYzZo7no'
    b'Hr9eG+Z0Pau1rdYj7SMn5ULncF3OA8iVX5qnNB+sA6S6ccGePnP78ybGAL3zzD7SGvP1MUfj'
    b'xhj2a9/6Zi9jrYVVDkyfx6856OaBvb2GQF/3Yp1SP8ye2IJe2x5gnTnormPmqGurs0ZqzIGV'
    b'jvSxCpBzLo/XSWuA/z91/x2t7XrWVcPre1FBmjQpSRCIVA1VSoAAISCKgKBCQEUp4aVIaCJd'
    b'JDSRppSA0tEhSCLIoBqUKgQpQmgCEqkCEooEFATU4Zd57z2fzOe3z3s9O+P765tjnPtov+M4'
    b'z+u67lWftdZ2v85mrc7YZc651cLGYK6vXWd0md97sa9H70F7Wm9eX9RuDd+5ztKq27isRjqL'
    b'5fx9jqKOtaxO8Km1ju8c83tf65+w3lks522/sRpj9Sd8nZbuAaf97rx++ReG3/qt37oj2s3a'
    b'VNDdVgPrpwPYj+UwaqA10MfW94Wtjjl9sZsHc+IM2Rlwrae9+s23v3Px23tCvRrinklOM5zd'
    b'GfrQM4D1Wn1jMX+N9hmz9l52brXNF2vW7VlumwH2We+czm29M6sBfO4n+JrbHtkYqvX59vno'
    b'qwVnGENz7Xf2bayG2Jx54z0PeTFW5/3YWdA+aE2cUR7ykIfcvOEbvuGdmcB3tp23c17wBV/w'
    b'on/Jl3zJO78cLT/0Qz9084xnPONi+ZEZzws9Mz6rdeA77J/4iZ94f3RfT/+FwbO0B/jl3zd6'
    b'oze6/LlRziX8uA6LPz96DWZ5Js/zfM/3fJe/SPRSL/VSN6/xGq9x175Pf/rT75ppbzGnZfHX'
    b'njgfM4E/h8qcpzzlKZeY695/YXjyk598Zzb2JV7iJW4e9ahHXWIgVw2wJ3tU903f9E03v/3b'
    b'v33RUeP5cV1A7qd+6qdufuZnfubyI09e67J78Dpgj4c//OGXmdR/5Vd+5XJ/+HOw6t/hHd7h'
    b'Yun56Z/+6Zsf/MEfvFPDkmed3i5BTa3+Yu7UAye/OXkwue3FF/OsvsZ3RnuaF+un2olr87s/'
    b'EK8WbqtfmwXNnerQmZ3F2vcD0H5fG2qNzbEaCzE0t9pTj3k4vc9Uj6b1zoHO7tzm7oU9+rAx'
    b'NOceWnmwGvOw97qoO2mL+e6nptrOX721PovWr1lYH67F0h7A93VKzee+c5bVifO1ly8YnvnM'
    b'Z95VAH0HLR28Pfq15oHcbTfUnKivDuqXze9sXxgnVqt/zcLpHlGv3YfR+bCzzUH7luoBf/da'
    b'rs095fHNQ+PmF3Xea1bnWrvtrPfqF+f0Obg/Vv9E57bHOYuanqv0DFAdvpjrnicLzgBr+p3f'
    b'fOcIMXSeEJP3ebTfnLrOhGqsO799p33tldMZgE+Mr/0pU3FvPvl77GMfe/kE/Tb4YuE7vuM7'
    b'bj77sz/7zl7dE4ibw+eT2NOPJOmzek3Eb//2b3/zju/4jlfPhOaXf/mXb77kS77kzifE5E5w'
    b'L9jv0Y9+9F1nXej/pV/6pcufOOUTZLW9x+Ze8RVf8eYjPuIjLl+Y7Ux0/+k//afLfeKev9Vb'
    b'vdX9lfu+YODPqtJj371+ZAsd/j5T/Kc97Wk37/u+73vzpm/6pg84B9DHNX3SJ33S5Zo6E4jx'
    b'uUa+8PGaFnRc0+d8zudc4s/6rM+6M2P/VCzsWdwXWut5ep/F84H29HaxM53BPPVqnFm7tA7M'
    b'EHLX+tWTs37KFWdopXno/TF3m741WY2Yu20eWCd3uq+34Tz9svt6rbXt6SwsGqmWGn710Pjk'
    b's7o/XOsH9dKa2LP77bVJ9VKt9bI921/9auWaBsva+2GtbG77e1+vXT+Qrxac6yxs9+us5vTB'
    b'mLWzr2nFGAutiZo77zUUYfW9cHOtaUF/N8Q2p+8FkeseorZLqKmtDtavFXugtZNOup+r0Ns8'
    b'1wTE1HwR3Ib9q2veWs9PDmuOvbynu+Q0h9V9VkOMz3xzoA7aa76zjYH4lBdr7uc9FWou7y/W'
    b'mv1YF+hba84Y+gxd0F59UNMzqDO2pxrYt4Ha9lUD+N6f5nv2k7WnC7ToWrMP37OWagC/MRB3'
    b'X+Kdo8b+rZ9AV/uu7/quN4973OPu+cUCoGGPXpPxztX67E6goR+NM/gON//vgvd4j/e49Uz0'
    b'8R3wj/qoj7p5/OMff2c/8ixj4Dv49/piAajzyTKf6PfPmpL3mon5YoFP1tn/NJMcGv51Yf9f'
    b'Ct4PZzH3Gs7utZQXe7EXu/mgD/qgW6+NPNfEFwyn83oOrhfN6YsFQMc1ffzHf/zNwx72sON+'
    b'5FxyOju5zRPT1zxx7xf0tSf22Wvdtw3satYKutX6jMh3FmCJoX345u1vXm3zp97mvRfivXC5'
    b'D1Yf6AVngjNd0nnmtw7kvL/GsnpnXdPISeM1O0e/usb2bI51rR+sed+6L7nVy2mme5lTA9WJ'
    b'2uqgOn2vzTnbs6izX9s+69Ut5OnxvhRrtebFWuvCzNXCbTM7S6vf175YE/W9HuJa6B7F/mqh'
    b'ustZ7vcvkOjywjdPzoOZAzc0h8ZaZ2FBjbEW8H1h26PvTNib6Qxtaa7nWJx/qreve596vEfk'
    b'emZn7Hzyrd1Wh9pq1Xi+1rHdw5x5ls+NJe1Riy32sPa5kqu/8dKzQ/Wif21G2XuBfmc5w+s/'
    b'zW2v/dU1f+oFzqIP1XUW7FxiV/NC3tedqAW07m/fztjXbfvxq23d2upPqPV10j6sZ7jWL+3h'
    b'E8h3eqd3uquHH6nhO8Z8JxzLvyjwLwvuyY/BoDeGvX7AqjtRLfeXGcTv8i7vcvkfnVkDtN/3'
    b'fd93WT/5kz9510x0b/3Wb335F4nuZz+WH6Xhu+xAne+UP+lJT7pcH+sHfuAHHjCTczgD9Pmx'
    b'Jr4Lv1/M0P/93//9lzOyFzFf/HB/i9dKnZn6CzkXoO154D3f8z1v3uAN3uDio+M6+NEgfhRp'
    b'Z3Je7pH5WuZ++Id/+IO+pg/5kA+5X3EfzsD6fgOIZc9+wjmAPc3qHHx15tF1jjhr9yj27jxf'
    b'm+Ks7S/uw9pn7D7tb261YL7LuY3VushjAR+s6Wu5Lq8NrMled2cXzwGerfu0X8jRx2IfLLme'
    b'uXpxtjOBHMsZrWPtgZ1Jjzmtc6A1c8W8OjFnvfNaA+utAfdFHb4zTqiz1zmn+9q1OXT1YWdC'
    b'z8MeYCxqob3gfWdRYzlz52ws5OlnFr3FmvObuw3nrK5nqN/5l/0e+chHXv5K0oqkDdBmaIzP'
    b'gU43S19byBXnnHoB6x7OstZe4xPV71xvav3THHN7jvrONAb3tKa/exDvtTgDjNtn/Zq2eu1J'
    b't9aacC6vS3/7enao78zF/uI8+603rkb/tL810G8/1msBcr0+c2JOnCFqe7+u9bRXv/n2b729'
    b'J6iDPczqmeBav7M7Qx+8z1uv1TcW89ewzo8B8R1jIb8/5vLGb/zGNx/5kR95iYEvFt7//d//'
    b'8gUCdC9/l4AfAbrtDNbcB2778ajO4UdzOHNzfIHw0R/90Zfv1NPHevEXf/HLJ7iv/MqvfL/q'
    b'5nLmd3u3d7tY9+853vIt3/Lyyf5Tn/rUy3UCNV+nfDLNv7QIOf71hd/d8DxYfnyrOuCMf+/v'
    b'/b07/+8Enu8jHvGIy7lf4AVe4H7VffAFin8lSU4/ksR5meXe5PaZAvmv//qvv/mn//Sf3vl9'
    b'Bnr4omu/sOF8/u4BOuFZfOAHfuCdveBbvuVbbj7v8z7vMlOe9bHv5oM/+IOP1+SPJHUG9H0B'
    b'Na14Dqw6Y3T2bB2a62w17tMeqAbaC6sv6rC7d+vNXfMXatwvfWjfbb3QOva2+7W4H1C/ba/W'
    b'2lfae9ITsziPseCra2/zqxHztdUWc6ceOPlY339LdbI5eztPzLP6fHZGe5oX66eaUFN3bb65'
    b'xquF2+rXZkFzpzp0ZmexTq/h9vt81Bqz+valRoihOfyTVszby3xf03DZDYHNirWIbdaCejj1'
    b'An572Lx94AV3BstDGqsT9VAfegZxjqs5z+lZ1+8Ns8baOcbAebd3odb9QQvU7G9+9e6rba7Y'
    b'54L2sIi1xZx5z1799qEhB2pd5K3Vbw0fvAf2gvXVgDVnVmsOTv1adJ2jzh7XzvO5F/K1sBqw'
    b'Ts05Ls5FfWc5Z2Oo37qz4GTbB9aEOjmXevy+nVqHPh+wp3vtvkCf+12DOvvyozqFfP8nYsQu'
    b'fk/gS7/0S++v3P1+aPcyxtL7YOET1+r5rrafiDuT+q/+6q9ePnHuj/vwibFfhOx56PnGb/zG'
    b'yyfq/AKvOffC8i8n7SPnj/Co45r5wqlwBr4w8JN14Bn86I/+6OUT7j0LkDOPdX7x+atFY0/h'
    b'HvEjVP0ij8W/NPCL04V/HeCanOO18UvOPQMz/8k/+Sd37rvP+nu+53tuPv/zP/94DnLOsI71'
    b'bac9jT0Di32cYQ4d1jnFXHuqqa+G3LUea0v1Pheo3jo401w1+tI+aX+XtaV18ZzWWM0tnst9'
    b'e+ZC3teDNXKu0li/uu4j5FywevN9DlBNIb9a6ezSGe5ZbedZ07e3uUKvOW3vp33dT67Fa5nT'
    b'BVuD0zxXY33BZ8bWnW0Nupe5svVq9LevsXtxD72P3mMsNXz3qVUvzqHWPmPA15rfuj72/1Fo'
    b'Qjzctcb2SbUucn0BgXHzvRnY7uENY4Fa0IJ1LVDfmybOhZ2HVW8OzJvDMgec5X7XoGfnXsO9'
    b'XKecs9yzvnivwb5yyvWMazsP7LfHpa73iLX94Jnpg1NsrpBTw1x9LdhLjoVuX1dgXU171FVf'
    b'mOd12iPNQ88J6pm9+6rrvvqtF+vY9jFbtgbE7s9itprus33idYIzwH2dYdw53Qvw0W1ezHte'
    b'/rpNeehDH3rzYR/2YZdPvnv2k09/89CY+j7DQr0zsG/yJm9y8eXbvu3b7vqiwB4WXzR867d+'
    b'6/2V++CTeWdioXvjcyY1rXUf4S8zqXHfV3qlV7rE8rVf+7V3Pll3rnzzN3/zXd+hl+6Pf8Ka'
    b'9c4t/LhVXyud98M//MN39VHrX5sC6q/92q99f3QfX/d1X3e5pp7B1xXX9Iu/+Iv3K+9DXfcC'
    b'c86wXh/r4tnoC1rwGqUzFnuEePvtbd6+tb6Oie1rbunzADTVnXoAvbWTfq+3sc8Hqj9pWKd9'
    b'1HYWfrUs34a8zs4Qtda8Xyc8T8/mbGNQo20OsC7j1oWcqzVjc71f4DX0bGXz2+v87qsVatcs'
    b'yzMZszq7a7XOAfInTvOg/rVnWa2W5Z7QWN2DYefge0bPu3N9HtC90NsHnW3N2aBVA+TaB9Vb'
    b'u3OCk1CM1ZwGAXbnNIftRQE554g95pyjBeeAuZ1BfOrFmgOtddDfmr36gMZlDuyFzmH14Qv5'
    b'9sDOcP7azge1XVB/9yrUnKGusfd/56oR/c7onGq9J82JfSxxhovYXmLfWLoAjTVw32pATefW'
    b'qje3qIG9NizzsdSw6q9pek596ixxv9r6XlMx7r72rd68PqC3V6g5Z2vQM4Ma74Xou1fZ+fzV'
    b'HD/ZBfJ80s6PHfGXd/bPq4K9WqgP7MG5sKw9O1jT55duFz7h3dlgL3++tPDJvDMB3+fB6iyu'
    b'jR+V4seBsP450sIXTu0/aTgjeL3QvfhxpUUdtG8xf7oHwhd91D2nWiy/q7FUA/2Tr8KfYoU+'
    b't/qnaxLfztjHBd3TM7R+ek6tk3OBOtbew/aAWm3xuqjZd7KnPXYWMasz3dfe+rJz2qcVcy7g'
    b'bPqrJ/aZcC51arDVQ3XQ+eC9cC99YzVSjRjXCr2+Hpxr/kTnVl825zXstXoO9wYtOetA3jM5'
    b'yz4XbP9Ji3+N1tTaC8Z7LcTQfs9rDXaOvvO6rDPHPqjvHLXQGfdi+4S8cedX31z37BwgPvVJ'
    b'+6H6zvJ11Jw++cvdPg3B2ri53njz4oayfh+MD7l7gHUtnPbo/vVPs8S6PT2PuWIOayz10ajr'
    b'i5fYRf10f1oTNfsi97z2iLnibGi9OWmve9izz+lan74abP326dsD7EPc+6Cuepfg09s+ME9v'
    b'55BH65zWVg/2iL73xXj37wznlu5vrZaa51Sj373Nibrmsdc0pTqs19Re6Oydo18N523eBWjU'
    b'dh/r1/Bs6viu+md+5mc+oI9PlPlToE984hMvf+nHHxVyX/XuTdxnab49J8irZU99oPbzP//z'
    b'dz1PIMbn/vjjRYW/5OOzBvfmO+vv9m7vdvlzoPz4kdfG7w7w4037uxNA7N71hdhPrqGvMS0/'
    b'GrQ4T/8a7um81ZLniyZ15h7MTOHM1VP72Z/92Ts5n2uf736hphbrMt57Yg1a3+cM9aVz8Ntz'
    b'2kPInXRel3U1Qtw9ap2DZXkNLq4N25nNOaOxC7SARuyBavD3eaFzT2PYvqIGqLHa13mtm2Nv'
    b'ckBOzelM5tWLtbLX0aXWWMi7hzF1ZtlDrXO0Ynyq6TMP1PRanU9NHXE55bvf5s3tnMb67e8+'
    b'5Ou7evZiXR+dseysQs0F1LtHffs3VwvqpPPFuLZ+Zxh7nwp5rtn7I+R3Hlz0JCwCgyugRs6h'
    b'5tpz4lqdWdScI8Tu2wesxpq961+DujPWSvMsZ2JZfSGtBf3OIVcti7wPzliNexirQ+Nc68bW'
    b'XNSYo19bH/C1m+ve4EzwteB5zUM1QL37dA7WWqHXfGcD+VPd/cAaVr/Y4yx9z4P1nGq91mJN'
    b'rJs3xjoXmFWsF/c+1Yy7P7md630y7zX1WrD13dfZ2L23rcHOYL491TpLvbF18Kzt6/zlNIff'
    b'TXi/93u/y//TwDmCnl+e5Rdi+USbfwUgRz97d3/PKvo7s3iea/DjPJ2Jlti+7SXPLzZzrtb4'
    b'5WV+/4L/rwNfUDjjwYDO6zzxu7/7uxfrPXXubddVbjvH7ns6R3/R2SXXzqCGeaeZ/X2IXldn'
    b'F/fXFnIu0dc6215ntWfpjPr2agGf68S6ZF+30NhZYux9w3cfUMvcPQc0t/nm6qPvHGMg13nm'
    b'vS7zrOL9ML9156jB+noxtra93VvwzWO9f+BsrLHWGriv1nlq3A+rL2igGq01cJ5sX2vQuosc'
    b'Z6uPdYbYi+39APXVdH5r0vnUrK9WHba+mmrxrakFYnOsfZ61aqS+oO3zVKPfGX2tkGvsDFjb'
    b'ma59NvrGte5Tjb554zs9F+9ZmAR9xKJfHTSPz4Fhe7dffXXdl4tRg/UBGgNWDVgz5iy9+c3r'
    b'L+TtcZ9eEznPBtjuKeZdYH9nA/GeqT1QPVQLxJ6bddoHmrfWntVDz2a/sRaq6T10rRYNYHtP'
    b'RU37YOd0vlYftO2zBzyH+LwBjdevXoyb3xyWtWdzee2FPNjLAvLG+qCF7d1raZ/YU7ta7Wqk'
    b'dXu7N5BXR6396Hcmsa8L/BPm28ePJr37u7/7zWd8xmdcfoylNaDH//eAPzpEzjPhY7dv4xP0'
    b'uhZfy84/aU709ccXC/unY/mXla/5mq+5/FLyp33ap13+TOiHfuiHHs/b3Gl/c31NVnfqcSa1'
    b'a9dFrs/cePEeCfqeefH1AfRd21t6vvrX6Hz1rs0tJ42zAN+aMb7PG+tz2D57lp3p+dsPm0PP'
    b'IudzMWf+BDXYeWCttrprveS7BA2x1hwY9+za03ytPpyetRD7XNBZc/buq3Zn7Fx8ctIznGY5'
    b'48Qp35zzOse5Yr60Dr4moXPM9/4AfjVac7UL+dU3D+0jZ4zVV+8Z27OaQs0e2DrYd5q5/cRo'
    b'fb2Avc7uLPNYc4DvjGrhtF9prO9rTLzfQN7a5ZeeHVpRaa5Dyfdw7XcmVAPm0agntzcRqJPv'
    b'zbGGdYZ7WwNj10J95zYH5lzE1PGhWrEHqBOzSnNoPb99WlDrfVwNtdVXY78+tvpSnTGoJ3Y1'
    b'Z0/95lhw7X57n6D2dH/pAepqxViN++hD57b/1IOO2HtfPbTH60Cr7jTfZ63upBXrLPvFPPQ+'
    b'oTMP9qkxdqZL9LGd47nFawVnqcevdmdtHYyr3TMX92StjnM95SlPufmAD/iAy784fMM3fMMD'
    b'ZvDnNPlTneCs0lh/NUKeGX22y8u93MtdbGfZc4K6P6aEz1+B2i8W+Pl7vjjirwB99Vd/9eUX'
    b'p/mLRj/yIz9yv+LZuK/9xsW/NMX9pM5C77pGa6e50r1Puj7HauG0vznsqQ5cU/fq7HvR+fS5'
    b'3E8fCz5/fbB+es7t9dqFPDk0y+aM6dmZm8N3Ljnza6E9rF4fEHceC7Cd11jMi74zqbfHutZa'
    b'rX41+NsD5Kpn9X7b2x5z4Dmh2i416mT76nc5Z+vmYHXFHBpQx3Uac0Zwtqvz7MFas06eGb13'
    b'Up04wyX6zdm7WvbbmnN7Dmtw7VkAvS76WYUe9ztZfTDufa1mY9nnIOiMvW5j/c7aftj41KdP'
    b'3ntIznPBnb+SRMGbZNwBmxN67FUD1ZE/gaZzjQWf5U0qat0XsOR7gdDZaljWzJfW64t6+7Vi'
    b'ztVr0KLpat5nAcTgtRpr6TPPcg4Y75760Hpp3ucM3t/2uw8188Wc9c6uvZaXzfUsLO9ze9zT'
    b'ZU56r+lT4zzpXH003pvm1BT36XyXvbB94HWBc049WOeD5ydX3159LewMIN59WV67enwgdmbr'
    b'1Vk3ZhY5rGdt79KePif1Wn5GnZ/x5wsH/idghb+k1H9lcBlLa80v3iP+lcNrA3oe/vCHH6/H'
    b'a6C+8AUDPaz9c6Hk+F0Ff+SGe+D+94Je/3KQMNsvasS695cf6TqBzrXXB9aA+jUd+6jTck36'
    b'J5zH8n5Jr8n9qmftX1o6nQvIW/OcPdv2qaeur95ca850gb5awAdr5rGne+VrYvvAGrHncC/1'
    b'fSaysZjHOgPr60da657QvBC33hrXYKztXOP2C35rnJPlffTc6PTV977aD/ZC5+O7ej+s1Uqv'
    b'zTmtt08dqDFvbH973MP8Nah5zUAPcC3tN69vDaxVA3s/YDVYljPNackxB995je2zRt5+52FX'
    b'v8+52rWuPjdz0D3Fmvvs/qVz0NCD9Vz2uYd+Y7FH9Mkzx1nd4/I7DIuDavUdKuZF3z6wv7Hg'
    b'V+vBwHxvpPPNQWdg1cDGnS3sKdS7z/afcKa9+kAvfs/rPDWwOay9Lh+imFe3OZeoc4Zazla9'
    b'Pfrq8Z0N+GKeWdWU9uF3bQ+xS3qO9uizuj8L9rVS7FNvP7CfMzoPGre/861jmeVeUJ39Ul/I'
    b'sbwWz+ac7bHevH7z6Hp/lp4Z7HVZ670C+9SB94C497kacr0289dwBujb11ksPon/qI/6qLt6'
    b'yPMvDc31WjYPzYn7sfD5MaH9qz789SJQ4xz7Hv3oR19i+fZv//bLfULb+1X4c6xQDWv/nxTF'
    b'OdyP/fOr+5eTnMl87lP/53KFusv7VMhrmXftetSJeu1CrnX+J3Z7Td53UA+cAfbPsFLnGtRp'
    b'C73sua8VfGPPZM54a1iW54FqrZMzLqsV+041ZwH5U2xv98X3nMSir0br/XFGbTV9zajpfCCv'
    b'3ppasCZoTnPF2s7w+nqd7odFY481YjXQmWDds/dZ4+8MfZc58/qyvqv9WPZqzTznIgfWjHsP'
    b'wbwQb6794DUuarYfvFdy0oAa93SB1+v9RmOukN+9vCedD+S62leoAXV19oDW+0vdpR7ULeT7'
    b'3NB7n8mdZhCf6tXhe4/sA/zLFwxNEpvzJsul4f4DtufEtbqzd0YP6EVLz2Me2wWdV9rjHvpi'
    b'3rUvFnz39wGD+oLG6zmxD9k9gDxx65sDezbHYu/Gok9dzWmm1lottdr6XJe+EHe1VsyrA+83'
    b'tS7r0rnV9xm2p/d/Ueec7T1R7eI98X5rF3u1zttzktvznzTeO9g6dDZ+te3FErMnq7Rvr+s0'
    b'Gw1549Jcz2v+1APkrfFJ8v5fe3su5vbPrkr3E6/VfjXYk57cnpH/p0Bzb/Zmb3bzqq/6qnfN'
    b'8vVB7VVe5VUueSDn/3dAzWlfUSPv8i7vclXvc4Af+IEfuFh5u7d7uzv/0uH51HLGvb+w+5z2'
    b'5Wwu6yfd1rymXlvpDK/rO77jO+7P3AfXxL8ydG9527d925uHPexh90f3gWYX183/PZvfe+H/'
    b'ys2fb3We90jdYx/72MtfrOLH3fgCDJ3nR8Nf0OL/UK2mX9D4eutZa9kLnFfUSftcxXP1baSv'
    b'o/ZrWXs2zwTNS/XOtgfrc2NRr77sPp15ra86wK+2C6zpm79Nt2zN2F7YGLYOq7GP5Vzw3pjH'
    b'kjMu9rnQ8Ax6f8EaC5zFEn21+n1NtUd/Y33Bd+/O9QxSja+j3ou9JnL294zOqJ5692wvoG3e'
    b'BfrUBH9jrdrV7MxaUOtZpWdj4bcu5tRewxmXH0liuGKsm18Ec1O0aov1+i6ovjPwu5oXzwGd'
    b'CfrUmyemr3SO+r5wFrWg3/20pxr+7g/kreuX5pyBNYbtb129OWnsuejtrJ6XfGP97e0blqAh'
    b'3hdyNfjOAGfs82BW53deqcb9tWDdWJzXuWrUs077kvO87SG/e2vJ2dOZasG5ra/WRZ5lvznj'
    b'ndHlDBc5z83yDNjqWNDrYC3uoV9Nrw8N+xb36X0s9PZc/F9/+b8f8wndW77lW971fwHG8snc'
    b'4x//+Ess5Pnb/1iWs077kVO39J4BGn6Hgr/WJNT4vyjzCSxfODziEY+4rPd6r/e6/KJy9+Rf'
    b'J/i/OZPzPj3jGc94wN7v/d7vfbku9+aT/Y/7uI+7fHK/qAHnnP6P0P/gH/yDyxlf7dVe7XI+'
    b'LPu8z/u8z/2qu+HameE60Xz119i6516q0X/qU5/6gN5P/uRPvnnzN3/zO/eK63rnd37nyzVd'
    b'm03e1yS/bP64xz3u8oUC/28PfhTsIQ95yEXTfr5Q43dK1HEv+ZEnZ3EuZql54zd+48us/lgU'
    b'WnSdC+bMq9N3vhprWH0h7tuuM8md8s5gD2e73E/UsJzlfUQP1lnO6KzqgJhZzMESq7GvbK5a'
    b'ob7ncrZ58DzOw+qTd5kraq3Vl+7lnJMONoce9pkxU21n7Xz7va/k8NVZh+bsd19wT1Yx11Wa'
    b'c7Zn2f17BpZ7YmVneT3qrVk3xu/1kCtq7PWMgm+stUeIe1awr3n3IF9/Z4E5zsMMdSyvvbQu'
    b'apfucZlv0II+lnjr0sNBdUB9D6yW3M4k3hlAzmVfNfaDZ3KWPmC5aGNre0Z10Nn1YWvOK8zx'
    b'QYJ1LMt8655H61x9cD+x5lLPAnPAXO9D9eQbg3F97414dnWg7xwg555Q372r73lYxO4FrYHX'
    b'pC+did99Ab8a6D5w6nGB/T1DqW7rzjavpnFZ7UJOze5rXLjW0xzvgTVnVKvfueSc2XN0UWdZ'
    b'B2vS2ol9xu7DJ2rv//7vf/kftvFJu+srv/IrL/8/hu7xFV/xFQ/4ERbr1d12DkHvPZP+jgHw'
    b'CSuffH/qp37qZX3Kp3zK5bvc3Qs9v3MB3if4ru/6rrvOSg+9fJHE9fHJ/+d+7ufevM7rvM6l'
    b'9t3f/d33Kx+I9+qHfuiHLj/6VDwjZ3N5xh/7sR+7X3Xmttc/S7/2BDN21m1zqbG4V0972tOO'
    b'1/TBH/zBl3vFfeKvSfEFA72na3KmZzz9nsOLv/iL3x89+/XHF6kFnb1ez2nW9hXPos81uh8x'
    b'rN8Y9LEsNeY6s3kgbj9arsXVHuh8e9u/tjrAl9ZqF2vOAM7ZvtbA/PrVta/74u/c1rkv5NUt'
    b'p1xp/bQH1lwht9ctq+8szis+11OvPcA+3QvWFnJoq3euc/b1RM4aWDPWArrWxJnXrsuZLFl/'
    b'Z7bvFEtzWHQuY84N+ILvuZs/zfC6e59gtebcD989wHnd1xxgjz+SJDSCdayHawztA2ouqS/0'
    b'9QzXNEK9euiMU97r2Afg2YGcMb69UB/sP+ncC7xX20tcy6JPX52o8/zmatXv83AuOKeze82e'
    b'XZ3W3DXcA406rLN3LtSa37o+nGrkuor69gB5zwPOsQ74PbOQ7xyvr5BTx3K2c8y399r9aY81'
    b'fRYzei3qoT4a+rTgLGgeWoPqnNvzU/dMxp2xdfDczeG3TzaWazPFWV1CH/8Tsq/6qq+6xNTI'
    b'cV3O3PlA3DnC3j57cD9/b+L0o1An+BeJj/zIj7z0eY+dBaf/MZ11F3X+PxNf+IVfeJcW36WO'
    b'c3/O53zO5ZfBq12offEXf/HN137t196lc4b0HhR73Bfb11Bx5u5zDWv0MJfFF1z7C+5gnUUf'
    b'fz3rD/7gD+6vPhuvgwW7P/FtZxI12Nuu14UG6/nMCTF4Ltm8vV6D9ebNgff7NLc5fJ+3s06Y'
    b'R++qHmuu84oa17WcPrWtOxNfWgd79IHYeeagdSHXecU8z9DniN5rBvuco/W14CrVLc4+zTrp'
    b'pecT/drO3ddNffHaO8M+8uidWY2219PZ+missezd+kLe+dZ7nuJMaXyb3znXzkB+teAs8q2R'
    b'r77PwBo09tmiZRmDOufp22uO9YA/q1qM27Qbbh8xC9zEPapjhjpQd8K8/fSiB2tY6s27zGFb'
    b'd462+vaVU+4anYGvra89zSXP2VjQWdvjrEK9q5rG+N675ty3tM5av3uc+gta9rWnvYW8e+y9'
    b'0EKfvzjTfGe5AHvan5xr56tvrrQPupfX0Tr0HPbXt06/8dIcvvcYv8t997qs62tZ7ssCLbXm'
    b'pTk07uWZrHkW91kfjJujn5hz8deQnvSkJ11+8bWaQp5PJPnEu5/IexbPg05frFPrAq8HzAk/'
    b'XsSPoHzRF33R5V8Itk7MmfmEnP+pHF8swO7HNfI/puPn3k+f4BOTp86PM/EXg/z/ULCcp9Z+'
    b'7gF/fpYvMPDNAz5n+4RP+ITLd+f9Vw77nec53cM6y3o1sjoxZ0+xZl7f1xD2d37ndy7Pl3t6'
    b'2zXxhUXPI+7rc+W6nYHlvvIvGQvPpzr+7C3/igPu0x+Zctb+LonafXsTYno3D+aoc351LqgP'
    b'PY/UF3Ku23B2deS4Hn3xjLLnIvbZimfo2vzijGph93OZVyftU2fO2GsydoH6XYBV57NvHcyd'
    b'6L1ExyLnLKC+Oe+NuKd1cF7nC77zdpY1cK6Qr96Z5N2fuj3m9M2Tw1fbpb41cu7BAnLO2bh5'
    b'qO+1ATqwx+U1ajtTTWcWNbL7MbP3y1nta4/7rIY5+s3LZY/Xe73X+7/PfOYzLwkEbeogxNY6'
    b'bH3xAq5xW//uAa3tDYLT2Yx31onWmQXkWO4HzsIum2+veXP6xXhnt/caaNyHpdb9sCxr1VVT'
    b'zO+z1HcOnDSbuwaaa3u7B7Ou3Tf71Urjaoxrna+tzr5Tvj52+8HaSS/VYK0RV4u9dl/RuXd7'
    b'TlAHNOqc2znGWrEHOqsaOPURszqjVAOn+0mu96F1cvzYhz9jXviigk94m2cWmMN6ht0bqPVe'
    b'Yc0JMXSGPn/Glf+Ds3U+sWfhi/0n3JcfY/HHW8jxrxN8Iux+6vRh99g8ll/CNc8n234BA9RP'
    b'90TI2wuNtwbE5K1hmQ/4QP50v63DxuoAyzVZ95qs84UDv08gfJHBj6/19QU8N36JmdcPP9bk'
    b'864G1LEPv/gOPQ8+/+NANXxxJ2hYaPYaPP+DoXtB++u7x9r6ex/EutjD4hnSt69FsN68/im+'
    b'tr/YAw+mz5w90BnSnHPXB+Nar0/fs7D0qQF1qMYa1ljrPHAfaB8Yt7ea5hqvX9qzdeK9VnLq'
    b'iE90Zq/LOWD9msa9oX3SMzjjNk1xb+vQ+w74167d/PZA5+4eQE6YAZ2/XJuHdRa+Z1GjZYl6'
    b'wL9c27UvGDrARut7U0Tfmhe4M6UafK3zjdsjzoPVGK8GzO3ZoHogpq5f3KO0/+Tb0zyYL9vT'
    b'3PZhhbjPCLDG9jgDeg+qhWvzO8PY2dIZUt3WO3drxA92njGLmdAeOPXV3xnWfN2oE/WgVluM'
    b'O69aZ7BnnwPsXLWg7lTHeg1wTdP8c0L1PbPzdqa+ewvx3museuLWa+t777BATtv7UE41/M5s'
    b'zTOd9PZA/Wp7tp3VnBDv6wHUsvB3nr72NEM6Azhj9c7Dej/aU701/fZLa7B1uK3nwejBnL3W'
    b'ncMXDP3/S/AvQXzBsPq9F7I5ny3Yv/q9T1ANeI9h59gD+vtsT/rOg+qLvdr61sG4Zz1B7bbX'
    b'R+dVW6sOq7Z9+rfRfiDufeuMzlTDMt850h7rnr01sO5cUGMNdp5Utz3gLH1Qh2X13loHNVh9'
    b'sa85NJ3THucU6/YxTzoXdp9izX5i5y6752qsd+beGzWtta8x4EO1YF3sYe2+WjDvXrX3ojr2'
    b'0Hc+sfN2pvlnv2d7Fj2MAxXCnaZn6dSAdWgPFlqXapi3OXs6B9u1msagTsizPDf79hq8LnXm'
    b'Xc5qHfS9jmo9gzG4J6Aldoa96old5lrvnkBerbnG5oCc90ANPjl127c1MBbj3luxn177sZ0L'
    b'aoCaqGmv/Vjq1TQG485cqPee2CPN4V/jtEdnrWWW19HnYF3cE7v7V9u5zFNvfi10nvrboO69'
    b'MobOlObwWbuf+WJu76d76wMar3VnmRN7oPrOIt59oXP07fNMpZrua94zQzXU8bXmwZhlf+tC'
    b'L3X3Kuaw7sH1diZ0Lv72ea9E/eYaw+bs057uPTWXsVzLsdinC/hl6P3/MOy/9lTvHGfK5tpj'
    b'TXx9kNvrMz7dT2dgreEzz5nS3vonqLtEX+v+LvG8p9dK50HPSB86Nb0G87XO70zia1R38u3t'
    b'XHP4xtTbLzvnBNfY56gWy/LeQa9dX+z3TFiXM9UUtfqi7z7dG72x89sL3Ve8TvXWsaczlNa9'
    b'J+3DuoxFv/tx/saFuLn2s7oPnHxsZ7SveehcLNdXjb4WXV8z9rWu3dXn1mdLDKvrXH21Yuw9'
    b'vfM/bnOYfl/MOwjfAfZrpflTzQvpXNgY1HqhanrGnse56vR7Fnt9ONrOUXvNF2e5X8/l3i6g'
    b'vzF69wdt6Z76zmDtufA9hzVWtcbCtdPjPVitua5eK5jDqjfvskcN+Gy7FzgLei5or+uEOvc7'
    b'zQD2sr6LGvN7bSz3PM0zpwX7xJiFTq37nM4E1PTVgP3WWc7xHqkRddIZvafmq3c2ce8Fsba+'
    b'dWi+WqkPaFxeS68dyHVO/dMeUj06UG+8feahPtjX3vZX73VsjvjanrXqVu+emwP7jdkf3Beo'
    b'6WPVCDnroMaZWH3pDPReO6B1f6z7d541LAuIl2v/AzoX0L//vwpq/M4BZ2peH+t56/cayGvt'
    b'g9ZYcKqDVh2Qcx8xx3JuZwI571lpjwu0i/2d431lFvn27kwXuj0LtKZv3rh5aJ4F1jevFrDW'
    b'AdvXETVi77fWfucag/PMOcO8OVf36/xqtc2vXdrXWae+vgb2rHCKa6U6fawLOl9tZwMact4b'
    b'e0Gt9wpO9c50f3PqtZtvjN+lBoy3D3o+Uefc06zOAOLbtO5jjlhtdc1pzXOfnVNdZwv153ro'
    b'Qx/6hN/7vd+7q6DfAS5y+uJB98DVyM44aUAdM9XUdh8tueY9TzWy/cS9Se1xRmeBOmd15va4'
    b'RL/2NF9rfa8J6pd7zZPN98wnqpf2dd/a3l/pXizfUWzc62YBMQvMb31zYF6s7zspcvpgj9cB'
    b'9i69VmacerZmjC3mi5rW7LVmvlpwP+o9FzhjfUBLziX6aO3RLuSab69cq+P3XlUH7qkWqul1'
    b'u5oDe0/7qMF2bjVYdcyo7sT2tQdr/hrVV3fqRUtsbWkN33sA5Hj7aK1aNcVae7Dm1Lg2b2wO'
    b'qum1V4PPn9R9zGMec/PSL/3SNy/6oi96+Z+lked3BvhXhdd93de9/FnVt3iLt7i/6z74q0n+'
    b'gvODOSe+lvOc7hG+q30nX4jba13ba99ZhRhtWU057Snmru1rre+z8bGneWCuVt9z27sWGjfX'
    b'a6YOaq1VYy84i+XzvIaz96wnHxrTowZrDnZPYnXGJ6wDs9S1n3Xqr2brp3znl91Dq57aUo33'
    b'3HsBnaev3fyJ6qW9+ieNr+fmZbX0L2qsY9sHzZ3OAHs/ijXy+FrY2Z2jFtRgfbsVcuj+P498'
    b'5CP/72/+5m/eF5hMIzHLZvxy6qu/M6xdewjqQa22GHdetc7oDZFqqHsWcG5nAb56LFRjTo3n'
    b'eU6ovv3Ody/Rd2/xDOqdpZ649dr6XgcWyGntX57TmmdqDp+854D61fZszgLizQHx6dmoZdnr'
    b'WTtHe3o+0hnAnOqdh3WP9lRvTb/90tqDwd5r8+C2nPvtHNne1XttLHyx7jyfLdjfvez3Hkp9'
    b'aH3nuCfo91nBSd95UH2xV1u/Pc7Za1mo3fb6cCZ+tbXqsGrbp3+NaoVc71tndKYalvnOkfbo'
    b'q20N7FcD/LKxeTn1FP7C1N/9u3/3rv/XBXS/7mWe1XtrHdRg9cW+5kA9tEdrrZDzGUNnOq+5'
    b'nWFtn+G1vaz1msW8nO6NM7YG1tWAdbXG1pfT7Pa4x8nei+p6v07zq61u856187CrBWIwt7Ok'
    b's0Adq3PbL8R7JrWApSbOk52r3xlCbs+6nPqu4V7q8Z1tba+J5WulddB2njpz0BnG7VW/9w06'
    b'S98eY2yfybW9oPEpT3/ZM+08IHdR4QACRea0UJ3soVmnC2FZt+Yhq+FCrLuPtnSOD9c5gGVZ'
    b'M4eGffF7k9SrcXapHnZ/cQ9xpla6H2D1nbd6Md8HTw7NnrOz1KsFrHl8l9fVPli96HcPqU5O'
    b's8HnYz+2s4A6uu510rivVtSbZ5Y58/qwud7j3gtqxKvRN48Wi7Zz9bHQGea0oF5aA2vNk/OM'
    b'5NkDf+ecZptz9drF64PmndU50tz2mNNnSXu05l1eK3g/yffeijNc5syfrhfUyNa3b+ucxedQ'
    b'jat5/VOu12rsdfZ61YAzAN/4mvVaQH3ngTFa6tj2Wb/W570A57Pwex0bqzthbevM4P/JwRcL'
    b'v/3bv32Jy8bADPalho/1+qqvrx7aV81iXf2e3Zx16L2D9au/zTc+YR6NmHMGrIXmOv+kld7r'
    b'0hnYztv70PtPvjVjnqH5k/UZV3fan5qxvvqFWZwNuzOke1nX0gvE6trbHqDW3Na03r/WwZxa'
    b'6f3F6jtL3/7WT31FDVb0t9e450GrHns6T5+pkK9m68bUdoZ7AL4zYPfy2etTaz+033mLOXT4'
    b'xljm6gMa5rhP9dIY3V0/kkTRAxnrm4fqwLqrfSdtrfVqOVh1+s7tBYK95u2xD6qV9mFPfddo'
    b'n/uC/e4n5qwbm1NjHrDM7otJGtunbz++vc5Sq0bMW9PutYmzOl+IqxXz1mrrO8tzbN112rM5'
    b'MY+F7Ste17XZ3o/Oq773C9pbv/32gvWdsz3lNKe0xxnN4dvLvvjYvu46e3tLZ4H7aQHr7F6n'
    b'dfEc7VW/WmJz1UP3AOpw0utjqzPnfQHrzu8+znGu9oR7Ob/Q535ymulZmsM3D/jkqpHtt/ek'
    b'3Vy1rZHjek6z9dWIfnur14J+X6eA/3M/93OXPzH7+7//+zfP+hh3yanR58eTvud7vufm8z7v'
    b'826+7Mu+7PI/cKtG61maWx3Ul+a8D+Iczu+1aq2D90Dqe7/Itb+9ak5z7KtFr6491YBzofn6'
    b'0HmwM+GUcz4xdSF2yWpg6+Jep/q1aypoOkO/emN9rTnx3uwMbK+fpb9afZaY86z65EW9Wqlm'
    b'OdXsdw9zUr971kLPcKLzob2ws4lPPrYx6Hc+VKvdvtbMyakOPovWsObxF/uxfZ+nhfWZp5bl'
    b'XuqIXc2D8V05fiSJP6tqQ5sFv+/URD20R1utkPMiYPfpHNgZ1vaGXdvL2p4dzEv1oI+97fpZ'
    b'rTU2h/bEtdnSM6y9F9X1frkPsfOqrc58c/in+98ZcFvcfGeBOlbnYk/PwPvnHLVgjxBvPzEW'
    b'9BtLtc3DbbVrrB6fBdb2mljeg9ZB23nqzEFnLOpBC2o7S5/lPbZf67Oxx7w0PuWx9fdZnqhO'
    b'jTN2JgtO97G5a1B3XmPYMwix90Q99tq9Ui/m9aHx6sEer2n1cDoTrGbPqQ46f+vO6T7moT1g'
    b'vHlzLPdrbnv0+f8j8LsM/n8Y2gPELO+ds2/DGWvFeVigxlz9E86xB5zB2n2a615gXh9al+qw'
    b'asVa52P32vRPUPfaYc8K95pBTc3ek6WzTr62eRY82GfPGap15m1Uc9ITk2f1tbL7mTPvHK11'
    b'bKneenPE7mEMG+NvvNrNMZd9YHtPrGbPzTLuPYDTfrA9YHxtJguogTV9lr3mtD2XOnCfYt0a'
    b'6znph9s01qxX6zMX+7xOuOv/wwCnhuIG3bg5cIaxdal2e/uAzGPbvxcG6vR7k0FfTbWyfWhO'
    b'exGj0eovnWcdX+wX/Z3fGVj9QuxZraEr1/Jg7tpeWv3i3NP++Lc9Lyx7mqv1LGrVs+wB9WCt'
    b'Oc8ArWE9l33Q81bTnPnmCnlz+tjT7NbNi7UH42vNe63koZpivrXNsXrPiz1F/T777qHfHJgD'
    b'a+0p1daH9uIbX4N6XydiD9a8c3uP91rltK89YO/ueW1+86VzrO0M82r1q1NrvlroPMCHxqzT'
    b'vrA5+2TzxL0maZ/nq657YInbY27nEjOn99I+/PbtTCCvba2x/aecMb7gcxbhbNWzmoPeC/vv'
    b'dZ+cU+yjBtVjjZ2pD86y98HQmdvXfagx373EXDXO0XY2fuke6ljq8N3jNLs5aG9nF/PtNSfE'
    b'nQX65Lvnngud/VC/qNXf8+hb67XYu7Pbr23dmOVM991eYvVatcSep/niHDidHex3hnguLKBj'
    b'GYN1a7u/+5jHL9ZlY3tPefAsntt9AH/viXOc2/lgrH/nz6oqdpnT1teqgx7QGfrewGKt81ZH'
    b'zjp5Vh+I4JNTb881Wu8c55prrZBnhvXTecB9jDfvPRPmsMD53Ue9+7UG9jbnXlj6rTWvZXWv'
    b'atWV7uPZ2t/Z5J3TPKt7gffBnr0u+4k3h908PpblXvjuUR1r81pyXucJNOpBnz77ma1fiJ3f'
    b'GWIN2o9vT+uNuxc+tdL7a6+ak54cs1n4LFHbe1iaw+/s9uKzvDbQ7n6snaWG3LV7fkK92p0L'
    b'5tS51LmX1vtUOtOa1ueGptfPfmDsfMHfudVsHbw3xbh9i3NdhZpnFWdi9Xfv1XS5Bz4Q7+uP'
    b'ed47aI99gMb7qgacpbZ1rD2ti73tX1bfWUAOvC6wjiXn2c11hr73tTOqWbofdAa2NXzXzlVn'
    b'D8s56tRI+zpLtrbs3NrTPKhm+9D2molZq0UD1qE9Yi+0b+k8aa/PnLj7sLzHrXXe6l3m7Vut'
    b'Of3O5DxYoe4ZPQ+o7fztc679gEY9y5w4x3MYqyfvXPsFXa8F1OwctdjTTPu9RtCW7uN8Y3PG'
    b'sDGsDr+Ls/Uc5NbHFnIsetWaY+2M/6cihykWD7F1Y6yrfeBBvNGdQa4z7HU21pyoh/aWUy+5'
    b'000hb39zYI+YB+6JcX3Ya+0Mcbbnkcb2myNmecZasUeqcb/2GK+v9ezUXKshh45492BBr1W9'
    b'Ontdoq+uNXKuYnzSA3v1LFL9Ps/uQx6fGYV831ixxGAPmPeazXmmnq190B5xj+qAGK1r6+Cs'
    b'a71ijFXr3ELN84Aae81BZxrrixpwjj50hrmyM6s5+Zz9NAeY02eDVp+e7gNogZrPTQ2W2AVa'
    b'a/rOwXdJfWdVs/uCPrb6XlstC52z2mOtedjXpPfKuHp92Ng55szXdlVfC/pquB78ash5nTsL'
    b'qIlnlfpibq10D+/N3oNinsVZ7GFOz4PfOe6jnpw+2AfmtwecB+7fuphzH5Zn9B6qIe9cc1hz'
    b'rGK8em373LOYcw4Q77mKOXuw5E7zV9u6fS7Adt41urd+6VwWoNuZWxeu/9r+6NHaZ9wc/c4j'
    b'1+Vrhfn21Ba10PuL1beHus+t7FncC/AbS+v2NG4OjK27ZzX1e297H6A651oD416XkHceqMW6'
    b'Oqs+OBc6Y3s9/0Vpsg0dbF6IPTw6tTsH3KgactuzF11/oYf9sS7zjb0RQp551UP3Lp3VPnxj'
    b'fRaQ85ql1wv4rvbVgjUttA7uvf21LDSeq7n6arBg3JwY7xwWdEZr1hfy3qf1nUEOiJ3f1yG2'
    b'z9x+UNO1+eJ8wFeH9bUn+JzNs5hrn7FsPzi3NXuwXr91rHu4BH9ngXlozd6tnTRizetm6fv8'
    b'YK265vfe9VrxnYlVR486oUaPGvAsrBPNd56+8zqj84HYBfS2H/YaOw/aD+gBDfla+zqvEHvd'
    b'xiz3MG8/mPOcLtnY8wk19/Da22PdBT0j6KPd+c7EdtZpLzjNhdWwOq+xGtGn7jmgPS6pD+js'
    b'A+pcq7azd459+C7vk9rO994UdWuFXs+zdH8wLuRar8brMqdFf9rP/NauXVfXvn5K56HbcxVy'
    b'6HtWfe/Tak7ns4bVh57lhPX2k+sCzqLGfHtqoTm024/vcg9QI8Rer3p96GxXz4Zv7D74PQ+W'
    b'xT5qWadeqW7rxn3uuwSfs4AziPFdp+cNO0//NAfUCTGz1Z2wp3X3wNqrrx7UiTVyp3l33qJO'
    b'jd7M5oVcbzao7bIG+hya1Zts7Dz9xZzzwRsC9kt1sjF4FvtZ1fVszetrqfc8YI+LeCHnHmra'
    b'U6xBa16DOXQsILe+luXenL2YQ2vN+eacA9qexZz9xM5Ap1/sAev0dz7+9p9mAVqXsazPYo4+'
    b'y/06vzqwZg+Y632yJsS9jlM/MAMdrMYF5rWiZnvxN6/1nqsBYzWcqffHWVCtOTVAzrg5tb5m'
    b'oP1ibmvNOwPf1RlwquEvm2vsM2R53wCrTw2/+xvb3xjU7rMwD+S0zqjeun3NgbOsuzdYg/rQ'
    b'Pl8D0Ocm7slCv3HpXBc6aF8x7tmh/Sx8MGZtD6jlWrB9Hs7Qbw7ohc0Dce8VkHM/9d2v84Sc'
    b'PcZQPbavxWpZje0z1z4s57EmrRfvWee7zGGNsb5m8MUecebpmsw5Ry05NTsP+izUib1Yde1X'
    b'rwbUsJrv8wTy3idj2FjMg9eoLe2zB0tee01TiF3eW/vMi3mvkbj9ak/32rmN22MdPId1a2qh'
    b'NWPR19qr3WdkTo25xpyJtTqsOcA6v7P0T9gL+MbO1hd8llo19mlBLZA3tl+qu/wOAxeLwKY2'
    b'g36HALm9IdtTv7oTnAOo17e/87SszsP3JsFqpXPZq3VqLPPgPQJz9riE/Yl7lpNuffdzL1Z7'
    b'sHsG2PqpBviu6npe54NaOF0/Oa+P2kkD5rDuI8ZYr9+81O/91Op7HeJcFjVic9aFnHHrLs4G'
    b'6mqhZwd8l+DTI84m73zrWvvVuo99gO0M7xGQ33vWeq/LewTuJ/XbD+5N3j0A3zksa9V0lnuo'
    b'F2a31n6xTq31ztI3luatdQ62eSA2X+ta7JdrvaDWms8IrJFTr877v/prc1zG6FzX5oNa0II6'
    b'Lcs8OAPLfDXG7bPHnOg3h0Z96Sz3A2d2hvfGWuf1de0sz9sF5oE51UK1sLF7s+gDLXhu6ntO'
    b'Ied9tq7vWbym5lid3T7oOYCa9b427AV7YX2WWq35ns89rEP3UbPLmpx8dPVrd67ge75qYWu1'
    b'avTJWxNrLO9pIdf8aUZpHp3gMwe7ry/YeeS7TpCnTw0+q/Px7d/X06nXeNfqd1b3kc5sXBqr'
    b'c1bvO7p9DuS677U6lthc68UYyyysC31nuZdzgRoa6R5qpPnqgNj5l99hUNCLLTZjXdKa6DvL'
    b'PYp7VsuhzJvrBQM5l6BvzutgOUt2z5OOeKl261vzPODc3Xch14eu3h7xfqiR7nfKQ3tOz9ra'
    b'vvhY5E71noclPUOfxy5A67PvbDEHp2fbOfrWsfTTt/qivr6xFnoWIGa5D1ybv73M3efgvizy'
    b'1jxDc8xTV+wHavrQ2F7P7z3aOpz6iv3V3dZjjK1mV++Z/TunUHNtDTp7415/5zjLvFrxOYg9'
    b'Yg/snNbAuK8LbJd9rNto3fPS63KWqMee7jvgezYXOGdz+M5yXyBvbK46Z5Dz7Du7tLbX6lzr'
    b'YD+5nUWsFuv1Ohfap7ZzrFsDfNdq1ZH3vFjyWqDe86jtXlhjc8vuv/eodbhNQ+x+WP2FnJri'
    b'faXmtTbX+36Ced4TY/dojtnNq9MX/epXy3613hsgXjwH4Deu3jzW2dax5tSZg2sz8Y3RXOtV'
    b'gzVunz7YV8itDnofe588B1Z/e4mtwSluzv5qQJ1Qd5161LPIe9+LOfvqA7EaF6BhVW+tVNde'
    b'7yd2+9UDtjPEGNtnQyzWrWmPb4mKAVu/OAQc3g262luNfduvHlu/vWK9vX2YWvAG9QVAjeWL'
    b'mRqYV1fLssc8ffZq1QJ6aH+hx1xr24+1H9szFOuw9a1tfWu9ntM5rQMa8+BeLNDfXHXNM9t4'
    b'5wI1/Mayfud01uY7q7nq8Hs28DWEtQfUFmeD2uags/FdaHwOWPdT56ylZ+g+Qs5rkNV1tpac'
    b'utb1rbOYf22PXgeWXrW919Us3Q+co7+1Wnuxu+xrjz7Ubx9Q89pY5p3bWOqLeiFmLtbXQ+eB'
    b'OZZnOOm9vy7yoG/dfHGGSxqvxudK3hp73MZp1uJca9jT+fSpGasrzVULxOZqO6M9rtWqJ/Y+'
    b'Q2tgH/jcWeSttVdOvv3iWbDeQzCvf3pG1O1lSePVOBPMr1/rgvaab07I9Trb7zX2esivhrrz'
    b'dw605ur9M3eCPP07D5jhAnXOcp/2dl7z9p2uVV1997AP9hyiT12tELuPmJPG1UnfHqi31/he'
    b'dWzP1x6vqzX0LKgP6mT1oKb5+p1RbS35fV4uNI1ZJ01z4LWK8/fe0Nu93e9OhgaWBdEn7wEA'
    b'v/pTbemsWujhlp7HnubAeLUnffPA3sRq6kP1qzn1nvBeifenvdA5rhPorO/em1PbuH7rwDVx'
    b'vuqIvQbPbm/pnBPtwfYM3kvo/XFfa+0H8/Sbwwdqzt0ZavDNg3nPANWjtad+64taMe7e+OyJ'
    b'NW4NvBetgXVo3Xz1pxps3UXsPWy9/dQbS7XeH/zGYH9zoNaz9AxgXOzRh95X2XmNsfaszpxx'
    b'z2we2gd7baBGHfPAuHVrnsGYuWqAfPXbS9zXkct+bP174Wznac0t7n26H9de36De2YBGHXkX'
    b'OAeaY7GPUOscOfWLevJbk9bVu7gW+4jFnK89sO6s9aHxSU/Oe+vydYOm52kf6KOxB7TVtk7e'
    b'+YDf2PMA1jOYg87Dlz4/2LnSvPPBPJZlT/XgntWW3cvVswK5zu05oPrV9QytFc+hrdY9PBtQ'
    b'O10ze6kRYvLVdP72tr+zAX814Dy1O6NxddC6eSy5xoLfuj7U9r6L2l3W1JoD/M6Ak7ZzYPNY'
    b'l/3WwL6+JuGkEedde+4serwXl99h2KVIX04xiwNioRvgqzdWB/aD2q5qC/nW10JnmCfujSFf'
    b'HeibN3aZW8xp+8Zozpve+wXUG8Pu5wy1WhfUVmevWNNfyJ2e3+7DdThL6zWCedBuD2Bd5vuc'
    b'SutlzwtoS/eEnW+sVX9tjnl9LWfZ84F1NcQsfPvbp16fBWqdZR6qr+W+O3trWPsEbc/lgtMe'
    b'rfvatxfb+ebUS2eIce9L93e2a/P1oRpnqmPB9oA5dWrNiT3qS3ta02+vlpzPgrhLTe+34Ktp'
    b'HpxpvnV6jPWx6Pu22yVqsWhbA2qeFf/B4AxnQnvJ91oEjcu4s9qzOn3q+lCN4KtbfefjN4be'
    b'o1r1Yk7wG8P2gBrvG3WXryd7PIuxFpyD1V9aYza4Lzi7cxtj6W8M5oydrb6sVl+t+uatYRdr'
    b'7QNz9rnEvqX3w16o7ZzTa7Rzr824DerVbuzMnhW6lzXP4mtHzJszBnPY1l2tb+yS5rbWXnzO'
    b'6GvHWP/UW21r0LmCnpnN7Wx98i5Q1z2v4Syoznks51Tbs7WvqLe+e11m61A8CZqr/5zAHOle'
    b'5rVcqDXWXmT7tIXYGmir84VjrXsCVr05cDaoN1edvnVhn9v0Xmt7qLl8EYh91S+9VhfYY4wO'
    b'v2fbua2JPdUyC9RqPX/vA+xMcK49xp3pDHPOK56lbG9napt37m3znSeNT33mug9wvczcWdVh'
    b'yXlvxPqpV72127Quc7XW9r6ql90Lv6vPVVbfvp0vq4PTTNC/9vp0FvT8QJ5Fb/tYq2vc1wfY'
    b'S8zqrJ1zqm2PPuddnUvNXrfaPaP4jMDZ3ad99tZXV0u/M7BqRR0L7HX1TNBaF7gPdA6crLO7'
    b'P/n1t671eqzrqyn2awWt+tXsLLWbK8aejeVzwzp7+0DdCfq6BN9Zp7q17tce2H2p7bKns31+'
    b'5LWr0Vcj5K1V41nIOc+ZXWqxi3Xs4nz7sNUag7nOac4+cz3PzjAGdJt3lta69G0FDbH7Veu8'
    b'zjLntZNzweqeE1t/Z/ZtwLz7cJaeB9SuD9WSt8f7AuS8L+AMVnXQPfWdra9VYw3wXaUxPexb'
    b'y7IG6PWLcy69/IdEb5pY03bgXvRt2NM57NW87DnsgVqWffWh9dWw8NkDK6sX9dZY9qrtHNhZ'
    b'WDW9b+0nv3NADVQvnQ3VO9Ml9pjzTOaxndN48/s6uLYnoOfe3bZfe6yBVqyd9Fj22ZlYNafe'
    b'LnPqqjdmwTW/kPO66XdWIVcNXJvlDJaaWpd155V9DuBMF7ViDmtcds/qyO3rw/lac1jPB8RA'
    b'zfcP6rSArZYlavWd0zy0H7/xtdwJ81yHvrYzsJtnea/Md5++D8J6LaV6z9B50Hts3UXcHnBm'
    b'zybUNo/fPZzr26fzQJ399jauvj40Rnua0xx6rZjTL/bbw0ysPerrA77PS+ovnYddLXnvldfV'
    b'/U54VkC/94PYMzrPmn3tV2NcWlcDG4O6zpPTDKhW6+uJGvT69t4v9rUfnEE/PrgfULPPZd5Z'
    b'9a3X6lOX1VrTt94eY85qzALPDvaq87mrdabzjOsLsffIPfCdpQXnQefgN0bn2YDYOdWJc1l7'
    b'LYDf6xf7sGr03cdYH9oDWmgfPsu9V28dTjWvQw2QM24e0LL6HE7a5qF7trZ54zv/p2c3lG3g'
    b'IPqiRuuD7oVRa19voDkssTfJeWtFze4hrTfvPixfIM333KBfnVpjILZmvTpoz/q9J9awnqer'
    b'vbULutbsW5rvzH0Wp2cqpxmAf9KeYnPE3btafGrQmlpz+takeem8LnPO6zl8WzixeZ8teWv7'
    b'2ivGnoPYM+KbU7cWqtd2nqt4TWhE32soew2d133EXO+3WJPO1cfq9zzk9nqpk+tenrczjLuP'
    b'eFZs6/os68Wa+fpCbs+Dpjr71FQL1u3ZmlhXax/7m2PJnotrtAewxmrEWVvbPJZ9rBVjtaC2'
    b'M/Wxrp1Vvdex+6rps3Te+mDcc0Jz22Netkft9gGxzwTQu1YLnc0i7rV1FnSuPcZirZrVNW9u'
    b'Z7iuQa1znSfXfLRcV/sB35q+rwPAB/uwxr5OyOuLOueIsbb3GuuS+qXz8XsuZzQPzupZV2t/'
    b'Med9cQGztg+/GKtRd02vhtU9pfOgr91CD3lrnrVnbh3rPuagOVdnd3/y6sE8qLe3M+xpzteG'
    b'NfPsZ03Ii/ntB3znWMNXa17YC5zf2s6Ry6vLxBbB2GaHY93w1N8+MN4eWR10xvraa3rpXOu+'
    b'CFbXWbDzWsc3b2/Xzhb8xos1LA8aTjPBfP32byz2APkuYe/m7PH5Ufc+YqlrOx+8Duuy862p'
    b'twbWWXumzilqd07pPLUualsX56ipr06/ee8ZaMnJSUsMPhM15nee/d7H1YE1sK6F+sUZPVsX'
    b'OZ8zaznld4795p2JdZkH+8wD1+f9Ure+2APOorc+emMWsffQmjM5KxCb0+/aeyjk4F65a/5q'
    b'a9nTc8P27Tr1kNdSPy1YWzq/eN9BjXi/oLXmpXt3npAjptfY5+wC62LNfnNAzrOYE8+A1W+/'
    b'+3SWczrT5+Accs47sTrndD811ekX47VCzPIZnmZA87ftA/gsddiFnNeD35nVt9ZZ1Zyovj3u'
    b'IY3tuVfuhHv0mgr95HwtOM8zqW9era8lNVrrYB+2rzfYPbuH4LsPejVQvTqvE8yzgH59sIc5'
    b'p7lw0guxdWzndEavu2fYfVjO77Vi7Wuuc6xZd55xIe88Fqg7WVbnGVfDPM9uHpxvP1h/9qvk'
    b'WbTphAPQYdnwRPNonYvtTdTCzm5NyAEXqS8bS/PM63xW96+VrYNz9vp7853dPnxjfWctp9re'
    b'19I3CkHjfmDc3sb41Ru37hk6m1xn61s3J61B+0BrXvA709dBl9QH4s61bq6zrW/N62zO2F4w'
    b'J8b0qyNn3PtnDYyx+3zJ7T5A3iWrJWbe9hOfZhZn7bXUUvPZAHn81YM6cu3H14K91ZqDzrZn'
    b'e8Hc0h7Xxs15jtMZOLerGnuEeuesziU+M3WgdlHjDHWe6bYewDe2B5rHOst1ep1urjgXOgfc'
    b'h1i/uP/pPkvvWesnrVjv7OZFX+012lNdffYp1rDUnEFszbcdME/cnJBr3Jli3Tk9E7nei85y'
    b'tvO857B7gLP0RW3nwM4g7n6Ab94Y30XsvPZqq13UQGeI8zqrPWrNVStbc4a9WmgeVnOqAX0+'
    b'dxe0z9y161x77XV0er6wWnRqAb2aas1rqyHnPvVBPfR1CfXR9N7Yp+9a1JXG7Ll12Xn7+mzf'
    b'aX/rao1773dGY+g1L6f7dedJ2UByV2tAbA3UmC++IKoFtN4gON3Yxj189znNPc2xDsT7cGTj'
    b'3nxneJON8Vnmr6EeOq+037mrVdO8OfW1+lB9NdJnAupPtE9fS58LyFdfqpFTX+vNu09fQ6fX'
    b'i3H9Pl9ntk6sBvBbB/Zyv/adNOTlNIfYc4DWfaE9vuaa03c/YtfOhdbME58ssKdnhZ3pLK15'
    b'WP+kYzac+sEYi8bVvOfrAp9le/Fdi/q9z9U7x5oQe6+MYfuIPa81qE5aF3Kd1b49d2fJ9oO6'
    b'1mB1UH/347paB+Iu0dc6w9jZ0nNg1bePHn01rbug8+o3Z29nqMV2P9l7oI91QecszanR+vra'
    b'XmJrQCzVOWPrash39ubFfJ8TuWrAuHl8+4F4X0v6xvrkrWGtgc8D1JDzvjhD7IfmZevEzlVv'
    b'vFpzu/e1HHbPX+xR61q21pjl/bDOvO4L1NwHVkPe80B1J6xju0rvye6N7/7E7qPfWOoLOeY4'
    b'G3va7wR5a+qrJXZ2Z1YDneFqjzTPAp+bSw3od4Y1sQ/QqdVvDu78DkOpqBfMIq+9hjPt6QsJ'
    b'rPcF14e2eJ7O1TZ/4tp5H2z+pIHuie8C9K7bqF4fa7z1rs7Xb00r3uvmdg6oc1Zp7B6gbQ6c'
    b'3fnUXa1vTvSp1Rb7+lp1zs6y31pjfF6r7bEO+Kz26rvAGqjhbH0GatWBOWgerunAPczXdn/j'
    b'1Ruf3uFrV9/Xyd4zcKb9sL4adZvbvJAHc2qFvNerFWrE2oXc5tH6jhmoE3u/uheoK85cDZZ1'
    b'6tX3TM440f1FfWfKzvIaVtszrG986lHTfeqLr52dAeStdZ1qxqyi/sFgb+fJzgX31i/Gzmlc'
    b'K9S3hvWZ4p+WteJrdbXNiTH7eEZQg20e7CHP8u3AvLjfzrWneTnNKJ2nlthcfWud53Xa67JW'
    b'rJ1eo9aag+59ui89jxZ2b3R7VvNATN2asTk19aH95rw+YzlptdZgdWoKGvJaV+e077a6M9Zv'
    b'bvusQV979bXVbm73YJGrZZ0w3zp+XyfSWeZ9ToA17uvA2frY0pxa8V50BjS+vEodLsYVushh'
    b'T/lekDcBrFsD9eaxCzkXmn0DOfUZW7O3tlyL1bOW0yx1zV3z1faNG/A713hZHbRn88b6mxN6'
    b'fW7uwSrta928OeN9HWipu9BwL8AcGl8fYr5sL6ghpk7sgtZla9jd+8FwmiPOwOpX5yrEaJs/'
    b'9ULniv3OcHWGsfeRuL62PcV49xB8a2KM3dpJZ47YZ1rICzU00Pn2WANyapyxtr1AnvvDso+Z'
    b'1Qs54+b3/gL+xuAerUFjNS6xr7Pwa9X3vog12BmgldaKewHWddKaVyPmtL4OnGFO/7Tktpzg'
    b'72vlNqx7pu0H56+VxvZvTtt89/a11Tp4JnHGSbeg6R7lNr1WzcZaoc7SBzTmWbddX7XlpFVn'
    b'Det5mt+3Ve2yvY2FXGfLxoLe17kz1TrnXq8x0O/+zWnNYc2X5p1BvNpqYOv2em9h5xZqneXb'
    b'RfPkvFfOErXAntVgqXde9fhgrZDb+y/V4zuv9CzdV6uvVh/be1fav/fJGaxqYeeXO/1twDfG'
    b'7nCovlY96LPwO8sYrDvHGrEPoXo4PRzrzl8f8DdH7LmAmjrAuqzJ5hrjl/ZJ+05ra94r83Ca'
    b'u7X26DOr2KMG6wsNOovc6qyDfZ7X+8sqe4bFPfTBuPt1jnnP5AJnrJVT7DXIzhL3Ic9SZ97X'
    b'rJpirvd7cV5Re5oHWz/pyLm6R7U7zz799lnrPOy+RvBPz1+NM2D7XFuvDnx26kqfa8+2Ft1e'
    b'i6tnVNO8NXLS/Na3p33G1qU9Ytya/s41V9+4Vt/XsXPBHKh1v52/VK81L/VBXWeDOZ+tq896'
    b'MX/a1xz94Px7gaZvy53Z/fZMxK2L5++87W8dqrXmOnGapfbUc+36hJpzjPvasV5NMX+aDdtf'
    b'n30aX9NDY3NQH9C4GoMzpK+XnUPM+fqaPGnMuQ96ffF+AvXGS/fY/Tuz7BluQw09aq/1qHG+'
    b'5zYG/I3dw7leQ/ch13tlrRpxvveu87q3oNma+va618b69mtbh2t1sJ+1eZd9QNyzeW/K9qAR'
    b'rxm0ly8YrrHD0fqA3UjrcHvqg7HrtK81cDb04PYZl87U7xwhJu8N7MzGcK8aZ7umwS+rK31Q'
    b'+ujtkcbOWKsG6/MC5+3eC/t7hs5mdX/oPcQS67vK9hM313jz4LzWzHmt22cd21hu0wu+S419'
    b'+L4OmtOq168OGtvX2NziPC34ttKZoM5ZWlDXel830nnSOfjuS79n4TWhr17bvd3TGeRqnVGs'
    b'LeStWV9ta8U9tJ5LOgd/31YWtd1Pn9nNMWPvFeBbdznjtB4M6q7pneUZ1fVtnoUPnku2tqh3'
    b'zs6rD82zYGeYqzWvFevgHNbOUme+q/ntrX/CunvYD+5pHtReo3u1fyG3WteJPdO+j4eNsd1D'
    b'v7PU2Nu8sbRffTX45Pe1KeqbA/W+jeNr3Wd7TrFa+7d38y7f1lcH5gDfsxq77D/1kmueGXBt'
    b'DtxWqw/EQr5xMX9tD+LWWJ2lrrnVyGqu4T59zSzmsOrxjbF9hixobA58X2pdqqNmHWtOaw12'
    b'RuvWjK3B9kFrLmPt5dVj0YayNXwhZ838SSe+WAGd2tI+ffrcB9aXzqxVj3Xx4HwnAeoLOZf7'
    b'GOubL9apVb80355l93ZutfguZ2F771xiv1ZWh3/StN/YXvz2tMYqp345zQE19oGvL+I+2/aL'
    b'OWz3qy/kvI/q7fcdAHXyLmtgH1gTY+tCvn1izrw6aV7MtQ+MWXsO72XnLKe9ybHo7wx99dtX'
    b'u3s6F9u+Zes758HSGfh7L7TWTvv0LNSrMWY5W9q3dEbP5AJ6q3OW+a2X1bi8Rmfha8m5wF59'
    b'2F41zRXrzauV1rG+rZlrbG5hZuca29OaOZe5Wqhfdh/orO5tjK92bffRb67PzHUb1bSvcTnl'
    b'Gutj669lDktWI93vmp5nrk4NfjXtxV+dmr5d7/vxzlioa9Wa2z411k86csSu1UJ9NTvDnMu8'
    b'/uqJuW78Qt551rSdgb/xshpxtjXt5utLa1J/Z55macV+bXUs8u1v3DwQl2pP8DpUA/r2uAes'
    b'7xLrzZXONK4e+4BfeiZ20+IHKHDQSecGnbsz26vvap8a6Iz1XWAe23446YCc+q4+rGr6zoT4'
    b'hHWpbn2XbC/4xsvyLCeo9WzGXsvSedfqt1lpXr9z9aUxfq094AcBqQ+d0ZrPaHs7u72LOmvO'
    b'skf6WgD79Isxej8IwekaqxVyxquX7tk8ELsau7+97qOt7+vQXK8DyAF1MQfO0Hct5NpXyLug'
    b'Z+isPpvarttg/knHXLDW89gjD8YXc86R5rXkWNWak+qlfWK8edh8rTWxBtX5vsccPd5Dcc7O'
    b'aw8Q228N31hd61hrLPNiXdbf+mmO+5rDrk7fPBBbF3PmsfbYJ7fF9oHWmRsLee4d9l5v28TN'
    b'sTbWF+qb7xxtcVb1YCx95tI+MXfSAvn2dL/NmzO/FvC7F35j+9VZ64zm8NWbA3tv64PqfNbF'
    b'2Frr9jWH35kb6xdzzdfv/OI8/er6cQU4v3Q2GKuxZ8+we3Tvvt7YuzUgNt8lnQvupabXo1bb'
    b'ueZk9zBW21isFeLq4a732hZWaLy52g6F1RVnlVNOzGu7lz529+y81n0Q7a0WvzPUgfm+0Mx1'
    b'j/Y4X5007wsA397q+8ZLHb0xrBbUdh9jc2K9oCmN1dae/BPOOWk8l+vaGzS25ylo+4y319mb'
    b'h/rUiZuDU6zWmWDvaS+vC8ypv9bT2bB6aI+r94JV39XX12kfwaduTttecupag60ZS32wt31d'
    b'5E73Erhur0t2vjOhugVde9Wa64y+Zlnu0b121mmOUOsM31fA6k6gqW7Pp78zu6faxmrAGuyc'
    b'Yq2ow1L3fZuQc6nRivq+jn3dF3tBW1oHffIu9sCeQO8M9cW8EHfZy7Iu9rW/uS7wdeLcou60'
    b'D1jXF/PmnH2KzcG1evO1UF8tOWf0Wa9Wqy+taTcH9U9Q9xztr69l9XxwOi+srq9hZ8m95hZ7'
    b'2y+t2X/SQedXi98e5/mMYGevfmeAMbXT+72+La7tPHxje6U6wL+2RN9elnO3hrUmG8P29d4R'
    b'u6zD1qU6rLreL3NauTaHdfnI0UYLxuZK9Ut7r7HzwRy2dX1ojD31qzm9uKx501jWoH5r+4Fn'
    b'dSxA5x5YdVp1snNqxTksaiz24RqgeuvVw/qe0xjsLdSqqxaI8bVymmWsXl/ssQatg7VaV6Fv'
    b'35HsLNleYrSnmeB+ali+1uxZWzZHn7OB+mrMVbv7NX+tZg7wWZ5d7BdntRfMVXsNZ6htz2lu'
    b'6/gszskyp/UcXV5T69XbD61B9cVc650jmzO+ll9Oefekhu0HEtDXOoO4OvKtda/mgVi/2vbA'
    b'zj9ZQOfaGV6Ped922wNqGp8sGpbvI8mz7LXeWn3r5qVa0HdW5576i7piT2es7ra458N6/Q+G'
    b'7tVz736ye0lnNL/xCes9i/7GJ+3ON8aqEXJdrTe3febag681r9/c6kGtGKvta/gaO5fYRa4L'
    b'tML7S3Pb4xxr0rzs3M7oHr4vN1a3Pn36cO3tuXogZr6+2hP2VmMO1m8s5rA9M373tZ/Vt832'
    b'tYdYrJurvrrV1IJ1cs1Dc2pq4fJLz4rAwubvFdvnBnDStMZNw9oL+MbWdsZq1JnD2mNdXw2o'
    b'q16q6zm19QF/rwe/VuyFk8b+E7uvmDv1djZ+Y2ivtZNmuU3jOZxrDOo2f9IA/sa1O6Nza/VP'
    b'swCfhe40+xq3zeMdF9b8SasG1FYnXoOrGs+pBf2d1fnYzmt/sad9sNcHziund/auajcW8p1R'
    b'nCP14fT2C/Y1B8SiX425PQfx5qRz9EH92tKe9taH9m6NmLoLsCfdKaftHvrW/SBd0OxrZPev'
    b'dcH2qBFr6rYOaoAarwWsOvv0gdq1MxO3XzaPbe70dmLssvcazlrdqfdarnZBT631034nXdn6'
    b'6k4z1bOs28e9O/VsTr05Z/l+A3aGPeA8cvYal1Nu54C5k9bZzqrGOmzdHn3t9ugXNbWw7x9d'
    b'4CxjaK0W7DWnzx4+B/eT9ui3XpzLjO4h+u5x25z2qzPXWrXSnP1q21NNbVEP7SPvklN/70U5'
    b'9TV3en8NPQv6xnf9DgNFBc3DtVwPoq/OHmd2dpda+8UaUPMFtzow11pnLzt7rQvQsow9x4nd'
    b'ix57W9M/5dxH2rs1oU7tVKdmvTQ+9TbXfs/Suc1Be+u3B5o/5WpL5/R57Guk1jes07zds3Qv'
    b'F2jBuujva2V1p5gl1FyLulO9sXuwOvsaarbP1dk701o1S3tu63U/lj3V9B2euqIWWiNvbfvI'
    b'Nz59snLNL6c8Oc+M7xl6Hmhvz3PN2t851JpbrZDfeYsalrOc0djX+urVGC/NbZ2e4jy4bZ59'
    b'q9l5GwP6vq9whnOuzeg+Yu70vkd/80CfeZb7O09bmnOevcbiXDj1CbVrcwvx6lzGrQt53yao'
    b'qy/cO8+hvrE9+uSNwbfhRR1Ybw42dn7n4ZuHa3WwtnPBWnvJ9X1Q+/A3PrE6ID7ttbF9zV/z'
    b'5VQ/6aDn6pmq7zlA/za9cd/fsnZOtaWzRb3od/bWq1la297SXrWl9dbMY9unPX1ucgK9667/'
    b'DwN0cDG3dWNn4O+SarStw4OJnVN6Lqxrab8aYnOn2VJdZ1/r2f03BnO7/87vB2NRs1rYvYjb'
    b'C8Tbq6b2XvPNQfdpXuyrpjn7W1/L2jkbi3p9dVj3gurMVwtq1MnOWr3oY31HBuqhvWutrQV1'
    b'0hjd1kv37MxCfmun3Anmuozp637a6pyvFrTgJxLOOemh9c6p5tQH7OHbHnVtfedL4+bhmh7a'
    b'45I9l6ixjnV+c8W4+6wGrEn902z805yl+2ndi7i+bFw6qzrjE+6xetm3T2rW9/UA1tW2Juac'
    b'sxriaxrjaxZOOfqJtdZ2r+brgzG0zj1yTvPVS+v4sr2lOXxW9SzfB7BAK8Q+L6j2Ntxr9y3k'
    b'ofOhvfZtLzTnPrA929uaPXCtZzXQvcD9nWFsTuqDcfuMRb+zWncfqV6rT82YRczyGVQL3QeN'
    b'NXur1W/PCevVn3qou89tmqJGa717LatdWu/q+zhAR169cdflXxh2w+bEGuAbOxSary+nffR3'
    b'PzjpgXxr5mVjUHeqgfOwq3E/NbCzGqtrbL0z1neJvrbzWMbSOjTWx9pvfvtErbZsbmdpq2ld'
    b'dkYhNld/6V5q3Mucfq0+qDMuqwP75eQ7T21n950X6Lf3ZKHak35z0HzZ/KkXyFur1YfTHs7B'
    b'uqQ1oLe6nSXVnzTmWtO3t/vIziLeHOws2Fz7OudePfjba90a1tUZrhPVV9d+IHaV1vXLbXq5'
    b'tudCvftgjdvbuHWsEKsBa+arb6259p98tdBe2Fjf3tZPOdlYTrPLzmSdcq1p1RGDsZ+cbd54'
    b'P4EGai5jcD9ZTWc3Ls3hn+JTb2ugVVe9fuesHsxBtYu6nWfcddIW69B6e81rt6dxuTYbrFWj'
    b'332cr781UbM+1Afrm4dTfmM//p60pzOx9uxS/bW6+VrWzjanRh7Mfs6phdWY18r2+gWFOvIP'
    b'+B+3bQzdHOuSk98cNL96Y/bpXnCKWWKtGvzqqqkOTvPtv8bWdibcK+ce1/Yx37PYvz2neHOw'
    b'/ac+NdjujbWuRjYGc/aBOWewWi+tXdORP+Fs2BlLa107m5xsrajbWe5hb/NgvZgz337Qb5+a'
    b'ztNWr07qw/beRufWP1lAQ9wcvnk56XYvl5pqwfqyOqi2PddmE7PaZ1x2Zi3LufWLM62dNEC+'
    b'NfcB886p1hz21APXfLDvWq81c+qI60NnyM4Ccu1hOU8r+rX1Ox+sQfdYOkec15n6u0/ZWbf1'
    b'7J5oTucwp0XXueQ7vzWw7uocsL5zhLw9ctKBM1ztMydbq3XPXc7cWdBaaT/Y+2BjISfWm4PN'
    b'Ebs6U7v9xtahfkG7e3WP9avVr+2Ca/vCzjXG2q+Fa+cAc12yMRB33sku5LdmzCznyc43xt6W'
    b'A2Jzm19aV8+qVo1zZXX6WGurAb7IuvwLg4OhQn3jDlgdNLaurwasbd2cmNO/xs5ZzLXu3FMv'
    b'tueQ9ra/dF455TvDvJrm1MmpthpYnXNXW500Xr1zQHvqp2b9eZ7neW4e/ehH37ze673eJVa/'
    b's0/cdhYgh0Zdfc/QGN85J6sPp7z9jaE5IbYO6ze23xnU6teW7qH+xO5FvPPaj6/O/CkHq9F2'
    b'udf2FvNoTjpndJ6cZjpHfy3rtKfWVVqX6gv5hVyXXPPdbzGHZe15aou6ntc9Osecuq3V2iv2'
    b'LKvTR7v92s6x3zzr2gywV2u/MwC7Othca9fYs9hjXgvWNye7720z9GFjMAfXfCB2dZ5xZz4n'
    b'2Nu5nWWNJebglG+u/gnq7tde/Z7FGrntsSbGt1lW50hz3f9Ez4Lt/FNv9d2zPrS3PbB9LkFr'
    b'vHlozVx7YGdUpw/tgZ0jzW3d+F6z8Ls3XItPeXOdSW73he516t2z1KdWXbWtnfqr25kLdXV3'
    b'/ZWkFSvqQGNr4Ixqja21jg9qYXONNwftLWquzdsZLHIuwHb+6sxprZWT7l4452EPe9jNT3zV'
    b'K9385L965Yt1D+vOqq8tzW19455Xv7SurW+9vWrIvf7rv/7NP36//3rzTz/st+6vPpudTawv'
    b'nVsfVgtv8zZvc7l/b/3Wb33nDO1rD/7GtafztLbsXvrXLDBvl/lTH8ua1nr7wXzt9kjznaGv'
    b'bd0e2RjM1Zq/DfU7bznVN3fbDPfRF/w9Q+vmWrumb225lidnP3QuNFa39dJZQOxylv5qm2tN'
    b'335obueIWlHbGZ1zjdv2cIarc7ZmTvBXXwv66NTWVqvmVMeyrIGxmtZWp1a98al+YvWgvvFi'
    b'XVut/m39YF3UdQbgW8M3Punbd43qOxecq6bzTj2nOtSHU++J5tVqgfqpt/NZ1W1NyDcW9aXa'
    b'2tMe0lp7XOTbtzWsGDfXuLPAWnP69rS+2hOd6Qy4V5/62vY4y1o56U50bnsat9/cWlFLHv/y'
    b'w4YErgo2BmJzWHXFOlhnNQ87Z30gdp2o9hrXekvneFatELtg5z6YfXaekGeRe43XeI37s/fx'
    b'Ii/yInf6qKt94Rd+4csnxW/6pm96qYE6LDVWe6R+Ia++lnUv0L7jO77jZc/Op/dpT3vaxf/U'
    b'b3jDi4XORO9exoW8dRdUp4/91Hd7+sXH7iw55Z0LW3df8taMS3XYE1vrTP3N7azNXZtH/tQr'
    b'9U+s1ln4re0eYr52+4zVGDdff2eAueZPmsWc1hnd49QHp14gbs5855p7MFTf2aV1/JPOvDi3'
    b'vdpTTrZ2glrnFHKd6yrts07ulBdraqH60vzOhM5qbudZV7O2qLvX3qXngFNvc1I9q7ONXaDv'
    b'LPONnVWcZc05oJXGnbN9gO9MuGbbR25nuKhtHbbeHFzLbR3IWatvrZZa69AaNMZn2SfV1q92'
    b'82AO297S3sU5p96tnWZQa2979MUYbWvbe4KaffrSeZs/sfrONien3ELN5azmxZhVnXtoF3Va'
    b'qNaZq6te6Lt8wdAGkqzGQKyvldPw0vmdA9vr3rVdZXuNqzvN11LbOlybWz22++zZjKuX5vTb'
    b'/2nv/p8v9u9++SMu1i8g1KNl9QuLzoKHPvSh93v31exxH+3Sun2du/tA5z/hsT90f/bZWtZv'
    b'/uZv3rzyX/7Jmy/+4i++v3of9rFkY/cz58zq1EB7oTrs9ttba41lTnvKw+b1ZWM47QWnXrSn'
    b'/Xcv4mLsDPu7SnOt7T6l+tN5dm196bxrMxuffCxr99z9rJ/y26/fWIirAXWrBXKgfjXX+k5z'
    b'7C/kXKJ2c/ZuTb99rYM556zG2VCtmlpr7am2eTn1GZ+41yy51m8e696g37h29ac5XdZk8/qw'
    b'Oi2LmvXbdMX57YXGWyudLWrNnXq3drKs09nAmnX91dcvm6/PjMX67mNu+11Srei3t34hz3Ku'
    b'/jWq68z2WIfqrumBmjnsaUZ7NtZvXv+U02eBOWzrYh/LfHubtx/qF7TOhM7QB2eCdVC3dWiu'
    b'OvPts+fBzCJnvjhb7fpC712/w7DDGqMhrq0P+PZYayzmwDn6azujkFsdVh+05qE1c1pojxp9'
    b'86Xzlubsq+0s93q1V3u1+zM3Nz/+4z9+sZ/7+F++WLCH3wUwz4/68KNLrIc85CE3r/AKr3Dz'
    b'zZ/1/Jca+ONN/f2B533e573zrwH2PuYxj7nUwfNQf6u3eqs7erXkPSu6F33RF7153OMed4lB'
    b'Hb3U+QLGvYh7b171VV/10utc/Fd/9Ve/aDwHeBZ+H+Kxj33sJXY94hH3fXGl9mOe9OoXC93r'
    b'5Pc87odtXbZWtqeazoDG1eGftNXcRntv20Pwd/bG1/bfc4K6kx7o6bzqnLdzr80iX21ndnVP'
    b'VjVgHZoD4vabN5b66oWa9Z3TvLZ66CxpXU59p95r867pTzPV2affeFmtPpZY9DunGnxX50Dn'
    b'gDH2Nm3zUP3qrF3DWbWdJ51DvjXYnq2LM6R6fWftPHvNgfnmQC3Uv9ZbWz3Y05p6aY81c53r'
    b'KtaxrmtaYzSyGrC+NfNb3z2rc4F6rbRPH+yt/pSzd2v4xXjtzr/GtT3NY5u3Viv2yLWavfqC'
    b'b83Z9dU2J8TQHKiFrUnzqzHGOst52hPqZf1re3Z2e9D0DKU5/Y3hrr9/tsOuxXDKiTksS4w3'
    b'f6Iz1ZJznfqtLc23r1p8z3WaXeyzRwtaNc4zBuNqgPhVXuVVLv4HfN7L3PzET/zExYf+iwFf'
    b'EJx+FwD+6B/9ozdf98nPdX90N8/3fM93sWh+8J//iZuPfccfvsRP/NY3v1i+AOkn/Z6Pf/Go'
    b'Xp78hD+4+ZN/8k9e/Kd+wR+/+ZC3eurFL/5rCV9wCHO95kc+8pE3//Jj/9ddvfhP+pjfv3nd'
    b'133dS9x79emP++mbp33ZyzzgLMx4+Zd/+fujm5tf/dVfvdi/88X35bpnrbPxzUN9qVau9a2O'
    b'WKpZqJnHN9Y3NifmWNewx77VGncP1+bLKec+LqkO/151WI2QO+2rbd/OMg/UWK0ZnzC/1j2c'
    b'tzNXL7fFzmyvfvdrHk6aWuvtaa0zjaFWX27TArXanWF/63LNL+R3j0JOzc4wX42Ys8daZ5z6'
    b'7WltOenMuzYP5ESNPhg3b006A4g3B52hpntuT/dp7wnz2PranS2nuac+rAuotYd89WBOf3EG'
    b'ta13NqgF57bPHFhrvDn7pHF1YK+0Rt4FW1s2t/vUdu72GaPFrz3RfrXL9qvp7FNvc/bXVm/e'
    b'HJZFXq12Nc2BPaylOXpWY4x15s6H0xx1+FsXa67qWXf+PwxYG07sZvaxivnW67NAe6Iaewu5'
    b'os4ljZuXU45Z7ke9PvQs1tfqL9ZYsJrnfu7nvvOJ8I/8yI9c7Ed92Z++WH78yPlPf/rTLz/e'
    b'I3/riQ+5xKyf/umfvlhy8ip/5T9dct/6rd96id/2bd/2YvlCgdoTn/jEm9f4az93yfHJOt/d'
    b'P53/Dd7jVy/6N/x/f+3+zLNmP+sLHM5E/m0+7P/cn332nqxr8LsZX/qhz7z4/+8/+uN39O/x'
    b'D1/skuOLohd6oRe6nGXP8/qPe8ZFy5nklV7ple73ns3//J//82K9d4XY2a3pu6c6UNuabA5b'
    b'rVgnf+o5carj2797NL62T/P65Du32CvV2Vu/a+cZW9e/NgeuWcBvL9Yl3bOQby8YN1//lIP6'
    b'J6hXQz+Y3zpsLPTaL56nPavbur699RvXLubR47sE31mixnz3K50J7bnmn3BO9cu1frTVbwyn'
    b'ufrWru1dHX7PUW3zZTWdsbOsn+aa01Z78mFjZ0Fz5jd30lTras3cvVCzMxZ1rbuP/va2tn71'
    b'WvMnWsM6D9anfm3myW+u+s6Fe+WXzneJM7Au40IPOfvV7jyxvqjdHmddo/tJ/dZZ+FJfTjmx'
    b'3/nG9mitN9+9jaV9+K23Bq2pl2rVQOM7/x+GCnaTsnq12PrtrbYa6Lz2nLRy0hZ71dRvn5Bz'
    b'hrY6/FMf7Oztv61P7OvvJPzKr/zKJee/MvCd+s6q3z3xtVKfmr9n8C3f8i0XC7/3e79354sT'
    b'fryo8+F9P+ehN//tv/23y6zf+I3fuPMjP/xSMTnXsnOEfK/3O7/zOy+W/FOf+ux/bejvbwhf'
    b'DD3zmc+85PjdCM/iv2ZUy/98xHPtGddvnz62/dI8tLd5UItdnwXm5FTX6sv2gvFtc0QfzckH'
    b'fOP6zlXP6l7VnWJoXqh3jn77Tjiry7wzm4PuA9VZaw5ag+b1of1grb07V8yzbptTv/WtgTHo'
    b'b845zUtrLmdrob50Njwnmmrx0RXj9renoGl/ddZOe4Da03z1p5p0pvvASd9cffpOZ4Odp5Z4'
    b'57F2lprVQufszNMe5rAuUGdue7TqXGXj1TvbWmlv+8QcNF+2R/+0lzn91UBn3UZ1nnPnGZ/2'
    b'Kc7avYk35yz30+4ejdWBMxu3v31qwBlbN6f22hzr0NpyqtnbvXZmfems9Z3V2Fx9wNeaA/Or'
    b'K7fVSmfjb4zvgssXDNvQHNzLx9q3XNNoW1cD12wh19Xc0tnQfeHUR1ydPtSXrRvv3M0T4/vd'
    b'dnjUox51WXzyLvys/4mdD6cc9Ixf/YnP+oLk/t8bYH3iX/+Pl/zLvdzLXWz5+Z//+btm/tqv'
    b'PftfGaR191kL+I35lw56Wdb8MSnOYl5+4Rd+4X7vPnoWz9CzgPOl81YL1Dur/fYSq1u9kK+m'
    b'frFHjUs685oPp97m0G+/qz1QXTGv/tpsUXetbt4Z6qU9W4Od3yX1ZXP2MK/71Fdz6tXqO+da'
    b'TR+qge3Fr4VTv3Xi7W8M+qdc9ynOKZ2rr6a+GG9f87LanXeKoTkg7gx19lsT+1cP9WFnm5PW'
    b'jRc1pxrY33r1PdPOaM0Z7dtcebA5uKZ1D3Cvcq952Gqu9VfXPcG4vdWQ3zpsLOS7wFlaoLZ7'
    b'tA7EncWS27St6Zt3iX513QfstWYs9e095aD7rG2PkGs//vaiOc091cV6a6sxdg6QM75mC7nT'
    b'/M6B1RFb17ZfyJnfeeXBzm59tcbFvrt+JEnRWrCOVr1DtKV6IS7t7/9O/tq84vz69JnrjJ1n'
    b'jNXvPDnNrM7ea5z+F/nQPmfxozflCz7o126+8G//+sUKP/6jftmZ1VGzfq8zwzOe8YyL3Rly'
    b'mrE5r/20L/5phlBz7w996++++NsPXmfPafzrv/7rl/jaPuSvzSw7G6rVx25vUXsvHTizdB/p'
    b'TNnePeM1PBMa/J5xfZazrDWuHk5a/erVYZ+TeXLSgvtZ63zpTP1q7O38zW2tM0+11dSKGvVg'
    b'T6G2vWA/dK/TLPdoj3SGq3Fntl/fBeqNpXXovGtYo8e5xu2zXoy17a2Vxmq7B74LrRZq67cf'
    b'WofVNu4C99YHas1De0pz6KtrbXvVme9e0Ni55tp7LacPjU9rMUef80+2ve05zRRrWGcB/ine'
    b'WdvXeWKfuY0Xa+5pzj5zpTP1l+1Vr78zzK8GWi+nuP1Ar/2ghrXzwZrUh62xukc/hzNnj1r7'
    b'SmeoK81tb1F30upbVyPU7deKOVEL6k7zHvAvDA5y7WBic6da42W1/LiIufbuj5FU49p9eLDm'
    b'W19dcRasvrPKvea2h+uQ05zmXvM1X/N+774fuWG9z2e/1MX6Izf8fgO/sHztC5Hd41489gl/'
    b'5PJ7AP19A/yv//qvP84i57lb32uBPltofbWPf8w3PyD3fm92349L9XcxFua7CjG/A8L18Hsb'
    b'Wwf3o4bvMi6t+TqrRt99WjPXfYzL5rfua0ldrT7g07v9xKsVc2rsXX3n1uee4J/m6HeONdCK'
    b'Wt8HOGPpPDBW23i1sHogpx7bGtizvfZI/WrkWs59ta2DOevgXtbMy+rF1/HijPa0157ue5pf'
    b'tkcL63cOfhf16s3D1sAatKZ/rad12R5ne4aN1XQGtL8134bE2lqxf+vkXdB8tV2iby9U13zn'
    b'gRpQh22PnPpYq1dXa/30sdW6MZjrXDG3tv3QuHNO+xG7zG+P+fbBxtA5rZs/zWD1DGpqrYu6'
    b'5sCek1577Vmc6Jxq9Klt3h59P/8xD9baK+TM1y/b27mwe7lWB5tvvHpi/H37X9TZB/Wpq3GO'
    b'emvmQS2sVdc+Z13+hcHiYg1O9Ws9bsI6zbe2oG3/Yr419f0E1di9xflQLZhXQ15brsXtJ+cy'
    b'D/XFfv9EKn/V59u+7dsu69u//dsv9mu/9msvNeBPme4c/gKROefdhv/zNP7KkXotf7J0c+V0'
    b'DeZa4wubazAX7U/+5LN/IZofPSJH7WVf9mXvzz77x49O+8LmPTN/VYo/E8v/NVsNtV5TffEM'
    b'Yo+5vnM0h+05TvnO3fxiTp299m+sTr9YO2lhfT+RrF4frG2fb3/tO81pDppfqqNeje9gnecS'
    b'r6NYt6c0hyW2v3kXWG/v9lRTX6svxPbKam7bq6tsvlYfNhZz7LV68QN56bW013zrC1r12J0F'
    b'nXea5Yy+Hk5zSmdtT/XO1tfql2t55pHv+xWpvmeyZ3Ow+5iXU62zrLevz7Xzvaf2w8agj72X'
    b'7+wTaFp3H/NbL5t3v+IzOM1rP/nt31i9eWfZe6rrr64aYpbvb82D2rXWodpanmVr7SP23qin'
    b'Vp3xidbWAnUgx+q81tbH9pkVatJrK+a2ZuyMjU9vD6dZO1c6V5/rcJY5LJqd3b5r2CvO3T41'
    b'6quppca6XHmFDgBFNlqrXqpprTcXzNfqw7V3Qvpij/t1361Z7ww11a4Gv3XoG6q1hbxLOntr'
    b'/ZOp/h+RQQ1/6ecJT77vl3/9c6rUzPHLvv4eAn/mlH3860Dg/xPB/yP0U57ylIsF8vy/DVj0'
    b'8ydLmc2MnhF6DcUcvxQtzGE2/7+Exfm//Mu/fPMhX/IKl9y//vTnvnn84x9/877v+74XH/jC'
    b'hr/6dNqzZ9tzwrd89gtcvgjr/48C3bVruraH+vrqW7PfPKvvzKovvt6r0Rfzp1pn6muv6TpD'
    b'39gzA7mdb85lbL/5Yg3qQ/WdA6c5LPKec9+/QOvi3NMe5rDmpHVpfeduDLXbaw3wfT1AZzSn'
    b'31q1YlzbnsZSrft0tjl7TzUxD9TU2le9edg50LpW+hrojM45zQTzu/cp7zKmxqpW/dJaNfYu'
    b'aLgutdWdfGz3uI3qVk+8MzcW82DNZU7rgs4s5Dr/GtV1zmmme6nHmlt9a8XeRa11Z9pv3fj0'
    b'Oi3oruVd1Luf1poYt2b95KtjSftWX7avNL9ztO6zNOecWuqnPqnWdepRV045+jrH3M6rTuwx'
    b't76rqOkcc1jfP7SvdWPojM6sFnyNkttZcKlu0oEssOaQ+urMQ2t84FZTXfVCDn1r+C5hDvTi'
    b'aos31Z71xRzsHHtYzmu+kDv1gzOgutd6rde6WOCT6GrE/4kb8OdIof/yIHyhQP/3fu/33vU/'
    b'LwPnscebvd9/v/jAFxz+haHS/WHPL/gsvmB4l0/+Y/dn7+P5n//579QXcl/3dV93+dEr4EeT'
    b'WMC/tHz5l3/5RcOe29+4vmf0X1E+7RsfdbFFPbprn1gCPgudr7VibXvK1tqDra8GPFdrYI90'
    b'nr3tqRbar341cMqd9jLGbg279/c0V9rXOWX7jd2f1d7q1zc+6Ynxra3+Ntoj9myvc9Xu/YL2'
    b'6N/rLOQ7Vxpb97WNTx+x+d0PNld7Ok9zaFidDbfNaK0Y956ZY4ZrOc1vn+Bb27y1xtK4+c7R'
    b'73Ie4Pd9AGvpPPtPumpO2Avaas0Vct3PGWqtGeN35vZJ/XKaY+/mQP3OI25PdfrWqsHC6jdv'
    b'LPs21H6tPuw8Ib+zwRy2s9p/8k+63cOZZePtKTtbyO8c2DlqsJ7ltJfz1KNxGRd12uIce1ZD'
    b'vhrr5vRh9z3h+1ohhs7rPtAz7LIOzZPb87CX+zmT9zn65c6cRz7ykf+XP03ZTdZf25p+MS/E'
    b'fed3mgedY12/NN9Zza0Ppxo3zJtkvh+AzKPVB+POh9VI50hfHLXOXSudhf/CL/zCl7+m9J//'
    b'832f9FfLjwbxYzm/9Eu/dPO7v/u7D+hlPfzhD79YvpvvvWChUedM/HKq4/M/l+MLCP8Uq/n2'
    b'b8z/pRo4q/n2Qn0wrh6I+deWn/mZn7lLX+w7zZPOPe2xejjNO82BU83+9aW6k8a4r+1r2oX8'
    b'tR7ngf3WoFpQA87SB+bhtwbGa61B4+2FUw66J1S3rAbrvRE0ziwb00Nue8Fc42u1cuqDe825'
    b'NnOvw/57zVB3qkM10BqsXnYmOKd5c3v+1uTUtzm51gfbCyc9qKu+c5bWTr3lNFPs028MO9O4'
    b'+erhWh5aO/kL+c6pb+1aL1hvX+mM0yxyvGb6/g5WBzvnNA+cIWpumy2deU2/mmvz7C9od+7O'
    b'2DqcNMQs9WX1cNKJc5zZ97H3mtWa2q2f9M23b63Ydw17BL8fK42xO785ONW1O0NaA+tqdyZU'
    b'C9urbe7yBQN/077Fsk1wbRj2/9d32su1Pjj1nvSgrvrOObE97S2nmWKffmPYmcbNVw/X8tDa'
    b'yV/Id059a9d6wXr7SmecZpH7/7d32uXaGWDPAWh37s447XvSELPUl9VLZ7fP2Jmndz6lc4ra'
    b'nQ3bU1371op917AHtFwHELP2Ha7zm4NTXcuMvmbVWVNrzvrOhGphe7XN6Rfz9kD1t3GvPYid'
    b'e23m5o2vzTAHjbdWTn07Q5zVOcR9buZWa8xatq80p18L27OoW+41w5rXBw9mf+vLSW9OOl9/'
    b'Y9G35jMg75mx6qoHYvXminpZzanPnHM7w5yo62tn+8wXa15btQ+mrzVy9t0rbyzbA6sHc76G'
    b'rj0TdZ1hHbYG5mBrRc2pbt+9+rtX9e1bv9cK9dWJeuhrwh73Wr90pvO879uzWmKWeunrzBn2'
    b'7rzG22fdWC5XvEkgB83je5PMqwNyvYCtyc7urPYANZcYo22+c62f5p1YXWNnQfP6p72u7QMn'
    b'XfvJNd9YK5vvDME3rxWfF3n3ktV2hv7uj61/mtkFPYNaa1AtOFf0td0P7N88tJfl61t997Jf'
    b'betdYr2rdWkeS8w5zLdn+3vvxBn62yNoXNtjTho3j9/lOx5n7cxiT2mf84yh+s7Ux7K4L+bM'
    b'931T5zpDC3sd+GtbczW39dOep77GcNK03nyvkTy5a5zmavWd4f0ELVSntvVreTjpinWt9Y3L'
    b'zukM7n/vj1Dr7NN8n51Qq05fNkfsPPPYky/qobX21LrnaZ/uX3YPF9frNTvnGvYUY6x7YIl5'
    b'Bj2Psa8xe6yDPtbZoF99+zrPuNZ51UjnUfe1c5rBvXIOaMVetN3H2c8J9tjnvOatVbN1Y8B6'
    b'RizXY726+qLGJWpP69qca5xqzqrP6tuq51kr9pvfOeQ7zxr56oR899Cv7b3deeqgPlAX+xbf'
    b'hpx37V5s78a+FsplHk4PZuMpBx7Iha5aDtiaVGtenT60B04ac91r2TlArlpv5vYT7zk7j3hz'
    b'9fuQnE0OjX3OgM6yBthTn6wWnFOdvdbAXvNbh1Nu6T5oG4P9u1fxGkv7hJxx6/Rrhbpz1ZbO'
    b'7Ux8VucvzlQru89tveIM54l5OM3dGb12OfXjG2PVCHHn66vTWhfindcZp/PZU9oPvL/pnNX7'
    b'jm3z0D4gPukAzWk+2Gd9Nc7fGdXh952wPWp2trPE+9dc51+jGmey3GuXNF7/Gp5N/emsuzeo'
    b'tQb6pxxoi3pQaw7ra4kl1dgrxtbba82+zjHfnHnwWbaONbfW1bj7gDln9X0fvjrZ/sWP87I6'
    b'5oo+muaBmPzpmvd56BsX918L9bfXeWhum2utGnu0XdZdvRZi2R5xprQHtke9ufr27gxjdT0j'
    b'67SntjNZvp7AfqkejFnVbXx6XQIadTun/dWAfb52Tz1qWwdi+sA51Up7wBiNOnuvzeg+2u03'
    b'59sN6DfXGX1G4r0oxO4B2O5tXYit3/mzqmJD170ODWr7oiS+trFYbw9ovQmbB/zOL9ceSvXG'
    b'rua6j6xW0HaWveqwpwfHtdkH2tLZgHWO1mdhzTys7xzvD+jbi8Ylxp2xPku/vbC94LntAzVY'
    b'88S9V9bwnWe9Pb4WjbVqoPnVuod+n2FrgN+5QM58+2T1C3X7a1ll92hd3159Vp+7M7D1rTfW'
    b'gvqyMdAvzutr0J4+x87ZeGmPyxwYA9bXhhp86JmgPZxtz2wdiFmdDdXgG7unfdbYx1pRV62+'
    b'tM+6GmvtwXJe1upFv2+DavTFvLVizro5ULt9pzzW85pn6VeLr7Um+NXufW9s3z5/cA64x/YR'
    b'bw707Tn1innZWOjr3M4xbq+xC7DV7lIj6tqjb73LXuNyinkWQu8ue9qLb4zGt0tjqB46p3uu'
    b'zn1dgMbYt5ViHbSFuppqwRwL6oN6e1rzuneGWmlNOq/LvHNX11z9gq6gaW7ngHVzW1/Q2+M8'
    b'rM+2vfXtgfbD6lbLch8h7tq+5sFnZnzSL33fBM5US79x55k31/d76vUv/+O24hCw1sEs8tqy'
    b'etCnZr3WmYXYB2rdHthZ+n0DB/Lt1xdjc7XOPEG95/MM7XGW7P7EfQcGrUN7WKslVtM3AHXm'
    b'qxM11VfH4nxYcp61+5ww372cB85kjjksfZ2589WAWnIs31DMV+d+Rc3mnSdq1JvTqm1O31rn'
    b'lfZotx9/rX41Ur8aoNbn6fL1sfpCXdQ6x1w195q1enBmn6X9+L7uwNrOaQ+sXy24l7TevbWd'
    b'0djc9kh7vN9Cz/adXs/ViW9D1hfzzNNfLbELqJ1mma/uXj2Lei30uQI1Zzt3Y3xnmBfrorY5'
    b'aL7zyymuzhh2Fug3dknrZefc1oNfPZx6tNsLaol9XRmzjGv3dSX4fQ3X9nn7ttD9SmdS795a'
    b'V7VgjqVe3wWex/7a9m29M8QelvemeuvF/Gph7yFYq3b7nMXy+k6zgJi+9upL98CynFetNXCm'
    b'C6jhq4H6i3r74ZrefLXu5Qw15sDatddgc/Sd9oFTzRyxy/sG1Hw+9uzrUZwFznJ2e8yLc8E8'
    b'1iXqyOEbNw+XnU5DPURp7jRwh0P97Snk0KrfG9sF6DuHPD3WsdQ5sz5Wv71o1KoHNaeevgFa'
    b'I6e/98q9F2qymtY6z3OC+1ULzmmdXHXEvc/WPEdn2KvGnD6osdc8eF9d+3yN0bWP2onVEPf+'
    b'W3ffzYN5bXONu8Da9pbmT32C77MU9VAfuMbm6HdJfTDeWe2j5jKuhdXKaQ6xtqxW7HOh6Wvc'
    b'Z2vcXuNacJaLvDUwD+2R+u3D7+sXOgtO84A8i3xngnGvu9gL9jsf25nmoZracuozB+RZzW0d'
    b'TnPAfHuA2CVevzPct3uobx/13Rd2Npq+npwPtfWdrV+sMZP59vU6zLVX35lqusf2EbvAPutg'
    b'DfZeQuvQGtw2z/30Xc1pm3em77+I+zZkTh34jDoH3zp4fa13hpBr3jnmQWse7Fl962qM1RrD'
    b'xqU5dfea0dzWi/fY1yWrPe3tMg/GWn1r7OHaGvvaBz6vYg2dvZ3THrWycfdktb5aUdcefRaQ'
    b'6zIH9uh7XrWdxRJ7RL1L7GmNnNZnTLz3Sp1sDORYPbd4L+GiOW1SC/jdaGPppoC/PfWt4bN8'
    b'wZnD7yr2tGYsu7/WXjHX/cXYntY7A9Q0b+xs74+aaj0H2GdMf8+HT415anq2+mCMFt8FWPcy'
    b'78zSntbbC/Z7rVpwhv211qQzxXj7ob7sPGfuXPOyZ+Z+66t1npxmLtsD9NlLTX/zhfxpFnB2'
    b'Xxet23PbTPG15lKr397O1Jb2yvq7OhO6n5jDuoydU6qrVh+2z7ia7QE1p97bOM09zWC1Xk1x'
    b'nq9XuE1fnN9V+jYg+Or0G6s1b60a/H17k9Vrhdh97NNas6c6ctZ9Xwrm9dVim9PXqnMWcRfo'
    b'22e+c/TFt+X2VmOudfDt32eGpQ7OaK/55rCgbwxqnFstazFnn/PwezZfB9ZXf6I6Y/2ibuvG'
    b'zeMLOc7ovfTein5n4jeWPkvoHLGuRgveHy3sWYm7wLODGqnvXua6t1QPxF3moM8W2yVqW+P6'
    b'PPPq63sfrtWlZ9t5YKxOjbFL8Hdvcp1bvZz20TeW+gXdCc5Dj6s0333cF3xWnd8+6s/1sIc9'
    b'7An+X4FtZmObtrl5l1AXNxF0xt5ocIazN1YDnQfm4VqtczsT9hzFeZt3lvnW8fccnVMtNEbH'
    b'eXgonWMf6zGPeczN277t29687uu+7s0jHvGIm9/+7d++6/9zwJL6sjl7to/Vmbddg6jvPRX7'
    b'tdC5p9cDdN9acUZ7ViPNr7/nEmvY+tY+4AM+4PIsfvEXf/Hmv//3/35XTe32gPsRu+Skx77/'
    b'+7//zeu93us9YC/Ab+x8sNY9ud/uU2sdf59J61p17/d+73fz+q//+nedzbn1r80EtbK+M2D9'
    b'WvfoXtUv5rvH+tJ4Z550LHVYaz0bkINq6ruMWwP3EOvQPi11zrB9reG3tpzq1+LmT3veRq8F'
    b'0JvrfJc1rsFPOMy3jg8+C+tSH4z5v+X/xb/4F28e+chH3vzpP/2nH/A+uM+2Mb5LLUvIodUK'
    b'MbTXGN7mbd7m5i3f8i0vPv//Guurw/L/5HnUox518xIv8RKXt1VrgG9sL1RDnthz2uN5d0+o'
    b'D8+JFk469+Z979u//dvf/PE//sdvfuqnfupSe97nfd7LNb7kS77kXf8/H23PvTngfPpYa7c9'
    b'E1Dn/txj9+982FmtAXFzp7p9WjXV7uxq2off59LzWRdniPrONA/Vr0Y2Zl779YFY/e5R3eka'
    b'1BVrUg2+cfs3134xpxY6o1TrMu5sa87Rsoq5aswTt7/Yc4L85Tk/65OQ//tbv/Vb96fvYwcB'
    b'Yt8Bi5vu5m66c5xxrz6sOmN09mwdmutsNe7THqgG2gurL+qwu3frzV3z+eQTzGG/6qu+6s7/'
    b'+fkd3/Edb971Xd/1opG/9tf+2g3/070TnY297X4t9Ar1zlpaa19p70lPzOI8xoKvrr3Nr0bM'
    b'11ZbzJ164OT/63/9ry8+n8z3f5qnTjaHv/PEPKvPZ/dqj5pi/VQTaurcV7a/8Wo9G1848D//'
    b'e7CzoLlTHchb7yzW6TXcfj/4qDVm4YNx5xBDc/gnrZi399r7TEDTuueS7tG5zd2LnmX7jKE5'
    b'99DKSbO0F3qvV6/upC3mu6+aajt/9db6LFo/2T076x3e4R1u3u3d3u3+Cfdxeh9sj+D7OnW2'
    b'MayeGFYn6rEf+IEfePPn/tyfu/m0T/u0m2/5lm+5k2+POb7h9CEf8iGXHF9kVIe/17xWiIW8'
    b'mmu0rnVeZ6trDk4xZ330ox99uZ5v+qZvuvmMz/iMS40v6D7swz7s4nuNaGGfP1i3dq99Gxdq'
    b'wD3+0A/90Iv/5//8n79Y2X3s6Vn0safzQnXOAHLW2m/e/bdXvXHzxdmdBad5oF6s7zmcqb9z'
    b'YWeJ+fbrl82feprjjM2ZB3L3onpmgXP23pHr3s43L+1dDat52HmFnHU57bfx5ZeeW7gkn3Uo'
    b'Yhf0ApsHfG+KeeZAdeakmlMfPpa922t+tdBc80AM5Fzb63WAM0CNtM97U6j1ngE5fWie78zy'
    b'DsYF/MuP184XC9hP+ZRPudQf97jHXf1iATqbBZ65OW1B5zKubb+vFeLbegANevupeb9P94rV'
    b'e0utdeC7TN/4jd94+b86F3Ro3M9e58JaUAvdy3Nab8/G69sLxD5TrP5iH9ZzAP4uQcv/9ZtP'
    b'4PnAKeTdA72xOayzzLF3Z+urA7UnOr9z4DQLa495a4t5Xxv22O/9JscnedwPtN5Pa73/uxex'
    b'M0Xf+cStg7N2L7APyLG3tV4L9BoE3/nGrYO55lcD5JjlPDXmtUWdy37oHJY5MC6971xr74UQ'
    b'd75WX9S5ep/NdT7WRe1a3hwQ88UCdt8Hq2+PPvhswRrW2fWtgX2+TfMJclEH9nVfIPZe/9AP'
    b'/dDNU5/61Jt/+S//5aW2emc41zr3c7VqwHzrYI/LHp8PuT4rz3maLfZgrVXzwz/8w5drfPKT'
    b'n3xXfZ9B96Bm3Pw1mMc38Hgm0HlPe9rTLvt/5Vd+5Z28tZ6BGb0PnlU2FvP2OIM9iLXu5d7o'
    b'9jr1xdnWWOY6u/myPfiwWmfI1qn5jKH6nUlsff0uYW7vGb6anQPdZ601aQ7fRY57/2BmqjfG'
    b'd0FfQ1BNffA6jaV7tKYe0LDgrpmX/z6LvsAsrt+4kPPFWD0HIN6DkMNCH5j05jq3dTGnFtT2'
    b'HLWg5lTr3mC8WnKuPhjq1eNLdQXtF3/xF18+EMFTnvKUm8/6rM+6/FP38l/+y3+5WP7lYfcw'
    b'PrHPQq0x7LlOMX0uYu4PS6ydIO/zdN/eb2c29tyLOX40C989tdBerEva0776zvbcrYmaXea1'
    b'wrmIsfrVqSWG3l9yG7voe/VXf/U7/q7qWGLNawRisUdfOgOcoy/bj1+tbA9wf0C996tzoGfX'
    b'R+OPa0Dvm+w8rAuc2bh1UAOnun7zWK8N6HPdpoNeXyEn1por1Luftn3mjMHYHvNqXZxZH+pD'
    b'e8nbb95rbl97oD5Yt6czrFn3tVC9S6id4H0wNX8EyB6vWR+IO0c9q69H+wC9Pdh9mxbnCD77'
    b'qmkNfuM3fuPm4z/+4y8fa8CZ0LOTs2a+WuvSun5prfH62M17Pfbqt0+I+QKOa/ySL/mSS6we'
    b'23vDvTdvDpy9mMMyx2/q0dvn+MxnPvOue3zCPbs/ayHX669ePM/2b67vM7qc5xys0GOus7ZX'
    b'7DWnrnOrB/O1LvrA/q7dW0659kDvBb7P71pvLdgH9phzrjkg19XciWsafO9Jz3MNNM7oHLGO'
    b'ZXH++tW4nuuhD33oE37v937vUtyhxlqbAcsi11jMg33YXrD6an1xaDu3Ndg67MxrsThD8FcD'
    b'7rk1Y2w15nsdsD6of9mXfdmbN3zDN7z8WMf3fu/3XmoPe9jDLp/0vOZrvuYlfqEXeqGLT29/'
    b'ZpV+/jmUn699mZd5mZsf+7EfuzMXjT/v+af+1J+6fBfEHr4Tze9FPOEJT7h58zd/85vnfu7n'
    b'vrzT41881DzrNXLz7u/+7pefoedcvQb+SZyf5+VnYvl5XvfD1se+2Zu92eXHVj7ogz7o5o/8'
    b'kT9y84xnPOPmtV/7tS/7t5/Fnnx3mB/Bee/3fu+bF3uxF7v53d/93UsP8PO4b/RGb3Tznu/5'
    b'npf4j/2xP3a5L5zFeyfOhFd7tVe7eeu3fuubv/7X//rlHPRwT/kCzN/lAfZ/7GMf+wDdH/zB'
    b'H1w+8MI7v/M7XyzfaSLHNfK8vFfQnxXmXv+Nv/E3bj78wz/8zryf+Zmfufnf//t/X+qC7vGP'
    b'f/xlX57Hr/3ar12e3/M///Nf/jXF72qC18ZC8x7v8R4XHd+VfJVXeZVLznvLa5H7xo8w8B2y'
    b'j/iIj7ic4w//4T98+STo//yf/3OZKd2Da4Oe7Xme53lufvVXf/XO2bgPPRt78YH1nd7pne7s'
    b'xXP/hV/4hTvXzFzuFa9Nzslr96/+1b96eT2+1mu91uUe8faA3rk8G94m/vJf/suXubxueX3w'
    b'mvWL7Bd5kRe5/LiIz4E6rw1/3tnr4fXA+diP1yc6XmO/8zu/c6kD2t4D4F6+6qu+6uW15GuU'
    b'Z8U95HkBenT8uCH7Pv3pT7/cP98G/vk//+d3rgmc72uIn4fm9cbbwd//+3//cv/+1//6X5fz'
    b'ef+Yf7ofXP//+B//48794LVMnpk/+7M/e8m5tz8Hb42ZfvBT4zXw7Njn7/ydv3Pzdm/3djcv'
    b'+qIvenkNcK6/8lf+yuW78H/7b//ty73Y+9jXX18TvP549n39+f6qr4mP+ZiPuXmN13iNy2ub'
    b'txv2BM/YZ+k94FnwuuBfIHnb4zXAd6H94AjcP/61gBrPiPczvfaHPOQhD3gfzDmo+/bNM+O1'
    b'znPj2b7cy73c5Xp//ud//s7rAHi9/IW/8Bduvu/7vu/y+uH9F/eB91k8K3R9nfH67dv0K7/y'
    b'K995f8t14b/8y7/8zb//9//+sifvk5j38Ic//DLr537u5+5cC2fk+dDzPd/zPffvcHP5goT7'
    b'xmv4vd7rvS4fh3h/+uu//ut3vU8sPEfed/PM3+d93ufSy/5/6A/9oZtf+ZVfuevZ8DGC3/f4'
    b'iZ/4icsz5bXD+3zef/zX//pfb/z8g+v2/vAc+L2o933f973zfpD3Ybx/Qcdc9uPjJT+i+f3f'
    b'//2XfJ+lH6sA/b698rbOa9575HPu2xGv732/wmvR9yvU2cv3K9fuMfixZ99f8HbiNWG5X5yN'
    b'Z/yX/tJfuvM2xV68Nnl7A19T4HVKr1vwWb7GsMS8LXSWtBd2VvfYWFrTL9Y8i9S3txhv7do+'
    b'YA7bvo3xxXtVf/u8d+bLKQfdQ077F+ouz9H9wRnW6mPrNwe9Puui5rle+qVf+gm///u/fwlM'
    b'yg5cOtBDt6d9pxh2j848sTovUqgT9ya6B5ysPVsD56xOWy056Jk61xyY6zl5J/8Gb/AGl0+Q'
    b'eGeDhg9AfMIgf+JP/InLBwg+4PSDATzXcz3X5Z0RH9j4xLJfCDKHf9Km7z/+x/94yfFJBJ/8'
    b'MQ/4oEQvH6z/w3/4D3c+yXzxF3/xyyc5r/AKr3DzZV/2ZXf2Az4488H4m7/5my9faHi9WHr1'
    b'+YDEO3/esQIfQNiHXw7jl8T+7b/9t3c+GHCej/3Yj728U+aLmx/90R+9fBD5s3/2z14+seeT'
    b'mjd5kze587Oi4H1h+YmY5+x95509H6z4ROIHf/AHL/ecLzz4wMPPwvKJGB8UPvmTP/lyPnQ/'
    b'8AM/cEfHc+EMXBtfTICfKPPB56M+6qMuH+i+67u+6/IvRcA5uP98csAH1G//9m+/fEDmEyf+'
    b'heTf/bt/d+eTJT6R55lwz4H79Dqv8zqXD8L8Ih97cZ/9DgBwFq6bf6HiGQL95Hhm3ls+QPMz'
    b'v3yQ536p4zqf9X7g8troJ/Lifdyz8cVnz8Zrjg+s6PmEwr2YDbsX14yWM77Lu7zL5ex8wsK5'
    b'gdcKn5hxr/wikHP9mT/zZy7n4BNN7jOW1zavEXRcK/ea54yePXxtcD6eIfeMHl6/5L/+67/+'
    b'8gk2nzDQ963f+q2X13/xPgCvzU/8xE+8PB/vOT6vUT7Z4Yt59uA5sQf3m0+i+OSHTwaY9eVf'
    b'/uV37nPvN/eJt7fne77nu3wDwE9OyPO2wiesXgPwhdXeD74w8X7wxSy93GM+6fw3/+bfXPZn'
    b'T57Tp3/6p1/uAXnODdaxLD5Z59nxCRn3h2tm8RrgbYP3G+R9bfDFKufmbYDrZgavPz5Z5JPG'
    b'02uCs6p9pVd6pZu/+Tf/5gNeE+jZ6wVf8AUvryFAzzdLuM+8lnyWXD/379u+7dsun2TxiSS9'
    b'P/mTP3nnXwmA1wHvF9j7a77may55rt3rP70PZh/fB3NPPuETPuHy/sHr53p4Vszk/a2zOBNf'
    b'WPDJIO/j0JHn7dpPStVyzZ/6qZ965/XFbPZl8f6W5+oXDLzv6X11f54n7y+Zx/ta34/7PpJP'
    b'Ynm/wQy+kPrxH//xy73kmfyrf/Wv7vqCwXNheY1xv7mfP/IjP3K5Rvp4P+rbq1p0vG3sa4cv'
    b'VNDzGvEbArz9cX94jfPFj/eTfu4dr3vevsEvGPwGG3vxfqgfq4S3B+533165Zj7J9/nwvoy3'
    b'I76p8Z3f+Z0X6/sVnjXPh9fitfcrnIHz8jGY/fv2zXO69v6CL3j6dsf94v7zBUzfptjnLd7i'
    b'LS73gP2cDfSB7xOIzZXm6Pc6jNfX7lzy5PSlPSwwBvPmnOM3KMT9Ss/gnvY4pzXtNbofEG9O'
    b'mM0856trjK3O8xJL+6A1/dv64JQnh98ZzWmtA7nWoXuT6xy4/FlVh9Qv5tzAZjC2t7X2nbCO'
    b'7SdAQp8XAKd55MwDvufZfU99Lmv4PUs1ot59pDP0H3DDnxXrQ/u7rxp+NIl3osI7NN6h8kEQ'
    b'OotPVHiHz0zekQI+nwDzhQhaPvkF3iHxnQvgO0TM5DsrX/AFX3D5wMInNp194lrda8JyTXyg'
    b'8Be2eafJ9bC+7uu+7vIBBzrrb/2tv3V5x893VVmf8zmfczkj8EUCHxz5hI535MIHCa6Bucxi'
    b'sT/Le47lZ0v5jh2fzPKLcsz1E14+gAGWe/Dd3/3dl09wPvMzP/Nyr/hlOj44el3CbD7xQssn'
    b'UF/6pV9686QnPelOjU+c+ISD76bxRdPnfu7nXvbn+vmgwXe2mcl98plwn7wePgHqfUKrD5yF'
    b'Dzro/SKFTwLoJccHVOCTJ14HfAHGJ0jUsXzBwuuFD07OdB9jPnidztZnCPbxXevdiy8a+UDM'
    b'XpxFrXAfeu4nPvGJlzoxn2yq5QMzrwNeUzybD/7gD75cN3U+ecaS5zUhzOP1Qh74xNlfjuQ1'
    b'wGvskz7pky7XRj+fJHrt0LPSywd18PXMfHygxtuceuD1xNsu18e5+KSC54aG5WvUBXyxxLNn'
    b'PosvRoG9+E6m/XwCwbVwP3hN8zrkE1Bq3A/m8brF8nrzdU6sz9sAzwo8t2fytU6e6+L9BGfg'
    b'OqnzRS+fIPEFNHk+MSfftyl6eeY8e18TaPlXIF4TvFb6+vMMt70meJsDnoffPOBZ8vbF+w2f'
    b'JV8o8Ykvr1ViPulyH+CTSaAOaKi7uKfsJzw/Yt4HUee7vzxfPkHkO8Kck3Pw9s7bDJ8sovOa'
    b'sDyvJz/5yZd/uWGe/1LhAt5u2ce3ab6J4X3gE93O5G2Q1xQ1zuDbA180OFMtuAcfB8hzX7lf'
    b'fLyhn/dPfgEDaDqD+4meZ/5xH/dxd729cUZeJ+4L9LF47VDnvvh+l2+wqFHP+1Fez1wPPbyP'
    b'os4n8J5hrb1inrP4ts6PKrE/i9cpX2ADr3X+lQYdZ9v3K9xfLHnus/g8uG/QM3T/vr/g/RB9'
    b'vEaBGq9h9L1f9PH2wXys/xLBvzKpw3ZP3laJ0bk/qLstxz0AckDeuv5teS2Qh9bIcT7P2Lyx'
    b'vu/bSvvK9vQ6uk7vYxuz6Hdfc8DsEz2j/e0D9xX3aC9UA84xb8+1nODvbOj1gxry+nudzr6j'
    b'5T8kdhhsTJONHaQvG4u9ooa9wboxtEe9842x3dPYizeW6vSFePevrnOcv7ONsWjsxRJbV+tS'
    b'B/pqhXxr28snGPh8ECTPtfBdJHy+k+Jf8+ETB3J8geC/VPDPnXwhgk+d72icXkBafajf88Er'
    b'vuIrXnw+UfAdNLEfCIGYPj4R4oMF8K8cwhn9hIZPXtE7vzSnr+Va+E4O/0Lgc+Ff1/hlQDR8'
    b'IUKOf4rH8kkM99FPTPik6/Tje/zLDl9goecTtX6xwFzvNXk+0HoePtHD5z5je5/4JMo9+M69'
    b'OFNfS641McfigxT2K77iK278y2j8awX/skLeL+qcy2uHPPeK7/jiezbpM3Qv+rqX3xFkLz8A'
    b'80FZrfvxCYRfCAMfwK3xuhBep5zDGpbvjsJLvdRL3ckzvxhT5xNZYq7FH9EBfpQP/ILb9wVo'
    b'6cPyiTy294Iar21y1PxEufBFCdfHj9P4ZyDBuQt5PimlxuJfxJzPJ+iejdcU14+eBbxWwfvB'
    b'J3/8siu9fPdfna9NngtznMEiv2//vH/xR3b4wk3+2T/7Z3d+VI+3L37xk37epjhnXxO8HfCa'
    b'YAbn8jXB6w/Lkr4m0Pc1wfsBfJ8Hn1TyLPHJ+yzf+I3f+GL5LjF53k75ZAx8f0PeL6pYsGcR'
    b'c+g4g/18wcH7B66Vc3Cv0PINg84F7g/fWOCbPLxP5t5zr52NtadnML/wxQezgFncJ/B1vM/R'
    b'GXwSis+/TvjFA/3cO/fqWewD9vM5gh9b0HN/sSzh/QyvHXI8V7+A40eFqgNqnA3o4V+/gHOe'
    b'sL/n83Xn64M9fRsAXqcserg/PDvfboC8MV/YOHvPSp7c5oFa31/wPgKfPO87vM9ooDO+4Ru+'
    b'4c79xfKxBfx44XmEmMW1eO1ijbW9zQP95qqz3rlLzw/Ocs/OVGvd12hntEfdwnma79xyyjsX'
    b'qFezcZfoo8NXz7Xodwa+9w/rPGudAfWp2atvL9jP0i/Owq5vn72Lsy67I+gFgo07THxI5vVr'
    b'QSsbo90XaF84q1/QQ8+z80ALnXma35wPhRzLuDTGV28s5KyDfnPi83DOsj2ezQ8UfBDjO9bM'
    b'4btMwDsg+/gnfeCf6t2Dfr+rRM5/Lu8++lj0Ur+0l5/nBXv5wMQHVXOctd9J5p/EeSfp8gOL'
    b'P07T2UDMQsMyBmNm8MnqP/yH//Ayk0/G+Q5O4R27f0mE71x+9Vd/9eXHcfguEDhT+KDMPWaP'
    b'/lw6MbzAC7zAxfKzqezJJ0gsvyPNBwt61HOfjFl8IPMTU1/bQM373n6oL3zQAz74MAfQEUu/'
    b'GPM1WDybZ+BsfKImnsO9eD15Rmy/a8le4Cx+/Ewf6yegnoEcM/gkjx+n++iP/ug7rw2/g7jn'
    b'LdS2zo+R8Cyc8y/+xb+4v/Lse+GZoD5fxIJzWeb4cYnt5UdhwHtPzbr9+sIXWerI+zbkjykA'
    b'94PX5+l+gLP5Apw5vN6J+WSef/kiZ029ZwSfH/Cd8MbiF9nO8Me53Bt8Tfhcpa8J3mcxwx6/'
    b'mAfyfU30vMAXBteeJfeIs/Ovhuj9JM7vHKPnHM7C9npKz9f3V3wRjm/sz5r3X+DEc6h1r+5H'
    b'rW/vrWPthX3f2nsK5OwFe/lTrHwjiWfDd7r5Djw/WsR1uYfWHufwrz98t50e77m0V/p+hpq/'
    b'68P7c19T7mENmNHr8Ys9e6i7T1+3+Cxn+rt7YA7rPebt3fcrvo76Y6/XYIbzCjNb2/fr4Dcr'
    b'eH+xb1f8vlDpPQFniXH3OMXVnthn4WvHePs2jxaqq8blTO5/n6WQUwfb23xj8dlv3edNvhpR'
    b'p8ZYvfmiRtqzs4n3WcNp7uJ5obO195pBbe/1aYb3fmdd/qyqjdrFRlY3qQ/ezNKH7oL29uap'
    b'Oe3lPtgu6N7tI68v9XdvWC3L/fvA1Aux57BmX2eIs6zZI6ccVI/vNeDzHXPegePzgYpflOIT'
    b'WrT7XUhxjvdK3Kd5cix9QeO126e/nGbYU/zEepff4dzZzmgNq8+/FvDjDXySxHf4+ISdxRcI'
    b'0HncQz6A+kGQH2vgRw74gmPh5/T5ThXwi3Lds/DjYl6DH2D5rls/kJVey/6/UlpzES9qWjM2'
    b'Ryx8EgnW+9oqxtj9Wf+TllmbZy/fBsDzQP3Cz8t/4Rd+4eWLPj6J4GfH+af9fuGpfTDz+K6j'
    b'z8Nn4/J9F/T9hLhHl/hzytfobOj8zkHD2vlAnu829n7weuaeeD/sZz7fLeU1yCeHvI59LZPj'
    b'x1/6ds5e7ts8OLPwNgme07M6Z2dYh/p9/ZXTnqvps/R58vaFTy/3wN/f4F8ZsPyIC7b/WkJ8'
    b'et7iOXZ/83tO7vfpHoIziPGxLPfvOezZXjAH9WVzxCy+4OcTZH7cyS8c+CT5H//jf3znE3Po'
    b'2fD55gc/tsS/pPGviL4vLXsP7QVqxODsXs+iFnoWwHJ/yXcGezSH9Tl4Nuu8HX3RF33Rre9X'
    b'nNOzgDVWa/j2yKkX+KbStZps3Ws23zo+ta07s1py3hfy1uxtTnvC/bqAHv1a86y+fRDv6/40'
    b'o5i7dj7mO0d8fejvHsY7s/eKuppr97CYV9M6/l730v30XeDcxVx7pb3WO6PaO6czia2/thsL'
    b'vms3wzdvDz43t7HWZU2q90G33xvdGeTMoyW3+JDBPrWdXx10ln57++LRWjeGxuaWzXcPfRc5'
    b'fnSBPF8o8AGAPB80+e6cGiz0O5Xcq37A5jty6Dwj4LunP6oDzRuLPr8MJ87lL3KIOfWf//mf'
    b'f/nZUH5utMsP7t0DiJ3ha8Q88BcqqP+jf/SPLv96wT8Ps/zuXOEesQ/787O5/MsNvXz3beFH'
    b'TfilUPbhA44/giD0AT9awfn5mWjmusiBPf7rD3g9/KIv4KuzZlxf+hoRPxGw1ufYvyAE+L2X'
    b'PENzQN6z7XlgfzShe/EjDdVWh3UPMM9fZsHnX1y473zhh++PJN2GZ+uefKLM/ec58Fz0sf5i'
    b'LPv5NtNe/noPOc+G5Zc1gU/Oe35wFnafCzH6zgP+Vcs8+DbEdxvJ+Tsb3AN+Dh3LPfF+sAf9'
    b'zAd/TIb3C3zXHZ+c14Wtf0KNZwK15JqHvQ++/tTx3WzxNWENS+w9cB/wmQg/6tW3LZ8nix9F'
    b'RMtz4QsL3jfyBRM/kkXM/eqe+n0u0jOAMc8K38UvrQNfuKhxjjG2+1bnWtQs7V/NzqLOIscX'
    b'e7xv4ndf+CYJ94PfyfBHWdtLD69x/5WK/2EcX5TxftR/BZX2Ad+8ot/76f3xO+k9Mx+XekY/'
    b'LgGf0FcL6rqfqO2/TPv2APTwPgzLv5bydsTbEH5/RMnZ1/ZeyDXv+4vi+3r2WX1hj74dEXuO'
    b'zcO+ZsHcbX3gOVzgfixz0t7FnrLnAP3u27fv0x7WoLr6LmFvNS7rvWfsbV69vvetevLXasWZ'
    b'1rAs8r1ec3DqAV/DxmCfPVC/dA9pzjnkzF9+6bkQcxBvmPU21Rd13Kj2wUkHzlht9eKDQGuf'
    b'sTV7XX0AYB6c0RiIO3N1Wxd1Yk+15qD96kr77QFita138bOkfNeQf3bnL02Q618UYW++q47P'
    b'J9H+8zP3y0/++KDhX27oGfiRAWN+ma+Q82w9I5/cYPnxD7+AIeaLBb/LyZnIcXb2Bj7x7jOk'
    b'ziecxC7ZvH30ANbfjfDHJ4DzcA+AHD18QsN5nMUnlXwAKeSFHzXhiyv+ognwJ/P64zbea/4l'
    b'4v/L3ptH3ZZVdZY3iE6QCIJMgUQEARt6kkAREgR1KNQfDFSwFBtAS8E+rTQ1a9hg32Gatqik'
    b'DaiFSkoKKGKNFFRABEfZACqCmEqriTRKr0VAEPXmeW9+Md9in/s98t+q+cZ+e++1fmvtffY5'
    b'99xz7z33fszTsYE8zt15cWsFH1HTZh6sE/eii/MCthPQ2gbe4UbT44z7nIEvGaJ3Hr4I4kWl'
    b'6CMHeXmxiY19yNxc387NNQO+XA5+oXGO5UWU+hX1Gc+FDPATjcL68YVZIY5iDKAR5v7KV75y'
    b'83PhyPcBoGvVWzK02/cLpxy77ifstFkf+l6gUoQ2PrFv6b4E/P6dEWCtze/+cO293Qkb28oX'
    b'jIFY8roNfsrIp21+OdmLZdpi37HLnKeobYxtxvc2vx4TlHlMkL+5yeGYE/K6P/jUgO8BGUtN'
    b'LBebtClcHPuJA1+8pqbPJ7PGTdCsfNh5kcL5ijYvPoR9wG1ixPWi0zzoKYCtdliNx2N62mef'
    b'dTKH0O8YoKa3WWLjTRI/8WRtjfH4QdNPHvxkFTvHpsx5gc8XaFkffgQB/FEG5wSck/nZUfP4'
    b'xXRu5Zo49zmm+Tyvcv7nOQWM8Q9+8jwAPI7Mwxz58QZBbxHPK3tz6PHZ8wXQ5lxPv196n5C3'
    b'+3WvFvVAPvqWYk7tq/G1VcM20a/efjG3PmpgXI+nPcxtWeUH84N+Y2D6VlrXwXkZb25j5Fif'
    b'HMY6xmpb9Z3GzAV7sdjVT4zRr1bsd6ypwXfxR3zER3w7v/WtA6MbaII5gP4mL9qpQY19qI18'
    b'U1uqrZ82tpYV6mSVrxptstIA7a6VmNdaX2OBWH2cIPn1Dn5Kko8nOVlyIuWnJ4nzN/95N6fv'
    b'sDiOaOfn/LivnhMhXx7jD8n4050c1NxrzQmLkyg/Ucq7jdxOw2+VA780womOOfJdAzS8I8QJ'
    b'l3dK+Dk4nnC5MGK+/UnNeXxwLy+3kjAG8bxDxdz4orBz9xMQ9DwBc6sAGubIT/jxk3f8WgYn'
    b'XZ7UPGa47Yo1490wLqhYw+c///kn6+J6ABeBbC+FbeLjdH7NhFtq2AaejFgXLjy+9Vu/dXtH'
    b'jCdU9GwrGi5qfBe0f4eB+3OJJYYXasyJ3wbn5wJZf74PwpdNWUf2LX4ucnlxwQUF284LK7aX'
    b'deJ44N1ktptfYXGdGct1Zvtca8DGvmFN+AIjP99JTW5ieCePC2TelWa9uLji9iwvQrktYe+n'
    b'RLsPmRv7kNzsQ+fG2jAO8+JTG8dinedY/CIRv29Om/2GluO9t4aAa8zxxRpz8cdxwQtbLv7Y'
    b'Xn7RiG3lgooXnL44Bl6kARferD96Xmywnewb9hVfxuUnFNkm7svml184PvplaNcBiOW7BWy/'
    b'+4njmv0ETz3zwox7w4G4HieuD3gMi/uSCzLmxMXYgx/84G3O7C/zc5x68d31YM4cZ7wQWK0H'
    b'Y3ELCtvKdgLnE79UzPg+4UGPr+4Hjz/K/GlhwO7PffJC2y8i9/g7dkwAjwOPCX4cwPFgricx'
    b'nO847rsveSGCluPEfUkO9h2PPc6N9Dk3kkeYq2O5j+jPNdDHHDnvcPHHu9hsG7/Exos53rj5'
    b'hV/4hZOfi3Vd+MSyx5djOC6Yv49pzi8caz6mzee5C8jBeYtf46Htz4tOG/VjHvOYk+9n8a4+'
    b'Y/i9lmc+85knXzzu/BiX5wqOrzve8Q7bccf5ml+Am+cCcN14N519yn53fcjPrUDsI3K7Pfws'
    b'Lsc+55seI49//ONPvhvieYNj3PMGj51uI/NGz/HEvuGFB48NxiEvxwDHF89t5Op5pY+jnpvI'
    b'7XmF5yN+tQg9+7przC2sMM8XPXcCj+WeL/qY8jiDPiZ8TLNGfJrGcxsv9NheII/QtoCaHttA'
    b'uzYKbfXqrKVx1WOb2lXszEtdu/ms629MmVpRV7/1zDFt7gfA3jnMMSwyxyvGz/zFscT+Xl5z'
    b'6Qf3UcfjfA97eexbb1kJmgEmbQI11k5KTXPYhraBuI5jbdyML9gtYDzMtv22hb7zB/vqHGMV'
    b'1yLOxxrw03enVA+OAfzkIu9QoeEkxq0tfgHQOPO16OvcgZOgcOLhJGiM8Pvr/FIHJ25OZDzh'
    b'cdLjPn8uIsxHLF8S5kKLufGkzDsz6H7t137tvHGdo22gz8e8PIkwFhff3FribTwTTszcR8s9'
    b'tZwguVeW9eBCnotrx6BmXjzpMC8+Juei1pzNTZvxeaJmDpyseffoyU9+8nbLgjmBC3dO1Dyh'
    b'MA/2DfnZBn9KUdomntuoeMHDXH2XlydUPn1grd23fCmV+TKOL5RcJy7igH3COvH74f3tfLFP'
    b'beHXRfw0hPzsKy4SgXEe+9jHbuvAEx35qbnYYBt9lwuswfZpcxOOxdPG6juTYDz9biM0N8e1'
    b'F8v8rQXupeYLu/wEIjq1zIG19ecMeWyxHlzMADp+rYf9wv7iy44cZ/wKCxdl/RJv56SN23g4'
    b'/onlOGL7aLNG3NOttnG2faz24hx6HgZ+fYv58wkI+YH19JMs6Hpw8cdxPddjzp0XsvaJZz5Q'
    b'HTYKttrLnl20U1PYH/w07OqY4LY/j4nGOQa0bU7bvEhzf/C4ZV9Ssy8ZVz05uKhlTOB8xwVn'
    b'MS/MbWyNj8Iv3XCeIBfnULaLcwz7hfv6efyhn7Gue+09JhybC3fn62PaC2yY9bE52wZ0fPrJ'
    b'RTa/UOV5ljXkzQM/jRL09Jm359273vVu2z7lhTdrwA9EoJlzgJ/6qZ/ajmnXh/M75wjOFRPO'
    b'y4zvMcKceCz015uA2qJdH7jGPtcBa0jhnOCnPzwv+Kmo5xV+gtzHkdBmvjx3AW8mkYsXFdDx'
    b'fd4HXmR6fLJNFM8X/XJ+1422fZi5afsJib8IVo2x5rHU72PcOPK6ZqCWGp3MHLbNAz2f6Wut'
    b'b2IOtaLdtvEd34Jt5rA2DrRBtbZbZhwFqhW23X0Esy7GNz9o097Y5qsdjJPp73jGU7rfZea5'
    b'6Mwr3et8VxEnQRUBQmERoDr8tmszDls1Qp88c2Gbq/1uELb6jQf12PSvbMUc1N222o11vmqm'
    b'3m2C+oyZGtGGbkKM8ea0DeYylo9KuU8feDL2SdE8toV3dXiHkCdX6DjoyU/fW2140m0uNeK8'
    b'1DgWT07MzXguHqiZI++cgDEU3o3nXVP+YqwXFOB41OCLK+47F+df6PvJQcfrfIV5sr1c8DNf'
    b'cF7SOVATT7FduzXvmvHOMBfoPPEzdtcOmCNrxX5rLLVt+0C720tstxEa77qyXmzfavvF3M6R'
    b'3MyPuZHLNTA/NA/byv5he33xAp1Pt9+x9KFzDjLn77hiTmN4YuXY9vgW5+l6czHA48C5TdQ7'
    b'N8bw2OsLruqssWkHbNrtAy96eSeVPheH+HlXlhcxvFM587CNrAfHFXPg9pr6oX3eAX/c4x63'
    b'XfDxN096DDqH6lfzpE1RX6qlNrf7AhvviLJuPK7m/jOGmqKvbelYwn6ksK/Zn6tt4xNEbo3i'
    b'xRd/SLF+6FiNW81BsPPuMe9K97sY1hS3a5XTmuJ8sEnPCRN1zQPNaR/U6edcQX7WjOOf8dWt'
    b'wI6GxyA5OO5W60ybN6xo+zzEcQo+XtQBf5eCP2jJdyN4c4Z5sZ7Ekdv1A2PbB/O1b43Ni2zX'
    b'0Tzk9nHkcWmM0HZt0PNY9XnTcaDzFHPxnELd55Rq7auX9mkzBi9EeOHBJ+XMV8wx59E2vrmm'
    b'F8LMO3PSd/y5LbPeAz/MfI2j7TZgUyO29bnfjJ/6PY35V33pvKjpm9tt6FjYwDjHVQv6hH7j'
    b'imOKbeObyzbFbaE0Zi/X9c/AZzCB0C8zocUY2m4Q6FM36eKIfWrHtzaX4834YzH0u9gWmfM2'
    b'RmhTyKe9/oKmYwFa2503bUtzF+diDPWqrYbivZq8i3PsyYs+NReWPelhs904TnKe6ABbY9CJ'
    b'a0/hAgEYw3jvHSfGC0m0jk3Bzq1RvFhobnzOiUJOn4Ao5FiBjzmwvcZTA21rbJyAeVLpO5/G'
    b'9LgS+hTnrx5sU5greblQg5WWOfYJrXic7NmBJzHiq7NmPC4qOS58knHuFGn+5uaildzVz3Fs'
    b'sxZsJ3rGFDUUcnvsUDqHrrNtisdFX4AYD86XGtjWvpNpHmBs1hsN6wbmKeo7DnB8eMEE+u0D'
    b'sdrc1olzmj70zI05uj2OQSGGtWWN2Z9uu/MV5+P94H7yCI5Lgdl2bhTzz+2zbttYauL0s994'
    b'DM7jT9oW51Ntc4r7khrwGQu8OcIngNj42VZydFsm+B2HGIs4PoXjh7G1A7HGaFNfzKlev7Fu'
    b'l7rmYv7dBuOtnb/oM5fzZozmaww0BjjuPfZX2mIfPedA+1MH5KI4r7km1N0nbrt9QSPaOe48'
    b'/2ujJraPI/3NSRvok5s8nlfU61tBPOcLnwPRYjOvNXR/YrfvGHxKA7zp5nkQu/ti5gZjq3Gu'
    b'6lcYZ9tY+/WD48581UB1+tp2bl1P/RTstrHrl9oFG3QcaF5jzE/fUvTNPKIdG2tOfy/fXg5p'
    b'nFptnedEbeOgazfXtwW/x8uZ+vonL51gDdhNXuhb5FzSrYZqtB0bR4yxDeQt5qm9Oaafvv4Z'
    b'J9gt9sHY6bMN018aXx3ratGnXo19sA+us1reseO+Xe5J9XfYuX8Wmo/Sbe/BAmi1GUcttGe+'
    b'aXN7KMDP9HHbBxcrFv9yLSc8nkSAeXU+5Ox2arONzzGmRmpD2/7MPamedreLIm2D82re2TZG'
    b'e/1Qe33EOY8ZU/S7no4HxmGrHTpe/dbdP4C98+h4zdO4tmd82/go0H0Ntq2NozaOop140A/W'
    b'x1jpsVHMOe22Z10/uA7YVnOptmNNrfHayWsbH9+B4D5zbrXgFgo+XXjOc55zomkcNN/MzTzQ'
    b'aQf9FnzOdwV+mXHWQA760Bjs9htrmWPzaSHnHG4F4TYY4HaQ+aLCPK0pzkM7BfR1PGxl9kGb'
    b'eYo+x3S8VUxtFuj+N09pXkt19M1BW6rXR+1xs8pbzD+Z2lVcbfTnfAFbc+GfGlAzdfap5zaJ'
    b'fcayfxro1TUX7eYCbTBz66Nw7PKpDbesAVrn1rFs10+RrqPMHDMGX48PfVMjzQXGUVvI13jn'
    b'pU4bNA80TltjzGHbvnGzlpkL2p56qB/Yrs5B6Gt3u1wD+mjN3zZ4bGLDZ97m1+5+oqiHjqGt'
    b'dYua7VeSnKQOoW2ZGzx1W7Jzmm6MtRpoDu2WxhxDPXRBtHW8tkvH6JzV264OHG/6Oh5FjdTv'
    b'mpfGUKPptqkBdYUnRe4j5T5U4J7P+TcGVnM3t9D3AAZ0avQ1hz7a5JfGcHJjXtwna+F+ft7l'
    b'5L7/5rANnQfoV+N4jdOvr8dudbRnvqlrIR+5Oqas2uiIE9r6zE++zq/Qt7gO1TQGP23n1jma'
    b'o2NL86mjOCfB5vbMoh86J2r7s7bQb5Gppc34bhfob+zKJvZdS9dMLW2wr37FSkObHM0D9qF6'
    b'Mc5taw7trdHTnvnpTxs1hdtNeMzxYoFbGHix7qcprEPHXuF4al3DFfWTb29OtjtvoK3fcfXr'
    b's884tkVbx+GTFM6N3ILFeYf72fuHLIEYczWn49Vne84PZh/QmQfUYFutJT5iwDliQ0tbuzmE'
    b'dvOpgWrNDcZ0TFBrjuYSbBb71is7tA2dlzRWv2WlL/rcFvSNMU/pdk+t2MbPenX/iG3Xcy+P'
    b'cxLb+qjJb9t8xU+J/ZQQjDHOfFB7IcY4xtGvHhtoN6c1/sZB24KtdvM6jn41tamZqKlPrTY1'
    b'tsE+VOd2TH1z7FFt29bTTr7pB+zuD5l659I5TV/70wbd79BcgN0iF9373ve+bv5RKAQdgEU0'
    b'qMHa0c76NKpj0h0P6Jtv5lzZqcnDnJpvpQX6oG36bTcXqKM074wH+nNOaoEan5hPZl7bzSHY'
    b'vP8S+MjTj/tlFVf0qaueNgW0qVFH6TEx9wP3bvKiRngRwUWL+aA57JvDthpRq69tY+xTd5/s'
    b'jQXtr+zEF+e0lw+0UaoD5yTmm+sItU3mGOa3b3sFftcEjWtkbbx+a5j557zxUdwuMYd6tfpg'
    b'NbZUM+c5czWuNIe6xpl7L146RvNQUzo/81ILbR4jfi+CWx60q4fOBbttsN/a+/rpc8uFujkX'
    b'8kLzgbnMR5Hm0G/81HXezeV2VS/qgLq563MeQN0+cCsSfc87hTxuO8zYCwG98zFe26TzXqFf'
    b'DX3zHNv3gp057K23/Yma2YbaKT1W8HU8bRS+f4OdW3G8uNVPXXiO4BeLuM2H0tzqHWPGq7NN'
    b'AbViTOOpyWt8242VVW7naF5zguNM3xwDuznmtpgD9JsfOsYq1tyiXWZ/MvNQnIM2a+zUEzWg'
    b'VvTpt0/dODBu6mXajG8c7a4TNrdFW7dPG9gv5hC1rsX0g7b6bFfrfq7WdmNL/fa1Uc/9Npma'
    b'zcYLBr703MSrRdpbONDWxKKt9u4ka3XmKtjmxmkT4/CftoPAXDJ1ZWoBm+M7njrbMMeYdmvt'
    b'E/zmX4G9sfb38uqrrvvDftcb5hzqA9qOZV0/aIfmd3xthT5256TtNDqftqHzwk7BVp22D4bG'
    b'NGfXjlpfa6G9WgdYabFRXB/H0gf6a9enXR+l42sv5oC9uKLNGGgOqc28sw32G9/tcC20Oy/1'
    b'2EB7fdT2rWc+tY0rqxxQW/uzXRoz/fS7fWrU0V/RnKt1Av17mumnLp3DhWiKufVD1x1o7227'
    b'9hkDzTvHAGxCDmj+CfY5B6Cmb9u5qLGmiHqg3fGl+lINmB86nrq2G4vdOOz6VmtBWa0xoHFd'
    b'AI1xcy30z1xqbIN96uaH5oNqGj816uxPOo+J9uaEY3bz6aPtPBtXDaxyqaGe6zGpdpV/L8fU'
    b'2J86MXf92LSXas0LtDkepPtx5rVff3MBNnKQs7lOO+b2/Kf5zAFqapOpBWzmxndsv6qtxjhj'
    b'O09t0nHUVAvNt+0RB9sMYxGkg6gzBr1lon2ln+ADfeoo+prDvrWliwfNYYHOCcwJF2IH2h3P'
    b'cYQ249hGO9ey+mIu6s4Bpm3moO+4xRj1Mz8xtLFbJuqNUV+6jYIOe/WOh71jA7V9/bT146ue'
    b'NtjfA7+5wLk6PlgL2pl39udc7NuGGQNTC42zPW3Qdv2WQp9tRWcR22jMU5rP9QLWDPDZXmFe'
    b'MZd26j1NbUDf4phuFzQP7e5X2mjtyxyLWps5bAttSzG2OYC++cE5m0PfKnbmWdVqmCvFHNqn'
    b'jhqba0JbTWO1gRpLc9kGfOTF1n0DU7uKBbeBQg5Qp615aTsmGGMO7LU5bnNoo5BLtNlujO3O'
    b'x1qt8d2Oavfiuj3WasR4/FML+ho3c0DzW8DYGdO54Wvbum1hDdDO/QPmgMaoWdnEeZrDfjlm'
    b'm7kAm8chaBf63Q7Rbl4KthZRJ/jUF4/HHpfGGgONW9md72pcabsaoL8XB/i0tZ55YKUV+8zT'
    b'bXZsfPpnXn36odvaXNURbIJhAACyzUlEQVSIOurGWROjT+h3/6iV9o3v2O0Tb5vavLWJ2uaf'
    b'bfW0XUva9tVXN23UlBtMB9DWDh0ADF5hbOMbB/Vpq09/2/jVlGqEPloX2vljq96c2kUb1G4O'
    b'S3cWC69N1Bds5pw+qK3auQ9aUzx4tYO5Zi17Wu22qyureGydy8yhTb1a1xJ6EBf95nStmw9m'
    b'PO1VPjCX8Wq1Q3PX11qNNXZ99kWf0Hb7KfTdBts9rqbWNmgD48F1BtrGzFjb5hXGNFepZpVn'
    b'5Z9gd/ucp+N1G8zr3Ciuk1RvTnRiPFjX33hraBy0P9dmti3dB7VRi/Y559K+OY2xrqb5Zn61'
    b'2Ir92hujvW1qNbYbD/Qt3cfuK9rS9dLfGErnBF2P5sJvLG102oyh37wdX/Q3xhq7aFcPjOV2'
    b'1E97FmNsU4N26pbpl2m3D227Huai1gbU1YM2CzHGuz7U2oC2a0AbjIdpM1a71Ae0p6bonzG0'
    b'7cNsuwYW5q6mtgl256POvnVRA51X2/q1Q/2iTc2M6/rX15jWLSu6Jo2b+x6mjr7xM/8qhxpq'
    b'4igeayuN2EajHqoB+o4J5rdPvWqj6Tw6BjkAO4UYaudPW/TZBse3b75inBqgby5q83Ru9tUB'
    b'tuaxT9n+0rM/d2hQxU0k2EwAbIDtGdu+G6pt5oHGOLb5ta9qF2EV3zy1qRP7jteFhepn7B7N'
    b'OedG2/nMfK5V4b5mvjjMX6n0Dy4ZD+QwT9ugdtaClr4xbQP3lvIXdRm7f41XTevGzu3AXo1+'
    b'9fpFHYU2OPeO0xj19RkLU2tde9dHe3O0DcZjbyxt45unNooPZu3QtTFmaqB+6PgzjuKcKNBa'
    b'n/Hq7IN6c1M7V+AY4Q+g9ffoVzrz+Ndd+eUe/vpyx6btOOpnHtAn5oCpr0+7tWM63rHSvO4/'
    b'+Jqv+Zptm/jlL/5iLfCXXe9whzucbKNasE1NHnI6B3CM2sDtqE2aEx0/YczfX+D7atxHjl2N'
    b'ec0narB3TlOLTzvg06+NL12zJmj5/sDMAdi6jtbFOL7nwRe4+au65OUv7XKPPD8viV+dtdA3'
    b'bzXa7MPefoDGWAsx1TZH2+aYfbFNDN9NY1v5C8tsr3+bYOZrX+q3gNtHEf3msbZAbUBtjrbB'
    b'dTAGjJ22iTpozrZXceC4+NG7rdNuPDW/oMUaA98BNAafxbHxaRP91PrpN4bznI9DfwqVcfl7'
    b'K8AxzGOAvxHiOdTvHEnHFMeCbqPg4xfSOA9xXvIvqgta9W6DbWs1tB2jWpk242QVu8oj2PVT'
    b'F/rmAzSsn+1ijo5vvjkna1GLrr5q8K3sUHvjbVND4xxv0viC1m2HxqI3ZsbW7jw6dsfbLA2Y'
    b'7fZFO4koTLJJZfbVUUA/tYttjaYTbmwXRa25ukhgTug8G2cbqG1jl5XNeTSP2NY+taDPtjWl'
    b'OqDP3zLgj9rwRKnPbaNG03EsaLFb6wdsFHVAe64jf3zLsSfGmkfbXts5gPNSUy3UN/sdj7YF'
    b'sJNbreDXXj1oW8Xosw9dI2PUFvtu99QYV8yttjErvf3qLRPzlGrdJ/bR8weVLFwQU/MEVNuD'
    b'H/zgTc+XFjlWeHIE4p2TbQsvRPmrqfwMMC+IwbFdr3ksQn3Oc0J+QON45samnf6qpoh9xnXs'
    b'2sxL4cmfxwmPGfxsI38Rm1/poQ3Htk3IBeQA+7LqTxtg41eR+JUkLla6Hvpba1eDndq5aofG'
    b'qKWg1Qef+ZmfuY3PxRE6t9/c5gNzGF+/cd/93d99+Kqv+qptnSn83Rn+PgiY03hq50O8+dTY'
    b'Vls7de3qrGVqrafNtQfzNVYf2ObF1s/+7M8evvALv/Bke/nLwvobQ57mg+amuIbG4bdA1wja'
    b'LuaBxtJ2vYnTJubT1vza6wNt+nssVq8PO4Wxu+bOmb45nCt/0I3zlo/bztt8gB6ffaG/0msD'
    b'H4dXX331OcvZL+OzTzlvmoMXxMzFPzLXHIJt2p0bdH7oPHbITb/zhdqsXRtxTcyNf8a0DWrb'
    b'X+WRxmqnb7EPjg/Uxq7iKGqgGm1Tf4zGANvk2oNzgdqxzTmAdmPqqx3om0OftbqOWfQbv8J8'
    b'5gTa28+qWmBusGDvZAD/7It2Y9TOPswx67MG7Cziykcb/2rHUOyDGvoWMWaiXR91Y9vGxxhT'
    b'K46PncI22bbob13Uze3tOI3TPg9QQGe7NsHWPhijvduL3VLql+ZoXIu+4nZoN0dpvKCrfY69'
    b'Ak3HM0dzNbZt84P22ppj4prOsSnu91UcqIOOu9KbF6jnMULxyYbCBbEvHu1T88TXXBN91PKG'
    b'N7zh8F//6389vOhFL9p+vUZ/59F8+CzQ4x+0E0sxl5i/x+uszUnfAo5rPDWs5gn2ebfSbZy/'
    b'CgYdQ7oP6rd2bKHPRTN/+ZX94Papf/KTn3z4gz/4g+2vRc9c1uI2dgzaK53gm5rm+OM//uNt'
    b'fH/mWYxje5vDAu5HYfvufOc7b+2v/uqv3o6/H/zBHzzRU3efNKdt6rZFW9fPvhjT48Q+bTHW'
    b'tjXajolt5iq8yMP+8pe//PD5n//5h4c+9KHb39AA9jk/Td0/gulaUoo2NNazaJf6pPuqvrbx'
    b'C7bVuNL9qwaspx6ah7YFXMv67Qtjomv8xHk1h9rmsl+7eiEX8HeReBy8+c1v3vpTB3s25wKO'
    b'N1np2hd0roE0Vj22HpvEUNsHtGq69uYD7O2L69J5aKvWsYC2+Sxoq59+ClSHpjFQre3G0O8a'
    b'AHnmnJuj8TL70jhLc5qL0jHdXtrU+NSJbXVq6Ev1oN+c24irgNoUG6htJpfquiGFPr5STf3G'
    b'O4eiz9octtuHbaOzUBR3uDZraQ5j2l/ZjdFmDStfY1Z1/TB9Mwe4TWDdebhvtJlnrjPt5gW1'
    b'1OinrX2grq4+9e13bvqtJ42zPcHX+KlzLFBXzTwW9U07YKumbevuG21Cv7aZr7ET7dTGzHy1'
    b'Na9MLXBRxsf11PyxIOGFgvYf/dEfPWc9yyqv8/NYgCc+8YmH7/zO7zz5qUvjXNtuR+dL7VrU'
    b'Zk18c1jjs0+7fahGP6VMTW2in/KkJz3p8F3f9V3bi6K5/9SoL81tgWmnf5e73OU8e/md3/md'
    b'7V15LtiN6T4gjmKcbe0Usc3a0naNVxpq8vzpn/7ptv3Mw/GrB+2Ar/6pt83tGvi4lUPUNldr'
    b'7PrcF8aAfTX1Ny+xxgB217S5VpjLfM1lPXnd6163PUa4lYXjCO5617uepzcnkLN5GcfiPEF/'
    b'HyvGqi/osHVcdR2r6FvNZ+aZOeh7rJVpM3bmsJSpm+BzPcB5zxjalo7R9QVjnvvc526Pwz/7'
    b'sz/b+nNekzmWtaV0bs5dXbdFsM/tAWPEbVHrnO1TqoHq6gftwLzo46+eMvevOdWqp1anxmIf'
    b'7K/WQv2x3NqId3uaX4yfdvNYF7XU5tTWvuulXZ/ztk9djf2irXEtgL3bevGtb33rk+8wFANm'
    b'beLSPu0Zo41i/CqPYO/CqBf607ai8dYdH1wMNTDntoo7jeZYtd3BQpvCX2P9jM/4jO2Prn3q'
    b'p37q4ba3ve329xS49/mmN73pdnGG7nnPe97hsz/7s7dbQdBzr+OrX/3q7ckEv+NwG9PDHvaw'
    b'7fsHX/u1X3u4/e1vf7j44os3rTgXx+YWEe6Vdew3velN28fiXBSi++Vf/uWtBu6n/azP+qyt'
    b'fv3rX/8B90bybuAjHvGI7Z5MTpK9R51bUJgX91X+1V/91cmf47/b3e623brAtn35l3/59vcl'
    b'iGMegIYc3ArjuPw0sHPi1hjWCQ33a2J3nmivvPLKbe2+93u/d3uH+1WvetVJLNjmvmF0zJ+1'
    b'42Pkq666avuDOb5TjPa0+arDzzowJ+YrxHLhjQYf+4N3DrmHlT7zpf193/d924XRa17zmi2O'
    b'9WOf8L0W9+0tbnGL7bf73/ve924at4G1Ym7sR+5h53hiPOdmfQw0zI3f8/dY+MVf/MVz3uu3'
    b'k/vJ73e/+23zYKzP+7zP245n1u/SSy/dton1MYZbm9g/2Dl+yMG28ZfBv+ALvuBk7RmXtff3'
    b'2S2du/uCuH//7//94Z73vOf2uOFdfu8ZRuua8x0L9gnvVDMO+47vHTAGsL3cRvQlX/Il20f5'
    b'rKvHDnNiO1hL1xs4XoC/YO6FHfuefeq+d87uQx+ft7vd7Q63vOUtt2OSnOyv+973vodP//RP'
    b'3x6X5MZGPNtEDh7j97///Q9f+qVfuo11k5vc5HCPe9xjW1O+64TmIQ95yDYOcRxDHZ/HCscQ'
    b'68X4nh/UsAasF/F/+Id/uJ0nHvWoRx2+8Ru/cdNfcsklJ8ckMehtQ49nv9einb9M77axz9jH'
    b'3BLCH5e79tprNx15zMtfrH7gAx948mkWa+G6st84zh2Dv+zsfuU4da04D/iY6fbiF8bjnf3P'
    b'/dzP3Y5dzoeMxWPaY7TbB9h43mKOHPM83r7sy75sG4PHMO8q9zsW6DxvoGNubLPnDdaBY4xP'
    b'FG52s5sdrrjiiu2xxfbywu8TP/ETT/Y55yX3Oec4z6u8UOM4YjzW7JGPfOQWz/Htscm43N5F'
    b'LOdh5sgxz/5m7G/4hm/Ytp915dj1hT05yeV5ldukeMzy2ODY9JhgO11HntNYRx4z7C/3LbmE'
    b'9aTPscCcfD7k2GcOMI9htte+z4vcBsdYHEt9fiA/L7RYc45hzptsE7n55IpPApl750Ru4ji+'
    b'5vpxXnD9aBtLYT1YO57bmIePI/DxSz72zQtf+MKT52XmxOOecyjfGexcwPyc2zh/rdaI/K4J'
    b'c+fxBXwixT7nMcCceV7muEPHLVA8trHzaeRqG32u5rmFbeH6wmOE9WatvT2Qxzdzu81tbrN9'
    b'QsZ8hFycE1jzl7zkJSePTfKxX8x32WWXnWzLxO0D10RdfaV6UG/sjKmOtv0+7qF+c67w+FZn'
    b'vOzFa7N2fDCPvuZ0vF5TQ/XmmmOot95uSZp0IoKOQqAD1WZdLWhjskB/NXH7s5a5OJM5HjiP'
    b'jmcfsNGnxtYc1WundvFboG1wvtrNY9/xtFFzkuNebi5kgL9ISpsnDkAHPHh4t44TIxoKD7Qf'
    b'+qEf2i54yMX4PAC/53u+ZzsxcEJ41rOetT15cS81F0Dkc56MjX01NvlcM3DunKh5okfHSW31'
    b'oMbGkx4aLubA7eBijltbeBLkBMNceJL7j//xP55sG9DGxolVGIec3nNaOPli555Qx+KEh+3M'
    b'C+TtfnJOVOSgdF8JT1a8E8TYwMUfJy/WEh+gZ06nzde8nFyZA3NxnRibkzTbop3i9wA4Kc/5'
    b'UojhvuYv+qIv2t5ZBp5gWD9fNHKbgtvABRT7n3GYGxdTaJwbNXmlY6lTUx3z10cbn+vJixfG'
    b'YkxgnlzAPeYxjzkvr/uR7afPkyDzZpvp8wTH2rOtrD0243tcAtvF9uJjn6EnjseGxwmxrjmP'
    b'A457b3Eh9sd+7MdObvEAjx0uVH3cAdvD/chsD3RdoH32ffcx83Mfckw5Pi+02If+gSvWwr/Q'
    b'zPZwUUEujgm2FbhgYBuEHI7nWjEW28Bx5ZrxwoR1nscQuR7+8IefxFK4gCHfYx/72O0chQ4Y'
    b'Cz1zQecxQCwF6LP2jM9jkz7wwn61bdj7QxweY/D93//9m0ZoU1hXIBfHDTm6X4lH4/b2fMgc'
    b'uOAUtFzoOBY6Hj/sdz4N47zHvJyb28O68iLDY56LPbaLNeJiy22g5mJpnjeYN2Oy/8npd1/c'
    b'N+jcXuK7z9kf2BmXi2lePNDnj6Y5rudbCnZgHNrEcW70xQDHP+vEfmcbuEBmfj/+4z9+sg8p'
    b'7lfOU3xK6HlKeHHJNpGfdeRi03Xk+EPr+cJ5mpvHPNtILOcALuRpc2H8SZ/0SSd6nueYAy8Q'
    b'nANrReF5kedA5omesVjfH/iBHzg5hqnZFz2vA3OgbaHPi0XmwA8YqGGfY2MOvIgTL8rx8YKK'
    b'sX0c9lwkcyyhTdHX9WLOrpGPIdfIczzMfLxR5vNy9+fHf/zHb/Oj3PGOdzzR9xjhuZq8rAHb'
    b'xzHC/uHFBfuWY4TtBD4VIw4dL2qdD/WDHvSgbZx3v/vdW5/Hocdc83F9YIx129LngtrVsx3z'
    b'WKvPAuTSV9pXS43e3PSNpaz6pXkEXeuJYwEa+ubXJnM8wV6f/eYRbSejMqDFhTcZQhOBbScp'
    b'c0D72qwLttaMTbGv3jmBuYq62rFRmCfgax/MZQ3UFnNYOg810DmLemqY4xYuLnlgARfhnOx5'
    b'54+TwUtf+tLNbgxPJL//+7+/vfuDDg0+TpB9IuBdRZ4wOVHzYPyJn/iJ7YmLkwUPRC/gOzYn'
    b'Gm8xIS/vUEHnDjxp8uQLxPBO5greieBExny44ALX0Ase5oeNEwpPkMBJ3jWgDYzDCbJrCnPd'
    b'V6gnx2tf+9rtoocXSayt+ZwX+XjC5YKXJ6mv//qv32634aTHmvhxMk9o5APnS+l8ueCDOV/7'
    b'bcNcZ+fLuMyX/UHMV37lV241TxAcB6wT9zf/5//8n09yfsVXfMV2TDAf3vX7yZ/8yc0GbD9P'
    b'aOjmHArzwU+BqdUOtl1HnpB4IvZ44okEDW0vnCfYeAJm7dm2r/u6r9su4Fl75szaO777rfP5'
    b'1V/91cOjH/3okzi2l3f2WAeP98Ljg4tF5sTFxe/93u9tc+CCBNwW4JjgWGV7eLzwBUagzeMB'
    b'5jattpE1Zc7uQ44xH8u8C8h+Ej5pYLuZG8cgL1i4ACOOdyuB23x8/AK3jNFnntD1AY8xPlFg'
    b'nfnEkHf1GJ85cX5gvTkvuP/JQc3FlfmJ4YkdOxfFaqhdN9oWsc82oefYZts4n3AMP+EJTziJ'
    b'Z3za6CjMcd4Sh81fDAK2iRemXBTyjrB6Psng4pt9yJrO8yHvhDMvHrPMCVgPjlsePxTG4HhB'
    b'59oULriwkZvHHccg60Q+LoCI4xzGOR48b8zzHOcWtgkfjyFgrelTfvd3f3erxe9yUBj/BS94'
    b'wVZzgSfsT+J4QcELImAbuDBE+0d/9EebjTZvADFnjgO2gXOg53FeeBBHYXuAOfPOuudVzlOs'
    b'I31gHVmTxz3ucdt2ksc3rYC+tTa2nznw2GAOvBhgLdBw7Kuz5vHZ8yGx+Hjs96KYT36on/KU'
    b'p2xajiFeCPPpB+ATY4THI7AGjssn8Wie9rSnbY8P9i99jif4i7/4i5NPpIVY+uYAbTC1gI3H'
    b'go8N+qwRa8wxxhrxGOoaycxHDq4hsHNBTk25173udXKM8GIPLfv5Tne60+bnGDEX5y3G9hjh'
    b'fNJjBHjRzPZj4xwhrBFrRX6+38SLR1/Acaw8/vGP3445zuXs04lzANetj0e2z+MTG8U2aEOH'
    b'nQLmsKbox1aab4W+zsuc4rjY2q7e2u1x3PpsA363C/Q7D+1gPqFtrvo85k7+DoOYsGITNBFt'
    b'izbrPV9RV599ijunthUrH/2OTZsN1ubGF/M4njYwjtqdBq21G+94tvWJbe08kVFzwcODUjsf'
    b'PXsrRWN4YPou3Mte9rKTj/t4osEPPnlwAnB+XMD/xm/8xmbno0vqjs2Fv3NnbPRAX3g3iRMT'
    b'J2JOTqsXC4zlPDgx0eaE4bsMvOjhYo02Ty7UfrmPcYkR2mwjPp4UPPCFWEptQJ+Cr3AhwRic'
    b'zPxkA6zR83EsNScxTpxc4NLv/uAJgfzOFz+FNjZ8zBd6zKFxXtRlZe98eeJh/V077o13Pvi8'
    b'p9v1BU7IQE6e1FlL8J1S17NjkmPOY2UDjxdQA1yoc+zp58t++tgGsA/m8JYjjhdeVPrChhcL'
    b'HI+uJTYKcebh4s9PuijoeVFI23f1ChePzBN4V//Zz3721uZdSnO25h5kxqfNx+juZ1+olxlf'
    b'evzzbqufCrkPC9vtJw5ouP0G3L8+toU2pcfchH3P4x4d5wMf5xwfrAnb5CdkPi6AL28zP2zM'
    b'2Z9Y7sXApMcHtXPleAbeGeaCDth+7KvtaY5J9cBFPvuKTwbIRwwXhtQ9Jtlut5dzJ/i45qK7'
    b'tyv6uOGcgN8c+lkTb/XjxZDrxxgcJ9iJmec5c3Fh5PGEBmgL8Y51DObBRRp4Ycv+5njhXMsL'
    b'D9pc0DMu77ij4TlE2LfMpdjnvA/MrfPji+doOD54ceR2so695cu5uY7msGZOaOmTz/Mb8E49'
    b'cOy6/sYRw/OievaXF6vc0gUcZ8wfLce9j7s/+ZM/2eZZnG/xDQvm7nmJ44pzDOc3xvLTSV9I'
    b'cBxKc9J27sD2+FjrYw7UYqdtHvqeH/BTen5QZy30PZ59juKczLp6jNDm+Xp1jNDm+oOxi31e'
    b'AMhv/uZvbnqeR50jY1KTj8eYtzABt/NxbOLnXE4hnj5YA20K62AbLcXjA7TZB9eyGts9BoG6'
    b'x5u+uZ+qRzNzrGyArcy8+qszVug33/TDXp7GijmoXd+TW5JaK6S4cAapMYF9SuOqB+3kOxn8'
    b'TI1O2nfcFfjAfNSlfktzr2rzdM4d3zGs8dG2tpjLbaTfAvhp4wfa3J8K3jtsKe1zYVQdH/0V'
    b'cnpi53YMfj2FwonA+175OJ5Y7j2F1RO1ODYPXh7QvIvHyZiTYdfM7WYbXVPereDJkDYnCvLy'
    b'7jN95sOTC23z8I46Goo5uJABT8Kd2wS/oKOvjfF8oQXkL47JiY+LI+Cdqqc//enbu5B9QWbN'
    b'fMFxKNpYY9g7rgp2xxdfGGI3Nxe+1MDaAjFqoO/gP+MZz9i22+IXJXn3kdrxmKNzMBbogzr7'
    b'MvvST8Yofi+A3JZiHp6wuvbMn3uBeVdK1DYXNraNdy65eGFbWT+e0MU44b5ytsscHIvCkxZ6'
    b'7KJfm/v55je/+aZtftvdn8Z1H/JYrtZjBT8XJdxewzvl7j/efRM05hH7cz6gvuPzZK0d/AUX'
    b'H6PawXdYtXe9QLvHErRtjYZ3eLnA5pYqtol95u04gNa1MyfsbVPt3PpCrDmoez7kuKCwnt5S'
    b'xq0QzcP3QtRQ+CRGeMHnfIAYYvm0h/MiY/EpAi/oedHr47ExHjvEGq+NuWifqK1PG1DzQgmb'
    b'F7a8oMX+yle+8vCKV7xia2PjfMaFIfSFKtvHY+5bvuVbTp43+JQaVuOzTrwwwlY7sI7E+xzU'
    b'dfSTOWOMJz9rxrHPJxbEM0aPfXSsZ9eU8yF29jk5fF7sfGkDL04FHy8aQC2lccDx7gseXnyw'
    b'TuxrznX8bQW03kLDu/X0eZFjPpljgO3aWtcvnh/4HphrxLv94rFvnuIxwot9blXkhQ66eYxw'
    b'3vXNCY8RfGw7ty7y6Yxjc74Wx/UNRY4z3yjyDQZfrPOCx0/SeLPml37pl7b97hsJaIprYO3+'
    b'LhwX+mX2i2sF1PSBvPRbRA04fjWd0+p8sdLZbj6g3zLHsa/N2nE7VyBGGicdy/wnLxjoaNTW'
    b'B6P2qQFtLjhFOwW7O28Va79t2LMDeZwbPvM6tnVzaBNsFudXfWt8+rUB7eatb6K2a9pYaLy6'
    b'Feg6tnHUrHcPDi7WfeJrzZfrOj5tczK2OUEdJwk+zubEzAmAJ/ju98YLNt65xc6Jgr73V3oy'
    b'mePRNlfxhVVpHHpjVuuHr3qw75iAjid7nvRZK+D+Sr48ya0tM4djYu+4q/kCGtetrGwdazV/'
    b'0O7YzcH8Z/mt3/qt7SSNTi3xFvJo91iy39y00TdH212LttE0D6AH7Lzrzm0OHKvAb9DzJMLa'
    b'Nz/Y55jiSYcnHI55bn2g+E4aOD9j2bZua8FmEfvdFjDvZMYb5/hA21ItF/XcnsTtJlxYuT0/'
    b'8zM/c05x/bY3rnkcx3qF+hnjBXZz066+edVp11cNeDzx4oPbGLhVhU95uCjhlkQuUpubNuu2'
    b'lw+w1U7bHNQU8XxI4fii8Hjw0wFhTtWow9bcbI9j8441F1Ach75w4CKK/eitKhNtHdu/szD1'
    b'1bqOQL/HJBfDXtjyJovvNnMPvhe2nJsch23yUyYu0vxuDRfIHndc3MkcH7TN7WEdWbu53q7j'
    b'Cl4seOxzkbk69l0fxwPHJ+/MXV1Bh6+f4qm13Vx88R8bj0/egafNCz2eE9lWPlnizQZfiPHm'
    b'ExqL2DZ3xxVtlM6BPi8WLuT8MGOBPvvWTwx4kcN8sfNldI8RvqzPcUIOjxHsHiM8J3KsOXaP'
    b'EY8PYn7u535uy8GbELxI5YUseXxTCfghF24f/Pmf//mtzxs9vEDk1iq3gZoC9qk9h1MzLm2P'
    b'BfU9NqBtaBvoW4yF5vQxV60+wTZR41zV2MYuzae/j/X6217lMHf7czz6MMdFc3JLEk7btVkA'
    b'O6V9Ju7OAvVqoTGgHdRC7V0QoN9x3Wja9mGODTPXijk/42ds88oc27ZzxlZNx3I7xHcqtRkP'
    b'nQt2+/jVUGO3D8985jMPP/IjP7K988C9wtQUHtzV8bEtfXI7rvMQbNy36LtE3CPOCX3qjHeO'
    b'fLTMyZQXDHzkz8mJvh9zuz4wv+QE/PILcPLdmxeFPJzkYG8btDtmNeaxz+1hrBknMj9y9rsX'
    b'xnsPKLjPO1/QL/Rdm84XGH+CrznU+K57Y9AxN20//dM/vW0Dx4D7n7a/vmFeavoU4rU7T/qW'
    b'MnOs1nXGdX6CXxtj8sTMXHlCdO299xrQoDeG+5bR/PAP//D2qQS3e1D8dMr5dGw+KXNe2HgS'
    b'Ft89VwtcCIDb6H72XflqV9uIzVh9fvzuPPDT5nHiRTsvXLnQpXArlJjLWDAv9RxfW30cQ7bJ'
    b'x7uNwAUCNDdttNSOXTxWzGdtDuOBeNaYWxY4j3DrHXCO4EuT6MjX8Y0V+nMMwEa/48qv//qv'
    b'n/dYoND23U7z8YlrNVy8qOWTVpnHIS8auPjhezS86OU8x3Hmp6vqPM8J6+HxxHmx2uK2rHza'
    b'0DAHt4cLNV5AcHHH3JkT5zG/vOtFLXAbE22+z8OLOR5D3K7DJ3+FvMaAY4ltXhiybqw5a+g6'
    b'0mcuzQH0e+x/67d+63bcM48e+x4bc0z70we18aIEPI55YVXQUmwL776Tg08zubefNu/Wo2Gd'
    b'sPmFbj8ppY3Ose03b23qinbmS80tX10j91PXSDoOmIM7BMzLMcILCB6TH8wxwu1/q2Okjwvm'
    b'RM0LBeZMLOcXjkfHZ058gvHUpz51+7UnbpHGN38wwP3eONqCHxqD3/moNVYd2K/NcSgdp33b'
    b'jTPG9tSuwG4etwO0gzlBbXNW17Z9am31g30xjnVhPtfPKBDUwL1kQKLWMCfSAvqouxMbY1va'
    b'N66Yu+MAupnL/NWBfQ8aNBZ9K1vrttHAnhbcDu/n5VV1P+7myZt+84l95mtbHcWTFQ9686nj'
    b'ZKnWsfnOA+9UqOUXl/zIuPBkxn3A5OfBz5cAPfnOeToX3mXgBEGbn9ij5p0m7zcljtsIqHkX'
    b'mVt5PKb4eJ6PtfH5EbNzBH6yDS2F+XJSEvclRWgzPjlqB+zQ21+AExknRSHOj3SZr7dKUWg7'
    b'X+4nnWPwAgsbWvat81XnHAo+t9mLFXT89Fz1XmixTznhA7+oAt1e3h0T5sMx4gs/1my1No5f'
    b'u/uo1E+7pcxY/IzvO7FuF2vPBUOp37bv6HHrkz6OT7/8tzoW8Hnsgi9IGM+8zpM2FwlAju7n'
    b'jnkMx+4+5McAWFvXl1sDaPPYxz/v42bMSbeJ7emc6wNsPNY4Pmi7bsBx4S8k9QJBsLdMP2Cj'
    b'rPzGgS9U0LB93utt/IwFbK4TmMu61EfxfMg+nnpfKJL/L//yLze/L1wEH+vaxw46bBT8njdo'
    b'4+NFue+iqjO/5w3a6Hue4x1rtLTFnNI288dPAXNQ80Ka8wwvIISLO17AcO5Ew/EAtL3/nFtT'
    b'hG3mS+PiXCjtF7eT8xvvSNN2jhRyGjfj9Xns6++xP2PEfVHsewsnfNzHfdxWk4PHjG8ENbbH'
    b'mnhbDrfSkYMv//rmgm9O4IP+PDGYm777tzbo+NB+Y7pGvc12nh/MW7TNY4Tnddk7RhjTY4R9'
    b'zBrhZw35CVVBZ+G5khes5OPFAHq/00bhWoPtoQ18h5AXIwUfuWyL+0gfOC6o7eNJvzltk4s2'
    b'WsBmDODreBTb5hLa81i0PXOCNmvt1Nhqrw/0txhXrTaLdqDv9hfXAs770nMd2qlnAmzTX5u4'
    b'g5pX1BJr/OzXBh6Y3Si1rS36bZfGiPPtAQHNi08/NIea5rZdv6U+LlD4SJx3ovhCMffvUXiH'
    b'x/tPHQdsa5995ujH7LwI4d07Lo745STyck/+aWPzayW8u0A+teB4fMrARQdPCORFwxrO9bPP'
    b'CYg432njnlE19DmZs73gR628u0AbeMLnZO04vgPKR/7cw8l93tzK4sUYkLd0O2zP4xM7797w'
    b'MSofy/NEwtrx+9Tk42IcDfPl3RVgrZwvbWC+vvMEna9r3Pl6/EHnbZs8tHnxxbi0mR/vLvEJ'
    b'CLdy8O6den4xCRiP2yTYDu5Lpt2fAuUWHu5P5vYQIB6786Ftob9ar+L4gLZ5RM2MBdee7yIw'
    b'Z44tfj+eGPY/dY8xc3lByD7gmOeXQ/xN+KJeOOaI4TYS9jN+PpVTZ83+/qZv+qat9LjkgoEn'
    b'bZjb2PkJc5/7kH3SfUhcX0DzyyFcwPJ753x5UMiFluItKOxHHg/knGMLcdzLj59fe+J3z9km'
    b'1oKLAXJxuyD+mcPxVr6CBqrRBpw/2F72LxfxPB6Ac9G8v3x1DBXsHhPFsfH3fPif/tN/2u79'
    b'9h55PpES9jPHH7CPeEOENafmexbcckLezsdxOE7JzeOMY5cXX4yHn4sg5jjPG6w75455njO/'
    b'uaHj0faWEvY55z/WU7wVzxdI/Z6bv/fPl7PJwWPE9fNTXM4RPIb46UtuFfP3/YXxnQ/Ypiae'
    b'nK4jx3TXkTXiotptc3uoKbxYoebYZ324CJ7HvvrOAdyO+rDR5rYj134e99LjiOPOHNTm4FzO'
    b'BTbPZS9+8Ys3Pzhv1pWaF4vUlHnedE6y10ZH/KRrxPmBn3Tl3NQ1AnLNePrY/QR8HiO0e4xw'
    b'PvA8io/zHTXfh+SXpnjTg1+x8ocDJmj98jNrxnUDOZwb36fjmoTHIo8b5uMv+nF+Rdc1AfvW'
    b'5AFzin1K22Ibn6W2HgONw7Y61krzgPscuwUarw3U6vMYUmM+C7Rd0FLMQT3Ht9BvAewnjwxF'
    b'BojtLhr1HEwcQBu6bpQ+c0Fj6ldjH9xYwG5uaYwFDZizmubrPCnGg+3Gu21QrX5wnbRVpw94'
    b'h4IneJ7UeFeUJxkK+GXR6s1pH5oXH+9uk5OTG+8icmKk8EkC7+4LT85zbDTAk1znDvZ554f7'
    b'FoGLHp5IWQ/nSbsxfLmTBz9wAvKTjWo4qfDihhMKF28U2pzk+ZIkWnTUfGTpRbhz5sTPLTjm'
    b'pKY4p9pL+7TZbtadLzpzwc26sTbMw1+dgguZr4ULAdYYnC867jlVI27jCteJC1zG4gUbuai7'
    b'X3l3k9vHWGsuNv2da3RcTDimf4jKC07o+LR9bED3K7VrQbt2cxi78kltrj0vZLr27FvehWZf'
    b'eoyjp80YrC3vWnHBywUzF6J854RbSNA5BkWe/OQnbx+js9944mU9uY3EJ1IgDvgDX/j4BAA9'
    b'cPyx//e2p8zxe+x0H3pM82VJvwjIeFzgcLHCY5XtBHK5P3gBwAWxj2HesQbWB9B0DmyjxwcX'
    b'ZIzB2nGc8rj2fmXna7s5tIM2+zDj2+fxy/ayfzk2mTMXr7xpwTlJrfM3rmPYpnQ71YJtLtR7'
    b'PuQincK6Y0PnsfrUpz715PHlOcAfPeD4hI7hHLgIQsP50McbOcjFY84YvvxrftadQptjnPMG'
    b'kE/Mb7w1t9/NfY7Pwr40D29eAHYvNinc+geuHy8U2TfAiwYeS7y5wy1WnQN47BU1+FhHj/G5'
    b'jt7GV5w3F6f8fDCwNlwIz2Of/OB22J71bPPFdF8gPOABD9jyc7Hq84bb11hs7XvBTPGXm4Bj'
    b'jG3F7u09Mx8F23xcin5r48FtBsZibYFt8PzAi0afZ8X81s3ZY8RPT/D3GPEndx2ffdBjhD+C'
    b'yK/x8VOo5oJuR39NsXcXAOd75swxzDFC4Xs3nNN5juy+Jpd5O5Y+61K7bVFr7VjqKHN87e5D'
    b'oF9mH4i1gJr2p5/i+HNu1mAN2NFOm3YwHqzV23f7TmLOXORd15+WRECQyahrg5lcVoPOGG0U'
    b'bSsaK7MvzI/5O09jZw5t0r5aSvOQtzGgfa6V6Lc9c1KXaefjOW4P4cHPRbbbh8bc1MUcYF0d'
    b'fj4Wps+FOjm1Cz4+FuSdEx7M/jybGmu3BYjpth6DGE5qXCTwDhMX3o2Z28U8gCcPYh2LWh12'
    b'bgOguF3OTdAaT227NJ/Qdl9w8cQJunH4u2+4HQqbf6TH8eb+Y648YXpyRqOWGuzP9grmx8fB'
    b'rJN/BKcx1NyywPzYDt8pArUcG3M+Yh5t9qHrbVxr/WqaF2ZMYZs4Blx7WOXB1nH4IiLr6y1j'
    b'5rcNvBvLO6c84XIcuk/89IjiPuMFgi86/J4ENp7kvAcX8IN9a/OUqWXfsL085njs4e/asn+4'
    b'+PDWB/09zpqLNmtWO3X12mj7GPKiUhr/wTDHdbzatbGPPX4551XLNtpun+1w+4W8M7e1PvOA'
    b'txt5nEhjgO+YsDbsa/b5MS1gMwY9+2zuJ2vwvMH2z31KnxpWsUIO6DlKrXr7BZvjtY2Ocwb7'
    b'hpw8Bidoun+IE8cxF7WPMdaDdQF8jVVfeuyrM8b5HsN8zU2b5zrWjcccxx10LWCO07mpmXYw'
    b'zlob2N8DP+P1+G6OVTzHMscnBdBQ0DsuGEvtGPWXxts23rbnaK5TPEZWOemj5W9VAC/U+W4L'
    b'OcwtnFvBT1hFHcV5yEqnxnZt9qF+ob/STBoDq8crULsvfcyAWv3UFOzGz74YW9Q3F6itT2xP'
    b'O3zAHHjBwJ/yFgPm5KCDtt2+GN881KvJYlsdZMZD88i0mcu2tfn3FkSfc9Bm/trMYV7RBsYJ'
    b'/T2mFhwL5hh7zDGcz7Gx8a/WRIx3jnv59E8dtfOnzYmfj6aBP9DkyU2tbWiOUn/RDt13jq+t'
    b'qKGuX/tsw9QaL42zxkZxrbWdRvNCc882dbe79Uoj+vSLbfTM27q5gXrabVcH9Of4orYx1O6/'
    b'5inmMlamfublXVNfMPCphf6ZB+YLBreBYtvcna95bHcNtdPHDvU1J8w+mBMaC9WvYkH7yk9/'
    b'NZ/2y8xF3bl12/WrmW2wdjzAZrx94+b2215tA1A7hnV9xtWnvePpF2zQsaRacgB5YGqhOTqP'
    b'Qr9zsQbHoH/MZ60N1Nsu9vHPcY/FqQe1sFoLits1IY6YmR9WNnJgb21bP3Qdm78646dGzAX4'
    b'9nRiLkpjwRjtaqZdtMOMsb1Cv7mp3Rcyc9gX4zpGNdi5VYpPDvhEk08iYGpg5in65jjHYrDr'
    b'V9vtc//MHO1PP23BRo4eP62rafw8vrU112mgMWfHg/rEMfTtzVttbdTbdxhoUAgW+q3Vtd1+'
    b'sb9X78Vio29hQxoD9NVpA9tsQ3dM9W6fPnEnaUfv2J2DC+tYtiloqqe2XX2h33Gl+dRoL8ZZ'
    b'Ty3jw9SJ+SnTB9jUUJtPGi/VUfMuFX81149MgY+D+4daGm8+C/m0t22B2sG+NdCundKc7ito'
    b'7rbBmMYJNvrN1WPO2NU+b79ji23zQP3NSd2ibda2yTP92LS3nkw7/a6JqMNnvhVzO+b6OZaa'
    b'2mD6Bbu2OT/t1O67lok2c1IT57Y5587FtjEWmG0wB2BrH5rb7aHdcVqbd0U1tKnbBtoUt7P5'
    b'sDu/brt5wLUB7eYD9aBv0pxqtXVcbeaGaoxXRw3WxulTR6kd5rgy+8YCdvquif36HKNxjNW+'
    b'fmroXID8XQPAV/8caxZoGxin+rb3mGtv3LFY/SuNbX1ATR/mWtinRue2g+ukFly32jpOoT99'
    b'xoN+feSkNMZxqt1bZ1jlgGkX40ENpftFpnairTF7Oj795vsI3o4Gv/ALv7DVQA7LzNuc+ud+'
    b'oaYYMzGO4nq6r7u+0H2mTtRR2zauvok2NbYn2BxP3TGqMffM2/lLdT4WGt8C1nLeH25zEtZg'
    b'2+RlpaP2IHTg5sbHhth3fDfOnQjGCjH09xbCvNToHIO6/trEvjbHprg9RZ0x1Qvt5uz409c4'
    b'0A9ur9sltGccMY2FGVMfbWP0WUC7+4UiU69fOzW3V3CfNF/K4j5bvgTHvdtqJtqs0Qlt54Hf'
    b'9VRDrc++Nba5H42dOmgO178YZ6x60I5t5mMOzTfjGmMeSvuApnnmHBln5jZW6DufOSbUBvQp'
    b's6+tpTrQBtTuC/VgrhVonKfx1ZrHXKDfmPpkZRPG0G8ux5i5J2rcTpja5qLQhvatu4+Afv2g'
    b'blL/CvMar665oeMDPmyO2XZBZ5Fpc6w5JrQ/fZ2TPufQ/Uetnbb9Pf+kOse0nnr6lK5FjwOY'
    b'22l72ucxWF/zg/MBdJYyc1ka23G6RitWY4p9bc1L3ViYWmD8OYe2wVyulX194FrVbmncpHr3'
    b'oTp8FGO1r/ZL45vTdvOUlVaNMUBtfqDdnJT2zUVtG9rfi4Fpq9b1pM8bhnyXh+/0QL8fhr85'
    b'YWUT7dZub9d7xjIPQIOvx9LeOICv+4viNtm2D7Nfvf22wRgK8+p4xjYHNBbanzo1Qn/qZGon'
    b'xm23JPFHOjS6oCeCcwPXBw7KRmKH+hoD9vdy6gPqmVe/GvrWKx1Qt1+/Pmi7NH7lh+lTT2nf'
    b'Nhhj3/mDNphx1MYCcXOd8GtT1xhRW9+eDsxnXFnZBDu3IgFfFuQ+1GptM+dVDm3Oo33a2ldz'
    b'mLEzB2Bz/ZyDeam7vrDKAdNuvG1rbBRtMPuNldkX5+fcjZ05tEn7ainN02NItM+1Ev22Z07q'
    b'Mu1qgZq++Wx3PDCH0K7OfI5DHu5d5h7mfg/BPM1Hm3tveacMel8tmm7rMRy3+sastguwOR81'
    b'6pwHqJk0nnql28vX+ULj6m98bTMH7Y4B9NWax/5sr6jP/MY0B+iTasH21OzR7Wkua/1qmhdm'
    b'zESfrPJg6xrra15q27LqAzZK96F2Y7QBfaiuGFOmdmroz2OlGtuzrs820KfMbZoYJ3t5T6Na'
    b'x3NM+2VqgZo1sG2/bfc5EGse/K31GavNWhus/ID9NC2oE14w8AtI2PgujN9Ral5xmxynx4Ax'
    b'jZWVz742+wWb47W9F6PddvePdjCmubSJtmopzmFF85ymler32vYp9sF+1+W8Lz0rBNurSTUx'
    b'7dpkr6++B7/2HjDGVrNi+miTYx5sHQ/QHYulFrW2wT7MsaC62Z75qgF9oI+62zDj7NenHeyD'
    b'efCtthM/zFyihlqNdtvQ/CsNtTnat71C/2p8asajbhvUnWY3r7Qtc2zrsudbaQG7GGdbpgam'
    b'rv3mAdvM3zXAVp1xqzVqm7p5pLHqJtNue8Y4Rvv4gXqOLc1n3Rww84ra5p1+mBpQ1/Foty/G'
    b'Nw/13np2vmI8NM8qN5jLtqBb7UuozzloM39t5uhYoA2d0IfaJo5RHAvmGHvMMVbzgTneanwx'
    b'Xs0qH+jXZz7qOX80rq0YbxvUapf6S/Ppo3Z8bXMs2tSd00ojs288ULvfapu5ajuGOWTmaZt6'
    b'rqusNLVR2xbb6D3mZwxQT7/t6oD+hczRGOq5/ybmMlamfualX1vbE30U5tM1tG1s54u97Vm7'
    b'ttTgOkJzwuyDOaCxUP0qFrSvtJTVfNovMxf1XCfz6V9pqM0HM6fxQH/6xPbemhoD1ti2vdek'
    b'FWmvj9KdoAb0r3BjGwvGwipX+5PGinmr76ITQ2nuSRcR1HaHmQe0Qe17qKd2DS32hVz2qc3d'
    b'MdTMcenrY+60uxbGuE+AfudgDY3Rblu7NnBf0J++CfbmFG2TuU6Aze10PtZut3OiXQ1F2ja2'
    b'pdtlbdtY89oW7bPoIz+1BfQXbdVDY5sbarcm3j4FGjPjW6905mq7Oqh2Up9zs9+6+wBbi3bR'
    b'BtjNq51+cU1hlQ86LlA3pu15rOLT79j4jVNbmzksk8aJY2innttGWcWCPpgaY7tt6rVDx9Mm'
    b'5iizb6xaCjbH1e+41kW7a20M4NNvabxabeptgzEr36xBnevRMU4bv+sJ2muT5hF0q5yiH581'
    b'MFfjZt1xpq0147jftB3LBdinRtqfPpj56Xdsaaz2xhlru1Q/dbRX/nnsqoG21due9cyxyqMf'
    b'up9BDTW+9olrbNv4LcU42+AxPvW0nU/jOkc11OYp2I2d8wNsaqB29dZTA45tHqE/Hw+2sbt/'
    b'gdoc0r66rpO5KeaiPeuiTbs5xDgLzBr22nLRfe5zn+0Thq1zRtADB2g7GL5ORJ9+aXv6jbG/'
    b'ygntq7fuHKd/Uttq7kCND8gt2JwfoKsW5vyLc8TXttTGT5PxxSDgF1kmztfatjm6JkJ/2ml3'
    b'DjOP/VUbjNfuetGnOB4a10Ut7eZRx99v4K8R87Oe/D45ObgFhN/hx+8v1BjXHLZh+oC+dm5B'
    b'4Y/CeIsUv5f97Gc/++Q2KbWrWMrefoZVjDZgm4jv/pga2uoch5p+0ec4E+2sIX90B1xD7Oak'
    b'dnzt/NG0j//4jz9cccUVm53f2+Y3uJmXGLPCnJS5rd0O+qC/WqGvTrS1ds2gvhW1N6YQz+OR'
    b'4w9+7Md+7CQvzDHmeNMnKw2lGqB/2nqoAfelVNMYoT9jQC0/UMDPNPJ3PPjtdGz4qikrG8w4'
    b'UFe9c6lm6sFxrCndjk/4hE/YHuPMmb98W21jbBPrsUN/oq7t2gp29xmFvwh+r3vda3scoWdO'
    b'/L0D4ynd7lVtmwL0ZWrlQmLUaANt6tuG9qmZu+3SfBN8Pa7R0Db3jJ26aQdsM7brqg3MsapB'
    b'nbbaaXf/djsAjeOaZ+5fMU5b86kX+s3bWNpTK/obY982NKb6uX0yc6ifNpl9MKbxYn+ux4zZ'
    b'YxWrvX1zaLctaq1X69HYFTOf7MWpnz76Pt7AuainXz/6OYY5qq1/b07GnbS31jnqLCbCR7ul'
    b'ExfsTExNB8RuWx+1aNemXrA7Hu3mcy5tk3/aqUvnYIzQdlug8dSNtQbalvaFPIKdJzp+5pE/'
    b'XIKv/jmmfjXYOmfQh32ll8aZ2+1d6bVrm3n1VVPUUxiH+kM/9EO3bedCXhv3PmLjjyrRX+E4'
    b'+o3d47u+67u2339mjSk8ofdvkBi7N+/W0LYx1G1bdwzjuvbY0OlrbjAXNMfUFdeQbQVzENO5'
    b'OS5/eZU/lsQLV9eo4zBfCu3aC37ysS/Umh+wgzkcv6x8tUFr7MW4qQW0bkc15gdsc+1k5qJg'
    b'M5babZTGiDEWwU5hfvbFtnXjoH3baFd254i/BfjjX2w7awCNn/sPsFUD9c8x9FUD+ifqjC3a'
    b'+E4Kf42YH1jghbJzagx14/U5ZnWgv5rmE/qM5zHFGyD8UTYfR6tzmDHSMYB+Hz/6Zp7GQP34'
    b'7Ne+snUMMHZqtDH36rWv8oB5rMHtKx1j5rHfGt3MM+OkbfXU3Rb6+tw/arQ7rjW0rw20y/TV'
    b'335tjk0paqqH5jHGfpkx1ctePG3Xp8ycE/w+Tqp1H3Q8i31RN/2U+laPn9NA53YZZ2zbQJv8'
    b'4Di2tRtTn3FqoG216tgO+0Kb4rFhn0LfbTBv66nVpl/0l5MrlukwEQPPHYx9bsRM7s7S1lgx'
    b'pz6ojrI3jr7mA/0rPfRg0FYtuBO66Pj0g/G1NV992gu5KWpXNB80J7QtU+MYLawbfziNP16l'
    b'1m21D+pXOLfP+ZzP2f5qozrs7jNwPvULupkf/yqHxXkC/cYTU7+g4cUIfzkS/u2//bfb7+nz'
    b'V1I7N7BdG+OA2o6rDxh7+mxbQ9vGGztxjeqj3xwXAvHNsRqLd2jJy1/+fNjDHnb4gi/4gvN+'
    b'0cIxOzbtmYs5Y3Nf0FbT/Vr0U5PTvNq1rajGGpvzmKUaaezKR9991Bwt4jZqb67SGDXU2FfH'
    b'MeD3mLBvXdu026dNfNembXOAMdbQtnmNM3bVX2G8tTbr+m3zIp9PIf2UEDtrxR8947h94Qtf'
    b'uH1iqM9aHZCn+2iOXYhpHucj9lvzgoH2fBw5Dqg1rvvbNnZQB9gsRX91tsGYaQPG85jC3xxC'
    b'W01Rj73xLdC42iz2hTY66+YS+91H2qqlbR5Qb/H4B/OIfY8XQV/bHG/m26tBvfud9sytXi1+'
    b'ijGAHdBS8Bvb8YA49YBfLb7G6ndO2B0fmgtdY+Y4tJ1zY6oxh3mmj3GrwV+tdqBWr4/x9Rdt'
    b'6Fq0gbkKfQo+dPqrM9dcD7A/81A7V4o66hZtUK1ti+su3RZrmLmdA/3tZ1V1AH0L4GvbuhrQ'
    b'Rq0O2maCotZapgb0V7taSPWw10ZL0WZsbVKbO9FS7NfX9hwLqpuodxvFNjWFWNv6wAOhGmrL'
    b'LW95y8Nd7nKXTUt/1i3Q/NjsU3j3rPSgxD8PUjHettQu2sjlnIR+7R4/xjhfa/Cv+favB6tx'
    b'7YS2Pqi2+2dqQB/MeDAe22pc68aINu30Le2L2mmn3Rzw6le/evurnVx4+dc7jVVrDd3HzVU9'
    b'TJ3F/gSbcxLzSsfQ7jEgauYY7ashtvlFn3koxky9ts5j6lZjADrnYA7bxqCZmH9qZg0znr5l'
    b'br/tWc98jXU/08eOrUW9bepJtUKbW32M6dpge+ITn3j47u/+7uUvsVnAnNraL42hZjyp1nio'
    b'/djjSF3XCvSbk3o+btSaA1v1tVvbJlf7q9o2OLY5AX/nS+mYHWP69kDTMWjvxepznKm1FmOt'
    b'V7r6jvkBu+tCvaej3VwzB31t9D2eofbWxljqb38eT0BtAXyT+rttjmcpaGozh0Wf/W4naC/0'
    b'jaPWP2vo2NXWPh8zjRdjKR5bK2Ys/am1bz5jmAc+jx+gPfvgfGxXAx2DdvUdk3q15tUX8+pX'
    b'y/gX3/rWt/52fiu/mKTJZuJqWooDQ/XgBuzFTRu400F/a+LmgQHVWByDRXAnGttxijHUQt9a'
    b'/0oz+9VR8yfz/ej6+c9//nb/9Pd93/cd7nnPex7e+973Ht74xjce3ve+921+c9ztbnc7fO7n'
    b'fu72UfynfdqnbTnQvetd7zrRiX3emXvUox61fWzP/bUf+ZEfuX1/AD/v0jEffkaSWxIe/vCH'
    b'H77xG7/xcPXVVx8uv/zy7U/oOwf+zP/nfd7nbe+mwYd92Idt7Zvd7GaH//7f//tmYwzeyX/o'
    b'Qx+65WGOxDE/fsqSPJTb3va2h/vd737bhTz3TUPX45d+6Ze27x58xmd8xqblL0WCa8r8WS8+'
    b'QXjpS1+62YiTu9/97ocHPehB27ZjJzcxr3/967e5fM3XfM3JvBmHTyC+9mu/dhsXPbeL8U4h'
    b'vyWNnVs2LrnkksNrXvOacyNcPx77hHXh96a7T975zndufuD4Qm8Mtdtim/qmN73p4b73ve/h'
    b'0z/907d8vFNJPmDuPU65fYTvK3zd133dtk6XXXbZ9uf6u4bgmI4BjMN6sM9vfOMbb/voTne6'
    b'07Ym/IwoPnKz/zlm+FTpe7/3e7f8rAF5WGOOReb5qZ/6qcvtRsexNdfy4osvPrz2ta/d/MzL'
    b'uTk/oM3aPvjBDz484hGP2GI5Lq+66qrthZ/nMGLRcNxx3zh/XfSRj3zkdvw5FnPu9jMnjlH+'
    b'+ihrx7HetfvlX/7lTQfOq/HAHydiXt/wDd+wzYs1fdWrXrU9XpgD+5DHiD/LajzbxOOMF/Ac'
    b'u/o4Ds13j3vcY8vH44NzgfAJITnZL8zfNcXGBSrrvwdjUPjOypd+6ZeerA+PS/Yd8+H7K1z0'
    b'OlfPC+x/9JybLr300u28wXYCOm4P+uIv/uItDnhs8hhjbcn9pje96bzjwuOPNeJcxnajI57c'
    b'jn3/+99/myvc5CY32daZOM4ZPBYYg9vqXve6122Pa+H7KOxL1+d2t7vddhywbeS2cNyg47hh'
    b'/Xm8rY4bIcYaO3NmfB9HbNcd73jHk8eR+fkuA4+XxzzmMYdv+qZv2ubv+XB1/njzm998sl7O'
    b'lTV2Xb/8y7980/GTlWjFeVHDfH7T7/kIqqe2aNcH7TfPLPhg9o0B7dRQjTZroG1RM/tCv+NM'
    b'3WoMa+kYUz9tsGqvagrXINq8HrG/Yo5VtFOjsz2ZNvXmpmYetanTD+pk+u1Papv6ifMA6hl7'
    b'jOaGlV7baXmxad+bx7R1uxrTvvu7fePENcbe9YbmlLaBfnUzP6jB51y0W1985mT67f2CmE6p'
    b'eB7M2qiNpy/0q1VXOjHbXRBj5iI2n23tMuPUg/YZ2/i2gX5j9M9tdoyittTGCZ8nE+Bjdy/E'
    b'ebLhYhrtn/7pn2424AKFJ5WP+ZiPOTzrWc86vPvd797ieVJ+7nOfe94TsuNQ/+Iv/uL2u8jA'
    b'xR8X0RSexHhC5OKYCycuENXd/OY3325Xoc+TGxcHPNkxlutBDubC79p70f9xH/dx23cGuHj9'
    b'/d///e3igosnn5R55414nsDZRr70TCw214PcXLDxhM2TIxdP3ALFBSI69uMXfdEXbXnZBl9M'
    b'EOd285clmR84V8pv//Zvb/NlHW9zm9ts2/Xv/t2/2y640HGRzYUK71o+8IEP3C7A+AIwL0y8'
    b'x9sXKMBFBrnIzT7hooULV9bpec973nkXMeDada628bHejE0+tpmLAcZgW7mg5YIUmCN/HOch'
    b'D3nIdqFC4WKK/ct2kY9tIScFHI8+L0r4K5zEAfubMdk/7A/2Ky8yX/ziF28vSDw2uf2Di665'
    b'3T0W2W6ORcZjvb7ne77nA9aS+7w5Nl7ykpecbD9QO2favCAhJ+vwJ3/yJ9uFHBeRHDt8eZ2L'
    b'aY4HxiYnfi6+PI6p0XIR6sUia8fxzsXqsbWjdj7Q8woXxzweeBHJi30uZjk+uPh7wQtesI3x'
    b'FV/xFdtj6GlPe9rh2muv3eLcJubKsfvyl798y0k+LoxnPt5dJ58X56w5ObkgZl3Yb8AXlllj'
    b'9p2PMebrNlCAi1uOr64PcfwYAI9J9q8vCF0nzgusC3Bu8rzwx3/8x9v6o2UevOjmxRzryvHi'
    b'2rK/6T/nOc852Q7eWOC44Dj7b//tv20vKHqcs68e8IAHnPylWGAOHG8UXwyzHmw7j2s/ZSA3'
    b'28hx4voQy3HAfD1fgN83YNs5btzOHjerF7bWvHiZjyO2yccR5wLy8wL3277t27a8xPHY5gUD'
    b'27t6HLGGnNM9f+BHxzrymPnzP//z7cUI+85jmzkJYzhP6LyPPQ/OHOqgOSbVzhiZPmupfU8j'
    b'fSzuaQDf1K1qNM7NUqpdsbIfywO0O6bzhBnnY3mysok51XQsaBsYQ9qufgX21XbMuOpKY1fa'
    b'7muh7xz12TeHNC/QntewRb2+2bYU/c1XzSqmOuczMW7mpW+7zH7BN4v25gf7lDPrev3CKrYP'
    b'9C3dKeoaj8245oLGFOKNsxR8cwww314MNuJ6MV+9ecBctYF9Y1qq1QYzj3Y19qH5G8OTBU8U'
    b'PME89rGP3Wy8q8etRMA7V1wgAn9B+cd//Me3TyN415c8vJPWfLQdg7x8IQ94cuZJknG4sMPP'
    b'L6RwAcmT0Od//udvPmouVHy3m1z8cgwvBoS85Hr84x9/znLYniR5AuWCHj0XHIzJOLyYcD2c'
    b'q33K3G+8mODJnTYXOsD+5aKEJ3NiuKBtPmoK8+ICRpgrxU9C4Ba3uMXhq77qq7a14YUJ20Yu'
    b'LsK5yGGf8IVK1hodFzK8w8dFHDrelfeChovDn/zJnzxvn/iOK1oKtA3OVx3bzJi8I8+68qVt'
    b'5oef/QLoWA/2DTA228s7zsWxfLxRtHMxwnqwb4AxyN9fpwIuUrhg4l1v1ogXSxyLbjfHItvN'
    b'NvdYBPYnF7WuJTFoiWEtOb65wHZe0DZwsf0lX/Il24sWjidiubjlL4gT27kSy5qw39k21tBj'
    b'7xM/8RO3dUDPRZdrRz60c+2AOAoxFNvE8+VWtoHj4id+4ie2fcY2sq1c+HL/Oi8GwLGI5dhl'
    b'X9Hm4hy4AG8+1oi1Ih/v+vPpDRADzIMX1zxGmTvvzvNiDPsd7nCHTTf3OWD/si/7ss32lKc8'
    b'ZVsf9vk3f/M3f8AYwOOAufe8wEW15wX8Yhwv7tkucjM31gUf+4uLXqDP49DjnGOO45wv3zM3'
    b'xqH+3d/93S2HsF9Zu9qK28sbADy2edPBeXjMcWyy3t1OYjifkJ+xe9xgpwbW1HUVzqHE/NZv'
    b'/dbW/4Ef+IFtvP7qHXrO3Xy/gccQhYv80x5H/cSGTxRYQ15kcY7hmCMGyMELc+YGbBtxq4si'
    b'+y21TR3oM7+gUS+NaS4wh+d5tR0Lapf6YT5XTIhd5cVG7GoM2/gap73a+mH2ZaVrMaf7Soyr'
    b'bTJ9s0+O7jPaaBx3zqE4/ooeZ+YR23McaN82WINa0D7joDG0mVN1ZdV3LayB2ng1E30UMLbj'
    b'ayszhtLHp2M1Vj2os6hTU/9k5qzOuGqAvrbzVmEGAvVqsaAaqc0CDmiN3TbYN4b29FO6Uws+'
    b'a3cYqDW3ND+1eT2B6FfTE0vrmdO6dphaaH6hz5OjObgI5kma9sd+7MduNe+AUvNkzbvMbi86'
    b'6BMbdD4dE5tt4QkO+3/5L/9l+wUh2rz7xZMgbZ5kWQtobPNac1sEc+r+cI48icucwwo0fNmR'
    b'mk9XyEfhooSaFxPcsqHW8RibUvC3CC8GuHjmQt3vObge7BNqcvHpBhdw9HmXldp5sE94V9Y1'
    b'etnLXrbVXFThpxRtFOdijY318tMU4PYT4OLR+XN7A/6f+ZmfOXkHlLX/tV/7tZNcwrzYBuzE'
    b'OM+J41kLX5bnApj14Z3TbjfvbAK53W5fzDEmF3hoWUvpWvrJDu05b+DCigs9QEMs77DS5pMx'
    b'6sJFmccEWj7VAi/awfmzdr6bzieuz3jGM07m4Hzat7AfqH/lV35lGwMNfW7noebCGNtv/MZv'
    b'bH3Wwxw+jnkxwbvO7Avv0Sef970Tbz7eQXce8pu/+ZvbYxX4xMwXfozd/dv58+kLF53YnvnM'
    b'Z25zB9aTfQnopOcFzge03/72t5+cF3hTQIwjN3NxO/iE1E9R2NfUFHQcU8zBPrfcAes7H7+A'
    b'rna3DWhT+OTFxwnHGLfsAMepxxwvtudjgOOGcwD0uHHfCfGFvqV96Px4EfVzP/dz2xgU1md1'
    b'/iCm5w9wm4BP2QAd2+S5lU9VyIV9jt9ajTbR1xzV2J65qwft1uyv5pptcb/OfGKM0K9ttolv'
    b'jhnvvI7RMcxnjPOtptRWjbXjr/IV/dWqqc/asbR5TNkX7eaSqavf/EJfG2XGwsoG6vU3LzRO'
    b'rePUJqtzXvXQNjSeNjkch7p+c5lDv3rQr61zWlEtNdi3lNqrA+PB9tRS2wb7xZhqti89H8Pk'
    b'MJPaNmGTQ9suWGPMp665wb6xM6b5QT96fdXYNod5bDcOsAl2fbZrqxa0i/0eOI4L1XuhLlwE'
    b'AhfZPbnxMTtPyFxI87E27xQK97gW57oas30uIsCLAuHiUMzdOaNtH9DxzjGfkjA/ip+MoJ3H'
    b'BMy5gW2fuHnn1jn4JM5FE7GdB7W2FdPOfcZiDtfjh37oh7b5s9YUbkEBvlMB5mKfoGO/UPf+'
    b'd57IYc4ROhfWhT7vFHKrAe9Cun68s16ai1s5gD7FC3jBxjuuvrPJPfB8ouTY5rEG2vq5OOxF'
    b'MceiWrfb9el288kY+tVaUruW3ArSx4c4BhfTvGD9wR/8wZN4LmT36PaTt8fwPPa899u156Lt'
    b'GMyJwq1LwLq67cyNd3/BC0Eu5tBz4ce7yeCxy8UrsJ7N1/VsPnDe4MU1YO93F7z4EOOYi20u'
    b'/IE+hduLwHXH1vOC2w68QBEek+YQXuQBeubC9wsKdm534jjkmPR8xot3cV85JtDuOLONn59r'
    b'1t6fTwb3N+uJtrl94SjdRsflEwgfSzyOeJyucMzOj9sz2y88jth+16GPI9a3L4yf/vSnnxwf'
    b'HCt+QuctZqyb2+a8wfa0UTz+53GjXR2s2miaWz/ooxQ0XSf3tzZzCf0WfbSBfn3atRXGMJ7a'
    b'NZtxgE2trDTGF7dJezXU3VbAVj92S9GnVpqnsfTdZn1zDVobA62xe0wAfVj1a9MO2utX73pV'
    b'X7S3Nt61hGPrbqx9auPraz6oHtAa45o4Tmu1oq/+Pa2op4DbJ+Y01nk1xlq7dDzabosF2w0q'
    b'Khdip20yMOnUtEhtzTHB7w4zv9ivnZrixmpT4wKrr8YCjTe2fWm8uVd+aH7rFfqI3csF3I7B'
    b'E0sLF3U8eTQ/7eaaPpn5pRrgSQuqn3m4d/dnf/Zntws8LtS44KF4cQTGzPz0m5s2hXfieGeO'
    b'Nu/OchuQ72D7/Y7mRNd+aX6pbfpf9KIXbevadabML5aetk8sHitQO4XjnYuoJzzhCdttKVwo'
    b'uH68Ey5owbnOvu/sFt7l5354S9+x7jbXNv3V2Wa72UYK2+t2U3vSEtay62PhBQ86ypwL93f7'
    b'2/a8Q+t6+K7qnKPY9xwi9LsP0Kkl12rt1FAcT/iEa24P2+93XHznn1guUjl2efFAnn43SVb5'
    b'KOSb49MXtqvbWp9tYuf86/OdeG1z7UrzcMzOvOL5tPMBXhRz+02Pc27D6XHu+I11G1rEceZY'
    b'9KfWF0LVNt4YUccLVX5IwccT5ztRY9wck+0xb2vw/NFzjWUy/RSOOfYfORmnz2NzHrMPxNQ2'
    b'Y+m3QNvVrZj5baM3tvtbf2MczzJZ5Zxga7wa9401WMuMEezmldmH6TePWvPUN3MU9WoaM9v2'
    b'wZjqtNmfcRxP1UztRF81tO0X7S3VU9S1Bsd2v+GzBmtsLdgt9KVx2vdsFB9nauY6VSczr2gH'
    b'2s0LbfexYhw2Ndh6DrAuaCn6jNUu+G/ghoGCmbRBcKzvgphLaDcvbctKa92Y9md8bbBayGqh'
    b'44gaF92+OcC+a0cBx4TajTWXbaHdPvc2A/mwX3nllVv/LW95y3k5uB2J+2MpvPPc0nf2mnui'
    b'r8cB+C6o8TyxC7d5zLy2qSm9bYoLAi7yKP6uv6DpuLZrE7R+T4GLLZ7ssfFEyTufgq3MXB1z'
    b'agV/43791399+x6B6/0jP/IjW+HdveZjn7D+6izdJ9BjxTlYsy+4zciLGb4gybuSFG4ZKZ0j'
    b'L+R6TPqdFyA3hXdEeXeUd0Wpf/VXf3XzNw84l2kX7GqAY8L1YV3cZmq22/MCsJZdFwu37QB5'
    b'3Qb7vINLzd/O4J1V1oJjy0/fjCn251xX+G602q7dKi+a5uRWtm6zbdbCeD4ho82vC3nscvvL'
    b'/DQPyDdz2Xd8se04M5f9aVfvY9s+n/SUxnFeaL6eF7i9Bpt5wLl6vM859jjnOzKcI+ZxPnOC'
    b'xxM+cwla9dacU9VSfNODc8cHg/l47Pg4ojz1qU/d7OSec8XW4x+qwS+eP3wstd1zOvz0T//0'
    b'eceHbX84gjLPM8yD2hyOrb79stommT7ARmnOol3fqt85Mm/X0NxtU1bHhDX+lR3MJfZbo6e2'
    b'gGs51xSqaYx0/DK1xM99OGPRd3zajgvmnLGrNrXXHcYZC9NHn7GAvqihbtFnW7R1rJUOaqvG'
    b'dnMUfZZqaLvOtPW1psz9qb15Kd1ngq72VQ6xvdLY1i711c6Y+Ci09c/cxljDbJ+JP/9gXIHd'
    b'AU+jEyqrHO2vcjcH/tlvfPNT5nj2S/NB/fX1wQf6sNlGU/tkjiWrOXmPKm3uNeYXQtDxggFe'
    b'+cpXbn0umr1HGtBTfKdPe9vgXHghok8/FzDAvb3aqPneAPAOluPoB8YUjgEvuF7xildsNXou'
    b'LvrlSHM4H+g6FsfiwpR3X3mXli94YucJUlax2GonZu5TqMa2FwJ8ebUnC0ov0LtP2GcT1qfz'
    b'mDWxQD7WzwtY3kHvu93csjDxPn1+nrPj8OmB+YUvmHJRQk2cf4uiOtrOZ9pX+dDySY+fVljA'
    b'44K+xxZrqd98rGXjOg42HxM+BoD7ubmVZY8519knr/eqs3ZeRGKfa2fb+QFtbzXiC/Ac3+jU'
    b'0CanNl4s8w4yjyUfX9z+Y27q5uvaSR9ngp9YS9EHPdf7XRjgBwiE/OwfcWxfWDJv8+HzvMA7'
    b'4tC5ljkvQOv6sN28M66ux3m3QfoCbzUmPo5v1pu232WgsJ/Y37T7BkbzrHIWv3/AbYzUfreG'
    b'NW7s3hyx9xzkz+1y/uDYA/roKO53twnYF+I4PWZo88lcf0ygx4A25wCOaVvMD9Rup1phm6Tb'
    b't7KTg3hzW+zP3NhkalpXt8qjRh19bdVqnxjrGqzW1Hz6mtt4cAxLbdDcYrwF7ZyD+Yt5za3G'
    b'/vS371iCjf1IzdjUoKZ14+zPvNomtRsz281BEdvUaqXHJr6pod/49jt2qd21EdvVSPM6ztTV'
    b'bt96zwfVCfureqCtvVrQRrn4Vre61fazqjomtdkm+cpO7STUWLct1asp2tBQ5gZZm2NirO0W'
    b'7NT6mkOfZdpWaJ+avTbQd1xuUeBjbi7geDeVv4/Au2/8bjhwGwcXr6wBP1N5zTXXbO/i86sc'
    b'/Gwp7/zxRM9vh3OB2fu3Ow7wXQi03OvKu4nk4cmFe3e5x5iLP94FZXy+aM3FC0/g5Hnc4x63'
    b'je+28DOLwJMSvznOvPliI/n4NRouRrgQ4CcK+YUbvuzIzw5y0eqFPnNgTJ4M+XlJ5jp/VtX5'
    b'U/OzlOh5Z5Jbgp70pCdtP9GI1nmh80SGzfWlzU/LqgNeeADvNnqfu3HcJsMv4fAChXVirVkT'
    b'cvGLMswN3Tve8Y7tZxrdJ/yW/9wn3hvN/uWdQDT97X2wzfbwi1TsK94d5SKHebJfWD90bAdw'
    b'uwvrwYu0T/qkT9q+K8FPLPJrN2pdQ9pAbVv4WUhegPIF297DP/cPcc53td3Ml+1mvux7j0Xu'
    b'G+dXaVxLfkqVX/JxLf350gk2tFz08f0VvkfB3w/gF6EYn/v+eXw4Z/aX28HYbvc8BqBrxwtz'
    b'1o514zfwXTt/tlOcIzUXihzb/N0KLs7YTxzj/CIUv2bD7UYeU+xT/Gw/28Gx21tvgItB5oCf'
    b'fcl68vOcHAvk43jxEwmPWy7WGYP5UHgMur/4VIPHQUHDPuO7C+wPtptt4PH+6Ec/etOw7a4p'
    b'empycvyx9vO8wK8a+bOffeyyzp63wWOM3OwbzmOsVY9zHi+r4xyw80MDnG/YTm4L4qdn0REH'
    b'fOrnJ46cZ9CwjZ5T+c4M+5s3Hp785CefnDvmcQPYe9x4LNAGtq0Xw83DpyV9HLnt2j0/AWu3'
    b'Oqd/8qd88uERX3D2ccSnaYzFccOxxv7gscnP77If+XUvHiOeQ9k3/GoS5wKOEb/YDszTbZDZ'
    b'h5UNsPu4onY73Nf6hPbKPo9N/VNvjLXUTkHfmF4YzhqdtXqKfXD/2i/azDM19dO21Aa1l+al'
    b'NMa2mqJ+ot04Ne6D2sC2eqB2H1ukuqJGv3HVV1Nfj49qZtweezr6zSfajSvVycxBzfHiGmkr'
    b'7TtOt3WOXT3tmRf9ngZom1N7/cDYaObY0Phthh1wBrRve06ABaJfm/kE38o2mbHGTZv19E8t'
    b'0FdrbDXaRF/t5l3ZRF81tCnVwcwF2Ph9cv54EffE+u4pF7L8Ok1z8OKBe7q5wOC+bn6ylJon'
    b'a9+FnWMKTyg///M/v7V5R4t7cIH5cOHBxRtj8qTMHKh5gucjeD4Wd5t4UmauwAUO9/PyJA+8'
    b'GPAdZZ6g+YIg76YyT+bFMQOug7U2CzgecGDzhC4+Ea6OQdrmgLZFG3WLDyBewLkePBlzrzWF'
    b'bcXmuMSwvaftE7S+g+hPbcIcm3XmIgzYB/yBJ36XnS+Qd/vRc9HLfd/k40IIPWN+y7d8y8kn'
    b'PGB+cJ1EO7W+6mecPvpzu/liOzUXWv1EgHe1mT/rxvHCT9d2Lc1XHJfHBdvN9nEs8UkVF3u8'
    b'8OrcnFdzsZ61C22OYe6b79pxwc/auX88Vs0v9Dn2eGzyeOIFLL8WxE+Esk3sFy/kgZpftqGm'
    b'8DOxzlENLyz5Urf5+A4QF33kIxc5mU9zWpPLOa78to3/nd/5nQM/yQlcULPtzIlbXdSak3FZ'
    b'Ex5vx84Lxhgv+qBz4fHFsQM9zhmrxzmQg7Xhgpm14SKeT/PIZf7mBn5liPVjX3IBzRjsZ45Z'
    b'HjN+etd4a/N2vaHbAvWJ8RYgbqWV1Tn9cz77c7bHMutPPMcyLwI5xnjBw4sGHm8cd5zL+cTE'
    b'cRyLfL5o1UdNkWPzmr6VFtvMu6crzke7tXnoN2ftUg3rQ5GZV62PacCm3b5t0G+7tTpqSrXQ'
    b'cdSoa107zDygFthGc2tbYd7Z7hrtgbZj0jauuVa6if7qqp+2qQVt4H62b13UzzxqsWlvbbu5'
    b'm8O+tA320e/5xD71Xn7tQNt+9UVN86iV+ilTL/Q9/23lPve5z3X+JB9gnMlNMu0rVvGl/tmW'
    b'08Y37liutsG+VAPVTV9Z+Wq7kDzY+oBtbNtcWHJBw5PFKpdj8c4cFzleUKDT1/a08W4e72by'
    b'Kyt+ylQ9fr6IyMVAb4uZoGeujO2xRB4Ktw5w6wg5fIeLA3B1wkIPnadga04ubICLFW4JwN+8'
    b'Mxa0UVdHUeM4MwawebHPu7f1ifFcLFPYJz5ZA37eAeVJnN9OZ10dr2O2zbuS5nHM1fED7E/6'
    b'rDfQRqvG+ZlfXLuVTpv92qoD3hWlMFd/7at+MIbtAm8LkmodR1hTLqCImXMW47W379jtC8c6'
    b'cBG7p5HVGLRZfz4VIIfHezVl2juWPh473LZDPt5lFsezXjHHk7lungd4QTffhVbTXOiZl9uo'
    b'hnq1P6Z9zlk/xwPnEM55zHFv/tgZn9oXKuZsDbX5mPR8gU1oMwfbq/hJdStNcwD9nqOgMc3B'
    b'Y4hzOi+4+/xMPKCleI7mPNLHvLn4FJk17XlGOp5cqG2VC6YdjDVP801ba1gdB1P7wdJ8M4++'
    b'9juG/epWmj26PdWZ59jxAY5lvUd1UO0cZ+YxbsZeSN9YsF0b7MVLY1axq7gZM21Q/0pnG6ZP'
    b'+0SdTP30l1VO9MY3x9Rqmz760Figf9qxBTMOavuAFwyAYDWw9mNJQfvUVgMzz9RqF23HfHvo'
    b'mwtGnA9ic1DQrfxiPmP0aW+OY+zlLNjNZ7/jeiAYv6J6aZ4yNVAbHDvhmNP8xq5y7cVaawP7'
    b'3O7Cu4a8w+bPtIoaaucHzTnzTTvs6WQ++MrU2wcuzLgNhXeQ+a39lQab4++NTb+xbVM8Hhpn'
    b'f9ZCX/SpKzOHNph20CdqVu0V1ZSZw/i2wf5Ko/2YDYwDddL+Sg+1T71tfdVSVseZMZPmg9mH'
    b'5j+NVXypf7bltPGNO5arbbAv1UB101dWvtouJA+2ea6Bmac5VrmwgX7bs297ZYN5bq4O6Nte'
    b'UX9jKZ5XQN/euXCVQxyjOSlqqfeeY2Y+c9ieedo3BvTNdmn8nh+qsT19tqFa6PppgxlH7XqB'
    b'edSJa7fSabNfW3VAe+rqh8ZQT6o95p9zFv3a2++Y9suMXWlg6szbWqop0944fbBnU197MW6y'
    b't26T5m6u1TyAeua96N73vvd13AeM0SQVgL76TUw5Nllj9mgua6gNpp+acSdTt5fTWlYaOe3B'
    b'N/XHMKbM2Obb056WA2Ye2jMOsLONahtTtJdjY8w8Kx9og2oEG7cR8B0J3nXjNg3gRYNfEi3E'
    b'U047Lue4x05Y2FrDXLO9uMJ3O3x3lnf9jFfX/MZXM/Wwp6tG1BR0jafuWsxc7TdfNTK1Kw2s'
    b'dK2l8dobB40tF5oH9nLNvKs+1AZ7dpg5RPuMbb+x2gFbY0Ft46H2WYM6qZ22jwPjxH7t1Kvj'
    b'irbUZm71xX59e/nMsWKVB5pr5pj5Zo4L0e/1ae/RGKCP/oPJX7RTg5r2bYP9WeuDGatd9EN9'
    b'qzzmkGO5ehzCKpb+KofnO6i/uSan+Y7lqX+2YebUPkFHmc9bzQmrPmCrb44z7dXXRmEOfd4o'
    b'jdHXNjQf7ZlrlQMaV/5n7DMv/ZW+vmrKjG2fmu0Dj7syc88aPN61aac/qW/qmmOPE+0nfMIn'
    b'bC8YDCpN1OQw7aBP1KzaK6opM4fxbYP9lUa7NpixMG17/ZUeap962/qqpewdOCuaD2Yfmn9y'
    b'IfGl/tkuMyfMuGO52gb73K7AzwsKP8HI9ySqa/xk5dsb77Q80tjZnnUxh37be6z0MJ/kZi76'
    b'p+WtFuhT5okaOl5Z5RDHaE6KWv17saCNuttbTstjv+3S+D0/VGN7+myDWqDu+mmHmePYk2U5'
    b'ptNmv7bqgPbU1Q+NoZ5Ue8w/5yz6tbffMe2XGbvHaozmb97VONBYqE4f7NnU116Mm5wWJ9U0'
    b'V+OqoV7tD5i5Ztv8tlc5RK005kLzTRttH1MXEj/ZGwO005/nvsbMHPbNA8QDtqkXY6i7P7Tr'
    b'W8VfqG2CBsxbjDVP801ba1BXpvaDxdww88xx5xj2q1tp9tjTmefY8QGONcecVAfVznH28szY'
    b'C+nT1i7TtvX5hMG/9AkzSAx2kD2qmYNJNdR9cJSZa7bNb3uVQ9RKYy4037TR7s47LX6yNwZo'
    b'p///n6zO/jwl78yD93Praw3Glqn9YDE3zDxz3DmG/epWmj32dOb5/8rJCma8NM8qdi9XY6YN'
    b'6l/5YNWvbqJOjuVdaSdojG+OqdU2ffShsUD/tGMLLiQX1LbyA/aVDfZyibGz1id7Gtizw/RR'
    b'sz7U2rSrB9fQfNpFu5jLNvG2Vzk6plQL+rFROh+onrr5Vrnah+bfa8vKRts56YdqBL+6WUvj'
    b'9Ev1q3Na9TMWsEE1xdyreo+VHhqjDTzuSmOO5YGVtv1VnDZoXLW1zdhqYfrhtBhYaUTtXB/a'
    b'83EIxlPmcQDNIVO/ty+ahza2aTduZQPjbIt59DmH2uf2Uq+2EcwDK99J/vmCAQw28EL6tLXL'
    b'tO3FS/OsYvdyNWbaoP6VD1b96ibq5FjelXZSTXOstDB9HQ/a39OWC8kFta38gH1lg71cYuys'
    b'9cmeBqauzBjq+WDTrh4aA9pFu0wtY9jeozGw6gM2iicDdfVPqmldGr9qgzH1C+3OSaoR/Opm'
    b'LY3TL3txaqpfxUo1xZyreo+VHhqjDTzuSmNWebTBnl3qF23QuFUua5lamH7Q1n5jYJVXZh7B'
    b'Pp8EwXjK6glxjg1Tv7cvmoc2tmk3bmUD42yLefTN8xD13vZCbaAdVr5uI7Wa5qtdtKmD9mce'
    b'OM22apc9O+ibeWTGVS+z79pg95gAdV07NdRibDWgvZym0Q+rnGDMhWpBv74P1i76S2NXcTNm'
    b'5ZtxjdFnG/Zy7unsA7aZs7bpA+2rtjS+rGxg7Eov9c087VP3uKzvf2acyZbfRqFPIaiDlpUN'
    b'pp0H2iqfOm0wY6uDtlcx2mQVS93Y9oE2pXrraYPmaj3tYm4LTE19Ui3F/BN1Hd8x7UPjOyf7'
    b'oI3+ymbftmCTGQe1gX1qbbPuGNqE/rEc0hzQGJhj1V5b884YWGmwNYfU3nFkL6ZPaoCN+NPm'
    b'Yy341BrfPvAYnkwtdU9Ws1Yn2qE+7BbAR6FvG+xfCD7ZWzpGbWAN+q1BvW2pzhye+6oD/e5D'
    b'+8batwbazQ22zb8ax7j6arfWLtMHHgfq9Dden/H2RZsx6sxjX9+0U+trDWpsi7ZZq6fQnkWN'
    b'tW3jizn26Dhivz77rYt2263NI9PP8WZb6Ddfx7TWZn71pdqyiqG90mObY4L2+ibajLPQ7/mr'
    b'sbQtaj2HWcR8tvVps98YoK9mUjttCzGrPLDKVd8qFrDpl2r12552i1QD9YG+PfsKtR1rjgPN'
    b'uZpDY7DNeNCmVt3MXR90DFEHU1t9+7DS1j9Z+cwLHrszzyquNmKax9q5WcP2jLU6kcgqEdBu'
    b'4mocgPax3ID22BhCu/3GQPPUt7rYKeotgt1iPttSX1GjfcYBtvonta1ip63g6xxsN4a2Y9Qu'
    b'+I7NAaatenDs5qpmtk+bB/6VBhwHVrVt8WJu5mwMdnTa1PZJpb7Zti/1A33bpblgpfO4njqp'
    b'vm00zUdN2YsFtvdCmHmg4+mzrd1S9MPKB8Y1T+PAvn7Zs0Pz2J46bSvwgetmjlUb6GsTbdqn'
    b'X8hhHmuY8SuMNU6tNvr6QL/25qbdPkxbc0kfX6Xn7c5HzKVP1GibfcFuWWFeCprGN64+t0Vf'
    b'40WtuvbLjFVvu0ydtbnNZWm8mj3QNmdjYeYDc6rX33bjrEWdeagt+hpjuznZF/a9BqEP1VG3'
    b'LdopjYPqa9Pe/GVqhLZF1FGbb6XRB9Nn0V4/1AfNJTNeP/XKZx/UXijENh90PP0U7epkb8zG'
    b'QPNSph/s66Pu865FnEvjtEH7q7j6W0/t3rhTW9TAngbwqbXdentGazJpIHU1tUttxNq2aJPZ'
    b'V7On1257+kt9Pmlj024e0U7tOB1rhdqJ4+Drk968eGj+mWf6zQn67Btf/wrsLWLb2nGheaHa'
    b'1RwAW+1ie9paoGPAno+iHaqfmKO+XgS3LWodh9IxVuO1XdCax7j2vdAAbMznWF7jqPXZNo+0'
    b'3zGKuWZs2ctf9FGbE+Z4bp/5qjWHftAG2qDtqaGs8kLtE3z6m6P2Pq612xa12mjD1KwwFlqb'
    b'zwLW02ccGCvVqbXQl8aUqQPji321jgfTB+bANs+XYpu6dmmO07TQ/MbKjDFPNUXfzAONM281'
    b'PabAsUr1zdXcpfEzFxirzxyzLh1Xqte+5xf86uufZaJN/xxPP/0927TDtLWeOvrqoW3Y05hn'
    b'ta9bi/pVvulrvzbtYHzzqLeNXpv2SXM3prHq+txW8AntGUutZsbrMwbUWsvMQd18zWO7fTGG'
    b'89LKp9940F7/MdSstNjM2zGKmuoaB82tT5uxqzyynZVnoH3blmo8EOxDB1Br0QaNETW29zDv'
    b'Ma1jTd+MsdYu2CnNMTUwfbPvwSW0KfpnzlW+xgM+czRe+x7qLeYA46ibey+fcULfJ/jJzGH+'
    b'Y7n3YjquOov+xlavfWUrM6/Qbmx12tVrs0j9szaf2G588+GfmlU8VAuz3bGtZ84Zs8IYQVdb'
    b'2/jMg31eIBprUQv0YXXMTW1zQfNNrahtHKif42Jv0Wbu1pw3q9NX9MH0G1uNTLv9jj/jsFlW'
    b'1Dd15neM+iaO2/GN8QKqOcxbmmOVZ7ZX+lmrnWBfxbQ9Y1e5mof27Ivt5q2tVDN9k44B9Imx'
    b'7NH8e9ppMze4T+ljN18vINXbL9j6/EltEdvkcFxstq2ldkpzTW2pTsxhe+I8OkfBtje2Ma2h'
    b'+hWrfKuY5hb1oL80xtp4tbPWzz7Eph1o65fZh9pWMaCtvqlbxe3lA+z1t8Z+WmxB21rMI+1T'
    b'O9YcswXaNl6w1zb9oKZ5yrRtz3wmaj2F09Ynzalt35wyxwL11LZnHOz5jNNvW13tsMoN2qmr'
    b'MW5FcxtHezWW7eZr+7TY9tVMvRptstJPTdE35wDmaL86mfmnbuVXQ9Fv2wLVrdizN4d5m1+M'
    b'n/ayGmNqfZyobd144tpve0XjO0dsq1z2a5fGUuxbQ+NWbePqK/gsgE6tcfqAfs8x1e/ReDCG'
    b'4thqtIF281czMR/MmJkH6l/V+qlnLmk+ffVDbehtt659jlfoW8oxvT6o33HU6KtmdVEBaIyz'
    b'b47Gg/bmmH0xFp9+bfXRnnZpf9Wmpszx7XfsYnx1pX3ajtHxWqAaawpUN1FTvcw8YB7t9vfs'
    b'YLx1QUcxxiLtr3LDtFPTl+aQxlRrW/8eM599c0rt9VE3P31t2tU3xlqNNqi+ftug3/ZkL5ba'
    b'As0D2qG6MmPaLsTiax61s5babZtn1S6n9S8kJzV9Y9sWbdqNKdhmTtuyspVpb75VHmjO7RkZ'
    b'g6VU2Bralur3csHKD6txZhzM2MatckB9xre/KtC46rVT1M44UWcbpq59bULf3Oqk8fqotRs7'
    b'cwr2+mZ7FWtMxxR9YnvqpPap7RgzZ32TaqEafca3D2pXeWVqrMlhWVH7Kj+2mVP0tcjMS1+N'
    b'vtrrl+ZoW6qVVQ77tM2zigXsxzTNVz/txoLjaVdDETWl/ZlTmsOczVV/0T9raNv45pn+PV/b'
    b'MueD5phOH33bxtQ3mfEyY8y7ygH10TbeNr7GVmNuaD01jZ+oE/rN27bM/p7GsW2L9hZRuxpD'
    b'3Wosbc0F2qlX8Y61yr/Sy9SA7ebay0G/BZpL8DWfWsHeHFDtyg7N2fYqPzQXdWO1zxzq1Oif'
    b'qIfmMNb+zKG/Oqmt+ffySGMsEzWNk/pWY8m0tW+7Y6/azU1tkfZtN0/RN8eprTXF3KBvjlcN'
    b'GAv6tc0c0By1w9TTbxtm/BynZUW1N+A/E9Qx+9ZTU2Yfpo7+Kg/FNjVoL/qgvhlH23zqps0+'
    b'qNGnv1Q/a2NsY7cPUw/HbNC2zDGE/hxPv3b66qqFla2Yq3knxE+/7b0xC1p1q7iVr7XxpVra'
    b'alqDfaBue4X6as0FtvXXV4xd1Y2b9hXaV/MQc8582GacPrXaqtMH2qcGmuc0P+Cn1AYdA9So'
    b'13YaU+v4jW1bX8e1aAN1FrAuK595OlaLvtboZv7qZeqaH5qvbWOw1SdTI7SNAeui3rxT035z'
    b'YzdG1M4cgM78jbMP2ppTGqt+xgG22S/msT2pfuWXmZe+NuqOA/Wbd6Wn7rj2tdUHM6ZjTG01'
    b'6vba0HjsM2fjrFvQ1tdanzltizpR0/jW0Hz2m6cxauuHqW/ftrFC274xja0Wm0UaW6a2bbSN'
    b'a7/UNjXNa61fLaX2YtyK6lexoL15HG/mbn/6zDPHob/nc4xj4zR2L1fbYM7a7a/iQZ+l8W1b'
    b'n/cJgxhYW4OlfmhMtcaufKuxYPbBPMdyiW11xhb61dVv33ioXp82ddMPzVGqbbusNBPse2PU'
    b'vorH3zIxt7HNQVu/TFv1sBpnau3PWmZ+2pTaQVvb9qttrLVtsT3tUjttmblsU/SJtom6+psP'
    b'7E/2ck4ar576WKy5j2nwdQ5znvrFvmXGaYfmrl+mTsxZOk61Bbu51LRe2cT2HGfaqR2jtlUt'
    b'5ihoKPXZpm7+okafWtvNWZ80p9rqqNVUOzHWWpqzPvtiuza1p9loz3yATb2ord24PTv1Kndr'
    b'UKe2+RrfmDI15lrlgFW/5RjOrXNpuzmqpWBfaasX7bWJNnNCa+zVlKk3R3O1LWpk+sv0Gde6'
    b'mubVt9Jqn33brUEfYLcUNDOH2G8e0dcY2hZjWjemY9pf+alnuzYxpnbzCT5t6jrmZM+2ytHc'
    b'0LY6NdbViLaVTtsK7dWX5oDmcRzwttEbVGBSSu0r8Lc0xkFEO1RTXfPYh6kBbNWCbWoLVEdt'
    b'vwXMLfatV1pz2Qb7soqxDfobR3v2pe2OL9OvxjLZm89E+55fHKc5Owf7x/ygprlmDph9qG7l'
    b'F22t1YN5ap8x1ZTqqqVtjLQttTVHUdN81c32SiNzPOsZZ3vmmv1qwX5t0Pjpo69fqjNna+2g'
    b'DozThmalb8yxfIC9Mat62hpT/2lj0dcn2qptvpW+dZm2vXlA81BWc1jZy5zf1Nu2nnbbotb2'
    b'hTJz2Z/21ViW2qyl9qKmWttoZ57moN2+GFPdqp65px5mbtFeP21L+0JeC6z89qut/RhqbRPT'
    b'vvUcV9Qcw3ixXXvrVc7a0KgX42bsKpd0rNbm3ovtWBZsxkHbcCwXrPKJNsFnXx9l5iqzj1b9'
    b'Xrs5ZeYpaOunbX/GdTx1Hav9xqoV4xu7Z5PmqG4vpvqJGmrLHtstSXAs4YpVUmzN03z6yvSD'
    b'8fQ7Rtsw8822xf6qhuoc07HaVjd9jS36GqemcTBjjZHG62vfWq1twCeN2+trA33N17ZoU2t/'
    b'ame/48w4fUBbTftg3LRZW0C/0L/QWGh89RRzUGYfrCfm128+wGau0v7UizZoDmpL46oHYyiT'
    b'xunH1hhKdTD7K45pVjkn2NWpXbXVTdRB/c3ZWG0y7fqqgek3znHEfm2gHqYfn2UP86ozh31t'
    b'akXdiuY5Rv3qa+t4Ug21cxRt1bSeWmlbps2xzHEhMfZrX9mA/t4Y1G1PnaiBVbt5zWO7tubV'
    b'LsY0V2tQs0KffvPUXpv2FepEPZhnFVvbzAH6V/HHfICtmmNMrfrWlGpo6wd9oN524wTbzNE4'
    b'aE4wZsYdQ525mhPf7Fvrsy21teizVqdtsrI3fsbadizAprYc6zd3Y62xlepaTx3MHGrFeLCG'
    b'mXOvXYj5gE8YYCXeo5MA+hahfSE5Gzv19JtzxYX6rR1jFVdb28Y0Vn/rOV/6jdVXOzZLoa9u'
    b'+vVpm77JHA/2cgu2+hvfMnPUZ784rvkE3bRJ7au8+Gtvkfap5xxWY5S9XGBsa8cQ2qu+uZqv'
    b'rPJA9bbNU19ZxTY30LcAWtrW2mHmUVfsN67s2eFC8+sr2PXNGKhNbfVtg2PoE+0wfbMv2owz'
    b'r+32YeZY5TRXMZdt6Dgzj7ZqLYDdItVaTxvUL2035x6O3TjYyymrGMBW+2lzmHppfjWUlX1F'
    b'x63eGv8szUV7xgE6qF9WNtA2x7INxk5bUdO2+qmVmV/dsXHMR6lGu/3Wkxlbvb6OM23SHLbB'
    b'vrGNgWqlmo7T2ri9+Nppm8e2aDM30G6OqbeeMda1y8xFPW3NMf2WakS9qNPeGNtQn/H1q6fg'
    b'r36izzyrfLWt8swcbcPsV1fMU2rby7GK2b7D0ABpspUfmnDqaOOfsY2h3XGsZ+yspfHWZdoa'
    b'7xhtz/yAbdrRVl+Ndf3qbYO+srIB9sZVtxdT1DgPy7TPvBbQT5n66qo5xml+6Jj2a3OcY31o'
    b'jV+0g7ltW8+Yon2Vf8as+h2/nGaf/tpbSjXA+M6htmO1VG9b2rfdmnIszrHUgvo9jX2hb4Hq'
    b'Vnpsq1p97c27R2PMAcaDefTJzD37sBeDvWMA7Rb9zbGy0xZsFqkf6rNNjc681Yh5GlOMta0e'
    b'2pZqW4PxHUM/NktjVqz82mZ+27W3xl6feUC/NahvMVZmH6q1aCszVn+1tinq268N7Df31KuF'
    b'6TvGjG2MOWDP7lhQDdie9RyvfWgOmGPIzGuNlvbKXrRDfTPuQuKBPqXjG6NW28q+AvvKZ7x1'
    b'ae7692Lodx6No576amGlqW3qrWX2m2vV7rildgu2qbM/x4Xa1FU/bdalNmOst1uSLBNF9a10'
    b'pROW2mzPmryrWJhjorOAse0DfdrNbVtN/dqAfuOLuYoac9m2by5rme1juYG2/Y7TvNWD/uau'
    b'Xl/70ly0m0tfa0tpPjG+2lXb2hyNo2iffaBf9FvKtKmdOaBaNa1LbWpsA30LVDtRA22DubVT'
    b'Yztmp2gDtdpbW6S6FfircQxt9if1naaZ/pmXfrW0a7dtzCoWjG+O0jiwbw7jZry2FdUBuuYp'
    b'takB6lm0T90qJ2CvTzvU15rSnLbtC/a9ccq0r7T0Ozdobpk2+uarzjY1Gsuqrw2stVVPW9o3'
    b'xhrwTb3QboGOA7Y7hv1pm+z5Z5viuNr2xquWItWv6ulvPqE99avaOIp2qM0yaYx6StnrT7t5'
    b'qKdGG3WL6F9hXKmtY1hXP3Ur0OBf5epYQr8a65UWtOl3rNr3aL49XTXmh9bVyIyzdBw1zaHf'
    b'PkwftA30pw0c0xytm1edtF0d2C/4Vnkuuve9733d29/+9nPds8yBV20w2bRDfbOGakG7NAba'
    b'huZZ5Vz5Rdv0NV5mHjWzDTPfHs11LLY6WeWfupnTesWeb5Vz2mCvf1os7T2aD9Tu2YvjtN0x'
    b'V204FjNR0/bUt7/KpQ2qEW0zfpULpqZaWcWvtPpEjW0x7liuFav8spez7VlP30RNUbeXD5qr'
    b'uWe+6mBqV21Y+VrLjIHGQWPLheaBvVwz76oPjdMG1UL1MGP22mC/saKtqN3LsbJL82lvLLQN'
    b'9quH2usv9e/RvG1Dc+7l0rbKA801c7QNM8dKD8fip3ZF886YGW8f6gc1YC7b0P5KO2t9cCwW'
    b'VjZY5Zk5HnH13Q6PesebzvXO52lX3Ozwm2/6x8Pf/o//sfVnrHRMWI2j5lH3vPvhkTvjPf3K'
    b'mx+e9cZ/OLz+7/7unOV6zCnm1lZ/fbT/wz3ufHjgO//h8NXvv+Hhla969eZTM5n5/sPVdzk8'
    b'6Ezs5/zDew5vfetbT+zWauGh97j74Sve+cbDd37Ivzy84GV/sdnmOMZKc2lv3pUdVj5tsvLt'
    b'2fbiYBVbLlRvX5oH39FPGLA1oG2YfTFX66mdGvxqZq2m1NfYvXy2wZhVrGWitm112sE29bRb'
    b'mn/aaK/qYoxlzg2mXa1F1NRGWzu1OWHGyjHdXoxMrblW2oLWWNvGaIfmmW3LRFvzdAzbssoB'
    b'6ptvZZPmoV3fxFxT0xwFXceFjqGv+fba5lC/52sN6kt1czxt2rWB9coG9bcW/NNWmmvFKp90'
    b'bNqOVc3e2GrBuvnMo86+NegH7KCt9tqqsy3GiH216mccoGmZmsZSpqbtvXht+PfY09Rum1rd'
    b'Kie22lcaaR7zA+2Wma9xona2zV0bzJz4aoNVjDrrGSMzX/O0DfZXufDpt21xHvqM1zbz0dc2'
    b'fcdi9JWOK9Wah3610w+1WbSV5pTL//ndh4ve//5z5dqT9v/69jcevuOqyw9X3eQmy1zieLbR'
    b'2of2ybKNd935Y1E+621/f/j2qy473PSmN920M4c4hm1of7Ydc8XmP6efmHub79Y6i3brE851'
    b'yYfvZPwUbdVB7Y2VqT3Gnl978wo+i1Q/29VNqgf12Du2GuvtOwygqEmkvg5EXf2MdfAZ3771'
    b'zFPf1MvKrg1mHnB8+tb6ytRTQHvrxtNWC6tYbcbWbrw2mLpZS/vTJ9gpzqE2WcVOrZrOdaWx'
    b'QMe0bR/aLtqbq7nx1wft6xfa2FZFaJtD+8xR/yoW6q+9/ZZSPTX90jiL7OVujrbx0zdOn3Gl'
    b'NvUTc9Q346xtg5pjeaExYB7jGkt75rNdrTppjPbZn/bmoN0+0NY+Uaumeawt1dmnFv3aqcue'
    b'HfRZtAntGX+avjUYD9ZAW9/UW6oH+pYyc8jMo27arPXNfu3FWHy2ZfrsU+/lOjbGzGEbiJvj'
    b'QPNNH2391ZkLjKkfZh77bQv95ivqtc9xpe1J5zZj8E0/fXVTL23Dagxq245Dv/mLPtvQ/tY+'
    b'N8z3vPeSwwNf/eYz5S1b/WmvetPhxTe49PDRb3vz4VNu95GbvmMQO0vHsy5bvONdc8mZMRjv'
    b'7FjbeBddeviYt73lzHi3OW+sjl37HANfx1/5rfVrm33Y+mlb2y7YnvGSPzs86G/eePj9v3j5'
    b'ia75xPHnWCvUFnNPmnOOW/3Kp9+2Ba1zoKgB81Qr2izQXGAtJ7+S1MQTk9i2RrvS1zbjRM1K'
    b'W/DXTnul066P2tzV2zYvtTrb9purOWAVs9LP2LbBWLFdm+z5jsWvxoPaZ7wFjW0wxj5Us8q5'
    b'8gm25mz/QjC32J92mPY5Tvtq1K/mNHNZtMGM0z/tzTXja6dvbGOgOlFTG2hrfriQeVWzFzu1'
    b'9B3Ltn3b9cvUF/W2rW3XZ9t8ltqKfWObV7RZ9nKIeWzv5ZXpN2bSXPqP5TxWNw5bi3NpmXF7'
    b'fWh7xlPX1lpst1YH1LahPmi+GQv6tFHv+W3DXruxMxeg1W57Lx7qg/pnu9qOo6820G5fjW1r'
    b'y0o3UQO0HaPxMvvFmMat6lWO2ozX1j5l9sEa8It6MdZa6Fc3mVr7s339FfG56oxP/5Pecc1W'
    b'f/Thfeflo70auxrRRt24qcX+c+9679b+qOvet9Xqp1b7nEPzr/3nGsHcq1xbvf1/fV1ONOfG'
    b'pW6+5px9mPH1N2ftezlWdou0XYg1ftbNf8wn6mqb6FNnnvM+YZhObfbFvnqoxhh9ZWVDaxHj'
    b'zaVtpatt1lINOI85n/bRd3x99vVDfRb7Urt5Z07QJjMHGC/GzLww281hvcoFbaNp7plHv3a1'
    b'FNugragxtqjVr9Y8+ktt1VE6hjaxrZ3iuI0DfTD9tTdPbWJ7xjdWGzS2qG+cZdqq10+pHVrb'
    b'VqfNWNvWE+NhT4fNUtSXleYYM685a7NtrvarK8d8K9BOfedeP3bzU+xDdTD9oE2dbfttw4y1'
    b'aKe2PX0y+3t56MPMoW9ls90a8OmfrOJm2z7Qbswq3vFmnPWeX5910Q/6po62Beo3tjn0zxhp'
    b'vHqoHehb1Fn0C/7mMk/7bbc0j6xsaCfqqOvvWNZqLI2ZtTRP9W0X7I0BbY2Z+WCZj3/ndPq/'
    b'+MrLDu+54Yce/vqiS07y/Oydb3f41Tve+nDTq67aNOopT7zL7Q7P+eh/dbj1rW51kqOYQ6rB'
    b'/r/d+NJtvL85XHIyF+qHXn33w7M/6hZb7tZ8Z6CgR8v88FMeeaYvjmZO8ljM+9B73O2c6vz5'
    b'PeT2tzmzfbc/0X/7v77j4RPvcudNo86c97/rXbYxKF9/jzsfvvPqOx8+9na3PXzHPe50Mi/W'
    b'6mFX/+vzthOoP/PMHNwG8vE9k/vf9c5b/yY3ucnJmI7rWGK7GqietrrG64PGghqZ+cqebRah'
    b'ffKzqgTqtF2bdVnZCn7zrPrQNpjTsdVbz9iW0v6MtZ5jgbUYW2aexgP9xnQc7XO8GTPbzqO6'
    b'9vFbwFpmXHUzhro5wXhzVFOqW2mtizrBr0a9sWpXMfUbX2bOmaN9/JY9mqOxtGdumNq9GNv2'
    b'O4fVnJwHpXOqrjbt6kUNmEf/aboV+KbfdmtzV7eygXZz20bXXGB75YPm3vNhpxhvkbZB7WSO'
    b'1Tz4zG8t+sR+dW2Xxu35j8VNX8cD+pSZh74F1IFafaBv2pvDuLarnagFtY2zSPvUzd9cezb7'
    b'rSnqgbb92lc684BtNc0946Rt9Y2DxmOH+qAx2qT9to2xLVNPUWtZ5dFWH8w+aCNOsK1yabPf'
    b'evpsQ9vQGGtslgu1r1ADj73s2sNv3/7mh+fc7sPOlJtt7Xte997DH1zxL7ZbbeR5l9/4cPN3'
    b'vu3wybc9e9sQOSj3vMPHHm7znn/e9KsvLU8Yj3Ec6+x41xz+4MZnxnvpn53MmfoV73jX4f+8'
    b'4ubbl7ALXzC++sy4gO47zlzEf8U73ni46pr3nHwv4gvf/veHh7zpdZummPPpV86cbzp83B3v'
    b'cLJtZ1Zzs3/h2/7+8JH//K4zOc9+7+J+73jL4dve84/bdpd+V4IcRH/ym15/+Jn3vOXwb975'
    b'j2cdZ2CtmP/DzrzIcD9QP/Kedz985Zk5nN2Gs2Mx9ve89fUnuV1z6VoVdds8zm1PmXpp/sY1'
    b'z8oG+moDbRSxrf3kEwaoEJqAMgda2SbYYfoaa18tmNN2a2m8bfPYnn4LzPzGlvbVWQt9ddT0'
    b'p2biWM0/qa95ZynNWd9sq1HfOGuxP8dre8aopTRvY6A6qBb29G23D8Q61tSI+WHPX83U19/4'
    b'2ooa/NMHtdle6cCxHauYn9I2aJtx1eqfGv3mgsZNZjyoM49F2oaO2XHsz7Gr068d7OtrrD7Q'
    b'N+PEvuPYVl87rNozbsa2b1umrdqOVc0cF9RXV+qj3VjQdmxcffqnrzSHGK+Wuu1Z24a9cSfN'
    b'v8Icx3RqjtH5zTz2O8a0WRzL/qRzuZC2Oc21yulYjQPjLAWf/uafzJxF3yo/OIY41rTbN0d1'
    b'9ltXr63MXCuNtqm1dmygPwtUcz7Xj8dF7oPudpdzvcPh+W/8h+1TgAdc+8/nLGfzfOoNL9na'
    b'L3z/xVu9gnHPH/L6cc5y0eHfvOsfD//L3e+69Zwrv2z05DMvWn7qpS87PPCv/377nsATrrzF'
    b'dgF92xt+yDb+/e58pzOxbz38/XUXbd/H4DsRfD+C9l98yBVbPq7e3ea//JtXHX7xpX9+eMKL'
    b'/3zLt+W84mzOj7zRh2watGdmsLX9joffu/i/Lrp8u5h/5GXv3/zl7Haev7bPu9mtD99x+b+4'
    b'fv5nxgLWES3ljh91++0Xq959Jv5Hr730ZKyvPvM64S9ueG4bzqDe/TjRXzonY7VpN5+29tVP'
    b'G1iDucA82oyfNuuTX0nSoFObmKRoq532Koft2mD2wbyr/J2Hvtpotw9TL+iKfTT1Xai9vjnW'
    b'qm2M8Suqpd08x6jW2EnHpG3fuvHVgr69MWhbSvWNqbYxtXUObe9p6Ncnji3VYae9l99iDnXT'
    b'Tlu7te2y0lNqA+21ATrrmWuvLdqmXfTf4AZn31fY0047cRSxj8ZavW3tom1Szcp/LEbf1NC3'
    b'CDEWaRtWftcKOl7bezlnPlnp1Zpv9mXVvxDMBdS2zVWftlnD1K98QJvSvHu5LfZBrX2YY6ox'
    b'N+ibce2LMXvMXM1xzFcc+zR97c5rNT9t6qxboL6CzQL1t60f9vTVwMqHzSK08fexNZm5wRyt'
    b'1VHT1wf6a6NvAX1qwRqqpVZfTfPPsVbbaOT5X3o++8XnJ77/8u3i9ev/6S2HO97+9luO1/3d'
    b'3x1edOObHu7yT+/YbrOBq6666vAJ//yOw+suv9Hh2X/2ss3G2G6HpZwd7/ovWG/jXXfZNt7X'
    b'vfvNJ+NR7nCm/Z3nbufhFh1qPknYOJf2bpdfsl3sP+maiw7P+9s3bDbGp/2Gc+9dd07k5xYh'
    b'820533k2JxrrMzPY2i9+6zu22u34ob/528MbLrr4zDq88/ARH/7hm00tnOTY/j8cfvi1bzi8'
    b'8OWvONc7HJ7+kj89vP2SSw8fcc3/c85yONz5yiu2bfiV9196eNbrrv8p21e+6c2HN5x5IbRi'
    b'ris4tmzbsdBho+hX0/iZS2pv7hlrUeN4xf7J0dkAne2bpEm1TaaPeuran3noHwPtnsaxxfZK'
    b'j81c+p2HD1z71tVaC311k9ppUzrmKqc6aO5qoPFFfVE7Y1Y51ehre5UbtBtftDXf1Ftqm+Pb'
    b'h+YozVO9+WoD9VNr3TZwfKhtjLkbA43XDyu9NaifVA/mMZc269rLzNM+20j7/e8//x0aNeZf'
    b'4ZiyGl+/9umHmWOCTbttyiqXVN96Qo5jc8Pm2jgm5Vj+vfZk+jqPY77TMPZC8uC3CO0Z27jZ'
    b'rk3MMelx1nHVGjdzzrnMWG32YZ7fS/PRnpqZq371M4ecNp40t+2O2zyOWdQ0xjb1qg3tm0Nq'
    b'bwzMsVrv5Zy26qwFP8eHOmP0nUa1lo5XzA/WoNa6Pmgux5htNNXNfnXSUcyl7imvfv128cpF'
    b'7Mdf+aGbndjfft/Z4/sTbnLF1v+U2956u02J25XMTT1foGA7l3rDsYx5yqv/9gPG45797770'
    b'msN93/EPJ7foWDbOJbziumu3mgt7c54dD7+DnrXxM7Hffdl7D/d9+1vO5bo+7+TMDM+1zs5X'
    b'yPOSw8XbXG90+WXnjePYW3v7/wznYp2TfjDvRx3Oftn7Je9+z1abp+Pe4FycOeprG7yOqI66'
    b'sdMO+KzV2dYH+vRr015tWdmxnfxKkphM6t9LXs1KP2s19Gfs1Ah2C0w/1Df99qkvJEcvBCzm'
    b'bfy0lWmnD+abbTCf1AfTD3vx2Glba2sNxmCbRZ9gE9v1l2qLesfsgwao1Wijb4HaobGtoRqK'
    b'/eYDfRS1lPqkxwfoM76YD8xjbaFfn22wLvjLSruydQxw7WHWq1wyNdS266NNmW39jakP6MvU'
    b'ttbe2Am+6mfBN/PVVvRPZry5q6/P2nGqtW3OVW7RB+axPX2T5lNPoW8Bbb2on76yvhA5X0Pf'
    b'8cQ2Pkv9YEy11ezFgXFzOyiAr33rFasxKdpnmzWhqCszl/2Vfdpqr4+249i21Nb29E/2bM0F'
    b'M0fXW6ppvDGtW9Dpg9pql6mduubrHGi7v0SdOaqf1NbHgzF7tdCnfGDm8+fx9+87u7a3PJy5'
    b'oD43J/4o2esuv+Hhk6951+Z7wLX/z3ab0h++7Z3Lx7Bs453Ljev69vU6x/tXh7MvAD7ltrfZ'
    b'Xoz83kWXndyiwycSfEJxFrfgbH3LD73heXltg81Pvl1z8pOuZ/Oa8/qIts9fR+obn6nZblQd'
    b'53zO2t1C59Rt/gAy/4mWOd5qm1ePCzH3HGPmnTrzU2Zbf2k+dS3Gw3m3JEHbMPsmOUb9tslj'
    b'bMfUbhtW8bXJnq55tGuDPXvbK/BT3MkzJ6ixT61N6msbOLFUC+q07+XTTqlNtJlPZsyeH6bP'
    b'dscRfSuNOc1ngerbtlarDdRB/a2Bdu0U7dI2VAfG2m4fqndca9CnjlK/OSfNRWm8drAP6hpr'
    b'n3qesJqLtn1jJtrVqp/jrJh6oW0BNVNbzcoGsw+dT9uT5kRnLbTtnzYO6G9Ma8DXfjVtq9vT'
    b'd+z6p91+7SubWm3NCTNmzmOlp1RnsX8axFL28qzGFNutZw5zC+15AQlqqlXD48s2NX10lJkH'
    b'pm/W4ljVTw19/WBbvbbi80/zzVqMba7mM0+ZfkE39TOWvjrYywUzFtSYp9ifObVfiF7wabd2'
    b'vxfzU1ukOY6B7qMvPfti5K8P1383gdjnX37l4Tbv+aftV4W4PellN7zi8Fevfs2Jn1hK+1t9'
    b'8i78B243/o+59Ow4f3PR2Yv3G5+b5guuuf4FC7WQD9tfn7uh5f4fevlWLzk3HBf68HvvOfui'
    b'xLzOx1mdna+cHdOxqT/momu324r+6tVn/3q02vNzXZ/hxHauFsd3ja++kZ9YnNWeHfPsuHs5'
    b'Cr76r89x/vyFdvtgfK8ZsfniVD+1+a2hMdb6LaJm+4RBEXiCUyD2ZyKgP/3aptaNWeG4xphH'
    b'OsYe+NTJ7IO5HRPanmPom37zdCdRtB+jfttewDkO7OXSRl39qq129gX7zAO1rWJpq2msGmzN'
    b'UfvU67MGY82jrRpQJ9VazzHta6tv5u8TvblEbfNQ1Ip2dWDbnMbMoqb1zDW17QPtxhyr1YLt'
    b'WddfpnY+WdpuDlnpYLbNPe0tK41Mu3OZ8zFH7capN5c6/ULfk3o16mY9WY0N5Jzj0W7fWGvP'
    b'L4Bu+qmnpjX+aYOZB6qzwNRQGBM7ZbVd+rBRQ/2gvUwNNEdRW9/UuTarvGBu6qnRXtTbFuNb'
    b'SnM1nmJ/xRzLfmvzSNv6qY2pf6JWjTHGT7/9STUTc7WgbS5jV33b6tWsqE9ti7RN3jm+x7jY'
    b'tj5vTlvrLM0Fj7n9RxwefnjP9i76y9/+zvPyPPeNb97aX/qGv95uy3nBJTc6icdP3esW7ecN'
    b'eAbHo370bW91+JyLzo33tndudn9z6P6XXZ/3kz/ilmf6Z3PTpzzvNa8/vOmKq7b5Pvp2tzrR'
    b'3vEWNzvc8qJz8z43uH+3+QGXX/8i6FNu/eFn+tdfP25zHTjWJ93qlofv/6gPP9zy/dce/vCG'
    b'N9l823hbC122a/v/bG38xLnyy01s+8Nv8N7DQz7yVue8Z7nlRee/+SbmMwc4TvvgNk27tE8b'
    b'fc9JFM+lalcxFjG22qJ9+4RhshfUAWyjrV2Y9CpPJ3psHH2r3Kv42Z4FmrdoU9v8tI1rAXVq'
    b'QB+1cTJ9to9R7bG6uhX60K3GvND45pl4UbSXZ2U3T320m5/2zLuXa2rsm6O0X53txkPbq1iY'
    b'dkpttDsGrHSw0pTmMlbdLGKM+hXmFNraWq909tVA62pgakpzNQaaq7FTO9v2p67zsAg6basY'
    b'aL6poe9JXKo392TazAXG1zZZ2Vd6bL1I9yIC6ENj1IE1TO0cZ/bF5wrjfQLsOEC7OTpOdTDH'
    b'qn+lB+wzboWx1Z62Zqv5aaPu2K2nTYwR+3MtsU0t0NcHqxhYxa4wX2NnX+hX0zZMvZqpnXpq'
    b'i359oH5SnfGw0tdv277HQG3Ow1K7OtpS/0l9zv3Nl77v5GdOz/606odtF9/X3eDiwxOuuPnh'
    b'L1/1qk1n3tf/3f/YfgL1RhdfvF2oP/fVrz1vLKDfAs6B8bafcb392Z9VffZt/+Xh4WdeLFx3'
    b'0Q1OxkPrC4EHXPfes/oz8/umy99/uPiKK87dDnSWf3zrWw8/e/lV23yZt9rH3+hwuMs/n33x'
    b'cWbmW/3c17zuXM5rzujObjM5L7niyi2ncwRbT7v5jbY1efaZ8tjL3ne4+nDt4bU3vPHhp1/9'
    b't+cU5fx13jiXE5trWLDza1D8etKHnvH97xczt7M/N8v8Pub9Z7/fQNR5eY+ArtqOqQ+bmmrB'
    b'eU47TJt9r9M6VulYamhTTj5hoECTaJ+J1YqDT92K5mt+bfXJjKHtg7M6oG8RY8pK0z56+3NO'
    b'1c4a0PukJ1O3l7PzdA7WxT6+6rRJfdqbi7ZlFae9T4iCD5qXtn3btTeGAvr1lWlrfOtpn3Hd'
    b'H/qo1YNzoJ77D5v+Fu1qWkNttok7DXOrbc76pm6eDBpX3YpqyyrO/oyZ/epo67e9yjtzQOOM'
    b'mbrmmnlsUzfedvW0vfCC6uZ5p5q2C333C3GOZS7GMp8+tUBb9GmzbRy1peizLbY93htLPR83'
    b'6JvL2m2pf67VheKczNO+bWhfHfUcD/vcDuu2C/2Opb/jgWOW9ptD9nJP5lhgrLYZq2/GzHo1'
    b'PnVLNUDffVrUtoA1oAFszV/NMeZ8ZmyPv2odF7RNnzErqpHmB/s9xkQdtQXMu5fLtnCRfN2Z'
    b'bby+XLyVF115s8N3fgh/F+HPN92Mfcm524b+7xteeXjr2962tQGdmo5v+7zxzrxAcMyz4/3L'
    b'w9Nfcv3fYSDvY6+5dLs4R/e6MzUvKL7tpa/YbgfqdvzWn71s++nSl934pif5n3bVLQ7ffNNb'
    b'n7y4QP/WMy8uHvvey87kZB4Xb/WW80//csvJi6jrt+GizPfMupyZL3Pgbzg8+uWvPrz97W/f'
    b'8gLqs+Ocv+3YXAXzdt6gll9PYi6vveEV523Db93k3N+LOKNDq95c9q2hOnFcfZ2HfW3VTmpr'
    b'rr1z4WSOBRfd5z73uY4FxciDjmSrwQHNyqfdxM1z3mA7/dr3bHvsae3LKgca5kq9yrNqQ8eY'
    b'OtGuBvb07bfdPsx40ea612a71H5aTttQbetS2/RPX9d+j1V+wTdzzvas67NdtAv9uaatpXn0'
    b'2y61N1dtsw0r33y8UjtX0I7WNthvfpgaaR5hbNBmbd5ZS3NVI9XC1LdNcftnG406c9IuK782'
    b'qWZlF3OA9sZC22C/etDu42OFcfWv+qDWNtCfeljlW+WBlc/42ZbqVhr7Pbb3tBPsezHmA+P1'
    b'QbWgBsxlG9w39YH9WeuD9mcsrGzQMaG6ydRQuzaCZnWMzT4x2GYsaGt/z1dWcXBanr2cczuM'
    b'Py2HupUfqoH6YOpl5gTz1K5tzr8+WcVNmxj3H66+y+FB7/yHwzdccpPDn/zlKzfbjAX1MO1T'
    b'r7Y6qW8VW1Y5xTjb7cPMab/26mHPDvWt2hPszUObteYP0H3GP12yveDZiwVzN0fR17pg45jp'
    b'+Q6mDmaeVT4wh6hp7vN+JWm2ZwJZ+ejPAQBb7WykNnWNBdu1oWle280j9a1yCTYWfMZXS7v5'
    b'YParl/nkBCvdHFuwTx9rB3NcddRqtKExl6X25rLIqi/GNidUU1bjuva0G2e/NsfB5jaCGvML'
    b'dvXWMHWAb8/vfmRMfVNj3xxlaj3+YaWHlX/mwdf5WBqrf+arz/noA30wffZZF9em44LtlU2t'
    b'+5C241ljq56ivlrKzKu9PmvQt0fziblqa3+Vzxjo+BPzUKs7LW9pbn3T1mMXVmspq1jbc35S'
    b'H6zaM952tUCfMVfHFrVt52ANxDhfdMZSzAfY65taijppG8x3TGvO+tq3Xf/E/Ks8oG3mwa8G'
    b'6qt2z974laY++/M4A33qoW2g3zz6bZtTu1TL/lBH3f2txvy2BRt9/bZFu+hXU79t18J2fca1'
    b'7XztCxoLPv3U5oXmoqZ/61vdanuxwK8l8WKheajVGle/qBNju00tMGNA39S13VIbzPXBbhvU'
    b'rWgesD1roU/uaRd8HRvQfvj7rjn76cVijsY0zrbj7I0HjQNzN0bbaoza5jjm0W7dGDk54nrw'
    b'IaTfCczgDupgaqjrb992/ZOZpzH6bNcHsy/GSfvddjCvbTEnde20p6392qF5rNXb1g7Ge1JU'
    b'B9agz30ntFvwm8MY0V7qFzWzFmNmLNuwp60d22pcwI62fvozXtTWNtvtg7aZV6ZtNXZttLHP'
    b'E1/H0FZmDvtojQX3aW3QnI4Natwf1emjpnjcaZ9Ubx7q5mzbfNXUD/Q7nv5pm3Gdy0Stjw9K'
    b'xzGfNvWrXKJvaro/pPmqp12d/tqAvnH6tU27bcrcx7MG2hbjjKFWM5m2ao2HY7mqA49T7OoB'
    b'zV4+a4+tFWp6fjSPdAygXT3QNs7SPGpbT42oETUWsY+/eYzXLjNen7Y+Bia1TZ3tzsU+pWvV'
    b'8UG7rPzmgVXbPpiPeuaGagv2lV6O+fbGd25tA8ejxzNoty7Gl+YSNI4D1tN2r5t/2PZl59+8'
    b'/MqTvM3VOGMpK6022fNNHcx8HCMTx7ZoE3NQq7Ets41/jm1trH6w3/Ol+vJ/XH2XwyOuvtvJ'
    b'H4MD/tL2Xf/5nYfXX36j7Rat5m8O+hb7wJqop6zGXdmkMTPeMfbywmm5LSdfeiagQT1pi22D'
    b'wRhttTfnzE1frTVgd/GkftDXsWCOTb+1Om0W7aCtbU+CjbdubJla4y3dRsfzgYQdW080otZY'
    b'0Gbdfed4YO0DApqPdvvW5pGpgc51L9de3+0GbdWar2jTr802vuawr6319Km33bxFTWNbG2N8'
    b'92/RX9pvfu21OdbUTPSDeso8XoR2dfVpA3XgcV2/aKOoqb1UY7t9itRvEfvqqdleSu3Mm0K/'
    b'Wmi+iWunZhXjOPpg5uyY+Ch9XEB9FPo9ppofqrOupnZxDcQcoN046Rws1Upjpt2cjQVtgF2d'
    b'2GY/6FdjrUab+wz0qS3YSvMAfouYRxvtxlU7+0C/RQ2Fdfa4VQvNow+Mh8ZQetw2ftK1glVO'
    b'MH7mq532qm8ea6netn1AbxHb1a/81NPX/rG2ZVKd9DHcWONnm/jm0D/zwtTaNt+Dr3nn9o73'
    b'H73xLbs51M7Y0nFWfsC+yrWK7bHXfDNH2+ZoLttSvTXFvLQ9v822OuuCzdq/mP2od7zp8KQb'
    b'XnvyF6j5S9vwG5ed/UHY5rDdscQ+RT8Y0379pTZ11bbGbrs1tK2u4D//GekcDihtz6Q+IHoQ'
    b'FGPV6aeeWtmzOy9zWkNjtPdkh405oKPd8bVN6reujrbF/h7mUEPffMzTvjprcIzOf5XHPu3G'
    b'QzXVwuxDxwLryRxHmpvi/gdttuf2W/QL7dptO1eoHrTLqm8xdo4jjENfvxrosea2NhbtPB4d'
    b'szrA7jZZqrFtjd965qJvjmOog5lHe8erplq2sbmAfm3TZ9889Cn6bFPMD9r0TxrXfKDePnXb'
    b'0rxtw8rXPBM06vp4MKaxM5/2gq3HlHQcmf1CHv3k61irOP1uA31tHbt5oLmqF2MbN23UjZEZ'
    b'B/T7mK2N2iIzLz5sXRNzWQr95jO+Wv2tm2euv2BTS3EbxMeFuZpzxq4wXsw99VM3czqOdXHb'
    b'jKHdcVpA38QcjdV2IVS3iiHXKrdafbOW5mSbYW8c6wv1z/3u8Q3Ncc873mH7GwwvuvFND6//'
    b'u7/b5jG1lOaafWlecD4rrT5hTNGn33rmm35raIy03RgLfsdgHTyGbau3bj4xnu8mfPYr/3b7'
    b'QjWfJghtvgj9jHNfBifval6lYwJ696/jWaTaWdenHZpDH301ttXA1Nu+6F73utd173rXuzZB'
    b'F88EipsM9E9Wem3S/LZnX2zrc2djZ3Hpu8hQPdBXr62ol6lZxWkzb3NoE3XOW1vjtJfpa/+D'
    b'iQNsxp1mty8zBqYetHkM7e0Tdc2hH6YPtMH0FTUrv3GnxXes6hs3291WaFudqIceE8Y41myX'
    b'5sR/LGalpbifxG1oPmNnvvZnnH77RRs12J42WeWAY1p9oL++Vb4y4+3P9h6rMVZx1dmeupXd'
    b'/kor2oC2x1k1UJtt9qfHhnmwr+JFHag5djxB7aBvpVtxTD99lJmn/fpnm7K3Hvpsr8ZoDNgH'
    b'/Y2rfqUtM2fzgLlXfn1t1wbGQe1QX2nOyRxP5jj6944haqit9qnzmMYG2kGbGCszB+zFqLVN'
    b'3Xbjq4VjOeA0fVnFVjvjqoPGW9u2L3t2qd8+Ze8xZRuM1V706TdmciwHNG7mad94c1nPGNrH'
    b'jltqmX2o1mOu+WyrBfXFvNhne2onU2M8NV96vlaBjinWDvjU2hbbM485mse2Bw6s8hlHuweZ'
    b'NjDOvtB3HGuYWvOBduuVXducT2lcY6C5qxP1Kx9w0OCr3b5xtOufOcD81mjcpqm3T60eZozj'
    b'YzNGm0Vd9WzTHuZSD83dNtg/jepsUzMX52NOH6gUx6S2TZl0PtW4PcauqM9x2l7FaVcrat0m'
    b'xjePoDG2udtufotx0Bpf0Tft5rBdTtN2PJkx+NRSr+KoLfiPHYsrVvlK56TPeVBsU1drWztl'
    b'Pq6kbTF/Udea0nnAag2MEWOlYzFP0U5tsQ/N0TlMv+O1QHPWJjMf9cyxF9fHSrX4ptb+ymcs'
    b'6DOPue0LbYt9sW1e+rZX6O84sw3a2m8NtImhTIzV36JPXWtpv3FQ34zr8QbEATp92sQcjgPN'
    b'69iUvVjQz2Nmxvt4NZd2aF591M0Bjd2j8XMsbc6vfvu2wT7ot0y0k1t/a9vkaS5tYB9o99yz'
    b'N75t/WJO6rarAfOpAfuUbg+oBzWgbWqF9lwbYq1ti3nB49Z6aotx5gTHmNTWOOncCv0bXHvt'
    b'te/uDpIGzA1qoraBPvo5aG2zTw36RJ+6xpYZ39rYGVOffdtqqW1PPWibVPPB0PFmTU7zdkza'
    b'2HvC1Nb2XvweakG9uexXA+3TntrOccbOMWyDuRpDG785pxa0QWNBHZrGAjnng5RCu4+VY9sD'
    b'03ZMY+04UH3tzrfgs9iXxs38bA919doKfWM7ftv4WJPG2rY2x0rTXEW7udXPGtRicyxrWM2v'
    b'Be3crxRxbRxHOoZgs9ifGvLphxkj2nr8aWvOzq1tdbPftn1QB42Tmas5mqe2PfvMI9VPVmNq'
    b'066uNRzL23wzhzS/1Na6sXPfgRpLY9Vrg6mjLY1tjBhrjHVzUWa/OsrUSO3WpblWrHxds2Iu'
    b'5yO2sfexRV/t9NHGVtSJfW2eI7Cbp7Xa5oDa/t9Kzl3X0isrowZXlY1cFkZIzkgJiZBA4hFQ'
    b'R6glIqKOEbwGCUIQkdFJQ9wSECMR8wAgIiJfq+V2uS4uxB5HHmbwef3nFENamrdvzrX+yz5V'
    b'28e2Ov2ugsZca/g7/75eztyetdZcgu8MfVdzxRnmW8dvbe9/e8x3nkusib66xmJP69vnubBC'
    b'7H0UZzQH5NRv7Pt39R6pBezW9T2bMdQH5xRyvS5wT/X67oeeLwz/9ejRox+IQKExeBh1aqpb'
    b'fXv0T6htD+wDs1aNbJ2Yh+KZzEG1vgTWltbsAWeY0zduz9agPuz+xKd9168Oa12/eth+6IxT'
    b'zllymtnVXp+BPacPSvViTQvVa/eDg7XeXnLErt2P2AWr8dzbB86ErRvvh7Q90ti+zjvVnWMN'
    b'u2fYHLHv/UN6bBdYdxGbl6v7haY66tyb0wxxD5f7WoO+B+r3nhfPB2hLY+ehZzl78Rzgvuba'
    b'03lgDUtftUJsjro0D+3Fd1XDHvtsOkf9xvpr9UFf/drWWcRawDZX61Kn3xwQ4xtrwRn2yNU8'
    b'867O0j/lOgOMT7Rfne8ZYOtL37HqPavY315QUy1zNr+zBJ8aC993Cog5n2dc2msMzmrtiq27'
    b'J3Tu+sZYz9xce94W9NtzFTMfWjdXu/ra9bvsa7+rUHcZQ3Xk2qvPUg+tO9NcaQ7N3n9Qs+80'
    b'EO8MqI5FzLugz9Iv9mvV+TloXrszxF7BV7t56Cx7+/6aUwP1vXfNQXvcC5wH9p5A46LHxReG'
    b'f+GA+9AcjIU2w2kzNdUBvjHWenO7mkcPztavnmtYrfjSwElTLXQuVHfyRX2tGnNXUFfjtUD3'
    b'aU4N1lypFt8Y6re+OqDubLWA3Zq+c/zACb41lmfH1zpHbdl86/3gbK85lvH/F3uhPjR2tvtZ'
    b'a4zGBWtL+++DXmefuC9vzfP53Npz+vnQurE5Z+n354WzWWqgz7BsDPZ6Vuk+7UPjvur7OQN8'
    b'l7FWX5yhpb5+7xl7tcd3H/S1vQZAf9p/z6Xf+fgsqaa+sYszWIfWxbn2S7XV2GvOWK0+tK9Q'
    b'915W077OA3XNraY4Y+c3hp0np3sHnSE7E6uuM07sPOOHeq1hO8N3pr1qqpPqxGcj+L7PzoFq'
    b'mmOd5rbWObDv+tXnByv6nbfXb8+pX81C3lr1izPVdu/uaR1aY5mDvnPWxL4rugfnqB576ic2'
    b'132b61xndNZqpFpYvTFWnTmwD7gv6tT2/VCrra41VueU6k6svjjXz422Nedas+6zAmz15tWK'
    b'da2YU9+aPH78+J1fff369d/idIiN65+GNH+qn+BCAT2zwX2EWh+stau9fDGAmgvIn/zqXHsG'
    b'0V8r7XWP074utfpdp2sxltO9WU69xGIdmOda1KnFMtMYtqYv9a33XPjOdBkD1g+IOeuds+xc'
    b'Y3NgDawtJy1259hrTjbuPrXo1JoHZ5s7aaAa0O9zddZ9+BmV3e8hi37XCfL2SGe5ij2s02xz'
    b'XHMty1lY8s7pEv2tOUuc2/mr8f6bq86a5znde+e7wJwQO1db/ZVWjecgb46z7ExtQdu8Pvli'
    b'3PrV3P1zwrOc9PV35u65rFb97tsakDOvL/rt8f6C+dNq3TnOt969xLoaqN/+05yd6SzyWzPW'
    b'Oq/XWKxL453R/bTiZ4SFnkVO33dmNaWx851LzV4xZ1/r5FywfYVaP09CvPeNXnVYlvNO+zG3'
    b'12Ad2iv2QevMcI55teaM7WnO+w/Vs9TvWTbvvSBmHtb5WmlNTnv1XGCP9fZA6/U9T7F+otrt'
    b'A66Vmc7AuqD7976AecA/5e1vHarFZza2GueYu/vC8OzZs3979erVV/3Xkq6gftocGutrV+8L'
    b'6SFP86C5nYU1hp2zdWlv6Rwtub4g22tsXRpTv9K0dlqFGK2+cR+080AL1EC9VCNqYeuN8U/9'
    b'Yq0fBmf3rCzinvEKz67m1A/Ol9Zg93KO8VV9IbdaOOX0sV3V1mfBzjKG9jwEOlZnt19/Y2kd'
    b'37V0BlRr3hlgnuUPdWsnfbG+tfZvjVznutwbnx5jOM035/ttHxba4x7VbF2Y53te3fYAObTV'
    b'uMi5rEl1Uh9O/Wqw5K9iaV1N5+lrvZdd6rD92UUs+C5QD9VBa+6hL+bNse99s30Gm2+Ps8xJ'
    b'a/dZ+k69S3t6P4H+vi+ys7fXuhpta8ZgvDhvfai/UNu9Qb9n9R2htuc49QJ9zCDnOeqX1qEa'
    b'c1e97NHzodl50Dla9Ys5rPrV2VvNCWsnDbku77mY9/1yry717RN7fA6sfVfxrUFnmlMDrTPL'
    b'GKtvnX2BvL41ddQ8E/6J9tS6n76cZrZu3t5Crn1eY/vBnHpRZ854LXP5fsD3hLs78/Lly589'
    b'efLkBwcQ4t1M3zwLnVpr0Fxxn758zgEtdJbWJfo7Y3uBnHmoDnyI1WnVNr81bNdqq4fWa+FK'
    b'W1bfPcGcM4CcS/RPuu7fOn5nEFv3JQbn2O+ytzPqwym2X6pxrtZa9fXFHxYnOsfZUl8NkLe2'
    b'fvci3jNqRU21hXyXufu0vudinpz5/QEq6KDaxXlQjXt0r/7As0eM1ZfVqzHf+2yv+t1byPlz'
    b'yTli3NwVaNzDmdurBrTWW8P3ebVfyF/10wfWq4Xee7CvtFf09x2h37MC1tml+Z7BXPv7HEEd'
    b'tc6xB6xB54Ixq+dXU21xnucF53RvaKxGfCbbVw1Yd5lTd+rF9nzSPqi+c/Cr697a9qz+RPdy'
    b'NXYWVNNa9/b98j4W8p0npzlQvZ9RIW9cPWwMq2eR6znb7xJrJz3gN4bGziKn35za9uijq7/Y'
    b'f9LD9pxqa0G/87d+0pSTxpx5rH2nXPtKNeCzaa5sPzTXPbTOIm6NfP/c2D0b4xuvrnNb29xe'
    b'G3V+u3D7nvAPdz8l37x582e35JvTbxkaM4DY3B6I2Jx+Nfr0cwOsc0DnsnpgF1Crj864lpr+'
    b'xsX8gu70B0gxh3WBvV6DWHcumJPu1Xn4WJasf5pVK8QsX8CeZ6HeJfidS+y87staLThr88Ac'
    b'+0DN6ZzUOsMewDfWX61xtfvcSq9RfWduXi2YB6/RvVqTU65QV8Os7g3uK6dzNMdyDnhGFue0'
    b'Dp0B3hfYOfp9fqvtvO2V+ie99c70/mLVWHf17GKsXh+MndNn6DJ2j605S06zd66zzBU1xX3b'
    b'o6+F+mp2FrSXerVYl73VPUR7sdIZLO+JGvvg1Muy15r5k18ttqhTo28ePB+0Zg9xZ2uhGrjS'
    b'aq2z/Gxtf+3iHEDD2U97FPLtK+TRt779xs1X73xniXNd5oB4f/6YW5zT2WCvUFcLndU8OMvc'
    b'aX6h7nKu+zm7y7q+FpoXZpIHas41BvftTLXGYC/61VbTmraznCPGvHOtqXWO+VrrarBes6sY'
    b't9ZeaA+5nQGbsxdOvvt5r09Q7372el+kGiBmOXtr4Gx9NdXie+92D33y330vePPtt9/+6d2O'
    b'X3755TfPnz//qb9lgG3u5kDsgXtT8FtrH75xf0BB94Puo+057DcP2+NZoPPtW5ylNQeNT71g'
    b'7erasNa8P+RY9hpbE+vQ+90+fXUnrHuO3kfruy94LhfYx4zmtPpizhmnevPVswe4j+wMUG/v'
    b'9pg79Ta3defsXK343rnHfXO21j5pbL2QY0/ztfbuPGh+dd5vINeZ4H7Wts8Ye+qHk6++fnUn'
    b'+nlAa49zfB7GsHFpDeus7rPXicZlXDZvH5BrDMbsY90l5jvTenWrOVlQ0/2gmtI8ft9BYnxj'
    b'cK5+MW/f6qqvVmtf8Xk5T3vSEru2z/dne6S1t9UJOSDPMtaCtaW90n6XqMP6/pprn+ijqS/m'
    b'2yPW2lsdeWeZ31zj4vNR42dEzFmvhVr7sF2CZj+D+lp17Vvfd8iY1XNjneE6oa7zQN/nCs7o'
    b'3OKs+mqxfe/ttaYt1YExOnvAeH1pj7R3/V4z2F8rnbn3X9RU21zz0F59dVvbOZzB3J6hWmtY'
    b'59i7dXPFuFr83rtqtGj57cKLFy9+yveE7/8EfPPmzU9uxV++//7732/awfXFnHrwAD0IWO8c'
    b'lz8AYOuFuPXTLCDvMqcVe5fOuOrda3NWZ+LvHp3TWveU7RXnbg/30BpQdxlbA/Vw0mj3hfKH'
    b'iD1g3/ZqO1dOOTjlwD27+t4AvSxrnF2tedCqF/PQmjOKOVfn71xjc9hq77Nyipvbd3I5zfXc'
    b'+rBzvcdrvbfi/uSc2zlgbd+pWmhvZ+w8Oc0r1u1H4x7UzDdnT2dbV79ndq4Qr0brAjVb335o'
    b'D+s0o6vPzR61oK45MA/UnAPmtYDPvULbPtGnhn+qleqs13YP9z7hHNCecrXOMgf0cA/aWx96'
    b'jwo6QU/sMucqxn129q22OHdpj2fdufbWnjTNqSvWsNLYfiBvf3PFGHt6z+wDfJ8VqBfyG4M5'
    b'LIt8tRuDvZsvnSV9V6hX4xz1p/jqfXeuc+wtrTkT8I2x7LE5cG9jWN931udgvbrT2XouFzOc'
    b'R9y6M8zpF+Lm1Ak1zynOZ+08MNfZahuDMfS5qVfHGQp5lzpn+U7bi99lnzVYrfP0YXu++z7w'
    b'y9evX/+E+PsT3r49/Pc333zzY75NsE44uMMdLL3xrZkr5nrxWPuId5a69UUdtL+60/zW8Z1d'
    b'uy8VEJtH0yX41NtrbA3a1/4T9up7D423Dp3ZHL2NfXGbc5mD+u3Dr0WnX7qPqzrnk7MOfuh6'
    b'bi3gqwFi9yo9n6u4L7S2OuI9o5jrdXXuotY+49N8Z6qpXvRPOe9RZwL11Zy0u1c55e/rPc0i'
    b'x3Mjv9ra7atezYnqsO5l7Jn0zasBNetXA9sHxD3fxs5r3tjnsXFp31rpNW9NyLPUrYWttwbU'
    b'91muBjyDFri29rkXVt/l5xzfPug8MLZPH5jhbMCacy7gq6sPWnBuc9Ael+h3P3LOAuPtJafu'
    b'qqczVwPEzV/Nqd+YtfeReuPSfvA5QvOl+xX36LugZm01pc+4Vuy/onueoIamcxtr0TnHunHz'
    b'+n3nYXvBnFhjUau2rE7saY5zEHsfZefag63fveRUF3M+T2LfP6Gurnn8PSe97qG2PerJuVa7'
    b'+wC5K7xnoHWG86T+9jCHupqdpV/UN//uu+++w7919Pz58x8/e/bs7oLf/eCDD+6KcPvC8B+P'
    b'Hj36jadPn/7+7RvF98PhtEEtWvyrw6kDtfpSzYnOA+O+JNawLHPbI9VXqw7rfGkd7CuN1ZrD'
    b'ru8M8515lTvF+uahvrQX6jsHOuu+/cH4ql+2x/tr78m65JSD5ve5da/uqdVHJ+ZAjWcCtdZO'
    b'Gi3UF86yWnKdDaczF2JWzy/VVmP+lAN8a7XWGkN9z6tmdZ3ZnH415hbv09acc7qPG2+v8fa6'
    b'T3MbV9N6bVmNdXObh86T9tVXK+1tHtoHvX4g3x5r5PoczDduH5izTj+o0zpLdk5x1kOgc4Fn'
    b'uW8v9dWYax7fa4HeFxZsz2JdzclKfVAD9/VsbM+izvp9vfpbb95a/dJctbJ9xlfn73vVM7BE'
    b'f3PGV9fk6t6rk50BG580QO6U59rM9wxwNed0LVpqfV/NW9OaX7u5fg5a2zPI9ruXkLd2Omdp'
    b'jF/tXsPOwq/G/PbD1rSAvz3E28/yDEXt6T6S19fKzur1ba3zmufLwocffvjOV1999VdffPHF'
    b'33yX/r9fGOD2peGfb98qfve99977bb9FdSjsAYHcqW4ea15LnguoZq1rZ4g1bwQW6gMxbD80'
    b'1x7z9p44nYdFz+655zn1No/t9UjrV9DXHtj5YnylB/s2lsZ7D+2rvrm1ZePVnOYu5rwnxH4L'
    b'Jwb89hqr17dWTjo12uZA7amO7WfP2pUtxtj6pbUT7WOPk9/3i9hVPF9r5Hw/yDkD1JjH9l0S'
    b'daU9sv7VeaqD5rCeoedmoTP2ftgH+tUCsWtp/j6Ne7l6llKtcdk67FmLcffH3x7r5qvVL+r2'
    b'3ejzb0/nNN9ca2vBGVJfzHk+eUi7c7f/xPZA+8h1lr7a2mq01YKx2r3X7bG2WmMxr3W/7gPm'
    b'wT2s41/pzZ9sNeatlY1XY6+WazE2d2J10lnWGm+POedp1Ym6zUNnFeLNifk+O2bri/5V7nQe'
    b'Z4IaOfVeacgxq38+tqYPjZu/8hdqnmF9+/RbB+vgOU6aUw2/VqhXD9vXvJb66R1qXD1fFm5/'
    b'/+c3C//42Wef/cld4Tv+9ymGTz755EevXr36+dOnT+/+C+niAVjGUh/Umuch22u/uatedb1g'
    b'QeMyv3pYXfNCrrG+fdK8bM6XGfygUHubvbFdcop3lhpWz2BOvzRW5zJXWnN/Me6HGczXsjq7'
    b'sbpiDo39q2utseh7PmKeDzoWeX1qWJ+fsRA31z4WaMEaqLnSa0/vsD55Y1ifeued4u0xVged'
    b'VX3vFajRh+o7g159NWu979WCc8QZXeZPWjCHbd/q9X1ftOadV1rrvN2nOMfaalbfmfWd4www'
    b'z1JrXc3+jPIz0dmwnwXrQOwyr277Fvdj+bzVes+tw84xvqrjk4Na8+zPsgbOUwf6jUWtfm1p'
    b'/7L5zmM17nmx7TVujzlj9Ve9+rJ9+1zaoxarrux8YzBHn3N9f4wBnT72NKt+6/hdYuze1lYD'
    b'vrNaOF0rWNdCZ3cGsTXP0bnWmu9c75Wgp968e7gWewCr3zzY23o11sFrATWdhW8eW/3q3pZq'
    b'PYuWmnVzPof2rd8YruaqMw/4pxnE1jhDe8AabD81z43vEnu9n/aa1wfm8Pd9fonw8uXLn3/6'
    b'6ad/eFcIP/gNg3z99dc/uzX/5q3+e8Rv3ry5y7NJX75TDB6oNSCmZh5ND9/YZV7rBcL2Quui'
    b'bs8D9kH37mz7nK1Gqu8e5tp3RWvqsXvm7mVcrLF6bn1r+tULOTjplmq01e38rUFz1XLm3de6'
    b'ua1p24ff+7j31HPY05n2dmbr5q2ZK9vjdcFD2sb2QK/Bevtkc/Z53o2r7zUBvjnPYk9ry5W2'
    b'9wHs7Rwt2OsC+9dun+g3B8S9F2AO65nqq6ntNamHPZfxzmI1V04597MXjGvLzul+9bXs0T/E'
    b'ob737YR7X81nbvvxWy+ddeV7VmOx5v6tgfHpWtTb637QOfXVArZ9xq2f9MWzw0lP3LOrlZ1p'
    b'vHNqxbj7S/u7f2e1T73a5gDfa21OS848VAdq936pubKA77m2333MWwPyLmkvEHfmifbj7wzx'
    b'jFd1YnOrqdUv5Ohpnzlj0W8N3x7r9QHfnuWqR/YcndO5rZvHmi+9n9bbI1v3eZrbGJxNjpq+'
    b'nHL2QPugPux+QNxrAud0NtjLbxVYt7/7//X+ZkEuvzDA8+fP/+k27F9vQ/7oyQ0228N6iPUL'
    b'OWrWsSe2Xx05+zoLmgP7jctqoHNc1J1ZbenD6Aww56oG6lfbvfYl2zp0Dhhrqye3M/T3WrT1'
    b'4RRL/cVae7sHi1jMwX37Q32pXlbX+G328HzNC7ku6Iw+Sy31/eDKzmDtPyEo5tVrmd8Z4t7N'
    b'gXqwdjo7a3XGxV7PIPbvnOZ79pM9nRWrD8as0ww1O0eNMagB9/b65KGZ0Jnusbn+ZZe+re+1'
    b'qznlWIv5nQ2d0druAda1nYft/bEXq0Ya0+P1dx44Q9/7oKZ1uK/31IetDtScOOlPdEZ7asX6'
    b'+tAzlubQ9L50WS/m10LP1jx+5xj77Far3fyeRaqD9mrtbc3z+t4Zs+pD7ebktAfW/InVXlmX'
    b'Z13UXj3LnqGxdWhf60VNMXc6G7mdKTsH1Hkd5sBcrxGw9mnNr070e+bq2+c8IGceVtuenvOk'
    b'0Uo1+GDsOYm3z31ga9Xr7zVbd4Z1Y0FHjn8Fif8b0o3bd4Wvf/T5559//98sLPd+YYAXL178'
    b'523Dv7gN/q3b0N95/Pjx3e78xsGDXVnA3/jEVU8vklwvXo032D7zsP3a1QFa51PrHo23b2Np'
    b'bzX4u1et1wNa6Bz9nlHtlUZbH+wD9jYP1RvD1dlX19lir2fYnlPO2HujprZ1MAed0/xpFqxf'
    b'jdQH9uYPTK8Pdk592D3MQ/3TdWHNwWrwa63bD+2H1XQGmMeaNyfWinFr7V0LzbF2L/PWpNqr'
    b'PVyij97nR87+ajtTyJWtnzhp9rysPUN9930oB/tsW1uoVdt7om1d372F+PTendje07ydoeaU'
    b'F+teQ/XOtwbUqi+dqw72/izVyubW77WftKfrBvs6Q13tqS6drTXXPIt8r9+Zor559NvXZQ1r'
    b'jIX60Dq2mHOf6lZfn5pLWgdre86y/WrMqzfvOaXzWkPf2cadvdds3pmtQ/vImQf7WdsP5tWI'
    b'+fZc6YzVSmvtAWLPUc1pj54Xquue9lgDzw3kXNI5tdbk1AfMv9Ib1wfP1DoQ47taN8byf0Pl'
    b'NwpPnjx5c/t7/t/d1h98+eWX/34nvuBXPv744+/ch/noo49+7dGjR3952+SPb5v9Ol8ausAL'
    b'4EDllIPm8aEXBfrYPjhorZblP+0wd8JZrZ9yzrEG26PG/M7Z/Pa0tzRvr9gHfiCMqe0/8XHW'
    b'fTP3RSztOfng/PWh+fuwz9nb97Zz0HE9fRdg3yMgVlO7bJ8a86eeBQ1n0l/IMc8zGBdru69x'
    b'n6M1WP19s0+1++js9hk7s+8l+X0enSPtc5YWtsc6rB7reyH2SfvBXtD2GbJO57PuntjOqo9l'
    b'hmcjtre1zrDeOfhwFcv2rF7ck7q16qE1fazXAe2pVn3rZfPGVzPMwSnWF2LOqQ+rM14L2H1u'
    b'UC01IWYt23fF1h/SL7u3Z9TXmtN6fWD9vl7ry+qhOfu0+huXrWH7THyHq5WNwTmgldWe+s05'
    b'pzM6G9T13dk+84Wavat9qA9O9wR7lXdW58OpxnKONX2vU601UAvbK/b1nDurc0r1izP7HBZn'
    b'd05z9jkLW1/q09OZ6qFnsV6tfnNgj5b/PgHf/13q7QvCL169evX333777Z8/e/bsmzvRvbzz'
    b'zv8AG+i5ARCdzkEAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
support_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'3klEQVR42mNgwAFso/5xAnEyEG8B4pdA/B+KX0LFQHKcDOQAoMZIIH6OZCguDFITSYrBzEA8'
    b'DdkQu+h//0s7//5fsPYPGBe1/wWLoVkE0sNMjAVTkDUGZP37f+H67/+/fv1Cweeu/P7vk45h'
    b'yRRChgcja7CP+ff/8k2E4U+e//r//BWqJVh8EozLcDYgfoSsuG7iX7hhbTP+wMVBbJh4addf'
    b'dAtAZrBhsyAKPQIbp0As2HPsN0bknr8G8dmqbX+wRXwUNgvWYEslIbmQoEIX33UEYsGG3Vgt'
    b'WIPNgkdEJEkwDs3/+//dB0gQgXyJRc0jbBYQZXhqzV94RO87jjWSwZgsC9Jr//7//AVi+PaD'
    b'v/87xOJWi82CT4QsuHYbEu7HzuF2ORS/wWbBUXyGe6f9gyfN/Na/hHx7GpsFtfg0OQKDI6H8'
    b'Lxg7xxMMzj5sFsgB8R9iI5sAdsGVm6fi0hSU8w+cNEEYxMZj+B0gZsRlAS8Q38SV4WBxAGLj'
    b'sSCVUIGnDMRP0DW6Jv773zztLxiD2DgMv0BskS0JxAdJDPcfQGxESsXDCMThQHyKSAuSGMgF'
    b'QM3SQOwPxBlAvB6L4bUM1AJAwwqQDP4L4jNQEyBZAEoITgzUBtBgagdiHmL1AADQseEZfuWC'
    b'VgAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
switch_slot_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAQlSURBVEhLxZVZTFxVGMf/986doYBQ'
    b'GpZCy0xBklJLRatxSSqYuFTjbiI0dUnc6hKNiT5Vo/HNGJ9ca/SxMVXDizGNS22jL2q01SYW'
    b'hQQpYQALhYK0bDPMzPX33RkQymB80n/yz5zvO+eebz+j/x2v6dv1H2nyird0ojqnWhXrVVcU'
    b'knd9SOHratRQaDon2MmD/RrZUKTSVxw5N7sKVfjKjKH+OqGZF3ZrXV/21N+oULR0UmMHUpq7'
    b'1eSwCg9WKbY7MPC2OqtSmq9h6WeUzlygspJyRfeFFbnU9pcipWTnuP546qzGxl15Lg449WqO'
    b'3yW3wVPx0aSmg3NEoWKtu8V5R79VEdoRvNyCPmObfBTmwKrRpTFDRMmc6JCW7iPa//KbeqgD'
    b'OZRVB1Hc6eJRDZ5swVvPU8TnN+MpnGB/djV68uay5yKCYVduY4va4uwdgAEqVPf5dt3whfO6'
    b'jjfHtPWoXY6+PSJ14bpHKM483rDGqNJpybUD7AdrKpgY0pmLC1XagUPpNVJTv/pqZzX1jRmg'
    b'fjc9qrpDngkGLspQpPj9qnwccTP8Dr4KLeR3oRX5M/gMHIUTz+mDwy1qxw+5s/LdDapnuYgg'
    b'3W6wBBhID6jbTjwGb4e7TA9icA/cCOtgGzwN945q4EpqZwasbtTG6rPIoIbLDExouJZlAbQw'
    b'o7AMXgQNP0KrgeFG2Feh2u6MKMU/YKkB/0+N2GVmmVSrHFbBbdDwEzS9YR+MjireRIFTWVV+'
    b'LBoA/jlNbOL3F/giHIAmW9ps/SucghPwEfhzkdb2EMFiW+bDYnjkrPha7eqIqrGnWhdOjWnw'
    b'QTphOqnZDxm+j0lHPR0yzIC1pTUfZohGKxWN+fItpZb2vHDe0PFLotp6jDb1GCByzCfyaU83'
    b'zS+TiijHZ7Dw1PEpZtAdqB02XFrU0mZD1wztvQraFOy8Q85XboGKR/iw1zRMZCETHLKZYG0f'
    b'28jbpLKO+FnZc7MMO7nLbaqHieosy6UpD+A+oc3DIYWez8mGJzm1jdw15SNhNBGVedsOE7xh'
    b'/mnFH75bkVPINovLEFgkHWY9AB/33iZncEC9O4bU1wpbFjiok63Dil99Sr0DnOvmOCmTX6y1'
    b'DQfl70C+PLgki9zd4FP51teHbI2HrSfVGdmoxsOkAs1yp6xCZzT0QLVi31PZE6iCd38BdmFK'
    b'qbkZTV52nyq6VuQMJOeVmMut84KuSnDRwmu6DFw+w3/GS3a5ySsiQPHsjM4N8creg3S+Ayjc'
    b'ZKFKPuGJMM/fs5ad0/TTJSrror0KpjTef6/KLX0BFgzs5OdLWy+ADXuyVyCXMOv94OMkde7R'
    b'se17dU2n6c5H4KH1P7ldlmyEgnxkK7jcgIwRx1+jIitWXgQRvK/fI5XadBVFtbDtu38Lpi49'
    b'P6r+H/aoYSan+y8h/QVfJltbo6DR9wAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
switch_slot_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAV/SURBVHhe7ZtrbBRVFMf/iwExFmot'
    b'7Spt7QMVVFSsSvEZMUYTPxgfQRM/GII0Ro0xGIIPElETDSYSUIkmvjD6CRODmhgTH2nFqrU+'
    b'QkEJINqibWVbSmltPwh9eM7MmeH2zuzuzM5Ou+3OL/n3nHs76c7979xz585uERERkdfEJIbG'
    b'JxibT+FaUtNtiHUZneFTQbrJTG2+JP1tpifJugE84D4cvuMoupaOYLiiFJWLz0C85BgSPd04'
    b'9OvpKGwsw8J9dGgYhlQUo3zVCE6spNerkj6DYpTtoeF+2IuOd6hpG5E1A6yBxxDbwAOW7qR0'
    b'o31vKaqepTRbRpTNQfGGf9FbL21X6Jg36Rh+3U5uz+AfQeHBJ9C+rQhnbfUyeIYGfyGF7XSl'
    b'rJdpEgh651enGzzDx/Cx0gxuAJ/8IPr2x1F1s3T54kzMf4jNC2rCXMy7WtK0qMcGMoBP+gg6'
    b'vitAUYF0ZQSbR/VhUxATxjBaKGlaqA4socCFcnwN4BNoQ+u6YRyvlK6UlOCca7xe8l7gutCP'
    b'ngPSTMoMnDJAV04LTbkdVv2gwtrVif1nGwd4YxVpm20AD54q565sDihsEmhrjqP6LjahHIv+'
    b'6MC+GvmVF24nfWxPAX7np9LgGRr8Mgp8j4GZmH2QoxdonO0UvubcNmAUI0WSTkmG0NcoaVpm'
    b'YfYbFI5xrhowV9IpCRXRV3iNl2ZS+N3nY6UZfBnMIYZojV8TR82P0nZQgsqD9dhyC6VDZo+y'
    b'CmxCy47zcCUXBp1HSN1mOnlQwaPBGXNe5x4qgh9Ijs345f4GvPfWHjRSXdtl9FVjCS7GDViO'
    b'+1avQe3bRqfgxYBxLzBZeD0/Ws3uprDdbDlwjMXPFDiNlLW9gwf4tcrMNDz8GHCc9DzpBRc9'
    b'R0rGo6QXSZtJW0QWG0nPkB4nrVP0IGkFaYAUKn6mwLmk340eJ1wj4mbqgLahWGymBnznZr2z'
    b'/5FmmakrHSQ2ojkXpsClEt0oleiGOnjmG4luPEziq8GinPSUmYaDHwMukWih7+EvkKiySKLK'
    b'ToluvE5610xtQr1BC3IF/CTR4jKJKnUSVb6V6JV/JIaCHwNqJVq0SLTgLaaOmwGtEt1gcz4y'
    b'UwO+v+erIjT8GGDsnxV+lmjhZsD1Ei0cDyU1rhJZsBkNZhoOXg3QB8+FTL8C3IrkRRItUs1/'
    b'hk1cbqYGa0k5UQT1AshPX9abqY2+EiyQqPK9xGTsJu01U5srJIaCVwP0+c+GPGam46iWyKiX'
    b'skWzRD+E+ozCqwGXS7RYSeKbqNeM1klUo66TqKLXDS+ckBgKmRpwSCJ/wKGiGqAXQH4Kk45R'
    b'UsJMbTw/6MgErwbwHZnKXxJ1A9R7Af0myM/lz/t1vlq4zqTaZwTGqwGnavqTxHxBUvvVe3W1'
    b'n3UvSWcOST9uJokfs3Px441WqHg1gHeCqlSS/U7vHyPp6MewhkkTRtrdID96HsCRw9KcNFJ8'
    b'BhFoN+hlO5zrTNh2eFoSGSAR81DB36DIO2wD+IPGBNo/l+aU4Ci6+E60yWxlhl0EGf6AlMKd'
    b'pFeNDicT/RkBb7Ac55Lq2yUZrwIWfv9AmCQ7lwNoaViLuhulOY5oFfBJ3hsQaAo8gK11dPP0'
    b'tDQDUYiSnXFUv6/O6WTnotQAN1zrhpDdGvASfvj0fCy9VZqBodvuJ+pRw58iGaQ5l0zI7RrQ'
    b'jx79GULW4C9qUnAsmXlTA3rR+Zk6vSzywoBB9A0uQO2T0hzHtDeAB78bXy1ze/eZnDKAVwJJ'
    b'A8Nzvg2tLxegaOFGrPhNuh1Mx2XQwtOXsP0akBN7gVS3wn7xa0BOkE0D8mYZTEZkgMS8JTJA'
    b'okoTLzOS5yQxxPolDYxjFWBoJbD+1S1Xmch/wYuIiJi2AP8DNpWxFwxkbQAAAAAASUVORK5C'
    b'YII=')

#----------------------------------------------------------------------
top_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAxElEQVRIS+2U0Q2DMAxEYYOO'
    b'0NHKBu0E7QbtBjAaI7ABtau4ssyFHBLhi0hRPuLcs89y2qbyaivrNx4w7wz7aR8KYAqwKmlr'
    b'6cBEPwHFNpwWHWfRVVAjwK31AL5Bc3AT4bfsh+whQHKA7BsEeIroKwl3AYIAJn6R2E9K7J9X'
    b'bpK1gjuARMCqePzsouUI4gFF8RJA7yOkd1XpHbTFZ8p8dh5ibydGnKnABBFk0dDo8RZAtIsS'
    b'3wowiJ46I9RiekAJ5YKqA74r4y0ZwWo33gAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
unlock_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAA'
    b'7ElEQVR42mNgIADSdmexAHEuEF8A4j9A/AuIzwNxDhCzMlACgAbwA/FRIP6PAx8CYj5KLFiD'
    b'ZNgOIE4C4mQoGya+mlzDTZEMacUi344kb0yOBZVQzc9A8YBFnhWIn0LVNJFjgRoQbwTiIDxq'
    b'1kEtWMJACwA0eAHUgg2DwwKgQjsgfoQnWRLCIL12+Cy4T4HhMHwfnwUwRceAOASIA4jEIVA9'
    b'YP3EWBBERnx4kmJBABkWOFBkAVCMCYhtoZiJqhYA+YxAvBlJHsRmpKYFJlhSiyk1LTCltQW0'
    b'DSKaRzItkinNMxrNigqaF3ZUL64BcldFkjYjk6wAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
unlock_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAD30lEQVR4Xu1bXVLbMBCWEpvp'
    b'YzhBwwkgN3A4QXIDcoKGGcL0DfrWIcyQG0BPACcI4gTNDeobNI8dDFFXwe74R7IVyWbWRZrh'
    b'Betvv939tFptKPngjX5w+UkrAQimpEd8v79VHuc94nkh+/4nNFFmawDYCu15XyilIxBUCN+T'
    b'CMw45wz6/dAFBD0AQvDOnn/BOTlRCC1VPKVksbyKTqusAjUAwcw/gg3exxqvkkX2fc0JGbJ5'
    b'tFINRgtAcL43opzf7qJ1lZDgFkN2/cJk31ECEGv+sQ7hE6HBEgYyS0AHgPB56vs/S8x+Bf7N'
    b'NoQ+wQkQkm53TTabI/g7BIIUPPF2OhTbmne7gzw54gPgzLsAQS4V5nq3iaJTtiBrlbkfn/s3'
    b'QJhT1fjlPJqkv6ECIPj6qU9fX4X2C0ccp3TMrp4fdJgwOPMCAFG4UKGBFRykrQAXAGf+FMz7'
    b'Jr9r3SMtPU5lCWAdp+w6WiR9UQEwnPlCa0EOgJBH0aDM7FVWAfP9knDC+nEe7WMFAMg620y0'
    b'n8wAriDlEwB0PwEUjQXER5/w/0zbxffzY+NYQgRS2TlTRyIeABTElSctHRL8ZwFvR+rvAgCp'
    b'wAgPAG+RX0Fb4K9WewQeKLgV/GMCQdGdAMZq8l20UdVXZa4OAGcBzgWs3NSaA0R4Sl5eR50O'
    b'+Uy4NAtT5d5a34GY+pIgSJDUlqxE24jLDyFPqqutbCE4Xk8K/+92WRIOK9E1zcRoSWvfaQXH'
    b'41g37VW2nBoARVxuv/faZgjhhDiwnU0KQNmtzHbBOsfnLzYmc8sBwK/9RFYGVjA0ETwZIwXg'
    b'eObfAikVycNmpWbGZm52Jku0HQBiGyk6AGRm0yIXcBbgXMDysuQ4wHGABIEGSFA8ZIiLjMj3'
    b'903Oa9UY7BywitNPmdfZOgHGDACD9PNYlc9XpcB2tQ6sAFS+ywtBj2fePSfbig/jhhIASvjD'
    b'cv4yrpKqDitACQAUJFxC1uZbJQCKvH3VuPR3pABkHyBVAsW1AIWHi9YDoO0CJc/YuiCgtADY'
    b'vLQaIy/Uf0uCsaCl2RqRrYU4XBRBWTWsFpAIVcje1p1txg5AAkQIvABRIRVhsPiTVXkaWUJb'
    b'ADASTmeQA8DlA+weT11CROZndV5XdfzYpo/jAMcBTXBASb2tjbk2MbYRF6grTG1C4NycKwBg'
    b'YLOO/HW4hnu6zaZ0x+rmHcrmUxZIlJWd626w4X7GNcTpfZUWIKlqbRsWTGd6BiUyk0ZLZJJd'
    b'iBpeKI4KOpQcwo/0arvE6EhZ6ENpuP2lyPMzM6kel61pVYJmJASyQQ4AZAp59+04C3h3yJEt'
    b'+BfjlxdfQsQuBQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
update_check_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'8ElEQVR42r1WMUtCURS+mkiplEvgFjQESVujmxA46Zg462Zh7g01iP9AkQYdEgPBFmlrcAhc'
    b'QmhQiLZwaiiMhgxe58T34HS5z/ck6ML34Jz7ne/cd8899z2lMKzD7Trh2oCE0gb5qoQvwoBw'
    b'TIgot0GkFsEyoGTg3mqcF0KR4F+UYIXQ9pggRjgljDTuDWHDKUHIsDJjAi0uRRgL/tC4ZeTs'
    b'CNKT1wSIDROuRExPJ2TFZJ8QINS8JhBb3BM6OXsiIFY8JUTh9xFOCHHlcXAs4Rlajz9Fp0dG'
    b'ZM2rJQYWcUQ444XCVxB6aXY0YbwSVpcUrwmxA/iDhDf4GuyYwOj+QfyBsC7m7VqM2ZjDONdE'
    b'9ghbDsW80MQ3NU4FczMliGVB2Ifvg5DUxC9FzL0uDl7Z5rAxg1ERhB2I20nSBvGhU9fyboAz'
    b'V6ILexopKZJ8al3uKI7YLngTNhowuPLBBUls3LmIr+JEMrep8Pp2cMEQwEneMc9vEXI5YXmh'
    b'l2GHH11noQujhqBdBK5p/ji63Sc6eSrus4BNzMmLigvqsR9KiKnhyukLnaxOlhcV34zhJRLo'
    b'N3DHRI7gdNgkPl2pJRJYrnXi04GvkgwY4esV85igvXCLUfQivrO/VuYxAaPlpYAR/DEM8AdR'
    b'NXASDn8idfVf4xu0zJz0nqH5+wAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
wifi_adb_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5Q7t/AAAB'
    b'UElEQVR42mNgGAXUALaXmxiBmBmIWaAYxGakxEB2IA4B4qVA/AiI/+PAj6BqQGrZiTGYB4jr'
    b'gPgVHkNx4VdQvTy4DA8E4udkGIyOQWYEIhvMBMRTcCi+C8R9QBwKxHpALAvF+lCxCVA12PRO'
    b'AccTkFDGInkAiJ2JiUhoAnAF4kNYzFEGKdBEEngPxJEUJI4YIP6AZJ4GSJANiNcA8XogVsKi'
    b'SRqIY4F4IhCvAOLlUDbIMGks6lWgZq0GmY3PNdpAvA6I/+CJUJDcWiDWItWrZUD8i4SU8xOI'
    b'i4k1nBeI/2Ex5CoQb4biq1jk/wIxJzEWgIqBJ1BNv4G4B5Q0saiTA+JeqBqQ2segJE+sL1RB'
    b'XganAsJqQamwAJwkqVDo8eEsCig02AeIbyCF92UgdqemBfuxROpualoQDE0lyCnGi9rBFI9k'
    b'eDStajZOIOYYWfU5AIwa2O9PebR1AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
slot_a_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABqElEQVRoQ+1Z7W2DMBA9Qwag'
    b'YoF0g3aDdIRuEDYIE0SZgGzQjNARskGzQfu/QvUAhavJh9RamMOpDVg5/4pkOO69dx/OWUDg'
    b'SwTuPzCAsRVkBSatQJFgImawhhoXKlseBnb2A0DssYJNLoX63b6MIXR0PsZ39VoysOP65yRW'
    b'4tEEwghgm+ILAC5Hdv78ebFblSJr86UDQN2wP58GAJCrMrqzBYATcf7ohgLQSnaXAgzApYKs'
    b'QE82JSJuII72+ac4/H5HleU5xNVCQLS+pjgMoUBTr+9VvZZdYM/95c0WhHcACHWWl7NdH6WK'
    b'9HuplFB9pv/yD+DEvrHla+HUdPmv/u4PUEZ1hrZp/acMU/sUGO8KUA5S+wxAZ0APAVuGgg8h'
    b'CvB/CbrYd3YWMiWZCQgDuPxT8M2Qb/veQij4JGYAWuxxJ6bqOnVUoPZt7XvvA5wDnAPaeZ6K'
    b'Ud/73qsQAyAYuEkFQh/uTmq8/qrG689tUUZdcFiNPjwlssRIPOmTPrITNw+cpmhQjHTR0Uz4'
    b'Dmral111xeSJTedm+ZrVOaWWBlkBS8KcPx68Aj9BVj9AffO7OQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
slot_b_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAB20lEQVRoQ+1Z3U3DMBC+czpA'
    b'IQyQEcoGZYMyAe0G6QSFCdINYAPYADagG8A7qsgATY5zKKhEid0rqetI9lOkOM734/P5bISe'
    b'N+w5fggETu1gcMBrB7IhDXEACyhpzNEycgz2HQBfqIC7eY783Nxap1AFPqI3/mzoGHj9dzkV'
    b'eNlGopXAMqZ7AJqeGPz29/iQrnHWhMVAoNTqJ34QgDxdqzMpAfIEfAWDCTSKbXIgEOjSweCA'
    b'Tc02hX6+42U5gagYI6jFIYvD0R2wEdghovPLq5SENwQ0kSzeTNkJzjP7N78IfGf5z/3hO1hG'
    b'6wot4/LPMmx7byPj3IFAoGaJVw5sd7p+x4BpTmfnRYqImW3e77537kATOK08qHLK4HUyE9UZ'
    b'vhBIlIIbQrqVqO9kN7pvJtZglheUAVEqIeHcAdMy2osgDnnA5zxQxUFtq2GLB+cxYMwDfdjM'
    b'GQnEmwlvpx9tqnuXyKpaQKuv6Fl60nfyKVRl4cFmhBTpQiaRqO8kkUkBSfsf3QEpIGn/QECq'
    b'WNf9D3Gg74e7Xh2vP/Hx+nWTq7YLDlHZ1/W02Y6Xk8Kr+QeuRAR+k04EXPrRRFpBdUAm5zFW'
    b'fDszO+iKqQMAToYI16xOZDb8JDgQHPinAl/V2CpAdYUKSwAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
rooted = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAGkAAAAwCAMAAAAl3aQ3AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAIuUExURf+wfP+NQf+IOP+IN/+FM/+DL/+BLP+AK/+CLv+HN/+FNP+BLv9/'
    b'K/9/Kv+sdf+LPv+IOf+qcf9+Kv+eXv/x6P/28f/z7P/UuP+PRP/59v/////48/+SSv/eyP/+'
    b'/f+DMP+SSf/28P+4if+3iP/17/+ZVf+DMf+YU/+/lf/9/P+CMP+nbP/Rsv/hzf/eyf/Hof+V'
    b'Tv+ALP/StP/Fn/+TS/+EMv+0g//Ttv/Mqv+jZf+9kv/bxP/iz/+kZ/+QRv/fyv+PRf+1hP/Y'
    b'vv/7+P/m1v/r3v/+/v/cxf/69//s3//8+/+vev+nbf/u4//w5/+zgP/z6//k0v/IpP+fX//v'
    b'5P/n1//59f/Kp/+bWP/Wu/+XUf/w5v/Lqf/Stf+GNf+aVv/y6v+qcv+KPP/l1P+pcP+1g//E'
    b'nf/s4P+YVP+LPf+obv/LqP+sdP/gzP/q3P+jZv/XvP/8+v/Rs//49P+BLf/QsP+laf/38v/K'
    b'pv+0gv/v5f+RSP+yfv/q3f+4iP/Dm//gy/+kaP++kv+3h/+yf//GoP/n2P/Al//t4f+MQP/H'
    b'ov+7jf/ZwP+gYP/dx//Ut/+GNv+rdP/Orv+CL//Xvf+mav/PsP+VT//o2f+bWf+6jP/Gof/N'
    b'q//Yv//NrP/Ttf+8j//j0P+we//7+f+eXf/Qsf/j0f/Jpf/Fnv/EnP+ueP+ma//Pr//awv/A'
    b'lv/m1f+zgf/Cmv/k0/+2hv+WUP/07f+tdv+fYP+KOwAAAP1sXPMAAAC6dFJOU///////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////ALtpJHUAAAAJcEhZcwAADsEAAA7BAbiRa+0AAAM2SURBVFhH7Zbp'
    b'O1RRGMBVY8xoXkvWeWNERbeyDJGdwpimBpFkKZm0oZgIFam00J6KSlG0a5HW+e86m8mTJdfM'
    b'9MHj9+G8y7nP+T333nPvc9xs/4slkyMsapPbsuUzs0LhrvTwUKlF+TeeKzUwBwovsb7d5C1m'
    b'nI+PMAiTr2jLZZWIc+HHFcKkFl1XoOQKYRJN18AVS6aFwRUzmPwDOIFBwaLjIFwxg0mLk6wO'
    b'ES3H4Io5TRgqWo7BFXObdGGiJ5MQ3zUio3DFLKZg8kcLJ9FH9GQSgWtFRuGKWUz0n7HuX6b1'
    b'kSKZhpNNUTjrhnGyaYNTTAJpI4Bm0+bomNg4Pqf3jY8OTdhCssSkQNyanJxCUp/UtPT4DDYP'
    b'mbFZWQnZ22SbogHCtmNObp5BSqJTinw05u5A006AXWYjFpjNhQBxRWjercViekGJEfeUGveW'
    b'yTUZ9wEkYDl5lBWVOj8yVYX7DwBUH5SqSRHKn15YnlQDYDmEteRG/fEwgOoIyjQdPQagNgaQ'
    b'tQFSMB/guKkokRZ1WE5GYfLCehpKMAagAU/QXJ8nY0dEkeEkKRqxiTX1Wmsk1OIpVqik5ha7'
    b'6TS20qAwtAG04xmaQ70ME5wl4zmADv78AToxE85jFy8q0WI3XSAXMgwaaMKLbP6SHFMZGbsB'
    b'LuMV3r1K1j2P13jRg712Uzpev8HRwE28xea75ZgyyHgboBXv8G644S7cwz6Wa3JM9+2mB/iQ'
    b'NSn96MVilxxTWDOiSQ1qawF5JQAD+AjAWypQ0eIxppMxH9lH9gQHaWB041MWn8kxQTkJZPsO'
    b'sSeWGIMdJAzjczJ6vsAGEoZwhIxgabPSzxc8swF6R40DJH0pyTKNkPCKbPNSfJ3wphKD6FHV'
    b'0onRb9v9sZ9e14ja4nfvAcZyDOlVQ2k5qaQXgdoPgx9N5bJMFh1iuJJs3089kunzuJ7Nqb+Y'
    b'JeuEGz8gj5t1zV9J/Db8HUcr+ypo70epZJoYyzSz2xVwxQym6bA3NcnUwp5PaeqnndO5Yl4m'
    b'B+GKRWxif1EX0cIVwlQnuq7gJ1cIk22Bh6B5YBGGSZOthh4dnIyH0v1XoVj/j8nlLJkcYfGZ'
    b'bLbfQGTrh1g9rfkAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
watch_green_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIESURBVEhLnZXdUQIxEMd3A5nx8ewA'
    b'KhAr8LQBtAKlA5wBxzeHNwed0Q60A7EBPStQK5AO5NHhPuJuLgcH+YDh90D+l1zyv91sAkKA'
    b'uA8RSvlrHp2oNN1PHmFmHi2Ead1I2TLKT7PZMcpJ2AAgOLkEdzcQCAdGehGojox0Eo5AqY0p'
    b'UoCRkU6CBjR5ixSF0+g1iAfNG2p0BAhqohDPFMChajTarKn8nnmMiE6G8sloC2eZxgPZR4QH'
    b'kjNarJeM55NyZJV4KDu0wDvJiMx7yV1amS6wDOLrvRbm+SfJiL+0vvjxUNI6tOJduphHkcaI'
    b'yCbA0SW3f1M9YLBTlGXn9BtxCnxfXie5zxJ+l7XIc07rCpYBfU3MbYH4qju2oHqXwtNz67g2'
    b'uSxNIb50uw3zeWKUVbIug2Bdb2Arg3KT8lyHe3IlH3hzqw1mqmce0x3L+8iK2rEHoMMVoLrc'
    b'vo3TS+p7ZF2H+3jMPOrroppbxzIo5umIWzrFp1yCrNdN6oubMu2TnBWFsgrDMuC7neufNU18'
    b'0Z1EZbL25fwOn+JIKRhxyZa9S6yDVsHHn5J+wZoX1V+XZWWOKedCYJcW5fFo3bSO14Chjfyh'
    b'ZtONOqN/tbbvX81VRXVWjr2H6c5/mRT6xsNGKQi+EzQoAD+M9FIo+DbSSThFReENfYHAYBrD'
    b'BlXVhAjeWQD/lDKwDnlodkAAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
watch_blue_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIDSURBVEhLnZXLUcMwEIZXNq+jaSBD'
    b'KiBUQI4QDkAFQAdxBQwVOFQAHRAOPG5ABUAF4VEAOTLMiOVfWU4UJCuefBf91uuXVitZUYSD'
    b'YpT9qPTLfgZZYb0+zNtj++mR2DLID9GGlbV8E3WsDBI1IEqjgwVFyeIGStGmlbUopbatDBI1'
    b'4AYhQp/MyiBzQhSPr4AsWSxEvfPPUxTVDobMdEist35Zt40muiybKOsNPi6s9gim6W7x3kds'
    b'C8gxJju5y1vDsmWWXjHqkEofIDPE6uQ2b1WmEzyDnWK0kaj0GTKTlbqTY6UIOdFtvzUZh/5d'
    b'9BcTkt3d5+0302DxQpQkS0co5OAu61buggkfUZiVw0jCOoNnwMzdsqRrU9EAp68Z6+IZYO/m'
    b'YJn0i6lowCpp2YXgpWwoi6J5PYcmBsocUkKp2e7e4KOQw60OWKi+pU2+p++R8nYdCBGX21W0'
    b'L8VNv5UjbANT5yB10iYaiWGei8lYB89gmfWZlQeSgiL+m7iTmz7MfcixZu0lhmcgb7u9qZJ2'
    b'V6YSVCbu5AL6yC3GneEzm7IzoH8YxFgGHouWSWV1a0QmxhLzVKX7OBRpz/6butQaCDAZoZj3'
    b'oo7xV2vX/dVCaToBK5y59mHU28K/TDQ2uGwc7RM1+GV6srIWHO6rlUHmhEjXbn1KeTHriBpU'
    b'WRMj/mYR/QHZ47rtaS0S+AAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
phone_green_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAElSURBVEhL7ZTNccIwEIV3HesOFZAS'
    b'XIJCBVBCOoAZ3AQ+hA4ogVQAlJAOQgfh7mSUfcoaHGSw+Jnhwjdj79Na855ly6YHd4dxsrnJ'
    b'RMxFZhhfy6oovS9IcJLRm5SbmDfykhuHQ4c3xa/gFNeGp1p3iNmTPMMfHZ6kn6cLRzzQ4T+Y'
    b'3Puy+B4GK4g1B8fMQXWt9RHFgF1TP7TtaQywI+qoDMCWVhlFEGAnZsTGfNlJarW1Az25vRXm'
    b'aKuVICBJqIfKzGK0D/HmzAuRnWpODEHAclqOmWkGjRDfFCpzXMOcv247je+gHlLjbHPQGAAO'
    b'Qy4xB0cDQBVyqTnwe1a+3k8pz9AxuLLsrme0bfuF4JvwK3DOvUrZQMcAc5UfWgPwq1D54K4Q'
    b'/QKPSWDjcGtw8QAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
phone_blue_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAESSURBVEhL7ZRPEsEwFMYTNdZcwJ8b'
    b'OIIlVhzBDeokcQNH0A1bV3CD4gKszRDve0lNR0KqNWPjN5O+ly/p+yZNUvHn50g8xirtC1lf'
    b'CqH7rFZkE7e5LqjhoWWkvlXcy3hx1Gi2+1V4Be+oal63sRRkvKIwMT2HhPZiGlxBgFfFAY9V'
    b'NWBwavLNyozXYKLSpk0d+Eh/gGMwUof4IqPTUKUDKz1gTUZbzLFSEMegJmXHxGibN0FOGja1'
    b'mc0pgmOwjttz+ogL5DBhkciKYwxzjBrGuwd5kxwfFwdeA/BsUqY4eGkAMpOyxQG9yzcypdBF'
    b'XoSGvraSee8c+oXgTvAKbvo6o7BHXgQUN5ncmeglsfHPTxHiDk1ZWJDswzzyAAAAAElFTkSu'
    b'QmCC')

#----------------------------------------------------------------------
disable_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACIUlEQVRIS7WVzVXbQBDHZ0Y4'
    b'Z3PLQxxMBZYqiFMBuAOnAqACoAKcCkIqwFQQUoFEBfEB8XKLzyHayYy0wiux1toH73t69tPu'
    b'7G/mPx9C2PPCPd8PQUAGxxMiPmWAiTgzsg4t5Tdn5Ie0fFn0ObkRkEGcIOIVIJ8FoszZlNMU'
    b'fiv03fICsiieIcOtnB7Ks0LguTH0E+BffUlECTGMGXDWRCURXqammHcJ7wAZxRfyUi8X/fja'
    b'mA9fU1iuNkXxRPGtXH6h+z5IC5DBxxFSlFnP1UbCH3zuA+ghzRMS/6ggpjxx5WoBcjy+V83l'
    b'5dwmNdkW4kSSJ6ZIm4jfAFl0dIaM97KxFK+rA0iv6tXWkJziX5oTRviSlsVdLbNdsvlN/s5U'
    b'97F5ualDHw13gTzR0ZUk/hoYFwk/T7sA1T6R2p66tb0LxFFhJTIddgF1eJ0k7RKJdeaP2HgB'
    b'ujH0AbaFOACQCCr53RxYidYJavLT/Ibkcsp1KYCTYJK7gFAkb03qS7Jbpg3dB9gEsWWtKkiZ'
    b'rgul3WgUVzJpo41NcbkJ4IOIzaMdGa3u940KrSZpeZQR8fy4A0SPrsROJuvaLjDs+iPRpBP9'
    b'Pa+aq6qYdZM2jvnHtTNR5WAuhot6XB/kteHrCCKRkuFcJa08B7gBM7jrDsb+Dw6Bjg+9oG+J'
    b'5lLaUFh4+2j4k1l/fD6J2UQrRL2tHpahSPAdysGib5wHAQHvg9t7B/wHAUlDKHr4TGIAAAAA'
    b'SUVORK5CYII=')

#----------------------------------------------------------------------
enable_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABAklEQVRIS+2V3w2CMBCHr5Ia'
    b'HhnFEXAD2cARMDHOYNQERnEDOoJuwAg+GkmsrcmZUlv6B3mTNyh8H3f8rhCY+CAT8+Ev+HQ4'
    b'LyFjNdz0lv+kRRI+o7R6criyU1erktEChHOAtQRzDhtVMkqgw/HNOSEFOzzO8jxaYIML5oUn'
    b'ScH29zZa4AuPEoTArYJ8N19hD9VEhMKNgnxLS0KgEousOXZLFMTAvwQKHLlvSSy8J5AQQmkj'
    b'Li60aWQiai3mXFnrpcW2afZiOiDRn/eCm7+BvRKUeMPtKbJLguCDc2BoVzDcOWiKBNTxD/kL'
    b'OvciKYE0zXBvCYE7KwiFme53VjBWMrngBSl6hxnXra1IAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
download_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAEWSURBVDhPxZI7bsJAEIbNQ4gQpaOG'
    b'gkNEygUioMgNohwB5SQcAcEJKJK0qXKA9CniDokOhzwEge/fXa+8tikQBZ/0a2ZnZ2ZnZEen'
    b'UnE2YDCOFW+h9H6H1s+jjmxA1dk8Kv5ACyf5ihU41EAvXyEVSfJLpz3U4N8pJX/2BF2H4/iC'
    b'Jeu46QqXisMX6qE1BZunUefbRCE/wTV6RzHK7ixfMd0pxxM0oPMrLzziJig7nfxEd8qxIUs2'
    b'ycMqfVaZ4rZtJFqSeE/xizt7ShsImtzRZCKfpAeK5+biGGhyK7ljKcEE/IFNjL6CgQn+ZElq'
    b'mIBlwx/54/zCV5ihVSoKf6VsDCnHk5/gBtNFWxMoUkOfTPBmj+cnivYIfEiPJqGh0gAAAABJ'
    b'RU5ErkJggg==')

#----------------------------------------------------------------------
download_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAnklEQVRIS+2U2w2AIAxFZREG'
    b'0mVwEllGB2IRpR8mhLTcNob4iPz4QbmH4knd0Hm5zvnDMwBjTDvX6RY8vCAsoOAfAEV63xNN'
    b'MS1ZmwBbKwqyLXENfq7PiBZZIFI4wZqaaiCtcAigghYEhasAEkQTrgbUEG24CXBC6MvZIhmn'
    b'mkUWXdWaXgktz7IdSKMBQbnxfQ8A3dSy/9GfbHkCVHsAr/hIGUeLKLAAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
uninstall_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACcUlEQVRIS7VVwXHbMBA8gFEm'
    b'T+XnMfOQKwjZgdyB3YFcgaMKZFVgqwIzFcQd2B2QriB8hJn8wmdmJOJyB+A4IEVGnMyYHxHC'
    b'4fZud3FU8MaPeuP8MBkgh09LpfEeEGrU8DVtqmxKcScBcogTpdQGFF51EiK8IDY3Kfwq/wU0'
    b'CpDDYq71foMAK0owlyS0XtOhe1nT+4MxzW4M6AiAE4Per2hjEyaWhImpFMcovWcQBrcPA302'
    b'1brfTQeg5RkgGWubAWTP0qfhNgCqUeFN2vx8CoDdqw9+Hqo6BAsBWiAdfwlpQ9NcCGVtNYWK'
    b'n6nP5SlndDs4W2gd3QY61bZAMkCC1aWnjqqPzq8Uqm9jQvY7GDBAQdRsoTGF0tF3jqf1NVNl'
    b'O/DcMz32GRPSHnQuEgPUtN6CmWUAB9IDHylk4QCAtKiyjsiFjineAbT8OiH5YCg8U/FEXG8B'
    b'3i3sBQz2JXlLkSQbAmiBonil0AKRVHhnzPtd7544/nsFnuxAAPhXCvD/ScKgG9qJdDJo0zDB'
    b'kBUHAFgQGhewTqEqwkLC9//tICOxXlNTPfD9AZiVKZTcCRmGJgH8mR/dA1/hb89jgYZc0Kus'
    b'r5G/nGzvGs3M+V4dHmkwLun8JZ8fGhWtXSk+Y6dINccAdiZxPDusIG+WfupSgc01nxucpq/6'
    b'nKaouhMuZZAN27gDYomQ5Ec2DcXJ4Yz8HfGFWvVcA0THx5BzT4t8LwhgRvQ4TSZ+cGj+B3NK'
    b'LpId245zTi5OsnQJyEkA6crPK/5klqhxx173XeYUUzItAB9qr8kCjSINfrxMBhjzubNpU4sR'
    b'nE0PCSefRNFY4qn//wVB404o8iopVQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
launch_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAClElEQVRIS7VUQXLaQBCcXck5'
    b'kx8sviY48ALDD+AFgRdg7gaE8R3zAjsvMHmByQsgxrka/SC6W9rJzEpLbZAwGJdVRUGJne6e'
    b'7pkV8MGP+GB8eBfB5UrVJcA5gGgSUgmQPgIiTHA6/hbesPijCIKFKuGJHCJimzBKBS5EV5X1'
    b'56MIUtXiPgOOhBCzBPUPP4aQ3kXaF3/5+yiC/m91IaQYMjgCzL0YO0EtZGDzcGcZARCBcedg'
    b'izLwSQqFgZTwU2txK0CECejpdSWcZ9090IElEdQOJgj+qCqBcWGJfO+Mz8K7/qr8QOrqho66'
    b'GVfWjcFKUXciINtuRl+fe68SsBqeCj+BuT4RC/qt3MLBU3nN7zJ3ljLGBtmzZhEasMEd5QjY'
    b'w9iHKoXIVlT5oAeyi4BNAr8TL7pHnkdcaOwQ4pZIIo048qQ8p+4uyLLZqPLcsrlsMug/qjaB'
    b'dBk4ZabpIG+JjK2JSGHZgttiG2wioU3hs6hISmwEX8JljoB9RiS16WwDqyeSYeozBleVcOQC'
    b'29+Xj6ppOuF8NPbsguUI3GIu8j0IKdjFa+rdsXXzcbF2jmlmGSvbjJwtzDZ5YrstUr6zg3RZ'
    b'oCtjmNqlsWPI/xm/PcoqnSAOuHN9Fs6K7CucIrpjzDLxxMAnUJlN/GqZXWgMbGZ/e5OLSDYW'
    b'2bYz8BH6cqK1/uX5tAdpFuZhYLJmyhnFGkp23vd2MHw6Zb9ZuQHn2Xf950BRwtKXdB2j/M7+'
    b'77PnP4uYYBucZr/F1zJ7zau/dZPmwt9nkXKVW3BSqcjrFi+Ze1vaO2mXNbkpGq5O760tReC2'
    b'gDulc3X5grWizd4m3IQ8WJUpP+BLy9jiKneL7Bjv2uydBPta3SY5RH1uD95CcujZf2NYkShw'
    b'vcGiAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
kill_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABJElEQVRIS+1VQRLBQBDsDVcp'
    b'fuAJ/IAfyA+4UE6e4AmOigtewA/iB/KTqByVoCeEJSTKykXZW3Z3uns604lCzkvljI8fIwim'
    b'cHFEQ2xja16ph7qphVeLggmhv7zsHtSfINXUXC0S8MuwnEX4Y1QtCy3ujp7Icrgn+x4LHd5t'
    b'FCxOHODweZXWRiJonCafBWW9SNRcQAdCIGcydbHKtwn8KWqFIzaPBaFCvdKFF+8TXDodvpOT'
    b'uw4YtBnT0M6Mg8IaIRZ2H/Osu3oOWry8fCyQRO8VOnoHWaD6eUTgz1Au7uAyyrWEPQc0K30q'
    b'/nBFBMGYtli0Jyl/bXfR/BA7KjsTaB85HSw0VH8jePah44s0VZ/WwZbqHRPvYyd+7I9mMi2v'
    b'anO36ARJVFsZOfXo7AAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
clear_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABYklEQVRIS7VVy03DQBCdMUd8'
    b'CB0EBe4pIekAX5OTK0AugQ7oACRErqSDUELuKEAJlvhIINnDzBJby7If27B7s3f3vZn33tgI'
    b'kRdGxof4BK+3p1PE6goAp0O74Srva0qKdPmwNTHwfTXZEMBsKLh2r/z8qI6P8udSx8K31YTx'
    b'/22tDxe7LCaBYGdMsm5IHB0Qa4kXfIi9gZHRX0kEBSKdO3z7IZVLIlXFdwDqjUYi+uay93Jz'
    b'MksOSPZsq5XKRcBVJnNJhUYiQAp8/+6On8ce91SRPpNNknEPcOFVUoVS1JLIjY6V6015O1BV'
    b'NLJoBLonoXz7JdI1FyTDEzNdJplXorZyTZaRxXgnCQEV6eLx0uoB5zxPl7tri+atJ3+MKW3r'
    b'Kik45zJoZhTLusKM93jQ4MxiQqdBC5nn3G+kaQ6EYtqXyPqxewpMZFcS++d6b5ZN667Av+ZF'
    b'vxj/l9mnzCFno3fwBY+E7W8JEV3vAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
check_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABHklEQVRIS82V0Q2CMBCGaSKJ'
    b'j46AG+gG1Ul0A0zA+MqbERPYQF1EOgIb6Ag+mmCC/yU2KShIKxh4gaS9/7u/d1yZ1fHDOta3'
    b'/gvgvj0B8QBXE0NnIs/zQOwfQsYXHMx8O8ECNxSXYdckzMZVgJwWsMHo6JDgW3zZQf8AVDcR'
    b'Zik5b90BxBc4ggiFjVHYoFWAFEfiI8as+LzLVq0BPokbHRHfDB2xvV/Vtq0S1wZwz3ZhPUJb'
    b'LVHEIwnUiWsD5msbxbNcCiQIvamg6pmXf0jtGqgQiN3qxLUdyOxUiOyWqlGi7UCF0De1Yt2c'
    b'MgY0HX69AFyQrdM044p9KabxVK4Vpin3BpwxRheOKUSgpU/yv3m19o/5fgk3ulh0Uuoc8ATI'
    b'zNAZjmwSGgAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
uncheck_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAfklEQVRIS2NkoDFgpLH5DHS3'
    b'wADoo/lADKLJAQeAmhqBGESDAboP9gPFHMgxGUnPAyBbEZcF/3FYTKydGPrRfTBqwWgQEUxM'
    b'o0E0GkQMDEO/qLgPjEYFglGJX8EFoLQhruIaVBeAKhxyLQFVNAuBeAEuCyh0PKZ2utfJVPcB'
    b'APwoJhnauKM2AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
clipboard_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABPklEQVRIS+2Vy3HCMBCGdyFt'
    b'8OoAOuAYfAolUEHsCjJUYKcCkgq4ObnhEujAhDRAA54/UoIzkkaWhHFywjd5d/XtS7tMf/xx'
    b'6P3R8+cTgR5AODFzkT8O1iG2QYBF+hGLS1PtQtAqT4YvPogGiNJySny3IcLUZgjQElSdetzf'
    b'WeVEBVCt35NJUcs1wCI77sSPeaNXqGag/piZtg7PD3k8nFgBUXaEFAiFb3B99qXB1K/P0k5P'
    b'0X8DfJ6bcjMD3gguBZzTuhEpWgXVoA3AtHHWoAnQ1M4AkrdklKl2rQCudjYhrQC2Yt6n5bx+'
    b'gCqkM4BMiw3SKcCEyAfXOUCdADfA71B0jQyzBqVQHjc9MNfUVG3UNtYA5zYTC8cOuRoQOnuE'
    b'h85If+7hfR4PZkE72QT7IhVbq2DQq9zZrQChkUq9L4xK7xn5q/8GAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
push_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAC7SURBVEhL7ZVBDoIwEEWLJ/IIHMW1'
    b'KzyJrLyOR9AbgCfB/8nYxOk0DKVuDC95+QmUTjptSthZyxE+4FToHbYwCwdYH65xgJFG8gMH'
    b'1CDOe5D8GSUFeskidD8Tp/OcV/1cGSlqEYp0CNdKFjcZk2VpbnMRFtPU2WTPSmqcopekyaYC'
    b'aNEFwQ13o09DIk+RnCS2J3kvZrEGf+mYnGaxBmuXJqeR/7uLRsktPCVN+LPgfa576pX/kxPc'
    b'8RLCG3WzjIvZeDJDAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
push_cart_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhElEQVRIS71V0W3CMBC1RSP1'
    b'k24AG8AGzghs0G4AEkj9LL9NpbJB2w06AXiDsgEZIf8BuXdpjGznzrFaqH+SyM/37u49X6S4'
    b'8pJXji8agnyVGUtkjHnSL8f1pYg7BBC42hX13UUJbDCo5AveJ38MriHB3MbwNFDLGyWl3CUQ'
    b'VIAZMrg9EExJglaPAzxHMRIzGIzl6YTVdkhAzAdd1O8sgVpl91DWm0uAwrvfaAL1eDsiSLz2'
    b'4BnSpqCFVwWUTOLClkIiOZBrNxn6YFBFpALUq2mnFOZzWxxnYWvZixZW4bXsR4NzcNyjsmdb'
    b'hBtqmc2lFK+M2KVrBMBtts/1gsLSLZqLocwyzLDvTqBd96auZ3oj8L2zGPHO2ZdweModjlmZ'
    b'tSlu2P6Hnk4JmCRyTOAYCWXnmL/xsjUWTF3JBKkBU3DcRZu046ICf6/D22kDw1jpxXGjAi2q'
    b'2kAllD6msgWtenEps8gbvy5RYAYS1ydyCVb9cMevS9AOOzQDi/ufn36KG36L+QZeTbIZLqzR'
    b'/wAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
json_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADBSURBVEhL7ZTBDYMwDEWjTtIT547A'
    b'KN2MUTpCuwGM0A2CP/KPaEIKcYED5UlfFsGxE2zjTkq5iZ4ir1oK/R+iGgs54EBnSwKoxUKO'
    b'0sAxyf6L2s04VgJ00Fpc1QbQWo0IBUKbWkEHIQa6MSRh5fniLrKCgzLJoKkadGotvFUJyMwh'
    b'+zooMzAGPnNSU3wzXs0K92d/F58JKu8HkbnneL+w+RzEJCcoZP8bxAleaktvMvZnjEnQWuNB'
    b'WQr9fx3U/8O5HlPmTN1oXEehAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
xml_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABY0lEQVRIS82VgU0CQRBFoQPt'
    b'4OxAOtAOtAPsQCtAK8AOtAPoQDvQDqQD7ED/IzswjDu3FwkJm0yO29z+t/NndhmPjjzGR9Yf'
    b'nSTgUlkvFK+Kp5YD/8ngXqLzArg7FHAmge8g8qL3qeJB8ayofbNd0pcBCxG7DYAvvXdlfqnn'
    b'h+K6spHNsgxg4jfhG+bXBXheRH/0/MwgNYAXZ+HEZXCl329F0ObJgMJXIREQxbFn5QBWYLyn'
    b'BgzWAK1CPKAljhjtiW2A8d9GCjHAEHHErMAXIbM0Ew9I0yzb7AqAtqXAcVQ3GS3qg2ANFr0r'
    b'aEs/UgdqRc4gMyk+KnyBzRrOCxugk/YaI2tTD7F2zAps83/EofcdNIPYN1mB7aDFlt5Y2Loq'
    b'gJABPc6BigcPDear4i2A+UvXTBX4TO/Hu6nT3Gq/5ru3ode13aAUufkf4GFDAXQQ1wT3vz/B'
    b'2ca380MBTaFDLTpdwC/P+GQZw57SpwAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
alert_red_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA0UlEQVRIS+2V0RHCIAxAE9ao'
    b'HzqBsEFHkw3cwDqJ3QA20A9xC0Hona30rCUiH57y17vwHklKQCi8sDAfeoGCiiODnRfyLKmD'
    b'1jmUAs5t4PQCjdXBf9VZ8GHziVuzigWsch+Cdxgv6A4/ZJAguG/ShNi/YLJtP9oDym/8VomK'
    b'C77/HuSW6OgBSwrkRaz25RTRLFKwqJG5MK7zJGFcM9iLq2kiwdRpng02BLdZ24tMyXb2RRsL'
    b'KHByBlR4qkCFvvjXSAprtilleYyZLREVOI4vLrgBj3+DGRtqfu8AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
alert_gray_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAxklEQVRIS2NkoDFgpLH5DHAL'
    b'Zs2aZcDIyDgfaKEBhZYeAOpvTE1NBdEIC2bPnr0fyHeg0HCwdqBDH6SkpCiiW/CfGobDzAD6'
    b'ABw68CAC+oCgBTBNpKgdtQBntI3QOCAlGZMVRDS3YOjnA4qCaM6cOff///+vQIoheNReAAan'
    b'IXpZ5AAqrqlgyQGgGQvT0tIWoFiAyzU4CrYGoAsbifEtwRoNiwVEG06OD0gynFgLzgMVgiIf'
    b'VA1OICZYkNUQDCJSDURXT3MLAFLIgxmdZDEoAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
pif_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHMSURBVEhL7ZRNSwJBGMcfXQmCIIIE'
    b'oxfqG9g3MKJj504J1geIiASPnQQJokuXiqWIiKDo0KWbEBF16YUOnbJjoAcPncrN/v+ZWXN1'
    b'1TS6+YPfzjPjOs/uzDwrXVoRMK0ibGeiEhJbyhJlPx9Pen5vRHg/UzZhtuw4a4VEKmv6EjSt'
    b'xpINd/IOiQUsyzZxPXySqqdpG7//e9/gH/hLgl64DY/hBAf8aDfBOuSkJAVn4BnMccCPSgJ1'
    b'glrTB290KKPwCB6qXhUROz1uQp1g0E7HcIKW1EhA7lUrwpu+4CKMcwBswR0dyhDk0qyqnuaV'
    b'FwcnyU0Sqtn1LI7pnon7IeuAS8L2E87DS8i3HYO38AIqUAMJc0xjSJLD3PV7gJvUUwAuAZmG'
    b'H/AZ9nAAzMECPIWPHCABsYq4FE1XEWS1YtIpxKy+6kIZNm0EXsM71WuGW6hcZkcmObd6A5a2'
    b'hddTN+m1JwOmPYALOpQH6I6/wxEdVojxUi45y/lEUu1lZYneEil3aVw4AbHgiw5lBSZ1KCeQ'
    b'Ceto/C1qj114pcPGNEvApzjXYec0S/AEZ3XYOd4Epsj8vorN8Nz/U6gKb4KS8CTVbnY7sFA3'
    b'TdzlN4h8A2tJgiY1SXc7AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
pif_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAa2SURBVHhe7ZpbaB1VFIZnzpxUjVWj'
    b'Jk2ttyKKIF7aBxUEpUWqgqgtIl6b5oj3C23ApFRR2xdDWrSKUm/oiak+6IOtPvgiiooi3rAi'
    b'Cgqa4KW2JkqqNQaTyfj/s/dM98zZM3viOW0mOB/8rD1jzZm1Zu+11t7nWAUFBQUFBQX/W2xp'
    b'jbRUN7eUy5OrbctbbnnWQt4S/0XgWdb2kY6eFfJyv9I2sLEK0ymuIrwDDTmuu2FXZd2QuJVO'
    b'SdpU8IGdTc7EoO156+HpItyKOJ8jlkCdruMMtlZ7OTZiDMD8ai/f9mYor05rsR1nm3z2VIwB'
    b'cJ3yaphZ5bykBTPhQTlOxLwEbC/TVMopy6VNxBwAkfDi9EOViFz3MdgDgue6L8BEP9+yH4WN'
    b'Y5y5xiqABIgEX0NluKOHQcgN87b2Lfc8e5u8DMFzpvqYqQrkhIOgY6DD/asGMVsC0AX9BO2E'
    b'9kB/Q19Cy6C6mA0BeAZ6BGr1rwQHQ6dD9/tXdTDTAaAjaVwG3SyGIcPQAPQsVHcemskAbIU4'
    b'lXdDSY7Ey9hr0DxoFXQL9DxUFzMVgAuhG8TQd+hqMazhTGkDeqVtGDMVgJOkDXhJ2jhqHX8b'
    b'+kgMG8dMBYDr9ysx9GGiM/GdtA1lJnPAOdDd0DXQx7yh4WhpyS/SNpTUAPAMQA7TOAVit0hd'
    b'xxsZGYOegF72r2phhThSDH1+lHZamHaEqQEoW+Pc+5s4TFpyj7TkAuh8aK5/NX3Y9amcCvHA'
    b'5Xop9XMTwY4wdTOXvgQch1thEydLS8rS9kDvQu9BIxAbmRMgldugbogNTRwHulIMQxjcV6EX'
    b'pV6HssCSmUhiAHgKhF2EdjvpuC6PngJOk5ZwyTwA9flXAvbwbGU/8K8El0BPQhshtrSBs3dA'
    b'X0N/QZt4I8afEHuB+6AO3gj4Z3KO+kwqS+iLHNdQEwCu+7aBTTwBonSMxs7b1Bb1eGiDGPpr'
    b'/BMx9DkOCpYDnVZpl3YO1ASx24vDnoAbIb6Uh6BIThitdI3SiKsaqtKnGmx5wCiwrUVy/5+Y'
    b'/DzbXj+ysjtwkmyHrhDDCJdCnA3n+lei45svhtaJkBrEO6EtYhhyE8RySX6D1EBrSdoSR7Ct'
    b'HfBxh7zyZwCnh5DhwNM/+Y06TwKnVG6H3oC4lgM+k5YcJW0a49KSKWlT+XXlWrwM7cHIPoSP'
    b'oc/pSVDAacX1VUk49l4gbcDT0FMQp/Ji3pCotZ5T3QTfeoDuUEbLcEd3l+e6SzHkMyctiZBM'
    b'AcCnj9q2l/THuLZVgrV2BqTOgLek1fGHtEk0S5sZPjOmu/G7gSwBWMhqwLWlSSTHQvEjp2+l'
    b'vVhawsz+vhj6cAOkwuyeBpMnZ5QRPiOPxP0KJqZ7KiWuawpj/1sV/24i3homGnlB4m9f5XJp'
    b'SZDMAljmVIL+QYXBnRatA31r+IwYpnWwQ4HPlPbAUFaGpNo5OtzRE7SoV0GviGEIZ9XjEDM7'
    b'4doPKkEAS9oXYujDjP+cGIaoVYC0QWyqEsFzD8Iktb79E25TlyyXIdolAAcrWPNJ3/O1KP31'
    b'IdKq0PHAeZY+bnjixOu87qDzZ2kD4q1xhLbqRk53rfOe5XXRp7jzJDEHsKTIpVGD0l/rAsC3'
    b'T36AmAd0Oz3u7NRWVtfX75I2QFduQzzL1U57+jDSsTaxNKYmwZLt8QuINNTtqsqH0EWQOs3j'
    b'8AsNBoenvXt5I8bn0Pdi6BM/RIlQKpe0ATD5kBqAlP46gO2uCqcYy9950De8kcLvEHMD22du'
    b'lnSoAWAOmDalyamw69ORGgDdmolBJ1T4FvyTHiQkbYKdJtfiFW6xj5h7I/7ew5DTWu1Vewsj'
    b'pt8JpAagThIDgFLaDGcin417OsdG2vr77vL27GVVGkcic0cq61wk4SydZCbqDYBu7fLtHwqT'
    b'+KaQYMfgzJQ6S3DPlcMI+HfIY/ssmSqXJuSwbuoNQDxTW80rltEpGw9sfEjVqemAYP2n/09H'
    b'vQGoWV9j295sgmPamZFH6g0Av6zkCU2Is6C9HYmq3r97wGjEg94Lhef67s7dTFSZ9u95oBEB'
    b'4E7vVohN0dlQvIXNNY2cquwJPhXD2cOsWav7C2O3hlqtKzn92C1Gkp83aQ8NV3pS285GwR9B'
    b'xnv/Kat0lv9DzhioSKk+mmcAT1Fr6eQJUUSOZfxNXqOwHWdV/PN1zic8ewRzADzbtCHKLZ7X'
    b'gDPBCbe8IUskc8io7YZf0iRiDAB3hM6ku2KWBYG72K4sOSlTFeCWcnhlz2IeLeEyv0sCLwkZ'
    b'e7vlWkuR/HL1Q86CgoKCgoKCvGFZ/wLTfN9xeSSi8AAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
heart_red_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABdklEQVRIS72Vy1HDMBCGd8Xk'
    b'Hm7MOAd3QNRB6ABKSAVACVQAHQAVhA6SDmwqwAfMcMNnGEusbMtIWJFExmYvHo/l/fbflxAm'
    b'NpzYP/w/IIN0ztjnpQQ8J3UpSNwhilwI8cjhvVCK3WdkIcTshkNRmVmxFGSQLJHBpnE8tEqi'
    b'XEPNKmTyfu8ZgRccXnf69x6gokL29UIf5oG6qAh9Zyopaq7V9oBnltxKgKuRiv6wFOVa+eoB'
    b'OS42gFLlfQyrCHBsA1jyEZGeaDgBmuANBcmW3lbRHvwHcwJwCzBmDSjqu1NRXluArkWzMRRI'
    b'gWe6Va05GEOFGb2lQE8ozYJS4Rq0GHGFFDOagZ9pHuyiLlXbAzqqmXRevz2ZkTiX3QH1cDof'
    b'pMgkZ7BY0c5RSkK217kX0NakWX6+zvI6DwIMiKsmQedRgBZykiI7UhDdXbQxgXq9zEP5i77R'
    b'unXe1ITWMe389vIJWTRAz4l6/r61fJA/AULRur5PDvgGkN6bGamx95wAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
heart_gray_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABdUlEQVRIS72V222DMBSGw+09'
    b'3YARygbNBs0ISFzEU9sROkH7hgRItBO0GyQbhA3KBvUAXPofBMgQwFYEtRQlxMfn8/8fH6Ps'
    b'Nh7Kxvl3/w9I03RfFMUTlD3iYyqKcq7rOsN/n0EQ5KR4JibXdf3Vtm3GuzJQEEXRvaqqX0ho'
    b'TljHqqqyMc8ATedisO7ouu65W98D2l39YGIvqAvtcCmGQa3Vqe0BcRy/YeHzGkWHwg/HcWzK'
    b'1QOSJCFryPc1BoNNdwMAFPxK2CMNB6DZPG/RCc8P0hmWAzMArDFgtRog8TsALwMAHVEU57KS'
    b'gkN3VAd9sNJJ6nc/UEAP1AtlWV5mmkgoDg7kmqZZfDdf3UWtVVRwUcONgU2n+77/zU9MXnY3'
    b'1GMy+ZVFPBn1oCNLSkRjNvkigCYllCwmFwI4yFRNhMmlABQUhqFpGMaJO10Mvw+e52Ui/6Tf'
    b'aO113tQE1/Gxu45XA3R9Qt/jt9YSRFqBaKdz85sD/gA0X7UZ/caCnQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
import_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABoUlEQVRIS8VVy03DQBCd2USc'
    b'0wCR3QFUkBwJXEwFKBVgV7LpAKiAcDHcSAmhgiypwEeECMOMP0rsrO01UZSVLFvW7LyZ997s'
    b'Ihx54ZHzw2kBrvRqrFR/BARB1il52RsNfxuuzhBtnuLIX9YxYe0gTYx9zUku3CjEJdDP1Aa0'
    b'B5Al7z1z4oFb8m0UEdy+RsP57j5rBzeztSaAsCsAx5s4HPq1ABP9GSJgEkfDx/+B4DIOzy+t'
    b'ADk175mWwHx2Bkl4XyT7ajsoVd0NJGH+pwgbUxV6T4MGELGq2DTJHkwQaCE2PWPupepv7GnW'
    b'YFrq4Hq2Zj0bVt5JU0igVwNO/sAxAQOUikZXAEkyj/xE3l9sYcUPgRojqrt8ANnWDSIXFaZO'
    b'QuQh24pd+lffSrvIhyRvFdlm05Rb1b8HIo+F8pjccWeRdztOHUTwIV4uOHeZ5kaRbQkKqrjq'
    b'BVf/QvArp6V5i3xzsMhMlceH3cql8kpMu8jFhlwP8bUMlstKJ7l6ksrGxhttoteBQhgRIIub'
    b'XjZyhFsnWWbEVslpr0wXbtpijt7BH6Rh/RkdlLcrAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
cancel_ota_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACNElEQVRIS+WV31HbQBDGd8+j'
    b'd3jLIB6UCnLXgakguAKcCoAKgArsVBBTAXRgd3CigugBMXlDz0l8m937k5GxLGtgeOJmPGNb'
    b'd/vb/b7dE8I7L3zn+PABABaKA6V+nxPhmOstvKSEJaIrv7inm30S90pkR0enSDjjICHw9mrI'
    b'4cTA42oXaCfAQq5RwZIPHgDBiivgbKkBWDcwUprBV/xM+4IcnuyCdAJEFlR/fkpw3jB3Lrsx'
    b'UHHwzfWg8hkBXPC/jXb1YVcV3QCVX/CDWcg8Ywm2g6dgJeZL9maMQNddnmwALHwqlFJnBDgV'
    b'3QlpYtZP931GRp/u2Ph7TY+Tl3v/AzY0j7vIrT8b+FX1AoKcz7tk8oC25kEWuATIqj5p2tBS'
    b'5WyFuA0rROD2rfl8WB7woI6uWJbrIZp3VSPVS0IAfzWMqECHX5NcHpCMGqJ5n1ztZ+KnyBsA'
    b'KpeWLMhlh0NlScHsKJ8iwbmcZ6NZos0JTwDLGzQ5MAbqcmiWJR7fAdKpFwG8d1paVn7zXJiW'
    b'B3Fg2CRN9ckQgE2zEoycJ2MtHI9R0ZJdvzSunm93EcCCK/m+r5KYfSHZ8mfahkRPtUx3aw4C'
    b'eV/2fCjJ+sxfFpI5e/ijDUldKXtfTLIfGrk9RUfJbmul4eOgltu6SZK2IXwxFuxNIT68+o2W'
    b'siSEb2ZdL2I3+kqCueFuejUgBvTdJ/cQIlVsrFQuV3jJLc9XeNW8CSCQ2E1nUVKB3ILLFmme'
    b'3gzY1xT/ABkkFyhU6ypQAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
factory_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABH0lEQVRIS82VzQ3CMAyFbYlI'
    b'XLsBI8AGhAlgAzaAShRxgzNFoht0BJigZAPYgBV6DygkiJTwUxIgRfTWFzefHT83CBU/WPH+'
    b'4A1AIyJ0soLzgCWQq3cvgPak3sDjcV8AAFos5jt/gIg0ZabbAiAEZYsD8wnoS0B6BUDIFjzx'
    b'BxiRISIsKwTUpog40wAJS7I5D28q6IzJUos60FmLSCot1C8AINZZfOjdAC4220mLUW0xV60T'
    b'1VYCsGvMFNvEnD4DKC2X2VBlM8PbNk1ZtGEAcgkIygDnOCEgNBtn0QZvA779hcgKzkNcTLI5'
    b'6t9urr4vBegFG0QndB9/rz9UUDnAlrnr+v/0wPWsdWVv98A7wPWMbXG/74Eto0/XvdzJr+An'
    b'1jHTGaDILiwAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
cloud_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABWElEQVRIS+WVwU3DMBSGn1GM'
    b'OJYNMkLZwGGCdgLYgFRKK26UK63UjgATwAStNyAbwAi5O8L8TnBQK7txID313aK89z77e3bC'
    b'6MjBjtyfTgAgUhpQFN0xxgR0xkYpI51/acrlsnxsU3xQkZidj5jWK9vY0azQWo8Bkj6QFyCy'
    b'SGDVrygctK0SkMQHcQKMFsb5R0jzH3ixXahL10LcgIynjJFRExzYxdw1kx2AuL+IqSxvoOb2'
    b'gHcnFIN/2yzK8f7LBiCmfIiHbQct+72cmirAH5z71EmozTdPamITakAWPUDLPFh4e2KOoV/V'
    b'dwaRTLlRI9rrwjO0polcqrUFmCMZh5cHZVYzsYB3lAyDyjokAYCRIK5nfIUtpR1qQ1KrOfR9'
    b'ihqwvXi/96D+9phh9xG5ViqRayp2bzK+QWccuup5dJ1JgZpPqH6hUj2b5s0x7WPJvh4n8Mv8'
    b'r75vimB0GVWdah0AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
star_green_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABE0lEQVRIS8WV3w2CMBDGr4n4'
    b'7ga6AWxQN3AFRzAR33nGRDcQJzBOQEdgAxmB95LUO7UmIH/aGoAnEnr3+772vsJg4IcN3B/G'
    b'BfDQ85F4QVe+ozOhlIrEsRS6vuJgHXopfuCOzXVZnsZy1QZQfzZ/lSPgK7zuYHJA9nHYeUbO'
    b'DtDeFhgrmFK3rq10BeRKykCcocBheCBg2QZxAeSoPhKxTKgp3884Y4zGuRFiA8C5hjuUMiHl'
    b'dcX8MN/gdp3qIDsAwFUr/wG8nRCgcug2AN0zw4TudEL7Eu8CIFCBhQt66Uu8KwCGHlMST0Gj'
    b'w+68r5wdmN5TkwI6E2roIEMHQeN13ZdQA4DAQajkZtxfpoFC6yWDO3gCC9GPGUIPuKoAAAAA'
    b'SUVORK5CYII=')

#----------------------------------------------------------------------
e2j_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAE5SURBVEhL7dUxS4JBHMfxMygbTCjs'
    b'DeQo1SQNRVBTNPYOImgRB3sDgjUVNQYthWAQLdES4ioN7dXg6CtoKJqivr/n7nnwSRSHexqk'
    b'H3y4/3Pi3XN3eJqkk3Ltt2t9JzXhisSjFfhcRTTen61gPLKIK1v6S+8ZTGPFlv4y7JCPcIdy'
    b'8GRTQh3nKKiDrOIJFdxiF1EGTVCFBtjDpDrIIZZxjEc8QEljCZto4hLa7r4U8WpLc4B7qC9M'
    b'B1u2DKK3XoMGbqnDRd/btmV8Bb0/tDNc4xQX6iBzCF9A+cCMLc2Xa5VPTNkyPkEe+lBZgPZz'
    b'HTvI4BnabyWLDbwET/EJYgkn0NvfQIeqnEB7rKU38I4adA5tvGEfXSgjXTPzrg2Tgw7wd2Zd'
    b'+x+/ie5vT4nGG3ZVeMn4/CcnFGN+AL3WNWKCnLKoAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
j2e_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAEySURBVEhL3ZU9SgRBEEZ7xb/An8wL'
    b'CF5ANBLFQC9g5A1MxEAXN9iNFg30BB5BEMyMzEQDRTBQzE0ETQRDA31fd83QLowO0r2BDx5V'
    b'1bs1RffO7LjcNCx+WkxNY8CS7GgHKXdRXq9vO8jOtJmNOzwNaVri32DEYlLiAaMWxSSu4ISv'
    b'fkZ98yH9xqLp0RFdhdSN4TW+++p3ZlG35LqvAkOotZavQANucRgfzZibCudQPONZSD0bqAGD'
    b'xV+FBmjqFN7jMsbsWuzlCN+wiQeo/le8wBdcQ48GFE9fVws9rFYYo95NnLF8AUs04By3UR/u'
    b'YcxHhcURiWO8xDY+aSFGA05C6vZRQzq+qs8Sqk/uaCEmHiAOUV/c8lV9HlB9dW7vPzFu9p/i'
    b'7FJRXi/7++D/vJMz4dwXiD1GdseRrBIAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
save_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA4UlEQVRIS2NkoDFgpLH5DHS3'
    b'wADoo/lADKJJAYVAxROwaUD3wX6gIgdSTEZSi9USdAv+QzWQEnQgB4EcBgIYluCzAGYZPg/B'
    b'9OO0hFoWgByBbAncXGpaALIEI4gH1AJyEhNJPqCrBQJA2+qhEQlib4AmSXRHkO0DkOENaKaB'
    b'ci4o3SMDsi24DzRFAc2wD0C+4JCxoB/o0gJaBhHIbJgloKCBRTKITZU4IDbJEoxkbJFJrOEw'
    b'dReADEMYB72ocABKgCoc9BRDrCUHgAoXAvECXBYQaxDR6kipWIg2FFkhzS0AAA+zORkpPFSg'
    b'AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
kernelsu_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAABRUExURSMYFSIXFB8VE2RkZHx7e3l5eXt6enZ1dTw5OB8SDhcREMvLy/j4'
    b'+PX09Pb29uzs6x8RDRgRENTT0////9LS0hcRDxoGABQMC9XV1RMPDq+url0oLbYAAAAJcEhZ'
    b'cwAADsIAAA7CARUoSoAAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCA1LjEuOWxu2j4AAAC2'
    b'ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAoAQMAAQAAAAIAAAAxAQIA'
    b'EAAAAFoAAABphwQAAQAAAGoAAAAAAAAA8nYBAOgDAADydgEA6AMAAFBhaW50Lk5FVCA1LjEu'
    b'OQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAAAAAAAAACAAEAAgAEAAAA'
    b'Ujk4AAIABwAEAAAAMDEwMAAAAAArIfcnPEIHlAAAAIJJREFUKFN1zEkShSAMBFCmgASCwA+C'
    b'3v+gv8RhZ+/6VSdCzEilDQBYt1xdeAyRiNLqbsil/s4k+wDyBIJPaC9In3POWx8TohEKC2Lr'
    b'+zGYuQYtdKjMPI69N8SCSpg4t6Nv56mXAmgCt3z/fwA/waYJtTzg1kREMaC/YXEWAIxW8up/'
    b'h4sKZ65icsYAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
kernelsu_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYBAMAAAASWSDLAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAnUExURSMYFSUbGAAAACUaF5qZmdTU1NHQ0NTU06uqqcC/v////728vIyK'
    b'itjz2rIAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABdSURBVCjPYwADRiUQUIZwmFzT0tLSm6Cc'
    b'WauAoAjK2QXiJNGEA7YniEEI7JKTu3fv3unEoDIbSM8BiygyqIIUrFSAKFcDcVbThKOObI9G'
    b'GTAsQqAcI7BLBIAsBgYAAw1RfHh0GLUAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
kernelsu_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAAuGVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAGAAAAABAAAAYAAAAAEA'
    b'AABQYWludC5ORVQgNS4xLjExAAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAA'
    b'lgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAAAGNdRzso9yOwAABW1JREFU'
    b'WEetWctuHEUUPac8M443QCzZHkdssCMESLAH1nwB4iEhBfEBQeE/gkT+ABBiAWwREmHFCrHg'
    b'BwAJCYIDAYck9owfSh0W99aj2z3jefioZU1X37516r7qVps7wy0AgAAABAAJAkH5IBDoPwAK'
    b'BESarIsTAh6DSc8kZD0CIClAAAkRgQQJ7gw3i6hrU5nfxgj6ZDRRFdUw+ienp3/8s1+9Nx/W'
    b'Ay5vDxUTIQIAIZuyng4A2bg1Cv6KWfHkeHxl9+o7195dHaxOMZGraaojSeD27W+/+/Kry8NN'
    b'7rqFukHQKdb2BsxTEEAB+P3u36+//dbHn3w6GAwaQjPj1q2Pbtz44OpwK2S+pJuCQkiTp+US'
    b'IGRX0lEcyAj0eitSTM/mRmBIUxefZGY0s8Dt0EItRggQ1eHX+WCvC0Yo+1UkAoCYidBIxZJx'
    b'VR6lXxIQLoIQC6EKhQ2QIvgMLBElExVAhnaUzQXTB4RqnZPUtceNhYTaLssZyOeoXFbBS56F'
    b'MECQCDZYxXgD7Ay2+eA6jVBLW4npUo8NkhpFqo6nZRlVMVRtEo5y67Obm8g6Ba0QJSGvSwtD'
    b'mZD/6oQSMqcW7MWLcxkDAIgi8wI7JzZ0PPI4a1h1AWTFAaTzgJTzeDJqm2WYhc57dTqcRehY'
    b'3+yKJTFOKRgLwNO+seLZS0rOxWU9VhC8lyB1JnPz3VkftTDt2ZwIAEhJaS+wbLaAAmXtBexZ'
    b'i5Rg1slBuAQ8kS2oUwzY9ASDSKXtN9HyTEwdhkrVNMvO7uguxOjrCXlhkrmOSAWwIAQG2zvN'
    b'IGkNovUej4ElKVkvZXuZW5yc3kHIm/Bm75QfE6RVtYXg4UCr1KTISCpQhE0LO1cEpQt+EQgu'
    b'qRBFgVwDTk6ODx49Go3Hh4eHo9FoNBodOhp31fjhyB+NxqPR0fgIACXubm8h8Gg8vrP/wIK8'
    b'l8t4bYFcuYDoEeRXH9jYWL/0xJPPv/hSCCtJ0rM2WT2bwDZOazctTEXht19+/nfvTi/0uHtl'
    b'eHp6/PTO1Wefe8G3ctNXpbo8+UqAhUCAUiR4cnz0048/jA8e3r/3X7PDKjCtNt4SMMJPXX6q'
    b'PxhQ4u6VrV///OvDmzevX38/Vl16O8cbKA00yYODh+9du/b919+sDzftkSz2c2NF355y/gCQ'
    b'cpMheNEBhGCDq6ur/UF/tcKlaShig8FgbW2t3+9bohnsjBIkShQY0/ZnV4SiYPeKUuaFCDvL'
    b'LgepTreiLpHwauuk8vyAWxKww4tFmBNa8hADWsG0wKLNm+psvuhFLF9pELYQAQgeYaH6nLAA'
    b'vJ5Ws7d738zpzMo9YbwaI0yL3ZmR0s/PAsxB2oR7zOd2kbwd2O3itTXDdrWi3iK0UTIcedbM'
    b'7CwCuPiBvIBew41Nyy8lnCeQqHEBFiouy9VkhoknQBdAiIlQbkNq17Slz0OuQ3O/WSHnlP1d'
    b'RlXuqdvj86KmYhnXzLPSeJ6D5LJZ5Schv984v9a0uivBGeRvZUuhWk6KgEb0tI8PU+AWalt4'
    b'XqT9UXmr6lI4C6vlvjIlyB1i3/iYYyot1ffQSagNeAEWEqRo1dVOU6696LQqBVZfTCfCN9Vl'
    b'CEGI0Qqaf6RtlZ9UqFqfvzMa4Z5d1i07C0gWBu6u1IE01tllHsZA1Znlv5exEIEYI5GDwQ5M'
    b'5yqUdbn2T4sszZ3tjQd79157842XX3nV1hSttzTD+9qrsLPTgsUqSfJoPP7i88/27+6t9AaA'
    b'HTTabJRPvE0EgGZOIFqc7WxvMoT9vbv3u1+ZCc9srK/0+ok8WyafxMYcREBSOVrtbG8JskW7'
    b'IllguU1kh51mRBJM57PUEEsgo8T6n1lu267oAWoLxRTG/wPkGO/4W1GZxgAAAABJRU5ErkJg'
    b'gg==')

#----------------------------------------------------------------------
kernelsu_next_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOWxu2j4AAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAA8nYBAOgDAADydgEA6AMA'
    b'AFBhaW50Lk5FVCA1LjEuOQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAAArIfcnPEIHlAAAApFJREFUOE9t'
    b'k79LG3EYxp+7C5hBzempZyBZFE6iWwIxSE8bBaeqUAgdM0YhDq2r/4BLmyFbkHKjbiKoBU1E'
    b'+kPpGUgOya4OCWSIqHhBz6dDe5LEPvBdvryf7/u8L88XW1tbElqkqqoC4D2AL8FgcK+7u3sP'
    b'QGZqaupDIpEYaK3d3t5uYwFgYWJiwtzY2HAKhQIty2KpVOLm5iZVVaWqqufz8/NLnZCrj8vL'
    b'yw+WZfHp6YmdOjw8pCAIVFW1GY/HP3XC71Kp1MP19fUL4DgOy+UyS6USSdK2ba6vrxMAh4aG'
    b'HqanpxdcWBkfH/9tWVZLP7JWq3Fubo7xeJy1Wo0kaRgGARAAR0ZGzhcXFwc8AN4mk8lIKBRq'
    b's+Tz+bC6ugqSkGUZJFGv1wEAgiDg5uYmXK/XZwHgc6FQaOv+P11cXHBycpIAKEkSJUni2NhY'
    b'BoFAYK/TvivbttloNHh6espEIkEA7OrqoiRJBMBIJPLNQ7LNOgDc3t5id3cXBwcHuLq6wvHx'
    b'MQDA6/Xi8fGxsxyZ1hFs22Y2m31Zlnu8Xi89Hg8lSaIoihRFkZqmZUQAP87Ozug4DgDg8vIS'
    b'6XQa0WgUR0dHyOfz0HUdtm2DJEji+fkZvb29kGX5pwggbxhGsVKpAADu7u4AANFoFLFYDLFY'
    b'DOFw+MWuO3JPT09RluW8e7+USqWa1WqV1WqVuq4TAHO5HHO5HAOBAAFQEAQC4PDwcFPX9VeR'
    b'XltZWWmWy2Xu7Oywr6/v1R4A0O/3N2dmZtZcqPU3/TJN0yoWi5qiKP5gMAjTNIF/wVEUBYOD'
    b'g8XR0dH0ycnJVxcSDMOQk8lko+WhAQCzmqa96e/vDzmOg/v7+4osy999Pl9+f3//bxwBGIYh'
    b'/wH1DZ+oAKIUwQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
kernelsu_next_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMvu8A7YAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuMgADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAADp1fY4ytpsegAABElJREFUSEuN'
    b'lk1oE2kYx/8zmUyqkRxUahSxHwmp1IZt3TCuksSJhBChLqYFA0IUPAmldcvuYUEv4klYgxhM'
    b'LgETSAWbmKAHLSiCeNCg22wplD1Ym36Ah4VgGhNmpemzh+28ZmabxR+85J1n5vk/H/PO+4Z7'
    b'8OCBKRwO/402XLp0af/y8rK0sLBg7+/vPwwAKysrf/b09LwfGBgoRaPRFb2PyvT0tElvY5w7'
    b'd+6HAwcOTAH4CwB5vV6KRCJ0/vx5slqtBIAcDse62+3ODg8PH9P7tyUej4uBQCAOgEZGRiif'
    b'z9OHDx+oWq2SoiikKAp9/PiRMpkMASAA1N3dTX6/P5FIJHbq9TTcvHnT6nK5XgGgbDZLnz9/'
    b'pv/j9evXLIjRaCSfz1e8evXqPr0uACAWi5kGBwdfHTlyhObm5vRabUmlUgSARFEknudJkqRX'
    b'169fF/X6OH78+B0AbcWr1SqlUim6d+8effr0idlXV1c1VXAcR7IsxzXiZ86ckQBs5HI5jWgr'
    b'U1NTTCiTyTB7o9Gg0dFRVgXHcXTw4EE6ffr0MQDgAWB2dvankZERQzAY1ARuxWT6uuJa50SE'
    b'jY0NNhcEAWtra6hUKr8AACKRyH4AlXw+r8lYT71ep8ePH9OjR4+oXq8ze7lc1rRIEAQCQDab'
    b'bf3y5cuH4PF4hgHQ0tKSRvBbuXv3LmuPIAgkCALxPE8Wi4W8Xu+PfLlc7pNlGbt372ZlfyvP'
    b'nj3D2NgYsNUe9ZfjONTrdSiK0s/39vYe7urqQkdHh879vyiKglqthsXFRcRiMQQCAQCAKIos'
    b'gEqz2cTevXv7eI21DfPz87hx4wYuXLiAs2fPwm63Y2JiAtgS39zcBHRVMDo7O38+efIkVatV'
    b'fXuJiKhQKLCX2DpEUSSj0cherMFgIIPBQDzPsyFJ0q+80+l8//LlS1Qqla9RtyiVSgiFQnoz'
    b'AIDn/y2+NVt1vrm5CbPZDJPJtMA7nc5ZANVSqcQeVB/O5XLs2uv14smTJ3j69ClkWYaiKJqW'
    b'6NuzZ8+emsPh+AMAYLFYpkKhkGZzq9Vq5Pf7WUueP3/O7r148YIAsLaoreE4jjiOIwB09OjR'
    b'LNQv+dSpU3cKhQJmZmZYxkSEZrPJrlu/XnXFtaugs7MTFovlN+YAALIsJ9Cy2TWbTZqcnGQV'
    b'hEIhevv2Lb17947tPdtlDoDcbndCIw4AyWRyp8vlKjocDhbkzZs3zEk/1O1ZL37ixInirVu3'
    b'tj94rl27tk+SpCIAevjwIdVqNbp//z5zVoXUZagXd7vdxStXrmx/4Kgkk8mdHo8nAYDC4TDl'
    b'cjm6ffs2DQ0NsSA8z2uqsVqt5PF4EtFodPvMtyMYDB6z2+1ZAOsDAwPU19dHoiiyILt27SKb'
    b'zbYuSVLW5/O1PfS5dDptu3jx4qL+hsr4+PihYrH4ndls/n7Hjh09RIQvX74sNRqN34eGhubi'
    b'8Xjbvy3pdNr2D8WTObhU0uCcAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
kernelsu_next_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAAuGVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAGAAAAABAAAAYAAAAAEA'
    b'AABQYWludC5ORVQgNS4xLjExAAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAA'
    b'lgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAAAGNdRzso9yOwAAC0RJREFU'
    b'aEO9mntMU2cfx7/tKZzS4rgJOCu4VMewRUAFqVNDWocw4+sFNlcZRImOZGImuHfzTabZsmzL'
    b'LDNzmMWYJZplYqa7ZJp30Q0WnGOAl02wig4JilzKZKMyWuwNfu8fcM7ah4uluveTPMk5z+U8'
    b'39/p77mc31PJ4cOHozUajVWn03nwCDCZTLKrV6/CYDCkdXV1KYkIKpXKXlNTc0mr1WLXrl2P'
    b'pJ+6ujrZzZs3IyU1NTUyvV7/UA/dvXt3dlNT0xK3253U29ub2tLSMqTT6RIcDgeICCEhIair'
    b'q2t56qmnuOjo6EaZTGZesGDBxRUrVvyk1+sH2Of5y9mzZ2USNtNfdu/enfTzzz//q6OjY51U'
    b'Kl1ss9nQ3d3NVvNBJpPB4/EgJiYGUVFRUKlU7Wq1uiosLGx/eXn5Nba+P0zZgL1792qqqqr+'
    b'/eeff+Z3d3fzVqsVLpdLLA8LC0NycjLmzJmD2NhYcByH69ev49tvvxXrhYSEwO12w+Px4LHH'
    b'HsMTTzzhDA8PP7Zs2bIP3nvvvWav7h4dV65cCSkpKTEZDAb3tGnTCICYCgsL6bPPPqNffvmF'
    b'Ojo66N69ezQ4OEgej4c8Hg8NDAzQnTt3qKqqigoLC8V2SqWS5HI5ASCO42jp0qXurVu3ms6f'
    b'P69g+38o8vPzZxqNxiaVSuUj3GQykdlspvv375O/2Gw2OnnyJIWGhhIACg0NJblcLhoSFRVF'
    b'a9eubSwrK1OzOgJi37596xYsWNDGcZwo/I033qDW1lZW25Qwm820ePFiAkAKhUI0Quhn5cqV'
    b'tvLy8o2sninx+uuvG3NycojneQJAarWazpw5Q263m9UTEE1NTSSRSAgAyeVy4nleTAAoMzOT'
    b'SkpKjKwuvygvL1+n1+vFt56Xl0c3b95kNTw0X3zxxYgBIb4GCEYsWbKE3n777XWsvklZs2bN'
    b'zNTU1DalUkkAaPPmzWSxWNi+Hwn9/f30/PPPEwAf8cHBwRQcHEwASKPRtC1btmwmq3Nc6uvr'
    b'Q3Nzc5sEX8zLy6Pu7m623wfS09NDP/74I509e/aBxn/zzTc+Bgjig4ODKSgoiADQ6tWrm2pr'
    b'a0NYvWPIysraERcXRwDoySefDGiw1tfXU0pKiuh+iYmJVFtby1YTaWlpIYxOpeMZIJVKKTw8'
    b'nAoLC02sXh927tw5Lzk5uV94+1VVVWxfD6S3t5fS0tIIo7OLQqEgAJSSkkJ3795lqxMRUV9f'
    b'HwnjjRUvJACUnp7uLi0t1bC6RbKyso5EREQQANqzZ09As01TU5OPeG8jGhsb2epERORyuai4'
    b'uHhSA2QyGWFkZjrsrVkqXOzatSupt7d3o9VqBQBs2rQJMpnMu65fSKUjjxweHhbzhGuO48Q8'
    b'b4aHh+Hx+O4niWjc67t37+Zv375dK9yLBtTW1q7u7u7mMbIlxpw5c4SiKREfH4/nnnsODocD'
    b'Q0NDGBoagsPhwPr16xEXF8dWBwD89ddfuHz5Mps9Bo7j0NbWxtvt9lKfglOnToXp9fpbwqAz'
    b'm83srzwlWltbqaioSBzEBQUF1NLSwlYTaW5uFgfxeK7jnTCyNtz+/PPPp4kG5OXlpc6dO5cw'
    b'OudPZW8zEXa7ndrb2+n27dtks9nYYh+OHj0q+r+3eNYAYXJRq9X06quvroLgQhaLJevevXvA'
    b'yECGXC4XjQsUhUKB+Ph4zJ49G0qlki0W6enpQcWBCjYbmGAcSKVSWK1WmM3mdAgGREdH6/74'
    b'4w8AwLx588RG/w++/vprXDh/AXK53EfwREgkElitVrjd7vkAID1w4IDMYrGkAMD06dMRExPD'
    b'tvnHqKqqQklJCcDMWpjg7Xtf9/T0JOfm5kqlly9fRnNz8xAAJCUlITQ0VKz8T/Ldd99h5cqV'
    b'AACe58cVORlut1thMBgipDqdLi0jIyMBAObOnQue59m6j5Suri7s378fOTk5AAC5XD7m7Xsz'
    b'kWHx8fGq4eHhVKnFYlE6HA4AQExMDIKDg8VKD4PL5YLD4cDg4CA6Oztx6dIlHDx4ENnZ2Sgr'
    b'K4NEIgHP8xgaGvJpN5FgFqvVilu3bg2LC9mjwG63o7a2Fh999BFKSkpgNBqxYcMGLF26FOnp'
    b'6di2bRuuXbsGnucRFBQ0RiB7782EZYcOHdIZDAYCQFu3bg14DWhoaKD8/HyC1zezdwoKCvLZ'
    b'57BzPrtgcRwnJqlU6pMAkMFgoIqKihXS+vr6S+fPn28BgNbWVjidTtbGSXG73aisrIROp8Ox'
    b'Y8cgl8shl8vB87xPkkh8IziTuYo/Ze3t7V0SiaRRqtVqkZiYyGEkdAKbzebTYDKICEePHkVB'
    b'QQEwGu8R8tl6k917428Zz/ODFy5cGNl5rlq16kvhp/71119Z75iQc+fOiS4SEhIy5puW/Thh'
    b'3YZ1HW+3Gc91JBKJGATQ6/VfQliJpVKpOTY2FgDQ3OxfYKy/vx/79u0DRt+891QokUjgdDrh'
    b'dDrhcrnEiBz7dv1xFfaeiBAWFgaO48wQDFi0aNHFqKgoYHR1FKbVyWhoaMDJkyfHzOMymQwO'
    b'hwMRERHYsWMHSktLMWPGDLhcLp/vi0DEC4SHh0Or1V4UM06fPj0tMzOzTXCHB22nh4eH6c03'
    b'3yQwkQQhurZt2za6desWud1ucrvd1N7eTjt27CCM7jgncxvWdQS38Xaf9PT020eOHPl7Ow0A'
    b'aWlp/4mMjCSMhgwnY2BggNauXTvGAACk1Wqps7OTbUIWi4VSU1MJwEOJ5ziOXnzxxU8E3eJC'
    b'tnz58v8+/vjjToxE5NDa2ioUjcHlcuHq1aviPRGJP7PRaIRKpfKqPcKMGTNgNP4dZGPdgs1j'
    b'y4V7tVrtDA0N3S/kiwZ8+OGHV2NjY48FBQUBAD799NMxy7w33oPKm8n2/grFSNCZbcPmseXe'
    b'91GRkccOHTokniX4bCWWLFnyweLFiz0A8M4776Cmpsa7WITjOMyePZvNBgCcOXMG/f39bDYG'
    b'BgZQXV3NZgNTEJ+cnOzRaLUf+FRg2bJli2n69OmESQJbHo+HXnvtNcI4n4EAqKKiwucz0m63'
    b'08cff0wY9eGp+LyQlEolGY3GyQNbAHDjxg3F+vXrG4WGubm544YWjx8/ThgdxOziBIA2bNhA'
    b'x48fpxMnToh7JKlUOq7wycQL1zk5OY0//PCDfwcf27dvV+fk5NiEhxQVFY2Jb/b09ND8+fMJ'
    b'oxs175VVMMI7ec86/ooXkl6vtxUVFU3twGPv3r0bdTqd+JDxwutCaJzdEvg7TfojfuHChfTW'
    b'W28FdtDx8ssvGzMzM8WHxcfH0/fff08ej4eIiJxOp7igPUg8K9wf8RkZGbRp06bADjgEysvL'
    b'N2ZnZ4vuBOaIyWaz0Z49e8SyRyVer9fb3n333cDePMvOnTvVa9asaQwPD/fpxGQy0W+//UZ9'
    b'fX104sQJWr58uU95IOIVCgVlZ2c3FhcXT83nH0RDQ4Ni8+bNpoyMDDf7tl566SX66quvqLKy'
    b'koqLiykhIYGio6MJozPPRMJZ8QsXLnQXFBSYzp07599sEwhlZWWap59++rBGo3EEjx4BCUkm'
    b'k1FSUhJpNBqaNWuWjwETiZZIJJSYmOjIyMg4vGXLlolj/xMw5ZN6gVdeeUVrt9tLW1tbszo7'
    b'O2f39fVBCM0/iLCwMERERGDWrFntCQkJVTzP7z948GBgfzWorq7WPPPMM/59xYzDqVOnptXV'
    b'1S1vbGxMv3///vyOjo5klUql4jhO0dfXBwCIjIyEx+MZ7Ojo6IqLi7uiVCrNKSkpFxctWvTT'
    b'Cy+8EPCfPaqrqzWS999/PzslJeX6s88+e4etECDSysrKxN9//31mW1vbEBFBrVZzMTEx3YWF'
    b'hTcATBzFmgKnT5+ON5vN2v8Bi4S2yQSV5yIAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
sukisu_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOWxu2j4AAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuOQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAABMz8BIJY/XoAAAA2lJREFUOE91'
    b'kztsG3UAh3/3v2fuzo/YsRM7sXHcRGkABVCVqE1RHwyEgTK3QkJCnWBAQgxdeAxlYmEEMYAA'
    b'CXVgIFGQQAwUitT04UYWNG0T2/EjiV/YvrPPd747+38MSAyR+LbfJ/3GDzjG5voPZzY21i8e'
    b'9/8Hc2zzu492spGA/8T21r1Pb+08ubG4MK+MXAemptWuvv1W+Z1rHygvv7hyrpLblzObv20y'
    b'AHD/o+sxdjIS02aTayfnTnysiiIZMCx4RbE9OiJD14XeaAycXi8TmoxOmoa5ONwtHz3czb/C'
    b'bL3/YXzuypXrxKecrR8cLQxZgrnFeQiKD6auQxBFOI4DBoDRaoI6LkaUYvikXLn9R2aNzFy8'
    b'cFoDPZ09rKWYiRhiE2FIivrvWZLAchw8zwNhCSLJJKgggFNVdEQyNXP++WVCBCHKSxLdKxQ5'
    b'Sh3IkgBb14CRC14UYA8sCDwPapoglGI6OYNS24Q2Ps2Hgr5VwilKutFuy1ZXJ4rAwqMe+rqO'
    b'fGEf/a4Oho4gCBxsy0KpWIHjDvF0ehotKYRbbeISj46QTKVx6dJrTCwehzscolKt43GuiFqt'
    b'gTGfDx1NR+GwikbXQq5YxRgLcLYBjVMEwkpSmOdYY/dh1tM7GjzqodlsQrl/E/mt28gXisj8'
    b'9DNKd+6BuiYWUjEMWh0YlRwVD//6kYAhnmEY/PaDDMrlMkAYJKbjeO7CKlZWVzARGscsb2DW'
    b'2kNQ5OH1TRTqGvrh1KCqJDpk0GrdHdmDaDyRYAjPo1qtodZqox+ZBzek8DeqeOrcq5BfugzX'
    b'GmB7O4sjw0FKQjfyd65H+r1eQ2E5ee3UMuL+AELjQSRn4gjFo/iz2sQRWBz0B2hbLnhRAhEE'
    b'nEmO42xCkZZPJiQCjiWM7cBe/wVs6QCW7ULiORBJwaOxWdwsd7Gx04DJSlDDQXgcB05RQQIB'
    b'WQ4EZFL/7vs7tutko1cvI7DyAtqdLlhpDFXdhucLo8P6wYoySgii0jaRmIpCUmVYtj3QNN1g'
    b'v8o+6L3+7NIeG51Yqu4X63ePjKZPEZSD3oi4guIxQxuCpXuuP0p7NnVivNOrtdv5SuXw98+/'
    b'vvHlfzVeA6K/Atz+G+/hzfRUWp1bUkVZZW1DZ9CpMYbopxwdmafCjPnuJ5+Vzz8z73z7zRet'
    b'fwDLnpbvAJvwGwAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
sukisu_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOBtp6qgAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuOAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAACrgCETU544KAAABqlJREFUSEut'
    b'lVlsXAcVhr+7zL2z3bkej2fG23ip7XHipCGtk9C6oXEJW6mARg2hiIqlIJEFkCACIVVIvIDK'
    b'QwVIFVIDagtINLygpg0CBeLQNEnThGZxnMVOvIy3mbE945k7+8xdeKAPaR4qHvjezn/O0Xn4'
    b'dfTDhxO6V/i/8cdXf/+zqRsT+TePvXEU6L23/78i3Cu8j3TpwrszDww/0GXlDcavjCd//suX'
    b'Dsa3DK1Eoy1BVVFclVKpsricSr/wwvMzgAFw8LuHd3x698dG52cT3ZOXr7/24h+OnLn3gAA4'
    b'P/jRc986+My+3/R1dbryqxmMeh3R58evB8BxMBsNHMehsLZmW5XK4p3ZxJuhUPPGvo2DHy/m'
    b'Daxbc0zNJF76zOED+wWA74Cy/7cv/1jr7d48M3XbFf/sp55s5A1USUTQNCKdMQRRolYqYts2'
    b'ZqOOIIhk1zLU8+uEdJ1gqJmcUWD83fd4qKmVi9PTr+w89I1nRYBvH/ndc/F9ez/XNjo6sPWJ'
    b'x59cGp9kfHYJfzRCNNaJIIoUc+vk17O4vV4k2YXjOHT19xEbjJMpl5m+M0PWMBja+VFS9TIF'
    b'o5AGEP8CHW0jD+9ezK1bp0+N9WYkN96+QbZ2RPA3N4MjUCkUqJZLhNvawXEQRBHbtjHWs6h+'
    b'jf5NQ+D1IqkqzaEQ2XoVoTO8G9BED7hlj4flpUXf5EJav3Z7ltbOKD63G6dWo1GtUC0V0ZtD'
    b'CJKEaVk4to3idmOWyzTKZXAc+jbEsS2LS9dusVRv8PDItu1Hfv3i50X9wPe6ZK/HtWloUy7c'
    b'3GQVMiuYZQPR5cKyLGq5dSTLfN9+m0atitmo41YVXJKEVSqCIIDj0N3bzVwR1nq2USyVCema'
    b'Xwxs2bwRVRWPvf5614m//02q5DMEdR2rXse2bWiYLKdXWZyfB7NBKZ/D61YRBBAFKBlFctl1'
    b'AERFZedAGMvtYyxtMnntUlI6tGfPaOvwgwO4VK1nw+amrRv68Xi9CLUagiRwZzZBIpXGNE1i'
    b'sU5UVUVWFBr1Opn0CvMra8wlV7Esh5Cu4dd85FPL5FoGWC7Ur4hmuVJyTFNo7+gUBuNx4vEB'
    b'tEAAQZbJZNapO2DVGySX06ykV5A9HpBlUqk00wuLeLUAvff1cW4iAbZNKZsjY5Qppxeo5NfX'
    b'pO9/7etPhbd+pKNcLPL22D+jlUqFtkiUajqNYduMnTqNvZRi+dJV1hwLr8fN3EyCsZNvocou'
    b'rl6/SW9XG49uG0KyHYqra7w3lUAvLS7+cP9XD4qS16MjCFatXpOadI07MzOUCgXAIRhuYbi/'
    b'myealvhSLMvWeD/R1laMVJLHcnNsSs6wduotAnoAlyzjVCpgm7S2hLicZQEoio1CMQtImbWM'
    b'5+TJk9y4PsF6oYDtgCJJ+CIRqg/txXz8AD1DG/DrAfoH+3F1K6jKHYY/OYJsWdh5g5XVVc4n'
    b'smRb+gj3DMgAYmF84p1SOu0O6HqoKxYjPjAAwGIyxdi/TpM3ipTqMsGWdtTkMvV3zhA2LSKP'
    b'Pkt9+zdRY734RZGJW1OcOHuBRbkZpVakMHXlOoC06+zbq9Ev7nva0bQ+r88nhCNhVI+XoCzR'
    b'2dVBMpsj0tLM9OwcitdLk64hR6KowSA4MHl7mtTKKg7Q09HGjnY/W4IulJpx+dWjR4+JYfAL'
    b'quoJa5qwvbuX4Z4+Iqobwe2GRoPBvl56hwZp645xbmaBSVNgMr3K+asTnL9+g+YmndFdO/EG'
    b'/Ni2TVDX8WgaWkvoPvjvr8iiooiVpaSTOPwLpg/+lOq1m9iSzK2Jm+gBDcc0Wa5KJCIPcnV2'
    b'hfmFRY7PVjAcDztGdmCYJuvlCrV6A9HtBs2P4vNpgCC+Bsvl+YUFtavTDB96msDeTxB+7BF8'
    b'soRXD6C4VQyjwFTNQzTcwoLQxE05RrS9k1SpQWJxmfMX/k1fbzedbVFQFRBFbMtqAI74CtTS'
    b'f/rzr3ILC0bTrhHav7wHQXExdWWCZENEkWVyxQpFZCRBQFZU3PkkGGu4Yhs5m3Vx/+YhzGqV'
    b'lnALNlAtl8kXCjMAEsDLVy/PfqU/rqLro4osC9NnztUu5m052jdAqwdurlRw60Ect4YgSehC'
    b'A5dLQQ61oYdamFst0SVVCbZGuHh5vFYuleVLV6795Phfj09+IDJPfGHfSKor9sytsxffuD3y'
    b'iLpxw+an2sgPltru93k8qmy6fGKlaAhKKYNZKlDRwjiiVHOM7NquTo/PqFaPHzv+j/Edw1sG'
    b'Dxw68DwfEvr34gLEu+bv3jOBxl31B/gPRHH1HRiqQZ0AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
sukisu_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAA0GVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAGAAAAABAAAAYAAAAAEA'
    b'AABQYWludC5ORVQgNS4xLjExAAAFAABAAwABAAAAAAAAAAFAAQABAAAAAAAAAACQBwAEAAAA'
    b'MDIzMAGgAwABAAAAAQAAAAWgBAABAAAArgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAA'
    b'MDEwMAAAAABFTO0LpE0megAAF8BJREFUaEPtmXdwXueV3n/vLV9vwIfeCKI3kgDB3kWRElUs'
    b'WZa0kqy1imVH2c1q18lk7Z0k6x3vrpzY8bhlrbUtObbcJMuUaVE0KZGUKFIsYidAVAJEBwF8'
    b'aF9vt+UPiJy1xjO7SiY7k5k8f7733vee595znlNe+H8c4qML/xL8/d9+zakb5obwYnzo2999'
    b'fvSj1/81IX904Z/Dc889579xY/JQMBj8a93IPlNUWFKrW44LC/NTsY/e+6+Bj00AYXv6jx7+'
    b'1J8++2+fYdOmtfbSsrI2CeOJyqraVNfVjnMfvf3/Nj42gdVrtzz/2Sc/XV2YH8RhU6mqKGdV'
    b'Y5NLz2p3Z1Gb9tx9z7vnzp5OffS5/0NU5tWvb9+2fmP1mtXtka7uzlv7f9wYEM/9+V9e/cp/'
    b'+VJzTsCNkclgpVIokopmCU6dP89Lv3z1wviNme/qmlbn93nW6rpu1w0jlhfMtaVS6Wg4Eu3X'
    b'NN1YuaJZ+/G+w2f1kN4BQ7MfeY8NWLN7z/0PlFVUbG9pamjM9wc8w30DzM7PnhhXsrve+P6L'
    b'Gh+XwNbtd92/ZdO6X3/5i/9etQkdI6uhmhIAC+EwA+Nj9I6OkJdfQGlpKT6vF8uy0A0DVVXB'
    b'gkw2SzqdIZ1KMTk5ycjY2GzfwEB3LJn8yfGu/rOtBYWPNDfWP9rauqqhobGR8soivG4nQ5c7'
    b'cSSyHLnQEfuzv/lSHTDNxyHw9COf+1Z+ZfEX3G4n/+HZZ3AJA0lIxBJZert7iKQTVDXWUlFR'
    b'jupwLG1tmSAkTE0jmYjjcLpQnG6srMbY6AgejweH08nUzCxnzpynr68/u3PrJltLSzOFJaWg'
    b'KGQTUS4eP06JKSjPKeCnx0/y9A9f2M749RP8IQI/u/Oxdfkrav/M4/FUWFra1JPpi4fmQsu2'
    b'3nPXw6vXrOCVfW/y7GOP4bHLjIyOcqWnl7qmRuoa6lEcdjAMsKylrQUkkkn0TBbLsohHY+Tk'
    b'BXG6XPT29DA+OkY2pdHc1ERZaRGmruNwqGBaCNWOpki8ffBtvLEsG5bXYEfws5MneeIfv7uL'
    b'GyPv8NEg3rvnyc9XP3jHb1Y9dF9b5e1bKks3rVueFtamnOnp5p0P3YnX6efi5U5WtDQwODDA'
    b'0PQ023Zsp3x5JUISWJaFsAAhYVkWE+MTZDSN/IJCtKyGx+tlbm4Wt8dDUVkZ1VVVBPPy6O3t'
    b'YXjoOiUlxTgUFWGAblicOXcOp8fH3PQ0JR4/LsXG5dER3ug4/yMi4dHfI/CjB5+8rX7Xpr3t'
    b'jz8iOUsKwOEgmTHQ3F5KKooZOX6OkxM3uNB/DdkykVSZbTt34PZ4sEwTS1hYQiAh0DWNoevX'
    b'sYDyZRUISZBMJLHb7AhJIpVK4XK5EIDb56aquoqsbnDmg7N4XW58Pj+XOjqQHU7Wb9rExPQU'
    b'WjxBwOPl7MC1hUMHfvO3QAJgKQKBgvyiz1XfuxPhd4MJsmkxPTNOXsCHq2oZybRG7FIXNocb'
    b'm9fL1h3bUG0CyzKWHFGSkCSJrJZl6sYNJFlmeXU1kqKALGNYJpYk8Ph8xGNxME0AdEPDkqBp'
    b'5Uq2376bS91d/O7IYWZjMdrXr0dWFbbu2U1INhienWEuHjWpKrgloxLA/4TcvKaK3f6SMgQW'
    b'8wuznDlzBk0zWYxGCCWg+vNPseX2HdxmGezevhFLUTANCUMILFlGyAqZjEZkMYZmWJRXViFs'
    b'dkABS0HLGghFBUUlMr9AeHYeJJAlBUtIGMKkoDifO+++i6SeJa+wAMW2pFzRRAI9kUZSVMbm'
    b'5vMe2/zJL90kIANUgHvLU08+V9DS4kpnM7z33nt87evfwO1yMxoKUd/WTtphQ5HBk0iguly4'
    b'C/IxTZAUGUlI6JpGLBIhm8rgz8nB7VuSUCEJLMMisrhIIBgklUxhZrJEFhfx+r0oNjuSrCCE'
    b'hDBNVNXG8qoqOq504HI68efmQCZLaGCUucg8xfU1+D3urZKwnRi83j8iAUTBRAgTWeZqZzff'
    b'+tZ30CwYnwnxg+/+I5HQAtZcDFfAS+WW9YQ6uhHGkowKC7As4tEoNpsNXTcI5OaCEAghwLLI'
    b'pFMIQEgS4bl58gsLUVWVuekQlimwkJacQchYmLi8HrZu3sKFMx8QiywwM7fASGieS8NDbGht'
    b'YcemDQT8vidvudCe9k8WGpblwzJob2/n+ee/SlNLC5/9/OdYsboF08ggpxLk5eUi5/kxInFM'
    b'U8MUAmEKovOLqAiii2GCeUEALMPAMk0wTRLRKA6Hg1Q0ipHVcPt8qA47VlYnGo6AxYd5AywB'
    b'lqGTm59HW2srh958mxdeeZ2DPYNkLSjLz6UkP0hRQUHL8ZE5SQIILC/8hLOgxA4CSRZ43B4W'
    b'5uaYGhtHWIJXf/5j9r/5OtmMgWzZsewChECyLLK6hkhnkVIZ0okoHo8TjCzC0BC6hmXoJONR'
    b'fF43czduEMzLAVVgdzqxqzay0RhGOgl6FsvSl/4oADoV1cvoudaHvbiJtoefISHZyeoGfreN'
    b'gqKCyvNvH8iVAFwNFXtK6+qwxJIoFZeUUF5ayulTp9i4fgNaOsOaNWux2WykwxFsbhdCVpEE'
    b'JMML2CRBOhnH63KRSadvWgBCkEokUFWVRDyOoip4fF4wDKQP84bLqaJpKRA6oN961LIsZJvC'
    b'bTu3E56bp6BsOfbGjfz2wFtohokiIyxTQ/oq5Dry/M2OoJ9UOsOvfrWXF198if7+fn69dy8v'
    b'//SnBPOCbNiwHlVVmejrIbe8HENS0E0TI51GttuYi8Vxe3NYXFxcch2xlOQjC4sIIBKJUFRS'
    b'/GGWBi2rIYTA4XQtKZSkIGT1FgEATItVzS0o4SmisRgrN26jI6Hw3tmLJNLZWK7fl5FiIKle'
    b'p2wpEjISiizzwj98n8KCAspLS6mrrcEyTWKxOAAet5NsOo2QZDRdRxIKg+OTvH7wCIawsbAY'
    b'xrSWND6dSjEfCpFOpSguLUXIH6YdIchmM9hsdiLhJJcudXH5Uhe9PQNLgX/LfhN/wE9jaS6R'
    b'0AQ4bLTecR+/OPw+I6OT3c98+pGYlAWwEFgmdoeK2+fmoT96gIcefhhJCP7kT55FCNj/xhtg'
    b'QcnKVuYHxhDJNFY2Qyqd4Uc/f4XLvf10Xu7gZ6/sI5JIggzxWBRfMJeyymXYHHawwLQsFsNh'
    b'orE4druDo8ePc+z0BV7+9QF++ev9zMzMIVQbQkiYmCBDW1szU92XkCwdb34Ba+/+JMlk1AKQ'
    b'HwW5+LZdny1ZtSogbDa8bjeVVTWU1zRQUFZJSX6Au++6k/raWlRFQbbZmevtI1BVTlbXOHDo'
    b'EP7iYpwuJ6WlJRw9dpz6+lrKyktx2FUCOUEkSbrlOkKS6ejs4it//zVqm1YyvTDPug3raGis'
    b'p39ggEs915mfn6fAH8DjdWBaJkX5+aSnh7l6tYu8inpyissJjU8V1TvNV6W/gNjiwMhgZH4B'
    b'AJ/Hi9Ppwuf1sWbNGnxeDzZFwut2gmViLck1YDE0MsHw5BSPfOqTrGpq5NzlK+QXFXL6zAVS'
    b'iSxCVpYM/9B4hMBEcK1/kO07dvL6wYNcHx2jrraarRvX0L56FTFXMRemDX78y/3ouoJkSaRT'
    b'SepqaxntuIgZj5GORtAzaUdFc5tLevG2u90Oj7fa4XJhWqDa7MjCYu7GKMn5aTwuJ0KSwTIR'
    b'wkLPpjASUUwkDh07yerWdq51dnOtq4upkQmKi0uYmJ7l/IVLCEVeCmZJAixQFLp6eonOzfNv'
    b'nvoM7SvqQQi8Pg+GqWMYGpPXe1iYGKS9pQ4pk0BkdI6f+IBvvnKQbQ8+xcL4GAdf+ibZ2cH/'
    b'9NVvfr1HfqJ1Y33RptX/sWLDOll8WJCFIxF6urtYXJgjFotjaAZerw9ZUYiOTJCanid3ZSMH'
    b'336Hw4ePsvftE5ixGRqrG7h4tZveiSkmrvfStqINu8PNzPQMvpxc5mZDfP0fvk9RXhHjwyNM'
    b'z0wzPnaDvt5BPrhwmqGeIbasauDR+3ayuq0FUkm0dBrF4eHi1V6mpyaodaXx22U8/sDzx949'
    b'Mip/et3mlWWrW54ONjUuZUQBw8PDfPGLX2Rufo4333qLq1c62L1zJ7Jmcu31A5RubcWRV0DH'
    b'hW4qWxqo86vsjM6w7ZFPUSXSlPSPcTGT5vrQJD3dvez/3Vs4nE727XuTS+eucnV4BJchs5BI'
    b'0DM6QmtlIw/cvp177r2DtvbVBIO5WOkMwjCYn5nF5/GQDM9x+tRptm/dzPz8Aolk8gcnjr87'
    b'KY3/4rxpt9vhw+RhWWCaFlu2bOHLf/1l7tqzh9raGkxzqaZJzYVwut0I3aC8rIQ7d97OMiGx'
    b'OrmI/dRhmoavcI8U5hNtK3n66YfYsLGNv/jCnzIzM01hWQl3O01eePRuHtyzitL+HmyZJD0T'
    b'1wmWFeHMdYFsQjoN6QzCEkshpKXZuWMbXreLV/bup6u3vzu+MHUZQCrYWS1uNpbWEgsMw2DD'
    b'hg309fUxMjBIJBJhdHwMV0GQ3DUrWOgdQzEFBaU5zIyNkTQlpHvWkVMjkbulCXljLQ5UapdX'
    b'sHnjKmqWFfDoQ58gV7XYlR2l8Ny75B97m/uVLHvy8kgZGZLZLKZmgKlhZlIIc6mfRpWYiyzw'
    b'09d+zbI1m3EXlDA7Exr51v/4XhZA8pXkxROROOhLHZVm6Bx95yi/em0vX/6bv8Pj83P67AV6'
    b'+6+hGzqBkmK0ZBSwKCsIsjg3S8WaVg4u2PhxX5qfD8Y5mHVTvX0NNktG13QswyKVzjDe14dv'
    b'1xZcmyoJ1rrJacjBF1ukbtkyXE4PY8OjWPE0pmWiCYNYKsrgyDATM7NMRwzWfeIRlrWtJRmN'
    b'jSx9cpBjHecia7ds/+PS1lV+FIVEJk3nlU4mJyaRZBlFUZidDbF79+34PB7i/f1IKsRtKoXB'
    b'PM6e/4C1bStpW9lOdXUTNVVNtKzbSFVDA5KQEUIGE2woyC4fHQsaVxejzJsGGW8O710PsfGB'
    b'h/CpYLd0vHY/pgW9g9eJp7K89KvDdMQ0ypvXUrG8DjSNrrOn00OD3T8BkPsh+3Dzqu0FLU0N'
    b'joCfxXCYeCxO59UufD4va9asJhIJc8fuXXh9XmYHRgknUvzVD18mFkkyNrXA7NgNGkpKCDpk'
    b'7A47Pr8TsTBLamKE1MwU0eF+sqMjLKtZTl19HZXlNcjBKrqSKidHpgn4fdQVBSgtLAFh49iZ'
    b'M7z4i1dBsmHWrGXF7nspXV5DZHGBoUtnmejpfnFoqOd9bnZkjy6vt8lFBQ/k11QzNz9Pfl4+'
    b'nZ0dKLJMOBwm4A+wfetWArkBQlOjDJ+7zN2fepizVy7RUFWCsDs5cvocs9E4M7EkvoAfc2gM'
    b'dWYKW1bHZWaRZsPEZbDZJBzpDEG3m2g0zFunLrB1ZRNbNq0nk4V3T5/h6NlzoNo4efIinpwc'
    b'ZkdHmO+4QKTvfab7r4Yne0aeHp8dSdwisLZQ6rebngcKVzQXpAydmekp5ubncDqdeBxODMNg'
    b'ZGSYupo6HC47gcUka+/YSuXySrp6rmFz22lf20Z4NkR1RQWHTp6luWklQtERsozIaiRtNrxV'
    b'daDaUZFQZBUNiWgmw7333MXUdIifvrqX/W8f5ak/fpwtrU2UlBRxz6YWNlbmsbWlmjs2b8Dp'
    b'VB1vXrp0MjQ+1H+LwNtDU8ZTO27/TNHq1jJdlohHo3jcbhobGqhrqmN1WysrVq3AkgQuu4v4'
    b'tRECRbkUVpTTPThMS0sT61e3UlVeRp7by5ETp4gDzVs3I/u9ZOx2fDU1SIEcJEWgOhxEdPjB'
    b'r15neCFM37U+QjPT7LxtG+vb24iEw6xb1YRpmDTX1RP0+/E4nciyQlrXOHX+4rWha73vcbOl'
    b'/AFSnr8wrxZVQgjB+g0buO/++9lx221s3riJttWrqa+tBctAqAr2vADJSJR4PIaESUtdPaoQ'
    b'+AtySfts3HHXHq7fmCaaBClYgrOqAcOfR0qoaJZKOKlxbWSS0fF5yt0eHtm1m3/3mSdY3dSC'
    b'y6YyPDZBKqNh6BqSYWIZJoZpYloGhUVFNNbVtN1UIQWgD5MNbpdlSUs9LpaFHk0slS9ulfTs'
    b'AqrdTl4gQCwZR/HaMCWZ69MhygoKcCsKlqmTlUxygnnkByKcOHOcRCJKMJiHy+1Ez2ZJJVOE'
    b'oxFsqsraDetYv30t21ubaa6txjRNwEAzoXtgmJlwHI/XhyUJdBNMAbKq4MvJobiwcOOy1i25'
    b'o1dOLkgAXpYqRYQMpkxqfJye77zA9e/8iIn9Rxj4xvcZfulV1Kwgo8uYlsX0zAzTU/OUl5ei'
    b'W1kQYDNtZGJZfrnvt6y87QECK28nKvvYuWEdj927h8KiIuKuQhbVIMHcPHICXrIZDWxOcHvA'
    b'62ZqcZHegX76B4coys1FWBaWLFBcDhSHHVlRyfH4pdErJ6VbLtRIPeloQpYVCc3KEOkZwNYx'
    b'gjx6g+S+Y0jxOEb3EGJhEY/NRnhyhsudVzl67BiBnBwkRV4qo4TMeyfO4m3cyI6HniCvton8'
    b'0mIudnbSPzRELLKI2+uisL6Bty70sO+1d3B7/eB0cbWnn9m5RcYmJ9m1cwcTY6O4nE5My0J1'
    b'OJBU5abXgLVUNNwi8Bj9c6Gx8cvE4pi6jpobJON1kbUMLKeMSJnItWVIJT7yg37MpMHW++6j'
    b'vqkBm9OOkCWELLEQWeTIhS6q2zeTUhQkBbr7+3nt/Q72fdDHYDhLZGyK2eFhZkOTVNSVULZ8'
    b'OfOzC7zy2j72H3ib2poa2tpa0XUdRVFAEghZWrJYAtMwSCQSEpSLWwQA4oPDL0yd78SuS0g1'
    b'yyh99tNYhUH0tI5SV0nh4/di9/mwkgmik1Psf2M/yWQau9OFYZkIWWImNINv2XJ0VcUGTPdc'
    b'pKqhmcf//K8oXr2TFbsepOnO+9m86xMMdvZTWVbMwNAQr73+OpKsEI3G2b5tG5ZlUltbg5AE'
    b'QpGxxNKoHiEwLIt0Oj0D41H+6XT69b6u3j2ewvKcktzVSZ+HsoZGAu0NeNobCe5chysvH5CZ'
    b'7+rl3Bvv0O13UlpYTvuqJiQ0EDJXugZJuQoIFhbgtKmYGY2FmRCyDbpPnmL66gdM3bjO+GAf'
    b'DatWEcqYjC9qRKNhnvj0g9y5eydCknj/vWNsX78Gt10Bpw1LUdANA1kShKMJDh0+8v7Zs6d/'
    b'+Xt/ACASCf3XqVNnsmY4xGQyjC03H29DI3Z3DroqkQ2Hubj3TfR77uC+x5/G4ZGQhIWwBJpu'
    b'MnQjRGFpOdFYDEWG6uoaigv89Jw5Sp5HsKKqkBUtLeQWlrJm133Ub7uHsrb1NG6/g/2H3yGl'
    b'63T29VLi8VGYk4vptCNUGwuLEY4ceQeEwrVrg4yMjLx/0+bfI/D43l9cD3cO/Wft+GWi1wdI'
    b'ZjJYgKXKJKan6dt7gJ5YlJZ77iInGMSlmSgsTZhj8SSziTTFQT+paBhZgGxTaNmwlarlLZQ3'
    b't2L35OKxyRTm+5mbGaeyKJ/QjRDVy6pYvW4z3/veSxz93SE2bVoHqoRsd2NaEgcPHcbu8JDN'
    b'Gpw+fXZ2//69r/5BAgD3/vYn35js7P3Lmb2HtKHfHSbaf42J989w6ms/NM91drIQCHDu3eNM'
    b'hWa5EYmRSqUBiaGhUZbV1lFb5sEja5jZDDa7QLZMRDpLWXERlmmRjKcoKixiZmKUXLdMvt9F'
    b'LDZPTWsLgapaNrWuIaekENxOUvEMR48c4+WXX0kvW1ZFR2cX7x078Xc3D/j46BHTTfz80gen'
    b'H1yzZd/Mlb7F9w/8rrWzp88+ZpfDNwKeJ2fDSXHh+HuJbDyS39d/TRZGhkgkzusHjlK7cg1p'
    b'UzB4fRyP04FsaiimSeeViywrDDIbmkLPZkkkk0QWF/H7AqRjMa719xBZWOTkkbdY2dxIIpXh'
    b'7PmL/PaNAzfOXbz0ZQtrwOG0bzzx/smTP3n5peeApcnZHzrk+yjufurRZq+wP1tcWDr27f/2'
    b'1W/cXH/i0Sdb41rm3lBo2ikMs90dyHMEikvHrIxRJMlykcPlHpYtLdebE2iamp40PS67yGQz'
    b'eiqR7I/Hk5rHlyPSqYysmOZQLJkczvW5ZZsskUgniUUT2jvvHjwLXADCTz71zCdlWX66qKj4'
    b'8199/iuhf2rfP0vgfwdf2OOyffutZPZNEL/51EPBkoZ6bC4HC5EF8zv//VtLA6j/jyX8L5+I'
    b'vSYhAQHeAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
wild_ksu_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOWxu2j4AAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuOQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAABMz8BIJY/XoAAAAwhJREFUOE9t'
    b'k89rXFUUxz/33vfue/Mjza9hEmvbaSRNRG2pduFKdP4BBRfSoqiItAqmghsXUhetSxdq3ejG'
    b'ZURw41qIStC2sbZQK6Jtkpk2mZlM0ybOvHvfezPvPRdjSq1+4cA58D3fA4fvV/A/mFt+Jx97'
    b'PEamK0SabFvVcoH89eOnTpn7ueLeYW7pTW1n5VyaquNZ5BzIQlcI64LRmTT+n7KrP/ebwdmz'
    b'r74X/0fgeOvERDIk55O+rBJqsBqMBusOeqsRRqOMt6C20mOfvXGiBSABXv/2Za9fFPNJIqsi'
    b'1Ah7b3l3C+uRWl1N0qH5197+yLsrkBzJnUwTVRX/XMo6DiL0MbUuwfUOMvKh6yKtPxAxuaoo'
    b'VU4CiKOLLxb9R0Yu0dfTwmhE7GOuBwR/bJGJHiLWZLGHDCcYHnsIt+cjbA5h1TV7s/G4dMrF'
    b'Q8TutLCaJPSIjEevl6fVbHJ7u0HD1mk1fmdf8SKT+huitkWGPpjctPYmDzpCeRUiTT9wmbx0'
    b'g/GOxa42mO4H/NVI2T2csVJwqTycIcQGG6u/kXYrSOshQ2dKpsYRGJde6PNAGHNs+Euem1nm'
    b'+dlbPDu1yQuPNpktJoiCg1ME5UTQHTw3M46QvUZyIws0TujR7he4Wh/l2rpi7VZGJqG26fBg'
    b'HOB+dxP/hx8ZWS8hojzCuvS7ti5bS8tXso6zkhrNSD9lKHeHXYWQoXyCdg0jhZjZfS325+vs'
    b'8aFchDTwyYxaWV+7eEUAHP3qzCnfHzudtnuwGeOleWLrkxgHEWr8nkZEGhkpUjuBDMeJzPb7'
    b'X3x/+IwCiG9vXN49c+QZV43tlapElo6i0lHcbBw3GYdeCRGVICyj7C4SG/209MvpuVZ8NVIA'
    b'myvtqLz3wELeKz+pwvweYT2E0YhgYGdhNNJqhHHpm+hco33hpcW1D5oAaicLyxfO39n6ufn1'
    b'5MzBnopyU8LmhoX1BxY2DqnJ6mGw9cni+XffOtf8sLGz96807uCJQ6+UKzNPH/Yp7xehS9zp'
    b'rtZqC5eXVj/duJ/7N3GBZLykuxeZAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
wild_ksu_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOWxu2j4AAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuOQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAABMz8BIJY/XoAAABWxJREFUSEuN'
    b'lltsHFcZx3/nMrPj9W13bSebOMZuo9YlJGlKQUQRIC4tVEhVUxWpQm0hDREkRSBVBUTkJxAS'
    b'TzwgRKF9IQjKA7xAL4BURQVKkyZqConTJqnr2Fk7jvHdm/XOnnPmwsOu144TqXzSSHOOZn7/'
    b'8/3n+84Zwf8ZT//naBuFICBWJFdd7Wef/GFl4zO3CrFxYn0cLn1nIM3K/Uki708ieYeIdRdO'
    b'kYZ6Xho9Io33qijLP/3qi98f3/juatxS4Mi5I51xvzoaS76RRDKfOkVqFcJqMIrUegirENZD'
    b'Gn9Rhfp5NWt+8ssD31veyLpJ4JvTR3bHHeJYnKb3pFaD1eA0GI2wiuacrc9hNcJ5aKP/LcvJ'
    b'gecOHjm3nneDwKGpw3dTEH+LEop14Bq8CW2ICOuB0WuZWQ9l9bS87h54/tuHzq4y5erN108c'
    b'zKWdHGvC3a3gjRVbr5mZsF5TLDG6mNB+7Mmhn+duEkju8odixJ4mvGGBiDxE5CFjn8r7i5Qv'
    b'LCBiH+k8hPMa32U1I4/U+HtUduvQDQJPvHNwe6rlofrq1sGdR3WsQm0yJK1pKhPXWJmahKqi'
    b'NlOlOrGEcD7C+WDXxHDBoQNP/257U0Dm/IeJVW79B8VqiD3sjGHylVPMnRojlSEia5kfvsyV'
    b's68wd6mEXQa7HJOGwKp1xs9JCg+vWSTU/az33HkQ1X1t791KUMxRuX6JKAqJohXK5gyytYNO'
    b'JugRL5HO/ZFwpox0mYZVPsIF9wGoh37/aD7o6/gBiZcXjcqpLqW4qqI6Yxg/fpHZ6TJWOeII'
    b'ZixEUYQ5VWHv5yX9d0Tkuw1X3t1M4G9DrlWYvG3bPb/VciCbJdUF4RQi8liZqLLvjZNEiUSl'
    b'MTq9RmVrAbsYMns1Ye9gytmSwD7URb4YkRDjEkNu018w89tp0dvAKIRVBZ0OZCWhEM2mMQqn'
    b's/QVEh7/2Hs8vrfEvo/AIzsWuG9HhU8PGj63O+Qre8u0yYS2gqar16O7N0O+6JrVJBrFkhqE'
    b'6v1wr9fWX/yqTP0cRqMIKL9foRiNM1NuYXhMYBy4CBIkWqdcmIh54cUeWttSKishU5cWGfnn'
    b'bjqCfcgoQFiP1CTT0zP/elYeP/ryUloVo/Um8oirkk5ToWo1I1dhoJiyUBZoDULC5Jwk3xHw'
    b'40eu8tn4CuHLJfarYe7Nr+DCetPVBcToq6eHliQQu8Xk73XfNC5U9LZa9tw+ha8q9G2aY0vX'
    b'Ev2bS3yoZ5q7B66wa6BEb88oPbnL3NlfoqM9obd7gSiUzS53tfA1IBYAX/jpwZ3FXYMnVBq0'
    b'2xVJz5nTbDZTSKVob+1grqwJjSCQEVUTsKUzRaYCYyVxrGnPXKc0+3Fml79EJg5ITHJ9av7N'
    b'fS+deeJ8c7N79IUf/aKlvfCUsJqoKrFVhbQeSZRBu0aHG4WwPnFNUy9pD2E0SU0RJC34sQ9G'
    b'E4Zzzx57/d5vAahVgSDTMtzVd/sDKm3pUVGGTBLgJRn8yMNzHjry0VEGz/n4sY8fZfDiDH7s'
    b'k4kDVOQjrEdkahfenfj14cmlk+UbBK6dHylvuXPHO9nW7gdlEmTrZbu2La962xybtXH98olr'
    b'dn5m6e2vHb/4TPNMaAoAjL5xcnzzwOBbQabwCRVnu4Wrp9yEG6++qZk1qLA+wni42srF6aXT'
    b'T7547rHX1jNvEAAYPX1iLK2lf+3M92V10jIoXeAL5yNMY8c0q2APYRSxiSrV6sxvzo0/99Q/'
    b'Robe3si76chcF+ozD373oz2bdu0PZNenVJy9TblsZ71Dk+XYJGO2Wnn9v/Nn/3z8/DNngHgj'
    b'gA8QWB9tO+/6cndXbmcrTrGwOLwyfPkPc8AH/rr8D12tqzk+c2MYAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
wild_ksu_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAAuGVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAPJ2AQDoAwAA8nYBAOgD'
    b'AABQYWludC5ORVQgNS4xLjExAAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAA'
    b'lgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAABc7WH6CeiquwAAD4pJREFU'
    b'aEPtl2mQldWZx3/nvO97l/fe2/f2wu2mN5qGptl3hAYF3EBjIlnUSNBgZnSMJpmMMckksbJo'
    b'ZsaUTpmUlUySSiaZDBo0RkZcswACaoRGdhQaaLpp6Kb3u/Vd3vsuZz60UEAqk5gyH6aK35db'
    b'dc5Tdf7/5znnee4Ll7jEJS7xp7jjjjvia9eurb94/f8Nc+fM3TZ96rSTt65eXXLx3vuFvHjh'
    b'/eL6a66flBf5RUXTru882nH5xfvvF38zA71dvZ8MNAR80VmlJHsSn7p4//3ib2Lgq1/5aqBQ'
    b'yN8SmBYi1BzCLnFWXLn4yrqL494PtIsX/hwPPfSQL5fL/ayqvOrGloUtuw+3HU5fHKNyLM2V'
    b'5e4rXxRHD2rkU3l/7kCurT/bv/vi2DWr14R0pT1QXVf95SuvunLLwYMHRy6O+b94zxXoaO8I'
    b'pdKpD+bjhU+9c/Tt3QunLPzinXfedcEjHTmTujrYFEaP6EhDI9JUgpOyrz4/5tHH/13OmTD3'
    b'tp1bd+6yxzjfzFgj1/f39ledH/OX8J4N/PwXP0/oBe2p4BiT+Eeq45lJ2Udfe3Z767LLly0+'
    b'G+NknVmhhhBCCYRShGtMvJCa+sCXHzAArlp+VeOP7//hlsK43LrqT9RMiUyO4g27mzZt3rT3'
    b'gsP+At6zAYCyivKfjRxLe4HKADU3jCP2DxXNp452vTpvytxPABBmoq/Uh9IUrgt6xIeKq+qu'
    b'YyfNRXMXtZzc0/mH2F1ly2pvGUewySTVnUSckT9QSomLz/pz/FUGvv5v39jrHXL2j6Sy4EHp'
    b'xDLq75/oS9jD6xZMnf9ZR3MN4degqJBFkH4dTCGPHDny0f6uvhdrPl9fWdFSCa7AKdqk3kh1'
    b'qQnqpqbGyV3z5sy/DuAbDzwYPHveZbMXf67lssu/d9PNHy27QMhfa+Daa6/xgvHQ9xOvDWJE'
    b'dIqpIsEak4bPTJKD1tB3rXyhRjM0lC5QukJKUIZr9h4+8/26e8eXRWZEKfZa+CtM+ncN4g07'
    b'zxumt2zeR2K1J/YO/HcVk1uf/Nkzh+JM3lbO5F+FxmcfN6oSnz/V3nf3xVr+KgMA19/+gV9Y'
    b'm/KtyYPDhCaEyfcWCNQEGXd3o+4OOn5lA0WFl1d4rsQ6UzDqvtBgRqfHyHfmCDeESZ9OkVjf'
    b'31kze+xDRw4WTkld4+9+OG7Mp385dsGdP4g3/v1Pxyy99j7z5knzY2SSxYJddFov1vGe2+hZ'
    b'3njtddU4ZcJbAwf6PhmeUmKEKoLkOkYIN0SQtToogT/sQ2kCN2sjhaBqRTUjXVkCpUFc26Xz'
    b'iePILrm2q9dadcVNsduuvKmKiVPjRModIqU6FdUG42b6yCRsNv8glWycOvaRjs4TyfN1vCcD'
    b'a9asqWuobZg2NlbVXF9Zt0hTeiDXmdMyydTM0jmlGBE/2a4cJZOjpI8kCZaF8Aouue4spfMq'
    b'KCRsAn4/WqlO10sdZH6T+q1/fPRwtEY9esuXq/W62nFMjH6QM5ldKOWiixhTy29HlbUTqCiY'
    b'u9dl4mn6nz1f01/86levXl1+8MDBfV7Iq9VKdDy/AimwE5aTfT2lR66OMe6mRoRPYmcdRjpS'
    b'hGrCSL9B+kiC2NQypCbQTEn3y6cYfLEXoroz2I3+0S+NZcVtY1CeQigDpWwQCil8hH2NZOzD'
    b'DHTn+fHnzgzPnDJ/4oaXfpk4q+uCCqxfv17LF73pkyY1zzh2tK1jz569srJybGj6jJklM2fO'
    b'yO7asXNZzudOqlxQTfn8CkqmxYhOLZWVHxpLsNJP6mgaaWgYQgdLke0YwUnbSCRmiR/Xthnc'
    b'20+oPoJ/fAjr+IgMhDRqpwSxii7t+zO0H0zT+XaOU215+k/nSSRPohs+/KZB275kMHnM6/jA'
    b'R1a07d23p8jZClx/3XWzuvuG7jmwN9cSqHen1AWVURaNPn60P784kZJxAm50VqXxbL6QL4sF'
    b'Ch9uPe1S2lLK7DkVaNEAxZECgwWL4ZRH74t9NDX7MEMB9r+ZhD4HFsYgrAhkXJZ8rB4Z0uh6'
    b'6ji3f64eLQg7Ng4za2kp4ZiG7pcIoXBsRT7jMNRbZOCUje24tLUmCUYDpDo51NTUuPKFF1/o'
    b'EQDTZi14YmxocM3dHzKZM8Fh8x7F3d/J8807DVYtEQykJGsfs+jtQ731I1OUBB2e3gxf/0kB'
    b'FoThZJ77lkhqKiVK03l2a45Dxx3uuSVKQ1wRMFwKRY/2XnjsZYdoU4SJAYc7H25EaC5trQVm'
    b'LwvhKRuUBsjRzAoAD6Ukx/ePkE8ZNC0yeeWnXRx/IfDP7/S1PqIDZBzjd40Bbc2KeSOUhFNk'
    b'86WA5IbFBnOaB3CKJh9baHB6WIrJtXlCZoa5k8fQ+hOTWNjhme1+Vi32mDY+SybrZ9tBychx'
    b'g3tuhPFVaVAKANvRufMDfh78eYo3h4Ojy57Cc11czwUlAA8ABaAUSik0TWH4JeFaDdN0CMUk'
    b'WLrG2TlwxezG37zwqj54sEOCp1M/xuWOVT7GVxahKNG1IlfNgZVzJaFAgVw2wO5jLtMbcjTV'
    b'p6iKuWgSoEg2Z9PW7YIGnuuAsrFtGMnr6NJhSkOaf7nLh550GEnZo0OOd9MtQGgSpAKpEBIQ'
    b'CoQgn3HxBQWuDdmES6Qy2H3OwJNPPtFPVeh32/YJPNcgHCyydqVONFhAIcDzmN0ES6YDwuXU'
    b'gEF7DwghwZHkLIGhjTa0ZFZyrF0BAs8bFdWf9nHrwwZbDkTAk4yvzPHhOUVOd1pIKUZvivJQ'
    b'nsJzR3/xRrP/biGwCh7+oMCxXTIJB79p9JwzALCoqfzp51sFg2kdXXq0NGfRpIPlGDiuRn25'
    b'xeTaHHiC3ccUugBNjJa74CgMbVT0YFqOXoCch6tGM+h5gpe2QjLrB0AKhekHx5HkcopiwUGc'
    b'a+hq1JQmR9uqkCjlYRcVvqDEdhS5hPAipebABQYWzJq8beeBwOlDHToI8Mk8Uip2HguRyPrR'
    b'pY1PsygUfbyyC2JhEO+Ks22BoTugFIah8d37Inzp9hCOK8CTREMeh9b5+dDCDOAwlDX4Q7tk'
    b'+4ZuHv7i7+k7PQL4RiuqBEKIs6/gXWOCwe48iX6b3o48qW6Rrm6In+H8OdDautOidnxjvVm4'
    b'bPksDyldPE/j8f/RaKjUGBu3QAg6+wLc9bDLB6/QWTbTQimP7Qd8tEz1CPosaspcWmYUCfsk'
    b'ugZV5QX8hk28LIsmbXJWgP98WefHGxwKPRm+8o/fZvgUtB0/Su2EGD6/pP1QlmIeImU6hZyi'
    b'p6PA9qcH7V0vpbIHtmataCT6tRdf3rj1ggoALKwNHlv/msehLj99ST8HO02+90uX3++BU30m'
    b'w2k/O96RgEsqA+09ProGfAyPwGDGYCClM5yRZNKCZBYG0orBpJ/uoQBHTpq8sjPE57+vcf/j'
    b'DjLikXYVc+fN5ZZbbuVX3+2ndVuC3a+neeT2Dt7ZkSNfEGx5bpBv3XqUg7t8I8FI3TOzps25'
    b'4a09rf9xVvO5m7dy5XVLT3ae2DqjXomaKp0TPQ59CYe7bzB5q83m9cMOdRUaruuhPA+BoCep'
    b'SBU8JsZ1oiFBKqfoOGNTXw6Wq5EpSvJFj1zB45pZfspLoKvPpntQEQ2PvpWRVAdKr6GpNkxT'
    b'XJHLO2zcZjFhRRXdyRyTUjbLF+h4nscb7zi8cSwwNL626pFXt2x55AIDsy5bdmPI7d741AOS'
    b'sWUFfvqKj4qo5KYr0mTyfh7bYHL7lR7lkQJCgKHDln0Gmu6jZbKFEB6WLdl7wsfKbxXY+LUQ'
    b'LZOLtPUIrrjb4sh6P811aZ57PUxtpUbT2DxCCXQdDpyQ9KdNbmxJkkgLPv5t+P2bDv96bzmf'
    b'XWVREkyBgFwhyCNPCR7cVPo6J/dewflXKGSa6LrA9GXRZZKJtT6unVMAHFrf8di8p8CYaJao'
    b'mcZxihSKNgVLUFNuEY0M47gWQf8IK+YP8YvPasSjFmNK+7l8SoLHvqBj2zYIC+V5VERsomYa'
    b'181hWXmsootfd4EcOcvlSI+CUj8fX25TEuzjjbcDbD8QIZUVnOiB+lj4ibO6zxnw+fR3B7dA'
    b'eTotU0aImhlOnAlx7w8lsdBoT7ccPzuOl/DbvTG+9/xoJUBj3WaTVw/EQDjUlDuj7cPTAIeb'
    b'l9r4/KNXxlMKTXooT2NfRymbD1bw6AadoM8DoUhn4dRJ0AMKQzogJBUxnfYzBg8+6WPdXsOd'
    b'31i+848M6Lo2qvDd72pTz4DQ2XnE4GibRygwqsmnF7l+3hA3LsxQZnqjE9hTrLna5erZOfI5'
    b'H5v2Sfz66FzoT0epjuUZH8+Aq+EpiS48hHBZPmOIjy0eYkLcxtAVoBhMAyicMy5PbxUMp6I0'
    b'12T41MoBvr22yKcX29r+jqE7/siA47hKKQUKhBBkbT/K87hhgc29NwewbYEmBQXbx5ttFexu'
    b'jzCpzsCQHigwfUVMf5a2bpPv/JeH36dAwKY9GoNpE0Pa55KjawrXM9jTEWfH0Qoi4RB+nwdK'
    b'EA0HeObhUr7zmRBmOMjzrSHWb4uTzpqMiaW4fLpNe2d2+lnd5+bAuMbmZmUNrv7E8iJB02PD'
    b'9jC6rlFbmWHmhACnh3WWzSwQMGxqy4uMG5sjaPgoi0K0JM8LO6JUlykaqixqq8OMiysqyiy2'
    b'7jE41q0zv9kB6dLWFaCp2iUYtKgutairzFMSFAT8GvFYhspYkakT0gSMAEumeSxpHqa2AkoC'
    b'Fp6S/Hq7xoH0mNcKA6eeu8DAxEnNU4ojg7deM1fgurBpt8bGP8DVszUMadM9FMS2YTil0ZfS'
    b'GEprHDghONGjyBcCPLddcXpIcmZQ8nKrx7RxOn5NsKsN/ulHLktn+klmBK1HDXy6IJHW6RvW'
    b'GU5rHD4lGUzpFAsa3YNB+oeC7Drisn0/VJXqRIJ5kjmNX2/X+OKvAu6Spsp7Ok60d3N+G121'
    b'6sNLDx9+e1vQcMnZEqVE+nhCFT+9zK44PQAvvu0bZsgtIHQNQ0iKjpBx4XhJY5iiE6uoVYXB'
    b'rNBIaJmKOmLRgFtruZ5nSJEFfW/HSWcmtrSIFh1SukTX9NH/GgpRJYQqah4JqRAeeJ6iUti4'
    b'RhLNalrWgP9MWnG0TWtfML/0/l2tOzee1X3OwB23rRHHOk/OK+IPeQqrekxpbzoxULPt6OCD'
    b'oYCx4dpZ45/N5a1CKBzSBEKmUmkhhPKWL7s8veut3aFcPu+Gg6ZeXl6WSySTZZatxp7uG3Kj'
    b'Yf/I8iWXdbbu3h+PhMNWT/cpNxSOyWi0REun06Jo25hmUEQjIU/TdVzHVZZVVD6f4c6eNSP3'
    b'wm82N+n+UINrF5N11WX7n1z3RPas5ktc4hKXuMQl/hdiGQO3SJRM1QAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
apatch_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOWxu2j4AAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAASRkBAOgDAABJGQEA6AMA'
    b'AFBhaW50Lk5FVCA1LjEuOQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAACKyFmG9q9FEwAAAfdJREFUOE9l'
    b'Uk1rE1EUPfe9NzOZTDqZpAFto5WWBBREaRGyUMTiVqr+CH+O/8B/4MJ9Ka5adNN2VZG6kFKI'
    b'Smq+mknyZua96yJNmtizuhfu4ZzDuZSrljAPBgDQjXkKsbABUMR9zT3NPc19DbV4DkgV+lcj'
    b'gVuj/Mt6sF3LMi1uBeHOIxF66dEvKjgzwrwCcWJtrJca6+U3W+XXm2Fjww4TTuy8rWsFjlNV'
    b'i0o7j3v7p+33nwd73zOXlhob+k/HtobkyjkCAanl7jh49SB/f4WECLbrwYu6s1zwViPDVn89'
    b'p5ya5KFctcSJESWv8u6ZUwoop1gbEAEAW3Id1mnaiS8+HNj2mFwpAGCQqrsRSSGLfnx83t09'
    b'SZqdpNnp7n6Lj89k5JMUzp0iBulCaM4sMsuJCbbWCk/uBQ+r3lrZJhkyy5mdVDIlEMGw8BQ5'
    b'ktmagTaXYzCrSgGWoaTwFAxPfEoV+uRKcxG7tQpJYUfp6KQJIdLf/cHhmbsSQYqk2Y33fpAn'
    b'IYiuXoPZNLve0/Xy283scix9F2AzTFQx3/50pPd/ytXoWmHiShTz5rSb9Abh87rpj9lY73bU'
    b'/niYfmmKajiLOtc0M5Vd8zdmwybWNtYAZ62Ylj3wLDOmlmbIWEQ5O04BCN+xnRHUwoPeIADI'
    b'LAQBgOX/rgH8Azkn6MNjgb82AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
apatch_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAHIUExURQgbEQgcEgcLCgYABgYABBZrPxdwQgQAAAYAABBNLCWsZhNdNhl4'
    b'RhNeNiasZggcEQcECAszHii3bCWrZR6PVCWqZCi3bQs2IAcCCAgVDgosGhh1RAUAABhyQgow'
    b'HAcTDh6MUhyFTgAAABuCTB6OVAcTDQYAAQMAACWoYyKdXR+SVh+TViCUVyKeXQcSDQw5ISOk'
    b'YSGZWii4bSi1ayi1bCi0ayGbXB6MUySkYQw7IiKcXCSmYyexaRVkOhFRLw9LKxZqPg9MLBFS'
    b'LxRhOCexaCSnYyGcXBh2RR6QVCKfXiatZwknFxNcNRyDTCGYWR2ITxRfNyauZiKgXhl2RR+R'
    b'VSOgXwkjFR+PVCSnYh6LURp6RwkhFCOgXh+QVAsxHBFTMCm6bii2ayewaAoqGB+QVSSlYiat'
    b'ZgkoFySmYggXDyCXWQcPDA1CJiGaWyOjYQklFhJYMxuAShp8SBJXMggZECOjYA5DJwcODAcQ'
    b'DBuASw1CJRhxQg0/JBt/SiSlYQcGCRh0QxhzQxFVMQcHCiOhXxyETRp6SBl6RxuBSwgdEgYA'
    b'BQgYDx2KUR2JUAgWDwgaERBPLg9LLAYABwgYEAcMCwcNCwgXEAgaEKtR2PgAAAAJcEhZcwAA'
    b'CxMAAAsTAQCanBgAAAbfaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVn'
    b'aW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pg0KPHg6eG1wbWV0YSB4'
    b'bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMw'
    b'MDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4NCiAgPHJkZjpS'
    b'REYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgt'
    b'bnMjIj4NCiAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0'
    b'dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcv'
    b'ZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29t'
    b'L3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAv'
    b'MS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlw'
    b'ZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUu'
    b'MyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDI0LTAxLTEwVDAxOjMxOjAzKzAxOjAw'
    b'IiB4bXA6TW9kaWZ5RGF0ZT0iMjAyNC0wMS0xMVQwMDoxMzoxNSswMTowMCIgeG1wOk1ldGFk'
    b'YXRhRGF0ZT0iMjAyNC0wMS0xMVQwMDoxMzoxNSswMTowMCIgZGM6Zm9ybWF0PSJpbWFnZS9w'
    b'bmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6'
    b'MDA4NTQwZTQtOGZhZC0zNTQyLTkxZmYtMjJiMGFlNGE2YWNkIiB4bXBNTTpEb2N1bWVudElE'
    b'PSJ4bXAuZGlkOmYzNmJmZDViLTJmOGUtZGY0Zi1hOTUyLWRiZmM5M2M1NWZlMyIgeG1wTU06'
    b'T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmYzNmJmZDViLTJmOGUtZGY0Zi1hOTUyLWRi'
    b'ZmM5M2M1NWZlMyI+DQogICAgICA8eG1wTU06SGlzdG9yeT4NCiAgICAgICAgPHJkZjpTZXE+'
    b'DQogICAgICAgICAgPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3Rh'
    b'bmNlSUQ9InhtcC5paWQ6ZjM2YmZkNWItMmY4ZS1kZjRmLWE5NTItZGJmYzkzYzU1ZmUzIiBz'
    b'dEV2dDp3aGVuPSIyMDI0LTAxLTEwVDAxOjMxOjAzKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFn'
    b'ZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMyAoV2luZG93cykiIC8+DQogICAgICAgICAgPHJk'
    b'ZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmE5'
    b'YTE2ZDQ4LWY2NjItYTU0ZS1hZTU1LTc5Nzg0YzU3MTlkMyIgc3RFdnQ6d2hlbj0iMjAyNC0w'
    b'MS0xMFQyMToyNTo1NCswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9z'
    b'aG9wIDI1LjMgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIiAvPg0KICAgICAgICAgIDxy'
    b'ZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDow'
    b'MDg1NDBlNC04ZmFkLTM1NDItOTFmZi0yMmIwYWU0YTZhY2QiIHN0RXZ0OndoZW49IjIwMjQt'
    b'MDEtMTFUMDA6MTM6MTUrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rv'
    b'c2hvcCAyNS4zIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIgLz4NCiAgICAgICAgPC9y'
    b'ZGY6U2VxPg0KICAgICAgPC94bXBNTTpIaXN0b3J5Pg0KICAgIDwvcmRmOkRlc2NyaXB0aW9u'
    b'Pg0KICA8L3JkZjpSREY+DQo8L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9InIiPz7StoMG'
    b'AAABUUlEQVQoU2MgGzAyMTMCSWYmIIkCWFjZ2Dk42NlYWaACMMDEycXNw8PLx8kEFYACfgFB'
    b'IWEREVExcQl+qBAESEpxScvIyLDL8snJQ4UgQEZBUQkoIaOkrCIDFQICflU1dQ1NLW0g0NEV'
    b'VVfTg5mmp2+gYmhkbGJqamwsZmZuYakHleCQtrK2sbWzd3BwdHJ2cXWT5oBJuHt4enn7+Pr5'
    b'+QcwBAZ5BCMkQkK9wsIjhIwjo6IDY0LcERKxnl5x8QmJiUnxyYFBKUgSfqlp6cqxGRoa2plp'
    b'qVlwo7JzhHPz8gsKtbWKiktKs4TLyqES/BXZMgaVVTKy1TI1tXUy5dmIUCmpj891beATbqyz'
    b'ahIogQqCASNzc0trW3tHTGcXWoR0S9X1VNb2Wgj2QQVgoJ9ZJW3CxLSQSf1QATjol5g8Zeo0'
    b'ielQLhLoB1pagqEeHTAwAAAEn0WcBB+K8QAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
apatch_48 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAA0GVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAGAAAAABAAAAYAAAAAEA'
    b'AABQYWludC5ORVQgNS4xLjExAAAFAABAAwABAAAAAAAAAAFAAQABAAAAAAAAAACQBwAEAAAA'
    b'MDIzMAGgAwABAAAAAQAAAAWgBAABAAAArgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAA'
    b'MDEwMAAAAABFTO0LpE0megAADANJREFUWEetWGtsHNd1/s6d176XuyRXFB8iKVIP07H8Ev2Q'
    b'Iiu2Y6dxHCsuktTNn7auUydRggZCmqKokTptHKBFnLhFERsokABBbcBFjCayosiBrVaNbEW2'
    b'ZcuVLTuSKJGUSPOx3Cd3d2bncfpjZmd3ZykiAfoBu5h775lzv3PuueeeO0SjGfyeYGYiCvb+'
    b'f4ABEexiXrPJLWhtdkoGsE7/mkMeIX/sapYTUdMrDFgOWiQ7WbJpX23KdVh6hHx1AAKSbUvD'
    b'7NIiRWhqiKq2z8kVIyIQCEDNVMNhWZaa7/7O8DzkalyHuG8sF/XwjqHM03+kbutFxQIAy+Ga'
    b'iZoFyyEmrpra5p6+f/l89IZhFHUiajXYhWdAi3ZfoC2GrhaqrqinJa7VXjpvWFbqy3fQUp4u'
    b'LUkhWdu+QZnoU1QF08tYKiS/std0zMqRc5QI+Up8Zs1m49l78FiO9K5DZW3k9PCtw6nH7zNO'
    b'zUqDXVImYSsEQLIca7GM2bw6ObLynSP68Sl0h117iAjgVqcALpO2HgZEq9/WCcMmiLiokyBH'
    b'QN0zjoJeeeHt/FNHSz84uvrCO05RF3vHHRkKg0s1z2jP2va5eQ02AIhGM64FrevSCc9KAi4W'
    b'41+4MXngLuv80srjh+u/nQc0xDQIoKQDdWVsIP33n1S2Z0r//N+ln5wSm5Ouja3Z62pzMSBR'
    b'KhoY65TzO7lqahOZ1OOfMs/MrRw4FLp3q1U1EVcoqlBEpi5NZJLRveOVp45L1/TE7r/B+u1C'
    b'/cMSqVKnWq/RMVcwMa4DBrCYT37tTi7q2Ud+Evuzm1Nf/Zg21surpidRMUPD3V37PxZ5eDL3'
    b'6LNWbjW2fw8t5QN6muQ62KDpoUZ7Tfe4oJqp3TQc/cJk6dmTxqkZs1I3P1isvXUZBDgMmyHI'
    b'zlfMmZXKyWlnseTIFPrkRH02b88WXSe1q6PAEeQ2Gx5qi74OMIPBC9XQ7lGYlvXGnDy5mRRZ'
    b'P7sg9yWUwZQykJIHUvJgSvQl9bOLpEjy5Kj15jzV6qFbR7FUBvubu4nO6dgP6qtJgIjzupzX'
    b'GWRDT//Tg/IDO8SKQeS07xFvi7T0AMycDhsvfZD/+vMCIQCcUpEKB0+DFgQJuZzadn7BiN69'
    b'NfHwLsFcevKodP/20HUDpWeOI6IQN+fnWt0hiJDCRH4/V+rRL91hnFs0/vN09zfuIRKFH722'
    b'+vI5Smlwvd5uv5sGgoTa/MRM04W+Fx+1SjorQhGiNpWVJzLLn/4h4gkQUCoBAETP3z0gJFr5'
    b'1mEbBgDE4iBCudT9s/3OpeVwf8oWsA1LSkaWP/00j6SDCbKBNcqPNjCkcFzEQtXj56qvX7QT'
    b'mqAG3W5NKKLnG/dlnnxo47f2KemYFNX6ntjX+73Pdv/N/VJEoW4N7hoSOXFVPzVdPX5BiikU'
    b'i6+fe9clBDDYhsOqDFmwY8M7fwhVU7t9OLRzyFooaHvHRaHOzMqWPvtKKXRNX/juLZzXm1oc'
    b'hiJBkQJx3XkwUCehYFwTwCDvNXeIAAFFsoo1rtvmpWV7vqiMpUKpuF3TnYohRruliIaqBQBg'
    b'AgQYAIGIGW11VBAMiEYWD44F0ZRgwCFVMn89Zc/k0ndcS0JULy7XFvLIRKI3DttnFqrvz6M3'
    b'7L/qbnly/1wfd/jGh18xeu2gHJF7THsS3iADQCKy+pvz0nC6fvqKdMMA7eirHT4bHuguv/CW'
    b'eeIyNNl9n10veRrIO83b86H/DEC01qZtdaoL1ypvDA1iEpgFia4HbzFOz0RuH+WTM+ZrM/G9'
    b'W2snLyX+eFIkQ81ix9dExMR+v6suOF0ghjqjDKZDJMhkqtsEweQGEvNyNfqH15mOlTtxoV6o'
    b'Rrf2xXYMY6WaPfi24ziRB67lXLWphIgsm02bRUdSDLbbS1g/bhuDZJlFa64QefD62Cc+4lwp'
    b'OE7jfUU4lbqSiCb3bFeT4dV3Zo13ZpCJJv7kFikWZsP2iAPMbF8uRu+aiO+7wVlcdSpFCPIt'
    b'b4RAk5Z3uDbXK+DDiGae/VDZkkGhlv/mL0J3jlF3pPrc67Sxy3xvkVWy2bazZWl7Rk7H9RNT'
    b'9aqhvzdXOXIWSQ2FauihnVwxSn91WJ0cRMUsPX3Mthnyels7mKmDlRoBukXzOXendD+xT9s1'
    b'tnzn900A/WkUDFRrgJN65A6umoXnTgASIiF0aZjPCSDzygHjzdn8X//U2xkb0xSW2fH0B8PD'
    b'I9BSMXaGWBtqpra5p+e7++qGYU3nqv9xWn/nipZJJr64y0xpIJKKRvlHJ+qX85Ed/ZHP3yyN'
    b'pOSYtvLYIf2DRYoorZpaZ2yrJDsTYxCtRoQV/cxC9juHnQs55bZReecQskVlc1rdOy5rqqzK'
    b'2t5xbUsGK0XpxgF594g1k8/9wy/1N+d8No2qvanTi6SWf9G+Azt82O4z6g3rp+ez+591shWW'
    b'BABHZq7WC98+Ujrwc1QMWyYAtkScrea/9O+1N67QhmaG9O6ZbrA2AsNrNmgEPLTukgFgUEwh'
    b'JeETde+qlIlgUxzw71rEgqinmxKqa6PvG9893B7LnoeYm4TWDLE14J0CDdUO4BpCADHcYshh'
    b'BrXo9uAy8DZNSzw0t5FbwrYRvwqtpgwBdUtiUlUZgJAlEoLqNtdtkBCKYEAKKxKAXN3l3arc'
    b'XyDXtE79wWvQ2huthSURcaEYntwc2bNFjGei+3ZwtlJ68hh/WIndu027bVSd2Bi551rn3bnK'
    b'i6fQkuQCD274tDx6zTZCa7MB/CuAJ5YI14+ek8Z6lOsH6Eqx8L1XLLY5rhlvzyrX9Mnb+4z/'
    b'nSt891ecipBobpqGpqtM0UDw5uq/00wPbv73DXNLX5v58gpBMGxsTCMkEYgNC/M5gmA42NQD'
    b'ibxVYSBXQypEkl9cNIKmBW1L1jns9TBjUadsHXGZJCFsR8wbKNuUtxgG+lPUG4fUeFESiIdR'
    b'qtNQGrJblgHMUkyL7BrnVYN1072OtU3TDs+lzROjdWkAmi70PvWZ3kMPK8kIZsrx3Vt6j3wx'
    b'/fKj3cce7f3xn2qZJAwbhTqmy6hZsGw1Ed7w9buV7hh0C6aD6TJmSpGtmdQ379Z2DPDMMhv2'
    b'mpZ7nWvsspamUzXV20bEzZtoW2/43u3s1Mx0yBlMOmfmcGpG2jkU++pHeW4lfNdY9Gu7tLEe'
    b'sVCLf3xCfvjW2H0Tsgk1FY1/+fbwPVvYZFsmNRmKPbJH609yxQzkuxYCLFEq2knZW68rufhf'
    b'7JFG0jxbkIZS1effkCdHQjdtqv3jK6V/Oxb9zE1OSI5vG4z9+S5l24bwPdcouhV+6KZKd0gb'
    b'SEmE+IG71FuGIx/fJkji0XR4pFfeMxb96Hj9N9N2sYZGPPnTERHgX6U7xxgCinzrsH1uQT90'
    b'RtqUVndvJdN2ZBF77N7MS39JA0k+OWMvlOoH39UPvstdYWs8lfvhMaVq55/5H7FzyFZQ+NyP'
    b'q794TygySVT+1ZnKD47afXF15xAWvDtJc7EaCBLyRzmvhx78CA0maXuf9tDNdkKLfGKC6zbY'
    b'cZbK1oXl1X89VnjisLRzUNqzWd3Rbzu2RUClTmAnu4qukL1c1mcXSo8fXP2v98mBPVswLq3A'
    b'sIUi0Cj0/MXyY8aLIZ8Qs/ejYinyBxOk28bLH+ivnsfFrLp7VIQUgqg8/1Z2/3PlZ14VmzbI'
    b'1/db2ZJzYYk0mYiobgtZin3qOlzKhYY3pL79QObgV9KfuwUAZAFFQO6oARtwaQQ9BMC9P0la'
    b'KqxpODZV+tuflx970frpaaVshkhSzi+T46C3i0a6rNli/dBZuT+lTvTL7y+pKzXj6JT1+rRy'
    b'bb/+6kXztSnlzq2sm+Uj70pTOVEySDflqSxWaki6dxJ3tpZVY27/+tFyCBMJka06VZM3xZlB'
    b'ZUNkTQyEaa7qDEUdWYAZBLpUliTFsWuAoL4Eh4inC0Qab1R5Pi9E3HFq1B2jFQODURYsZqvO'
    b'YISVRs5sTNpokPcVthNuXAMAMTPIXck1ne00vmM0/pqSjVuU39NZczVKI6/Rdtb43mukKY+N'
    b'q3ltNgAEwbseIShJwZ4AGyCoVwSTUPu51vINCK3Uf1/4cbKmhtYYEpKQmtOzu8nYfw5grb7f'
    b'Cewte0MDNROMNxEBgCxJ/wcf5DnwWOeJcQAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
cert_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABFklEQVRIS9WUzRGCMBCFd8UC'
    b'bEBGOsAO8CacLAUqcKwAOlAr0BN6kxLsAIY+MGYPwZARiPw4ygkIvC9v920QRr5wZH34HsAL'
    b'Uxtwugdgdh9XDCBhrNhdAyshndKBG+U3/uD0EZf+zWLftCoAL8o5HIAv9CqbqlOKyQviXnWj'
    b'Ax8EwEVOD1YEfAMLRGN78c2V2IwWoK0PqkPZmRagTmAdpg7t+E0YzuSIJyfrBXDDfIMIIZVG'
    b'dilHUwvw9RIJoKg1zQwNE4IxI0ci8/SdloPRYzpWiVK1eXWDVpey13u8x/58WTkqKIITNPhh'
    b'V02IDBE9aAJQopDBMQ7MQwXQVhZ5vWnQVJ1OB9v/A5rmYJASfdKvTj34KcATT0TYGZdaUUAA'
    b'AAAASUVORK5CYII=')

#----------------------------------------------------------------------
downgrade_16 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOWxu2j4AAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuOQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAABMz8BIJY/XoAAAAWZJREFUOE+1'
    b'0kFLVVEUBeDviJlooYOiSUQl7xI+i0bRwL/gNKOa1p+op+ClPxANnUlCNqnoDwQNnAYXBw9e'
    b'TpoXqE8rvaeB58btZEPX5MDea+1z1tqH08Jg+ebY9tKt0byeYyQvQL/XnT6q67VfsX75Zen2'
    b'mbzfxj839HuzU4QXuIf3MdThuD43idCiHhZldZCa3bMhhBtiHERhFYt4Q/2kKLe+J/EA55N4'
    b'AutFWT1sLIzH6FUU3ibxu0ac+vtJPJG9orEQjtBBFx+D+KhTbu32e3N3cQVjiTvEdeyg1gox'
    b'4ht+YFoIM6n+FK+xloaMY6coq2FRVgftAUPM4ALmOyvV51TfTecmNrDe3NzgLz+O076DZ9jD'
    b'PC5joSirDznXf/7BVSzgfhLDuYzzB82OQ0p4Hw+S5008T+JPRVl9zcVaAyaxnVY1kgLbKMpq'
    b'MRfkOMnCYQrqZ944Ce0tXMNFXMIUHmfc08FvlRFn32/KCNQAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
downgrade_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA10lEQVRIS2NkoDFgpLH5DERb'
    b'cL/BQECx4cIHUh1ElAW3arUTgAbXM/xlCFRru3qBFEsIWgAxnLEfaKgAEH9gZWZRJMUneC1A'
    b'Mxxo/v9EtearC8j2AXI4E2P4rVqd/7gsU2u+AnY8ig+Aht5nZWY1/P33dwBSsOB0ORkWgF0E'
    b'SymgMMcbLORagORr/GGObAEsSNCDDC2IkMP0/wNQcCGnGGJcTIIF4OBBsYRiCwglP7pagCvM'
    b'8QYRuiQ5Lh7BFhAb5iQmU4TyUQsI5TGy5QnWaGSbDNVIcwsA0aiBGYyKH2AAAAAASUVORK5C'
    b'YII=')

#----------------------------------------------------------------------
check_otacerts_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAB6klEQVRIS+WVUU7CQBCGZ2hr'
    b'fMQb4A3wBoULICcQTyAkYHwT3oyYgCcQT6An0PUE9gZyA/toKOn6z+Ji27QFjT4Ym/SB3dn/'
    b'6/wzszD98sO/rE//AOB3qUque8LMPuysiaVMOog1BepqOdpkcalF/unOIWs9scI5YqHWug2Q'
    b'KgIVAvyBV8fmIw5W8SoIjYg5JMcJKY7rAJ9jvS7C2GsUQXIBYgt73ouIM9M0XkQjNaUw+5XN'
    b'U2+iNXWxHj6Oo728LPIBfa8LYbFG6Shq54lbscbAkyx9ZDHMq0kK4J/t1mi5PEJBO+K7Zm6r'
    b'y8V9WSE/6nSHwt8/jJftbOwakPHcxGnH2VcXb/NSwMrO1yKbDCDpubGFqEdRNC+zJgmFTThi'
    b'HgVrg4fLqGf3V4C+ew5bhtt4npdNAmC3AxT9QH4YwLpQW3heapfUEC1c0boVEz2pcTSzAGnJ'
    b'Gjpmb1tbykDGFcCkfhbwjLU6jDwANdh0+Cv7BpAYGAXvGl8RyMaiGzsQPUnVIDW5RDP4d/2d'
    b'TD7EZUDl+jB31Occ9F0fnSRTufGx8+GvJr4lWafEmY/tgKYnGUNT8XC/oEZS9CKSbYbmwLtB'
    b'bAdxc7xyKRKmfy2+btONn1wSkICEWfEfAZgmGbh3MVdu8+6tv/+f/A4tw+YZxQyScgAAAABJ'
    b'RU5ErkJggg==')

#----------------------------------------------------------------------
wrench_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABWUlEQVRIS7WUT1bCMBDGOzkB'
    b'3kB39rnBG+AN9AYFyho4Cexp+8IJ0BPgDexG2529gSxdJU5iw6ulfzJBWPWRyfeb+TIz4F34'
    b'B3X9IBgOGPueA8BjeVZIKVMhvC3neUHN5wSgBMLQX0npLepi+N8ySbI1BdII+E+IBihbOE8P'
    b'9czaKmGM3W8276lNJRownfo79PklSXJuBwEexx9jCuATg6+bPJ5M/AWAt6qJHeI4u6IAvjB4'
    b'oC5UIS3iWhcBre9XBRuLdAXmQEHUd0PmJoRWQdtjdljwjBU8WVs0m90NhRBvNhdMDIB8iKL8'
    b'te/O0UeHKtDCfsifh7oE5KQTfu2Sc+ynoCxfDaAaqlGbHV2V9LaamfIwvB1JCXsqpBdQFXSB'
    b'kAAKRoWQAVSIE4ACcQZYQAqc9puzAF0Q3GPrKMqWZwOaIEZcL8y+XWJ7XnbXDsW5yvy4s2wF'
    b'XON+ABl2zBkFef63AAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
java_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABXUlEQVRIS7WTDY3CQBSEQQFI'
    b'AAfggFMAKAAUAAoupwAc3DkACUUB4AAUcBJuPrLvst203d1AXzJptj8z8+a9djstV7dl/s4r'
    b'AhOZK2IGXxFYivynLYGNiG/CsQ2BkUh3wlz4fbcAzqfCypEj1jiHnBlAvhA+hE/h+s4ZzFws'
    b'Y13XQl/YxuLheWoHZE5Beha+UgacI0DWxMJgv4WBiyraRGoHEDED1pLNeQhD4RZTyBGAayIU'
    b'wkGwTeI+M6lc2SYBYoHw4pz6bomIsxHX/hsxAdYSZxBZcb67A+KAstUt/d0pEZH93hOwSOjC'
    b'yOmA9WXLSlGlCOCMqKwLooGEK+sKOc+KwMTzmCKAUwh9Z7VDDUVSBHDPj+aTIoZjOmisKgGI'
    b'yPMkkHHoHMJwJfkGEFup6gTInWgQseoF37JJRmrENpv/V2MRQWBD9FcVAovMROg2qYNIqnmP'
    b'Yx3ksVW8/QdjBEgZ1/PFyAAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
folder_zip_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAuklEQVRIS2NkoDFgpLH5DMPI'
    b'AtH5XQYMLAzzGf4zGGALtv8M/wvfxJVPIDVI4UEkuqhrP1CzAz4DyLEE2YL/pLoOh/oD///+'
    b'bXyTWHkAJE8LC0DmPngdV6aI1QKgBFEpCxikYB+jq0cXx/DBoLEAFv7oLqaaD2huwWgcEJ3n'
    b'aBbJgzIO7gPDRYHosMGnkJHhwuvYMkOUokJkfrsDIzPzfCpYAirkFgJLhAUoFlDF5VgMIapg'
    b'o8TyoW8BACFToBnuVIsBAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
restore_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACEElEQVRIS9VVXU7CQBCeYes7'
    b'JmB8lBOIJxBvAAcA7Q3kQYxP6pMRH/QG5ecA4AnEE8gN5NGIiX00gWWdWVrZ1nZrTIixSRPS'
    b'nZ3vm++bGRDW/OCa88PfAxS8qwo4zj6CqoKCHV0xwgQUjkCq7tRtjW0qpFaQ927zG2J+DqCO'
    b'7TLi3bRx0kyLSQQoeu0yCBjQJWbsE+UO4uJRzXEiQPoLJ1deQG4XlboIEvtKytqbezaKA30D'
    b'0Myd2QPJUaZgkgGaaTIERG4prsJEpo3WZiZAsXdDF7Qso5ncqPlukyqwP8Ve+4FBFMDwrdGq'
    b'mdGRCrb611WlkKXxiflBloFhoqVfs3ftP6raa/10GJ5FAAr9m/OlrnbjkupZ3YUOSeUmAhT7'
    b'7SfWPs6Cg7XeDnh0zoZexg01qze9iFRAWj5z5wgpSy/u2cRkGuocfJtQkpJ5bsgUMRsNUxMq'
    b'X0kVgusghPG03tpLAQAC/yKufySDRH3giUYhPArnyrqUpGMCBOfcTZHqvpCiIL83Od6qMQ94'
    b'BoBKTB/9pA7a9q52pBBPdJa3tmnS5Z98K/TaA2JapdhIiy7tsjzcGbZJ5nNHzLwguU+TX4rH'
    b'W7fp6jLeKTm/597XSeGDZoJWuNIrJU+vT9K45gSHvFMBAl1pXcNRhkzWnZX5j7bcmHhIC5C3'
    b'a4XZ8kvdMs6h6iaxNgllAvzEZFvM/wf4BKTuAihlxtTWAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
analyze_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACRUlEQVRIS7VVTZbSQBCuSubp'
    b'Nh5AJCeQOcHgTnADN4AbJCfAGySeYPAE4kLG3TAnkBuA8QCyVqH9KnZlekgnoM/JezxC0v39'
    b'VVXD9MgXn4P/Otv0g+DiyhjTZ+KIyHSJeMtkVsbs3y/TeN2E00owyjbRTw5nhmgCAAD7L4Dk'
    b'n5JO6nvbSDDMNj3i8AM2QS3tiDk/HH7dBbg/4MMU9jjgl2TMWwu8O5j9+HMar1wiL4Eo/8EX'
    b't4iiB/UrNvu0KQYRYjjMANQXIcuk8+wkwTAvRPlIwJ9C1SKNd7oJ7zbiCmpjqN3q80Fe3FqS'
    b'BUjG+rzmwEbzpYzF7F+J8j+OwmvEtHYimWMzYqG7m7SzsGu+C7AxNJZncl8jGGRfE2YWy1Xh'
    b'3uRFBjeJVbXFPTqojESuKpbhu28zK2AOF1M/gbXqqnBdPUE0EhmiugbAhAxNl2lnLmCDrBgx'
    b'k8RbkT5wMMyKCTzJRumIS83Y6ahIi6gErhAnpjoBhqkbcCjZRxio9CZ9kWuhHkaEOpCR4kpE'
    b'MhtbkMay1q0DnpXiKwfaOb6h8RW5bF+Aw8FHLeh9lLxeJs8vjwm87acu9BtCpFOi4zaV906R'
    b'q1atOVAgtXhM0PTbupSIu942rWJAlALytwQaMVKv4vG2KRYi3vMJrLCsbFlnONVpfZIbjoKm'
    b'aPToEHBEM9WCtxGUAyRdgrN+6p43PhJ17Cu6NyJrWTqqOv/b6nEqUu9xbYduZnNtLfg/ETg9'
    b'f7Lg/4XgnFloirH1P1nVPRrBOcCn1vwG99tiKElOH7oAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
analyze_64 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAF3ElEQVR4Xu1aTVbjRhDutgmz'
    b'TQ4wHvsGcILALjgL4ARhToB1AoYT2JwgnhOELGKyG3KCOCfA4zlAvEwmtjpVkgyyXFVdLcn8'
    b'93u8gVF3q+urqq9+Wta88GFfuPzmQQE46t98iwr4akzbmSb8LGbw5+T3qDO5L8XcKwAo8FfT'
    b'PALYD0HAHfhBABIQiIFgXMMBJ84tPo6izngToGwcgEToxtapcebIGIdClx0zOOxw4RYXdVrI'
    b'xgC4E9ydgMTtslJT6+DQg7qA2AgAP/Rv9hq2+XPdghfBQCB+67WiKuDWCgBq/T/bPHPG9Koc'
    b'KmytHcduflzWLWoDALTeBq334fDg675hx0CElyZ2n2OzmDSMmW0D2f2TEmLbmib869rG2kM4'
    b'4J5vN3g+i90CQbhWzF2ZUgsAib/b5p8ek5+BQAMTz38NZfSD/vTIWnvmJVFn3o+i1jAEhMoA'
    b'pMJvfRION3POnb8x8fAy6mBoKz26/ekJWA4AwZMqWMJ+iCVUAiDTPJIdY/bV/JNDqnvx5cw4'
    b'94F5PjMAgtbKKgHw42Da5wgPGfobtzivqnUOhCzSgOWRY7LtFruad5cGQDpASHjKzPr7vBhg'
    b'xh81Ztzt3+yYlHuocTnqtY59/lYKAMnvQ4THwx0Mpp8IplcdHteLlgBW4HOFUgDwPmjH226+'
    b'rzG9pWa6g+kNQWoz0N53Pu0tnx/0P/cgSmAILgw7HvXe7kr7BAOQER8euljEiOSD6yDO7+RN'
    b'WzThnPaotUWhAMhfKDJ2zhxfRa1LDoRgADKfReZfHdZ+GJ2+PedelLOapKjBeUCgJwSQt1tA'
    b'+Iwa1r5bzpPcK0vEUDHFIVpTMACMz4qsm2kaGZsrfbXWDsnjosOlvWAFqBgEdWVIa4IAYE3W'
    b'o30GNLXQ+YlgDddXvdY+tThzz7+Lz9CSrqJ3A2pNEAAs2Qhsm6axBv2TG4lLgK/+lUywBkPi'
    b'mhbzi6VsjyZVngyDAKCJRmZaT6pMFjFSaEMLeAOFDxdpuAjFuUEoAGshSxv3yaxRcB3Cn1U1'
    b'BecGnNWoAeA2BipXV2AgFCjwbkghinAddW4A70EeWCFcjgfUAHBxNqT6KgIgra0IwJqlVgKA'
    b'z7SSRsSuphtD7iG5AFHxSWyetywq6nCu6rUAMYZ7wh8eKnMdTFNpZiciiCdvGEKa/F6KoUw+'
    b'QNYXIgAeBlcVLJ6yNZUDgIzj+R/4a9M2D30Zos/tKHctZQGc38M51fU2CtUdfIGStdKdwK3C'
    b'pURoOYlMvBhrZS3A4/dBDUhP3S5Z89ozn/ZTwNcrTC7ikAAIFR90ovi0UumX2BdcVmdSxpdm'
    b'iGk4S+Zpco5a8gC24oMD+QiIAwEP9q9pnOSboxI/5DWdWFBj63A7nl/4eg1c6h2UCTIsGuT3'
    b'WrumkhbkGAC6o90jP485O5tEkS4QEkbKHHL1wOsEqSE66r1ZTwB7hMWym41YJABctxd9MHYm'
    b'CVfLIXVbNOBkJvvTylxn4PIk7IIjIT+mXS4RJwmAooS9PS+YqjeZ0gBRdQ5P3HK1yh5eG7sf'
    b'CwBso9aTrbIAKO/7zGMAQEqdpXZYFlp548s2xm5Om5v10ABIwmvyBpX/SpeSDwmAXKvo7ihU'
    b'AKD2OWJ8KAA8F7Pq7wWeJAC+T3BC0vUnBYC3t5ASVVC6rgaA7wn6LyCrxnhcL2R5+e2HcC0e'
    b'+eqF/AI1AEmmVWhq4v+FmFsVIHzJmYbxqfcHAkA2NtTd2g0BAJeyJiqTOnvzgOKBuRqhbPES'
    b'AghnAb7bX987gixAapRAu2IM/nABn71da7rEvoMVn28qDAcBkPBA+qXW+vU4I1FdecKjASBJ'
    b'iujPWkgIniUAWUQgv8goovBsAUBBpc/klkA8awCWQmYt9FP4u/2iLCAv7KZI6g5k+kOLqhYW'
    b'HAW48PUKAPMpTFUNPXkLCE14QudXBXjjLhAqUOj8VwAqtuVfLSDU5EKjQF37c/s8GhdIOjam'
    b'ubdpgdcSrRJXaPk9anOB+xa8rve9eAD+B1ASxW49lJMpAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
shizuku_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAAHYYAAB2GAV2iE4EAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMWK1UgwAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAA/u0CAOgDAAD+7QIA6AMA'
    b'AFBhaW50Lk5FVCA1LjEuMQADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAACq92RN8bsONgAABI1JREFUSEul'
    b'VUtsG1UUPTNjO46dj0mcT9sEpCo0IlAUxJJuUFFKUaOiwCJCiKplgQQSEuwoO0RViQ07smVT'
    b'tXwaJBaINFlkARsQUtKIkBBSWpKY2EmL7diJHc+8x7lvxnbThoLEle/MfZ97zv28ebbwH2X4'
    b'1YmotqwmrTX4K3xz6UQpWHqgPJDg9JnJHg2MEHCIqP20W2nT1DkuL1KvKaXHv738/Kpx2Ef2'
    b'JXjx7FScMOeh8SYBE8SUqM2jaksmInxlaY8p6AvXLp8smsm75D6CkXNT/XS6QvdBAyhgnDd4'
    b'Mg7suwiMzdcMlB6d+OykZFaTPQQCztcU90tpfEAB8E1/HNj7EEArrNE+Pvl5naRGIGXh4Dua'
    b'gzI27nRUCgwsIKq9ZV3DFm9jB8q93DOjlXds6stTply2PAI57yk96MkmGQVgDREbne0N6GiL'
    b'oFO03dcuaiRkgT5mn+9kZBC2835g+xmMnJ3sKVf0XEvcSUjE+W0PDWE6exq9h2JoiocZnWI2'
    b'Poo8xTGXL+PmSgGWY3MssVqSgaxnaRyd+uKFVZNBsaxHog124t03BvDe20/gke4ICjsKzU0h'
    b'xBpD8FwPLtXzRF2OXVSosUaH5LZZ0359BE4kQbKXxDAEfxW8oVdO96LvcBse7k3grdcfR1db'
    b'CC3NYTpJ5KIEofo2D6UoFJJtUVjBvERfFz0kTxJ8HO3vaeh/6sluU0/XVTh0sAWvvXwYzArF'
    b'HRflXbeaei1IGUvJGqMOEq1hkwWpfRL5aRx5duTrqHXl6nzySF/7fM/Blg7f1RfZmN8qI7W+'
    b'hZ9m01hY3jLzcqIEwHYshKmWZTEADzdu5qEsB7btmH7Qf0Npb8C6faecZGzzytMd0jm6+FFQ'
    b'LJ5DmwC7FQ/zC2ks3cjiodYI66/xZ2Ybt1aLJAT7orD8ew4VZcOxQyQlAbDBvgxY65ntKKOY'
    b'I05fuSxNVIjFeGp8DiNcMypzNknFzudLGPv0OvJFF5sbBaQyJUTCEWZWI/iNfTtqd3fGeCvq'
    b'XyXVzGYB84sb3CCHUERY5Jz79Za3BCBEWRJkt1zsll2kN3cYufj4fkFsS9Pjw6Xqh8ZbUYF9'
    b'wNODB8yJqG2j+FFXSblChpm5NEulkNkoklT2sPaMvEai9YS8AwJ9lY+sb+8VAb71R5YNLxlb'
    b'Il1dy+GHmdtwyxXcyZbhOAIuSnAq+XMkGBd/Q9DVEZf7fEzse0V8dkr8sCrK2AKS39rB4nIW'
    b'qXTRRG4HjQ3AKfqT6fFTK2JVSyRlucDXjD+qi9T+sf4k2ttifh84Fwk7SG1WeLqYkRPmaXOk'
    b'Rlwz5ZnlRyhYRmoEB7qaikxrlOaaP1MXuZOk7iJ+Rh6BIwiFglNTbzCvazU6/dVw7Y+nRiDS'
    b'3RlfJNBxmvdlUhPypFK84KSpjNpvvoGZJfhzLM2CDKqyh0BESHipHaN5kVpvPIHlI5R+/MgG'
    b'N/OiMzWHxf9nfZH31DP3gouYvP5J1tPFHr54K1onuPNRx7Faf/4lg3c+vJ5LxJ0lAk/Iaak2'
    b'9H/JSiofXc8Ukx989H0SuBQNpv9FgL8BobmWfM3j26MAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
beta_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACMklEQVRIS+2VT2sTURTF730T'
    b'01qa2k4UtFoVFD+AIkjNwk39AoIuXLnQIkjbUaQrrQaXNanFP+jCreIHqAtdqrUi6qYIBUGl'
    b'dKN9JohoSWaOZ5IGpHYy7djufJt5zMw9v3fPvXdGZZ2XrrO+xALG27ElaAkKED2mkFaIzDLq'
    b'jePr1YGSvo07YFNAIYvtRvCaIlv/EoJARXODVl80gzQFjLn+Q1E9AUiZYv0LRibSFTkoKdxh'
    b'4D7en/Ss6U0EuCJIdWbxncGtPOvIkNV8Q6jo4owq7gqkwgxaCKdzy6/IDIpt2KYbMReG0f8+'
    b'b16fNiTGXJym5j1mYJlBNlEG1130OIrPNQC017M6Ge5HM9icSuMlt3sAFDzrXFgTwIaKzFTT'
    b'cpK4YQp2M62pTVaPnBL9lQhwows7YfApDFboYV46oHhct4xtWtXjA2X9kLhNl1qkKgG9ekDB'
    b'3ZyDeu2Aa4PWXE5U5KgajLvYQdJ9IvoWG+AcG+DWqrsoChAKPRI4cy6eEXKIfs0OWdOzpoBQ'
    b'rOj6eVW9VMvC1y6vpKXlIJFz0CyDGiDr36b3Z8N9ZV7bL4r+SAxgMfMLxowOf9VwsmXxGzXD'
    b'bRstekKLjv6TRfWGYReJTNN3y+t+pp5hu/5kEx9gkd+vGvDnHPCUExTIUbyjIUTgKwm0n96/'
    b'azYLK65B2cpUJiN7jSPdMPLlvNXpuCELn0cCbnZiV9XBx5o9gea8b/p8JYJL3/kPiHUt9qcf'
    b'qxDzwm9g7hgohWJl9wAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
canary_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAAuGVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAAx3AQDoAwAADHcBAOgD'
    b'AABQYWludC5ORVQgNS4xLjExAAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAA'
    b'lgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAACCsPyy0vpjvAAAAx1JREFU'
    b'SEvtlF+IVFUcxz+/c+7ccXbdzNlGbZuCXdNGuFrUQxZR7UxQCGkg/aGsHsQHwSD1bV976w/S'
    b'S0IFBYs9FLEQCVHtlZUFox6idpdmI83VlLXBhk3Gde+dOceHO3ecuY6avQV9n87v+/ud7+/8'
    b'fr9zDvxXEE7er5IcgCSJm0F49F7H1hu7gGeBfuAEIgfd4amv45h/nSCY2JSmYT4FthILCVgL'
    b'wOtucfpdgK5l3Qh/17cpGuZQLA5QNxDWI3XgreDIxo3cTIJgYtNa81H/K/Ydns98OzuKyPbY'
    b'52jB/2GRQ19dREWKKUexjX/aosD39iPyhp6bz6hqBdLLqOfz2L4MWIsIVKoNlkLIr9IogV/m'
    b'wjPeqwsf37CCwPf2Am8DmRa5dAnn9CkkrLf6viqruWu1bs5ATs2cqJ/RSOG6FQS+txP4EAAR'
    b'9Nw8qlqJGmugMTiEWdHbmmwMC8V0cfoI15tB4HvPAR8k+Q4khJsIRWQ+NromCHzvKWD0mjOy'
    b'gKOxmXTT6EAFOBsbVyUIfO8R4DPATfqEqDUINAbuxKZTXfSZdIenFmKjI0Hge/cBY8Dydh5r'
    b'wRqs1pjcaup3r8dk+7q3SOT9DjNeBL63DvCBfMtrLYggqRTS24OtLWLDAOTKk03gE7c4/VI7'
    b'oYjE88CXQD46rQWlkN5e9G1ZdC6LWp4BRzer6Sr+I0r2JEkV+N4a4DCwHkBcF3XrCpxcP3rl'
    b'LUi6OYprCwP4iGxxH5+qJh0KeAbYgLWjOrvyeHTaHtCqQ1SU4Ohok6MjN3AS2Csp50l3eKp1'
    b'Ndshge/1NM7NOukHHnsRy8HEKeeAYyLUfjvJ08Ff1fTa3KWxyZ/DHbVF8/nWkfzLIhNh+4Yk'
    b'opv36xMPYuzRtqtZa34PB1RhfAFgiOLuTN+592YuzNwDa17LIS9UaBTgz/MdigmIKZf6gWPA'
    b'uiY3Boyowni5PXBXaXtm9vRPx5eC2jciMgL8Aez77vezB9rjroIpl74w5ZI15dK0KZda/3s3'
    b'bB68/eGHhu54NFoPbNk8OLAhGZOEmHLpMPA98KYqjC8mA/7HZXAzEzDbYzMiAAAAAElFTkSu'
    b'QmCC')

#----------------------------------------------------------------------
all_betas_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuMTGKCBbOAAAAuGVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAA'
    b'KAEDAAEAAAACAAAAMQECABEAAABaAAAAaYcEAAEAAABsAAAAAAAAAGAAAAABAAAAYAAAAAEA'
    b'AABQYWludC5ORVQgNS4xLjExAAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAA'
    b'lgAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAAAGNdRzso9yOwAAAjdJREFU'
    b'SEvVkztoU2EYhp/3JG2DNDYkLZTWG+LqoriUgoKLnRwEETqIi4NDkypSB/GGi9C0VVx0cuvq'
    b'5NJRFCulTkXoJFJctMfWeiXJeV2SNDmYkooOfab/+7/Ly/tfYKej+EacB93ui7qiKaMzMinD'
    b'CmIxUdHtsTW9idfH2VJgKufBAC8A/fEcxkLD+VAv46lGgvhGI4GjItBvs4517pe022WdNCwj'
    b'FOHJeE+clg5u4WQm5w0ghXWzEOpOLTed9UXJjzClfKguITd3b9LSQc8u+oAUgEXTMQgMYNiI'
    b'D5/Jlscb45YCUYpkPTDfasvJtHuRJ6qJJ/WaKlZiZLLbvbW45REVs96bkN8D2BrqKLFc7mQU'
    b'PAEMYOZ7Qp24gH4CzGRdRHywo9FIwWxSrOc/6XFLB0lvigegSgfHwPeBAcNiUNFobTiAAxYM'
    b'3yU6FUXdjuhkOw4kIuxZ4ACq9tl382Fwo/EepnOV51EpOH3li0K2uoM4hVXNF8LgYID2YeYA'
    b'kK7P5LjUWCeCp7XhbEegxliolYFQI5hXALKvNeYLqyo2xtsWADiLKsZVF+yZzjgTr6nxVwIA'
    b'iPpTLK9Rak5u0paAiE7d63W6Fk/lPCh0HgAzdxXV/0mctl4RgE0ELCFC4IggbfgBOjq+qrfN'
    b'3Zu0dND4DzDPBF8lDguOC9I2r6loaKvhtOvA1tB6yHw6zaEgwYADPl4OtRTv+RMtBR5mvL+c'
    b'8DsARxoe/6wX8Zp2aHlE/4qdL/Df+Q2LP9fnC7OtHgAAAABJRU5ErkJggg==')

#----------------------------------------------------------------------
permissions_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuNBLfpoMAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuNAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAADX5rshveZftAAAAm5JREFUSEvd'
    b'lE1IVUEYhp/v6M0sQ1LKHwKxRWkFKcRFg06C/aBmZdCiIDCxoI1Qy06IhJdqYYRBQbgrchEE'
    b'FZT940XCfiAojYTEjaQQFUJJ3rwzLe5R7p0zdt3WszvvvN+8M9+ZGfjXEVOw0dEfk5CENgF1'
    b'wE+gz3Nl1PTZWDCgs18tEZEKoB5oADYDIX94GngN3AMezqhfw2drsrUxBdgCIlFdBRwEdgMb'
    b'bB6D38Bb4AHQ67kykjyYUhyJqlyQD0Bxsg4JpyOgAa3MwXmeea7UJgtO8geQCWQYGiKg44qp'
    b'L5NMT33XIubS5skyBTMAIGV9IjAz/YPnNy7o801FRBryGIreUShrywN7swWkIA6MDPappz2n'
    b'Zc+pq3rbkTPc9PbL5NiwdgJ7DZI2QCuYGH1P4fowVXuPEW5s1QBfxz+ZVitpA8SBgtKNMjny'
    b'ihe3rzBwq1sAVpWUmVYraQO0gvKt9bLj+Dl9v7tN3ty9RnPXI726pExU3HQHSR+gYWlODtVN'
    b'J2RZ/hpqWzpkbWVN2ro5bMbAAdQ6Ia8sKqW/t4tLzRWMvRtQlp8cqDUDrGcvgUbNxiheV0nF'
    b'zsMsz80XizugpAR4rvPNv/ZBNEx8fEl5dR27WjwKSstFBU49A6Zg7gAgErgwGkJZ2YQPtMVz'
    b'8gr1As/FZ+CyKQZ6RuLBOwlcTBEFZmMzyhFHnMyQWRcD9nmu9Bm6PYBESKsfsmJOE/+xMzo9'
    b'Dhz1XHmSovrYWgSA50oP6LD/5sPcaUqd/Dqa8EKT87cdJBOJ6kagHdjiS4NAu+fKY8MaYFEB'
    b'AJ3ReEhwDgEKrXq97RmLuMf/A38A7868xh5PWVQAAAAASUVORK5CYII=')

#----------------------------------------------------------------------
google_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAB/UlEQVRIS7WVTUSmURTHK5Ji'
    b'Fn0SGSka0lD7Nk1azKIULaLSzDppjGFIpobSiNJitIiIWrVJH/ShXaSmXVFpkQyZYTIMU4um'
    b'j/n9Ob1u1/M+z5t6D3/3vuf5n/M/97z3OU9qSpItNcn5U6IEMiigCbwCVaAUZINrsAKWwSL4'
    b'Hq/QMIHXBH0FJRGnvOL5GOgB/3xuPIE+iP0BiU/w/TTRAu/5Er/rExH4BOmzQ9yy6rZZLxx/'
    b'MXsV8sZaplaqXffMP0EdT9ccxns7/m1Im1R1JpgN4rgCaRD2wQsjDlnlIbmjH7kCqmTBQk5M'
    b'6DI6RTjDFZiG2mb0TtbxxyZXvCtw6LSniP3pUwv8JqFeIlk60P0Osl2cLyPEYx1wT3BGUK4F'
    b'PmP9+wiBXmIH/Rbt4aiwpOWsB3EEJvFrZPiWj0Nxsg9gxBeYwtFhhC5WjYmH2EfIXyygnXXG'
    b'F2jAMW8EnaYS3DxAYQNutfFjHfBfNLWlzEiqaDhBASWWgOwYxFroj4pGHs45STVrBiJOojd/'
    b'Hehqy96CqbscQdNUo7fbEdlh/w5sOr7n7P8AjWj9X5pFslWgMR+bXUECmkmjnoiCj8APkAOC'
    b'3oNv+GvBvesd9sFpMaFCp/J4W12OVnDuE6I+mVkENIMaoFulPudZkl+s+shMAH0zAi1KIIHi'
    b'wylJF/gP78dSGaeIPe8AAAAASUVORK5CYII=')

#----------------------------------------------------------------------
android_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABsUlEQVRIS+2Uz0vCABTH33MI'
    b'ERJBQVBCvy5BENG8doluIsnMcFQQdKi/IKjuRn9Ahw4RBDW1nKFEtzp0dVK3upTWKSiK8ibb'
    b'6ykmzvxVKF4aG2Pwfd/P+343htDkA5vsD/+Amg23pqJxxT1wLZ8ma65XJKg0UzaBqHhWCegt'
    b'IavBeiBi0OMmA/oScninVF++opBXEHXjMt2ecd7NRD+rQUZDXlubrp/DR2pKW9Ey9QFYld0K'
    b'DHAjGDcEOMkf9AhvYydCCyA9AsEtAl0R4hinjSV8EbXcIhVfsqhITjaNIWDVD4HN+QSXJqtn'
    b'dQPY3I+I6/X0X9AQ+eOyulmzIkdA2gbAtV+Z58VEtMVJNopnTfEdirTIjRxkBZz7nW8nfC1X'
    b'qilXD8AeX7Os6czNEc0z5OgbUgCIu6IVOvqTXE1vXngBtowL09Z7hvaUTUT0bBWEwYyhRzn1'
    b'dH4upQnCMMwd69nnAmBCkZYsiPsmI6JXNu+qVhdv/MJLdZs1hhz3RQImgCPgydbh+Uv3pTNc'
    b'3aHmUxfMAEV64m3tjQCwx0PcFx4yARpk/MOmNX/TRqb5T1CzzS8Ot5MZGf0EQAAAAABJRU5E'
    b'rkJggg==')

#----------------------------------------------------------------------
axml_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuN4vW9zkAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuNwADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAAAlR56NozS1xQAABTNJREFUSEuN'
    b'lm1ok+cax3/PS5Kua5um9i3Vymjr5jzncCbnzIkc2Bgyk6FjdBP2RQQFZYPD+TB2NnfYN3Ev'
    b'Xw5lsFIoBcEeEDsEZR3O4erAuY6ocYR29s2lITXaNGmSNs2T5+Xahy6aph2e37f75v7/r/u+'
    b'ruu5eBTK6OrqGj5w4EDQ6/VimiaKoqCqKpZl4XK5ME0TVVVRVRXbtgmFQnLp0qV3gf+W+/wh'
    b'wWDwajKZlHQ6LaZpSrFYlFQqJbZtSzKZFNu2pVAoSCqVEhGRgYEBOXbsmADvVXqVUMsXuq6L'
    b'iNDb20s8HmdoaIhTp05x+/Zt+vr6SCQSDA4OcvLkSaLRKB6PhxMnTtDf3/8Z8EG5V4k1AUzT'
    b'pKqqim3btpFOp1lYWODgwYPMzc3R1dVFMpnEMAy6u7uZmpoCoKamhqNHj3L69OmPgf+U+1EZ'
    b'AEBE0HWduro6amtrOXv2LJ2dnaiqitfrRdM0Lly4QEdHB4ZhMDw8zMjICJs2bWLnzp0n/+gl'
    b'AAQCgZF0Oi2FQkEymYysrKzI7OysWJYlS0tLksvlZGVlRWKxmNi2LfF4XEZHR2V0dFRCoZBc'
    b'vXpVdu/e/UO5p16+ANA0jWg0Sm9vL/v378c0TWZmZmhsbKS/v5/u7m4WFhZobm5mz549tLW1'
    b'PdTmcjl8Pl+x3G9dihRF4caNGxw6dIjx8XEaGxvJ5/OEw2EOHz5MJBKhpaWF5eXlSimWZSEi'
    b'a/bWBRAR2tvbOX/+PF6vF4/Hg6ZpbNmyhaGhIZqamnC73SiKUil9PKUaiIiMj49LPp8XwzBk'
    b'cXFRTNOUyclJMQxDlpaWJJvNSiWpVEoCgcBIuee6F6iqSjQa5dy5c9y6dQvHcThz5gyDg4N0'
    b'dHRw+fJlenp6KBQKldIN2TDA9evX2bt3Lzdv3iQSieD3+xERxsbGuHv3Lrt27SIcDldKN2Rd'
    b'AICmpiauXbuG2+3G5/MxNjZGPB7H5/NRKBQIhUI0NDRUyh5PYF/gSjabFcdxJBwOy+LiooiI'
    b'TExMSDQaFRGRBw8eSCQSqcj+KplMRgL7AlfKPRWAre1b/3pv8f6HnVs7Xn7n+NuNNbU1uFxu'
    b'LMvEsiw8nipEHIpFE5euo+kahmGw2pGrbakoCvnlPF/09SanY3evtNW3nIrORm+Xeu39t3v+'
    b'/clTOzrJGyuICJZpobt0VFWlaBTRNBVZHYhYpoWiKji2g6Zrj26rKFR7nuDXsWl6//XZB8Cn'
    b'pRo4dQ1e6psbaPW3srl9M8biMtm5FJqjkLgTw626iP08TVNzExM/Rqh7spbEnRi++nr8m9vw'
    b't/lp9bdS39xAXYMXwKG8yCKC2A6O42BbNk/t6GQmMsmXPWd49oW/4NgOpz/6gm//N8zFvnPY'
    b'tkVmIY1t2YgIjrOqFdtZ8zVv2EUARaOIbdnU+OooLK/gOA6vHn8DVVV48c1XcGzBsR2MfAHb'
    b'tCrlD3kYQFVVVF1F1TQ0l8796D2ee+l5Xn/nLeZmYnie8PDnf+xk3+HX2P73P+GprqJxcwvX'
    b'v/qeRDSO7nahatqqh/ro3qUK7en627OvoCjcm0swn3iAjYMlNrlcDq3KxXI+j60I8/fnwaWQ'
    b'zWTQqz3U+xswbYvk/XlS8ykK2Txz0zHCV376BvhBAdi2/emtk79MHHm6tfPIx59/2l5TW/so'
    b'j1Jq5t+pXP+Ooijkcjk+/Of7sYnE9MAzO7YP3Bn7ZXbNoWAw+N1GQ+z/JZvNSjAY/K7cc81d'
    b'Sr8t1dXV6+b641AUhXw+z8WLF7+empp6tbT/G7WHAI0Qf0gxAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
open_url_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAW1JREFU'
    b'SEu1VdFtg0AMfVaD1DHIJjBJm0maTlI2aTYpY1SCyuU1Z2SOg4NUROIjcH7v2c/2CQ7+ycH4'
    b'+BfBM7TsgbKH3JaEPkRwglYCfDrQVoGmh7zHRLsJTtC3IegagFoAfCr730HOnmQXQQH9GABf'
    b'CaDA1RSzVD/3jMrhaTrIxUg2E0TgdVz3QPLFjHwWmwhy4Ka2gDKLSoFRQJbAG+oDU11TQJlB'
    b'+QScvyH0Jt+mFuTBg1IC1QZUQOkNPdpXogI6+Al0kDFbV7JbB6n53c7FWSZLRDUdpHHlGYEI'
    b'5gwdiZlpahZmBEFdxU7wneHLERRPDDVRq4PmDTWjrDPi/k4ZmjJ+kkHKUJfFOEDO0Ik3Wwhm'
    b'hlrNrVv2tO2kTZcm0auKltxkJWS36ZqhDH4EfDZorr/bhSFizCblyWUXbcW/UQ8b0s7vAk+u'
    b'inBLvbidz3O8UC5rN1fWg/gAifjOumcJIPc+u01zALnvhxP8AlTmwRkLqBmoAAAAAElFTkSu'
    b'QmCC')

#----------------------------------------------------------------------
logcat_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOBtp6qgAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAA'
    b'AFBhaW50Lk5FVCA1LjEuOAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAACrgCETU544KAAAAvlJREFUSEuV'
    b'lU9onFUUxX/nzUwTomlmJhVEBLF1ISq0UBcipXXlQhBFRBD/gFAQ0YWpllq6sHRhUdrMJOhC'
    b'ty4LLkXqoqBVwZWCRKQUN9JVmokpxknGvNPFvG/65psZtQce37vn3nfPe/f9+QCeAX4FXGq3'
    b'i/L4FeApgD/GOH1u1nvKGSbh41nPl8endlXZbAXQbvg4wR/ZRPDizFp4/3W0OZyyjw/3eHaX'
    b'41msNySC0VsL1/VJchsgDA8By08DSARJ7242vbI054PluOWmH5uKXhF6U+rnEX6yHDcigHhg'
    b'yBT3uervlho+VFCtud4TEX+DuDePtbk/txkrANgjezzl4G/b89Ht+Ri3wl+XenRreYBtJP7J'
    b'OZKAivoDyFxhvMgA02E3NU0THQdcjy7Yv2VhAjSygq43v5SENNCciKAwmEiNaf6M1y6NxJSJ'
    b'qmtf5bbRQ0Ttz7mcLyYiiapmvi/HjQpUaqdzO0QqwVRybhJ/h+qncpu89stN796J7FXwj4ha'
    b'f9P+u0xDMBuOOrJd5eqJVd0gFyguRrsZdyKxQqpxDluPY4KCLw85EnZib+edzlSxKlEqkdoN'
    b'7wc2ggJK2oo6iekl4yWF+HKK3wKVS7Kx2PQj+cQHAq26D7zd0c9I5wbhQJRftdzCPo+p0T/C'
    b'i9jLxq8NAo172lo8tqZfWnUfKOihIrfqri+sa32p4fei4tn/uwe2sX38WKf6WavusLCu9cI3'
    b'MUNr3s8Kfw7cWfblcIwdqLyy0NHXwHbZP1EA4NOG57riOeMXEPsM9whsuIa5EqQL3eurX5zg'
    b'rhsp18j1nyRwKPkuZ4MeBB5O/Z+A34FHgb1AJdkjF61AWaj4YRSHYBfwQ8ZfBI4Aaxl3oZRj'
    b'kHPklmaDlERmk/18agaOpu/d416EBAUgjllBjryufwPF3y2mtgacAk5mceQXrZjpOBQrKd7l'
    b'XKzANnAG+KDEm2xptx72YQiYgf4FS/2Z1A+p/esxnoR85gZeTBtb8BeBw8BqxpWfDQBuAnfx'
    b'MHe+O8KIAAAAAElFTkSuQmCC')

#----------------------------------------------------------------------
bootloader_versions_24 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5F'
    b'VCA1LjEuOBtp6qgAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAo'
    b'AQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAASRkBAOgDAABJGQEA6AMA'
    b'AFBhaW50Lk5FVCA1LjEuOAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAA'
    b'AAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAABth7jdgL6qmwAAAmZJREFUSEu1'
    b'lk1oE0EUx38zUmKCaKIgCXhZBRV68CDezEX0VMVDa4V6KGkRvArRQ1AQPRnwUGrBg+JJFA+C'
    b'VSsUUfzorbSiFKQSFyoFEcmuUIwxuM9DNnV3usk2h/7gkc3/vX3/2ZnZDyUibCQqaGBrpQAV'
    b'qvCxPPFMbT1omo17ba0WAQ/4GxW2Vt9trY6aDeJQIoKt1XvggJmMoArssjypmYl2aP93Pc0B'
    b'tndRCwGDbthsCp2INchUHTMOmjWdaK1B272a2B/4swXqs+QsT74F1I7EXkH9UyDmIDWy85JZ'
    b'04nYK8hUHVMqptPpG6bYjliD0BQloT7PBWDM8qQRyLQl1qAND4BRy5NfZsKka4P7AivAWcUy'
    b'cA94BbyzPFkxa4kyeCgwC5wHchFPpdMC14BlvzNADrwj8HGfYhK4bXmy1Kpfs4sqwDTw1EwA'
    b'nwUE2KvgK2ADJ4CtoEebd/hlYNHWaqR1zhqDKaAEPDMTwCTQZ2iHFJxR8Af42ZyHBHDH1moQ'
    b'02DGn99BBR+ABWNlHgPHwxIvBG4KHAa2had0zNZKhwymgHP+8UngSSD3VqAX2BFoUgHmgB/A'
    b'PFAJDygLZEIGz4HrwG5pjja4DlGj3wNcVHBFwTG/xiC1ajDtj/CL+h8J4I3Ab4FHQF/Ermrx'
    b'EkiZImxCRHAcRwYGBmRiYkIcx1mNUqkkQ0NDMj4+LoVCIZQrl8uitZZsNiuA9Pf3h/LO0oKI'
    b'SPM+cF33Vq1WO5VMJlPGO1m7rquHh4d1sVgkn8+3dAGk0Wh4gNfT0xM4BYDXwNV0Oj2DiHQM'
    b'/wVz19TXG6Gvio3gH6zTVSruMqDFAAAAAElFTkSuQmCC')


```

`ksu_asset_selector.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
import re
from i18n import _

# ============================================================================
#                      Class KsuAssetSelectorDialog
# ============================================================================
class KsuAssetSelectorDialog(wx.Dialog):
    def __init__(self, parent, assets, title="Select KSU Asset", message="Select a KSU asset:", suggested_asset=None, initial_filter=None):
        super().__init__(parent, title=title, style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER)

        self.assets = assets
        self.filtered_assets = assets.copy()
        self.selected_asset = None

        self.init_ui(message, suggested_asset, initial_filter)
        self.Centre()
        self.Bind(wx.EVT_CLOSE, self._on_close)

    def init_ui(self, message, suggested_asset, initial_filter):
        main_sizer = wx.BoxSizer(wx.VERTICAL)

        # Message
        message_text = wx.StaticText(self, label=message)
        main_sizer.Add(message_text, 0, wx.ALL | wx.EXPAND, 10)

        # Filter section
        filter_sizer = wx.BoxSizer(wx.HORIZONTAL)
        filter_label = wx.StaticText(self, label=_("Filter:"))
        filter_sizer.Add(filter_label, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 5)

        self.filter_text = wx.SearchCtrl(self, style=wx.TE_PROCESS_ENTER)
        self.filter_text.SetDescriptiveText(_("Search assets..."))
        self.filter_text.ShowSearchButton(True)
        self.filter_text.ShowCancelButton(True)

        # Set initial filter if provided
        if initial_filter:
            self.filter_text.SetValue(initial_filter)

        filter_sizer.Add(self.filter_text, 1, wx.EXPAND)

        main_sizer.Add(filter_sizer, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 10)

        # Asset list
        self.asset_list = wx.ListCtrl(self, style=wx.LC_REPORT | wx.LC_SINGLE_SEL)
        self.asset_list.AppendColumn(_("Asset Name"), width=500)
        self.asset_list.AppendColumn(_("Version"), width=100)
        self.asset_list.AppendColumn(_("Size"), width=120)

        main_sizer.Add(self.asset_list, 1, wx.ALL | wx.EXPAND, 10)

        # Suggested text
        self.suggested_text = None
        if suggested_asset:
            self.suggested_text = wx.StaticText(self, label=_("Suggested: %s") % suggested_asset['name'])
            self.suggested_text.SetFont(self.suggested_text.GetFont().Bold())
            main_sizer.Add(self.suggested_text, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM, 10)

        # Buttons
        button_sizer = wx.StdDialogButtonSizer()

        ok_button = wx.Button(self, wx.ID_OK, _("OK"))
        ok_button.SetDefault()
        button_sizer.AddButton(ok_button)

        cancel_button = wx.Button(self, wx.ID_CANCEL, _("Cancel"))
        button_sizer.AddButton(cancel_button)

        button_sizer.Realize()
        main_sizer.Add(button_sizer, 0, wx.ALL | wx.EXPAND, 10)

        self.SetSizer(main_sizer)

        # Check screen size and adjust dialog size if needed
        display = wx.Display()
        screen_size = display.GetGeometry().GetSize()

        # Desired size
        desired_width = 840
        desired_height = 950

        # Leave some margin from screen edges
        margin = 50
        max_width = screen_size.width - (margin * 2)
        max_height = screen_size.height - (margin * 2)

        # Adjust size to fit screen
        final_width = min(desired_width, max_width)
        final_height = min(desired_height, max_height)

        self.SetSize((final_width, final_height))

        # Bind events
        self.Bind(wx.EVT_BUTTON, self.on_ok, id=wx.ID_OK)
        self.asset_list.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_item_activated)
        self.filter_text.Bind(wx.EVT_TEXT, self.on_filter_changed)
        self.filter_text.Bind(wx.EVT_TEXT_ENTER, self.on_filter_changed)
        self.filter_text.Bind(wx.EVT_SEARCHCTRL_CANCEL_BTN, self.on_filter_cleared)

        # Apply initial filter if provided
        if initial_filter:
            self.apply_filter(initial_filter)

        # Initially populate the list
        self.populate_list(suggested_asset)

    def apply_filter(self, filter_text):
        filter_text = filter_text.strip().lower()

        if not filter_text:
            # No filter, show all assets
            self.filtered_assets = self.assets.copy()
        else:
            # Filter assets by name containing the filter text
            self.filtered_assets = [
                asset for asset in self.assets
                if filter_text in asset['name'].lower()
            ]

    def populate_list(self, suggested_asset=None):
        self.asset_list.DeleteAllItems()

        for i, asset in enumerate(self.filtered_assets):
            index = self.asset_list.InsertItem(i, asset['name'])

            # Extract version from asset name if possible
            match = re.search(r'\.([0-9]+)(?:_.*|)-', asset['name'])
            version = match.group(1) if match else _("Unknown")
            self.asset_list.SetItem(index, 1, version)

            # Format size
            size_bytes = asset.get('size', 0)
            if size_bytes > 1024 * 1024:
                size_str = f"{size_bytes / (1024 * 1024):.1f} MB"
            elif size_bytes > 1024:
                size_str = f"{size_bytes / 1024:.1f} KB"
            else:
                size_str = f"{size_bytes} B"
            self.asset_list.SetItem(index, 2, size_str)

            # Select suggested asset
            if suggested_asset and asset['name'] == suggested_asset['name']:
                self.asset_list.Select(index)
                self.asset_list.Focus(index)

    def on_filter_changed(self, event):
        filter_text = self.filter_text.GetValue()
        self.apply_filter(filter_text)
        # Repopulate the list with filtered results
        self.populate_list()

    def on_filter_cleared(self, event):
        self.filtered_assets = self.assets.copy()
        self.populate_list()

    def on_ok(self, event):
        selected_index = self.asset_list.GetFirstSelected()
        if selected_index != -1:
            self.selected_asset = self.filtered_assets[selected_index]
            self.EndModal(wx.ID_OK)
        else:
            wx.MessageBox(_("Please select an asset."), _("No Selection"), wx.OK | wx.ICON_WARNING)

    def on_item_activated(self, event):
        self.selected_asset = self.filtered_assets[event.GetIndex()]
        self.EndModal(wx.ID_OK)

    def get_selected_asset(self):
        return self.selected_asset

    def _on_close(self, event):
        self.EndModal(wx.ID_CANCEL)


# ============================================================================
#                  Function show_ksu_asset_selector
# ============================================================================
def show_ksu_asset_selector(parent, assets, title=_("Select KSU Asset"), message=_("Select a KSU asset:"), suggested_asset=None, initial_filter=None):
    dialog = KsuAssetSelectorDialog(parent, assets, title, message, suggested_asset, initial_filter)

    if dialog.ShowModal() == wx.ID_OK:
        selected_asset = dialog.get_selected_asset()
        dialog.Destroy()
        return selected_asset
    else:
        dialog.Destroy()
        return None

```

`locale/en/LC_MESSAGES/pixelflasher.po`:

```po
# English translations for PixelFlasher.
# Copyright (C) 2023-2024 Badabing2005
# This file is distributed under the same license as the PixelFlasher package.
msgid ""
msgstr ""
"Project-Id-Version: PixelFlasher\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-13 16:17+0000\n"
"PO-Revision-Date: 2024-05-13 16:17+0000\n"
"Last-Translator: PixelFlasher Developers <badabing2005@hotmail.com>\n"
"Language-Team: English\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"


##############################################################################
# Common buttons
##############################################################################
msgid "Yes"
msgstr ""

msgid "No"
msgstr ""

msgid "OK"
msgstr ""

msgid "Cancel"
msgstr ""

msgid "Apply"
msgstr ""

# Main Menu items
msgid "&File"
msgstr ""

msgid "&Device"
msgstr ""

msgid "Dev Tools"
msgstr ""

msgid "&My Tools"
msgstr ""

msgid "&Google Images"
msgstr ""

msgid "&Toolbar"
msgstr ""

msgid "&Language"
msgstr ""

msgid "&Help"
msgstr ""

##############################################################################
# Menu
##############################################################################
# -------------------------------------
# File menu items
# -------------------------------------
msgid "Settings"
msgstr ""

msgid "Exit"
msgstr ""

msgid "E&xit\tCtrl-Q"
msgstr ""

msgid "Exit PixelFlasher"
msgstr ""

# -------------------------------------
# Device menu items
# -------------------------------------
msgid "Install APK"
msgstr ""

msgid "Package Manager"
msgstr ""

msgid "ADB Shell"
msgstr ""

msgid "Scrcpy"
msgstr ""

msgid "Device Info"
msgstr ""

msgid "Pif Print"
msgstr ""

msgid "Props as Json"
msgstr ""

msgid "Dump Screen XML"
msgstr ""

msgid "Cancel OTA Update"
msgstr ""

msgid "Check otacerts"
msgstr ""

msgid "Partitions Manager"
msgstr ""

msgid "PI Analysis Report"
msgstr ""

msgid "Switch Slot"
msgstr ""

msgid "Reboot"
msgstr ""

# -------------------------------------
# Reboot sub-menu items
# -------------------------------------
msgid "System"
msgstr ""

msgid "Bootloader"
msgstr ""

msgid "Fastbootd"
msgstr ""

msgid "Recovery"
msgstr ""

msgid "Interactive Recovery"
msgstr ""

msgid "Safe Mode"
msgstr ""

msgid "Download"
msgstr ""

msgid "Sideload"
msgstr ""
# ---

msgid "Push file(s) to"
msgstr ""

msgid "Magisk"
msgstr ""

msgid "Rooting App"
msgstr ""

msgid "Magisk Backup Manager"
msgstr ""

msgid "Backup /data/adb"
msgstr ""

msgid "Restore /data/adb"
msgstr ""

msgid "Clear /data/adb/*"
msgstr ""

msgid "Start Shizuku"
msgstr ""

msgid "Pif Manager"
msgstr ""

msgid "SOS"
msgstr ""

msgid "Lock Bootloader"
msgstr ""

msgid "Unlock Bootloader"
msgstr ""

# -------------------------------------
# Dev Tools menu items
# -------------------------------------
msgid "Check keybox.xml"
msgstr ""

msgid "Decode Binary XML"
msgstr ""

msgid "AVB - Get Image Info"
msgstr ""

msgid "AVB - Prepare Downgrade Patch"
msgstr ""

# -------------------------------------
# My Tools menu items
# -------------------------------------
msgid "Customize My Tools"
msgstr ""

# Google Images menu items
msgid "Phones"
msgstr ""

msgid "Watches"
msgstr ""

msgid "Refresh images list"
msgstr ""

msgid "Show Progress Window"
msgstr ""

# -------------------------------------
# Toolbar menu items
# -------------------------------------
msgid "Top"
msgstr ""

msgid "Left"
msgstr ""

msgid "Right"
msgstr ""

msgid "Bottom"
msgstr ""

msgid "Show Button Text"
msgstr ""

msgid "Show Button Icon"
msgstr ""

msgid "Show / Hide Buttons"
msgstr ""

# -------------------------------------
# Toolbar Show / Hide Button
# sub-menu items share translations
# from Device menu items
# -------------------------------------
msgid "Reboot to System"
msgstr ""

msgid "Reboot to Bootloader"
msgstr ""

msgid "Reboot to Fastbootd"
msgstr ""

msgid "Reboot to Recovery"
msgstr ""

msgid "Reboot to Interactive Recovery"
msgstr ""

msgid "Reboot to Safe Mode"
msgstr ""

msgid "Reboot to Download"
msgstr ""

msgid "Reboot to Sideload"
msgstr ""

msgid "Configuration"
msgstr ""

msgid "Support"
msgstr ""

# -------------------------------------
# Help menu items
# -------------------------------------
msgid "Report an Issue"
msgstr ""

msgid "Feature Request"
msgstr ""

msgid "PixelFlasher Project Page"
msgstr ""

msgid "PixelFlasher Community (Forum)"
msgstr ""

msgid "Links"
msgstr ""

msgid "Open Configuration Folder"
msgstr ""

msgid "Open PixelFlasher Working Directory"
msgstr ""

msgid "Create a Sanitized support.zip"
msgstr ""

msgid "Check for New Version"
msgstr ""

msgid "&About PixelFlasher"
msgstr ""

msgid "About"
msgstr ""

# -------------------------------------
# Links sub-menu items
# -------------------------------------
msgid "Homeboy76's Guide"
msgstr ""

msgid "V0latyle's Guide"
msgstr ""

msgid "roirraW's Guide"
msgstr ""

msgid "osm0sis's PIF FAQ"
msgstr ""

msgid "V0latyle's PI API Info"
msgstr ""

msgid "Tricky Store (Support Thread)"
msgstr ""

msgid "osm0sis's PlayIntegrityFork"
msgstr ""

msgid "chiteroman's PlayIntegrityFix"
msgstr ""

msgid "5ec1cff's TrickyStore"
msgstr ""

msgid "Get the Google USB Driver"
msgstr ""

msgid "Android Security Update Bulletins"
msgstr ""

msgid "Android Codenames, tags, and build numbers"
msgstr ""

msgid "Full OTA Images for Pixel Phones / Tablets"
msgstr ""

msgid "Factory Images for Pixel Phones / Tablets"
msgstr ""

msgid "Full OTA Images for Pixel Watches"
msgstr ""

msgid "Factory Images for Pixel Watches"
msgstr ""

msgid "Full OTA Images for Pixel Beta 16"
msgstr ""

msgid "Factory Images for Pixel Beta 16"
msgstr ""

##############################################################################
# Helper values
##############################################################################
msgid "Open adb shell to the device"
msgstr ""

msgid "Launch Screen Copy"
msgstr ""

msgid "Dump Full Device Info"
msgstr ""

msgid "Get current device's Pif print (osm0sis fork v5 format)"
msgstr ""

msgid "Get current device's properties in json format"
msgstr ""

msgid "Use uiautomator to dump the screen view in xml"
msgstr ""

msgid "Cancels and Resets OTA updates by Google (Not PixelFlasher)"
msgstr ""

msgid "Used to see if ROM is signed or not."
msgstr ""

msgid "Backup / Erase Partitions"
msgstr ""

msgid "Generate a report of PI Analysis"
msgstr ""

msgid "Switch to the other slot"
msgstr ""

msgid "Manage Magisk modules and settings"
msgstr ""

msgid "Manage Magisk Backups"
msgstr ""

msgid ""
"Backs up /data/adb.\n"
"This is useful for backing up Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those paths will not be backed up."
msgstr ""

msgid ""
"Restore /data/adb from a backup file.\n"
"This is useful for restoring Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those items will not be restored."
msgstr ""

msgid ""
"Clear up /data/adb/ content (not the directory).\n"
"This is useful when switching to different root flavor."
msgstr ""

msgid "Starts Shizuku service on the device."
msgstr ""

msgid "Disable Magisk Modules"
msgstr ""

msgid "Unlock Bootloader (Will wipe data)"
msgstr ""

msgid "Get Android Verified Boot Image Info"
msgstr ""

msgid "Create Downgrade Patch"
msgstr ""

##############################################################################
# Toast messages
##############################################################################
msgid "Download Successful"
msgstr ""

msgid "✅ File downloaded successfully: %s and saved to %s"
msgstr ""

msgid "No Downloads"
msgstr ""

msgid "ℹ️ No downloads are in progress."
msgstr ""

msgid "⚠️ WARNING! SHA256 of the selected file does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr ""

msgid "APK Install"
msgstr ""

msgid "❌ ERROR: Please select a device before attempting APK Installation."
msgstr ""

msgid "❌ ERROR: No device selected"
msgstr ""

msgid "Check OTA Certs"
msgstr ""

msgid "Device Analysis"
msgstr ""

msgid "❌ ERROR: /data/local/tmp is not accessible, this will affect some features."
msgstr ""

msgid "vbmeta Warning!"
msgstr ""

msgid "WARNING! Banned Kernel"
msgstr ""

msgid "⚠️ Kernel string: %s is known to be banned.\nPlay Integrity would possibly fail."
msgstr ""

msgid "Scan"
msgstr ""

msgid "⚠️ No devices are found.."
msgstr ""

msgid "✅ Select your device from the list of %s found devices."
msgstr ""

msgid "Firmware SHA256"
msgstr ""

msgid "    ⚠️ WARNING! WARNING! WARNING!    Slot a verity / verification does not match slot b verity / verification"
msgstr ""

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verity state and device's verity state\n"
msgstr ""

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verification state and device's verification state\n"
msgstr ""

msgid "                                     This has a device wipe implications, please double check.\n"
msgstr ""

##############################################################################
# Message dialogs
##############################################################################
msgid "Error"
msgstr ""

msgid "Warning"
msgstr ""

msgid "Information"
msgstr ""

msgid "Success"
msgstr ""

msgid "Click OK to accept and continue.\n"
msgstr ""

msgid "or Hit CANCEL to abort."
msgstr ""

msgid "Select Language"
msgstr ""

msgid "Language changed to %s. A restart is required for translations to apply."
msgstr ""

msgid "Language Changed"
msgstr ""

msgid "Updates are available"
msgstr ""

msgid "ℹ️ There are updates available for PixelFlasher.\n"
msgstr ""

msgid "Click OK to download and install the updates.\n"
msgstr ""

msgid "Select binary xml file to decode"
msgstr ""

msgid "Select a file"
msgstr ""

msgid "Browse"
msgstr ""

msgid "  Browse  "
msgstr ""

msgid "Save File"
msgstr ""

msgid "ℹ️ There are updates available for your device.\nCheck Google Images menu.\n"
msgstr ""

msgid "Select one or multiple APK file(s) to install"
msgstr ""

msgid "Save support file"
msgstr ""

msgid "Dump Screen Xml"
msgstr ""

msgid "Save device analysis"
msgstr ""

msgid "Select files to push"
msgstr ""

msgid "Save /data/adb backup file"
msgstr ""

msgid "Select /data/adb backup file"
msgstr ""

msgid "Select keybox to test"
msgstr ""

msgid "Add / Edit / Delete Custom menu items"
msgstr ""

msgid "Select Boot Image"
msgstr ""

##############################################################################
# Main UI
##############################################################################
msgid "Downloads Progress"
msgstr ""

msgid "Welcome to PixelFlasher %s by Badabing2005"
msgstr ""

msgid "Install APK on the device"
msgstr ""

msgid "App Manager"
msgstr ""

msgid "Manage Apps / Packages"
msgstr ""

msgid "Open ADB shell to the device."
msgstr ""

msgid "Partitions"
msgstr ""

msgid "Partition Manager"
msgstr ""

msgid "Switch to the other Slot"
msgstr ""

msgid "Reboot to userspace fastboot (fastbootd)"
msgstr ""

msgid "iRecovery"
msgstr ""

msgid "Reboot to Download Mode"
msgstr ""

msgid "Reboot to Sideload Mode"
msgstr ""

msgid "Magisk Backup"
msgstr ""

msgid ""
"Remove Magisk Modules\n"
"This button issues the following command:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"This helps for cases where device bootloops due to incompatible magisk modules(YMMV).\n"
msgstr ""

msgid "Lock"
msgstr ""

msgid "UnLock"
msgstr ""

msgid "UnLock Bootloader\nCaution will wipe data\n"
msgstr ""

msgid "UnLock Bootloader"
msgstr ""

msgid "Configuration Settings"
msgstr ""

msgid "Create Support file"
msgstr ""

msgid "APK installation options"
msgstr ""

msgid "Install"
msgstr ""

msgid "Set ownership to Play Store Market"
msgstr ""

msgid "Bypass low target sdk block"
msgstr ""

msgid "ADB Connected Devices"
msgstr ""

msgid "ADB Connected Devices\nCurrent Active Slot: [A]"
msgstr ""

msgid "ADB Connected Devices\nCurrent Active Slot: [B]"
msgstr ""

msgid "Android Platform Tools\nVersion %s"
msgstr ""

msgid "Android Platform Tools"
msgstr ""

msgid "vbmeta issue."
msgstr ""

msgid "Warning!\n%s\n"
msgstr ""

msgid "❌ ERROR: You must first select a boot image"
msgstr ""

msgid "❌ ERROR: Downgrade patch file not found\nYou must first create a downgrade patch to enable this option.\n"
msgstr ""

msgid "❌ ERROR: Wipe All Data is selected\nYou must first select another mode to enable this option.\n"
msgstr ""

msgid "No Wipe Downgrade"
msgstr ""

msgid "                 WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr ""

msgid "THIS IS AN EXPERIMENTAL FEATURE, NO ASSURANCES THAT IT WOULD WORK\n\n"
msgstr ""

msgid "Do NOT enable this option if you are not downgrading!!!\n\n"
msgstr ""

msgid "Proceed only if you know what you're doing.\n\n\n"
msgstr ""

msgid "Do you want to continue to select the No Wipe Downgrade option?\n\n"
msgstr ""

msgid "       Press OK to continue or CANCEL to abort.\n\n"
msgstr ""

msgid "CANCEL"
msgstr ""

msgid "         WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr ""

msgid "NEVER, EVER LOCK THE BOOTLOADER WITHOUT REVERTING\n\n"
msgstr ""

msgid "TO STOCK FIRMWARE OR YOUR PHONE WILL BE BRICKED!!!\n\n\n"
msgstr ""

msgid "       THIS WILL WIPE YOUR DEVICE DATA!!!\n\n\n"
msgstr ""

msgid "Do you want to continue to Lock the device bootloader?\n\n"
msgstr ""

msgid "WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n\n"
msgstr ""

msgid "Make sure you first read either of the guides linked in the help menu.\n\n"
msgstr ""

msgid "Failing to follow the proper steps could potentially brick your phone.\n\n"
msgstr ""

msgid "\nNote: Pressing OK button will invoke a script that will utilize\n\n"
msgstr ""

msgid "fastboot commands, if your PC fastboot drivers are not properly setup,\n\n"
msgstr ""

msgid "fastboot will wait forever, and PixelFlasher will appear hung.\n\n"
msgstr ""

msgid "In such cases, killing the fastboot process will resume to normalcy.\n\n\n"
msgstr ""

msgid "      Do you want to continue to Lock the device bootloader?\n\n"
msgstr ""

msgid "              Press OK to continue or CANCEL to abort.\n\n"
msgstr ""

msgid "      Do you want to continue to Unlock the device bootloader?\n\n"
msgstr ""

msgid "WARNING!!! This is an experimental feature to attempt disabling magisk modules.\n\n\n"
msgstr ""

msgid "You would only need to do this if your device is bootlooping due to\n\n"
msgstr ""

msgid "incompatible magisk modules, this is not guaranteed to work in all cases (YMMV).\n\n"
msgstr ""

msgid "\nNote: Pressing OK button will invoke a script that will wait forever to detect the device.\n\n"
msgstr ""

msgid "If your device is not detected PixelFlasher will appear hung.\n\n"
msgstr ""

msgid "In such cases, killing the adb process will resume to normalcy.\n\n\n"
msgstr ""

msgid "                        Press OK to continue or CANCEL to abort.\n\n"
msgstr ""

msgid "Clear /data/adb/ contents"
msgstr ""

msgid "WARNING!!! This will the clear contents of /data/adb\n\n\n"
msgstr ""

msgid "Do you want to continue to clear /data/adb/ contents?\n\n"
msgstr ""

msgid "      Press OK to continue or CANCEL to abort.\n\n"
msgstr ""

msgid "This will invoke the command adb kill-server.\nAre you sure want to continue?\n"
msgstr ""

msgid "ADB Kill Server"
msgstr ""

msgid "Download Latest Android Platform-Tools"
msgstr ""

msgid "Select Android Platform-Tools Folder\nWhere adb and fastboot are located.\n"
msgstr ""

msgid "Double click this label to issue the command:\nadb kill-server"
msgstr ""

msgid "Open wireless manager dialog."
msgstr ""

msgid "[root status] [device mode] [device id] [device model] [device firmware]\n\n"
msgstr ""

msgid "✓ Rooted with Magisk.\n"
msgstr ""

msgid "✗ Probably Not Root (Magisk Tools not found).\n"
msgstr ""

msgid "?  Unable to determine the root status.\n\n"
msgstr ""

msgid "(adb) device is in adb mode\n"
msgstr ""

msgid "(f.b) device is in fastboot mode\n"
msgstr ""

msgid "(sid) device is in sideload mode\n"
msgstr ""

msgid "(rec) device is in recovery mode\n"
msgstr ""

msgid "Scan for Devices\nPlease manually select the device after the scan is completed."
msgstr ""

msgid "Device Image"
msgstr ""

msgid "Download image file for current Pixel device."
msgstr ""

msgid "Select Pixel Firmware"
msgstr ""

msgid "Process"
msgstr ""

msgid "Process the firmware file and extract the boot.img"
msgstr ""

msgid "Apply Custom ROM"
msgstr ""

msgid "Caution: Make sure you read the selected ROM documentation.\nThis might not work for your ROM"
msgstr ""

msgid "Select Custom ROM"
msgstr ""

msgid "Process the ROM file and extract the boot.img"
msgstr ""

msgid "Select a boot/init_boot"
msgstr ""

msgid "Show All boot/init_boot"
msgstr ""

msgid "Show all boot/init_boot even if it is\nnot part of the selected firmware or ROM"
msgstr ""

msgid "Source SHA1  "
msgstr ""

msgid "Package Fingerprint  "
msgstr ""

msgid "Patched with version "
msgstr ""

msgid "Patch Method  "
msgstr ""

msgid "Patched on Device  "
msgstr ""

msgid "Date  "
msgstr ""

msgid "Package Path  "
msgstr ""

msgid "Open Folder"
msgstr ""

msgid "Open boot files folder"
msgstr ""

msgid "Open Working Directory"
msgstr ""

msgid "Patch"
msgstr ""

msgid "Patch the selected item"
msgstr ""

msgid "Patch with Magisk"
msgstr ""

msgid "Patch with KernelSU"
msgstr ""

msgid "Patch with KernelSU LKM"
msgstr ""

msgid "Patch with KernelSU-Next"
msgstr ""

msgid "Patch with KernelSU-Next LKM"
msgstr ""

msgid "Patch with APatch"
msgstr ""

msgid "Patch with APatch Alternate"
msgstr ""

msgid "Patch custom boot/init_boot"
msgstr ""

msgid "Delete"
msgstr ""

msgid "Delete the selected item"
msgstr ""

msgid "Add a new boot item"
msgstr ""

msgid "Info"
msgstr ""

msgid "Get information about the selected item"
msgstr ""

msgid "Live Boot"
msgstr ""

msgid "Live boot to the selected item"
msgstr ""

msgid "Flash Boot"
msgstr ""

msgid "Flash just the selected item"
msgstr ""

msgid "Flash Mode"
msgstr ""

msgid "Keep Data"
msgstr ""

msgid "Data will be kept intact."
msgstr ""

msgid "WIPE all data"
msgstr ""

msgid "CAUTION: This will wipe your data"
msgstr ""

msgid "Dry Run"
msgstr ""

msgid ""
"Dry Run, no flashing will be done.\n"
"The phone will reboot to fastboot and then\n"
"back to normal.\n"
"This is for testing.\n"
msgstr ""

msgid "Full OTA"
msgstr ""

msgid "Flash full OTA, and have the choice of flashing patched image(s)."
msgstr ""

msgid "Custom Flash"
msgstr ""

msgid ""
"Custom Flash, Advanced option to flash a single file.\n"
"This will not flash the factory image.\n"
"It will flash the single selected file.\n"
msgstr ""

msgid "Live Boot to selected boot / init_boot"
msgstr ""

msgid "Flash"
msgstr ""

msgid "Flashes the selected boot / init_boot"
msgstr ""

msgid "Depending on the flash selection, paste the appropriate path as custom image."
msgstr ""

msgid "Flash Options"
msgstr ""

msgid "Flash to inactive slot"
msgstr ""

msgid "This option when checked will flash to the alternate slot (inactive).\nKeeping the current slot intact.\n"
msgstr ""

msgid "Flash to both slots"
msgstr ""

msgid "This option when checked will flash to both slots."
msgstr ""

msgid "Disable Verity"
msgstr ""

msgid "Disables Verity"
msgstr ""

msgid "Disable Verification"
msgstr ""

msgid "Disables Verification"
msgstr ""

msgid "Force"
msgstr ""

msgid "Force a flash operation that may be unsafe (will wipe your data)"
msgstr ""

msgid "Verbose"
msgstr ""

msgid "Set fastboot option to verbose"
msgstr ""

msgid "Temporary Root"
msgstr ""

msgid "Wipe"
msgstr ""

msgid ""
"This option when enabled will not flash patched boot\n"
"Instead it will flash unpatched boot.img, but boot to Live Patched boot\n"
"Handy to test if Magisk will cause a bootloop.\n"
"Please be aware that this temporary root will not survive a subsequent reboot.\n"
"If you want to make this permanent, just Flash Boot the patched boot image.\n"
msgstr ""

msgid "No reboot"
msgstr ""

msgid "Do not reboot after flashing\nThis is useful if you want to perform other actions before reboot.\n"
msgstr ""

msgid "This will invoke data wipe operation at the end of custom flashing.\nOne use case would be when disabling verification for the first time.\n"
msgstr ""

msgid "WARNING!!! This is a highly experimental feature.\nThis will attempt to downgrade the device without needing a data wipe.\n\n"
msgstr ""

msgid "Flash Device"
msgstr ""

msgid "Sideload OTA"
msgstr ""

msgid "Custom Flash Device"
msgstr ""

msgid "Flashes the selected device with chosen flash options."
msgstr ""

msgid "Console"
msgstr ""

msgid "Please be patient ..."
msgstr ""

msgid "Create encrypted and optionally sanitized support.zip file\nWhen sanitized all sensitive data is redacted.\n\nThis file is absolutely required when asking for help."
msgstr ""

msgid "Debug"
msgstr ""

msgid "Enable Debug Messages in the console."
msgstr ""

msgid "Clear Console"
msgstr ""

msgid "**APK installation options**<br/>\n"
msgstr ""

msgid "This is a summary of available options.<br/>\n"
msgstr ""

msgid "1. **Set ownership to Play Store Market** This option sets the ownership to Play Store (as if it was installed from Play Store).<br/>\n"
msgstr ""

msgid "   Android auto apps require that they be installed from the Play Market.<br/>\n"
msgstr ""

msgid "2. Starting with Android 14, apps with a targetSdkVersion lower than 23 can't be installed.<br/>\n"
msgstr ""

msgid "   Requiring apps to meet these minimum target API level requirements improves security and privacy for users.<br/><br/>\n"
msgstr ""

msgid "   Malware often targets older API levels in order to bypass security and privacy protections that have been introduced in newer Android versions.<br/>\n"
msgstr ""

msgid "   For example, some malware apps use a `targetSdkVersion` of 22 to avoid being subjected to the runtime permission model\n"
msgstr ""

msgid "   introduced in 2015 by Android 6.0 Marshmallow (API level 23).<br/>\n"
msgstr ""

msgid "   This Android 14 change makes it harder for malware to avoid security and privacy improvements.<br/>\n"
msgstr ""

msgid "   Attempting to install an app targeting a lower API level will result in an installation failure.<br/><br/>\n"
msgstr ""

msgid "   **Bypass low target sdk block** option bypasses that enforcement.\n"
msgstr ""

msgid "_If you have selected multiple APKs to install, the options will apply to all APKs._\n"
msgstr ""

msgid "**This feature will generate a device analysis report that you could optionally post online to get assistance on Play Integrity related issues.**<br/>\n"
msgstr ""

msgid "- Device state and other device related details.\n"
msgstr ""

msgid "- Magisk (if available):\n"
msgstr ""

msgid "	- modules list.\n"
msgstr ""

msgid "	- denylist.\n"
msgstr ""

msgid "- TrickyStore (if available):\n"
msgstr ""

msgid "	- `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)\n"
msgstr ""

msgid "- PlayIntegrity Fork (if available):\n"
msgstr ""

msgid "- PlayIntegrityFix (if available):\n"
msgstr ""

msgid "- Whether a testkey ROM is used or not.\n"
msgstr ""

msgid "- logcat for PlayIntegrity and TrickyStore related logs.\n"
msgstr ""

msgid "- Droidguard VM list.\n"
msgstr ""

msgid "- If any custom ROM injection apps are installed from:\n"
msgstr ""

msgid "- Check overlays (if contents of /debug_ramdisk is visible without root)\n"
msgstr ""

msgid "**NOTE:**\n"
msgstr ""

msgid "This report will be saved at a location of your choosing, and will **not** be part of PixelFlasher captured logs (even though you see it in the console), so rest assured, if you submit support.zip for PixelFlasher related issues, even if you had generated such report, it will never be included in the support.zip file.<br/>\n"
msgstr ""

msgid "Your privacy is yours to keep.<br/>\n"
msgstr ""

msgid "If you continue you'd only be generating the report, and not posting it online.<br/>\n"
msgstr ""

msgid "If you want to post it online, please make sure to remove any sensitive information from the report before posting it online.<br/>\n"
msgstr ""

msgid "**Are you sure you want to continue?**<br/>\n"
msgstr ""

##############################################################################
# Advanced Settings
##############################################################################
msgid "Advanced Configuration Settings"
msgstr ""

msgid "WARNING!\n"
msgstr ""

msgid "This is advanced configuration.\n"
msgstr ""

msgid "Unless you know what you are doing,\n"
msgstr ""

msgid "you should not be enabling it.\n"
msgstr ""

msgid "YOU AND YOU ALONE ARE RESPONSIBLE FOR ANYTHING THAT HAPPENS TO YOUR DEVICE.\n"
msgstr ""

msgid "THIS TOOL IS CODED WITH THE EXPRESS ASSUMPTION THAT YOU ARE FAMILIAR WITH\n"
msgstr ""

msgid "ADB, MAGISK, ANDROID, AND ROOT.\n"
msgstr ""

msgid "IT IS YOUR RESPONSIBILITY TO ENSURE THAT YOU KNOW WHAT YOU ARE DOING.\n"
msgstr ""

msgid "Enable Advanced Options"
msgstr ""

msgid "Expert mode"
msgstr ""

msgid "Magisk Package Name"
msgstr ""

msgid "If you have hidden Magisk,\nset this to the hidden package name."
msgstr ""

msgid "Resets package name to default: %s"
msgstr ""

msgid "Linux File Explorer:"
msgstr ""

msgid "Set full path to File Explorer.\nDefault: Nautilus"
msgstr ""

msgid "Linux Shell:"
msgstr ""

msgid "Set full path to Linux Shell.\nDefault: gnome-terminal"
msgstr ""

msgid "Offer Patch Methods"
msgstr ""

msgid "When patching the choice of method is presented."
msgstr ""

msgid "Patching Recovery Partition"
msgstr ""

msgid ""
"Enabling this will show an option to patch a recovery partition.\n"
"This should be kept disabled unless you have an old device.\n"
"(most A-only devices launched with Android 9, legacy SAR)"
msgstr ""

msgid "Use Busybox Shell"
msgstr ""

msgid "When creating a patch, if this is checked, busybox ash will be used as shell."
msgstr ""

msgid "System has low memory"
msgstr ""

msgid "Use this option to sacrifice speed in favor of memory."
msgstr ""

msgid "Extra img extraction"
msgstr ""

msgid "When checked and available in payload.bin\nAlso extract vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"
msgstr ""

msgid "Show notifications"
msgstr ""

msgid "When checked PixelFlasher will display system toast notifications."
msgstr ""

msgid "Always create boot.tar"
msgstr ""

msgid "When checked, PixelFlasher always creates boot.tar of the patched boot file.\nIf unchecked, only for Samsung firmware boot.tar will be created."
msgstr ""

msgid "Check for updates"
msgstr ""

msgid "Checks for available updates on startup"
msgstr ""

msgid "Check for Minimum Disk (5Gb)"
msgstr ""

msgid "Enforces minimum disk space of 5 Gb to allow flashing.\nThis avoids storage related issues."
msgstr ""

msgid "Check for bootloader unlocked"
msgstr ""

msgid "Checks to make sure bootloader is unlocked before flashing."
msgstr ""

msgid "Check for firmware hash validity"
msgstr ""

msgid "Checks for sha256 portion to be in the image filename to detect Pixel compatible image."
msgstr ""

msgid "Keep temporary support files"
msgstr ""

msgid "It keeps the temporary support files.\nUseful for inspecting what data is included in support.zip."
msgstr ""

msgid "Check Magisk modules for updates"
msgstr ""

msgid ""
"It checks if the module has updates.\n"
"Disable this if you don't want to check for updates or\n"
" if some module update server has issues and delays the process."
msgstr ""

msgid "Show custom ROM options"
msgstr ""

msgid "Make sure you check if your ROM is supported."
msgstr ""

msgid "Sanitize (Redact) support files"
msgstr ""

msgid ""
"The support files are always encrypted.\n"
"This option redacts sensitive information from the support files.\n"
"But impedes support and is not recommended."
msgstr ""

msgid "Force codepage to"
msgstr ""

msgid "Uses specified code page instead of system code page"
msgstr ""

msgid "Delete bundled libs"
msgstr ""

msgid "The listed libraries would be deleted from the PF bundle to allow system defined ones to be used."
msgstr ""

msgid "Example: libreadline.so.8, libgdk*"
msgstr ""

msgid "Override KMI"
msgstr ""

msgid ""
"This will override the Kernel Module Interface (KMI) to the specified value.\n"
"This is useful for devices with custom kernels.\n"
"The value will be passed to KernelSU as the KMI value."
msgstr ""

msgid "Example: 5.15.131-android14"
msgstr ""

msgid "Use Custom Fontface"
msgstr ""

msgid "Use custom font for monospace fonts\nMight require PixelFlasher restart to properly apply to the Console window."
msgstr ""

msgid "Sample "
msgstr ""

msgid "Select font size"
msgstr ""

msgid "scrcpy Path"
msgstr ""

msgid "Download scrcpy"
msgstr ""

msgid "Scrcpy executable (*.exe;*)|*.exe;*"
msgstr ""

msgid "Select scrcpy executable"
msgstr ""

msgid "Flags / Arguments (Example: --video-bit-rate 2M --max-fps=30 --max-size 1024)"
msgstr ""

msgid "Scrcpy settings"
msgstr ""

##############################################################################
# Message dialogs and toasts (modules.py)
##############################################################################
msgid "Module update URL has issues, inform the module author: %s\nDo you want to skip checking updates for this module?"
msgstr ""

msgid "You have an old or problematic Android platform Tools version %s \n"
msgstr ""

msgid "You are strongly advised to update before continuing.\n"
msgstr ""

msgid "Are you sure you want to continue?"
msgstr ""

msgid "Bad Android Platform Tools"
msgstr ""

msgid "Android SDK Version:    %s\n"
msgstr ""

msgid "Device:                 %s %s %s\n"
msgstr ""

msgid "Factory Image:          %s\n"
msgstr ""

msgid "Custom Rom:             %s\n"
msgstr ""

msgid "Custom Rom File:        %s\n"
msgstr ""

msgid "\nBoot image:             %s / %s \n"
msgstr ""

msgid "                        From: %s\n"
msgstr ""

msgid "                        Patched with %s on %s method:        %s\n"
msgstr ""

msgid "                        Patched with %s on %s\n"
msgstr ""

msgid "\nFlash Mode:             %s\n"
msgstr ""

msgid "SHA256 of %s%s matches the segment in the filename."
msgstr ""

msgid "⚠️ Firmware SHA256 Mismatch"
msgstr ""

msgid "WARNING! SHA256 of %s%s does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr ""

msgid "Process action"
msgstr ""

msgid "❌ Could not extract %s"
msgstr ""

msgid "Possibly extracted firmware."
msgstr ""

msgid "WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n"
msgstr ""

msgid "You should not extract the file, please select the downloaded firmware file instead\n\n"
msgstr ""

msgid "If this is not the case, and you want to continue with this selection\n"
msgstr ""

msgid "❌ Could not unpack %s."
msgstr ""

msgid "❌ Could not extract %s."
msgstr ""

msgid "❌ Could not find %s."
msgstr ""

msgid "⚠️ Detected unsupported firmware."
msgstr ""

msgid "❌ Could not extract payload.bin."
msgstr ""

msgid "❌ The selected firmware is not valid."
msgstr ""

msgid "⚠️ Nothing to extract from %s"
msgstr ""

msgid "✅ Process %s time: %s seconds"
msgstr ""

msgid "WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?"
msgstr ""

msgid "Confirm"
msgstr ""

msgid "Display is Locked!"
msgstr ""

msgid "ERROR: Your phone display is Locked.\n\n"
msgstr ""

msgid "Make sure you unlock your display\n"
msgstr ""

msgid "And set the display timeout to at least 1 minute.\n\n"
msgstr ""

msgid "After doing so, Click OK to accept and continue.\n"
msgstr ""

msgid "Manual Patching"
msgstr ""

msgid "Done creating the patch, continue"
msgstr ""

msgid "Magisk Manager is not detected."
msgstr ""

msgid "WARNING: Magisk Manager [%s] is not found on the phone\n\n"
msgstr ""

msgid "This could be either because it is hidden, or it is not installed (most likely not installed)\n\n"
msgstr ""

msgid "If it is installed and hidden, then you should abort and then unhide it.\n"
msgstr ""

msgid "If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n"
msgstr ""

msgid "WARNING: Do not install Magisk again if it is currently hidden.\n"
msgstr ""

msgid "Do you want PixelFlasher to download and install Magisk?\n"
msgstr ""

msgid "You will be given a choice of Magisk Version to install.\n\n"
msgstr ""

msgid "Click OK to continue with Magisk installation.\n"
msgstr ""

msgid "Kernel KMI Override"
msgstr ""

msgid "Kernel KMI Override: %s\n\n"
msgstr ""

msgid "You have set a custom kernel KMI override.\n"
msgstr ""

msgid "Are you sure you want to proceed with this override?\n"
msgstr ""

msgid "Click OK to proceed with the override.\n"
msgstr ""

msgid "Boot Model Mismatch"
msgstr ""

msgid "APatch Manual Patching"
msgstr ""

msgid "APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n"
msgstr ""

msgid "APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n"
msgstr ""

msgid "Do you want to continue regardless of not meeting the pre-requisites?\n\n"
msgstr ""

msgid "Click Yes to continue with APatch Manual Patching\n"
msgstr ""

msgid "or Hit No to abort."
msgstr ""

msgid "Download Latest KernelPatch Tools"
msgstr ""

msgid "Latest KernelPatch Tools Pre-release Version: %s\n"
msgstr ""

msgid "Latest KernelPatch Tools Release Version: %s\n\n"
msgstr ""

msgid "Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n"
msgstr ""

msgid "Click Yes to download the latest pre-release versions: %s\n"
msgstr ""

msgid "Click No to download the latest Release versions: %s\n"
msgstr ""

msgid "%s Boot"
msgstr ""

msgid "ERROR: Your phone model is: %s\n\n"
msgstr ""

msgid "The selected Boot is for: %s\n\n"
msgstr ""

msgid "Unless you know what you are doing, if you continue flashing\n"
msgstr ""

msgid "you risk bricking your device, proceed only if you are absolutely\n"
msgstr ""

msgid "certain that this is what you want, you have been warned.\n\n"
msgstr ""

msgid "Flash action"
msgstr ""

msgid "❌ Device is not detected."
msgstr ""

msgid "❌ Bootloader is locked, cannot flash."
msgstr ""

msgid "Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"
msgstr ""

msgid "❌ Android Platform Tools is not set."
msgstr ""

msgid "❌ Valid device is not selected."
msgstr ""

msgid "❌ boot is not selected."
msgstr ""

msgid "You can only sideload OTA that is equal or higher than the currently installed version.\n"
msgstr ""

msgid "Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n"
msgstr ""

msgid "See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n"
msgstr ""

msgid "If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n"
msgstr ""

msgid "You have selected to WIPE data\nAre you sure want to continue?"
msgstr ""

msgid "Wipe Data"
msgstr ""

msgid "✅ Wipe Data is accepted."
msgstr ""

msgid "You have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?"
msgstr ""

msgid "Flash option: Wipe"
msgstr ""

msgid "✅ Wipe is accepted."
msgstr ""

msgid "You have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?"
msgstr ""

msgid "Flash option: Force"
msgstr ""

msgid "✅ Force flag is accepted."
msgstr ""

msgid "❌ Not enough disk space."
msgstr ""

msgid "❌ Full OTA or factory image must be selected."
msgstr ""

msgid "Tensor device not on Android 13 or higher"
msgstr ""

msgid "WARNING: Your phone OS version is lower than Android 13.\n\n"
msgstr ""

msgid "If you are upgrading to Android 13 or newer,\n"
msgstr ""

msgid "make sure you at least flash the bootloader to both slots.\n"
msgstr ""

msgid "The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n"
msgstr ""

msgid "a bootloader update that increments the anti-roll back version for the bootloader.\n"
msgstr ""

msgid "This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n"
msgstr ""

msgid "After flashing an Android 13 build on these devices\n"
msgstr ""

msgid "you will not be able to flash and boot older Android 12 builds.\n\n"
msgstr ""

msgid "Selecting the option 'Flash to both slots'\n"
msgstr ""

msgid "Will take care of that.\n\n"
msgstr ""

msgid "Click OK to continue as is.\n"
msgstr ""

msgid "or Hit CANCEL to abort and change options."
msgstr ""

msgid "✅ Anti rollback warning acknowledged and bypassed."
msgstr ""

msgid "❌ downgrade_boot.img is not found."
msgstr ""

msgid "❌ Unable to replace boot.img in image.zip."
msgstr ""

msgid "⚠️ Live booting Pixel 7 or newer devices is not supported."
msgstr ""

msgid "❌ Image file is not selected."
msgstr ""

msgid "❌ Boot file is not found."
msgstr ""

msgid "❌ ROM file is not found."
msgstr ""

msgid "Device / Firmware Mismatch"
msgstr ""

msgid "The selected firmware is for: %s\n\n"
msgstr ""

msgid "✅ Device / Firmware mismatch acknowledged."
msgstr ""

msgid "❌ Encountered an error while rebooting to bootloader."
msgstr ""

msgid "❌ Encountered an error while rebooting to sideload."
msgstr ""

msgid "❌ Encountered an error while rebooting to fastbootd."
msgstr ""

msgid "❌ Encountered an error while running the flash script."
msgstr ""

msgid "❌ Encountered an error while flashing the patch."
msgstr ""

msgid "❌ vbmeta flashing did not return the expected result."
msgstr ""

msgid "❌ It appears that OTA flashing did not properly switch slots."
msgstr ""

msgid "⚠️ Device is not found after rebooting to bootloader."
msgstr ""

msgid "✅ Flashing elapsed time: %s seconds"
msgstr ""

msgid "You have selected  WIPE option.\nAdb debugging will be reset and disabled\nHence patch or vbmeta flashing will be skipped."
msgstr ""

msgid "%s %s \n"
msgstr ""

msgid "Device is not detected."
msgstr ""

msgid "Done rebooting to bootloader, continue"
msgstr ""

msgid "Done rebooting to system, continue"
msgstr ""

msgid "## Is your device waiting for interaction?\n"
msgstr ""

msgid "_If it is not, please hit the cancel button._\n"
msgstr ""

msgid "If your device is waiting for user interaction which can not be programmatically invoked.\n"
msgstr ""

msgid "- Using volume keys, scroll up and down and select **Reboot %s**\n"
msgstr ""

msgid "- Press the power button to apply.\n"
msgstr ""

msgid "When done, the device should reboot to %s <br/>\n"
msgstr ""

msgid "Wait for the device to fully boot to %s <br/>\n"
msgstr ""

msgid "Click on **Done rebooting to %s, continue** button <br/>\n"
msgstr ""

msgid "or hit the **Cancel** button to abort.\n"
msgstr ""

msgid "Waiting for user interaction"
msgstr ""

msgid "## Your watch should now be in Android Recovery\n"
msgstr ""

msgid "The watch is waiting for user interaction which can not be programmatically invoked.\n"
msgstr ""

msgid "- Using touch, scroll and select **Reboot to bootloader**\n"
msgstr ""

msgid "- Press the side button to apply.\n"
msgstr ""

msgid "When done, the watch should reboot to bootloader mode <br/>\n"
msgstr ""

msgid "Wait for the watch to indicate that it is in bootloader mode <br/>\n"
msgstr ""

msgid "Click on **Done rebooting to bootloader, continue** button <br/>\n"
msgstr ""

msgid "- Using touch, scroll and select **Reboot to system now**\n"
msgstr ""

msgid "When applied, the watch should reboot to system. <br/>\n"
msgstr ""

msgid "Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n"
msgstr ""

##############################################################################
# Pif Manager
##############################################################################
msgid "Active Pif"
msgstr ""

msgid "Loaded Pif (from Device)"
msgstr ""

msgid "Active pif is not modified."
msgstr ""

msgid "Save Active pif content to a json file on disk."
msgstr ""

msgid "Pif Module"
msgstr ""

msgid "Active pif is not saved in favorites."
msgstr ""

msgid "Select a folder to import pif json files."
msgstr ""

msgid "Output"
msgstr ""

msgid "Console Output:\nIt could be the json output of processed prop\nor it could be the Play Integrity Check result.\n\nThis is not what currently is on the device."
msgstr ""

msgid "Smart Paste:\nSets First API to the set value if it is missing or forced.\nReprocesses the output window content to adapt to current module requirements.\nPastes to Active pif."
msgstr ""

msgid "Paste the console window content to Active pif."
msgstr ""

msgid "Paste the Active pif to console window."
msgstr ""

msgid "Reprocess current Active Pif window json.\nUseful if you changed module version which might require additional / different fields."
msgstr ""

msgid "Reprocess one or many json file(s)\nUseful if you changed module version which might require additional / different fields.\nIf a single file is selected, the new json will output to console output\nHowever if multiple files are selected, the selected file will be updated in place."
msgstr ""

msgid "Process one or many json file(s) to generate the FrameworkPatcher formatted code excerpts.\n"
msgstr ""

msgid "Add missing Keys from device"
msgstr ""

msgid "When Processing or Reprocessing, add missing fields from device."
msgstr ""

msgid "Force First API to:"
msgstr ""

msgid "Forces First API value(s) to"
msgstr ""

msgid "Sort Keys"
msgstr ""

msgid "Sorts json keys"
msgstr ""

msgid "Keep All keys"
msgstr ""

msgid "Does not remove non standard / unrecognized keys"
msgstr ""

msgid "Spoof Build"
msgstr ""

msgid "Spoof Props"
msgstr ""

msgid "Spoof Provider"
msgstr ""

msgid "Spoof Signature"
msgstr ""

msgid "Close"
msgstr ""

msgid "Create print"
msgstr ""

msgid "Create pif.json / spoof_build_vars"
msgstr ""

msgid "Push print, no validation"
msgstr ""

msgid "Pushes the print as is without performing any validation.\nThis is useful to retain comments."
msgstr ""

msgid "Reload print"
msgstr ""

msgid "Reload pif.json / spoof_build_vars from device."
msgstr ""

msgid "Cleanup DG"
msgstr ""

msgid "Cleanup Droidguard Cache"
msgstr ""

msgid "Push keybox.xml"
msgstr ""

msgid "Push a valid keybox.xml to device."
msgstr ""

msgid "Edit TS Target"
msgstr ""

msgid "Edit Tricky Store target.txt file."
msgstr ""

msgid "Edit TS SP"
msgstr ""

msgid "Edit Tricky Store security_patch.txt file."
msgstr ""

msgid "Process build.prop(s)"
msgstr ""

msgid "Process build.prop to extract a compatible print."
msgstr ""

msgid "Process bulk props"
msgstr ""

msgid "Process a folder containing .prop files and convert then to .json files."
msgstr ""

msgid "Process Image"
msgstr ""

msgid "Process an image and get a print from it."
msgstr ""

msgid "Auto Update print"
msgstr ""

msgid "After Processing build.props, the print is automatically pushed to the device and the GMS process is killed."
msgstr ""

msgid "Auto Check Play Integrity"
msgstr ""

msgid "After saving (pushing) print, automatically run Play Integrity Check."
msgstr ""

msgid "Disable UIAutomator"
msgstr ""

msgid "Disables UIAutomator\nThis is useful for devices with buggy UIAutomator.\nNOTE: Create the coords.json file manually to make use of automated testing."
msgstr ""

msgid "Play Integrity Check"
msgstr ""

msgid "Play Integrity API Checker\nNote: Need to install app from Play store."
msgstr ""

msgid "Latest"
msgstr ""

msgid "Custom"
msgstr ""

msgid "Select 'Latest' to get the latest Pixel beta pif (Includes Developer Preview).\nSelect 'Custom' to set a custom Android version code."
msgstr ""

msgid "Set a valid Android version code."
msgstr ""

msgid "Get Pixel Beta Pif"
msgstr ""

msgid "Get the latest Pixel beta pif."
msgstr ""

msgid "Get Xiaomi Pif"
msgstr ""

msgid "Get Xiaomi.eu pif\nEasy to start but is not recommended as it gets banned quickly.\nRecommended to find your own."
msgstr ""

msgid "Get TheFreeman193 Random Pif"
msgstr ""

msgid "Get a random pif from TheFreeman193 repository.\nNote: The pif might or might not work."
msgstr ""

msgid "No Device is selected.\nPif Manager features are set to limited mode."
msgstr ""

msgid "Device is not rooted or SU permissions to adb shell is not granted.\nPif Manager features are set to limited mode."
msgstr ""

msgid "Update print"
msgstr ""

msgid "Update pif.json / spoof_build_vars."
msgstr ""

msgid "Create pif.json / spoof_build_vars."
msgstr ""

msgid "Getting Pixel beta print ...\nPlease be patient this could take some time ..."
msgstr ""

msgid "Failed to get beta print."
msgstr ""

msgid "Active pif not in sync"
msgstr ""

msgid "⚠️ WARNING! Device pif is not in sync with Active Pif contents.\nThe result will not be reflective of the Active pif you're viewing."
msgstr ""

msgid "Choose property files to open"
msgstr ""

msgid "Select a Device Image"
msgstr ""

msgid "Processing %s ...\nPlease be patient this could take some time ..."
msgstr ""

msgid "Image format not supported"
msgstr ""

msgid "Select folder to bulk process props files"
msgstr ""

msgid "The contents is different than what is currently on the device.\nUpdate the print before testing."
msgstr ""

msgid "Active pif is saved in favorites."
msgstr ""

msgid "Select keybox to push"
msgstr ""

msgid "Choose one or multiple json files to reprocess"
msgstr ""

msgid "Save FP file"
msgstr ""

msgid "Enter a label:"
msgstr ""

msgid "Save Pif to Favorites"
msgstr ""

msgid "Select folder to Import Pifs"
msgstr ""

##############################################################################
# Magisk
##############################################################################
msgid "❌ ERROR: You must first select a valid device."
msgstr ""

msgid "Manage Magisk"
msgstr ""

msgid "When you press the OK button, the Modules with checkbox selected will be enabled and the rest will be disabled."
msgstr ""

msgid "Magisk Modules"
msgstr ""

msgid "Enable / Disable Magisk modules"
msgstr ""

msgid "Install Module"
msgstr ""

msgid "Install magisk module."
msgstr ""

msgid "Update Module"
msgstr ""

msgid "Update magisk module."
msgstr ""

msgid "Uninstall Module"
msgstr ""

msgid "Uninstall magisk module."
msgstr ""

msgid "Run Action"
msgstr ""

msgid "Run Module action.sh."
msgstr ""

msgid "Install Pif / TS Module"
msgstr ""

msgid "Install Play Integrity Fix related modules."
msgstr ""

msgid "Install ZygiskNext Module"
msgstr ""

msgid "Install ZygiskNext module."
msgstr ""

msgid "Systemless Hosts"
msgstr ""

msgid "Add Systemless Hosts Module."
msgstr ""

msgid "Enable Zygisk"
msgstr ""

msgid "Enable Magisk zygisk (requires reboot)"
msgstr ""

msgid "Disable Zygisk"
msgstr ""

msgid "Disable Magisk zygisk (requires reboot)"
msgstr ""

msgid "Enable Denylist"
msgstr ""

msgid "Enable Magisk denylist"
msgstr ""

msgid "Disable Denylist"
msgstr ""

msgid "Disable Magisk denylist"
msgstr ""

msgid "Refresh"
msgstr ""

msgid "Refresh Magisk modules list."
msgstr ""

msgid "To manage denylist or to manage SU permissions, use PixelFlasher's App Manager feature."
msgstr ""

msgid "Use Pixelflasher's App Manager functionality to add/remove items to denylist or su permissions."
msgstr ""

msgid "Restore Module"
msgstr ""

msgid "## You need to reboot your device for the changes to take effect."
msgstr ""

msgid "osm0sis PlayIntegrityFork"
msgstr ""

msgid "chiteroman PlayIntegrityFix"
msgstr ""

msgid "PIF Module"
msgstr ""

msgid "Select the module you want to install"
msgstr ""

msgid "## You need to reboot your device to complete the installation."
msgstr ""

msgid "## You need to reboot your device to complete the update."
msgstr ""

msgid "Copy"
msgstr ""

msgid "Select All"
msgstr ""

msgid "Superuser Access"
msgstr ""

msgid "Superuser Access (requires reboot)"
msgstr ""

msgid "Apps Only"
msgstr ""

msgid "ADB Only"
msgstr ""

msgid "Apps and ADB"
msgstr ""

msgid "Disabled"
msgstr ""

##############################################################################
# Rooting App
##############################################################################
msgid "Download and Install Rooting Application"
msgstr ""

msgid "Select rooting app to install."
msgstr ""

msgid "Root App"
msgstr ""

msgid "Version"
msgstr ""

msgid "VersionCode"
msgstr ""

msgid "URL"
msgstr ""

msgid "Package"
msgstr ""

msgid "WARNING! Do not install magisk if you already have a hidden (stub) Magisk installed.\nFirst unhide Magisk before attempting an install."
msgstr ""

msgid "Download the rooting app."
msgstr ""

msgid "Copy URL to Clipboard"
msgstr ""

msgid "Copy Package ID to Clipboard"
msgstr ""

msgid "Download Selected Rooting App"
msgstr ""

msgid "Device Not Supported"
msgstr ""

msgid "The selected Magisk is not supported for your device\n"
msgstr ""

msgid "Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n"
msgstr ""

msgid "Unless you know what you are doing, if you choose to continue\n"
msgstr ""

msgid "you risk running into serious issues, proceed only if you are absolutely\n"
msgstr ""

##############################################################################
# Magisk Backup Manager
##############################################################################
msgid "Check / Uncheck All"
msgstr ""

msgid "Delete checked backups"
msgstr ""

msgid "Add Backup from Computer"
msgstr ""

msgid "Select a boot.img and create a backup from it.\nWARNING! No verification is done if the selected file is stock boot image or even for the correct device."
msgstr ""

msgid "Auto Create Backup"
msgstr ""

msgid "Checks current boot partition,\nFf it is a Magisk Patched with SHA1\nand the boot.img is available, then it\nAutomatically creates a backup of boot image."
msgstr ""

msgid "Closes this dialog"
msgstr ""

msgid "boot / init_boot image to create backup of."
msgstr ""

msgid "Delete Backup"
msgstr ""

msgid "Check All"
msgstr ""

msgid "UnCheck All"
msgstr ""

msgid "Copy to Clipboard"
msgstr ""

##############################################################################
# App Manager
##############################################################################
msgid "Set SU Permission"
msgstr ""

msgid "Enter SU Permission details:"
msgstr ""

msgid "Enable Notification"
msgstr ""

msgid "Enable Logging"
msgstr ""

msgid "Forever"
msgstr ""

msgid "10 mins"
msgstr ""

msgid "20 mins"
msgstr ""

msgid "30 mins"
msgstr ""

msgid "60 mins"
msgstr ""

msgid "Allow"
msgstr ""

msgid "Deny"
msgstr ""

msgid "Revoke"
msgstr ""

msgid "Manage Packages on the Device"
msgstr ""

msgid "%s Packages"
msgstr ""

msgid "Show System apps"
msgstr ""

msgid "Show 3rd Party apps"
msgstr ""

msgid "Get All Application Names"
msgstr ""

msgid "Extracts App names, and caches them for faster loading in the future.\nNOTE: This could take a while."
msgstr ""

msgid "Disable"
msgstr ""

msgid "Disable checked packages"
msgstr ""

msgid "Enable"
msgstr ""

msgid "Enable checked packages"
msgstr ""

msgid "Uninstall"
msgstr ""

msgid "Uninstall checked packages"
msgstr ""

msgid "Add to Denylist"
msgstr ""

msgid "Add package to Magisk Denylist"
msgstr ""

msgid "Remove from Denylist"
msgstr ""

msgid "Remove package from Magisk Denylist"
msgstr ""

msgid "Install an APK on the device"
msgstr ""

msgid "Download APK"
msgstr ""

msgid "Extract and download APK"
msgstr ""

msgid "Export List"
msgstr ""

msgid "Export the package list in CSV format"
msgstr ""

msgid "%s / %s Packages"
msgstr ""

msgid "Export Package list"
msgstr ""

msgid "Choose a directory where all apks should be saved."
msgstr ""

msgid "Download APK file"
msgstr ""

msgid "Disable Package"
msgstr ""

msgid "Enable Package"
msgstr ""

msgid "Uninstall Package"
msgstr ""

msgid "Download Package"
msgstr ""

msgid "Launch Package"
msgstr ""

msgid "View Application Permissions"
msgstr ""

msgid "Kill Application"
msgstr ""

msgid "Clear Application Data"
msgstr ""

msgid "Add Package to Magisk Denylist"
msgstr ""

msgid "Remove Package from Magisk Denylist"
msgstr ""

msgid "SU Permission ..."
msgstr ""

msgid "Before switching slots, please make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr ""

msgid "Switch Slot potential concerns"
msgstr ""

msgid "## ⚠️ WARNING: You have selected to flash both slots.<br/>\n"
msgstr ""

msgid "Please make sure your device is not subject to ARB concerns before clicking continue.<br/>\n"
msgstr ""

msgid "You have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr ""

msgid "Flash option: Flash to both slots"
msgstr ""

msgid "✅ Flash to both slots is accepted."
msgstr ""

msgid "Open URL on Device"
msgstr ""

msgid "Enter the URL to open on the device:"
msgstr ""

msgid "Open URL"
msgstr ""

msgid "Open a URL in the default browser"
msgstr ""

##############################################################################
# Additions 2025-07-20
##############################################################################
msgid "Keep Temp Files"
msgstr ""

msgid "Enabling this will keep temporary files used for patching.\nThis is useful for debugging purposes.\nIt is recommended to keep this disabled."
msgstr ""

msgid "Logcat"
msgstr ""

msgid "Logcat Viewer"
msgstr ""

msgid "Logcat filter: update_engine"
msgstr ""

msgid "Logcat filtered for update_engine to monitor OTA merging"
msgstr ""

msgid "Bootloader Versions"
msgstr ""

msgid "Get Bootloader Versions"
msgstr ""

msgid "Formatting Options"
msgstr ""

msgid "Enable formatting (-v)"
msgstr ""

msgid "Enable or disable formatting options for logcat output"
msgstr ""

msgid "Format Verbs"
msgstr ""

msgid "Show priority, tag, and PID of the process issuing the message"
msgstr ""

msgid "Show all metadata fields and separate messages with blank lines"
msgstr ""

msgid "Show PID only"
msgstr ""

msgid "Show the raw log message with no other metadata fields"
msgstr ""

msgid "Show the priority and tag only"
msgstr ""

msgid "Show priority, PID, and TID of the thread issuing the message"
msgstr ""

msgid "Show date, time, priority, tag, PID, and TID (default)"
msgstr ""

msgid "Show date, time, priority, tag, and PID of the process"
msgstr ""

msgid "Adverb Modifiers"
msgstr ""

msgid "Show each priority with a different color"
msgstr ""

msgid "Show event descriptions from event-log-tags database"
msgstr ""

msgid "Show time as seconds since 1970-01-01 (Unix epoch)"
msgstr ""

msgid "Show time as CPU seconds since boot"
msgstr ""

msgid "Ensure that any binary logging content is escaped"
msgstr ""

msgid "Show UID or Android ID of logged process (if permitted)"
msgstr ""

msgid "Show time with microsecond precision"
msgstr ""

msgid "Filter Options"
msgstr ""

msgid "Tag Filter"
msgstr ""

msgid "Tag:"
msgstr ""

msgid "Enter log component tag (or * for all)"
msgstr ""

msgid "Priority Level"
msgstr ""

msgid "Verbose (default for specific tag)"
msgstr ""

msgid "Debug (default for *)"
msgstr ""

msgid "Warn"
msgstr ""

msgid "Fatal"
msgstr ""

msgid "Silent (suppress all output)"
msgstr ""

msgid "Additional Filters"
msgstr ""

msgid "Regex Filter (-e):"
msgstr ""

msgid "Enter ECMAScript regex to filter output"
msgstr ""

msgid "UIDs Filter (comma-separated):"
msgstr ""

msgid "Enter UIDs (numeric, comma-separated)"
msgstr ""

msgid "View Logcat"
msgstr ""

msgid "View logcat output with selected options"
msgstr ""

msgid "Clear Logcat"
msgstr ""

msgid "Clear logcat buffer"
msgstr ""

msgid "Close this panel"
msgstr ""

msgid "No device connected"
msgstr ""

msgid "Logcat buffer cleared"
msgstr ""

##############################################################################
# Additions 2025-09-08
##############################################################################
msgid "Select Package for TargetedFix Target"
msgstr ""

msgid "Add Target"
msgstr ""

msgid "Add selected package as TargetedFix target"
msgstr ""

msgid "Get Application Names"
msgstr ""

msgid "TF Targets"
msgstr ""

msgid "TargetedFix Targets"
msgstr ""

msgid "Add TF Target"
msgstr ""

msgid "Add a new TargetedFix target by selecting from package list on device"
msgstr ""

msgid "Delete TF Target"
msgstr ""

msgid "Delete the selected TargetedFix target"
msgstr ""

msgid "Edit TF Targets"
msgstr ""

msgid "Edit TargetedFix targets file"
msgstr ""

msgid "Push TF Json"
msgstr ""

msgid "Push Active pif content as JSON to the selected TargetedFix target"
msgstr ""

msgid "Auto run migrate.sh"
msgstr ""

msgid "After saving (pushing) print, automatically run migrate.sh"
msgstr ""

msgid "	- Contents of every app json configuration referenced in target.txt\n"
msgstr ""

##############################################################################
# Additions 2025-09-24
##############################################################################
msgid "There will be two versions created.<br/>\n"
msgstr ""

msgid "1. Unfiltered version, that would have some sensitive information such as Device ID.\n"
msgstr ""

msgid "2. Sanitized version which will filter out sensitive information<br/>\n"
msgstr ""

msgid "**Note:** If you're using publicly shared keybox, keep the checkbox `Redact Keybox details` unticked so that the keybox information is included in the report.<br/>\n"
msgstr ""

msgid "If you're using a private keybox, please tick the checkbox `Redact Keybox details` to redact keybox details.<br/>\n"
msgstr ""

msgid "**This report will include the following details:**<br/>\n"
msgstr ""

msgid "- Playstore and GMS versions.\n"
msgstr ""

msgid "Redact Keybox details"
msgstr ""

##############################################################################
# Additions 2025-10-01
##############################################################################
msgid "Patch with SukiSU"
msgstr ""

msgid "Patch with SukiSU LKM"
msgstr ""

msgid "Select a pre-built kernel flavor"
msgstr ""

msgid "ShirkNeko flavor kernel"
msgstr ""

msgid "MiRinFork flavored kernel"
msgstr ""

msgid "WildKernels"
msgstr ""

##############################################################################
# Additions 2025-10-05
##############################################################################
msgid "Convert console content from env (key=value) prop format to json"
msgstr ""

msgid "Convert console content from json to env (key=value) prop format"
msgstr ""

##############################################################################
# Additions 2025-10-11
##############################################################################
msgid "Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"
msgstr ""

msgid "Push TF Prop"
msgstr ""

##############################################################################
# Additions 2025-10-18
##############################################################################
msgid "Select Device"
msgstr ""

msgid "Select a device:"
msgstr ""

msgid "Unknown"
msgstr ""

msgid "PixelFlasher guessed Kernel KMI"
msgstr ""

msgid "Your device kernel KMI is unknown probably because you're using\n"
msgstr ""

msgid "a custom kernel which has stripped out the Android build tag.\n\n"
msgstr ""

msgid "PixelFlasher has guessed the Kernel KMI to be: %s\n\n"
msgstr ""

msgid "Are you sure you want to proceed with this guessed KMI?\n"
msgstr ""

##############################################################################
# Additions 2025-11-03
##############################################################################

msgid "The selected path contains single quotes (').\n\nPlease rename the folder to remove the single quotes and try again."
msgstr ""

msgid "Options"
msgstr ""

msgid "Additional Options"
msgstr ""

msgid "Select Option"
msgstr ""

msgid "⚠️ WARNING: With Option 3, fingerprint can't be patched."
msgstr ""

msgid " (Recommended)"
msgstr ""

msgid "Latest Release"
msgstr ""

msgid "Latest Pre-Release"
msgstr ""

msgid "Latest Release or Pre-Release"
msgstr ""

msgid "Let me choose the kernel version from a matching list"
msgstr ""

msgid "Show all assets including non-matching ones"
msgstr ""

msgid "Flash to active slot"
msgstr ""

msgid "Flash boot partition"
msgstr ""

msgid "Flash init_boot partition"
msgstr ""

msgid "Flash vendor_boot partition"
msgstr ""

msgid "No Reboot after flash"
msgstr ""

msgid "## ✅ Live Boot the stock image:\n"
msgstr ""

msgid "## ✅ Live Boot the patched image:\n"
msgstr ""

msgid "## ❌ Live Booting is only supported for boot partition.\n"
msgstr ""

msgid "## ❌ Valid image is not found that supports live booting.\n"
msgstr ""

msgid "## ℹ️ Select partitions that you wish to flash stock image\n"
msgstr ""

msgid "## ℹ️ Select the options to flash a patch image:\n"
msgstr ""

msgid "## ❌ The selected image is not valid.<br/>\n"
msgstr ""

msgid "Edit script before continuing"
msgstr ""

##############################################################################
# Additions 2025-12-28
##############################################################################

##############################################################################
# Download Progress Window
##############################################################################
msgid "Downloading: %s"
msgstr ""

##############################################################################
# File Editor Window
##############################################################################
msgid "Open Shell"
msgstr ""

msgid "Save and Continue"
msgstr ""

msgid "Cancel and Abort"
msgstr ""

msgid "Open Folder in working directory"
msgstr ""

msgid "Open command shell in working directory"
msgstr ""

msgid "Open Folder in working directory\nNote: PF_FILEMANAGER needs to be set."
msgstr ""

msgid "Open Terminal shell in working directory"
msgstr ""

msgid "Save the file and continue."
msgstr ""

msgid "Cancel and Abort."
msgstr ""

##############################################################################
# Ksu Asset Selector
##############################################################################
msgid "Filter:"
msgstr ""

msgid "Search assets..."
msgstr ""

msgid "Asset Name"
msgstr ""

msgid "Size"
msgstr ""

msgid "Suggested: %s"
msgstr ""

msgid "Please select an asset."
msgstr ""

msgid "No Selection"
msgstr ""

msgid "Select KSU Asset"
msgstr ""

msgid "Select a KSU asset:"
msgstr ""

```

`locale/es/LC_MESSAGES/pixelflasher.po`:

```po
# Spanish translations for PixelFlasher.
# Copyright (C) 2023-2024 Badabing2005
# This file is distributed under the same license as the PixelFlasher package.
msgid ""
msgstr ""
"Project-Id-Version: PixelFlasher\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-13 16:17+0000\n"
"PO-Revision-Date: 2024-05-13 16:17+0000\n"
"Last-Translator: PixelFlasher Developers <badabing2005@hotmail.com>\n"
"Language-Team: Spanish\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"


##############################################################################
# Common buttons
##############################################################################
msgid "Yes"
msgstr "Sí"

msgid "No"
msgstr "No"

msgid "OK"
msgstr "Aceptar"

msgid "Cancel"
msgstr "Cancelar"

msgid "Apply"
msgstr "Aplicar"

# Main Menu items
msgid "&File"
msgstr "&Archivo"

msgid "&Device"
msgstr "&Dispositivo"

msgid "Dev Tools"
msgstr "Herramientas de desarrollo"

msgid "&My Tools"
msgstr "&Mis Herramientas"

msgid "&Google Images"
msgstr "&Imágenes de Google"

msgid "&Toolbar"
msgstr "&Barra de herramientas"

msgid "&Language"
msgstr "&Idioma"

msgid "&Help"
msgstr "&Ayuda"

##############################################################################
# Menu
##############################################################################
# -------------------------------------
# File menu items
# -------------------------------------
msgid "Settings"
msgstr "Configuración"

msgid "Exit"
msgstr "Salir"

msgid "E&xit\tCtrl-Q"
msgstr "&Salir\tCtrl-Q"

msgid "Exit PixelFlasher"
msgstr "Salir de PixelFlasher"

# -------------------------------------
# Device menu items
# -------------------------------------
msgid "Install APK"
msgstr "Instalar APK"

msgid "Package Manager"
msgstr "Administrador de paquetes"

msgid "ADB Shell"
msgstr "Terminal ADB"

msgid "Scrcpy"
msgstr "Scrcpy"

msgid "Device Info"
msgstr "Información del dispositivo"

msgid "Pif Print"
msgstr "Pif Print"

msgid "Props as Json"
msgstr "Props como Json"

msgid "Dump Screen XML"
msgstr "Volcar pantalla en XML"

msgid "Cancel OTA Update"
msgstr "Cancelar actualización OTA"

msgid "Check otacerts"
msgstr "Verificar otacerts"

msgid "Partitions Manager"
msgstr "Administrador de particiones"

msgid "PI Analysis Report"
msgstr "Informe de análisis PI"

msgid "Switch Slot"
msgstr "Cambiar ranura"

msgid "Reboot"
msgstr "Reiniciar"

# -------------------------------------
# Reboot sub-menu items
# -------------------------------------
msgid "System"
msgstr "Sistema"

msgid "Bootloader"
msgstr "Bootloader"

msgid "Fastbootd"
msgstr "Fastbootd"

msgid "Recovery"
msgstr "Recovery"

msgid "Interactive Recovery"
msgstr "Recovery interactivo"

msgid "Safe Mode"
msgstr "Modo seguro"

msgid "Download"
msgstr "Download"

msgid "Sideload"
msgstr "Sideload"
# ---

msgid "Push file(s) to"
msgstr "Enviar archivo(s) a"

msgid "Magisk"
msgstr "Magisk"

msgid "Rooting App"
msgstr "App de root"

msgid "Magisk Backup Manager"
msgstr "Administrador de copias de Magisk"

msgid "Backup /data/adb"
msgstr "Copia de seguridad de /data/adb"

msgid "Restore /data/adb"
msgstr "Restaurar /data/adb"

msgid "Clear /data/adb/*"
msgstr "Borrar /data/adb/*"

msgid "Start Shizuku"
msgstr "Iniciar Shizuku"

msgid "Pif Manager"
msgstr "Administrador Pif"

msgid "SOS"
msgstr "SOS"

msgid "Lock Bootloader"
msgstr "Bloquear Bootloader"

msgid "Unlock Bootloader"
msgstr "Desbloquear Bootloader"

# -------------------------------------
# Dev Tools menu items
# -------------------------------------
msgid "Check keybox.xml"
msgstr "Verificar keybox.xml"

msgid "Decode Binary XML"
msgstr "Decodificar XML binario"

msgid "AVB - Get Image Info"
msgstr "AVB - Obtener info imagen"

msgid "AVB - Prepare Downgrade Patch"
msgstr "AVB - Preparar parche de downgrade"

# -------------------------------------
# My Tools menu items
# -------------------------------------
msgid "Customize My Tools"
msgstr "Personalizar Mis Herramientas"

# Google Images menu items
msgid "Phones"
msgstr "Teléfonos"

msgid "Watches"
msgstr "Relojes"

msgid "Refresh images list"
msgstr "Actualizar lista de imágenes"

msgid "Show Progress Window"
msgstr "Mostrar ventana de progreso"

# -------------------------------------
# Toolbar menu items
# -------------------------------------
msgid "Top"
msgstr "Arriba"

msgid "Left"
msgstr "Izquierda"

msgid "Right"
msgstr "Derecha"

msgid "Bottom"
msgstr "Abajo"

msgid "Show Button Text"
msgstr "Mostrar texto de botones"

msgid "Show Button Icon"
msgstr "Mostrar iconos de botones"

msgid "Show / Hide Buttons"
msgstr "Mostrar / Ocultar botones"

# -------------------------------------
# Toolbar Show / Hide Button
# sub-menu items share translations
# from Device menu items
# -------------------------------------
msgid "Reboot to System"
msgstr "Reiniciar a Sistema"

msgid "Reboot to Bootloader"
msgstr "Reiniciar a Bootloader"

msgid "Reboot to Fastbootd"
msgstr "Reiniciar a Fastbootd"

msgid "Reboot to Recovery"
msgstr "Reiniciar a Recovery"

msgid "Reboot to Interactive Recovery"
msgstr "Reiniciar a Recovery interactivo"

msgid "Reboot to Safe Mode"
msgstr "Reiniciar a Modo seguro"

msgid "Reboot to Download"
msgstr "Reiniciar a Download"

msgid "Reboot to Sideload"
msgstr "Reiniciar a Sideload"

msgid "Configuration"
msgstr "Configuración"

msgid "Support"
msgstr "Soporte"

# -------------------------------------
# Help menu items
# -------------------------------------
msgid "Report an Issue"
msgstr "Reportar un problema"

msgid "Feature Request"
msgstr "Solicitar función"

msgid "PixelFlasher Project Page"
msgstr "Página del proyecto PixelFlasher"

msgid "PixelFlasher Community (Forum)"
msgstr "Comunidad PixelFlasher (Foro)"

msgid "Links"
msgstr "Enlaces"

msgid "Open Configuration Folder"
msgstr "Abrir carpeta de configuración"

msgid "Open PixelFlasher Working Directory"
msgstr "Abrir directorio de trabajo de PixelFlasher"

msgid "Create a Sanitized support.zip"
msgstr "Crear un support.zip sanitizado"

msgid "Check for New Version"
msgstr "Buscar nueva versión"

msgid "&About PixelFlasher"
msgstr "&Acerca de PixelFlasher"

msgid "About"
msgstr "Acerca"

# -------------------------------------
# Links sub-menu items
# -------------------------------------
msgid "Homeboy76's Guide"
msgstr "Guía de Homeboy76"

msgid "V0latyle's Guide"
msgstr "Guía de V0latyle"

msgid "roirraW's Guide"
msgstr "Guía de roirraW"

msgid "osm0sis's PIF FAQ"
msgstr "FAQ PIF de osm0sis"

msgid "V0latyle's PI API Info"
msgstr "Información de API PI de V0latyle"

msgid "Tricky Store (Support Thread)"
msgstr "Tricky Store (Hilo de soporte)"

msgid "osm0sis's PlayIntegrityFork"
msgstr "PlayIntegrityFork de osm0sis"

msgid "chiteroman's PlayIntegrityFix"
msgstr "PlayIntegrityFix de chiteroman"

msgid "5ec1cff's TrickyStore"
msgstr "TrickyStore de 5ec1cff"

msgid "Get the Google USB Driver"
msgstr "Obtener el controlador USB de Google"

msgid "Android Security Update Bulletins"
msgstr "Boletines de actualización de seguridad de Android"

msgid "Android Codenames, tags, and build numbers"
msgstr "Nombres en clave, etiquetas y números de compilación de Android"

msgid "Full OTA Images for Pixel Phones / Tablets"
msgstr "Imágenes OTA completas para teléfonos/tabletas Pixel"

msgid "Factory Images for Pixel Phones / Tablets"
msgstr "Imágenes de fábrica para teléfonos/tabletas Pixel"

msgid "Full OTA Images for Pixel Watches"
msgstr "Imágenes OTA completas para relojes Pixel"

msgid "Factory Images for Pixel Watches"
msgstr "Imágenes de fábrica para relojes Pixel"

msgid "Full OTA Images for Pixel Beta 16"
msgstr "Imágenes OTA completas para Pixel Beta 16"

msgid "Factory Images for Pixel Beta 16"
msgstr "Imágenes de fábrica para Pixel Beta 16"

##############################################################################
# Helper values
##############################################################################
msgid "Open adb shell to the device"
msgstr "Abrir terminal adb al dispositivo"

msgid "Launch Screen Copy"
msgstr "Iniciar copia de pantalla"

msgid "Dump Full Device Info"
msgstr "Volcar información completa del dispositivo"

msgid "Get current device's Pif print (osm0sis fork v5 format)"
msgstr "Obtener Pif print del dispositivo actual (formato fork v5 de osm0sis)"

msgid "Get current device's properties in json format"
msgstr "Obtener propiedades del dispositivo actual en formato json"

msgid "Use uiautomator to dump the screen view in xml"
msgstr "Usar uiautomator para volcar la vista de pantalla en xml"

msgid "Cancels and Resets OTA updates by Google (Not PixelFlasher)"
msgstr "Cancela y reinicia actualizaciones OTA de Google (No PixelFlasher)"

msgid "Used to see if ROM is signed or not."
msgstr "Utilizado para ver si la ROM está firmada o no."

msgid "Backup / Erase Partitions"
msgstr "Respaldar / Borrar particiones"

msgid "Generate a report of PI Analysis"
msgstr "Generar un informe de análisis PI"

msgid "Switch to the other slot"
msgstr "Cambiar a la otra ranura"

msgid "Manage Magisk modules and settings"
msgstr "Administrar módulos y configuración de Magisk"

msgid "Manage Magisk Backups"
msgstr "Administrar copias de seguridad de Magisk"

msgid ""
"Backs up /data/adb.\n"
"This is useful for backing up Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those paths will not be backed up."
msgstr ""
"Respalda /data/adb.\n"
"Esto es útil para hacer copias de seguridad de módulos Magisk.\n"
"NOTA: Si un módulo escribe en cualquier lugar que no sea /data/adb, esas rutas no se respaldará."

msgid ""
"Restore /data/adb from a backup file.\n"
"This is useful for restoring Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those items will not be restored."
msgstr ""
"Restaura /data/adb desde un archivo de respaldo.\n"
"Esto es útil para restaurar módulos Magisk.\n"
"NOTA: Si un módulo escribe en cualquier lugar que no sea /data/adb, esos elementos no se restaurarán."

msgid ""
"Clear up /data/adb/ content (not the directory).\n"
"This is useful when switching to different root flavor."
msgstr ""
"Borra el contenido de /data/adb/ (no el directorio).\n"
"Esto es útil al cambiar a una solución de root diferente."

msgid "Starts Shizuku service on the device."
msgstr "Inicia el servicio Shizuku en el dispositivo."

msgid "Disable Magisk Modules"
msgstr "Deshabilitar módulos Magisk"

msgid "Unlock Bootloader (Will wipe data)"
msgstr "Desbloquear Bootloader (Borrará datos)"

msgid "Get Android Verified Boot Image Info"
msgstr "Obtener información de imagen de arranque verificado de Android"

msgid "Create Downgrade Patch"
msgstr "Crear parche de downgrade"

##############################################################################
# toast messages
##############################################################################
msgid "Download Successful"
msgstr "Descarga exitosa"

msgid "✅ File downloaded successfully: %s and saved to %s"
msgstr "✅ Archivo descargado exitosamente: %s y guardado en %s"

msgid "No Downloads"
msgstr "Sin descargas"

msgid "ℹ️ No downloads are in progress."
msgstr "ℹ️ No hay descargas en progreso."

msgid "⚠️ WARNING! SHA256 of the selected file does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "⚠️ ¡ADVERTENCIA! El SHA256 del archivo seleccionado no coincide con los segmentos en el nombre del archivo.\nPor favor, verifique para asegurarse de que el checksum es correcto."

msgid "APK Install"
msgstr "Instalación de APK"

msgid "❌ ERROR: Please select a device before attempting APK Installation."
msgstr "❌ ERROR: Por favor seleccione un dispositivo antes de intentar la instalación de APK."

msgid "❌ ERROR: No device selected"
msgstr "❌ ERROR: Ningún dispositivo seleccionado"

msgid "Check OTA Certs"
msgstr "Verificar certificados OTA"

msgid "Device Analysis"
msgstr "Análisis de dispositivo"

msgid "❌ ERROR: /data/local/tmp is not accessible, this will affect some features."
msgstr "❌ ERROR: /data/local/tmp no es accesible, esto afectará algunas funciones."

msgid "vbmeta Warning!"
msgstr "¡Advertencia de vbmeta!"

msgid "WARNING! Banned Kernel"
msgstr "¡ADVERTENCIA! Kernel prohibido"

msgid "⚠️ Kernel string: %s is known to be banned.\nPlay Integrity would possibly fail."
msgstr "⚠️ Cadena de kernel: %s es conocida por estar prohibida.\nPlay Integrity posiblemente fallará."

msgid "Scan"
msgstr "Escanear"

msgid "⚠️ No devices are found.."
msgstr "⚠️ No se encontraron dispositivos.."

msgid "✅ Select your device from the list of %s found devices."
msgstr "✅ Seleccione su dispositivo de la lista de %s dispositivos encontrados."

msgid "Firmware SHA256"
msgstr "SHA256 del firmware"

msgid "    ⚠️ WARNING! WARNING! WARNING!    Slot a verity / verification does not match slot b verity / verification"
msgstr "    ⚠️ ¡ADVERTENCIA! ¡ADVERTENCIA! ¡ADVERTENCIA!    La verificación/verity del slot a no coincide con la verificación/verity del slot b"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verity state and device's verity state\n"
msgstr "    ⚠️ ¡ADVERTENCIA! ¡ADVERTENCIA! ¡ADVERTENCIA!    Hay una discrepancia entre el estado de verity de vbmeta seleccionado actualmente y el estado de verity del dispositivo\n"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verification state and device's verification state\n"
msgstr "    ⚠️ ¡ADVERTENCIA! ¡ADVERTENCIA! ¡ADVERTENCIA!    Hay una discrepancia entre el estado de verificación de vbmeta seleccionado actualmente y el estado de verificación del dispositivo\n"

msgid "                                     This has a device wipe implications, please double check.\n"
msgstr "                                     Esto tiene implicaciones de borrado de datos del dispositivo, por favor verifique nuevamente.\n"

##############################################################################
# Message dialogs
##############################################################################
msgid "Error"
msgstr "Error"

msgid "Warning"
msgstr "Advertencia"

msgid "Information"
msgstr "Información"

msgid "Success"
msgstr "Éxito"

msgid "Click OK to accept and continue.\n"
msgstr "Haz clic en ACEPTAR para aceptar y continuar.\n"

msgid "or Hit CANCEL to abort."
msgstr "o presiona CANCELAR para abortar."

msgid "Select Language"
msgstr "Seleccionar idioma"

msgid "Language changed to %s. A restart is required for translations to apply."
msgstr "Idioma cambiado a %s. Se requiere reiniciar para aplicar las traducciones."

msgid "Language Changed"
msgstr "Idioma cambiado"

msgid "Updates are available"
msgstr "Actualizaciones disponibles"

msgid "ℹ️ There are updates available for PixelFlasher.\n"
msgstr "ℹ️ Hay actualizaciones disponibles para PixelFlasher.\n"

msgid "Click OK to download and install the updates.\n"
msgstr "Haga clic en ACEPTAR para descargar e instalar las actualizaciones.\n"

msgid "Select binary xml file to decode"
msgstr "Seleccionar archivo xml binario para decodificar"

msgid "Select a file"
msgstr "Seleccionar un archivo"

msgid "Browse"
msgstr "Explorar"

msgid "  Browse  "
msgstr "  Explorar  "

msgid "Save File"
msgstr "Guardar archivo"

msgid "ℹ️ There are updates available for your device.\nCheck Google Images menu.\n"
msgstr "ℹ️ Hay actualizaciones disponibles para tu dispositivo.\nRevisa el menú de Imágenes de Google.\n"

msgid "Select one or multiple APK file(s) to install"
msgstr "Selecciona uno o varios archivos APK para instalar"

msgid "Save support file"
msgstr "Guardar archivo de soporte"

msgid "Dump Screen Xml"
msgstr "Volcar pantalla en XML"

msgid "Save device analysis"
msgstr "Guardar análisis del dispositivo"

msgid "Select files to push"
msgstr "Seleccionar archivos para enviar"

msgid "Save /data/adb backup file"
msgstr "Guardar archivo de respaldo de /data/adb"

msgid "Select /data/adb backup file"
msgstr "Seleccionar archivo de respaldo de /data/adb"

msgid "Select keybox to test"
msgstr "Seleccionar keybox para probar"

msgid "Add / Edit / Delete Custom menu items"
msgstr "Añadir / Editar / Eliminar elementos de menú personalizados"

msgid "Select Boot Image"
msgstr "Seleccionar imagen de arranque"

##############################################################################
# Main UI
##############################################################################
msgid "Downloads Progress"
msgstr "Progreso de descargas"

msgid "Welcome to PixelFlasher %s by Badabing2005"
msgstr "Bienvenido a PixelFlasher %s por Badabing2005"

msgid "Install APK on the device"
msgstr "Instalar APK en el dispositivo"

msgid "App Manager"
msgstr "Administrador de aplicaciones"

msgid "Manage Apps / Packages"
msgstr "Administrar Apps / Paquetes"

msgid "Open ADB shell to the device."
msgstr "Abrir terminal ADB al dispositivo."

msgid "Partitions"
msgstr "Particiones"

msgid "Partition Manager"
msgstr "Administrador de particiones"

msgid "Switch to the other Slot"
msgstr "Cambiar a la otra ranura"

msgid "Reboot to userspace fastboot (fastbootd)"
msgstr "Reiniciar a fastboot en espacio de usuario (fastbootd)"

msgid "iRecovery"
msgstr "iRecovery"

msgid "Reboot to Download Mode"
msgstr "Reiniciar a modo Download"

msgid "Reboot to Sideload Mode"
msgstr "Reiniciar a modo Sideload"

msgid "Magisk Backup"
msgstr "Copia de seguridad de Magisk"

msgid ""
"Remove Magisk Modules\n"
"This button issues the following command:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"This helps for cases where device bootloops due to incompatible magisk modules(YMMV).\n"
msgstr ""
"Eliminar módulos de Magisk\n"
"Este botón ejecuta el siguiente comando:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"Esto ayuda en casos donde el dispositivo entra en bucle de arranque debido a módulos de magisk incompatibles (YMMV).\n"

msgid "Lock"
msgstr "Bloquear"

msgid "UnLock"
msgstr "Desbloquear"

msgid "UnLock Bootloader\nCaution will wipe data\n"
msgstr "Desbloquear Bootloader\nPrecaución: borrará datos\n"

msgid "UnLock Bootloader"
msgstr "Desbloquear Bootloader"

msgid "Configuration Settings"
msgstr "Ajustes de configuración"

msgid "Create Support file"
msgstr "Crear archivo de soporte"

msgid "APK installation options"
msgstr "Opciones de instalación de APK"

msgid "Install"
msgstr "Instalar"

msgid "Set ownership to Play Store Market"
msgstr "Establecer propiedad a Play Store Market"

msgid "Bypass low target sdk block"
msgstr "Omitir bloqueo de SDK objetivo bajo"

msgid "ADB Connected Devices"
msgstr "Dispositivos conectados ADB"

msgid "ADB Connected Devices\nCurrent Active Slot: [A]"
msgstr "Dispositivos conectados ADB\nRanura activa actual: [A]"

msgid "ADB Connected Devices\nCurrent Active Slot: [B]"
msgstr "Dispositivos conectados ADB\nRanura activa actual: [B]"

msgid "Android Platform Tools\nVersion %s"
msgstr "Herramientas de plataforma Android\nVersión %s"

msgid "Android Platform Tools"
msgstr "Herramientas de plataforma Android"

msgid "vbmeta issue."
msgstr "Problema de vbmeta."

msgid "Warning!\n%s\n"
msgstr "¡Advertencia!\n%s\n"

msgid "❌ ERROR: You must first select a boot image"
msgstr "❌ ERROR: Primero debes seleccionar una imagen de arranque"

msgid "❌ ERROR: Downgrade patch file not found\nYou must first create a downgrade patch to enable this option.\n"
msgstr "❌ ERROR: Archivo de parche de downgrade no encontrado\nPrimero debes crear un parche de downgrade para habilitar esta opción.\n"

msgid "❌ ERROR: Wipe All Data is selected\nYou must first select another mode to enable this option.\n"
msgstr "❌ ERROR: La opción Borrar todos los datos está seleccionada\nPrimero debes seleccionar otro modo para habilitar esta opción.\n"

msgid "No Wipe Downgrade"
msgstr "Downgrade sin borrar datos"

msgid "                 WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "                 ¡¡¡ADVERTENCIA!!! ¡¡¡ADVERTENCIA!!! ¡¡¡ADVERTENCIA!!!\n\n\n"

msgid "THIS IS AN EXPERIMENTAL FEATURE, NO ASSURANCES THAT IT WOULD WORK\n\n"
msgstr "ESTA ES UNA FUNCIÓN EXPERIMENTAL, SIN GARANTÍAS DE QUE FUNCIONE\n\n"

msgid "Do NOT enable this option if you are not downgrading!!!\n\n"
msgstr "¡¡¡NO habilite esta opción si no está haciendo downgrade!!!\n\n"

msgid "Proceed only if you know what you're doing.\n\n\n"
msgstr "Proceda solo si sabe lo que está haciendo.\n\n\n"

msgid "Do you want to continue to select the No Wipe Downgrade option?\n\n"
msgstr "¿Desea continuar y seleccionar la opción de Downgrade sin borrar datos?\n\n"

msgid "       Press OK to continue or CANCEL to abort.\n\n"
msgstr "       Presione ACEPTAR para continuar o CANCELAR para abortar.\n\n"

msgid "CANCEL"
msgstr "CANCELAR"

msgid "         WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "         ¡¡¡ADVERTENCIA!!! ¡¡¡ADVERTENCIA!!! ¡¡¡ADVERTENCIA!!!\n\n\n"

msgid "NEVER, EVER LOCK THE BOOTLOADER WITHOUT REVERTING\n\n"
msgstr "NUNCA, JAMÁS BLOQUEE EL BOOTLOADER SIN VOLVER\n\n"

msgid "TO STOCK FIRMWARE OR YOUR PHONE WILL BE BRICKED!!!\n\n\n"
msgstr "AL FIRMWARE ORIGINAL O SU TELÉFONO QUEDARÁ INUTILIZADO!!!\n\n\n"

msgid "       THIS WILL WIPE YOUR DEVICE DATA!!!\n\n\n"
msgstr "       ¡¡¡ESTO BORRARÁ LOS DATOS DE SU DISPOSITIVO!!!\n\n\n"

msgid "Do you want to continue to Lock the device bootloader?\n\n"
msgstr "¿Desea continuar para bloquear el bootloader del dispositivo?\n\n"

msgid "WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n\n"
msgstr "¡¡¡ADVERTENCIA!!! ESTO BORRARÁ TODOS LOS DATOS DE USUARIO DEL DISPOSITIVO\n\n\n"

msgid "Make sure you first read either of the guides linked in the help menu.\n\n"
msgstr "Asegúrese de leer primero alguna de las guías vinculadas en el menú de ayuda.\n\n"

msgid "Failing to follow the proper steps could potentially brick your phone.\n\n"
msgstr "No seguir los pasos adecuados podría potencialmente inutilizar su teléfono.\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will utilize\n\n"
msgstr "\nNota: Al presionar el botón ACEPTAR se ejecutará un script que utilizará\n\n"

msgid "fastboot commands, if your PC fastboot drivers are not properly setup,\n\n"
msgstr "comandos fastboot, si los controladores fastboot de su PC no están configurados correctamente,\n\n"

msgid "fastboot will wait forever, and PixelFlasher will appear hung.\n\n"
msgstr "fastboot esperará indefinidamente, y PixelFlasher parecerá bloqueado.\n\n"

msgid "In such cases, killing the fastboot process will resume to normalcy.\n\n\n"
msgstr "En tales casos, terminar el proceso fastboot volverá a la normalidad.\n\n\n"

msgid "      Do you want to continue to Lock the device bootloader?\n\n"
msgstr "      ¿Desea continuar para bloquear el bootloader del dispositivo?\n\n"

msgid "              Press OK to continue or CANCEL to abort.\n\n"
msgstr "              Presione ACEPTAR para continuar o CANCELAR para abortar.\n\n"

msgid "      Do you want to continue to Unlock the device bootloader?\n\n"
msgstr "      ¿Desea continuar para desbloquear el bootloader del dispositivo?\n\n"

msgid "WARNING!!! This is an experimental feature to attempt disabling magisk modules.\n\n\n"
msgstr "¡¡¡ADVERTENCIA!!! Esta es una función experimental para intentar deshabilitar los módulos de magisk.\n\n\n"

msgid "You would only need to do this if your device is bootlooping due to\n\n"
msgstr "Solo necesitaría hacer esto si su dispositivo está en bucle de arranque debido a\n\n"

msgid "incompatible magisk modules, this is not guaranteed to work in all cases (YMMV).\n\n"
msgstr "módulos de magisk incompatibles, no se garantiza que funcione en todos los casos (YMMV).\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will wait forever to detect the device.\n\n"
msgstr "\nNota: Al presionar el botón ACEPTAR se ejecutará un script que esperará indefinidamente para detectar el dispositivo.\n\n"

msgid "If your device is not detected PixelFlasher will appear hung.\n\n"
msgstr "Si su dispositivo no es detectado, PixelFlasher parecerá bloqueado.\n\n"

msgid "In such cases, killing the adb process will resume to normalcy.\n\n\n"
msgstr "En tales casos, terminar el proceso adb volverá a la normalidad.\n\n\n"

msgid "                        Press OK to continue or CANCEL to abort.\n\n"
msgstr "                        Presione ACEPTAR para continuar o CANCELAR para abortar.\n\n"

msgid "Clear /data/adb/ contents"
msgstr "Borrar contenido de /data/adb/"

msgid "WARNING!!! This will the clear contents of /data/adb\n\n\n"
msgstr "¡¡¡ADVERTENCIA!!! Esto borrará el contenido de /data/adb\n\n\n"

msgid "Do you want to continue to clear /data/adb/ contents?\n\n"
msgstr "¿Desea continuar para borrar el contenido de /data/adb/?\n\n"

msgid "      Press OK to continue or CANCEL to abort.\n\n"
msgstr "      Presione ACEPTAR para continuar o CANCELAR para abortar.\n\n"

msgid "This will invoke the command adb kill-server.\nAre you sure want to continue?\n"
msgstr "Esto ejecutará el comando adb kill-server.\n¿Está seguro de que desea continuar?\n"

msgid "ADB Kill Server"
msgstr "Detener servidor ADB"

msgid "Download Latest Android Platform-Tools"
msgstr "Descargar las últimas herramientas de plataforma Android"

msgid "Select Android Platform-Tools Folder\nWhere adb and fastboot are located.\n"
msgstr "Seleccionar carpeta de herramientas de plataforma Android\nDonde se encuentran adb y fastboot.\n"

msgid "Double click this label to issue the command:\nadb kill-server"
msgstr "Haga doble clic en esta etiqueta para ejecutar el comando:\nadb kill-server"

msgid "Open wireless manager dialog."
msgstr "Abrir diálogo de administrador inalámbrico."

msgid "[root status] [device mode] [device id] [device model] [device firmware]\n\n"
msgstr "[estado de root] [modo del dispositivo] [id del dispositivo] [modelo del dispositivo] [firmware del dispositivo]\n\n"

msgid "✓ Rooted with Magisk.\n"
msgstr "✓ Rooteado con Magisk.\n"

msgid "✗ Probably Not Root (Magisk Tools not found).\n"
msgstr "✗ Probablemente sin Root (No se encontraron herramientas de Magisk).\n"

msgid "?  Unable to determine the root status.\n\n"
msgstr "?  No se puede determinar el estado de root.\n\n"

msgid "(adb) device is in adb mode\n"
msgstr "(adb) dispositivo en modo adb\n"

msgid "(f.b) device is in fastboot mode\n"
msgstr "(f.b) dispositivo en modo fastboot\n"

msgid "(sid) device is in sideload mode\n"
msgstr "(sid) dispositivo en modo sideload\n"

msgid "(rec) device is in recovery mode\n"
msgstr "(rec) dispositivo en modo recovery\n"

msgid "Scan for Devices\nPlease manually select the device after the scan is completed."
msgstr "Buscar dispositivos\nPor favor, seleccione manualmente el dispositivo después de que el escaneo se complete."

msgid "Device Image"
msgstr "Imagen del dispositivo"

msgid "Download image file for current Pixel device."
msgstr "Descargar archivo de imagen para el dispositivo Pixel actual."

msgid "Select Pixel Firmware"
msgstr "Seleccionar firmware Pixel"

msgid "Process"
msgstr "Procesar"

msgid "Process the firmware file and extract the boot.img"
msgstr "Procesar el archivo de firmware y extraer boot.img"

msgid "Apply Custom ROM"
msgstr "Aplicar ROM personalizada"

msgid "Caution: Make sure you read the selected ROM documentation.\nThis might not work for your ROM"
msgstr "Precaución: Asegúrese de leer la documentación de la ROM seleccionada.\nEsto podría no funcionar para su ROM"

msgid "Select Custom ROM"
msgstr "Seleccionar ROM personalizada"

msgid "Process the ROM file and extract the boot.img"
msgstr "Procesar el archivo ROM y extraer boot.img"

msgid "Select a boot/init_boot"
msgstr "Seleccionar un boot/init_boot"

msgid "Show All boot/init_boot"
msgstr "Mostrar todos los boot/init_boot"

msgid "Show all boot/init_boot even if it is\nnot part of the selected firmware or ROM"
msgstr "Mostrar todos los boot/init_boot incluso si no\nson parte del firmware o ROM seleccionados"

msgid "Source SHA1  "
msgstr "SHA1 de origen  "

msgid "Package Fingerprint  "
msgstr "Huella digital del paquete  "

msgid "Patched with version "
msgstr "Parcheado con versión "

msgid "Patch Method  "
msgstr "Método de parche  "

msgid "Patched on Device  "
msgstr "Parcheado en dispositivo  "

msgid "Date  "
msgstr "Fecha  "

msgid "Package Path  "
msgstr "Ruta del paquete  "

msgid "Open Folder"
msgstr "Abrir carpeta"

msgid "Open boot files folder"
msgstr "Abrir carpeta de archivos boot"

msgid "Open Working Directory"
msgstr "Abrir directorio de trabajo"

msgid "Patch"
msgstr "Parche"

msgid "Patch the selected item"
msgstr "Parchear el elemento seleccionado"

msgid "Patch with Magisk"
msgstr "Parchear con Magisk"

msgid "Patch with KernelSU"
msgstr "Parchear con KernelSU"

msgid "Patch with KernelSU LKM"
msgstr "Parchear con KernelSU LKM"

msgid "Patch with KernelSU-Next"
msgstr "Parchear con KernelSU-Next"

msgid "Patch with KernelSU-Next LKM"
msgstr "Parchear con KernelSU-Next LKM"

msgid "Patch with APatch"
msgstr "Parchear con APatch"

msgid "Patch with APatch Alternate"
msgstr "Parchear con APatch Alternativo"

msgid "Patch custom boot/init_boot"
msgstr "Parchear boot/init_boot personalizado"

msgid "Delete"
msgstr "Eliminar"

msgid "Delete the selected item"
msgstr "Eliminar el elemento seleccionado"

msgid "Add a new boot item"
msgstr "Añadir un nuevo elemento boot"

msgid "Info"
msgstr "Info"

msgid "Get information about the selected item"
msgstr "Obtener información sobre el elemento seleccionado"

msgid "Live Boot"
msgstr "Arranque en vivo"

msgid "Live boot to the selected item"
msgstr "Arrancar en vivo al elemento seleccionado"

msgid "Flash Boot"
msgstr "Flashear Boot"

msgid "Flash just the selected item"
msgstr "Flashear solo el elemento seleccionado"

msgid "Flash Mode"
msgstr "Modo de flasheo"

msgid "Keep Data"
msgstr "Mantener datos"

msgid "Data will be kept intact."
msgstr "Los datos se mantendrán intactos."

msgid "WIPE all data"
msgstr "BORRAR todos los datos"

msgid "CAUTION: This will wipe your data"
msgstr "PRECAUCIÓN: Esto borrará sus datos"

msgid "Dry Run"
msgstr "Prueba en seco"

msgid ""
"Dry Run, no flashing will be done.\n"
"The phone will reboot to fastboot and then\n"
"back to normal.\n"
"This is for testing.\n"
msgstr ""
"Prueba en seco, no se realizará ningún flasheo.\n"
"El teléfono se reiniciará a fastboot y luego\n"
"volverá a la normalidad.\n"
"Esto es para pruebas.\n"

msgid "Full OTA"
msgstr "OTA completa"

msgid "Flash full OTA, and have the choice of flashing patched image(s)."
msgstr "Flashear OTA completa, y tener la opción de flashear imágenes parcheadas."

msgid "Custom Flash"
msgstr "Flasheo personalizado"

msgid ""
"Custom Flash, Advanced option to flash a single file.\n"
"This will not flash the factory image.\n"
"It will flash the single selected file.\n"
msgstr ""
"Flasheo personalizado, opción avanzada para flashear un solo archivo.\n"
"Esto no flasheará la imagen de fábrica.\n"
"Flasheará solo el archivo seleccionado.\n"

msgid "Live Boot to selected boot / init_boot"
msgstr "Arranque en vivo al boot / init_boot seleccionado"

msgid "Flash"
msgstr "Flashear"

msgid "Flashes the selected boot / init_boot"
msgstr "Flashea el boot / init_boot seleccionado"

msgid "Depending on the flash selection, paste the appropriate path as custom image."
msgstr "Dependiendo de la selección de flasheo, pegue la ruta apropiada como imagen personalizada."

msgid "Flash Options"
msgstr "Opciones de flasheo"

msgid "Flash to inactive slot"
msgstr "Flashear a ranura inactiva"

msgid "This option when checked will flash to the alternate slot (inactive).\nKeeping the current slot intact.\n"
msgstr "Esta opción cuando está marcada flasheará a la ranura alternativa (inactiva).\nManteniendo la ranura actual intacta.\n"

msgid "Flash to both slots"
msgstr "Flashear a ambas ranuras"

msgid "This option when checked will flash to both slots."
msgstr "Esta opción cuando está marcada flasheará a ambas ranuras."

msgid "Disable Verity"
msgstr "Deshabilitar Verity"

msgid "Disables Verity"
msgstr "Deshabilita Verity"

msgid "Disable Verification"
msgstr "Deshabilitar Verificación"

msgid "Disables Verification"
msgstr "Deshabilita Verificación"

msgid "Force"
msgstr "Forzar"

msgid "Force a flash operation that may be unsafe (will wipe your data)"
msgstr "Forzar una operación de flasheo que puede ser insegura (borrará tus datos)"

msgid "Verbose"
msgstr "Detallado"

msgid "Set fastboot option to verbose"
msgstr "Establecer opción de fastboot a detallado"

msgid "Temporary Root"
msgstr "Root temporal"

msgid "Wipe"
msgstr "Borrar"

msgid ""
"This option when enabled will not flash patched boot\n"
"Instead it will flash unpatched boot.img, but boot to Live Patched boot\n"
"Handy to test if Magisk will cause a bootloop.\n"
"Please be aware that this temporary root will not survive a subsequent reboot.\n"
"If you want to make this permanent, just Flash Boot the patched boot image.\n"
msgstr ""
"Esta opción cuando está habilitada no flasheará el boot parcheado\n"
"En su lugar flasheará el boot.img sin parchear, pero arrancará con el boot parcheado en vivo\n"
"Útil para probar si Magisk causará un bucle de arranque.\n"
"Tenga en cuenta que este root temporal no sobrevivirá a un reinicio posterior.\n"
"Si desea hacerlo permanente, simplemente flashee la imagen de boot parcheada.\n"

msgid "No reboot"
msgstr "Sin reinicio"

msgid "Do not reboot after flashing\nThis is useful if you want to perform other actions before reboot.\n"
msgstr "No reiniciar después de flashear\nEsto es útil si desea realizar otras acciones antes de reiniciar.\n"

msgid "This will invoke data wipe operation at the end of custom flashing.\nOne use case would be when disabling verification for the first time.\n"
msgstr "Esto invocará una operación de borrado de datos al final del flasheo personalizado.\nUn caso de uso sería cuando se deshabilita la verificación por primera vez.\n"

msgid "WARNING!!! This is a highly experimental feature.\nThis will attempt to downgrade the device without needing a data wipe.\n\n"
msgstr "¡¡¡ADVERTENCIA!!! Esta es una función altamente experimental.\nEsto intentará hacer downgrade al dispositivo sin necesidad de borrar datos.\n\n"

msgid "Flash Device"
msgstr "Flashear dispositivo"

msgid "Sideload OTA"
msgstr "Carga lateral OTA"

msgid "Custom Flash Device"
msgstr "Flash personalizado de dispositivo"

msgid "Flashes the selected device with chosen flash options."
msgstr "Flashea el dispositivo seleccionado con las opciones de flasheo elegidas."

msgid "Console"
msgstr "Consola"

msgid "Please be patient ..."
msgstr "Por favor, sea paciente ..."

msgid "Create encrypted and optionally sanitized support.zip file\nWhen sanitized all sensitive data is redacted.\n\nThis file is absolutely required when asking for help."
msgstr "Crear archivo support.zip encriptado y opcionalmente sanitizado\nCuando está sanitizado todos los datos sensibles son redactados.\nEste archivo es absolutamente necesario cuando se solicita ayuda."

msgid "Debug"
msgstr "Depuración"

msgid "Enable Debug Messages in the console."
msgstr "Habilitar mensajes de depuración en la consola."

msgid "Clear Console"
msgstr "Limpiar consola"

msgid "**APK installation options**<br/>\n"
msgstr "**Opciones de instalación de APK**<br/>\n"

msgid "This is a summary of available options.<br/>\n"
msgstr "Este es un resumen de las opciones disponibles.<br/>\n"

msgid "1. **Set ownership to Play Store Market** This option sets the ownership to Play Store (as if it was installed from Play Store).<br/>\n"
msgstr "1. **Establecer propiedad a Play Store Market** Esta opción establece la propiedad a Play Store (como si se hubiera instalado desde Play Store).<br/>\n"

msgid "   Android auto apps require that they be installed from the Play Market.<br/>\n"
msgstr "   Las aplicaciones de Android Auto requieren que sean instaladas desde Play Market.<br/>\n"

msgid "2. Starting with Android 14, apps with a targetSdkVersion lower than 23 can't be installed.<br/>\n"
msgstr "2. A partir de Android 14, las aplicaciones con targetSdkVersion inferior a 23 no se pueden instalar.<br/>\n"

msgid "   Requiring apps to meet these minimum target API level requirements improves security and privacy for users.<br/><br/>\n"
msgstr "   Requerir que las aplicaciones cumplan con estos requisitos mínimos de nivel de API mejora la seguridad y privacidad para los usuarios.<br/><br/>\n"

msgid "   Malware often targets older API levels in order to bypass security and privacy protections that have been introduced in newer Android versions.<br/>\n"
msgstr "   El malware a menudo se dirige a niveles de API más antiguos para eludir las protecciones de seguridad y privacidad que se han introducido en las versiones más recientes de Android.<br/>\n"

msgid "   For example, some malware apps use a `targetSdkVersion` of 22 to avoid being subjected to the runtime permission model\n"
msgstr "   Por ejemplo, algunas aplicaciones maliciosas utilizan un `targetSdkVersion` de 22 para evitar ser sometidas al modelo de permisos en tiempo de ejecución\n"

msgid "   introduced in 2015 by Android 6.0 Marshmallow (API level 23).<br/>\n"
msgstr "   introducido en 2015 por Android 6.0 Marshmallow (nivel de API 23).<br/>\n"

msgid "   This Android 14 change makes it harder for malware to avoid security and privacy improvements.<br/>\n"
msgstr "   Este cambio en Android 14 dificulta que el malware evite las mejoras de seguridad y privacidad.<br/>\n"

msgid "   Attempting to install an app targeting a lower API level will result in an installation failure.<br/><br/>\n"
msgstr "   Intentar instalar una aplicación dirigida a un nivel de API inferior resultará en un fallo de instalación.<br/><br/>\n"

msgid "   **Bypass low target sdk block** option bypasses that enforcement.\n"
msgstr "   La opción **Omitir bloqueo de SDK objetivo bajo** evita esa restricción.\n"

msgid "_If you have selected multiple APKs to install, the options will apply to all APKs._\n"
msgstr "_Si ha seleccionado múltiples APKs para instalar, las opciones se aplicarán a todos los APKs._\n"

msgid "**This feature will generate a device analysis report that you could optionally post online to get assistance on Play Integrity related issues.**<br/>\n"
msgstr "**Esta función generará un informe de análisis del dispositivo que opcionalmente podría publicar en línea para obtener ayuda con problemas relacionados con Play Integrity.**<br/>\n"

msgid "- Device state and other device related details.\n"
msgstr "- Estado del dispositivo y otros detalles relacionados con el dispositivo.\n"

msgid "- Magisk (if available):\n"
msgstr "- Magisk (si está disponible):\n"

msgid "	- modules list.\n"
msgstr "	- lista de módulos.\n"

msgid "	- denylist.\n"
msgstr "	- lista de denegación.\n"

msgid "- TrickyStore (if available):\n"
msgstr "- TrickyStore (si está disponible):\n"

msgid "	- `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)\n"
msgstr "	- `/data/adb/tricky_store/keybox.xml` (No el contenido, solo si los certificados están revocados o no)\n"

msgid "- PlayIntegrity Fork (if available):\n"
msgstr "- PlayIntegrity Fork (si está disponible):\n"

msgid "- PlayIntegrityFix (if available):\n"
msgstr "- PlayIntegrityFix (si está disponible):\n"

msgid "- Whether a testkey ROM is used or not.\n"
msgstr "- Si se utiliza una ROM con testkey o no.\n"

msgid "- logcat for PlayIntegrity and TrickyStore related logs.\n"
msgstr "- logcat para registros relacionados con PlayIntegrity y TrickyStore.\n"

msgid "- Droidguard VM list.\n"
msgstr "- Lista de VM de Droidguard.\n"

msgid "- If any custom ROM injection apps are installed from:\n"
msgstr "- Si hay aplicaciones de inyección de ROM personalizada instaladas desde:\n"

msgid "- Check overlays (if contents of /debug_ramdisk is visible without root)\n"
msgstr "- Verificar superposiciones (si el contenido de /debug_ramdisk es visible sin root)\n"

msgid "**NOTE:**\n"
msgstr "**NOTA:**\n"

msgid "This report will be saved at a location of your choosing, and will **not** be part of PixelFlasher captured logs (even though you see it in the console), so rest assured, if you submit support.zip for PixelFlasher related issues, even if you had generated such report, it will never be included in the support.zip file.<br/>\n"
msgstr "Este informe se guardará en una ubicación de su elección y **no** formará parte de los registros capturados por PixelFlasher (aunque lo vea en la consola), así que tenga la seguridad de que, si envía support.zip para problemas relacionados con PixelFlasher, incluso si ha generado dicho informe, nunca se incluirá en el archivo support.zip.<br/>\n"

msgid "Your privacy is yours to keep.<br/>\n"
msgstr "Su privacidad es suya para mantener.<br/>\n"

msgid "If you continue you'd only be generating the report, and not posting it online.<br/>\n"
msgstr "Si continúa, solo estará generando el informe, no publicándolo en línea.<br/>\n"

msgid "If you want to post it online, please make sure to remove any sensitive information from the report before posting it online.<br/>\n"
msgstr "Si desea publicarlo en línea, asegúrese de eliminar cualquier información sensible del informe antes de publicarlo en línea.<br/>\n"

msgid "**Are you sure you want to continue?**<br/>\n"
msgstr "**¿Está seguro de que desea continuar?**<br/>\n"

##############################################################################
# Advanced Settings
##############################################################################
msgid "Advanced Configuration Settings"
msgstr "Configuración Avanzada"

msgid "WARNING!\n"
msgstr "¡ADVERTENCIA!\n"

msgid "This is advanced configuration.\n"
msgstr "Esta es una configuración avanzada.\n"

msgid "Unless you know what you are doing,\n"
msgstr "A menos que sepa lo que está haciendo,\n"

msgid "you should not be enabling it.\n"
msgstr "no debería estar habilitándola.\n"

msgid "YOU AND YOU ALONE ARE RESPONSIBLE FOR ANYTHING THAT HAPPENS TO YOUR DEVICE.\n"
msgstr "USTED Y SOLO USTED ES RESPONSABLE DE CUALQUIER COSA QUE LE SUCEDA A SU DISPOSITIVO.\n"

msgid "THIS TOOL IS CODED WITH THE EXPRESS ASSUMPTION THAT YOU ARE FAMILIAR WITH\n"
msgstr "ESTA HERRAMIENTA ESTÁ CODIFICADA CON LA SUPOSICIÓN EXPRESA DE QUE ESTÁ FAMILIARIZADO CON\n"

msgid "ADB, MAGISK, ANDROID, AND ROOT.\n"
msgstr "ADB, MAGISK, ANDROID, Y ROOT.\n"

msgid "IT IS YOUR RESPONSIBILITY TO ENSURE THAT YOU KNOW WHAT YOU ARE DOING.\n"
msgstr "ES SU RESPONSABILIDAD ASEGURARSE DE QUE SABE LO QUE ESTÁ HACIENDO.\n"

msgid "Enable Advanced Options"
msgstr "Habilitar Opciones Avanzadas"

msgid "Expert mode"
msgstr "Modo experto"

msgid "Magisk Package Name"
msgstr "Nombre del paquete Magisk"

msgid "If you have hidden Magisk,\nset this to the hidden package name."
msgstr "Si ha ocultado Magisk,\nestablezca esto al nombre del paquete oculto."

msgid "Resets package name to default: %s"
msgstr "Restablece el nombre del paquete al predeterminado: %s"

msgid "Linux File Explorer:"
msgstr "Explorador de archivos Linux:"

msgid "Set full path to File Explorer.\nDefault: Nautilus"
msgstr "Establecer ruta completa al Explorador de archivos.\nPredeterminado: Nautilus"

msgid "Linux Shell:"
msgstr "Shell de Linux:"

msgid "Set full path to Linux Shell.\nDefault: gnome-terminal"
msgstr "Establecer ruta completa al Shell de Linux.\nPredeterminado: gnome-terminal"

msgid "Offer Patch Methods"
msgstr "Ofrecer Métodos de Parche"

msgid "When patching the choice of method is presented."
msgstr "Al parchear se presenta la elección del método."

msgid "Patching Recovery Partition"
msgstr "Parchear Partición de Recovery"

msgid ""
"Enabling this will show an option to patch a recovery partition.\n"
"This should be kept disabled unless you have an old device.\n"
"(most A-only devices launched with Android 9, legacy SAR)"
msgstr ""
"Habilitar esto mostrará una opción para parchear una partición de recovery.\n"
"Esto debe mantenerse deshabilitado a menos que tenga un dispositivo antiguo.\n"
"(la mayoría de dispositivos A-only lanzados con Android 9, SAR heredado)"

msgid "Use Busybox Shell"
msgstr "Usar Shell Busybox"

msgid "When creating a patch, if this is checked, busybox ash will be used as shell."
msgstr "Al crear un parche, si esto está marcado, se usará busybox ash como shell."

msgid "System has low memory"
msgstr "El sistema tiene poca memoria"

msgid "Use this option to sacrifice speed in favor of memory."
msgstr "Use esta opción para sacrificar velocidad a favor de memoria."

msgid "Extra img extraction"
msgstr "Extracción extra de imágenes"

msgid "When checked and available in payload.bin\nAlso extract vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"
msgstr "Cuando está marcado y disponible en payload.bin\nTambién extrae vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"

msgid "Show notifications"
msgstr "Mostrar notificaciones"

msgid "When checked PixelFlasher will display system toast notifications."
msgstr "Cuando está marcado, PixelFlasher mostrará notificaciones toast del sistema."

msgid "Always create boot.tar"
msgstr "Siempre crear boot.tar"

msgid "When checked, PixelFlasher always creates boot.tar of the patched boot file.\nIf unchecked, only for Samsung firmware boot.tar will be created."
msgstr "Cuando está marcado, PixelFlasher siempre crea boot.tar del archivo boot parcheado.\nSi no está marcado, solo se creará boot.tar para firmware Samsung."

msgid "Check for updates"
msgstr "Buscar actualizaciones"

msgid "Checks for available updates on startup"
msgstr "Busca actualizaciones disponibles al inicio"

msgid "Check for Minimum Disk (5Gb)"
msgstr "Verificar Disco Mínimo (5Gb)"

msgid "Enforces minimum disk space of 5 Gb to allow flashing.\nThis avoids storage related issues."
msgstr "Exige un espacio mínimo de disco de 5 Gb para permitir el flasheo.\nEsto evita problemas relacionados con el almacenamiento."

msgid "Check for bootloader unlocked"
msgstr "Verificar que el bootloader esté desbloqueado"

msgid "Checks to make sure bootloader is unlocked before flashing."
msgstr "Verifica que el bootloader esté desbloqueado antes de flashear."

msgid "Check for firmware hash validity"
msgstr "Verificar validez del hash del firmware"

msgid "Checks for sha256 portion to be in the image filename to detect Pixel compatible image."
msgstr "Verifica que la porción sha256 esté en el nombre del archivo de imagen para detectar imágenes compatibles con Pixel."

msgid "Keep temporary support files"
msgstr "Mantener archivos temporales de soporte"

msgid "It keeps the temporary support files.\nUseful for inspecting what data is included in support.zip."
msgstr "Mantiene los archivos temporales de soporte.\nÚtil para inspeccionar qué datos se incluyen en support.zip."

msgid "Check Magisk modules for updates"
msgstr "Verificar actualizaciones de módulos Magisk"

msgid ""
"It checks if the module has updates.\n"
"Disable this if you don't want to check for updates or\n"
" if some module update server has issues and delays the process."
msgstr ""
"Verifica si el módulo tiene actualizaciones.\n"
"Deshabilite esto si no desea buscar actualizaciones o\n"
" si algún servidor de actualización de módulos tiene problemas y retrasa el proceso."

msgid "Show custom ROM options"
msgstr "Mostrar opciones de ROM personalizadas"

msgid "Make sure you check if your ROM is supported."
msgstr "Asegúrese de verificar si su ROM es compatible."

msgid "Sanitize (Redact) support files"
msgstr "Sanitizar (Redactar) archivos de soporte"

msgid ""
"The support files are always encrypted.\n"
"This option redacts sensitive information from the support files.\n"
"But impedes support and is not recommended."
msgstr ""
"Los archivos de soporte siempre están encriptados.\n"
"Esta opción redacta información sensible de los archivos de soporte.\n"
"Pero impide el soporte y no es recomendable."

msgid "Force codepage to"
msgstr "Forzar página de códigos a"

msgid "Uses specified code page instead of system code page"
msgstr "Usa la página de códigos especificada en lugar de la página de códigos del sistema"

msgid "Delete bundled libs"
msgstr "Eliminar bibliotecas incluidas"

msgid "The listed libraries would be deleted from the PF bundle to allow system defined ones to be used."
msgstr "Las bibliotecas listadas serían eliminadas del paquete PF para permitir el uso de las definidas por el sistema."

msgid "Example: libreadline.so.8, libgdk*"
msgstr "Ejemplo: libreadline.so.8, libgdk*"

msgid "Override KMI"
msgstr "Anular KMI"

msgid ""
"This will override the Kernel Module Interface (KMI) to the specified value.\n"
"This is useful for devices with custom kernels.\n"
"The value will be passed to KernelSU as the KMI value."
msgstr ""
"Esto anulará la Interfaz de Módulo del Kernel (KMI) con el valor especificado.\n"
"Esto es útil para dispositivos con kernels personalizados.\n"
"El valor se pasará a KernelSU como valor KMI."

msgid "Example: 5.15.131-android14"
msgstr "Ejemplo: 5.15.131-android14"

msgid "Use Custom Fontface"
msgstr "Usar fuente personalizada"

msgid "Use custom font for monospace fonts\nMight require PixelFlasher restart to properly apply to the Console window."
msgstr "Usar fuente personalizada para fuentes monoespaciadas\nPodría requerir reiniciar PixelFlasher para aplicarse correctamente a la ventana de Consola."

msgid "Sample "
msgstr "Muestra "

msgid "Select font size"
msgstr "Seleccionar tamaño de fuente"

msgid "scrcpy Path"
msgstr "Ruta de scrcpy"

msgid "Download scrcpy"
msgstr "Descargar scrcpy"

msgid "Scrcpy executable (*.exe;*)|*.exe;*"
msgstr "Ejecutable de scrcpy (*.exe;*)|*.exe;*"

msgid "Select scrcpy executable"
msgstr "Seleccionar ejecutable de scrcpy"

msgid "Flags / Arguments (Example: --video-bit-rate 2M --max-fps=30 --max-size 1024)"
msgstr "Banderas / Argumentos (Ejemplo: --video-bit-rate 2M --max-fps=30 --max-size 1024)"

msgid "Scrcpy settings"
msgstr "Configuración de scrcpy"

##############################################################################
# Message dialogs and toasts (modules.py)
##############################################################################
msgid "Module update URL has issues, inform the module author: %s\nDo you want to skip checking updates for this module?"
msgstr "La URL de actualización del módulo tiene problemas, informe al autor del módulo: %s\n¿Desea omitir la verificación de actualizaciones para este módulo?"

msgid "You have an old or problematic Android platform Tools version %s \n"
msgstr "Tiene una versión antigua o problemática de Android Platform Tools %s \n"

msgid "You are strongly advised to update before continuing.\n"
msgstr "Se recomienda encarecidamente actualizar antes de continuar.\n"

msgid "Are you sure you want to continue?"
msgstr "¿Está seguro de que desea continuar?"

msgid "Bad Android Platform Tools"
msgstr "Android Platform Tools problemático"

msgid "Android SDK Version:    %s\n"
msgstr "Versión de Android SDK:    %s\n"

msgid "Device:                 %s %s %s\n"
msgstr "Dispositivo:             %s %s %s\n"

msgid "Factory Image:          %s\n"
msgstr "Imagen de fábrica:       %s\n"

msgid "Custom Rom:             %s\n"
msgstr "ROM personalizada:       %s\n"

msgid "Custom Rom File:        %s\n"
msgstr "Archivo de ROM personalizada: %s\n"

msgid "\nBoot image:             %s / %s \n"
msgstr "\nImagen de arranque:      %s / %s \n"

msgid "                        From: %s\n"
msgstr "                        De: %s\n"

msgid "                        Patched with %s on %s method:        %s\n"
msgstr "                        Parcheado con %s en %s método:      %s\n"

msgid "                        Patched with %s on %s\n"
msgstr "                        Parcheado con %s en %s\n"

msgid "\nFlash Mode:             %s\n"
msgstr "\nModo de flasheo:         %s\n"

msgid "SHA256 of %s%s matches the segment in the filename."
msgstr "SHA256 de %s%s coincide con el segmento en el nombre del archivo."

msgid "⚠️ Firmware SHA256 Mismatch"
msgstr "⚠️ Discrepancia en SHA256 del firmware"

msgid "WARNING! SHA256 of %s%s does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "¡ADVERTENCIA! SHA256 de %s%s no coincide con los segmentos en el nombre del archivo.\nPor favor, verifique para asegurarse de que el checksum es correcto."

msgid "Process action"
msgstr "Acción de procesamiento"

msgid "❌ Could not extract %s"
msgstr "❌ No se pudo extraer %s"

msgid "Possibly extracted firmware."
msgstr "Posiblemente firmware extraído."

msgid "WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n"
msgstr "ADVERTENCIA: Parece que ha extraído el archivo de firmware.\ny seleccionado el zip de imagen de él.\n\n"

msgid "You should not extract the file, please select the downloaded firmware file instead\n\n"
msgstr "No debería extraer el archivo, por favor seleccione el archivo de firmware descargado en su lugar\n\n"

msgid "If this is not the case, and you want to continue with this selection\n"
msgstr "Si este no es el caso, y desea continuar con esta selección\n"

msgid "❌ Could not unpack %s."
msgstr "❌ No se pudo desempaquetar %s."

msgid "❌ Could not extract %s."
msgstr "❌ No se pudo extraer %s."

msgid "❌ Could not find %s."
msgstr "❌ No se pudo encontrar %s."

msgid "⚠️ Detected unsupported firmware."
msgstr "⚠️ Se detectó firmware no compatible."

msgid "❌ Could not extract payload.bin."
msgstr "❌ No se pudo extraer payload.bin."

msgid "❌ The selected firmware is not valid."
msgstr "❌ El firmware seleccionado no es válido."

msgid "⚠️ Nothing to extract from %s"
msgstr "⚠️ Nada que extraer de %s"

msgid "✅ Process %s time: %s seconds"
msgstr "✅ Tiempo de procesamiento %s: %s segundos"

msgid "WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?"
msgstr "ADVERTENCIA: El boot.img objetivo no es un downgrade.\n¿Está seguro de que desea continuar?"

msgid "Confirm"
msgstr "Confirmar"

msgid "Display is Locked!"
msgstr "¡La pantalla está bloqueada!"

msgid "ERROR: Your phone display is Locked.\n\n"
msgstr "ERROR: La pantalla de su teléfono está bloqueada.\n\n"

msgid "Make sure you unlock your display\n"
msgstr "Asegúrese de desbloquear su pantalla\n"

msgid "And set the display timeout to at least 1 minute.\n\n"
msgstr "Y establecer el tiempo de espera de la pantalla a al menos 1 minuto.\n\n"

msgid "After doing so, Click OK to accept and continue.\n"
msgstr "Después de hacer esto, haga clic en ACEPTAR para aceptar y continuar.\n"

msgid "Manual Patching"
msgstr "Parcheado manual"

msgid "Done creating the patch, continue"
msgstr "Terminado de crear el parche, continuar"

msgid "Magisk Manager is not detected."
msgstr "No se detecta Magisk Manager."

msgid "WARNING: Magisk Manager [%s] is not found on the phone\n\n"
msgstr "ADVERTENCIA: Magisk Manager [%s] no se encuentra en el teléfono\n\n"

msgid "This could be either because it is hidden, or it is not installed (most likely not installed)\n\n"
msgstr "Esto podría ser porque está oculto, o no está instalado (probablemente no instalado)\n\n"

msgid "If it is installed and hidden, then you should abort and then unhide it.\n"
msgstr "Si está instalado y oculto, entonces debería abortar y luego desocultarlo.\n"

msgid "If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n"
msgstr "Si Magisk no está instalado, PixelFlasher puede instalarlo por usted y usarlo para parcheado.\n\n"

msgid "WARNING: Do not install Magisk again if it is currently hidden.\n"
msgstr "ADVERTENCIA: No instale Magisk nuevamente si actualmente está oculto.\n"

msgid "Do you want PixelFlasher to download and install Magisk?\n"
msgstr "¿Desea que PixelFlasher descargue e instale Magisk?\n"

msgid "You will be given a choice of Magisk Version to install.\n\n"
msgstr "Se le dará una opción de versión de Magisk para instalar.\n\n"

msgid "Click OK to continue with Magisk installation.\n"
msgstr "Haga clic en ACEPTAR para continuar con la instalación de Magisk.\n"

msgid "Kernel KMI Override"
msgstr "Anulación de KMI del kernel"

msgid "Kernel KMI Override: %s\n\n"
msgstr "Anulación de KMI del kernel: %s\n\n"

msgid "You have set a custom kernel KMI override.\n"
msgstr "Ha establecido una anulación personalizada de KMI del kernel.\n"

msgid "Are you sure you want to proceed with this override?\n"
msgstr "¿Está seguro de que desea continuar con esta anulación?\n"

msgid "Click OK to proceed with the override.\n"
msgstr "Haga clic en ACEPTAR para continuar con la anulación.\n"

msgid "Boot Model Mismatch"
msgstr "Discrepancia del modelo de boot"

msgid "APatch Manual Patching"
msgstr "Parcheado manual de APatch"

msgid "APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n"
msgstr "El parcheado manual de APatch requiere CONFIG_KALLSYMS=y en la configuración del kernel.\n"

msgid "APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n"
msgstr "El parcheado manual de APatch solo admite versiones de kernel 3.18 - 6.1\n\n"

msgid "Do you want to continue regardless of not meeting the pre-requisites?\n\n"
msgstr "¿Desea continuar a pesar de no cumplir con los prerequisitos?\n\n"

msgid "Click Yes to continue with APatch Manual Patching\n"
msgstr "Haga clic en Sí para continuar con el parcheado manual de APatch\n"

msgid "or Hit No to abort."
msgstr "o presione No para abortar."

msgid "Download Latest KernelPatch Tools"
msgstr "Descargar las últimas herramientas de KernelPatch"

msgid "Latest KernelPatch Tools Pre-release Version: %s\n"
msgstr "Última versión preliminar de herramientas de KernelPatch: %s\n"

msgid "Latest KernelPatch Tools Release Version: %s\n\n"
msgstr "Última versión de lanzamiento de herramientas de KernelPatch: %s\n\n"

msgid "Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n"
msgstr "¿Desea descargar los últimos kptools-android y kpimg-android que incluyen versiones preliminares?\n\n"

msgid "Click Yes to download the latest pre-release versions: %s\n"
msgstr "Haga clic en Sí para descargar las últimas versiones preliminares: %s\n"

msgid "Click No to download the latest Release versions: %s\n"
msgstr "Haga clic en No para descargar las últimas versiones de lanzamiento: %s\n"

msgid "%s Boot"
msgstr "Boot %s"

msgid "ERROR: Your phone model is: %s\n\n"
msgstr "ERROR: El modelo de su teléfono es: %s\n\n"

msgid "The selected Boot is for: %s\n\n"
msgstr "El Boot seleccionado es para: %s\n\n"

msgid "Unless you know what you are doing, if you continue flashing\n"
msgstr "A menos que sepa lo que está haciendo, si continúa flasheando\n"

msgid "you risk bricking your device, proceed only if you are absolutely\n"
msgstr "corre el riesgo de inutilizar su dispositivo, proceda solo si está absolutamente\n"

msgid "certain that this is what you want, you have been warned.\n\n"
msgstr "seguro de que esto es lo que desea, ha sido advertido.\n\n"

msgid "Flash action"
msgstr "Acción de flasheo"

msgid "❌ Device is not detected."
msgstr "❌ El dispositivo no es detectado."

msgid "❌ Bootloader is locked, cannot flash."
msgstr "❌ El bootloader está bloqueado, no se puede flashear."

msgid "Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"
msgstr "Su bootloader está bloqueado o no ha otorgado permisos su al proceso shell.\n¿Desea continuar de todos modos?"

msgid "❌ Android Platform Tools is not set."
msgstr "❌ Android Platform Tools no está configurado."

msgid "❌ Valid device is not selected."
msgstr "❌ No se ha seleccionado un dispositivo válido."

msgid "❌ boot is not selected."
msgstr "❌ No se ha seleccionado el boot."

msgid "You can only sideload OTA that is equal or higher than the currently installed version.\n"
msgstr "Solo puede hacer sideload de OTA que sea igual o superior a la versión actualmente instalada.\n"

msgid "Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n"
msgstr "Alternativamente, puede flashear la imagen completa del firmware (con borrado de datos) para hacer downgrade o parchear la imagen de boot actual para permitir un downgrade sin borrado.\n"

msgid "See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n"
msgstr "Vea el elemento de menú: Herramientas de desarrollo | AVB Preparar parche de downgrade para más detalles.\n\n"

msgid "If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n"
msgstr "Si aún desea continuar, haga clic en SÍ para aceptar y continuar. o NO para abortar.\n"

msgid "You have selected to WIPE data\nAre you sure want to continue?"
msgstr "Ha seleccionado BORRAR datos\n¿Está seguro de que desea continuar?"

msgid "Wipe Data"
msgstr "Borrar datos"

msgid "✅ Wipe Data is accepted."
msgstr "✅ Borrado de datos aceptado."

msgid "You have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?"
msgstr "Ha seleccionado la opción de flasheo: Borrar\nEsto borrará sus datos\n¿Está seguro de que desea continuar?"

msgid "Flash option: Wipe"
msgstr "Opción de flasheo: Borrar"

msgid "✅ Wipe is accepted."
msgstr "✅ Borrado aceptado."

msgid "You have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?"
msgstr "Ha seleccionado la opción de flasheo: Forzar\nEsto borrará sus datos\n¿Está seguro de que desea continuar?"

msgid "Flash option: Force"
msgstr "Opción de flasheo: Forzar"

msgid "✅ Force flag is accepted."
msgstr "✅ Bandera de forzado aceptada."

msgid "❌ Not enough disk space."
msgstr "❌ No hay suficiente espacio en disco."

msgid "❌ Full OTA or factory image must be selected."
msgstr "❌ Se debe seleccionar OTA completa o imagen de fábrica."

msgid "Tensor device not on Android 13 or higher"
msgstr "Dispositivo Tensor no está en Android 13 o superior"

msgid "WARNING: Your phone OS version is lower than Android 13.\n\n"
msgstr "ADVERTENCIA: La versión del SO de su teléfono es inferior a Android 13.\n\n"

msgid "If you are upgrading to Android 13 or newer,\n"
msgstr "Si está actualizando a Android 13 o más reciente,\n"

msgid "make sure you at least flash the bootloader to both slots.\n"
msgstr "asegúrese de al menos flashear el bootloader a ambas ranuras.\n"

msgid "The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n"
msgstr "La actualización de Android 13 para Pixel 6, Pixel 6 Pro y Pixel 6a contiene\n"

msgid "a bootloader update that increments the anti-roll back version for the bootloader.\n"
msgstr "una actualización del bootloader que incrementa la versión anti-retroceso para el bootloader.\n"

msgid "This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n"
msgstr "Esto impide que el dispositivo retroceda a versiones anteriores vulnerables del bootloader.\n"

msgid "After flashing an Android 13 build on these devices\n"
msgstr "Después de flashear una versión de Android 13 en estos dispositivos\n"

msgid "you will not be able to flash and boot older Android 12 builds.\n\n"
msgstr "no podrá flashear y arrancar versiones antiguas de Android 12.\n\n"

msgid "Selecting the option 'Flash to both slots'\n"
msgstr "Seleccionar la opción 'Flashear a ambas ranuras'\n"

msgid "Will take care of that.\n\n"
msgstr "Se encargará de eso.\n\n"

msgid "Click OK to continue as is.\n"
msgstr "Haga clic en ACEPTAR para continuar como está.\n"

msgid "or Hit CANCEL to abort and change options."
msgstr "o presione CANCELAR para abortar y cambiar opciones."

msgid "✅ Anti rollback warning acknowledged and bypassed."
msgstr "✅ Advertencia de anti-retroceso reconocida y omitida."

msgid "❌ downgrade_boot.img is not found."
msgstr "❌ downgrade_boot.img no se encuentra."

msgid "❌ Unable to replace boot.img in image.zip."
msgstr "❌ No se puede reemplazar boot.img en image.zip."

msgid "⚠️ Live booting Pixel 7 or newer devices is not supported."
msgstr "⚠️ El arranque en vivo de dispositivos Pixel 7 o más nuevos no es compatible."

msgid "❌ Image file is not selected."
msgstr "❌ No se ha seleccionado archivo de imagen."

msgid "❌ Boot file is not found."
msgstr "❌ No se encuentra el archivo boot."

msgid "❌ ROM file is not found."
msgstr "❌ No se encuentra el archivo ROM."

msgid "Device / Firmware Mismatch"
msgstr "Discrepancia de dispositivo / firmware"

msgid "The selected firmware is for: %s\n\n"
msgstr "El firmware seleccionado es para: %s\n\n"

msgid "✅ Device / Firmware mismatch acknowledged."
msgstr "✅ Discrepancia de dispositivo / firmware reconocida."

msgid "❌ Encountered an error while rebooting to bootloader."
msgstr "❌ Se encontró un error al reiniciar al bootloader."

msgid "❌ Encountered an error while rebooting to sideload."
msgstr "❌ Se encontró un error al reiniciar a sideload."

msgid "❌ Encountered an error while rebooting to fastbootd."
msgstr "❌ Se encontró un error al reiniciar a fastbootd."

msgid "❌ Encountered an error while running the flash script."
msgstr "❌ Se encontró un error al ejecutar el script de flasheo."

msgid "❌ Encountered an error while flashing the patch."
msgstr "❌ Se encontró un error al flashear el parche."

msgid "❌ vbmeta flashing did not return the expected result."
msgstr "❌ El flasheo de vbmeta no devolvió el resultado esperado."

msgid "❌ It appears that OTA flashing did not properly switch slots."
msgstr "❌ Parece que el flasheo OTA no cambió correctamente las ranuras."

msgid "⚠️ Device is not found after rebooting to bootloader."
msgstr "⚠️ No se encuentra el dispositivo después de reiniciar al bootloader."

msgid "✅ Flashing elapsed time: %s seconds"
msgstr "✅ Tiempo transcurrido de flasheo: %s segundos"

msgid "You have selected  WIPE option.\nAdb debugging will be reset and disabled\nHence patch or vbmeta flashing will be skipped."
msgstr "Ha seleccionado la opción BORRAR.\nLa depuración adb se restablecerá y deshabilitará\nPor lo tanto, se omitirá el flasheo del parche o vbmeta."

msgid "%s %s \n"
msgstr "%s %s \n"

msgid "Device is not detected."
msgstr "El dispositivo no es detectado."

msgid "Done rebooting to bootloader, continue"
msgstr "Reinicio al bootloader completado, continuar"

msgid "Done rebooting to system, continue"
msgstr "Reinicio al sistema completado, continuar"

msgid "## Is your device waiting for interaction?\n"
msgstr "## ¿Su dispositivo está esperando interacción?\n"

msgid "_If it is not, please hit the cancel button._\n"
msgstr "_Si no es así, por favor presione el botón cancelar._\n"

msgid "If your device is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "Si su dispositivo está esperando una interacción del usuario que no puede ser invocada programáticamente.\n"

msgid "- Using volume keys, scroll up and down and select **Reboot %s**\n"
msgstr "- Usando las teclas de volumen, desplácese arriba y abajo y seleccione **Reiniciar %s**\n"

msgid "- Press the power button to apply.\n"
msgstr "- Presione el botón de encendido para aplicar.\n"

msgid "When done, the device should reboot to %s <br/>\n"
msgstr "Cuando termine, el dispositivo debería reiniciar a %s <br/>\n"

msgid "Wait for the device to fully boot to %s <br/>\n"
msgstr "Espere a que el dispositivo arranque completamente a %s <br/>\n"

msgid "Click on **Done rebooting to %s, continue** button <br/>\n"
msgstr "Haga clic en el botón **Reinicio a %s completado, continuar** <br/>\n"

msgid "or hit the **Cancel** button to abort.\n"
msgstr "o presione el botón **Cancelar** para abortar.\n"

msgid "Waiting for user interaction"
msgstr "Esperando interacción del usuario"

msgid "## Your watch should now be in Android Recovery\n"
msgstr "## Su reloj debería estar ahora en Recovery de Android\n"

msgid "The watch is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "El reloj está esperando una interacción del usuario que no puede ser invocada programáticamente.\n"

msgid "- Using touch, scroll and select **Reboot to bootloader**\n"
msgstr "- Usando el táctil, desplácese y seleccione **Reiniciar a bootloader**\n"

msgid "- Press the side button to apply.\n"
msgstr "- Presione el botón lateral para aplicar.\n"

msgid "When done, the watch should reboot to bootloader mode <br/>\n"
msgstr "Cuando termine, el reloj debería reiniciar al modo bootloader <br/>\n"

msgid "Wait for the watch to indicate that it is in bootloader mode <br/>\n"
msgstr "Espere a que el reloj indique que está en modo bootloader <br/>\n"

msgid "Click on **Done rebooting to bootloader, continue** button <br/>\n"
msgstr "Haga clic en el botón **Reinicio al bootloader completado, continuar** <br/>\n"

msgid "- Using touch, scroll and select **Reboot to system now**\n"
msgstr "- Usando el táctil, desplácese y seleccione **Reiniciar al sistema ahora**\n"

msgid "When applied, the watch should reboot to system. <br/>\n"
msgstr "Cuando se aplique, el reloj debería reiniciar al sistema. <br/>\n"

msgid "Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n"
msgstr "Haga clic en el botón **Reinicio al sistema completado, continuar** cuando el sistema operativo del reloj cargue completamente.\n"

##############################################################################
# Pif Manager
##############################################################################
msgid "Active Pif"
msgstr "Pif activo"

msgid "Loaded Pif (from Device)"
msgstr "Pif cargado (del dispositivo)"

msgid "Active pif is not modified."
msgstr "El pif activo no está modificado."

msgid "Save Active pif content to a json file on disk."
msgstr "Guardar el contenido del pif activo a un archivo json en disco."

msgid "Pif Module"
msgstr "Módulo Pif"

msgid "Active pif is not saved in favorites."
msgstr "El pif activo no está guardado en favoritos."

msgid "Select a folder to import pif json files."
msgstr "Seleccionar una carpeta para importar archivos json pif."

msgid "Output"
msgstr "Salida"

msgid "Console Output:\nIt could be the json output of processed prop\nor it could be the Play Integrity Check result.\n\nThis is not what currently is on the device."
msgstr "Salida de consola:\nPodría ser la salida json de prop procesado\no podría ser el resultado de verificación de Play Integrity.\n\nEsto no es lo que está actualmente en el dispositivo."

msgid "Smart Paste:\nSets First API to the set value if it is missing or forced.\nReprocesses the output window content to adapt to current module requirements.\nPastes to Active pif."
msgstr "Pegado inteligente:\nEstablece la primera API al valor establecido si falta o es forzada.\nReprocesa el contenido de la ventana de salida para adaptarlo a los requisitos del módulo actual.\nPega al pif activo."

msgid "Paste the console window content to Active pif."
msgstr "Pegar el contenido de la ventana de consola al pif activo."

msgid "Paste the Active pif to console window."
msgstr "Pegar el pif activo a la ventana de consola."

msgid "Reprocess current Active Pif window json.\nUseful if you changed module version which might require additional / different fields."
msgstr "Reprocesar el json de la ventana Pif activa actual.\nÚtil si cambió la versión del módulo que podría requerir campos adicionales / diferentes."

msgid "Reprocess one or many json file(s)\nUseful if you changed module version which might require additional / different fields.\nIf a single file is selected, the new json will output to console output\nHowever if multiple files are selected, the selected file will be updated in place."
msgstr "Reprocesar uno o varios archivo(s) json\nÚtil si cambió la versión del módulo que podría requerir campos adicionales / diferentes.\nSi se selecciona un solo archivo, el nuevo json se enviará a la salida de la consola\nSin embargo, si se seleccionan varios archivos, el archivo seleccionado se actualizará en su lugar."

msgid "Process one or many json file(s) to generate the FrameworkPatcher formatted code excerpts.\n"
msgstr "Procesar uno o varios archivo(s) json para generar los extractos de código formateados de FrameworkPatcher.\n"

msgid "Add missing Keys from device"
msgstr "Añadir claves faltantes del dispositivo"

msgid "When Processing or Reprocessing, add missing fields from device."
msgstr "Al procesar o reprocesar, añadir campos faltantes del dispositivo."

msgid "Force First API to:"
msgstr "Forzar primera API a:"

msgid "Forces First API value(s) to"
msgstr "Fuerza el/los valor(es) de la primera API a"

msgid "Sort Keys"
msgstr "Ordenar claves"

msgid "Sorts json keys"
msgstr "Ordena las claves json"

msgid "Keep All keys"
msgstr "Mantener todas las claves"

msgid "Does not remove non standard / unrecognized keys"
msgstr "No elimina claves no estándar / no reconocidas"

msgid "Spoof Build"
msgstr "Falsificar Build"

msgid "Spoof Props"
msgstr "Falsificar Props"

msgid "Spoof Provider"
msgstr "Falsificar Proveedor"

msgid "Spoof Signature"
msgstr "Falsificar Firma"

msgid "Close"
msgstr "Cerrar"

msgid "Create print"
msgstr "Crear impresión"

msgid "Create pif.json / spoof_build_vars"
msgstr "Crear pif.json / spoof_build_vars"

msgid "Push print, no validation"
msgstr "Enviar impresión, sin validación"

msgid "Pushes the print as is without performing any validation.\nThis is useful to retain comments."
msgstr "Envía la impresión tal como está sin realizar ninguna validación.\nEsto es útil para conservar comentarios."

msgid "Reload print"
msgstr "Recargar impresión"

msgid "Reload pif.json / spoof_build_vars from device."
msgstr "Recargar pif.json / spoof_build_vars desde el dispositivo."

msgid "Cleanup DG"
msgstr "Limpiar DG"

msgid "Cleanup Droidguard Cache"
msgstr "Limpiar caché de Droidguard"

msgid "Push keybox.xml"
msgstr "Enviar keybox.xml"

msgid "Push a valid keybox.xml to device."
msgstr "Enviar un keybox.xml válido al dispositivo."

msgid "Edit TS Target"
msgstr "Editar objetivo TS"

msgid "Edit Tricky Store target.txt file."
msgstr "Editar archivo target.txt de Tricky Store."

msgid "Edit TS SP"
msgstr "Editar SP TS"

msgid "Edit Tricky Store security_patch.txt file."
msgstr "Editar archivo security_patch.txt de Tricky Store."

msgid "Process build.prop(s)"
msgstr "Procesar build.prop(s)"

msgid "Process build.prop to extract a compatible print."
msgstr "Procesar build.prop para extraer una impresión compatible."

msgid "Process bulk props"
msgstr "Procesar props en masa"

msgid "Process a folder containing .prop files and convert then to .json files."
msgstr "Procesar una carpeta que contiene archivos .prop y convertirlos a archivos .json."

msgid "Process Image"
msgstr "Procesar imagen"

msgid "Process an image and get a print from it."
msgstr "Procesar una imagen y obtener una impresión de ella."

msgid "Auto Update print"
msgstr "Actualizar impresión automáticamente"

msgid "After Processing build.props, the print is automatically pushed to the device and the GMS process is killed."
msgstr "Después de procesar build.props, la impresión se envía automáticamente al dispositivo y se mata el proceso GMS."

msgid "Auto Check Play Integrity"
msgstr "Verificar Play Integrity automáticamente"

msgid "After saving (pushing) print, automatically run Play Integrity Check."
msgstr "Después de guardar (enviar) la impresión, ejecutar automáticamente la verificación de Play Integrity."

msgid "Disable UIAutomator"
msgstr "Deshabilitar UIAutomator"

msgid "Disables UIAutomator\nThis is useful for devices with buggy UIAutomator.\nNOTE: Create the coords.json file manually to make use of automated testing."
msgstr "Deshabilita UIAutomator\nEsto es útil para dispositivos con UIAutomator con errores.\nNOTA: Cree el archivo coords.json manualmente para hacer uso de pruebas automatizadas."

msgid "Play Integrity Check"
msgstr "Verificación de Play Integrity"

msgid "Play Integrity API Checker\nNote: Need to install app from Play store."
msgstr "Verificador de API de Play Integrity\nNota: Necesita instalar la aplicación desde Play Store."

msgid "Latest"
msgstr "Más reciente"

msgid "Custom"
msgstr "Personalizado"

msgid "Select 'Latest' to get the latest Pixel beta pif (Includes Developer Preview).\nSelect 'Custom' to set a custom Android version code."
msgstr "Seleccione 'Más reciente' para obtener el último pif beta de Pixel (Incluye vista previa para desarrolladores).\nSeleccione 'Personalizado' para establecer un código de versión de Android personalizado."

msgid "Set a valid Android version code."
msgstr "Establecer un código de versión de Android válido."

msgid "Get Pixel Beta Pif"
msgstr "Obtener Pif beta de Pixel"

msgid "Get the latest Pixel beta pif."
msgstr "Obtener el último pif beta de Pixel."

msgid "Get Xiaomi Pif"
msgstr "Obtener Pif de Xiaomi"

msgid "Get Xiaomi.eu pif\nEasy to start but is not recommended as it gets banned quickly.\nRecommended to find your own."
msgstr "Obtener pif de Xiaomi.eu\nFácil de empezar pero no se recomienda ya que se prohíbe rápidamente.\nSe recomienda encontrar el suyo propio."

msgid "Get TheFreeman193 Random Pif"
msgstr "Obtener Pif aleatorio de TheFreeman193"

msgid "Get a random pif from TheFreeman193 repository.\nNote: The pif might or might not work."
msgstr "Obtener un pif aleatorio del repositorio de TheFreeman193.\nNota: El pif puede funcionar o no."

msgid "No Device is selected.\nPif Manager features are set to limited mode."
msgstr "No se ha seleccionado ningún dispositivo.\nLas características del Administrador Pif están configuradas en modo limitado."

msgid "Device is not rooted or SU permissions to adb shell is not granted.\nPif Manager features are set to limited mode."
msgstr "El dispositivo no tiene root o no se han concedido permisos SU al shell adb.\nLas características del Administrador Pif están configuradas en modo limitado."

msgid "Update print"
msgstr "Actualizar impresión"

msgid "Update pif.json / spoof_build_vars."
msgstr "Actualizar pif.json / spoof_build_vars."

msgid "Create pif.json / spoof_build_vars."
msgstr "Crear pif.json / spoof_build_vars."

msgid "Getting Pixel beta print ...\nPlease be patient this could take some time ..."
msgstr "Obteniendo impresión beta de Pixel ...\nPor favor sea paciente, esto podría tomar algún tiempo ..."

msgid "Failed to get beta print."
msgstr "Error al obtener impresión beta."

msgid "Active pif not in sync"
msgstr "Pif activo no sincronizado"

msgid "⚠️ WARNING! Device pif is not in sync with Active Pif contents.\nThe result will not be reflective of the Active pif you're viewing."
msgstr "⚠️ ¡ADVERTENCIA! El pif del dispositivo no está sincronizado con el contenido del Pif activo.\nEl resultado no reflejará el pif activo que está viendo."

msgid "Choose property files to open"
msgstr "Elegir archivos de propiedades para abrir"

msgid "Select a Device Image"
msgstr "Seleccionar una imagen de dispositivo"

msgid "Processing %s ...\nPlease be patient this could take some time ..."
msgstr "Procesando %s ...\nPor favor sea paciente, esto podría tomar algún tiempo ..."

msgid "Image format not supported"
msgstr "Formato de imagen no compatible"

msgid "Select folder to bulk process props files"
msgstr "Seleccionar carpeta para procesar archivos props en masa"

msgid "The contents is different than what is currently on the device.\nUpdate the print before testing."
msgstr "El contenido es diferente de lo que está actualmente en el dispositivo.\nActualice la impresión antes de probar."

msgid "Active pif is saved in favorites."
msgstr "El pif activo está guardado en favoritos."

msgid "Select keybox to push"
msgstr "Seleccionar keybox para enviar"

msgid "Choose one or multiple json files to reprocess"
msgstr "Elegir uno o varios archivos json para reprocesar"

msgid "Save FP file"
msgstr "Guardar archivo FP"

msgid "Enter a label:"
msgstr "Ingrese una etiqueta:"

msgid "Save Pif to Favorites"
msgstr "Guardar Pif en favoritos"

msgid "Select folder to Import Pifs"
msgstr "Seleccionar carpeta para importar Pifs"

##############################################################################
# Magisk
##############################################################################
msgid "❌ ERROR: You must first select a valid device."
msgstr "❌ ERROR: Primero debe seleccionar un dispositivo válido."

msgid "Manage Magisk"
msgstr "Administrar Magisk"

msgid "When you press the OK button, the Modules with checkbox selected will be enabled and the rest will be disabled."
msgstr "Cuando presione el botón ACEPTAR, los módulos con casilla seleccionada serán habilitados y el resto serán deshabilitados."

msgid "Magisk Modules"
msgstr "Módulos Magisk"

msgid "Enable / Disable Magisk modules"
msgstr "Habilitar / Deshabilitar módulos Magisk"

msgid "Install Module"
msgstr "Instalar módulo"

msgid "Install magisk module."
msgstr "Instalar módulo magisk."

msgid "Update Module"
msgstr "Actualizar módulo"

msgid "Update magisk module."
msgstr "Actualizar módulo magisk."

msgid "Uninstall Module"
msgstr "Desinstalar módulo"

msgid "Uninstall magisk module."
msgstr "Desinstalar módulo magisk."

msgid "Run Action"
msgstr "Ejecutar acción"

msgid "Run Module action.sh."
msgstr "Ejecutar action.sh del módulo."

msgid "Install Pif / TS Module"
msgstr "Instalar módulo Pif / TS"

msgid "Install Play Integrity Fix related modules."
msgstr "Instalar módulo Play Integrity Fix."

msgid "Install ZygiskNext Module"
msgstr "Instalar módulo ZygiskNext"

msgid "Install ZygiskNext module."
msgstr "Instalar módulo ZygiskNext."

msgid "Systemless Hosts"
msgstr "Hosts sin sistema"

msgid "Add Systemless Hosts Module."
msgstr "Añadir módulo Hosts sin sistema."

msgid "Enable Zygisk"
msgstr "Habilitar Zygisk"

msgid "Enable Magisk zygisk (requires reboot)"
msgstr "Habilitar Magisk zygisk (requiere reinicio)"

msgid "Disable Zygisk"
msgstr "Deshabilitar Zygisk"

msgid "Disable Magisk zygisk (requires reboot)"
msgstr "Deshabilitar Magisk zygisk (requiere reinicio)"

msgid "Enable Denylist"
msgstr "Habilitar lista de denegación"

msgid "Enable Magisk denylist"
msgstr "Habilitar lista de denegación de Magisk"

msgid "Disable Denylist"
msgstr "Deshabilitar lista de denegación"

msgid "Disable Magisk denylist"
msgstr "Deshabilitar lista de denegación de Magisk"

msgid "Refresh"
msgstr "Actualizar"

msgid "Refresh Magisk modules list."
msgstr "Actualizar lista de módulos Magisk."

msgid "To manage denylist or to manage SU permissions, use PixelFlasher's App Manager feature."
msgstr "Para administrar la lista de denegación o para administrar permisos SU, use la función Administrador de aplicaciones de PixelFlasher."

msgid "Use Pixelflasher's App Manager functionality to add/remove items to denylist or su permissions."
msgstr "Use la funcionalidad Administrador de aplicaciones de Pixelflasher para añadir/eliminar elementos a la lista de denegación o permisos su."

msgid "Restore Module"
msgstr "Restaurar módulo"

msgid "## You need to reboot your device for the changes to take effect."
msgstr "## Necesita reiniciar su dispositivo para que los cambios surtan efecto."

msgid "osm0sis PlayIntegrityFork"
msgstr "osm0sis PlayIntegrityFork"

msgid "chiteroman PlayIntegrityFix"
msgstr "chiteroman PlayIntegrityFix"

msgid "PIF Module"
msgstr "Módulo PIF"

msgid "Select the module you want to install"
msgstr "Seleccione el módulo que desea instalar"

msgid "## You need to reboot your device to complete the installation."
msgstr "## Necesita reiniciar su dispositivo para completar la instalación."

msgid "## You need to reboot your device to complete the update."
msgstr "## Necesita reiniciar su dispositivo para completar la actualización."

msgid "Copy"
msgstr "Copiar"

msgid "Select All"
msgstr "Seleccionar todo"

msgid "Superuser Access"
msgstr "Modificar acceso root"

msgid "Superuser Access (requires reboot)"
msgstr "Modificar acceso root (requiere reinicio)"

msgid "Apps Only"
msgstr "Solo aplicaciones"

msgid "ADB Only"
msgstr "Solo ADB"

msgid "Apps and ADB"
msgstr "Aplicaciones y ADB"

msgid "Disabled"
msgstr "Deshabilitado"

##############################################################################
# Rooting App
##############################################################################
msgid "Download and Install Rooting Application"
msgstr "Descargar e instalar aplicación de root"

msgid "Select rooting app to install."
msgstr "Seleccione la aplicación de root para instalar."

msgid "Root App"
msgstr "Aplicación de Root"

msgid "Version"
msgstr "Versión"

msgid "VersionCode"
msgstr "Código de versión"

msgid "URL"
msgstr "URL"

msgid "Package"
msgstr "Paquete"

msgid "WARNING! Do not install magisk if you already have a hidden (stub) Magisk installed.\nFirst unhide Magisk before attempting an install."
msgstr "¡ADVERTENCIA! No instale magisk si ya tiene instalado un Magisk oculto (stub).\nPrimero desoculte Magisk antes de intentar una instalación."

msgid "Download the rooting app."
msgstr "Descargar la aplicación de root."

msgid "Copy URL to Clipboard"
msgstr "Copiar URL al portapapeles"

msgid "Copy Package ID to Clipboard"
msgstr "Copiar ID del paquete al portapapeles"

msgid "Download Selected Rooting App"
msgstr "Descargar aplicación de root seleccionada"

msgid "Device Not Supported"
msgstr "Dispositivo no compatible"

msgid "The selected Magisk is not supported for your device\n"
msgstr "El Magisk seleccionado no es compatible con su dispositivo\n"

msgid "Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n"
msgstr "Actualmente solo son compatibles Pixel 7 (panther), Pixel 7 Pro (cheetah), Pixel 7a (lynx) y Pixel Tablet (tangorpro).\n\n"

msgid "Unless you know what you are doing, if you choose to continue\n"
msgstr "A menos que sepa lo que está haciendo, si elige continuar\n"

msgid "you risk running into serious issues, proceed only if you are absolutely\n"
msgstr "corre el riesgo de encontrarse con problemas graves, proceda solo si está absolutamente\n"

##############################################################################
# Magisk Backup Manager
##############################################################################
msgid "Check / Uncheck All"
msgstr "Marcar / Desmarcar todo"

msgid "Delete checked backups"
msgstr "Eliminar copias de seguridad marcadas"

msgid "Add Backup from Computer"
msgstr "Añadir copia de seguridad desde el ordenador"

msgid "Select a boot.img and create a backup from it.\nWARNING! No verification is done if the selected file is stock boot image or even for the correct device."
msgstr "Seleccione un boot.img y cree una copia de seguridad a partir de él.\n¡ADVERTENCIA! No se realiza ninguna verificación si el archivo seleccionado es una imagen de arranque stock o incluso para el dispositivo correcto."

msgid "Auto Create Backup"
msgstr "Crear copia de seguridad automáticamente"

msgid "Checks current boot partition,\nFf it is a Magisk Patched with SHA1\nand the boot.img is available, then it\nAutomatically creates a backup of boot image."
msgstr "Verifica la partición de arranque actual,\nSi es un Magisk parcheado con SHA1\ny el boot.img está disponible, entonces\nCrea automáticamente una copia de seguridad de la imagen de arranque."

msgid "Closes this dialog"
msgstr "Cierra este diálogo"

msgid "boot / init_boot image to create backup of."
msgstr "imagen boot / init_boot para crear copia de seguridad."

msgid "Delete Backup"
msgstr "Eliminar copia de seguridad"

msgid "Check All"
msgstr "Marcar todo"

msgid "UnCheck All"
msgstr "Desmarcar todo"

msgid "Copy to Clipboard"
msgstr "Copiar al portapapeles"

##############################################################################
# App Manager
##############################################################################
msgid "Set SU Permission"
msgstr "Establecer permisos SU"

msgid "Enter SU Permission details:"
msgstr "Ingrese detalles de permisos SU:"

msgid "Enable Notification"
msgstr "Habilitar notificación"

msgid "Enable Logging"
msgstr "Habilitar registro"

msgid "Forever"
msgstr "Para siempre"

msgid "10 mins"
msgstr "10 minutos"

msgid "20 mins"
msgstr "20 minutos"

msgid "30 mins"
msgstr "30 minutos"

msgid "60 mins"
msgstr "60 minutos"

msgid "Allow"
msgstr "Permitir"

msgid "Deny"
msgstr "Denegar"

msgid "Revoke"
msgstr "Revocar"

msgid "Manage Packages on the Device"
msgstr "Administrar paquetes en el dispositivo"

msgid "%s Packages"
msgstr "%s Paquetes"

msgid "Show System apps"
msgstr "Mostrar aplicaciones del sistema"

msgid "Show 3rd Party apps"
msgstr "Mostrar aplicaciones de terceros"

msgid "Get All Application Names"
msgstr "Obtener todos los nombres de aplicaciones"

msgid "Extracts App names, and caches them for faster loading in the future.\nNOTE: This could take a while."
msgstr "Extrae nombres de aplicaciones y los almacena en caché para cargarlos más rápido en el futuro.\nNOTA: Esto podría llevar tiempo."

msgid "Disable"
msgstr "Deshabilitar"

msgid "Disable checked packages"
msgstr "Deshabilitar paquetes marcados"

msgid "Enable"
msgstr "Habilitar"

msgid "Enable checked packages"
msgstr "Habilitar paquetes marcados"

msgid "Uninstall"
msgstr "Desinstalar"

msgid "Uninstall checked packages"
msgstr "Desinstalar paquetes marcados"

msgid "Add to Denylist"
msgstr "Añadir a lista de denegación"

msgid "Add package to Magisk Denylist"
msgstr "Añadir paquete a lista de denegación de Magisk"

msgid "Remove from Denylist"
msgstr "Eliminar de lista de denegación"

msgid "Remove package from Magisk Denylist"
msgstr "Eliminar paquete de lista de denegación de Magisk"

msgid "Install an APK on the device"
msgstr "Instalar un APK en el dispositivo"

msgid "Download APK"
msgstr "Descargar APK"

msgid "Extract and download APK"
msgstr "Extraer y descargar APK"

msgid "Export List"
msgstr "Exportar lista"

msgid "Export the package list in CSV format"
msgstr "Exportar la lista de paquetes en formato CSV"

msgid "%s / %s Packages"
msgstr "%s / %s Paquetes"

msgid "Export Package list"
msgstr "Exportar lista de paquetes"

msgid "Choose a directory where all apks should be saved."
msgstr "Elija un directorio donde se guardarán todos los apks."

msgid "Download APK file"
msgstr "Descargar archivo APK"

msgid "Disable Package"
msgstr "Deshabilitar paquete"

msgid "Enable Package"
msgstr "Habilitar paquete"

msgid "Uninstall Package"
msgstr "Desinstalar paquete"

msgid "Download Package"
msgstr "Descargar paquete"

msgid "Launch Package"
msgstr "Iniciar paquete"

msgid "View Application Permissions"
msgstr "Ver permisos de la aplicación"

msgid "Kill Application"
msgstr "Terminar aplicación"

msgid "Clear Application Data"
msgstr "Borrar datos de la aplicación"

msgid "Add Package to Magisk Denylist"
msgstr "Añadir paquete a lista de denegación de Magisk"

msgid "Remove Package from Magisk Denylist"
msgstr "Eliminar paquete de lista de denegación de Magisk"

msgid "SU Permission ..."
msgstr "Permisos SU ..."

msgid "Before switching slots, please make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "Antes de cambiar las ranuras, asegúrese de que su dispositivo no está sujeto a problemas de ARB.\n¿Está seguro de que desea continuar?"

msgid "Switch Slot potential concerns"
msgstr "Posibles problemas al cambiar de ranura"

msgid "## ⚠️ WARNING: You have selected to flash both slots.<br/>\n"
msgstr "## ⚠️ ADVERTENCIA: Ha seleccionado flashear ambas ranuras.<br/>\n"

msgid "Please make sure your device is not subject to ARB concerns before clicking continue.<br/>\n"
msgstr "Por favor, asegúrese de que su dispositivo no está sujeto a problemas de ARB antes de hacer clic en continuar.<br/>\n"

msgid "You have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "Ha seleccionado la opción de flasheo: Flashear a ambas ranuras\nPor favor, asegúrese de que su dispositivo no está sujeto a problemas de ARB.\n¿Está seguro de que desea continuar?"

msgid "Flash option: Flash to both slots"
msgstr "Opción de flasheo: Flashear a ambas ranuras"

msgid "✅ Flash to both slots is accepted."
msgstr "✅ Flashear a ambas ranuras aceptado."

msgid "Open URL on Device"
msgstr "Abrir URL en el dispositivo"

msgid "Enter the URL to open on the device:"
msgstr "Ingrese la URL para abrir en el dispositivo:"

msgid "Open URL"
msgstr "Abrir URL"

msgid "Open a URL in the default browser"
msgstr "Abrir una URL en el navegador predeterminado"

##############################################################################
# Additions 2025-07-20
##############################################################################
msgid "Keep Temp Files"
msgstr "Mantener archivos temporales"

msgid "Enabling this will keep temporary files used for patching.\nThis is useful for debugging purposes.\nIt is recommended to keep this disabled."
msgstr "Habilitar esto mantendrá los archivos temporales utilizados para el parcheado.\nEsto es útil para propósitos de depuración.\nSe recomienda mantener esto deshabilitado."

msgid "Logcat"
msgstr "Logcat"

msgid "Logcat Viewer"
msgstr "Visor de Logcat"

msgid "Logcat filter: update_engine"
msgstr "Filtro de Logcat: update_engine"

msgid "Logcat filtered for update_engine to monitor OTA merging"
msgstr "Logcat filtrado para update_engine para monitorear la fusión OTA"

msgid "Bootloader Versions"
msgstr "Versiones del Bootloader"

msgid "Get Bootloader Versions"
msgstr "Obtener versiones del Bootloader"

msgid "Formatting Options"
msgstr "Opciones de formato"

msgid "Enable formatting (-v)"
msgstr "Habilitar formato (-v)"

msgid "Enable or disable formatting options for logcat output"
msgstr "Habilitar o deshabilitar opciones de formato para la salida de logcat"

msgid "Format Verbs"
msgstr "Verbos de formato"

msgid "Show priority, tag, and PID of the process issuing the message"
msgstr "Mostrar prioridad, etiqueta y PID del proceso que emite el mensaje"

msgid "Show all metadata fields and separate messages with blank lines"
msgstr "Mostrar todos los campos de metadatos y separar mensajes con líneas en blanco"

msgid "Show PID only"
msgstr "Mostrar solo PID"

msgid "Show the raw log message with no other metadata fields"
msgstr "Mostrar el mensaje de registro sin procesar sin otros campos de metadatos"

msgid "Show the priority and tag only"
msgstr "Mostrar solo la prioridad y etiqueta"

msgid "Show priority, PID, and TID of the thread issuing the message"
msgstr "Mostrar prioridad, PID y TID del hilo que emite el mensaje"

msgid "Show date, time, priority, tag, PID, and TID (default)"
msgstr "Mostrar fecha, hora, prioridad, etiqueta, PID y TID (predeterminado)"

msgid "Show date, time, priority, tag, and PID of the process"
msgstr "Mostrar fecha, hora, prioridad, etiqueta y PID del proceso"

msgid "Adverb Modifiers"
msgstr "Modificadores de adverbio"

msgid "Show each priority with a different color"
msgstr "Mostrar cada prioridad con un color diferente"

msgid "Show event descriptions from event-log-tags database"
msgstr "Mostrar descripciones de eventos de la base de datos event-log-tags"

msgid "Show time as seconds since 1970-01-01 (Unix epoch)"
msgstr "Mostrar tiempo como segundos desde el 1 de enero de 1970 (época Unix)"

msgid "Show time as CPU seconds since boot"
msgstr "Mostrar tiempo como segundos de CPU desde el arranque"

msgid "Ensure that any binary logging content is escaped"
msgstr "Asegurar que cualquier contenido de registro binario sea escapado"

msgid "Show UID or Android ID of logged process (if permitted)"
msgstr "Mostrar UID o ID de Android del proceso registrado (si está permitido)"

msgid "Show time with microsecond precision"
msgstr "Mostrar tiempo con precisión de microsegundos"

msgid "Filter Options"
msgstr "Opciones de filtro"

msgid "Tag Filter"
msgstr "Filtro de etiqueta"

msgid "Tag:"
msgstr "Etiqueta:"

msgid "Enter log component tag (or * for all)"
msgstr "Ingresar etiqueta del componente de registro (o * para todos)"

msgid "Priority Level"
msgstr "Nivel de prioridad"

msgid "Verbose (default for specific tag)"
msgstr "Detallado (predeterminado para etiqueta específica)"

msgid "Debug (default for *)"
msgstr "Depuración (predeterminado para *)"

msgid "Warn"
msgstr "Advertencia"

msgid "Fatal"
msgstr "Fatal"

msgid "Silent (suppress all output)"
msgstr "Silencioso (suprimir toda salida)"

msgid "Additional Filters"
msgstr "Filtros adicionales"

msgid "Regex Filter (-e):"
msgstr "Filtro Regex (-e):"

msgid "Enter ECMAScript regex to filter output"
msgstr "Ingresar regex ECMAScript para filtrar salida"

msgid "UIDs Filter (comma-separated):"
msgstr "Filtro de UIDs (separados por comas):"

msgid "Enter UIDs (numeric, comma-separated)"
msgstr "Ingresar UIDs (numéricos, separados por comas)"

msgid "View Logcat"
msgstr "Ver Logcat"

msgid "View logcat output with selected options"
msgstr "Ver salida de logcat con opciones seleccionadas"

msgid "Clear Logcat"
msgstr "Limpiar Logcat"

msgid "Clear logcat buffer"
msgstr "Limpiar búfer de logcat"

msgid "Close this panel"
msgstr "Cerrar este panel"

msgid "No device connected"
msgstr "No hay dispositivo conectado"

msgid "Logcat buffer cleared"
msgstr "Búfer de logcat limpiado"

##############################################################################
# Additions 2025-09-08
##############################################################################
msgid "Select Package for TargetedFix Target"
msgstr "Seleccionar paquete para objetivo TargetedFix"

msgid "Add Target"
msgstr "Añadir objetivo"

msgid "Add selected package as TargetedFix target"
msgstr "Añadir paquete seleccionado como objetivo TargetedFix"

msgid "Get Application Names"
msgstr "Obtener nombres de aplicaciones"

msgid "TF Targets"
msgstr "Objetivos TF"

msgid "TargetedFix Targets"
msgstr "Objetivos TargetedFix"

msgid "Add TF Target"
msgstr "Añadir objetivo TF"

msgid "Add a new TargetedFix target by selecting from package list on device"
msgstr "Añadir un nuevo objetivo TargetedFix seleccionando de la lista de paquetes en el dispositivo"

msgid "Delete TF Target"
msgstr "Eliminar objetivo TF"

msgid "Delete the selected TargetedFix target"
msgstr "Eliminar el objetivo TargetedFix seleccionado"

msgid "Edit TF Targets"
msgstr "Editar objetivos TF"

msgid "Edit TargetedFix targets file"
msgstr "Editar archivo de objetivos TargetedFix"

msgid "Push TF Json"
msgstr "Enviar JSON TF"

msgid "Push Active pif content as JSON to the selected TargetedFix target"
msgstr "Enviar contenido del pif activo como JSON al objetivo TargetedFix seleccionado"

msgid "Auto run migrate.sh"
msgstr "Ejecutar migrate.sh automáticamente"

msgid "After saving (pushing) print, automatically run migrate.sh"
msgstr "Después de guardar (enviar) la impresión, ejecutar migrate.sh automáticamente"

msgid "	- Contents of every app json configuration referenced in target.txt\n"
msgstr "    - Contenido de cada configuración json de la aplicación referenciada en target.txt\n"

##############################################################################
# Additions 2025-09-24
##############################################################################
msgid "There will be two versions created.<br/>\n"
msgstr "Se crearán dos versiones.<br/>\n"

msgid "1. Unfiltered version, that would have some sensitive information such as Device ID.\n"
msgstr "1. Versión sin filtrar, que tendría alguna información sensible como ID del dispositivo.\n"

msgid "2. Sanitized version which will filter out sensitive information<br/>\n"
msgstr "2. Versión saneada que filtrará información sensible<br/>\n"

msgid "**Note:** If you're using publicly shared keybox, keep the checkbox `Redact Keybox details` unticked so that the keybox information is included in the report.<br/>\n"
msgstr "**Nota:** Si está utilizando un keybox compartido públicamente, mantenga la casilla `Redactar detalles del Keybox` sin marcar para que la información del keybox se incluya en el informe.<br/>\n"

msgid "If you're using a private keybox, please tick the checkbox `Redact Keybox details` to redact keybox details.<br/>\n"
msgstr "Si está utilizando un keybox privado, marque la casilla `Redactar detalles del Keybox` para redactar los detalles del keybox.<br/>\n"

msgid "**This report will include the following details:**<br/>\n"
msgstr "**Este informe incluirá los siguientes detalles:**<br/>\n"

msgid "- Playstore and GMS versions.\n"
msgstr "- Versiones de Playstore y GMS.\n"

msgid "Redact Keybox details"
msgstr "Redactar detalles del Keybox"

##############################################################################
# Additions 2025-10-01
##############################################################################
msgid "Patch with SukiSU"
msgstr "Parchear con SukiSU"

msgid "Patch with SukiSU LKM"
msgstr "Parchear con SukiSU LKM"

msgid "Select a pre-built kernel flavor"
msgstr "Seleccionar un sabor de kernel preconstruido"

msgid "ShirkNeko flavor kernel"
msgstr "Kernel con sabor ShirkNeko"

msgid "MiRinFork flavored kernel"
msgstr "Kernel con sabor MiRinFork"

msgid "WildKernels"
msgstr "WildKernels"

##############################################################################
# Additions 2025-10-05
##############################################################################
msgid "Convert console content from env (key=value) prop format to json"
msgstr "Convertir contenido de consola de formato env (clave=valor) a json"

msgid "Convert console content from json to env (key=value) prop format"
msgstr "Convertir contenido de consola de json a formato env (clave=valor)"

##############################################################################
# Additions 2025-10-11
##############################################################################
msgid "Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"
msgstr "Descargar / Instalar aplicación de root como Magisk o KernelSU* o APatch o SukiSU o Wild_KSU"

msgid "Push TF Prop"
msgstr "Enviar prop TF"

##############################################################################
# Additions 2025-10-18
##############################################################################
msgid "Select Device"
msgstr "Seleccionar dispositivo"

msgid "Select a device:"
msgstr "Seleccionar un dispositivo:"

msgid "Unknown"
msgstr "Desconocido"

msgid "PixelFlasher guessed Kernel KMI"
msgstr "Kernel KMI adivinado por PixelFlasher"

msgid "Your device kernel KMI is unknown probably because you're using\n"
msgstr "El KMI del kernel de su dispositivo es desconocido probablemente porque está utilizando\n"

msgid "a custom kernel which has stripped out the Android build tag.\n\n"
msgstr "un kernel personalizado que ha eliminado la etiqueta de compilación de Android.\n\n"

msgid "PixelFlasher has guessed the Kernel KMI to be: %s\n\n"
msgstr "PixelFlasher ha adivinado que el Kernel KMI es: %s\n\n"

msgid "Are you sure you want to proceed with this guessed KMI?\n"
msgstr "¿Está seguro de que desea continuar con este KMI adivinado?\n"

##############################################################################
# Additions 2025-11-03
##############################################################################

msgid "The selected path contains single quotes (').\n\nPlease rename the folder to remove the single quotes and try again."
msgstr "La ruta seleccionada contiene comillas simples (').\n\nPor favor, renombre la carpeta para eliminar las comillas simples y vuelva a intentarlo."

msgid "Options"
msgstr "Opciones"

msgid "Additional Options"
msgstr "Opciones adicionales"

msgid "Select Option"
msgstr "Seleccionar opción"

msgid "⚠️ WARNING: With Option 3, fingerprint can't be patched."
msgstr "⚠️ ADVERTENCIA: Con la Opción 3, la huella digital no se puede parchear."

msgid " (Recommended)"
msgstr " (Recomendado)"

msgid "Latest Release"
msgstr "Última versión"

msgid "Latest Pre-Release"
msgstr "Última pre-lanzamiento"

msgid "Latest Release or Pre-Release"
msgstr "Última versión o pre-lanzamiento"

msgid "Let me choose the kernel version from a matching list"
msgstr "Déjame elegir la versión del kernel de una lista coincidente"

msgid "Show all assets including non-matching ones"
msgstr "Mostrar todos los activos, incluidos los que no coinciden"

msgid "Flash to active slot"
msgstr "Flashear a la ranura activa"

msgid "Flash boot partition"
msgstr "Flashear partición de arranque"

msgid "Flash init_boot partition"
msgstr "Flashear partición init_boot"

msgid "Flash vendor_boot partition"
msgstr "Flashear partición vendor_boot"

msgid "No Reboot after flash"
msgstr "No reiniciar después del flasheo"

msgid "## ✅ Live Boot the stock image:\n"
msgstr "## ✅ Live Boot la imagen stock:\n"

msgid "## ✅ Live Boot the patched image:\n"
msgstr "## ✅ Live Boot la imagen parcheada:\n"

msgid "## ❌ Live Booting is only supported for boot partition.\n"
msgstr "## ❌ El arranque en vivo solo es compatible con la partición de arranque.\n"

msgid "## ❌ Valid image is not found that supports live booting.\n"
msgstr "## ❌ No se encuentra una imagen válida que admita el arranque en vivo.\n"

msgid "## ℹ️ Select partitions that you wish to flash stock image\n"
msgstr "## ℹ️ Seleccione las particiones que desea flashear con la imagen stock\n"

msgid "## ℹ️ Select the options to flash a patch image:\n"
msgstr "## ℹ️ Seleccione las opciones para flashear una imagen parcheada:\n"

msgid "## ❌ The selected image is not valid.<br/>\n"
msgstr "## ❌ La imagen seleccionada no es válida.<br/>\n"

msgid "Edit script before continuing"
msgstr "Editar script antes de continuar"

##############################################################################
# Additions 2025-12-28
##############################################################################

##############################################################################
# Download Progress Window
##############################################################################
msgid "Downloading: %s"
msgstr ""

##############################################################################
# File Editor Window
##############################################################################
msgid "Open Shell"
msgstr ""

msgid "Save and Continue"
msgstr ""

msgid "Cancel and Abort"
msgstr ""

msgid "Open Folder in working directory"
msgstr ""

msgid "Open command shell in working directory"
msgstr ""

msgid "Open Folder in working directory\nNote: PF_FILEMANAGER needs to be set."
msgstr ""

msgid "Open Terminal shell in working directory"
msgstr ""

msgid "Save the file and continue."
msgstr ""

msgid "Cancel and Abort."
msgstr ""

##############################################################################
# Ksu Asset Selector
##############################################################################
msgid "Filter:"
msgstr ""

msgid "Search assets..."
msgstr ""

msgid "Asset Name"
msgstr ""

msgid "Size"
msgstr ""

msgid "Suggested: %s"
msgstr ""

msgid "Please select an asset."
msgstr ""

msgid "No Selection"
msgstr ""

msgid "Select KSU Asset"
msgstr ""

msgid "Select a KSU asset:"
msgstr ""

```

`locale/fr/LC_MESSAGES/pixelflasher.po`:

```po
# French translations for PixelFlasher.
# Copyright (C) 2023-2024 Badabing2005
# This file is distributed under the same license as the PixelFlasher package.
msgid ""
msgstr ""
"Project-Id-Version: PixelFlasher\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-13 16:17+0000\n"
"PO-Revision-Date: 2024-05-13 16:17+0000\n"
"Last-Translator: PixelFlasher Developers <badabing2005@hotmail.com>\n"
"Language-Team: French\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"


##############################################################################
# Common buttons
##############################################################################
msgid "Yes"
msgstr "Oui"

msgid "No"
msgstr "Non"

msgid "OK"
msgstr "OK"

msgid "Cancel"
msgstr "Annuler"

msgid "Apply"
msgstr "Appliquer"

# Main Menu items
msgid "&File"
msgstr "&Fichier"

msgid "&Device"
msgstr "&Appareil"

msgid "Dev Tools"
msgstr "Outils de développement"

msgid "&My Tools"
msgstr "&Mes Outils"

msgid "&Google Images"
msgstr "&Images Google"

msgid "&Toolbar"
msgstr "&Barre d'outils"

msgid "&Language"
msgstr "&Langue"

msgid "&Help"
msgstr "&Aide"

##############################################################################
# Menu
##############################################################################
# -------------------------------------
# File menu items
# -------------------------------------
msgid "Settings"
msgstr "Paramètres"

msgid "Exit"
msgstr "Quitter"

msgid "E&xit\tCtrl-Q"
msgstr "&Quitter\tCtrl-Q"

msgid "Exit PixelFlasher"
msgstr "Quitter PixelFlasher"

# -------------------------------------
# Device menu items
# -------------------------------------
msgid "Install APK"
msgstr "Installer APK"

msgid "Package Manager"
msgstr "Gestionnaire de paquets"

msgid "ADB Shell"
msgstr "Console ADB"

msgid "Scrcpy"
msgstr "Scrcpy"

msgid "Device Info"
msgstr "Infos de l'appareil"

msgid "Pif Print"
msgstr "Pif Print"

msgid "Props as Json"
msgstr "Props en Json"

msgid "Dump Screen XML"
msgstr "Extraire de l'écran en XML"

msgid "Cancel OTA Update"
msgstr "Annuler la mise à jour OTA"

msgid "Check otacerts"
msgstr "Vérifier otacerts"

msgid "Partitions Manager"
msgstr "Gestionnaire de partitions"

msgid "PI Analysis Report"
msgstr "Rapport d'analyse PI"

msgid "Switch Slot"
msgstr "Changer de slot"

msgid "Reboot"
msgstr "Redémarrer"

# -------------------------------------
# Reboot sub-menu items
# -------------------------------------
msgid "System"
msgstr "Système"

msgid "Bootloader"
msgstr "Bootloader"

msgid "Fastbootd"
msgstr "Fastbootd"

msgid "Recovery"
msgstr "Recovery"

msgid "Interactive Recovery"
msgstr "Recovery interactif"

msgid "Safe Mode"
msgstr "Mode sans échec"

msgid "Download"
msgstr "Téléchargement"

msgid "Sideload"
msgstr "Sideload"
# ---

msgid "Push file(s) to"
msgstr "Envoyer fichier(s) vers"

msgid "Magisk"
msgstr "Magisk"

msgid "Rooting App"
msgstr "Application de root"

msgid "Magisk Backup Manager"
msgstr "Gestionnaire de sauvegarde Magisk"

msgid "Backup /data/adb"
msgstr "Sauvegarder /data/adb"

msgid "Restore /data/adb"
msgstr "Restaurer /data/adb"

msgid "Clear /data/adb/*"
msgstr "Effacer /data/adb/*"

msgid "Start Shizuku"
msgstr "Démarrer Shizuku"

msgid "Pif Manager"
msgstr "Gestionnaire Pif"

msgid "SOS"
msgstr "SOS"

msgid "Lock Bootloader"
msgstr "Verrouiller Bootloader"

msgid "Unlock Bootloader"
msgstr "Déverrouiller Bootloader"

# -------------------------------------
# Dev Tools menu items
# -------------------------------------
msgid "Check keybox.xml"
msgstr "Vérifier keybox.xml"

msgid "Decode Binary XML"
msgstr "Décoder XML binaire"

msgid "AVB - Get Image Info"
msgstr "AVB - Obtenir infos d'image"

msgid "AVB - Prepare Downgrade Patch"
msgstr "AVB - Préparer patch de downgrade"

# -------------------------------------
# My Tools menu items
# -------------------------------------
msgid "Customize My Tools"
msgstr "Personnaliser Mes outils"

# Google Images menu items
msgid "Phones"
msgstr "Téléphones"

msgid "Watches"
msgstr "Montres"

msgid "Refresh images list"
msgstr "Actualiser la liste d'images"

msgid "Show Progress Window"
msgstr "Afficher la fenêtre de progression"

# -------------------------------------
# Toolbar menu items
# -------------------------------------
msgid "Top"
msgstr "Haut"

msgid "Left"
msgstr "Gauche"

msgid "Right"
msgstr "Droite"

msgid "Bottom"
msgstr "Bas"

msgid "Show Button Text"
msgstr "Afficher le texte des boutons"

msgid "Show Button Icon"
msgstr "Afficher l'icône des boutons"

msgid "Show / Hide Buttons"
msgstr "Afficher / Masquer les boutons"

# -------------------------------------
# Toolbar Show / Hide Button
# sub-menu items share translations
# from Device menu items
# -------------------------------------
msgid "Reboot to System"
msgstr "Redémarrer vers le système"

msgid "Reboot to Bootloader"
msgstr "Redémarrer vers le Bootloader"

msgid "Reboot to Fastbootd"
msgstr "Redémarrer vers Fastbootd"

msgid "Reboot to Recovery"
msgstr "Redémarrer vers Recovery"

msgid "Reboot to Interactive Recovery"
msgstr "Redémarrer vers Recovery interactif"

msgid "Reboot to Safe Mode"
msgstr "Redémarrer en mode sans échec"

msgid "Reboot to Download"
msgstr "Redémarrer en mode téléchargement"

msgid "Reboot to Sideload"
msgstr "Redémarrer en mode Sideload"

msgid "Configuration"
msgstr "Configuration"

msgid "Support"
msgstr "Assistance"

# -------------------------------------
# Help menu items
# -------------------------------------
msgid "Report an Issue"
msgstr "Signaler un problème"

msgid "Feature Request"
msgstr "Demande de fonctionnalité"

msgid "PixelFlasher Project Page"
msgstr "Page du projet PixelFlasher"

msgid "PixelFlasher Community (Forum)"
msgstr "Communauté PixelFlasher (Forum)"

msgid "Links"
msgstr "Liens"

msgid "Open Configuration Folder"
msgstr "Ouvrir le dossier de configuration"

msgid "Open PixelFlasher Working Directory"
msgstr "Ouvrir le répertoire de travail PixelFlasher"

msgid "Create a Sanitized support.zip"
msgstr "Créer un support.zip anonymisé"

msgid "Check for New Version"
msgstr "Vérifier les nouvelles versions"

msgid "&About PixelFlasher"
msgstr "&À propos de PixelFlasher"

msgid "About"
msgstr "À propos"

# -------------------------------------
# Links sub-menu items
# -------------------------------------
msgid "Homeboy76's Guide"
msgstr "Guide de Homeboy76"

msgid "V0latyle's Guide"
msgstr "Guide de V0latyle"

msgid "roirraW's Guide"
msgstr "Guide de roirraW"

msgid "osm0sis's PIF FAQ"
msgstr "FAQ PIF d'osm0sis"

msgid "V0latyle's PI API Info"
msgstr "Infos API PI de V0latyle"

msgid "Tricky Store (Support Thread)"
msgstr "Tricky Store (fil d'assistance)"

msgid "osm0sis's PlayIntegrityFork"
msgstr "PlayIntegrityFork d'osm0sis"

msgid "chiteroman's PlayIntegrityFix"
msgstr "PlayIntegrityFix de chiteroman"

msgid "5ec1cff's TrickyStore"
msgstr "TrickyStore de 5ec1cff"

msgid "Get the Google USB Driver"
msgstr "Obtenir le pilote USB Google"

msgid "Android Security Update Bulletins"
msgstr "Bulletins de mise à jour de sécurité Android"

msgid "Android Codenames, tags, and build numbers"
msgstr "Noms de code, tags et numéros de build Android"

msgid "Full OTA Images for Pixel Phones / Tablets"
msgstr "Images OTA complètes pour téléphones / tablettes Pixel"

msgid "Factory Images for Pixel Phones / Tablets"
msgstr "Images d'usine pour téléphones / tablettes Pixel"

msgid "Full OTA Images for Pixel Watches"
msgstr "Images OTA complètes pour montres Pixel"

msgid "Factory Images for Pixel Watches"
msgstr "Images d'usine pour montres Pixel"

msgid "Full OTA Images for Pixel Beta 16"
msgstr "Images OTA complètes pour Pixel Beta 16"

msgid "Factory Images for Pixel Beta 16"
msgstr "Images d'usine pour Pixel Beta 16"

##############################################################################
# Helper values
##############################################################################
msgid "Open adb shell to the device"
msgstr "Ouvrir le shell adb vers l'appareil"

msgid "Launch Screen Copy"
msgstr "Lancer la copie d'écran"

msgid "Dump Full Device Info"
msgstr "Extraire les informations complètes de l'appareil"

msgid "Get current device's Pif print (osm0sis fork v5 format)"
msgstr "Obtenir le Pif print de l'appareil actuel (format fork v5 d'osm0sis)"

msgid "Get current device's properties in json format"
msgstr "Obtenir les propriétés de l'appareil actuel au format json"

msgid "Use uiautomator to dump the screen view in xml"
msgstr "Utiliser uiautomator pour extraire la vue d'écran en xml"

msgid "Cancels and Resets OTA updates by Google (Not PixelFlasher)"
msgstr "Annule et réinitialise les mises à jour OTA de Google (pas PixelFlasher)"

msgid "Used to see if ROM is signed or not."
msgstr "Utilisé pour voir si la ROM est signée ou non."

msgid "Backup / Erase Partitions"
msgstr "Sauvegarder / Effacer les partitions"

msgid "Generate a report of PI Analysis"
msgstr "Générer un rapport d'analyse PI"

msgid "Switch to the other slot"
msgstr "Changer vers l'autre slot"

msgid "Manage Magisk modules and settings"
msgstr "Gérer les modules et paramètres Magisk"

msgid "Manage Magisk Backups"
msgstr "Gérer les sauvegardes Magisk"

msgid ""
"Backs up /data/adb.\n"
"This is useful for backing up Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those paths will not be backed up."
msgstr ""
"Sauvegarde /data/adb.\n"
"C'est utile pour sauvegarder les modules Magisk.\n"
"REMARQUE : Si un module écrit ailleurs que dans /data/adb, ces chemins ne seront pas sauvegardés."

msgid ""
"Restore /data/adb from a backup file.\n"
"This is useful for restoring Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those items will not be restored."
msgstr ""
"Restaure /data/adb à partir d'un fichier de sauvegarde.\n"
"C'est utile pour restaurer les modules Magisk.\n"
"REMARQUE : Si un module écrit ailleurs que dans /data/adb, ces éléments ne seront pas restaurés."

msgid ""
"Clear up /data/adb/ content (not the directory).\n"
"This is useful when switching to different root flavor."
msgstr ""
"Efface le contenu de /data/adb/ (pas le répertoire).\n"
"Utile lors du passage à une autre méthode de root."

msgid "Starts Shizuku service on the device."
msgstr "Démarre le service Shizuku sur l'appareil."

msgid "Disable Magisk Modules"
msgstr "Désactiver les modules Magisk"

msgid "Unlock Bootloader (Will wipe data)"
msgstr "Déverrouiller le Bootloader (Effacera les données)"

msgid "Get Android Verified Boot Image Info"
msgstr "Obtenir les infos d'image de démarrage vérifié Android"

msgid "Create Downgrade Patch"
msgstr "Créer un patch de downgrade"

##############################################################################
# toast messages
##############################################################################
msgid "Download Successful"
msgstr "Téléchargement réussi"

msgid "✅ File downloaded successfully: %s and saved to %s"
msgstr "✅ Fichier téléchargé avec succès : %s et enregistré dans %s"

msgid "No Downloads"
msgstr "Aucun téléchargement"

msgid "ℹ️ No downloads are in progress."
msgstr "ℹ️ Aucun téléchargement en cours."

msgid "⚠️ WARNING! SHA256 of the selected file does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "⚠️ ATTENTION ! Le SHA256 du fichier sélectionné ne correspond pas aux segments du nom de fichier.\nVeuillez vérifier que la somme de contrôle est correcte."

msgid "APK Install"
msgstr "Installation d'APK"

msgid "❌ ERROR: Please select a device before attempting APK Installation."
msgstr "❌ ERREUR : Veuillez sélectionner un appareil avant de tenter l'installation d'APK."

msgid "❌ ERROR: No device selected"
msgstr "❌ ERREUR : Aucun appareil sélectionné"

msgid "Check OTA Certs"
msgstr "Vérifier les certificats OTA"

msgid "Device Analysis"
msgstr "Analyse de l'appareil"

msgid "❌ ERROR: /data/local/tmp is not accessible, this will affect some features."
msgstr "❌ ERREUR : /data/local/tmp n'est pas accessible, cela affectera certaines fonctionnalités."

msgid "vbmeta Warning!"
msgstr "Avertissement vbmeta !"

msgid "WARNING! Banned Kernel"
msgstr "ATTENTION ! Noyau banni"

msgid "⚠️ Kernel string: %s is known to be banned.\nPlay Integrity would possibly fail."
msgstr "⚠️ Chaîne du noyau : %s est connue pour être bannie.\nPlay Integrity pourrait échouer."

msgid "Scan"
msgstr "Scanner"

msgid "⚠️ No devices are found.."
msgstr "⚠️ Aucun appareil trouvé.."

msgid "✅ Select your device from the list of %s found devices."
msgstr "✅ Sélectionnez votre appareil dans la liste des %s appareils trouvés."

msgid "Firmware SHA256"
msgstr "SHA256 du firmware"

msgid "    ⚠️ WARNING! WARNING! WARNING!    Slot a verity / verification does not match slot b verity / verification"
msgstr "    ⚠️ ATTENTION ! ATTENTION ! ATTENTION !    La vérification du slot a ne correspond pas à la vérification du slot b"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verity state and device's verity state\n"
msgstr "    ⚠️ ATTENTION ! ATTENTION ! ATTENTION !    Il y a une différence entre l'état de vérité vbmeta sélectionné et l'état de vérité de l'appareil\n"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verification state and device's verification state\n"
msgstr "    ⚠️ ATTENTION ! ATTENTION ! ATTENTION !    Il y a une différence entre l'état de vérification vbmeta sélectionné et l'état de vérification de l'appareil\n"

msgid "                                     This has a device wipe implications, please double check.\n"
msgstr "                                     Cela peut entraîner l'effacement de l'appareil, veuillez vérifier attentivement.\n"

##############################################################################
# Message dialogs
##############################################################################
msgid "Error"
msgstr "Erreur"

msgid "Warning"
msgstr "Avertissement"

msgid "Information"
msgstr "Information"

msgid "Success"
msgstr "Succès"

msgid "Click OK to accept and continue.\n"
msgstr "Cliquez sur OK pour accepter et continuer.\n"

msgid "or Hit CANCEL to abort."
msgstr "ou appuyez sur ANNULER pour abandonner."

msgid "Select Language"
msgstr "Sélectionner la langue"

msgid "Language changed to %s. A restart is required for translations to apply."
msgstr "Langue changée en %s. Un redémarrage est nécessaire pour appliquer les traductions."

msgid "Language Changed"
msgstr "Langue modifiée"

msgid "Updates are available"
msgstr "Des mises à jour sont disponibles"

msgid "ℹ️ There are updates available for PixelFlasher.\n"
msgstr "ℹ️ Des mises à jour sont disponibles pour PixelFlasher.\n"

msgid "Click OK to download and install the updates.\n"
msgstr "Cliquez sur OK pour télécharger et installer les mises à jour.\n"

msgid "Select binary xml file to decode"
msgstr "Sélectionner le fichier xml binaire à décoder"

msgid "Select a file"
msgstr "Sélectionner un fichier"

msgid "Browse"
msgstr "Parcourir"

msgid "  Browse  "
msgstr "  Parcourir  "

msgid "Save File"
msgstr "Enregistrer le fichier"

msgid "ℹ️ There are updates available for your device.\nCheck Google Images menu.\n"
msgstr "ℹ️ Des mises à jour sont disponibles pour votre appareil.\nVérifiez le menu Images Google.\n"

msgid "Select one or multiple APK file(s) to install"
msgstr "Sélectionnez un ou plusieurs fichier(s) APK à installer"

msgid "Save support file"
msgstr "Enregistrer le fichier de support"

msgid "Dump Screen Xml"
msgstr "Extraire l'écran Xml"

msgid "Save device analysis"
msgstr "Enregistrer l'analyse de l'appareil"

msgid "Select files to push"
msgstr "Sélectionner les fichiers à envoyer"

msgid "Save /data/adb backup file"
msgstr "Enregistrer le fichier de sauvegarde /data/adb"

msgid "Select /data/adb backup file"
msgstr "Sélectionner le fichier de sauvegarde /data/adb"

msgid "Select keybox to test"
msgstr "Sélectionner le keybox à tester"

msgid "Add / Edit / Delete Custom menu items"
msgstr "Ajouter / Modifier / Supprimer des éléments de menu personnalisés"

msgid "Select Boot Image"
msgstr "Sélectionner l'image de démarrage"

##############################################################################
# Main UI
##############################################################################
msgid "Downloads Progress"
msgstr "Progression des téléchargements"

msgid "Welcome to PixelFlasher %s by Badabing2005"
msgstr "Bienvenue à PixelFlasher %s par Badabing2005"

msgid "Install APK on the device"
msgstr "Installer APK sur l'appareil"

msgid "App Manager"
msgstr "Gestionnaire d’applications"

msgid "Manage Apps / Packages"
msgstr "Gérer les applications / packages"

msgid "Open ADB shell to the device."
msgstr "Ouvrez le shell ADB sur l'appareil."

msgid "Partitions"
msgstr "Partitions"

msgid "Partition Manager"
msgstr "Gestionnaire de partitionsComment"

msgid "Switch to the other Slot"
msgstr "Basculer vers l'autre emplacement"

msgid "Reboot to userspace fastboot (fastbootd)"
msgstr "Redémarrer vers l'espace utilisateur fastboot (fastbootd)"

msgid "iRecovery"
msgstr "iRecovery"

msgid "Reboot to Download Mode"
msgstr "Redémarrer en mode téléchargement"

msgid "Reboot to Sideload Mode"
msgstr "Redémarrer en mode chargement latéral"

msgid "Magisk Backup"
msgstr "Sauvegarde Magisk"

msgid ""
"Remove Magisk Modules\n"
"This button issues the following command:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"This helps for cases where device bootloops due to incompatible magisk modules(YMMV).\n"
msgstr ""
"Supprimer les modules Magisk\n"
"Ce bouton émet la commande suivante:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"Cela aide dans les cas où l'appareil s'amorce en raison de modules magisk incompatibles (YMMV).\n"

msgid "Lock"
msgstr "Verrouiller"

msgid "UnLock"
msgstr "Déverrouiller"

msgid "UnLock Bootloader\nCaution will wipe data\n"
msgstr "Déverrouiller le chargeur d'amorçage\nAttention effacera les données\n"

msgid "UnLock Bootloader"
msgstr "Déverrouiller le chargeur d'amorçage"

msgid "Configuration Settings"
msgstr "Paramètres de configuration"

msgid "Create Support file"
msgstr "Créer un fichier de support"

msgid "APK installation options"
msgstr "Options d'installation"

msgid "Install"
msgstr "Installer"

msgid "Set ownership to Play Store Market"
msgstr "Définir la propriété sur Play Store Market"

msgid "Bypass low target sdk block"
msgstr "Contourner le bloc sdk cible basse"

msgid "ADB Connected Devices"
msgstr "Appareils connectés"

msgid "ADB Connected Devices\nCurrent Active Slot: [A]"
msgstr "Appareils connectés ADB\nEmplacement actif actuel: [A]"

msgid "ADB Connected Devices\nCurrent Active Slot: [B]"
msgstr "Appareils connectés ADB\nEmplacement actif actuel: [B]"

msgid "Android Platform Tools\nVersion %s"
msgstr "Outils de la plateforme Android\nVersion %s"

msgid "Android Platform Tools"
msgstr "Outils de la plateforme Android"

msgid "vbmeta issue."
msgstr "problème vbmeta."

msgid "Warning!\n%s\n"
msgstr "Avertissement%s\n"

msgid "❌ ERROR: You must first select a boot image"
msgstr "❌ ERREUR: vous devez d'abord sélectionner une image de démarrage"

msgid "❌ ERROR: Downgrade patch file not found\nYou must first create a downgrade patch to enable this option.\n"
msgstr "❌ ERREUR: Fichier de correctif de rétrogradation introuvable\nVous devez d'abord créer un correctif de rétrogradation pour activer cette option.\n"

msgid "❌ ERROR: Wipe All Data is selected\nYou must first select another mode to enable this option.\n"
msgstr "❌ ERREUR: Effacer toutes les données est sélectionné\nVous devez d'abord sélectionner un autre mode pour activer cette option.\n"

msgid "No Wipe Downgrade"
msgstr "Pas de rétrogradation de l'effacement"

msgid "                 WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "AVERTISSEMENT!!! AVERTISSEMENT!!! AVERTISSEMENT!!!\n\n\n"

msgid "THIS IS AN EXPERIMENTAL FEATURE, NO ASSURANCES THAT IT WOULD WORK\n\n"
msgstr "CECI EST UNE FONCTIONNALITÉ EXPÉRIMENTALE, PAS D'ASSURANCE QUE CELA FONCTIONNERAIT\n\n"

msgid "Do NOT enable this option if you are not downgrading!!!\n\n"
msgstr "N'activez PAS cette option si vous ne rétrogradez pas!!!\n\n"

msgid "Proceed only if you know what you're doing.\n\n\n"
msgstr "Ne continuez que si vous savez ce que vous faites.\n\n\n"

msgid "Do you want to continue to select the No Wipe Downgrade option?\n\n"
msgstr "Souhaitez-vous continuer à sélectionner l'option No Wipe Downgrade?\n\n"

msgid "       Press OK to continue or CANCEL to abort.\n\n"
msgstr "Appuyer sur OK pour continuer ou sur Annuler pour arrêter le scan.\n\n"

msgid "CANCEL"
msgstr "ANNULER"

msgid "         WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "AVERTISSEMENT!!! AVERTISSEMENT!!! AVERTISSEMENT!!!\n\n\n"

msgid "NEVER, EVER LOCK THE BOOTLOADER WITHOUT REVERTING\n\n"
msgstr "NE JAMAIS, JAMAIS VERROUILLER LE CHARGEUR D'AMORÇAGE SANS REVENIR EN ARRIÈRE\n\n"

msgid "TO STOCK FIRMWARE OR YOUR PHONE WILL BE BRICKED!!!\n\n\n"
msgstr "POUR STOCKER LE MICROLOGICIEL OU VOTRE TÉLÉPHONE SERA BRIQUETÉ!!!\n\n\n"

msgid "       THIS WILL WIPE YOUR DEVICE DATA!!!\n\n\n"
msgstr "CELA EFFACERA LES DONNÉES DE VOTRE APPAREIL!!!\n\n\n"

msgid "Do you want to continue to Lock the device bootloader?\n\n"
msgstr "Voulez-vous continuer à verrouiller le chargeur d'amorçage de l'appareil?\n\n"

msgid "WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n\n"
msgstr "ATTENTION!!! CELA EFFACERA TOUTES LES DONNÉES UTILISATEUR DE L'APPAREIL\n\n\n"

msgid "Make sure you first read either of the guides linked in the help menu.\n\n"
msgstr "Assurez-vous de lire d'abord l'un des guides liés dans le menu d'aide.\n\n"

msgid "Failing to follow the proper steps could potentially brick your phone.\n\n"
msgstr "Ne pas suivre les étapes appropriées pourrait potentiellement bloquer votre téléphone.\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will utilize\n\n"
msgstr "\nRemarque: en appuyant sur le bouton OK, un script qui utilisera\n\n"

msgid "fastboot commands, if your PC fastboot drivers are not properly setup,\n\n"
msgstr "commandes de démarrage rapide, si les pilotes de démarrage rapide de votre PC ne sont pas correctement configurés,\n\n"

msgid "fastboot will wait forever, and PixelFlasher will appear hung.\n\n"
msgstr "fastboot attendra éternellement, et PixelFlasher apparaîtra suspendu.\n\n"

msgid "In such cases, killing the fastboot process will resume to normalcy.\n\n\n"
msgstr "Dans de tels cas, l'arrêt du processus de démarrage rapide reprendra son cours normal.\n\n\n"

msgid "      Do you want to continue to Lock the device bootloader?\n\n"
msgstr "Voulez-vous continuer à verrouiller le chargeur d'amorçage de l'appareil?\n\n"

msgid "              Press OK to continue or CANCEL to abort.\n\n"
msgstr "Appuyer sur OK pour continuer ou sur Annuler pour arrêter le scan.\n\n"

msgid "      Do you want to continue to Unlock the device bootloader?\n\n"
msgstr "Voulez-vous continuer à déverrouiller le chargeur d'amorçage de l'appareil?\n\n"

msgid "WARNING!!! This is an experimental feature to attempt disabling magisk modules.\n\n\n"
msgstr "Attention!!! Il s'agit d'une fonctionnalité expérimentale pour tenter de désactiver les modules magisk.\n\n\n"

msgid "You would only need to do this if your device is bootlooping due to\n\n"
msgstr "Vous n'auriez besoin de le faire que si votre appareil démarre en raison de\n"

msgid "incompatible magisk modules, this is not guaranteed to work in all cases (YMMV).\n\n"
msgstr "modules magisk incompatibles, cela n'est pas garanti pour fonctionner dans tous les cas (YMMV).\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will wait forever to detect the device.\n\n"
msgstr "Remarque: Appuyez sur le bouton OK pour appeler un script qui attendra éternellement pour détecter l'appareil.\n\n"

msgid "If your device is not detected PixelFlasher will appear hung.\n\n"
msgstr "Si votre appareil n'est pas détecté, PixelFlasher apparaîtra suspendu.\n\n"

msgid "In such cases, killing the adb process will resume to normalcy.\n\n\n"
msgstr "Dans de tels cas, le fait de tuer le processus adb reviendra à la normale.\n\n\n"

msgid "                        Press OK to continue or CANCEL to abort.\n\n"
msgstr "Appuyer sur OK pour continuer ou sur Annuler pour arrêter le scan.\n\n"

msgid "Clear /data/adb/ contents"
msgstr "Effacer /data/adb/ contents"

msgid "WARNING!!! This will the clear contents of /data/adb\n\n\n"
msgstr "Avertissement!!! Cela effacera le contenu de /data/adb\n\n\n"

msgid "Do you want to continue to clear /data/adb/ contents?\n\n"
msgstr "Voulez-vous continuer à effacer /data/adb/ contents?\n\n"

msgid "      Press OK to continue or CANCEL to abort.\n\n"
msgstr "      Appuyer sur OK pour continuer ou sur Annuler pour arrêter le scan.\n\n"

msgid "This will invoke the command adb kill-server.\nAre you sure want to continue?\n"
msgstr "Cela invoquera la commande adb kill-server.\nVoulez-vous vraiment continuer?\n"

msgid "ADB Kill Server"
msgstr "Serveur ADB Kill"

msgid "Download Latest Android Platform-Tools"
msgstr "Téléchargez les derniers outils de la plateforme Android"

msgid "Select Android Platform-Tools Folder\nWhere adb and fastboot are located.\n"
msgstr "Sélectionner le dossier Android Platform-Tools\nOù se trouvent adb et fastboot.\n"

msgid "Double click this label to issue the command:\nadb kill-server"
msgstr "Double-cliquez sur cette étiquette pour émettre la commande:\nadb kill-server"

msgid "Open wireless manager dialog."
msgstr "Ouvrez la boîte de dialogue du gestionnaire sans fil."

msgid "[root status] [device mode] [device id] [device model] [device firmware]\n\n"
msgstr "[état racine] [mode appareil] [id appareil] [modèle appareil] [micrologiciel appareil]\n\n"

msgid "✓ Rooted with Magisk.\n"
msgstr "✓ Enraciné avec Magisk.\n"

msgid "✗ Probably Not Root (Magisk Tools not found).\n"
msgstr "✗ Probablement pas root (Magisk Tools introuvable).\n"

msgid "?  Unable to determine the root status.\n\n"
msgstr "?  Impossible de déterminer l'état racine.\n\n"

msgid "(adb) device is in adb mode\n"
msgstr "(adb) l'appareil est en mode adb\n"

msgid "(f.b) device is in fastboot mode\n"
msgstr "(f.b) l'appareil est en mode de démarrage rapide\n"

msgid "(sid) device is in sideload mode\n"
msgstr "(sid) l'appareil est en mode de chargement latéral\n"

msgid "(rec) device is in recovery mode\n"
msgstr "(rec) l'appareil est en mode de récupération\n"

msgid "Scan for Devices\nPlease manually select the device after the scan is completed."
msgstr "Rechercher des appareils\nVeuillez sélectionner manuellement l'appareil une fois l'analyse terminée."

msgid "Device Image"
msgstr "Image du dispositif"

msgid "Download image file for current Pixel device."
msgstr "Téléchargez le fichier image pour l'appareil Pixel actuel."

msgid "Select Pixel Firmware"
msgstr "Sélectionner le micrologiciel de pixel"

msgid "Process"
msgstr "Traiter"

msgid "Process the firmware file and extract the boot.img"
msgstr "Traiter le fichier firmware et extraire le fichier boot.img"

msgid "Apply Custom ROM"
msgstr "Appliquer la rom personnalisée"

msgid "Caution: Make sure you read the selected ROM documentation.\nThis might not work for your ROM"
msgstr "Attention: assurez-vous de lire la documentation rom sélectionnée.\nCela pourrait ne pas fonctionner pour votre ROM"

msgid "Select Custom ROM"
msgstr "Sélectionnez l’icône Personnaliser"

msgid "Process the ROM file and extract the boot.img"
msgstr "Traiter le fichier rom et extraire le fichier boot.img"

msgid "Select a boot/init_boot"
msgstr "Sélectionner un boot/init_boot"

msgid "Show All boot/init_boot"
msgstr "Afficher tous les boot/init_boot"

msgid "Show all boot/init_boot even if it is\nnot part of the selected firmware or ROM"
msgstr "Afficher tous les boot/init_boot même si c'est le cas\nne fait pas partie du micrologiciel ou de la ROM sélectionnés"

msgid "Source SHA1  "
msgstr "Source SHA1 "

msgid "Package Fingerprint  "
msgstr "Empreinte digitale de l'emballage"

msgid "Patched with version "
msgstr "Corrigé avec la version"

msgid "Patch Method  "
msgstr "méthode de la hauteur au sable"

msgid "Patched on Device  "
msgstr "Corrigé sur l'appareil"

msgid "Date  "
msgstr "Date "

msgid "Package Path  "
msgstr "Chemin du colis"

msgid "Open Folder"
msgstr "Ouvrir le dossier"

msgid "Open boot files folder"
msgstr "Ouvrir le dossier des fichiers de démarrage"

msgid "Open Working Directory"
msgstr "Répertoire de travail"

msgid "Patch"
msgstr "Correctif"

msgid "Patch the selected item"
msgstr "Corriger l'élément sélectionné"

msgid "Patch with Magisk"
msgstr "Patch avec Magisk"

msgid "Patch with KernelSU"
msgstr "Correctif avec KernelSU"

msgid "Patch with KernelSU LKM"
msgstr "Patch avec KernelSU LKM"

msgid "Patch with KernelSU-Next"
msgstr "Correctif avec KernelSU-Next"

msgid "Patch with KernelSU-Next LKM"
msgstr "Correctif avec KernelSU-Next LKM"

msgid "Patch with APatch"
msgstr "Patch avec APatch"

msgid "Patch with APatch Alternate"
msgstr "Patch avec APatch Alternate"

msgid "Patch custom boot/init_boot"
msgstr "Patch boot personnalisé/init_boot"

msgid "Delete"
msgstr "Supprimer"

msgid "Delete the selected item"
msgstr "Supprimer l'article sélectionné"

msgid "Add a new boot item"
msgstr "Ajoutez un nouvel article"

msgid "Info"
msgstr "Info"

msgid "Get information about the selected item"
msgstr "Obtenir des informations sur l'élément sélectionné"

msgid "Live Boot"
msgstr "Live Boot"

msgid "Live boot to the selected item"
msgstr "Démarrage en direct de l'élément sélectionné"

msgid "Flash Boot"
msgstr "Flash Boot"

msgid "Flash just the selected item"
msgstr "Clignotez uniquement l'élément sélectionné"

msgid "Flash Mode"
msgstr "Mode Flash"

msgid "Keep Data"
msgstr "Conserver les données"

msgid "Data will be kept intact."
msgstr "Les données seront conservées intactes."

msgid "WIPE all data"
msgstr "EFFACER toutes les données"

msgid "CAUTION: This will wipe your data"
msgstr "ATTENTION: cela effacera vos données"

msgid "Dry Run"
msgstr "Essai à vide"

msgid ""
"Dry Run, no flashing will be done.\n"
"The phone will reboot to fastboot and then\n"
"back to normal.\n"
"This is for testing.\n"
msgstr ""
"Exécution à sec, aucun clignotement ne sera effectué.\n"
"Le téléphone redémarrera pour démarrer rapidement, puis\n"
"retour à la normale.\n"
"Ceci est pour les tests.\n"

msgid "Full OTA"
msgstr "OTA complet"

msgid "Flash full OTA, and have the choice of flashing patched image(s)."
msgstr "Flash full OTA, et avoir le choix d'image(s) patchée (s) clignotante (s)."

msgid "Custom Flash"
msgstr "Flash personnalisé"

msgid ""
"Custom Flash, Advanced option to flash a single file.\n"
"This will not flash the factory image.\n"
"It will flash the single selected file.\n"
msgstr ""
"Flash personnalisé, option avancée pour flasher un seul fichier.\n"
"Cela ne fera pas clignoter l'image d'usine.\n"
"Il clignotera le fichier sélectionné unique.\n"

msgid "Live Boot to selected boot / init_boot"
msgstr "Démarrage en direct vers le démarrage sélectionné/ init_boot"

msgid "Flash"
msgstr "Clignotant"

msgid "Flashes the selected boot / init_boot"
msgstr "Clignote le boot / init_boot sélectionné"

msgid "Depending on the flash selection, paste the appropriate path as custom image."
msgstr "En fonction de la sélection du flash, collez le chemin approprié en tant qu'image personnalisée."

msgid "Flash Options"
msgstr "Options de flash"

msgid "Flash to inactive slot"
msgstr "Emplacement Flash vers inactif"

msgid "This option when checked will flash to the alternate slot (inactive).\nKeeping the current slot intact.\n"
msgstr "Cette option, lorsqu'elle est cochée, clignotera vers l'autre emplacement (inactif).\nGarder la fente actuelle intacte.\n"

msgid "Flash to both slots"
msgstr "Flash sur les deux emplacements"

msgid "This option when checked will flash to both slots."
msgstr "Cette option, lorsqu'elle est cochée, clignotera dans les deux emplacements."

msgid "Disable Verity"
msgstr "Désactiver Verity"

msgid "Disables Verity"
msgstr "Désactive Verity"

msgid "Disable Verification"
msgstr "Désactiver vérification"

msgid "Disables Verification"
msgstr "Désactive la vérification"

msgid "Force"
msgstr "Forcer"

msgid "Force a flash operation that may be unsafe (will wipe your data)"
msgstr "Forcer une opération flash qui peut être dangereuse (effacera vos données)"

msgid "Verbose"
msgstr "Verbeux"

msgid "Set fastboot option to verbose"
msgstr "Définissez l'option fastboot sur verbose"

msgid "Temporary Root"
msgstr "Racine temporaire"

msgid "Wipe"
msgstr "Effacer"

msgid ""
"This option when enabled will not flash patched boot\n"
"Instead it will flash unpatched boot.img, but boot to Live Patched boot\n"
"Handy to test if Magisk will cause a bootloop.\n"
"Please be aware that this temporary root will not survive a subsequent reboot.\n"
"If you want to make this permanent, just Flash Boot the patched boot image.\n"
msgstr ""
"Cette option lorsqu'elle est activée ne clignotera pas le démarrage corrigé\n"
"Au lieu de cela, il clignotera boot.img non corrigé, mais démarre sur Live Patched boot\n"
"Pratique pour tester si Magisk va provoquer un bootloop.\n"
"Veuillez noter que cette racine temporaire ne survivra pas à un redémarrage ultérieur.\n"
"Si vous souhaitez rendre cela permanent, il vous suffit de démarrer Flash Boot avec l'image de démarrage corrigée.\n"

msgid "No reboot"
msgstr "Pas de redémarrage"

msgid "Do not reboot after flashing\nThis is useful if you want to perform other actions before reboot.\n"
msgstr "Ne pas redémarrer après avoir clignoté\nCeci est utile si vous souhaitez effectuer d'autres actions avant le redémarrage.\n"

msgid "This will invoke data wipe operation at the end of custom flashing.\nOne use case would be when disabling verification for the first time.\n"
msgstr "Cela appellera l'opération d'effacement des données à la fin du clignotement personnalisé.\nUn cas d'utilisation serait lors de la désactivation de la vérification pour la première fois.\n"

msgid "WARNING!!! This is a highly experimental feature.\nThis will attempt to downgrade the device without needing a data wipe.\n\n"
msgstr "Attention!!! Il s'agit d'une fonctionnalité très expérimentale.\nCela tentera de rétrograder l'appareil sans avoir besoin d'effacer les données.\n\n"

msgid "Flash Device"
msgstr "Flasher l'appareil"

msgid "Sideload OTA"
msgstr "Chargement latéral OTA"

msgid "Custom Flash Device"
msgstr "Flash personnalisé de l'appareil"

msgid "Flashes the selected device with chosen flash options."
msgstr "Fait clignoter l'appareil sélectionné avec les options de flash choisies."

msgid "Console"
msgstr "Console"

msgid "Please be patient ..."
msgstr "Patientez SVP"

msgid "Create encrypted and optionally sanitized support.zip file\nWhen sanitized all sensitive data is redacted.\n\nThis file is absolutely required when asking for help."
msgstr "Créez un fichier support.zip chiffré et éventuellement désinfecté\nLorsqu'elles sont nettoyées, toutes les données sensibles sont expurgées.\nCe fichier est absolument nécessaire lorsque vous demandez de l'aide."

msgid "Debug"
msgstr "Déboguer"

msgid "Enable Debug Messages in the console."
msgstr "Activer les messages de débogage dans la console."

msgid "Clear Console"
msgstr "Vider la console"

msgid "**APK installation options**<br/>\n"
msgstr "**Options d'installation APK**<br/>\n"

msgid "This is a summary of available options.<br/>\n"
msgstr "Ceci est un résumé des options disponibles.<br/>\n"

msgid "1. **Set ownership to Play Store Market** This option sets the ownership to Play Store (as if it was installed from Play Store).<br/>\n"
msgstr "1. ** Définir la propriété pour jouer le marché des magasins ** Cette option définit la propriété à Play Store (comme si elle avait été installée depuis Play Store).<br/>\n"

msgid "   Android auto apps require that they be installed from the Play Market.<br/>\n"
msgstr "   Les applications Android Auto exigent qu'elles soient installées à partir du marché des jeux.<br/>\n"

msgid "2. Starting with Android 14, apps with a targetSdkVersion lower than 23 can't be installed.<br/>\n"
msgstr "2. Commençant par Android 14, les applications avec une cibledkversion inférieure à 23 ne peuvent pas être installées.<br/>\n"

msgid "   Requiring apps to meet these minimum target API level requirements improves security and privacy for users.<br/><br/>\n"
msgstr "   Obliger les applications pour répondre à ces exigences minimales au niveau de l'API cible améliore la sécurité et la confidentialité des utilisateurs.<br/><br/>\n"

msgid "   Malware often targets older API levels in order to bypass security and privacy protections that have been introduced in newer Android versions.<br/>\n"
msgstr "   Les logiciels malveillants ciblent souvent les niveaux d'API plus anciens afin de contourner la sécurité et les protections de confidentialité qui ont été introduites dans les versions Android plus récentes.<br/>\n"

msgid "   For example, some malware apps use a `targetSdkVersion` of 22 to avoid being subjected to the runtime permission model\n"
msgstr "   Par exemple, certaines applications de logiciels malveillants utilisent un `TargetsDkversion` de 22 pour éviter d'être soumis au modèle d'autorisation d'exécution\n"

msgid "   introduced in 2015 by Android 6.0 Marshmallow (API level 23).<br/>\n"
msgstr "   Introduit en 2015 par Android 6.0 Marshmallow (API Niveau 23).<br/>\n"

msgid "   This Android 14 change makes it harder for malware to avoid security and privacy improvements.<br/>\n"
msgstr "   Ce changement Android 14 rend plus difficile pour les logiciels malveillants d'éviter la sécurité et les améliorations de la confidentialité.<br/>\n"

msgid "   Attempting to install an app targeting a lower API level will result in an installation failure.<br/><br/>\n"
msgstr "   Tenter d'installer une application ciblant un niveau API inférieur entraînera une panne d'installation.<br/><br/>\n"

msgid "   **Bypass low target sdk block** option bypasses that enforcement.\n"
msgstr "   ** Terger le bloc SDK de faible cible ** L'option contourne cette application.\n"

msgid "_If you have selected multiple APKs to install, the options will apply to all APKs._\n"
msgstr "_Si vous avez sélectionné plusieurs APK à installer, les options s'appliqueront à tous les APK._\n"

msgid "**This feature will generate a device analysis report that you could optionally post online to get assistance on Play Integrity related issues.**<br/>\n"
msgstr "**Cette fonctionnalité générera un rapport d'analyse de l'appareil que vous pourriez éventuellement publier en ligne pour obtenir de l'aide sur les problèmes liés à Play Integrity.**<br/>\n"

msgid "- Device state and other device related details.\n"
msgstr "- État de l'appareil et autres détails liés à l'appareil.\n"

msgid "- Magisk (if available):\n"
msgstr "- Magisk (si disponible) :\n"

msgid "	- modules list.\n"
msgstr "	- liste des modules.\n"

msgid "	- denylist.\n"
msgstr "	- liste de refus.\n"

msgid "- TrickyStore (if available):\n"
msgstr "- TrickyStore (si disponible) :\n"

msgid "	- `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)\n"
msgstr "	- `/data/adb/tricky_store/keybox.xml` (Pas le contenu, juste si les certificats sont révoqués ou non)\n"

msgid "- PlayIntegrity Fork (if available):\n"
msgstr "- PlayIntegrity Fork (si disponible) :\n"

msgid "- PlayIntegrityFix (if available):\n"
msgstr "- PlayIntegrityFix (si disponible) :\n"

msgid "- Whether a testkey ROM is used or not.\n"
msgstr "- Si une ROM testkey est utilisée ou non.\n"

msgid "- logcat for PlayIntegrity and TrickyStore related logs.\n"
msgstr "- logcat pour les journaux liés à PlayIntegrity et TrickyStore.\n"

msgid "- Droidguard VM list.\n"
msgstr "- Liste des VM Droidguard.\n"

msgid "- If any custom ROM injection apps are installed from:\n"
msgstr "- Si des applications d'injection de ROM personnalisée sont installées depuis :\n"

msgid "- Check overlays (if contents of /debug_ramdisk is visible without root)\n"
msgstr "- Vérification des superpositions (si le contenu de /debug_ramdisk est visible sans root)\n"

msgid "**NOTE:**\n"
msgstr "**REMARQUE :**\n"

msgid "This report will be saved at a location of your choosing, and will **not** be part of PixelFlasher captured logs (even though you see it in the console), so rest assured, if you submit support.zip for PixelFlasher related issues, even if you had generated such report, it will never be included in the support.zip file.<br/>\n"
msgstr "Ce rapport sera enregistré à un emplacement de votre choix et ne fera **pas** partie des journaux capturés par PixelFlasher (même si vous le voyez dans la console), donc soyez assuré que si vous soumettez support.zip pour les problèmes liés à PixelFlasher, même si vous avez généré un tel rapport, il ne sera jamais inclus dans le fichier support.zip.<br/>\n"

msgid "Your privacy is yours to keep.<br/>\n"
msgstr "Votre vie privée vous appartient.<br/>\n"

msgid "If you continue you'd only be generating the report, and not posting it online.<br/>\n"
msgstr "Si vous continuez, vous ne ferez que générer le rapport, sans le publier en ligne.<br/>\n"

msgid "If you want to post it online, please make sure to remove any sensitive information from the report before posting it online.<br/>\n"
msgstr "Si vous voulez le publier en ligne, veuillez vous assurer de supprimer toute information sensible du rapport avant de le publier en ligne.<br/>\n"

msgid "**Are you sure you want to continue?**<br/>\n"
msgstr "**Êtes-vous sûr de vouloir continuer ?**<br/>\n"

##############################################################################
# Advanced Settings
##############################################################################
msgid "Advanced Configuration Settings"
msgstr "Paramètres de configuration avancés"

msgid "WARNING!\n"
msgstr "AVERTISSEMENT!\n"

msgid "This is advanced configuration.\n"
msgstr "Ceci est une configuration avancée.\n"

msgid "Unless you know what you are doing,\n"
msgstr "À moins que vous sachiez ce que vous faites,\n"

msgid "you should not be enabling it.\n"
msgstr "vous ne devriez pas l'activer.\n"

msgid "YOU AND YOU ALONE ARE RESPONSIBLE FOR ANYTHING THAT HAPPENS TO YOUR DEVICE.\n"
msgstr "VOUS ET VOUS SEUL ÊTES RESPONSABLE DE TOUT CE QUI ARRIVE À VOTRE APPAREIL.\n"

msgid "THIS TOOL IS CODED WITH THE EXPRESS ASSUMPTION THAT YOU ARE FAMILIAR WITH\n"
msgstr "CET OUTIL EST CODÉ AVEC L'HYPOTHÈSE EXPRESSE QUE VOUS ÊTES FAMILIER AVEC\n"

msgid "ADB, MAGISK, ANDROID, AND ROOT.\n"
msgstr "ADB, MAGISK, ANDROID, ET ROOT.\n"

msgid "IT IS YOUR RESPONSIBILITY TO ENSURE THAT YOU KNOW WHAT YOU ARE DOING.\n"
msgstr "IL EST DE VOTRE RESPONSABILITÉ DE VOUS ASSURER QUE VOUS SAVEZ CE QUE VOUS FAITES.\n"

msgid "Enable Advanced Options"
msgstr "Activer les options avancées"

msgid "Expert mode"
msgstr "Mode expert"

msgid "Magisk Package Name"
msgstr "Nom du package Magisk"

msgid "If you have hidden Magisk,\nset this to the hidden package name."
msgstr "Si vous avez masqué Magisk,\ndéfinissez-le sur le nom du package masqué."

msgid "Resets package name to default: %s"
msgstr "Réinitialise le nom du package par défaut : %s"

msgid "Linux File Explorer:"
msgstr "Explorateur de fichiers Linux :"

msgid "Set full path to File Explorer.\nDefault: Nautilus"
msgstr "Définir le chemin complet vers l'explorateur de fichiers.\nPar défaut : Nautilus"

msgid "Linux Shell:"
msgstr "Shell Linux :"

msgid "Set full path to Linux Shell.\nDefault: gnome-terminal"
msgstr "Définir le chemin complet vers le Shell Linux.\nPar défaut : gnome-terminal"

msgid "Offer Patch Methods"
msgstr "Proposer des méthodes de patch"

msgid "When patching the choice of method is presented."
msgstr "Lors de l'application du patch, le choix de la méthode est présenté."

msgid "Patching Recovery Partition"
msgstr "Patcher la partition de récupération"

msgid ""
"Enabling this will show an option to patch a recovery partition.\n"
"This should be kept disabled unless you have an old device.\n"
"(most A-only devices launched with Android 9, legacy SAR)"
msgstr ""
"Activer cette option affichera une option pour patcher une partition de récupération.\n"
"Cela devrait rester désactivé sauf si vous avez un ancien appareil.\n"
"(la plupart des appareils A-only lancés avec Android 9, SAR hérité)"

msgid "Use Busybox Shell"
msgstr "Utiliser le Shell Busybox"

msgid "When creating a patch, if this is checked, busybox ash will be used as shell."
msgstr "Lors de la création d'un patch, si cette option est cochée, busybox ash sera utilisé comme shell."

msgid "System has low memory"
msgstr "Le système a peu de mémoire"

msgid "Use this option to sacrifice speed in favor of memory."
msgstr "Utilisez cette option pour sacrifier la vitesse en faveur de la mémoire."

msgid "Extra img extraction"
msgstr "Extraction d'images supplémentaires"

msgid "When checked and available in payload.bin\nAlso extract vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"
msgstr "Lorsque coché et disponible dans payload.bin\nExtrait également vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"

msgid "Show notifications"
msgstr "Afficher les notifications"

msgid "When checked PixelFlasher will display system toast notifications."
msgstr "Lorsque cette option est cochée, PixelFlasher affichera les notifications toast du système."

msgid "Always create boot.tar"
msgstr "Toujours créer boot.tar"

msgid "When checked, PixelFlasher always creates boot.tar of the patched boot file.\nIf unchecked, only for Samsung firmware boot.tar will be created."
msgstr "Lorsque cette option est cochée, PixelFlasher crée toujours un boot.tar du fichier de démarrage patché.\nSi décoché, boot.tar ne sera créé que pour le firmware Samsung."

msgid "Check for updates"
msgstr "Vérifier les mises à jour"

msgid "Checks for available updates on startup"
msgstr "Vérifie les mises à jour disponibles au démarrage"

msgid "Check for Minimum Disk (5Gb)"
msgstr "Vérifier l'espace disque minimum (5Go)"

msgid "Enforces minimum disk space of 5 Gb to allow flashing.\nThis avoids storage related issues."
msgstr "Impose un espace disque minimum de 5 Go pour permettre le flashage.\nCela évite les problèmes liés au stockage."

msgid "Check for bootloader unlocked"
msgstr "Vérifier si le bootloader est déverrouillé"

msgid "Checks to make sure bootloader is unlocked before flashing."
msgstr "Vérifie que le bootloader est déverrouillé avant le flashage."

msgid "Check for firmware hash validity"
msgstr "Vérifier la validité du hash du firmware"

msgid "Checks for sha256 portion to be in the image filename to detect Pixel compatible image."
msgstr "Vérifie que la partie sha256 est dans le nom du fichier image pour détecter une image compatible Pixel."

msgid "Keep temporary support files"
msgstr "Conserver les fichiers de support temporaires"

msgid "It keeps the temporary support files.\nUseful for inspecting what data is included in support.zip."
msgstr "Il conserve les fichiers de support temporaires.\nUtile pour inspecter les données incluses dans support.zip."

msgid "Check Magisk modules for updates"
msgstr "Vérifier les mises à jour des modules Magisk"

msgid ""
"It checks if the module has updates.\n"
"Disable this if you don't want to check for updates or\n"
" if some module update server has issues and delays the process."
msgstr ""
"Il vérifie si le module a des mises à jour.\n"
"Désactivez-le si vous ne voulez pas vérifier les mises à jour ou\n"
" si un serveur de mise à jour de module a des problèmes et retarde le processus."

msgid "Show custom ROM options"
msgstr "Afficher les options de ROM personnalisée"

msgid "Make sure you check if your ROM is supported."
msgstr "Assurez-vous de vérifier si votre ROM est prise en charge."

msgid "Sanitize (Redact) support files"
msgstr "Assainir (Expurger) les fichiers de support"

msgid ""
"The support files are always encrypted.\n"
"This option redacts sensitive information from the support files.\n"
"But impedes support and is not recommended."
msgstr ""
"Les fichiers de support sont toujours chiffrés.\n"
"Cette option expurge les informations sensibles des fichiers de support.\n"
"Mais entrave le support et n'est pas recommandée."

msgid "Force codepage to"
msgstr "Forcer la page de code à"

msgid "Uses specified code page instead of system code page"
msgstr "Utilise la page de code spécifiée au lieu de la page de code système"

msgid "Delete bundled libs"
msgstr "Supprimer les bibliothèques groupées"

msgid "The listed libraries would be deleted from the PF bundle to allow system defined ones to be used."
msgstr "Les bibliothèques listées seront supprimées du bundle PF pour permettre l'utilisation de celles définies par le système."

msgid "Example: libreadline.so.8, libgdk*"
msgstr "Exemple : libreadline.so.8, libgdk*"

msgid "Override KMI"
msgstr "Remplacer KMI"

msgid ""
"This will override the Kernel Module Interface (KMI) to the specified value.\n"
"This is useful for devices with custom kernels.\n"
"The value will be passed to KernelSU as the KMI value."
msgstr ""
"Cela remplacera l'Interface de Module du Noyau (KMI) par la valeur spécifiée.\n"
"C'est utile pour les appareils avec des noyaux personnalisés.\n"
"La valeur sera transmise à KernelSU comme valeur KMI."

msgid "Example: 5.15.131-android14"
msgstr "Exemple : 5.15.131-android14"

msgid "Use Custom Fontface"
msgstr "Utiliser une police personnalisée"

msgid "Use custom font for monospace fonts\nMight require PixelFlasher restart to properly apply to the Console window."
msgstr "Utiliser une police personnalisée pour les polices à espacement fixe\nPeut nécessiter un redémarrage de PixelFlasher pour s'appliquer correctement à la fenêtre Console."

msgid "Sample "
msgstr "Exemple "

msgid "Select font size"
msgstr "Sélectionner la taille de police"

msgid "scrcpy Path"
msgstr "Chemin de scrcpy"

msgid "Download scrcpy"
msgstr "Télécharger scrcpy"

msgid "Scrcpy executable (*.exe;*)|*.exe;*"
msgstr "Exécutable scrcpy (*.exe;*)|*.exe;*"

msgid "Select scrcpy executable"
msgstr "Sélectionner l'exécutable scrcpy"

msgid "Flags / Arguments (Example: --video-bit-rate 2M --max-fps=30 --max-size 1024)"
msgstr "Drapeaux / Arguments (Exemple : --video-bit-rate 2M --max-fps=30 --max-size 1024)"

msgid "Scrcpy settings"
msgstr "Paramètres de scrcpy"

##############################################################################
# Message dialogs and toasts (modules.py)
##############################################################################
msgid "Module update URL has issues, inform the module author: %s\nDo you want to skip checking updates for this module?"
msgstr "L'URL de mise à jour du module a des problèmes, informez l'auteur du module : %s\nVoulez-vous ignorer la vérification des mises à jour pour ce module ?"

msgid "You have an old or problematic Android platform Tools version %s \n"
msgstr "Vous avez une ancienne ou problématique version d'Android Platform Tools %s \n"

msgid "You are strongly advised to update before continuing.\n"
msgstr "Il est fortement conseillé de mettre à jour avant de continuer.\n"

msgid "Are you sure you want to continue?"
msgstr "Êtes-vous sûr de vouloir continuer ?"

msgid "Bad Android Platform Tools"
msgstr "Mauvais Android Platform Tools"

msgid "Android SDK Version:    %s\n"
msgstr "Version du SDK Android :    %s\n"

msgid "Device:                 %s %s %s\n"
msgstr "Appareil :               %s %s %s\n"

msgid "Factory Image:          %s\n"
msgstr "Image d'usine :          %s\n"

msgid "Custom Rom:             %s\n"
msgstr "ROM personnalisée :      %s\n"

msgid "Custom Rom File:        %s\n"
msgstr "Fichier ROM personnalisé : %s\n"

msgid "\nBoot image:             %s / %s \n"
msgstr "\nImage de démarrage :     %s / %s \n"

msgid "                        From: %s\n"
msgstr "                        De : %s\n"

msgid "                        Patched with %s on %s method:        %s\n"
msgstr "                        Patché avec %s sur %s méthode :     %s\n"

msgid "                        Patched with %s on %s\n"
msgstr "                        Patché avec %s sur %s\n"

msgid "\nFlash Mode:             %s\n"
msgstr "\nMode Flash :             %s\n"

msgid "SHA256 of %s%s matches the segment in the filename."
msgstr "SHA256 de %s%s correspond au segment dans le nom de fichier."

msgid "⚠️ Firmware SHA256 Mismatch"
msgstr "⚠️ Non-correspondance SHA256 du firmware"

msgid "WARNING! SHA256 of %s%s does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "ATTENTION ! Le SHA256 de %s%s ne correspond pas aux segments du nom de fichier.\nVeuillez vérifier pour vous assurer que la somme de contrôle est correcte."

msgid "Process action"
msgstr "Action de traitement"

msgid "❌ Could not extract %s"
msgstr "❌ Impossible d'extraire %s"

msgid "Possibly extracted firmware."
msgstr "Firmware possiblement extrait."

msgid "WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n"
msgstr "ATTENTION : Il semble que vous ayez extrait le fichier firmware.\net sélectionné le zip d'image à partir de celui-ci.\n\n"

msgid "You should not extract the file, please select the downloaded firmware file instead\n\n"
msgstr "Vous ne devriez pas extraire le fichier, veuillez sélectionner le fichier firmware téléchargé à la place\n\n"

msgid "If this is not the case, and you want to continue with this selection\n"
msgstr "Si ce n'est pas le cas, et que vous souhaitez continuer avec cette sélection\n"

msgid "❌ Could not unpack %s."
msgstr "❌ Impossible de décompresser %s."

msgid "❌ Could not extract %s."
msgstr "❌ Impossible d'extraire %s."

msgid "❌ Could not find %s."
msgstr "❌ Impossible de trouver %s."

msgid "⚠️ Detected unsupported firmware."
msgstr "⚠️ Firmware non pris en charge détecté."

msgid "❌ Could not extract payload.bin."
msgstr "❌ Impossible d'extraire payload.bin."

msgid "❌ The selected firmware is not valid."
msgstr "❌ Le firmware sélectionné n'est pas valide."

msgid "⚠️ Nothing to extract from %s"
msgstr "⚠️ Rien à extraire de %s"

msgid "✅ Process %s time: %s seconds"
msgstr "✅ Temps de traitement %s : %s secondes"

msgid "WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?"
msgstr "ATTENTION : Le boot.img cible n'est pas une rétrogradation.\nÊtes-vous sûr de vouloir continuer ?"

msgid "Confirm"
msgstr "Confirmer"

msgid "Display is Locked!"
msgstr "L'écran est verrouillé !"

msgid "ERROR: Your phone display is Locked.\n\n"
msgstr "ERREUR : L'écran de votre téléphone est verrouillé.\n\n"

msgid "Make sure you unlock your display\n"
msgstr "Assurez-vous de déverrouiller votre écran\n"

msgid "And set the display timeout to at least 1 minute.\n\n"
msgstr "Et définir le délai d'affichage à au moins 1 minute.\n\n"

msgid "After doing so, Click OK to accept and continue.\n"
msgstr "Après l'avoir fait, cliquez sur OK pour accepter et continuer.\n"

msgid "Manual Patching"
msgstr "Patching manuel"

msgid "Done creating the patch, continue"
msgstr "Création du patch terminée, continuer"

msgid "Magisk Manager is not detected."
msgstr "Magisk Manager n'est pas détecté."

msgid "WARNING: Magisk Manager [%s] is not found on the phone\n\n"
msgstr "ATTENTION : Magisk Manager [%s] n'est pas trouvé sur le téléphone\n\n"

msgid "This could be either because it is hidden, or it is not installed (most likely not installed)\n\n"
msgstr "Cela pourrait être soit parce qu'il est caché, soit parce qu'il n'est pas installé (probablement pas installé)\n\n"

msgid "If it is installed and hidden, then you should abort and then unhide it.\n"
msgstr "S'il est installé et caché, vous devriez abandonner puis le démasquer.\n"

msgid "If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n"
msgstr "Si Magisk n'est pas installé, PixelFlasher peut l'installer pour vous et l'utiliser pour le patching.\n\n"

msgid "WARNING: Do not install Magisk again if it is currently hidden.\n"
msgstr "ATTENTION : N'installez pas Magisk à nouveau s'il est actuellement caché.\n"

msgid "Do you want PixelFlasher to download and install Magisk?\n"
msgstr "Voulez-vous que PixelFlasher télécharge et installe Magisk ?\n"

msgid "You will be given a choice of Magisk Version to install.\n\n"
msgstr "Vous aurez le choix de la version de Magisk à installer.\n\n"

msgid "Click OK to continue with Magisk installation.\n"
msgstr "Cliquez sur OK pour continuer avec l'installation de Magisk.\n"

msgid "Kernel KMI Override"
msgstr "Remplacement du KMI du noyau"

msgid "Kernel KMI Override: %s\n\n"
msgstr "Remplacement du KMI du noyau : %s\n\n"

msgid "You have set a custom kernel KMI override.\n"
msgstr "Vous avez défini un remplacement personnalisé du KMI du noyau.\n"

msgid "Are you sure you want to proceed with this override?\n"
msgstr "Êtes-vous sûr de vouloir continuer avec ce remplacement ?\n"

msgid "Click OK to proceed with the override.\n"
msgstr "Cliquez sur OK pour continuer avec le remplacement.\n"

msgid "Boot Model Mismatch"
msgstr "Non-correspondance de modèle de démarrage"

msgid "APatch Manual Patching"
msgstr "Patching manuel APatch"

msgid "APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n"
msgstr "Le patching manuel APatch nécessite CONFIG_KALLSYMS=y dans la configuration du noyau.\n"

msgid "APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n"
msgstr "Le patching manuel APatch prend uniquement en charge les versions de noyau 3.18 - 6.1\n\n"

msgid "Do you want to continue regardless of not meeting the pre-requisites?\n\n"
msgstr "Voulez-vous continuer malgré le non-respect des conditions préalables ?\n\n"

msgid "Click Yes to continue with APatch Manual Patching\n"
msgstr "Cliquez sur Oui pour continuer avec le patching manuel APatch\n"

msgid "or Hit No to abort."
msgstr "ou appuyez sur Non pour abandonner."

msgid "Download Latest KernelPatch Tools"
msgstr "Télécharger les derniers outils KernelPatch"

msgid "Latest KernelPatch Tools Pre-release Version: %s\n"
msgstr "Dernière version préliminaire des outils KernelPatch : %s\n"

msgid "Latest KernelPatch Tools Release Version: %s\n\n"
msgstr "Dernière version publiée des outils KernelPatch : %s\n\n"

msgid "Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n"
msgstr "Voulez-vous télécharger les derniers kptools-android et kpimg-android qui incluent les versions préliminaires ?\n\n"

msgid "Click Yes to download the latest pre-release versions: %s\n"
msgstr "Cliquez sur Oui pour télécharger les dernières versions préliminaires : %s\n"

msgid "Click No to download the latest Release versions: %s\n"
msgstr "Cliquez sur Non pour télécharger les dernières versions publiées : %s\n"

msgid "%s Boot"
msgstr "Démarrage %s"

msgid "ERROR: Your phone model is: %s\n\n"
msgstr "ERREUR : Le modèle de votre téléphone est : %s\n\n"

msgid "The selected Boot is for: %s\n\n"
msgstr "Le démarrage sélectionné est pour : %s\n\n"

msgid "Unless you know what you are doing, if you continue flashing\n"
msgstr "À moins que vous sachiez ce que vous faites, si vous continuez le flashage\n"

msgid "you risk bricking your device, proceed only if you are absolutely\n"
msgstr "vous risquez de bricker votre appareil, ne procédez que si vous êtes absolument\n"

msgid "certain that this is what you want, you have been warned.\n\n"
msgstr "certain que c'est ce que vous voulez, vous avez été averti.\n\n"

msgid "Flash action"
msgstr "Action de flashage"

msgid "❌ Device is not detected."
msgstr "❌ L'appareil n'est pas détecté."

msgid "❌ Bootloader is locked, cannot flash."
msgstr "❌ Le bootloader est verrouillé, impossible de flasher."

msgid "Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"
msgstr "Votre bootloader est verrouillé ou vous n'avez pas accordé les permissions su au processus shell.\nVoulez-vous continuer quand même ?"

msgid "❌ Android Platform Tools is not set."
msgstr "❌ Android Platform Tools n'est pas défini."

msgid "❌ Valid device is not selected."
msgstr "❌ Aucun appareil valide n'est sélectionné."

msgid "❌ boot is not selected."
msgstr "❌ boot n'est pas sélectionné."

msgid "You can only sideload OTA that is equal or higher than the currently installed version.\n"
msgstr "Vous ne pouvez sideloader que des OTA égales ou supérieures à la version actuellement installée.\n"

msgid "Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n"
msgstr "Alternativement, vous pouvez flasher l'image firmware complète (avec effacement des données) pour rétrograder ou patcher l'image de démarrage actuelle pour permettre une rétrogradation sans effacement.\n"

msgid "See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n"
msgstr "Voir l'élément de menu : Outils de développement | AVB Préparer un patch de rétrogradation pour plus de détails.\n\n"

msgid "If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n"
msgstr "Si vous souhaitez toujours continuer, cliquez sur OUI pour accepter et continuer. ou NON pour abandonner.\n"

msgid "You have selected to WIPE data\nAre you sure want to continue?"
msgstr "Vous avez sélectionné d'EFFACER les données\nÊtes-vous sûr de vouloir continuer ?"

msgid "Wipe Data"
msgstr "Effacer les données"

msgid "✅ Wipe Data is accepted."
msgstr "✅ L'effacement des données est accepté."

msgid "You have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?"
msgstr "Vous avez sélectionné l'option de flash : Effacer\nCela effacera vos données\nÊtes-vous sûr de vouloir continuer ?"

msgid "Flash option: Wipe"
msgstr "Option de flash : Effacer"

msgid "✅ Wipe is accepted."
msgstr "✅ L'effacement est accepté."

msgid "You have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?"
msgstr "Vous avez sélectionné l'option de flash : Forcer\nCela effacera vos données\nÊtes-vous sûr de vouloir continuer ?"

msgid "Flash option: Force"
msgstr "Option de flash : Forcer"

msgid "✅ Force flag is accepted."
msgstr "✅ Le drapeau Force est accepté."

msgid "❌ Not enough disk space."
msgstr "❌ Espace disque insuffisant."

msgid "❌ Full OTA or factory image must be selected."
msgstr "❌ Une OTA complète ou une image d'usine doit être sélectionnée."

msgid "Tensor device not on Android 13 or higher"
msgstr "Appareil Tensor pas sous Android 13 ou supérieur"

msgid "WARNING: Your phone OS version is lower than Android 13.\n\n"
msgstr "ATTENTION : La version OS de votre téléphone est inférieure à Android 13.\n\n"

msgid "If you are upgrading to Android 13 or newer,\n"
msgstr "Si vous effectuez une mise à niveau vers Android 13 ou plus récent,\n"

msgid "make sure you at least flash the bootloader to both slots.\n"
msgstr "assurez-vous de flasher au moins le bootloader dans les deux emplacements.\n"

msgid "The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n"
msgstr "La mise à jour Android 13 pour Pixel 6, Pixel 6 Pro et Pixel 6a contient\n"

msgid "a bootloader update that increments the anti-roll back version for the bootloader.\n"
msgstr "une mise à jour du bootloader qui incrémente la version anti-retour en arrière pour le bootloader.\n"

msgid "This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n"
msgstr "Cela empêche l'appareil de revenir à des versions précédentes vulnérables du bootloader.\n"

msgid "After flashing an Android 13 build on these devices\n"
msgstr "Après avoir flashé une version Android 13 sur ces appareils\n"

msgid "you will not be able to flash and boot older Android 12 builds.\n\n"
msgstr "vous ne pourrez pas flasher et démarrer d'anciennes versions Android 12.\n\n"

msgid "Selecting the option 'Flash to both slots'\n"
msgstr "En sélectionnant l'option 'Flasher sur les deux emplacements'\n"

msgid "Will take care of that.\n\n"
msgstr "S'occupera de cela.\n\n"

msgid "Click OK to continue as is.\n"
msgstr "Cliquez sur OK pour continuer tel quel.\n"

msgid "or Hit CANCEL to abort and change options."
msgstr "ou appuyez sur ANNULER pour abandonner et changer les options."

msgid "✅ Anti rollback warning acknowledged and bypassed."
msgstr "✅ Avertissement anti-retour en arrière reconnu et contourné."

msgid "❌ downgrade_boot.img is not found."
msgstr "❌ downgrade_boot.img n'est pas trouvé."

msgid "❌ Unable to replace boot.img in image.zip."
msgstr "❌ Impossible de remplacer boot.img dans image.zip."

msgid "⚠️ Live booting Pixel 7 or newer devices is not supported."
msgstr "⚠️ Le démarrage en direct des appareils Pixel 7 ou plus récents n'est pas pris en charge."

msgid "❌ Image file is not selected."
msgstr "❌ Aucun fichier image n'est sélectionné."

msgid "❌ Boot file is not found."
msgstr "❌ Fichier de démarrage introuvable."

msgid "❌ ROM file is not found."
msgstr "❌ Fichier ROM introuvable."

msgid "Device / Firmware Mismatch"
msgstr "Non-correspondance appareil / firmware"

msgid "The selected firmware is for: %s\n\n"
msgstr "Le firmware sélectionné est pour : %s\n\n"

msgid "✅ Device / Firmware mismatch acknowledged."
msgstr "✅ Non-correspondance appareil / firmware reconnue."

msgid "❌ Encountered an error while rebooting to bootloader."
msgstr "❌ Une erreur s'est produite lors du redémarrage vers le bootloader."

msgid "❌ Encountered an error while rebooting to sideload."
msgstr "❌ Une erreur s'est produite lors du redémarrage vers le sideload."

msgid "❌ Encountered an error while rebooting to fastbootd."
msgstr "❌ Une erreur s'est produite lors du redémarrage vers fastbootd."

msgid "❌ Encountered an error while running the flash script."
msgstr "❌ Une erreur s'est produite lors de l'exécution du script de flash."

msgid "❌ Encountered an error while flashing the patch."
msgstr "❌ Une erreur s'est produite lors du flashage du patch."

msgid "❌ vbmeta flashing did not return the expected result."
msgstr "❌ Le flashage de vbmeta n'a pas renvoyé le résultat attendu."

msgid "❌ It appears that OTA flashing did not properly switch slots."
msgstr "❌ Il semble que le flashage OTA n'ait pas correctement changé les emplacements."

msgid "⚠️ Device is not found after rebooting to bootloader."
msgstr "⚠️ L'appareil n'est pas trouvé après le redémarrage vers le bootloader."

msgid "✅ Flashing elapsed time: %s seconds"
msgstr "✅ Temps écoulé de flashage : %s secondes"

msgid "You have selected  WIPE option.\nAdb debugging will be reset and disabled\nHence patch or vbmeta flashing will be skipped."
msgstr "Vous avez sélectionné l'option EFFACER.\nLe débogage adb sera réinitialisé et désactivé\nPar conséquent, le flashage du patch ou de vbmeta sera ignoré."

msgid "%s %s \n"
msgstr "%s %s \n"

msgid "Device is not detected."
msgstr "L'appareil n'est pas détecté."

msgid "Done rebooting to bootloader, continue"
msgstr "Redémarrage vers le bootloader terminé, continuer"

msgid "Done rebooting to system, continue"
msgstr "Redémarrage vers le système terminé, continuer"

msgid "## Is your device waiting for interaction?\n"
msgstr "## Votre appareil attend-il une interaction ?\n"

msgid "_If it is not, please hit the cancel button._\n"
msgstr "_Si ce n'est pas le cas, veuillez appuyer sur le bouton annuler._\n"

msgid "If your device is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "Si votre appareil attend une interaction utilisateur qui ne peut pas être invoquée par programme.\n"

msgid "- Using volume keys, scroll up and down and select **Reboot %s**\n"
msgstr "- À l'aide des touches de volume, faites défiler vers le haut et vers le bas et sélectionnez **Redémarrer %s**\n"

msgid "- Press the power button to apply.\n"
msgstr "- Appuyez sur le bouton d'alimentation pour appliquer.\n"

msgid "When done, the device should reboot to %s <br/>\n"
msgstr "Une fois terminé, l'appareil devrait redémarrer vers %s <br/>\n"

msgid "Wait for the device to fully boot to %s <br/>\n"
msgstr "Attendez que l'appareil démarre complètement vers %s <br/>\n"

msgid "Click on **Done rebooting to %s, continue** button <br/>\n"
msgstr "Cliquez sur le bouton **Redémarrage vers %s terminé, continuer** <br/>\n"

msgid "or hit the **Cancel** button to abort.\n"
msgstr "ou appuyez sur le bouton **Annuler** pour abandonner.\n"

msgid "Waiting for user interaction"
msgstr "En attente d'interaction utilisateur"

msgid "## Your watch should now be in Android Recovery\n"
msgstr "## Votre montre devrait maintenant être en mode Recovery Android\n"

msgid "The watch is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "La montre attend une interaction utilisateur qui ne peut pas être invoquée par programme.\n"

msgid "- Using touch, scroll and select **Reboot to bootloader**\n"
msgstr "- À l'aide du tactile, faites défiler et sélectionnez **Redémarrer vers le bootloader**\n"

msgid "- Press the side button to apply.\n"
msgstr "- Appuyez sur le bouton latéral pour appliquer.\n"

msgid "When done, the watch should reboot to bootloader mode <br/>\n"
msgstr "Une fois terminé, la montre devrait redémarrer en mode bootloader <br/>\n"

msgid "Wait for the watch to indicate that it is in bootloader mode <br/>\n"
msgstr "Attendez que la montre indique qu'elle est en mode bootloader <br/>\n"

msgid "Click on **Done rebooting to bootloader, continue** button <br/>\n"
msgstr "Cliquez sur le bouton **Redémarrage vers le bootloader terminé, continuer** <br/>\n"

msgid "- Using touch, scroll and select **Reboot to system now**\n"
msgstr "- À l'aide du tactile, faites défiler et sélectionnez **Redémarrer vers le système maintenant**\n"

msgid "When applied, the watch should reboot to system. <br/>\n"
msgstr "Une fois appliqué, la montre devrait redémarrer vers le système. <br/>\n"

msgid "Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n"
msgstr "Cliquez sur le bouton **Redémarrage vers le système terminé, continuer** lorsque l'OS de la montre est complètement chargé.\n"

##############################################################################
# Pif Manager
##############################################################################
msgid "Active Pif"
msgstr "Pif actif"

msgid "Loaded Pif (from Device)"
msgstr "Pif chargé (depuis l'appareil)"

msgid "Active pif is not modified."
msgstr "Le pif actif n'est pas modifié."

msgid "Save Active pif content to a json file on disk."
msgstr "Enregistrer le contenu du pif actif dans un fichier json sur le disque."

msgid "Pif Module"
msgstr "Module Pif"

msgid "Active pif is not saved in favorites."
msgstr "Le pif actif n'est pas enregistré dans les favoris."

msgid "Select a folder to import pif json files."
msgstr "Sélectionner un dossier pour importer des fichiers json pif."

msgid "Output"
msgstr "Sortie"

msgid "Console Output:\nIt could be the json output of processed prop\nor it could be the Play Integrity Check result.\n\nThis is not what currently is on the device."
msgstr "Sortie de console :\nCela pourrait être la sortie json d'une prop traitée\nou ce pourrait être le résultat de la vérification d'intégrité Play.\n\nCe n'est pas ce qui est actuellement sur l'appareil."

msgid "Smart Paste:\nSets First API to the set value if it is missing or forced.\nReprocesses the output window content to adapt to current module requirements.\nPastes to Active pif."
msgstr "Collage intelligent :\nDéfinit la première API à la valeur définie si elle est manquante ou forcée.\nRetraite le contenu de la fenêtre de sortie pour l'adapter aux exigences du module actuel.\nColle vers le pif actif."

msgid "Paste the console window content to Active pif."
msgstr "Coller le contenu de la fenêtre de console vers le pif actif."

msgid "Paste the Active pif to console window."
msgstr "Coller le pif actif vers la fenêtre de console."

msgid "Reprocess current Active Pif window json.\nUseful if you changed module version which might require additional / different fields."
msgstr "Retraiter le json de la fenêtre Pif actif actuelle.\nUtile si vous avez changé la version du module qui pourrait nécessiter des champs supplémentaires / différents."

msgid "Reprocess one or many json file(s)\nUseful if you changed module version which might require additional / different fields.\nIf a single file is selected, the new json will output to console output\nHowever if multiple files are selected, the selected file will be updated in place."
msgstr "Retraiter un ou plusieurs fichier(s) json\nUtile si vous avez changé la version du module qui pourrait nécessiter des champs supplémentaires / différents.\nSi un seul fichier est sélectionné, le nouveau json sera envoyé à la sortie de la console\nCependant, si plusieurs fichiers sont sélectionnés, le fichier sélectionné sera mis à jour sur place."

msgid "Process one or many json file(s) to generate the FrameworkPatcher formatted code excerpts.\n"
msgstr "Traiter un ou plusieurs fichier(s) json pour générer les extraits de code formatés FrameworkPatcher.\n"

msgid "Add missing Keys from device"
msgstr "Ajouter les clés manquantes depuis l'appareil"

msgid "When Processing or Reprocessing, add missing fields from device."
msgstr "Lors du traitement ou du retraitement, ajouter les champs manquants depuis l'appareil."

msgid "Force First API to:"
msgstr "Forcer la première API à :"

msgid "Forces First API value(s) to"
msgstr "Force la(les) valeur(s) de la première API à"

msgid "Sort Keys"
msgstr "Trier les clés"

msgid "Sorts json keys"
msgstr "Trie les clés json"

msgid "Keep All keys"
msgstr "Conserver toutes les clés"

msgid "Does not remove non standard / unrecognized keys"
msgstr "Ne supprime pas les clés non standard / non reconnues"

msgid "Spoof Build"
msgstr "Falsifier Build"

msgid "Spoof Props"
msgstr "Falsifier Props"

msgid "Spoof Provider"
msgstr "Falsifier Fournisseur"

msgid "Spoof Signature"
msgstr "Falsifier Signature"

msgid "Close"
msgstr "Fermer"

msgid "Create print"
msgstr "Créer impression"

msgid "Create pif.json / spoof_build_vars"
msgstr "Créer pif.json / spoof_build_vars"

msgid "Push print, no validation"
msgstr "Envoyer impression, sans validation"

msgid "Pushes the print as is without performing any validation.\nThis is useful to retain comments."
msgstr "Envoie l'impression telle quelle sans effectuer de validation.\nCeci est utile pour conserver les commentaires."

msgid "Reload print"
msgstr "Recharger impression"

msgid "Reload pif.json / spoof_build_vars from device."
msgstr "Recharger pif.json / spoof_build_vars depuis l'appareil."

msgid "Cleanup DG"
msgstr "Nettoyer DG"

msgid "Cleanup Droidguard Cache"
msgstr "Nettoyer le cache Droidguard"

msgid "Push keybox.xml"
msgstr "Envoyer keybox.xml"

msgid "Push a valid keybox.xml to device."
msgstr "Envoyer un keybox.xml valide vers l'appareil."

msgid "Edit TS Target"
msgstr "Éditer cible TS"

msgid "Edit Tricky Store target.txt file."
msgstr "Éditer le fichier target.txt de Tricky Store."

msgid "Edit TS SP"
msgstr "Éditer SP TS"

msgid "Edit Tricky Store security_patch.txt file."
msgstr "Éditer le fichier security_patch.txt de Tricky Store."

msgid "Process build.prop(s)"
msgstr "Traiter build.prop(s)"

msgid "Process build.prop to extract a compatible print."
msgstr "Traiter build.prop pour extraire une impression compatible."

msgid "Process bulk props"
msgstr "Traiter props en masse"

msgid "Process a folder containing .prop files and convert then to .json files."
msgstr "Traiter un dossier contenant des fichiers .prop et les convertir en fichiers .json."

msgid "Process Image"
msgstr "Traiter l'image"

msgid "Process an image and get a print from it."
msgstr "Traiter une image et en obtenir une impression."

msgid "Auto Update print"
msgstr "Mise à jour auto de l'impression"

msgid "After Processing build.props, the print is automatically pushed to the device and the GMS process is killed."
msgstr "Après le traitement des build.props, l'impression est automatiquement envoyée à l'appareil et le processus GMS est tué."

msgid "Auto Check Play Integrity"
msgstr "Vérification auto de Play Integrity"

msgid "After saving (pushing) print, automatically run Play Integrity Check."
msgstr "Après avoir enregistré (envoyé) l'impression, exécuter automatiquement la vérification de Play Integrity."

msgid "Disable UIAutomator"
msgstr "Désactiver UIAutomator"

msgid "Disables UIAutomator\nThis is useful for devices with buggy UIAutomator.\nNOTE: Create the coords.json file manually to make use of automated testing."
msgstr "Désactive UIAutomator\nCeci est utile pour les appareils avec UIAutomator bogué.\nREMARQUE : Créez manuellement le fichier coords.json pour utiliser les tests automatisés."

msgid "Play Integrity Check"
msgstr "Vérification de Play Integrity"

msgid "Play Integrity API Checker\nNote: Need to install app from Play store."
msgstr "Vérificateur d'API Play Integrity\nRemarque : Nécessite d'installer l'application depuis le Play Store."

msgid "Latest"
msgstr "Plus récent"

msgid "Custom"
msgstr "Personnalisé"

msgid "Select 'Latest' to get the latest Pixel beta pif (Includes Developer Preview).\nSelect 'Custom' to set a custom Android version code."
msgstr "Sélectionnez 'Plus récent' pour obtenir le dernier pif beta Pixel (inclut la Developer Preview).\nSélectionnez 'Personnalisé' pour définir un code de version Android personnalisé."

msgid "Set a valid Android version code."
msgstr "Définir un code de version Android valide."

msgid "Get Pixel Beta Pif"
msgstr "Obtenir Pif Beta Pixel"

msgid "Get the latest Pixel beta pif."
msgstr "Obtenir le dernier pif beta Pixel."

msgid "Get Xiaomi Pif"
msgstr "Obtenir Pif Xiaomi"

msgid "Get Xiaomi.eu pif\nEasy to start but is not recommended as it gets banned quickly.\nRecommended to find your own."
msgstr "Obtenir pif Xiaomi.eu\nFacile à démarrer mais non recommandé car il est rapidement banni.\nRecommandé de trouver le vôtre."

msgid "Get TheFreeman193 Random Pif"
msgstr "Obtenir Pif aléatoire TheFreeman193"

msgid "Get a random pif from TheFreeman193 repository.\nNote: The pif might or might not work."
msgstr "Obtenir un pif aléatoire du dépôt TheFreeman193.\nRemarque : Le pif peut fonctionner ou non."

msgid "No Device is selected.\nPif Manager features are set to limited mode."
msgstr "Aucun appareil n'est sélectionné.\nLes fonctionnalités du Gestionnaire Pif sont définies en mode limité."

msgid "Device is not rooted or SU permissions to adb shell is not granted.\nPif Manager features are set to limited mode."
msgstr "L'appareil n'est pas rooté ou les permissions SU au shell adb ne sont pas accordées.\nLes fonctionnalités du Gestionnaire Pif sont définies en mode limité."

msgid "Update print"
msgstr "Mettre à jour impression"

msgid "Update pif.json / spoof_build_vars."
msgstr "Mettre à jour pif.json / spoof_build_vars."

msgid "Create pif.json / spoof_build_vars."
msgstr "Créer pif.json / spoof_build_vars."

msgid "Getting Pixel beta print ...\nPlease be patient this could take some time ..."
msgstr "Obtention de l'impression beta Pixel...\nVeuillez patienter, cela peut prendre du temps..."

msgid "Failed to get beta print."
msgstr "Échec de l'obtention de l'impression beta."

msgid "Active pif not in sync"
msgstr "Pif actif non synchronisé"

msgid "⚠️ WARNING! Device pif is not in sync with Active Pif contents.\nThe result will not be reflective of the Active pif you're viewing."
msgstr "⚠️ ATTENTION ! Le pif de l'appareil n'est pas synchronisé avec le contenu du Pif actif.\nLe résultat ne reflétera pas le pif actif que vous consultez."

msgid "Choose property files to open"
msgstr "Choisir les fichiers de propriétés à ouvrir"

msgid "Select a Device Image"
msgstr "Sélectionner une image d'appareil"

msgid "Processing %s ...\nPlease be patient this could take some time ..."
msgstr "Traitement de %s...\nVeuillez patienter, cela peut prendre du temps..."

msgid "Image format not supported"
msgstr "Format d'image non pris en charge"

msgid "Select folder to bulk process props files"
msgstr "Sélectionner un dossier pour traiter en masse les fichiers props"

msgid "The contents is different than what is currently on the device.\nUpdate the print before testing."
msgstr "Le contenu est différent de ce qui se trouve actuellement sur l'appareil.\nMettez à jour l'impression avant de tester."

msgid "Active pif is saved in favorites."
msgstr "Le pif actif est enregistré dans les favoris."

msgid "Select keybox to push"
msgstr "Sélectionner keybox à envoyer"

msgid "Choose one or multiple json files to reprocess"
msgstr "Choisir un ou plusieurs fichiers json à retraiter"

msgid "Save FP file"
msgstr "Enregistrer fichier FP"

msgid "Enter a label:"
msgstr "Entrez une étiquette :"

msgid "Save Pif to Favorites"
msgstr "Enregistrer Pif dans les favoris"

msgid "Select folder to Import Pifs"
msgstr "Sélectionner un dossier pour importer des Pifs"

##############################################################################
# Magisk
##############################################################################
msgid "❌ ERROR: You must first select a valid device."
msgstr "❌ ERREUR : Vous devez d'abord sélectionner un appareil valide."

msgid "Manage Magisk"
msgstr "Gérer Magisk"

msgid "When you press the OK button, the Modules with checkbox selected will be enabled and the rest will be disabled."
msgstr "Lorsque vous appuyez sur le bouton OK, les modules avec case à cocher sélectionnée seront activés et les autres seront désactivés."

msgid "Magisk Modules"
msgstr "Modules Magisk"

msgid "Enable / Disable Magisk modules"
msgstr "Activer / Désactiver les modules Magisk"

msgid "Install Module"
msgstr "Installer le module"

msgid "Install magisk module."
msgstr "Installer le module magisk."

msgid "Update Module"
msgstr "Mettre à jour le module"

msgid "Update magisk module."
msgstr "Mettre à jour le module magisk."

msgid "Uninstall Module"
msgstr "Désinstaller le module"

msgid "Uninstall magisk module."
msgstr "Désinstaller le module magisk."

msgid "Run Action"
msgstr "Exécuter l'action"

msgid "Run Module action.sh."
msgstr "Exécuter action.sh du module."

msgid "Install Pif / TS Module"
msgstr "Installer le module Pif / TS"

msgid "Install Play Integrity Fix related modules."
msgstr "Installer le module Play Integrity Fix."

msgid "Install ZygiskNext Module"
msgstr "Installer le module ZygiskNext"

msgid "Install ZygiskNext module."
msgstr "Installer le module ZygiskNext."

msgid "Systemless Hosts"
msgstr "Hosts sans système"

msgid "Add Systemless Hosts Module."
msgstr "Ajouter le module Hosts sans système."

msgid "Enable Zygisk"
msgstr "Activer Zygisk"

msgid "Enable Magisk zygisk (requires reboot)"
msgstr "Activer Magisk zygisk (nécessite un redémarrage)"

msgid "Disable Zygisk"
msgstr "Désactiver Zygisk"

msgid "Disable Magisk zygisk (requires reboot)"
msgstr "Désactiver Magisk zygisk (nécessite un redémarrage)"

msgid "Enable Denylist"
msgstr "Activer la liste de refus"

msgid "Enable Magisk denylist"
msgstr "Activer la liste de refus Magisk"

msgid "Disable Denylist"
msgstr "Désactiver la liste de refus"

msgid "Disable Magisk denylist"
msgstr "Désactiver la liste de refus Magisk"

msgid "Refresh"
msgstr "Actualiser"

msgid "Refresh Magisk modules list."
msgstr "Actualiser la liste des modules Magisk."

msgid "To manage denylist or to manage SU permissions, use PixelFlasher's App Manager feature."
msgstr "Pour gérer la liste de refus ou pour gérer les permissions SU, utilisez la fonction Gestionnaire d'applications de PixelFlasher."

msgid "Use Pixelflasher's App Manager functionality to add/remove items to denylist or su permissions."
msgstr "Utilisez la fonctionnalité du Gestionnaire d'applications de Pixelflasher pour ajouter/supprimer des éléments à la liste de refus ou aux permissions su."

msgid "Restore Module"
msgstr "Restaurer le module"

msgid "## You need to reboot your device for the changes to take effect."
msgstr "## Vous devez redémarrer votre appareil pour que les changements prennent effet."

msgid "osm0sis PlayIntegrityFork"
msgstr "osm0sis PlayIntegrityFork"

msgid "chiteroman PlayIntegrityFix"
msgstr "chiteroman PlayIntegrityFix"

msgid "PIF Module"
msgstr "Module PIF"

msgid "Select the module you want to install"
msgstr "Sélectionnez le module que vous souhaitez installer"

msgid "## You need to reboot your device to complete the installation."
msgstr "## Vous devez redémarrer votre appareil pour terminer l'installation."

msgid "## You need to reboot your device to complete the update."
msgstr "## Vous devez redémarrer votre appareil pour terminer la mise à jour."

msgid "Copy"
msgstr "Copier"

msgid "Select All"
msgstr "Tout sélectionner"

msgid "Superuser Access"
msgstr "Modifier l'accès root"

msgid "Superuser Access (requires reboot)"
msgstr "Modifier l'accès root (nécessite un redémarrage)"

msgid "Apps Only"
msgstr "Applications uniquement"

msgid "ADB Only"
msgstr "ADB uniquement"

msgid "Apps and ADB"
msgstr "Applications et ADB"

msgid "Disabled"
msgstr "Désactivé"

##############################################################################
# Rooting App
##############################################################################
msgid "Download and Install Rooting Application"
msgstr "Télécharger et installer l'application de rootage"

msgid "Select rooting app to install."
msgstr "Sélectionnez l'application de rootage à installer."

msgid "Root App"
msgstr "Application Root"

msgid "Version"
msgstr "Version"

msgid "VersionCode"
msgstr "Code de version"

msgid "URL"
msgstr "URL"

msgid "Package"
msgstr "Paquet"

msgid "WARNING! Do not install magisk if you already have a hidden (stub) Magisk installed.\nFirst unhide Magisk before attempting an install."
msgstr "ATTENTION ! N'installez pas Magisk si vous avez déjà un Magisk caché (stub) installé.\nDémasquez d'abord Magisk avant de tenter une installation."

msgid "Download the rooting app."
msgstr "Télécharger l'application de rootage."

msgid "Copy URL to Clipboard"
msgstr "Copier l'URL dans le presse-papiers"

msgid "Copy Package ID to Clipboard"
msgstr "Copier l'ID du paquet dans le presse-papiers"

msgid "Download Selected Rooting App"
msgstr "Télécharger l'application de rootage sélectionnée"

msgid "Device Not Supported"
msgstr "Appareil non pris en charge"

msgid "The selected Magisk is not supported for your device\n"
msgstr "Le Magisk sélectionné n'est pas pris en charge pour votre appareil\n"

msgid "Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n"
msgstr "Seuls les Pixel 7 (panther), Pixel 7 Pro (cheetah), Pixel 7a (lynx) et Pixel Tablet (tangorpro) sont actuellement pris en charge.\n\n"

msgid "Unless you know what you are doing, if you choose to continue\n"
msgstr "À moins que vous sachiez ce que vous faites, si vous choisissez de continuer\n"

msgid "you risk running into serious issues, proceed only if you are absolutely\n"
msgstr "vous risquez de rencontrer de graves problèmes, ne procédez que si vous êtes absolument\n"

##############################################################################
# Magisk Backup Manager
##############################################################################
msgid "Check / Uncheck All"
msgstr "Cocher / Décocher tout"

msgid "Delete checked backups"
msgstr "Supprimer les sauvegardes cochées"

msgid "Add Backup from Computer"
msgstr "Ajouter une sauvegarde depuis l'ordinateur"

msgid "Select a boot.img and create a backup from it.\nWARNING! No verification is done if the selected file is stock boot image or even for the correct device."
msgstr "Sélectionnez un boot.img et créez une sauvegarde à partir de celui-ci.\nATTENTION ! Aucune vérification n'est effectuée pour savoir si le fichier sélectionné est une image de démarrage stock ou même pour le bon appareil."

msgid "Auto Create Backup"
msgstr "Créer automatiquement une sauvegarde"

msgid "Checks current boot partition,\nFf it is a Magisk Patched with SHA1\nand the boot.img is available, then it\nAutomatically creates a backup of boot image."
msgstr "Vérifie la partition de démarrage actuelle,\nS'il s'agit d'un Magisk Patché avec SHA1\net que le boot.img est disponible, alors il\nCrée automatiquement une sauvegarde de l'image de démarrage."

msgid "Closes this dialog"
msgstr "Ferme cette boîte de dialogue"

msgid "boot / init_boot image to create backup of."
msgstr "image boot / init_boot dont il faut créer une sauvegarde."

msgid "Delete Backup"
msgstr "Supprimer la sauvegarde"

msgid "Check All"
msgstr "Tout cocher"

msgid "UnCheck All"
msgstr "Tout décocher"

msgid "Copy to Clipboard"
msgstr "Copier dans le presse-papiers"

##############################################################################
# App Manager
##############################################################################
msgid "Set SU Permission"
msgstr "Définir les permissions SU"

msgid "Enter SU Permission details:"
msgstr "Entrez les détails des permissions SU :"

msgid "Enable Notification"
msgstr "Activer la notification"

msgid "Enable Logging"
msgstr "Activer la journalisation"

msgid "Forever"
msgstr "Pour toujours"

msgid "10 mins"
msgstr "10 minutes"

msgid "20 mins"
msgstr "20 minutes"

msgid "30 mins"
msgstr "30 minutes"

msgid "60 mins"
msgstr "60 minutes"

msgid "Allow"
msgstr "Autoriser"

msgid "Deny"
msgstr "Refuser"

msgid "Revoke"
msgstr "Révoquer"

msgid "Manage Packages on the Device"
msgstr "Gérer les paquets sur l'appareil"

msgid "%s Packages"
msgstr "%s Paquets"

msgid "Show System apps"
msgstr "Afficher les applications système"

msgid "Show 3rd Party apps"
msgstr "Afficher les applications tierces"

msgid "Get All Application Names"
msgstr "Obtenir tous les noms d'applications"

msgid "Extracts App names, and caches them for faster loading in the future.\nNOTE: This could take a while."
msgstr "Extrait les noms d'applications et les met en cache pour un chargement plus rapide à l'avenir.\nREMARQUE : Cela peut prendre un certain temps."

msgid "Disable"
msgstr "Désactiver"

msgid "Disable checked packages"
msgstr "Désactiver les paquets cochés"

msgid "Enable"
msgstr "Activer"

msgid "Enable checked packages"
msgstr "Activer les paquets cochés"

msgid "Uninstall"
msgstr "Désinstaller"

msgid "Uninstall checked packages"
msgstr "Désinstaller les paquets cochés"

msgid "Add to Denylist"
msgstr "Ajouter à la liste de refus"

msgid "Add package to Magisk Denylist"
msgstr "Ajouter le paquet à la liste de refus Magisk"

msgid "Remove from Denylist"
msgstr "Supprimer de la liste de refus"

msgid "Remove package from Magisk Denylist"
msgstr "Supprimer le paquet de la liste de refus Magisk"

msgid "Install an APK on the device"
msgstr "Installer un APK sur l'appareil"

msgid "Download APK"
msgstr "Télécharger APK"

msgid "Extract and download APK"
msgstr "Extraire et télécharger APK"

msgid "Export List"
msgstr "Exporter la liste"

msgid "Export the package list in CSV format"
msgstr "Exporter la liste des paquets au format CSV"

msgid "%s / %s Packages"
msgstr "%s / %s Paquets"

msgid "Export Package list"
msgstr "Exporter la liste des paquets"

msgid "Choose a directory where all apks should be saved."
msgstr "Choisissez un répertoire où tous les apks doivent être enregistrés."

msgid "Download APK file"
msgstr "Télécharger le fichier APK"

msgid "Disable Package"
msgstr "Désactiver le paquet"

msgid "Enable Package"
msgstr "Activer le paquet"

msgid "Uninstall Package"
msgstr "Désinstaller le paquet"

msgid "Download Package"
msgstr "Télécharger le paquet"

msgid "Launch Package"
msgstr "Lancer le paquet"

msgid "View Application Permissions"
msgstr "Voir les permissions de l'application"

msgid "Kill Application"
msgstr "Tuer l'application"

msgid "Clear Application Data"
msgstr "Effacer les données de l'application"

msgid "Add Package to Magisk Denylist"
msgstr "Ajouter le paquet à la liste de refus Magisk"

msgid "Remove Package from Magisk Denylist"
msgstr "Supprimer le paquet de la liste de refus Magisk"

msgid "SU Permission ..."
msgstr "Permission SU ..."

msgid "Before switching slots, please make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "Avant de changer d'emplacement, assurez-vous que votre appareil n'est pas soumis à des problèmes d'ARB.\nÊtes-vous sûr de vouloir continuer?"

msgid "Switch Slot potential concerns"
msgstr "Problèmes potentiels de changement d'emplacement"

msgid "## ⚠️ WARNING: You have selected to flash both slots.<br/>\n"
msgstr "## ⚠️ AVERTISSEMENT: Vous avez choisi de flasher les deux emplacements.<br/>\n"

msgid "Please make sure your device is not subject to ARB concerns before clicking continue.<br/>\n"
msgstr "Veuillez vous assurer que votre appareil n'est pas soumis à des problèmes d'ARB avant de cliquer sur continuer.<br/>\n"

msgid "You have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "Vous avez sélectionné l'option de flash: Flasher les deux emplacements\nVeuillez vous assurer que votre appareil n'est pas soumis à des problèmes d'ARB.\nÊtes-vous sûr de vouloir continuer?"

msgid "Flash option: Flash to both slots"
msgstr "Option de flash: Flasher les deux emplacements"

msgid "✅ Flash to both slots is accepted."
msgstr "✅ Flasher les deux emplacements est accepté."

msgid "Open URL on Device"
msgstr "Ouvrir une URL sur l'appareil"

msgid "Enter the URL to open on the device:"
msgstr "Entrez l'URL à ouvrir sur l'appareil :"

msgid "Open URL"
msgstr "Ouvrir l'URL"

msgid "Open a URL in the default browser"
msgstr "Ouvrir une URL dans le navigateur par défaut"

##############################################################################
# Additions 2025-07-20
##############################################################################
msgid "Keep Temp Files"
msgstr "Conserver les fichiers temporaires"

msgid "Enabling this will keep temporary files used for patching.\nThis is useful for debugging purposes.\nIt is recommended to keep this disabled."
msgstr "L'activation de cette option conservera les fichiers temporaires utilisés pour le patching.\nCeci est utile à des fins de débogage.\nIl est recommandé de laisser cette option désactivée."

msgid "Logcat"
msgstr "Logcat"

msgid "Logcat Viewer"
msgstr "Visualiseur Logcat"

msgid "Logcat filter: update_engine"
msgstr "Filtre Logcat : update_engine"

msgid "Logcat filtered for update_engine to monitor OTA merging"
msgstr "Logcat filtré pour update_engine pour surveiller la fusion OTA"

msgid "Bootloader Versions"
msgstr "Versions du bootloader"

msgid "Get Bootloader Versions"
msgstr "Obtenir les versions du bootloader"

msgid "Formatting Options"
msgstr "Options de formatage"

msgid "Enable formatting (-v)"
msgstr "Activer le formatage (-v)"

msgid "Enable or disable formatting options for logcat output"
msgstr "Activer ou désactiver les options de formatage pour la sortie logcat"

msgid "Format Verbs"
msgstr "Verbes de format"

msgid "Show priority, tag, and PID of the process issuing the message"
msgstr "Afficher la priorité, le tag et le PID du processus émettant le message"

msgid "Show all metadata fields and separate messages with blank lines"
msgstr "Afficher tous les champs de métadonnées et séparer les messages par des lignes vides"

msgid "Show PID only"
msgstr "Afficher uniquement le PID"

msgid "Show the raw log message with no other metadata fields"
msgstr "Afficher le message de journal brut sans autres champs de métadonnées"

msgid "Show the priority and tag only"
msgstr "Afficher uniquement la priorité et le tag"

msgid "Show priority, PID, and TID of the thread issuing the message"
msgstr "Afficher la priorité, le PID et le TID du thread émettant le message"

msgid "Show date, time, priority, tag, PID, and TID (default)"
msgstr "Afficher la date, l'heure, la priorité, le tag, le PID et le TID (par défaut)"

msgid "Show date, time, priority, tag, and PID of the process"
msgstr "Afficher la date, l'heure, la priorité, le tag et le PID du processus"

msgid "Adverb Modifiers"
msgstr "Modificateurs d'adverbe"

msgid "Show each priority with a different color"
msgstr "Afficher chaque priorité avec une couleur différente"

msgid "Show event descriptions from event-log-tags database"
msgstr "Afficher les descriptions d'événements de la base de données event-log-tags"

msgid "Show time as seconds since 1970-01-01 (Unix epoch)"
msgstr "Afficher l'heure en secondes depuis le 1er janvier 1970 (époque Unix)"

msgid "Show time as CPU seconds since boot"
msgstr "Afficher l'heure en secondes CPU depuis le démarrage"

msgid "Ensure that any binary logging content is escaped"
msgstr "S'assurer que tout contenu de journalisation binaire est échappé"

msgid "Show UID or Android ID of logged process (if permitted)"
msgstr "Afficher l'UID ou l'ID Android du processus journalisé (si autorisé)"

msgid "Show time with microsecond precision"
msgstr "Afficher l'heure avec une précision en microsecondes"

msgid "Filter Options"
msgstr "Options de filtre"

msgid "Tag Filter"
msgstr "Filtre de tag"

msgid "Tag:"
msgstr "Tag :"

msgid "Enter log component tag (or * for all)"
msgstr "Entrer le tag du composant de journal (ou * pour tous)"

msgid "Priority Level"
msgstr "Niveau de priorité"

msgid "Verbose (default for specific tag)"
msgstr "Verbeux (par défaut pour un tag spécifique)"

msgid "Debug (default for *)"
msgstr "Debug (par défaut pour *)"

msgid "Warn"
msgstr "Avertissement"

msgid "Fatal"
msgstr "Fatal"

msgid "Silent (suppress all output)"
msgstr "Silencieux (supprimer toute sortie)"

msgid "Additional Filters"
msgstr "Filtres supplémentaires"

msgid "Regex Filter (-e):"
msgstr "Filtre Regex (-e) :"

msgid "Enter ECMAScript regex to filter output"
msgstr "Entrer une regex ECMAScript pour filtrer la sortie"

msgid "UIDs Filter (comma-separated):"
msgstr "Filtre UIDs (séparés par des virgules) :"

msgid "Enter UIDs (numeric, comma-separated)"
msgstr "Entrer les UIDs (numériques, séparés par des virgules)"

msgid "View Logcat"
msgstr "Voir Logcat"

msgid "View logcat output with selected options"
msgstr "Voir la sortie logcat avec les options sélectionnées"

msgid "Clear Logcat"
msgstr "Effacer Logcat"

msgid "Clear logcat buffer"
msgstr "Effacer le buffer logcat"

msgid "Close this panel"
msgstr "Fermer ce panneau"

msgid "No device connected"
msgstr "Aucun appareil connecté"

msgid "Logcat buffer cleared"
msgstr "Buffer logcat effacé"
##############################################################################
# Additions 2025-09-08
##############################################################################
msgid "Select Package for TargetedFix Target"
msgstr "Sélectionner le paquet pour la cible TargetedFix"

msgid "Add Target"
msgstr "Ajouter cible"

msgid "Add selected package as TargetedFix target"
msgstr "Ajouter le paquet sélectionné comme cible TargetedFix"

msgid "Get Application Names"
msgstr "Obtenir les noms d'applications"

msgid "TF Targets"
msgstr "Cibles TF"

msgid "TargetedFix Targets"
msgstr "Cibles TargetedFix"

msgid "Add TF Target"
msgstr "Ajouter cible TF"

msgid "Add a new TargetedFix target by selecting from package list on device"
msgstr "Ajouter une nouvelle cible TargetedFix en sélectionnant dans la liste des paquets sur l'appareil"

msgid "Delete TF Target"
msgstr "Supprimer cible TF"

msgid "Delete the selected TargetedFix target"
msgstr "Supprimer la cible TargetedFix sélectionnée"

msgid "Edit TF Targets"
msgstr "Éditer cibles TF"

msgid "Edit TargetedFix targets file"
msgstr "Éditer le fichier des cibles TargetedFix"

msgid "Push TF Json"
msgstr "Envoyer TF Json"

msgid "Push Active pif content as JSON to the selected TargetedFix target"
msgstr "Envoyer le contenu du pif actif en tant que JSON à la cible TargetedFix sélectionnée"

msgid "Auto run migrate.sh"
msgstr "Exécuter automatiquement migrate.sh"

msgid "After saving (pushing) print, automatically run migrate.sh"
msgstr "Après avoir enregistré (envoyé) l'impression, exécuter automatiquement migrate.sh"

msgid "	- Contents of every app json configuration referenced in target.txt\n"
msgstr "    - Contenu de chaque configuration json d'application référencée dans target.txt\n"

##############################################################################
# Additions 2025-09-24
##############################################################################
msgid "There will be two versions created.<br/>\n"
msgstr "Il y aura deux versions créées.<br/>\n"

msgid "1. Unfiltered version, that would have some sensitive information such as Device ID.\n"
msgstr "1. Version non filtrée, qui contiendrait des informations sensibles telles que l'ID de l'appareil.\n"

msgid "2. Sanitized version which will filter out sensitive information<br/>\n"
msgstr "2. Version assainie qui filtrera les informations sensibles<br/>\n"

msgid "**Note:** If you're using publicly shared keybox, keep the checkbox `Redact Keybox details` unticked so that the keybox information is included in the report.<br/>\n"
msgstr "**Remarque :** Si vous utilisez un keybox partagé publiquement, laissez la case `Redact Keybox details` décochée afin que les informations du keybox soient incluses dans le rapport.<br/>\n"

msgid "If you're using a private keybox, please tick the checkbox `Redact Keybox details` to redact keybox details.<br/>\n"
msgstr "Si vous utilisez un keybox privé, veuillez cocher la case `Redact Keybox details` pour rédiger les détails du keybox.<br/>\n"

msgid "**This report will include the following details:**<br/>\n"
msgstr "**Ce rapport inclura les détails suivants :**<br/>\n"

msgid "- Playstore and GMS versions.\n"
msgstr "- Versions du Playstore et de GMS.\n"

msgid "Redact Keybox details"
msgstr "Rédiger les détails du Keybox"

##############################################################################
# Additions 2025-10-01
##############################################################################
msgid "Patch with SukiSU"
msgstr "Patch avec SukiSU"

msgid "Patch with SukiSU LKM"
msgstr "Patch avec SukiSU LKM"

msgid "Select a pre-built kernel flavor"
msgstr "Sélectionner une saveur de noyau pré-construite"

msgid "ShirkNeko flavor kernel"
msgstr "Kernel saveur ShirkNeko"

msgid "MiRinFork flavored kernel"
msgstr "Kernel saveur MiRinFork"

msgid "WildKernels"
msgstr "WildKernels"

##############################################################################
# Additions 2025-10-05
##############################################################################
msgid "Convert console content from env (key=value) prop format to json"
msgstr "Convertir le contenu de la console du format env (clé=valeur) en json"

msgid "Convert console content from json to env (key=value) prop format"
msgstr "Convertir le contenu de la console du format json en format env (clé=valeur)"

##############################################################################
# Additions 2025-10-11
##############################################################################
msgid "Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"
msgstr "Télécharger / Installer une application de rootage comme Magisk ou KernelSU* ou APatch ou SukiSU ou Wild_KSU"

msgid "Push TF Prop"
msgstr "Envoyer TF Prop"

##############################################################################
# Additions 2025-10-18
##############################################################################
msgid "Select Device"
msgstr "Sélectionner l'appareil"

msgid "Select a device:"
msgstr "Sélectionner un appareil :"

msgid "Unknown"
msgstr "Inconnu"

msgid "PixelFlasher guessed Kernel KMI"
msgstr "Kernel KMI deviné par PixelFlasher"

msgid "Your device kernel KMI is unknown probably because you're using\n"
msgstr "Le KMI du noyau de votre appareil est inconnu probablement parce que vous utilisez\n"

msgid "a custom kernel which has stripped out the Android build tag.\n\n"
msgstr "un noyau personnalisé qui a supprimé la balise de build Android.\n\n"

msgid "PixelFlasher has guessed the Kernel KMI to be: %s\n\n"
msgstr "PixelFlasher a deviné que le KMI du noyau est : %s\n\n"

msgid "Are you sure you want to proceed with this guessed KMI?\n"
msgstr "Êtes-vous sûr de vouloir continuer avec ce KMI deviné?\n"

##############################################################################
# Additions 2025-11-03
##############################################################################

msgid "The selected path contains single quotes (').\n\nPlease rename the folder to remove the single quotes and try again."
msgstr "Le chemin sélectionné contient des guillemets simples (').\n\nVeuillez renommer le dossier pour supprimer les guillemets simples et réessayer."

msgid "Options"
msgstr "Options"

msgid "Additional Options"
msgstr "Options supplémentaires"

msgid "Select Option"
msgstr "Sélectionner l'option"

msgid "⚠️ WARNING: With Option 3, fingerprint can't be patched."
msgstr "⚠️ AVERTISSEMENT : Avec l'option 3, l'empreinte digitale ne peut pas être patchée."

msgid " (Recommended)"
msgstr " (Recommandé)"

msgid "Latest Release"
msgstr "Dernière version"

msgid "Latest Pre-Release"
msgstr "Dernière pré-version"

msgid "Latest Release or Pre-Release"
msgstr "Dernière version ou pré-version"

msgid "Let me choose the kernel version from a matching list"
msgstr "Laissez-moi choisir la version du noyau à partir d'une liste correspondante"

msgid "Show all assets including non-matching ones"
msgstr "Afficher tous les actifs, y compris ceux qui ne correspondent pas"

msgid "Flash to active slot"
msgstr "Flasher sur l'emplacement actif"

msgid "Flash boot partition"
msgstr "Flasher la partition boot"

msgid "Flash init_boot partition"
msgstr "Flasher la partition init_boot"

msgid "Flash vendor_boot partition"
msgstr "Flasher la partition vendor_boot"

msgid "No Reboot after flash"
msgstr "Pas de redémarrage après le flash"

msgid "## ✅ Live Boot the stock image:\n"
msgstr "## ✅ Démarrage en direct de l'image stock :\n"

msgid "## ✅ Live Boot the patched image:\n"
msgstr "## ✅ Démarrage en direct de l'image patchée :\n"

msgid "## ❌ Live Booting is only supported for boot partition.\n"
msgstr "## ❌ Le démarrage en direct n'est pris en charge que pour la partition boot.\n"

msgid "## ❌ Valid image is not found that supports live booting.\n"
msgstr "## ❌ Aucune image valide n'est trouvée qui prend en charge le démarrage en direct.\n"

msgid "## ℹ️ Select partitions that you wish to flash stock image\n"
msgstr "## ℹ️ Sélectionnez les partitions que vous souhaitez flasher avec l'image stock\n"

msgid "## ℹ️ Select the options to flash a patch image:\n"
msgstr "## ℹ️ Sélectionnez les options pour flasher une image patchée :\n"

msgid "## ❌ The selected image is not valid.<br/>\n"
msgstr "## ❌ L'image sélectionnée n'est pas valide.<br/>\n"

msgid "Edit script before continuing"
msgstr "Éditer le script avant de continuer"

##############################################################################
# Additions 2025-12-28
##############################################################################

##############################################################################
# Download Progress Window
##############################################################################
msgid "Downloading: %s"
msgstr ""

##############################################################################
# File Editor Window
##############################################################################
msgid "Open Shell"
msgstr ""

msgid "Save and Continue"
msgstr ""

msgid "Cancel and Abort"
msgstr ""

msgid "Open Folder in working directory"
msgstr ""

msgid "Open command shell in working directory"
msgstr ""

msgid "Open Folder in working directory\nNote: PF_FILEMANAGER needs to be set."
msgstr ""

msgid "Open Terminal shell in working directory"
msgstr ""

msgid "Save the file and continue."
msgstr ""

msgid "Cancel and Abort."
msgstr ""

##############################################################################
# Ksu Asset Selector
##############################################################################
msgid "Filter:"
msgstr ""

msgid "Search assets..."
msgstr ""

msgid "Asset Name"
msgstr ""

msgid "Size"
msgstr ""

msgid "Suggested: %s"
msgstr ""

msgid "Please select an asset."
msgstr ""

msgid "No Selection"
msgstr ""

msgid "Select KSU Asset"
msgstr ""

msgid "Select a KSU asset:"
msgstr ""

```

`locale/it/LC_MESSAGES/pixelflasher.po`:

```po
# English translations for PixelFlasher.
# Copyright (C) 2023-2024 Badabing2005
# This file is distributed under the same license as the PixelFlasher package.
msgid ""
msgstr ""
"Project-Id-Version: PixelFlasher\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-13 16:17+0000\n"
"PO-Revision-Date: 2024-05-13 16:17+0000\n"
"Last-Translator: bandrea83 <come@anche.no>\n"
"Language-Team: Italian\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"


##############################################################################
# Common buttons
##############################################################################
msgid "Yes"
msgstr "Sì"

msgid "No"
msgstr "No"

msgid "OK"
msgstr "OK"

msgid "Cancel"
msgstr "Annulla"

msgid "Apply"
msgstr "Applica"

# Main Menu items
msgid "&File"
msgstr "&File"

msgid "&Device"
msgstr "&Dispositivo"

msgid "Dev Tools"
msgstr "Strumenti Dev"

msgid "&My Tools"
msgstr "&I Miei Strumenti"

msgid "&Google Images"
msgstr "&Immagini Google"

msgid "&Toolbar"
msgstr "&Barra degli strumenti"

msgid "&Language"
msgstr "&Lingua"

msgid "&Help"
msgstr "&Aiuto"

##############################################################################
# Menu
##############################################################################
# -------------------------------------
# File menu items
# -------------------------------------
msgid "Settings"
msgstr "Impostazioni"

msgid "Exit"
msgstr "Esci"

msgid "E&xit\tCtrl-Q"
msgstr "E&sci\tCtrl-Q"

msgid "Exit PixelFlasher"
msgstr "Esci da PixelFlasher"

# -------------------------------------
# Device menu items
# -------------------------------------
msgid "Install APK"
msgstr "Installa APK"

msgid "Package Manager"
msgstr "Gestore Pacchetti"

msgid "ADB Shell"
msgstr "Shell ADB"

msgid "Scrcpy"
msgstr "Scrcpy"

msgid "Device Info"
msgstr "Info Dispositivo"

msgid "Pif Print"
msgstr "Impronta Pif"

msgid "Props as Json"
msgstr "Proprietà come Json"

msgid "Dump Screen XML"
msgstr "Dump Schermo XML"

msgid "Cancel OTA Update"
msgstr "Annulla Aggiornamento OTA"

msgid "Check otacerts"
msgstr "Controlla otacerts"

msgid "Partitions Manager"
msgstr "Gestore Partizioni"

msgid "PI Analysis Report"
msgstr "Report Analisi PI"

msgid "Switch Slot"
msgstr "Cambia Slot"

msgid "Reboot"
msgstr "Riavvia"

# -------------------------------------
# Reboot sub-menu items
# -------------------------------------
msgid "System"
msgstr "Sistema"

msgid "Bootloader"
msgstr "Bootloader"

msgid "Fastbootd"
msgstr "Fastbootd"

msgid "Recovery"
msgstr "Recovery"

msgid "Interactive Recovery"
msgstr "Recovery Interattiva"

msgid "Safe Mode"
msgstr "Modalità Provvisoria"

msgid "Download"
msgstr "Download"

msgid "Sideload"
msgstr "Sideload"
# ---

msgid "Push file(s) to"
msgstr "Invia file a"

msgid "Magisk"
msgstr "Magisk"

msgid "Rooting App"
msgstr "App di Root"

msgid "Magisk Backup Manager"
msgstr "Gestore Backup Magisk"

msgid "Backup /data/adb"
msgstr "Backup /data/adb"

msgid "Restore /data/adb"
msgstr "Ripristina /data/adb"

msgid "Clear /data/adb/*"
msgstr "Pulisci /data/adb/*"

msgid "Start Shizuku"
msgstr "Avvia Shizuku"

msgid "Pif Manager"
msgstr "Gestore Pif"

msgid "SOS"
msgstr "SOS"

msgid "Lock Bootloader"
msgstr "Blocca Bootloader"

msgid "Unlock Bootloader"
msgstr "Sblocca Bootloader"

# -------------------------------------
# Dev Tools menu items
# -------------------------------------
msgid "Check keybox.xml"
msgstr "Controlla keybox.xml"

msgid "Decode Binary XML"
msgstr "Decodifica XML Binario"

msgid "AVB - Get Image Info"
msgstr "AVB - Ottieni Info Immagine"

msgid "AVB - Prepare Downgrade Patch"
msgstr "AVB - Prepara Patch Downgrade"

# -------------------------------------
# My Tools menu items
# -------------------------------------
msgid "Customize My Tools"
msgstr "Personalizza I Miei Strumenti"

# Google Images menu items
msgid "Phones"
msgstr "Telefoni"

msgid "Watches"
msgstr "Orologi"

msgid "Refresh images list"
msgstr "Aggiorna lista immagini"

msgid "Show Progress Window"
msgstr "Mostra Finestra Avanzamento"

# -------------------------------------
# Toolbar menu items
# -------------------------------------
msgid "Top"
msgstr "Alto"

msgid "Left"
msgstr "Sinistra"

msgid "Right"
msgstr "Destra"

msgid "Bottom"
msgstr "Basso"

msgid "Show Button Text"
msgstr "Mostra Testo Pulsante"

msgid "Show Button Icon"
msgstr "Mostra Icona Pulsante"

msgid "Show / Hide Buttons"
msgstr "Mostra / Nascondi Pulsanti"

# -------------------------------------
# Toolbar Show / Hide Button
# sub-menu items share translations
# from Device menu items
# -------------------------------------
msgid "Reboot to System"
msgstr "Riavvia al Sistema"

msgid "Reboot to Bootloader"
msgstr "Riavvia in Bootloader"

msgid "Reboot to Fastbootd"
msgstr "Riavvia in Fastbootd"

msgid "Reboot to Recovery"
msgstr "Riavvia in Recovery"

msgid "Reboot to Interactive Recovery"
msgstr "Riavvia in Recovery Interattiva"

msgid "Reboot to Safe Mode"
msgstr "Riavvia in Modalità Provvisoria"

msgid "Reboot to Download"
msgstr "Riavvia in Download Mode"

msgid "Reboot to Sideload"
msgstr "Riavvia in Sideload"

msgid "Configuration"
msgstr "Configurazione"

msgid "Support"
msgstr "Supporto"

# -------------------------------------
# Help menu items
# -------------------------------------
msgid "Report an Issue"
msgstr "Segnala un problema"

msgid "Feature Request"
msgstr "Richiesta Funzionalità"

msgid "PixelFlasher Project Page"
msgstr "Pagina Progetto PixelFlasher"

msgid "PixelFlasher Community (Forum)"
msgstr "Community PixelFlasher (Forum)"

msgid "Links"
msgstr "Link"

msgid "Open Configuration Folder"
msgstr "Apri Cartella Configurazione"

msgid "Open PixelFlasher Working Directory"
msgstr "Apri Cartella di Lavoro PixelFlasher"

msgid "Create a Sanitized support.zip"
msgstr "Crea un support.zip sanificato"

msgid "Check for New Version"
msgstr "Controlla Nuova Versione"

msgid "&About PixelFlasher"
msgstr "&Informazioni su PixelFlasher"

msgid "About"
msgstr "Info"

# -------------------------------------
# Links sub-menu items
# -------------------------------------
msgid "Homeboy76's Guide"
msgstr "Guida di Homeboy76"

msgid "V0latyle's Guide"
msgstr "Guida di V0latyle"

msgid "roirraW's Guide"
msgstr "Guida di roirraW"

msgid "osm0sis's PIF FAQ"
msgstr "FAQ PIF di osm0sis"

msgid "V0latyle's PI API Info"
msgstr "Info PI API di V0latyle"

msgid "Tricky Store (Support Thread)"
msgstr "Tricky Store (Thread di Supporto)"

msgid "osm0sis's PlayIntegrityFork"
msgstr "PlayIntegrityFork di osm0sis"

msgid "chiteroman's PlayIntegrityFix"
msgstr "PlayIntegrityFix di chiteroman"

msgid "5ec1cff's TrickyStore"
msgstr "TrickyStore di 5ec1cff"

msgid "Get the Google USB Driver"
msgstr "Ottieni i Driver USB Google"

msgid "Android Security Update Bulletins"
msgstr "Bollettini Sicurezza Android"

msgid "Android Codenames, tags, and build numbers"
msgstr "Codici, tag e numeri build Android"

msgid "Full OTA Images for Pixel Phones / Tablets"
msgstr "Immagini OTA complete per Telefoni / Tablet Pixel"

msgid "Factory Images for Pixel Phones / Tablets"
msgstr "Factory Image per Telefoni / Tablet Pixel"

msgid "Full OTA Images for Pixel Watches"
msgstr "Immagini OTA complete per Pixel Watch"

msgid "Factory Images for Pixel Watches"
msgstr "Factory Image per Pixel Watch"

msgid "Full OTA Images for Pixel Beta 16"
msgstr "Immagini OTA complete per Pixel Beta 16"

msgid "Factory Images for Pixel Beta 16"
msgstr "Factory Image per Pixel Beta 16"

##############################################################################
# Helper values
##############################################################################
msgid "Open adb shell to the device"
msgstr "Apri shell adb sul dispositivo"

msgid "Launch Screen Copy"
msgstr "Avvia Screen Copy (Scrcpy)"

msgid "Dump Full Device Info"
msgstr "Scarica Info Complete Dispositivo"

msgid "Get current device's Pif print (osm0sis fork v5 format)"
msgstr "Ottieni impronta Pif attuale del dispositivo (formato osm0sis fork v5)"

msgid "Get current device's properties in json format"
msgstr "Ottieni proprietà del dispositivo attuale in formato json"

msgid "Use uiautomator to dump the screen view in xml"
msgstr "Usa uiautomator per scaricare la vista schermo in xml"

msgid "Cancels and Resets OTA updates by Google (Not PixelFlasher)"
msgstr "Annulla e Resetta aggiornamenti OTA di Google (Non PixelFlasher)"

msgid "Used to see if ROM is signed or not."
msgstr "Usato per vedere se la ROM è firmata o meno."

msgid "Backup / Erase Partitions"
msgstr "Backup / Cancella Partizioni"

msgid "Generate a report of PI Analysis"
msgstr "Genera un report di Analisi PI"

msgid "Switch to the other slot"
msgstr "Cambia all'altro slot"

msgid "Manage Magisk modules and settings"
msgstr "Gestisci moduli e impostazioni Magisk"

msgid "Manage Magisk Backups"
msgstr "Gestisci Backup Magisk"

msgid ""
"Backs up /data/adb.\n"
"This is useful for backing up Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those paths will not be backed up."
msgstr ""
"Esegue il backup di /data/adb.\n"
"Utile per il backup dei moduli Magisk.\n"
"NOTA: Se un modulo scrive altrove rispetto a /data/adb, quei percorsi non saranno salvati."

msgid ""
"Restore /data/adb from a backup file.\n"
"This is useful for restoring Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those items will not be restored."
msgstr ""
"Ripristina /data/adb da un file di backup.\n"
"Utile per ripristinare i moduli Magisk.\n"
"NOTA: Se un modulo scrive altrove rispetto a /data/adb, quegli elementi non saranno ripristinati."

msgid ""
"Clear up /data/adb/ content (not the directory).\n"
"This is useful when switching to different root flavor."
msgstr ""
"Pulisce il contenuto di /data/adb/ (non la directory).\n"
"Utile quando si passa a un diverso tipo di root."

msgid "Starts Shizuku service on the device."
msgstr "Avvia il servizio Shizuku sul dispositivo."

msgid "Disable Magisk Modules"
msgstr "Disabilita Moduli Magisk"

msgid "Unlock Bootloader (Will wipe data)"
msgstr "Sblocca Bootloader (Cancellerà i dati)"

msgid "Get Android Verified Boot Image Info"
msgstr "Ottieni Info Immagine Android Verified Boot"

msgid "Create Downgrade Patch"
msgstr "Crea Patch Downgrade"

##############################################################################
# Toast messages
##############################################################################
msgid "Download Successful"
msgstr "Download Riuscito"

msgid "✅ File downloaded successfully: %s and saved to %s"
msgstr "✅ File scaricato con successo: %s e salvato in %s"

msgid "No Downloads"
msgstr "Nessun Download"

msgid "ℹ️ No downloads are in progress."
msgstr "ℹ️ Nessun download in corso."

msgid "⚠️ WARNING! SHA256 of the selected file does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "⚠️ ATTENZIONE! L'SHA256 del file selezionato non corrisponde ai segmenti nel nome del file.\nPer favore controlla due volte per assicurarti che il checksum sia valido."

msgid "APK Install"
msgstr "Installazione APK"

msgid "❌ ERROR: Please select a device before attempting APK Installation."
msgstr "❌ ERRORE: Seleziona un dispositivo prima di tentare l'installazione dell'APK."

msgid "❌ ERROR: No device selected"
msgstr "❌ ERRORE: Nessun dispositivo selezionato"

msgid "Check OTA Certs"
msgstr "Controlla Certificati OTA"

msgid "Device Analysis"
msgstr "Analisi Dispositivo"

msgid "❌ ERROR: /data/local/tmp is not accessible, this will affect some features."
msgstr "❌ ERRORE: /data/local/tmp non è accessibile, questo influenzerà alcune funzionalità."

msgid "vbmeta Warning!"
msgstr "Attenzione vbmeta!"

msgid "WARNING! Banned Kernel"
msgstr "ATTENZIONE! Kernel Bannato"

msgid "⚠️ Kernel string: %s is known to be banned.\nPlay Integrity would possibly fail."
msgstr "⚠️ Stringa Kernel: %s è nota per essere bannata.\nPlay Integrity potrebbe fallire."

msgid "Scan"
msgstr "Scansiona"

msgid "⚠️ No devices are found.."
msgstr "⚠️ Nessun dispositivo trovato.."

msgid "✅ Select your device from the list of %s found devices."
msgstr "✅ Seleziona il tuo dispositivo dalla lista di %s dispositivi trovati."

msgid "Firmware SHA256"
msgstr "SHA256 Firmware"

msgid "    ⚠️ WARNING! WARNING! WARNING!    Slot a verity / verification does not match slot b verity / verification"
msgstr "    ⚠️ ATTENZIONE! ATTENZIONE!    Verity / verifica dello slot A non corrisponde a verity / verifica dello slot B"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verity state and device's verity state\n"
msgstr "    ⚠️ ATTENZIONE! ATTENZIONE!    C'è una discrepanza tra lo stato verity vbmeta selezionato e lo stato verity del dispositivo\n"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verification state and device's verification state\n"
msgstr "    ⚠️ ATTENZIONE! ATTENZIONE!    C'è una discrepanza tra lo stato verification vbmeta selezionato e lo stato verification del dispositivo\n"

msgid "                                     This has a device wipe implications, please double check.\n"
msgstr "                                     Questo implica la cancellazione dei dati del dispositivo, si prega di ricontrollare.\n"

##############################################################################
# Message dialogs
##############################################################################
msgid "Error"
msgstr "Errore"

msgid "Warning"
msgstr "Attenzione"

msgid "Information"
msgstr "Informazione"

msgid "Success"
msgstr "Successo"

msgid "Click OK to accept and continue.\n"
msgstr "Clicca OK per accettare e continuare.\n"

msgid "or Hit CANCEL to abort."
msgstr "o premi ANNULLA per interrompere."

msgid "Select Language"
msgstr "Seleziona Lingua"

msgid "Language changed to %s. A restart is required for translations to apply."
msgstr "Lingua cambiata in %s. È necessario un riavvio per applicare le traduzioni."

msgid "Language Changed"
msgstr "Lingua Cambiata"

msgid "Updates are available"
msgstr "Sono disponibili aggiornamenti"

msgid "ℹ️ There are updates available for PixelFlasher.\n"
msgstr "ℹ️ Ci sono aggiornamenti disponibili per PixelFlasher.\n"

msgid "Click OK to download and install the updates.\n"
msgstr "Clicca OK per scaricare e installare gli aggiornamenti.\n"

msgid "Select binary xml file to decode"
msgstr "Seleziona file xml binario da decodificare"

msgid "Select a file"
msgstr "Seleziona un file"

msgid "Browse"
msgstr "Sfoglia"

msgid "  Browse  "
msgstr "  Sfoglia  "

msgid "Save File"
msgstr "Salva File"

msgid "ℹ️ There are updates available for your device.\nCheck Google Images menu.\n"
msgstr "ℹ️ Ci sono aggiornamenti disponibili per il tuo dispositivo.\nControlla il menu Immagini Google.\n"

msgid "Select one or multiple APK file(s) to install"
msgstr "Seleziona uno o più file APK da installare"

msgid "Save support file"
msgstr "Salva file di supporto"

msgid "Dump Screen Xml"
msgstr "Dump Xml Schermo"

msgid "Save device analysis"
msgstr "Salva analisi dispositivo"

msgid "Select files to push"
msgstr "Seleziona file da inviare"

msgid "Save /data/adb backup file"
msgstr "Salva file backup /data/adb"

msgid "Select /data/adb backup file"
msgstr "Seleziona file backup /data/adb"

msgid "Select keybox to test"
msgstr "Seleziona keybox da testare"

msgid "Add / Edit / Delete Custom menu items"
msgstr "Aggiungi / Modifica / Elimina voci menu Personalizzate"

msgid "Select Boot Image"
msgstr "Seleziona Immagine Boot"

##############################################################################
# Main UI
##############################################################################
msgid "Downloads Progress"
msgstr "Avanzamento Download"

msgid "Welcome to PixelFlasher %s by Badabing2005"
msgstr "Benvenuto in PixelFlasher %s di Badabing2005"

msgid "Install APK on the device"
msgstr "Installa APK sul dispositivo"

msgid "App Manager"
msgstr "Gestore App"

msgid "Manage Apps / Packages"
msgstr "Gestisci App / Pacchetti"

msgid "Open ADB shell to the device."
msgstr "Apri shell ADB sul dispositivo."

msgid "Partitions"
msgstr "Partizioni"

msgid "Partition Manager"
msgstr "Gestore Partizioni"

msgid "Switch to the other Slot"
msgstr "Cambia all'altro Slot"

msgid "Reboot to userspace fastboot (fastbootd)"
msgstr "Riavvia in userspace fastboot (fastbootd)"

msgid "iRecovery"
msgstr "iRecovery"

msgid "Reboot to Download Mode"
msgstr "Riavvia in Download Mode"

msgid "Reboot to Sideload Mode"
msgstr "Riavvia in Sideload Mode"

msgid "Magisk Backup"
msgstr "Backup Magisk"

msgid ""
"Remove Magisk Modules\n"
"This button issues the following command:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"This helps for cases where device bootloops due to incompatible magisk modules(YMMV).\n"
msgstr ""
"Rimuovi Moduli Magisk\n"
"Questo pulsante invia il seguente comando:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"Utile nei casi in cui il dispositivo vada in bootloop a causa di moduli Magisk incompatibili (Non garantito).\n"

msgid "Lock"
msgstr "Blocca"

msgid "UnLock"
msgstr "Sblocca"

msgid "UnLock Bootloader\nCaution will wipe data\n"
msgstr "Sblocca Bootloader\nAttenzione cancellerà i dati\n"

msgid "UnLock Bootloader"
msgstr "Sblocca Bootloader"

msgid "Configuration Settings"
msgstr "Impostazioni Configurazione"

msgid "Create Support file"
msgstr "Crea file di Supporto"

msgid "APK installation options"
msgstr "Opzioni installazione APK"

msgid "Install"
msgstr "Installa"

msgid "Set ownership to Play Store Market"
msgstr "Imposta proprietà a Play Store Market"

msgid "Bypass low target sdk block"
msgstr "Bypassa blocco target sdk basso"

msgid "ADB Connected Devices"
msgstr "Dispositivi Connessi ADB"

msgid "ADB Connected Devices\nCurrent Active Slot: [A]"
msgstr "Dispositivi Connessi ADB\nSlot Attivo Corrente: [A]"

msgid "ADB Connected Devices\nCurrent Active Slot: [B]"
msgstr "Dispositivi Connessi ADB\nSlot Attivo Corrente: [B]"

msgid "Android Platform Tools\nVersion %s"
msgstr "Android Platform Tools\nVersione %s"

msgid "Android Platform Tools"
msgstr "Android Platform Tools"

msgid "vbmeta issue."
msgstr "problema vbmeta."

msgid "Warning!\n%s\n"
msgstr "Attenzione!\n%s\n"

msgid "❌ ERROR: You must first select a boot image"
msgstr "❌ ERRORE: Devi prima selezionare un'immagine boot"

msgid "❌ ERROR: Downgrade patch file not found\nYou must first create a downgrade patch to enable this option.\n"
msgstr "❌ ERRORE: File patch downgrade non trovato\nDevi prima creare una patch downgrade per abilitare questa opzione.\n"

msgid "❌ ERROR: Wipe All Data is selected\nYou must first select another mode to enable this option.\n"
msgstr "❌ ERRORE: Cancella Tutti i Dati è selezionato\nDevi prima selezionare un'altra modalità per abilitare questa opzione.\n"

msgid "No Wipe Downgrade"
msgstr "Downgrade Senza Wipe"

msgid "                 WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "                 ATTENZIONE!!! ATTENZIONE!!! ATTENZIONE!!!\n\n\n"

msgid "THIS IS AN EXPERIMENTAL FEATURE, NO ASSURANCES THAT IT WOULD WORK\n\n"
msgstr "QUESTA È UNA FUNZIONE SPERIMENTALE, NESSUNA GARANZIA CHE FUNZIONI\n\n"

msgid "Do NOT enable this option if you are not downgrading!!!\n\n"
msgstr "NON abilitare questa opzione se non stai facendo un downgrade!!!\n\n"

msgid "Proceed only if you know what you're doing.\n\n\n"
msgstr "Procedi solo se sai cosa stai facendo.\n\n\n"

msgid "Do you want to continue to select the No Wipe Downgrade option?\n\n"
msgstr "Vuoi continuare selezionando l'opzione Downgrade Senza Wipe?\n\n"

msgid "       Press OK to continue or CANCEL to abort.\n\n"
msgstr "       Premi OK per continuare o ANNULLA per interrompere.\n\n"

msgid "CANCEL"
msgstr "ANNULLA"

msgid "         WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "         ATTENZIONE!!! ATTENZIONE!!! ATTENZIONE!!!\n\n\n"

msgid "NEVER, EVER LOCK THE BOOTLOADER WITHOUT REVERTING\n\n"
msgstr "MAI E POI MAI BLOCCARE IL BOOTLOADER SENZA RIPRISTINARE\n\n"

msgid "TO STOCK FIRMWARE OR YOUR PHONE WILL BE BRICKED!!!\n\n\n"
msgstr "IL FIRMWARE STOCK ALTRIMENTI IL TELEFONO VERRÀ BRICKATO!!!\n\n\n"

msgid "       THIS WILL WIPE YOUR DEVICE DATA!!!\n\n\n"
msgstr "       QUESTO CANCELLERÀ I DATI DEL TUO DISPOSITIVO!!!\n\n\n"

msgid "Do you want to continue to Lock the device bootloader?\n\n"
msgstr "Vuoi continuare con il Blocco del bootloader del dispositivo?\n\n"

msgid "WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n\n"
msgstr "ATTENZIONE!!! QUESTO CANCELLERÀ TUTTI I DATI UTENTE DAL DISPOSITIVO\n\n\n"

msgid "Make sure you first read either of the guides linked in the help menu.\n\n"
msgstr "Assicurati di leggere prima una delle guide linkate nel menu aiuto.\n\n"

msgid "Failing to follow the proper steps could potentially brick your phone.\n\n"
msgstr "Non seguire i passaggi corretti potrebbe potenzialmente brickare il telefono.\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will utilize\n\n"
msgstr "\nNota: Premere il pulsante OK invocherà uno script che utilizzerà\n\n"

msgid "fastboot commands, if your PC fastboot drivers are not properly setup,\n\n"
msgstr "comandi fastboot, se i driver fastboot del PC non sono configurati correttamente,\n\n"

msgid "fastboot will wait forever, and PixelFlasher will appear hung.\n\n"
msgstr "fastboot aspetterà all'infinito e PixelFlasher sembrerà bloccato.\n\n"

msgid "In such cases, killing the fastboot process will resume to normalcy.\n\n\n"
msgstr "In questi casi, terminare il processo fastboot ripristinerà la normalità.\n\n\n"

msgid "      Do you want to continue to Lock the device bootloader?\n\n"
msgstr "      Vuoi continuare con il Blocco del bootloader del dispositivo?\n\n"

msgid "              Press OK to continue or CANCEL to abort.\n\n"
msgstr "              Premi OK per continuare o ANNULLA per interrompere.\n\n"

msgid "      Do you want to continue to Unlock the device bootloader?\n\n"
msgstr "      Vuoi continuare con lo Sblocco del bootloader del dispositivo?\n\n"

msgid "WARNING!!! This is an experimental feature to attempt disabling magisk modules.\n\n\n"
msgstr "ATTENZIONE!!! Questa è una funzione sperimentale per tentare di disabilitare i moduli magisk.\n\n\n"

msgid "You would only need to do this if your device is bootlooping due to\n\n"
msgstr "Dovresti farlo solo se il tuo dispositivo è in bootloop a causa di\n\n"

msgid "incompatible magisk modules, this is not guaranteed to work in all cases (YMMV).\n\n"
msgstr "moduli magisk incompatibili, non è garantito che funzioni in tutti i casi.\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will wait forever to detect the device.\n\n"
msgstr "\nNota: Premere OK invocherà uno script che attenderà all'infinito di rilevare il dispositivo.\n\n"

msgid "If your device is not detected PixelFlasher will appear hung.\n\n"
msgstr "Se il dispositivo non viene rilevato, PixelFlasher sembrerà bloccato.\n\n"

msgid "In such cases, killing the adb process will resume to normalcy.\n\n\n"
msgstr "In questi casi, terminare il processo adb ripristinerà la normalità.\n\n\n"

msgid "                        Press OK to continue or CANCEL to abort.\n\n"
msgstr "                        Premi OK per continuare o ANNULLA per interrompere.\n\n"

msgid "Clear /data/adb/ contents"
msgstr "Pulisci contenuto /data/adb/"

msgid "WARNING!!! This will the clear contents of /data/adb\n\n\n"
msgstr "ATTENZIONE!!! Questo pulirà il contenuto di /data/adb\n\n\n"

msgid "Do you want to continue to clear /data/adb/ contents?\n\n"
msgstr "Vuoi continuare a pulire il contenuto di /data/adb/?\n\n"

msgid "      Press OK to continue or CANCEL to abort.\n\n"
msgstr "      Premi OK per continuare o ANNULLA per interrompere.\n\n"

msgid "This will invoke the command adb kill-server.\nAre you sure want to continue?\n"
msgstr "Questo invocherà il comando adb kill-server.\nSei sicuro di voler continuare?\n"

msgid "ADB Kill Server"
msgstr "ADB Kill Server"

msgid "Download Latest Android Platform-Tools"
msgstr "Scarica Ultimi Android Platform-Tools"

msgid "Select Android Platform-Tools Folder\nWhere adb and fastboot are located.\n"
msgstr "Seleziona Cartella Android Platform-Tools\nDove si trovano adb e fastboot.\n"

msgid "Double click this label to issue the command:\nadb kill-server"
msgstr "Doppio click su questa etichetta per inviare il comando:\nadb kill-server"

msgid "Open wireless manager dialog."
msgstr "Apri finestra gestione wireless."

msgid "[root status] [device mode] [device id] [device model] [device firmware]\n\n"
msgstr "[stato root] [mod. dispositivo] [id dispositivo] [modello dispositivo] [firmware dispositivo]\n\n"

msgid "✓ Rooted with Magisk.\n"
msgstr "✓ Rootato con Magisk.\n"

msgid "✗ Probably Not Root (Magisk Tools not found).\n"
msgstr "✗ Probabilmente Non Root (Strumenti Magisk non trovati).\n"

msgid "?  Unable to determine the root status.\n\n"
msgstr "?  Impossibile determinare lo stato di root.\n\n"

msgid "(adb) device is in adb mode\n"
msgstr "(adb) dispositivo in modalità adb\n"

msgid "(f.b) device is in fastboot mode\n"
msgstr "(f.b) dispositivo in modalità fastboot\n"

msgid "(sid) device is in sideload mode\n"
msgstr "(sid) dispositivo in modalità sideload\n"

msgid "(rec) device is in recovery mode\n"
msgstr "(rec) dispositivo in modalità recovery\n"

msgid "Scan for Devices\nPlease manually select the device after the scan is completed."
msgstr "Scansione Dispositivi\nSeleziona manualmente il dispositivo dopo il completamento della scansione."

msgid "Device Image"
msgstr "Immagine Dispositivo"

msgid "Download image file for current Pixel device."
msgstr "Scarica file immagine per il dispositivo Pixel corrente."

msgid "Select Pixel Firmware"
msgstr "Seleziona Firmware Pixel"

msgid "Process"
msgstr "Elabora"

msgid "Process the firmware file and extract the boot.img"
msgstr "Elabora il file firmware ed estrae il boot.img"

msgid "Apply Custom ROM"
msgstr "Applica Custom ROM"

msgid "Caution: Make sure you read the selected ROM documentation.\nThis might not work for your ROM"
msgstr "Attenzione: Assicurati di leggere la documentazione della ROM selezionata.\nPotrebbe non funzionare per la tua ROM"

msgid "Select Custom ROM"
msgstr "Seleziona Custom ROM"

msgid "Process the ROM file and extract the boot.img"
msgstr "Elabora il file ROM ed estrae il boot.img"

msgid "Select a boot/init_boot"
msgstr "Seleziona un boot/init_boot"

msgid "Show All boot/init_boot"
msgstr "Mostra Tutti i boot/init_boot"

msgid "Show all boot/init_boot even if it is\nnot part of the selected firmware or ROM"
msgstr "Mostra tutti i boot/init_boot anche se non\nfanno parte del firmware o ROM selezionati"

msgid "Source SHA1  "
msgstr "SHA1 Sorgente  "

msgid "Package Fingerprint  "
msgstr "Fingerprint Pacchetto  "

msgid "Patched with version "
msgstr "Patchato con versione "

msgid "Patch Method  "
msgstr "Metodo Patch  "

msgid "Patched on Device  "
msgstr "Patchato su Dispositivo  "

msgid "Date  "
msgstr "Data  "

msgid "Package Path  "
msgstr "Percorso Pacchetto  "

msgid "Open Folder"
msgstr "Apri Cartella"

msgid "Open boot files folder"
msgstr "Apri cartella file boot"

msgid "Open Working Directory"
msgstr "Apri Cartella di Lavoro"

msgid "Patch"
msgstr "Patch"

msgid "Patch the selected item"
msgstr "Patcha l'elemento selezionato"

msgid "Patch with Magisk"
msgstr "Patch con Magisk"

msgid "Patch with KernelSU"
msgstr "Patch con KernelSU"

msgid "Patch with KernelSU LKM"
msgstr "Patch con KernelSU LKM"

msgid "Patch with KernelSU-Next"
msgstr "Patch con KernelSU-Next"

msgid "Patch with KernelSU-Next LKM"
msgstr "Patch con KernelSU-Next LKM"

msgid "Patch with APatch"
msgstr "Patch con APatch"

msgid "Patch with APatch Alternate"
msgstr "Patch con APatch Alternativo"

msgid "Patch custom boot/init_boot"
msgstr "Patch custom boot/init_boot"

msgid "Delete"
msgstr "Elimina"

msgid "Delete the selected item"
msgstr "Elimina l'elemento selezionato"

msgid "Add a new boot item"
msgstr "Aggiungi un nuovo elemento boot"

msgid "Info"
msgstr "Info"

msgid "Get information about the selected item"
msgstr "Ottieni informazioni sull'elemento selezionato"

msgid "Live Boot"
msgstr "Live Boot"

msgid "Live boot to the selected item"
msgstr "Live boot sull'elemento selezionato"

msgid "Flash Boot"
msgstr "Flash Boot"

msgid "Flash just the selected item"
msgstr "Flasha solo l'elemento selezionato"

msgid "Flash Mode"
msgstr "Modalità Flash"

msgid "Keep Data"
msgstr "Mantieni Dati"

msgid "Data will be kept intact."
msgstr "I dati verranno mantenuti intatti."

msgid "WIPE all data"
msgstr "CANCELLA tutti i dati"

msgid "CAUTION: This will wipe your data"
msgstr "ATTENZIONE: Questo cancellerà i tuoi dati"

msgid "Dry Run"
msgstr "Simulazione (Dry Run)"

msgid ""
"Dry Run, no flashing will be done.\n"
"The phone will reboot to fastboot and then\n"
"back to normal.\n"
"This is for testing.\n"
msgstr ""
"Simulazione, nessun flash verrà eseguito.\n"
"Il telefono si riavvierà in fastboot e poi\n"
"tornerà alla normalità.\n"
"Questo serve per i test.\n"

msgid "Full OTA"
msgstr "OTA Completo"

msgid "Flash full OTA, and have the choice of flashing patched image(s)."
msgstr "Flash OTA completo, con scelta di flashare immagine/i patchata/e."

msgid "Custom Flash"
msgstr "Flash Personalizzato"

msgid ""
"Custom Flash, Advanced option to flash a single file.\n"
"This will not flash the factory image.\n"
"It will flash the single selected file.\n"
msgstr ""
"Flash Personalizzato, opzione avanzata per flashare un singolo file.\n"
"Questo non flasherà la factory image.\n"
"Flasherà il singolo file selezionato.\n"

msgid "Live Boot to selected boot / init_boot"
msgstr "Live Boot al boot / init_boot selezionato"

msgid "Flash"
msgstr "Flash"

msgid "Flashes the selected boot / init_boot"
msgstr "Flasha il boot / init_boot selezionato"

msgid "Depending on the flash selection, paste the appropriate path as custom image."
msgstr "A seconda della selezione di flash, incolla il percorso appropriato come immagine personalizzata."

msgid "Flash Options"
msgstr "Opzioni Flash"

msgid "Flash to inactive slot"
msgstr "Flash sullo slot inattivo"

msgid "This option when checked will flash to the alternate slot (inactive).\nKeeping the current slot intact.\n"
msgstr "Questa opzione se selezionata flasherà sullo slot alternativo (inattivo).\nMantenendo lo slot corrente intatto.\n"

msgid "Flash to both slots"
msgstr "Flash su entrambi gli slot"

msgid "This option when checked will flash to both slots."
msgstr "Questa opzione se selezionata flasherà su entrambi gli slot."

msgid "Disable Verity"
msgstr "Disabilita Verity"

msgid "Disables Verity"
msgstr "Disabilita Verity"

msgid "Disable Verification"
msgstr "Disabilita Verification"

msgid "Disables Verification"
msgstr "Disabilita Verification"

msgid "Force"
msgstr "Forza"

msgid "Force a flash operation that may be unsafe (will wipe your data)"
msgstr "Forza un'operazione di flash che potrebbe non essere sicura (cancellerà i tuoi dati)"

msgid "Verbose"
msgstr "Dettagliato"

msgid "Set fastboot option to verbose"
msgstr "Imposta opzione fastboot su dettagliato"

msgid "Temporary Root"
msgstr "Root Temporaneo"

msgid "Wipe"
msgstr "Wipe (Cancella)"

msgid ""
"This option when enabled will not flash patched boot\n"
"Instead it will flash unpatched boot.img, but boot to Live Patched boot\n"
"Handy to test if Magisk will cause a bootloop.\n"
"Please be aware that this temporary root will not survive a subsequent reboot.\n"
"If you want to make this permanent, just Flash Boot the patched boot image.\n"
msgstr ""
"Questa opzione se abilitata non flasherà il boot patchato\n"
"Invece flasherà il boot.img non patchato, ma avvierà in Live Patched boot\n"
"Comodo per testare se Magisk causerà un bootloop.\n"
"Tieni presente che questo root temporaneo non sopravviverà a un riavvio successivo.\n"
"Se vuoi renderlo permanente, esegui Flash Boot dell'immagine boot patchata.\n"

msgid "No reboot"
msgstr "Nessun riavvio"

msgid "Do not reboot after flashing\nThis is useful if you want to perform other actions before reboot.\n"
msgstr "Non riavviare dopo il flash\nUtile se vuoi eseguire altre azioni prima del riavvio.\n"

msgid "This will invoke data wipe operation at the end of custom flashing.\nOne use case would be when disabling verification for the first time.\n"
msgstr "Questo invocherà l'operazione di cancellazione dati alla fine del flash personalizzato.\nUn caso d'uso sarebbe quando si disabilita la verifica per la prima volta.\n"

msgid "WARNING!!! This is a highly experimental feature.\nThis will attempt to downgrade the device without needing a data wipe.\n\n"
msgstr "ATTENZIONE!!! Questa è una funzione altamente sperimentale.\nTenterà di fare il downgrade del dispositivo senza bisogno di cancellare i dati.\n\n"

msgid "Flash Device"
msgstr "Flasha Dispositivo"

msgid "Sideload OTA"
msgstr "Sideload OTA"

msgid "Custom Flash Device"
msgstr "Flash Dispositivo Personalizzato"

msgid "Flashes the selected device with chosen flash options."
msgstr "Flasha il dispositivo selezionato con le opzioni di flash scelte."

msgid "Console"
msgstr "Console"

msgid "Please be patient ..."
msgstr "Si prega di pazientare ..."

msgid "Create encrypted and optionally sanitized support.zip file\nWhen sanitized all sensitive data is redacted.\n\nThis file is absolutely required when asking for help."
msgstr "Crea un file support.zip crittografato e opzionalmente sanificato\nSe sanificato tutti i dati sensibili sono oscurati.\n\nQuesto file è assolutamente richiesto quando si chiede aiuto."

msgid "Debug"
msgstr "Debug"

msgid "Enable Debug Messages in the console."
msgstr "Abilita messaggi di Debug nella console."

msgid "Clear Console"
msgstr "Pulisci Console"

msgid "**APK installation options**<br/>\n"
msgstr "**Opzioni installazione APK**<br/>\n"

msgid "This is a summary of available options.<br/>\n"
msgstr "Questo è un riepilogo delle opzioni disponibili.<br/>\n"

msgid "1. **Set ownership to Play Store Market** This option sets the ownership to Play Store (as if it was installed from Play Store).<br/>\n"
msgstr "1. **Imposta proprietà a Play Store Market** Questa opzione imposta la proprietà a Play Store (come se fosse stato installato dal Play Store).<br/>\n"

msgid "   Android auto apps require that they be installed from the Play Market.<br/>\n"
msgstr "   Le app Android auto richiedono di essere installate dal Play Market.<br/>\n"

msgid "2. Starting with Android 14, apps with a targetSdkVersion lower than 23 can't be installed.<br/>\n"
msgstr "2. A partire da Android 14, le app con targetSdkVersion inferiore a 23 non possono essere installate.<br/>\n"

msgid "   Requiring apps to meet these minimum target API level requirements improves security and privacy for users.<br/><br/>\n"
msgstr "   Richiedere alle app di soddisfare questi requisiti minimi di livello API target migliora la sicurezza e la privacy per gli utenti.<br/><br/>\n"

msgid "   Malware often targets older API levels in order to bypass security and privacy protections that have been introduced in newer Android versions.<br/>\n"
msgstr "   Il malware spesso prende di mira livelli API più vecchi per aggirare le protezioni di sicurezza e privacy introdotte nelle versioni Android più recenti.<br/>\n"

msgid "   For example, some malware apps use a `targetSdkVersion` of 22 to avoid being subjected to the runtime permission model\n"
msgstr "   Ad esempio, alcune app malware usano un `targetSdkVersion` di 22 per evitare di essere soggette al modello di permessi runtime\n"

msgid "   introduced in 2015 by Android 6.0 Marshmallow (API level 23).<br/>\n"
msgstr "   introdotto nel 2015 da Android 6.0 Marshmallow (livello API 23).<br/>\n"

msgid "   This Android 14 change makes it harder for malware to avoid security and privacy improvements.<br/>\n"
msgstr "   Questa modifica di Android 14 rende più difficile per il malware evitare i miglioramenti di sicurezza e privacy.<br/>\n"

msgid "   Attempting to install an app targeting a lower API level will result in an installation failure.<br/><br/>\n"
msgstr "   Tentare di installare un'app che punta a un livello API inferiore risulterà in un fallimento dell'installazione.<br/><br/>\n"

msgid "   **Bypass low target sdk block** option bypasses that enforcement.\n"
msgstr "   L'opzione **Bypassa blocco target sdk basso** aggira questa restrizione.\n"

msgid "_If you have selected multiple APKs to install, the options will apply to all APKs._\n"
msgstr "_Se hai selezionato più APK da installare, le opzioni si applicheranno a tutti gli APK._\n"

msgid "**This feature will generate a device analysis report that you could optionally post online to get assistance on Play Integrity related issues.**<br/>\n"
msgstr "**Questa funzionalità genererà un report di analisi del dispositivo che potrai opzionalmente pubblicare online per ottenere assistenza su problemi relativi a Play Integrity.**<br/>\n"

msgid "- Device state and other device related details.\n"
msgstr "- Stato del dispositivo e altri dettagli relativi al dispositivo.\n"

msgid "- Magisk (if available):\n"
msgstr "- Magisk (se disponibile):\n"

msgid "	- modules list.\n"
msgstr "	- lista moduli.\n"

msgid "	- denylist.\n"
msgstr "	- denylist.\n"

msgid "- TrickyStore (if available):\n"
msgstr "- TrickyStore (se disponibile):\n"

msgid "	- `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)\n"
msgstr "	- `/data/adb/tricky_store/keybox.xml` (Non il contenuto, solo se i certificati sono revocati o meno)\n"

msgid "- PlayIntegrity Fork (if available):\n"
msgstr "- PlayIntegrity Fork (se disponibile):\n"

msgid "- PlayIntegrityFix (if available):\n"
msgstr "- PlayIntegrityFix (se disponibile):\n"

msgid "- Whether a testkey ROM is used or not.\n"
msgstr "- Se viene usata una ROM testkey o meno.\n"

msgid "- logcat for PlayIntegrity and TrickyStore related logs.\n"
msgstr "- logcat per log relativi a PlayIntegrity e TrickyStore.\n"

msgid "- Droidguard VM list.\n"
msgstr "- Lista Droidguard VM.\n"

msgid "- If any custom ROM injection apps are installed from:\n"
msgstr "- Se sono installate app di iniezione Custom ROM da:\n"

msgid "- Check overlays (if contents of /debug_ramdisk is visible without root)\n"
msgstr "- Controlla overlay (se il contenuto di /debug_ramdisk è visibile senza root)\n"

msgid "**NOTE:**\n"
msgstr "**NOTA:**\n"

msgid "This report will be saved at a location of your choosing, and will **not** be part of PixelFlasher captured logs (even though you see it in the console), so rest assured, if you submit support.zip for PixelFlasher related issues, even if you had generated such report, it will never be included in the support.zip file.<br/>\n"
msgstr "Questo report verrà salvato in una posizione a tua scelta e **non** farà parte dei log catturati da PixelFlasher (anche se lo vedi nella console), quindi stai tranquillo, se invii support.zip per problemi relativi a PixelFlasher, anche se avevi generato tale report, non sarà mai incluso nel file support.zip.<br/>\n"

msgid "Your privacy is yours to keep.<br/>\n"
msgstr "La tua privacy è tua da custodire.<br/>\n"

msgid "If you continue you'd only be generating the report, and not posting it online.<br/>\n"
msgstr "Se continui genererai solo il report, e non lo pubblicherai online.<br/>\n"

msgid "If you want to post it online, please make sure to remove any sensitive information from the report before posting it online.<br/>\n"
msgstr "Se vuoi pubblicarlo online, assicurati di rimuovere qualsiasi informazione sensibile dal report prima di pubblicarlo.<br/>\n"

msgid "**Are you sure you want to continue?**<br/>\n"
msgstr "**Sei sicuro di voler continuare?**<br/>\n"

##############################################################################
# Advanced Settings
##############################################################################
msgid "Advanced Configuration Settings"
msgstr "Impostazioni Configurazione Avanzata"

msgid "WARNING!\n"
msgstr "ATTENZIONE!\n"

msgid "This is advanced configuration.\n"
msgstr "Questa è una configurazione avanzata.\n"

msgid "Unless you know what you are doing,\n"
msgstr "A meno che tu non sappia cosa stai facendo,\n"

msgid "you should not be enabling it.\n"
msgstr "non dovresti abilitarla.\n"

msgid "YOU AND YOU ALONE ARE RESPONSIBLE FOR ANYTHING THAT HAPPENS TO YOUR DEVICE.\n"
msgstr "TU E SOLTANTO TU SEI RESPONSABILE PER QUALSIASI COSA ACCADA AL TUO DISPOSITIVO.\n"

msgid "THIS TOOL IS CODED WITH THE EXPRESS ASSUMPTION THAT YOU ARE FAMILIAR WITH\n"
msgstr "QUESTO TOOL È CODIFICATO CON L'ASSUNZIONE ESPLICITA CHE TU SIA FAMILIARE CON\n"

msgid "ADB, MAGISK, ANDROID, AND ROOT.\n"
msgstr "ADB, MAGISK, ANDROID E ROOT.\n"

msgid "IT IS YOUR RESPONSIBILITY TO ENSURE THAT YOU KNOW WHAT YOU ARE DOING.\n"
msgstr "È TUA RESPONSABILITÀ ASSICURARTI DI SAPERE COSA STAI FACENDO.\n"

msgid "Enable Advanced Options"
msgstr "Abilita Opzioni Avanzate"

msgid "Expert mode"
msgstr "Modalità Esperto"

msgid "Magisk Package Name"
msgstr "Nome Pacchetto Magisk"

msgid "If you have hidden Magisk,\nset this to the hidden package name."
msgstr "Se hai nascosto Magisk,\nimposta questo con il nome del pacchetto nascosto."

msgid "Resets package name to default: %s"
msgstr "Resetta nome pacchetto al default: %s"

msgid "Linux File Explorer:"
msgstr "Esplora File Linux:"

msgid "Set full path to File Explorer.\nDefault: Nautilus"
msgstr "Imposta percorso completo per Esplora File.\nDefault: Nautilus"

msgid "Linux Shell:"
msgstr "Shell Linux:"

msgid "Set full path to Linux Shell.\nDefault: gnome-terminal"
msgstr "Imposta percorso completo per Shell Linux.\nDefault: gnome-terminal"

msgid "Offer Patch Methods"
msgstr "Offri Metodi Patch"

msgid "When patching the choice of method is presented."
msgstr "Durante il patching viene presentata la scelta del metodo."

msgid "Patching Recovery Partition"
msgstr "Patching Partizione Recovery"

msgid ""
"Enabling this will show an option to patch a recovery partition.\n"
"This should be kept disabled unless you have an old device.\n"
"(most A-only devices launched with Android 9, legacy SAR)"
msgstr ""
"Abilitare questo mostrerà un'opzione per patchare una partizione recovery.\n"
"Questo dovrebbe rimanere disabilitato a meno che tu non abbia un vecchio dispositivo.\n"
"(maggior parte dei dispositivi A-only lanciati con Android 9, legacy SAR)"

msgid "Use Busybox Shell"
msgstr "Usa Shell Busybox"

msgid "When creating a patch, if this is checked, busybox ash will be used as shell."
msgstr "Durante la creazione di una patch, se selezionato, busybox ash verrà usata come shell."

msgid "System has low memory"
msgstr "Il sistema ha poca memoria"

msgid "Use this option to sacrifice speed in favor of memory."
msgstr "Usa questa opzione per sacrificare la velocità a favore della memoria."

msgid "Extra img extraction"
msgstr "Estrazione img extra"

msgid "When checked and available in payload.bin\nAlso extract vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"
msgstr "Quando selezionato e disponibile in payload.bin\nEstrae anche vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"

msgid "Show notifications"
msgstr "Mostra notifiche"

msgid "When checked PixelFlasher will display system toast notifications."
msgstr "Quando selezionato PixelFlasher mostrerà notifiche toast di sistema."

msgid "Always create boot.tar"
msgstr "Crea sempre boot.tar"

msgid "When checked, PixelFlasher always creates boot.tar of the patched boot file.\nIf unchecked, only for Samsung firmware boot.tar will be created."
msgstr "Quando selezionato, PixelFlasher crea sempre boot.tar del file boot patchato.\nSe deselezionato, boot.tar sarà creato solo per firmware Samsung."

msgid "Check for updates"
msgstr "Controlla aggiornamenti"

msgid "Checks for available updates on startup"
msgstr "Controlla aggiornamenti disponibili all'avvio"

msgid "Check for Minimum Disk (5Gb)"
msgstr "Controlla Disco Minimo (5Gb)"

msgid "Enforces minimum disk space of 5 Gb to allow flashing.\nThis avoids storage related issues."
msgstr "Impone spazio disco minimo di 5 Gb per consentire il flash.\nQuesto evita problemi relativi allo spazio di archiviazione."

msgid "Check for bootloader unlocked"
msgstr "Controlla bootloader sbloccato"

msgid "Checks to make sure bootloader is unlocked before flashing."
msgstr "Controlla per assicurarsi che il bootloader sia sbloccato prima del flash."

msgid "Check for firmware hash validity"
msgstr "Controlla validità hash firmware"

msgid "Checks for sha256 portion to be in the image filename to detect Pixel compatible image."
msgstr "Controlla che la porzione sha256 sia nel nome file immagine per rilevare immagine compatibile Pixel."

msgid "Keep temporary support files"
msgstr "Mantieni file di supporto temporanei"

msgid "It keeps the temporary support files.\nUseful for inspecting what data is included in support.zip."
msgstr "Mantiene i file di supporto temporanei.\nUtile per ispezionare quali dati sono inclusi in support.zip."

msgid "Check Magisk modules for updates"
msgstr "Controlla aggiornamenti moduli Magisk"

msgid ""
"It checks if the module has updates.\n"
"Disable this if you don't want to check for updates or\n"
" if some module update server has issues and delays the process."
msgstr ""
"Controlla se il modulo ha aggiornamenti.\n"
"Disabilita se non vuoi controllare gli aggiornamenti o\n"
"se qualche server di aggiornamento modulo ha problemi e ritarda il processo."

msgid "Show custom ROM options"
msgstr "Mostra opzioni custom ROM"

msgid "Make sure you check if your ROM is supported."
msgstr "Assicurati di controllare se la tua ROM è supportata."

msgid "Sanitize (Redact) support files"
msgstr "Sanifica (Oscura) file di supporto"

msgid ""
"The support files are always encrypted.\n"
"This option redacts sensitive information from the support files.\n"
"But impedes support and is not recommended."
msgstr ""
"I file di supporto sono sempre crittografati.\n"
"Questa opzione oscura le informazioni sensibili dai file di supporto.\n"
"Ma ostacola il supporto e non è raccomandata."

msgid "Force codepage to"
msgstr "Forza codepage a"

msgid "Uses specified code page instead of system code page"
msgstr "Usa la code page specificata invece di quella di sistema"

msgid "Delete bundled libs"
msgstr "Elimina librerie integrate"

msgid "The listed libraries would be deleted from the PF bundle to allow system defined ones to be used."
msgstr "Le librerie elencate saranno eliminate dal bundle PF per permettere l'uso di quelle di sistema."

msgid "Example: libreadline.so.8, libgdk*"
msgstr "Esempio: libreadline.so.8, libgdk*"

msgid "Override KMI"
msgstr "Override KMI"

msgid ""
"This will override the Kernel Module Interface (KMI) to the specified value.\n"
"This is useful for devices with custom kernels.\n"
"The value will be passed to KernelSU as the KMI value."
msgstr ""
"Questo sovrascriverà l'Interfaccia Modulo Kernel (KMI) al valore specificato.\n"
"Utile per dispositivi con kernel custom.\n"
"Il valore sarà passato a KernelSU come valore KMI."

msgid "Example: 5.15.131-android14"
msgstr "Esempio: 5.15.131-android14"

msgid "Use Custom Fontface"
msgstr "Usa Font Personalizzato"

msgid "Use custom font for monospace fonts\nMight require PixelFlasher restart to properly apply to the Console window."
msgstr "Usa font personalizzato per font monospazio\nPotrebbe richiedere il riavvio di PixelFlasher per applicarsi correttamente alla finestra Console."

msgid "Sample "
msgstr "Esempio "

msgid "Select font size"
msgstr "Seleziona dimensione font"

msgid "scrcpy Path"
msgstr "Percorso scrcpy"

msgid "Download scrcpy"
msgstr "Scarica scrcpy"

msgid "Scrcpy executable (*.exe;*)|*.exe;*"
msgstr "Eseguibile Scrcpy (*.exe;*)|*.exe;*"

msgid "Select scrcpy executable"
msgstr "Seleziona eseguibile scrcpy"

msgid "Flags / Arguments (Example: --video-bit-rate 2M --max-fps=30 --max-size 1024)"
msgstr "Flag / Argomenti (Esempio: --video-bit-rate 2M --max-fps=30 --max-size 1024)"

msgid "Scrcpy settings"
msgstr "Impostazioni Scrcpy"

##############################################################################
# Message dialogs and toasts (modules.py)
##############################################################################
msgid "Module update URL has issues, inform the module author: %s\nDo you want to skip checking updates for this module?"
msgstr "L'URL di aggiornamento del modulo ha problemi, informa l'autore del modulo: %s\nVuoi saltare il controllo aggiornamenti per questo modulo?"

msgid "You have an old or problematic Android platform Tools version %s \n"
msgstr "Hai una versione Android platform Tools vecchia o problematica %s \n"

msgid "You are strongly advised to update before continuing.\n"
msgstr "Ti consigliamo vivamente di aggiornare prima di continuare.\n"

msgid "Are you sure you want to continue?"
msgstr "Sei sicuro di voler continuare?"

msgid "Bad Android Platform Tools"
msgstr "Android Platform Tools Errati"

msgid "Android SDK Version:    %s\n"
msgstr "Versione SDK Android:    %s\n"

msgid "Device:                 %s %s %s\n"
msgstr "Dispositivo:                 %s %s %s\n"

msgid "Factory Image:          %s\n"
msgstr "Factory Image:          %s\n"

msgid "Custom Rom:             %s\n"
msgstr "Custom Rom:             %s\n"

msgid "Custom Rom File:        %s\n"
msgstr "File Custom Rom:        %s\n"

msgid "\nBoot image:             %s / %s \n"
msgstr "\nImmagine Boot:             %s / %s \n"

msgid "                        From: %s\n"
msgstr "                        Da: %s\n"

msgid "                        Patched with %s on %s method:        %s\n"
msgstr "                        Patchato con %s su %s metodo:        %s\n"

msgid "                        Patched with %s on %s\n"
msgstr "                        Patchato con %s su %s\n"

msgid "\nFlash Mode:             %s\n"
msgstr "\nModalità Flash:             %s\n"

msgid "SHA256 of %s%s matches the segment in the filename."
msgstr "SHA256 di %s%s corrisponde al segmento nel nome del file."

msgid "⚠️ Firmware SHA256 Mismatch"
msgstr "⚠️ Discrepanza SHA256 Firmware"

msgid "WARNING! SHA256 of %s%s does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "ATTENZIONE! SHA256 di %s%s non corrisponde ai segmenti nel nome del file.\nPer favore controlla due volte per assicurarti che il checksum sia valido."

msgid "Process action"
msgstr "Azione elaborazione"

msgid "❌ Could not extract %s"
msgstr "❌ Impossibile estrarre %s"

msgid "Possibly extracted firmware."
msgstr "Firmware possibilmente estratto."

msgid "WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n"
msgstr "ATTENZIONE: Sembra che tu abbia estratto il file firmware.\ne selezionato lo zip immagine da esso.\n\n"

msgid "You should not extract the file, please select the downloaded firmware file instead\n\n"
msgstr "Non dovresti estrarre il file, per favore seleziona invece il file firmware scaricato\n\n"

msgid "If this is not the case, and you want to continue with this selection\n"
msgstr "Se non è questo il caso, e vuoi continuare con questa selezione\n"

msgid "❌ Could not unpack %s."
msgstr "❌ Impossibile decomprimere %s."

msgid "❌ Could not extract %s."
msgstr "❌ Impossibile estrarre %s."

msgid "❌ Could not find %s."
msgstr "❌ Impossibile trovare %s."

msgid "⚠️ Detected unsupported firmware."
msgstr "⚠️ Rilevato firmware non supportato."

msgid "❌ Could not extract payload.bin."
msgstr "❌ Impossibile estrarre payload.bin."

msgid "❌ The selected firmware is not valid."
msgstr "❌ Il firmware selezionato non è valido."

msgid "⚠️ Nothing to extract from %s"
msgstr "⚠️ Niente da estrarre da %s"

msgid "✅ Process %s time: %s seconds"
msgstr "✅ Tempo elaborazione %s: %s secondi"

msgid "WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?"
msgstr "ATTENZIONE: Il boot.img target non è un downgrade.\nSei sicuro di voler continuare?"

msgid "Confirm"
msgstr "Conferma"

msgid "Display is Locked!"
msgstr "Il Display è Bloccato!"

msgid "ERROR: Your phone display is Locked.\n\n"
msgstr "ERRORE: Il display del tuo telefono è Bloccato.\n\n"

msgid "Make sure you unlock your display\n"
msgstr "Assicurati di sbloccare il display\n"

msgid "And set the display timeout to at least 1 minute.\n\n"
msgstr "E imposta il timeout del display ad almeno 1 minuto.\n\n"

msgid "After doing so, Click OK to accept and continue.\n"
msgstr "Dopo averlo fatto, Clicca OK per accettare e continuare.\n"

msgid "Manual Patching"
msgstr "Patching Manuale"

msgid "Done creating the patch, continue"
msgstr "Creazione patch completata, continua"

msgid "Magisk Manager is not detected."
msgstr "Magisk Manager non rilevato."

msgid "WARNING: Magisk Manager [%s] is not found on the phone\n\n"
msgstr "ATTENZIONE: Magisk Manager [%s] non trovato sul telefono\n\n"

msgid "This could be either because it is hidden, or it is not installed (most likely not installed)\n\n"
msgstr "Questo potrebbe essere perché è nascosto, o non è installato (molto probabilmente non installato)\n\n"

msgid "If it is installed and hidden, then you should abort and then unhide it.\n"
msgstr "Se è installato e nascosto, dovresti interrompere e poi renderlo visibile.\n"

msgid "If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n"
msgstr "Se Magisk non è installato, PixelFlasher può installarlo per te e usarlo per il patching.\n\n"

msgid "WARNING: Do not install Magisk again if it is currently hidden.\n"
msgstr "ATTENZIONE: Non installare nuovamente Magisk se è attualmente nascosto.\n"

msgid "Do you want PixelFlasher to download and install Magisk?\n"
msgstr "Vuoi che PixelFlasher scarichi e installi Magisk?\n"

msgid "You will be given a choice of Magisk Version to install.\n\n"
msgstr "Ti verrà data una scelta della Versione Magisk da installare.\n\n"

msgid "Click OK to continue with Magisk installation.\n"
msgstr "Clicca OK per continuare con l'installazione di Magisk.\n"

msgid "Kernel KMI Override"
msgstr "Override Kernel KMI"

msgid "Kernel KMI Override: %s\n\n"
msgstr "Override Kernel KMI: %s\n\n"

msgid "You have set a custom kernel KMI override.\n"
msgstr "Hai impostato un override KMI del kernel personalizzato.\n"

msgid "Are you sure you want to proceed with this override?\n"
msgstr "Sei sicuro di voler procedere con questo override?\n"

msgid "Click OK to proceed with the override.\n"
msgstr "Clicca OK per procedere con l'override.\n"

msgid "Boot Model Mismatch"
msgstr "Discrepanza Modello Boot"

msgid "APatch Manual Patching"
msgstr "Patching Manuale APatch"

msgid "APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n"
msgstr "Patching Manuale APatch richiede CONFIG_KALLSYMS=y nella config del kernel.\n"

msgid "APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n"
msgstr "Patching Manuale APatch supporta solo versioni kernel 3.18 - 6.1\n\n"

msgid "Do you want to continue regardless of not meeting the pre-requisites?\n\n"
msgstr "Vuoi continuare nonostante il mancato rispetto dei pre-requisiti?\n\n"

msgid "Click Yes to continue with APatch Manual Patching\n"
msgstr "Clicca Sì per continuare con Patching Manuale APatch\n"

msgid "or Hit No to abort."
msgstr "o Premi No per interrompere."

msgid "Download Latest KernelPatch Tools"
msgstr "Scarica Ultimi KernelPatch Tools"

msgid "Latest KernelPatch Tools Pre-release Version: %s\n"
msgstr "Ultima Versione Pre-release KernelPatch Tools: %s\n"

msgid "Latest KernelPatch Tools Release Version: %s\n\n"
msgstr "Ultima Versione Release KernelPatch Tools: %s\n\n"

msgid "Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n"
msgstr "Vuoi scaricare gli ultimi kptools-android e kpimg-android che includono versioni pre-release?\n\n"

msgid "Click Yes to download the latest pre-release versions: %s\n"
msgstr "Clicca Sì per scaricare le ultime versioni pre-release: %s\n"

msgid "Click No to download the latest Release versions: %s\n"
msgstr "Clicca No per scaricare le ultime versioni Release: %s\n"

msgid "%s Boot"
msgstr "%s Boot"

msgid "ERROR: Your phone model is: %s\n\n"
msgstr "ERRORE: Il modello del tuo telefono è: %s\n\n"

msgid "The selected Boot is for: %s\n\n"
msgstr "Il Boot selezionato è per: %s\n\n"

msgid "Unless you know what you are doing, if you continue flashing\n"
msgstr "A meno che tu non sappia cosa stai facendo, se continui il flash\n"

msgid "you risk bricking your device, proceed only if you are absolutely\n"
msgstr "rischi di brickare il tuo dispositivo, procedi solo se sei assolutamente\n"

msgid "certain that this is what you want, you have been warned.\n\n"
msgstr "certo che questo è ciò che vuoi, sei stato avvertito.\n\n"

msgid "Flash action"
msgstr "Azione Flash"

msgid "❌ Device is not detected."
msgstr "❌ Dispositivo non rilevato."

msgid "❌ Bootloader is locked, cannot flash."
msgstr "❌ Bootloader bloccato, impossibile flashare."

msgid "Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"
msgstr "Il tuo bootloader è bloccato o non hai concesso i permessi su al processo shell.\nVuoi procedere comunque?"

msgid "❌ Android Platform Tools is not set."
msgstr "❌ Android Platform Tools non impostato."

msgid "❌ Valid device is not selected."
msgstr "❌ Dispositivo valido non selezionato."

msgid "❌ boot is not selected."
msgstr "❌ boot non selezionato."

msgid "You can only sideload OTA that is equal or higher than the currently installed version.\n"
msgstr "Puoi fare sideload solo di OTA che è uguale o superiore alla versione attualmente installata.\n"

msgid "Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n"
msgstr "Alternativamente, puoi flashare l'immagine firmware completa (con cancellazione dati) per fare downgrade o patchare l'immagine boot corrente per permettere un downgrade senza cancellazione.\n"

msgid "See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n"
msgstr "Vedi voce Menu: Strumenti Dev | AVB Prepara Patch Downgrade per ulteriori dettagli.\n\n"

msgid "If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n"
msgstr "Se vuoi ancora procedere, Clicca SÌ per accettare e continuare. o NO per Interrompere.\n"

msgid "You have selected to WIPE data\nAre you sure want to continue?"
msgstr "Hai selezionato di CANCELLARE i dati\nSei sicuro di voler continuare?"

msgid "Wipe Data"
msgstr "Cancella Dati"

msgid "✅ Wipe Data is accepted."
msgstr "✅ Cancellazione Dati accettata."

msgid "You have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?"
msgstr "Hai selezionato l'opzione flash: Wipe\nQuesto cancellerà i tuoi dati\nSei sicuro di voler continuare?"

msgid "Flash option: Wipe"
msgstr "Opzione Flash: Wipe"

msgid "✅ Wipe is accepted."
msgstr "✅ Wipe accettato."

msgid "You have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?"
msgstr "Hai selezionato l'opzione flash: Forza\nQuesto cancellerà i tuoi dati\nSei sicuro di voler continuare?"

msgid "Flash option: Force"
msgstr "Opzione Flash: Forza"

msgid "✅ Force flag is accepted."
msgstr "✅ Flag Forza accettato."

msgid "❌ Not enough disk space."
msgstr "❌ Spazio su disco insufficiente."

msgid "❌ Full OTA or factory image must be selected."
msgstr "❌ Deve essere selezionata Full OTA o factory image."

msgid "Tensor device not on Android 13 or higher"
msgstr "Dispositivo Tensor non su Android 13 o superiore"

msgid "WARNING: Your phone OS version is lower than Android 13.\n\n"
msgstr "ATTENZIONE: La versione OS del tuo telefono è inferiore ad Android 13.\n\n"

msgid "If you are upgrading to Android 13 or newer,\n"
msgstr "Se stai aggiornando ad Android 13 o più recente,\n"

msgid "make sure you at least flash the bootloader to both slots.\n"
msgstr "assicurati almeno di flashare il bootloader su entrambi gli slot.\n"

msgid "The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n"
msgstr "L'aggiornamento Android 13 per Pixel 6, Pixel 6 Pro e Pixel 6a contiene\n"

msgid "a bootloader update that increments the anti-roll back version for the bootloader.\n"
msgstr "un aggiornamento bootloader che incrementa la versione anti-roll back per il bootloader.\n"

msgid "This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n"
msgstr "Questo impedisce al dispositivo di tornare a versioni precedenti vulnerabili del bootloader.\n"

msgid "After flashing an Android 13 build on these devices\n"
msgstr "Dopo aver flashato una build Android 13 su questi dispositivi\n"

msgid "you will not be able to flash and boot older Android 12 builds.\n\n"
msgstr "non sarai in grado di flashare e avviare build Android 12 più vecchie.\n\n"

msgid "Selecting the option 'Flash to both slots'\n"
msgstr "Selezionando l'opzione 'Flash su entrambi gli slot'\n"

msgid "Will take care of that.\n\n"
msgstr "Si occuperà di questo.\n\n"

msgid "Click OK to continue as is.\n"
msgstr "Clicca OK per continuare così com'è.\n"

msgid "or Hit CANCEL to abort and change options."
msgstr "o Premi ANNULLA per interrompere e cambiare opzioni."

msgid "✅ Anti rollback warning acknowledged and bypassed."
msgstr "✅ Avviso anti rollback riconosciuto e bypassato."

msgid "❌ downgrade_boot.img is not found."
msgstr "❌ downgrade_boot.img non trovato."

msgid "❌ Unable to replace boot.img in image.zip."
msgstr "❌ Impossibile sostituire boot.img in image.zip."

msgid "⚠️ Live booting Pixel 7 or newer devices is not supported."
msgstr "⚠️ Live booting dispositivi Pixel 7 o più recenti non supportato."

msgid "❌ Image file is not selected."
msgstr "❌ File immagine non selezionato."

msgid "❌ Boot file is not found."
msgstr "❌ File Boot non trovato."

msgid "❌ ROM file is not found."
msgstr "❌ File ROM non trovato."

msgid "Device / Firmware Mismatch"
msgstr "Discrepanza Dispositivo / Firmware"

msgid "The selected firmware is for: %s\n\n"
msgstr "Il firmware selezionato è per: %s\n\n"

msgid "✅ Device / Firmware mismatch acknowledged."
msgstr "✅ Discrepanza Dispositivo / Firmware riconosciuta."

msgid "❌ Encountered an error while rebooting to bootloader."
msgstr "❌ Riscontrato un errore durante il riavvio in bootloader."

msgid "❌ Encountered an error while rebooting to sideload."
msgstr "❌ Riscontrato un errore durante il riavvio in sideload."

msgid "❌ Encountered an error while rebooting to fastbootd."
msgstr "❌ Riscontrato un errore durante il riavvio in fastbootd."

msgid "❌ Encountered an error while running the flash script."
msgstr "❌ Riscontrato un errore durante l'esecuzione dello script di flash."

msgid "❌ Encountered an error while flashing the patch."
msgstr "❌ Riscontrato un errore durante il flash della patch."

msgid "❌ vbmeta flashing did not return the expected result."
msgstr "❌ Il flash vbmeta non ha restituito il risultato atteso."

msgid "❌ It appears that OTA flashing did not properly switch slots."
msgstr "❌ Sembra che il flash OTA non abbia cambiato correttamente gli slot."

msgid "⚠️ Device is not found after rebooting to bootloader."
msgstr "⚠️ Dispositivo non trovato dopo il riavvio in bootloader."

msgid "✅ Flashing elapsed time: %s seconds"
msgstr "✅ Tempo trascorso Flash: %s secondi"

msgid "You have selected  WIPE option.\nAdb debugging will be reset and disabled\nHence patch or vbmeta flashing will be skipped."
msgstr "Hai selezionato l'opzione WIPE.\nIl debug Adb sarà resettato e disabilitato\nQuindi il flash di patch o vbmeta sarà saltato."

msgid "%s %s \n"
msgstr "%s %s \n"

msgid "Device is not detected."
msgstr "Dispositivo non rilevato."

msgid "Done rebooting to bootloader, continue"
msgstr "Riavvio in bootloader completato, continua"

msgid "Done rebooting to system, continue"
msgstr "Riavvio al sistema completato, continua"

msgid "## Is your device waiting for interaction?\n"
msgstr "## Il tuo dispositivo attende interazione?\n"

msgid "_If it is not, please hit the cancel button._\n"
msgstr "_Se non lo è, per favore premi il pulsante annulla._\n"

msgid "If your device is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "Se il tuo dispositivo sta aspettando un'interazione utente che non può essere invocata programmaticamente.\n"

msgid "- Using volume keys, scroll up and down and select **Reboot %s**\n"
msgstr "- Usando i tasti volume, scorri su e giù e seleziona **Riavvia %s**\n"

msgid "- Press the power button to apply.\n"
msgstr "- Premi il pulsante accensione per applicare.\n"

msgid "When done, the device should reboot to %s <br/>\n"
msgstr "Quando fatto, il dispositivo dovrebbe riavviarsi in %s <br/>\n"

msgid "Wait for the device to fully boot to %s <br/>\n"
msgstr "Attendi che il dispositivo si avvii completamente in %s <br/>\n"

msgid "Click on **Done rebooting to %s, continue** button <br/>\n"
msgstr "Clicca sul pulsante **Riavvio a %s completato, continua** <br/>\n"

msgid "or hit the **Cancel** button to abort.\n"
msgstr "o premi il pulsante **Annulla** per interrompere.\n"

msgid "Waiting for user interaction"
msgstr "In attesa di interazione utente"

msgid "## Your watch should now be in Android Recovery\n"
msgstr "## Il tuo orologio dovrebbe ora essere in Android Recovery\n"

msgid "The watch is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "L'orologio sta aspettando un'interazione utente che non può essere invocata programmaticamente.\n"

msgid "- Using touch, scroll and select **Reboot to bootloader**\n"
msgstr "- Usando il touch, scorri e seleziona **Reboot to bootloader**\n"

msgid "- Press the side button to apply.\n"
msgstr "- Premi il pulsante laterale per applicare.\n"

msgid "When done, the watch should reboot to bootloader mode <br/>\n"
msgstr "Quando fatto, l'orologio dovrebbe riavviarsi in modalità bootloader <br/>\n"

msgid "Wait for the watch to indicate that it is in bootloader mode <br/>\n"
msgstr "Attendi che l'orologio indichi che è in modalità bootloader <br/>\n"

msgid "Click on **Done rebooting to bootloader, continue** button <br/>\n"
msgstr "Clicca sul pulsante **Riavvio in bootloader completato, continua** <br/>\n"

msgid "- Using touch, scroll and select **Reboot to system now**\n"
msgstr "- Usando il touch, scorri e seleziona **Reboot to system now**\n"

msgid "When applied, the watch should reboot to system. <br/>\n"
msgstr "Quando applicato, l'orologio dovrebbe riavviarsi al sistema. <br/>\n"

msgid "Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n"
msgstr "Clicca sul pulsante **Riavvio al sistema completato, continua** quando il SO dell'orologio si carica completamente.\n"

##############################################################################
# Pif Manager
##############################################################################
msgid "Active Pif"
msgstr "Pif Attivo"

msgid "Loaded Pif (from Device)"
msgstr "Pif Caricato (dal Dispositivo)"

msgid "Active pif is not modified."
msgstr "Pif Attivo non è modificato."

msgid "Save Active pif content to a json file on disk."
msgstr "Salva contenuto Pif Attivo in un file json su disco."

msgid "Pif Module"
msgstr "Modulo Pif"

msgid "Active pif is not saved in favorites."
msgstr "Pif Attivo non è salvato nei preferiti."

msgid "Select a folder to import pif json files."
msgstr "Seleziona una cartella per importare file json pif."

msgid "Output"
msgstr "Output"

msgid "Console Output:\nIt could be the json output of processed prop\nor it could be the Play Integrity Check result.\n\nThis is not what currently is on the device."
msgstr "Output Console:\nPotrebbe essere l'output json di prop elaborati\no potrebbe essere il risultato del Controllo Play Integrity.\n\nQuesto non è ciò che si trova attualmente sul dispositivo."

msgid "Smart Paste:\nSets First API to the set value if it is missing or forced.\nReprocesses the output window content to adapt to current module requirements.\nPastes to Active pif."
msgstr "Incolla Intelligente:\nImposta la First API al valore impostato se mancante o forzato.\nRielabora il contenuto della finestra di output per adattarlo ai requisiti del modulo corrente.\nIncolla in Pif Attivo."

msgid "Paste the console window content to Active pif."
msgstr "Incolla il contenuto della finestra console in Pif Attivo."

msgid "Paste the Active pif to console window."
msgstr "Incolla il Pif Attivo nella finestra console."

msgid "Reprocess current Active Pif window json.\nUseful if you changed module version which might require additional / different fields."
msgstr "Rielabora json finestra Pif Attivo corrente.\nUtile se hai cambiato versione del modulo che potrebbe richiedere campi aggiuntivi / diversi."

msgid "Reprocess one or many json file(s)\nUseful if you changed module version which might require additional / different fields.\nIf a single file is selected, the new json will output to console output\nHowever if multiple files are selected, the selected file will be updated in place."
msgstr "Rielabora uno o più file json\nUtile se hai cambiato versione del modulo che potrebbe richiedere campi aggiuntivi / diversi.\nSe è selezionato un singolo file, il nuovo json uscirà nell'output console\nTuttavia se sono selezionati più file, il file selezionato sarà aggiornato sul posto."

msgid "Process one or many json file(s) to generate the FrameworkPatcher formatted code excerpts.\n"
msgstr "Elabora uno o più file json per generare gli estratti di codice formattati FrameworkPatcher.\n"

msgid "Add missing Keys from device"
msgstr "Aggiungi Chiavi mancanti dal dispositivo"

msgid "When Processing or Reprocessing, add missing fields from device."
msgstr "Durante l'Elaborazione o Rielaborazione, aggiungi campi mancanti dal dispositivo."

msgid "Force First API to:"
msgstr "Forza First API a:"

msgid "Forces First API value(s) to"
msgstr "Forza valore/i First API a"

msgid "Sort Keys"
msgstr "Ordina Chiavi"

msgid "Sorts json keys"
msgstr "Ordina chiavi json"

msgid "Keep All keys"
msgstr "Mantieni Tutte le chiavi"

msgid "Does not remove non standard / unrecognized keys"
msgstr "Non rimuove chiavi non standard / non riconosciute"

msgid "Spoof Build"
msgstr "Spoof Build"

msgid "Spoof Props"
msgstr "Spoof Props"

msgid "Spoof Provider"
msgstr "Spoof Provider"

msgid "Spoof Signature"
msgstr "Spoof Signature"

msgid "Close"
msgstr "Chiudi"

msgid "Create print"
msgstr "Crea impronta"

msgid "Create pif.json / spoof_build_vars"
msgstr "Crea pif.json / spoof_build_vars"

msgid "Push print, no validation"
msgstr "Invia impronta, nessuna validazione"

msgid "Pushes the print as is without performing any validation.\nThis is useful to retain comments."
msgstr "Invia l'impronta così com'è senza eseguire alcuna validazione.\nUtile per mantenere i commenti."

msgid "Reload print"
msgstr "Ricarica impronta"

msgid "Reload pif.json / spoof_build_vars from device."
msgstr "Ricarica pif.json / spoof_build_vars dal dispositivo."

msgid "Cleanup DG"
msgstr "Pulizia DG"

msgid "Cleanup Droidguard Cache"
msgstr "Pulizia Cache Droidguard"

msgid "Push keybox.xml"
msgstr "Invia keybox.xml"

msgid "Push a valid keybox.xml to device."
msgstr "Invia un keybox.xml valido al dispositivo."

msgid "Edit TS Target"
msgstr "Modifica TS Target"

msgid "Edit Tricky Store target.txt file."
msgstr "Modifica file target.txt Tricky Store."

msgid "Edit TS SP"
msgstr "Modifica TS SP"

msgid "Edit Tricky Store security_patch.txt file."
msgstr "Modifica file security_patch.txt Tricky Store."

msgid "Process build.prop(s)"
msgstr "Elabora build.prop(s)"

msgid "Process build.prop to extract a compatible print."
msgstr "Elabora build.prop per estrarre un'impronta compatibile."

msgid "Process bulk props"
msgstr "Elabora props in massa"

msgid "Process a folder containing .prop files and convert then to .json files."
msgstr "Elabora una cartella contenente file .prop e li converte in file .json."

msgid "Process Image"
msgstr "Elabora Immagine"

msgid "Process an image and get a print from it."
msgstr "Elabora un'immagine e ottieni un'impronta da essa."

msgid "Auto Update print"
msgstr "Aggiorna impronta Auto"

msgid "After Processing build.props, the print is automatically pushed to the device and the GMS process is killed."
msgstr "Dopo l'Elaborazione build.props, l'impronta viene inviata automaticamente al dispositivo e il processo GMS viene terminato."

msgid "Auto Check Play Integrity"
msgstr "Controllo Auto Play Integrity"

msgid "After saving (pushing) print, automatically run Play Integrity Check."
msgstr "Dopo il salvataggio (invio) impronta, esegui automaticamente Controllo Play Integrity."

msgid "Disable UIAutomator"
msgstr "Disabilita UIAutomator"

msgid "Disables UIAutomator\nThis is useful for devices with buggy UIAutomator.\nNOTE: Create the coords.json file manually to make use of automated testing."
msgstr "Disabilita UIAutomator\nUtile per dispositivi con UIAutomator buggato.\nNOTA: Crea manualmente il file coords.json per utilizzare il testing automatizzato."

msgid "Play Integrity Check"
msgstr "Controllo Play Integrity"

msgid "Play Integrity API Checker\nNote: Need to install app from Play store."
msgstr "Checker API Play Integrity\nNota: Necessario installare app dal Play store."

msgid "Latest"
msgstr "Ultimo"

msgid "Custom"
msgstr "Personalizzato"

msgid "Select 'Latest' to get the latest Pixel beta pif (Includes Developer Preview).\nSelect 'Custom' to set a custom Android version code."
msgstr "Seleziona 'Ultimo' per ottenere l'ultimo pif Pixel beta (Include Developer Preview).\nSeleziona 'Personalizzato' per impostare un codice versione Android personalizzato."

msgid "Set a valid Android version code."
msgstr "Imposta un codice versione Android valido."

msgid "Get Pixel Beta Pif"
msgstr "Ottieni Pixel Beta Pif"

msgid "Get the latest Pixel beta pif."
msgstr "Ottieni l'ultimo Pixel beta pif."

msgid "Get Xiaomi Pif"
msgstr "Ottieni Xiaomi Pif"

msgid "Get Xiaomi.eu pif\nEasy to start but is not recommended as it gets banned quickly.\nRecommended to find your own."
msgstr "Ottieni Xiaomi.eu pif\nFacile per iniziare ma non raccomandato poiché viene bannato velocemente.\nRaccomandato trovarne uno proprio."

msgid "Get TheFreeman193 Random Pif"
msgstr "Ottieni Pif Casuale TheFreeman193"

msgid "Get a random pif from TheFreeman193 repository.\nNote: The pif might or might not work."
msgstr "Ottieni un pif casuale dalla repository TheFreeman193.\nNota: Il pif potrebbe funzionare o meno."

msgid "No Device is selected.\nPif Manager features are set to limited mode."
msgstr "Nessun Dispositivo selezionato.\nFunzionalità Gestore Pif impostate in modalità limitata."

msgid "Device is not rooted or SU permissions to adb shell is not granted.\nPif Manager features are set to limited mode."
msgstr "Dispositivo non rootato o permessi SU a shell adb non concessi.\nFunzionalità Gestore Pif impostate in modalità limitata."

msgid "Update print"
msgstr "Aggiorna impronta"

msgid "Update pif.json / spoof_build_vars."
msgstr "Aggiorna pif.json / spoof_build_vars."

msgid "Create pif.json / spoof_build_vars."
msgstr "Crea pif.json / spoof_build_vars."

msgid "Getting Pixel beta print ...\nPlease be patient this could take some time ..."
msgstr "Ottenimento impronta Pixel beta ...\nSi prega di pazientare, potrebbe richiedere del tempo ..."

msgid "Failed to get beta print."
msgstr "Impossibile ottenere impronta beta."

msgid "Active pif not in sync"
msgstr "Pif Attivo non sincronizzato"

msgid "⚠️ WARNING! Device pif is not in sync with Active Pif contents.\nThe result will not be reflective of the Active pif you're viewing."
msgstr "⚠️ ATTENZIONE! Il pif del dispositivo non è sincronizzato con i contenuti Pif Attivo.\nIl risultato non rifletterà il Pif Attivo che stai visualizzando."

msgid "Choose property files to open"
msgstr "Scegli file proprietà da aprire"

msgid "Select a Device Image"
msgstr "Seleziona un'Immagine Dispositivo"

msgid "Processing %s ...\nPlease be patient this could take some time ..."
msgstr "Elaborazione %s ...\nSi prega di pazientare, potrebbe richiedere del tempo ..."

msgid "Image format not supported"
msgstr "Formato immagine non supportato"

msgid "Select folder to bulk process props files"
msgstr "Seleziona cartella per elaborare file props in massa"

msgid "The contents is different than what is currently on the device.\nUpdate the print before testing."
msgstr "Il contenuto è diverso da quello attualmente sul dispositivo.\nAggiorna l'impronta prima di testare."

msgid "Active pif is saved in favorites."
msgstr "Pif Attivo salvato nei preferiti."

msgid "Select keybox to push"
msgstr "Seleziona keybox da inviare"

msgid "Choose one or multiple json files to reprocess"
msgstr "Scegli uno o più file json da rielaborare"

msgid "Save FP file"
msgstr "Salva file FP"

msgid "Enter a label:"
msgstr "Inserisci un'etichetta:"

msgid "Save Pif to Favorites"
msgstr "Salva Pif nei Preferiti"

msgid "Select folder to Import Pifs"
msgstr "Seleziona cartella per Importare Pif"

##############################################################################
# Magisk
##############################################################################
msgid "❌ ERROR: You must first select a valid device."
msgstr "❌ ERRORE: Devi prima selezionare un dispositivo valido."

msgid "Manage Magisk"
msgstr "Gestisci Magisk"

msgid "When you press the OK button, the Modules with checkbox selected will be enabled and the rest will be disabled."
msgstr "Quando premi il pulsante OK, i Moduli con casella selezionata saranno abilitati e il resto sarà disabilitato."

msgid "Magisk Modules"
msgstr "Moduli Magisk"

msgid "Enable / Disable Magisk modules"
msgstr "Abilita / Disabilita moduli Magisk"

msgid "Install Module"
msgstr "Installa Modulo"

msgid "Install magisk module."
msgstr "Installa modulo magisk."

msgid "Update Module"
msgstr "Aggiorna Modulo"

msgid "Update magisk module."
msgstr "Aggiorna modulo magisk."

msgid "Uninstall Module"
msgstr "Disinstalla Modulo"

msgid "Uninstall magisk module."
msgstr "Disinstalla modulo magisk."

msgid "Run Action"
msgstr "Esegui Azione"

msgid "Run Module action.sh."
msgstr "Esegui action.sh del Modulo."

msgid "Install Pif / TS Module"
msgstr "Installa Modulo Pif / TS"

msgid "Install Play Integrity Fix related modules."
msgstr "Installa moduli relativi a Play Integrity Fix."

msgid "Install ZygiskNext Module"
msgstr "Installa Modulo ZygiskNext"

msgid "Install ZygiskNext module."
msgstr "Installa modulo ZygiskNext."

msgid "Systemless Hosts"
msgstr "Host Systemless"

msgid "Add Systemless Hosts Module."
msgstr "Aggiungi Modulo Host Systemless."

msgid "Enable Zygisk"
msgstr "Abilita Zygisk"

msgid "Enable Magisk zygisk (requires reboot)"
msgstr "Abilita Magisk zygisk (richiede riavvio)"

msgid "Disable Zygisk"
msgstr "Disabilita Zygisk"

msgid "Disable Magisk zygisk (requires reboot)"
msgstr "Disabilita Magisk zygisk (richiede riavvio)"

msgid "Enable Denylist"
msgstr "Abilita Denylist"

msgid "Enable Magisk denylist"
msgstr "Abilita Magisk denylist"

msgid "Disable Denylist"
msgstr "Disabilita Denylist"

msgid "Disable Magisk denylist"
msgstr "Disabilita Magisk denylist"

msgid "Refresh"
msgstr "Aggiorna"

msgid "Refresh Magisk modules list."
msgstr "Aggiorna lista moduli Magisk."

msgid "To manage denylist or to manage SU permissions, use PixelFlasher's App Manager feature."
msgstr "Per gestire denylist o permessi SU, usa la funzione Gestore App di PixelFlasher."

msgid "Use Pixelflasher's App Manager functionality to add/remove items to denylist or su permissions."
msgstr "Usa la funzionalità Gestore App di Pixelflasher per aggiungere/rimuovere elementi dalla denylist o permessi su."

msgid "Restore Module"
msgstr "Ripristina Modulo"

msgid "## You need to reboot your device for the changes to take effect."
msgstr "## Devi riavviare il dispositivo affinché le modifiche abbiano effetto."

msgid "osm0sis PlayIntegrityFork"
msgstr "osm0sis PlayIntegrityFork"

msgid "chiteroman PlayIntegrityFix"
msgstr "chiteroman PlayIntegrityFix"

msgid "PIF Module"
msgstr "Modulo PIF"

msgid "Select the module you want to install"
msgstr "Seleziona il modulo che vuoi installare"

msgid "## You need to reboot your device to complete the installation."
msgstr "## Devi riavviare il dispositivo per completare l'installazione."

msgid "## You need to reboot your device to complete the update."
msgstr "## Devi riavviare il dispositivo per completare l'aggiornamento."

msgid "Copy"
msgstr "Copia"

msgid "Select All"
msgstr "Seleziona Tutto"

msgid "Superuser Access"
msgstr "Accesso Superuser"

msgid "Superuser Access (requires reboot)"
msgstr "Accesso Superuser (richiede riavvio)"

msgid "Apps Only"
msgstr "Solo App"

msgid "ADB Only"
msgstr "Solo ADB"

msgid "Apps and ADB"
msgstr "App e ADB"

msgid "Disabled"
msgstr "Disabilitato"

##############################################################################
# Rooting App
##############################################################################
msgid "Download and Install Rooting Application"
msgstr "Scarica e Installa Applicazione Rooting"

msgid "Select rooting app to install."
msgstr "Seleziona app rooting da installare."

msgid "Root App"
msgstr "App Root"

msgid "Version"
msgstr "Versione"

msgid "VersionCode"
msgstr "CodiceVersione"

msgid "URL"
msgstr "URL"

msgid "Package"
msgstr "Pacchetto"

msgid "WARNING! Do not install magisk if you already have a hidden (stub) Magisk installed.\nFirst unhide Magisk before attempting an install."
msgstr "ATTENZIONE! Non installare magisk se hai già un Magisk nascosto (stub) installato.\nPrima rendi visibile Magisk prima di tentare un'installazione."

msgid "Download the rooting app."
msgstr "Scarica l'app di rooting."

msgid "Copy URL to Clipboard"
msgstr "Copia URL negli Appunti"

msgid "Copy Package ID to Clipboard"
msgstr "Copia ID Pacchetto negli Appunti"

msgid "Download Selected Rooting App"
msgstr "Scarica App Rooting Selezionata"

msgid "Device Not Supported"
msgstr "Dispositivo Non Supportato"

msgid "The selected Magisk is not supported for your device\n"
msgstr "Il Magisk selezionato non è supportato per il tuo dispositivo\n"

msgid "Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n"
msgstr "Solo Pixel 7 (panther) e Pixel 7 Pro (cheetah) e Pixel 7a (lynx) e Pixel Tablet (tangorpro) sono attualmente supportati.\n\n"

msgid "Unless you know what you are doing, if you choose to continue\n"
msgstr "A meno che tu non sappia cosa stai facendo, se scegli di continuare\n"

msgid "you risk running into serious issues, proceed only if you are absolutely\n"
msgstr "rischi di incorrere in seri problemi, procedi solo se sei assolutamente\n"

##############################################################################
# Magisk Backup Manager
##############################################################################
msgid "Check / Uncheck All"
msgstr "Seleziona / Deseleziona Tutto"

msgid "Delete checked backups"
msgstr "Elimina backup selezionati"

msgid "Add Backup from Computer"
msgstr "Aggiungi Backup dal Computer"

msgid "Select a boot.img and create a backup from it.\nWARNING! No verification is done if the selected file is stock boot image or even for the correct device."
msgstr "Seleziona un boot.img e crea un backup da esso.\nATTENZIONE! Nessuna verifica viene fatta se il file selezionato è l'immagine boot stock o anche per il dispositivo corretto."

msgid "Auto Create Backup"
msgstr "Crea Backup Auto"

msgid "Checks current boot partition,\nFf it is a Magisk Patched with SHA1\nand the boot.img is available, then it\nAutomatically creates a backup of boot image."
msgstr "Controlla la partizione boot corrente,\nSe è un Magisk Patched con SHA1\ne il boot.img è disponibile, allora\nCrea automaticamente un backup dell'immagine boot."

msgid "Closes this dialog"
msgstr "Chiude questa finestra"

msgid "boot / init_boot image to create backup of."
msgstr "immagine boot / init_boot di cui creare backup."

msgid "Delete Backup"
msgstr "Elimina Backup"

msgid "Check All"
msgstr "Seleziona Tutto"

msgid "UnCheck All"
msgstr "Deseleziona Tutto"

msgid "Copy to Clipboard"
msgstr "Copia negli Appunti"

##############################################################################
# App Manager
##############################################################################
msgid "Set SU Permission"
msgstr "Imposta Permesso SU"

msgid "Enter SU Permission details:"
msgstr "Inserisci dettagli Permesso SU:"

msgid "Enable Notification"
msgstr "Abilita Notifica"

msgid "Enable Logging"
msgstr "Abilita Logging"

msgid "Forever"
msgstr "Per sempre"

msgid "10 mins"
msgstr "10 min"

msgid "20 mins"
msgstr "20 min"

msgid "30 mins"
msgstr "30 min"

msgid "60 mins"
msgstr "60 min"

msgid "Allow"
msgstr "Consenti"

msgid "Deny"
msgstr "Nega"

msgid "Revoke"
msgstr "Revoca"

msgid "Manage Packages on the Device"
msgstr "Gestisci Pacchetti sul Dispositivo"

msgid "%s Packages"
msgstr "%s Pacchetti"

msgid "Show System apps"
msgstr "Mostra app di Sistema"

msgid "Show 3rd Party apps"
msgstr "Mostra app Terze Parti"

msgid "Get All Application Names"
msgstr "Ottieni Tutti i Nomi Applicazione"

msgid "Extracts App names, and caches them for faster loading in the future.\nNOTE: This could take a while."
msgstr "Estrae nomi App, e li memorizza nella cache per caricamento più veloce in futuro.\nNOTA: Potrebbe richiedere un po' di tempo."

msgid "Disable"
msgstr "Disabilita"

msgid "Disable checked packages"
msgstr "Disabilita pacchetti selezionati"

msgid "Enable"
msgstr "Abilita"

msgid "Enable checked packages"
msgstr "Abilita pacchetti selezionati"

msgid "Uninstall"
msgstr "Disinstalla"

msgid "Uninstall checked packages"
msgstr "Disinstalla pacchetti selezionati"

msgid "Add to Denylist"
msgstr "Aggiungi a Denylist"

msgid "Add package to Magisk Denylist"
msgstr "Aggiungi pacchetto a Magisk Denylist"

msgid "Remove from Denylist"
msgstr "Rimuovi da Denylist"

msgid "Remove package from Magisk Denylist"
msgstr "Rimuovi pacchetto da Magisk Denylist"

msgid "Install an APK on the device"
msgstr "Installa un APK sul dispositivo"

msgid "Download APK"
msgstr "Scarica APK"

msgid "Extract and download APK"
msgstr "Estrai e scarica APK"

msgid "Export List"
msgstr "Esporta Lista"

msgid "Export the package list in CSV format"
msgstr "Esporta la lista pacchetti in formato CSV"

msgid "%s / %s Packages"
msgstr "%s / %s Pacchetti"

msgid "Export Package list"
msgstr "Esporta lista Pacchetti"

msgid "Choose a directory where all apks should be saved."
msgstr "Scegli una directory dove salvare tutti gli apk."

msgid "Download APK file"
msgstr "Scarica file APK"

msgid "Disable Package"
msgstr "Disabilita Pacchetto"

msgid "Enable Package"
msgstr "Abilita Pacchetto"

msgid "Uninstall Package"
msgstr "Disinstalla Pacchetto"

msgid "Download Package"
msgstr "Scarica Pacchetto"

msgid "Launch Package"
msgstr "Avvia Pacchetto"

msgid "View Application Permissions"
msgstr "Vedi Permessi Applicazione"

msgid "Kill Application"
msgstr "Termina Applicazione"

msgid "Clear Application Data"
msgstr "Cancella Dati Applicazione"

msgid "Add Package to Magisk Denylist"
msgstr "Aggiungi Pacchetto a Magisk Denylist"

msgid "Remove Package from Magisk Denylist"
msgstr "Rimuovi Pacchetto da Magisk Denylist"

msgid "SU Permission ..."
msgstr "Permesso SU ..."

msgid "Before switching slots, please make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "Prima di cambiare slot, assicurati che il tuo dispositivo non sia soggetto a problemi ARB.\nSei sicuro di voler continuare?"

msgid "Switch Slot potential concerns"
msgstr "Potenziali problemi Cambio Slot"

msgid "## ⚠️ WARNING: You have selected to flash both slots.<br/>\n"
msgstr "## ⚠️ ATTENZIONE: Hai selezionato di flashare entrambi gli slot.<br/>\n"

msgid "Please make sure your device is not subject to ARB concerns before clicking continue.<br/>\n"
msgstr "Assicurati che il tuo dispositivo non sia soggetto a problemi ARB prima di cliccare continua.<br/>\n"

msgid "You have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "Hai selezionato l'opzione flash: Flash su entrambi gli slot\nAssicurati che il tuo dispositivo non sia soggetto a problemi ARB.\nSei sicuro di voler continuare?"

msgid "Flash option: Flash to both slots"
msgstr "Opzione flash: Flash su entrambi gli slot"

msgid "✅ Flash to both slots is accepted."
msgstr "✅ Flash su entrambi gli slot accettato."

msgid "Open URL on Device"
msgstr "Apri URL su Dispositivo"

msgid "Enter the URL to open on the device:"
msgstr "Inserisci l'URL da aprire sul dispositivo:"

msgid "Open URL"
msgstr "Apri URL"

msgid "Open a URL in the default browser"
msgstr "Apri un URL nel browser predefinito"

##############################################################################
# Additions 2025-07-20
##############################################################################
msgid "Keep Temp Files"
msgstr "Mantieni File Temp"

msgid "Enabling this will keep temporary files used for patching.\nThis is useful for debugging purposes.\nIt is recommended to keep this disabled."
msgstr "Abilitare questo manterrà i file temporanei usati per il patching.\nUtile per scopi di debug.\nSi raccomanda di tenerlo disabilitato."

msgid "Logcat"
msgstr "Logcat"

msgid "Logcat Viewer"
msgstr "Visualizzatore Logcat"

msgid "Logcat filter: update_engine"
msgstr "Filtro Logcat: update_engine"

msgid "Logcat filtered for update_engine to monitor OTA merging"
msgstr "Logcat filtrato per update_engine per monitorare unione OTA"

msgid "Bootloader Versions"
msgstr "Versioni Bootloader"

msgid "Get Bootloader Versions"
msgstr "Ottieni Versioni Bootloader"

msgid "Formatting Options"
msgstr "Opzioni Formattazione"

msgid "Enable formatting (-v)"
msgstr "Abilita formattazione (-v)"

msgid "Enable or disable formatting options for logcat output"
msgstr "Abilita o disabilita opzioni di formattazione per output logcat"

msgid "Format Verbs"
msgstr "Verbi Formato"

msgid "Show priority, tag, and PID of the process issuing the message"
msgstr "Mostra priorità, tag e PID del processo che emette il messaggio"

msgid "Show all metadata fields and separate messages with blank lines"
msgstr "Mostra tutti i campi metadati e separa i messaggi con righe vuote"

msgid "Show PID only"
msgstr "Mostra solo PID"

msgid "Show the raw log message with no other metadata fields"
msgstr "Mostra il messaggio log grezzo senza altri campi metadati"

msgid "Show the priority and tag only"
msgstr "Mostra solo priorità e tag"

msgid "Show priority, PID, and TID of the thread issuing the message"
msgstr "Mostra priorità, PID e TID del thread che emette il messaggio"

msgid "Show date, time, priority, tag, PID, and TID (default)"
msgstr "Mostra data, ora, priorità, tag, PID e TID (default)"

msgid "Show date, time, priority, tag, and PID of the process"
msgstr "Mostra data, ora, priorità, tag e PID del processo"

msgid "Adverb Modifiers"
msgstr "Modificatori Avverbio"

msgid "Show each priority with a different color"
msgstr "Mostra ogni priorità con un colore diverso"

msgid "Show event descriptions from event-log-tags database"
msgstr "Mostra descrizioni evento dal database event-log-tags"

msgid "Show time as seconds since 1970-01-01 (Unix epoch)"
msgstr "Mostra ora come secondi dal 1970-01-01 (Unix epoch)"

msgid "Show time as CPU seconds since boot"
msgstr "Mostra ora come secondi CPU dall'avvio"

msgid "Ensure that any binary logging content is escaped"
msgstr "Assicura che qualsiasi contenuto di logging binario sia escaped"

msgid "Show UID or Android ID of logged process (if permitted)"
msgstr "Mostra UID o ID Android del processo loggato (se permesso)"

msgid "Show time with microsecond precision"
msgstr "Mostra ora con precisione al microsecondo"

msgid "Filter Options"
msgstr "Opzioni Filtro"

msgid "Tag Filter"
msgstr "Filtro Tag"

msgid "Tag:"
msgstr "Tag:"

msgid "Enter log component tag (or * for all)"
msgstr "Inserisci tag componente log (o * per tutti)"

msgid "Priority Level"
msgstr "Livello Priorità"

msgid "Verbose (default for specific tag)"
msgstr "Dettagliato (default per tag specifico)"

msgid "Debug (default for *)"
msgstr "Debug (default per *)"

msgid "Warn"
msgstr "Attenzione"

msgid "Fatal"
msgstr "Fatale"

msgid "Silent (suppress all output)"
msgstr "Silenzioso (sopprimi tutto l'output)"

msgid "Additional Filters"
msgstr "Filtri Aggiuntivi"

msgid "Regex Filter (-e):"
msgstr "Filtro Regex (-e):"

msgid "Enter ECMAScript regex to filter output"
msgstr "Inserisci regex ECMAScript per filtrare output"

msgid "UIDs Filter (comma-separated):"
msgstr "Filtro UID (separati da virgola):"

msgid "Enter UIDs (numeric, comma-separated)"
msgstr "Inserisci UID (numerici, separati da virgola)"

msgid "View Logcat"
msgstr "Vedi Logcat"

msgid "View logcat output with selected options"
msgstr "Vedi output logcat con opzioni selezionate"

msgid "Clear Logcat"
msgstr "Pulisci Logcat"

msgid "Clear logcat buffer"
msgstr "Pulisci buffer logcat"

msgid "Close this panel"
msgstr "Chiudi questo pannello"

msgid "No device connected"
msgstr "Nessun dispositivo connesso"

msgid "Logcat buffer cleared"
msgstr "Buffer logcat pulito"

##############################################################################
# Additions 2025-09-08
##############################################################################
msgid "Select Package for TargetedFix Target"
msgstr "Seleziona Pacchetto per Target TargetedFix"

msgid "Add Target"
msgstr "Aggiungi Target"

msgid "Add selected package as TargetedFix target"
msgstr "Aggiungi pacchetto selezionato come target TargetedFix"

msgid "Get Application Names"
msgstr "Ottieni Nomi Applicazione"

msgid "TF Targets"
msgstr "Target TF"

msgid "TargetedFix Targets"
msgstr "Target TargetedFix"

msgid "Add TF Target"
msgstr "Aggiungi Target TF"

msgid "Add a new TargetedFix target by selecting from package list on device"
msgstr "Aggiungi un nuovo target TargetedFix selezionando dalla lista pacchetti sul dispositivo"

msgid "Delete TF Target"
msgstr "Elimina Target TF"

msgid "Delete the selected TargetedFix target"
msgstr "Elimina il target TargetedFix selezionato"

msgid "Edit TF Targets"
msgstr "Modifica Target TF"

msgid "Edit TargetedFix targets file"
msgstr "Modifica file target TargetedFix"

msgid "Push TF Json"
msgstr "Invia Json TF"

msgid "Push Active pif content as JSON to the selected TargetedFix target"
msgstr "Invia contenuto Pif Attivo come JSON al target TargetedFix selezionato"

msgid "Auto run migrate.sh"
msgstr "Esegui Auto migrate.sh"

msgid "After saving (pushing) print, automatically run migrate.sh"
msgstr "Dopo il salvataggio (invio) impronta, esegui automaticamente migrate.sh"

msgid "	- Contents of every app json configuration referenced in target.txt\n"
msgstr "	- Contenuto di ogni configurazione json app referenziata in target.txt\n"

##############################################################################
# Additions 2025-09-24
##############################################################################
msgid "There will be two versions created.<br/>\n"
msgstr "Verranno create due versioni.<br/>\n"

msgid "1. Unfiltered version, that would have some sensitive information such as Device ID.\n"
msgstr "1. Versione non filtrata, che avrà alcune informazioni sensibili come ID Dispositivo.\n"

msgid "2. Sanitized version which will filter out sensitive information<br/>\n"
msgstr "2. Versione sanificata che filtrerà le informazioni sensibili<br/>\n"

msgid "**Note:** If you're using publicly shared keybox, keep the checkbox `Redact Keybox details` unticked so that the keybox information is included in the report.<br/>\n"
msgstr "**Nota:** Se stai usando un keybox condiviso pubblicamente, mantieni la casella `Oscura dettagli Keybox` deselezionata in modo che le informazioni keybox siano incluse nel report.<br/>\n"

msgid "If you're using a private keybox, please tick the checkbox `Redact Keybox details` to redact keybox details.<br/>\n"
msgstr "Se stai usando un keybox privato, seleziona la casella `Oscura dettagli Keybox` per oscurare i dettagli keybox.<br/>\n"

msgid "**This report will include the following details:**<br/>\n"
msgstr "**Questo report includerà i seguenti dettagli:**<br/>\n"

msgid "- Playstore and GMS versions.\n"
msgstr "- Versioni Playstore e GMS.\n"

msgid "Redact Keybox details"
msgstr "Oscura dettagli Keybox"

##############################################################################
# Additions 2025-10-01
##############################################################################
msgid "Patch with SukiSU"
msgstr "Patch con SukiSU"

msgid "Patch with SukiSU LKM"
msgstr "Patch con SukiSU LKM"

msgid "Select a pre-built kernel flavor"
msgstr "Seleziona un kernel pre-compilato"

msgid "ShirkNeko flavor kernel"
msgstr "Kernel ShirkNeko"

msgid "MiRinFork flavored kernel"
msgstr "Kernel MiRinFork"

msgid "WildKernels"
msgstr "WildKernels"

##############################################################################
# Additions 2025-10-05
##############################################################################
msgid "Convert console content from env (key=value) prop format to json"
msgstr "Converti contenuto console da formato prop env (chiave=valore) a json"

msgid "Convert console content from json to env (key=value) prop format"
msgstr "Converti contenuto console da json a formato prop env (chiave=valore)"

##############################################################################
# Additions 2025-10-11
##############################################################################
msgid "Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"
msgstr "Scarica / Installa app rooting come Magisk o KernelSU* o APatch o SukiSU o Wild_KSU"

msgid "Push TF Prop"
msgstr "Invia TF Prop"

##############################################################################
# Additions 2025-10-18
##############################################################################
msgid "Select Device"
msgstr "Seleziona Dispositivo"

msgid "Select a device:"
msgstr "Seleziona un dispositivo:"

msgid "Unknown"
msgstr "Sconosciuto"

msgid "PixelFlasher guessed Kernel KMI"
msgstr "PixelFlasher ha indovinato Kernel KMI"

msgid "Your device kernel KMI is unknown probably because you're using\n"
msgstr "Il kernel KMI del tuo dispositivo è sconosciuto probabilmente perché stai usando\n"

msgid "a custom kernel which has stripped out the Android build tag.\n\n"
msgstr "un kernel custom che ha rimosso il tag build Android.\n\n"

msgid "PixelFlasher has guessed the Kernel KMI to be: %s\n\n"
msgstr "PixelFlasher ha indovinato che il Kernel KMI sia: %s\n\n"

msgid "Are you sure you want to proceed with this guessed KMI?\n"
msgstr "Sei sicuro di voler procedere con questo KMI ipotizzato?\n"

##############################################################################
# Additions 2025-11-03
##############################################################################

msgid "The selected path contains single quotes (').\n\nPlease rename the folder to remove the single quotes and try again."
msgstr "Il percorso selezionato contiene virgolette singole (').\n\nPer favore rinomina la cartella rimuovendo le virgolette singole e riprova."

msgid "Options"
msgstr "Opzioni"

msgid "Additional Options"
msgstr "Opzioni Aggiuntive"

msgid "Select Option"
msgstr "Seleziona Opzione"

msgid "⚠️ WARNING: With Option 3, fingerprint can't be patched."
msgstr "⚠️ ATTENZIONE: Con Opzione 3, il fingerprint non può essere patchato."

msgid " (Recommended)"
msgstr " (Raccomandato)"

msgid "Latest Release"
msgstr "Ultima Release"

msgid "Latest Pre-Release"
msgstr "Ultima Pre-Release"

msgid "Latest Release or Pre-Release"
msgstr "Ultima Release o Pre-Release"

msgid "Let me choose the kernel version from a matching list"
msgstr "Lasciami scegliere la versione kernel da una lista corrispondente"

msgid "Show all assets including non-matching ones"
msgstr "Mostra tutti gli asset inclusi quelli non corrispondenti"

msgid "Flash to active slot"
msgstr "Flash sullo slot attivo"

msgid "Flash boot partition"
msgstr "Flash partizione boot"

msgid "Flash init_boot partition"
msgstr "Flash partizione init_boot"

msgid "Flash vendor_boot partition"
msgstr "Flash partizione vendor_boot"

msgid "No Reboot after flash"
msgstr "Nessun Riavvio dopo flash"

msgid "## ✅ Live Boot the stock image:\n"
msgstr "## ✅ Live Boot dell'immagine stock:\n"

msgid "## ✅ Live Boot the patched image:\n"
msgstr "## ✅ Live Boot dell'immagine patchata:\n"

msgid "## ❌ Live Booting is only supported for boot partition.\n"
msgstr "## ❌ Live Booting supportato solo per partizione boot.\n"

msgid "## ❌ Valid image is not found that supports live booting.\n"
msgstr "## ❌ Immagine valida che supporta live booting non trovata.\n"

msgid "## ℹ️ Select partitions that you wish to flash stock image\n"
msgstr "## ℹ️ Seleziona partizioni che desideri flashare immagine stock\n"

msgid "## ℹ️ Select the options to flash a patch image:\n"
msgstr "## ℹ️ Seleziona le opzioni per flashare un'immagine patch:\n"

msgid "## ❌ The selected image is not valid.<br/>\n"
msgstr "## ❌ L'immagine selezionata non è valida.<br/>\n"

msgid "Edit script before continuing"
msgstr "Modifica script prima di continuare"

##############################################################################
# Additions 2025-12-28
##############################################################################

##############################################################################
# Download Progress Window
##############################################################################
msgid "Downloading: %s"
msgstr "Dowmload in corso: %s"

##############################################################################
# File Editor Window
##############################################################################
msgid "Open Shell"
msgstr "Apri Shell"

msgid "Save and Continue"
msgstr "Salva e Continua"

msgid "Cancel and Abort"
msgstr "Annulla e Ferma"

msgid "Open Folder in working directory"
msgstr "Apri Cartells nella directory di lavoro"

msgid "Open command shell in working directory"
msgstr "Apri shell comandi nella directory di lavoro"

msgid "Open Folder in working directory\nNote: PF_FILEMANAGER needs to be set."
msgstr "Apri Cartella nella directory di lavoro\nNota: PF_FILEMANAGER richiede di essere impostato."

msgid "Open Terminal shell in working directory"
msgstr "Apri shell Terminale nella directory di lavoro"

msgid "Save the file and continue."
msgstr "Salva file e continua"

msgid "Cancel and Abort."
msgstr "Annulla e Ferma."

##############################################################################
# Ksu Asset Selector
##############################################################################
msgid "Filter:"
msgstr "Filtra:"

msgid "Search assets..."
msgstr "Cerca assets..."

msgid "Asset Name"
msgstr "Nome Asset"

msgid "Size"
msgstr "Dimensione"

msgid "Suggested: %s"
msgstr "Suggerito: %s"

msgid "Please select an asset."
msgstr "Prego seleziona un asset."

msgid "No Selection"
msgstr "Nessuna Selezione"

msgid "Select KSU Asset"
msgstr "Selezione Asset KSU"

msgid "Select a KSU asset:"
msgstr "Selezioona un asset KSU:"

```

`locale/zh_CN/LC_MESSAGES/pixelflasher.po`:

```po
# English translations for PixelFlasher.
# Copyright (C) 2023-2024 Badabing2005
# This file is distributed under the same license as the PixelFlasher package.
msgid ""
msgstr ""
"Project-Id-Version: PixelFlasher\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-13 16:17+0000\n"
"PO-Revision-Date: 2024-05-13 16:17+0000\n"
"Last-Translator: Littlenine <Himwdsj@gmail.com>\n"
"Language-Team: Simplified Chinese\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"


##############################################################################
# Common buttons
##############################################################################
msgid "Yes"
msgstr "是"

msgid "No"
msgstr "否"

msgid "OK"
msgstr "确定"

msgid "Cancel"
msgstr "取消"

msgid "Apply"
msgstr "应用"

# Main Menu items
msgid "&File"
msgstr "&文件"

msgid "&Device"
msgstr "&设备"

msgid "Dev Tools"
msgstr "开发者工具"

msgid "&My Tools"
msgstr "&我的工具"

msgid "&Google Images"
msgstr "&谷歌图像"

msgid "&Toolbar"
msgstr "&工具栏"

msgid "&Language"
msgstr "&语言"

msgid "&Help"
msgstr "&帮助"

##############################################################################
# Menu
##############################################################################
# -------------------------------------
# File menu items
# -------------------------------------
msgid "Settings"
msgstr "设置"

msgid "Exit"
msgstr "退出"

msgid "E&xit\tCtrl-Q"
msgstr "&退出\tCtrl-Q"

msgid "Exit PixelFlasher"
msgstr "退出 PixelFlasher"

# -------------------------------------
# Device menu items
# -------------------------------------
msgid "Install APK"
msgstr "安装APK"

msgid "Package Manager"
msgstr "包管理"

msgid "ADB Shell"
msgstr "ADB SHELL"

msgid "Scrcpy"
msgstr "投屏"

msgid "Device Info"
msgstr "设备信息"

msgid "Pif Print"
msgstr "Pif Print"

msgid "Props as Json"
msgstr "Props as Json"

msgid "Dump Screen XML"
msgstr "导出 Screen XML"

msgid "Cancel OTA Update"
msgstr "取消OTA更新"

msgid "Check otacerts"
msgstr "检查otacerts"

msgid "Partitions Manager"
msgstr "分区管理"

msgid "PI Analysis Report"
msgstr "PI分析报告"

msgid "Switch Slot"
msgstr "切换槽位"

msgid "Reboot"
msgstr "重启"

# -------------------------------------
# Reboot sub-menu items
# -------------------------------------
msgid "System"
msgstr "系统"

msgid "Bootloader"
msgstr "Bootloader"

msgid "Fastbootd"
msgstr "Fastbootd"

msgid "Recovery"
msgstr "Recovery"

msgid "Interactive Recovery"
msgstr "交互式Recovery"

msgid "Safe Mode"
msgstr "安全模式"

msgid "Download"
msgstr "下载"

msgid "Sideload"
msgstr "侧载"
# ---

msgid "Push file(s) to"
msgstr "推送文件到"

msgid "Magisk"
msgstr "Magisk"

msgid "Rooting App"
msgstr "Root App"

msgid "Magisk Backup Manager"
msgstr "Magisk备份管理"

msgid "Backup /data/adb"
msgstr "备份/data/adb"

msgid "Restore /data/adb"
msgstr "恢复/data/adb"

msgid "Clear /data/adb/*"
msgstr "清除/data/adb"

msgid "Start Shizuku"
msgstr "启动Shizuku"

msgid "Pif Manager"
msgstr "Pif管理"

msgid "SOS"
msgstr "SOS"

msgid "Lock Bootloader"
msgstr "锁定Bootloader"

msgid "Unlock Bootloader"
msgstr "解锁Bootloader"

# -------------------------------------
# Dev Tools menu items
# -------------------------------------
msgid "Check keybox.xml"
msgstr "检查keybox.xml"

msgid "Decode Binary XML"
msgstr "解码二进制XML"

msgid "AVB - Get Image Info"
msgstr "AVB - 获取镜像信息"

msgid "AVB - Prepare Downgrade Patch"
msgstr "AVB - 准备降级补丁"

# -------------------------------------
# My Tools menu items
# -------------------------------------
msgid "Customize My Tools"
msgstr "个性化我的工具"

# Google Images menu items
msgid "Phones"
msgstr "手机"

msgid "Watches"
msgstr "手表"

msgid "Refresh images list"
msgstr "刷新镜像列表"

msgid "Show Progress Window"
msgstr "显示进度窗口"

# -------------------------------------
# Toolbar menu items
# -------------------------------------
msgid "Top"
msgstr "上"

msgid "Left"
msgstr "左"

msgid "Right"
msgstr "右"

msgid "Bottom"
msgstr "下"

msgid "Show Button Text"
msgstr "显示按钮文字"

msgid "Show Button Icon"
msgstr "显示按钮图标"

msgid "Show / Hide Buttons"
msgstr "显示/隐藏按钮"

# -------------------------------------
# Toolbar Show / Hide Button
# sub-menu items share translations
# from Device menu items
# -------------------------------------
msgid "Reboot to System"
msgstr "重启到System"

msgid "Reboot to Bootloader"
msgstr "重启到Bootloader"

msgid "Reboot to Fastbootd"
msgstr "重启到Fastbootd"

msgid "Reboot to Recovery"
msgstr "重启到Recovery"

msgid "Reboot to Interactive Recovery"
msgstr "重启到交互式Recovery"

msgid "Reboot to Safe Mode"
msgstr "重启到安全模式"

msgid "Reboot to Download"
msgstr "重启到Download"

msgid "Reboot to Sideload"
msgstr "重启到侧载"

msgid "Configuration"
msgstr "配置设置"

msgid "Support"
msgstr "支持"

# -------------------------------------
# Help menu items
# -------------------------------------
msgid "Report an Issue"
msgstr "反馈问题"

msgid "Feature Request"
msgstr "功能请求"

msgid "PixelFlasher Project Page"
msgstr "PixelFlasher 项目页面"

msgid "PixelFlasher Community (Forum)"
msgstr "PixelFlasher 社区（论坛）"

msgid "Links"
msgstr "链接"

msgid "Open Configuration Folder"
msgstr "打开配置文件夹"

msgid "Open PixelFlasher Working Directory"
msgstr "打开 PixelFlasher 工作文件夹"

msgid "Create a Sanitized support.zip"
msgstr "创建一个已清理的support.zip"

msgid "Check for New Version"
msgstr "检查更新"

msgid "&About PixelFlasher"
msgstr "&关于 PixelFlasher"

msgid "About"
msgstr "关于"

# -------------------------------------
# Links sub-menu items
# -------------------------------------
msgid "Homeboy76's Guide"
msgstr "Homeboy76 的指南"

msgid "V0latyle's Guide"
msgstr "V0latyle 的指南"

msgid "roirraW's Guide"
msgstr "roirraW 的指南"

msgid "osm0sis's PIF FAQ"
msgstr "osm0sis 的 PIF 常见问题"

msgid "V0latyle's PI API Info"
msgstr "V0latyle 的 PI API 信息"

msgid "Tricky Store (Support Thread)"
msgstr "Tricky Store（支持帖）"

msgid "osm0sis's PlayIntegrityFork"
msgstr "osm0sis 的 PlayIntegrityFork"

msgid "chiteroman's PlayIntegrityFix"
msgstr "chiteroman 的 PlayIntegrityFix"

msgid "5ec1cff's TrickyStore"
msgstr "5ec1cff 的 TrickyStore"

msgid "Get the Google USB Driver"
msgstr "获取 Google USB 驱动程序"

msgid "Android Security Update Bulletins"
msgstr "Android 安全更新公告"

msgid "Android Codenames, tags, and build numbers"
msgstr "Android 代号、标签和构建编号"

msgid "Full OTA Images for Pixel Phones / Tablets"
msgstr "Pixel 手机 / 平板的完整 OTA 镜像"

msgid "Factory Images for Pixel Phones / Tablets"
msgstr "Pixel 手机 / 平板的工厂镜像"

msgid "Full OTA Images for Pixel Watches"
msgstr "Pixel 手表的完整 OTA 镜像"

msgid "Factory Images for Pixel Watches"
msgstr "Pixel 手表的工厂镜像"

msgid "Full OTA Images for Pixel Beta 16"
msgstr "Pixel Beta 16 的完整 OTA 镜像"

msgid "Factory Images for Pixel Beta 16"
msgstr "Pixel Beta 16 的工厂镜像"

##############################################################################
# Helper values
##############################################################################
msgid "Open adb shell to the device"
msgstr "打开设备的 ADB shell"

msgid "Launch Screen Copy"
msgstr "启动屏幕复制"

msgid "Dump Full Device Info"
msgstr "导出完整设备信息"

msgid "Get current device's Pif print (osm0sis fork v5 format)"
msgstr "获取当前设备的 Pif 指纹（osm0sis 分支 v5 格式）"

msgid "Get current device's properties in json format"
msgstr "获取当前设备的属性（JSON 格式）"

msgid "Use uiautomator to dump the screen view in xml"
msgstr "使用 uiautomator 以 XML 格式导出屏幕视图"

msgid "Cancels and Resets OTA updates by Google (Not PixelFlasher)"
msgstr "取消并重置 Google 的 OTA 更新（非 PixelFlasher）"

msgid "Used to see if ROM is signed or not."
msgstr "用于查看 ROM 是否已签名"

msgid "Backup / Erase Partitions"
msgstr "备份 / 擦除分区"

msgid "Generate a report of PI Analysis"
msgstr "生成 PI 分析报告"

msgid "Switch to the other slot"
msgstr "切换到另一个分区槽"

msgid "Manage Magisk modules and settings"
msgstr "管理 Magisk 模块和设置"

msgid "Manage Magisk Backups"
msgstr "管理 Magisk 备份"

msgid ""
"Backs up /data/adb.\n"
"This is useful for backing up Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those paths will not be backed up."
msgstr ""
"备份 /data/adb。\n"
"这对备份 Magisk 模块很有用。\n"
"注意：如果某个模块写入的位置不在 /data/adb，则这些路径不会被备份。"

msgid ""
"Restore /data/adb from a backup file.\n"
"This is useful for restoring Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those items will not be restored."
msgstr ""
"从备份文件中还原 /data/adb。\n"
"这对还原 Magisk 模块很有用。\n"
"注意：如果某个模块写入的位置不在 /data/adb，则这些项目不会被还原。"

msgid ""
"Clear up /data/adb/ content (not the directory).\n"
"This is useful when switching to different root flavor."
msgstr ""
"清除 /data/adb/ 的内容（不删除目录）。\n"
"在切换不同的 Root 方案时很有用。"

msgid "Starts Shizuku service on the device."
msgstr "在设备上启动 Shizuku 服务"

msgid "Disable Magisk Modules"
msgstr "禁用 Magisk 模块"

msgid "Unlock Bootloader (Will wipe data)"
msgstr "解锁引导加载程序（将清除数据）"

msgid "Get Android Verified Boot Image Info"
msgstr "获取 Android 验证启动镜像信息"

msgid "Create Downgrade Patch"
msgstr "创建降级补丁"

##############################################################################
# Toast messages
##############################################################################

msgid "Download Successful"
msgstr "下载成功"

msgid "✅ File downloaded successfully: %s and saved to %s"
msgstr "✅ 文件下载成功：%s，已保存到 %s"

msgid "No Downloads"
msgstr "无下载内容"

msgid "ℹ️ No downloads are in progress."
msgstr "ℹ️ 当前无下载任务进行中。"

msgid "⚠️ WARNING! SHA256 of the selected file does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "⚠️ 警告！所选文件的 SHA256 校验值与文件名中的片段不匹配。\n请再次确认校验值是否正确。"

msgid "APK Install"
msgstr "APK 安装"

msgid "❌ ERROR: Please select a device before attempting APK Installation."
msgstr "❌ 错误：请在尝试安装 APK 之前选择设备。"

msgid "❌ ERROR: No device selected"
msgstr "❌ 错误：未选择任何设备"

msgid "Check OTA Certs"
msgstr "检查 OTA 证书"

msgid "Device Analysis"
msgstr "设备分析"

msgid "❌ ERROR: /data/local/tmp is not accessible, this will affect some features."
msgstr "❌ 错误：无法访问 /data/local/tmp，这将影响某些功能的使用。"

msgid "vbmeta Warning!"
msgstr "vbmeta 警告！"

msgid "WARNING! Banned Kernel"
msgstr "警告！内核已被禁止"

msgid "⚠️ Kernel string: %s is known to be banned.\nPlay Integrity would possibly fail."
msgstr "⚠️ 内核字符串：%s 已知被禁止。\n可能导致 Play Integrity 检测失败。"

msgid "Scan"
msgstr "扫描"

msgid "⚠️ No devices are found.."
msgstr "⚠️ 未发现任何设备。"

msgid "✅ Select your device from the list of %s found devices."
msgstr "✅ 请从发现的 %s 个设备中选择你的设备。"

msgid "Firmware SHA256"
msgstr "固件 SHA256"

msgid "    ⚠️ WARNING! WARNING! WARNING!    Slot a verity / verification does not match slot b verity / verification"
msgstr "    ⚠️ 警告！警告！警告！分区槽 a 的校验与分区槽 b 不一致"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verity state and device's verity state\n"
msgstr "    ⚠️ 警告！警告！警告！当前选中的 vbmeta 校验状态与设备的校验状态不一致\n"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verification state and device's verification state\n"
msgstr "    ⚠️ 警告！警告！警告！当前选中的 vbmeta 验证状态与设备的验证状态不一致\n"

msgid "                                     This has a device wipe implications, please double check.\n"
msgstr "                                     这可能会导致设备被清除，请务必确认。\n"

##############################################################################
# Message dialogs
##############################################################################

msgid "Error"
msgstr "错误"

msgid "Warning"
msgstr "警告"

msgid "Information"
msgstr "信息"

msgid "Success"
msgstr "成功"

msgid "Click OK to accept and continue.\n"
msgstr "点击“确定”以接受并继续。\n"

msgid "or Hit CANCEL to abort."
msgstr "或点击“取消”以中止操作。"

msgid "Select Language"
msgstr "选择语言"

msgid "Language changed to %s. A restart is required for translations to apply."
msgstr "语言已更改为 %s。需重启应用以应用翻译。"

msgid "Language Changed"
msgstr "语言已更改"

msgid "Updates are available"
msgstr "有可用更新"

msgid "ℹ️ There are updates available for PixelFlasher.\n"
msgstr "ℹ️ PixelFlasher 有可用更新。\n"

msgid "Click OK to download and install the updates.\n"
msgstr "点击“确定”下载并安装更新。\n"

msgid "Select binary xml file to decode"
msgstr "选择要解码的二进制 XML 文件"

msgid "Select a file"
msgstr "选择一个文件"

msgid "Browse"
msgstr "浏览"

msgid "  Browse  "
msgstr "  浏览  "

msgid "Save File"
msgstr "保存文件"

msgid "ℹ️ There are updates available for your device.\nCheck Google Images menu.\n"
msgstr "ℹ️ 您的设备有可用更新。\n请查看 Google 镜像菜单。\n"

msgid "Select one or multiple APK file(s) to install"
msgstr "选择一个或多个 APK 文件进行安装"

msgid "Save support file"
msgstr "保存支持文件"

msgid "Dump Screen Xml"
msgstr "导出屏幕 XML"

msgid "Save device analysis"
msgstr "保存设备分析"

msgid "Select files to push"
msgstr "选择要推送的文件"

msgid "Save /data/adb backup file"
msgstr "保存 /data/adb 备份文件"

msgid "Select /data/adb backup file"
msgstr "选择 /data/adb 备份文件"

msgid "Select keybox to test"
msgstr "选择要测试的 keybox"

msgid "Add / Edit / Delete Custom menu items"
msgstr "添加 / 编辑 / 删除自定义菜单项"

msgid "Select Boot Image"
msgstr "选择启动镜像"

##############################################################################
# Main UI
##############################################################################

msgid "Downloads Progress"
msgstr "下载进度"

msgid "Welcome to PixelFlasher %s by Badabing2005"
msgstr "欢迎使用 PixelFlasher %s - 作者 Badabing2005"

msgid "Install APK on the device"
msgstr "在设备上安装 APK"

msgid "App Manager"
msgstr "应用管理器"

msgid "Manage Apps / Packages"
msgstr "管理应用 / 软件包"

msgid "Open ADB shell to the device."
msgstr "打开设备的 ADB shell"

msgid "Partitions"
msgstr "分区"

msgid "Partition Manager"
msgstr "分区管理器"

msgid "Switch to the other Slot"
msgstr "切换到另一个分区槽"

msgid "Reboot to userspace fastboot (fastbootd)"
msgstr "重启到用户空间 fastboot（fastbootd）"

msgid "iRecovery"
msgstr "iRecovery"

msgid "Reboot to Download Mode"
msgstr "重启到下载模式"

msgid "Reboot to Sideload Mode"
msgstr "重启到 Sideload 模式"

msgid "Magisk Backup"
msgstr "Magisk 备份"

msgid ""
"Remove Magisk Modules\n"
"This button issues the following command:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"This helps for cases where device bootloops due to incompatible magisk modules(YMMV).\n"
msgstr ""
"移除 Magisk 模块\n"
"此按钮将执行以下命令：\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"适用于因不兼容的 Magisk 模块导致设备陷入开机循环的情况（效果因人而异）。\n"

msgid "Lock"
msgstr "锁定"

msgid "UnLock"
msgstr "解锁"

msgid "UnLock Bootloader\nCaution will wipe data\n"
msgstr "解锁引导加载程序\n警告：这将清除数据\n"

msgid "UnLock Bootloader"
msgstr "解锁引导加载程序"

msgid "Configuration Settings"
msgstr "配置设置"

msgid "Create Support file"
msgstr "创建支持文件"

msgid "APK installation options"
msgstr "APK 安装选项"

msgid "Install"
msgstr "安装"

msgid "Set ownership to Play Store Market"
msgstr "设置为 Play 商店所有"

msgid "Bypass low target sdk block"
msgstr "绕过低目标 SDK 限制"

msgid "ADB Connected Devices"
msgstr "ADB 已连接设备"

msgid "ADB Connected Devices\nCurrent Active Slot: [A]"
msgstr "ADB 已连接设备\n当前活动分区槽：[A]"

msgid "ADB Connected Devices\nCurrent Active Slot: [B]"
msgstr "ADB 已连接设备\n当前活动分区槽：[B]"

msgid "Android Platform Tools\nVersion %s"
msgstr "Android 平台工具\n版本 %s"

msgid "Android Platform Tools"
msgstr "Android 平台工具"

msgid "vbmeta issue."
msgstr "vbmeta 问题。"

msgid "Warning!\n%s\n"
msgstr "警告！\n%s\n"

msgid "❌ ERROR: You must first select a boot image"
msgstr "❌ 错误：您必须先选择一个启动镜像"

msgid "❌ ERROR: Downgrade patch file not found\nYou must first create a downgrade patch to enable this option.\n"
msgstr "❌ 错误：未找到降级补丁文件\n您必须先创建一个降级补丁以启用此选项。\n"

msgid "❌ ERROR: Wipe All Data is selected\nYou must first select another mode to enable this option.\n"
msgstr "❌ 错误：当前选择了“清除所有数据”\n您必须先选择其他模式才能启用此选项。\n"

msgid "No Wipe Downgrade"
msgstr "无清除降级"

msgid "                 WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "                 警告！！！警告！！！警告！！！\n\n\n"

msgid "THIS IS AN EXPERIMENTAL FEATURE, NO ASSURANCES THAT IT WOULD WORK\n\n"
msgstr "这是一个实验性功能，不保证可以正常工作\n\n"

msgid "Do NOT enable this option if you are not downgrading!!!\n\n"
msgstr "如果您不是在进行降级操作，请不要启用此选项！！！\n\n"

msgid "Proceed only if you know what you're doing.\n\n\n"
msgstr "仅在您清楚自己正在做什么时继续。\n\n\n"

msgid "Do you want to continue to select the No Wipe Downgrade option?\n\n"
msgstr "是否继续选择无清除降级选项？\n\n"

msgid "       Press OK to continue or CANCEL to abort.\n\n"
msgstr "       按“确定”继续或“取消”中止。\n\n"

msgid "CANCEL"
msgstr "取消"

msgid "         WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "         警告！！！警告！！！警告！！！\n\n\n"

msgid "NEVER, EVER LOCK THE BOOTLOADER WITHOUT REVERTING\n\n"
msgstr "切勿在未恢复官方固件的情况下锁定引导加载程序\n\n"

msgid "TO STOCK FIRMWARE OR YOUR PHONE WILL BE BRICKED!!!\n\n\n"
msgstr "至原厂固件，否则您的设备将变砖！！！\n\n\n"

msgid "       THIS WILL WIPE YOUR DEVICE DATA!!!\n\n\n"
msgstr "       此操作将清除您的设备数据！！！\n\n\n"

msgid "Do you want to continue to Lock the device bootloader?\n\n"
msgstr "是否继续锁定设备引导加载程序？\n\n"

msgid "WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n\n"
msgstr "警告！！！此操作将清除设备上的所有用户数据\n\n\n"

msgid "Make sure you first read either of the guides linked in the help menu.\n\n"
msgstr "请确保您已阅读帮助菜单中链接的指南之一。\n\n"

msgid "Failing to follow the proper steps could potentially brick your phone.\n\n"
msgstr "未按正确步骤操作可能导致设备变砖。\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will utilize\n\n"
msgstr "\n注意：点击“确定”将调用一个脚本，它将使用\n\n"

msgid "fastboot commands, if your PC fastboot drivers are not properly setup,\n\n"
msgstr "fastboot 命令，如果您的电脑未正确安装 fastboot 驱动，\n\n"

msgid "fastboot will wait forever, and PixelFlasher will appear hung.\n\n"
msgstr "fastboot 将一直等待，PixelFlasher 将看起来像是卡住了。\n\n"

msgid "In such cases, killing the fastboot process will resume to normalcy.\n\n\n"
msgstr "在此情况下，终止 fastboot 进程即可恢复正常。\n\n\n"

msgid "      Do you want to continue to Lock the device bootloader?\n\n"
msgstr "      是否继续锁定设备引导加载程序？\n\n"

msgid "              Press OK to continue or CANCEL to abort.\n\n"
msgstr "              按“确定”继续或“取消”中止。\n\n"

msgid "      Do you want to continue to Unlock the device bootloader?\n\n"
msgstr "      是否继续解锁设备引导加载程序？\n\n"

msgid "WARNING!!! This is an experimental feature to attempt disabling magisk modules.\n\n\n"
msgstr "警告！！！这是一个用于尝试禁用 Magisk 模块的实验性功能。\n\n\n"

msgid "You would only need to do this if your device is bootlooping due to\n\n"
msgstr "仅当您的设备因以下原因陷入开机循环时，您才需要执行此操作：\n\n"

msgid "incompatible magisk modules, this is not guaranteed to work in all cases (YMMV).\n\n"
msgstr "不兼容的 Magisk 模块，无法保证在所有情况下都有效（效果因人而异）。\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will wait forever to detect the device.\n\n"
msgstr "\n注意：点击“确定”将运行一个脚本，该脚本会无限等待以检测设备。\n\n"

msgid "If your device is not detected PixelFlasher will appear hung.\n\n"
msgstr "如果未检测到设备，PixelFlasher 将看起来像是卡住了。\n\n"

msgid "In such cases, killing the adb process will resume to normalcy.\n\n\n"
msgstr "在此情况下，终止 adb 进程即可恢复正常。\n\n\n"

msgid "                        Press OK to continue or CANCEL to abort.\n\n"
msgstr "                        按“确定”继续或“取消”中止。\n\n"

msgid "Clear /data/adb/ contents"
msgstr "清除 /data/adb/ 内容"

msgid "WARNING!!! This will the clear contents of /data/adb\n\n\n"
msgstr "警告！！！这将清除 /data/adb 的所有内容\n\n\n"

msgid "Do you want to continue to clear /data/adb/ contents?\n\n"
msgstr "是否继续清除 /data/adb/ 内容？\n\n"

msgid "      Press OK to continue or CANCEL to abort.\n\n"
msgstr "      按“确定”继续或“取消”中止。\n\n"

msgid "This will invoke the command adb kill-server.\nAre you sure want to continue?\n"
msgstr "这将执行命令 adb kill-server。\n您确定要继续吗？\n"

msgid "ADB Kill Server"
msgstr "ADB 杀掉服务"

msgid "Download Latest Android Platform-Tools"
msgstr "下载最新 Android 平台工具"

msgid "Select Android Platform-Tools Folder\nWhere adb and fastboot are located.\n"
msgstr "选择 Android 平台工具文件夹\n（adb 和 fastboot 所在位置）\n"

msgid "Double click this label to issue the command:\nadb kill-server"
msgstr "双击此标签以执行命令：\nadb kill-server"

msgid "Open wireless manager dialog."
msgstr "打开无线管理器对话框。"

msgid "[root status] [device mode] [device id] [device model] [device firmware]\n\n"
msgstr "[Root 状态] [设备模式] [设备 ID] [设备型号] [设备固件版本]\n\n"

msgid "✓ Rooted with Magisk.\n"
msgstr "✓ 已通过 Magisk 获取 Root。\n"

msgid "✗ Probably Not Root (Magisk Tools not found).\n"
msgstr "✗ 可能未 Root（未找到 Magisk 工具）。\n"

msgid "?  Unable to determine the root status.\n\n"
msgstr "?  无法确定是否已 Root。\n\n"

msgid "(adb) device is in adb mode\n"
msgstr "（adb）设备处于 ADB 模式\n"

msgid "(f.b) device is in fastboot mode\n"
msgstr "（f.b）设备处于 Fastboot 模式\n"

msgid "(sid) device is in sideload mode\n"
msgstr "（sid）设备处于 Sideload 模式\n"

msgid "(rec) device is in recovery mode\n"
msgstr "（rec）设备处于恢复模式\n"

msgid "Scan for Devices\nPlease manually select the device after the scan is completed."
msgstr "扫描设备\n扫描完成后请手动选择设备。"

msgid "Device Image"
msgstr "设备镜像"

msgid "Download image file for current Pixel device."
msgstr "为当前 Pixel 设备下载镜像文件。"

msgid "Select Pixel Firmware"
msgstr "选择 Pixel 固件"

msgid "Process"
msgstr "处理"

msgid "Process the firmware file and extract the boot.img"
msgstr "处理固件文件并提取 boot.img"

msgid "Apply Custom ROM"
msgstr "应用自定义 ROM"

msgid "Caution: Make sure you read the selected ROM documentation.\nThis might not work for your ROM"
msgstr "注意：请务必阅读所选 ROM 的说明文档。\n这可能与你的 ROM 不兼容。"

msgid "Select Custom ROM"
msgstr "选择自定义 ROM"

msgid "Process the ROM file and extract the boot.img"
msgstr "处理 ROM 文件并提取 boot.img"

msgid "Select a boot/init_boot"
msgstr "选择 boot/init_boot"

msgid "Show All boot/init_boot"
msgstr "显示所有 boot/init_boot"

msgid "Show all boot/init_boot even if it is\nnot part of the selected firmware or ROM"
msgstr "显示所有 boot/init_boot，即使它们不是所选固件或 ROM 的一部分"

msgid "Source SHA1  "
msgstr "源 SHA1  "

msgid "Package Fingerprint  "
msgstr "包指纹  "

msgid "Patched with version "
msgstr "修补版本 "

msgid "Patch Method  "
msgstr "修补方法  "

msgid "Patched on Device  "
msgstr "设备上的修补信息  "

msgid "Date  "
msgstr "日期  "

msgid "Package Path  "
msgstr "包路径  "

msgid "Open Folder"
msgstr "打开文件夹"

msgid "Open boot files folder"
msgstr "打开 boot 文件夹"

msgid "Open Working Directory"
msgstr "打开工作目录"

msgid "Patch"
msgstr "修补"

msgid "Patch the selected item"
msgstr "修补所选项"

msgid "Patch with Magisk"
msgstr "使用 Magisk 修补"

msgid "Patch with KernelSU"
msgstr "使用 KernelSU 修补"

msgid "Patch with KernelSU LKM"
msgstr "使用 KernelSU LKM 修补"

msgid "Patch with KernelSU-Next"
msgstr "使用 KernelSU-Next 修补"

msgid "Patch with KernelSU-Next LKM"
msgstr "使用 KernelSU-Next LKM 修补"

msgid "Patch with APatch"
msgstr "使用 APatch 修补"

msgid "Patch with APatch Alternate"
msgstr "使用 APatch 备用方式修补"

msgid "Patch custom boot/init_boot"
msgstr "修补自定义 boot/init_boot"

msgid "Delete"
msgstr "删除"

msgid "Delete the selected item"
msgstr "删除所选项"

msgid "Add a new boot item"
msgstr "添加新的 boot 项"

msgid "Info"
msgstr "信息"

msgid "Get information about the selected item"
msgstr "获取所选项的信息"

msgid "Live Boot"
msgstr "实时启动"

msgid "Live boot to the selected item"
msgstr "实时启动到所选项"

msgid "Flash Boot"
msgstr "刷写启动镜像"

msgid "Flash just the selected item"
msgstr "仅刷写所选项"

msgid "Flash Mode"
msgstr "刷写模式"

msgid "Keep Data"
msgstr "保留数据"

msgid "Data will be kept intact."
msgstr "数据将保持不变。"

msgid "WIPE all data"
msgstr "清除所有数据"

msgid "CAUTION: This will wipe your data"
msgstr "警告：这将清除你的数据"

msgid "Dry Run"
msgstr "模拟运行"

msgid ""
"Dry Run, no flashing will be done.\n"
"The phone will reboot to fastboot and then\n"
"back to normal.\n"
"This is for testing.\n"
msgstr ""
"模拟运行，不会进行刷写操作。\n"
"手机将重启进入 fastboot 模式，然后再\n"
"恢复正常模式。\n"
"该操作用于测试。\n"

msgid "Full OTA"
msgstr "完整 OTA"

msgid "Flash full OTA, and have the choice of flashing patched image(s)."
msgstr "刷写完整 OTA，并可选择刷写已修补的镜像。"

msgid "Custom Flash"
msgstr "自定义刷写"

msgid ""
"Custom Flash, Advanced option to flash a single file.\n"
"This will not flash the factory image.\n"
"It will flash the single selected file.\n"
msgstr ""
"自定义刷写，高级选项用于刷写单个文件。\n"
"这不会刷写出厂镜像，\n"
"而是刷写所选择的单个文件。\n"

msgid "Live Boot to selected boot / init_boot"
msgstr "实时启动到所选 boot/init_boot"

msgid "Flash"
msgstr "刷写"

msgid "Flashes the selected boot / init_boot"
msgstr "刷写所选 boot/init_boot"

msgid "Depending on the flash selection, paste the appropriate path as custom image."
msgstr "根据所选刷写项，将相应路径粘贴为自定义镜像。"

msgid "Flash Options"
msgstr "刷写选项"

msgid "Flash to inactive slot"
msgstr "刷写到未激活分区槽"

msgid "This option when checked will flash to the alternate slot (inactive).\nKeeping the current slot intact.\n"
msgstr "启用此选项将刷写到备用（未激活）分区槽，\n当前分区槽将保持不变。\n"

msgid "Flash to both slots"
msgstr "刷写到两个分区槽"

msgid "This option when checked will flash to both slots."
msgstr "启用此选项将同时刷写两个分区槽。"

msgid "Disable Verity"
msgstr "禁用 Verity 校验"

msgid "Disables Verity"
msgstr "禁用 Verity 校验机制"

msgid "Disable Verification"
msgstr "禁用验证"

msgid "Disables Verification"
msgstr "禁用验证机制"

msgid "Force"
msgstr "强制执行"

msgid "Force a flash operation that may be unsafe (will wipe your data)"
msgstr "强制执行可能不安全的刷写操作（将清除你的数据）"

msgid "Verbose"
msgstr "详细模式"

msgid "Set fastboot option to verbose"
msgstr "设置 fastboot 为详细输出模式"

msgid "Temporary Root"
msgstr "临时 Root"

msgid "Wipe"
msgstr "清除"

msgid ""
"This option when enabled will not flash patched boot\n"
"Instead it will flash unpatched boot.img, but boot to Live Patched boot\n"
"Handy to test if Magisk will cause a bootloop.\n"
"Please be aware that this temporary root will not survive a subsequent reboot.\n"
"If you want to make this permanent, just Flash Boot the patched boot image.\n"
msgstr ""
"启用此选项时不会刷写已修补的 boot.img，\n"
"而是刷写未修补的 boot.img，但启动到临时修补的 boot。\n"
"适用于测试 Magisk 是否会导致开机循环。\n"
"请注意，这种临时 Root 在重启后将失效。\n"
"若需永久生效，请刷写已修补的 boot 镜像。\n"

msgid "No reboot"
msgstr "不重启"

msgid "Do not reboot after flashing\nThis is useful if you want to perform other actions before reboot.\n"
msgstr "刷写后不重启\n适用于你想在重启前执行其他操作的情况。\n"

msgid "This will invoke data wipe operation at the end of custom flashing.\nOne use case would be when disabling verification for the first time.\n"
msgstr "此操作将在自定义刷写完成后执行数据清除。\n适用于首次禁用验证时的场景。\n"

msgid "WARNING!!! This is a highly experimental feature.\nThis will attempt to downgrade the device without needing a data wipe.\n\n"
msgstr "警告！！！这是一个高度实验性的功能。\n此操作将尝试在不清除数据的情况下降级设备。\n\n"

msgid "Flash Device"
msgstr "刷写设备"

msgid "Sideload OTA"
msgstr "侧载 OTA"

msgid "Custom Flash Device"
msgstr "自定义刷写设备"

msgid "Flashes the selected device with chosen flash options."
msgstr "使用所选的刷写选项刷写设备。"

msgid "Console"
msgstr "控制台"

msgid "Please be patient ..."
msgstr "请耐心等待……"

msgid ""
"Create encrypted and optionally sanitized support.zip file\n"
"When sanitized all sensitive data is redacted.\n\n"
"This file is absolutely required when asking for help."
msgstr ""
"创建加密并可选清除敏感信息的 support.zip 文件。\n"
"若启用清除功能，所有敏感数据将被隐藏。\n\n"
"此文件在请求帮助时是必需的。"

msgid "Debug"
msgstr "调试"

msgid "Enable Debug Messages in the console."
msgstr "在控制台中启用调试信息。"

msgid "Clear Console"
msgstr "清空控制台"

msgid "**APK installation options**<br/>\n"
msgstr "**APK 安装选项**<br/>\n"

msgid "This is a summary of available options.<br/>\n"
msgstr "以下是可用选项的简要说明。<br/>\n"

msgid "1. **Set ownership to Play Store Market** This option sets the ownership to Play Store (as if it was installed from Play Store).<br/>\n"
msgstr "1. **设置归属为 Play 商店** 此选项将应用标记为来自 Play 商店安装。<br/>\n"

msgid "   Android auto apps require that they be installed from the Play Market.<br/>\n"
msgstr "   某些 Android Auto 应用要求必须通过 Play 商店安装。<br/>\n"

msgid "2. Starting with Android 14, apps with a targetSdkVersion lower than 23 can't be installed.<br/>\n"
msgstr "2. 从 Android 14 开始，目标 SDK 版本低于 23 的应用无法安装。<br/>\n"

msgid "   Requiring apps to meet these minimum target API level requirements improves security and privacy for users.<br/><br/>\n"
msgstr "   要求应用满足最低目标 API 级别，有助于提升用户的安全性和隐私保护。<br/><br/>\n"

msgid "   Malware often targets older API levels in order to bypass security and privacy protections that have been introduced in newer Android versions.<br/>\n"
msgstr "   恶意软件通常利用旧版本 API 来绕过新版本 Android 中引入的安全与隐私机制。<br/>\n"

msgid "   For example, some malware apps use a `targetSdkVersion` of 22 to avoid being subjected to the runtime permission model\n"
msgstr "   例如，一些恶意软件将 `targetSdkVersion` 设置为 22，以避开运行时权限管理机制\n"

msgid "   introduced in 2015 by Android 6.0 Marshmallow (API level 23).<br/>\n"
msgstr "   该机制由 Android 6.0（API 级别 23）在 2015 年引入。<br/>\n"

msgid "   This Android 14 change makes it harder for malware to avoid security and privacy improvements.<br/>\n"
msgstr "   Android 14 的这一更改让恶意软件更难绕过安全和隐私增强功能。<br/>\n"

msgid "   Attempting to install an app targeting a lower API level will result in an installation failure.<br/><br/>\n"
msgstr "   尝试安装目标 API 版本较低的应用将导致安装失败。<br/><br/>\n"

msgid "   **Bypass low target sdk block** option bypasses that enforcement.\n"
msgstr "   **绕过低目标 SDK 限制** 选项可跳过该限制。\n"

msgid "_If you have selected multiple APKs to install, the options will apply to all APKs._\n"
msgstr "_若你选择了多个 APK 进行安装，以上选项将应用于所有 APK。_\n"

msgid "**This feature will generate a device analysis report that you could optionally post online to get assistance on Play Integrity related issues.**<br/>\n"
msgstr "**此功能将生成设备分析报告，你可以选择将其发布在线以获得关于 Play Integrity 相关问题的帮助。**<br/>\n"

msgid "- Device state and other device related details.\n"
msgstr "- 设备状态及其他相关详情。\n"

msgid "- Magisk (if available):\n"
msgstr "- Magisk（如有）：\n"

msgid "	- modules list.\n"
msgstr "	- 模块列表。\n"

msgid "	- denylist.\n"
msgstr "	- 拒绝列表。\n"

msgid "- TrickyStore (if available):\n"
msgstr "- TrickyStore（如有）：\n"

msgid "	- `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)\n"
msgstr "	- `/data/adb/tricky_store/keybox.xml`（不包含内容，仅表示证书是否被吊销）\n"

msgid "- PlayIntegrity Fork (if available):\n"
msgstr "- PlayIntegrity Fork（如有）：\n"

msgid "- PlayIntegrityFix (if available):\n"
msgstr "- PlayIntegrityFix（如有）：\n"

msgid "- Whether a testkey ROM is used or not.\n"
msgstr "- 是否使用了 testkey ROM。\n"

msgid "- logcat for PlayIntegrity and TrickyStore related logs.\n"
msgstr "- PlayIntegrity 和 TrickyStore 相关的 logcat 日志。\n"

msgid "- Droidguard VM list.\n"
msgstr "- Droidguard 虚拟机列表。\n"

msgid "- If any custom ROM injection apps are installed from:\n"
msgstr "- 是否安装了任何自定义 ROM 注入应用：\n"

msgid "- Check overlays (if contents of /debug_ramdisk is visible without root)\n"
msgstr "- 检查 overlays（如果未获取 root 权限即可查看 /debug_ramdisk 内容）\n"

msgid "**NOTE:**\n"
msgstr "**注意：**\n"

msgid "This report will be saved at a location of your choosing, and will **not** be part of PixelFlasher captured logs (even though you see it in the console), so rest assured, if you submit support.zip for PixelFlasher related issues, even if you had generated such report, it will never be included in the support.zip file.<br/>\n"
msgstr "该报告将保存在你指定的位置，且**不会**包含在 PixelFlasher 采集的日志中（即使你在控制台中看到），请放心，如果你提交 PixelFlasher 相关问题的 support.zip，即使你生成了此报告，也不会包含在 support.zip 文件中。<br/>\n"

msgid "Your privacy is yours to keep.<br/>\n"
msgstr "你的隐私由你自行保管。<br/>\n"

msgid "If you continue you'd only be generating the report, and not posting it online.<br/>\n"
msgstr "继续操作仅会生成报告，并不会将其发布到网络上。<br/>\n"

msgid "If you want to post it online, please make sure to remove any sensitive information from the report before posting it online.<br/>\n"
msgstr "如果你想在线发布，请确保先从报告中删除所有敏感信息。<br/>\n"

msgid "**Are you sure you want to continue?**<br/>\n"
msgstr "**你确定要继续吗？**<br/>\n"

##############################################################################
# Advanced Settings
##############################################################################

msgid "Advanced Configuration Settings"
msgstr "高级配置设置"

msgid "WARNING!\n"
msgstr "警告！\n"

msgid "This is advanced configuration.\n"
msgstr "这是高级配置。\n"

msgid "Unless you know what you are doing,\n"
msgstr "除非你知道自己在做什么，\n"

msgid "you should not be enabling it.\n"
msgstr "否则不应启用此选项。\n"

msgid "YOU AND YOU ALONE ARE RESPONSIBLE FOR ANYTHING THAT HAPPENS TO YOUR DEVICE.\n"
msgstr "设备出现任何问题，责任完全由你本人承担。\n"

msgid "THIS TOOL IS CODED WITH THE EXPRESS ASSUMPTION THAT YOU ARE FAMILIAR WITH\n"
msgstr "本工具假设你熟悉\n"

msgid "ADB, MAGISK, ANDROID, AND ROOT.\n"
msgstr "ADB、Magisk、Android 及 Root 权限。\n"

msgid "IT IS YOUR RESPONSIBILITY TO ENSURE THAT YOU KNOW WHAT YOU ARE DOING.\n"
msgstr "你有责任确保自己知道在做什么。\n"

msgid "Enable Advanced Options"
msgstr "启用高级选项"

msgid "Expert mode"
msgstr "专家模式"

msgid "Magisk Package Name"
msgstr "Magisk 包名"

msgid "If you have hidden Magisk,\nset this to the hidden package name."
msgstr "如果你隐藏了 Magisk，\n请设置为隐藏的包名。"

msgid "Resets package name to default: %s"
msgstr "重置包名为默认：%s"

msgid "Linux File Explorer:"
msgstr "Linux 文件浏览器："

msgid "Set full path to File Explorer.\nDefault: Nautilus"
msgstr "设置文件浏览器的完整路径。\n默认：Nautilus"

msgid "Linux Shell:"
msgstr "Linux 终端："

msgid "Set full path to Linux Shell.\nDefault: gnome-terminal"
msgstr "设置 Linux 终端的完整路径。\n默认：gnome-terminal"

msgid "Offer Patch Methods"
msgstr "提供补丁方式"

msgid "When patching the choice of method is presented."
msgstr "补丁时会提供方法选择。"

msgid "Patching Recovery Partition"
msgstr "修补 Recovery 分区"

msgid ""
"Enabling this will show an option to patch a recovery partition.\n"
"This should be kept disabled unless you have an old device.\n"
"(most A-only devices launched with Android 9, legacy SAR)"
msgstr ""
"启用后会显示修补 Recovery 分区的选项。\n"
"除非你使用老设备，否则建议保持禁用。\n"
"(大多数 Android 9 及之后的 A-only 设备为遗留 SAR 设备)"

msgid "Use Busybox Shell"
msgstr "使用 Busybox Shell"

msgid "When creating a patch, if this is checked, busybox ash will be used as shell."
msgstr "创建补丁时勾选此项，将使用 busybox ash 作为 shell。"

msgid "System has low memory"
msgstr "系统内存不足"

msgid "Use this option to sacrifice speed in favor of memory."
msgstr "启用此项可牺牲速度以节省内存。"

msgid "Extra img extraction"
msgstr "额外镜像提取"

msgid "When checked and available in payload.bin\nAlso extract vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"
msgstr "勾选后（payload.bin 中存在时），\n还会提取 vendor_boot.img、vendor_kernel_boot.img、dtbo.img、super_empty.img。"

msgid "Show notifications"
msgstr "显示通知"

msgid "When checked PixelFlasher will display system toast notifications."
msgstr "勾选后 PixelFlasher 会显示系统吐司通知。"

msgid "Always create boot.tar"
msgstr "始终创建 boot.tar"

msgid "When checked, PixelFlasher always creates boot.tar of the patched boot file.\nIf unchecked, only for Samsung firmware boot.tar will be created."
msgstr "勾选后，PixelFlasher 始终为补丁后的 boot 文件创建 boot.tar。\n未勾选时仅三星固件会创建 boot.tar。"

msgid "Check for updates"
msgstr "检查更新"

msgid "Checks for available updates on startup"
msgstr "启动时检查可用更新"

msgid "Check for Minimum Disk (5Gb)"
msgstr "检查最小磁盘空间（5GB）"

msgid "Enforces minimum disk space of 5 Gb to allow flashing.\nThis avoids storage related issues."
msgstr "强制要求至少 5GB 可用空间才能刷机。\n避免存储相关问题。"

msgid "Check for bootloader unlocked"
msgstr "检查是否解锁 Bootloader"

msgid "Checks to make sure bootloader is unlocked before flashing."
msgstr "刷机前确认 Bootloader 已解锁。"

msgid "Check for firmware hash validity"
msgstr "检查固件哈希有效性"

msgid "Checks for sha256 portion to be in the image filename to detect Pixel compatible image."
msgstr "检查镜像文件名是否包含 sha256 字段以判定是否为 Pixel 兼容镜像。"

msgid "Keep temporary support files"
msgstr "保留临时支持文件"

msgid "It keeps the temporary support files.\nUseful for inspecting what data is included in support.zip."
msgstr "保留临时支持文件。\n方便检查 support.zip 中包含哪些数据。"

msgid "Check Magisk modules for updates"
msgstr "检查 Magisk 模块更新"

msgid ""
"It checks if the module has updates.\n"
"Disable this if you don't want to check for updates or\n"
" if some module update server has issues and delays the process."
msgstr ""
"检查模块是否有更新。\n"
"如果你不想检查更新，或某些模块更新服务器有问题导致延迟，可禁用此项。"

msgid "Show custom ROM options"
msgstr "显示自定义 ROM 选项"

msgid "Make sure you check if your ROM is supported."
msgstr "请确保确认你的 ROM 是否被支持。"

msgid "Sanitize (Redact) support files"
msgstr "清理（脱敏）支持文件"

msgid ""
"The support files are always encrypted.\n"
"This option redacts sensitive information from the support files.\n"
"But impedes support and is not recommended."
msgstr ""
"支持文件始终加密。\n"
"此选项会从支持文件中脱敏敏感信息。\n"
"但会影响支持效果，不推荐使用。"

msgid "Force codepage to"
msgstr "强制代码页为"

msgid "Uses specified code page instead of system code page"
msgstr "使用指定代码页而非系统代码页"

msgid "Delete bundled libs"
msgstr "删除捆绑库"

msgid "The listed libraries would be deleted from the PF bundle to allow system defined ones to be used."
msgstr "将从 PF 捆绑包中删除列出的库，以使用系统自带库。"

msgid "Example: libreadline.so.8, libgdk*"
msgstr "示例：libreadline.so.8，libgdk*"

msgid "Override KMI"
msgstr "覆盖 KMI"

msgid ""
"This will override the Kernel Module Interface (KMI) to the specified value.\n"
"This is useful for devices with custom kernels.\n"
"The value will be passed to KernelSU as the KMI value."
msgstr ""
"此项会将内核模块接口（KMI）覆盖为指定值。\n"
"适用于使用自定义内核的设备。\n"
"该值会传递给 KernelSU 作为 KMI 值。"

msgid "Example: 5.15.131-android14"
msgstr "示例：5.15.131-android14"

msgid "Use Custom Fontface"
msgstr "使用自定义字体"

msgid "Use custom font for monospace fonts\nMight require PixelFlasher restart to properly apply to the Console window."
msgstr "为等宽字体使用自定义字体\n可能需要重启 PixelFlasher 以正确应用到控制台窗口。"

msgid "Sample "
msgstr "示例 "

msgid "Select font size"
msgstr "选择字体大小"

msgid "scrcpy Path"
msgstr "scrcpy 路径"

msgid "Download scrcpy"
msgstr "下载 scrcpy"

msgid "Scrcpy executable (*.exe;*)|*.exe;*"
msgstr "Scrcpy 可执行文件 (*.exe;*)|*.exe;*"

msgid "Select scrcpy executable"
msgstr "选择 scrcpy 可执行文件"

msgid "Flags / Arguments (Example: --video-bit-rate 2M --max-fps=30 --max-size 1024)"
msgstr "参数 / 选项（示例：--video-bit-rate 2M --max-fps=30 --max-size 1024）"

msgid "Scrcpy settings"
msgstr "Scrcpy 设置"

msgid "Module update URL has issues, inform the module author: %s\nDo you want to skip checking updates for this module?"
msgstr "模块更新 URL 出现问题，请通知模块作者：%s\n你想跳过该模块的更新检查吗？"

msgid "You have an old or problematic Android platform Tools version %s \n"
msgstr "你的 Android Platform Tools 版本 %s 已过时或存在问题\n"

msgid "You are strongly advised to update before continuing.\n"
msgstr "强烈建议你在继续之前先更新。\n"

msgid "Are you sure you want to continue?"
msgstr "你确定要继续吗？"

msgid "Bad Android Platform Tools"
msgstr "无效的 Android Platform Tools"

msgid "Android SDK Version:    %s\n"
msgstr "Android SDK 版本：    %s\n"

msgid "Device:                 %s %s %s\n"
msgstr "设备：                 %s %s %s\n"

msgid "Factory Image:          %s\n"
msgstr "官方固件：              %s\n"

msgid "Custom Rom:             %s\n"
msgstr "自定义 ROM：            %s\n"

msgid "Custom Rom File:        %s\n"
msgstr "自定义 ROM 文件：        %s\n"

msgid "\nBoot image:             %s / %s \n"
msgstr "\n启动镜像：              %s / %s \n"

msgid "                        From: %s\n"
msgstr "                        来源：%s\n"

msgid "                        Patched with %s on %s method:        %s\n"
msgstr "                        使用 %s 按 %s 方法补丁：        %s\n"

msgid "                        Patched with %s on %s\n"
msgstr "                        使用 %s 按 %s 补丁\n"

msgid "\nFlash Mode:             %s\n"
msgstr "\n刷写模式：              %s\n"

msgid "SHA256 of %s%s matches the segment in the filename."
msgstr "%s%s 的 SHA256 与文件名中的段匹配。"

msgid "⚠️ Firmware SHA256 Mismatch"
msgstr "⚠️ 固件 SHA256 不匹配"

msgid "WARNING! SHA256 of %s%s does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "警告！%s%s 的 SHA256 与文件名中的段不匹配。\n请仔细核对以确保校验和正确。"

msgid "Process action"
msgstr "处理操作"

msgid "❌ Could not extract %s"
msgstr "❌ 无法提取 %s"

msgid "Possibly extracted firmware."
msgstr "可能已提取固件。"

msgid "WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n"
msgstr "警告：看起来你已经解压了固件文件，\n并选择了其中的镜像压缩包。\n\n"

msgid "You should not extract the file, please select the downloaded firmware file instead\n\n"
msgstr "你不应该解压该文件，请直接选择下载的固件文件。\n\n"

msgid "If this is not the case, and you want to continue with this selection\n"
msgstr "如果不是这种情况，并且你想继续使用当前选择\n"

msgid "❌ Could not unpack %s."
msgstr "❌ 无法解包 %s。"

msgid "❌ Could not extract %s."
msgstr "❌ 无法提取 %s。"

msgid "❌ Could not find %s."
msgstr "❌ 找不到 %s。"

msgid "⚠️ Detected unsupported firmware."
msgstr "⚠️ 检测到不支持的固件。"

msgid "❌ Could not extract payload.bin."
msgstr "❌ 无法提取 payload.bin。"

msgid "❌ The selected firmware is not valid."
msgstr "❌ 选择的固件无效。"

msgid "⚠️ Nothing to extract from %s"
msgstr "⚠️ %s 中无可提取内容"

msgid "✅ Process %s time: %s seconds"
msgstr "✅ 处理 %s 用时：%s 秒"

msgid "WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?"
msgstr "警告：目标 boot.img 不是降级版本。\n你确定要继续吗？"

msgid "Confirm"
msgstr "确认"

msgid "Display is Locked!"
msgstr "屏幕已锁定！"

msgid "ERROR: Your phone display is Locked.\n\n"
msgstr "错误：你的手机屏幕已锁定。\n\n"

msgid "Make sure you unlock your display\n"
msgstr "请确保解锁屏幕\n"

msgid "And set the display timeout to at least 1 minute.\n\n"
msgstr "并将屏幕超时时间设置为至少 1 分钟。\n\n"

msgid "After doing so, Click OK to accept and continue.\n"
msgstr "完成后，点击确定以接受并继续。\n"

msgid "Manual Patching"
msgstr "手动补丁"

msgid "Done creating the patch, continue"
msgstr "补丁创建完成，继续"

msgid "Magisk Manager is not detected."
msgstr "未检测到 Magisk Manager。"

msgid "WARNING: Magisk Manager [%s] is not found on the phone\n\n"
msgstr "警告：未在手机上找到 Magisk Manager [%s]\n\n"

msgid "This could be either because it is hidden, or it is not installed (most likely not installed)\n\n"
msgstr "可能是因为被隐藏，或未安装（极有可能未安装）\n\n"

msgid "If it is installed and hidden, then you should abort and then unhide it.\n"
msgstr "如果已安装但被隐藏，请先中止操作并取消隐藏。\n"

msgid "If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n"
msgstr "如果未安装 Magisk，PixelFlasher 可以帮你安装并用于补丁。\n\n"

msgid "WARNING: Do not install Magisk again if it is currently hidden.\n"
msgstr "警告：如果 Magisk 当前被隐藏，请勿重新安装。\n"

msgid "Do you want PixelFlasher to download and install Magisk?\n"
msgstr "你想让 PixelFlasher 下载并安装 Magisk 吗？\n"

msgid "You will be given a choice of Magisk Version to install.\n\n"
msgstr "你将可以选择安装的 Magisk 版本。\n\n"

msgid "Click OK to continue with Magisk installation.\n"
msgstr "点击确定继续安装 Magisk。\n"

msgid "Kernel KMI Override"
msgstr "内核 KMI 覆盖"

msgid "Kernel KMI Override: %s\n\n"
msgstr "内核 KMI 覆盖：%s\n\n"

msgid "You have set a custom kernel KMI override.\n"
msgstr "你已设置自定义内核 KMI 覆盖。\n"

msgid "Are you sure you want to proceed with this override?\n"
msgstr "你确定要继续使用该覆盖吗？\n"

msgid "Click OK to proceed with the override.\n"
msgstr "点击确定继续覆盖。\n"

msgid "Boot Model Mismatch"
msgstr "启动模型不匹配"

msgid "APatch Manual Patching"
msgstr "APatch 手动补丁"

msgid "APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n"
msgstr "APatch 手动补丁需要内核配置中启用 CONFIG_KALLSYMS=y。\n"

msgid "APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n"
msgstr "APatch 手动补丁仅支持内核版本 3.18 - 6.1\n\n"

msgid "Do you want to continue regardless of not meeting the pre-requisites?\n\n"
msgstr "你是否仍然希望继续，即使不满足前置条件？\n\n"

msgid "Click Yes to continue with APatch Manual Patching\n"
msgstr "点击“是”继续使用 APatch 手动补丁\n"

msgid "or Hit No to abort."
msgstr "或点击“否”中止操作。"

msgid "Download Latest KernelPatch Tools"
msgstr "下载最新 KernelPatch 工具"

msgid "Latest KernelPatch Tools Pre-release Version: %s\n"
msgstr "最新 KernelPatch 工具预发布版本：%s\n"

msgid "Latest KernelPatch Tools Release Version: %s\n\n"
msgstr "最新 KernelPatch 工具正式版本：%s\n\n"

msgid "Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n"
msgstr "你想下载包含预发布版本的最新 kptools-android 和 kpimg-android 吗？\n\n"

msgid "Click Yes to download the latest pre-release versions: %s\n"
msgstr "点击“是”下载最新预发布版本：%s\n"

msgid "Click No to download the latest Release versions: %s\n"
msgstr "点击“否”下载最新正式版本：%s\n"

msgid "%s Boot"
msgstr "%s 启动"

msgid "ERROR: Your phone model is: %s\n\n"
msgstr "错误：你的手机型号是：%s\n\n"

msgid "The selected Boot is for: %s\n\n"
msgstr "所选启动镜像适用于：%s\n\n"

msgid "Unless you know what you are doing, if you continue flashing\n"
msgstr "除非你知道自己在做什么，否则继续刷写\n"

msgid "you risk bricking your device, proceed only if you are absolutely\n"
msgstr "可能导致设备变砖，只有在完全确定的情况下才继续\n"

msgid "certain that this is what you want, you have been warned.\n\n"
msgstr "你确定这是你想要的，现已警告。\n\n"

msgid "Flash action"
msgstr "刷写操作"

msgid "❌ Device is not detected."
msgstr "❌ 未检测到设备。"

msgid "❌ Bootloader is locked, cannot flash."
msgstr "❌ Bootloader 锁定，无法刷写。"

msgid "Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"
msgstr "你的 Bootloader 被锁定，或未授予 shell 进程 su 权限。\n你确定仍要继续吗？"

msgid "❌ Android Platform Tools is not set."
msgstr "❌ 未设置 Android Platform Tools。"

msgid "❌ Valid device is not selected."
msgstr "❌ 未选择有效设备。"

msgid "❌ boot is not selected."
msgstr "❌ 未选择启动镜像。"

msgid "You can only sideload OTA that is equal or higher than the currently installed version.\n"
msgstr "你只能侧载等于或高于当前安装版本的 OTA。\n"

msgid "Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n"
msgstr "或者，你可以刷写完整固件镜像（含数据清除）以降级，或补丁当前启动镜像以允许无清除降级。\n"

msgid "See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n"
msgstr "详见菜单项：开发工具 | AVB 准备降级补丁。\n\n"

msgid "If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n"
msgstr "如果你仍想继续，点击“是”接受并继续，点击“否”中止。\n"

msgid "You have selected to WIPE data\nAre you sure want to continue?"
msgstr "你选择了清除数据\n你确定要继续吗？"

msgid "Wipe Data"
msgstr "清除数据"

msgid "✅ Wipe Data is accepted."
msgstr "✅ 已接受清除数据选项。"

msgid "You have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?"
msgstr "你选择了刷写选项：清除\n这将清除你的数据\n你确定要继续吗？"

msgid "Flash option: Wipe"
msgstr "刷写选项：清除"

msgid "✅ Wipe is accepted."
msgstr "✅ 已接受清除选项。"

msgid "You have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?"
msgstr "你选择了刷写选项：强制\n这将清除你的数据\n你确定要继续吗？"

msgid "Flash option: Force"
msgstr "刷写选项：强制"

msgid "✅ Force flag is accepted."
msgstr "✅ 已接受强制标志。"

msgid "❌ Not enough disk space."
msgstr "❌ 磁盘空间不足。"

msgid "❌ Full OTA or factory image must be selected."
msgstr "❌ 必须选择完整 OTA 或官方固件。"

msgid "Tensor device not on Android 13 or higher"
msgstr "Tensor 设备未运行 Android 13 或更高版本"

msgid "WARNING: Your phone OS version is lower than Android 13.\n\n"
msgstr "警告：你的手机系统版本低于 Android 13。\n\n"

msgid "If you are upgrading to Android 13 or newer,\n"
msgstr "如果你要升级到 Android 13 或更高版本，\n"

msgid "make sure you at least flash the bootloader to both slots.\n"
msgstr "请确保至少对两个槽位刷入 Bootloader。\n"

msgid "The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n"
msgstr "Pixel 6、Pixel 6 Pro 和 Pixel 6a 的 Android 13 更新包含\n"

msgid "a bootloader update that increments the anti-roll back version for the bootloader.\n"
msgstr "针对 Bootloader 的更新，提升了防止回滚的版本号。\n"

msgid "This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n"
msgstr "这可防止设备回滚至之前存在漏洞的 Bootloader 版本。\n"

msgid "After flashing an Android 13 build on these devices\n"
msgstr "在这些设备刷入 Android 13 构建后\n"

msgid "you will not be able to flash and boot older Android 12 builds.\n\n"
msgstr "你将无法刷入并启动旧版 Android 12 系统。\n\n"

msgid "Selecting the option 'Flash to both slots'\n"
msgstr "选择“刷写至两个槽位”选项\n"

msgid "Will take care of that.\n\n"
msgstr "即可解决此问题。\n\n"

msgid "Click OK to continue as is.\n"
msgstr "点击“确定”继续。\n"

msgid "or Hit CANCEL to abort and change options."
msgstr "或点击“取消”中止并修改选项。"

msgid "✅ Anti rollback warning acknowledged and bypassed."
msgstr "✅ 已确认并绕过防止回滚警告。"

msgid "❌ downgrade_boot.img is not found."
msgstr "❌ 未找到 downgrade_boot.img。"

msgid "❌ Unable to replace boot.img in image.zip."
msgstr "❌ 无法替换 image.zip 中的 boot.img。"

msgid "⚠️ Live booting Pixel 7 or newer devices is not supported."
msgstr "⚠️ 不支持 Pixel 7 或更新设备的实时启动。"

msgid "❌ Image file is not selected."
msgstr "❌ 未选择镜像文件。"

msgid "❌ Boot file is not found."
msgstr "❌ 未找到启动文件。"

msgid "❌ ROM file is not found."
msgstr "❌ 未找到 ROM 文件。"

msgid "Device / Firmware Mismatch"
msgstr "设备 / 固件不匹配"

msgid "The selected firmware is for: %s\n\n"
msgstr "所选固件适用于：%s\n\n"

msgid "✅ Device / Firmware mismatch acknowledged."
msgstr "✅ 已确认设备与固件不匹配。"

msgid "❌ Encountered an error while rebooting to bootloader."
msgstr "❌ 重启至 bootloader 时出错。"

msgid "❌ Encountered an error while rebooting to sideload."
msgstr "❌ 重启至 sideload 模式时出错。"

msgid "❌ Encountered an error while rebooting to fastbootd."
msgstr "❌ 重启至 fastbootd 时出错。"

msgid "❌ Encountered an error while running the flash script."
msgstr "❌ 执行刷写脚本时出错。"

msgid "❌ Encountered an error while flashing the patch."
msgstr "❌ 刷写补丁时出错。"

msgid "❌ vbmeta flashing did not return the expected result."
msgstr "❌ vbmeta 刷写未返回预期结果。"

msgid "❌ It appears that OTA flashing did not properly switch slots."
msgstr "❌ OTA 刷写似乎未正确切换槽位。"

msgid "⚠️ Device is not found after rebooting to bootloader."
msgstr "⚠️ 重启到 bootloader 后未找到设备。"

msgid "✅ Flashing elapsed time: %s seconds"
msgstr "✅ 刷写耗时：%s 秒"

msgid "You have selected  WIPE option.\nAdb debugging will be reset and disabled\nHence patch or vbmeta flashing will be skipped."
msgstr "你选择了清除数据选项。\nADB 调试将被重置并禁用，\n因此补丁或 vbmeta 刷写将被跳过。"

msgid "%s %s \n"
msgstr "%s %s \n"

msgid "Device is not detected."
msgstr "未检测到设备。"

msgid "Done rebooting to bootloader, continue"
msgstr "已完成重启至 bootloader，继续"

msgid "Done rebooting to system, continue"
msgstr "已完成重启至系统，继续"

msgid "## Is your device waiting for interaction?\n"
msgstr "## 你的设备是否等待用户操作？\n"

msgid "_If it is not, please hit the cancel button._\n"
msgstr "_如果不是，请点击取消按钮。_\n"

msgid "If your device is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "如果设备正在等待无法程序化调用的用户操作。\n"

msgid "- Using volume keys, scroll up and down and select **Reboot %s**\n"
msgstr "- 使用音量键上下滚动并选择 **重启至 %s**\n"

msgid "- Press the power button to apply.\n"
msgstr "- 按下电源键确认操作。\n"

msgid "When done, the device should reboot to %s <br/>\n"
msgstr "操作完成后，设备应重启至 %s <br/>\n"

msgid "Wait for the device to fully boot to %s <br/>\n"
msgstr "等待设备完全启动至 %s <br/>\n"

msgid "Click on **Done rebooting to %s, continue** button <br/>\n"
msgstr "点击 **已完成重启至 %s，继续** 按钮 <br/>\n"

msgid "or hit the **Cancel** button to abort.\n"
msgstr "或点击 **取消** 按钮中止。\n"

msgid "Waiting for user interaction"
msgstr "等待用户操作"

msgid "## Your watch should now be in Android Recovery\n"
msgstr "## 你的手表现在应该处于 Android 恢复模式\n"

msgid "The watch is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "手表正在等待无法程序化调用的用户操作。\n"

msgid "- Using touch, scroll and select **Reboot to bootloader**\n"
msgstr "- 使用触摸操作，滚动并选择 **重启至 bootloader**\n"

msgid "- Press the side button to apply.\n"
msgstr "- 按侧边键确认操作。\n"

msgid "When done, the watch should reboot to bootloader mode <br/>\n"
msgstr "操作完成后，手表应重启至 bootloader 模式 <br/>\n"

msgid "Wait for the watch to indicate that it is in bootloader mode <br/>\n"
msgstr "等待手表显示已进入 bootloader 模式 <br/>\n"

msgid "Click on **Done rebooting to bootloader, continue** button <br/>\n"
msgstr "点击 **已完成重启至 bootloader，继续** 按钮 <br/>\n"

msgid "- Using touch, scroll and select **Reboot to system now**\n"
msgstr "- 使用触摸操作，滚动并选择 **立即重启至系统**\n"

msgid "When applied, the watch should reboot to system. <br/>\n"
msgstr "操作完成后，手表应重启至系统。 <br/>\n"

msgid "Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n"
msgstr "当手表系统完全加载后，点击 **已完成重启至系统，继续** 按钮。\n"

##############################################################################
# Pif Manager
##############################################################################
msgid "Active Pif"
msgstr "激活的 Pif"

msgid "Loaded Pif (from Device)"
msgstr "已加载的 Pif（来自设备）"

msgid "Active pif is not modified."
msgstr "激活的 pif 未被修改。"

msgid "Save Active pif content to a json file on disk."
msgstr "将激活的 pif 内容保存为磁盘上的 json 文件。"

msgid "Pif Module"
msgstr "Pif 模块"

msgid "Active pif is not saved in favorites."
msgstr "激活的 pif 未保存至收藏。"

msgid "Select a folder to import pif json files."
msgstr "选择文件夹以导入 pif json 文件。"

msgid "Output"
msgstr "输出"

msgid "Console Output:\nIt could be the json output of processed prop\nor it could be the Play Integrity Check result.\n\nThis is not what currently is on the device."
msgstr "控制台输出：\n可能是已处理的属性的 json 输出\n或是 Play Integrity 检查结果。\n\n这不是设备当前的状态。"

msgid "Smart Paste:\nSets First API to the set value if it is missing or forced.\nReprocesses the output window content to adapt to current module requirements.\nPastes to Active pif."
msgstr "智能粘贴：\n若缺失或强制，设置首个 API 值。\n重新处理输出窗口内容以适应当前模块需求。\n粘贴至激活的 pif。"

msgid "Paste the console window content to Active pif."
msgstr "将控制台窗口内容粘贴至激活的 pif。"

msgid "Paste the Active pif to console window."
msgstr "将激活的 pif 粘贴至控制台窗口。"

msgid "Reprocess current Active Pif window json.\nUseful if you changed module version which might require additional / different fields."
msgstr "重新处理当前激活的 Pif 窗口 JSON。\n当更改模块版本可能需要额外或不同字段时很有用。"

msgid "Reprocess one or many json file(s)\nUseful if you changed module version which might require additional / different fields.\nIf a single file is selected, the new json will output to console output\nHowever if multiple files are selected, the selected file will be updated in place."
msgstr "重新处理一个或多个 JSON 文件\n当你更改模块版本，可能需要额外或不同字段时非常有用。\n如果选择单个文件，新 JSON 会输出到控制台。\n如果选择多个文件，选中的文件将被原地更新。"

msgid "Process one or many json file(s) to generate the FrameworkPatcher formatted code excerpts.\n"
msgstr "处理一个或多个 JSON 文件以生成 FrameworkPatcher 格式的代码片段。\n"

msgid "Add missing Keys from device"
msgstr "添加设备缺失的键"

msgid "When Processing or Reprocessing, add missing fields from device."
msgstr "处理或重新处理时，添加设备中缺失的字段。"

msgid "Force First API to:"
msgstr "强制首个 API 为："

msgid "Forces First API value(s) to"
msgstr "强制首个 API 值为"

msgid "Sort Keys"
msgstr "排序键"

msgid "Sorts json keys"
msgstr "对 JSON 键进行排序"

msgid "Keep All keys"
msgstr "保留所有键"

msgid "Does not remove non standard / unrecognized keys"
msgstr "不移除非标准或未识别的键"

msgid "Spoof Build"
msgstr "伪造 Build"

msgid "Spoof Props"
msgstr "伪造属性"

msgid "Spoof Provider"
msgstr "伪造提供者"

msgid "Spoof Signature"
msgstr "伪造签名"

msgid "Close"
msgstr "关闭"

msgid "Create print"
msgstr "创建打印"

msgid "Create pif.json / spoof_build_vars"
msgstr "创建 pif.json / spoof_build_vars"

msgid "Push print, no validation"
msgstr "推送打印，无验证"

msgid "Pushes the print as is without performing any validation.\nThis is useful to retain comments."
msgstr "按原样推送打印，且不进行任何验证。\n这对于保留注释非常有用。"

msgid "Reload print"
msgstr "重新加载打印"

msgid "Reload pif.json / spoof_build_vars from device."
msgstr "从设备重新加载 pif.json / spoof_build_vars。"

msgid "Cleanup DG"
msgstr "清理 Droidguard"

msgid "Cleanup Droidguard Cache"
msgstr "清理 Droidguard 缓存"

msgid "Push keybox.xml"
msgstr "推送 keybox.xml"

msgid "Push a valid keybox.xml to device."
msgstr "向设备推送有效的 keybox.xml 文件。"

msgid "Edit TS Target"
msgstr "编辑 Tricky Store target.txt"

msgid "Edit Tricky Store target.txt file."
msgstr "编辑 Tricky Store 的 target.txt 文件。"

msgid "Edit TS SP"
msgstr "编辑 Tricky Store security_patch.txt"

msgid "Edit Tricky Store security_patch.txt file."
msgstr "编辑 Tricky Store 的 security_patch.txt 文件。"

msgid "Process build.prop(s)"
msgstr "处理 build.prop 文件"

msgid "Process build.prop to extract a compatible print."
msgstr "处理 build.prop 以提取兼容的打印信息。"

msgid "Process bulk props"
msgstr "批量处理属性"

msgid "Process a folder containing .prop files and convert then to .json files."
msgstr "处理包含 .prop 文件的文件夹并转换为 .json 文件。"

msgid "Process Image"
msgstr "处理镜像"

msgid "Process an image and get a print from it."
msgstr "处理镜像并获取打印信息。"

msgid "Auto Update print"
msgstr "自动更新打印"

msgid "After Processing build.props, the print is automatically pushed to the device and the GMS process is killed."
msgstr "处理完 build.prop 后，打印会自动推送到设备并杀死 GMS 进程。"

msgid "Auto Check Play Integrity"
msgstr "自动检查 Play Integrity"

msgid "After saving (pushing) print, automatically run Play Integrity Check."
msgstr "保存（推送）打印后，自动运行 Play Integrity 检查。"

msgid "Disable UIAutomator"
msgstr "禁用 UIAutomator"

msgid "Disables UIAutomator\nThis is useful for devices with buggy UIAutomator.\nNOTE: Create the coords.json file manually to make use of automated testing."
msgstr "禁用 UIAutomator\n适用于 UIAutomator 有缺陷的设备。\n注意：需手动创建 coords.json 文件以使用自动测试功能。"

msgid "Play Integrity Check"
msgstr "Play Integrity 检查"

msgid "Play Integrity API Checker\nNote: Need to install app from Play store."
msgstr "Play Integrity API 检查器\n注意：需从 Play 商店安装应用。"

msgid "Latest"
msgstr "最新"

msgid "Custom"
msgstr "自定义"

msgid "Select 'Latest' to get the latest Pixel beta pif (Includes Developer Preview).\nSelect 'Custom' to set a custom Android version code."
msgstr "选择“最新”以获取最新的 Pixel 测试版 pif（含开发者预览）。\n选择“自定义”以设置自定义 Android 版本号。"

msgid "Set a valid Android version code."
msgstr "设置有效的 Android 版本代码。"

msgid "Get Pixel Beta Pif"
msgstr "获取 Pixel 测试版 pif"

msgid "Get the latest Pixel beta pif."
msgstr "获取最新的 Pixel 测试版 pif。"

msgid "Get Xiaomi Pif"
msgstr "获取小米 pif"

msgid "Get Xiaomi.eu pif\nEasy to start but is not recommended as it gets banned quickly.\nRecommended to find your own."
msgstr "获取 Xiaomi.eu pif\n易于入门，但不推荐使用，因为容易被封禁。\n建议自行寻找。"

msgid "Get TheFreeman193 Random Pif"
msgstr "获取 TheFreeman193 随机 pif"

msgid "Get a random pif from TheFreeman193 repository.\nNote: The pif might or might not work."
msgstr "从 TheFreeman193 仓库获取随机 pif。\n注意：该 pif 可能可用也可能不可用。"

msgid "No Device is selected.\nPif Manager features are set to limited mode."
msgstr "未选择设备。\nPif 管理器功能设置为受限模式。"

msgid "Device is not rooted or SU permissions to adb shell is not granted.\nPif Manager features are set to limited mode."
msgstr "设备未获得 root 或未授予 adb shell 的 SU 权限。\nPif 管理器功能设置为受限模式。"

msgid "Update print"
msgstr "更新打印"

msgid "Update pif.json / spoof_build_vars."
msgstr "更新 pif.json / spoof_build_vars。"

msgid "Create pif.json / spoof_build_vars."
msgstr "创建 pif.json / spoof_build_vars。"

msgid "Getting Pixel beta print ...\nPlease be patient this could take some time ..."
msgstr "正在获取 Pixel 测试版打印信息...\n请耐心等待，可能需要一些时间..."

msgid "Failed to get beta print."
msgstr "获取测试版打印信息失败。"

msgid "Active pif not in sync"
msgstr "激活的 pif 未同步"

msgid "⚠️ WARNING! Device pif is not in sync with Active Pif contents.\nThe result will not be reflective of the Active pif you're viewing."
msgstr "⚠️ 警告！设备上的 pif 与激活的 pif 内容不同步。\n结果不会反映你当前查看的激活 pif。"

msgid "Choose property files to open"
msgstr "选择要打开的属性文件"

msgid "Select a Device Image"
msgstr "选择设备镜像"

msgid "Processing %s ...\nPlease be patient this could take some time ..."
msgstr "正在处理 %s ...\n请耐心等待，可能需要一些时间..."

msgid "Image format not supported"
msgstr "不支持的镜像格式"

msgid "Select folder to bulk process props files"
msgstr "选择文件夹批量处理属性文件"

msgid "The contents is different than what is currently on the device.\nUpdate the print before testing."
msgstr "内容与设备当前的不一致。\n测试前请更新打印信息。"

msgid "Active pif is saved in favorites."
msgstr "激活的 pif 已保存到收藏夹。"

msgid "Select keybox to push"
msgstr "选择要推送的 keybox"

msgid "Choose one or multiple json files to reprocess"
msgstr "选择一个或多个 JSON 文件重新处理"

msgid "Save FP file"
msgstr "保存 FP 文件"

msgid "Enter a label:"
msgstr "输入标签："

msgid "Save Pif to Favorites"
msgstr "将 Pif 保存到收藏夹"

msgid "Select folder to Import Pifs"
msgstr "选择文件夹导入 Pif 文件"

##############################################################################
# Magisk
##############################################################################
msgid "❌ ERROR: You must first select a valid device."
msgstr "❌ 错误：你必须先选择一个有效设备。"

msgid "Manage Magisk"
msgstr "管理 Magisk"

msgid "When you press the OK button, the Modules with checkbox selected will be enabled and the rest will be disabled."
msgstr "点击确定后，勾选的模块将被启用，其余模块将被禁用。"

msgid "Magisk Modules"
msgstr "Magisk 模块"

msgid "Enable / Disable Magisk modules"
msgstr "启用 / 禁用 Magisk 模块"

msgid "Install Module"
msgstr "安装模块"

msgid "Install magisk module."
msgstr "安装 Magisk 模块。"

msgid "Update Module"
msgstr "更新模块"

msgid "Update magisk module."
msgstr "更新 Magisk 模块。"

msgid "Uninstall Module"
msgstr "卸载模块"

msgid "Uninstall magisk module."
msgstr "卸载 Magisk 模块。"

msgid "Run Action"
msgstr "执行操作"

msgid "Run Module action.sh."
msgstr "运行模块的 action.sh 脚本。"

msgid "Install Pif / TS Module"
msgstr "安装 Pif / Tricky Store 模块"

msgid "Install Play Integrity Fix related modules."
msgstr "安装 Play Integrity 修复模块。"

msgid "Install ZygiskNext Module"
msgstr "安装 ZygiskNext 模块"

msgid "Install ZygiskNext module."
msgstr "安装 ZygiskNext 模块。"

msgid "Systemless Hosts"
msgstr "无系统 Hosts"

msgid "Add Systemless Hosts Module."
msgstr "添加无系统 Hosts 模块。"

msgid "Enable Zygisk"
msgstr "启用 Zygisk"

msgid "Enable Magisk zygisk (requires reboot)"
msgstr "启用 Magisk Zygisk（需要重启）"

msgid "Disable Zygisk"
msgstr "禁用 Zygisk"

msgid "Disable Magisk zygisk (requires reboot)"
msgstr "禁用 Magisk Zygisk（需要重启）"

msgid "Enable Denylist"
msgstr "启用拒绝列表"

msgid "Enable Magisk denylist"
msgstr "启用 Magisk 拒绝列表"

msgid "Disable Denylist"
msgstr "禁用拒绝列表"

msgid "Disable Magisk denylist"
msgstr "禁用 Magisk 拒绝列表"

msgid "Refresh"
msgstr "刷新"

msgid "Refresh Magisk modules list."
msgstr "刷新 Magisk 模块列表。"

msgid "To manage denylist or to manage SU permissions, use PixelFlasher's App Manager feature."
msgstr "要管理拒绝列表或 SU 权限，请使用 PixelFlasher 的应用管理功能。"

msgid "Use Pixelflasher's App Manager functionality to add/remove items to denylist or su permissions."
msgstr "使用 PixelFlasher 的应用管理功能添加或移除拒绝列表或 SU 权限项。"

msgid "Restore Module"
msgstr "恢复模块"

msgid "## You need to reboot your device for the changes to take effect."
msgstr "## 你需要重启设备以使更改生效。"

msgid "osm0sis PlayIntegrityFork"
msgstr "osm0sis PlayIntegrityFork"

msgid "chiteroman PlayIntegrityFix"
msgstr "chiteroman PlayIntegrityFix"

msgid "PIF Module"
msgstr "PIF 模块"

msgid "Select the module you want to install"
msgstr "选择你想安装的模块"

msgid "## You need to reboot your device to complete the installation."
msgstr "## 你需要重启设备以完成安装。"

msgid "## You need to reboot your device to complete the update."
msgstr "## 你需要重启设备以完成更新。"

msgid "Copy"
msgstr "复制"

msgid "Select All"
msgstr "全选"

msgid "Superuser Access"
msgstr "超级用户权限"

msgid "Superuser Access (requires reboot)"
msgstr "超级用户权限（需要重启）"

msgid "Apps Only"
msgstr "仅应用"

msgid "ADB Only"
msgstr "仅 ADB"

msgid "Apps and ADB"
msgstr "应用和 ADB"

msgid "Disabled"
msgstr "已禁用"

##############################################################################
# Rooting App
##############################################################################
msgid "Download and Install Rooting Application"
msgstr "下载并安装 Root 权限应用"

msgid "Select rooting app to install."
msgstr "选择要安装的 Root 应用。"

msgid "Root App"
msgstr "Root 应用"

msgid "Version"
msgstr "版本"

msgid "VersionCode"
msgstr "版本代码"

msgid "URL"
msgstr "下载地址"

msgid "Package"
msgstr "包名"

msgid "WARNING! Do not install magisk if you already have a hidden (stub) Magisk installed.\nFirst unhide Magisk before attempting an install."
msgstr "警告！如果你已经安装了隐藏的（stub）Magisk，请不要重复安装。\n请先取消隐藏 Magisk 后再尝试安装。"

msgid "Download the rooting app."
msgstr "下载 Root 应用。"

msgid "Copy URL to Clipboard"
msgstr "复制下载地址到剪贴板"

msgid "Copy Package ID to Clipboard"
msgstr "复制包名到剪贴板"

msgid "Download Selected Rooting App"
msgstr "下载选定的 Root 应用"

msgid "Device Not Supported"
msgstr "设备不支持"

msgid "The selected Magisk is not supported for your device\n"
msgstr "所选 Magisk 不支持你的设备\n"

msgid "Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n"
msgstr "当前仅支持 Pixel 7（panther）、Pixel 7 Pro（cheetah）、Pixel 7a（lynx）和 Pixel 平板（tangorpro）。\n\n"

msgid "Unless you know what you are doing, if you choose to continue\n"
msgstr "除非你非常清楚自己在做什么，否则如果继续操作，"

msgid "you risk running into serious issues, proceed only if you are absolutely\n"
msgstr "可能会遇到严重问题，请确保你绝对确定后再继续。\n"

##############################################################################
# Magisk Backup Manager
##############################################################################
msgid "Check / Uncheck All"
msgstr "全选 / 取消全选"

msgid "Delete checked backups"
msgstr "删除选中的备份"

msgid "Add Backup from Computer"
msgstr "从电脑添加备份"

msgid "Select a boot.img and create a backup from it.\nWARNING! No verification is done if the selected file is stock boot image or even for the correct device."
msgstr "选择一个 boot.img 并从中创建备份。\n警告！不会验证所选文件是否为原厂启动镜像或适用于当前设备。"

msgid "Auto Create Backup"
msgstr "自动创建备份"

msgid "Checks current boot partition,\nFf it is a Magisk Patched with SHA1\nand the boot.img is available, then it\nAutomatically creates a backup of boot image."
msgstr "检测当前启动分区，\n如果是带有 SHA1 的 Magisk 修补且 boot.img 可用，\n则自动创建启动镜像备份。"

msgid "Closes this dialog"
msgstr "关闭此对话框"

msgid "boot / init_boot image to create backup of."
msgstr "用于创建备份的 boot / init_boot 镜像。"

msgid "Delete Backup"
msgstr "删除备份"

msgid "Check All"
msgstr "全选"

msgid "UnCheck All"
msgstr "取消全选"

msgid "Copy to Clipboard"
msgstr "复制到剪贴板"

##############################################################################
# App Manager
##############################################################################
msgid "Set SU Permission"
msgstr "设置 SU 权限"

msgid "Enter SU Permission details:"
msgstr "输入 SU 权限详情："

msgid "Enable Notification"
msgstr "启用通知"

msgid "Enable Logging"
msgstr "启用日志"

msgid "Forever"
msgstr "永久"

msgid "10 mins"
msgstr "10 分钟"

msgid "20 mins"
msgstr "20 分钟"

msgid "30 mins"
msgstr "30 分钟"

msgid "60 mins"
msgstr "60 分钟"

msgid "Allow"
msgstr "允许"

msgid "Deny"
msgstr "拒绝"

msgid "Revoke"
msgstr "撤销"

msgid "Manage Packages on the Device"
msgstr "管理设备上的软件包"

msgid "%s Packages"
msgstr "%s 个软件包"

msgid "Show System apps"
msgstr "显示系统应用"

msgid "Show 3rd Party apps"
msgstr "显示第三方应用"

msgid "Get All Application Names"
msgstr "获取所有应用名称"

msgid "Extracts App names, and caches them for faster loading in the future.\nNOTE: This could take a while."
msgstr "提取应用名称并缓存，以便未来更快加载。\n注意：此过程可能需要一些时间。"

msgid "Disable"
msgstr "禁用"

msgid "Disable checked packages"
msgstr "禁用选中的软件包"

msgid "Enable"
msgstr "启用"

msgid "Enable checked packages"
msgstr "启用选中的软件包"

msgid "Uninstall"
msgstr "卸载"

msgid "Uninstall checked packages"
msgstr "卸载选中的软件包"

msgid "Add to Denylist"
msgstr "添加到拒绝列表"

msgid "Add package to Magisk Denylist"
msgstr "将软件包添加到 Magisk 拒绝列表"

msgid "Remove from Denylist"
msgstr "从拒绝列表移除"

msgid "Remove package from Magisk Denylist"
msgstr "将软件包从 Magisk 拒绝列表中移除"

msgid "Install an APK on the device"
msgstr "在设备上安装 APK"

msgid "Download APK"
msgstr "下载 APK"

msgid "Extract and download APK"
msgstr "提取并下载 APK"

msgid "Export List"
msgstr "导出列表"

msgid "Export the package list in CSV format"
msgstr "以 CSV 格式导出软件包列表"

msgid "%s / %s Packages"
msgstr "%s / %s 个软件包"

msgid "Export Package list"
msgstr "导出软件包列表"

msgid "Choose a directory where all apks should be saved."
msgstr "选择保存所有 APK 的目录。"

msgid "Download APK file"
msgstr "下载 APK 文件"

msgid "Disable Package"
msgstr "禁用软件包"

msgid "Enable Package"
msgstr "启用软件包"

msgid "Uninstall Package"
msgstr "卸载软件包"

msgid "Download Package"
msgstr "下载软件包"

msgid "Launch Package"
msgstr "启动软件包"

msgid "View Application Permissions"
msgstr "查看应用权限"

msgid "Kill Application"
msgstr "强制停止应用"

msgid "Clear Application Data"
msgstr "清除应用数据"

msgid "Add Package to Magisk Denylist"
msgstr "将软件包添加到 Magisk 拒绝列表"

msgid "Remove Package from Magisk Denylist"
msgstr "将软件包从 Magisk 拒绝列表移除"

msgid "SU Permission ..."
msgstr "SU 权限 ..."

msgid "Before switching slots, please make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "切换分区前，请确保设备不受 ARB（反回滚）限制影响。\n你确定要继续吗？"

msgid "Switch Slot potential concerns"
msgstr "切换分区的潜在风险"

msgid "## ⚠️ WARNING: You have selected to flash both slots.<br/>\n"
msgstr "## ⚠️ 警告：你已选择对两个分区同时刷写。<br/>\n"

msgid "Please make sure your device is not subject to ARB concerns before clicking continue.<br/>\n"
msgstr "请确保你的设备没有受到反回滚（ARB）限制，再点击继续。<br/>\n"

msgid "You have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "你已选择刷写选项：同时刷写两个分区\n请确保你的设备没有受到反回滚（ARB）限制。\n你确定要继续吗？"

msgid "Flash option: Flash to both slots"
msgstr "刷写选项：同时刷写两个分区"

msgid "✅ Flash to both slots is accepted."
msgstr "✅ 已接受同时刷写两个分区的操作。"

msgid "Open URL on Device"
msgstr "在设备上打开 URL"

msgid "Enter the URL to open on the device:"
msgstr "输入要在设备上打开的 URL："

msgid "Open URL"
msgstr "打开 URL"

msgid "Open a URL in the default browser"
msgstr "在默认浏览器中打开 URL"

##############################################################################
# Additions 2025-07-20
##############################################################################
msgid "Keep Temp Files"
msgstr ""

msgid "Enabling this will keep temporary files used for patching.\nThis is useful for debugging purposes.\nIt is recommended to keep this disabled."
msgstr ""

msgid "Logcat"
msgstr ""

msgid "Logcat Viewer"
msgstr ""

msgid "Logcat filter: update_engine"
msgstr ""

msgid "Logcat filtered for update_engine to monitor OTA merging"
msgstr ""

msgid "Bootloader Versions"
msgstr ""

msgid "Get Bootloader Versions"
msgstr ""

msgid "Formatting Options"
msgstr ""

msgid "Enable formatting (-v)"
msgstr ""

msgid "Enable or disable formatting options for logcat output"
msgstr ""

msgid "Format Verbs"
msgstr ""

msgid "Show priority, tag, and PID of the process issuing the message"
msgstr ""

msgid "Show all metadata fields and separate messages with blank lines"
msgstr ""

msgid "Show PID only"
msgstr ""

msgid "Show the raw log message with no other metadata fields"
msgstr ""

msgid "Show the priority and tag only"
msgstr ""

msgid "Show priority, PID, and TID of the thread issuing the message"
msgstr ""

msgid "Show date, time, priority, tag, PID, and TID (default)"
msgstr ""

msgid "Show date, time, priority, tag, and PID of the process"
msgstr ""

msgid "Adverb Modifiers"
msgstr ""

msgid "Show each priority with a different color"
msgstr ""

msgid "Show event descriptions from event-log-tags database"
msgstr ""

msgid "Show time as seconds since 1970-01-01 (Unix epoch)"
msgstr ""

msgid "Show time as CPU seconds since boot"
msgstr ""

msgid "Ensure that any binary logging content is escaped"
msgstr ""

msgid "Show UID or Android ID of logged process (if permitted)"
msgstr ""

msgid "Show time with microsecond precision"
msgstr ""

msgid "Filter Options"
msgstr ""

msgid "Tag Filter"
msgstr ""

msgid "Tag:"
msgstr ""

msgid "Enter log component tag (or * for all)"
msgstr ""

msgid "Priority Level"
msgstr ""

msgid "Verbose (default for specific tag)"
msgstr ""

msgid "Debug (default for *)"
msgstr ""

msgid "Warn"
msgstr ""

msgid "Fatal"
msgstr ""

msgid "Silent (suppress all output)"
msgstr ""

msgid "Additional Filters"
msgstr ""

msgid "Regex Filter (-e):"
msgstr ""

msgid "Enter ECMAScript regex to filter output"
msgstr ""

msgid "UIDs Filter (comma-separated):"
msgstr ""

msgid "Enter UIDs (numeric, comma-separated)"
msgstr ""

msgid "View Logcat"
msgstr ""

msgid "View logcat output with selected options"
msgstr ""

msgid "Clear Logcat"
msgstr ""

msgid "Clear logcat buffer"
msgstr ""

msgid "Close this panel"
msgstr ""

msgid "No device connected"
msgstr ""

msgid "Logcat buffer cleared"
msgstr ""

##############################################################################
# Additions 2025-09-08
##############################################################################
msgid "Select Package for TargetedFix Target"
msgstr ""

msgid "Add Target"
msgstr ""

msgid "Add selected package as TargetedFix target"
msgstr ""

msgid "Get Application Names"
msgstr ""

msgid "TF Targets"
msgstr ""

msgid "TargetedFix Targets"
msgstr ""

msgid "Add TF Target"
msgstr ""

msgid "Add a new TargetedFix target by selecting from package list on device"
msgstr ""

msgid "Delete TF Target"
msgstr ""

msgid "Delete the selected TargetedFix target"
msgstr ""

msgid "Edit TF Targets"
msgstr ""

msgid "Edit TargetedFix targets file"
msgstr ""

msgid "Push TF Json"
msgstr ""

msgid "Push Active pif content as JSON to the selected TargetedFix target"
msgstr ""

msgid "Auto run migrate.sh"
msgstr ""

msgid "After saving (pushing) print, automatically run migrate.sh"
msgstr ""

msgid "	- Contents of every app json configuration referenced in target.txt\n"
msgstr ""

##############################################################################
# Additions 2025-09-24
##############################################################################
msgid "There will be two versions created.<br/>\n"
msgstr ""

msgid "1. Unfiltered version, that would have some sensitive information such as Device ID.\n"
msgstr ""

msgid "2. Sanitized version which will filter out sensitive information<br/>\n"
msgstr ""

msgid "**Note:** If you're using publicly shared keybox, keep the checkbox `Redact Keybox details` unticked so that the keybox information is included in the report.<br/>\n"
msgstr ""

msgid "If you're using a private keybox, please tick the checkbox `Redact Keybox details` to redact keybox details.<br/>\n"
msgstr ""

msgid "**This report will include the following details:**<br/>\n"
msgstr ""

msgid "- Playstore and GMS versions.\n"
msgstr ""

msgid "Redact Keybox details"
msgstr ""

##############################################################################
# Additions 2025-10-01
##############################################################################
msgid "Patch with SukiSU"
msgstr ""

msgid "Patch with SukiSU LKM"
msgstr ""

msgid "Select a pre-built kernel flavor"
msgstr ""

msgid "ShirkNeko flavor kernel"
msgstr ""

msgid "MiRinFork flavored kernel"
msgstr ""

msgid "WildKernels"
msgstr ""

##############################################################################
# Additions 2025-10-05
##############################################################################
msgid "Convert console content from env (key=value) prop format to json"
msgstr "将控制台内容从 env（key=value）prop 格式转换为 JSON"

msgid "Convert console content from json to env (key=value) prop format"
msgstr "将控制台内容从 JSON 转换为 env（key=value）prop 格式"

##############################################################################
# Additions 2025-10-11
##############################################################################
msgid "Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"
msgstr ""

msgid "Push TF Prop"
msgstr ""

##############################################################################
# Additions 2025-10-18
##############################################################################
msgid "Select Device"
msgstr ""

msgid "Select a device:"
msgstr ""

msgid "Unknown"
msgstr ""

msgid "PixelFlasher guessed Kernel KMI"
msgstr ""

msgid "Your device kernel KMI is unknown probably because you're using\n"
msgstr ""

msgid "a custom kernel which has stripped out the Android build tag.\n\n"
msgstr ""

msgid "PixelFlasher has guessed the Kernel KMI to be: %s\n\n"
msgstr ""

msgid "Are you sure you want to proceed with this guessed KMI?\n"
msgstr ""

##############################################################################
# Additions 2025-11-03
##############################################################################

msgid "The selected path contains single quotes (').\n\nPlease rename the folder to remove the single quotes and try again."
msgstr ""

msgid "Options"
msgstr ""

msgid "Additional Options"
msgstr ""

msgid "Select Option"
msgstr ""

msgid "⚠️ WARNING: With Option 3, fingerprint can't be patched."
msgstr ""

msgid " (Recommended)"
msgstr ""

msgid "Latest Release"
msgstr ""

msgid "Latest Pre-Release"
msgstr ""

msgid "Latest Release or Pre-Release"
msgstr ""

msgid "Let me choose the kernel version from a matching list"
msgstr ""

msgid "Show all assets including non-matching ones"
msgstr ""

msgid "Flash to active slot"
msgstr ""

msgid "Flash boot partition"
msgstr ""

msgid "Flash init_boot partition"
msgstr ""

msgid "Flash vendor_boot partition"
msgstr ""

msgid "No Reboot after flash"
msgstr ""

msgid "## ✅ Live Boot the stock image:\n"
msgstr ""

msgid "## ✅ Live Boot the patched image:\n"
msgstr ""

msgid "## ❌ Live Booting is only supported for boot partition.\n"
msgstr ""

msgid "## ❌ Valid image is not found that supports live booting.\n"
msgstr ""

msgid "## ℹ️ Select partitions that you wish to flash stock image\n"
msgstr ""

msgid "## ℹ️ Select the options to flash a patch image:\n"
msgstr ""

msgid "## ❌ The selected image is not valid.<br/>\n"
msgstr ""

msgid "Edit script before continuing"
msgstr ""

##############################################################################
# Additions 2025-12-28
##############################################################################

##############################################################################
# Download Progress Window
##############################################################################
msgid "Downloading: %s"
msgstr ""

##############################################################################
# File Editor Window
##############################################################################
msgid "Open Shell"
msgstr ""

msgid "Save and Continue"
msgstr ""

msgid "Cancel and Abort"
msgstr ""

msgid "Open Folder in working directory"
msgstr ""

msgid "Open command shell in working directory"
msgstr ""

msgid "Open Folder in working directory\nNote: PF_FILEMANAGER needs to be set."
msgstr ""

msgid "Open Terminal shell in working directory"
msgstr ""

msgid "Save the file and continue."
msgstr ""

msgid "Cancel and Abort."
msgstr ""

##############################################################################
# Ksu Asset Selector
##############################################################################
msgid "Filter:"
msgstr ""

msgid "Search assets..."
msgstr ""

msgid "Asset Name"
msgstr ""

msgid "Size"
msgstr ""

msgid "Suggested: %s"
msgstr ""

msgid "Please select an asset."
msgstr ""

msgid "No Selection"
msgstr ""

msgid "Select KSU Asset"
msgstr ""

msgid "Select a KSU asset:"
msgstr ""

```

`locale/zh_TW/LC_MESSAGES/pixelflasher.po`:

```po
# Traditional Chinese translations for PixelFlasher.
# Copyright (C) 2023-2024 Badabing2005
# This file is distributed under the same license as the PixelFlasher package.
msgid ""
msgstr ""
"Project-Id-Version: PixelFlasher\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-13 16:17+0000\n"
"PO-Revision-Date: 2024-05-13 16:17+0000\n"
"Last-Translator: EdwardWu <bluehome.wu@gmail.com>\n"
"Language-Team: Traditional Chinese\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"


##############################################################################
# Common buttons
##############################################################################
msgid "Yes"
msgstr "是"

msgid "No"
msgstr "否"

msgid "OK"
msgstr "確定"

msgid "Cancel"
msgstr "取消"

msgid "Apply"
msgstr "套用"

# Main Menu items
msgid "&File"
msgstr "&檔案"

msgid "&Device"
msgstr "&裝置"

msgid "Dev Tools"
msgstr "開發工具"

msgid "&My Tools"
msgstr "&我的工具"

msgid "&Google Images"
msgstr "&Google 映像"

msgid "&Toolbar"
msgstr "&工具列"

msgid "&Language"
msgstr "&語言"

msgid "&Help"
msgstr "&協助"

##############################################################################
# Menu
##############################################################################
# -------------------------------------
# File menu items
# -------------------------------------
msgid "Settings"
msgstr "設定"

msgid "Exit"
msgstr "退出"

msgid "E&xit\tCtrl-Q"
msgstr "&退出\tCtrl-Q"

msgid "Exit PixelFlasher"
msgstr "退出 PixelFlasher"

# -------------------------------------
# Device menu items
# -------------------------------------
msgid "Install APK"
msgstr "安裝 APK"

msgid "Package Manager"
msgstr "套件管理器"

msgid "ADB Shell"
msgstr "ADB Shell"

msgid "Scrcpy"
msgstr "Scrcpy"

msgid "Device Info"
msgstr "裝置資訊"

msgid "Pif Print"
msgstr "Pif Print"

msgid "Props as Json"
msgstr "Props as Json"

msgid "Dump Screen XML"
msgstr "Dump Screen XML"

msgid "Cancel OTA Update"
msgstr "取消 OTA 更新"

msgid "Check otacerts"
msgstr "檢查 otacerts"

msgid "Partitions Manager"
msgstr "分區管理"

msgid "PI Analysis Report"
msgstr "PI 分析報告"

msgid "Switch Slot"
msgstr "切換槽位"

msgid "Reboot"
msgstr "重新啟動"

# -------------------------------------
# Reboot sub-menu items
# -------------------------------------
msgid "System"
msgstr "系統"

msgid "Bootloader"
msgstr "Bootloader"

msgid "Fastbootd"
msgstr "Fastbootd"

msgid "Recovery"
msgstr "Recovery"

msgid "Interactive Recovery"
msgstr "互動式 Recovery"

msgid "Safe Mode"
msgstr "安全模式"

msgid "Download"
msgstr "下載"

msgid "Sideload"
msgstr "Sideload"
# ---

msgid "Push file(s) to"
msgstr "推送檔案到"

msgid "Magisk"
msgstr "Magisk"

msgid "Rooting App"
msgstr "Rooting App"

msgid "Magisk Backup Manager"
msgstr "Magisk 備份管理器"

msgid "Backup /data/adb"
msgstr "備份 /data/adb"

msgid "Restore /data/adb"
msgstr "還原 /data/adb"

msgid "Clear /data/adb/*"
msgstr "清除 /data/adb/*"

msgid "Start Shizuku"
msgstr "啟動 Shizuku"

msgid "Pif Manager"
msgstr "Pif 管理器"

msgid "SOS"
msgstr "SOS"

msgid "Lock Bootloader"
msgstr "鎖定 Bootloader"

msgid "Unlock Bootloader"
msgstr "解鎖 Bootloader"

# -------------------------------------
# Dev Tools menu items
# -------------------------------------
msgid "Check keybox.xml"
msgstr "檢查 keybox.xml"

msgid "Decode Binary XML"
msgstr "解碼二進位 XML"

msgid "AVB - Get Image Info"
msgstr "AVB - 取得映像資訊"

msgid "AVB - Prepare Downgrade Patch"
msgstr "AVB - 準備降級補丁"

# -------------------------------------
# My Tools menu items
# -------------------------------------
msgid "Customize My Tools"
msgstr "自訂我的工具"

# Google Images menu items
msgid "Phones"
msgstr "手機"

msgid "Watches"
msgstr "手錶"

msgid "Refresh images list"
msgstr "重新整理映像列表"

msgid "Show Progress Window"
msgstr "顯示進度視窗"

# -------------------------------------
# Toolbar menu items
# -------------------------------------
msgid "Top"
msgstr "上"

msgid "Left"
msgstr "左"

msgid "Right"
msgstr "右"

msgid "Bottom"
msgstr "下"

msgid "Show Button Text"
msgstr "顯示按鈕文字"

msgid "Show Button Icon"
msgstr "顯示按鈕圖示"

msgid "Show / Hide Buttons"
msgstr "顯示 / 隱藏按鈕"

# -------------------------------------
# Toolbar Show / Hide Button
# sub-menu items share translations
# from Device menu items
# -------------------------------------
msgid "Reboot to System"
msgstr "重新啟動到系統"

msgid "Reboot to Bootloader"
msgstr "重新啟動到 Bootloader"

msgid "Reboot to Fastbootd"
msgstr "重新啟動到 Fastbootd"

msgid "Reboot to Recovery"
msgstr "重新啟動到 Recovery"

msgid "Reboot to Interactive Recovery"
msgstr "重新啟動到互動式 Recovery"

msgid "Reboot to Safe Mode"
msgstr "重新啟動到安全模式"

msgid "Reboot to Download"
msgstr "重新啟動到下載模式"

msgid "Reboot to Sideload"
msgstr "重新啟動到 Sideload"

msgid "Configuration"
msgstr "配置"

msgid "Support"
msgstr "支援"

# -------------------------------------
# Help menu items
# -------------------------------------
msgid "Report an Issue"
msgstr "回報問題"

msgid "Feature Request"
msgstr "功能請求"

msgid "PixelFlasher Project Page"
msgstr "PixelFlasher 專案頁面"

msgid "PixelFlasher Community (Forum)"
msgstr "PixelFlasher 社群 (論壇)"

msgid "Links"
msgstr "連結"

msgid "Open Configuration Folder"
msgstr "打開配置資料夾"

msgid "Open PixelFlasher Working Directory"
msgstr "打開 PixelFlasher 工作目錄"

msgid "Create a Sanitized support.zip"
msgstr "建立一個已清理的 support.zip"

msgid "Check for New Version"
msgstr "檢查新版本"

msgid "&About PixelFlasher"
msgstr "&關於 PixelFlasher"

msgid "About"
msgstr "關於"

# -------------------------------------
# Links sub-menu items
# -------------------------------------
msgid "Homeboy76's Guide"
msgstr "Homeboy76 的指南"

msgid "V0latyle's Guide"
msgstr "V0latyle 的指南"

msgid "roirraW's Guide"
msgstr "roirraW 的指南"

msgid "osm0sis's PIF FAQ"
msgstr "osm0sis 的 PIF 常見問題"

msgid "V0latyle's PI API Info"
msgstr "V0latyle 的 PI API 資訊"

msgid "Tricky Store (Support Thread)"
msgstr "Tricky Store (支援線)"

msgid "osm0sis's PlayIntegrityFork"
msgstr "osm0sis 的 PlayIntegrityFork"

msgid "chiteroman's PlayIntegrityFix"
msgstr "chiteroman 的 PlayIntegrityFix"

msgid "5ec1cff's TrickyStore"
msgstr "5ec1cff 的 TrickyStore"

msgid "Get the Google USB Driver"
msgstr "取得 Google USB 驅動程式"

msgid "Android Security Update Bulletins"
msgstr "Android 安全更新公告"

msgid "Android Codenames, tags, and build numbers"
msgstr "Android 代號、標籤和版本號"

msgid "Full OTA Images for Pixel Phones / Tablets"
msgstr "Pixel 手機 / 平板的完整 OTA 映像"

msgid "Factory Images for Pixel Phones / Tablets"
msgstr "Pixel 手機 / 平板的工廠映像"

msgid "Full OTA Images for Pixel Watches"
msgstr "Pixel 手錶的完整 OTA 映像"

msgid "Factory Images for Pixel Watches"
msgstr "Pixel 手錶的工廠映像"

msgid "Full OTA Images for Pixel Beta 16"
msgstr "Pixel Beta 16 的完整 OTA 映像"

msgid "Factory Images for Pixel Beta 16"
msgstr "Pixel Beta 16 的工廠映像"

##############################################################################
# Helper values
##############################################################################
msgid "Open adb shell to the device"
msgstr "開啟 adb shell 到裝置"

msgid "Launch Screen Copy"
msgstr "啟動螢幕複製"

msgid "Dump Full Device Info"
msgstr "轉儲完整裝置資訊"

msgid "Get current device's Pif print (osm0sis fork v5 format)"
msgstr "取得目前裝置的 Pif (osm0sis fork v5 格式)"

msgid "Get current device's properties in json format"
msgstr "取得目前裝置的 props (json 格式)"

msgid "Use uiautomator to dump the screen view in xml"
msgstr "使用 uiautomator 轉儲螢幕視圖為 xml"

msgid "Cancels and Resets OTA updates by Google (Not PixelFlasher)"
msgstr "取消並重置 Google 的 OTA 更新 (非 PixelFlasher)"

msgid "Used to see if ROM is signed or not."
msgstr "用於查看 ROM 是否已簽名。"

msgid "Backup / Erase Partitions"
msgstr "備份 / 擦除分區"

msgid "Generate a report of PI Analysis"
msgstr "生成 PI 分析報告"

msgid "Switch to the other slot"
msgstr "切換到另一個槽位"

msgid "Manage Magisk modules and settings"
msgstr "管理 Magisk 模組和設定"

msgid "Manage Magisk Backups"
msgstr "管理 Magisk 備份"

msgid ""
"Backs up /data/adb.\n"
"This is useful for backing up Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those paths will not be backed up."
msgstr ""
"備份 /data/adb 。\n"
"這對於備份 Magisk 模組很有用。\n"
"注意：如果模組寫入到 /data/adb 以外的任何地方，這些路徑將不會被備份到。"

msgid ""
"Restore /data/adb from a backup file.\n"
"This is useful for restoring Magisk modules.\n"
"NOTE: If a module writes to anywhere other than /data/adb, those items will not be restored."
msgstr ""
"從備份檔案還原 /data/adb。\n"
"這對於還原 Magisk 模組很有用。\n"

msgid ""
"Clear up /data/adb/ content (not the directory).\n"
"This is useful when switching to different root flavor."
msgstr ""
"清除 /data/adb/ 內容 (不是目錄)。\n"
"這對於切換到不同的 root 類型很有用。"

msgid "Starts Shizuku service on the device."
msgstr "在裝置上啟動 Shizuku 服務。"

msgid "Disable Magisk Modules"
msgstr "停用 Magisk 模組"

msgid "Unlock Bootloader (Will wipe data)"
msgstr "解鎖 Bootloader (將清除資料)"

msgid "Get Android Verified Boot Image Info"
msgstr "取得 Android 驗證啟動映像資訊"

msgid "Create Downgrade Patch"
msgstr "建立降級補丁"

##############################################################################
# Toast messages
##############################################################################
msgid "Download Successful"
msgstr "下載成功"

msgid "✅ File downloaded successfully: %s and saved to %s"
msgstr "✅ 檔案下載成功：%s 並已儲存到 %s"

msgid "No Downloads"
msgstr "沒有下載"

msgid "ℹ️ No downloads are in progress."
msgstr "ℹ️ 沒有下載正在進行中。"

msgid "⚠️ WARNING! SHA256 of the selected file does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "⚠️ 警告！所選檔案的 SHA256 與檔名中的段落不匹配。\n請仔細檢查以確保校驗和是正確的。"

msgid "APK Install"
msgstr "APK 安裝"

msgid "❌ ERROR: Please select a device before attempting APK Installation."
msgstr "❌ 錯誤：請在嘗試 APK 安裝之前選擇一個裝置。"

msgid "❌ ERROR: No device selected"
msgstr "❌ 錯誤：未選擇裝置"

msgid "Check OTA Certs"
msgstr "檢查 OTA 憑證"

msgid "Device Analysis"
msgstr "裝置分析"

msgid "❌ ERROR: /data/local/tmp is not accessible, this will affect some features."
msgstr "❌ 錯誤：/data/local/tmp 無法存取，這將影響某些功能。"

msgid "vbmeta Warning!"
msgstr "vbmeta 警告！"

msgid "WARNING! Banned Kernel"
msgstr "警告！禁止的內核"

msgid "⚠️ Kernel string: %s is known to be banned.\nPlay Integrity would possibly fail."
msgstr "⚠️ 內核字串：%s 已知為禁止。\nPlay Integrity 可能會失敗。"

msgid "Scan"
msgstr "掃描"

msgid "⚠️ No devices are found.."
msgstr "⚠️ 找不到裝置.."

msgid "✅ Select your device from the list of %s found devices."
msgstr "✅ 從找到的 %s 個裝置列表中選擇您的裝置。"

msgid "Firmware SHA256"
msgstr "韌體 SHA256"

msgid "    ⚠️ WARNING! WARNING! WARNING!    Slot a verity / verification does not match slot b verity / verification"
msgstr "    ⚠️ 警告！警告！警告！    Slot a 的 verity / verification 與 slot b 的 verity / verification 不匹配"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verity state and device's verity state\n"
msgstr "    ⚠️ 警告！警告！警告！    當前選擇的 vbmeta verity 狀態與裝置的 verity 狀態不匹配\n"

msgid "    ⚠️ WARNING! WARNING! WARNING!    There is a mismatch of currently selected vbmeta verification state and device's verification state\n"
msgstr "    ⚠️ 警告！警告！警告！    當前選擇的 vbmeta verification 狀態與裝置的 verification 狀態不匹配\n"

msgid "                                     This has a device wipe implications, please double check.\n"
msgstr "                                     這可能會影響裝置清除，請仔細檢查。\n"

##############################################################################
# Message dialogs
##############################################################################
msgid "Error"
msgstr "錯誤"

msgid "Warning"
msgstr "警告"

msgid "Information"
msgstr "資訊"

msgid "Success"
msgstr "成功"

msgid "Click OK to accept and continue.\n"
msgstr "點擊確定以接受並繼續。\n"

msgid "or Hit CANCEL to abort."
msgstr "或點擊取消以中止。"

msgid "Select Language"
msgstr "選擇語言"

msgid "Language changed to %s. A restart is required for translations to apply."
msgstr "語言已更改為 %s。需要重新啟動才能套用翻譯。"

msgid "Language Changed"
msgstr "語言已更改"

msgid "Updates are available"
msgstr "有可用的更新"

msgid "ℹ️ There are updates available for PixelFlasher.\n"
msgstr "ℹ️ 有可用的更新供 PixelFlasher 使用。\n"

msgid "Click OK to download and install the updates.\n"
msgstr "點擊確定以下載並安裝更新。\n"

msgid "Select binary xml file to decode"
msgstr "選擇要解碼的二進位 xml 檔案"

msgid "Select a file"
msgstr "選擇檔案"

msgid "Browse"
msgstr "瀏覽"

msgid "  Browse  "
msgstr "  瀏覽  "

msgid "Save File"
msgstr "儲存檔案"

msgid "ℹ️ There are updates available for your device.\nCheck Google Images menu.\n"
msgstr "ℹ️ 有可用的更新供您的裝置使用。\n請檢查 Google 映像選單。\n"

msgid "Select one or multiple APK file(s) to install"
msgstr "選擇一個或多個 APK 檔案進行安裝"

msgid "Save support file"
msgstr "儲存支援檔案"

msgid "Dump Screen Xml"
msgstr "轉儲螢幕 Xml"

msgid "Save device analysis"
msgstr "儲存裝置分析"

msgid "Select files to push"
msgstr "選擇要推送的檔案"

msgid "Save /data/adb backup file"
msgstr "儲存 /data/adb 備份檔案"

msgid "Select /data/adb backup file"
msgstr "選擇 /data/adb 備份檔案"

msgid "Select keybox to test"
msgstr "選擇要測試的 keybox"

msgid "Add / Edit / Delete Custom menu items"
msgstr "新增 / 編輯 / 刪除自訂選單項目"

msgid "Select Boot Image"
msgstr "選擇啟動映像"

##############################################################################
# Main UI
##############################################################################
msgid "Downloads Progress"
msgstr "下載進度"

msgid "Welcome to PixelFlasher %s by Badabing2005"
msgstr "歡迎使用 PixelFlasher %s，由 Badabing2005 提供"

msgid "Install APK on the device"
msgstr "在裝置上安裝 APK"

msgid "App Manager"
msgstr "應用程式管理器"

msgid "Manage Apps / Packages"
msgstr "管理應用程式 / 套件"

msgid "Open ADB shell to the device."
msgstr "開啟 ADB shell 到裝置。"

msgid "Partitions"
msgstr "分區"

msgid "Partition Manager"
msgstr "分區管理器"

msgid "Switch to the other Slot"
msgstr "切換到另一個插槽"

msgid "Reboot to userspace fastboot (fastbootd)"
msgstr "重新啟動到使用者空間 fastboot (fastbootd)"

msgid "iRecovery"
msgstr "iRecovery"

msgid "Reboot to Download Mode"
msgstr "重新啟動到下載模式"

msgid "Reboot to Sideload Mode"
msgstr "重新啟動到 Sideload 模式"

msgid "Magisk Backup"
msgstr "Magisk 備份"

msgid ""
"Remove Magisk Modules\n"
"This button issues the following command:\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"This helps for cases where device bootloops due to incompatible magisk modules(YMMV).\n"
msgstr ""
"移除 Magisk 模組\n"
"這個按鈕執行以下命令：\n"
"    adb wait-for-device shell magisk --remove-modules\n"
"這將有助於處理由於不相容的 Magisk 模組導致裝置啟動循環的情況 (YMMV)。\n"

msgid "Lock"
msgstr "鎖定"

msgid "UnLock"
msgstr "解鎖"

msgid "UnLock Bootloader\nCaution will wipe data\n"
msgstr "解鎖 Bootloader\n注意：這將清除所有資料\n"

msgid "UnLock Bootloader"
msgstr "解鎖 Bootloader"

msgid "Configuration Settings"
msgstr "配置設定"

msgid "Create Support file"
msgstr "建立支援檔案"

msgid "APK installation options"
msgstr "APK 安裝選項"

msgid "Install"
msgstr "安裝"

msgid "Set ownership to Play Store Market"
msgstr "將擁有權設定為 Play 商店"

msgid "Bypass low target sdk block"
msgstr "繞過低目標 sdk 限制"

msgid "ADB Connected Devices"
msgstr "ADB 連接的裝置"

msgid "ADB Connected Devices\nCurrent Active Slot: [A]"
msgstr "ADB 連接的裝置\n當前活動插槽：[A]"

msgid "ADB Connected Devices\nCurrent Active Slot: [B]"
msgstr "ADB 連接的裝置\n當前活動插槽：[B]"

msgid "Android Platform Tools\nVersion %s"
msgstr "Android 平台工具\n版本 %s"

msgid "Android Platform Tools"
msgstr "Android 平台工具"

msgid "vbmeta issue."
msgstr "vbmeta 問題。"

msgid "Warning!\n%s\n"
msgstr "警告！\n%s\n"

msgid "❌ ERROR: You must first select a boot image"
msgstr "❌ 錯誤：您必須先選擇一個 boot 映像"

msgid "❌ ERROR: Downgrade patch file not found\nYou must first create a downgrade patch to enable this option.\n"
msgstr "❌ 錯誤：未找到降級補丁檔案\n您必須先建立降級補丁才能啟用此選項。\n"

msgid "❌ ERROR: Wipe All Data is selected\nYou must first select another mode to enable this option.\n"
msgstr "❌ 錯誤：已選擇清除所有資料\n您必須先選擇其他模式才能啟用此選項。\n"

msgid "No Wipe Downgrade"
msgstr "不清除降級"

msgid "                 WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "                 警告！！！警告！！！警告！！！\n\n\n"

msgid "THIS IS AN EXPERIMENTAL FEATURE, NO ASSURANCES THAT IT WOULD WORK\n\n"
msgstr "這是一個實驗性功能，無法保證它會正常工作\n\n"

msgid "Do NOT enable this option if you are not downgrading!!!\n\n"
msgstr "如果您不進行降級，請勿啟用此選項！！！\n\n"

msgid "Proceed only if you know what you're doing.\n\n\n"
msgstr "僅在您知道自己在做什麼的情況下繼續。\n\n\n"

msgid "Do you want to continue to select the No Wipe Downgrade option?\n\n"
msgstr "您是否要繼續選擇不清除降級選項？\n\n"

msgid "       Press OK to continue or CANCEL to abort.\n\n"
msgstr "       按下 OK 繼續或按下 CANCEL 取消。\n\n"

msgid "CANCEL"
msgstr "取消"

msgid "         WARNING!!! WARNING!!! WARNING!!!\n\n\n"
msgstr "         警告！！！警告！！！警告！！！\n\n\n"

msgid "NEVER, EVER LOCK THE BOOTLOADER WITHOUT REVERTING\n\n"
msgstr "絕對不要在未還原的情況下鎖定 Bootloader\n\n"

msgid "TO STOCK FIRMWARE OR YOUR PHONE WILL BE BRICKED!!!\n\n\n"
msgstr "恢復到原廠韌體，否則您的手機將變磚！！！\n\n\n"

msgid "       THIS WILL WIPE YOUR DEVICE DATA!!!\n\n\n"
msgstr "       這將清除您的裝置資料！！！\n\n\n"

msgid "Do you want to continue to Lock the device bootloader?\n\n"
msgstr "您是否要繼續鎖定裝置的 bootloader？\n\n"

msgid "WARNING!!! THIS WILL ERASE ALL USER DATA FROM THE DEVICE\n\n\n"
msgstr "警告！！！這將清除裝置上的所有用戶資料\n\n\n"

msgid "Make sure you first read either of the guides linked in the help menu.\n\n"
msgstr "請確保您首先閱讀幫助菜單中鏈接的任一指南。\n\n"

msgid "Failing to follow the proper steps could potentially brick your phone.\n\n"
msgstr "未能遵循正確的步驟可能會導致您的手機變磚。\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will utilize\n\n"
msgstr "\n注意：按下 OK 按鈕將調用一個腳本，該腳本將使用\n\n"

msgid "fastboot commands, if your PC fastboot drivers are not properly setup,\n\n"
msgstr "fastboot 命令，如果您的 PC fastboot 驅動程式未正確設定，\n\n"

msgid "fastboot will wait forever, and PixelFlasher will appear hung.\n\n"
msgstr "fastboot 將永遠等待，PixelFlasher 將顯示為未回應。\n\n"

msgid "In such cases, killing the fastboot process will resume to normalcy.\n\n\n"
msgstr "在這種情況下，強制停止 fastboot 處理程序將恢復正常。\n\n\n"

msgid "      Do you want to continue to Lock the device bootloader?\n\n"
msgstr "      您是否要繼續鎖定裝置的 bootloader？\n\n"

msgid "              Press OK to continue or CANCEL to abort.\n\n"
msgstr "              按下 OK 繼續或按下 CANCEL 取消。\n\n"

msgid "      Do you want to continue to Unlock the device bootloader?\n\n"
msgstr "      您是否要繼續解鎖裝置的 bootloader？\n\n"

msgid "WARNING!!! This is an experimental feature to attempt disabling magisk modules.\n\n\n"
msgstr "警告！！！這是一個實驗性功能，旨在嘗試停用 magisk 模組。\n\n\n"

msgid "You would only need to do this if your device is bootlooping due to\n\n"
msgstr "您只有在裝置因不相容的 Magisk 模組而進入 bootloop 時才需要這樣做。\n\n"

msgid "incompatible magisk modules, this is not guaranteed to work in all cases (YMMV).\n\n"
msgstr "不相容的 Magisk 模組，這並不保證在所有情況下都能正常工作（YMMV）。\n\n"

msgid "\nNote: Pressing OK button will invoke a script that will wait forever to detect the device.\n\n"
msgstr "\n注意：按下 OK 按鈕將調用一個腳本，該腳本將永遠等待以偵測裝置。\n\n"

msgid "If your device is not detected PixelFlasher will appear hung.\n\n"
msgstr "如果您的裝置未被偵測到，PixelFlasher 將顯示為未回應。\n\n"

msgid "In such cases, killing the adb process will resume to normalcy.\n\n\n"
msgstr "在這種情況下，強制停止 adb 處理程序將恢復正常。\n\n\n"

msgid "                        Press OK to continue or CANCEL to abort.\n\n"
msgstr "                        按下 OK 繼續或按下 CANCEL 取消。\n\n"

msgid "Clear /data/adb/ contents"
msgstr "清除 /data/adb/ 內容"

msgid "WARNING!!! This will the clear contents of /data/adb\n\n\n"
msgstr "警告！！！這將清除 /data/adb 的內容\n\n\n"

msgid "Do you want to continue to clear /data/adb/ contents?\n\n"
msgstr "您是否要繼續清除 /data/adb/ 的內容？\n\n"

msgid "      Press OK to continue or CANCEL to abort.\n\n"
msgstr "      按下 OK 繼續或按下 CANCEL 取消。\n\n"

msgid "This will invoke the command adb kill-server.\nAre you sure want to continue?\n"
msgstr "這將調用命令 adb kill-server。\n您確定要繼續嗎？\n"

msgid "ADB Kill Server"
msgstr "ADB 停止服務"

msgid "Download Latest Android Platform-Tools"
msgstr "下載最新的 Android Platform-Tools"

msgid "Select Android Platform-Tools Folder\nWhere adb and fastboot are located.\n"
msgstr "選擇 Android Platform-Tools 資料夾\n其中包含 adb 和 fastboot。\n"

msgid "Double click this label to issue the command:\nadb kill-server"
msgstr "雙擊此標籤以發出命令：\nadb kill-server"

msgid "Open wireless manager dialog."
msgstr "打開無線管理器對話框。"

msgid "[root status] [device mode] [device id] [device model] [device firmware]\n\n"
msgstr "[root 狀態] [裝置模式] [裝置 ID] [裝置型號] [裝置韌體]\n\n"

msgid "✓ Rooted with Magisk.\n"
msgstr "✓ 已使用 Magisk 取得 root。\n"

msgid "✗ Probably Not Root (Magisk Tools not found).\n"
msgstr "✗ 可能未取得 root（未找到 Magisk 工具）。\n"

msgid "?  Unable to determine the root status.\n\n"
msgstr "?  無法確定 root 狀態。\n\n"

msgid "(adb) device is in adb mode\n"
msgstr "(adb) 裝置處於 adb 模式\n"

msgid "(f.b) device is in fastboot mode\n"
msgstr "(f.b) 裝置處於 fastboot 模式\n"

msgid "(sid) device is in sideload mode\n"
msgstr "(sid) 裝置處於 sideload 模式\n"

msgid "(rec) device is in recovery mode\n"
msgstr "(rec) 裝置處於 recovery 模式\n"

msgid "Scan for Devices\nPlease manually select the device after the scan is completed."
msgstr "掃描裝置\n請在掃描完成後手動選擇裝置。"

msgid "Device Image"
msgstr "裝置映像"

msgid "Download image file for current Pixel device."
msgstr "下載目前 Pixel 裝置的映像檔。"

msgid "Select Pixel Firmware"
msgstr "選擇 Pixel 韌體"

msgid "Process"
msgstr "處理"

msgid "Process the firmware file and extract the boot.img"
msgstr "處理韌體檔案並提取 boot.img"

msgid "Apply Custom ROM"
msgstr "套用客製化 ROM"

msgid "Caution: Make sure you read the selected ROM documentation.\nThis might not work for your ROM"
msgstr "注意：請確保您已閱讀所選 ROM 的文件。\n這可能不適用於您的 ROM"

msgid "Select Custom ROM"
msgstr "選擇客製化 ROM"

msgid "Process the ROM file and extract the boot.img"
msgstr "處理 ROM 檔案並提取 boot.img"

msgid "Select a boot/init_boot"
msgstr "選擇 boot/init_boot"

msgid "Show All boot/init_boot"
msgstr "顯示所有 boot/init_boot"

msgid "Show all boot/init_boot even if it is\nnot part of the selected firmware or ROM"
msgstr "顯示所有 boot/init_boot，即使它不是所選韌體或 ROM 的一部分"

msgid "Source SHA1  "
msgstr "來源 SHA1  "

msgid "Package Fingerprint  "
msgstr "套件 Fingerprint  "

msgid "Patched with version "
msgstr "已修補版本 "

msgid "Patch Method  "
msgstr "修補方法  "

msgid "Patched on Device  "
msgstr "已在裝置上修補  "

msgid "Date  "
msgstr "日期  "

msgid "Package Path  "
msgstr "套件路徑  "

msgid "Open Folder"
msgstr "打開資料夾"

msgid "Open boot files folder"
msgstr "打開 boot 檔案資料夾"

msgid "Open Working Directory"
msgstr "打開工作目錄"

msgid "Patch"
msgstr "修補"

msgid "Patch the selected item"
msgstr "修補所選項目"

msgid "Patch with Magisk"
msgstr "使用 Magisk 修補"

msgid "Patch with KernelSU"
msgstr "使用 KernelSU 修補"

msgid "Patch with KernelSU LKM"
msgstr "使用 KernelSU LKM 修補"

msgid "Patch with KernelSU-Next"
msgstr "使用 KernelSU-Next 修補"

msgid "Patch with KernelSU-Next LKM"
msgstr "使用 KernelSU-Next LKM 修補"

msgid "Patch with APatch"
msgstr "使用 APatch 修補"

msgid "Patch with APatch Alternate"
msgstr "使用 APatch Alternate 修補"

msgid "Patch custom boot/init_boot"
msgstr "修補自訂 boot/init_boot"

msgid "Delete"
msgstr "刪除"

msgid "Delete the selected item"
msgstr "刪除所選項目"

msgid "Add a new boot item"
msgstr "新增一個 boot 項目"

msgid "Info"
msgstr "資訊"

msgid "Get information about the selected item"
msgstr "取得所選項目的資訊"

msgid "Live Boot"
msgstr "臨時開機"

msgid "Live boot to the selected item"
msgstr "臨時開機到所選項目"

msgid "Flash Boot"
msgstr "刷寫 Boot"

msgid "Flash just the selected item"
msgstr "僅刷寫所選項目"

msgid "Flash Mode"
msgstr "刷機模式"

msgid "Keep Data"
msgstr "保留資料"

msgid "Data will be kept intact."
msgstr "資料將保持不變。"

msgid "WIPE all data"
msgstr "清除所有資料"

msgid "CAUTION: This will wipe your data"
msgstr "注意：這將清除您的資料"

msgid "Dry Run"
msgstr "模擬執行"

msgid ""
"Dry Run, no flashing will be done.\n"
"The phone will reboot to fastboot and then\n"
"back to normal.\n"
"This is for testing.\n"
msgstr ""
"模擬執行，不會進行刷寫。\n"
"手機將重新啟動到 fastboot，然後\n"
"再回到正常模式。\n"
"這是為了測試。\n"

msgid "Full OTA"
msgstr "完整 OTA"

msgid "Flash full OTA, and have the choice of flashing patched image(s)."
msgstr "刷寫完整 OTA，並可以選擇刷寫已修補的映像檔。"

msgid "Custom Flash"
msgstr "客製化刷寫"

msgid ""
"Custom Flash, Advanced option to flash a single file.\n"
"This will not flash the factory image.\n"
"It will flash the single selected file.\n"
msgstr ""
"客製化刷寫，進階選項，用於刷寫單個檔案。\n"

msgid "Live Boot to selected boot / init_boot"
msgstr "臨時開機到所選的 boot / init_boot"

msgid "Flash"
msgstr "刷寫"

msgid "Flashes the selected boot / init_boot"
msgstr "刷寫所選的 boot / init_boot"

msgid "Depending on the flash selection, paste the appropriate path as custom image."
msgstr "根據刷寫選擇，將適當的路徑貼上為自訂映像。"

msgid "Flash Options"
msgstr "刷寫選項"

msgid "Flash to inactive slot"
msgstr "刷寫到非活動槽"

msgid "This option when checked will flash to the alternate slot (inactive).\nKeeping the current slot intact.\n"
msgstr "選中此選項將刷寫到替代槽（非活動槽）。\n保持當前槽不變。\n"

msgid "Flash to both slots"
msgstr "刷寫到兩個槽"

msgid "This option when checked will flash to both slots."
msgstr "選中此選項將刷寫到兩個槽。"

msgid "Disable Verity"
msgstr "停用 Verity"

msgid "Disables Verity"
msgstr "停用 Verity"

msgid "Disable Verification"
msgstr "停用驗證"

msgid "Disables Verification"
msgstr "停用驗證"

msgid "Force"
msgstr "強制"

msgid "Force a flash operation that may be unsafe (will wipe your data)"
msgstr "強制執行可能不安全的刷寫操作（將清除您的資料）"

msgid "Verbose"
msgstr "詳細"

msgid "Set fastboot option to verbose"
msgstr "將 fastboot 選項設定為詳細"

msgid "Temporary Root"
msgstr "臨時 root"

msgid "Wipe"
msgstr "清除"

msgid ""
"This option when enabled will not flash patched boot\n"
"Instead it will flash unpatched boot.img, but boot to Live Patched boot\n"
"Handy to test if Magisk will cause a bootloop.\n"
"Please be aware that this temporary root will not survive a subsequent reboot.\n"
"If you want to make this permanent, just Flash Boot the patched boot image.\n"
msgstr ""
"這個選項啟用時不會刷寫已修補的 boot\n"
"而是刷寫未修補的 boot.img，但會啟動到臨時已修補的 boot\n"
"方便測試 Magisk 是否會導致啟動循環。\n"
"請注意，這個臨時 root 不會在隨後的重啟中保留。\n"
"如果您想要使其永久化，只需刷寫已修補的 boot 映像即可。\n"

msgid "No reboot"
msgstr "不重新啟動"

msgid "Do not reboot after flashing\nThis is useful if you want to perform other actions before reboot.\n"
msgstr "刷寫後不重新啟動\n如果您想在重新啟動之前執行其他操作，這將很有用。\n"

msgid "This will invoke data wipe operation at the end of custom flashing.\nOne use case would be when disabling verification for the first time.\n"
msgstr "這將在自訂刷寫結束時觸發資料清除操作。\n一個使用案例是在第一次停用驗證時。\n"

msgid "WARNING!!! This is a highly experimental feature.\nThis will attempt to downgrade the device without needing a data wipe.\n\n"
msgstr "警告！！！這是一個高度實驗性的功能。\n這將嘗試降級裝置，而無需清除資料。\n\n"

msgid "Flash Device"
msgstr "刷寫裝置"

msgid "Sideload OTA"
msgstr "Sideload OTA"

msgid "Custom Flash Device"
msgstr "客製化刷寫裝置"

msgid "Flashes the selected device with chosen flash options."
msgstr "使用選定的刷寫選項刷寫所選裝置。"

msgid "Console"
msgstr "控制台"

msgid "Please be patient ..."
msgstr "請耐心等候 ..."

msgid "Create encrypted and optionally sanitized support.zip file\nWhen sanitized all sensitive data is redacted.\n\nThis file is absolutely required when asking for help."
msgstr "建立加密的並且可選的已清理支援.zip 檔案\n當清理時，所有敏感資料都會被刪除。\n\n在尋求幫助時，絕對需要此檔案。"

msgid "Debug"
msgstr "除錯"

msgid "Enable Debug Messages in the console."
msgstr "在控制台中啟用除錯訊息。"

msgid "Clear Console"
msgstr "清除控制台"

msgid "**APK installation options**<br/>\n"
msgstr "**APK 安裝選項**<br/>\n"

msgid "This is a summary of available options.<br/>\n"
msgstr "這是可用選項的摘要。<br/>\n"

msgid "1. **Set ownership to Play Store Market** This option sets the ownership to Play Store (as if it was installed from Play Store).<br/>\n"
msgstr "1. **將擁有權設定為 Play 商店** 此選項將擁有權設定為 Play 商店（就像是從 Play 商店安裝的一樣）。<br/>\n"

msgid "   Android auto apps require that they be installed from the Play Market.<br/>\n"
msgstr "   Android Auto 應用程式要求必須從 Play 商店安裝。<br/>\n"

msgid "2. Starting with Android 14, apps with a targetSdkVersion lower than 23 can't be installed.<br/>\n"
msgstr "2. 從 Android 14 開始，目標 SDK 版本低於 23 的應用程式無法安裝。<br/>\n"

msgid "   Requiring apps to meet these minimum target API level requirements improves security and privacy for users.<br/><br/>\n"
msgstr "   要求應用程式符合這些最低目標 API 等級要求可提高使用者的安全性和隱私性。<br/><br/>\n"

msgid "   Malware often targets older API levels in order to bypass security and privacy protections that have been introduced in newer Android versions.<br/>\n"
msgstr "   惡意軟體通常會針對較舊的 API 等級，以繞過在較新 Android 版本中引入的安全性和隱私保護措施。<br/>\n"

msgid "   For example, some malware apps use a `targetSdkVersion` of 22 to avoid being subjected to the runtime permission model\n"
msgstr "   例如，一些惡意軟體應用程式使用 `targetSdkVersion` 22 來避免受到執行時權限的約束\n"

msgid "   introduced in 2015 by Android 6.0 Marshmallow (API level 23).<br/>\n"
msgstr "   這是在 2015 年由 Android 6.0 Marshmallow（API 等級 23）引入的。<br/>\n"

msgid "   This Android 14 change makes it harder for malware to avoid security and privacy improvements.<br/>\n"
msgstr "   這個 Android 14 的變更使得惡意軟體更難以繞過安全性和隱私的改進。<br/>\n"

msgid "   Attempting to install an app targeting a lower API level will result in an installation failure.<br/><br/>\n"
msgstr "   嘗試安裝目標 API 等級較低的應用程式將導致安裝失敗。<br/><br/>\n"

msgid "   **Bypass low target sdk block** option bypasses that enforcement.\n"
msgstr "   **繞過低目標 SDK 限制** 選項繞過了這一限制。\n"

msgid "_If you have selected multiple APKs to install, the options will apply to all APKs._\n"
msgstr "_如果您選擇了多個 APK 進行安裝，這些選項將適用於所有 APK。_\n"

msgid "**This feature will generate a device analysis report that you could optionally post online to get assistance on Play Integrity related issues.**<br/>\n"
msgstr "**此功能將生成裝置分析報告，您可以選擇將其在線發布，以取得有關 Play Integrity 相關問題的幫助。**<br/>\n"

msgid "- Device state and other device related details.\n"
msgstr "- 裝置狀態和其他裝置相關詳細資訊。\n"

msgid "- Magisk (if available):\n"
msgstr "- Magisk（如果可用）：\n"

msgid "	- modules list.\n"
msgstr "	- 模組列表。\n"

msgid "	- denylist.\n"
msgstr "	- 拒絕列表。\n"

msgid "- TrickyStore (if available):\n"
msgstr "- TrickyStore（如果可用）：\n"

msgid "	- `/data/adb/tricky_store/keybox.xml` (Not the contents, just if the certificates are revoked or not)\n"
msgstr "	- `/data/adb/tricky_store/keybox.xml`（不是內容，只是證書是否被撤銷）\n"

msgid "- PlayIntegrity Fork (if available):\n"
msgstr "- PlayIntegrity Fork（如果可用）：\n"

msgid "- PlayIntegrityFix (if available):\n"
msgstr "- PlayIntegrityFix（如果可用）：\n"

msgid "- Whether a testkey ROM is used or not.\n"
msgstr "- 是否使用測試金鑰 ROM。\n"

msgid "- logcat for PlayIntegrity and TrickyStore related logs.\n"
msgstr "- logcat 用於 PlayIntegrity 和 TrickyStore 相關日誌。\n"

msgid "- Droidguard VM list.\n"
msgstr "- Droidguard VM 列表。\n"

msgid "- If any custom ROM injection apps are installed from:\n"
msgstr "- 如果安裝了任何自定義 ROM 注入應用程式，來源為：\n"

msgid "- Check overlays (if contents of /debug_ramdisk is visible without root)\n"
msgstr "- 檢查 overlays（如果 /debug_ramdisk 的內容在未取得 root 權限的情況下可見）\n"

msgid "**NOTE:**\n"
msgstr "**備註：**\n"

msgid "This report will be saved at a location of your choosing, and will **not** be part of PixelFlasher captured logs (even though you see it in the console), so rest assured, if you submit support.zip for PixelFlasher related issues, even if you had generated such report, it will never be included in the support.zip file.<br/>\n"
msgstr "此報告將保存在您選擇的位置，並且**不**會成為 PixelFlasher 擷取日誌的一部分（即使您在控制台中看到它），因此請放心，如果您提交 support.zip 以解決與 PixelFlasher 相關的問題，即使您生成了此報告，它也永遠不會包含在 support.zip 文件中。<br/>\n"

msgid "Your privacy is yours to keep.<br/>\n"
msgstr "您的隱私由您自己保護。<br/>\n"

msgid "If you continue you'd only be generating the report, and not posting it online.<br/>\n"
msgstr "如果您繼續，只會生成報告，而不會將其發布到線上。<br/>\n"

msgid "If you want to post it online, please make sure to remove any sensitive information from the report before posting it online.<br/>\n"
msgstr "如果您想將其發布到線上，請確保在發布之前刪除報告中的任何敏感資訊。<br/>\n"

msgid "**Are you sure you want to continue?**<br/>\n"
msgstr "**您確定要繼續嗎？**<br/>\n"

##############################################################################
# Advanced Settings
##############################################################################
msgid "Advanced Configuration Settings"
msgstr "進階配置設定"

msgid "WARNING!\n"
msgstr "警告！\n"

msgid "This is advanced configuration.\n"
msgstr "這是進階配置。\n"

msgid "Unless you know what you are doing,\n"
msgstr "除非您知道自己在做什麼，\n"

msgid "you should not be enabling it.\n"
msgstr "否則您不應該啟用它。\n"

msgid "YOU AND YOU ALONE ARE RESPONSIBLE FOR ANYTHING THAT HAPPENS TO YOUR DEVICE.\n"
msgstr "您和您自己對您的裝置發生的任何事情負全責。\n"

msgid "THIS TOOL IS CODED WITH THE EXPRESS ASSUMPTION THAT YOU ARE FAMILIAR WITH\n"
msgstr "此工具的編碼明確假設您熟悉\n"

msgid "ADB, MAGISK, ANDROID, AND ROOT.\n"
msgstr "ADB、MAGISK、ANDROID 和 ROOT。\n"

msgid "IT IS YOUR RESPONSIBILITY TO ENSURE THAT YOU KNOW WHAT YOU ARE DOING.\n"
msgstr "確保您知道自己在做什麼是您的責任。\n"

msgid "Enable Advanced Options"
msgstr "啟用進階選項"

msgid "Expert mode"
msgstr "專家模式"

msgid "Magisk Package Name"
msgstr "Magisk 套件名稱"

msgid "If you have hidden Magisk,\nset this to the hidden package name."
msgstr "如果您隱藏了 Magisk，\n請將其設定為隱藏的套件名稱。"

msgid "Resets package name to default: %s"
msgstr "重設套件名稱為預設值：%s"

msgid "Linux File Explorer:"
msgstr "Linux 檔案總管："

msgid "Set full path to File Explorer.\nDefault: Nautilus"
msgstr "設定檔案總管的完整路徑。\n預設值：Nautilus"

msgid "Linux Shell:"
msgstr "Linux Shell："

msgid "Set full path to Linux Shell.\nDefault: gnome-terminal"
msgstr "設定 Linux Shell 的完整路徑。\n預設值：gnome-terminal"

msgid "Offer Patch Methods"
msgstr "提供補丁方法"

msgid "When patching the choice of method is presented."
msgstr "當打補丁時，會顯示方法選擇。"

msgid "Patching Recovery Partition"
msgstr "修補 Recovery 分區"

msgid ""
"Enabling this will show an option to patch a recovery partition.\n"
"This should be kept disabled unless you have an old device.\n"
"(most A-only devices launched with Android 9, legacy SAR)"
msgstr ""
"開啟此選項將顯示修補 Recovery 分區的選項。\n"
"這應該保持停用，除非您擁有舊裝置。\n"
"(大多數於 Android 9 發佈的 A-only 裝置，舊版 SAR)"

msgid "Use Busybox Shell"
msgstr "使用 Busybox Shell"

msgid "When creating a patch, if this is checked, busybox ash will be used as shell."
msgstr "當建立補丁時，如果選中此項，將使用 busybox ash 作為 shell。"

msgid "System has low memory"
msgstr "系統記憶體不足"

msgid "Use this option to sacrifice speed in favor of memory."
msgstr "使用此選項以犧牲速度來獲得更多記憶體。"

msgid "Extra img extraction"
msgstr "額外的映像檔提取"

msgid "When checked and available in payload.bin\nAlso extract vendor_boot.img, vendor_kernel_boot.img, dtbo.img, super_empty.img"
msgstr "當選中且在 payload.bin 中可用時，\n還會提取 vendor_boot.img、vendor_kernel_boot.img、dtbo.img、super_empty.img"

msgid "Show notifications"
msgstr "顯示通知"

msgid "When checked PixelFlasher will display system toast notifications."
msgstr "當選中時，PixelFlasher 將顯示系統 Toast 通知。"

msgid "Always create boot.tar"
msgstr "永遠建立 boot.tar"

msgid "When checked, PixelFlasher always creates boot.tar of the patched boot file.\nIf unchecked, only for Samsung firmware boot.tar will be created."
msgstr "當選中時，PixelFlasher 將始終為已修補的 boot 檔案建立 boot.tar。\n如果未選中，則僅為 Samsung 韌體建立 boot.tar。"

msgid "Check for updates"
msgstr "檢查更新"

msgid "Checks for available updates on startup"
msgstr "在啟動時檢查可用的更新"

msgid "Check for Minimum Disk (5Gb)"
msgstr "檢查最小磁碟空間 (5Gb)"

msgid "Enforces minimum disk space of 5 Gb to allow flashing.\nThis avoids storage related issues."
msgstr "強制要求最小磁碟空間為 5 Gb 以允許刷寫。\n這可以避免與儲存相關的問題。"

msgid "Check for bootloader unlocked"
msgstr "檢查 bootloader 是否解鎖"

msgid "Checks to make sure bootloader is unlocked before flashing."
msgstr "在刷寫之前檢查 bootloader 是否已解鎖。"

msgid "Check for firmware hash validity"
msgstr "檢查韌體哈希有效性"

msgid "Checks for sha256 portion to be in the image filename to detect Pixel compatible image."
msgstr "檢查映像檔案名稱中是否包含 sha256 部分，以偵測 Pixel 相容的映像檔。"

msgid "Keep temporary support files"
msgstr "保留臨時支援檔案"

msgid "It keeps the temporary support files.\nUseful for inspecting what data is included in support.zip."
msgstr "它保留臨時支援檔案。\n對於檢查 support.zip 中包含的資料非常有用。"

msgid "Check Magisk modules for updates"
msgstr "檢查 Magisk 模組是否有更新"

msgid ""
"It checks if the module has updates.\n"
"Disable this if you don't want to check for updates or\n"
" if some module update server has issues and delays the process."
msgstr ""
"它檢查模組是否有更新。\n"
"關閉此選項如果您不想檢查更新，或\n"
"如果某些模組更新伺服器有問題並延遲了過程。"

msgid "Show custom ROM options"
msgstr "顯示自訂 ROM 選項"

msgid "Make sure you check if your ROM is supported."
msgstr "請確保您檢查您的 ROM 是否受支援。"

msgid "Sanitize (Redact) support files"
msgstr "清理 (隱藏) 支援檔案"

msgid ""
"The support files are always encrypted.\n"
"This option redacts sensitive information from the support files.\n"
"But impedes support and is not recommended."
msgstr ""
"支援檔案總是加密的。\n"
"這個選項會隱藏支援檔案中的敏感資訊。\n"
"但會妨礙支援，不建議使用。"

msgid "Force codepage to"
msgstr "強制要求代碼頁為"

msgid "Uses specified code page instead of system code page"
msgstr "使用指定的代碼頁而不是系統代碼頁"

msgid "Delete bundled libs"
msgstr "刪除捆綁的庫"

msgid "The listed libraries would be deleted from the PF bundle to allow system defined ones to be used."
msgstr "列出的庫將從 PF 捆綁包中刪除，以允許使用系統定義的庫。"

msgid "Example: libreadline.so.8, libgdk*"
msgstr "範例: libreadline.so.8, libgdk*"

msgid "Override KMI"
msgstr "覆蓋 KMI"

msgid ""
"This will override the Kernel Module Interface (KMI) to the specified value.\n"
"This is useful for devices with custom kernels.\n"
"The value will be passed to KernelSU as the KMI value."
msgstr ""
"這將覆蓋內核模組介面 (KMI) 為指定的值。\n"
"這對於具有自訂內核的裝置很有用。\n"
"該值將作為 KMI 值傳遞給 KernelSU。"

msgid "Example: 5.15.131-android14"
msgstr "範例: 5.15.131-android14"

msgid "Use Custom Fontface"
msgstr "使用自訂字型"

msgid "Use custom font for monospace fonts\nMight require PixelFlasher restart to properly apply to the Console window."
msgstr "對於等寬字型使用自訂字型\n可能需要重新啟動 PixelFlasher 才能正確應用於控制台視窗。"

msgid "Sample "
msgstr "範例: "

msgid "Select font size"
msgstr "選擇字型大小"

msgid "scrcpy Path"
msgstr "scrcpy 路徑"

msgid "Download scrcpy"
msgstr "下載 scrcpy"

msgid "Scrcpy executable (*.exe;*)|*.exe;*"
msgstr "Scrcpy 可執行檔 (*.exe;*)|*.exe;*"

msgid "Select scrcpy executable"
msgstr "選擇 scrcpy 可執行檔"

msgid "Flags / Arguments (Example: --video-bit-rate 2M --max-fps=30 --max-size 1024)"
msgstr "標誌 / 參數 (範例: --video-bit-rate 2M --max-fps=30 --max-size 1024)"

msgid "Scrcpy settings"
msgstr "Scrcpy 設定"

##############################################################################
# Message dialogs and toasts (modules.py)
##############################################################################
msgid "Module update URL has issues, inform the module author: %s\nDo you want to skip checking updates for this module?"
msgstr "模組更新 URL 有問題，請通知模組作者: %s\n您想跳過檢查此模組的更新嗎？"

msgid "You have an old or problematic Android platform Tools version %s \n"
msgstr "您有一個舊的或有問題的 Android 平台工具版本 %s \n"

msgid "You are strongly advised to update before continuing.\n"
msgstr "強烈建議您在繼續之前進行更新。\n"

msgid "Are you sure you want to continue?"
msgstr "您確定要繼續嗎？"

msgid "Bad Android Platform Tools"
msgstr "不良的 Android 平台工具"

msgid "Android SDK Version:    %s\n"
msgstr "Android SDK 版本:    %s\n"

msgid "Device:                 %s %s %s\n"
msgstr "裝置:                 %s %s %s\n"

msgid "Factory Image:          %s\n"
msgstr "工廠映像:          %s\n"

msgid "Custom Rom:             %s\n"
msgstr "自訂 ROM:             %s\n"

msgid "Custom Rom File:        %s\n"
msgstr "自訂 ROM 檔案:        %s\n"

msgid "\nBoot image:             %s / %s \n"
msgstr "Boot 映像:             %s / %s \n"

msgid "                        From: %s\n"
msgstr "                        來源: %s\n"

msgid "                        Patched with %s on %s method:        %s\n"
msgstr "                        使用 %s 在 %s 方法上打補丁:        %s\n"

msgid "                        Patched with %s on %s\n"
msgstr "                        使用 %s 在 %s 方法上打補丁:        %s\n"

msgid "\nFlash Mode:             %s\n"
msgstr "刷寫模式:             %s\n"

msgid "SHA256 of %s%s matches the segment in the filename."
msgstr "SHA256 的 %s%s 與檔名中的段落相符。"

msgid "⚠️ Firmware SHA256 Mismatch"
msgstr "⚠️ 韌體 SHA256 不匹配"

msgid "WARNING! SHA256 of %s%s does not match segments in the filename.\nPlease double check to make sure the checksum is good."
msgstr "警告！SHA256 的 %s%s 與檔名中的段落不匹配。\n請仔細檢查以確保檢查和校驗碼是正確的。"

msgid "Process action"
msgstr "處理操作"

msgid "❌ Could not extract %s"
msgstr "❌ 無法提取 %s"

msgid "Possibly extracted firmware."
msgstr "可能已提取韌體。"

msgid "WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n"
msgstr "警告：看起來您已經提取了韌體檔案。\n並從中選擇了映像 zip。\n\n"

msgid "You should not extract the file, please select the downloaded firmware file instead\n\n"
msgstr "您不應該提取該檔案，請選擇下載的韌體檔案\n\n"

msgid "If this is not the case, and you want to continue with this selection\n"
msgstr "如果不是這種情況，並且您想繼續使用此選擇\n"

msgid "❌ Could not unpack %s."
msgstr "❌ 無法解壓縮 %s."

msgid "❌ Could not extract %s."
msgstr "❌ 無法提取 %s."

msgid "❌ Could not find %s."
msgstr "❌ 找不到 %s."

msgid "⚠️ Detected unsupported firmware."
msgstr "⚠️ 偵測到不支援的韌體。"

msgid "❌ Could not extract payload.bin."
msgstr "❌ 無法提取 payload.bin."

msgid "❌ The selected firmware is not valid."
msgstr "❌ 選擇的韌體無效。"

msgid "⚠️ Nothing to extract from %s"
msgstr "⚠️ 從 %s 中沒有東西可提取"

msgid "✅ Process %s time: %s seconds"
msgstr "✅ 處理 %s 時間: %s 秒"

msgid "WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?"
msgstr "警告：目標 boot.img 不是降級。\n您確定要繼續嗎？"

msgid "Confirm"
msgstr "確認"

msgid "Display is Locked!"
msgstr "顯示已鎖定！"

msgid "ERROR: Your phone display is Locked.\n\n"
msgstr "錯誤：您的手機顯示已鎖定。\n\n"

msgid "Make sure you unlock your display\n"
msgstr "請確保您解鎖顯示螢幕\n"

msgid "And set the display timeout to at least 1 minute.\n\n"
msgstr "並將顯示逾時設定為至少 1 分鐘。\n\n"

msgid "After doing so, Click OK to accept and continue.\n"
msgstr "完成後，單擊確定以接受並繼續。\n"

msgid "Manual Patching"
msgstr "手動打補丁"

msgid "Done creating the patch, continue"
msgstr "完成建立補丁，繼續"

msgid "Magisk Manager is not detected."
msgstr "未偵測到 Magisk Manager。"

msgid "WARNING: Magisk Manager [%s] is not found on the phone\n\n"
msgstr "警告：未在手機上找到 Magisk Manager [%s]\n\n"

msgid "This could be either because it is hidden, or it is not installed (most likely not installed)\n\n"
msgstr "這可能是因為它被隱藏，或者它未安裝（最有可能未安裝）\n\n"

msgid "If it is installed and hidden, then you should abort and then unhide it.\n"
msgstr "如果已安裝且被隱藏，則應中止操作並取消隱藏。\n"

msgid "If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n"
msgstr "如果未安裝 Magisk，PixelFlasher 可以為您安裝它並用於打補丁。\n\n"

msgid "WARNING: Do not install Magisk again if it is currently hidden.\n"
msgstr "警告：如果 Magisk 目前被隱藏，請勿再次安裝。\n"

msgid "Do you want PixelFlasher to download and install Magisk?\n"
msgstr "您希望 PixelFlasher 下載並安裝 Magisk 嗎？\n"

msgid "You will be given a choice of Magisk Version to install.\n\n"
msgstr "您將取得要安裝的 Magisk 版本的選擇。\n\n"

msgid "Click OK to continue with Magisk installation.\n"
msgstr "單擊確定以繼續進行 Magisk 安裝。\n"

msgid "Kernel KMI Override"
msgstr "內核 KMI 覆蓋"

msgid "Kernel KMI Override: %s\n\n"
msgstr "內核 KMI 覆蓋: %s\n\n"

msgid "You have set a custom kernel KMI override.\n"
msgstr "您已設定自定義內核 KMI 覆蓋。\n"

msgid "Are you sure you want to proceed with this override?\n"
msgstr "您確定要繼續此覆蓋嗎？\n"

msgid "Click OK to proceed with the override.\n"
msgstr "單擊確定以繼續進行覆蓋。\n"

msgid "Boot Model Mismatch"
msgstr "啟動模式不匹配"

msgid "APatch Manual Patching"
msgstr "APatch 手動打補丁"

msgid "APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n"
msgstr "APatch 手動打補丁需要在內核配置中啟用 CONFIG_KALLSYMS=y。\n"

msgid "APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n"
msgstr "APatch 手動打補丁僅支援內核版本 3.18 - 6.1\n\n"

msgid "Do you want to continue regardless of not meeting the pre-requisites?\n\n"
msgstr "您確定要繼續，即使不符合先決條件嗎？\n\n"

msgid "Click Yes to continue with APatch Manual Patching\n"
msgstr "單擊是以繼續進行 APatch 手動打補丁\n"

msgid "or Hit No to abort."
msgstr "或單擊否以中止。"

msgid "Download Latest KernelPatch Tools"
msgstr "下載最新的 KernelPatch 工具"

msgid "Latest KernelPatch Tools Pre-release Version: %s\n"
msgstr "最新的 KernelPatch 工具預發行版本: %s\n"

msgid "Latest KernelPatch Tools Release Version: %s\n\n"
msgstr "最新的 KernelPatch 工具發行版本: %s\n\n"

msgid "Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n"
msgstr "您希望下載最新的 kptools-android 和 kpimg-android，包括預發行版本嗎？\n\n"

msgid "Click Yes to download the latest pre-release versions: %s\n"
msgstr "單擊是以下載最新的預發行版本: %s\n"

msgid "Click No to download the latest Release versions: %s\n"
msgstr "單擊否以下載最新的發行版本: %s\n"

msgid "%s Boot"
msgstr "%s Boot"

msgid "ERROR: Your phone model is: %s\n\n"
msgstr "錯誤：您的手機型號為: %s\n\n"

msgid "The selected Boot is for: %s\n\n"
msgstr "所選的啟動映像適用於: %s\n\n"

msgid "Unless you know what you are doing, if you continue flashing\n"
msgstr "除非您知道自己在做什麼，否則如果繼續刷寫\n"

msgid "you risk bricking your device, proceed only if you are absolutely\n"
msgstr "您有可能會將裝置變磚，僅在您完全確定這是您想要的情況下繼續\n"

msgid "certain that this is what you want, you have been warned.\n\n"
msgstr "您已被警告，請確定這是您想要的。\n\n"

msgid "Flash action"
msgstr "刷寫操作"

msgid "❌ Device is not detected."
msgstr "❌ 未偵測到裝置。"

msgid "❌ Bootloader is locked, cannot flash."
msgstr "❌ Bootloader 已鎖定，無法刷寫。"

msgid "Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"
msgstr "您的 bootloader 已鎖定或您尚未授權 shell 處理程序 su 權限。\n您確定要繼續嗎？"

msgid "❌ Android Platform Tools is not set."
msgstr "❌ Android 平台工具未設定。"

msgid "❌ Valid device is not selected."
msgstr "❌ 未選擇有效的裝置。"

msgid "❌ boot is not selected."
msgstr "❌ 未選擇 boot。"

msgid "You can only sideload OTA that is equal or higher than the currently installed version.\n"
msgstr "您只能 sideload 與當前安裝版本相等或更高的 OTA。\n"

msgid "Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n"
msgstr "或者，您可以刷寫完整的韌體映像（並清除數據）以降級，或修補目前的啟動映像以允許在不清除的情況下降級。\n"

msgid "See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n"
msgstr "請參閱菜單項目：開發工具 | AVB 準備降級補丁以取得更多詳細訊息。\n\n"

msgid "If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n"
msgstr "如果您仍然想要繼續，請單擊是以接受並繼續。或單擊否以中止。\n"

msgid "You have selected to WIPE data\nAre you sure want to continue?"
msgstr "您已選擇清除數據\n您確定要繼續嗎？"

msgid "Wipe Data"
msgstr "清除數據"

msgid "✅ Wipe Data is accepted."
msgstr "✅ 清除數據已完成。"

msgid "You have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?"
msgstr "您已選擇刷寫選項：清除\n這將清除您的數據\n您確定要繼續嗎？"

msgid "Flash option: Wipe"
msgstr "刷寫選項：清除"

msgid "✅ Wipe is accepted."
msgstr "✅ 清除已完成。"

msgid "You have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?"
msgstr "您已選擇刷寫選項：強制\n這將清除您的數據\n您確定要繼續嗎？"

msgid "Flash option: Force"
msgstr "刷寫選項：強制"

msgid "✅ Force flag is accepted."
msgstr "✅ 強制標誌已接受。"

msgid "❌ Not enough disk space."
msgstr "❌ 磁碟空間不足。"

msgid "❌ Full OTA or factory image must be selected."
msgstr "❌ 必須選擇完整的 OTA 或工廠映像。"

msgid "Tensor device not on Android 13 or higher"
msgstr "❌ 搭載 Tensor 的裝置未執行 Android 13 或更高版本"

msgid "WARNING: Your phone OS version is lower than Android 13.\n\n"
msgstr "警告：您的手機作業系統版本低於 Android 13。\n\n"

msgid "If you are upgrading to Android 13 or newer,\n"
msgstr "如果您要升級到 Android 13 或更新版本，\n"

msgid "make sure you at least flash the bootloader to both slots.\n"
msgstr "請確保至少將 bootloader 刷寫到兩個槽位。\n"

msgid "The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n"
msgstr "Android 13 更新適用於 Pixel 6、Pixel 6 Pro 和 Pixel 6a，包含\n"

msgid "a bootloader update that increments the anti-roll back version for the bootloader.\n"
msgstr "一個 bootloader 更新，增加了 bootloader 的反回滾版本。\n"

msgid "This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n"
msgstr "這可以防止裝置回滾到先前易受攻擊的 bootloader 版本。\n"

msgid "After flashing an Android 13 build on these devices\n"
msgstr "在這些裝置上刷寫 Android 13 版本後\n"

msgid "you will not be able to flash and boot older Android 12 builds.\n\n"
msgstr "您將無法刷寫和啟動舊版 Android 12 構建。\n\n"

msgid "Selecting the option 'Flash to both slots'\n"
msgstr "選擇 '刷寫到兩個槽位' 選項\n"

msgid "Will take care of that.\n\n"
msgstr "將會處理這個問題。\n\n"

msgid "Click OK to continue as is.\n"
msgstr "單擊確定以繼續。"

msgid "or Hit CANCEL to abort and change options."
msgstr "或單擊取消以中止並更改選項。"

msgid "✅ Anti rollback warning acknowledged and bypassed."
msgstr "✅ 反回滾警告已確認並繞過。"

msgid "❌ downgrade_boot.img is not found."
msgstr "❌ 找不到 downgrade_boot.img。"

msgid "❌ Unable to replace boot.img in image.zip."
msgstr "❌ 無法替換 image.zip 中的 boot.img。"

msgid "⚠️ Live booting Pixel 7 or newer devices is not supported."
msgstr "⚠️ 不支援即時啟動 Pixel 7 或更新版本的裝置。"

msgid "❌ Image file is not selected."
msgstr "❌ 未選擇映像檔。"

msgid "❌ Boot file is not found."
msgstr "❌ 找不到 boot 檔案。"

msgid "❌ ROM file is not found."
msgstr "❌ 找不到 ROM 檔案。"

msgid "Device / Firmware Mismatch"
msgstr "裝置 / 韌體不匹配"

msgid "The selected firmware is for: %s\n\n"
msgstr "所選韌體適用於：%s\n\n"

msgid "✅ Device / Firmware mismatch acknowledged."
msgstr "✅ 裝置 / 韌體不匹配已確認。"

msgid "❌ Encountered an error while rebooting to bootloader."
msgstr "❌ 重新啟動到 bootloader 時遇到錯誤。"

msgid "❌ Encountered an error while rebooting to sideload."
msgstr "❌ 重新啟動到 sideload 時遇到錯誤。"

msgid "❌ Encountered an error while rebooting to fastbootd."
msgstr "❌ 重新啟動到 fastbootd 時遇到錯誤。"

msgid "❌ Encountered an error while running the flash script."
msgstr "❌ 執行刷寫腳本時遇到錯誤。"

msgid "❌ Encountered an error while flashing the patch."
msgstr "❌ 刷寫補丁時遇到錯誤。"

msgid "❌ vbmeta flashing did not return the expected result."
msgstr "❌ vbmeta 刷寫未返回預期結果。"

msgid "❌ It appears that OTA flashing did not properly switch slots."
msgstr "❌ 看起來 OTA 刷寫未正確切換槽位。"

msgid "⚠️ Device is not found after rebooting to bootloader."
msgstr "⚠️ 重新啟動到 bootloader 後找不到裝置。"

msgid "✅ Flashing elapsed time: %s seconds"
msgstr "✅ 刷寫耗時：%s 秒"

msgid "You have selected  WIPE option.\nAdb debugging will be reset and disabled\nHence patch or vbmeta flashing will be skipped."
msgstr "您已選擇 WIPE 選項。\nAdb 調試將被重置和停用\n因此將跳過補丁或 vbmeta 刷寫。"

msgid "%s %s \n"
msgstr "%s %s \n"

msgid "Device is not detected."
msgstr "❌ 找不到裝置。"

msgid "Done rebooting to bootloader, continue"
msgstr "完成重新啟動到 bootloader，繼續"

msgid "Done rebooting to system, continue"
msgstr "完成重新啟動到系統，繼續"

msgid "## Is your device waiting for interaction?\n"
msgstr "## 您的裝置是否在等待互動？\n"

msgid "_If it is not, please hit the cancel button._\n"
msgstr "_如果不是，請點擊取消按鈕。_\n"

msgid "If your device is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "如果您的裝置正在等待無法以程式方式調用的使用者互動。\n"

msgid "- Using volume keys, scroll up and down and select **Reboot %s**\n"
msgstr "使用音量鍵，上下滾動並選擇 **重新啟動 %s**\n"

msgid "- Press the power button to apply.\n"
msgstr "按下電源按鈕以套用。\n"

msgid "When done, the device should reboot to %s <br/>\n"
msgstr "完成後，裝置應該重新啟動到 %s <br/>\n"

msgid "Wait for the device to fully boot to %s <br/>\n"
msgstr "等待裝置完全啟動到 %s <br/>\n"

msgid "Click on **Done rebooting to %s, continue** button <br/>\n"
msgstr "單擊 **Done rebooting to %s, continue** 按鈕 <br/>\n"

msgid "or hit the **Cancel** button to abort.\n"
msgstr "或單擊 **Cancel** 按鈕以中止。\n"

msgid "Waiting for user interaction"
msgstr "等待裝置互動"

msgid "## Your watch should now be in Android Recovery\n"
msgstr "## 您的手錶現在應該在 Android Recovery 中\n"

msgid "The watch is waiting for user interaction which can not be programmatically invoked.\n"
msgstr "手錶正在等待無法以程式方式調用的使用者互動。\n"

msgid "- Using touch, scroll and select **Reboot to bootloader**\n"
msgstr "- 使用觸控，滾動並選擇 **Reboot to bootloader**\n"

msgid "- Press the side button to apply.\n"
msgstr "- 按下側邊按鈕以套用。\n"

msgid "When done, the watch should reboot to bootloader mode <br/>\n"
msgstr "完成後，手錶應該重新啟動到 bootloader 模式 <br/>\n"

msgid "Wait for the watch to indicate that it is in bootloader mode <br/>\n"
msgstr "等待手錶顯示它已進入 bootloader 模式 <br/>\n"

msgid "Click on **Done rebooting to bootloader, continue** button <br/>\n"
msgstr "單擊 **Done rebooting to bootloader, continue** 按鈕 <br/>\n"

msgid "- Using touch, scroll and select **Reboot to system now**\n"
msgstr "- 使用觸控，滾動並選擇 **Reboot to system now**\n"

msgid "When applied, the watch should reboot to system. <br/>\n"
msgstr "套用後，手錶應該重新啟動到系統。 <br/>\n"

msgid "Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n"
msgstr "當手錶操作系統完全載入時，單擊 **Done rebooting to system, continue** 按鈕。\n"

##############################################################################
# Pif Manager
##############################################################################
msgid "Active Pif"
msgstr "啟用的 Pif"

msgid "Loaded Pif (from Device)"
msgstr "已載入 Pif（來自裝置）"

msgid "Active pif is not modified."
msgstr "目前啟用的 Pif 未被修改。"

msgid "Save Active pif content to a json file on disk."
msgstr "將目前 Pif 內容保存到磁碟上的 json 文件。"

msgid "Pif Module"
msgstr "Pif 模組"

msgid "Active pif is not saved in favorites."
msgstr "目前啟用的 Pif 未被保存到收藏夾。"

msgid "Select a folder to import pif json files."
msgstr "選擇一個資料夾以導入 pif json 文件。"

msgid "Output"
msgstr "輸出"

msgid "Console Output:\nIt could be the json output of processed prop\nor it could be the Play Integrity Check result.\n\nThis is not what currently is on the device."
msgstr "控制台輸出：\n這可能是處理過的屬性的 json 輸出\n或者它可能是 Play Integrity Check 的結果。\n\n這不是目前在裝置上的內容。"

msgid "Smart Paste:\nSets First API to the set value if it is missing or forced.\nReprocesses the output window content to adapt to current module requirements.\nPastes to Active pif."
msgstr "智慧貼上：\n如果缺少或被強制，則將第一個 API 設定為設定的值。\n重新處理輸出窗口內容以適應目前模組要求。\n貼上到啟用的 pif。"

msgid "Paste the console window content to Active pif."
msgstr "將控制台窗口內容貼上到啟用的 pif。"

msgid "Paste the Active pif to console window."
msgstr "將啟用的 pif 貼上到控制台窗口。"

msgid "Reprocess current Active Pif window json.\nUseful if you changed module version which might require additional / different fields."
msgstr "重新處理目前啟用的 Pif 窗口 json。\n如果您更改了模組版本，可能需要額外/不同的欄位，這將很有用。"

msgid "Reprocess one or many json file(s)\nUseful if you changed module version which might require additional / different fields.\nIf a single file is selected, the new json will output to console output\nHowever if multiple files are selected, the selected file will be updated in place."
msgstr "重新處理一個或多個 json 文件\n如果您更改了模組版本，可能需要額外/不同的欄位，這將很有用。\n如果選擇了單個文件，新的 json 將輸出到控制台輸出\n但是如果選擇了多個文件，則選定的文件將就地更新。"

msgid "Process one or many json file(s) to generate the FrameworkPatcher formatted code excerpts.\n"
msgstr "處理一個或多個 json 文件以生成 FrameworkPatcher 格式的代碼摘錄。\n"

msgid "Add missing Keys from device"
msgstr "從裝置增加缺失的鍵"

msgid "When Processing or Reprocessing, add missing fields from device."
msgstr "在處理或重新處理時，從裝置增加缺失的欄位。"

msgid "Force First API to:"
msgstr "強制第一個 API 設定為："

msgid "Forces First API value(s) to"
msgstr "強制第一個 API 值為"

msgid "Sort Keys"
msgstr "排序鍵"

msgid "Sorts json keys"
msgstr "對 json 鍵進行排序"

msgid "Keep All keys"
msgstr "保留所有鍵"

msgid "Does not remove non standard / unrecognized keys"
msgstr "不會移除非標準/未識別的鍵"

msgid "Spoof Build"
msgstr "偽裝構建"

msgid "Spoof Props"
msgstr "偽裝 Props"

msgid "Spoof Provider"
msgstr "偽裝提供者"

msgid "Spoof Signature"
msgstr "偽造簽名"

msgid "Close"
msgstr "關閉"

msgid "Create print"
msgstr "建立輸出"

msgid "Create pif.json / spoof_build_vars"
msgstr "建立 pif.json / spoof_build_vars"

msgid "Push print, no validation"
msgstr "推送輸出，不進行驗證"

msgid "Pushes the print as is without performing any validation.\nThis is useful to retain comments."
msgstr "將輸出按照原樣推送，不進行任何驗證。\n這對保留註釋很有用。"

msgid "Reload print"
msgstr "重新載入輸出"

msgid "Reload pif.json / spoof_build_vars from device."
msgstr "重新載入 pif.json / spoof_build_vars 從裝置。"

msgid "Cleanup DG"
msgstr "清理 DG"

msgid "Cleanup Droidguard Cache"
msgstr "清理 Droidguard 快取"

msgid "Push keybox.xml"
msgstr "推送 keybox.xml"

msgid "Push a valid keybox.xml to device."
msgstr "推送有效的 keybox.xml 到裝置。"

msgid "Edit TS Target"
msgstr "編輯 TS 目標"

msgid "Edit Tricky Store target.txt file."
msgstr "編輯 Tricky Store target.txt 文件。"

msgid "Edit TS SP"
msgstr "編輯 TS SP"

msgid "Edit Tricky Store security_patch.txt file."
msgstr "編輯 Tricky Store security_patch.txt 文件。"

msgid "Process build.prop(s)"
msgstr "處理 build.prop(s)"

msgid "Process build.prop to extract a compatible print."
msgstr "處理 build.prop 以提取相容的輸出。"

msgid "Process bulk props"
msgstr "批量處理 props"

msgid "Process a folder containing .prop files and convert then to .json files."
msgstr "處理包含 .prop 文件的資料夾並將其轉換為 .json 文件。"

msgid "Process Image"
msgstr "處理映像"

msgid "Process an image and get a print from it."
msgstr "處理映像並從中取得輸出。"

msgid "Auto Update print"
msgstr "自動更新輸出"

msgid "After Processing build.props, the print is automatically pushed to the device and the GMS process is killed."
msgstr "在處理 build.props 後，輸出會自動推送到裝置，並終強制停止 GMS 處理程序。"

msgid "Auto Check Play Integrity"
msgstr "自動檢查 Play 完整性"

msgid "After saving (pushing) print, automatically run Play Integrity Check."
msgstr "在儲存（推送）輸出後，自動執行 Play 完整性檢查。"

msgid "Disable UIAutomator"
msgstr "關閉 UIAutomator"

msgid "Disables UIAutomator\nThis is useful for devices with buggy UIAutomator.\nNOTE: Create the coords.json file manually to make use of automated testing."
msgstr "停用 UIAutomator\n這對於有問題的 UIAutomator 裝置很有用。\n注意：請手動建立 coords.json 文件以利用自動化測試。"

msgid "Play Integrity Check"
msgstr "Play 完整性檢查"

msgid "Play Integrity API Checker\nNote: Need to install app from Play store."
msgstr "Play 完整性 API 檢查器\n注意：需要從 Play 商店安裝應用程式。"

msgid "Latest"
msgstr "最新"

msgid "Custom"
msgstr "自定義"

msgid "Select 'Latest' to get the latest Pixel beta pif (Includes Developer Preview).\nSelect 'Custom' to set a custom Android version code."
msgstr "選擇「最新」以取得最新的 Pixel beta pif（包括開發者預覽）。\n選擇「自定義」以設定自定義的 Android 版本代號。"

msgid "Set a valid Android version code."
msgstr "設定一個有效的 Android 版本代號"

msgid "Get Pixel Beta Pif"
msgstr "取得 Pixel Beta Pif"

msgid "Get the latest Pixel beta pif."
msgstr "取得最新的 Pixel beta pif。"

msgid "Get Xiaomi Pif"
msgstr "取得 Xiaomi Pif"

msgid "Get Xiaomi.eu pif\nEasy to start but is not recommended as it gets banned quickly.\nRecommended to find your own."
msgstr "取得 Xiaomi.eu pif\n容易開始，但不建議使用，因為它很快會被禁止。\n建議自己尋找。"

msgid "Get TheFreeman193 Random Pif"
msgstr "取得 TheFreeman193 隨機 Pif"

msgid "Get a random pif from TheFreeman193 repository.\nNote: The pif might or might not work."
msgstr "從 TheFreeman193 Repo 取得隨機 pif。\n注意：該 pif 可能有效，也可能無效。"

msgid "No Device is selected.\nPif Manager features are set to limited mode."
msgstr "未選擇任何裝置。\nPif 管理器功能已設定為有限模式。"

msgid "Device is not rooted or SU permissions to adb shell is not granted.\nPif Manager features are set to limited mode."
msgstr "裝置未獲得 root 權限或未授權 adb shell 的 SU 權限。\nPif 管理器功能已設定為有限模式。"

msgid "Update print"
msgstr "更新輸出"

msgid "Update pif.json / spoof_build_vars."
msgstr "更新 pif.json / spoof_build_vars。"

msgid "Create pif.json / spoof_build_vars."
msgstr "建立 pif.json / spoof_build_vars。"

msgid "Getting Pixel beta print ...\nPlease be patient this could take some time ..."
msgstr "正在取得 Pixel beta 輸出 ...\n請耐心等候，這可能需要一些時間 ..."

msgid "Failed to get beta print."
msgstr "無法取得 beta 輸出。"

msgid "Active pif not in sync"
msgstr "活動 pif 與目前內容不同步"

msgid "⚠️ WARNING! Device pif is not in sync with Active Pif contents.\nThe result will not be reflective of the Active pif you're viewing."
msgstr "⚠️ 警告！裝置 pif 與目前的啟用 pif 內容不同步。\n結果將不反映您正在查看的啟用 pif。"

msgid "Choose property files to open"
msgstr "選擇要打開的 property 文件"

msgid "Select a Device Image"
msgstr "選擇裝置映像"

msgid "Processing %s ...\nPlease be patient this could take some time ..."
msgstr "正在處理 %s ...\n請耐心等候，這可能需要一些時間 ..."

msgid "Image format not supported"
msgstr "不支援的映像格式"

msgid "Select folder to bulk process props files"
msgstr "選擇資料夾以批量處理 props 文件"

msgid "The contents is different than what is currently on the device.\nUpdate the print before testing."
msgstr "內容與目前裝置上的內容不同。\n在測試之前請更新輸出。"

msgid "Active pif is saved in favorites."
msgstr "活動 pif 已儲存至最愛。"

msgid "Select keybox to push"
msgstr "選擇要推送的 keybox"

msgid "Choose one or multiple json files to reprocess"
msgstr "選擇一個或多個 json 文件以重新處理"

msgid "Save FP file"
msgstr "儲存 FP 文件"

msgid "Enter a label:"
msgstr "輸入標籤："

msgid "Save Pif to Favorites"
msgstr "儲存 Pif 至最愛"

msgid "Select folder to Import Pifs"
msgstr "選擇資料夾以匯入 Pifs"

##############################################################################
# Magisk
##############################################################################
msgid "❌ ERROR: You must first select a valid device."
msgstr "❌ 錯誤：您必須先選擇一個有效的裝置。"

msgid "Manage Magisk"
msgstr "管理 Magisk"

msgid "When you press the OK button, the Modules with checkbox selected will be enabled and the rest will be disabled."
msgstr "當您按下確定按鈕時，選中的模組將被啟用，其餘模組將被停用。"

msgid "Magisk Modules"
msgstr "Magisk 模組"

msgid "Enable / Disable Magisk modules"
msgstr "啟用 / 停用 Magisk 模組"

msgid "Install Module"
msgstr "安裝模組"

msgid "Install magisk module."
msgstr "安裝 magisk 模組。"

msgid "Update Module"
msgstr "更新模組"

msgid "Update magisk module."
msgstr "更新 magisk 模組。"

msgid "Uninstall Module"
msgstr "解除安裝模組"

msgid "Uninstall magisk module."
msgstr "解除安裝 magisk 模組。"

msgid "Run Action"
msgstr "執行 Action"

msgid "Run Module action.sh."
msgstr "執行模組 action.sh。"

msgid "Install Pif / TS Module"
msgstr "安裝 Pif / TS 模組"

msgid "Install Play Integrity Fix related modules."
msgstr "安裝 Play Integrity Fix 相關模組。"

msgid "Install ZygiskNext Module"
msgstr "安裝 ZygiskNext 模組。"

msgid "Install ZygiskNext module."
msgstr "安裝 ZygiskNext 模組。"

msgid "Systemless Hosts"
msgstr "系統無關的 Hosts"

msgid "Add Systemless Hosts Module."
msgstr "新增系統無關的 Hosts 模組。"

msgid "Enable Zygisk"
msgstr "啟用 Zygisk"

msgid "Enable Magisk zygisk (requires reboot)"
msgstr "啟用 Magisk zygisk（需要重新啟動）"

msgid "Disable Zygisk"
msgstr "停用 Zygisk"

msgid "Disable Magisk zygisk (requires reboot)"
msgstr "停用 Magisk zygisk（需要重新啟動）"

msgid "Enable Denylist"
msgstr "啟用 Denylist"

msgid "Enable Magisk denylist"
msgstr "啟用 Magisk denylist"

msgid "Disable Denylist"
msgstr "停用 Denylist"

msgid "Disable Magisk denylist"
msgstr "停用 Magisk denylist"

msgid "Refresh"
msgstr "重新整理"

msgid "Refresh Magisk modules list."
msgstr "重新整理 Magisk 模組列表。"

msgid "To manage denylist or to manage SU permissions, use PixelFlasher's App Manager feature."
msgstr "要管理 denylist 或管理 SU 權限，請使用 PixelFlasher 的應用程式管理器功能。"

msgid "Use Pixelflasher's App Manager functionality to add/remove items to denylist or su permissions."
msgstr "使用 Pixelflasher 的應用程式管理器功能來新增/移除 denylist 或 su 權限的項目。"

msgid "Restore Module"
msgstr "還原模組"

msgid "## You need to reboot your device for the changes to take effect."
msgstr "## 您需要重新啟動裝置以使更改生效。"

msgid "osm0sis PlayIntegrityFork"
msgstr "osm0sis PlayIntegrityFork"

msgid "chiteroman PlayIntegrityFix"
msgstr "chiteroman PlayIntegrityFix"

msgid "PIF Module"
msgstr "PIF 模組"

msgid "Select the module you want to install"
msgstr "選擇要安裝的模組"

msgid "## You need to reboot your device to complete the installation."
msgstr "## 您需要重新啟動裝置以完成安裝。"

msgid "## You need to reboot your device to complete the update."
msgstr "## 您需要重新啟動裝置以完成更新。"

msgid "Copy"
msgstr "複製"

msgid "Select All"
msgstr "全選"

msgid "Superuser Access"
msgstr "超級用戶存取"

msgid "Superuser Access (requires reboot)"
msgstr "超級用戶存取（需要重新啟動）"

msgid "Apps Only"
msgstr "僅限應用程式"

msgid "ADB Only"
msgstr "僅限 ADB"

msgid "Apps and ADB"
msgstr "應用程式和 ADB"

msgid "Disabled"
msgstr "停用"

##############################################################################
# Rooting App
##############################################################################
msgid "Download and Install Rooting Application"
msgstr "下載並安裝 Rooting 應用程式"

msgid "Select rooting app to install."
msgstr "選擇要安裝的 Rooting 應用程式。"

msgid "Root App"
msgstr "Root 應用程式"

msgid "Version"
msgstr "版本"

msgid "VersionCode"
msgstr "版本代號"

msgid "URL"
msgstr "URL"

msgid "Package"
msgstr "套件"

msgid "WARNING! Do not install magisk if you already have a hidden (stub) Magisk installed.\nFirst unhide Magisk before attempting an install."
msgstr "警告！如果您已經安裝了隱藏（stub）Magisk，請不要安裝 Magisk。\n請先取消隱藏 Magisk，然後再嘗試安裝。"

msgid "Download the rooting app."
msgstr "下載 Rooting 應用程式。"

msgid "Copy URL to Clipboard"
msgstr "複製 URL 到剪貼簿"

msgid "Copy Package ID to Clipboard"
msgstr "複製套件 ID 到剪貼簿"

msgid "Download Selected Rooting App"
msgstr "下載選定的 Rooting 應用程式"

msgid "Device Not Supported"
msgstr "裝置不支援"

msgid "The selected Magisk is not supported for your device\n"
msgstr "所選的 Magisk 不支援您的裝置\n"

msgid "Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n"
msgstr "目前僅支援 Pixel 7（panther）、Pixel 7 Pro（cheetah）、Pixel 7a（lynx）和 Pixel Tablet（tangorpro）。\n\n"

msgid "Unless you know what you are doing, if you choose to continue\n"
msgstr "除非您知道自己在做什麼，否則如果您選擇繼續\n"

msgid "you risk running into serious issues, proceed only if you are absolutely\n"
msgstr "您可能會遇到嚴重問題，僅在您完全了解情況下才繼續。"

##############################################################################
# Magisk Backup Manager
##############################################################################
msgid "Check / Uncheck All"
msgstr "全選 / 取消全選"

msgid "Delete checked backups"
msgstr "刪除已選擇的備份"

msgid "Add Backup from Computer"
msgstr "從電腦新增備份"

msgid "Select a boot.img and create a backup from it.\nWARNING! No verification is done if the selected file is stock boot image or even for the correct device."
msgstr "選擇一個 boot.img 並從中建立備份。\n警告！如果所選文件是 stock boot image，甚至是正確的設備，則不會進行任何驗證。"

msgid "Auto Create Backup"
msgstr "自動建立備份"

msgid "Checks current boot partition,\nFf it is a Magisk Patched with SHA1\nand the boot.img is available, then it\nAutomatically creates a backup of boot image."
msgstr "檢查目前啟動分區，\n如果它是帶有 SHA1 的 Magisk 修補，\n並且 boot.img 可用，則會自動建立 boot 映像的備份。"

msgid "Closes this dialog"
msgstr "關閉此對話框"

msgid "boot / init_boot image to create backup of."
msgstr "要建立備份的 boot / init_boot 映像。"

msgid "Delete Backup"
msgstr "刪除備份"

msgid "Check All"
msgstr "全選"

msgid "UnCheck All"
msgstr "取消全選"

msgid "Copy to Clipboard"
msgstr "複製到剪貼簿"

##############################################################################
# App Manager
##############################################################################
msgid "Set SU Permission"
msgstr "設定 SU 權限"

msgid "Enter SU Permission details:"
msgstr "輸入 SU 權限詳細資訊："

msgid "Enable Notification"
msgstr "啟用通知"

msgid "Enable Logging"
msgstr "啟用日誌記錄"

msgid "Forever"
msgstr "永遠"

msgid "10 mins"
msgstr "10 分鐘"

msgid "20 mins"
msgstr "20 分鐘"

msgid "30 mins"
msgstr "30 分鐘"

msgid "60 mins"
msgstr "60 分鐘"

msgid "Allow"
msgstr "允許"

msgid "Deny"
msgstr "拒絕"

msgid "Revoke"
msgstr "撤銷"

msgid "Manage Packages on the Device"
msgstr "管理裝置上的套件"

msgid "%s Packages"
msgstr "%s 套件"

msgid "Show System apps"
msgstr "顯示系統應用程式"

msgid "Show 3rd Party apps"
msgstr "顯示第三方應用程式"

msgid "Get All Application Names"
msgstr "取得所有應用程式名稱"

msgid "Extracts App names, and caches them for faster loading in the future.\nNOTE: This could take a while."
msgstr "提取應用程式名稱，並將其快取以便未來更快加載。\n注意：這可能需要一段時間。"

msgid "Disable"
msgstr "停用"

msgid "Disable checked packages"
msgstr "停用已選擇的套件"

msgid "Enable"
msgstr "啟用"

msgid "Enable checked packages"
msgstr "啟用已選擇的套件"

msgid "Uninstall"
msgstr "解除安裝"

msgid "Uninstall checked packages"
msgstr "解除安裝已選擇的套件"

msgid "Add to Denylist"
msgstr "加入拒絕列表"

msgid "Add package to Magisk Denylist"
msgstr "將套件加入 Magisk 拒絕列表"

msgid "Remove from Denylist"
msgstr "從拒絕列表中移除"

msgid "Remove package from Magisk Denylist"
msgstr "從 Magisk 拒絕列表中移除套件"

msgid "Install an APK on the device"
msgstr "在裝置上安裝 APK"

msgid "Download APK"
msgstr "下載 APK"

msgid "Extract and download APK"
msgstr "提取並下載 APK"

msgid "Export List"
msgstr "匯出清單"

msgid "Export the package list in CSV format"
msgstr "以 CSV 格式匯出套件清單"

msgid "%s / %s Packages"
msgstr "%s / %s 套件"

msgid "Export Package list"
msgstr "匯出套件清單"

msgid "Choose a directory where all apks should be saved."
msgstr "選擇一個目錄以儲存所有 APK。"

msgid "Download APK file"
msgstr "下載 APK 檔案"

msgid "Disable Package"
msgstr "停用套件"

msgid "Enable Package"
msgstr "啟用套件"

msgid "Uninstall Package"
msgstr "解除安裝套件"

msgid "Download Package"
msgstr "下載套件"

msgid "Launch Package"
msgstr "啟動套件"

msgid "View Application Permissions"
msgstr "查看應用程式權限"

msgid "Kill Application"
msgstr "強制停止應用程式"

msgid "Clear Application Data"
msgstr "清除應用程式資料"

msgid "Add Package to Magisk Denylist"
msgstr "將套件加入 Magisk 拒絕列表"

msgid "Remove Package from Magisk Denylist"
msgstr "從 Magisk 拒絕列表中移除套件"

msgid "SU Permission ..."
msgstr "SU 權限 ..."

msgid "Before switching slots, please make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "在切換槽之前，請確保您的設備不受 ARB 問題的影響。\n您確定要繼續嗎？"

msgid "Switch Slot potential concerns"
msgstr "切換槽的潛在問題"

msgid "## ⚠️ WARNING: You have selected to flash both slots.<br/>\n"
msgstr "## ⚠️ 警告：您已選擇同時刷寫兩個槽位。<br/>\n"

msgid "Please make sure your device is not subject to ARB concerns before clicking continue.<br/>\n"
msgstr "在點擊繼續之前，請確保您的設備不受 ARB 問題的影響。<br/>\n"

msgid "You have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"
msgstr "您已選擇的刷寫選項：同時刷寫兩個槽位\n請確保您的設備不受 ARB 問題的影響。\n您確定要繼續嗎？"

msgid "Flash option: Flash to both slots"
msgstr "刷寫選項：同時刷寫兩個槽位"

msgid "✅ Flash to both slots is accepted."
msgstr "✅ 同時刷寫兩個槽位已被接受。"

msgid "Open URL on Device"
msgstr "在裝置上打開 URL"

msgid "Enter the URL to open on the device:"
msgstr "輸入要在裝置上打開的 URL："

msgid "Open URL"
msgstr "打開 URL"

msgid "Open a URL in the default browser"
msgstr "在預設瀏覽器中打開 URL"

##############################################################################
# Additions 2025-07-20
##############################################################################
msgid "Keep Temp Files"
msgstr "保留暫存檔案"

msgid "Enabling this will keep temporary files used for patching.\nThis is useful for debugging purposes.\nIt is recommended to keep this disabled."
msgstr "開啟此選項將保留用於修補的暫存檔案。\n這對於偵錯的目的很有用。\n建議保持此選項為停用狀態。"

msgid "Logcat"
msgstr "日誌"

msgid "Logcat Viewer"
msgstr "日誌檢視器"

msgid "Logcat filter: update_engine"
msgstr "日誌過濾器：update_engine"

msgid "Logcat filtered for update_engine to monitor OTA merging"
msgstr "日誌過濾器：update_engine\n用於監控 OTA 合併"

msgid "Bootloader Versions"
msgstr "Bootloader 版本"

msgid "Get Bootloader Versions"
msgstr "取得 Bootloader 版本"

msgid "Formatting Options"
msgstr "格式化選項"

msgid "Enable formatting (-v)"
msgstr "啟用格式化 (-v)"

msgid "Enable or disable formatting options for logcat output"
msgstr "啟用或停用 logcat 輸出的格式化選項"

msgid "Format Verbs"
msgstr "格式化詳細輸出"

msgid "Show priority, tag, and PID of the process issuing the message"
msgstr "顯示發出消息的處理程序的優先級、標籤和 PID"

msgid "Show all metadata fields and separate messages with blank lines"
msgstr "顯示所有 metadata 欄位，並用空行分隔訊息"

msgid "Show PID only"
msgstr "僅顯示 PID"

msgid "Show the raw log message with no other metadata fields"
msgstr "顯示原始日誌訊息，不包含其他 metadata 欄位"

msgid "Show the priority and tag only"
msgstr "僅顯示優先級和標籤"

msgid "Show priority, PID, and TID of the thread issuing the message"
msgstr "顯示發出消息的執行緒的優先級、PID 和 TID"

msgid "Show date, time, priority, tag, PID, and TID (default)"
msgstr "顯示日期、時間、優先級、標籤、PID 和 TID（預設）"

msgid "Show date, time, priority, tag, and PID of the process"
msgstr "顯示日期、時間、優先級、標籤和 PID（預設）"

msgid "Adverb Modifiers"
msgstr "Adverb 修飾符"

msgid "Show each priority with a different color"
msgstr "顯示每個優先級的不同顏色"

msgid "Show event descriptions from event-log-tags database"
msgstr "顯示來自 event-log-tags 資料庫的事件描述"

msgid "Show time as seconds since 1970-01-01 (Unix epoch)"
msgstr "顯示自 1970-01-01（Unix 紀元）以來的秒數"

msgid "Show time as CPU seconds since boot"
msgstr "顯示自啟動以來的 CPU 秒數"

msgid "Ensure that any binary logging content is escaped"
msgstr "確保任何二進位日誌內容都已轉義"

msgid "Show UID or Android ID of logged process (if permitted)"
msgstr "顯示已登錄處理程序的 UID 或 Android ID（如果允許）"

msgid "Show time with microsecond precision"
msgstr "顯示微秒精度的時間"

msgid "Filter Options"
msgstr "過濾器選項"

msgid "Tag Filter"
msgstr "標籤過濾器"

msgid "Tag:"
msgstr "標籤："

msgid "Enter log component tag (or * for all)"
msgstr "輸入日誌組件標籤（或 * 代表全部）"

msgid "Priority Level"
msgstr "優先級"

msgid "Verbose (default for specific tag)"
msgstr "詳細（特定標籤的預設）"

msgid "Debug (default for *)"
msgstr "偵錯（* 的預設）"

msgid "Warn"
msgstr "警告"

msgid "Fatal"
msgstr "致命"

msgid "Silent (suppress all output)"
msgstr "安靜（抑制所有輸出）"

msgid "Additional Filters"
msgstr "附加過濾器"

msgid "Regex Filter (-e):"
msgstr "正則表達式過濾器 (-e)："

msgid "Enter ECMAScript regex to filter output"
msgstr "輸入 ECMAScript 正則表達式以過濾輸出"

msgid "UIDs Filter (comma-separated):"
msgstr "UID 過濾器（以逗號分隔）："

msgid "Enter UIDs (numeric, comma-separated)"
msgstr "輸入 UIDs（數字，以逗號分隔）"

msgid "View Logcat"
msgstr "查看 Logcat"

msgid "View logcat output with selected options"
msgstr "查看 logcat 輸出，使用所選選項"

msgid "Clear Logcat"
msgstr "清除 Logcat"

msgid "Clear logcat buffer"
msgstr "清除 logcat 緩衝區"

msgid "Close this panel"
msgstr "關閉此面板"

msgid "No device connected"
msgstr "未連接裝置"

msgid "Logcat buffer cleared"
msgstr "logcat 緩衝區已清除"

##############################################################################
# Additions 2025-09-08
##############################################################################
msgid "Select Package for TargetedFix Target"
msgstr "為針對性修正目標選擇套件"

msgid "Add Target"
msgstr "新增目標"

msgid "Add selected package as TargetedFix target"
msgstr "將選定的套件新增為針對性修正目標"

msgid "Get Application Names"
msgstr "取得應用程式名稱"

msgid "TF Targets"
msgstr "針對性修正目標"

msgid "TargetedFix Targets"
msgstr "針對性修正目標"

msgid "Add TF Target"
msgstr "新增針對性修正目標"

msgid "Add a new TargetedFix target by selecting from package list on device"
msgstr "從裝置上的套件列表中選擇，新增一個新的針對性修正目標"

msgid "Delete TF Target"
msgstr "刪除針對性修正目標"

msgid "Delete the selected TargetedFix target"
msgstr "刪除選定的針對性修正目標"

msgid "Edit TF Targets"
msgstr "編輯針對性修正目標"

msgid "Edit TargetedFix targets file"
msgstr "編輯針對性修正目標檔案"

msgid "Push TF Json"
msgstr "推送針對性修正 Json"

msgid "Push Active pif content as JSON to the selected TargetedFix target"
msgstr "將活動 pif 內容作為 JSON 推送到選定的針對性修正目標"

msgid "Auto run migrate.sh"
msgstr "自動執行 migrate.sh"

msgid "After saving (pushing) print, automatically run migrate.sh"
msgstr "在儲存（推送）輸出後，自動執行 migrate.sh"

msgid "	- Contents of every app json configuration referenced in target.txt\n"
msgstr "	- 每個在 target.txt 中引用的應用程式 json 配置的內容\n"

##############################################################################
# Additions 2025-09-24
##############################################################################
msgid "There will be two versions created.<br/>\n"
msgstr "將會建立兩個版本。<br/>\n"

msgid "1. Unfiltered version, that would have some sensitive information such as Device ID.\n"
msgstr "1. 未過濾的版本，將包含一些敏感資訊，例如裝置 ID。\n"

msgid "2. Sanitized version which will filter out sensitive information<br/>\n"
msgstr "2. 已清理的版本，將過濾掉敏感資訊<br/>\n"

msgid "**Note:** If you're using publicly shared keybox, keep the checkbox `Redact Keybox details` unticked so that the keybox information is included in the report.<br/>\n"
msgstr "**注意：** 如果您使用的是公開共享的 keybox，請保持 `Redact Keybox details` 核取方塊未選中，以便在報告中包含 keybox 資訊。<br/>\n"

msgid "If you're using a private keybox, please tick the checkbox `Redact Keybox details` to redact keybox details.<br/>\n"
msgstr "**注意：** 如果您使用的是私人 keybox，請勾選 `Redact Keybox details` 核取方塊以隱藏 keybox 詳細資訊。<br/>\n"

msgid "**This report will include the following details:**<br/>\n"
msgstr "**此報告將包含以下詳細資訊：**<br/>\n"

msgid "- Playstore and GMS versions.\n"
msgstr "- Playstore 和 GMS 版本。\n"

msgid "Redact Keybox details"
msgstr "隱藏 Keybox 詳細資訊"

##############################################################################
# Additions 2025-10-01
##############################################################################
msgid "Patch with SukiSU"
msgstr "使用 SukiSU 打補丁"

msgid "Patch with SukiSU LKM"
msgstr "使用 SukiSU LKM 打補丁"

msgid "Select a pre-built kernel flavor"
msgstr "選擇預建的內核風味"

msgid "ShirkNeko flavor kernel"
msgstr "ShirkNeko 風味內核"

msgid "MiRinFork flavored kernel"
msgstr "MiRinFork 風味內核"

msgid "WildKernels"
msgstr "WildKernels"

##############################################################################
# Additions 2025-10-05
##############################################################################
msgid "Convert console content from env (key=value) prop format to json"
msgstr "轉換控制台內容從 env（key=value）prop 格式到 json"

msgid "Convert console content from json to env (key=value) prop format"
msgstr "轉換控制台內容從 json 到 env（key=value）prop 格式"

##############################################################################
# Additions 2025-10-11
##############################################################################
msgid "Download / Install rooting app like Magisk or KernelSU* or APatch or SukiSU or Wild_KSU"
msgstr "下載 / 安裝 Rooting 應用程式，如 Magisk 或 KernelSU* 或 APatch 或 SukiSU 或 Wild_KSU"

msgid "Push TF Prop"
msgstr "推送針對性修正 Prop"

##############################################################################
# Additions 2025-10-18
##############################################################################
msgid "Select Device"
msgstr ""

msgid "Select a device:"
msgstr ""

msgid "Unknown"
msgstr ""

msgid "PixelFlasher guessed Kernel KMI"
msgstr ""

msgid "Your device kernel KMI is unknown probably because you're using\n"
msgstr ""

msgid "a custom kernel which has stripped out the Android build tag.\n\n"
msgstr ""

msgid "PixelFlasher has guessed the Kernel KMI to be: %s\n\n"
msgstr ""

msgid "Are you sure you want to proceed with this guessed KMI?\n"
msgstr ""

##############################################################################
# Additions 2025-11-03
##############################################################################

msgid "The selected path contains single quotes (').\n\nPlease rename the folder to remove the single quotes and try again."
msgstr ""

msgid "Options"
msgstr ""

msgid "Additional Options"
msgstr ""

msgid "Select Option"
msgstr ""

msgid "⚠️ WARNING: With Option 3, fingerprint can't be patched."
msgstr ""

msgid " (Recommended)"
msgstr ""

msgid "Latest Release"
msgstr ""

msgid "Latest Pre-Release"
msgstr ""

msgid "Latest Release or Pre-Release"
msgstr ""

msgid "Let me choose the kernel version from a matching list"
msgstr ""

msgid "Show all assets including non-matching ones"
msgstr ""

msgid "Flash to active slot"
msgstr ""

msgid "Flash boot partition"
msgstr ""

msgid "Flash init_boot partition"
msgstr ""

msgid "Flash vendor_boot partition"
msgstr ""

msgid "No Reboot after flash"
msgstr ""

msgid "## ✅ Live Boot the stock image:\n"
msgstr ""

msgid "## ✅ Live Boot the patched image:\n"
msgstr ""

msgid "## ❌ Live Booting is only supported for boot partition.\n"
msgstr ""

msgid "## ❌ Valid image is not found that supports live booting.\n"
msgstr ""

msgid "## ℹ️ Select partitions that you wish to flash stock image\n"
msgstr ""

msgid "## ℹ️ Select the options to flash a patch image:\n"
msgstr ""

msgid "## ❌ The selected image is not valid.<br/>\n"
msgstr ""

msgid "Edit script before continuing"
msgstr ""

##############################################################################
# Additions 2025-12-28
##############################################################################

##############################################################################
# Download Progress Window
##############################################################################
msgid "Downloading: %s"
msgstr ""

##############################################################################
# File Editor Window
##############################################################################
msgid "Open Shell"
msgstr ""

msgid "Save and Continue"
msgstr ""

msgid "Cancel and Abort"
msgstr ""

msgid "Open Folder in working directory"
msgstr ""

msgid "Open command shell in working directory"
msgstr ""

msgid "Open Folder in working directory\nNote: PF_FILEMANAGER needs to be set."
msgstr ""

msgid "Open Terminal shell in working directory"
msgstr ""

msgid "Save the file and continue."
msgstr ""

msgid "Cancel and Abort."
msgstr ""

##############################################################################
# Ksu Asset Selector
##############################################################################
msgid "Filter:"
msgstr ""

msgid "Search assets..."
msgstr ""

msgid "Asset Name"
msgstr ""

msgid "Size"
msgstr ""

msgid "Suggested: %s"
msgstr ""

msgid "Please select an asset."
msgstr ""

msgid "No Selection"
msgstr ""

msgid "Select KSU Asset"
msgstr ""

msgid "Select a KSU asset:"
msgstr ""

```

`logcat.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
from runtime import *
from i18n import _

# ============================================================================
#                               Class LogcatPanel
# ============================================================================
class LogcatPanel(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        self.device = get_phone(True)
        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            wx.MessageBox(_("❌ ERROR: You must first select a valid device."), _("Error"), wx.OK | wx.ICON_ERROR)
            self.Close()
            return

        self.main_sizer = wx.BoxSizer(wx.VERTICAL)

        # Create UI components
        self._create_formatting_section()
        self._create_filter_section()
        self._create_buttons()

        # Set up the panel
        self.SetSizer(self.main_sizer)
        self.Layout()

    # -----------------------------------------------
    #       Function _create_formatting_section
    # -----------------------------------------------
    def _create_formatting_section(self):
        # Formatting section with a box
        formatting_box = wx.StaticBox(self, -1, _("Formatting Options"))
        formatting_sizer = wx.StaticBoxSizer(formatting_box, wx.VERTICAL)

        # Formatting checkbox
        self.format_cb = wx.CheckBox(formatting_box, -1, _("Enable formatting (-v)"))
        self.format_cb.SetToolTip(_("Enable or disable formatting options for logcat output"))
        self.format_cb.SetValue(True)  # Default is enabled
        self.format_cb.Bind(wx.EVT_CHECKBOX, self.on_format_checkbox)
        formatting_sizer.Add(self.format_cb, 0, wx.ALL, 3)

        # Container for format options
        format_options_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # Format verbs - in a grid layout
        verbs_box = wx.StaticBox(formatting_box, -1, _("Format Verbs"))
        verbs_sizer = wx.StaticBoxSizer(verbs_box, wx.VERTICAL)

        verbs = [
            ("brief", _("Show priority, tag, and PID of the process issuing the message")),
            ("long", _("Show all metadata fields and separate messages with blank lines")),
            ("process", _("Show PID only")),
            ("raw", _("Show the raw log message with no other metadata fields")),
            ("tag", _("Show the priority and tag only")),
            ("thread", _("Show priority, PID, and TID of the thread issuing the message")),
            ("threadtime", _("Show date, time, priority, tag, PID, and TID (default)")),
            ("time", _("Show date, time, priority, tag, and PID of the process"))
        ]        # Create a grid of radio buttons with 2 rows, 4 columns
        verb_grid = wx.GridSizer(rows=2, cols=4, hgap=0, vgap=2)
        self.verb_radios = []

        for i, (verb, tooltip) in enumerate(verbs):
            rb = wx.RadioButton(verbs_box, -1, verb, style=wx.RB_GROUP if i == 0 else 0)
            rb.SetToolTip(tooltip)
            if verb == "long":
                rb.SetValue(True)
            self.verb_radios.append(rb)
            verb_grid.Add(rb, 0, wx.EXPAND)

        verbs_sizer.Add(verb_grid, 1, wx.ALL | wx.EXPAND, 2)

        # Adverb modifiers - in a grid layout
        adverbs_box = wx.StaticBox(formatting_box, -1, _("Adverb Modifiers"))
        adverbs_sizer = wx.StaticBoxSizer(adverbs_box, wx.VERTICAL)

        adverbs = [
            ("color", _("Show each priority with a different color")),
            ("descriptive", _("Show event descriptions from event-log-tags database")),
            ("epoch", _("Show time as seconds since 1970-01-01 (Unix epoch)")),
            ("monotonic", _("Show time as CPU seconds since boot")),
            ("printable", _("Ensure that any binary logging content is escaped")),
            ("uid", _("Show UID or Android ID of logged process (if permitted)")),
            ("usec", _("Show time with microsecond precision"))
        ]        # Create a grid of checkboxes with 2 rows, 4 columns
        adverb_grid = wx.GridSizer(rows=2, cols=4, hgap=0, vgap=2)
        self.format_adverbs_cbs = []

        for adverb, tooltip in adverbs:
            cb = wx.CheckBox(adverbs_box, -1, adverb)
            cb.SetToolTip(tooltip)
            if adverb in ["color", "descriptive"]:
                cb.SetValue(True)
            self.format_adverbs_cbs.append(cb)
            adverb_grid.Add(cb, 0, wx.EXPAND)

        adverbs_sizer.Add(adverb_grid, 1, wx.ALL | wx.EXPAND, 2)

        # Add verbs and adverbs to the format options sizer
        format_options_sizer.Add(verbs_sizer, 1, wx.RIGHT | wx.EXPAND, 2)
        format_options_sizer.Add(adverbs_sizer, 1, wx.LEFT | wx.EXPAND, 2)

        formatting_sizer.Add(format_options_sizer, 1, wx.ALL | wx.EXPAND, 2)
        self.main_sizer.Add(formatting_sizer, 0, wx.ALL | wx.EXPAND, 3)

    # -----------------------------------------------
    #              Function _create_filter_section
    # -----------------------------------------------
    def _create_filter_section(self):
        # Filter section with a box
        filter_box = wx.StaticBox(self, -1, _("Filter Options"))
        filter_sizer = wx.StaticBoxSizer(filter_box, wx.VERTICAL)

        # Container for all filter options
        filter_options_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # Tag filter
        tag_box = wx.StaticBox(filter_box, -1, _("Tag Filter"))
        tag_sizer = wx.StaticBoxSizer(tag_box, wx.VERTICAL)

        tag_label = wx.StaticText(tag_box, -1, _("Tag:"))
        self.tag_input = wx.TextCtrl(tag_box, -1, "*")
        self.tag_input.SetToolTip(_("Enter log component tag (or * for all)"))

        tag_sizer.Add(tag_label, 0, wx.TOP | wx.LEFT | wx.RIGHT, 2)
        tag_sizer.Add(self.tag_input, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 2)

        # Priority filter
        priority_box = wx.StaticBox(filter_box, -1, _("Priority Level"))
        priority_sizer = wx.StaticBoxSizer(priority_box, wx.VERTICAL)

        priorities = [
            ("V", "_(Verbose (default for specific tag))"),
            ("D", "_(Debug (default for *))"),
            ("I", _("Info")),
            ("W", _("Warn")),
            ("E", _("Error")),
            ("F", _("Fatal")),
            ("S", _("Silent (suppress all output)"))
        ]        # Create a horizontal row of radio buttons
        priority_grid = wx.BoxSizer(wx.HORIZONTAL)
        self.priority_radios = []

        for i, (priority, tooltip) in enumerate(priorities):
            rb = wx.RadioButton(priority_box, -1, priority, style=wx.RB_GROUP if i == 0 else 0)
            rb.SetToolTip(tooltip)
            if priority == "D":
                rb.SetValue(True)
            self.priority_radios.append(rb)
            priority_grid.Add(rb, 0, wx.RIGHT, 1)

        priority_sizer.Add(priority_grid, 0, wx.ALL, 2)

        # Additional filters
        additional_box = wx.StaticBox(filter_box, -1, _("Additional Filters"))
        additional_sizer = wx.StaticBoxSizer(additional_box, wx.VERTICAL)        # Regex filter
        regex_label = wx.StaticText(additional_box, -1, _("Regex Filter (-e):"))
        self.regex_input = wx.TextCtrl(additional_box, -1, "")
        self.regex_input.SetToolTip(_("Enter ECMAScript regex to filter output"))

        # UID filter
        uid_label = wx.StaticText(additional_box, -1, _("UIDs Filter (comma-separated):"))
        self.uid_input = wx.TextCtrl(additional_box, -1, "")
        self.uid_input.SetToolTip(_("Enter UIDs (numeric, comma-separated)"))

        additional_sizer.Add(regex_label, 0, wx.TOP | wx.LEFT | wx.RIGHT, 2)
        additional_sizer.Add(self.regex_input, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 2)
        additional_sizer.Add(uid_label, 0, wx.TOP | wx.LEFT | wx.RIGHT, 2)
        additional_sizer.Add(self.uid_input, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 2)

        # Add all filter sections to the filter options sizer
        filter_options_sizer.Add(tag_sizer, 1, wx.RIGHT | wx.EXPAND, 2)
        filter_options_sizer.Add(priority_sizer, 1, wx.RIGHT | wx.EXPAND, 2)
        filter_options_sizer.Add(additional_sizer, 2, wx.LEFT | wx.EXPAND, 2)

        filter_sizer.Add(filter_options_sizer, 1, wx.ALL | wx.EXPAND, 2)
        self.main_sizer.Add(filter_sizer, 0, wx.ALL | wx.EXPAND, 3)

    # -----------------------------------------------
    #              Function _create_buttons
    # -----------------------------------------------
    def _create_buttons(self):
        # Buttons at the bottom
        button_sizer = wx.BoxSizer(wx.HORIZONTAL)        # Add spacer to center the buttons
        button_sizer.Add((0, 0), 1, wx.EXPAND)

        self.view_btn = wx.Button(self, -1, _("View Logcat"))
        self.view_btn.SetToolTip(_("View logcat output with selected options"))
        self.view_btn.Bind(wx.EVT_BUTTON, self.on_view_logcat)

        self.clear_btn = wx.Button(self, -1, _("Clear Logcat"))
        self.clear_btn.SetToolTip(_("Clear logcat buffer"))
        self.clear_btn.Bind(wx.EVT_BUTTON, self.on_clear_logcat)

        self.cancel_btn = wx.Button(self, -1, _("Cancel"))
        self.cancel_btn.SetToolTip(_("Close this panel"))
        self.cancel_btn.Bind(wx.EVT_BUTTON, self.on_cancel)

        button_sizer.Add(self.view_btn, 0, wx.ALL, 3)
        button_sizer.Add(self.clear_btn, 0, wx.ALL, 3)
        button_sizer.Add(self.cancel_btn, 0, wx.ALL, 3)

        # Add spacer to center the buttons
        button_sizer.Add((0, 0), 1, wx.EXPAND)

        self.main_sizer.Add(button_sizer, 0, wx.ALL | wx.EXPAND, 5)

    # -----------------------------------------------
    #              Function on_format_checkbox
    # -----------------------------------------------
    def on_format_checkbox(self, event):
        is_enabled = self.format_cb.GetValue()

        for radio in self.verb_radios:
            radio.Enable(is_enabled)

        for cb in self.format_adverbs_cbs:
            cb.Enable(is_enabled)

    # -----------------------------------------------
    #              Function build_logcat_args
    # -----------------------------------------------
    def build_logcat_args(self):
        args = []

        # Formatting options
        if self.format_cb.GetValue():
            format_str = ""
            # Find the selected verb
            for radio in self.verb_radios:
                if radio.GetValue():
                    format_str = radio.GetLabel()
                    break

            # Add adverb modifiers
            for cb in self.format_adverbs_cbs:
                if cb.GetValue():
                    format_str += "," + cb.GetLabel()

            if format_str:
                args.extend(["-v", format_str])

        # Filter options
        tag = self.tag_input.GetValue().strip()

        # Find the selected priority
        priority = ""
        for radio in self.priority_radios:
            if radio.GetValue():
                priority = radio.GetLabel()
                break

        # Only add the tag:priority filter if tag is not empty
        if tag:
            filter_spec = f"{tag}:{priority}"
            args.append(filter_spec)

        # Regex filter
        regex = self.regex_input.GetValue().strip()
        if regex:
            args.extend(["-e", regex])

        # UID filter
        uid = self.uid_input.GetValue().strip()
        if uid:
            args.extend(["--uid", uid])

        return args

    # -----------------------------------------------
    #              Function on_view_logcat
    # -----------------------------------------------
    def on_view_logcat(self, event):
        args = self.build_logcat_args()
        if self.device:
            self.device.logcat(args)
        else:
            wx.MessageBox(_("No device connected"), _("Error"), wx.OK | wx.ICON_ERROR)
        self.GetParent().Close()

    # -----------------------------------------------
    #              Function on_clear_logcat
    # -----------------------------------------------
    def on_clear_logcat(self, event):
        if self.device:
            self.device.logcat(["-c"])
            wx.MessageBox(_("Logcat buffer cleared"), _("Success"), wx.OK | wx.ICON_INFORMATION)
        else:
            wx.MessageBox(_("No device connected"), _("Error"), wx.OK | wx.ICON_ERROR)

    # -----------------------------------------------
    #              Function on_cancel
    # -----------------------------------------------
    def on_cancel(self, event):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
        self.GetParent().Close()


# ============================================================================
#                               Class LogcatDialog
# ============================================================================
class LogcatDialog(wx.Dialog):
    def __init__(self, parent, title=_("Logcat")):
        wx.Dialog.__init__(self, parent, title=title, size=(580, 450))

        self.panel = LogcatPanel(self)

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND | wx.ALL, 2)
        self.SetSizer(sizer)

        self.Fit()
        self.CenterOnParent()
        self.Bind(wx.EVT_CLOSE, self._on_close)

    def _on_close(self, event):
        self.EndModal(wx.ID_CANCEL)


```

`magisk_downloads.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import webbrowser
from urllib.parse import urlparse

import pyperclip
import darkdetect
import markdown
import traceback
import wx
import wx.html
import wx.lib.mixins.listctrl as listmix
import wx.lib.wxpTag

import images as images
from runtime import *
from constants import *
from i18n import _


# ============================================================================
#                               Class HtmlWindow
# ============================================================================
class HtmlWindow(wx.html.HtmlWindow):
    def OnLinkClicked(self, link):
        webbrowser.open(link.GetHref())

# ============================================================================
#                               Class ListCtrl
# ============================================================================
class ListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)

# ============================================================================
#                               Class MagiskDownloads
# ============================================================================
class MagiskDownloads(wx.Dialog):
    def __init__(self, *args, **kwargs):
        style = kwargs.get('style', wx.DEFAULT_DIALOG_STYLE) | wx.RESIZE_BORDER
        kwargs['style'] = style
        wx.Dialog.__init__(self, *args, **kwargs)
        self.SetTitle(_("Download and Install Rooting Application"))
        self.url =  None
        self.channel = None
        self.version = None
        self.versionCode = None
        self.filename = None
        self.release_notes = None
        self.package = None

        vSizer = wx.BoxSizer(wx.VERTICAL)
        message_sizer = wx.BoxSizer(wx.HORIZONTAL)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        self.message_label = wx.StaticText(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        self.message_label.Wrap(-1)
        self.message_label.Label = _("Select rooting app to install.")
        if sys.platform == "win32":
            self.message_label.SetFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, "Arial"))

        message_sizer.Add(self.message_label, 0, wx.ALL, 20)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        vSizer.Add(message_sizer, 0, wx.EXPAND, 5)

        list_sizer = wx.BoxSizer(wx.HORIZONTAL)
        # list control
        if self.CharHeight > 20:
            self.il = wx.ImageList(24, 24)
            self.idx1 = self.il.Add(images.official_24.GetBitmap())
        else:
            self.il = wx.ImageList(16, 16)
            self.idx1 = self.il.Add(images.official_16.GetBitmap())
        self.list  = ListCtrl(self, -1, size=(-1, self.CharHeight * 20), style = wx.LC_REPORT)
        self.list.SetImageList(self.il, wx.IMAGE_LIST_SMALL)

        device = get_phone(True)
        if not device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device to be able to install.")
            print("You can still download the rooting app, but you will not be able to install it.")
            self.Parent.clear_device_selection()

        apks = get_rooting_app_apks()

        max_url_column_width = 600
        self.list.InsertColumn(0, _('Root App'), width = -1)
        self.list.InsertColumn(1, _('Version'), wx.LIST_FORMAT_LEFT, -1)
        self.list.InsertColumn(2, _('VersionCode'), wx.LIST_FORMAT_LEFT,  -1)
        self.list.InsertColumn(3, _('URL'), wx.LIST_FORMAT_LEFT, -1)
        self.list.SetColumnWidth(3, min(self.list.GetColumnWidth(3), max_url_column_width))
        self.list.InsertColumn(4, _('Package'), wx.LIST_FORMAT_LEFT,  -1)
        if sys.platform == "win32":
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLUE'),wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10).Bold())))

        i = 0
        for apk in apks:
            if apk.type:
                index = self.list.InsertItem(i, apk.type)
                if apk.type in ('stable', 'beta', 'canary', 'debug'):
                    self.list.SetItemColumnImage(i, 0, 0)
                else:
                    self.list.SetItemColumnImage(i, 0, -1)
            if apk.version:
                self.list.SetItem(index, 1, apk.version)
            if apk.versionCode:
                self.list.SetItem(index, 2, apk.versionCode)
            if apk.link:
                self.list.SetItem(index, 3, apk.link)
            if apk.package:
                self.list.SetItem(index, 4, apk.package)
            i += 1

        self.list.SetColumnWidth(0, -2)
        grow_column(self.list, 0, 20)
        self.list.SetColumnWidth(1, -2)
        grow_column(self.list, 1, 20)
        self.list.SetColumnWidth(2, -2)
        grow_column(self.list, 2, 20)
        self.list.SetColumnWidth(3, -2)
        grow_column(self.list, 3, 20)
        self.list.SetColumnWidth(3, min(self.list.GetColumnWidth(3), max_url_column_width))  # Set maximum width after growing
        self.list.SetColumnWidth(4, -1)
        grow_column(self.list, 4, 20)

        list_sizer.Add(self.list, 1, wx.ALL|wx.EXPAND, 10)

        vSizer.Add(list_sizer , 0, wx.EXPAND, 5)

        # Release Notes
        self.html = HtmlWindow(self, wx.ID_ANY, size=(420, -1))
        if darkdetect.isDark():
            black_html = "<!DOCTYPE html>\n<html><body style=\"background-color:#1e1e1e;\"></body></html>"
            self.html.SetPage(black_html)
        if "gtk2" in wx.PlatformInfo or "gtk3" in wx.PlatformInfo:
            self.html.SetStandardFonts()
        vSizer.Add(self.html , 1, wx.EXPAND | wx.ALL, 10)

        buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        self.install_button = wx.Button(self, wx.ID_ANY, _("Install"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.install_button.SetToolTip(_("WARNING! Do not install magisk if you already have a hidden (stub) Magisk installed.\nFirst unhide Magisk before attempting an install."))
        self.install_button.Enable(False)
        buttons_sizer.Add(self.install_button, 0, wx.ALL, 20)

        self.download_button = wx.Button(self, wx.ID_ANY, _("Download"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.download_button.SetToolTip(_("Download the rooting app."))
        self.download_button.Enable(False)
        buttons_sizer.Add(self.download_button, 0, wx.ALL, 20)

        self.cancel_button = wx.Button(self, wx.ID_ANY, _("Cancel"), wx.DefaultPosition, wx.DefaultSize, 0)
        buttons_sizer.Add(self.cancel_button, 0, wx.ALL, 20)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        vSizer.Add(buttons_sizer, 0, wx.EXPAND, 5)

        self.SetSizer(vSizer)
        self.Layout()
        self.Centre(wx.BOTH)

        # Connect Events
        self.install_button.Bind(wx.EVT_BUTTON, self._onOk)
        self.download_button.Bind(wx.EVT_BUTTON, self._OnDownloadMagisk)
        self.cancel_button.Bind(wx.EVT_BUTTON, self._onCancel)
        self.list.Bind(wx.EVT_LEFT_DOWN, self._on_apk_selected)
        self.list.Bind(wx.EVT_RIGHT_DOWN, self._onRightDown)
        # for wxMSW
        self.list.Bind(wx.EVT_COMMAND_RIGHT_CLICK, self._onRightClick)
        # for wxGTK
        self.list.Bind(wx.EVT_RIGHT_UP, self._onRightClick)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self._onItemSelected, self.list)
        self.Bind(wx.EVT_CLOSE, self._onCancel)


        # Autosize the dialog
        self.list.PostSizeEventToParent()
        self.SetSizerAndFit(vSizer)
        a = self.list.GetViewRect()
        self.SetSize(vSizer.MinSize.Width + 80, vSizer.MinSize.Height + 420)

        print("\nOpening Root App Installer / Downloader ...")
        puml(f":Open Root App Installer / Downloader;\n", True)


    # -----------------------------------------------
    #                  _onItemSelected
    # -----------------------------------------------
    def _onItemSelected(self, event):
        self.currentItem = event.Index
        print(f"Magisk {self.list.GetItemText(self.currentItem)} is selected.")
        puml(f":Select Magisk {self.list.GetItemText(self.currentItem)};\n")
        event.Skip()

    # -----------------------------------------------
    #                  _onRightDown
    # -----------------------------------------------
    def _onRightDown(self, event):
        x = event.GetX()
        y = event.GetY()
        # print("x, y = %s\n" % str((x, y)))
        item, flags = self.list.HitTest((x, y))
        if item != wx.NOT_FOUND and flags & wx.LIST_HITTEST_ONITEM:
            self.list.Select(item)
        event.Skip()

    # -----------------------------------------------
    #                  _onRightClick
    # -----------------------------------------------
    def _onRightClick(self, event):
        # print("OnRightClick %s\n" % self.list.GetItemText(self.currentItem))

        # only do this part the first time so the events are only bound once
        if not hasattr(self, "popupDisable"):
            self.popupCopyURL = wx.NewIdRef()
            self.popupCopyPackageId = wx.NewIdRef()
            self.popupDownloadMagisk = wx.NewIdRef()

            self.Bind(wx.EVT_MENU, self._OnCopyURL, id=self.popupCopyURL)
            self.Bind(wx.EVT_MENU, self._OnCopyPackageId, id=self.popupCopyPackageId)
            self.Bind(wx.EVT_MENU, self._OnDownloadMagisk, id=self.popupDownloadMagisk)

        # build the menu
        menu = wx.Menu()
        menu.Append(self.popupCopyURL, _("Copy URL to Clipboard"))
        menu.Append(self.popupCopyPackageId, _("Copy Package ID to Clipboard"))
        menu.Append(self.popupDownloadMagisk, _("Download Selected Rooting App"))

        # Popup the menu.  If an item is selected then its handler
        # will be called before PopupMenu returns.
        self.PopupMenu(menu)
        menu.Destroy()

    # -----------------------------------------------
    #                  _OnCopyPackageId
    # -----------------------------------------------
    def _OnCopyPackageId(self, event):
        item = self.list.GetItem(self.currentItem, 4)
        pyperclip.copy(item.Text)

    # -----------------------------------------------
    #                  _OnCopyURL
    # -----------------------------------------------
    def _OnCopyURL(self, event):
        item = self.list.GetItem(self.currentItem, 3)
        pyperclip.copy(item.Text)

    # -----------------------------------------------
    #                  _OnDownloadMagisk
    # -----------------------------------------------
    def _OnDownloadMagisk(self, event):
        url = self.list.GetItem(self.currentItem, 3).Text
        version = self.list.GetItem(self.currentItem, 1).Text
        versionCode = self.list.GetItem(self.currentItem, 2).Text
        app = self.channel.replace(' ', '_')
        filename = f"{app}_{version}_{versionCode}.apk"
        dialog = wx.FileDialog(None, _("Save File"), defaultFile=filename, wildcard="All files (*.*)|*.*", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
        if dialog.ShowModal() == wx.ID_OK:
            destination_path = dialog.GetPath()
            print(f"Downloading {destination_path} from {url}...")
            download_file(url=url, filename=destination_path, callback=None, stream=False)

    # -----------------------------------------------
    #                  __del__
    # -----------------------------------------------
    def __del__(self):
        pass

    # -----------------------------------------------
    #                  _onCancel
    # -----------------------------------------------
    def _onCancel(self, e):
        puml(f":Cancelled Magisk Downloader/Installer;\n", True)
        self.EndModal(wx.ID_CANCEL)

    # -----------------------------------------------
    #                  _on_apk_selected
    # -----------------------------------------------
    def _on_apk_selected(self, e):
        x,y = e.GetPosition()
        row,flags = self.list.HitTest((x,y))
        for i in range (0, self.list.ItemCount):
            # deselect all items
            self.list.Select(i, 0)
            item = self.list.GetItem(i)
            # reset colors
            if sys.platform == "win32":
                item.SetTextColour(wx.BLACK)
            elif darkdetect.isDark():
                item.SetTextColour(wx.WHITE)
            self.list.SetItem(item)
        if row != -1:
            self.list.Select(row)
            item = self.list.GetItem(row)
            if sys.platform == "win32":
                item.SetTextColour(wx.BLUE)
            self.list.SetItem(item)
            self.channel = self.list.GetItemText(row, col=0)
            self.version = self.list.GetItemText(row, col=1)
            self.versionCode = self.list.GetItemText(row, col=2)
            self.url = self.list.GetItemText(row, col=3)
            self.filename = os.path.basename(urlparse(self.url).path)
            self.package = self.list.GetItemText(row, col=4)
            device = get_phone()
            apks = get_rooting_app_apks()
            self.download_button.Enable(True)
            release_notes = apks[row].release_notes
            # convert markdown to html
            self.release_notes = markdown.markdown(release_notes)
            self.html.SetPage(self.release_notes)
            if device:
                self.install_button.Enable(True)
        else:
            self.install_button.Enable(False)
            self.download_button.Enable(False)

    # -----------------------------------------------
    #                  _onOk
    # -----------------------------------------------
    def _onOk(self, e):
        proceed = True
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
        app = self.channel.replace(' ', '_')
        filename = f"{app}_{self.version}_{self.versionCode}.apk"
        device = get_phone(True)
        if not device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device to be able to install.")
            return

        if 'Namelesswonder' in self.url and not device.has_init_boot:
            print(f"WARNING: The selected Magisk is not supported for your device: {device.hardware}")
            print("         Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.")
            print("         See details at: https://xdaforums.com/t/magisk-magisk-zygote64_32-enabling-32-bit-support-for-apps.4521029/")

            title = _("Device Not Supported")
            message_en =  f"ERROR: Your phone model is: {device.hardware}\n\n"
            message_en += "The selected Magisk is not supported for your device\n"
            message_en += "Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n"
            message_en += "Unless you know what you are doing, if you choose to continue\n"
            message_en += "you risk running into serious issues, proceed only if you are absolutely\n"
            message_en += "certain that this is what you want, you have been warned.\n\n"
            message_en += "Click OK to accept and continue.\n"
            message_en += "or Hit CANCEL to abort."
            message =  _("ERROR: Your phone model is: %s\n\n") % device.hardware
            message += _("The selected Magisk is not supported for your device\n")
            message += _("Only Pixel 7 (panther) and Pixel 7 Pro (cheetah) and Pixel 7a (lynx) and Pixel Tablet (tangorpro) are currently supported.\n\n")
            message += _("Unless you know what you are doing, if you choose to continue\n")
            message += _("you risk running into serious issues, proceed only if you are absolutely\n")
            message += _("certain that this is what you want, you have been warned.\n\n")
            message += _("Click OK to accept and continue.\n")
            message += _("or Hit CANCEL to abort.")
            print(f"\n*** Dialog ***\n{message_en}\n______________\n")
            # puml(":Dialog;\n")
            # puml(f"note right\n{message_en}\nend note\n")
            dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
            result = dlg.ShowModal()
            if result == wx.ID_OK:
                print("User pressed ok.")
                # puml(":User Pressed OK;\n")
            else:
                print("User pressed cancel.")
                print("Aborting ...\n")
                # puml("#pink:User Pressed Cancel to abort;\n}\n")
                proceed = False
        if proceed:
            self._on_spin('start')
            print(f"Downloading {app}: {self.channel} version: {self.version} versionCode: {self.versionCode} ...")
            download_file(self.url, filename)
            config_path = get_config_path()
            app = os.path.join(config_path, 'tmp', filename)
            device.install_apk(app, fastboot_included = True)
            # Fresh install of Magisk, reset the package name to default value
            if self.package in [MAGISK_PKG_NAME, MAGISK_ALPHA_PKG_NAME, MAGISK_DELTA_PKG_NAME]:
                set_magisk_package(self.package)
                self.Parent.config.magisk = self.package
            print('')
            self._on_spin('stop')
            self.EndModal(wx.ID_OK)

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        wx.YieldIfNeeded()
        if state == 'start':
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
            self.Parent._on_spin('start')
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.Parent._on_spin('stop')

```

`magisk_modules.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
import wx.lib.mixins.listctrl as listmix
import traceback
import images as images
import darkdetect
import markdown
import wx.html
import webbrowser
from datetime import datetime
from runtime import *
from constants import *
from message_box_ex import MessageBoxEx
from i18n import _


# ============================================================================
#                               Class HtmlWindow
# ============================================================================
class HtmlWindow(wx.html.HtmlWindow):
    def OnLinkClicked(self, link):
        webbrowser.open(link.GetHref())

    def CopySelectedText(self):
        selection = self.SelectionToText()
        if selection:
            data = wx.TextDataObject()
            data.SetText(selection)
            clipboard = wx.Clipboard.Get()
            clipboard.Open()
            clipboard.SetData(data)
            clipboard.Close()

# ============================================================================
#                               Class ListCtrl
# ============================================================================
class ListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)

# ============================================================================
#                               Class MagiskModules
# ============================================================================
class MagiskModules(wx.Dialog):
    def __init__(self, *args, parent=None, config=None, **kwargs):
        if config:
            size = (config.magisk_width, config.magisk_height)
        else:
            size=(MAGISK_WIDTH, MAGISK_HEIGHT)

        wx.Dialog.__init__(self, parent, *args, **kwargs, style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER, size=size)

        self.device = get_phone(True)
        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            wx.MessageBox(_("❌ ERROR: You must first select a valid device."), _("Error"), wx.OK | wx.ICON_ERROR)
            self.Close()
            return

        self.config = config
        self.SetTitle(_("Manage Magisk"))
        self.pif_json_path = PIF_JSON_PATH

        # Instance variable to store current selected module
        self.module = None
        self.pi_app = 'gr.nikolasspyr.integritycheck'
        self.coords = Coords()

        # Message label
        self.message_label = wx.StaticText(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        self.message_label.Wrap(-1)
        self.message_label.Label = _("When you press the OK button, the Modules with checkbox selected will be enabled and the rest will be disabled.")
        if sys.platform == "win32":
            self.message_label.SetFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, "Arial"))
        self.message_label.SetForegroundColour(wx.Colour(255, 0, 0))

        # Module label
        self.modules_label = wx.StaticText(parent=self, id=wx.ID_ANY, label=_("Magisk Modules"))
        self.modules_label.SetToolTip(_("Enable / Disable Magisk modules"))
        font = wx.Font(12, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        self.modules_label.SetFont(font)

        # Modules list control
        if self.CharHeight > 20:
            self.il = wx.ImageList(24, 24)
            self.idx1 = self.il.Add(images.download_24.GetBitmap())
        else:
            self.il = wx.ImageList(16, 16)
            self.idx1 = self.il.Add(images.download_16.GetBitmap())
        self.list  = ListCtrl(self, -1, size=(-1, self.CharHeight * 18), style = wx.LC_REPORT | wx.LC_SINGLE_SEL )
        self.list.SetImageList(self.il, wx.IMAGE_LIST_SMALL)

        # Change Log
        self.html = HtmlWindow(self, wx.ID_ANY, size=(-1, 320))
        if darkdetect.isDark():
            black_html = "<!DOCTYPE html>\n<html><body style=\"background-color:#1e1e1e;\"></body></html>"
            self.html.SetPage(black_html)
        if "gtk2" in wx.PlatformInfo or "gtk3" in wx.PlatformInfo:
            self.html.SetStandardFonts()

        # Ok button
        self.ok_button = wx.Button(self, wx.ID_ANY, _("OK"), wx.DefaultPosition, wx.DefaultSize, 0)

        # Install module button
        self.install_module_button = wx.Button(self, wx.ID_ANY, _("Install Module"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.install_module_button.SetToolTip(_("Install magisk module."))

        # update module button
        self.update_module_button = wx.Button(self, wx.ID_ANY, _("Update Module"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.update_module_button.SetToolTip(_("Update magisk module."))
        self.update_module_button.Enable(False)

        # UnInstall module button
        self.uninstall_module_button = wx.Button(self, wx.ID_ANY, _("Uninstall Module"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.uninstall_module_button.SetToolTip(_("Uninstall magisk module."))
        self.uninstall_module_button.Enable(False)

        # Run Module Action button
        self.run_action_button = wx.Button(self, wx.ID_ANY, _("Run Action"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.run_action_button.SetToolTip(_("Run Module action.sh."))
        self.run_action_button.Enable(False)

        # Play Integrity Fix Install button
        self.pif_install_button = wx.Button(self, wx.ID_ANY, _("Install Pif / TS / TargetedFix Module"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.pif_install_button.SetToolTip(_("Install Play Integrity Fix related modules."))

        # ZygiskNext Install button
        self.zygisk_next_install_button = wx.Button(self, wx.ID_ANY, _("Install ZygiskNext Module"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.zygisk_next_install_button.SetToolTip(_("Install ZygiskNext module."))

        # Systemless hosts button
        self.systemless_hosts_button = wx.Button(self, wx.ID_ANY, _("Systemless Hosts"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.systemless_hosts_button.SetToolTip(_("Add Systemless Hosts Module."))

        # Enable zygisk button
        self.enable_zygisk_button = wx.Button(self, wx.ID_ANY, _("Enable Zygisk"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.enable_zygisk_button.SetToolTip(_("Enable Magisk zygisk (requires reboot)"))

        # Disable zygisk button
        self.disable_zygisk_button = wx.Button(self, wx.ID_ANY, _("Disable Zygisk"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.disable_zygisk_button.SetToolTip(_("Disable Magisk zygisk (requires reboot)"))

        # Enable denlylist button
        self.enable_denylist_button = wx.Button(self, wx.ID_ANY, _("Enable Denylist"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.enable_denylist_button.SetToolTip(_("Enable Magisk denylist"))

        # Disable denylist button
        self.disable_denylist_button = wx.Button(self, wx.ID_ANY, _("Disable Denylist"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.disable_denylist_button.SetToolTip(_("Disable Magisk denylist"))

        # Superuser Access button
        self.superuser_access_button = wx.Button(self, wx.ID_ANY, _("Superuser Access"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.superuser_access_button.SetToolTip(_("Superuser Access (requires reboot)"))

        # Refresh
        self.refresh_button = wx.Button(self, wx.ID_ANY, _("Refresh"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.refresh_button.SetToolTip(_("Refresh Magisk modules list."))

        # static line
        self.staticline1 = wx.StaticLine(parent=self, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.LI_HORIZONTAL)

        # Cancel button
        self.cancel_button = wx.Button(self, wx.ID_ANY, _("Cancel"), wx.DefaultPosition, wx.DefaultSize, 0)

        # Make the buttons the same size
        button_width = self.pif_install_button.GetSize()[0] + 10
        self.install_module_button.SetMinSize((button_width, -1))
        self.update_module_button.SetMinSize((button_width, -1))
        self.uninstall_module_button.SetMinSize((button_width, -1))
        self.run_action_button.SetMinSize((button_width, -1))
        self.pif_install_button.SetMinSize((button_width, -1))
        self.zygisk_next_install_button.SetMinSize((button_width, -1))
        self.systemless_hosts_button.SetMinSize((button_width, -1))
        self.enable_zygisk_button.SetMinSize((button_width, -1))
        self.disable_zygisk_button.SetMinSize((button_width, -1))
        self.enable_denylist_button.SetMinSize((button_width, -1))
        self.disable_denylist_button.SetMinSize((button_width, -1))
        self.superuser_access_button.SetMinSize((button_width, -1))
        self.refresh_button.SetMinSize((button_width, -1))

        # Label for managing denylist and SU Permissions
        management_label = wx.StaticText(parent=self, id=wx.ID_ANY, label=_("To manage denylist or to manage SU permissions, use PixelFlasher's App Manager feature."))
        management_label.SetToolTip(_("Use Pixelflasher's App Manager functionality to add/remove items to denylist or su permissions."))
        font = management_label.GetFont()
        font.SetStyle(wx.FONTSTYLE_ITALIC)
        management_label.SetFont(font)

        # populate the list
        res = self.PopulateList()
        if res == -1:
            self.Close()
            return
        self.add_magisk_details()

        # Sizers
        message_sizer = wx.BoxSizer(wx.HORIZONTAL)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        message_sizer.Add(self.message_label, 0, wx.ALL, 20)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        h_buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        h_buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        h_buttons_sizer.Add(self.ok_button, 0, wx.ALL, 20)
        h_buttons_sizer.Add(self.cancel_button, 0, wx.ALL, 20)
        h_buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        v_buttons_sizer = wx.BoxSizer(wx.VERTICAL)
        v_buttons_sizer.Add(self.install_module_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.update_module_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.uninstall_module_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.run_action_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.pif_install_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.zygisk_next_install_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.systemless_hosts_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.enable_zygisk_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.disable_zygisk_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.enable_denylist_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.disable_denylist_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.superuser_access_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.refresh_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.staticline1, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.AddStretchSpacer()

        modules_sizer = wx.BoxSizer(wx.VERTICAL)
        modules_sizer.Add(self.list, 1, wx.EXPAND | wx.ALL, 10)
        modules_sizer.Add(self.html, 0, wx.EXPAND | wx.ALL, 10)

        outside_modules_sizer = wx.BoxSizer(wx.HORIZONTAL)
        outside_modules_sizer.Add(modules_sizer, 1, wx.EXPAND | wx.ALL, 0)
        outside_modules_sizer.Add(v_buttons_sizer, 0, wx.EXPAND | wx.ALL, 0)

        vSizer = wx.BoxSizer(wx.VERTICAL)
        vSizer.Add(message_sizer, 0, wx.EXPAND, 5)
        vSizer.Add(self.modules_label, 0, wx.LEFT, 10)
        vSizer.Add(outside_modules_sizer, 1, wx.EXPAND, 0)
        vSizer.Add(management_label, 0, wx.LEFT, 10)
        vSizer.Add(h_buttons_sizer, 0, wx.EXPAND, 5)

        self.SetSizer(vSizer)
        self.SetMinSize((400, 300))
        self.Layout()
        self.Centre(wx.BOTH)

        # Connect Events
        self.ok_button.Bind(wx.EVT_BUTTON, self.onOk)
        self.install_module_button.Bind(wx.EVT_BUTTON, self.onInstallModule)
        self.update_module_button.Bind(wx.EVT_BUTTON, self.onUpdateModule)
        self.uninstall_module_button.Bind(wx.EVT_BUTTON, self.onUninstallModule)
        self.run_action_button.Bind(wx.EVT_BUTTON, self.onRunModuleAction)
        self.pif_install_button.Bind(wx.EVT_BUTTON, self.onInstallPif)
        self.zygisk_next_install_button.Bind(wx.EVT_BUTTON, self.onInstallZygiskNext)
        self.systemless_hosts_button.Bind(wx.EVT_BUTTON, self.onSystemlessHosts)
        self.enable_zygisk_button.Bind(wx.EVT_BUTTON, self.onEnableZygisk)
        self.disable_zygisk_button.Bind(wx.EVT_BUTTON, self.onDisableZygisk)
        self.enable_denylist_button.Bind(wx.EVT_BUTTON, self.onEnableDenylist)
        self.disable_denylist_button.Bind(wx.EVT_BUTTON, self.onDisableDenylist)
        self.superuser_access_button.Bind(wx.EVT_BUTTON, self.onSuperuserAccess)
        self.refresh_button.Bind(wx.EVT_BUTTON, self.onRefresh)
        self.cancel_button.Bind(wx.EVT_BUTTON, self.onCancel)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.onItemSelected, self.list)
        self.html.Bind(wx.EVT_CONTEXT_MENU, self.onContextMenu)
        self.list.Bind(wx.EVT_LEFT_DOWN, self.onModuleSelection)
        self.Bind(wx.EVT_SIZE, self.OnResize)
        self.Bind(wx.EVT_CLOSE, self.onCancel)

        # Autosize the dialog
        # self.list.PostSizeEventToParent()
        # self.SetSizerAndFit(vSizer)
        # a = self.list.GetViewRect()
        # self.SetSize(vSizer.MinSize.Width + 120, vSizer.MinSize.Height + 140)

        print("\nOpening Magisk Modules Manager ...")

    # -----------------------------------------------
    #              Function PopulateList
    # -----------------------------------------------
    def PopulateList(self, refresh=False):
        if "apatch" in self.device.su_version.lower():
            modules = self.device.get_apatch_detailed_modules(refresh)
            self.enable_zygisk_button.Enable(False)
            self.disable_zygisk_button.Enable(False)
            self.systemless_hosts_button.Enable(False)
            self.enable_denylist_button.Enable(False)
            self.disable_denylist_button.Enable(False)
            self.superuser_access_button.Enable(False)
        elif "kernelsu" in self.device.su_version.lower():
            modules = self.device.get_ksu_detailed_modules(refresh)
            self.enable_zygisk_button.Enable(False)
            self.disable_zygisk_button.Enable(False)
            self.systemless_hosts_button.Enable(False)
            self.enable_denylist_button.Enable(False)
            self.disable_denylist_button.Enable(False)
            self.superuser_access_button.Enable(False)
        else:
            modules = self.device.get_magisk_detailed_modules(refresh)

        self.pif_install_button.Enable(True)

        self.list.InsertColumn(0, 'ID', width = -1)
        self.list.InsertColumn(1, 'Name', width = -1)
        self.list.InsertColumn(2, 'Version', wx.LIST_FORMAT_LEFT, -1)
        self.list.InsertColumn(3, 'VersionCode', wx.LIST_FORMAT_LEFT, -1)
        self.list.InsertColumn(4, 'Description', wx.LIST_FORMAT_LEFT,  -1)
        if sys.platform == "win32":
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLUE'),wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10).Bold())))

        self.list.EnableCheckBoxes()
        if modules:
            i = 0
            for module in modules:
                if module.id == '' and module.name == '' or module.dirname == '*':
                    continue
                if module.id == '':
                    if len(modules) == 1:
                        continue
                    else:
                        index = self.list.InsertItem(i, module.dirname)
                else:
                    index = self.list.InsertItem(i, module.id)

                # disable pif button if it is already installed.
                if module.id == "playintegrityfix" and "Play Integrity" in module.name:
                    if module.name == "Play Integrity Fork":
                        self.pif_json_path = '/data/adb/modules/playintegrityfix/custom.pif.json'
                    elif module.name == "tricky_store":
                        self.pif_json_path = '/data/adb/tricky_store/spoof_build_vars'
                    elif module.name != "Play Integrity NEXT":
                        self.pif_json_path = '/data/adb/pif.json'
                    if module.version in ["PROPS-v2.1", "PROPS-v2.0"]:
                        self.pif_json_path = '/data/adb/modules/playintegrityfix/pif.json'

                # disable Systemless Hosts button if it is already installed.
                if module.id == "hosts" and module.name == "Systemless Hosts":
                    self.systemless_hosts_button.Enable(False)

                # disable denylist if Magisk is delta
                if get_magisk_package() == MAGISK_DELTA_PKG_NAME:
                    self.enable_denylist_button.Enable(False)
                    self.disable_denylist_button.Enable(False)

                # disable button if self.device is not rooted.
                if not self.device.rooted:
                    self.install_module_button.Enable(False)
                    self.update_module_button.Enable(False)
                    self.uninstall_module_button.Enable(False)
                    self.run_action_button.Enable(False)
                    self.pif_install_button.Enable(False)
                    self.zygisk_next_install_button.Enable(False)
                    self.enable_zygisk_button.Enable(False)
                    self.disable_zygisk_button.Enable(False)
                    self.systemless_hosts_button.Enable(False)
                    self.enable_denylist_button.Enable(False)
                    self.disable_denylist_button.Enable(False)
                    self.superuser_access_button.Enable(False)
                    self.refresh_button.Enable(False)

                self.list.SetItemColumnImage(i, 0, -1)
                with contextlib.suppress(Exception):
                    if module.updateAvailable:
                        self.list.SetItemColumnImage(i, 0, 0)

                self.list.SetItem(index, 1, module.name)
                self.list.SetItem(index, 2, module.version)
                self.list.SetItem(index, 3, module.versionCode)
                self.list.SetItem(index, 4, module.description)

                if module.state == 'enabled':
                    self.list.CheckItem(index, check=True)
                elif module.state == 'remove':
                    self.list.SetItemTextColour(index, wx.LIGHT_GREY)

                i += 1

        self.list.SetColumnWidth(0, -2)
        grow_column(self.list, 0, 20)
        self.list.SetColumnWidth(1, -2)
        grow_column(self.list, 1, 20)
        self.list.SetColumnWidth(2, -2)
        grow_column(self.list, 2, 20)
        self.list.SetColumnWidth(3, -2)
        grow_column(self.list, 3, 20)
        self.list.SetColumnWidth(4, -2)
        grow_column(self.list, 4, 20)

    # -----------------------------------------------
    #                  add_magisk_details
    # -----------------------------------------------
    def add_magisk_details(self):
        device = get_phone()
        if not device:
            return

        data = f"Magisk Manager Version:  {device.magisk_app_version}\n"
        if device.rooted:
            data += f"Magisk Version:          {device.magisk_version}\n"
        data += "\nMagisk Modules"
        self.modules_label.SetLabel(data)

    # -----------------------------------------------
    #                  __del__
    # -----------------------------------------------
    def __del__(self):
        pass

    # -----------------------------------------------
    #                  onModuleSelection
    # -----------------------------------------------
    def onModuleSelection(self, event):
        x,y = event.GetPosition()
        row,flags = self.list.HitTest((x,y))
        if row == -1:
            self.uninstall_module_button.Enable(False)
            self.uninstall_module_button.SetLabel(_('Uninstall Module'))
            self.run_action_button.Enable(False)
        else:
            self.uninstall_module_button.Enable(True)
            if self.list.GetItemTextColour(row) == wx.LIGHT_GREY:
                self.uninstall_module_button.SetLabel(_('Restore Module'))
            else:
                self.uninstall_module_button.SetLabel(_('Uninstall Module'))
        event.Skip()

    # -----------------------------------------------
    #                  onItemSelected
    # -----------------------------------------------
    def onItemSelected(self, event):
        self.currentItem = event.Index
        device = get_phone()
        if not device.rooted:
            return
        print(f"Magisk Module {self.list.GetItemText(self.currentItem)} is selected.")
        # puml(f":Select Magisk Module {self.list.GetItemText(self.currentItem)};\n")

        # Get the module object for the selected item
        if "apatch" in self.device.su_version.lower():
            modules = device.get_apatch_detailed_modules(refresh=False)
        elif "kernelsu" in self.device.su_version.lower():
            modules = device.get_ksu_detailed_modules(refresh=False)
        else:
            modules = device.get_magisk_detailed_modules(refresh=False)
        self.module = modules[self.currentItem]
        self.html.SetPage('')
        if self.module.updateAvailable:
            self.update_module_button.Enable(True)
        if self.module.updateDetails and self.module.updateDetails.changelog:
            changelog_md = f"# Change Log:\n{self.module.updateDetails.changelog}"
            self.outputMessage(changelog_md)
        else:
            self.update_module_button.Enable(False)
        # if module has has_action then enable run action button
        if self.module.hasAction == 'True' or "apatch" in self.device.su_version.lower() or "kernelsu" in self.device.su_version.lower():
            self.run_action_button.Enable(True)
        else:
            self.run_action_button.Enable(False)
        event.Skip()

    # -----------------------------------------------
    #                  outputMessage
    # -----------------------------------------------
    def outputMessage(self, md_message):
        self.html.SetPage('')
        # convert markdown to html
        html_message = markdown.markdown(md_message)
        self.html.SetPage(html_message)

    # -----------------------------------------------
    #                  onCancel
    # -----------------------------------------------
    def onCancel(self, e):
        self.EndModal(wx.ID_CANCEL)

    # -----------------------------------------------
    #                  onEnableZygisk
    # -----------------------------------------------
    def onEnableZygisk(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            print("Enable Zygisk")
            self._on_spin('start')
            res = device.magisk_enable_zygisk(True)
            if res == 0:
                self.outputMessage(_("## You need to reboot your device for the changes to take effect."))
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in function onEnableZygisk")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onDisableZygisk
    # -----------------------------------------------
    def onDisableZygisk(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            print("Disable Zygisk")
            self._on_spin('start')
            res = device.magisk_enable_zygisk(False)
            if res == 0:
                self.outputMessage(_("## You need to reboot your device for the changes to take effect."))
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in function onDisableZygisk")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onEnableDenylist
    # -----------------------------------------------
    def onEnableDenylist(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            print("Enable Denylist")
            self._on_spin('start')
            device.magisk_enable_denylist(True)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in function onEnableDenylist")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onDisableDenylist
    # -----------------------------------------------
    def onDisableDenylist(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            print("Disable Denylist")
            self._on_spin('start')
            device.magisk_enable_denylist(False)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in function onDisableDenylist")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onSuperuserAccess
    # -----------------------------------------------
    def onSuperuserAccess(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            buttons_text = [_("Disabled"), _("Apps Only"), _("ADB Only"), _("Apps and ADB"), _("Cancel")]
            dlg = MessageBoxEx(
                parent=self,
                title=_('Magisk'),
                message=_("Superuser Access"),
                button_texts=buttons_text,
                default_button=1,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
            value = None
            if result <= 4:
                value = str(result - 1)
            else:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                print("Aborting ...\n")
                return -1

            self._on_spin('start')
            debug(f"Superuser Access: {value}")
            res = device.magisk_modify_root_access(value)
            if res == 0:
                self.outputMessage(_("## You need to reboot your device for the changes to take effect."))
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in function onSuperuserAccess")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onRefresh
    # -----------------------------------------------
    def onRefresh(self, e):
        self.refresh_modules()

    # -----------------------------------------------
    #                  onSystemlessHosts
    # -----------------------------------------------
    def onSystemlessHosts(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            print("Add Systemless Hosts")
            self._on_spin('start')
            device.magisk_add_systemless_hosts()
            self.refresh_modules()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in function onSystemlessHosts")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onInstallPif
    # -----------------------------------------------
    def onInstallPif(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            buttons_text = [_("osm0sis PlayIntegrityFork"), "TrickyStore", "Tricky Store OSS", "TEESimulator","TargetedFix", _("Cancel")]
            dlg = MessageBoxEx(
                parent=self,
                title=_('PIF Module'),
                message=_("Select the module you want to install"),
                button_texts=buttons_text,
                default_button=1,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
            module_update_url = None
            gh_latest_url = None
            if result == 1:
                module_update_url = OSM0SIS_PIF_UPDATE_URL
            elif result == 2:
                gh_latest_url = get_gh_latest_release_asset_regex('5ec1cff', 'TrickyStore', r'^Tricky\-Store.*\-release\.zip$')
            elif result == 3:
                gh_latest_url = get_gh_latest_release_asset_regex('beakthoven', 'TrickyStoreOSS', r'^Tricky\-Store\-OSS.*\-Release\.zip$')
            elif result == 4:
                gh_latest_url = get_gh_latest_release_asset_regex('JingMatrix', 'TEESimulator', r'^TEESimulator.*\-Release\.zip$')
            elif result == 5:
                module_update_url = TARGETEDFIX_UPDATE_URL
                # gh_latest_url = get_gh_latest_release_asset_regex('VisionR1', 'TargetedFix', r'^TargetedFix.*\.zip$')
                # gh_latest_url = get_gh_pre_release_asset_regex('VisionR1', 'TargetedFix', r'^TargetedFix.*\.zip$')
            else:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                print("Aborting ...\n")
                return -1

            url = None
            if gh_latest_url is not None:
                url = gh_latest_url
            elif module_update_url is not None:
                url_obj = check_module_update(module_update_url)
                url = url_obj.zipUrl
            if url is None or url == '':
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get module download link.")
                print("Aborting ...\n")
                return -1

            self._on_spin('start')
            downloaded_file_path = download_file(url)
            print(f"Installing Play Integrity Fix (PIF) module. URL: {downloaded_file_path} ...")
            res = device.magisk_install_module(downloaded_file_path)
            if res == 0:
                self.outputMessage(_("## You need to reboot your device to complete the installation."))
            self.refresh_modules()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Play Integrity Fix module installation.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onInstallZygiskNext
    # -----------------------------------------------
    def onInstallZygiskNext(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            module_update_url = ZYGISK_NEXT_UPDATE_URL
            url = check_module_update(module_update_url)
            if url is None:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get module download link.")
                print("Aborting ...\n")
                return -1

            self._on_spin('start')
            downloaded_file_path = download_file(url.zipUrl)
            print(f"Installing ZygiskNext module. URL: {downloaded_file_path} ...")
            res = device.magisk_install_module(downloaded_file_path)
            if res == 0:
                self.outputMessage(_("## You need to reboot your device to complete the installation."))
            self.refresh_modules()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during ZygiskNext module installation.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onRunModuleAction
    # -----------------------------------------------
    def onRunModuleAction(self, e):
        # run the action.sh script
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            self._on_spin('start')
            res = device.magisk_run_module_action(self.module.dirname)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Magisk modules run action.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onUninstallModule
    # -----------------------------------------------
    def onUninstallModule(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            id = self.list.GetItem(self.currentItem, 0).Text
            name = self.list.GetItem(self.currentItem, 1).Text
            if "apatch" in self.device.su_version.lower():
                modules = device.get_apatch_detailed_modules()
            elif "kernelsu" in self.device.su_version.lower():
                modules = device.get_ksu_detailed_modules()
            else:
                modules = device.get_magisk_detailed_modules()
            self._on_spin('start')
            for i in range(0, self.list.ItemCount, 1):
                if modules[i].dirname == id:
                    if modules[i].state == 'remove':
                        print(f"Restoring Module {name} ...")
                        res = device.restore_magisk_module(modules[i].dirname)
                    else:
                        print(f"Uninstalling Module {name} ...")
                        res = device.magisk_uninstall_module(modules[i].dirname)
                    if res == 0:
                        modules[i].state = 'remove'
                        self.refresh_modules()
                        self.outputMessage(_("## You need to reboot your device for the changes to take effect."))
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to remove module: {modules[i].name}")
                    break
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Magisk modules uninstall")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onUpdateModule
    # -----------------------------------------------
    def onUpdateModule(self, e):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            id = self.list.GetItem(self.currentItem, 0).Text
            name = self.list.GetItem(self.currentItem, 1).Text
            print(f"Updating Module {name} ...")
            if self.module and self.module.updateAvailable and self.module.updateDetails and (self.module.id and self.module.id == id) and (self.module.name and self.module.name == name):
                url = self.module.updateDetails.zipUrl
                self._on_spin('start')
                print(f"Downloading Module: {name} URL: {url} ...")
                downloaded_file_path = download_file(url)
                res = device.magisk_install_module(downloaded_file_path)
                if res == 0:
                    self.outputMessage(_("## You need to reboot your device to complete the update."))
            self.refresh_modules()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during modules update")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onInstallModule
    # -----------------------------------------------
    def onInstallModule(self, e):
        device = get_phone(True)
        if not device.rooted:
            return
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Install Module.")
        with wx.FileDialog(self, "_(select Module file to install)", '', '', wildcard="Magisk Modules (*.*.zip)|*.zip", style=wx.FD_OPEN) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                print("User cancelled module install.")
                return
            # save the current contents in the file
            pathname = fileDialog.GetPath()
            print(f"\nSelected {pathname} for installation.")
            try:
                self._on_spin('start')
                res = device.magisk_install_module(pathname)
                if res == 0:
                    self.outputMessage(_("## You need to reboot your device to complete the installation."))
                self.refresh_modules()
            except IOError:
                wx.LogError(f"Cannot install module file '{pathname}'.")
                traceback.print_exc()
            finally:
                self._on_spin('stop')

    # -----------------------------------------------
    #                  onContextMenu
    # -----------------------------------------------
    def onContextMenu(self, event):
        menu = wx.Menu()
        copy_item = menu.Append(wx.ID_COPY, _("Copy"))
        select_all_item = menu.Append(wx.ID_SELECTALL, _("Select All"))
        self.Bind(wx.EVT_MENU, self.onCopy, copy_item)
        self.Bind(wx.EVT_MENU, self.onSelectAll, select_all_item)

        self.PopupMenu(menu)
        menu.Destroy()

    # -----------------------------------------------
    #                  onCopy
    # -----------------------------------------------
    def onCopy(self, event):
        self.html.CopySelectedText()

    # -----------------------------------------------
    #                  onSelectAll
    # -----------------------------------------------
    def onSelectAll(self, event):
        self.html.SelectAll()

    # -----------------------------------------------
    #                  onOk
    # -----------------------------------------------
    def onOk(self, e):
        device = get_phone(True)
        if not device.rooted:
            self.EndModal(wx.ID_OK)
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
        if "apatch" in self.device.su_version.lower():
            modules = device.get_apatch_detailed_modules()
        elif "kernelsu" in self.device.su_version.lower():
            modules = device.get_ksu_detailed_modules()
        else:
            modules = device.get_magisk_detailed_modules()
        for i in range(0, self.list.ItemCount, 1):
            if modules[i].state == 'enabled':
                module_state = True
            else:
                module_state = False
            list_state = self.list.IsItemChecked(i)

            if list_state == module_state:
                print(f"Module: {modules[i].name:<36} state has not changed,   Nothing to do. [Kept {modules[i].state.upper()}]")
            elif list_state:
                print(f"Module: {modules[i].name:<36} state has changed,       ENABLING  the module ...")
                res = device.enable_magisk_module(modules[i].dirname)
                if res == 0:
                    modules[i].state = 'enabled'
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to disable module: {modules[i].name}")
            else:
                print(f"Module: {modules[i].name:<36} state has changed,       DISABLING the module ...")
                res = device.disable_magisk_module(modules[i].dirname)
                if res == 0:
                    modules[i].state = 'disabled'
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to disable module: {modules[i].name}")
        print('')
        self.EndModal(wx.ID_OK)

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        wx.YieldIfNeeded()
        if state == 'start':
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
            self.Parent._on_spin('start')
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.Parent._on_spin('stop')

    # ----------------------------------------------------------------------------
    #                               refresh_modules
    # ----------------------------------------------------------------------------
    def refresh_modules(self):
        # self.Freeze()
        self.list.ClearAll()
        self.PopulateList(True)
        # self.Thaw

    # -----------------------------------------------
    #                  OnResize
    # -----------------------------------------------
    def OnResize(self, event):
        self.resizing = True
        self.Parent.config.magisk_width = self.Rect.Width
        self.Parent.config.magisk_height = self.Rect.Height

        self.Layout()
        event.Skip(True)


```

`manage_devices.py`:

```py
# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2026 Badabing2005
# SPDX-FileCopyrightText: 2026 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
import os
from datetime import datetime
from i18n import _
from runtime import (
                        load_devices_json,
                        save_devices_json,
                        delete_device,
                        update_device_custom_label,
                        toggle_device_enabled
                    )


# ============================================================================
#                            Class ManageDevicesDialog
# ============================================================================
class ManageDevicesDialog(wx.Dialog):
    def __init__(self, parent, title=_("Manage Devices")):
        super().__init__(parent, title=title, style=wx.RESIZE_BORDER | wx.DEFAULT_DIALOG_STYLE)
        self.SetSize((1200, 600))
        self.devices = {}
        self.load_devices()
        self.init_ui()
        self.refresh_list()

    # -----------------------------------------------
    #                  load_devices
    # -----------------------------------------------
    def load_devices(self):
        self.devices = load_devices_json()

    # -----------------------------------------------
    #                  save_devices
    # -----------------------------------------------
    def save_devices(self):
        save_devices_json(self.devices)

    # -----------------------------------------------
    #                  init_ui
    # -----------------------------------------------
    def init_ui(self):
        # Main sizer
        main_sizer = wx.BoxSizer(wx.VERTICAL)

        # Horizontal sizer for list and controls
        h_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # Device list (left side)
        list_box = wx.StaticBox(self, label=_("Devices"))
        list_sizer = wx.StaticBoxSizer(list_box, wx.VERTICAL)

        self.device_list = wx.ListCtrl(self, style=wx.LC_REPORT | wx.LC_SINGLE_SEL)
        self.device_list.AppendColumn(_("Device ID"), width=180)
        self.device_list.AppendColumn(_("Hardware"), width=120)
        self.device_list.AppendColumn(_("Custom Label"), width=150)
        self.device_list.AppendColumn(_("Enabled"), width=100)
        self.device_list.AppendColumn(_("Connected"), width=100)
        self.device_list.AppendColumn(_("Last Seen"), width=160)

        list_sizer.Add(self.device_list, 1, wx.EXPAND | wx.ALL, 5)
        h_sizer.Add(list_sizer, 1, wx.EXPAND | wx.ALL, 5)

        # Control panel (right side)
        control_box = wx.StaticBox(self, label=_("Device Actions"))
        control_sizer = wx.StaticBoxSizer(control_box, wx.VERTICAL)

        # Selected device info
        self.selected_text = wx.StaticText(self, label=_("No device selected"))
        control_sizer.Add(self.selected_text, 0, wx.ALL, 5)
        control_sizer.Add(wx.StaticLine(self), 0, wx.EXPAND | wx.ALL, 5)

        # Custom Label section
        label_text = wx.StaticText(self, label=_("Custom Display Label:"))
        control_sizer.Add(label_text, 0, wx.ALL, 5)

        self.custom_label_ctrl = wx.TextCtrl(self)
        self.custom_label_ctrl.SetHint(_("Enter custom name"))
        self.custom_label_ctrl.SetToolTip(_("Set a custom label for this device to easily identify it in the menu.\nThis does not affect the actual device name or functionality.\ne.g., OnePlus 5 - Daily Driver"))
        control_sizer.Add(self.custom_label_ctrl, 0, wx.EXPAND | wx.ALL, 5)

        update_label_btn = wx.Button(self, label=_("Update Label"))
        update_label_btn.Bind(wx.EVT_BUTTON, self.on_update_label)
        control_sizer.Add(update_label_btn, 0, wx.EXPAND | wx.ALL, 5)

        control_sizer.Add(wx.StaticLine(self), 0, wx.EXPAND | wx.ALL, 5)

        # Action buttons
        self.toggle_btn = wx.Button(self, label=_("Enable / Disable"))
        self.toggle_btn.Bind(wx.EVT_BUTTON, self.on_toggle_enabled)
        self.toggle_btn.Enable(False)
        control_sizer.Add(self.toggle_btn, 0, wx.EXPAND | wx.ALL, 5)

        self.delete_btn = wx.Button(self, label=_("Delete Device"))
        self.delete_btn.Bind(wx.EVT_BUTTON, self.on_delete)
        self.delete_btn.Enable(False)
        control_sizer.Add(self.delete_btn, 0, wx.EXPAND | wx.ALL, 5)

        control_sizer.AddStretchSpacer()

        # Help text
        help_text = wx.StaticText(self, label=_("Tip: Set a custom label to easily\nidentify your devices in the menu."))
        control_sizer.Add(help_text, 0, wx.ALL, 5)

        h_sizer.Add(control_sizer, 0, wx.EXPAND | wx.ALL, 5)

        main_sizer.Add(h_sizer, 1, wx.EXPAND)

        # Bottom button sizer
        btn_sizer = wx.StdDialogButtonSizer()

        close_btn = wx.Button(self, wx.ID_CLOSE)
        close_btn.Bind(wx.EVT_BUTTON, self.on_close)
        btn_sizer.AddButton(close_btn)

        btn_sizer.Realize()
        main_sizer.Add(btn_sizer, 0, wx.ALIGN_RIGHT | wx.ALL, 10)

        self.SetSizer(main_sizer)

        # Bind events
        self.device_list.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_item_selected)
        self.device_list.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.on_item_deselected)

    # -----------------------------------------------
    #                  refresh_list
    # -----------------------------------------------
    def refresh_list(self):
        self.device_list.DeleteAllItems()

        for idx, (device_id, device_data) in enumerate(sorted(self.devices.items())):
            # Device ID
            self.device_list.InsertItem(idx, device_id)

            # Hardware
            hardware = device_data.get('hardware', '') or device_data.get('device_name', '')
            self.device_list.SetItem(idx, 1, hardware)

            # Custom Label
            custom_label = device_data.get('custom_label', '')
            self.device_list.SetItem(idx, 2, custom_label)

            # Enabled
            enabled = device_data.get('enabled', True)
            self.device_list.SetItem(idx, 3, _("Yes") if enabled else _("No"))

            # Connected
            connected = device_data.get('connected', False)
            self.device_list.SetItem(idx, 4, _("Yes") if connected else _("No"))

            # Last Seen
            last_seen = device_data.get('last_seen', '')
            if last_seen:
                try:
                    # Format the datetime string
                    dt = datetime.fromisoformat(last_seen)
                    last_seen = dt.strftime("%Y-%m-%d %H:%M")
                except:
                    pass
            self.device_list.SetItem(idx, 5, last_seen)

    # -----------------------------------------------
    #                  get_selected_device_id
    # -----------------------------------------------
    def get_selected_device_id(self):
        selected = self.device_list.GetFirstSelected()
        if selected != -1:
            return self.device_list.GetItemText(selected)
        return None

    # -----------------------------------------------
    #                  on_item_selected
    # -----------------------------------------------
    def on_item_selected(self, event):
        device_id = self.get_selected_device_id()
        if device_id and device_id in self.devices:
            device_data = self.devices[device_id]

            # Update selected text
            hardware = device_data.get('hardware', '') or device_data.get('device_name', '')
            self.selected_text.SetLabel(f"{device_id}\n({hardware})")

            # Update custom label control
            custom_label = device_data.get('custom_label', '')
            self.custom_label_ctrl.SetValue(custom_label)

            # Enable buttons
            self.toggle_btn.Enable(True)
            self.delete_btn.Enable(True)

    # -----------------------------------------------
    #                  on_item_deselected
    # -----------------------------------------------
    def on_item_deselected(self, event):
        self.selected_text.SetLabel(_("No device selected"))
        self.custom_label_ctrl.SetValue("")
        self.toggle_btn.Enable(False)
        self.delete_btn.Enable(False)

    # -----------------------------------------------
    #                  on_update_label
    # -----------------------------------------------
    def on_update_label(self, event):
        device_id = self.get_selected_device_id()
        if not device_id:
            wx.MessageBox(_("Please select a device first."), _("No Selection"), wx.OK | wx.ICON_INFORMATION)
            return

        custom_label = self.custom_label_ctrl.GetValue().strip()

        if update_device_custom_label(device_id, custom_label):
            # Update local data
            self.devices[device_id]['custom_label'] = custom_label
            self.refresh_list()

            # Reselect the item
            for i in range(self.device_list.GetItemCount()):
                if self.device_list.GetItemText(i) == device_id:
                    self.device_list.Select(i)
                    break

            wx.MessageBox(_("Custom label updated successfully."), _("Success"), wx.OK | wx.ICON_INFORMATION)
        else:
            wx.MessageBox(_("Failed to update custom label."), _("Error"), wx.OK | wx.ICON_ERROR)

    # -----------------------------------------------
    #                  on_toggle_enabled
    # -----------------------------------------------
    def on_toggle_enabled(self, event):
        device_id = self.get_selected_device_id()
        if not device_id:
            wx.MessageBox(_("Please select a device first."), _("No Selection"), wx.OK | wx.ICON_INFORMATION)
            return

        device_data = self.devices[device_id]
        current_state = device_data.get('enabled', True)
        new_state = not current_state

        # Confirm action
        action = _("disable") if current_state else _("enable")
        result = wx.MessageBox(
            _("Are you sure you want to %s device\n%s?") % (action, device_id),
            _("Confirm %s") % action.capitalize(),
            wx.YES_NO | wx.ICON_QUESTION
        )

        if result == wx.YES:
            if toggle_device_enabled(device_id) is not None:
                # Update local data
                self.devices[device_id]['enabled'] = new_state
                self.refresh_list()

                # Reselect the item
                for i in range(self.device_list.GetItemCount()):
                    if self.device_list.GetItemText(i) == device_id:
                        self.device_list.Select(i)
                        break

                status = _("disabled") if not new_state else _("enabled")
                wx.MessageBox(_("Device %s successfully.") % status, _("Success"), wx.OK | wx.ICON_INFORMATION)
            else:
                wx.MessageBox(_("Failed to toggle device state."), _("Error"), wx.OK | wx.ICON_ERROR)

    # -----------------------------------------------
    #                  on_delete
    # -----------------------------------------------
    def on_delete(self, event):
        device_id = self.get_selected_device_id()
        if not device_id:
            wx.MessageBox(_("Please select a device first."), _("No Selection"), wx.OK | wx.ICON_INFORMATION)
            return

        # Confirm deletion
        result = wx.MessageBox(
            _("Are you sure you want to delete the device entry for\n%s?\n\nThis will remove the device from the list, but it will be re-added on the next scan if still connected.") % device_id,
            _("Confirm Delete"),
            wx.YES_NO | wx.ICON_WARNING
        )

        if result == wx.YES:
            if delete_device(device_id):
                # Remove from local data
                del self.devices[device_id]
                self.refresh_list()

                # Clear selection
                self.selected_text.SetLabel(_("No device selected"))
                self.custom_label_ctrl.SetValue("")
                self.toggle_btn.Enable(False)
                self.delete_btn.Enable(False)

                wx.MessageBox(_("Device entry deleted successfully."), _("Success"), wx.OK | wx.ICON_INFORMATION)
            else:
                wx.MessageBox(_("Failed to delete device entry."), _("Error"), wx.OK | wx.ICON_ERROR)

    # -----------------------------------------------
    #                  on_close
    # -----------------------------------------------
    def on_close(self, event):
        self.EndModal(wx.ID_CLOSE)

```

`message_box_ex.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import webbrowser

import darkdetect
import markdown
import wx
import wx.html

from runtime import *
from i18n import _

class MessageBoxEx(wx.Dialog):
    def __init__(
            self,
            *args,
            title=None,
            message=None,
            button_texts=None,
            default_button=None,
            disable_buttons=None,
            is_md=False,
            size=(800, 600),
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False,
            **kwargs
        ):
        wx.Dialog.__init__(self, *args, **kwargs)
        self.SetTitle(title)
        self.button_texts = button_texts or []
        self.default_button = default_button
        self.buttons = []
        self.return_value = None
        self.checkboxes = []
        self.checkboxes2 = []
        self.checkbox_labels = checkbox_labels
        self.checkbox_labels2 = checkbox_labels2
        self.radio_buttons = []
        self.radio_labels = radio_labels
        self.radio_initial_value = radio_initial_value
        if checkbox_initial_values is not None:
            self.checkbox_initial_values = checkbox_initial_values
        else:
            self.checkbox_initial_values = []
        if checkbox_initial_values2 is not None:
            self.checkbox_initial_values2 = checkbox_initial_values2
        else:
            self.checkbox_initial_values2 = []

        self._close_button_index = None
        if self.button_texts:
            cancel_keywords = ("cancel", "abort", "no", "stop")
            for idx, label in enumerate(self.button_texts):
                normalized = (label or "").strip().lower()
                tokens = normalized.replace('-', ' ').replace('_', ' ').split()
                if any(keyword == normalized or keyword in tokens for keyword in cancel_keywords):
                    self._close_button_index = idx
                    break
            if self._close_button_index is None:
                if len(self.button_texts) > 1:
                    self._close_button_index = len(self.button_texts) - 1
                elif self.default_button:
                    self._close_button_index = max(0, min(len(self.button_texts) - 1, self.default_button - 1))
                else:
                    self._close_button_index = 0

        vSizer = wx.BoxSizer(wx.VERTICAL)
        message_sizer = wx.BoxSizer(wx.HORIZONTAL)

        if is_md:
            self.html = wx.html.HtmlWindow(self, wx.ID_ANY, size=size)
            message = message.strip()  # Remove leading/trailing whitespace
            md_html = markdown.markdown(message, extensions=['extra'])

            # Adjust colors for dark mode on Mac and Linux
            if darkdetect.isDark() and sys.platform != "win32":
                dark_html = f"""
                <!DOCTYPE html>
                <html>
                <body style="background-color:#656565; color:#ffffff;">
                    {md_html}
                </body>
                </html>
                """
                self.html.SetPage(dark_html)
                if "gtk2" in wx.PlatformInfo or "gtk3" in wx.PlatformInfo or sys.platform == "darwin":
                    self.html.SetStandardFonts()
            else:
                self.html.SetPage(md_html)

            self.html.Bind(wx.html.EVT_HTML_LINK_CLICKED, self._onLinkClicked)
            message_sizer.Add(self.html, 1, wx.ALL | wx.EXPAND, 20)
        else:
            self.message_label = wx.StaticText(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
            self.message_label.Wrap(-1)
            self.message_label.SetFont(wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
            self.message_label.Label = message
            message_sizer.Add(self.message_label, 1, wx.ALL | wx.EXPAND, 20)

        vSizer.Add(message_sizer, 1, wx.EXPAND, 5)

        if checkbox_labels is not None or checkbox_labels2 is not None:
            if vertical_checkboxes:
                # For vertical layout: create horizontal sizer for columns
                main_checkbox_sizer = wx.BoxSizer(wx.HORIZONTAL)

                if checkbox_labels is not None:
                    checkbox_sizer = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, _("Options")), wx.VERTICAL)
                    for i in range(len(checkbox_labels)):
                        checkbox_label = checkbox_labels[i]
                        checkbox = wx.CheckBox(self, wx.ID_ANY, checkbox_label, wx.DefaultPosition, wx.DefaultSize, 0)
                        if i < len(self.checkbox_initial_values):
                            checkbox.SetValue(self.checkbox_initial_values[i])
                        if disable_checkboxes is not None and i + 1 in disable_checkboxes:
                            checkbox.Enable(False)
                        self.checkboxes.append(checkbox)
                        checkbox_sizer.Add(checkbox, 0, wx.ALL, 5)
                    main_checkbox_sizer.Add(checkbox_sizer, 1, wx.EXPAND | wx.ALL, 5)

                if checkbox_labels2 is not None:
                    checkbox_sizer2 = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, _("Additional Options")), wx.VERTICAL)
                    for i in range(len(checkbox_labels2)):
                        checkbox_label = checkbox_labels2[i]
                        checkbox = wx.CheckBox(self, wx.ID_ANY, checkbox_label, wx.DefaultPosition, wx.DefaultSize, 0)
                        if i < len(self.checkbox_initial_values2):
                            checkbox.SetValue(self.checkbox_initial_values2[i])
                        if disable_checkboxes2 is not None and i + 1 in disable_checkboxes2:
                            checkbox.Enable(False)
                        self.checkboxes2.append(checkbox)
                        checkbox_sizer2.Add(checkbox, 0, wx.ALL, 5)
                    main_checkbox_sizer.Add(checkbox_sizer2, 1, wx.EXPAND | wx.ALL, 5)

                vSizer.Add(main_checkbox_sizer, 0, wx.EXPAND | wx.ALL, 10)
            else:
                # For horizontal layout: create vertical sizer for rows
                main_checkbox_sizer = wx.BoxSizer(wx.VERTICAL)

                if checkbox_labels is not None:
                    checkbox_sizer = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, _("Options")), wx.HORIZONTAL)
                    for i in range(len(checkbox_labels)):
                        checkbox_label = checkbox_labels[i]
                        checkbox = wx.CheckBox(self, wx.ID_ANY, checkbox_label, wx.DefaultPosition, wx.DefaultSize, 0)
                        if i < len(self.checkbox_initial_values):
                            checkbox.SetValue(self.checkbox_initial_values[i])
                        if disable_checkboxes is not None and i + 1 in disable_checkboxes:
                            checkbox.Enable(False)
                        self.checkboxes.append(checkbox)
                        checkbox_sizer.Add(checkbox, 0, wx.ALL, 5)
                    main_checkbox_sizer.Add(checkbox_sizer, 0, wx.EXPAND | wx.ALL, 5)

                if checkbox_labels2 is not None:
                    checkbox_sizer2 = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, _("Additional Options")), wx.HORIZONTAL)
                    for i in range(len(checkbox_labels2)):
                        checkbox_label = checkbox_labels2[i]
                        checkbox = wx.CheckBox(self, wx.ID_ANY, checkbox_label, wx.DefaultPosition, wx.DefaultSize, 0)
                        if i < len(self.checkbox_initial_values2):
                            checkbox.SetValue(self.checkbox_initial_values2[i])
                        if disable_checkboxes2 is not None and i + 1 in disable_checkboxes2:
                            checkbox.Enable(False)
                        self.checkboxes2.append(checkbox)
                        checkbox_sizer2.Add(checkbox, 0, wx.ALL, 5)
                    main_checkbox_sizer.Add(checkbox_sizer2, 0, wx.EXPAND | wx.ALL, 5)

                vSizer.Add(main_checkbox_sizer, 0, wx.EXPAND | wx.ALL, 10)

        if radio_labels is not None:
            orientation = wx.VERTICAL if vertical_radios else wx.HORIZONTAL
            radio_sizer = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, _("Select Option")), orientation)
            for i, radio_label in enumerate(radio_labels):
                # First radio button should have RB_GROUP style to start a new group
                style = wx.RB_GROUP if i == 0 else 0
                radio_button = wx.RadioButton(self, wx.ID_ANY, radio_label, wx.DefaultPosition, wx.DefaultSize, style)
                if self.radio_initial_value is not None and self.radio_initial_value == i:
                    radio_button.SetValue(True)
                elif self.radio_initial_value is None and i == 0:
                    radio_button.SetValue(True)  # Default to first option
                if disable_radios is not None and i + 1 in disable_radios:
                    radio_button.Enable(False)
                self.radio_buttons.append(radio_button)
                radio_sizer.Add(radio_button, 0, wx.ALL, 5)
            vSizer.Add(radio_sizer, 0, wx.EXPAND | wx.ALL, 10)

        buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        # do this to not have any focus on the buttons, if default_button is set, then the corresponding button will have focus
        self.SetFocus()
        if button_texts is not None:
            for i, button_text in enumerate(button_texts):
                button = wx.Button(self, wx.ID_ANY, button_text, wx.DefaultPosition, wx.DefaultSize, 0)
                self.buttons.append(button)
                buttons_sizer.Add(button, 0, wx.ALL, 20)
                button.Bind(wx.EVT_BUTTON, lambda e, i=i: self._onButtonClick(e, i))
                if self.default_button == i + 1:
                    self._setDefaultButton(button)
                if disable_buttons is not None and i + 1 in disable_buttons:
                    button.Disable()
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        vSizer.Add(buttons_sizer, 0, wx.EXPAND, 5)

        self.SetSizer(vSizer)
        self.Layout()
        self.Centre(wx.BOTH)

        # Autosize the dialog
        self.SetSizerAndFit(vSizer)
        self.Bind(wx.EVT_CLOSE, self._onDialogClose)

    def _setDefaultButton(self, button):
        button.SetDefault()
        button.SetFocus()

    def _onButtonClick(self, e, button_index):
        self._emit_modal_result(button_index + 1)

    def _onLinkClicked(self, event):
        url = event.GetLinkInfo().GetHref()
        # wx.LaunchDefaultBrowser(url)
        webbrowser.open(url)

    def _emit_modal_result(self, button_value):
        self.return_value = {'button': button_value}

        if self.checkbox_labels is not None:
            checkbox_values = [checkbox.IsChecked() for checkbox in self.checkboxes]
            set_dlg_checkbox_values(checkbox_values)
            self.return_value['checkboxes'] = checkbox_values

        if self.checkbox_labels2 is not None:
            checkbox_values2 = [checkbox.IsChecked() for checkbox in self.checkboxes2]
            self.return_value['checkboxes2'] = checkbox_values2

        if self.radio_labels is not None:
            for i, radio_button in enumerate(self.radio_buttons):
                if radio_button.GetValue():
                    self.return_value['radio'] = i
                    break

        self.EndModal(button_value)

    def _onDialogClose(self, event):
        if self.IsModal():
            if self.button_texts:
                close_index = self._close_button_index if self._close_button_index is not None else 0
                close_index = max(0, min(len(self.button_texts) - 1, close_index))
                self._emit_modal_result(close_index + 1)
            else:
                self.EndModal(wx.ID_CANCEL)
        else:
            event.Skip()

```

`my_tools.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import json
import json5
from datetime import datetime

import wx
import images as images
from runtime import *
from i18n import _


# ============================================================================
#                               Class MyToolsDialog
# ============================================================================
class MyToolsDialog(wx.Dialog):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs, style=wx.RESIZE_BORDER | wx.DEFAULT_DIALOG_STYLE)
        self.SetTitle(_("My Tools Manager"))
        self.mytools = {}
        self.load_mytools()
        self.SetSize((900, 750))

        self.list = wx.ListCtrl(parent=self, id=wx.ID_ANY, size=(-1, -1), style=wx.LC_REPORT | wx.BORDER_SUNKEN | wx.LC_SINGLE_SEL)

        if sys.platform == "win32":
            self.list.SetHeaderAttr(wx.ItemAttr(colText=wx.Colour('BLACK'), colBack=wx.Colour('DARK GREY'), font=wx.Font(wx.FontInfo(10).Bold())))

        # Enable checkboxes
        if hasattr(self.list, 'EnableCheckBoxes'):
            self.list.EnableCheckBoxes()

        self.Refresh()

        self.title_ctrl = wx.SearchCtrl(self, style=wx.TE_LEFT)
        title_ctrl_default_height = self.title_ctrl.GetSize().height
        self.title_ctrl.SetMinSize((500, title_ctrl_default_height))
        self.title_ctrl.ShowCancelButton(True)
        self.title_ctrl.SetDescriptiveText(_("Title"))
        self.title_ctrl.ShowSearchButton(False)
        self.title_ctrl.SetToolTip(_("Title of the tool"))

        self.command_ctrl = wx.SearchCtrl(self, style=wx.TE_LEFT)
        self.command_ctrl.ShowCancelButton(True)
        self.command_ctrl.SetDescriptiveText(_("Command"))
        self.command_ctrl.ShowSearchButton(False)
        self.command_ctrl.SetToolTip(_("Command to run"))

        self.args_ctrl = wx.SearchCtrl(self, style=wx.TE_LEFT)
        self.args_ctrl.ShowCancelButton(True)
        self.args_ctrl.SetDescriptiveText(_("Arguments"))
        self.args_ctrl.ShowSearchButton(False)
        self.args_ctrl.SetToolTip(_("Arguments to pass to the command"))

        self.directory_ctrl = wx.SearchCtrl(self, style=wx.TE_LEFT)
        self.directory_ctrl.ShowCancelButton(True)
        self.directory_ctrl.SetDescriptiveText(_("Directory"))
        self.directory_ctrl.ShowSearchButton(False)
        self.directory_ctrl.SetToolTip(_("Directory to run the command in"))

        shell_method_choices = [_("Method 1"), _("Method 2"), _("Method 3"), _("Method 4")]
        self.shell_method_choice = wx.Choice(self, choices=shell_method_choices)
        self.shell_method_choice.SetSelection(2)
        self.shell_method_choice.SetToolTip(_("Shell method to use\nMethod 3 is recommended."))

        self.run_detached_checkbox = wx.CheckBox(self, label=_("Run Detached"))
        self.run_detached_checkbox.SetValue(True)
        self.run_detached_checkbox.SetToolTip(_("Run the command detached"))

        self.enabled_checkbox = wx.CheckBox(self, label=_("Enabled"))
        self.enabled_checkbox.SetToolTip(_("Enable the tool"))

        self.add_button = wx.Button(self, label=_("Add"))
        self.add_button.SetToolTip(_("Add a new tool"))
        self.add_button.Disable()

        self.add_separator = wx.Button(self, label=_("Add Separator"))
        self.add_separator.SetToolTip(_("Add a separator"))
        self.add_separator.Disable()

        self.remove_button = wx.Button(self, label=_("Remove"))
        self.remove_button.SetToolTip(_("Remove the selected tool"))
        self.remove_button.Disable()

        self.update_button = wx.Button(self, label=_("Update"))
        self.update_button.SetToolTip(_("Update the selected tool"))
        self.update_button.Disable()

        self.up_button = wx.Button(self, label=_("Up"))
        self.up_button.SetToolTip(_("Move selected tool up"))
        self.up_button.Disable()

        self.down_button = wx.Button(self, label=_("Down"))
        self.down_button.SetToolTip(_("Move selected tool down"))
        self.down_button.Disable()

        self.close_button = wx.Button(self, label=_("Close"))
        self.close_button.SetToolTip(_("Close this dialog"))

        vSizer = wx.BoxSizer(wx.VERTICAL)

        entry_vSizer = wx.BoxSizer(wx.VERTICAL)
        entry_vSizer.Add(self.title_ctrl, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.command_ctrl, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.args_ctrl, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.directory_ctrl, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.shell_method_choice, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.run_detached_checkbox, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.enabled_checkbox, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.AddSpacer(40)
        entry_vSizer.Add(self.add_button, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 10)
        entry_vSizer.Add(self.add_separator, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 10)
        entry_vSizer.Add(self.remove_button, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 10)
        entry_vSizer.Add(self.update_button, 0, wx.EXPAND | wx.ALL, 10)
        entry_vSizer.Add(self.up_button, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 10)
        entry_vSizer.Add(self.down_button, 0, wx.EXPAND | wx.ALL, 10)
        entry_vSizer.AddStretchSpacer()
        entry_vSizer.Add(self.close_button, 0, wx.EXPAND | wx.ALL, 10)

        main_hSizer = wx.BoxSizer(wx.HORIZONTAL)
        main_hSizer.Add(self.list, 1, wx.ALL|wx.EXPAND, 10)
        main_hSizer.Add(entry_vSizer, 2, wx.ALL|wx.EXPAND, 0)

        vSizer.Add(main_hSizer , 1, wx.ALL|wx.EXPAND, 10)

        self.SetSizer(vSizer)
        self.Layout()
        self.Centre(wx.BOTH)

        self.list.PostSizeEventToParent()
        self.SetSizerAndFit(vSizer)

        # Connect Events
        self.add_button.Bind(wx.EVT_BUTTON, self.OnAdd)
        self.add_separator.Bind(wx.EVT_BUTTON, self.OnAddSeparator)
        self.remove_button.Bind(wx.EVT_BUTTON, self.OnRemove)
        self.update_button.Bind(wx.EVT_BUTTON, self.OnUpdate)
        self.up_button.Bind(wx.EVT_BUTTON, self.OnMoveUp)
        self.down_button.Bind(wx.EVT_BUTTON, self.OnMoveDown)
        self.close_button.Bind(wx.EVT_BUTTON, self.OnClose)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self.list)
        self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.OnItemDeSelected, self.list)
        self.title_ctrl.Bind(wx.EVT_TEXT, self.on_command_change)
        self.args_ctrl.Bind(wx.EVT_TEXT, self.on_args_change)
        self.directory_ctrl.Bind(wx.EVT_TEXT, self.on_directory_change)
        self.Bind(wx.EVT_SIZE, self.OnResize)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    # -----------------------------------------------
    #              Function PopulateList
    # -----------------------------------------------
    def PopulateList(self):
        try:
            self.list.ClearAll()  # Clear existing items and columns
            self.list.InsertColumn(0, "Tools", width=wx.LIST_AUTOSIZE_USEHEADER)

            min_width = 250  # Minimum column width
            max_width = 500  # Maximum column width
            max_text_width = 0  # Track the maximum text width

            if self.mytools:
                for key, data in self.mytools.items():
                    index = self.list.InsertItem(self.list.GetItemCount(), data["title"])
                    if data["enabled"]:
                        self.list.CheckItem(index, check=True)
                    else:
                        self.list.SetItemTextColour(index, wx.Colour(128, 128, 128))
                        self.list.CheckItem(index, check=False)

                    # Measure text width of the current item
                    text_width = self.list.GetTextExtent(data["title"])[0]
                    if text_width > max_text_width:
                        max_text_width = text_width

            # Adjust column width based on text width, within min and max bounds
            column_width = max(min_width, min(max_text_width + 30, max_width))
            self.list.SetColumnWidth(0, column_width)

            self.list.GetParent().Layout()
        except Exception as e:
            print(f"Error: {e}")
            traceback.print_exc()

    # -----------------------------------------------
    #                  on_command_change
    # -----------------------------------------------
    def on_command_change(self, event):
        text = self.title_ctrl.GetValue()
        if text.strip():
            self.add_button.Enable()
            self.add_separator.Enable()
            self.remove_button.Enable()
        else:
            self.add_button.Disable()
            self.add_separator.Disable()
            self.remove_button.Disable()

    # -----------------------------------------------
    #                  on_args_change
    # -----------------------------------------------
    def on_args_change(self, event):
        self.update_button.Enable()

    # -----------------------------------------------
    #                  on_directory_change
    # -----------------------------------------------
    def on_directory_change(self, event):
        self.update_button.Enable()

    # -----------------------------------------------
    #                  load_mytools
    # -----------------------------------------------
    def load_mytools(self):
        if os.path.exists(get_mytools_file_path()):
            try:
                with open(get_mytools_file_path(), "r", encoding='ISO-8859-1', errors="replace") as file:
                    data = json5.load(file)
                    self.mytools = data.get('tools', {})
                    self.count = data.get('count', 0)
            except FileNotFoundError:
                self.mytools = {}
                self.count = 0
        else:
            self.mytools = {}
            self.count = 0

    # -----------------------------------------------
    #                  save_mytools
    # -----------------------------------------------
    def save_mytools(self):
        data = {
            'tools': self.mytools,
            'count': self.count
        }
        with open(get_mytools_file_path(), "w", encoding='ISO-8859-1', errors="replace") as file:
            json.dump(data, file, indent=4)

    # -----------------------------------------------
    #                  OnClose
    # -----------------------------------------------
    def OnClose(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Close Customize My Tools Dialog")
        self.EndModal(wx.ID_CANCEL)

    # -----------------------------------------------
    #                  OnAdd
    # -----------------------------------------------
    def OnAdd(self, e):
        try:
            if self.title_ctrl.Value:
                self._on_spin('start')
                self.add_to_mytools()
                self._on_spin('stop')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while adding to mytools")
            puml("#red:Encountered an error while adding to mytools;\n")
            self._on_spin('stop')
            traceback.print_exc()

    # -----------------------------------------------
    #                  OnAddSeparator
    # -----------------------------------------------
    def OnAddSeparator(self, e):
        try:
            if self.title_ctrl.Value:
                self._on_spin('start')
                self.add_to_mytools(separator=True)
                self._on_spin('stop')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while adding to mytools")
            puml("#red:Encountered an error while adding to mytools;\n")
            self._on_spin('stop')
            traceback.print_exc()

    # -----------------------------------------------
    #                  OnRemove
    # -----------------------------------------------
    def OnRemove(self, e):
        selection = self.list.GetFirstSelected()
        if selection != -1:
            item_id = str(selection + 1)
            self.list.DeleteItem(selection)
            if item_id in self.mytools:
                del self.mytools[item_id]
                # Renumber the remaining items
                new_mytools = {}
                for new_index, (old_key, value) in enumerate(self.mytools.items(), start=1):
                    new_mytools[str(new_index)] = value
                self.mytools = new_mytools
                # Update count
                self.count = len(self.mytools)
                self.save_mytools()
                self.Refresh()

    # -----------------------------------------------
    #                  OnUpdate
    # -----------------------------------------------
    def OnUpdate(self, e):
        selection = self.list.GetFirstSelected()
        if selection == -1:
            print("No item selected for update.")
            return
        item_id = str(selection + 1)
        self.add_to_mytools(update_index=item_id)
        self.list.Select(selection)

    # -----------------------------------------------
    #                  OnMoveUp
    # -----------------------------------------------
    def OnMoveUp(self, e):
        selection = self.list.GetFirstSelected()
        # Check if it's not the first item
        if selection > 0:
            # Swap items in self.mytools
            item_id = str(selection + 1)
            above_item_id = str(selection)
            self.mytools[item_id], self.mytools[above_item_id] = self.mytools[above_item_id], self.mytools[item_id]

            # Update GUI list
            self.RefreshList()
            # Select the item in its new position
            self.list.Select(selection - 1)

    # -----------------------------------------------
    #                  OnMoveDown
    # -----------------------------------------------
    def OnMoveDown(self, e):
        selection = self.list.GetFirstSelected()
        # Check if it's not the last item
        if selection < self.list.GetItemCount() - 1:
            # Swap items in self.mytools
            item_id = str(selection + 1)
            below_item_id = str(selection + 2)
            self.mytools[item_id], self.mytools[below_item_id] = self.mytools[below_item_id], self.mytools[item_id]

            self.RefreshList()
            # Select the item in its new position
            self.list.Select(selection + 1)

    # -----------------------------------------------
    #                  OnItemDeSelected
    # -----------------------------------------------
    def OnItemDeSelected(self, event):
        self.title_ctrl.Clear()
        self.command_ctrl.Clear()
        self.args_ctrl.Clear()
        self.directory_ctrl.Clear()
        self.enabled_checkbox.SetValue(False)
        self.up_button.Disable()
        self.down_button.Disable()
        self.remove_button.Disable()
        self.update_button.Disable()
        event.Skip()

    # -----------------------------------------------
    #                  OnItemSelected
    # -----------------------------------------------
    def OnItemSelected(self, event):
        item_index = event.Index
        item_id = str(item_index + 1)

        if item_id in self.mytools:
            tool_data = self.mytools[item_id]

            # Update UI controls with the selected tool's data
            self.title_ctrl.SetValue(tool_data.get("title", ""))
            self.command_ctrl.SetValue(tool_data.get("command", ""))
            self.args_ctrl.SetValue(tool_data.get("arguments", ""))
            self.directory_ctrl.SetValue(tool_data.get("directory", ""))
            self.enabled_checkbox.SetValue(tool_data.get("enabled", False))
            self.shell_method_choice.SetStringSelection(tool_data.get("method", "Method 3"))
            self.shell_method_choice.Enable()
            self.run_detached_checkbox.SetValue(tool_data.get("detached", True))
            self.run_detached_checkbox.Enable()
            self.update_button.Enable()
            self.remove_button.Enable()

            if item_index == 0:
                self.up_button.Disable()
            else:
                self.up_button.Enable()

            if item_index == len(self.mytools) - 1:
                self.down_button.Disable()
            else:
                self.down_button.Enable()
        else:
            print(f"Tool ID {item_id} not found in the tools list.")

        event.Skip()

    # -----------------------------------------------
    #          Function add_to_mytools
    # -----------------------------------------------
    def add_to_mytools(self, update_index=None, separator=False):
        if separator:
            title = "---"
            command = ""
            arguments = ""
            directory = ""
            enabled = True
            method = "Method 3"
            detached = False
        else:
            title = self.title_ctrl.GetValue()
            command = self.command_ctrl.GetValue()
            arguments = self.args_ctrl.GetValue()
            directory = self.directory_ctrl.GetValue()
            enabled = self.enabled_checkbox.GetValue()
            method = self.shell_method_choice.GetStringSelection()
            detached = self.run_detached_checkbox.GetValue()
        record = {
            "title": title,
            "command": command,
            "arguments": arguments,
            "directory": directory,
            "method": method,
            "detached": detached,
            "enabled": enabled
        }
        if update_index is None:
            # Adding a new tool
            self.count += 1
            self.mytools[str(self.count)] = record
        else:
            # Updating an existing tool
            if str(update_index) in self.mytools:
                self.mytools[str(update_index)] = record
            else:
                print(f"No tool found at index {update_index} to update.")
        self.save_mytools()
        self.Refresh()

    # -----------------------------------------------
    #                  Function Refresh
    # -----------------------------------------------
    def Refresh(self):
        self.list.Freeze()
        self.list.ClearAll()
        self.PopulateList()
        self.list.Thaw()

    # -----------------------------------------------
    #                  Function RefreshList
    # -----------------------------------------------
    def RefreshList(self):
        self.list.DeleteAllItems()
        sorted_tools = sorted(self.mytools.items(), key=lambda x: int(x[0]))
        for item_id, tool in sorted_tools:
            # Insert each tool's title into the list at the next available index
            index = self.list.InsertItem(self.list.GetItemCount(), tool['title'])
        self.save_mytools()

    # -----------------------------------------------
    #                  Function OnResize
    # -----------------------------------------------
    def OnResize(self, event):
        list_size = self.list.GetSize()
        self.list.SetColumnWidth(0, list_size.GetWidth() - 5)
        self.Layout()
        # event.Skip()

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        wx.YieldIfNeeded()
        if state == 'start':
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
            self.Parent._on_spin('start')
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.Parent._on_spin('stop')

```

`package_manager.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import json
import math
import time
import os

import pyperclip
import darkdetect
import traceback
import wx
import wx.html
import wx.lib.mixins.listctrl as listmix
import wx.lib.wxpTag
import contextlib

import images as images
from runtime import *

from datetime import datetime, timedelta
from i18n import _


# ============================================================================
#                               Class ListCtrl
# ============================================================================
class ListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)


# ============================================================================
#                               Class SuPermissionDialog
# ============================================================================
class SuPermissionDialog(wx.Dialog):
    def __init__(self, parent, pkg, uid, label=None):
        super().__init__(parent, title=_("Set SU Permission"))
        self.pkg = pkg
        self.uid = uid

        # Label
        if label is not None:
            label_text = wx.StaticText(self, label=label)
        else:
            label_text = wx.StaticText(self, label=_("Enter SU Permission details:"))
        font = label_text.GetFont()
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        label_text.SetFont(font)

        # Checkbox for notification
        self.notification_checkbox = wx.CheckBox(self, label=_("Enable Notification"))

        # Checkbox for logging
        self.logging_checkbox = wx.CheckBox(self, label=_("Enable Logging"))

        # Dropdown for Until
        until_choices = [_('Forever'), _('10 mins'), _('20 mins'), _('30 mins'), _('60 mins')]
        self.until_dropdown = wx.ComboBox(self, choices=until_choices, style=wx.CB_DROPDOWN| wx.CB_READONLY)
        # Set "Forever" as the default selection
        self.until_dropdown.SetSelection(0)

        # Buttons
        allow_button = wx.Button(self, label=_("Allow"))
        deny_button = wx.Button(self, label=_("Deny"))
        revoke_button = wx.Button(self, label=_("Revoke"))
        cancel_button = wx.Button(self, label=_("Cancel"))

        # Bind buttons to functions
        allow_button.Bind(wx.EVT_BUTTON, self.OnAllow)
        deny_button.Bind(wx.EVT_BUTTON, self.OnDeny)
        revoke_button.Bind(wx.EVT_BUTTON, self.OnRevoke)
        cancel_button.Bind(wx.EVT_BUTTON, self.OnCancel)

        # Sizer to arrange the elements
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(label_text, 0, wx.ALL, 10)
        sizer.Add(self.notification_checkbox, 0, wx.ALL, 10)
        sizer.Add(self.logging_checkbox, 0, wx.ALL, 10)
        sizer.Add(self.until_dropdown, 0, wx.ALL, 10)

        button_sizer = wx.BoxSizer(wx.HORIZONTAL)
        button_sizer.Add(allow_button, 0, wx.ALL, 10)
        button_sizer.Add(deny_button, 0, wx.ALL, 10)
        button_sizer.Add(revoke_button, 0, wx.ALL, 10)
        button_sizer.Add(cancel_button, 0, wx.ALL, 10)

        sizer.Add(button_sizer, 0, wx.ALIGN_CENTER)

        self.SetSizerAndFit(sizer)
        self.Bind(wx.EVT_CLOSE, self.OnCancel)

    def OnAllow(self, event):
        until_text = self.until_dropdown.GetValue()
        until = self.ComputeEpoch(until_text)
        notification = self.notification_checkbox.GetValue()
        logging = self.logging_checkbox.GetValue()
        print(f"\nAllow button clicked. Until: {until_text}, Notification: {notification}, Logging: {logging}, Epoch: {until}")
        device = get_phone()
        if device:
            device.magisk_update_su(uid=self.uid, policy='allow', logging=logging, notification=notification, until=until)
        self.EndModal(wx.ID_CANCEL)

    def OnDeny(self, event):
        until_text = self.until_dropdown.GetValue()
        until = self.ComputeEpoch(until_text)
        notification = self.notification_checkbox.GetValue()
        logging = self.logging_checkbox.GetValue()
        print(f"\nDeny button clicked. Until: {until_text}, Notification: {notification}, Logging: {logging}, Epoch: {until}")
        device = get_phone()
        if device:
            device.magisk_update_su(uid=self.uid, policy='deny', logging=logging, notification=notification, until=until)
        self.EndModal(wx.ID_CANCEL)

    def OnRevoke(self, event):
        until_text = _('Revoke')
        until = self.ComputeEpoch(until_text)
        print(f"\nRevoke button clicked. Until: {until_text}, Notification: 1, Logging: 1, Epoch: {until}")
        device = get_phone()
        if device:
            device.magisk_update_su(uid=self.uid, policy='deny', logging=1, notification=1, until=until)
        self.EndModal(wx.ID_CANCEL)

    def OnCancel(self, event):
        print("\nUser pressed Cancel")
        self.EndModal(wx.ID_CANCEL)

    def ComputeEpoch(self, until):
        # Compute the epoch value based on the 'until' dropdown choice
        now = datetime.now()
        if until == _('Forever'):
            return 0
        elif until == _('10 mins'):
            future = now + timedelta(minutes=10)
        elif until == _('20 mins'):
            future = now + timedelta(minutes=20)
        elif until == _('30 mins'):
            future = now + timedelta(minutes=30)
        elif until == _('60 mins'):
            future = now + timedelta(minutes=60)
        elif until == _('Revoke'):
            future = now - timedelta(minutes=1)
        else:
            return 0

        return int(future.timestamp())


# ============================================================================
#                               Class PackageManager
# ============================================================================
class PackageManager(wx.Dialog, listmix.ColumnSorterMixin):
    def __init__(self, *args, simplified_mode=False, **kwargs):
        wx.Dialog.__init__(self, *args, **kwargs, style = wx.RESIZE_BORDER | wx.DEFAULT_DIALOG_STYLE)
        self.simplified_mode = simplified_mode

        if simplified_mode:
            self.SetTitle(_("Select Package for TargetedFix Target"))
            self.selected_package = None
        else:
            self.SetTitle(_("Manage Packages on the Device"))
        self.package_count = 0
        self.all_cb_clicked = False
        self.download_folder = None
        self.abort = False
        self.show_system_apps = True
        self.show_user_apps = True
        self.device = get_phone(True)
        self.aapt2_pushed_this_session = False

        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            wx.MessageBox(_("❌ ERROR: You must first select a valid device."), _("Error"), wx.OK | wx.ICON_ERROR)
            self.Close()
            return

        res = self.device.get_detailed_packages(simplified=self.simplified_mode)
        if res == 0:
            self.packages = self.device.packages
            self.package_count = len(self.packages)
            #items = self.device.packages.items()
        else:
            self.packages = {}
            self.package_count = 0

        splitter = wx.SplitterWindow(self, -1)
        splitter.SetMinimumPaneSize(400)
        panel1 = wx.Panel(splitter, -1)
        panel2 = wx.Panel(splitter, -1)

        vSizer = wx.BoxSizer(wx.VERTICAL)
        vSizer.Add(splitter, 1, wx.EXPAND)

        vSizer1 = wx.BoxSizer(wx.VERTICAL)
        vSizer2 = wx.BoxSizer(wx.VERTICAL)

        message_sizer = wx.BoxSizer(wx.HORIZONTAL)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        self.message_label = wx.StaticText(panel1, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        self.message_label.Wrap(-1)
        self.message_label.Label = _("%s Packages") % self.package_count
        self.message_label.SetFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, "Arial"))
        self.searchCtrl = wx.SearchCtrl(panel1, style=wx.TE_PROCESS_ENTER)
        self.searchCtrl.ShowCancelButton(True)

        message_sizer.Add(self.message_label, 0, wx.ALL, 20)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        vSizer1.Add(message_sizer, 0, wx.EXPAND, 5)

        hSizer1 = wx.BoxSizer( wx.HORIZONTAL )
        self.all_checkbox = wx.CheckBox(panel1, wx.ID_ANY, _("Check / Uncheck All"), wx.DefaultPosition, wx.DefaultSize, style=wx.CHK_3STATE)
        self.system_apps_checkbox = wx.CheckBox(panel1, wx.ID_ANY, _("Show System apps"), wx.DefaultPosition, wx.DefaultSize)
        self.system_apps_checkbox.SetValue(True)
        self.user_apps_checkbox = wx.CheckBox(panel1, wx.ID_ANY, _("Show 3rd Party apps"), wx.DefaultPosition, wx.DefaultSize)
        if self.simplified_mode:
            self.user_apps_checkbox.SetValue(False)
            self.show_user_apps = False
        else:
            self.user_apps_checkbox.SetValue(True)

        self.button_get_names = wx.Button( panel1, wx.ID_ANY, _("Get Application Names"), wx.DefaultPosition, wx.DefaultSize, 0 )
        self.button_get_names.SetToolTip(_("Extracts App names, and caches them for faster loading in the future.\nNOTE: This could take a while."))
        hSizer1.Add( (10, 0), 0, wx.EXPAND, 5 )
        hSizer1.Add(self.all_checkbox, 0, wx.EXPAND, 5)
        hSizer1.Add( (10, 0), 0, wx.EXPAND, 5 )
        hSizer1.Add(self.system_apps_checkbox, 0, wx.EXPAND, 5)
        hSizer1.Add( (10, 0), 0, wx.EXPAND, 5 )
        hSizer1.Add(self.user_apps_checkbox, 0, wx.EXPAND, 5)
        hSizer1.Add( (0, 0), 1, wx.EXPAND, 5 )
        hSizer1.Add(self.searchCtrl, 1, wx.EXPAND)
        hSizer1.Add( (0, 0), 1, wx.EXPAND, 5 )
        hSizer1.Add( self.button_get_names, 0, wx.RIGHT, 28 )
        vSizer1.Add(hSizer1, 0, wx.EXPAND, 5)

        self.il = wx.ImageList(16, 16)

        self.idx1 = self.il.Add(images.official_16.GetBitmap())
        self.sm_up = self.il.Add(images.SmallUpArrow.GetBitmap())
        self.sm_dn = self.il.Add(images.SmallDnArrow.GetBitmap())

        self.list  = ListCtrl(panel1, -1, size=(-1, -1), style=wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.BORDER_NONE)
        if sys.platform == "win32":
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLACK'),wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10).Bold())))
        self.list.SetImageList(self.il, wx.IMAGE_LIST_SMALL)
        self.list.EnableCheckBoxes(enable=True)
        listmix.ColumnSorterMixin.__init__(self, 8)

        vSizer1.Add(self.list , 1, wx.ALL|wx.EXPAND, 5)

        panel1.SetSizer(vSizer1)
        panel1.Layout()
        panel1.Centre(wx.BOTH)

        # Panel 2
        self.details = wx.TextCtrl(panel2, style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_RICH2 | wx.HSCROLL, size=(-1, -1))
        if sys.platform == "win32":
            self.details.SetFont(wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL))

        vSizer2.Add(self.details , 1, wx.EXPAND, 5)

        buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        if self.simplified_mode:
            # Simplified mode: only Add Target and Cancel buttons
            self.add_target_button = wx.Button(panel2, wx.ID_OK, _("Add Target"))
            self.add_target_button.SetToolTip(_("Add selected package as TargetedFix target"))
            self.add_target_button.Enable(False)
            buttons_sizer.Add(self.add_target_button, 0, wx.ALL, 20)

            self.close_button = wx.Button(panel2, wx.ID_CANCEL, _("Cancel"))
        else:
            # Full mode: all the original buttons
            self.disable_button = wx.Button(panel2, wx.ID_ANY, _("Disable"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.disable_button.SetToolTip(_("Disable checked packages"))
            self.disable_button.Enable(False)
            buttons_sizer.Add(self.disable_button, 0, wx.ALL, 20)

            self.enable_button = wx.Button(panel2, wx.ID_ANY, _("Enable"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.enable_button.SetToolTip(_("Enable checked packages"))
            self.enable_button.Enable(False)
            buttons_sizer.Add(self.enable_button, 0, wx.ALL, 20)

            self.uninstall_button = wx.Button(panel2, wx.ID_ANY, _("Uninstall"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.uninstall_button.SetToolTip(_("Uninstall checked packages"))
            self.uninstall_button.Enable(False)
            buttons_sizer.Add(self.uninstall_button, 0, wx.ALL, 20)

            self.add_to_deny_button = wx.Button(panel2, wx.ID_ANY, _("Add to Denylist"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.add_to_deny_button.SetToolTip(_("Add package to Magisk Denylist"))
            self.add_to_deny_button.Enable(False)
            buttons_sizer.Add(self.add_to_deny_button, 0, wx.ALL, 20)

            self.rm_from_deny_button = wx.Button(panel2, wx.ID_ANY, _("Remove from Denylist"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.rm_from_deny_button.SetToolTip(_("Remove package from Magisk Denylist"))
            self.rm_from_deny_button.Enable(False)
            buttons_sizer.Add(self.rm_from_deny_button, 0, wx.ALL, 20)

            self.install_apk_button = wx.Button(panel2, wx.ID_ANY, _("Install APK"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.install_apk_button.SetToolTip(_("Install an APK on the device"))
            buttons_sizer.Add(self.install_apk_button, 0, wx.ALL, 20)

            self.download_apk_button = wx.Button(panel2, wx.ID_ANY, _("Download APK"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.download_apk_button.SetToolTip(_("Extract and download APK"))
            self.download_apk_button.Enable(False)
            buttons_sizer.Add(self.download_apk_button, 0, wx.ALL, 20)

            self.export_list_button = wx.Button(panel2, wx.ID_ANY, _("Export List"), wx.DefaultPosition, wx.DefaultSize, 0)
            self.export_list_button.SetToolTip(_("Export the package list in CSV format"))
            buttons_sizer.Add(self.export_list_button, 0, wx.ALL, 20)

            self.close_button = wx.Button(panel2, wx.ID_ANY, _("Close"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.close_button.SetToolTip(_("Closes this dialog"))
        buttons_sizer.Add(self.close_button, 0, wx.ALL, 20)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        vSizer2.Add(buttons_sizer, 0, wx.EXPAND, 5)

        panel2.SetSizer(vSizer2)
        panel2.Layout()
        panel2.Centre(wx.BOTH)

        splitter.SplitHorizontally(panel1, panel2)

        # Autosize the dialog
        self.list.PostSizeEventToParent()
        self.SetSizerAndFit(vSizer)
        self.SetSize(vSizer.MinSize.Width + 80, vSizer.MinSize.Height + 620)

        # Connect Events
        self.searchCtrl.Bind(wx.EVT_TEXT_ENTER, self.OnSearch)
        # Bind EVT_TEXT to get dynamic filtering as the user types
        self.searchCtrl.Bind(wx.EVT_TEXT, self.OnSearch)
        self.searchCtrl.Bind(wx.EVT_SEARCH, self.OnSearch)
        self.searchCtrl.Bind(wx.EVT_SEARCHCTRL_CANCEL_BTN, self.OnCancel)
        self.button_get_names.Bind(wx.EVT_BUTTON, self.OnGetAppNames)

        if not self.simplified_mode:
            # Full mode event bindings
            self.disable_button.Bind(wx.EVT_BUTTON, self.OnDisable)
            self.enable_button.Bind(wx.EVT_BUTTON, self.OnEnable)
            self.uninstall_button.Bind(wx.EVT_BUTTON, self.OnUninstall)
            self.add_to_deny_button.Bind(wx.EVT_BUTTON, self.OnAddToDeny)
            self.rm_from_deny_button.Bind(wx.EVT_BUTTON, self.OnRmFromDeny)
            self.install_apk_button.Bind(wx.EVT_BUTTON, self.OnInstallApk)
            self.download_apk_button.Bind(wx.EVT_BUTTON, self.OnDownloadApk)
            self.export_list_button.Bind(wx.EVT_BUTTON, self.OnExportList)
            # Enable checkboxes for full mode
            self.list.EnableCheckBoxes(enable=True)
            self.list.Bind(wx.EVT_LIST_ITEM_CHECKED, self.OnItemCheck)
            self.list.Bind(wx.EVT_LIST_ITEM_UNCHECKED, self.OnItemUncheck)
            self.all_checkbox.Bind(wx.EVT_CHECKBOX, self.OnAllCheckbox)
        else:
            # Simplified mode: disable checkboxes, enable double-click
            self.list.EnableCheckBoxes(enable=False)
            self.list.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.OnItemActivated)
            # Hide the "Check/Uncheck All" checkbox in simplified mode
            self.all_checkbox.Show(False)
            # Add missing packages for simplified mode
            self.add_missing_packages_for_simplified_mode("gms")

        self.close_button.Bind(wx.EVT_BUTTON, self.OnClose)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self.list)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.OnColClick, self.list)
        self.list.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        # for wxMSW
        self.list.Bind(wx.EVT_COMMAND_RIGHT_CLICK, self.OnRightClick)
        # for wxGTK
        self.list.Bind(wx.EVT_RIGHT_UP, self.OnRightClick)
        self.system_apps_checkbox.Bind(wx.EVT_CHECKBOX, self.OnSystemAppsCheckbox)
        self.user_apps_checkbox.Bind(wx.EVT_CHECKBOX, self.OnUserAppsCheckbox)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        self.Refresh()

        # Set focus on search control after initialization
        wx.CallAfter(self.searchCtrl.SetFocus)

    # -----------------------------------------------
    #              Function PopulateList
    # -----------------------------------------------
    def PopulateList(self):
        info = wx.ListItem()
        info.Mask = wx.LIST_MASK_TEXT | wx.LIST_MASK_IMAGE | wx.LIST_MASK_FORMAT
        info.Image = -1
        info.Align = 0
        info.Width = -1
        info.SetWidth(-1)
        info.Text = "Package"
        self.list.InsertColumn(0, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "Type"
        self.list.InsertColumn(1, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "Installed"
        self.list.InsertColumn(2, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "Enabled"
        self.list.InsertColumn(3, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "User 0"
        self.list.InsertColumn(4, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "Denylist"
        self.list.InsertColumn(5, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "UID"
        self.list.InsertColumn(6, info)

        info.Align = wx.LIST_FORMAT_LEFT # 0
        info.Text = "Name"
        self.list.InsertColumn(7, info)

        itemDataMap = {}
        query = self.searchCtrl.GetValue().lower()
        if self.packages:
            i = 0
            items = self.packages.items()
            for key, data in items:
                alltext = f"{key.lower()} {str(data.label.lower())}"
                if query.lower() in alltext:
                    if data.type and ((data.type == 'System' and not self.show_system_apps) or (data.type == '3rd Party' and not self.show_user_apps)):
                        continue  # Skip this item
                    index = self.list.InsertItem(self.list.GetItemCount(), key)
                    if data.type:
                        itemDataMap[i + 1] = (key, data.type, data.installed, data.enabled, data.user0, data.magisk_denylist, data.uid, data.label)
                        row = self.list.GetItem(index)
                        self.list.SetItem(index, 1, data.type)
                        self.list.SetItem(index, 2, str(data.installed))
                        self.list.SetItem(index, 3, str(data.enabled))
                        self.list.SetItem(index, 4, str(data.user0))
                        self.list.SetItem(index, 5, str(data.magisk_denylist))
                        self.list.SetItem(index, 6, str(data.uid))
                        self.list.SetItem(index, 7, str(data.label))
                        if data.type == 'System':
                            row.SetTextColour(wx.RED)
                        elif darkdetect.isLight():
                            row.SetTextColour(wx.BLUE)
                        else:
                            row.SetTextColour(wx.CYAN)
                        if not data.enabled:
                            row.SetTextColour(wx.LIGHT_GREY)
                        self.list.SetItem(row)
                        self.list.SetItemData(index, i + 1)
                    # hide image
                    self.list.SetItemColumnImage(i, 0, -1)
                    i += 1
            res = self.push_aapt2_if_needed()
            self.message_label.Label = _("%s / %s Packages") % (str(i), self.package_count)
        self.list.SetColumnWidth(0, -2)
        grow_column(self.list, 0, 20)
        self.list.SetColumnWidth(1, -2)
        grow_column(self.list, 1, 20)
        self.list.SetColumnWidth(2, -2)
        grow_column(self.list, 2, 20)
        self.list.SetColumnWidth(3, -2)
        grow_column(self.list, 3, 20)
        self.list.SetColumnWidth(4, -2)
        grow_column(self.list, 4, 20)
        self.list.SetColumnWidth(5, -2)
        grow_column(self.list, 5, 20)
        self.list.SetColumnWidth(6, -2)
        grow_column(self.list, 6, 20)
        self.list.SetColumnWidth(7, 200)
        grow_column(self.list, 7, 20)

        self.currentItem = 0
        if itemDataMap:
            return itemDataMap
        else:
            return -1

    # -----------------------------------------------
    #                  OnColClick
    # -----------------------------------------------
    def OnColClick(self, event):
        col = event.GetColumn()
        if col == -1:
            return # clicked outside any column.
        rowid = self.list.GetColumn(col)
        print(f"Sorting on Column {rowid.GetText()}")
        event.Skip()

    # -----------------------------------------------
    #          Function GetPackageDetails
    # -----------------------------------------------
    def GetPackageDetails(self, pkg, skip_details = False, ):
        package = self.packages[pkg]
        labels = get_labels()
        if package.details == '':
            package.details, package.path2 = self.device.get_package_details(pkg)
        elif package.path2 == '':
            package.path2 = self.device.get_path_from_details(package.details)
        path = package.path or package.path2
        if package.label == '':
            if path == '':
                path = self.device.get_package_path(pkg, False)
                if path != -1:
                    package.path = path
            label, icon = self.device.get_package_label(pkg, path)
            if label != -1:
                package.label = label
                package.icon = icon
                self.list.SetItem(self.currentItem, 7, label)
                row_as_list = list(self.itemDataMap[self.currentItem + 1])
                row_as_list[7] = label
                self.itemDataMap[self.currentItem + 1] = row_as_list
                labels[pkg] = label
                set_labels(labels)
        if not skip_details:
            path = package.path or package.path2
            self.details.SetValue(f"Application Name: {package.label}\nApplication Path: {path}\nApplication Icon: {package.icon}\n\n{package.details}")

    # -----------------------------------------------
    #              Function Check_UncheckAll
    # -----------------------------------------------
    def Check_UncheckAll(self, state):
        # Set this so that we skip processing OnItemChecked, OnItemUnchecked events
        self.Set_all_cb_clicked (True)
        itemcount = self.list.GetItemCount()
        [self.list.CheckItem(item=i, check=state) for i in range(itemcount)]
        if state:
            print("checking all Packages\n")
            self.EnableDisableButton(True)
        else:
            print("Unchecking all Packages\n")
            self.EnableDisableButton(False)
        self.Set_all_cb_clicked (False)

    # -----------------------------------------------
    #                  onSearch
    # -----------------------------------------------
    def OnSearch(self, event):
        query = self.searchCtrl.GetValue()
        print(f"Searching for: {query}")
        self.Refresh()

    # -----------------------------------------------
    #                  onCancel
    # -----------------------------------------------
    def OnCancel(self, event):
        self.searchCtrl.SetValue("")
        self.Refresh()

    # -----------------------------------------------
    #                  OnAllCheckbox
    # -----------------------------------------------
    def OnAllCheckbox(self, event):
        cb = event.GetEventObject()
        # print("\t3StateValue: %s\n" % cb.Get3StateValue())
        if cb.Get3StateValue() == 2:
            cb.Set3StateValue(2)
            self.Check_UncheckAll(False)
        elif cb.Get3StateValue() == 1:
            self.Check_UncheckAll(True)
        elif cb.Get3StateValue() == 0:
            self.Check_UncheckAll(False)

    # -----------------------------------------------
    #                  OnSystemAppsCheckbox
    # -----------------------------------------------
    def OnSystemAppsCheckbox(self, event):
        cb = event.GetEventObject()
        self.show_system_apps = cb.GetValue()
        self.Refresh()

    # -----------------------------------------------
    #                  OnUserAppsCheckbox
    # -----------------------------------------------
    def OnUserAppsCheckbox(self, event):
        cb = event.GetEventObject()
        self.show_user_apps = cb.GetValue()
        self.Refresh()

    # -----------------------------------------------
    #                  OnItemChecked
    # -----------------------------------------------
    def OnItemCheck(self, event):
        if self.Get_all_cb_clicked():
            return
        print(f"{event.Item.Text} is checked")
        self.Update_all_checkbox()

    # -----------------------------------------------
    #                  OnItemUnchecked
    # -----------------------------------------------
    def OnItemUncheck(self, event):
        if self.Get_all_cb_clicked():
            return
        print(f"{event.Item.Text} is unchecked")
        self.Update_all_checkbox()

    # -----------------------------------------------
    #         Function Get_all_cb_clicked
    # -----------------------------------------------
    def Get_all_cb_clicked(self):
        return self.all_cb_clicked

    # -----------------------------------------------
    #         Function Set_all_cb_clicked
    # -----------------------------------------------
    def Set_all_cb_clicked(self, value):
        self.all_cb_clicked = value

    # -----------------------------------------------
    #          Function Update_all_checkbox
    # -----------------------------------------------
    def Update_all_checkbox(self):
        i = 0
        for index in range(self.list.GetItemCount()):
            if self.list.IsItemChecked(index):
                # print(f"{self.list.GetItem(index).Text} item is checked")
                i += 1
        # print(f"Checked items count: {i}")
        if i == 0:
            self.all_checkbox.Set3StateValue(0)
            self.EnableDisableButton(False)
        elif i == self.package_count:
            self.all_checkbox.Set3StateValue(1)
            self.EnableDisableButton(True)
        else:
            self.all_checkbox.Set3StateValue(2)
            self.EnableDisableButton(True)

    # -----------------------------------------------
    #         Function GetItemsCheckedCount
    # -----------------------------------------------
    def GetItemsCheckedCount(self):
        checked_count = 0
        for i in range(self.list.GetItemCount()):
            if self.list.IsItemChecked(i):
                checked_count += 1
        return checked_count

    # -----------------------------------------------
    #                  EnableDisableButton
    # -----------------------------------------------
    def EnableDisableButton(self, state):
        self.disable_button.Enable(state)
        self.enable_button.Enable(state)
        self.uninstall_button.Enable(state)
        self.add_to_deny_button.Enable(state)
        self.rm_from_deny_button.Enable(state)
        self.download_apk_button.Enable(state)

    # -----------------------------------------------
    #                  OnClose
    # -----------------------------------------------
    def OnClose(self, e):
        try:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Close.")
            labels = get_labels()
            if (labels):
                with open(get_labels_file_path(), "w", encoding='ISO-8859-1', errors="replace") as f:
                    # Write the dictionary to the file in JSON format
                    json.dump(labels, f, indent=4)
            # Delete aapt2 from the device
            res = self.device.delete("/data/local/tmp/aapt2", self.device.rooted)
        except Exception:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to properly close the window.")
        finally:
            self.EndModal(wx.ID_CANCEL)

    # -----------------------------------------------
    #                  OnDisable
    # -----------------------------------------------
    def OnDisable(self, e):
        self._on_spin('start')
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Disable.")
        self.ApplyMultiAction('disable')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnEnable
    # -----------------------------------------------
    def OnEnable(self, e):
        self._on_spin('start')
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Enable.")
        self.ApplyMultiAction('enable')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnUninstall
    # -----------------------------------------------
    def OnUninstall(self, e):
        self._on_spin('start')
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Uninstall.")
        self.ApplyMultiAction('uninstall')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnAddToDeny
    # -----------------------------------------------
    def OnAddToDeny(self, e):
        self._on_spin('start')
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Add To Denylist.")
        self.ApplyMultiAction('add-to-denylist')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnRmFromDeny
    # -----------------------------------------------
    def OnRmFromDeny(self, e):
        self._on_spin('start')
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Remove Denylist.")
        self.ApplyMultiAction('rm-from-denylist')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnInstallApk
    # -----------------------------------------------
    def OnInstallApk(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Install APK.")
        self.Parent._on_install_apk(None)

    # -----------------------------------------------
    #                  OnGetAppNames
    # -----------------------------------------------
    def OnGetAppNames(self, e):
        self._on_spin('start')
        start = time.time()
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Get Application Names")
        labels = get_labels()

        # Check if any packages are selected (checked)
        selected_packages = []
        for i in range(self.list.GetItemCount()):
            if self.list.IsItemChecked(i):
                pkg = self.list.GetItemText(i)
                package = self.device.packages[pkg]
                selected_packages.append((i, pkg, package))

        if selected_packages:
            # Process only selected packages (even if they already have labels)
            packages_to_process = selected_packages
            print(f"\nProcessing {len(packages_to_process)} selected packages (including those with existing labels)...")
        else:
            # Process only packages without labels
            packages_to_process = []
            for i in range(self.list.GetItemCount()):
                pkg = self.list.GetItemText(i)
                package = self.device.packages[pkg]
                if package.label == '':
                    packages_to_process.append((i, pkg, package))
            print(f"\nNo selection made - processing {len(packages_to_process)} packages without labels...")

        if not packages_to_process:
            print("All packages already have labels")
            self._on_spin('stop')
            return

        total_packages = len(packages_to_process)
        for idx, (i, pkg, package) in enumerate(packages_to_process):
            print(f"Processing package {idx + 1}/{total_packages}: {pkg}")
            if idx % 5 == 0:  # Update UI every 5 packages to keep it responsive
                wx.YieldIfNeeded()

            if package.path == '':
                pkg_path = self.device.get_package_path(pkg, True)
                if pkg_path == -1:
                    continue
                package.path = pkg_path

            label, icon = self.device.get_package_label(pkg, package.path)
            if label != -1 and label != '':
                package.label = label
                package.icon = icon
                self.list.SetItem(i, 7, label)
                row_as_list = list(self.itemDataMap[i + 1])
                row_as_list[7] = label
                self.itemDataMap[i + 1] = row_as_list
                labels[pkg] = label
            else:
                # Set a placeholder label to avoid reprocessing this package in future runs
                placeholder_label = "N/A"
                package.label = placeholder_label
                package.icon = ""
                self.list.SetItem(i, 7, placeholder_label)
                row_as_list = list(self.itemDataMap[i + 1])
                row_as_list[7] = placeholder_label
                self.itemDataMap[i + 1] = row_as_list
                labels[pkg] = placeholder_label
                print(f"  -> Using placeholder label: {placeholder_label}")

        set_labels(labels)
        end = time.time()
        print(f"App names extraction time: {math.ceil(end - start)} seconds")
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnExportList
    # -----------------------------------------------
    def OnExportList(self, e):
        self._on_spin('start')
        start = time.time()
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Export List")
        with wx.FileDialog(self, _("Export Package list"), '', f"packages_{self.device.hardware}.csv", wildcard="Package list (*.csv)|*.csv",
                        style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return     # the user changed their mind
            # save the current contents in the file
            pathname = fileDialog.GetPath()
            content = "package,type,installed,enabled,user0,denylist,uid,name\n"
            for i in range(self.list.GetItemCount()):
                package = type = installed = enabled = user0 = denylist = uid = name = ''
                with contextlib.suppress(Exception):
                    package = self.list.GetItemText(i)
                with contextlib.suppress(Exception):
                    type = self.list.GetItemText(i, 1)
                with contextlib.suppress(Exception):
                    installed = self.list.GetItemText(i, 2)
                with contextlib.suppress(Exception):
                    enabled = self.list.GetItemText(i, 3)
                with contextlib.suppress(Exception):
                    user0 = self.list.GetItemText(i, 4)
                with contextlib.suppress(Exception):
                    denylist = self.list.GetItemText(i, 5)
                with contextlib.suppress(Exception):
                    uid = self.list.GetItemText(i, 6)
                with contextlib.suppress(Exception):
                    name = self.list.GetItemText(i, 7)
                content += f"{package},{type},{installed},{enabled},{user0},{denylist},{uid},{name}\n"
            with open(pathname, "w", encoding="utf-8", newline="\n") as f:
                f.write(content)
        end = time.time()
        print(f"Export Package List time: {math.ceil(end - start)} seconds")
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnDownloadApk
    # -----------------------------------------------
    def OnDownloadApk(self, e):
        self._on_spin('start')
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Download APK.")
        self.ApplyMultiAction('download')
        self._on_spin('stop')

    # -----------------------------------------------
    #                  DownloadApk
    # -----------------------------------------------
    def DownloadApk(self, pkg, multiple = False):
        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            return
        package = self.device.packages[pkg]
        path = package.path or package.path2
        if path == '':
            path = self.device.get_package_path(pkg, True)
            if path != -1:
                package.path = path
        if path == '':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to get apk path for {pkg}")
            print("Aborting download ...")
            return
        label = package.label
        label = self.getColumnText(self.currentItem, 7)
        if multiple:
            if not self.download_folder:
                with wx.DirDialog(None, _("Choose a directory where all apks should be saved."), style=wx.DD_DEFAULT_STYLE) as folderDialog:
                    if folderDialog.ShowModal() == wx.ID_CANCEL:
                        print("User Cancelled saving packages (option: folder).")
                        self.abort = True
                        return     # the user changed their mind
                    self.download_folder = folderDialog.GetPath()
                    print(f"Selected Download Directory: {self.download_folder}")
            pathname =  os.path.join(self.download_folder, f"{pkg}.apk")
        else:
            with wx.FileDialog(self, _("Download APK file"), '', f"{pkg}.apk", wildcard="APK files (*.apk)|*.apk", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print(f"User Cancelled saving package: {pkg}")
                    return     # the user changed their mind
                pathname = fileDialog.GetPath()
        try:
            if self.device:
                print(f"Downloading apk file to: {pathname}")
                self.device.pull_file(path, pathname)
        except IOError:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to save the apk file '{pathname}'.")

    # -----------------------------------------------
    #                  GetListCtrl
    # -----------------------------------------------
    # Used by the ColumnSorterMixin, see wx/lib/mixins/listctrl.py
    def GetListCtrl(self):
        return self.list

    # -----------------------------------------------
    #                  GetSortImages
    # -----------------------------------------------
    # Used by the ColumnSorterMixin, see wx/lib/mixins/listctrl.py
    def GetSortImages(self):
        return (self.sm_dn, self.sm_up)

    # -----------------------------------------------
    #                  OnRightDown
    # -----------------------------------------------
    def OnRightDown(self, event):
        x = event.GetX()
        y = event.GetY()
        # print("x, y = %s\n" % str((x, y)))
        item, flags = self.list.HitTest((x, y))
        if item != wx.NOT_FOUND and flags & wx.LIST_HITTEST_ONITEM:
            self.list.Select(item)
        event.Skip()

    # -----------------------------------------------
    #                  getColumnText
    # -----------------------------------------------
    def getColumnText(self, index, col):
        item = self.list.GetItem(index, col)
        return item.GetText()

    # -----------------------------------------------
    #                  OnItemSelected
    # -----------------------------------------------
    def OnItemSelected(self, event):
        self.currentItem = event.Index
        # print("OnItemSelected: %s, %s, %s, %s\n" %
        #                    (self.currentItem,
        #                     self.list.GetItemText(self.currentItem),
        #                     self.getColumnText(self.currentItem, 1),
        #                     self.getColumnText(self.currentItem, 2),
        #                     self.getColumnText(self.currentItem, 3),
        #                     self.getColumnText(self.currentItem, 4),
        #                     self.getColumnText(self.currentItem, 5)))
        self.GetPackageDetails(self.list.GetItemText(self.currentItem))
        if self.simplified_mode:
            # In simplified mode, enable the Add Target button when item is selected
            self.selected_package = self.list.GetItemText(self.currentItem)
            if hasattr(self, 'add_target_button'):
                self.add_target_button.Enable(True)
        event.Skip()

    # -----------------------------------------------
    #                  OnColClick
    # -----------------------------------------------
    def OnColClick(self, event):
        col = event.GetColumn()
        if col == -1:
            return # clicked outside any column.
        rowid = self.list.GetColumn(col)
        print(f"Sorting on Column {rowid.GetText()}")
        event.Skip()

    # -----------------------------------------------
    #                  OnCheckAllBoxes
    # -----------------------------------------------
    def OnCheckAllBoxes(self, event):
        self.Check_UncheckAll(True)

    # -----------------------------------------------
    #                  OnUnCheckAllBoxes
    # -----------------------------------------------
    def OnUnCheckAllBoxes(self, event):
        self.Check_UncheckAll(False)

    # -----------------------------------------------
    #                  OnRightClick
    # -----------------------------------------------
    def OnRightClick(self, event):
        # print("OnRightClick %s\n" % self.list.GetItemText(self.currentItem))

        # only do this part the first time so the events are only bound once
        if not hasattr(self, "popupDisable"):
            self.popupDisable = wx.NewIdRef()
            self.popupEnable = wx.NewIdRef()
            self.popupUninstall = wx.NewIdRef()
            self.popupAddToDeny = wx.NewIdRef()
            self.popupRmFromDeny = wx.NewIdRef()
            self.popupDownload = wx.NewIdRef()
            self.popupLaunch = wx.NewIdRef()
            self.popupPermissions = wx.NewIdRef()
            self.popupKill = wx.NewIdRef()
            self.popupClearData = wx.NewIdRef()
            self.popupRefresh = wx.NewIdRef()
            self.popupCheckAllBoxes = wx.NewIdRef()
            self.popupUnCheckAllBoxes = wx.NewIdRef()
            self.popupCopyClipboard = wx.NewIdRef()
            self.popupSuPermission = wx.NewIdRef()

            self.Bind(wx.EVT_MENU, self.OnPopupDisable, id=self.popupDisable)
            self.Bind(wx.EVT_MENU, self.OnPopupEnable, id=self.popupEnable)
            self.Bind(wx.EVT_MENU, self.OnPopupUninstall, id=self.popupUninstall)
            self.Bind(wx.EVT_MENU, self.OnPopupAddToDeny, id=self.popupAddToDeny)
            self.Bind(wx.EVT_MENU, self.OnPopupRmFromDeny, id=self.popupRmFromDeny)
            self.Bind(wx.EVT_MENU, self.OnPopupDownload, id=self.popupDownload)
            self.Bind(wx.EVT_MENU, self.OnPopupLaunch, id=self.popupLaunch)
            self.Bind(wx.EVT_MENU, self.OnPopupPermissions, id=self.popupPermissions)
            self.Bind(wx.EVT_MENU, self.OnPopupKill, id=self.popupKill)
            self.Bind(wx.EVT_MENU, self.OnPopupClearData, id=self.popupClearData)
            self.Bind(wx.EVT_MENU, self.OnPopupRefresh, id=self.popupRefresh)
            self.Bind(wx.EVT_MENU, self.OnCheckAllBoxes, id=self.popupCheckAllBoxes)
            self.Bind(wx.EVT_MENU, self.OnUnCheckAllBoxes, id=self.popupUnCheckAllBoxes)
            self.Bind(wx.EVT_MENU, self.OnCopyClipboard, id=self.popupCopyClipboard)
            self.Bind(wx.EVT_MENU, self.OnSuPermission, id=self.popupSuPermission)

        # build the menu
        menu = wx.Menu()
        disableItem = menu.Append(self.popupDisable, _("Disable Package"))
        enableItem = menu.Append(self.popupEnable, _("Enable Package"))
        uninstallItem = menu.Append(self.popupUninstall, _("Uninstall Package"))
        downloadItem = menu.Append(self.popupDownload, _("Download Package"))
        launchItem = menu.Append(self.popupLaunch, _("Launch Package"))
        PermissionsItem = menu.Append(self.popupPermissions, _("View Application Permissions"))
        killItem = menu.Append(self.popupKill, _("Kill Application"))
        clearItem = menu.Append(self.popupClearData, _("Clear Application Data"))
        # Add a separator
        menu.AppendSeparator()
        refreshItem = menu.Append(self.popupRefresh, _("Refresh"))
        checkItem = menu.Append(self.popupCheckAllBoxes, _("Check All"))
        unCheckItem = menu.Append(self.popupUnCheckAllBoxes, _("UnCheck All"))
        clipboardItem=menu.Append(self.popupCopyClipboard, _("Copy to Clipboard"))
        # Add a separator
        menu.AppendSeparator()
        addDenyItem = menu.Append(self.popupAddToDeny, _("Add Package to Magisk Denylist"))
        removeDenyItem = menu.Append(self.popupRmFromDeny, _("Remove Package from Magisk Denylist"))
        suPermissionItem = menu.Append(self.popupSuPermission, _("SU Permission ..."))

        # set icons
        disableItem.SetBitmap(images.disable_24.GetBitmap())
        enableItem.SetBitmap(images.enable_24.GetBitmap())
        uninstallItem.SetBitmap(images.uninstall_24.GetBitmap())
        downloadItem.SetBitmap(images.download_24.GetBitmap())
        launchItem.SetBitmap(images.launch_24.GetBitmap())
        PermissionsItem.SetBitmap(images.permissions_24.GetBitmap())
        killItem.SetBitmap(images.kill_24.GetBitmap())
        clearItem.SetBitmap(images.clear_24.GetBitmap())
        refreshItem.SetBitmap(images.scan_24.GetBitmap())
        checkItem.SetBitmap(images.check_24.GetBitmap())
        unCheckItem.SetBitmap(images.uncheck_24.GetBitmap())
        clipboardItem.SetBitmap(images.clipboard_24.GetBitmap())
        addDenyItem.SetBitmap(images.magisk_24.GetBitmap())
        removeDenyItem.SetBitmap(images.magisk_24.GetBitmap())
        suPermissionItem.SetBitmap(images.magisk_24.GetBitmap())

        # Popup the menu.  If an item is selected then its handler
        # will be called before PopupMenu returns.
        self.PopupMenu(menu)
        menu.Destroy()

    # -----------------------------------------------
    #                  OnPopupDisable
    # -----------------------------------------------
    def OnPopupDisable(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'disable')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupEnable
    # -----------------------------------------------
    def OnPopupEnable(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'enable')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupUninstall
    # -----------------------------------------------
    def OnPopupUninstall(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'uninstall')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupAddToDeny
    # -----------------------------------------------
    def OnPopupAddToDeny(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'add-to-denylist')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnSuPermission
    # -----------------------------------------------
    def OnSuPermission(self, event):
        self._on_spin('start')
        index = self.currentItem
        pkg = self.list.GetItem(index).Text
        uid = self.list.GetItem(index, 6).Text
        label = self.list.GetItem(index, 7).Text
        text = f"Set SU Permission for: {pkg} {uid} {label}"
        print(f"{text} ...")

        # Popup a small dialog to display SU Permission selection
        dialog = SuPermissionDialog(self, pkg=pkg, uid=uid, label=text)
        result = dialog.ShowModal()
        dialog.Destroy()

        # self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupRmFromDeny
    # -----------------------------------------------
    def OnPopupRmFromDeny(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'rm-from-denylist')
        self.RefreshPackages()
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupDownload
    # -----------------------------------------------
    def OnPopupDownload(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'download')
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupLaunch
    # -----------------------------------------------
    def OnPopupLaunch(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'launch')
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupPermissions
    # -----------------------------------------------
    def OnPopupPermissions(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'get-permissions')
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupKill
    # -----------------------------------------------
    def OnPopupKill(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'kill')
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupClearData
    # -----------------------------------------------
    def OnPopupClearData(self, event):
        self._on_spin('start')
        self.ApplySingleAction(self.currentItem, 'clear-data')
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupRefresh
    # -----------------------------------------------
    def OnPopupRefresh(self, event):
        self._on_spin('start')
        self.RefreshPackages
        self._on_spin('stop')

    # -----------------------------------------------
    #                  OnPopupRefresh
    # -----------------------------------------------
    def RefreshPackages(self):
        res = self.device.get_detailed_packages()
        if res == 0:
            self.packages = self.device.packages
            self.package_count = len(self.packages)
        else:
            self.package_count = 0
        self.Refresh()

    # -----------------------------------------------
    #                  OnCopyClipboard
    # -----------------------------------------------
    def OnCopyClipboard(self, event):
        item = self.list.GetItem(self.currentItem)
        pyperclip.copy(item.Text)

    # -----------------------------------------------
    #                  Function Refresh
    # -----------------------------------------------
    def Refresh(self):
        self.list.Freeze()
        print("Refreshing the packages ...\n")
        self._on_spin('start')
        self.list.ClearAll()
        itemDataMap = self.PopulateList()
        if itemDataMap != -1:
            self.itemDataMap = itemDataMap
        self._on_spin('stop')
        self.list.Thaw()

    # -----------------------------------------------
    #          Function ApplySingleAction
    # -----------------------------------------------
    def ApplySingleAction(self, index, action, fromMulti = False, counter = ''):
        pkg = self.list.GetItem(index).Text
        type = self.list.GetItem(index, 1).Text
        label = self.list.GetItem(index, 7).Text
        # installed = self.list.GetItem(index, 2).Text
        # enabled = self.list.GetItem(index, 3).Text
        # user0 = self.list.GetItem(index, 4).Text
        # magisk_denylist = self.list.GetItem(index, 5).Text
        # uid = self.list.GetItem(index, 6).Text
        # label = self.list.GetItem(index, 7).Text
        if type == 'System':
            isSystem = True
        else:
            isSystem = False

        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            return
        # res = self.device.get_detailed_packages()
        if action == "disable":
            print(f"Disabling {counter}{pkg} type: {type}...")
        elif action == "enable":
            print(f"Enabling {counter}{pkg} type: {type}...")
        elif action == "uninstall":
            print(f"Uninstalling {counter}{pkg} type: {type}...")
        elif action == "add-to-denylist":
            print(f"Adding {counter}{pkg} type: {type} to Magisk Denylist...")
        elif action == "rm-from-denylist":
            print(f"Removing {counter}{pkg} type: {type} from Magisk Denylist...")
        elif action == "launch":
            print(f"Launching {counter}{pkg} type: {type}...")
        elif action == "get-permissions":
            print(f"Getting Permissions for {counter}{pkg} type: {type}...")
            res = self.device.get_package_permissions(pkg)
            if res:
                self.details.SetValue(f"{res}")
                debug(res)
            return
        elif action == "kill":
            print(f"Killing {counter}{pkg} type: {type}...")
        elif action == "clear-data":
            print(f"Clearing {counter}data for {pkg} type: {type}...")
        elif action == "download":
            print(f"Downloading {counter}{pkg} Label: {label}...")
            self.DownloadApk(pkg, fromMulti)
            return
        self.device.perform_package_action(pkg, action, isSystem)
        # TODO: update / refresh the item

    # -----------------------------------------------
    #          Function ApplyMultiAction
    # -----------------------------------------------
    def ApplyMultiAction(self, action):
        i = 0
        count = self.GetItemsCheckedCount()
        multi = False
        if count > 1:
            print(f"Processing {count} items ...")
            multi = True
        if action == 'download':
            self.download_folder = None
        for index in range(self.list.GetItemCount()):
            if self.abort:
                self.abort = False
                break
            if self.list.IsItemChecked(index):
                self.ApplySingleAction(index, action, multi, f"{i}/{count} ")
                i += 1
        print(f"Total count of package actions attempted: {i}")

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        wx.YieldIfNeeded()
        if state == 'start':
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
            self.Parent._on_spin('start')
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.Parent._on_spin('stop')

    # -----------------------------------------------
    #                  OnItemActivated
    # -----------------------------------------------
    def OnItemActivated(self, event):
        if self.simplified_mode and hasattr(self, 'selected_package'):
            # Double-click in simplified mode acts as OK
            self.EndModal(wx.ID_OK)
        event.Skip()

    # -----------------------------------------------
    #                  GetSelectedPackage
    # -----------------------------------------------
    def GetSelectedPackage(self):
        if self.simplified_mode:
            return getattr(self, 'selected_package', None)
        return None

    # -----------------------------------------------
    #          Function add_missing_packages_for_simplified_mode
    # -----------------------------------------------
    def add_missing_packages_for_simplified_mode(self, process_filter=None):
        try:
            if not self.device or not self.device.rooted:
                return

            # Get running processes
            running_packages = self._get_running_packages(process_filter)

            # Define some well-known package labels
            known_labels = {
                'com.google.android.gms': 'Google Play Services',
                'com.google.android.gms.ui': 'Google Play Services UI',
                'com.google.android.gms.unstable': 'Google Play Services (Unstable)',
                'com.google.android.gms.learning': 'Google Play Services Learning',
                'com.google.android.gms.persistent': 'Google Play Services (Persistent)',
                'app.revanced.android.gms': 'ReVanced GMS',
                'com.android.vending': 'Google Play Store',
                'com.google.android.webview': 'Android System WebView',
                'com.google.android.tts': 'Google Text-to-Speech',
                'com.google.android.packageinstaller': 'Package Installer'
            }

            added_count = 0
            for pkg_name in running_packages:
                if pkg_name and pkg_name not in self.packages:
                    # Create a minimal package object for missing packages
                    class SimplePackage:
                        def __init__(self):
                            self.package = ""
                            self.type = ""
                            self.installed = True
                            self.enabled = True
                            self.user0 = False
                            self.magisk_denylist = False
                            self.uid = ""
                            self.label = ""
                            self.details = ""
                            self.path = ""
                            self.path2 = ""
                            self.icon = ""

                    new_package = SimplePackage()
                    new_package.package = pkg_name
                    new_package.type = 'System'
                    new_package.installed = True
                    new_package.enabled = True
                    new_package.user0 = False
                    new_package.magisk_denylist = False
                    new_package.uid = ''
                    new_package.details = ''
                    new_package.path = ''
                    new_package.path2 = ''
                    new_package.icon = ''

                    # Set label if known
                    if pkg_name in known_labels:
                        new_package.label = known_labels[pkg_name]
                    else:
                        new_package.label = ''

                    self.packages[pkg_name] = new_package
                    added_count += 1

            if added_count > 0:
                print(f"Added {added_count} missing packages from running processes (filter: '{process_filter or 'all'}')")
                # Update package count
                self.package_count = len(self.packages)

        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adding missing packages for simplified mode")

    # -----------------------------------------------
    #          Function _get_running_packages
    # -----------------------------------------------
    def _get_running_packages(self, process_filter=None):
        running_packages = set()

        try:
            if process_filter:
                ps_cmd = f"ps -A | grep {process_filter}"
            else:
                ps_cmd = "ps -A"
            ps_output = self.device.exec_cmd(ps_cmd, True)
            if ps_output:
                for line in ps_output.strip().split('\n'):
                    if line.strip():
                        parts = line.strip().split()
                        if len(parts) >= 9:  # Valid ps output line format
                            process_name = parts[8]
                            # Remove anything with colon (like :persistent, :ui, etc.)
                            if ':' in process_name:
                                process_name = process_name.split(':')[0]
                            # Only add if it looks like a valid Android package name
                            if self._is_valid_package_name(process_name):
                                running_packages.add(process_name)
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: getting running processes")

        return running_packages

    # -----------------------------------------------
    #          Function _is_valid_package_name
    # -----------------------------------------------
    def _is_valid_package_name(self, name):
        if not name or len(name) < 3:
            return False

        # Must contain at least one dot (package structure)
        if '.' not in name:
            return False

        # Should not contain spaces or special characters (except dots and underscores)
        import re
        if not re.match(r'^[a-zA-Z0-9_.]+$', name):
            return False

        # Should have at least 2 parts separated by dots
        parts = name.split('.')
        if len(parts) < 2:
            return False

        # Each part should not be empty and should start with a letter
        for part in parts:
            if not part or not part[0].isalpha():
                return False

        return True

    # -----------------------------------------------
    #              Function push_aapt2_if_needed
    # -----------------------------------------------
    def push_aapt2_if_needed(self):
        if self.aapt2_pushed_this_session:
            return 0
        try:
            print("Pushing aapt2 to device...")
            res = self.device.push_aapt2()
            if res == 0:
                self.aapt2_pushed_this_session = True
                print("aapt2 pushed successfully")
            else:
                print("Failed to push aapt2")
            return res
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: pushing aapt2")
            return -1

```

`partition_manager.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import json

import pyperclip
import traceback
import wx
import wx.html
import wx.lib.mixins.listctrl as listmix
import wx.lib.wxpTag

import images as images
from runtime import *


# ============================================================================
#                               Class ListCtrl
# ============================================================================
class ListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)


# ============================================================================
#                               Class PartitionManager
# ============================================================================
class PartitionManager(wx.Dialog, listmix.ColumnSorterMixin):
    def __init__(self, *args, **kwargs):
        wx.Dialog.__init__(self, *args, **kwargs, style = wx.RESIZE_BORDER | wx.DEFAULT_DIALOG_STYLE)
        self.SetTitle("Partition Manager")
        self.partitionCount = 0
        self.all_cb_clicked = False
        self.downloadFolder = None
        self.abort = False
        self.device = get_phone(True)
        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            wx.MessageBox(f"❌ ERROR: You must first select a valid device.", "Error", wx.OK | wx.ICON_ERROR)
            self.Close()
            return

        warning_sizer = wx.BoxSizer(wx.HORIZONTAL)
        warning_text = '''WARNING!
This is advanced feature.
Unless you know what you are doing,
you should not be touching this.

YOU AND YOU ALONE ARE RESPONSIBLE FOR ANYTHING THAT HAPPENS TO YOUR DEVICE.
THIS TOOL IS CODED WITH THE EXPRESS ASSUMPTION THAT YOU ARE FAMILIAR WITH
ADB, MAGISK, ANDROID, ROOT AND PARTITION MANIPULATION.
IT IS YOUR RESPONSIBILITY TO ENSURE THAT YOU KNOW WHAT YOU ARE DOING.
'''
        # warning label
        self.warning_label = wx.StaticText(self, wx.ID_ANY, warning_text, wx.DefaultPosition, wx.DefaultSize, wx.ALIGN_CENTER_HORIZONTAL)
        self.warning_label.Wrap(-1)
        self.warning_label.SetForegroundColour(wx.Colour(255, 0, 0))

        # static line
        staticline = wx.StaticLine(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LI_HORIZONTAL)

        self.message_label = wx.StaticText(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        self.message_label.Wrap(-1)
        self.message_label.Label = ""
        self.message_label.SetFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, "Arial"))

        self.all_checkbox = wx.CheckBox(self, wx.ID_ANY, u"Check / Uncheck All", wx.DefaultPosition, wx.DefaultSize, style=wx.CHK_3STATE)

        self.il = wx.ImageList(16, 16)
        self.idx1 = self.il.Add(images.official_16.GetBitmap())
        self.sm_up = self.il.Add(images.SmallUpArrow.GetBitmap())
        self.sm_dn = self.il.Add(images.SmallDnArrow.GetBitmap())

        self.list  = ListCtrl(self, -1, size=(-1, -1), style=wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.BORDER_NONE)
        if sys.platform == "win32":
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLACK'),wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10).Bold())))
        self.list.SetImageList(self.il, wx.IMAGE_LIST_SMALL)
        self.list.EnableCheckBoxes(enable=True)
        itemDataMap = self.PopulateList()
        if itemDataMap != -1:
            self.itemDataMap = itemDataMap

        self.erase_button = wx.Button(self, wx.ID_ANY, u"Erase", wx.DefaultPosition, wx.DefaultSize, 0)
        self.erase_button.SetToolTip(u"Erase checked partitions")
        self.erase_button.Enable(False)

        self.dump_partition = wx.Button(self, wx.ID_ANY, u"Dump / Backup", wx.DefaultPosition, wx.DefaultSize, 0)
        self.dump_partition.SetToolTip(u"Dumps / Backups the checked partitions")
        self.dump_partition.Enable(False)


        self.close_button = wx.Button(self, wx.ID_ANY, u"Close", wx.DefaultPosition, wx.DefaultSize, 0)
        self.close_button.SetToolTip(u"Closes this dialog")

        vSizer = wx.BoxSizer(wx.VERTICAL)
        warning_sizer.Add(self.warning_label, 1, wx.ALL, 10)
        message_sizer = wx.BoxSizer(wx.HORIZONTAL)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        message_sizer.Add(self.message_label, 0, wx.ALL, 20)
        message_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        hSizer1 = wx.BoxSizer( wx.HORIZONTAL )
        hSizer1.Add( (10, 0), 0, wx.EXPAND, 10 )
        hSizer1.Add(self.all_checkbox, 0, wx.EXPAND, 10)
        hSizer1.Add( (0, 0), 1, wx.EXPAND, 10 )
        buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        buttons_sizer.Add(self.erase_button, 0, wx.ALL, 20)
        buttons_sizer.Add(self.dump_partition, 0, wx.ALL, 20)
        buttons_sizer.Add(self.close_button, 0, wx.ALL, 20)
        buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        vSizer.Add(warning_sizer, 0, wx.EXPAND, 5)
        vSizer.Add(staticline, 0, wx.EXPAND, 5)
        vSizer.Add(message_sizer, 0, wx.EXPAND, 5)
        vSizer.Add(hSizer1, 0, wx.EXPAND, 10)
        vSizer.Add(self.list , 1, wx.ALL|wx.EXPAND, 10)
        vSizer.Add(buttons_sizer, 0, wx.EXPAND, 5)

        self.SetSizer(vSizer)
        self.Layout()
        self.Centre(wx.BOTH)

        # Autosize the dialog
        self.list.PostSizeEventToParent()
        self.SetSizerAndFit(vSizer)
        self.SetSize(vSizer.MinSize.Width + 80, vSizer.MinSize.Height + 400)

        # Connect Events
        self.erase_button.Bind(wx.EVT_BUTTON, self.OnErase)
        self.dump_partition.Bind(wx.EVT_BUTTON, self.OnDump)
        self.close_button.Bind(wx.EVT_BUTTON, self.OnClose)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self.list)
        self.list.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.list.Bind(wx.EVT_LIST_ITEM_CHECKED, self.OnItemCheck)
        self.list.Bind(wx.EVT_LIST_ITEM_UNCHECKED, self.OnItemUncheck)
        # for wxMSW
        self.list.Bind(wx.EVT_COMMAND_RIGHT_CLICK, self.OnRightClick)
        # for wxGTK
        self.list.Bind(wx.EVT_RIGHT_UP, self.OnRightClick)
        self.all_checkbox.Bind(wx.EVT_CHECKBOX, self.OnAllCheckbox)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    # -----------------------------------------------
    #              Function PopulateList
    # -----------------------------------------------
    def PopulateList(self):
        info = wx.ListItem()
        info.Mask = wx.LIST_MASK_TEXT | wx.LIST_MASK_IMAGE | wx.LIST_MASK_FORMAT
        info.Image = -1
        info.Align = 0
        info.Width = -1
        info.SetWidth(-1)
        info.Text = "Partition"
        self.list.InsertColumn(0, info)

        res = self.device.get_partitions()
        itemDataMap = {}
        if res != -1:
            self.partitionCount = len(res)
            self.message_label.Label = f"{self.partitionCount} Partitions"
            for i, key in enumerate(res):
                if key:
                    index = self.list.InsertItem(self.list.GetItemCount(), key)
                    itemDataMap[i + 1] = (key)
                    row = self.list.GetItem(index)
                    self.list.SetItem(row)
                    self.list.SetItemData(index, i + 1)
                    # hide image
                    self.list.SetItemColumnImage(i, 0, -1)
            self.partitionCount = i
            self.message_label.Label = f"{str(i)} Partitions"
        self.list.SetColumnWidth(0, -2)
        grow_column(self.list, 0, 20)

        self.currentItem = 0
        if itemDataMap:
            return itemDataMap
        else:
            return -1

    # -----------------------------------------------
    #              Function Check_UncheckAll
    # -----------------------------------------------
    def Check_UncheckAll(self, state):
        # Set this so that we skip processing OnItemChecked, OnItemUnchecked events
        self.Set_all_cb_clicked (True)
        itemcount = self.list.GetItemCount()
        [self.list.CheckItem(item=i, check=state) for i in range(itemcount)]
        if state and self.device.rooted:
            print("checking all Partitions\n")
            self.EnableDisableButton(True)
        else:
            print("Unchecking all Partitions\n")
            self.EnableDisableButton(False)
        self.Set_all_cb_clicked (False)

    # -----------------------------------------------
    #                  onCancel
    # -----------------------------------------------
    def OnCancel(self, event):
        self.searchCtrl.SetValue("")
        self.Refresh()

    # -----------------------------------------------
    #                  OnAllCheckbox
    # -----------------------------------------------
    def OnAllCheckbox(self, event):
        cb = event.GetEventObject()
        # print("\t3StateValue: %s\n" % cb.Get3StateValue())
        if cb.Get3StateValue() == 2:
            cb.Set3StateValue(2)
            self.Check_UncheckAll(False)
        elif cb.Get3StateValue() == 1:
            self.Check_UncheckAll(True)
        elif cb.Get3StateValue() == 0:
            self.Check_UncheckAll(False)

    # -----------------------------------------------
    #                  OnItemChecked
    # -----------------------------------------------
    def OnItemCheck(self, event):
        if self.Get_all_cb_clicked():
            return
        print(f"{event.Item.Text} is checked")
        self.Update_all_checkbox()

    # -----------------------------------------------
    #                  OnItemUnchecked
    # -----------------------------------------------
    def OnItemUncheck(self, event):
        if self.Get_all_cb_clicked():
            return
        print(f"{event.Item.Text} is unchecked")
        self.Update_all_checkbox()

    # -----------------------------------------------
    #         Function Get_all_cb_clicked
    # -----------------------------------------------
    def Get_all_cb_clicked(self):
        return self.all_cb_clicked

    # -----------------------------------------------
    #         Function Set_all_cb_clicked
    # -----------------------------------------------
    def Set_all_cb_clicked(self, value):
        self.all_cb_clicked = value

    # -----------------------------------------------
    #          Function Update_all_checkbox
    # -----------------------------------------------
    def Update_all_checkbox(self):
        i = 0
        for index in range(self.list.GetItemCount()):
            if self.list.IsItemChecked(index):
                # print(f"{self.list.GetItem(index).Text} item is checked")
                i += 1
        # print(f"Checked items count: {i}")
        if i == 0:
            self.all_checkbox.Set3StateValue(0)
            self.EnableDisableButton(False)
        elif i == self.partitionCount:
            self.all_checkbox.Set3StateValue(1)
            if self.device.rooted:
                self.EnableDisableButton(True)
        else:
            self.all_checkbox.Set3StateValue(2)
            if self.device.rooted:
                self.EnableDisableButton(True)

    # -----------------------------------------------
    #                  EnableDisableButton
    # -----------------------------------------------
    def EnableDisableButton(self, state):
        self.erase_button.Enable(state)
        self.dump_partition.Enable(state)

    # -----------------------------------------------
    #                  OnClose
    # -----------------------------------------------
    def OnClose(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Close.")
        self.EndModal(wx.ID_CANCEL)

    # -----------------------------------------------
    #                  OnErase
    # -----------------------------------------------
    def OnErase(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Erase.")
        self.ApplyMultiAction('erase')

    # -----------------------------------------------
    #                  Erase
    # -----------------------------------------------
    def Erase(self, partition):
        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            return
        dlg = wx.MessageDialog(None, f"You have selected to ERASE partition: {partition}\nAre you sure want to continue?", f"Erase Partition: {partition}",wx.YES_NO | wx.ICON_EXCLAMATION)
        result = dlg.ShowModal()
        if result != wx.ID_YES:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled erasing  partition: {partition}.")
            return
        self.device.erase_partition(partition)

    # -----------------------------------------------
    #                  OnDump
    # -----------------------------------------------
    def OnDump(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed on Dump / Backup Partition")
        self.ApplyMultiAction('dump')

    # -----------------------------------------------
    #                  Dump
    # -----------------------------------------------
    def Dump(self, partition, multiple = False):
        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            return

        # delete existing partition dump if it exists on the phone
        path = f"/data/local/tmp/{partition}.img"
        res = self.device.delete(path)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to delete old partition image from the phone;\n}\n")
            return

        # partition dump on the phone
        res, file_path = self.device.dump_partition(file_path=path, partition=partition)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to dump partition on the phone;\n}\n")
            return

        if multiple:
            if not self.downloadFolder:
                with wx.DirDialog(None, "Choose a directory where all the partition dumps should be saved.", style=wx.DD_DEFAULT_STYLE) as folderDialog:
                    if folderDialog.ShowModal() == wx.ID_CANCEL:
                        print("User Cancelled dumping partitions (option: folder).")
                        self.abort = True
                        return     # the user changed their mind
                    self.downloadFolder = folderDialog.GetPath()
                    print(f"Selected Download Directory: {self.downloadFolder}")
            pathname =  os.path.join(self.downloadFolder, f"{partition}.img")
        else:
            with wx.FileDialog(self, "Dump partition", '', f"{partition}.img", wildcard="IMG files (*.img)|*.img", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print(f"User Cancelled dumping partition: {partition}")
                    return     # the user changed their mind
                pathname = fileDialog.GetPath()
        try:
            if self.device:
                self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
                print(f"Dump partition to: {pathname}")
                self.device.pull_file(path, pathname)
                res = self.device.delete(path)
        except IOError:
            traceback.print_exc()
            wx.LogError(f"Cannot save img file '{pathname}'.")
        self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))


    # -----------------------------------------------
    #                  GetListCtrl
    # -----------------------------------------------
    # Used by the ColumnSorterMixin, see wx/lib/mixins/listctrl.py
    def GetListCtrl(self):
        return self.list

    # -----------------------------------------------
    #                  OnRightDown
    # -----------------------------------------------
    def OnRightDown(self, event):
        x = event.GetX()
        y = event.GetY()
        # print("x, y = %s\n" % str((x, y)))
        item, flags = self.list.HitTest((x, y))
        if item != wx.NOT_FOUND and flags & wx.LIST_HITTEST_ONITEM:
            self.list.Select(item)
        event.Skip()

    # -----------------------------------------------
    #                  getColumnText
    # -----------------------------------------------
    def getColumnText(self, index, col):
        item = self.list.GetItem(index, col)
        return item.GetText()

    # -----------------------------------------------
    #                  OnItemSelected
    # -----------------------------------------------
    def OnItemSelected(self, event):
        self.currentItem = event.Index
        # print("OnItemSelected: %s, %s, %s, %s\n" %
        #                    (self.currentItem,
        #                     self.list.GetItemText(self.currentItem),
        #                     self.getColumnText(self.currentItem, 1),
        #                     self.getColumnText(self.currentItem, 2),
        #                     self.getColumnText(self.currentItem, 3),
        #                     self.getColumnText(self.currentItem, 4),
        #                     self.getColumnText(self.currentItem, 5)))
        # self.GetPackageDetails(self.list.GetItemText(self.currentItem))
        # self.all_checkbox.Set3StateValue(2)
        event.Skip()

    # -----------------------------------------------
    #                  OnCheckAllBoxes
    # -----------------------------------------------
    def OnCheckAllBoxes(self, event):
        self.Check_UncheckAll(True)

    # -----------------------------------------------
    #                  OnUnCheckAllBoxes
    # -----------------------------------------------
    def OnUnCheckAllBoxes(self, event):
        self.Check_UncheckAll(False)

    # -----------------------------------------------
    #                  OnGetItemsChecked
    # -----------------------------------------------
    def OnGetItemsChecked(self, event):
        itemcount = self.list.GetItemCount()
        itemschecked = [i for i in range(itemcount) if self.list.IsItemChecked(item=i)]
        print(f"Package: {itemschecked} is checked.")

    # -----------------------------------------------
    #                  OnRightClick
    # -----------------------------------------------
    def OnRightClick(self, event):
        # print("OnRightClick %s\n" % self.list.GetItemText(self.currentItem))

        # only do this part the first time so the events are only bound once
        if not hasattr(self, "popupErase"):
            self.popupErase = wx.NewIdRef()
            self.popupDump = wx.NewIdRef()
            self.popupCheckAllBoxes = wx.NewIdRef()
            self.popupUnCheckAllBoxes = wx.NewIdRef()
            self.popupCopyClipboard = wx.NewIdRef()

            self.Bind(wx.EVT_MENU, self.OnpopupErase, id=self.popupErase)
            self.Bind(wx.EVT_MENU, self.OnPopupDump, id=self.popupDump)
            self.Bind(wx.EVT_MENU, self.OnCheckAllBoxes, id=self.popupCheckAllBoxes)
            self.Bind(wx.EVT_MENU, self.OnUnCheckAllBoxes, id=self.popupUnCheckAllBoxes)
            self.Bind(wx.EVT_MENU, self.OnCopyClipboard, id=self.popupCopyClipboard)

        # build the menu
        menu = wx.Menu()
        menu.Append(self.popupErase, "Erase Partition")
        menu.Append(self.popupDump, "Dump Partition")
        menu.Append(self.popupCheckAllBoxes, "Check All")
        menu.Append(self.popupUnCheckAllBoxes, "UnCheck All")
        menu.Append(self.popupCopyClipboard, "Copy to Clipboard")

        # Popup the menu.  If an item is selected then its handler
        # will be called before PopupMenu returns.
        self.PopupMenu(menu)
        menu.Destroy()

    # -----------------------------------------------
    #                  OnpopupErase
    # -----------------------------------------------
    def OnpopupErase(self, event):
        if self.device.rooted:
            self.ApplySingleAction(self.currentItem, 'erase')

    # -----------------------------------------------
    #                  OnPopupDump
    # -----------------------------------------------
    def OnPopupDump(self, event):
        if self.device.rooted:
            self.ApplySingleAction(self.currentItem, 'dump')

    # -----------------------------------------------
    #                  OnCopyClipboard
    # -----------------------------------------------
    def OnCopyClipboard(self, event):
        item = self.list.GetItem(self.currentItem)
        pyperclip.copy(item.Text)

    # -----------------------------------------------
    #         Function GetItemsCheckedCount
    # -----------------------------------------------
    def GetItemsCheckedCount(self):
        checked_count = 0
        for i in range(self.list.GetItemCount()):
            if self.list.IsItemChecked(i):
                checked_count += 1
        return checked_count

    # -----------------------------------------------
    #          Function ApplySingleAction
    # -----------------------------------------------
    def ApplySingleAction(self, index, action, fromMulti = False):
        partition = self.list.GetItem(index).Text

        if not self.device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            return
        if action == "erase":
            print(f"Erasing {partition} ...")
            self.Erase(partition)
        elif action == "dump":
            print(f"Dumping {partition} ...")
            self.Dump(partition, fromMulti)
        return

    # -----------------------------------------------
    #          Function ApplyMultiAction
    # -----------------------------------------------
    def ApplyMultiAction(self, action):
        i = 0
        count = self.GetItemsCheckedCount()
        multi = False
        if count > 1:
            print(f"Processing {count} items ...")
            multi = True
        if action == 'dump':
            self.downloadFolder = None
        for index in range(self.list.GetItemCount()):
            if self.abort:
                self.abort = False
                break
            if self.list.IsItemChecked(index):
                self.ApplySingleAction(index, action, multi)
                i += 1
        print(f"Total count of partition actions attempted: {i}")


```

`payload_dumper.py`:

```py

# Ref: https://github.com/vm03/payload_dumper/blob/35134a28d641deda899c30aed57aace21bfd4a3c/payload_dumper.py

import struct
import hashlib
import bz2
import sys
import bsdiff4
import io
import os
try:
    import lzma
except ImportError as e:
    print(f"Error importing lzma: {e}")
    from backports import lzma # type: ignore

import update_metadata_pb2 as um


def extract_payload(payload_file_path, out='output', diff=False, old='old', images=''):
    def u32(x):
        return struct.unpack('>I', x)[0]

    def u64(x):
        return struct.unpack('>Q', x)[0]

    def verify_contiguous(exts):
        blocks = 0

        for ext in exts:
            if ext.start_block != blocks:
                return False

            blocks += ext.num_blocks

        return True

    def data_for_op(op, out_file, old_file):
        payload_file.seek(data_offset + op.data_offset)
        data = payload_file.read(op.data_length)

        # assert hashlib.sha256(data).digest() == op.data_sha256_hash, 'operation data hash mismatch'

        if op.type == op.REPLACE_XZ:
            dec = lzma.LZMADecompressor()
            data = dec.decompress(data)
            out_file.seek(op.dst_extents[0].start_block * block_size)
            out_file.write(data)
        elif op.type == op.REPLACE_BZ:
            dec = bz2.BZ2Decompressor()
            data = dec.decompress(data)
            out_file.seek(op.dst_extents[0].start_block * block_size)
            out_file.write(data)
        elif op.type == op.REPLACE:
            out_file.seek(op.dst_extents[0].start_block * block_size)
            out_file.write(data)
        elif op.type == op.SOURCE_COPY:
            if not diff:
                print("SOURCE_COPY supported only for differential OTA")
                sys.exit(-2)
            out_file.seek(op.dst_extents[0].start_block * block_size)
            for ext in op.src_extents:
                old_file.seek(ext.start_block * block_size)
                data = old_file.read(ext.num_blocks * block_size)
                out_file.write(data)
        elif op.type == op.SOURCE_BSDIFF:
            if not diff:
                print("SOURCE_BSDIFF supported only for differential OTA")
                sys.exit(-3)
            out_file.seek(op.dst_extents[0].start_block * block_size)
            tmp_buff = io.BytesIO()
            for ext in op.src_extents:
                old_file.seek(ext.start_block * block_size)
                old_data = old_file.read(ext.num_blocks * block_size)
                tmp_buff.write(old_data)
            tmp_buff.seek(0)
            old_data = tmp_buff.read()
            tmp_buff.seek(0)
            tmp_buff.write(bsdiff4.patch(old_data, data))
            n = 0
            tmp_buff.seek(0)
            for ext in op.dst_extents:
                tmp_buff.seek(n * block_size)
                n += ext.num_blocks
                data = tmp_buff.read(ext.num_blocks * block_size)
                out_file.seek(ext.start_block * block_size)
                out_file.write(data)
        elif op.type == op.ZERO:
            for ext in op.dst_extents:
                out_file.seek(ext.start_block * block_size)
                out_file.write(b'\x00' * ext.num_blocks * block_size)
        else:
            print("Unsupported type = %d" % op.type)
            sys.exit(-1)

        return data

    def dump_part(part):
        sys.stdout.write(f"Processing {part.partition_name} partition")
        sys.stdout.flush()

        with open(f'{out}/{part.partition_name}.img', 'wb') as out_file:
            h = hashlib.sha256()

            if diff:
                with open(f'{old}/{part.partition_name}.img', 'rb') as old_file:
                    for op in part.operations:
                        data = data_for_op(op, out_file, old_file)
                        sys.stdout.write(".")
                        sys.stdout.flush()
            else:
                for op in part.operations:
                    data = data_for_op(op, out_file, None)
                    sys.stdout.write(".")
                    sys.stdout.flush()

        print("Done")

    with open(payload_file_path, 'rb') as payload_file:
        magic = payload_file.read(4)
        assert magic == b'CrAU'

        file_format_version = u64(payload_file.read(8))
        assert file_format_version == 2

        manifest_size = u64(payload_file.read(8))

        metadata_signature_size = 0

        if file_format_version > 1:
            metadata_signature_size = u32(payload_file.read(4))

        manifest = payload_file.read(manifest_size)
        metadata_signature = payload_file.read(metadata_signature_size)

        data_offset = payload_file.tell()

        dam = um.DeltaArchiveManifest()
        dam.ParseFromString(manifest)
        block_size = dam.block_size

        if images == "":
            for part in dam.partitions:
                dump_part(part)
        else:
            images_list = images.split(",")
            for image in images_list:
                partition = [part for part in dam.partitions if part.partition_name == image]
                if partition:
                    dump_part(partition[0])
                else:
                    sys.stderr.write("Partition %s not found in payload!\n" % image)

```

`pf_modules.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import contextlib
import copy
import fnmatch
import math
import ntpath
import os
import shutil
import sqlite3 as sl
import sys
import tempfile
import time
import traceback
from datetime import datetime

import wx
from packaging.version import parse
from platformdirs import *
from i18n import _

from constants import *
from file_editor import FileEditor
from magisk_downloads import MagiskDownloads
from message_box_ex import MessageBoxEx
from payload_dumper import extract_payload
from phone import get_connected_devices, update_phones
from runtime import *

console_widget = None

# ============================================================================
#                               Class FlashFile
# ============================================================================
class FlashFile():
    def __init__(self, linenum = '', platform = '', type = '', command = '', action = '', arg1 = '', arg2 = ''):
        # Instance variables
        self.linenum = linenum
        self.platform = platform
        self.type = type
        self.command = command
        self.action = action
        self.arg1 = arg1
        self.arg2 = arg2

    @property
    def full_line(self):
        response = f"{self.command} {self.action} {self.arg1} {self.arg2}"
        return response.strip()

    @property
    def sync_line(self):
        if self.type in ['init', 'sleep']:
            response = self.type
        elif self.type in ['path', 'if_block']:
            # don't include
            response = ''
        else:
            response = f"{self.command} {self.action} {self.arg1} {self.arg2}"
        return response.strip()


# ============================================================================
#                               Function check_platform_tools
# ============================================================================
def check_platform_tools(self):
    try:
        if sys.platform == "win32":
            adb_binary = 'adb.exe'
            fastboot_binary = 'fastboot.exe'
        else:
            adb_binary = 'adb'
            fastboot_binary = 'fastboot'
        if self.config.platform_tools_path:
            adb = os.path.join(self.config.platform_tools_path, adb_binary)
            fastboot = os.path.join(self.config.platform_tools_path, fastboot_binary)
            if os.path.exists(fastboot) and os.path.exists(adb):
                print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Selected Platform Tools Path:\n{self.config.platform_tools_path}")
                adb = os.path.join(self.config.platform_tools_path, adb_binary)
                fastboot = os.path.join(self.config.platform_tools_path, fastboot_binary)
                set_adb(adb)
                set_fastboot(fastboot)
                set_adb_sha256(sha256(adb))
                set_fastboot_sha256(sha256(fastboot))
                res = identify_sdk_version(self)
                print(f"SDK Version:      {get_sdk_version()}")
                print(f"Adb SHA256:       {get_adb_sha256()}")
                print(f"Fastboot SHA256:  {get_fastboot_sha256()}")
                puml(f":Selected Platform Tools;\nnote left: {self.config.platform_tools_path}\nnote right:{get_sdk_version()}\n")
                if res == -1:
                    return -1
                set_android_product_out(self.config.platform_tools_path)
                return
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The selected path {self.config.platform_tools_path} does not have adb and or fastboot")
                puml(f"#red:Selected Platform Tools;\nnote left: {self.config.platform_tools_path}\nnote right:The selected path does not have adb and or fastboot\n")
                self.config.platform_tools_path = None
                set_adb(None)
                set_fastboot(None)
        else:
            print("Android Platform Tools is not found.")
    except Exception as e:
        traceback.print_exc()
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while checking for platform tools.")

    with contextlib.suppress(Exception):
        if self.config.platform_tools_path:
            self.platform_tools_picker.SetPath(self.config.platform_tools_path)
            set_android_product_out(self.config.platform_tools_path)
        else:
            self.platform_tools_picker.SetPath('')
            return -1


# ============================================================================
#                               Function set_android_product_out
# ============================================================================
def set_android_product_out(sdk_path):
    # add the SDK path to to ANDROID_PRODUCT_OUT env
    env_vars = get_env_variables()
    env_vars["ANDROID_PRODUCT_OUT"] = f"{sdk_path}"
    set_env_variables(env_vars)


# ============================================================================
#                               Function populate_boot_list
# ============================================================================
def populate_boot_list(self, sortColumn=None, sorting_direction='ASC'):
    try:
        self.list.DeleteAllItems()
        con = get_db_con()
        if con is None:
            return None
        sql = """
            SELECT
                BOOT.id as boot_id,
                BOOT.boot_hash,
                BOOT.file_path as boot_path,
                BOOT.is_patched,
                BOOT.patch_method,
                BOOT.magisk_version,
                BOOT.hardware,
                BOOT.epoch as boot_date,
                PACKAGE.id as package_id,
                PACKAGE.boot_hash as package_boot_hash,
                PACKAGE.type as package_type,
                PACKAGE.package_sig,
                PACKAGE.file_path as package_path,
                PACKAGE.epoch as package_date,
                BOOT.is_odin,
                PACKAGE.full_ota
            FROM BOOT
            JOIN PACKAGE_BOOT
                ON BOOT.id = PACKAGE_BOOT.boot_id
            JOIN PACKAGE
                ON PACKAGE.id = PACKAGE_BOOT.package_id
        """
        # Apply filter if show all is not selected
        parameters = []
        if not self.config.show_all_boot:
            rom_path = ''
            firmware_path = ''
            if self.config.show_custom_rom_options and self.config.custom_rom and self.config.advanced_options:
                rom_path = self.config.custom_rom_path
            if self.config.firmware_path:
                firmware_path = self.config.firmware_path
            sql += """
                WHERE
                    (BOOT.is_patched = 0 AND PACKAGE.file_path IN (?, ?))
                    OR
                    (BOOT.is_patched = 1 AND PACKAGE.boot_hash IN (
                        SELECT PACKAGE.boot_hash
                        FROM BOOT
                        JOIN PACKAGE_BOOT
                            ON BOOT.id = PACKAGE_BOOT.boot_id
                        JOIN PACKAGE
                            ON PACKAGE.id = PACKAGE_BOOT.package_id
                        WHERE
                            (BOOT.is_patched = 0 AND PACKAGE.file_path IN (?, ?))
                    ))
            """
            parameters.extend([firmware_path, rom_path, firmware_path, rom_path])

        # Clear the previous sort order arrows
        for i in range(self.list.GetColumnCount()):
            col = self.list.GetColumn(i)
            col_text = col.Text.rstrip(" ▲▼")
            col.SetImage(-1)
            col.SetText(f"{col_text}  ")
            self.list.SetColumn(i, col)

        # Order the query results based on the sortColumn and sorting_direction if provided
        if sortColumn is not None:
            # Set the sort order arrow for the current column
            col = self.list.GetColumn(sortColumn - 1)
            col_text = col.Text.strip()
            if sorting_direction == 'ASC':
                col.SetText(f"{col_text} ▲")
                col.SetImage(-1)
            elif sorting_direction == 'DESC':
                col.SetText(f"{col_text} ▼")
                col.SetImage(-1)
            self.list.SetColumn(sortColumn - 1, col)

            # Get the column name based on the sortColumn number
            column_map = {
                1: 'BOOT.boot_hash',
                2: 'PACKAGE.boot_hash',
                3: 'PACKAGE.package_sig',
                4: 'BOOT.magisk_version',
                5: 'BOOT.patch_method',
                6: 'BOOT.hardware',
                7: 'BOOT.epoch',
                8: 'PACKAGE.file_path'
            }
            column_name = column_map.get(sortColumn, '')
            if column_name:
                sql += f" ORDER BY {column_name} {sorting_direction};"
        else:
            # Add default sorting
            sql += " ORDER BY BOOT.is_patched ASC, BOOT.epoch ASC;"

        with con:
            data = con.execute(sql, parameters)
            i = 0
            full_ota = None
            paths_to_update = []  # Store boot_id and new paths for updating after loop

            for row in data:
                boot_id = row[0]
                boot_hash = row[1][:8] or ''
                boot_path = row[2]  # Original boot path
                package_boot_hash = row[9][:8] or ''
                package_sig = row[11] or ''
                patched_with_version = str(row[5]) or ''
                patch_method = row[4] or ''
                hardware = row[6] or ''
                ts = datetime.fromtimestamp(row[7])
                boot_date = ts.strftime('%Y-%m-%d %H:%M:%S')
                package_path = row[12] or ''
                if self.config.firmware_path == package_path:
                    full_ota = row[15]

                # Path verification logic to handle modified pf_home
                if not os.path.exists(boot_path) and "boot_images4" in boot_path:
                    try:
                        path_parts = boot_path.split("boot_images4", 1)
                        right_side = "boot_images4" + path_parts[1]
                        new_path = os.path.join(self.config.pf_home, right_side)

                        if os.path.exists(new_path):
                            # Store for batch update after the loop
                            paths_to_update.append((boot_id, new_path))
                    except Exception as e:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Processing boot path during list population: {e}")

                index = self.list.InsertItem(i, boot_hash)                     # boot_hash (SHA1)
                self.list.SetItem(index, 1, package_boot_hash)                 # package_boot_hash (Source SHA1)
                self.list.SetItem(index, 2, package_sig)                       # package_sig (Package Fingerprint)
                self.list.SetItem(index, 3, patched_with_version)              # patched_with_version
                self.list.SetItem(index, 4, patch_method)                      # patched_method
                self.list.SetItem(index, 5, hardware)                          # hardware
                self.list.SetItem(index, 6, boot_date)                         # boot_date
                self.list.SetItem(index, 7, package_path)                      # package_path
                img_index = -1
                if patch_method in ['root', 'app', 'other']:
                    img_index = 0  # magisk image index
                elif 'apatch' in patch_method:
                    img_index = 1  # apatch image index
                elif 'kernelsu-next' in patch_method:
                    img_index = 2  # kernelsu-next image index
                elif 'kernelsu' in patch_method:
                    img_index = 3  # kernelsu image index
                elif "downgrade" in patch_method:
                    img_index = 4  # downgrade image index
                elif 'sukisu' in patch_method:
                    img_index = 5  # sukisu image index
                elif 'wild_ksu' in patch_method:
                    img_index = 6  # wild_ksu image index
                if row[3] and img_index != -1:
                    self.list.SetItemColumnImage(i, 0, img_index)
                else:
                    self.list.SetItemColumnImage(i, 0, -1)
                self.list.SetItemData(i, boot_id)  # Store boot_id for later reference
                i += 1

            # Update the database with the new paths
            if paths_to_update:
                try:
                    with con:
                        for boot_id, new_path in paths_to_update:
                            con.execute("UPDATE BOOT SET file_path = ? WHERE id = ?", (new_path, boot_id))
                    print(f"ℹ️ Updated {len(paths_to_update)} boot paths in database")
                except Exception as e:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to update boot paths in database: {e}")

            if i > 0 and full_ota is not None:
                set_ota(self, bool(full_ota))

        auto_resize_boot_list(self)

        # disable buttons
        self.config.boot_id = None
        self.config.selected_boot_md5 = None
        if self.list.ItemCount == 0 :
            if self.config.firmware_path:
                print("\nPlease Process the firmware!")
        else:
            print("\nPlease select a boot image!")
        self.update_widget_states()
        # we need to do this, otherwise the focus goes on the next control, which is a radio button, and undesired.
        self.process_firmware.SetFocus()
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while populating boot list")
        puml("#red:Encountered an error while populating boot list;\n")
        traceback.print_exc()


# ============================================================================
#                               Function auto_resize_boot_list
# ============================================================================
def auto_resize_boot_list(self):
    try:
        # auto size columns to largest text, including the header (except the last column)
        cw = 0
        column_widths = copy.deepcopy(self.boot_column_widths)
        for i in range(self.list.ColumnCount - 1):
            self.list.SetColumnWidth(i, -1)  # Set initial width to -1 (default)
            width = self.list.GetColumnWidth(i)
            self.list.SetColumnWidth(i, -2)  # Auto-size column width to largest text
            width = max(width, self.list.GetColumnWidth(i), column_widths[i])  # Get the maximum width
            if width > column_widths[i]:
                column_widths[i] = width  # Store / update the width in the array
            self.list.SetColumnWidth(i, width)  # Set the column width
            cw += width

        # Set the last column width to the available room
        available_width = self.list.BestVirtualSize.Width - cw - 20
        self.list.SetColumnWidth(self.list.ColumnCount - 1, available_width)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while auto resizing boot list")
        puml("#red:Encountered an error while auto resizing boot list;\n")
        traceback.print_exc()


# ============================================================================
#                               Function identify_sdk_version
# ============================================================================
def identify_sdk_version(self):
    try:
        sdk_version = None
        set_sdk_state(False)
        # Let's grab the adb version
        with contextlib.suppress(Exception):
            if get_adb():
                theCmd = f"\"{get_adb()}\" --version"
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.stdout:
                    # Split lines based on mixed EOL formats
                    lines = re.split(r'\r?\n', res.stdout)
                    for line in lines:
                        if 'Version' in line:
                            sdk_version = line.split()[1]
                            set_sdk_version(sdk_version)
                            # If version is old treat it as bad SDK
                            sdkver = sdk_version.split("-")[0]
                            if parse(sdkver) < parse(SDKVERSION) or (sdkver in ('34.0.0', '34.0.1', '34.0.2', '34.0.3', '34.0.4')):
                                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Detected old or problematic Android Platform Tools version {sdk_version}")
                                # confirm if you want to use older version
                                message = (
                                    _("You have an old or problematic Android platform Tools version %s \n") % sdk_version +
                                    _("You are strongly advised to update before continuing.\n") +
                                    _("Are you sure you want to continue?")
                                )
                                dlg = wx.MessageDialog(
                                    parent=None,
                                    message=message,
                                    caption=_("Bad Android Platform Tools"),
                                    style=wx.YES_NO | wx.NO_DEFAULT | wx.ICON_EXCLAMATION
                                )
                                result = dlg.ShowModal()
                                puml(f"#red:Selected Platform Tools;\nnote left: {self.config.platform_tools_path}\nnote right:ERROR: Detected old or problematic Android Platform Tools version {sdk_version}\n")
                                if result == wx.ID_YES:
                                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User accepted the bad version {sdk_version} of Android platform tools.")
                                    set_sdk_state(True)
                                    puml("#red:User wanted to proceed regardless;\n")
                                else:
                                    print("Bad Android platform tools is not accepted. For your protection, disabling device selection.")
                                    print("Please update Android SDK.\n")
                                    break
                            # 34.01 is still broken, skip the whitelisted binaries
                            # elif sdkver == '34.0.1' and (
                            #             get_adb_sha256() not in (
                            #                 '30c68c1c1a9814a724f47ca544f273b8097263677383046ddb7a0e8c26f7dc60',
                            #                 'bfd5ea39c672b8f0f51796d6fe5439f152e86eafbba9f402d3abda802050e956',
                            #                 '9d8e3e278b4415416b5da6f94f752e808f8a71fa8397bb6a765c1b44bb807bb2')
                            #             or get_fastboot_sha256() not in (
                            #                 'd765b626aa5b54d9d226eb1a915657c6197379835bde67742f9a2832c8c5c2a9',
                            #                 'e8e6b8f4e8d69401967d16531308b48f144202e459662eae656a0c6e68c2741f',
                            #                 '29c66b605521dea3c3e32f3b1fd7c30a1637ec3eb729820a48bd6827e4659a20')):
                            #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The selected Android Platform Tools version {sdkver} has known issues, please select another version.")
                            #     puml(f"#red:Android Platform Tools version {sdkver} has known issues;\n")
                            #     dlg = wx.MessageDialog(None, f"Android Platform Tools version {sdkver} has known issues, please select another version.",f"Android Platform Tools {sdkver}",wx.OK | wx.ICON_EXCLAMATION)
                            #     result = dlg.ShowModal()
                            #     break
                            else:
                                set_sdk_state(True)
                elif res.stderr:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {res.stderr}")

        self.update_widget_states()
        if get_sdk_state():
            return

        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Android Platform Tools version is not available or is too old.")
        print("                           For your protection, disabling device selection.")
        print("                           Please select valid Android SDK.\n")
        puml("#pink:For your protection, disabled device selection;\n")
        self.config.device = None
        self.device_choice.SetItems([''])
        self.device_choice.Select(-1)
        return -1
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while identifying sdk version")
        puml("#red:Encountered an error while identifying sdk version;\n")
        traceback.print_exc()


# ============================================================================
#                               Function get_flash_settings
# ============================================================================
def get_flash_settings(self):
    try:
        message = ''
        message_en = ''
        isPatched = ''

        p_custom_rom = self.config.show_custom_rom_options and self.config.custom_rom and self.config.advanced_options
        p_custom_rom_path = self.config.custom_rom_path
        boot = get_boot()
        device = get_phone()
        if not device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            self.clear_device_selection()
            return

        message_en += "Android SDK Version:    %s\n" %get_sdk_version()
        message_en += "Device:                 %s %s %s\n" % (self.config.device, device.hardware, device.build)
        message_en += "Factory Image:          %s\n" % self.config.firmware_path
        if p_custom_rom and p_custom_rom_path:
            message_en += "Custom Rom:             %s\n" % str(p_custom_rom)
            message_en += "Custom Rom File:        %s\n" % p_custom_rom_path
            rom_file = ntpath.basename(p_custom_rom_path)
            set_custom_rom_file(rom_file)
        message_en += "\nBoot image:             %s / %s \n" % (boot.boot_hash[:8], boot.package_boot_hash[:8])
        message_en += "                        From: %s\n" % boot.package_path
        if boot and boot.is_patched:
            if boot.patch_method:
                message_en += "                        Patched with %s on %s method:        %s\n" % (boot.magisk_version, boot.hardware, boot.patch_method)
            else:
                message_en += "                        Patched with %s on %s\n" % (boot.magisk_version, boot.hardware)
        message_en += "\nFlash Mode:             %s\n" % self.config.flash_mode
        message_en += "\n"

        # translate the message
        message += _("Android SDK Version:    %s\n") %get_sdk_version()
        message += _("Device:                 %s %s %s\n") % (self.config.device, device.hardware, device.build)
        message += _("Factory Image:          %s\n") % self.config.firmware_path
        if p_custom_rom and p_custom_rom_path:
            message += _("Custom Rom:             %s\n") % str(p_custom_rom)
            message += _("Custom Rom File:        %s\n") % p_custom_rom_path
            rom_file = ntpath.basename(p_custom_rom_path)
            set_custom_rom_file(rom_file)
        message += _("\nBoot image:             %s / %s \n") % (boot.boot_hash[:8], boot.package_boot_hash[:8])
        message += _("                        From: %s\n") % boot.package_path
        if boot and boot.is_patched:
            if boot.patch_method:
                message += _("                        Patched with %s on %s method:        %s\n") % (boot.magisk_version, boot.hardware, boot.patch_method)
            else:
                message += _("                        Patched with %s on %s\n") % (boot.magisk_version, boot.hardware)
        message += _("\nFlash Mode:             %s\n") % self.config.flash_mode
        message += "\n"

        return message
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting flash settings")
        puml("#red:Encountered an error while while getting flash settings;\n")
        traceback.print_exc()


# ============================================================================
#                               Function adb_kill_server
# ============================================================================
def adb_kill_server(self):
    try:
        if get_adb():
            print("Invoking adb kill-server ...")
            puml(":adb kill-server;\n", True)
            theCmd = f"\"{get_adb()}\" kill-server"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                print("returncode: 0")
                puml(f"#palegreen:Succeeded;\n")
                self.device_choice.SetItems(get_connected_devices())
                self._select_configured_device()
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not kill adb server.\n")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"#red:**Failed**\n{res.stderr}\n{res.stdout};\n")
                return -1
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Missing Android platform tools.\n")
            puml(f"#red:Missing Android platform tools;\n")
            return -1
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while killing adb server.")
        puml("#red:Encountered an error while killing adb server;\n")
        traceback.print_exc()


# ============================================================================
#                               Function set_flash_button_state
# ============================================================================
def set_flash_button_state(self):
    try:
        boot = get_boot()
        factory_images = os.path.join(get_config_path(), 'factory_images')
        if boot and os.path.exists(boot.boot_path) and os.path.exists(os.path.join(factory_images, boot.package_sig)):
            self.flash_button.Enable()
        else:
            self.flash_button.Disable()
            if boot:
                if not os.path.exists(boot.boot_path):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Boot image {boot.boot_path} does not exist.")
                if not os.path.exists(os.path.join(factory_images, boot.package_sig)):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Package {os.path.join(factory_images, boot.package_sig)} does not exist.")
            # else:
            #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Boot image is not selected.")
    except Exception:
        traceback.print_exc()
        self.flash_button.Disable()


# ============================================================================
#                               Function select_firmware
# ============================================================================
def select_firmware(self):
    try:
        puml(":Selecting Firmware;\n", True)
        firmware = ntpath.basename(self.config.firmware_path)
        filename, extension = os.path.splitext(firmware)
        extension = extension.lower()
        if extension in ['.zip', '.tgz', '.tar']:
            print(f"The following firmware is selected: {firmware}")

            if self.config.check_for_firmware_hash_validity:
                print("Calculating SHA-256 checksum of the selected firmware, please wait ...")
                wx.Yield()
                firmware_hash = sha256(self.config.firmware_path)
                print(f"SHA-256: {firmware_hash}")
                puml(f"note right\n{firmware}\nSHA-256: {firmware_hash}\nend note\n")

                # Check to see if the first 8 characters of the checksum is in the filename, Google published firmwares do have this.
                if firmware_hash and firmware_hash[:8] in firmware:
                    print(f"✅ Expected to match {firmware_hash[:8]} in the filename and did. This is good!")
                    puml(f"#CDFFC8:Checksum matches portion of the filename {firmware};\n")
                    self.toast("_(✅ Firmware SHA256 Match", _("SHA256 of %s%s matches the segment in the filename.") % (filename, extension))
                    set_firmware_hash_validity(True)
                else:
                    print(f"⚠️ WARNING: Expected to match {firmware_hash[:8]} in the {filename}{extension} but didn't, please double check to make sure the checksum is good.")
                    puml("#orange:Unable to match the checksum in the filename;\n")
                    self.toast(_("⚠️ Firmware SHA256 Mismatch"), _("WARNING! SHA256 of %s%s does not match segments in the filename.\nPlease double check to make sure the checksum is good.") % (filename, extension))
                    set_firmware_hash_validity(False)

            firmware = filename.split("-")
            if len(firmware) == 1:
                set_firmware_model(None)
                set_firmware_id(filename)
            else:
                try:
                    set_firmware_model(firmware[0])
                    if firmware[1] == 'ota' or firmware[0] == 'crDroidAndroid':
                        set_firmware_id(f"{firmware[0]}-{firmware[1]}-{firmware[2]}")
                        self.config.firmware_is_ota = True
                    else:
                        set_firmware_id(f"{firmware[0]}-{firmware[1]}")
                        self.config.firmware_is_ota = False
                except Exception as e:
                    traceback.print_exc()
                    set_firmware_model(None)
                    set_firmware_id(filename)
            set_ota(self, self.config.firmware_is_ota)
            if get_firmware_id():
                set_flash_button_state(self)
            else:
                self.flash_button.Disable()
            populate_boot_list(self)
            self.update_widget_states()
            if self.config.check_for_firmware_hash_validity:
                return firmware_hash
            else:
                return 'Checksum validity check is disabled!'
        else:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The selected file {firmware} is not a valid archive file.")
            puml("#red:The selected firmware is not valid;\n")
            self.config.firmware_path = None
            self.firmware_picker.SetPath('')
            return 'Select Pixel Firmware'
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while selecting ota/firmware file:")
        puml("#red:Encountered an error while selecting ota/firmware file;\n")
        traceback.print_exc()


# ============================================================================
#                               Function process_file
# ============================================================================
def process_file(self, file_type):
    try:
        print("")
        print("==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} PixelFlasher {VERSION}         Processing {file_type} file ...")
        print("==============================================================================")
        print(f"Low memory option:     {self.config.low_mem}")
        print(get_printable_memory())
        puml(f"#cyan:Process {file_type};\n", True)
        config_path = get_config_path()
        path_to_7z = get_path_to_7z()
        boot_images = os.path.join(config_path, get_boot_images_dir())
        tmp_dir_full = os.path.join(config_path, 'tmp')
        con = get_db_con()
        if con is None:
            return None
        cursor = con.cursor()
        start_1 = time.time()
        checksum = ''
        is_odin = False
        is_init_boot = False
        is_stock_boot = False
        image_file_path = None

        is_payload_bin = False
        factory_images = os.path.join(config_path, 'factory_images')
        if file_type == 'firmware':
            is_stock_boot = True
            file_to_process = self.config.firmware_path
            file_ext = os.path.splitext(file_to_process)[1].lower()
            print(f"Factory File:          {file_to_process}")
            file_size = os.path.getsize(file_to_process)
            file_size_gb = file_size / (1024 * 1024 * 1024)
            print(f"File Size:             {file_size_gb:.2f} GB")
            if file_size_gb > 3:
                print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                print("⚠️ WARNING: The selected firmware file is larger than 3GB.")
                print("This could take a while to process, please be patient.")
                print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
                puml("#orange:Large firmware file detected;\n")
                wx.Yield()

            puml(f"note right:{file_to_process}\n")
            package_sig = get_firmware_id()
            package_dir_full = os.path.join(factory_images, package_sig)
            wx.Yield()
            found_flash_all_bat = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="flash-all.bat", nested=False)
            wx.Yield()
            found_flash_all_sh = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="flash-all.sh", nested=False)
            wx.Yield()
            found_boot_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="boot.img", nested=True)
            wx.Yield()
            found_init_boot_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="init_boot.img", nested=True)
            wx.Yield()
            found_vbmeta_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="vbmeta.img", nested=True)
            wx.Yield()
            found_vendor_boot_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="vendor_boot.img", nested=True)
            wx.Yield()
            found_boot_img_lz4 = ''
            set_firmware_has_init_boot(False)
            set_ota(self, False)
            if found_init_boot_img:
                set_firmware_has_init_boot(True)
                is_init_boot = True
            if found_flash_all_bat and found_flash_all_sh and (get_firmware_hash_validity() or not self.config.check_for_firmware_hash_validity):
                # assume Pixel factory file
                if self.config.check_for_firmware_hash_validity:
                    print("Detected Pixel firmware")
                package_sig = found_flash_all_bat.split('/')[0]
                package_dir_full = os.path.join(factory_images, package_sig)
                image_file_path = os.path.join(package_dir_full, f"image-{package_sig}.zip")
                # Unzip the factory image
                wx.Yield()
                debug(f"Unzipping Image: {file_to_process} into {package_dir_full} ...")
                theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{factory_images}\" \"{file_to_process}\""
                debug(theCmd)
                res = run_shell2(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {file_to_process}")
                        puml("#red:ERROR: Could not extract image;\n")
                        print("Aborting ...\n")
                        self.toast(_("Process action"), _("❌ Could not extract %s") % file_to_process)
                        return
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {file_to_process}")
                    puml("#red:ERROR: Could not extract image;\n")
                    print("Aborting ...\n")
                    self.toast(_("Process action"), "❌ Could not extract %s" % file_to_process)
                    return
                if os.path.exists(image_file_path):
                    print("Possibly the selected image is an official Pixel factory image.")
                else:
                    print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    print(f"⚠️ WARNING: Possibly the selected image is a Non-official Pixel factory image.")
                    print("Please check the file you selected, it may not be a valid Pixel factory image.")
                    print("If it is not an official Pixel factory image, please check the author's documentation for more information.")
                    print("Do not flash this image if you are not sure how to proceed, it may brick your device!")
                    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
                    puml("#orange:Possible Non-Pixel factory image found;\n")
                    image_file_path = None
                wx.Yield()
            elif found_boot_img or found_init_boot_img:
                print(f"Detected Non Pixel firmware, with: {found_boot_img} {found_init_boot_img}")
                # Check if the firmware file starts with image-* and warn the user or abort
                firmware_file_name = os.path.basename(file_to_process)
                # empty mkdir - Nothing will be extracted here, needed for Non-Pixel factory firmware
                os.makedirs(package_dir_full, exist_ok=True)
                if firmware_file_name.startswith('image-'):
                    title = _("Possibly extracted firmware.")
                    message_en =  "WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n"
                    message_en += "You should not extract the file, please select the downloaded firmware file instead\n\n"
                    message_en += "If this is not the case, and you want to continue with this selection\n"
                    message_en += "Click OK to accept and continue.\n"
                    message_en += "or Hit CANCEL to abort."
                    message =  _("WARNING: It looks like you have extracted the firmware file.\nand selected the image zip from it.\n\n")
                    message += _("You should not extract the file, please select the downloaded firmware file instead\n\n")
                    message += _("If this is not the case, and you want to continue with this selection\n")
                    message += _("Click OK to accept and continue.\n")
                    message += _("or Hit CANCEL to abort.")
                    print(f"\n*** Dialog ***\n{message_en}\n______________\n")
                    puml("#orange:WARNING;\n", True)
                    puml(f"note right\n{message_en}\nend note\n")
                    dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
                    result = dlg.ShowModal()
                    if result != wx.ID_OK:
                        print("User pressed cancel.")
                        puml("#pink:User Pressed Cancel to abort;\n")
                        print("Aborting ...\n")
                        return
                    print("User pressed ok.")
                    puml(":User Pressed OK to continue;\n")
                image_file_path = file_to_process
            elif check_zip_contains_file(file_to_process, "payload.bin", self.config.low_mem):
                is_payload_bin = True
                set_ota(self, True)
                if get_ota() and (get_firmware_hash_validity() or not self.config.check_for_firmware_hash_validity):
                    print("Detected OTA file")
                else:
                    print("Detected a firmware, with payload.bin")
                wx.Yield()
            else:
                # -------------------------
                # Samsung firmware handling
                # -------------------------
                # Get file list from zip
                file_list = get_zip_file_list(file_to_process)
                patterns = {
                    'AP': 'AP_*.tar.md5',
                    'BL': 'BL_*.tar.md5',
                    'HOME_CSC': 'HOME_CSC_*.tar.md5',
                    'CSC': 'CSC_*.tar.md5',
                }
                found_ap = ''
                found_bl = ''
                found_csc = ''
                found_home_csc = ''
                # see if we find AP_*.tar.md5, if yes set is_samsung flag
                for file in file_list:
                    wx.Yield()
                    if not found_ap and fnmatch.fnmatch(file, patterns['AP']):
                        # is_odin = 1
                        is_odin = True
                        print(f"Found {file} file.")
                        found_ap = file
                    if not found_bl and fnmatch.fnmatch(file, patterns['BL']):
                        print(f"Found {file} file.")
                        found_bl = file
                    if not found_home_csc and fnmatch.fnmatch(file, patterns['HOME_CSC']):
                        print(f"Found {file} file.")
                        found_home_csc = file
                    if not found_csc and fnmatch.fnmatch(file, patterns['CSC']):
                        print(f"Found {file} file.")
                        found_csc = file

                # TODO check settings, see if offer samsung extraction options is enabled
                # if yes, offer list of found files to extract
                if found_ap:
                    # assume Samsung firmware
                    print("Detected Samsung firmware")
                    image_file_path = os.path.join(package_dir_full, found_ap)
                    # Unzip the factory image
                    debug(f"Unzipping Image: {file_to_process} into {package_dir_full} ...")
                    theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{package_dir_full}\" \"{file_to_process}\""
                    debug(theCmd)
                    wx.Yield()
                    res = run_shell2(theCmd)
                    wx.Yield()
                    # see if there is boot.img.lz4 in AP file
                    found_boot_img_lz4 = check_archive_contains_file(archive_file_path=image_file_path, file_to_check="boot.img.lz4", nested=False)
                    if found_boot_img_lz4:
                        boot_image_file = "boot.img.lz4"
                    else:
                        # if not look for boot.img (some Samsung devices don't have boot.img.lz4)
                        found_boot_img = check_archive_contains_file(archive_file_path=image_file_path, file_to_check="boot.img", nested=False)
                        if found_boot_img:
                            boot_image_file = "boot.img"
                    if boot_image_file:
                        print(f"Extracting {boot_image_file} from {found_ap} ...")
                        puml(f":Extract {boot_image_file};\n")
                        theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{package_dir_full}\" \"{image_file_path}\" {boot_image_file}"
                        wx.Yield()
                        debug(f"{theCmd}")
                        res = run_shell(theCmd)
                        wx.Yield()
                        # expect ret 0
                        if res and isinstance(res, subprocess.CompletedProcess):
                            debug(f"Return Code: {res.returncode}")
                            debug(f"Stdout: {res.stdout}")
                            debug(f"Stderr: {res.stderr}")
                            if res.returncode != 0:
                                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {boot_image_file}")
                                puml(f"#red:ERROR: Could not extract {boot_image_file};\n")
                                print("Aborting ...\n")
                                self.toast(_("Process action"), "❌ Could not extract %s." % boot_image_file)
                                return
                            else:
                                if boot_image_file == "boot.img.lz4":
                                    # unpack boot.img.lz4
                                    print(f"Unpacking {boot_image_file} ...")
                                    puml(f":Unpack {boot_image_file};\n")
                                    unpack_lz4(os.path.join(package_dir_full, 'boot.img.lz4'), os.path.join(package_dir_full, 'boot.img'))
                                # Check if it exists
                                if os.path.exists(os.path.join(package_dir_full, 'boot.img')):
                                    found_boot_img = 'boot.img'
                                else:
                                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not unpack {boot_image_file}")
                                    puml("#red:ERROR: Could not unpack {boot_image_file};\n")
                                    print("Aborting ...\n")
                                    self.toast(_("Process action"), _("❌ Could not unpack %s.") % boot_image_file)
                                    return
                        else:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {boot_image_file}")
                            puml(f"#red:ERROR: Could not extract {boot_image_file};\n")
                            print("Aborting ...\n")
                            self.toast(_("Process action"), _("❌ Could not extract %s.") % boot_image_file)
                            return
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {boot_image_file}")
                        puml(f"#red:ERROR: Could not find {boot_image_file};\n")
                        print("Aborting ...\n")
                        self.toast(_("Process action"), _("❌ Could not find %s.") % boot_image_file)
                        return
                else:
                    print("Detected Unsupported firmware file.")
                    print("Aborting ...")
                    self.toast(_("Process action"), _("⚠️ Detected unsupported firmware."))
                    return
        else:
            file_to_process = self.config.custom_rom_path
            file_ext = os.path.splitext(file_to_process)[1].lower()
            print(f"ROM File:              {file_to_process}")
            file_size = os.path.getsize(file_to_process)
            file_size_gb = file_size / (1024 * 1024 * 1024)
            print(f"File Size:             {file_size_gb:.2f} GB")
            if file_size_gb > 3:
                print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                print("⚠️ WARNING: The selected ROM file is larger than 3GB.")
                print("This could take a while to process, please be patient.")
                print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
                puml("#orange:Large firmware file detected;\n")
                wx.Yield()
            wx.Yield()
            found_boot_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="boot.img", nested=False)
            wx.Yield()
            found_init_boot_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="init_boot.img", nested=False)
            wx.Yield()
            found_vbmeta_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="vbmeta.img", nested=False)
            wx.Yield()
            found_vendor_boot_img = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="vendor_boot.img", nested=False)
            wx.Yield()
            set_rom_has_init_boot(False)
            if found_init_boot_img:
                set_rom_has_init_boot(True)
                is_init_boot = True
            elif check_zip_contains_file(file_to_process, "payload.bin", self.config.low_mem):
                print("Detected a ROM, with payload.bin")
                is_payload_bin = True
            package_sig = get_custom_rom_id()
            package_dir_full = os.path.join(factory_images, package_sig)
            image_file_path = file_to_process
            puml(f"note right:{image_file_path}\n")

        # delete all files in tmp folder to make sure we're dealing with new files only.
        wx.Yield()
        delete_all(tmp_dir_full)

        if is_payload_bin:
            # extract the payload.bin into a temporary directory
            is_stock_boot = True
            temp_dir = tempfile.TemporaryDirectory()
            temp_dir_path = temp_dir.name
            try:
                print(f"Extracting payload.bin from {file_to_process} ...")
                puml(":Extract payload.bin;\n")
                theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{file_to_process}\" payload.bin"
                debug(f"{theCmd}")
                wx.Yield()
                res = run_shell(theCmd)
                wx.Yield()
                # expect ret 0
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract payload.bin.")
                        puml("#red:ERROR: Could not extract payload.bin;\n")
                        print("Aborting ...\n")
                        self.toast(_("Process action"), _("❌ Could not extract payload.bin."))
                        return
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract payload.bin.")
                    puml("#red:ERROR: Could not extract payload.bin;\n")
                    print("Aborting ...\n")
                    self.toast(_("Process action"), _("❌ Could not extract payload.bin."))
                    return
                # extract boot.img, init_boot.img, vbmeta.img from payload.bin, ...
                payload_file_path = os.path.join(temp_dir_path, "payload.bin")
                if not os.path.exists(package_dir_full):
                    os.makedirs(package_dir_full, exist_ok=True)
                if self.config.extra_img_extracts:
                    print("Option to copy extra img files is enabled.")
                    wx.Yield()
                    extract_payload(payload_file_path, out=package_dir_full, diff=False, old='old', images='boot,vbmeta,init_boot,dtbo,super_empty,vendor_boot,vendor_kernel_boot')
                    wx.Yield()
                    if os.path.exists(os.path.join(package_dir_full, 'dtbo.img')):
                        dtbo_img_file = os.path.join(package_dir_full, 'dtbo.img')
                        debug(f"Copying {dtbo_img_file}")
                        shutil.copy(dtbo_img_file, os.path.join(tmp_dir_full, 'dtbo.img'), follow_symlinks=True)
                    if os.path.exists(os.path.join(package_dir_full, 'super_empty.img')):
                        super_empty_img_file = os.path.join(package_dir_full, 'super_empty.img')
                        debug(f"Copying {super_empty_img_file}")
                        shutil.copy(super_empty_img_file, os.path.join(tmp_dir_full, 'super_empty.img'), follow_symlinks=True)
                    if os.path.exists(os.path.join(package_dir_full, 'vendor_boot.img')):
                        vendor_boot_img_file = os.path.join(package_dir_full, 'vendor_boot.img')
                        debug(f"Copying {vendor_boot_img_file}")
                        shutil.copy(vendor_boot_img_file, os.path.join(tmp_dir_full, 'vendor_boot.img'), follow_symlinks=True)
                    if os.path.exists(os.path.join(package_dir_full, 'vendor_kernel_boot.img')):
                        vendor_kernel_boot_img_file = os.path.join(package_dir_full, 'vendor_kernel_boot.img')
                        debug(f"Copying {vendor_kernel_boot_img_file}")
                        shutil.copy(vendor_kernel_boot_img_file, os.path.join(tmp_dir_full, 'vendor_kernel_boot.img'), follow_symlinks=True)
                else:
                    print("Extracting files from payload.bin ...")
                    wx.Yield()
                    extract_payload(payload_file_path, out=package_dir_full, diff=False, old='old', images='boot,vbmeta,init_boot,vendor_boot')
                    wx.Yield()
                if os.path.exists(os.path.join(package_dir_full, 'boot.img')):
                    boot_img_file = os.path.join(package_dir_full, 'boot.img')
                    debug(f"Copying {boot_img_file}")
                    shutil.copy(boot_img_file, os.path.join(tmp_dir_full, 'boot.img'), follow_symlinks=True)
                    boot_file_name = 'boot.img'
                if os.path.exists(os.path.join(package_dir_full, 'init_boot.img')):
                    boot_img_file = os.path.join(package_dir_full, 'init_boot.img')
                    debug(f"Copying {boot_img_file}")
                    shutil.copy(boot_img_file, os.path.join(tmp_dir_full, 'init_boot.img'), follow_symlinks=True)
                    boot_file_name = 'init_boot.img'
                    found_init_boot_img = 'True' # This is intentionally a string, all we care is for it to not evaluate to False
                    is_init_boot = True
                if os.path.exists(os.path.join(package_dir_full, 'vendor_boot.img')):
                    boot_img_file = os.path.join(package_dir_full, 'vendor_boot.img')
                    debug(f"Copying {boot_img_file}")
                    shutil.copy(boot_img_file, os.path.join(tmp_dir_full, 'vendor_boot.img'), follow_symlinks=True)
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered while processing payload.bin")
                traceback.print_exc()
            finally:
                temp_dir.cleanup()
        else:
            if is_odin:
                shutil.copy(os.path.join(package_dir_full, 'boot.img'), os.path.join(tmp_dir_full, 'boot.img'), follow_symlinks=True)
            if image_file_path and not os.path.exists(image_file_path):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The firmware file did not have the expected structure / contents.")
                if file_type == 'firmware':
                    print(f"Please check {self.config.firmware_path} to make sure it is a valid factory image file.")
                    puml("#red:The selected firmware is not valid;\n")
                print("Aborting ...\n")
                self.toast(_("Process action"), _("❌ The selected firmware is not valid."))
                return

            files_to_extract = ''
            if found_boot_img:
                boot_file_name = 'boot.img'
                files_to_extract += 'boot.img '
            if found_init_boot_img:
                boot_file_name = 'init_boot.img'
                files_to_extract += 'init_boot.img '
                is_init_boot = True
            if found_vbmeta_img:
                files_to_extract += 'vbmeta.img '
            if found_vendor_boot_img:
                files_to_extract += 'vendor_boot.img '
            files_to_extract = files_to_extract.strip()

            if not is_odin:
                if not files_to_extract:
                    print(f"Nothing to extract from {file_type}")
                    print("Aborting ...")
                    puml("#red:Nothing to extract from {file_type};\n")
                    self.toast(_("Process action"), _("⚠️ Nothing to extract from %s") % file_type)
                    return

                if image_file_path:
                    print(f"Extracting {files_to_extract} from {image_file_path} ...")
                    print("This could take some more time, please wait ...")
                    puml(f":Extract {files_to_extract};\n")
                    wx.Yield()
                    if file_ext in ['.tgz']:
                        res = extract_from_nested_tgz(image_file_path, files_to_extract, tmp_dir_full)
                        if not res:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {boot_file_name}.")
                            puml(f"#red:ERROR: Could not extract {boot_file_name};\n")
                            self.toast(_("Process action"), _("❌ Could not extract %s") % boot_file_name)
                            print("Aborting ...\n")
                            return
                    else:
                        theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{tmp_dir_full}\" \"{image_file_path}\" {files_to_extract}"
                        debug(f"{theCmd}")
                        wx.Yield()
                        res = run_shell(theCmd)
                        # expect ret 0
                        if res and isinstance(res, subprocess.CompletedProcess):
                            debug(f"Return Code: {res.returncode}")
                            debug(f"Stdout: {res.stdout}")
                            debug(f"Stderr: {res.stderr}")
                            if res.returncode != 0:
                                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {boot_file_name}.")
                                puml(f"#red:ERROR: Could not extract {boot_file_name};\n")
                                self.toast(_("Process action"), _("❌ Could not extract %s") % boot_file_name)
                                print("Aborting ...\n")
                                return
                        else:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {boot_file_name}.")
                            puml(f"#red:ERROR: Could not extract {boot_file_name};\n")
                            self.toast(_("Process action"), _("❌ Could not extract %s") % boot_file_name)
                            print("Aborting ...\n")
                            return

        # sometimes the return code is 0 but no file to extract, handle that case.
        # also handle the case of extraction from payload.bin
        if image_file_path:
            boot_img_file = os.path.join(tmp_dir_full, boot_file_name)
        else:
            boot_img_file = os.path.join(package_dir_full, boot_file_name)
        if not os.path.exists(boot_img_file):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {boot_file_name}, ")
            print(f"Please make sure the file: {image_file_path} has {boot_file_name} in it.")
            puml(f"#red:ERROR: Could not extract {boot_file_name};\n")
            print("Aborting ...\n")
            self.toast(_("Process action"), _("❌ Could not extract %s") % boot_file_name)
            return

        # get the checksum of the boot_file_name
        wx.Yield()
        checksum = sha1(os.path.join(boot_img_file))
        print(f"sha1 of {boot_file_name}: {checksum}")
        puml(f"note right:sha1 of {boot_file_name}: {checksum}\n")

        # if a matching boot_file_name is not found, store it.
        cached_boot_img_dir_full = os.path.join(boot_images, checksum)
        cached_boot_img_path = os.path.join(cached_boot_img_dir_full, boot_file_name)
        print(f"Checking for cached copy of {boot_file_name}")
        if not os.path.exists(cached_boot_img_dir_full):
            os.makedirs(cached_boot_img_dir_full, exist_ok=True)
        if not os.path.exists(cached_boot_img_path):
            print(f"Cached copy of {boot_file_name} with sha1: {checksum} is not found.")
            print(f"Copying {boot_img_file} to {cached_boot_img_dir_full}")
            shutil.copy(boot_img_file, cached_boot_img_dir_full, follow_symlinks=True)
        else:
            print(f"Found a cached copy of {file_type} {boot_file_name} sha1={checksum}")

        # we need to copy boot.img for Pixel 7, 7P, 7a .. so that we can do live boot or KernelSu Patching.
        if image_file_path:
            if found_init_boot_img and os.path.exists(os.path.join(tmp_dir_full, 'boot.img')):
                shutil.copy(os.path.join(tmp_dir_full, 'boot.img'), cached_boot_img_dir_full, follow_symlinks=True)
            # we copy vbmeta.img so that we can do selective vbmeta verity / verification patching.
            if found_vbmeta_img and os.path.exists(package_dir_full):
                shutil.copy(os.path.join(tmp_dir_full, 'vbmeta.img'), package_dir_full, follow_symlinks=True)
            if found_vendor_boot_img and os.path.exists(package_dir_full):
                shutil.copy(os.path.join(tmp_dir_full, 'vendor_boot.img'), package_dir_full, follow_symlinks=True)
                shutil.copy(os.path.join(tmp_dir_full, 'vendor_boot.img'), cached_boot_img_dir_full, follow_symlinks=True)
        else:
            if found_init_boot_img and os.path.exists(os.path.join(package_dir_full, 'boot.img')):
                shutil.copy(os.path.join(package_dir_full, 'boot.img'), cached_boot_img_dir_full, follow_symlinks=True)
            if os.path.exists(os.path.join(package_dir_full, 'vendor_boot.img')):
                shutil.copy(os.path.join(package_dir_full, 'vendor_boot.img'), cached_boot_img_dir_full, follow_symlinks=True)

        # Let's see if we have a record for the firmware/rom being processed
        print(f"Checking DB entry for PACKAGE: {file_to_process}")
        package_id = 0
        cursor.execute(f"SELECT ID, boot_hash FROM PACKAGE WHERE package_sig = '{package_sig}' AND file_path = '{file_to_process}'")
        data = cursor.fetchall()
        if len(data) > 0:
            package_id = data[0][0]
            print(f"Found a previous {file_type} PACKAGE record id={package_id} for package_sig: {package_sig} Firmware: {file_to_process}")
            print(f"Package ID: {package_id}")
        else:
            # create PACKAGE db record
            print(f"Creating DB entry for PACKAGE: {file_to_process}")
            sql = 'INSERT INTO PACKAGE (boot_hash, type, package_sig, file_path, epoch, full_ota ) values(?, ?, ?, ?, ?, ?) ON CONFLICT (file_path) DO NOTHING'
            data = checksum, file_type, package_sig, file_to_process, time.time(), self.config.firmware_is_ota
            try:
                cursor.execute(sql, data)
                con.commit()
                package_id = cursor.lastrowid
                print(f"Package ID: {package_id}")
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
                traceback.print_exc()

        # Let's see if we already have an entry for the BOOT
        wx.Yield()
        print(f"Checking DB entry for BOOT: {checksum}")
        boot_id = 0
        cursor.execute(f"SELECT ID FROM BOOT WHERE boot_hash = '{checksum}'")
        data = cursor.fetchall()
        if len(data) > 0:
            boot_id = data[0][0]
            print(f"Found a previous BOOT record id={boot_id} for boot_hash: {checksum}")
            print(f"Boot_ID: {boot_id}")
        else:
            # create BOOT db record
            print(f"Creating DB entry for BOOT: {checksum}")
            sql = 'INSERT INTO BOOT (boot_hash, file_path, is_patched, magisk_version, hardware, epoch, patch_method, is_odin, is_stock_boot, is_init_boot) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (boot_hash) DO NOTHING'
            data = checksum, cached_boot_img_path, 0, '', '', time.time(), '', is_odin, is_stock_boot, is_init_boot
            try:
                cursor.execute(sql, data)
                con.commit()
                boot_id = cursor.lastrowid
                print(f"Boot ID: {boot_id}")
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
                traceback.print_exc()

        # Let's see if we already have an entry for the PACKAGE_BOOT
        print(f"Checking DB entry for PACKAGE_BOOT: package_id = '{package_id}' AND boot_id = '{boot_id}")
        cursor.execute(f"SELECT package_id, boot_id FROM PACKAGE_BOOT WHERE package_id = '{package_id}' AND boot_id = '{boot_id}'")
        data = cursor.fetchall()
        if len(data) > 0:
            package_boot_id = data[0][0]
            print(f"Found a previous PACKAGE_BOOT record for package_id: {package_id},  boot_id: {boot_id}")
            print(f"Package_Boot row id: {package_boot_id}")
        else:
        # create PACKAGE_BOOT db record
            print(f"Creating PACKAGE_BOOT record, package_id: {package_id} boot_id: {boot_id}")
            sql = 'INSERT INTO PACKAGE_BOOT (package_id, boot_id, epoch) values(?, ?, ?) ON CONFLICT (package_id, boot_id) DO NOTHING'
            data = package_id, boot_id, time.time()
            try:
                cursor.execute(sql, data)
                con.commit()
                package_boot_id = cursor.lastrowid
                print(f"Package_Boot row id: {package_boot_id}")
            except Exception as e:
                print(f"Record PACKAGE_BOOT record, package_id: {package_id} boot_id: {boot_id} already exists")
                traceback.print_exc()

        set_db(con)
        populate_boot_list(self)
        end_1 = time.time()
        print(f"Process {file_type} time: {math.ceil(end_1 - start_1)} seconds")
        print("------------------------------------------------------------------------------\n")
        self.toast(_("Process action"), _("✅ Process %s time: %s seconds") % (file_type, math.ceil(end_1 - start_1)))
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing ota/firmware file:")
        traceback.print_exc()


# ============================================================================
#                               Function process_flash_all_file
# ============================================================================
def process_flash_all_file(filepath):
    if not os.path.exists(filepath):
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR! File: {filepath} not found.")
        return "ERROR"
    try:
        cwd = os.getcwd()
        flash_file_lines = []
        with open(filepath) as fp:
            #1st line, platform
            line = fp.readline()
            if line[:9] == "@ECHO OFF":
                filetype = 'bat'
            elif line[:9] == "#!/bin/sh":
                filetype = 'sh'
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unexpected first line: {line} in file: {filepath}")
            flash = FlashFile(1, platform = filetype, type = "init", command = line.strip())
            flash_file_lines.append(flash)

            cnt = 1
            in_if_block = False
            if_block_data = ''
            while line:
                line = fp.readline()

                #---------------------------------
                # Line that should not be captured
                if line.strip() == '':
                    # blank line, ignore it
                    continue
                elif line[:2] == "::":
                    # comment line windows, ignore it
                    continue
                elif line[:1] == "#":
                    # comment line Linux, ignore it
                    continue
                elif line[:10] == "pause >nul":
                    # pause line, ignore it
                    continue
                elif line[:4] == "exit":
                    # exit line, ignore it
                    continue
                elif line[:26] == "echo Press any key to exit":
                    # exit line, ignore it
                    continue

                #-----------------------
                # line that are relevant
                elif line[:4] == "if !":
                    # if line to check fastboot version, grab it differently (all as one block)
                    in_if_block = True
                    if_block_data += line
                    continue
                elif line[:7] == "  echo ":
                    # part of the previous if, grab it differently (all as one block)
                    if in_if_block:
                        if_block_data += line
                    continue
                elif line[:6] == "  exit":
                    # part of the previous if, grab it differently (all as one block)
                    if in_if_block:
                        if_block_data += line
                    continue
                elif line[:2] == "fi":
                    # part of the previous if, grab it differently (all as one block)
                    if in_if_block:
                        if_block_data += line
                    in_if_block = False
                    flash = FlashFile(cnt, platform = filetype, type = "if_block", command = if_block_data.strip())
                    flash_file_lines.append(flash)
                    continue
                elif line[:5] == "PATH=":
                    flash = FlashFile(cnt, platform = filetype, type = "path", command = line.strip())
                    flash_file_lines.append(flash)
                    continue

                elif line[:5] == "ping " or line[:6] == "sleep ":
                    flash = FlashFile(cnt, platform = filetype, type = "sleep", command = line.strip())
                    flash_file_lines.append(flash)
                    continue

                elif line[:8] == "fastboot":
                    parts = line.split()
                    if parts[1] == 'flash':
                        flash = FlashFile(cnt, platform = filetype, type = "fastboot", command = "fastboot", action = "flash", arg1 = parts[2], arg2 = parts[3])
                        flash_file_lines.append(flash)
                        continue
                    elif parts[1] == 'reboot-bootloader':
                        flash = FlashFile(cnt, platform = filetype, type = "fastboot", command = "fastboot", action = "reboot-bootloader")
                        flash_file_lines.append(flash)
                        continue
                    elif parts[1] == '-w' and parts[2] == 'update':
                        flash = FlashFile(cnt, platform = filetype, type = "fastboot", command = "fastboot", action = "-w update", arg1 = parts[3])
                        flash_file_lines.append(flash)
                        continue
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR! Encountered an unexpected fastboot line while parsing {filepath}")
                        print(line)
                        return "ERROR"

                #-----------------
                # Unexpected lines
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR! Encountered an unexpected line while parsing {filepath}")
                    print(line)
                    return "ERROR"

                cnt += 1
            return flash_file_lines
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing flash_all file")
        puml("#red:Encountered an error while processing flash_all file;\n")
        traceback.print_exc()


# ============================================================================
#                               Function setup_for_downgrade
# ============================================================================
def setup_for_downgrade(self):
    try:
        device = get_phone()
        if not device:
            print("\nNo device is selected!")
            self.clear_device_selection()
        config_path = get_config_path()
        tmp_dir_full = os.path.join(config_path, 'tmp')
        current_boot_img = os.path.join(tmp_dir_full, 'current_boot.img')
        boot = get_boot()
        if not boot:
            print("\nPlease select a boot image!")
            return -1

        boot_path = boot.boot_path
        directory_path = os.path.dirname(boot_path)
        target_boot_img = os.path.join(directory_path, 'boot.img')
        downgrade_file_name = "downgrade_boot.img"
        downgrade_file_path = os.path.join(directory_path, downgrade_file_name)

        puml("#cyan:Create Downgrade Patch;\n", True)
        puml("partition \"**Create Downgrade Patch**\" {\n")

        # Make sure platform-tools is set
        if not self.config.platform_tools_path:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Select Android Platform Tools (ADB)")
            print("Aborting ...\n")
            puml("#red:Valid Android Platform Tools is not selected;\n}\n")
            return

        # Make sure boot image is selected
        if not self.config.boot_id:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Select a boot image.")
            print("Aborting ...\n")
            puml("#red:Valid boot image is not selected;\n}\n")
            return

        # make sure the target_boot_img exists
        if not os.path.exists(target_boot_img):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Boot image {target_boot_img} does not exist.")
            print("Aborting ...\n")
            puml("#red:Boot image does not exist;\n}\n")
            self._on_spin('stop')
            return

        print(f"\n=== Getting AVB info for Target boot.img [{target_boot_img}] ...")
        target_boot_info = get_boot_image_info(target_boot_img)

        if device and device.rooted:
            option_text = "Option 1"
            option = 1
            disabled_buttons = []
            device_is_rooted = True
        else:
            option_text = "Option 2"
            option = 2
            disabled_buttons = [1]
            device_is_rooted = False

        title = "Downgrade Patch Creation"
        buttons_text = ["Option 1", "Option 2", "Option 3", "Cancel"]
        buttons_text[option -1] += " (Recommended)"
        checkboxes=["Patch com.android.build.boot.security_patch", "Patch com.android.build.boot.fingerprint"]
        checkbox_values=[True, False]

        message = '''
#                   WARNING! WARNING! WARNING! WARNING!
**This is an experimental feature, do NOT proceed unless you understand what you're doing.**<br/>

**PixelFlasher** can create a downgrade patch by utilizing AVBTool to patch SPL value of `boot.img` from the downgrade firmware and match the current SPL value.\nThis would allow a downgrade, however even if downgrade is successful, the phone might not operate optimally or at all.<br/>

### How to get the Current SPL value
  - **Option 1:** If the device is already rooted, and root access is granted to adb, PixelFlasher can extract it from the device.
  - **Option 2:** Extract and select the `boot.img` file of the currently running firmware so that PixelFlasher can read the SPL value.
  - **Option 3:** Manually specify the SPL value. (Format: YYYY-MM-DD) Example: 2024-12-05.

### How to get the target `boot.img`
  - The target `boot.img` will be automatically selected from the currently processed and selected firmware image in PixelFlasher.

'''
        message += f"<pre>Rooted:                                   {device_is_rooted}\n"
        with contextlib.suppress(Exception):
            message += f"Current Target boot.security_patch:       {target_boot_info['com.android.build.boot.security_patch']}\n"
            device_spl = ''
            device_spl = device.get_prop('ro.build.version.security_patch')
            message += f"Device ro.build.version.security_patch:   {device_spl}\n"
        message += f"Recommended Patch option:                 {option_text}</pre>\n"
        clean_message = message.replace("<br/>", "").replace("</pre>", "").replace("<pre>", "")
        print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
        puml(":Dialog;\n", True)
        puml(f"note right\n{clean_message}\nend note\n")
        dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=buttons_text,
            default_button=option,
            disable_buttons=disabled_buttons,
            is_md=True,
            size=[915,670],
            checkbox_labels=checkboxes,
            checkbox_initial_values=checkbox_values,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()
        dlg.Destroy()
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
        puml(f":User Pressed {buttons_text[result - 1]};\n")
        current_spl = ''

        checkbox_values = get_dlg_checkbox_values()
        option = result
        hardware = ''
        # option 1 - Patch com.android.build.boot.security_patch
        if option == 1:
            # Device is rooted, extract boot.img from device
            partition = 'boot'
            slot = device.active_slot
            hardware = device.hardware
            if slot != '':
                partition = f"{partition}_{slot}"
            res, file_path = device.dump_partition(file_path='/data/local/tmp/current_boot.img', partition=partition)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to dump partition on the phone;\n}\n")
                return -1
            # pull the boot.img from the device
            res = device.pull_file('/data/local/tmp/current_boot.img', current_boot_img)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to pull boot.img from the phone;\n}\n")
                return -1

        # option 2 - Patch com.android.build.boot.fingerprint
        elif option == 2:
            with wx.FileDialog(self, "Select Boot Image", '', '', wildcard="All files (*.img)|*.img", style=wx.FD_OPEN) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled file push.")
                    return
                # copy to tmp folder
                print(f"Copying {fileDialog.GetPath()} to {current_boot_img}")
                shutil.copy(fileDialog.GetPath(), current_boot_img, follow_symlinks=True)

        # option 3 - Specify SPL value manually
        elif option == 3:
            if checkbox_values[1]:
                dlg = MessageBoxEx(
                    parent=None,
                    title=_("Warning"),
                    message=_("⚠️ WARNING: With Option 3, fingerprint can't be patched."),
                    button_texts=[_("OK")],
                    default_button=1,
                    disable_buttons=None,
                    is_md=False,
                    size=(800, 600),
                    checkbox_labels=None,
                    checkbox_initial_values=None,
                    disable_checkboxes=None,
                    vertical_checkboxes=False,
                    checkbox_labels2=None,
                    checkbox_initial_values2=None,
                    disable_checkboxes2=None,
                    radio_labels=None,
                    radio_initial_value=None,
                    disable_radios=None,
                    vertical_radios=False
                )
                dlg.CentreOnParent(wx.BOTH)
                dlg.ShowModal()
                dlg.Destroy()
            checkbox_values[1] = False
            dialog = wx.TextEntryDialog(None, "Enter the SPL value (YYYY-MM-DD):", "Enter SPL value", device_spl, style=wx.OK | wx.CANCEL)
            while True:
                if dialog.ShowModal() == wx.ID_OK:
                    current_spl = dialog.GetValue()
                    if current_spl == '':
                        continue
                    if not re.match(r'^\d{4}-\d{2}-\d{2}$', current_spl):
                        print(f"Invalid date format {current_spl}, please enter a valid date in the format YYYY-MM-DD")
                        dialog.SetValue('')
                        continue
                    break  # Valid input received
                else:
                    print("User cancelled.")
                    print("Aborting ...\n")
                    dialog.Destroy()
                    return
            dialog.Destroy()

        # option 4 - Cancel
        elif option == 4:
            puml("}\n")
            print("Aborting ...\n")
            return

        # Perform the patching
        start_1 = time.time()
        if current_spl == '':
            print(f"\n=== Getting AVB info for Current boot.img [{current_boot_img}] ...")
            current_boot_info = get_boot_image_info(current_boot_img)
            with contextlib.suppress(Exception):
                current_spl = current_boot_info['com.android.build.boot.security_patch']
            print(f"Current Security Patch: {current_spl}")

        # Compare the two boot image info objects and do validations to make sure the target is a downgrade and the current matches current OS version
        print(f"\nChecking if the target boot.img is a downgrade ...")
        target_spl = ''
        with contextlib.suppress(Exception):
            target_spl = target_boot_info['com.android.build.boot.security_patch']
        print(f"Target Security Patch: {target_spl}")
        if current_spl == '' or target_spl == '':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not determine the security patch levels.")
            puml("#red:Could not determine the security patch levels;\n")
            print("Aborting ...\n")
            return -1
        try:
            if target_spl >= current_spl and not checkbox_values[1]:
                print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?")
                dlg = MessageBoxEx(
                parent=None,
                title=_("Confirm"),
                message=_("WARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?"),
                button_texts=[_("Yes"), _("No")],
                default_button=2,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
                puml(f"note right\nDialog\n====\nWARNING: The target boot.img is not a downgrade.\nAre you sure want to continue?\nend note\n")
                result = dlg.ShowModal()
                dlg.Destroy()
                if result != wx.ID_YES:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled patching.")
                    puml("#pink:User cancelled patching;\n}\n")
                    return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while comparing the security patch levels.")
            puml("#red:Encountered an error while while comparing the security patch levels;\n")
            traceback.print_exc()
            return -1

        print("Proceeding with downgrade patching ...")
        if checkbox_values[1]:
            print(f"\n=== Patching fingerprint in Current boot.img [{current_boot_img}] ...")
            fingerprint = current_boot_info['com.android.build.boot.fingerprint']
        else:
            fingerprint = target_boot_info['com.android.build.boot.fingerprint']
        if checkbox_values[0]:
            security = current_spl
        else:
            security = target_boot_info['com.android.build.boot.security_patch']

        shutil.copy(target_boot_img, downgrade_file_path)
        add_hash_footer(boot_image_path=downgrade_file_path,
                    partition_size=target_boot_info['Image Size'],
                    partition_name=target_boot_info['Partition Name'],
                    salt=target_boot_info['Salt'],
                    rollback_index=target_boot_info['Rollback Index'],
                    algorithm=target_boot_info['Algorithm'],
                    hash_algorithm=target_boot_info['Hash Algorithm'],
                    prop_com_android_build_boot_os_version=target_boot_info['com.android.build.boot.os_version'],
                    prop_com_android_build_boot_fingerprint=fingerprint,
                    prop_com_android_build_boot_security_patch_level=security
                )

        print(f"\n=== Getting AVB info for Patched target boot.img [{target_boot_img}] ...")
        patched_boot_info = get_boot_image_info(downgrade_file_path)

        # ------------------------
        # add downgrade_boot to db
        # ------------------------
        # delete previous db records.
        boot_id = get_boot_id_by_file_path(downgrade_file_path)
        if boot_id and boot_id > 0:
            delete_package_boot_record(boot_id, boot.package_id)
            delete_boot_record(boot_id)

        # create BOOT db record
        boot_hash = sha1(downgrade_file_path)
        file_path = downgrade_file_path
        is_patched = 0
        magisk_version = current_spl
        # hardware = ''
        patch_method = 'downgrade'
        is_odin = 0
        is_stock_boot = 0
        is_init_boot = 0
        patch_source_sha1 = sha1(target_boot_img)
        boot_record_id = insert_boot_record(boot_hash, file_path, is_patched, magisk_version, hardware, patch_method, is_odin, is_stock_boot, is_init_boot, patch_source_sha1)
        if boot_record_id > 0:
            # create PACKAGE_BOOT db record
            package_boot_id = insert_package_boot_record(boot.package_id, boot_record_id)
            if not package_boot_id > 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not create a DB record for downgrade_boot.img")
                puml("#red:Could not create a DB record for downgrade_boot.img;\n")
                return -1
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not create a DB record for downgrade_boot.img")
            puml("#red:Could not create a DB record for downgrade_boot.img;\n")
            return -1

        end_1 = time.time()
        print(f"Downgrade Patch Creation time: {math.ceil(end_1 - start_1)} seconds")
        populate_boot_list(self)
        return 0

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while preparing a downgrade patch")
        puml("#red:Encountered an error while preparing a downgrade patch;\n")
        traceback.print_exc()


# ============================================================================
#                               Function avbtool_get_info (TODO)
# ============================================================================
def avbtool_get_info(self, boot_file_path):
    # perform avbtool info on the boot_file_path
    # convert to object and return object
    return


# ============================================================================
#                               Function kb_stats_ui
# ============================================================================
def kb_stats_ui(self):
    try:
        title = "KB Stats"
        buttons_text = ["Process KB Index", "Cancel"]
        checkboxes = ["Verbose", "List Unique Files", "List Valid Entries", "List Unmarked Entries ...", "Add Missing Files ...", "Check File Exists", "List Missing Files", "Remove Missing Entries from kb_index"]
        checkbox_initial_values = [False, False, True, True, True, True, True, True]
        message = _("**KB Stats Options**<br/>\n")
        dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=buttons_text,
            default_button=1,
            disable_buttons=None,
            is_md=True,
            size=[400,40],
            checkbox_labels=checkboxes,
            checkbox_initial_values=checkbox_initial_values,
            disable_checkboxes=None,
            vertical_checkboxes=True,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()
        dlg.Destroy()
        if result == 2:
            print("Aborting ...\n")
            return
        print("Selected options:")
        checkbox_values = get_dlg_checkbox_values()
        if checkbox_values is not None:
            for i in range(len(checkboxes)):
                print(f"{checkboxes[i]}: {bool(checkbox_values[i])}")
            print("\n")
            target_path = ""
            if checkbox_values[3] or checkbox_values[4]:
                if self.config.unmarked_entries_path and os.path.exists(self.config.unmarked_entries_path):
                    target_path = self.config.unmarked_entries_path

                with wx.DirDialog(self, "Select reference marking folder", defaultPath=target_path, style=wx.DD_DEFAULT_STYLE) as dirDialog:
                    if dirDialog.ShowModal() == wx.ID_OK:
                        target_path = dirDialog.GetPath()
                        print(f"Selected reference folder: {target_path}")
                        self.config.unmarked_entries_path = target_path
                        self.config.save(get_config_file_path())
                    else:
                        print("Aborting ...\n")
                        return
            kb_stats(verbose=checkbox_values[0], list_unique_files=checkbox_values[1], list_valid_entries=checkbox_values[2], list_non_common_entries=checkbox_values[3], add_missing_files=checkbox_values[4], target_path=target_path, check_file_existence=checkbox_values[5], list_non_existent=checkbox_values[6], remove_non_existent=checkbox_values[7])
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing kb_stats_ui")
        puml("#red:Encountered an error while processing kb_stats_ui;\n")
        traceback.print_exc()


# ============================================================================
#                               Function drive_magisk (TODO)
# ============================================================================
def drive_magisk(self, boot_file_name):
    print("UI Automator is broken, until Google fixes it, this feature is disabled.")
    return -1
    # start = time.time()
    # print("")
    # print("==============================================================================")
    # print(f" {datetime.now():%Y-%m-%d %H:%M:%S} PixelFlasher {VERSION}              Driving Magisk ")
    # print("==============================================================================")

    # device = get_phone(True)
    # config_path = get_config_path()

    # if not device:
    #     print("\nNo device is selected!\n Aborting ...\n")
    #     return -1

    # # Wake up the touch screen
    # print("Waking up the touch screen")
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input keyevent 26"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # if not device.is_display_unlocked():
    #     title = "Display is Locked!"
    #     message =  "ERROR: Your phone display is Locked.\n\n"
    #     message += "Make sure you unlock your display\n"
    #     message += "And set the display timeout to at least 1 minute.\n\n"
    #     message += "After doing so, Click OK to accept and continue.\n"
    #     message += "or Hit CANCEL to abort."
    #     print(f"\n*** Dialog ***\n{message}\n______________\n")
    #     dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
    #     result = dlg.ShowModal()
    #     if result == wx.ID_OK:
    #         print("User pressed ok.")
    #         if not device.is_display_unlocked():
    #             print("ERROR: The device display is still Locked!\nAborting ...\n")
    #             return -1
    #     else:
    #         print("User pressed cancel.")
    #         print("Aborting ...\n")
    #         return -1

    # # First stop magisk in case it is running
    # device.stop_magisk()

    # # Launch Magisk
    # device.perform_package_action(get_magisk_package(), 'launch', False)

    # res = device.ui_action(f"{self.config.phone_path}/view1.xml", os.path.join(config_path, 'tmp', 'view1.xml'), "Install")
    # if res == -1:
    #     return -1

    # res = device.ui_action(f"{self.config.phone_path}/view2.xml", os.path.join(config_path, 'tmp', 'view2.xml'), "Select and Patch a File")
    # if res == -1:
    #     return -1

    # res = device.ui_action(f"{self.config.phone_path}/view3.xml", os.path.join(config_path, 'tmp', 'view3.xml'), "Search this phone")
    # if res == -1:
    #     return -1

    # res = device.ui_action(f"{self.config.phone_path}/view4.xml", os.path.join(config_path, 'tmp', 'view4.xml'), "LET'S GO")
    # if res == -1:
    #     return -1

    # res = device.ui_action(f"{self.config.phone_path}/view5.xml", os.path.join(config_path, 'tmp', 'view5.xml'), "{MAGISK_PKG_NAME}:id/action_save")
    # if res == -1:
    #     return -1

    # # TODO
    # return -1
    # # # Get uiautomator dump of view1
    # # the_view = "view1.xml"
    # # dump_file = f"{self.config.phone_path}/{the_view}"
    # # res = device.uiautomator_dump(dump_file)
    # # if res == -1:
    # #     print("Aborting ...\n")
    # #     puml("#red:Failed to uiautomator dump;\n}\n")
    # #     return -1

    # # # Pull view1.xml
    # # view_file = os.path.join(config_path, 'tmp', the_view)
    # # print(f"Pulling {dump_file} from the phone to: {view_file} ...")
    # # res = device.pull_file(dump_file, view_file)
    # # if res != 0:
    # #     print("Aborting ...\n")
    # #     puml("#red:Failed to pull uiautomator dump from the phone;\n}\n")
    # #     return

    # # # get view1 bounds / click coordinates
    # # coords = get_ui_coordinates(view_file, "Install")

    # # # Check for Display being locked again
    # # if not device.is_display_unlocked():
    # #     print("ERROR: The device display is Locked!\nAborting ...\n")
    # #     return -1

    # # # # Click on coordinates of `Install`
    # # # # For Pixel 6 this would be: adb shell input tap 830 417
    # # # theCmd = f"\"{get_adb()}\" -s {device.id} shell input tap {coords}"
    # # # debug(theCmd)
    # # # res = run_shell(theCmd)

    # # # Click on coordinates of `Install`
    # # # For Pixel 6 this would be: adb shell input tap 830 417
    # # res = device.click(coords)
    # # if res == -1:
    # #     print("Aborting ...\n")
    # #     puml("#red:Failed to click;\n}\n")
    # #     return -1

    # # # Sleep 2 seconds
    # # print("Sleeping 2 seconds to make sure the view is loaded ...")
    # # time.sleep(2)

    # # # Check for Display being locked again
    # # if not device.is_display_unlocked():
    # #     print("ERROR: The device display is Locked!\nAborting ...\n")
    # #     return -1

    # # Get uiautomator dump of view2
    # dump_file = f"{self.config.phone_path}/view2.xml"
    # res = device.uiautomator_dump(dump_file)
    # if res == -1:
    #     print("Aborting ...\n")
    #     puml("#red:Failed to uiautomator dump;\n}\n")
    #     return -1

    # # Pull view2.xml
    # view2 = os.path.join(config_path, 'tmp', 'view2.xml')
    # print(f"Pulling {dump_file} from the phone to: {view2} ...")
    # res = device.pull_file(dump_file, view2)
    # if res != 0:
    #     print("Aborting ...\n")
    #     puml("#red:Failed to pull uiautomator dump from the phone;\n}\n")
    #     return

    # # Pull view2.xml
    # view2 = os.path.join(config_path, 'tmp', 'view2.xml')
    # print(f"Pulling {self.config.phone_path}/view2.xml from the phone ...")
    # theCmd = f"\"{get_adb()}\" -s {device.id} pull {self.config.phone_path}/view2.xml \"{view2}\""
    # debug(theCmd)
    # res = run_shell(theCmd)
    # # expect ret 0
    # if res.returncode == 1:
    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to pull {view2} from phone.")
    #     print(res.stderr)
    #     print("Aborting ...\n")
    #     return -1

    # # get view2 bounds / click coordinates
    # coords = get_ui_coordinates(view2, "Select and Patch a File")

    # # Check for Display being locked again
    # if not device.is_display_unlocked():
    #     print("ERROR: The device display is Locked!\nAborting ...\n")
    #     return -1

    # # Click on coordinates of `Select and Patch a File`
    # # For Pixel 6 this would be: adb shell input tap 540 555
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input tap {coords}"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # # Sleep 2 seconds
    # print("Sleeping 2 seconds to make sure the view is loaded ...")
    # time.sleep(2)

    # # Check for Display being locked again
    # if not device.is_display_unlocked():
    #     print("ERROR: The device display is Locked!\nAborting ...\n")
    #     return -1

    # # Get uiautomator dump of view3
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell uiautomator dump {self.config.phone_path}/view3.xml"
    # debug(theCmd)
    # res = run_shell(theCmd)
    # if res.returncode != 0:
    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: uiautomator dump failed.")
    #     print(res.stderr)
    #     return -1

    # # Pull view3.xml
    # view3 = os.path.join(config_path, 'tmp', 'view3.xml')
    # print(f"Pulling {self.config.phone_path}/view3.xml from the phone ...")
    # theCmd = f"\"{get_adb()}\" -s {device.id} pull {self.config.phone_path}/view3.xml \"{view3}\""
    # debug(theCmd)
    # res = run_shell(theCmd)
    # # expect ret 0
    # if res.returncode == 1:
    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to pull {view3} from phone.")
    #     print(res.stderr)
    #     print("Aborting ...\n")
    #     return -1

    # # get view3 bounds / click coordinates
    # coords = get_ui_coordinates(view3, "Search this phone")

    # # Check for Display being locked again
    # if not device.is_display_unlocked():
    #     print("ERROR: The device display is Locked!\nAborting ...\n")
    #     return -1

    # # Click on coordinates of `Search this phone`
    # # For Pixel 6 this would be: adb shell input tap 574 210
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input tap {coords}"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # # Sleep 2 seconds
    # print("Sleeping 2 seconds to make sure the view is loaded ...")
    # time.sleep(2)

    # # Type the boot_file_name to search for it
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input text {boot_file_name}"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # # Sleep 1 seconds
    # print("Sleeping 1 seconds to make sure the view is loaded ...")
    # time.sleep(1)

    # # Hit Enter to search
    # print("Hitting Enter to search")
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input keyevent 66"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # # Sleep 1 seconds
    # print("Sleeping 1 seconds to make sure the view is loaded ...")
    # time.sleep(1)

    # # Hit Enter to Select it
    # print("Hitting Enter to select")
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input keyevent 66"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # # Sleep 2 seconds
    # print("Sleeping 2 seconds to make sure the view is loaded ...")
    # time.sleep(2)

    # # Check for Display being locked again
    # if not device.is_display_unlocked():
    #     print("ERROR: The device display is Locked!\nAborting ...\n")
    #     return -1

    # # Get uiautomator dump of view4
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell uiautomator dump {self.config.phone_path}/view4.xml"
    # debug(theCmd)
    # res = run_shell(theCmd)
    # if res.returncode != 0:
    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: uiautomator dump failed.")
    #     print(res.stderr)
    #     return -1

    # # Pull view4.xml
    # view4 = os.path.join(config_path, 'tmp', 'view4.xml')
    # print(f"Pulling {self.config.phone_path}/view4.xml from the phone ...")
    # theCmd = f"\"{get_adb()}\" -s {device.id} pull {self.config.phone_path}/view4.xml \"{view4}\""
    # debug(theCmd)
    # res = run_shell(theCmd)
    # # expect ret 0
    # if res.returncode == 1:
    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to pull {view4} from phone.")
    #     print(res.stderr)
    #     print("Aborting ...\n")
    #     return -1

    # # get view4 bounds / click coordinates
    # coords = get_ui_coordinate(view4, "LET'S GO")

    # # Check for Display being locked again
    # if not device.is_display_unlocked():
    #     print("ERROR: The device display is Locked!\nAborting ...\n")
    #     return -1

    # # Click on coordinates of `LET'S GO`
    # # For Pixel 6 this would be: adb shell input tap 839 417
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input tap {coords}"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # # Sleep 2 seconds
    # print("Sleeping 2 seconds to make sure the view is loaded ...")
    # time.sleep(2)

    # # Sleep 10 seconds
    # print("Sleeping 10 seconds to make sure Patching is completed ...")
    # time.sleep(10)

    # # Check for Display being locked again
    # if not device.is_display_unlocked():
    #     print("ERROR: The device display is Locked!\nAborting ...\n")
    #     return -1

    # # Get uiautomator dump of view5
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell uiautomator dump {self.config.phone_path}/view5.xml"
    # debug(theCmd)
    # res = run_shell(theCmd)
    # if res.returncode != 0:
    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: uiautomator dump failed.")
    #     print(res.stderr)
    #     return -1

    # # Pull view5.xml
    # view5 = os.path.join(config_path, 'tmp', 'view5.xml')
    # print(f"Pulling {self.config.phone_path}/view5.xml from the phone ...")
    # theCmd = f"\"{get_adb()}\" -s {device.id} pull {self.config.phone_path}/view5.xml \"{view5}\""
    # debug(theCmd)
    # res = run_shell(theCmd)
    # # expect ret 0
    # if res.returncode == 1:
    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to pull {view5} from phone.")
    #     print(res.stderr)
    #     print("Aborting ...\n")
    #     return -1

    # # get view5 bounds / click coordinates (Save button)
    # coords = get_ui_coordinates(view5, f"{MAGISK_PKG_NAME}:id/action_save")

    # # Check for Display being locked again
    # if not device.is_display_unlocked():
    #     print("ERROR: The device display is Locked!\nAborting ...\n")
    #     return -1

    # # Click on coordinates of `{MAGISK_PKG_NAME}:id/action_save`
    # # For Pixel 6 this would be: adb shell input tap 1010 198
    # theCmd = f"\"{get_adb()}\" -s {device.id} shell input tap {coords}"
    # debug(theCmd)
    # res = run_shell(theCmd)

    # # get view5 bounds / click coordinates (All Done)
    # coords = None
    # coords = get_ui_coordinates(view5, "- All done!")
    # if coords:
    #     print("\nIt looks like Patching was successful.")
    # else:
    #     print("\nIt looks like Patching was not successful.")

    # end = time.time()
    # print(f"Magisk Version: {device.magisk_version}")
    # print(f"Driven Patch time: {math.ceil(end - start)} seconds")
    # print("------------------------------------------------------------------------------\n")


# ============================================================================
#                               Function manual_magisk
# ============================================================================
def manual_magisk(self, boot_file_name):
    try:
        start = time.time()
        print("")
        print("==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} PixelFlasher {VERSION}              Manual Patching ")
        print("==============================================================================")

        device = get_phone(True)

        if not device.is_display_unlocked():
            title = _("Display is Locked!")
            message_en =  "ERROR: Your phone display is Locked.\n\n"
            message_en += "Make sure you unlock your display\n"
            message_en += "And set the display timeout to at least 1 minute.\n\n"
            message_en += "After doing so, Click OK to accept and continue.\n"
            message_en += "or Hit CANCEL to abort."
            message =  _("ERROR: Your phone display is Locked.\n\n")
            message += _("Make sure you unlock your display\n")
            message += _("And set the display timeout to at least 1 minute.\n\n")
            message += _("After doing so, Click OK to accept and continue.\n")
            message += _("or Hit CANCEL to abort.")
            print(f"\n*** Dialog ***\n{message_en}\n______________\n")
            dlg = MessageBoxEx(
                parent=None,
                title=title,
                message=message,
                button_texts=[_("OK"), _("Cancel")],
                default_button=1,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_OK:
                print("User pressed ok.")
                if not device.is_display_unlocked():
                    print("ERROR: The device display is still Locked!\nAborting ...\n")
                    return -1
            else:
                print("User pressed cancel.")
                print("Aborting ...\n")
                return -1

        # First stop magisk in case it is running
        device.stop_magisk()

        # Launch Magisk
        device.perform_package_action(self.config.magisk, 'launch', False)

        # Message Dialog Here to Patch Manually
        title = _("Manual Patching")
        buttons_text = [_("Done creating the patch, continue"), _("Cancel")]
        message = "## Magisk should now be running on your phone\n"
        message += "\n"
        message += "_If it is not, you  can try starting in manually._\n"
        message += "\n"
        message += "Please follow these steps in Magisk.\n"
        message += "\n"
        message += "- Click on **Install** or **Upgrade** in the section under **Magisk** block (Not App)\n"
        message += "- Click on **Select and patch a file**\n"
        message += "- Select `%s` in `%s` \n" % (boot_file_name, self.config.phone_path)
        message += "- Then hit **Let's go**\n"
        message += "\n"
        message += "When done creating the patch in Magisk <br/>\n"
        message += "Click on **Done creating the patch, continue** button <br/>\n"
        message += "or hit the **Cancel** button to abort.\n"

        dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=buttons_text,
            default_button=1,
            disable_buttons=[],
            is_md=True,
            size=[800,400],
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()
        dlg.Destroy()
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
        if result == 2:
            print("Aborting ...")
            return -1
        # find the newly created file and return
        theCmd = f"\"{get_adb()}\" -s {device.id} shell \"ls -t {self.config.phone_path}/magisk_patched* | head -1\""
        res = run_shell(theCmd)
        if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0 and res.stderr == '':
            return os.path.basename(res.stdout.strip())
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {res.stdout}\n{res.stderr}\n")
        return -1
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while running manual Magisk")
        puml("#red:Encountered an error while running manual Magisk;\n")
        traceback.print_exc()

# ============================================
#        Function is_device_unlocked
# ============================================
def is_device_unlocked(self, device):
    # return values:
    # -1: Device not detected
    #  0: Bootloader is locked
    #  1: Bootloader is unlocked
    print("Checking if the bootloader is unlocked ...")
    if not device:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device is not detected.")
        return -1
    device_id = device.id
    if not (device.get_bl_status() == 'unlocked' or check_for_unlocked(device_id)):
        print("Device does not appear to be unlocked. Reloading it just in case ...")
        self.refresh_device(device_id)
        device = get_phone()
        if device is None:
            # sleep 5 seconds and try again for good measure
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to detect the device.\n  Retrying in 5 seconds ...")
            time.sleep(5)
            self.refresh_device(device_id)
            device = get_phone()
            if device is None:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Still unable to detect the device.")
                self.clear_device_selection()
                return -1
        print("Checking if the bootloader is unlocked (2nd attempt) ...")
        if not (device.get_bl_status() == 'unlocked' or check_for_unlocked(device_id)):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Bootloader is locked.")
            return 0
        print("Bootloader is unlocked:")
    return 1

# ============================================================================
#                               Function message_after_flashing
# ============================================================================
def message_after_flashing():
    # Inform the user that we're done flashing.
    print("\n\n\n===================================================================")
    print("  If you just rooted or changed rooting solution,")
    print("  please launch the root app on the device to complete the process.")
    print("  Afterwards you would need to scan for the device")
    print("  to see the updated device information.")
    print("\n")
    print("  Please be patient and wait for the device to fully boot.")
    print("  If you had selected to wipe data, you will have to set up the")
    print("  device again as it is now like a brand new device.")
    print("===================================================================\n")
    return 0

# ============================================================================
#                               Function get_all_dialog_values
# ============================================================================
def get_all_dialog_values(dlg):
    # Get all dialog return values including checkboxes, radio buttons, and button selection
    # dlg has to be a MessageBoxEx instance
    dialog_values = {
        'button': None,
        'checkboxes': None,
        'checkboxes2': None,
        'radio': None
    }

    if hasattr(dlg, 'return_value') and dlg.return_value:
        dialog_values.update(dlg.return_value)

    return dialog_values

# ============================================================================
#                               Function kernel_flavors
# ============================================================================
def kernel_flavors(self, default_button, radio_initial_value, kernel_recommendation, checkbox_initial_values=None):
    title = "Select the kernel flavor"
    button_texts = ["KernelSU", "KernelSU-Next", "WildKernels", "ShirkNeko", "MiRinFork", "Manual", "Cancel"]
    if default_button < 1 or default_button > len(button_texts):
        default_button = 1
    button_texts[default_button -1] += _(" (Recommended)")
    radio_labels=[_("Latest Release"), _("Latest Pre-Release"), _("Latest Release or Pre-Release")]
    checkbox_labels=[_("Let me choose the kernel version from a matching list"), _("Show all assets including non-matching ones"), _("Search older releases if asset not found in latest")]
    if not checkbox_initial_values:
        checkbox_initial_values=[False, False]

    message = '''
# Available kernel flavors<br/>
  - **KernelSU:** Sourced from `tiann/KernelSU` repository and recommended for use with `KernelSU`.
  - **KernelSU-Next:** Sourced from `KernelSU-Next/KernelSU-Next` repository and recommended for use with `KernelSU-Next`.
  - **WildKernels:** Sourced from `WildKernels/GKI_KernelSU_SUSFS` repository and recommended for use with `WildKSU`.
  - **ShirkNeko:** Sourced from `ShirkNeko/GKI_KernelSU_SUSFS` repository and recommended for use with SukiSU.
  - **MiRinFork:** Sourced from `MiRinFork/GKI_SukiSU_SUSFS` repository and recommended for use with SukiSU.
  - **Manual:** User provides the kernel (Not recommended for beginers).

## Select Option
  - **Latest Release:** Picks the latest stable release of the selected kernel flavor.
  - **Latest Pre-Release:** Picks the latest pre-release of the selected kernel flavor.
  - **Latest Release or Pre-Release:** Picks the latest available release, whether stable or pre-release.

Depending on the selected rooting app option,
PixelFlasher will offer available choices and recommend a suitable kernel flavor.<br/>
However you're free to choose the kernel of your choice.
'''

    message += f"<pre>Recommended kernel flavor:      {kernel_recommendation}</pre>\n"
    clean_message = message.replace("<br/>", "").replace("</pre>", "").replace("<pre>", "")
    print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
    puml(":Dialog;\n", True)
    puml(f"note right\n{clean_message}\nend note\n")
    dlg = MessageBoxEx(
        parent=self,
        title=title,
        message=message,
        button_texts=button_texts,
        default_button=default_button,
        disable_buttons=None,
        is_md=True,
        size=[930,640],
        checkbox_labels=checkbox_labels,
        checkbox_initial_values=checkbox_initial_values,
        disable_checkboxes=None,
        vertical_checkboxes=False,
        checkbox_labels2=None,
        checkbox_initial_values2=None,
        disable_checkboxes2=None,
        radio_labels=radio_labels,
        radio_initial_value=radio_initial_value,
        disable_radios=None,
        vertical_radios=False
    )
    dlg.CentreOnParent(wx.BOTH)
    result = dlg.ShowModal()

    # Get all dialog return values
    dialog_values = get_all_dialog_values(dlg)

    dlg.Destroy()
    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {button_texts[result -1]}")

    # Extract values from dialog_values
    selected_radio_index = dialog_values.get('radio')
    checkbox_values = dialog_values.get('checkboxes')

    if selected_radio_index is not None:
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Selected Radio Option: {radio_labels[selected_radio_index]}")
    if checkbox_values:
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Selected Checkboxes: {checkbox_values}")
    puml(f":User Pressed {button_texts[result - 1]};\n")

    # Return both the button selection and all dialog values
    return {
        'button': result,
        'button_text': button_texts[result - 1] if result <= len(button_texts) else 'Unknown',
        'radio_selection': selected_radio_index,
        'radio_text': radio_labels[selected_radio_index] if selected_radio_index is not None else None,
        'checkbox_values': checkbox_values,
        'checkbox_values2': dialog_values.get('checkboxes2'),
        'dialog_values': dialog_values
    }

# ============================================================================
#                               Function patch_boot_img
# ============================================================================
def patch_boot_img(self, patch_flavor = 'Magisk'):
    # ==========================================
    # Sub Function  ensure_root_app_installed
    # ==========================================
    def ensure_root_app_installed(app_type='KernelSU'):
        config_path = get_config_path()

        if app_type == 'KernelSU-Next':
            repo_user = 'rifsxd'
            repo_name = 'KernelSU-Next'
            pattern = r'^KernelSU_Next(?!.*spoofed).*\.apk$'
            path_getter = lambda: device.ksu_next_path
            app_name = "KernelSU-Next"
            package_name = KSU_NEXT_PKG_NAME
        elif app_type == 'APatch':
            repo_user = 'bmax121'
            repo_name = 'APatch'
            pattern = r'^APatch_.*\.apk$'
            path_getter = lambda: device.apatch_path
            app_name = "APatch"
            package_name = APATCH_PKG_NAME
        elif app_type == 'SukiSU':
            repo_user = 'SukiSU-Ultra'
            repo_name = 'SukiSU-Ultra'
            pattern = r'^SukiSU_(?!.*spoofed).*\.apk$'
            path_getter = lambda: device.sukisu_path
            app_name = "SukiSU"
            package_name = SUKISU_PKG_NAME
        elif app_type == 'Wild_KSU':
            repo_user = 'WildKernels'
            repo_name = 'Wild_KSU'
            pattern = r'^Wild_KSU(?!.*spoofed).*\.apk$'
            path_getter = lambda: device.wild_ksu_path
            app_name = "Wild_KSU"
            package_name = WILD_KSU_PKG_NAME
        elif app_type == "KernelSU-Legacy":
            repo_user = 'rsuntk'
            repo_name = 'KernelSU'
            pattern = r'^KernelSU(?!.*spoofed).*\.apk$'
            path_getter = lambda: device.ksu_path
            app_name = "KernelSU"
            package_name = KERNEL_SU_PKG_NAME
        else:  # KernelSU
            repo_user = 'tiann'
            repo_name = 'KernelSU'
            pattern = r'^KernelSU(?!.*spoofed).*\.apk$'
            path_getter = lambda: device.ksu_path
            app_name = "KernelSU"
            package_name = KERNEL_SU_PKG_NAME

        # Check if app is already installed
        app_path = path_getter()
        if app_path:
            version, version_code = device.get_app_version(package_name)
            return True, app_path, None, version, version_code

        # App not installed, let's check if the user has configured spoofed apps
        spoofed_apps_list = []
        if self.config.spoofed_apps:
            # We need appt2 to get the package names
            try:
                debug("Pushing aapt2 to device...")
                res = device.push_aapt2()
                if res == 0:
                    debug("aapt2 pushed successfully")
                else:
                    print("❌ Failed to push aapt2")
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: pushing aapt2")

            package_names = [pkg.strip() for pkg in self.config.spoofed_apps.split(',') if pkg.strip()]
            for package_name in package_names:
                app_info = device.get_package_info(package_name)
                if app_info is not None and app_info:
                    app_label, icon = device.get_package_label(package_name, app_info.get('sourceDir', None))

                    spoofed_apps_list.append({
                        'name': app_label,
                        'path': app_info.get('sourceDir', ''),
                        'package': package_name,
                        'installed': True
                    })
                else:
                    # Package not installed, but add to the list as disabled option
                    spoofed_apps_list.append({
                        'name': 'Missing App',
                        'path': '',
                        'package': package_name,
                        'installed': False
                    })

        # Present dialog for app selection
        title = f"Select {app_name} Application"
        message = f"**{app_name} does not appear to be installed with the official package name.**<br/>\n\n"
        message += f"You can choose to create a patch by pressing the button:<br/><br/>\n\n"
        message += f"- **Use the selected option:** Selecting an installed spoofed app.<br/>\n"
        message += f"  _If you have configured spoofed app package names in PixelFlasher settings._<br/>\n"
        message += f"- **Install latest:** Let PixelFlasher install the official {app_name} from the web.<br/>\n"
        message += f"- **Manual:** Provide your own {app_name} APK file manually.<br/>\n\n"

        button_texts = [
            _("Use the selected option"),
            _("Install latest"),
            _("Manual, let me provide my own apk"),
            _("Cancel")
        ]

        radio_labels = []
        disable_radios = []
        disable_buttons = [1]
        for i, app_info in enumerate(spoofed_apps_list):
            if app_info['installed']:
                radio_labels.append(f"{app_info['name']} ({app_info['package']}) - Installed")
                disable_buttons = []
            else:
                radio_labels.append(f"{app_info['name']} ({app_info['package']}) - Not Installed")
                disable_radios.append(i + 1)

        # Find first installed spoofed app as default selection (might not be the best match)
        radio_initial_value = 0
        for i, app_info in enumerate(spoofed_apps_list):
            if app_info['installed']:
                radio_initial_value = i
                break

        clean_message = message.replace("<br/>", "")
        print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
        puml(f"note right\nDialog\n====\n{clean_message}\nend note\n")

        dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=button_texts,
            default_button=1,
            disable_buttons=disable_buttons,
            is_md=True,
            size=[800, 300],
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=radio_labels,
            radio_initial_value=radio_initial_value,
            disable_radios=disable_radios,
            vertical_radios=True
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()
        dialog_values = get_all_dialog_values(dlg)
        selected_radio_index = dialog_values.get('radio')
        dlg.Destroy()

        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {button_texts[result - 1]}")

        # Use the selected spoofed app
        if result == 1:
            if selected_radio_index is not None and selected_radio_index < len(spoofed_apps_list):
                selected_app = spoofed_apps_list[selected_radio_index]
                if selected_app['installed']:
                    print(f"Using spoofed app: {selected_app['name']} [{selected_app['package']}]")
                    version, version_code = device.get_app_version(selected_app['package'])
                    return True, selected_app['path'], None, version, version_code
                else:
                    return False, None, f"Selected app {selected_app['name']} is not installed", None, None
            else:
                return False, None, "Invalid selection", None, None

        # Install latest official app
        elif result == 2:
            print(f"Getting the latest {app_name} to install ...")
            try:
                release = get_gh_release_object(user=repo_user, repo=repo_name, include_prerelease=False)
                if not release:
                    return False, None, f"Could not find {app_name} release", None, None

                apk_file = gh_asset_utility(release_object=release, asset_name_pattern=pattern, download=True)
                if not apk_file:
                    return False, None, f"Could not download {app_name} APK", None, None

                app = os.path.join(config_path, 'tmp', apk_file)
                res = device.install_apk(app)
                if res != 0:
                    return False, None, f"Failed to install {app_name}", None, None

                # Check if installation was successful
                app_path = path_getter()
                if not app_path:
                    return False, None, f"Failed to find {app_name} after installation", None, None
                version, version_code = device.get_app_version(package_name)
                return True, app_path, None, version, version_code

            except Exception as e:
                return False, None, f"Exception during {app_name} installation: {str(e)}", None, None

        # Manual APK selection
        elif result == 3:
            with wx.FileDialog(self, f"Select {app_name} Application", '', '', wildcard="APK files (*.apk)|*.apk", style=wx.FD_OPEN) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled APK selection.")
                    return False, None, "User cancelled APK selection", None, None
                selected_apk = fileDialog.GetPath()
                print(f"User selected APK: {selected_apk}")
                try:
                    res = device.install_apk(selected_apk)
                    if res != 0:
                        return False, None, f"Failed to install {app_name}", None, None

                    # Extract the binary xml AndroidManifest from the selected APK
                    tmp_AndroidManifest = os.path.join(config_path, 'tmp', 'AndroidManifest.xml')
                    if os.path.exists(tmp_AndroidManifest):
                        os.remove(tmp_AndroidManifest)
                    with zipfile.ZipFile(selected_apk, 'r') as zip_ref:
                        zip_ref.extract('AndroidManifest.xml', os.path.join(config_path, 'tmp'))
                    if os.path.exists(tmp_AndroidManifest):
                        axml2xml(tmp_AndroidManifest, tmp_AndroidManifest + '.xml.txt')
                        # parse the xml to get the package name
                        tree = ET.parse(tmp_AndroidManifest + '.xml.txt')
                        root = tree.getroot()
                        package_name = root.attrib.get('package', '')
                        if package_name:
                            # Check if installation was successful
                            app_info = device.get_package_info(package_name)
                            app_path = app_info.get('sourceDir', '')
                            if not app_path:
                                return False, None, f"Failed to find {app_name} after installation", None, None
                            # Update spoofed apps list in config
                            spoofed_apps = self.config.spoofed_apps.split(',') if self.config.spoofed_apps else []
                            if package_name not in [pkg.strip() for pkg in spoofed_apps]:
                                spoofed_apps.append(package_name)
                                self.config.spoofed_apps = ','.join(spoofed_apps)
                                self.config.save(get_config_file_path())
                            version, version_code = device.get_app_version(package_name)
                            return True, app_path, None, version, version_code
                    else:
                        # Push APK to phone
                        res = device.push_file(selected_apk, "/data/local/tmp/user_provided_app.apk")
                        if res != 0:
                            return False, None, "Failed to transfer user-provided APK to phone", None, None
                        return True, "/data/local/tmp/user_provided_app.apk", None, None, None

                except Exception as e:
                    return False, None, f"Exception during {app_name} installation: {str(e)}", None, None

        # Cancel
        else:
            return False, None, "User cancelled", None, None

    # ==========================================
    # Sub Function       patch_script
    # ==========================================
    def patch_magisk_script(patch_method):
        print("Creating pf_patch.sh script ...")
        if self.config.use_busybox_shell and patch_method == "rooted":
            # busybox_shell_cmd = "export ASH_STANDALONE=1; /data/adb/magisk/busybox ash"
            busybox_shell_cmd = "/data/adb/magisk/busybox ash"
        else:
            busybox_shell_cmd = ""
        if patch_method == "rooted":
            patch_label = "rooted Magisk"
            script_path = "/data/adb/magisk/pf_patch.sh"
            exec_cmd = f"\"{get_adb()}\" -s {device.id} shell \"su -c \'cd /data/adb/magisk; {busybox_shell_cmd} ./pf_patch.sh\'\""
            with_version = device.magisk_version
            with_version_code = device.magisk_version_code
            perform_as_root = True
        elif patch_method == "app":
            patch_label = "Magisk App"
            path_to_busybox = os.path.join(get_bundle_dir(),'bin', f"busybox_{device.architecture}")
            script_path = "/data/local/tmp/pf_patch.sh"
            if is_rooted:
                exec_cmd = f"\"{get_adb()}\" -s {device.id} shell \"su -c \'{busybox_shell_cmd} /data/local/tmp/pf_patch.sh\'\""
            else:
                exec_cmd = f"\"{get_adb()}\" -s {device.id} shell {busybox_shell_cmd} /data/local/tmp/pf_patch.sh"
            with_version = device.get_uncached_magisk_app_version()
            with_version_code = device.magisk_app_version_code
            perform_as_root = False
        elif patch_method == "other":
            patch_label = "Other Magisk App"
            path_to_busybox = os.path.join(get_bundle_dir(),'bin', f"busybox_{device.architecture}")
            script_path = "/data/local/tmp/pf_patch.sh"
            exec_cmd = f"\"{get_adb()}\" -s {device.id} shell {busybox_shell_cmd} /data/local/tmp/pf_patch.sh"
            perform_as_root = False
            # select the Magisk to use for patching
            with wx.FileDialog(self, "Select Magisk Application", '', '', wildcard="Images (*.apk)|*.apk", style=wx.FD_OPEN) as fileDialog:
                puml(":Other Magisk Application for patch use ;\n")
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("⚠️ User cancelled.")
                    puml("#pink:User Cancelled;\n")
                    return -1
                other_magisk = fileDialog.GetPath()
                print(f"\nSelected {other_magisk} for patch use.")
                puml(f"note right\nSelected {other_magisk} for patch use.\nend note\n")
            # Transfer user Magisk app to the phone
            res = device.push_file(f"\"{other_magisk}\"", f"{self.config.phone_path}/Magisk-Uploaded.apk", with_su=perform_as_root)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to transfer Magisk Application to the phone;\n")
                return -1
            with_version = "Other"
            with_version_code = "Other"
        else:
            print(f"ERROR: Unsupported patch method: {patch_method}")
            puml("#red:Unsupported patch method;\n")
            return -1

        set_patched_with(with_version)
        puml(f":Patching with {patch_label}: {with_version};\n", True)

        dest = os.path.join(config_path, 'tmp', 'pf_patch.sh')
        with open(dest.strip(), "w", encoding="ISO-8859-1", errors="replace", newline='\n') as f:
            data = " #!/system/bin/sh\n"
            data += " ##############################################################################\n"
            data += f" # PixelFlasher {VERSION} patch script using {patch_label} {with_version}\n"
            data += " ##############################################################################\n"
            data += f"MAGISK_VERSION=\"{with_version_code}\"\n"
            data += f"STOCK_SHA1={stock_sha1}\n"
            data += f"RECOVERYMODE={recovery}\n"
            if patch_method == "other":
                magisk_path = f"{self.config.phone_path}/Magisk-Uploaded.apk"
            else:
                magisk_path = device.magisk_path
            data += f"MAGISK_PATH={magisk_path}\n"
            data += f"if [ -f\"/data/local/tmp/pf_patch.log\" ]; then\n"
            data += f"    rm -f \"/data/local/tmp/pf_patch.log\"\n"
            data += "fi\n"

            if patch_method in ["app", "other"]:
                data += f"ARCH={device.architecture}\n"
                data += f"cp {magisk_path} /data/local/tmp/pf.zip\n"
                data += "cd /data/local/tmp\n"
                data += "rm -rf pf || { echo 'ERROR: Failed to remove directory pf'; exit 1; }\n"
                data += "mkdir pf || { echo 'ERROR: Failed to create directory pf'; exit 1; }\n"
                data += "cd pf\n"
                data += "../busybox unzip -o ../pf.zip\n"
                data += "cd assets\n"
                data += "for FILE in ../lib/$ARCH/lib*.so; do\n"
                data += r"    NEWNAME=$(echo $FILE | toybox sed -En 's/.*\/lib(.*)\.so/\1/p')"
                data += "\n"
                data += "    echo \"Copying [$FILE] to [$NEWNAME]\"\n"
                data += "    cp $FILE $NEWNAME\n"
                data += "done\n"
                if device.architecture == "x86_64":
                    data += "[ -f ../lib/x86/libmagisk32.so ] && cp ../lib/x86/libmagisk32.so magisk32\n"
                elif device.architecture == "arm64-v8a" and (device.get_prop('ro.zygote') != "zygote64" or "zygote64_32" in with_version.lower()):
                    data += "[ -f ../lib/armeabi-v7a/libmagisk32.so ] && cp ../lib/armeabi-v7a/libmagisk32.so magisk32\n"
                data += "chmod 755 *\n"
                data += "if [[ -f \"/data/local/tmp/pf/assets/magisk\" ]]; then\n"
                data += "    PATCHING_MAGISK_VERSION=$(/data/local/tmp/pf/assets/magisk -c)\n"
                data += "    echo \"PATCHING_MAGISK_VERSION: $PATCHING_MAGISK_VERSION\"\n"
                data += "elif [[ -f \"/data/local/tmp/pf/assets/magisk32\" ]]; then\n"
                data += "    PATCHING_MAGISK_VERSION=$(/data/local/tmp/pf/assets/magisk32 -c)\n"
                data += "    echo \"PATCHING_MAGISK_VERSION: $PATCHING_MAGISK_VERSION\"\n"
                data += "elif [[ -f \"/data/local/tmp/pf/assets/magisk64\" ]]; then\n"
                data += "    PATCHING_MAGISK_VERSION=$(/data/local/tmp/pf/assets/magisk64 -c)\n"
                data += "    echo \"PATCHING_MAGISK_VERSION: $PATCHING_MAGISK_VERSION\"\n"
                data += "else\n"
                data += "    echo \"❌ ERROR: Magisk binary not found in /data/local/tmp/pf/assets/ \"\n"
                data += "fi\n"

            # We need SDK_INT because check_encryption() in app_functions.sh uses it and it's not defined yet.
            data += f"SDK_INT={device.api_level}\n"
            data += "export SDK_INT\n"
            data += "if [[ -f \"./app_functions.sh\" ]]; then\n"
            data += "    . ./app_functions.sh\n"
            data += "    app_init\n"
            data += "    . ./util_functions.sh\n"
            data += "else\n"
            data += "    SYSTEM_ROOT=false\n"
            data += "    SYSTEM_AS_ROOT=false\n"
            data += "    grep \' / \' /proc/mounts | grep -qv \'rootfs\' && SYSTEM_ROOT=true\n"
            data += "    grep \' / \' /proc/mounts | grep -qv \'rootfs\' && SYSTEM_AS_ROOT=true\n"
            data += "    . ./util_functions.sh\n"
            data += "    mount_partitions >/dev/null\n"
            data += '    get_flags\n'
            data += "fi\n"
            data += "echo -------------------------\n"
            data += "echo \"SLOT:              $SLOT\"\n"
            data += "echo \"SYSTEM_AS_ROOT:    $SYSTEM_AS_ROOT\"\n"
            data += "echo \"RAMDISKEXIST:      $RAMDISKEXIST\"\n"
            data += "echo \"ISAB:              $ISAB\"\n"
            data += "echo \"CRYPTOTYPE:        $CRYPTOTYPE\"\n"
            data += "echo \"PATCHVBMETAFLAG:   $PATCHVBMETAFLAG\"\n"
            data += "echo \"LEGACYSAR:         $LEGACYSAR\"\n"
            data += "echo \"RECOVERYMODE:      $RECOVERYMODE\"\n"
            data += "echo \"KEEPVERITY:        $KEEPVERITY\"\n"
            data += "echo \"KEEPFORCEENCRYPT:  $KEEPFORCEENCRYPT\"\n"
            data += "echo \"VENDORBOOT:        $VENDORBOOT\"\n"
            data += "echo \"ISENCRYPTED:       $ISENCRYPTED\"\n"
            data += "export SLOT SYSTEM_AS_ROOT RAMDISKEXIST ISAB CRYPTOTYPE PATCHVBMETAFLAG LEGACYSAR RECOVERYMODE KEEPVERITY KEEPFORCEENCRYPT VENDORBOOT  ISENCRYPTED\n"
            data += "echo -------------------------\n"
            data += "echo \"Creating a patch ...\"\n"
            data += "./magiskboot cleanup\n"
            data += f"./boot_patch.sh {self.config.phone_path}/{boot_img}\n"
            data += "PATCH_SHA1=$(./magiskboot sha1 new-boot.img | cut -c-8)\n"
            data += "echo \"PATCH_SHA1:     $PATCH_SHA1\"\n"
            data += f"PATCH_FILENAME={patch_name}_${{MAGISK_VERSION}}_${{STOCK_SHA1}}_${{PATCH_SHA1}}.img\n"
            data += "echo \"PATCH_FILENAME: $PATCH_FILENAME\"\n"

            if patch_method in ["app", "other"]:
                data += f"cp -f /data/local/tmp/pf/assets/new-boot.img {self.config.phone_path}/${{PATCH_FILENAME}}\n"
                # if we're rooted, copy the stock boot.img to /data/adb/magisk/stock_boot.img so that magisk can backup
                if perform_as_root:
                    data += "cp -f /data/local/tmp/pf/assets/stock_boot.img /data/adb/magisk/stock_boot.img\n"
                    # TODO see if we need to update the config SHA1 (not needed)
            else:
                data += f"mv new-boot.img {self.config.phone_path}/${{PATCH_FILENAME}}\n"

            data += f"if [[ -s {self.config.phone_path}/${{PATCH_FILENAME}} ]]; then\n"
            data += "	echo $PATCH_FILENAME > /data/local/tmp/pf_patch.log\n"
            data += "	if [[ -n \"$PATCHING_MAGISK_VERSION\" ]]; then echo $PATCHING_MAGISK_VERSION >> /data/local/tmp/pf_patch.log; fi\n"
            data += "else\n"
            data += "	echo \"❌ ERROR: Patching failed!\"\n"
            data += "fi\n\n"
            if delete_temp_files:
                data += "echo \"Cleaning up ...\"\n"
                # intentionally not including \n
                data += "rm -f /data/local/tmp/pf_patch.sh"

                if patch_method in ["app", "other"]:
                    data += " /data/local/tmp/pf.zip /data/local/tmp/new-boot.img /data/local/tmp/busybox\n"
                    data += "rm -rf /data/local/tmp/pf\n"
                data += "\n"

            f.write(data)
            puml(f"note right\nPatch Script\n====\n{data}\nend note\n")

        print("PixelFlasher patching script contents:")
        print(f"___________________________________________________\n{data.replace('❌', '').replace('⚠️', '')}")
        print("___________________________________________________\n")

        # Transfer extraction script to the phone
        res = device.push_file(f"{dest}", script_path, with_su=perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to transfer Patch Script to the phone;\n")
            return -1

        # set the permissions.
        res = device.set_file_permissions(script_path, "755", perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to set the executable bit on patch script;\n")
            return -1

        if patch_method in ["app", "other"]:
            # Transfer busybox to the phone
            res = device.push_file(f"{path_to_busybox}", "/data/local/tmp/busybox")
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to transfer busybox to the phone;\n")
                return -1

            # set the permissions.
            res = device.set_file_permissions("/data/local/tmp/busybox", "755")
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to set the executable bit on busybox;\n")
                return -1

        #------------------------------------
        # Execute the pf_patch.sh script
        #------------------------------------
        print("\nExecuting the pf_patch.sh script ...")
        print(f"PixelFlasher Patching phone with {patch_label}: {with_version}")
        puml(":Executing the patch script;\n")
        debug(f"exec_cmd: {exec_cmd}")
        res = run_shell2(exec_cmd)

        # get the patched_filename
        print("\nChecking patch log: /data/local/tmp/pf_patch.log ...")
        res = device.file_content("/data/local/tmp/pf_patch.log")
        if res == -1:
            print("Aborting ...\n")
            puml("#red:Failed to pull pf_patch.log from the phone;\n")
            return -1
        else:
            lines = res.split("\n")
            patched_img = lines[0] if len(lines) > 0 else ""
            if patch_method == "other":
                set_patched_with(lines[1]) if len(lines) > 1 else ""

        # delete pf_patch.log from phone
        if delete_temp_files:
            print("\nDeleting /data/local/tmp/pf_patch.log from the phone ...")
            res = device.delete("/data/local/tmp/pf_patch.log", perform_as_root)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to delete pf_patch.log from the phone;\n")
                return -1

        return patched_img

    # ==========================================
    # Sub Function       patch_kernelsu_script
    # ==========================================
    def patch_kernelsu_script(kernelsu_version):
        if 'KernelSU-Next' in patch_flavor:
            patch_label = "KernelSU-Next App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('KernelSU-Next')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1
            VERSION_VAR = "KSU_NEXT_VERSION"
            PATH_VAR = "KSU_NEXT_PATH"
        elif 'SukiSU' in patch_flavor:
            patch_label = "SukiSU App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('SukiSU')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1
            VERSION_VAR = "SUKISU_VERSION"
            PATH_VAR = "SUKISU_PATH"
        elif 'Wild_KSU' in patch_flavor:
            patch_label = "Wild_KSU App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('Wild_KSU')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1
            VERSION_VAR = "WILD_KSU_VERSION"
            PATH_VAR = "WILD_KSU_PATH"
        elif 'KernelSU-Legacy' in patch_flavor:
            patch_label = "KernelSU-Legacy App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('KernelSU-Legacy')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1
            VERSION_VAR = "KSU_VERSION"
            PATH_VAR = "KSU_PATH"
        else:
            patch_label = "KernelSU App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('KernelSU')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1
            VERSION_VAR = "KSU_VERSION"
            PATH_VAR = "KSU_PATH"
        set_patched_with(with_version)

        print("Creating pf_patch.sh script ...")
        patch_label = patch_flavor
        script_path = "/data/local/tmp/pf_patch.sh"
        exec_cmd = f"\"{get_adb()}\" -s {device.id} shell \"cd /data/local/tmp; /data/local/tmp/pf_patch.sh\""
        perform_as_root = False

        puml(f":Patching with {patch_label}: {with_version};\n", True)

        dest = os.path.join(config_path, 'tmp', 'pf_patch.sh')
        with open(dest.strip(), "w", encoding="ISO-8859-1", errors="replace", newline='\n') as f:
            data = " #!/system/bin/sh\n"
            data += " ##############################################################################\n"
            data += f" # PixelFlasher {VERSION} patch script using {patch_label} {with_version}\n"
            data += " ##############################################################################\n"
            data += f"{VERSION_VAR}=\"{with_version_code}\"\n"
            data += f"{PATH_VAR}={flavor_path}\n"
            data += f"STOCK_SHA1={stock_sha1}\n"
            data += f"ARCH={device.architecture}\n\n"
            data += "cd /data/local/tmp\n"
            data += f"if [ -f\"/data/local/tmp/pf_patch.log\" ]; then\n"
            data += f"    rm -f \"/data/local/tmp/pf_patch.log\"\n"
            data += "fi\n"
            data += "rm -rf pf || { echo 'ERROR: Failed to remove directory pf'; exit 1; }\n"
            data += "mkdir pf || { echo 'ERROR: Failed to create directory pf'; exit 1; }\n"
            data += "cd pf\n"
            data += "mv ../magiskboot .\n"
            data += "mv ../Image .\n"
            data += "chmod 755 magiskboot\n"
            data += f"cp {self.config.phone_path}/{boot_img} ./boot.img\n\n"

            data += "echo \"Unpacking boot.img ...\"\n"
            data += "./magiskboot unpack boot.img\n\n"

            data += "echo \"Replacing Kernel ...\"\n"
            data += "mv -f Image kernel\n\n"

            data += "echo \"Repacking boot.img ...\"\n"
            data += "./magiskboot repack boot.img\n\n"

            data += "PATCH_SHA1=$(./magiskboot sha1 new-boot.img | cut -c-8)\n"
            data += "echo \"PATCH_SHA1:     $PATCH_SHA1\"\n"
            data += f"PATCH_FILENAME={patch_name}_${{{VERSION_VAR}}}_${{STOCK_SHA1}}_${{PATCH_SHA1}}.img\n"
            data += "echo \"PATCH_FILENAME: $PATCH_FILENAME\"\n"

            data += f"cp -f /data/local/tmp/pf/new-boot.img {self.config.phone_path}/${{PATCH_FILENAME}}\n"

            data += f"if [[ -s {self.config.phone_path}/${{PATCH_FILENAME}} ]]; then\n"
            data += "	echo $PATCH_FILENAME > /data/local/tmp/pf_patch.log\n"
            data += f"	if [[ -n \"${VERSION_VAR}\" ]]; then echo ${VERSION_VAR} >> /data/local/tmp/pf_patch.log; fi\n"
            data += "else\n"
            data += "	echo \"❌ ERROR: Patching failed!\"\n"
            data += "fi\n\n"
            if delete_temp_files:
                data += "echo \"Cleaning up ...\"\n"
                # intentionally not including \n
                data += "rm -rf /data/local/tmp/pf\n"
                data += "rm -f /data/local/tmp/pf_patch.sh\n"
                data += "\n"

            f.write(data)
            puml(f"note right\nPatch Script\n====\n{data}\nend note\n")

        print("PixelFlasher patching script contents:")
        print(f"___________________________________________________\n{data.replace('❌', '').replace('⚠️', '')}")
        print("___________________________________________________\n")

        # Transfer extraction script to the phone
        res = device.push_file(f"{dest}", script_path, with_su=perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to transfer Patch Script to the phone;\n")
            return -1

        # set the permissions.
        res = device.set_file_permissions(script_path, "755", perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to set the executable bit on patch script;\n")
            return -1

        #------------------------------------
        # Execute the pf_patch.sh script
        #------------------------------------
        print("Executing the pf_patch.sh script ...")
        print(f"PixelFlasher Patching phone with {patch_label}: {with_version}")
        puml(":Executing the patch script;\n")
        debug(f"exec_cmd: {exec_cmd}")
        res = run_shell2(exec_cmd)

        # get the patched_filename
        print("Checking patch log: /data/local/tmp/pf_patch.log ...")
        res = device.file_content("/data/local/tmp/pf_patch.log")
        if res == -1:
            print("Aborting ...\n")
            puml("#red:Failed to pull pf_patch.log from the phone;\n")
            return -1
        else:
            lines = res.split("\n")
            patched_img = lines[0] if len(lines) > 0 else ""

        # delete pf_patch.log from phone
        if delete_temp_files:
            print("\nDeleting /data/local/tmp/pf_patch.log from the phone ...")
            res = device.delete("/data/local/tmp/pf_patch.log", perform_as_root)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to delete pf_patch.log from the phone;\n")
                return -1

        return patched_img

    # ==========================================
    # Sub Function     patch_kernelsu_lkm_script
    # ==========================================
    def patch_kernelsu_lkm_script():
        if 'KernelSU-Next' in patch_flavor:
            patch_label = "KernelSU-Next App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('KernelSU-Next')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1, ""
            VERSION_VAR = "KSU_NEXT_VERSION"
            PATH_VAR = "KSU_NEXT_PATH"
        elif 'SukiSU' in patch_flavor:
            patch_label = "SukiSU App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('SukiSU')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1, ""
            VERSION_VAR = "SUKISU_VERSION"
            PATH_VAR = "SUKISU_PATH"
        elif 'Wild_KSU' in patch_flavor:
            patch_label = "Wild_KSU App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('Wild_KSU')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1, ""
            VERSION_VAR = "WILD_KSU_VERSION"
            PATH_VAR = "WILD_KSU_PATH"
        elif 'KernelSU-Legacy' in patch_flavor:
            patch_label = "KernelSU-Legacy App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('KernelSU-Legacy')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1, ""
            VERSION_VAR = "KSU_VERSION"
            PATH_VAR = "KSU_PATH"
        else:
            patch_label = "KernelSU App"
            success, flavor_path, error_msg, with_version, with_version_code = ensure_root_app_installed('KernelSU')
            if not success:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
                puml(f"#red:{error_msg};\n")
                print("Aborting ...\n")
                return -1, ""
            VERSION_VAR = "KSU_VERSION"
            PATH_VAR = "KSU_PATH"

        try:
            version_code_int = int(with_version_code)
        except (ValueError, TypeError):
            # Handle the case where conversion fails assume very high version code
            version_code_int = 9999999
            print(f"⚠️ Warning: Could not convert version code '{with_version_code}' to integer, using default value")

        path_to_busybox = os.path.join(get_bundle_dir(),'bin', f"busybox_{device.architecture}")
        script_path = "/data/local/tmp/pf_patch.sh"
        exec_cmd = f"\"{get_adb()}\" -s {device.id} shell /data/local/tmp/pf_patch.sh"
        perform_as_root = False

        set_patched_with(with_version)
        puml(f":Patching with {patch_label}: {with_version};\n", True)

        dest = os.path.join(config_path, 'tmp', 'pf_patch.sh')
        mountType = ""
        # Patch flavor based cmd selector
        if self.config.force_ksud_mount_selection or patch_flavor == 'Wild_KSU_LKM' or (patch_flavor == 'KernelSU-Next_LKM' and version_code_int < 32857) :
            magiskboot = "magiskboot"
            # show a question dialog to ask the user to select mount type MagicMount or OverlayFS
            title = "Select dynamic module mount system"
            buttons_text = ["MagicMount", "OverlayFS", "None", "Cancel"]
            message = f'''
## Select dynamic module mount

- **System MagicMount**
  `Magic Mount is more stable and compatible (when supported).`
- **OverlayFS**
- **None**

'''
            print(f"\n*** Dialog ***\n{message}\n______________\n")
            dlg = MessageBoxEx(
                parent=self,
                title=title,
                message=message,
                button_texts=buttons_text,
                default_button=1,
                disable_buttons=[],
                is_md=True,
                size=[650,200],
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
            if result == 1:
                ksud_mount = "ksud_magic"
                mountType = "magicmount"
                print("User selected MagicMount for dynamic module mount system.")
            elif result == 2:
                ksud_mount = "ksud_overlayfs"
                mountType = "overlayfs"
                print("User selected OverlayFS for dynamic module mount system.")
            elif result == 3:
                ksud_mount = "ksud"
                mountType = ""
                print("User selected None for dynamic module mount system.")
            if result == 4:
                print("⚠️ User cancelled, Aborting ...")
                return -1, ""
        elif patch_flavor == 'SukiSU_LKM' and version_code_int < 40000:
            # as of SukiSU 4.0.0 (version code 40000), zakozako and zakoboot are replaced with ksud and magiskboot
            ksud_mount = "zakozako"
            magiskboot = "zakoboot"
        else:
            ksud_mount = "ksud"
            magiskboot = "magiskboot"

        # Create the patch script
        with open(dest.strip(), "w", encoding="ISO-8859-1", errors="replace", newline='\n') as f:
            data = " #!/system/bin/sh\n"
            data += " ##############################################################################\n"
            data += f" # PixelFlasher {VERSION} patch script using {patch_label} {with_version}\n"
            data += " ##############################################################################\n"
            data += f"{VERSION_VAR}=\"{with_version_code}\"\n"
            data += f"STOCK_SHA1={stock_sha1}\n"
            data += f"{PATH_VAR}={flavor_path}\n"

            data += f"ARCH={device.architecture}\n"
            data += f"cp {flavor_path} /data/local/tmp/pf.zip\n"
            data += "cd /data/local/tmp\n"
            data += f"if [ -f\"/data/local/tmp/pf_patch.log\" ]; then\n"
            data += f"    rm -f \"/data/local/tmp/pf_patch.log\"\n"
            data += "fi\n"
            data += "rm -rf pf || { echo 'ERROR: Failed to remove directory pf'; exit 1; }\n"
            data += "mkdir pf || { echo 'ERROR: Failed to create directory pf'; exit 1; }\n"
            data += "cd pf\n"
            data += "../busybox unzip -o ../pf.zip\n"
            data += "cd assets\n"
            data += "for FILE in ../lib/$ARCH/lib*.so; do\n"
            data += r"    NEWNAME=$(echo $FILE | toybox sed -En 's/.*\/lib(.*)\.so/\1/p')"
            data += "\n"
            data += "    echo \"Copying [$FILE] to [$NEWNAME]\"\n"
            data += "    cp $FILE $NEWNAME\n"
            data += "done\n"
            data += "chmod 755 *\n"
            data += f"PATCHING_{VERSION_VAR}=$(/data/local/tmp/pf/assets/{ksud_mount} -V)\n"
            data += f"echo \"PATCHING_{VERSION_VAR}: $PATCHING_{VERSION_VAR}\"\n"

            data += "echo -------------------------\n"
            data += "echo \"Creating a patch ...\"\n"
            data += "rm -f kernelsu_boot_* kernelsu_patched_*\n"
            kmi_override = ''
            if self.config.override_kmi:
                kmi_override = f" --kmi {self.config.override_kmi}"
                data += "echo \"Overriding KMI ...\"\n"
            data += "NEWEST_FILE1=$(ls -t | head -n 1)\n"
            data += f"./{ksud_mount} boot-patch -b {self.config.phone_path}/{boot_img} --magiskboot {magiskboot} {kmi_override} | tee temp_file\n"

            data += "OUTPUT_FILE=$(grep -o '/data/local/tmp/pf/assets/[^ ]*' \"temp_file\" | tail -n 1 | xargs basename)\n"
            data += "echo \"OUTPUT_FILE: [${OUTPUT_FILE}]\"\n"
            data += "rm -f temp_file\n"
            data += "NEWEST_FILE2=$(ls -t | head -n 1)\n"
            data += "if [ \"${NEWEST_FILE1}\" = \"${NEWEST_FILE2}\" ] || [ \"${OUTPUT_FILE}\" != \"${NEWEST_FILE2}\" ]; then\n"
            data += "    echo \"ERROR: No new file is created. Patching failed!\"\n"
            data += "    echo \"       NEWEST_FILE:    [${NEWEST_FILE2}]\"\n"
            data += "else\n"
            data += "    echo \"Found ${NEWEST_FILE2} continuing ...\"\n"
            data += f"    PATCH_SHA1=$(./{magiskboot} sha1 ${{NEWEST_FILE2}} | cut -c-8)\n"
            data += "    echo \"PATCH_SHA1:     $PATCH_SHA1\"\n"
            data += f"    PATCH_FILENAME={patch_name}_${{{VERSION_VAR}}}_${{STOCK_SHA1}}_${{PATCH_SHA1}}.img\n"
            data += "    echo \"PATCH_FILENAME: $PATCH_FILENAME\"\n"
            data += f"    if [ -f\"${{NEWEST_FILE2}}\" ]; then\n"
            data += f"        cp \"${{NEWEST_FILE2}}\" \"{self.config.phone_path}/${{PATCH_FILENAME}}\"\n"
            data += "    fi\n"
            data += f"    if [[ -s \"{self.config.phone_path}/${{PATCH_FILENAME}}\" ]]; then\n"
            data += "        echo $PATCH_FILENAME > /data/local/tmp/pf_patch.log\n"
            data += f"        if [[ -n \"$PATCHING_{VERSION_VAR}\" ]]; then\n"
            data += f"            echo \"$PATCHING_{VERSION_VAR}\" >> /data/local/tmp/pf_patch.log\n"
            data += "        fi\n"
            data += "    else\n"
            data += "        echo \"❌ ERROR: Patching failed!\"\n"
            data += "    fi\n"
            data += "fi\n\n"
            if delete_temp_files:
                data += "echo \"Cleaning up ...\"\n"
                data += "rm -f /data/local/tmp/pf_patch.sh /data/local/tmp/pf.zip /data/local/tmp/busybox\n"
                data += "rm -rf /data/local/tmp/pf\n"
                data += "\n"

            f.write(data)
            puml(f"note right\nPatch Script\n====\n{data}\nend note\n")

        print("PixelFlasher patching script contents:")
        print(f"___________________________________________________\n{data.replace('❌', '').replace('⚠️', '')}")
        print("___________________________________________________\n")

        # Transfer extraction script to the phone
        res = device.push_file(f"{dest}", script_path, with_su=perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to transfer Patch Script to the phone;\n")
            return -1, mountType

        # set the permissions.
        res = device.set_file_permissions(script_path, "755", perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to set the executable bit on patch script;\n")
            return -1, mountType

        # Transfer busybox to the phone
        res = device.push_file(f"{path_to_busybox}", "/data/local/tmp/busybox")
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to transfer busybox to the phone;\n")
            return -1, mountType

        # set the permissions.
        res = device.set_file_permissions("/data/local/tmp/busybox", "755")
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to set the executable bit on busybox;\n")
            return -1, mountType

        #------------------------------------
        # Execute the pf_patch.sh script
        #------------------------------------
        print("Executing the pf_patch.sh script ...")
        print(f"PixelFlasher Patching phone with {patch_label}: {with_version}")
        puml(":Executing the patch script;\n")
        debug(f"exec_cmd: {exec_cmd}")
        res = run_shell2(exec_cmd)

        # get the patched_filename
        print("Checking patch log: /data/local/tmp/pf_patch.log ...")
        res = device.file_content("/data/local/tmp/pf_patch.log")
        if res == -1:
            print("Aborting ...\n")
            puml("#red:Failed to pull pf_patch.log from the phone;\n")
            return -1, mountType
        else:
            lines = res.split("\n")
            patched_img = lines[0] if len(lines) > 0 else ""
            if patch_method == "other":
                set_patched_with(lines[1]) if len(lines) > 1 else ""

        # delete pf_patch.log from phone
        if delete_temp_files:
            print("\nDeleting /data/local/tmp/pf_patch.log from the phone ...")
            res = device.delete("/data/local/tmp/pf_patch.log", perform_as_root)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to delete pf_patch.log from the phone;\n")
                return -1, mountType

        return patched_img, mountType

    # ==========================================
    # Sub Function     patch_apatch_script
    # ==========================================
    def patch_apatch_script(patch_method="app", kernel_patch_version=""):
        dialog = wx.TextEntryDialog(None,
            "The SUPERKEY has higher privileges than root access.\n"
            "Weak or compromised keys can result in unauthorized control of your device.\n"
            "It is critical to use robust keys and safeguard them from exposure to maintain the security of your device.\n\n"
            "The length of superkey should be at least 8 characters and include both numbers and letters.",
            "Please enter a Superkey", style=wx.OK | wx.CANCEL)

        while True:
            if dialog.ShowModal() == wx.ID_OK:
                superkey = dialog.GetValue()
                if len(superkey) < 8:
                    print("Superkey is too short. It should be at least 8 characters.")
                    puml("#red:Superkey is too short. It should be at least 8 characters.;\n")
                    continue
                if not any(char.isdigit() for char in superkey):
                    print("Superkey should include at least one number.")
                    puml("#red:Superkey should include at least one number.;\n")
                    continue
                if not any(char.isalpha() for char in superkey):
                    print("Superkey should include at least one letter.")
                    puml("#red:Superkey should include at least one letter.;\n")
                    continue
                break  # Valid input received
            else:
                print("User cancelled.")
                print("Aborting ...\n")
                dialog.Destroy()
                return -1

        dialog.Destroy()

        print("Creating pf_patch.sh script ...")
        if patch_method == "rooted":
            patch_label = "rooted APatch"
            script_path = "/data/adb/apatch/pf_patch.sh"
            exec_cmd = f"\"{get_adb()}\" -s {device.id} shell \"su -c \'cd /data/adb/apatch; ./pf_patch.sh\'\""
            with_version = device.apatch_version
            with_version_code = device.apatch_version_code
            perform_as_root = True
        elif patch_method == "app":
            patch_label = "APatch App"
            path_to_busybox = os.path.join(get_bundle_dir(),'bin', f"busybox_{device.architecture}")
            script_path = "/data/local/tmp/pf_patch.sh"
            # if is_rooted:
            #     exec_cmd = f"\"{get_adb()}\" -s {device.id} shell \"su -c \'/data/local/tmp/pf_patch.sh\'\""
            # else:
            exec_cmd = f"\"{get_adb()}\" -s {device.id} shell /data/local/tmp/pf_patch.sh"
            with_version = device.get_uncached_apatch_app_version()
            with_version_code = device.apatch_app_version_code
            perform_as_root = False
        elif patch_method == "manual":
            patch_label = "APatch Manual"
            path_to_busybox = os.path.join(get_bundle_dir(),'bin', f"busybox_{device.architecture}")
            script_path = "/data/local/tmp/pf_patch.sh"
            exec_cmd = f"\"{get_adb()}\" -s {device.id} shell /data/local/tmp/pf_patch.sh"
            with_version = kernel_patch_version
            with_version_code = kernel_patch_version
            perform_as_root = False
        else:
            print(f"ERROR: Unsupported patch method: {patch_method}")
            puml("#red:Unsupported patch method;\n")
            return -1

        set_patched_with(with_version)
        puml(f":Patching with {patch_label}: {with_version};\n", True)

        dest = os.path.join(config_path, 'tmp', 'pf_patch.sh')
        with open(dest.strip(), "w", encoding="ISO-8859-1", errors="replace", newline='\n') as f:
            data = " #!/system/bin/sh\n"
            data += " ##############################################################################\n"
            data += f" # PixelFlasher {VERSION} patch script using {patch_label} {with_version}\n"
            data += " ##############################################################################\n"
            data += f"APATCH_VERSION=\"{with_version_code}\"\n"
            data += f"STOCK_SHA1={stock_sha1}\n"
            apatch_path = device.apatch_path
            data += f"APATCH_PATH={apatch_path}\n"
            data += f"if [ -f\"/data/local/tmp/pf_patch.log\" ]; then\n"
            data += f"    rm -f \"/data/local/tmp/pf_patch.log\"\n"
            data += "fi\n"

            if patch_method == "app":
                data += f"ARCH={device.architecture}\n"
                data += f"cp {apatch_path} /data/local/tmp/pf.zip\n"
                data += "cd /data/local/tmp\n"
                data += "rm -rf pf || { echo 'ERROR: Failed to remove directory pf'; exit 1; }\n"
                data += "mkdir pf || { echo 'ERROR: Failed to create directory pf'; exit 1; }\n"
                data += "cd pf\n"
                data += "../busybox unzip -o ../pf.zip\n"
                data += "cd assets\n"
                data += "for FILE in ../lib/$ARCH/lib*.so; do\n"
                data += r"    NEWNAME=$(echo $FILE | toybox sed -En 's/.*\/lib(.*)\.so/\1/p')"
                data += "\n"
                data += "    echo \"Copying [$FILE] to [$NEWNAME]\"\n"
                data += "    cp $FILE $NEWNAME\n"
                data += "done\n"
                data += "chmod 755 *\n"
                data += "PATCHING_APATCH_VERSION=$(/data/local/tmp/pf/assets/apd -V)\n"
                data += "echo \"PATCHING_APATCH_VERSION: $PATCHING_APATCH_VERSION\"\n"
                if init_boot_path is not None:
                    # unpack ramdisk.cpio from init_boot.img first and place it in the assets folder
                    data += "echo \"Extracting ramdisk from init_boot ...\"\n"
                    data += f"cp {self.config.phone_path}/{init_boot_img} ./init_boot.img\n"
                    data += "./magiskboot unpack init_boot.img\n"
            elif patch_method == "manual":
                data += "ARCH=$(uname -m)\n"
                data += "cd /data/local/tmp\n"
                data += "rm -rf pf || { echo 'ERROR: Failed to remove directory pf'; exit 1; }\n"
                data += "mkdir pf || { echo 'ERROR: Failed to create directory pf'; exit 1; }\n"
                data += "cd pf\n"
                data += "mv ../magiskboot .\n"
                data += "mv ../kptools-android .\n"
                data += "mv ../kpimg-android .\n"
                data += "chmod 755 *\n"
                if boot_path is not None:
                    # unpack boot.img
                    data += f"cp {self.config.phone_path}/{boot_img} ./boot.img\n"
                    data += f"echo \"Unpacking boot.img [{boot_img}] ...\"\n"
                    data += "./magiskboot unpack boot.img\n"
                    data += "mv kernel kernel-b\n"
                else:
                    print("ERROR: boot.img not found")
                    puml("#red:boot.img not found;\n")
                    return -1
                data += "echo \"Creating a patch ...\"\n"
                data += f"./kptools-android -p --image kernel-b --skey \'{superkey}\' --kpimg kpimg-android --out kernel\n"
                data += "echo \"Repacking boot.img ...\"\n"
                data += "./magiskboot repack boot.img\n"
                data += "PATCHING_APATCH_VERSION=$(/data/local/tmp/pf/./kptools-android -v)\n"
                data += "echo \"PATCHING_APATCH_VERSION: $PATCHING_APATCH_VERSION\"\n"

            if patch_method != "manual":
                data += "echo \"Creating a patch ...\"\n"
                data += f"./boot_patch.sh {superkey} {self.config.phone_path}/{boot_img} -K kpatch\n"
            data += "PATCH_SHA1=$(./magiskboot sha1 new-boot.img | cut -c-8)\n"
            data += "echo \"PATCH_SHA1:     $PATCH_SHA1\"\n"
            data += f"PATCH_FILENAME={patch_name}_${{APATCH_VERSION}}_${{STOCK_SHA1}}_${{PATCH_SHA1}}.img\n"
            data += "echo \"PATCH_FILENAME: $PATCH_FILENAME\"\n"

            if patch_method in ["app"]:
                data += f"cp -f /data/local/tmp/pf/assets/new-boot.img {self.config.phone_path}/${{PATCH_FILENAME}}\n"
            else:
                data += f"mv new-boot.img {self.config.phone_path}/${{PATCH_FILENAME}}\n"

            data += f"if [[ -s {self.config.phone_path}/${{PATCH_FILENAME}} ]]; then\n"
            data += "	echo $PATCH_FILENAME > /data/local/tmp/pf_patch.log\n"
            data += "	if [[ -n \"$PATCHING_APATCH_VERSION\" ]]; then echo $PATCHING_APATCH_VERSION >> /data/local/tmp/pf_patch.log; fi\n"
            data += "else\n"
            data += "	echo \"❌ ERROR: Patching failed!\"\n"
            data += "fi\n\n"
            if delete_temp_files:
                data += "echo \"Cleaning up ...\"\n"
                # intentionally not including \n
                data += "rm -f /data/local/tmp/pf_patch.sh"

                if patch_method in ["app"]:
                    data += " /data/local/tmp/pf.zip /data/local/tmp/new-boot.img /data/local/tmp/busybox\n"
                    data += "rm -rf /data/local/tmp/pf\n"
                elif patch_method == "manual":
                    data += "rm -rf /data/local/tmp/pf\n"
                data += "\n"

            f.write(data)
            puml(f"note right\nPatch Script\n====\n{data}\nend note\n")

        print("PixelFlasher patching script contents:")
        print(f"___________________________________________________\n{data.replace('❌', '').replace('⚠️', '')}")
        print("___________________________________________________\n")

        # Transfer extraction script to the phone
        res = device.push_file(f"{dest}", script_path, with_su=perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to transfer Patch Script to the phone;\n")
            return -1

        # set the permissions.
        res = device.set_file_permissions(script_path, "755", perform_as_root)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to set the executable bit on patch script;\n")
            return -1

        if patch_method in ["app", "other"]:
            # Transfer busybox to the phone
            res = device.push_file(f"{path_to_busybox}", "/data/local/tmp/busybox")
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to transfer busybox to the phone;\n")
                return -1

            # set the permissions.
            res = device.set_file_permissions("/data/local/tmp/busybox", "755")
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to set the executable bit on busybox;\n")
                return -1

        #------------------------------------
        # Execute the pf_patch.sh script
        #------------------------------------
        print("Executing the pf_patch.sh script ...")
        print(f"PixelFlasher Patching phone with {patch_label}: {with_version}")
        puml(":Executing the patch script;\n")
        debug(f"exec_cmd: {exec_cmd}")
        res = run_shell2(exec_cmd)

        # get the patched_filename
        print("Checking patch log: /data/local/tmp/pf_patch.log ...")
        res = device.file_content("/data/local/tmp/pf_patch.log")
        if res == -1:
            print("Aborting ...\n")
            puml("#red:Failed to pull pf_patch.log from the phone;\n")
            return -1
        else:
            lines = res.split("\n")
            patched_img = lines[0] if len(lines) > 0 else ""
            if patch_method == "other":
                set_patched_with(lines[1]) if len(lines) > 1 else ""

        # delete pf_patch.log from phone
        if delete_temp_files:
            print("\nDeleting /data/local/tmp/pf_patch.log from the phone ...")
            res = device.delete("/data/local/tmp/pf_patch.log", perform_as_root)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to delete pf_patch.log from the phone;\n")
                return -1

        return patched_img

    # ==========================================
    # Sub Function     magisk_not_found
    # ==========================================
    def magisk_not_found():
        print("Unable to find magisk on the phone, perhaps it is hidden?")
        puml("#orange:Magisk not found;\n")
        # Message to Launch Manually and Patch
        title = _("Magisk Manager is not detected.")
        message_en =  f"WARNING: Magisk Manager [{self.config.magisk}] is not found on the phone\n\n"
        message_en += "This could be either because it is hidden, or it is not installed (most likely not installed)\n\n"
        message_en += "If it is installed and hidden, then you should abort and then unhide it.\n"
        message_en += "If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n"
        message_en += "WARNING: Do not install Magisk again if it is currently hidden.\n"
        message_en += "Do you want PixelFlasher to download and install Magisk?\n"
        message_en += "You will be given a choice of Magisk Version to install.\n\n"
        message_en += "Click OK to continue with Magisk installation.\n"
        message_en += "or Hit CANCEL to abort."
        message =  _("WARNING: Magisk Manager [%s] is not found on the phone\n\n") % self.config.magisk
        message += _("This could be either because it is hidden, or it is not installed (most likely not installed)\n\n")
        message += _("If it is installed and hidden, then you should abort and then unhide it.\n")
        message += _("If Magisk is not installed, PixelFlasher can install it for you and use it for patching.\n\n")
        message += _("WARNING: Do not install Magisk again if it is currently hidden.\n")
        message += _("Do you want PixelFlasher to download and install Magisk?\n")
        message += _("You will be given a choice of Magisk Version to install.\n\n")
        message += _("Click OK to continue with Magisk installation.\n")
        message += _("or Hit CANCEL to abort.")
        print(f"\n*** Dialog ***\n{message_en}\n______________\n")
        puml(f"note right\nDialog\n====\n{message_en}\nend note\n")
        dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
        result = dlg.ShowModal()
        if result == wx.ID_OK:
            # ok to download and install
            print("User pressed ok.")
            puml(":User Pressed OK;\nnote right:Proceed to Magisk download and install\n")
            dlg = MagiskDownloads(self)
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            if result != wx.ID_OK:
                # User cancelled out of Magisk Installation
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel, out of Magisk download and install.")
                puml(":User Pressed Cancel;\n}\n")
                print("Aborting ...\n")
                dlg.Destroy()
                return -1
            dlg.Destroy()
            try:
                magisk_app_version = device.get_uncached_magisk_app_version()
                if magisk_app_version:
                    # Magisk Manager is installed
                    print(f"Found Magisk Manager version {magisk_app_version} on the phone.")
                    puml(f":Found Magisk Manager;\nnote right:version {magisk_app_version}\n", True)
                    return 0
                else:
                    print("Magisk Manager is still not detected.\nAborting ...\n")
                    puml("#red:Magisk Manager is still not detected;\nnote right:Abort\n}\n", True)
                    return -1
            except Exception:
                traceback.print_exc()
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed Magisk is still not detected.")
                puml("#red:Magisk Manager is still not detected;\nnote right:Abort\n}\n", True)
                print("Aborting ...\n")
                return -1
        return -1

    #------------------
    # Start of function
    #------------------
    delete_temp_files = not self.config.keep_patch_temporary_files
    recovery = 'false'
    custom_text = ""
    tmp_path = os.path.join(get_config_path(), 'tmp')
    print("")
    print("==============================================================================")
    print(f" {datetime.now():%Y-%m-%d %H:%M:%S} PixelFlasher {VERSION}          Patching {patch_flavor} boot")
    print("==============================================================================")
    puml(f"#cyan:Create {custom_text}Patch;\n", True)
    puml("partition \"**Create Patch**\" {\n")

    # get device
    device = get_phone(True)
    if not device:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
        print("Aborting ...\n")
        puml("#red:Valid device is not selected;\n}\n")
        return
    else:
        print(f"Patching on hardware: {device.hardware}")

    # If patch_flavor is KernelSU* check if the device is a Pixel device and if the kernel is KMI
    if patch_flavor in ['KernelSU', 'KernelSU_LKM','KernelSU-Next', 'KernelSU_Next_LKM', 'SukiSU', 'SukiSU_LKM', 'Wild_KSU', 'Wild_KSU_LKM', 'KernelSU-Legacy']:
        if self.config.override_kmi:
            title = _("Kernel KMI Override")
            message_en = f"Kernel KMI Override: {self.config.override_kmi}\n\n"
            message_en += "You have set a custom kernel KMI override.\n"
            message_en += "Are you sure you want to proceed with this override?\n"
            message_en += "Click OK to proceed with the override.\n"
            message_en += "or Hit CANCEL to abort."
            message = _("Kernel KMI Override: %s\n\n") % self.config.override_kmi
            message += _("You have set a custom kernel KMI override.\n")
            message += _("Are you sure you want to proceed with this override?\n")
            message += _("Click OK to proceed with the override.\n")
            message += _("or Hit CANCEL to abort.")
            print(f"\n*** Dialog ***\n{message_en}\n______________\n")
            puml(f"note right\nDialog\n====\n{message_en}\nend note\n")
            dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
            result = dlg.ShowModal()
            if result == wx.ID_OK:
                # ok to proceed with the override
                print("User pressed ok.")
                puml(":User Pressed OK;\nnote right:Proceed with Kernel KMI Override\n")
                dlg.Destroy()
            else:
                # User cancelled out of KMI Override
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel, out of Kernel KMI Override.")
                puml(":User Pressed Cancel;\n}\n")
                print("Aborting ...\n")
                dlg.Destroy()
                return -1
            # set the kmi to the override value
            kmi = self.config.override_kmi
        else:
            kmi = device.kmi
        if not kmi:
            # See if have guessed kmi
            kmi_guessed = device.kmi_guessed
            if kmi_guessed:
                title = _("PixelFlasher guessed Kernel KMI")
                message_en = "Your device kernel KMI is unknown probably because you're using\n"
                message_en += "a custom kernel which has stripped out the Android build tag.\n\n"
                message_en += f"PixelFlasher has guessed the Kernel KMI to be: {kmi_guessed}\n\n"
                message_en += "Are you sure you want to proceed with this guessed KMI?\n"
                message_en += "Click OK to proceed with the override.\n"
                message_en += "or Hit CANCEL to abort."
                message = _("Your device kernel KMI is unknown probably because you're using\n")
                message += _("a custom kernel which has stripped out the Android build tag.\n\n")
                message += _("PixelFlasher has guessed the Kernel KMI to be: %s\n\n") % kmi_guessed
                message += _("Are you sure you want to proceed with this guessed KMI?\n")
                message += _("Click OK to proceed with the override.\n")
                message += _("or Hit CANCEL to abort.")
                print(f"\n*** Dialog ***\n{message_en}\n______________\n")
                puml(f"note right\nDialog\n====\n{message_en}\nend note\n")
                dlg = MessageBoxEx(
                    parent=None,
                    title=title,
                    message=message,
                    button_texts=[_("OK"), _("Cancel")],
                    default_button=1,
                    disable_buttons=None,
                    is_md=False,
                    size=(800, 600),
                    checkbox_labels=None,
                    checkbox_initial_values=None,
                    disable_checkboxes=None,
                    vertical_checkboxes=False,
                    checkbox_labels2=None,
                    checkbox_initial_values2=None,
                    disable_checkboxes2=None,
                    radio_labels=None,
                    radio_initial_value=None,
                    disable_radios=None,
                    vertical_radios=False
                )
                dlg.CentreOnParent(wx.BOTH)
                result = dlg.ShowModal()
                dlg.Destroy()
                if result == 1:
                    # ok to proceed with the override
                    print("User pressed ok.")
                    puml(":User Pressed OK;\nnote right:Proceed with Kernel KMI Override\n")
                    kmi = kmi_guessed
                else:
                    # User cancelled out of guessed KMI Override
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel, out of guessed Kernel KMI Override.")
                    puml(":User Pressed Cancel;\n}\n")
                    print("Aborting ...\n")
                    return -1
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unsupported Kernel KMI [{kmi}]")
                print("Aborting ...\n")
                puml("#red:Unsupported Kernel KMI [{kmi}];\n}\n")
                return
        anykernel = False
        pixel_devices = get_android_devices()
        if not device.is_gki and patch_flavor != 'KernelSU-Legacy':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Incompatible Kernel KMI")
            print("Aborting ...\n")
            puml("#red:Incompatible Kernel KMI;\n}\n")
            return
        if device.hardware in pixel_devices:
            anykernel = True
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: KernelSU (Next) / SukiSU / Wild_KSU patching in PixelFlasher is only supported on Pixel devices")
            print("Aborting ...\n")
            puml("#red:KernelSU (Next) / SukiSU / Wild_KSU is only supported on Pixel Devices;\n}\n")
            return

    if patch_flavor == 'Custom':
        with wx.FileDialog(self, "boot / init_boot image to create patch from.", '', '', wildcard="Images (*.*.img)|*.img", style=wx.FD_OPEN) as fileDialog:
            puml(":Select boot image to patch;\n")
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                print("User cancelled boot selection.")
                puml("#pink:User Cancelled;\n}\n")
                return
            # save the current contents in the file
            file_to_patch = fileDialog.GetPath()
            file_sha1 = sha1(file_to_patch)
            print(f"\nSelected {file_to_patch} for patching with SHA1 of {file_sha1}")
            puml(f"note right\nSelected {file_to_patch} for patching with SHA1 of {file_sha1}\nend note\n")
    else:
        # Make sure boot image is selected
        if not self.config.boot_id:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Select a boot image.")
            print("Aborting ...\n")
            puml("#red:Valid boot image is not selected;\n}\n")
            return

    # Make sure platform-tools is set
    if not self.config.platform_tools_path:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Select Android Platform Tools (ADB)")
        print("Aborting ...\n")
        puml("#red:Valid Android Platform Tools is not selected;\n}\n")
        return

    # Make sure the phone is in adb mode.
    if device.mode != 'adb':
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device: {device.id} is not in adb mode.")
        print("Perhaps a Scan is necessary?")
        print("Aborting ...\n")
        puml("#red:Device is not in ADB mode;\n}\n")
        return

    start = time.time()
    init_boot_path = None
    config_path = get_config_path()
    factory_images = os.path.join(config_path, 'factory_images')
    if patch_flavor == 'Custom':
        boot_path = file_to_patch
        boot_file_name = os.path.basename(boot_path)
        filename, extension = os.path.splitext(boot_file_name)
        stock_sha1 = file_sha1[:8]
        boot_img = f"{filename}_{stock_sha1}.img"
        patch_name = "magisk_patched"
        patched_img = f"{patch_name}_{file_sha1[:8]}.img"
        package_dir_full = os.path.join(factory_images, get_firmware_id())
        is_odin = 0
    else:
        boot = get_boot()
        if not boot:
            print("\nPlease select a boot image!")
            return -1

        boot_path = boot.boot_path
        boot_directory = os.path.dirname(boot_path)
        boot_exists = False
        init_boot_exists = False
        vendor_boot_exists = False
        disabled_buttons = []

        # check if
        if os.path.exists(os.path.join(boot_directory, 'boot.img')):
            boot_exists = True
        else:
            disabled_buttons.append(1) # "boot.img"
        if os.path.exists(os.path.join(boot_directory, 'init_boot.img')):
            init_boot_exists = True
            init_boot_path = os.path.join(boot_directory, 'init_boot.img')
            stock_init_sha1 = sha1(init_boot_path)[:8]
        else:
            disabled_buttons.append(2) # "init_boot.img"
        if os.path.exists(os.path.join(boot_directory, 'vendor_boot.img')):
            vendor_boot_exists = True
        else:
            disabled_buttons.append(3) # "vendor_boot.img"

        # Determine the recommendation based on the patch flavor and available images
        if patch_flavor == 'Magisk':
            app_version = device.get_uncached_magisk_app_version()
            app_name = "Magisk"
            if init_boot_exists:
                recommendation = 2 # "init_boot.img"
            elif boot_exists:
                recommendation = 1 # "boot.img"
            else:
                recommendation = 4 # "Custom"
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: boot.img or init_boot.img is not found in the selected boot directory.")
                puml("#red:boot.img or init_boot.img is not found;\n")
                print("You can select custom option and provide a file to be patched.\n\n")

        elif patch_flavor in ['KernelSU', 'KernelSU-Next', 'SukiSU', 'Wild_KSU', 'KernelSU-Legacy']:
            if patch_flavor == 'KernelSU-Next':
                app_name = "KernelSU-Next"
                app_version = device.get_uncached_ksu_next_app_version()
            elif patch_flavor == 'SukiSU':
                app_name = "SukiSU"
                app_version = device.get_uncached_sukisu_app_version()
            elif patch_flavor == 'Wild_KSU':
                app_name = "Wild_KSU"
                app_version = device.get_uncached_wild_ksu_app_version()
            elif patch_flavor == 'KernelSU-Legacy':
                app_name = "KernelSU-Legacy"
                app_version = device.get_uncached_ksu_app_version()
            else:
                app_name = "KernelSU"
                app_version = device.get_uncached_ksu_app_version()
            if boot_exists:
                recommendation = 1 # "boot.img"
            else:
                recommendation = 4 # "Custom"
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: boot.img is not found in the selected boot directory.")
                puml("#red:boot.img is not found;\n")
                print("You can select custom option and provide a file to be patched.\n\n")

        elif patch_flavor in ['KernelSU_LKM', 'KernelSU-Next_LKM', 'SukiSU_LKM', 'Wild_KSU_LKM']:
            if patch_flavor == 'KernelSU-Next_LKM':
                app_name = "KernelSU-Next_LKM"
                app_version = device.get_uncached_ksu_next_app_version()
            elif patch_flavor == 'SukiSU_LKM':
                app_name = "SukiSU_LKM"
                app_version = device.get_uncached_sukisu_app_version()
            elif patch_flavor == 'Wild_KSU_LKM':
                app_name = "Wild_KSU_LKM"
                app_version = device.get_uncached_wild_ksu_app_version()
            else:
                app_name = "KernelSU_LKM"
                app_version = device.get_uncached_ksu_app_version()
            recommendation = None
            if boot_exists:
                recommendation = 1 # "boot.img"
            if vendor_boot_exists:
                if ((patch_flavor == 'KernelSU_LKM' and (device.ksu_app_version_code and int(device.ksu_app_version_code) >= 12109)) or patch_flavor == 'KernelSU-Next_LKM' or patch_flavor == 'SukiSU_LKM' or patch_flavor == 'Wild_KSU_LKM'):
                    recommendation = 3 # "vendor_boot.img"
            if init_boot_exists:
                recommendation = 2 # "init_boot.img"
            else:
                recommendation = 4 # "Custom"
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: vendor_boot.img, init_boot.img or boot.img is not found in the selected boot directory.")
                puml("#red:vendor_boot.img, init_boot.img or boot.img is not found;\n")
                print("You can select custom option and provide a file to be patched.\n\n")
            if not recommendation:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to determine which image to patch for {patch_flavor}.")
                puml("#red:Unable to determine which image to patch;\n")
                print("Aborting ...\n}\n")
                return -1

        elif patch_flavor in ['APatch', 'APatch_manual']:
            app_name = "APatch"
            app_version = device.get_uncached_apatch_app_version()
            if boot_exists:
                recommendation = 1 # "boot.img"
            else:
                recommendation = 4 # "Custom"
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: boot.img is not found in the selected boot directory.")
                puml("#red:boot.img is not found;\n")
                print("You can select custom option and provide a file to be patched.\n\n")

        if recommendation == 1:
            boot_path = os.path.join(boot_directory, 'boot.img')
        elif recommendation == 2:
            boot_path = os.path.join(boot_directory, 'init_boot.img')
        elif recommendation == 3:
            boot_path = os.path.join(boot_directory, 'vendor_boot.img')

        # Determine the patch image based on the recommendation
        if self.config.offer_patch_methods:
            title = "Patching decision"
            buttons_text = ["Use boot.img", "Use init_boot.img", "Use vendor_boot", "Custom", "Cancel"]
            buttons_text[recommendation -1] += " (Recommended)"

            message = '''
**PixelFlasher** can create a patch by using different extracted images.<br/>

This is a summary of what each rooting system typically patches.<br/>

- **Magisk** patches the ramdisk in `init_boot` if it exists, otherwise it patches Ramdisk in `boot`.<br/>

- **Apatch** patches the kernel in `boot`.<br/>

- **KernelSU**, **KernelSU-Next**, **SukiSU** and **Wild_KSU** (non LKM options) patches the kernel in `boot`.<br/>

- **KernelSU LKM**, **KernelSU-Next LKM**, **SukiSU LKM** and ** Wild_KSU** patches the ramdisk in the following priority order:
  `vendor_boot/ramdisk`, `vendor_boot/init_boot`, `init_boot/ramdisk`, `boot/ramdisk`<br/>
  _**Note:** Due to a bug in KSUN which fails to detect root, for the time being PixelFlasher_
  _will prioritize init_boot over vendor_boot until the issue is addressed in KSUN._<br/>

- **Custom** allows you to select any image to patch.<br/>

Depending on the selected rooting option,
PixelFlasher will offer available choices and recommend the best image for patching.<br/>
Unless you know what you're doing, it is recommended that you choose the default suggested selection.
'''
            app_name_padding = max(0, 31 - len(f"{app_name} Version:"))
            message += f"<pre>{app_name} Version:{' ' * app_name_padding}{app_version}\n"
            message += f"Recommended Patch image:       {buttons_text[recommendation -1]}</pre>\n"
            clean_message = message.replace("<br/>", "").replace("</pre>", "").replace("<pre>", "")
            print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
            puml(":Dialog;\n", True)
            puml(f"note right\n{clean_message}\nend note\n")
            dlg = MessageBoxEx(
            parent=self,
            title=title,
            message=message,
            button_texts=buttons_text,
            default_button=recommendation,
            disable_buttons=disabled_buttons,
            is_md=True,
            size=[800,640],
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
            puml(f":User Pressed {buttons_text[result - 1]};\n")

            if result == 1:
                # User selected boot.img
                print("Using boot.img for patching.")
                puml(":Using boot.img for patching;\n")
                boot_path = os.path.join(boot_directory, 'boot.img')
            elif result == 2:
                # User selected init_boot.img
                print("Using init_boot.img for patching.")
                puml(":Using init_boot.img for patching;\n")
                boot_path = os.path.join(boot_directory, 'init_boot.img')
            elif result == 3:
                # User selected vendor_boot.img
                print("Using vendor_boot.img for patching.")
                puml(":Using vendor_boot.img for patching;\n")
                boot_path = os.path.join(boot_directory, 'vendor_boot.img')
            elif result == 4:
                # User selected Custom
                print("User selected Custom patching.")
                puml(":User selected Custom patching;\n")
                with wx.FileDialog(self, "boot / init_boot / vendor_boot image to create patch from.", '', '', wildcard="Images (*.*.img)|*.img", style=wx.FD_OPEN) as fileDialog:
                    puml(":Select image to patch;\n")
                    if fileDialog.ShowModal() == wx.ID_CANCEL:
                        print("User cancelled image selection.")
                        puml("#pink:User Cancelled;\n}\n")
                        return -1
                    # save the current contents in the file
                    boot_path = fileDialog.GetPath()
                    file_sha1 = sha1(boot_path)
                    print(f"\nSelected {boot_path} for patching with SHA1 of {file_sha1}")
                    puml(f"note right\nSelected {boot_path} for patching with SHA1 of {file_sha1}\nend note\n")

            elif result == 5:
                # User selected Cancel
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel, out of patching decision dialog.")
                puml(":User Pressed Cancel;\n}\n")
                print("Aborting ...\n")
                return -1
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Invalid selection in patching decision dialog.")
                puml("#red:Invalid selection in patching decision dialog;\n}\n")
                print("Aborting ...\n")
                return -1

        stock_sha1 = sha1(boot_path)[:8]
        boot_file_name = os.path.basename(boot_path)
        filename, unused = os.path.splitext(boot_file_name)
        boot_img = f"{filename}_{stock_sha1}.img"
        if init_boot_path is not None:
            init_boot_file_name = os.path.basename(init_boot_path)
            init_filename, unused = os.path.splitext(init_boot_file_name)
            init_boot_img = f"{init_filename}_{stock_init_sha1}.img"
        patch_name = f"{patch_flavor.lower()}_patched"
        patched_img = f"{patch_name}_{boot.boot_hash[:8]}.img"
        package_dir_full = os.path.join(factory_images, boot.package_sig)
        is_odin = boot.is_odin
    boot_images = os.path.join(config_path, get_boot_images_dir())
    tmp_dir_full = os.path.join(config_path, 'tmp')

    # delete all files in tmp folder to make sure we're dealing with new files only.
    delete_all(tmp_dir_full)

    # check if boot_file_name got extracted (if not probably the zip does not have it)
    if not os.path.exists(boot_path):
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You have selected the Patch option, however boot file is not found.")
        puml("#red:Cannot patch an already patched file;\n")
        print("Aborting ...\n}\n")
        return

    if patch_flavor != 'Custom':
        # Extract phone model from boot.package_sig and warn the user if it is not from the current phone model
        package_sig = boot.package_sig.split("-")
        try:
            firmware_model = package_sig[0]
        except Exception as e:
            traceback.print_exc()
            firmware_model = None
        if not (len(device.hardware) >= 3 and device.hardware in firmware_model):
            title = _("Boot Model Mismatch")
            message_en =  f"WARNING: Your phone model is: {device.hardware}\n\n"
            message_en += f"The selected {boot_file_name} is from: {boot.package_sig}\n\n"
            message_en += f"Please make sure the {boot_file_name} file you are trying to patch,\n"
            message_en += f"is for the selected device: {device.id}\n\n"
            message_en += "Click OK to accept and continue.\n"
            message_en += "or Hit CANCEL to abort."
            message =  "WARNING: Your phone model is: %s\n\n" % device.hardware
            message += "The selected %s is from: %s\n\n" % (boot_file_name, boot.package_sig)
            message += "Please make sure the %s file you are trying to patch,\n" % boot_file_name
            message += "is for the selected device: %s\n\n" % device.id
            message += "Click OK to accept and continue.\n"
            message += "or Hit CANCEL to abort."
            print(f"\n*** Dialog ***\n{message_en}\n______________\n")
            puml("#orange:WARNING;\n", True)
            puml(f"note right\n{message_en}\nend note\n")
            dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
            result = dlg.ShowModal()
            if result == wx.ID_OK:
                print("User pressed ok.")
                puml(":User Pressed OK to continue;\n")
            else:
                print("User pressed cancel.")
                puml("#pink:User Pressed Cancel to abort;\n}\n")
                print("Aborting ...\n")
                return

    # delete existing boot_img from phone
    file = f"{self.config.phone_path}/{boot_img}"
    print(f"\nDeleting {file} from the phone ...")
    res = device.delete(f"{self.config.phone_path}/{boot_img}")
    if res != 0:
        print("Aborting ...\n")
        puml("#red:Failed to delete old boot image from the phone;\n}\n")
        return

    # check if delete worked.
    print(f"\nMaking sure {file} is not on the phone ...")
    res, unused = device.check_file(f"{self.config.phone_path}/{boot_img}")
    if res != 0:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to delete old boot image from the phone\nAborting ...\n")
        puml("#red:Failed to delete old boot image from the phone;\n}\n")
        return

    # delete existing {patch_name} from phone
    file = f"{self.config.phone_path}/{patch_name}*.img"
    print(f"\nDeleting {patch_name} from the phone ...")
    res = device.delete(f"{self.config.phone_path}/{patch_name}*.img")
    if res != 0:
        puml(f"#red:Failed to delete old {patch_name}.img;\n")
        print("Aborting ...\n}\n")
        return

    # check if delete worked.
    print(f"\nMaking sure {file} is not on the phone ...")
    res, unused = device.check_file(f"{self.config.phone_path}/{patch_name}*.img")
    if res != 0:
        puml(f"#red:Failed to delete old {patch_name}.img;\n")
        print("Aborting ...\n}\n")
        return

    # Transfer boot image to the phone
    print(f"\nTransferring {boot_img} to the phone ...")
    res = device.push_file(f"{boot_path}", f"{self.config.phone_path}/{boot_img}")
    if res != 0:
        puml("#red:Failed to transfer the boot file to the phone;\n")
        print("Aborting ...\n}\n")
        return
    if patch_flavor == 'APatch' and init_boot_path is not None:
        # transfer init_boot.img to the phone as the RAMDISK is in the init_boot.img and is needed for patching
        res = device.push_file(f"{init_boot_path}", f"{self.config.phone_path}/{init_boot_img}")
        if res != 0:
            puml("#red:Failed to transfer the init_boot file to the phone;\n")
            print("Aborting ...\n}\n")
            return
        # check if transfer worked.
        res, unused = device.check_file(f"{self.config.phone_path}/{init_boot_img}")
        if res != 1:
            print("Aborting ...\n")
            puml("#red:Failed to transfer the init_boot file to the phone;\n}\n")
            return

    # check if transfer worked.
    print(f"\nMaking sure {boot_img} is on the phone ...")
    res, unused = device.check_file(f"{self.config.phone_path}/{boot_img}")
    if res != 1:
        print("Aborting ...\n")
        puml("#red:Failed to transfer the boot file to the phone;\n}\n")
        return

    is_rooted = device.rooted
    kernel_su_gz_file = None

    # KernelSU
    if patch_flavor in ['KernelSU', 'KernelSU-Next', 'SukiSU', 'Wild_KSU', 'KernelSU-Legacy']:
        magiskboot_created = False
        if is_rooted:
            res, unused = device.check_file("/data/adb/magisk/magiskboot", True)
            if res == 1:
                res = device.su_cp_on_device('/data/adb/magisk/magiskboot', '/data/local/tmp/magiskboot')
                if res == 0:
                    magiskboot_created = True
                theCmd = f"\"{get_adb()}\" -s {device.id} shell \"su -c \'chown shell:shell /data/local/tmp/magiskboot\'\""
                res = run_shell(theCmd)

        if not magiskboot_created:
            # Find latest Magisk to download
            apk = get_rooting_app_details('Magisk Stable')
            if apk is None:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find Magisk Stable version.")
                puml("#red:Could not find Magisk Stable version;\n")
                print("Aborting ...\n}\n")
                return
            filename = f"magisk_{apk.version}_{apk.versionCode}.apk"
            download_file(apk.link, filename)
            magisk_apk = os.path.join(tmp_path, filename)

            # extract magiskboot
            extract_magiskboot(magisk_apk, device.architecture, tmp_path)

            # transfer magiskboot to the phone
            res = device.push_file(os.path.join(tmp_path, 'magiskboot'), '/data/local/tmp/magiskboot', False)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to transfer magiskboot to the phone;\n")
                return


        kmi_parts = kmi.split('-')
        look_for_kernelsu = '-'.join(kmi_parts[::-1])
        kernel_su_gz_file = None
        kernelsu_version = None

        # default_button=1 is KernelSU
        # default_button=2 is KernelSU-Next
        # default_button=3 is Wild_KSU
        # default_button=4 is ShirkNeko SukiSU
        # default_button=5 is MiRinFork SukiSU
        # default_button=6 is Manual
        # radio_initial_value=0 is Release builds
        # radio_initial_value=1 is Pre-Release builds
        # radio_initial_value=2 is Release and Pre-Release builds
        #
        # Show the KernelSU flavor selection dialog
        if patch_flavor == 'KernelSU':
            method = 80
            res = kernel_flavors(self, default_button=1, radio_initial_value=0, kernel_recommendation="KernelSU", checkbox_initial_values=[False, False])
        elif patch_flavor == 'KernelSU-Next':
            method = 82
            res = kernel_flavors(self, default_button=2, radio_initial_value=0, kernel_recommendation="KernelSU-Next", checkbox_initial_values=[False, False])
        elif patch_flavor == 'SukiSU':
            method = 84
            res = kernel_flavors(self, default_button=5, radio_initial_value=1, kernel_recommendation="MiRinFork", checkbox_initial_values=[False, False])
        elif patch_flavor == 'Wild_KSU':
            method = 86
            res = kernel_flavors(self, default_button=3, radio_initial_value=2, kernel_recommendation="WildKernels", checkbox_initial_values=[False, True])
        elif patch_flavor == 'KernelSU-Legacy':
            method = 88
            res = kernel_flavors(self, default_button=1, radio_initial_value=0, kernel_recommendation="KernelSU", checkbox_initial_values=[False, False])

        # Check if the user canceled
        if res['button'] == 7:  # Cancel button
            print("ℹ️ User cancelled the operation\n Aborting ...\n")
            return -1

        # Check the radio button selection
        if res['radio_selection'] == 0:     # Release builds only
            include_prerelease = False,
            latest_any = False
        elif res['radio_selection'] == 1:   # Pre-Release builds only
            include_prerelease = True,
            latest_any = False
        elif  res['radio_selection'] == 2:  # Release and Pre-Release builds
            include_prerelease = True,
            latest_any = True

        # Check if version_choice checkbox is selected
        version_choice = res['checkbox_values'][0]

        # Check if get_all checkbox is selected
        get_all = res['checkbox_values'][1]

        # Check if search_all_releases checkbox is selected
        search_all_releases = res['checkbox_values'][2] if len(res['checkbox_values']) > 2 else False

        # Get checkbox values from the result
        checkbox_values = res.get('checkbox_values', [])
        print(f"Checkbox values received: {checkbox_values}")

        # Check what the user selected
        if res['button'] == 1:
            # KernelSU
            user='tiann'
            repo='KernelSU'
            custom_kernel=None
            chosen_kernel='KernelSU'
        elif res['button'] == 2:
            # KernelSU-Next
            user='rifsxd'
            repo='KernelSU-Next'
            custom_kernel=None
            chosen_kernel='KernelSU-Next'
        elif res['button'] == 3:
            # WildKernels
            user='WildKernels'
            repo='GKI_KernelSU_SUSFS'
            custom_kernel='WildKernels'
            chosen_kernel='WildKernels'
        elif res['button'] == 4:
            # ShirkNeko
            user='ShirkNeko'
            repo='GKI_KernelSU_SUSFS'
            custom_kernel='ShirkNeko'
            chosen_kernel='ShirkNeko'
        elif res['button'] == 5:
            # MiRinFork
            user='MiRinFork'
            repo='GKI_SukiSU_SUSFS'
            custom_kernel='MiRinFork'
            chosen_kernel='MiRinFork'
        elif res['button'] == 6:
            # Manual
            # show a file dialog to select the kernel file
            chosen_kernel='Manual'
            with wx.FileDialog(self, "Select the kernel image to use.", '', '', wildcard="Kernel image (*.gz;*.zip)|*.gz;*.zip", style=wx.FD_OPEN) as fileDialog:
                puml(":Select kernel image to use;\n")
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled kernel image selection.")
                    puml("#pink:User Cancelled;\n}\n")
                    return
                # save the current contents in the file
                kernel_su_gz_file = fileDialog.GetPath()
                print(f"\nSelected {kernel_su_gz_file} for KernelSU generic kernel image.")
                puml(f"note right\nSelected {kernel_su_gz_file} for KernelSU generic kernel image.\nend note\n")
        else:
            print("⚠️ Invalid selection, Aborting ...")
            return -1

        if res['button'] != 6:
            # download the selected KernelSU generic kernel image
            kernel_su_gz_file = download_ksu_latest_release_asset(user=user, repo=repo, asset_name=look_for_kernelsu, anykernel=anykernel, custom_kernel=custom_kernel, include_prerelease = include_prerelease, latest_any=latest_any, version_choice=version_choice, get_all=get_all, search_all_releases=search_all_releases)
            if kernel_su_gz_file:
                kernelsu_version = get_gh_latest_release_version(user, repo)

        if not kernel_su_gz_file:
            print("ERROR: Could not find matching generic kernel image\nAborting ...\n")
            return
        if isinstance(kernel_su_gz_file, list):
            print("ERROR: Could not find matching generic kernel image\nAborting ...\n")
            return

        # extract the kernelsu image
        if anykernel:
            kernelsu_image = os.path.join(tmp_path, kernel_su_gz_file)
            debug(f"Unzipping Image: {kernelsu_image} into {tmp_path} ...")
            extract_from_zip(kernelsu_image, 'Image', tmp_path, True)
            # check if Image exists
            if not os.path.exists(os.path.join(tmp_path, 'Image')):
                print(f"Image file not found in the {kernelsu_image}, checking for Image.lz4 ...")
                extract_from_zip(kernelsu_image, 'Image.lz4', tmp_path)
                # check if Image exists
                if not os.path.exists(os.path.join(tmp_path, 'Image.lz4')):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract Image or Image.lz4 from: {kernelsu_image}.")
                    puml("#red:Could not extract Image from: {kernelsu_image};\n")
                    print("Aborting ...\n}\n")
                    return
                else:
                    print(f"Extracted Image.lz4 from: {kernelsu_image} version {kernelsu_version} into {tmp_path}")
                    # transfer Image to the phone
                    res = device.push_file(os.path.join(tmp_path, 'Image.lz4'), '/data/local/tmp/Image', False)
                    if res != 0:
                        print("Aborting ...\n")
                        puml("#red:Failed to transfer Image to the phone;\n")
                        return
            else:
                print(f"Extracted Image from: {kernelsu_image} version {kernelsu_version} into {tmp_path}")
                # transfer Image to the phone
                res = device.push_file(os.path.join(tmp_path, 'Image'), '/data/local/tmp/Image', False)
                if res != 0:
                    print("Aborting ...\n")
                    puml("#red:Failed to transfer Image to the phone;\n")
                    return

    # KernelSU_LKM
    elif patch_flavor == 'KernelSU_LKM':
        method = 81

    # KernelSU_Next_LKM
    elif patch_flavor == 'KernelSU-Next_LKM':
        method = 83

    # SukiSU_LKM
    elif patch_flavor == 'SukiSU_LKM':
        method = 85

    # Wild_KSU_LKM
    elif patch_flavor == 'Wild_KSU_LKM':
        method = 87

    # APatch
    elif patch_flavor == 'APatch':
        method = 90
        # check if APatch app is installed
        print("Checking to see if APatch app is installed ...")
        puml(":Checking APatch App;\n")
        success, apatch_app_path, error_msg, with_version, with_version_code = ensure_root_app_installed('APatch')
        if not success:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
            puml(f"#red:{error_msg};\n")
            print("Aborting ...\n}\n")
            return

    # APatch Alternate
    elif patch_flavor == 'APatch_manual':
        method = 91
        # check if APatch app is installed
        print("Checking to see if APatch app is installed ...")
        puml(":Checking APatch App;\n")
        success, apatch_app_path, error_msg, with_version, with_version_code = ensure_root_app_installed('APatch')
        if not success:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
            puml(f"#red:{error_msg};\n")
            print("Aborting ...\n}\n")
            return
        compatible = True
        # Check for CONFIG_KALLSYMS=y in the kernel config
        if device.config_kallsyms != 'CONFIG_KALLSYMS=y':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: APatch requires CONFIG_KALLSYMS=y in the kernel config.")
            puml("#red:APatch requires CONFIG_KALLSYMS=y in the kernel config;\n")
            compatible = False
        # Make sure kernel version is supported by APatch 3.18 - 6.1
        try:
            kernel_version = float(device.get_prop('ro.kernel.version'))
            if kernel_version < 3.18 or kernel_version > 6.1:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: APatch only supports kernel versions 3.18 - 6.1")
                puml("#red:APatch only supports kernel versions 3.18 - 6.1;\n")
                compatible = False
        except Exception as e:
            print(f"Error processing kernel version: {e}")
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: APatch only supports kernel versions 3.18 - 6.1")
            puml("#red:APatch only supports kernel versions 3.18 - 6.1;\n")
            compatible = False

        if not compatible:
            # add a dialog to ask if the user wants to continue regardless of the kernel version or the CONFIG_KALLSYMS=y
            title = _("APatch Manual Patching")
            message_en =  f"APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n"
            message_en += f"APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n"
            message_en += "Do you want to continue regardless of not meeting the pre-requisites?\n\n"
            message_en += "Click Yes to continue with APatch Manual Patching\n"
            message_en += "or Hit No to abort."
            message =  _("APatch Manual Patching requires CONFIG_KALLSYMS=y in the kernel config.\n")
            message += _("APatch Manual Patching only supports kernel versions 3.18 - 6.1\n\n")
            message += _("Do you want to continue regardless of not meeting the pre-requisites?\n\n")
            message += _("Click Yes to continue with APatch Manual Patching\n")
            message += _("or Hit No to abort.")
            print(f"\n*** Dialog ***\n{message_en}\n______________\n")
            puml("#orange:APatch Manual Patching;\n", True)
            puml(f"note right\n{message_en}\nend note\n")
            dlg = wx.MessageDialog(None, message, title, wx.YES_NO | wx.NO_DEFAULT | wx.ICON_EXCLAMATION)
            result = dlg.ShowModal()
            if result == wx.ID_YES:
                print(f"User chose to ignore missing requirements and continued with APatch Manual Patching")
                puml(":User chose to ignore missing requirements and continued with APatch Manual Patching;\n")
            else:
                print(f"User chose to cancel APatch Manual Patching")
                puml(":User chose to cancel APatch Manual Patching;\n")
                print("Aborting ...\n")
                return -1

        success, apatch_app_path, error_msg, with_version, with_version_code = ensure_root_app_installed('APatch')
        if not success:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {error_msg}")
            puml(f"#red:{error_msg};\n")
            print("Aborting ...\n}\n")
            return
        magiskboot_created = False
        if is_rooted:
            res, unused = device.check_file("/data/adb/magisk/magiskboot", True)
            if res == 1:
                res = device.su_cp_on_device('/data/adb/magisk/magiskboot', '/data/local/tmp/magiskboot')
                if res == 0:
                    magiskboot_created = True
                theCmd = f"\"{get_adb()}\" -s {device.id} shell \"su -c \'chown shell:shell /data/local/tmp/magiskboot\'\""
                res = run_shell(theCmd)

        if not magiskboot_created:
            # Find latest Magisk to download
            apk = get_rooting_app_details('Magisk Stable')
            filename = f"magisk_{apk.version}_{apk.versionCode}.apk"
            download_file(apk.link, filename)
            magisk_apk = os.path.join(tmp_path, filename)

            # extract magiskboot
            extract_magiskboot(magisk_apk, device.architecture, tmp_path)

            # transfer magiskboot to the phone
            res = device.push_file(os.path.join(tmp_path, 'magiskboot'), '/data/local/tmp/magiskboot', False)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to transfer magiskboot to the phone;\n")
                return

        kernel_patch_version_prerelease = get_gh_latest_release_version('bmax121', 'KernelPatch', True)
        kernel_patch_version_release = get_gh_latest_release_version('bmax121', 'KernelPatch', False)
        # Pop up a dialog to ask the user if they want to download the latest kptools-android and kpimg-android that includes pre-release versions
        title = _("Download Latest KernelPatch Tools")
        message_en =  f"Latest KernelPatch Tools Pre-release Version: {kernel_patch_version_prerelease}\n"
        message_en +=  f"Latest KernelPatch Tools Release Version: {kernel_patch_version_release}\n\n"
        message_en += "Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n"
        message_en += f"Click Yes to download the latest pre-release versions: {kernel_patch_version_prerelease}\n"
        message_en += f"Click No to download the latest Release versions: {kernel_patch_version_release}\n"
        message_en += "or Hit CANCEL to abort."
        message =  _("Latest KernelPatch Tools Pre-release Version: %s\n") % kernel_patch_version_prerelease
        message += _("Latest KernelPatch Tools Release Version: %s\n\n") % kernel_patch_version_release
        message += _("Do you want to download the latest kptools-android and kpimg-android that includes pre-release versions?\n\n")
        message += _("Click Yes to download the latest pre-release versions: %s\n") % kernel_patch_version_prerelease
        message += _("Click No to download the latest Release versions: %s\n") % kernel_patch_version_release
        message += _("or Hit CANCEL to abort.")
        print(f"\n*** Dialog ***\n{message_en}\n______________\n")
        puml("#orange:Download Latest KernelPatch Tools;\n", True)
        puml(f"note right\n{message_en}\nend note\n")
        dlg = wx.MessageDialog(None, message, title, wx.YES_NO | wx.CANCEL | wx.ICON_EXCLAMATION)
        result = dlg.ShowModal()
        if result == wx.ID_YES:
            # include_prerelease = True
            print(f"User chose to download pre-release version: {kernel_patch_version_prerelease}")
            puml(":User chose to download pre-release version;\n")
            kernel_patch_version = kernel_patch_version_prerelease
            kptools_android_file = download_gh_pre_release_asset_regex(user='bmax121', repo='KernelPatch', asset_name_pattern='kptools-android')
            kpimg_android_file = download_gh_pre_release_asset_regex(user='bmax121', repo='KernelPatch', asset_name_pattern='kpimg-android')
        elif result == wx.ID_NO:
            # include_prerelease = False
            print(f"User chose to download release version: {kernel_patch_version_release}")
            puml(":User chose to download release version;\n")
            kernel_patch_version = kernel_patch_version_release
            kptools_android_file = download_gh_latest_release_asset_regex(user='bmax121', repo='KernelPatch', asset_name_pattern='kptools-android')
            kpimg_android_file = download_gh_latest_release_asset_regex(user='bmax121', repo='KernelPatch', asset_name_pattern='kpimg-android')
        else:
            print(f"User pressed Cancel")
            puml(":User Pressed Cancel;\n")
            print("Aborting ...\n")
            return -1

        if not kptools_android_file:
            print("ERROR: Could not find matching kptools-android file\nAborting ...\n")
            return

        if not kpimg_android_file:
            print("ERROR: Could not find matching kpimg-android file\nAborting ...\n")
            return

        # transfer kptools-android to the phone
        res = device.push_file(os.path.join(tmp_path, 'kptools-android'), '/data/local/tmp/kptools-android', False)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to transfer kptools-android to the phone;\n")
            return

        # transfer kpimg-android to the phone
        res = device.push_file(os.path.join(tmp_path, 'kpimg-android'), '/data/local/tmp/kpimg-android', False)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to transfer kpimg-android to the phone;\n")
            return

    # Magisk
    else:
        #------------------------------------
        # Check to see if Magisk is installed
        #------------------------------------
        print("\nLooking for Magisk Manager app ...")
        puml(":Checking Magisk Manager;\n")
        magisk_app_version = device.get_uncached_magisk_app_version()
        magisk_version = device.magisk_version

        # -------------------------------
        # Patching decision
        # -------------------------------
        m_version = 0
        m_app_version = 0
        with contextlib.suppress(Exception):
            m_version = int(magisk_version.split(':')[1])
        with contextlib.suppress(Exception):
            m_app_version = int(magisk_app_version.split(':')[1])
        print(f"  Magisk Manager Version: {m_app_version}")
        print(f"  Magisk Version:         {m_version}")
        puml(f"note right\nMagisk Manager Version: {m_app_version}\nMagisk Version:         {m_version}\nend note\n")

        # if selected firmware is Pixel and December 2025 or newer, and Magisk version is less than 30.6, warn the user
        if boot.spl:
            spl_date = datetime.strptime(boot.spl, '%Y-%m-%d')
            dec_2025 = datetime.strptime('2025-12-01', '%Y-%m-%d')
            try:
                device_type = get_android_devices()[device.hardware]
                mm_version = max(m_app_version, m_version)
            except Exception as e:
                device_type = None
            if device_type and spl_date >= dec_2025 and mm_version < 30600:
                self.toast(_("WARNING! Incompatible Magisk"), _("⚠️ Magisk versions older than 30.6 may not work correctly on this firmware.."))
                print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Your device firmware date is {boot.spl}, which is December 2025 or newer.")
                print("Magisk versions older than 30.6 may not work correctly on this firmware.\n")
                puml("#orange:WARNING: Magisk versions older than 30.6 may not work correctly on December 2025 or newer firmware;\n")
                dlg = wx.MessageDialog(None, _("⚠️ Magisk versions older than 30.6 may not work correctly on this firmware.\nAre you sure want to continue?"), _("Incompatible Magisk"), wx.YES_NO | wx.ICON_EXCLAMATION)
                result = dlg.ShowModal()
                if result != wx.ID_YES:
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled creating a patch.")
                    puml("#pink:User cancelled creating a patch;\n}\n")
                    return -1

        if is_rooted and magisk_version:
            method = 1  # rooted
            # disable app method if app is not found or is hidden.
            if not magisk_app_version or ( self.config.magisk not in ['', MAGISK_PKG_NAME, MAGISK_ALPHA_PKG_NAME, MAGISK_DELTA_PKG_NAME, KERNEL_SU_PKG_NAME, APATCH_PKG_NAME] ):
                disabled_buttons = [2, 3, 4]
            elif magisk_version and magisk_app_version:
                disabled_buttons = [3]
                if magisk_version != magisk_app_version:
                    print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Magisk Version is different than Magisk Manager version")
                    puml("#orange:WARNING: Magisk Version is different than Magisk Manager version;\n")
                    if m_version < m_app_version:
                        method = 2  # app
        elif m_app_version > 1:
            method = 2  # app
            disabled_buttons = [1, 3]
        else:
            disabled_buttons = [1, 2, 3]
            method = 5  # other

        # -------------------------------
        # Call the patch option
        # Let the user select with Guidance
        # -------------------------------
        if self.config.offer_patch_methods:
            title = "Patching decision"
            buttons_text = ["Use Rooted Magisk", "Use Magisk Application", "Use UIAutomator", "Manual", "Other Magisk", "Cancel"]
            buttons_text[method -1] += " (Recommended)"
            if self.config.show_recovery_patching_option:
                checkboxes=["Delete temporary files", "Recovery" ]
                checkbox_initial_values=[True, False]
            else:
                checkboxes=["Delete temporary files"]
                checkbox_initial_values=[True]

            message = '''
**PixelFlasher** can create a patch by utilizing different methods.<br/>

This is a summary of available methods.<br/>

1. If already rooted, and root access is granted to adb, PixelFlasher can utilize magisk in /data/adb/magisk (core Magisk) and create a patch without user interaction.<br/>

2. If Magisk application is not hidden, PixelFlasher can unpack it and utilize it to create a patch without user interaction.<br/>

3. PixelFlasher can programmatically control (using UIAutomator) the user interface of the installed Magisk and click on buttons to create a patch.
This method is not supported on all phones, and is prone to problems due to timing issues, screen being locked, or user interacting with the screen while PixelFlasher is creating a patch.
This method is usually not recommended.<br/>

4. PixelFlasher can transfer the stock file to /sdcard/Download/ (can be customized), Launch Magisk, and prompt the user to select the file and create a patch.
PixelFlasher will wait for the user to complete the task and then hit OK to continue.
This method involves user interaction hence it is also not recommended, and it is only kept for power users.<br/>

5. PixelFlasher can create a patch from a Magisk App (apk) that you select and provide without installing the app.
This is handy when you want to create a patch using Magisk that is different than what is currently installed.
One common use case would be when you want to create a patch with an older version of Magisk.

Depending on the state of your phone (root, Magisk versions, Magisk hidden ...)
PixelFlasher will offer available choices and recommend the best method to utilize for patching.
Unless you know what you're doing, it is recommended that you take the default suggested selection.
'''
            message += f"<pre>Core Magisk Version:          {magisk_version}\n"
            message += f"Magisk Application Version:   {magisk_app_version}\n"
            message += f"Recommended Patch method:     Method {method}</pre>\n"
            clean_message = message.replace("<br/>", "").replace("</pre>", "").replace("<pre>", "")
            print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
            puml(":Dialog;\n", True)
            puml(f"note right\n{clean_message}\nend note\n")
            dlg = MessageBoxEx(
                parent=self,
                title=title,
                message=message,
                button_texts=buttons_text,
                default_button=method,
                disable_buttons=disabled_buttons,
                is_md=True,
                size=[800,660],
                checkbox_labels=checkboxes,
                checkbox_initial_values=checkbox_initial_values,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
            puml(f":User Pressed {buttons_text[result - 1]};\n")

            method = result
            if method == 6:
                puml("}\n")
                print("Aborting ...\n")
                return
            checkbox_values = get_dlg_checkbox_values()
            if checkbox_values is not None:
                if checkbox_values[0]:
                    delete_temp_files = True
                else:
                    delete_temp_files = False
                if len(checkbox_values) > 1 and checkbox_values[1]:
                    recovery = 'true'
                else:
                    recovery = 'false'
                print(f"Recovery: {recovery}")

    # Perform the patching
    if method == 1:
        patch_method = 'root'
        patched_img = patch_magisk_script("rooted")
    elif method == 2:
        patch_method = 'app'
        if not m_app_version:
            res = magisk_not_found()
            if res == -1:
                return
        patched_img = patch_magisk_script("app")
    elif method == 3:
        patch_method = 'ui-auto'
        if not m_app_version:
            res = magisk_not_found()
            if res == -1:
                return
        set_patched_with(device.magisk_app_version)
        patched_img = drive_magisk(self, boot_file_name=boot_img)
    elif method == 4:
        patch_method = 'manual'
        if not m_app_version:
            res = magisk_not_found()
            if res == -1:
                return
        set_patched_with(device.magisk_app_version)
        patched_img = manual_magisk(self, boot_file_name=boot_img)
    elif method == 5:
        patch_method = 'other'
        set_patched_with("Other")
        patched_img = patch_magisk_script("other")
    elif method == 80:
        # KernelSU
        patch_method = f'kernelsu_{chosen_kernel.lower()}'
        set_patched_with(kernelsu_version)
        patched_img = patch_kernelsu_script(kernelsu_version)
    elif method == 81:
        # KernelSU_LKM
        patch_method = 'kernelsu_lkm'
        # set_patched_with(ksu_app_version)
        patched_img, mountType = patch_kernelsu_lkm_script()
    elif method == 82:
        # KernelSU Next
        patch_method = f'kernelsu-next_{chosen_kernel.lower()}'
        set_patched_with(kernelsu_version)
        patched_img = patch_kernelsu_script(kernelsu_version)
    elif method == 83:
        # KernelSU_Next_LKM
        patch_method = 'kernelsu-next_lkm'
        # set_patched_with(ksu_app_version)
        patched_img, mountType = patch_kernelsu_lkm_script()
        patch_method = f"{patch_method}_{mountType}"
    elif method == 84:
        # SukiSU
        patch_method = f'sukisu_{chosen_kernel.lower()}'
        set_patched_with(kernelsu_version)
        patched_img = patch_kernelsu_script(kernelsu_version)
    elif method == 85:
        # SukiSU_LKM
        patch_method = 'sukisu_lkm'
        # set_patched_with(sukisu_app_version)
        patched_img, mountType = patch_kernelsu_lkm_script()
    elif method == 86:
        # Wild_KSU
        patch_method = f'wild_ksu_{chosen_kernel.lower()}'
        set_patched_with(kernelsu_version)
        patched_img = patch_kernelsu_script(kernelsu_version)
    elif method == 87:
        # Wild_KSU_LKM
        patch_method = 'wild_ksu_lkm'
        # set_patched_with(wild_ksu_app_version)
        patched_img, mountType = patch_kernelsu_lkm_script()
    elif method == 88:
        # KernelSU-Legacy
        patch_method = f'kernelsu_{chosen_kernel.lower()}'
        set_patched_with(kernelsu_version)
        patched_img = patch_kernelsu_script(kernelsu_version)
    elif method == 90:
        # APatch
        patch_method = 'apatch'
        # set_patched_with(apatch_app_version)
        patched_img = patch_apatch_script("app")
    elif method == 91:
        # APatch Alternate
        patch_method = 'apatch_manual'
        patched_img = patch_apatch_script("manual", kernel_patch_version)
    else:
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unexpected patch method.")
        puml("#red:Unexpected patch method;\nnote right:Abort\n}\n", True)
        print("Aborting ...\n")
        return
    if patched_img == -1:
        print("Aborting ...\n")
        puml("#red:Failed to patch\n}\n", True)
        return

    # -------------------------------
    # Validation Checks
    # -------------------------------
    # abort if patching failed
    if patched_img == -1:
        puml("}\n")
        return

    # check if patched_img got created.
    print(f"\nLooking for {patched_img} in {self.config.phone_path} ...")
    res, patched_file = device.check_file(f"{self.config.phone_path}/{patched_img}")
    if res != 1:
        print("Aborting ...\n")
        puml(f"#red:Failed to find {patch_name} on the phone;\n}}\n")
        return

    # Transfer back patched.img
    print(f"\nPulling {patched_file} from the phone to: {patched_img} ...")
    patched_img_file = os.path.join(tmp_dir_full, patched_img)
    res = device.pull_file(patched_file, f"\"{patched_img_file}\"")
    if res != 0:
        print("Aborting ...\n")
        puml(f"#red:Failed to pull {patched_file} from the phone;\n}}\n")
        return

    # get the checksum of the *_patched.img
    print(f"\nGetting SHA1 of {patched_img_file} ...")
    checksum = sha1(os.path.join(patched_img_file))
    print(f"SHA1 of {patched_img} file: {checksum}")

    # get source boot_file_name sha1
    print(f"\nGetting SHA1 of source {boot_file_name} ...")
    boot_sha1_long = sha1(boot_path)
    boot_sha1 = boot_sha1_long[:8]
    print(f"Source {boot_file_name}'s SHA1 is: {boot_sha1_long}")

    # check to make sure the patch sha1 is not the same as the source (stock) sha1
    if checksum == boot_sha1_long:
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Patching failed, {patched_file} SHA1 is the same as the stock SHA1")
        puml(f"#red:Patching failed;\nnote right:{patched_file} SHA1 is the same as the stock SHA1\n}}\n", True)
        print("Aborting ...\n")
        return

    if patch_flavor in ['Magisk', 'Custom']:
        # if rooted, get magisk's stored sha1 from it's config.
        if is_rooted:
            print("Getting SHA1 from Magisk config ...")
            magisk_sha1 = device.magisk_sha1
            print(f"Magisk Config's SHA1 is:   {magisk_sha1}")
            # compare it to the original boot_file_name file's sha1
            # print(f"Comparing source {boot_file_name} SHA1 with Magisk's config SHA1 (they should match) ...")
            # if boot_sha1_long != magisk_sha1:
            #     print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Something is wrong Magisk config has the wrong SHA1 ...")
            #     # fix it
            #     # res = device.update_magisk_config(boot_sha1_long)
            # else:
            #     print(f"Good: Both SHA1s: {boot_sha1_long} match.")
            # see if we have a Magisk backup
            print(f"\nChecking to see if Magisk made a backup of the source {boot_file_name}")
            magisk_backups = device.magisk_backups
            if magisk_backups and boot_sha1_long in magisk_backups:
                print("✅ Good: Magisk has made a backup")
                puml("#lightgreen:Magisk Backup: Success;\n")
            else:
                print(f"Magisk has NOT made a backup of the source {boot_file_name}")
                do_manual_backup = True
                if method == 1:
                    print("Triggering Magisk to create a backup ...")
                    # Trigger Magisk to make a backup
                    res = device.run_magisk_migration(boot_sha1_long)
                    if res != -2:
                        do_manual_backup = False
                    else:
                        print("Magisk did not make a backup, will do a manual backup.")
                if do_manual_backup:
                    # copy stock_boot from Downloads folder it already exists, and do it as su if rooted
                    stock_boot_path = '/data/adb/magisk/stock_boot.img'
                    print(f"Copying {boot_img} to {stock_boot_path} ...")
                    res = device.su_cp_on_device(f"{self.config.phone_path}/{boot_img}", stock_boot_path)
                    if res != 0:
                        print("Aborting Backup ...\n")
                    else:
                        # rerun the migration.
                        print("Triggering Magisk migration to create a backup ...")
                        res = device.run_magisk_migration(boot_sha1_long)
                        print(f"\nChecking to see if Magisk made a backup of the source {boot_file_name}")
                        magisk_backups = device.magisk_backups
                        if magisk_backups and boot_sha1_long in magisk_backups:
                            print("✅ Good: Magisk has made a backup")
                            puml("#lightgreen:Magisk Backup: Success;\n")
                        else:
                            print("It looks like backup was not made.")

        # Extract sha1 from the patched image
        print(f"\nExtracting SHA1 from {patched_img} ...")
        puml(f":Extract from {patched_img};\n", True)
        patched_sha1 = extract_sha1(patched_img_file, 40)
        if patched_sha1:
            print(f"SHA1 embedded in {patched_img_file} is: {patched_sha1}")
            print(f"Comparing source {boot_file_name} SHA1 with SHA1 embedded in {patched_img} (they should match) ...")
            if patched_sha1 != boot_sha1_long:
                max_name_length = max(len(patched_img), len(boot_file_name))
                # Left justify the filenames with spaces
                padded_patched_img = patched_img.ljust(max_name_length)
                padded_boot_file_name = boot_file_name.ljust(max_name_length)
                print("\nNOTICE: The two SHA1s did not match.")
                print(f"        {padded_patched_img} extracted sha1: {patched_sha1}")
                print(f"        {padded_boot_file_name}           sha1: {boot_sha1_long}")
                print("This could be normal due to compression\nChecking match confidence level.")
                puml(f"#cyan:SHA1 mismatch;\n")
                puml(f"note right\n")
                puml(f"{padded_patched_img} extracted sha1: {patched_sha1}\n")
                puml(f"{padded_boot_file_name}           sha1: {boot_sha1_long}\n")
                puml("end note\n")
                confidence = compare_sha1(patched_sha1, boot_sha1_long)
                print(f"The confidence level is: {confidence * 100}%")
                puml(f":Confidence level: {confidence * 100}%;\n")
                if confidence < 0.5:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Something is wrong with the patched file SHA1, we got a low match confidence.\n")
                    print("Please compare the two sha1 strings and decide for yourself if this is acceptable to use.")
                    puml(f"#red:ERROR: Something is wrong with the patched file\nSHA1: {patched_sha1}\nExpected SHA1: {boot_sha1};\n", True)
                    #return
                else:
                    print("Acceptable!")
            else:
                print(f"✅ Good: Both SHA1s: {patched_sha1} match.\n")
                puml(f"note right:SHA1 {patched_sha1} matches the expected value\n")
        else:
            print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} NOTICE: The patched image file does not contain source boot's SHA1")
            print("                            This is normal for older devices, but newer devices should have it.")
            print("                            If you have a newer device, please double check if everything is ok.\n ")
            puml("#orange:The patched image file does not contain source boot's SHA1;\n")
            puml(f"note right\nThis is normal for older devices, but newer devices should have it.\nend note\n")

    if patch_flavor == "Custom":
        # Display save as dialog to save the patched file
        with wx.FileDialog(self, "Save Patched Magisk File", '', f"{patched_img}", wildcard="Image files (*.img)|*.img", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                print(f"User Cancelled saving: {patched_img}")
                return     # the user changed their mind
            shutil.copy(patched_img_file, fileDialog.GetPath(), follow_symlinks=True)
    else:
        # if a matching patched.img is not found, store it.
        cached_boot_img_dir_full = os.path.join(boot_images, boot.boot_hash)
        if kernel_su_gz_file:
            # if kernel_su_gz_file is full path, just keep the file name (manual case)
            kernel_su_gz_file = os.path.basename(kernel_su_gz_file)
            # Append the chosen kernel details to the patched image name
            patched_img = f"{os.path.splitext(patched_img)[0]}_{os.path.splitext(kernel_su_gz_file)[0]}.img"
        cached_boot_img_path = os.path.join(cached_boot_img_dir_full, patched_img)
        debug(f"Checking for cached copy of {patched_img}")
        if not os.path.exists(cached_boot_img_path):
            debug(f"Cached copy of {patched_img} with sha1: {checksum} is not found.")
            debug(f"Copying {patched_img_file} to {cached_boot_img_path}")
            shutil.copy(patched_img_file, cached_boot_img_path, follow_symlinks=True)
        else:
            debug(f"Found a cached copy of {patch_name}.img sha1={checksum}\n")

        # create BOOT db record
        con = get_db_con()
        if con is None:
            return None
        cursor = con.cursor()
        is_init_boot = 1 if boot.is_init_boot else 0
        if patch_flavor in ['KernelSU', 'KernelSU-Next', 'APatch', 'APatch_manual', 'SukiSU', 'Wild_KSU', 'KernelSU-Legacy']:
            is_init_boot = 0
        sql = 'INSERT INTO BOOT (boot_hash, file_path, is_patched, magisk_version, hardware, epoch, patch_method, is_odin, is_stock_boot, is_init_boot, patch_source_sha1) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT (boot_hash) DO NOTHING'
        data = (checksum, cached_boot_img_path, 1, get_patched_with(), device.hardware, time.time(), patch_method, False, False, is_init_boot, boot_sha1_long)
        debug(f"Creating BOOT record, boot_hash: {checksum}")
        try:
            cursor.execute(sql, data)
            con.commit()
            boot_id = cursor.lastrowid
            debug(f"DB BOOT record ID: {boot_id}")
        except Exception as e:
            boot_id = 0
        # if we didn't insert in BOOT, see if we have a record for the boot being processed in case we need to insert a record into PACKAGE_BOOT
        if boot_id == 0:
            cursor.execute(f"SELECT ID FROM BOOT WHERE boot_hash = '{checksum}'")
            data = cursor.fetchall()
            if len(data) > 0:
                boot_id = data[0][0]
                debug(f"Found a previous BOOT record id={boot_id} for boot_hash: {checksum}\n")
            else:
                boot_id = 0
                debug(f"ERROR: Something went wrong while inserting BOOT record id={boot_id} for boot_hash: {checksum}\n")

        # create PACKAGE_BOOT db record
        if boot.package_id > 0 and boot_id > 0:
            debug(f"Creating PACKAGE_BOOT record, package_id: {boot.package_id} boot_id: {boot_id}")
            sql = 'INSERT INTO PACKAGE_BOOT (package_id, boot_id, epoch) values(?, ?, ?) ON CONFLICT (package_id, boot_id) DO NOTHING'
            data = (boot.package_id, boot_id, time.time())
            try:
                cursor.execute(sql, data)
                con.commit()
                package_boot_id = cursor.lastrowid
                debug(f"DB Package_Boot record ID: {package_boot_id}\n")
            except Exception as e:
                package_boot_id = 0

        set_db(con)

    # if Samsung firmware, create boot.tar
    if is_odin == 1 or self.config.create_boot_tar:
        print(f"Creating boot.tar from patched boot.img ...")
        puml(f":Create boot.tar;\n")
        shutil.copy(patched_img_file, os.path.join(tmp_dir_full, 'boot.img'), follow_symlinks=True)
        create_boot_tar(tmp_dir_full)
        if os.path.exists(os.path.join(tmp_dir_full, 'boot.tar')):
            print("boot.tar file created.")
            print(f"copying boot.tar to {package_dir_full} directory ...")
            shutil.copy(os.path.join(tmp_dir_full, 'boot.tar'), os.path.join(package_dir_full, 'boot.tar'), follow_symlinks=True)
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not create boot.tar file")
            puml("#red:ERROR: Could not create boot.tar;\n")

    end = time.time()
    if patch_flavor == "Magisk":
        print(f"\nMagisk Version:   {get_patched_with()}")
    elif patch_flavor in ["KernelSU", "KernelSU_LKM", "KernelSU-Legacy"]:
        print(f"\nKernelSU Version: {get_patched_with()}")
    elif patch_flavor in ["SukiSU", "SukiSU_LKM"]:
        print(f"\nSukiSU Version: {get_patched_with()}")
    elif patch_flavor in ["Wild_KSU", "Wild_KSU_LKM"]:
        print(f"\nWild_KSU Version: {get_patched_with()}")
    elif patch_flavor in ["KernelSU-Next", "KernelSU-Next_LKM"]:
        print(f"\nKernelSU-Next Version: {get_patched_with()}")
    elif patch_flavor == "APatch":
        print(f"\nAPatch Version:   {get_patched_with()}")
    else:
        print(f"\nCustom Patch:     {get_patched_with()}")
    print(f"Patched File:     {patched_img}")
    print(f"Patch time:       {math.ceil(end - start)} seconds")
    print("------------------------------------------------------------------------------\n")
    puml(f"#cee7ee:End {custom_text}Patching;\n", True)
    puml(f"note right:Patch time: {math.ceil(end - start)} seconds\n")
    puml("}\n")

    populate_boot_list(self)


# ============================================================================
#                               Function live_flash_boot_phone
# ============================================================================
def live_flash_boot_phone(self, option):  # sourcery skip: de-morgan
    puml(f"#cyan:{option} Boot;\n", True)
    puml(f"partition \"**{option} Boot**\"")
    puml(" {\n")

    print("")
    print("==============================================================================")
    print(f" {datetime.now():%Y-%m-%d %H:%M:%S} PixelFlasher {VERSION}             {option} Boot")
    print("==============================================================================")
    puml(":Flashing / Live Booting;\n", True)

    if not get_adb():
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Android Platform Tools must be set.")
        puml("#red:Valid Android Platform Tools is not selected;\n}\n")
        return -1

    device = get_phone(True)
    if not device:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
        puml("#red:Valid device is not selected;\n}\n")
        return -1

    boot = get_boot()
    if boot:
        print(f"Selected File:\n     {boot.boot_path} ...")
        puml(f"note right:File: {boot.boot_path};\n")
        if boot.is_patched:
            firmware_model = boot.hardware
        else:
            # Extract phone model from boot.package_sig
            package_sig_array = boot.package_sig.split("-")
            try:
                firmware_model = package_sig_array[0]
            except Exception as e:
                traceback.print_exc()
                firmware_model = None
        # Warn the user if it is not from the current phone model
        if not (len(device.hardware) >= 3 and device.hardware in firmware_model):
            title = _("%s Boot") % option
            message_en =  f"ERROR: Your phone model is: {device.hardware}\n\n"
            message_en += f"The selected Boot is for: {boot.hardware}\n\n"
            message_en += "Unless you know what you are doing, if you continue flashing\n"
            message_en += "you risk bricking your device, proceed only if you are absolutely\n"
            message_en += "certain that this is what you want, you have been warned.\n\n"
            message_en += "Click OK to accept and continue.\n"
            message_en += "or Hit CANCEL to abort."
            message =  _("ERROR: Your phone model is: %s\n\n") % device.hardware
            message += _("The selected Boot is for: %s\n\n") % boot.hardware
            message += _("Unless you know what you are doing, if you continue flashing\n")
            message += _("you risk bricking your device, proceed only if you are absolutely\n")
            message += _("certain that this is what you want, you have been warned.\n\n")
            message += _("Click OK to accept and continue.\n")
            message += _("or Hit CANCEL to abort.")
            print(f"\n*** Dialog ***\n{message_en}\n______________\n")
            puml("#orange:WARNING;\n", True)
            puml(f"note right\n{message_en}\nend note\n")
            dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
            result = dlg.ShowModal()
            if result == wx.ID_OK:
                print("User pressed ok.")
                puml(":User Pressed OK to continue;\n")
            else:
                print("User pressed cancel.")
                puml("#pink:User Pressed Cancel to abort;\n}\n")
                print("Aborting ...\n")
                return -1
    else:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to access boot object, aborting ...\n")
        puml("#red:Unable to access boot object\n}\n")
        return -1

    # Make sure boot exists
    if not boot.boot_path:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to get boot.img path, aborting ...\n")
        puml("#red:Unable to get boot image path;\n}\n")
        return -1

    boot_dir = os.path.dirname(boot.boot_path)
    boot_img_path = boot.boot_path
    boot_hash = boot.boot_hash
    if boot.is_init_boot:
        partition = "init_boot"
    else:
        partition = "boot"
    # Get the actual selected boot partition in case of vendor_boot patch
    selected_boot_partition = get_selected_boot_partition()
    if selected_boot_partition:
        partition = selected_boot_partition

    boot_file = os.path.join(boot_dir, "boot.img")
    init_boot_file = os.path.join(boot_dir, "init_boot.img")
    vendor_boot_file = os.path.join(boot_dir, "vendor_boot.img")
    selected_image = ntpath.basename(boot_img_path)
    selected_dir = os.path.dirname(boot_img_path)

    # setup the dialog options
    title = f"{option} Boot"
    message = ""
    size = (940, 440)
    button_texts = [_("OK"), _("Cancel")]
    radio_labels = [_('Flash to active slot'), _('Flash to inactive slot'), _('Flash to both slots')]
    checkbox_labels = [_('Flash boot partition'), _('Flash init_boot partition'), _('Flash vendor_boot partition')]
    checkbox_labels2 = [_('No Reboot after flash'), _('Flash stock to other partitions (if available)')]
    checkbox_initial_values = [False, False, False]
    disable_checkboxes = None
    checkbox_initial_values2 = [False]
    disable_checkboxes2 = None
    radio_initial_value = 0
    disable_radios = None
    disable_buttons = None

    if not device.active_slot in ['a', 'b']:
        disable_radios = [2, 3]

    if option == 'Live':
        # Live option
        flash_string = ""
        disable_checkboxes2 = [1, 2]  # no reboot doesn't make sense for live booting, same with flashing stock to other partitions
        checkbox_initial_values2=[False]
        disable_radios = [1, 2, 3]
        disable_checkboxes = [1, 2, 3]

        if boot.is_patched != 1 and os.path.exists(os.path.join(selected_dir, "boot.img")):
            checkbox_initial_values=[True, False, False]
            partition = "boot"
            selected_image = "boot.img"
            message += _("## ✅ Live Boot the stock image:\n")
        elif os.path.exists(boot_file) and partition == "boot" and boot.is_patched == 1:
            checkbox_initial_values=[True, False, False]
            message += _("## ✅ Live Boot the patched image:\n")
        else:
            checkbox_initial_values=[False, False, False]
            disable_buttons = [1]
            radio_initial_value = None
            if partition != "boot":
                message += _("## ❌ Live Booting is only supported for boot partition.\n")
            else:
                message += _("## ❌ Valid image is not found that supports live booting.\n")
    else:
        # Flash option
        flash_string = "flash"
        if boot.is_patched != 1:
            disable_checkboxes2 = [2]  # flashing stock to other partitions doesn't make sense if the image is stock
            # stock
            disable_checkboxes = []  # Initialize as empty list
            if os.path.exists(boot_file):
                checkbox_initial_values[0] = True
            else:
                disable_checkboxes.append(1)
            if os.path.exists(init_boot_file):
                checkbox_initial_values[1] = True
            else:
                disable_checkboxes.append(2)
            if os.path.exists(vendor_boot_file):
                checkbox_initial_values[2] = True
            else:
                disable_checkboxes.append(3)
            # Convert to None if empty, or keep the list if it has items
            disable_checkboxes = disable_checkboxes if disable_checkboxes else None
            message += _("## ℹ️ Select partitions that you wish to flash stock image\n")
        else:
            # patched
            flash_message = _("## ℹ️ Select the options to flash a patch image:\n")
            disable_checkboxes = [1, 2, 3]
            if partition == "boot" and os.path.exists(boot_file):
                checkbox_initial_values=[True, False, False]
            elif partition == "init_boot" and os.path.exists(init_boot_file):
                checkbox_initial_values=[False, True, False]
            elif partition == "vendor_boot" and os.path.exists(vendor_boot_file):
                checkbox_initial_values=[False, False, True]
            else:
                checkbox_initial_values=[False, False, False]
                disable_buttons = [1]
                radio_initial_value = None
                disable_radios = [1, 2, 3]
                flash_message = _("## ❌ The selected image is not valid.<br/>\n")
            message += flash_message

    # Additional message details
    message += f"<pre>Option:                 {option}\n"
    message += f"Partition:              {partition}\n"
    message += f"Image SHA1:             {boot_hash}\n"
    message += f"Hardware:               {device.hardware}\n"
    # Add additional image details
    if boot.is_patched == 1:
        message += "Patched:                Yes\n"
        if boot.patch_method:
            message += f"Patched Method:         {boot.patch_method}\n"
        if boot.patch_source_sha1:
            message += f"Patch Source SHA1:      {boot.patch_source_sha1}\n"
        if boot.patch_method in ["kernelsu", "kernelsu_lkm"]:
            message += f"Patched With KernelSU:  {boot.magisk_version}\n"
        elif boot.patch_method in ["sukisu", "sukisu_lkm"]:
            message += f"Patched With SukiSU:    {boot.magisk_version}\n"
        elif boot.patch_method in ["wild_ksu", "wild_ksu_lkm"]:
            message += f"Patched With Wild_KSU:  {boot.magisk_version}\n"
        elif "kernelsu-next" in boot.patch_method:
            message += f"Patched With KSU-Next:  {boot.magisk_version}\n"
        elif "apatch" in boot.patch_method:
            message += f"Patched With Apatch:    {boot.magisk_version}\n"
        else:
            message += f"Patched With Magisk:    {boot.magisk_version}\n"
        message += f"Patched on Device:      {boot.hardware}\n"
        message += f"Source Image from:      {boot.package_sig}\n"
    else:
        message += "Patched:                No\n"
    if device.active_slot in ['a', 'b']:
        message += f"Current Slot:           {device.active_slot}\n"
    message += f"Selected Image:         {selected_image}</pre>\n"

    clean_message = message.replace("<br/>", "").replace("</pre>", "").replace("<pre>", "")
    print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
    puml(f":{option} Boot;\n", True)
    puml(f"note right\nDialog\n====\n{clean_message}\nend note\n")
    set_message_box_title(title)
    set_message_box_message(message)

    dlg = MessageBoxEx(
        parent=None,
        title=title,
        message=message,
        button_texts=button_texts,
        default_button=1,
        disable_buttons=disable_buttons,
        is_md=True,
        size=size,
        checkbox_labels=checkbox_labels,
        checkbox_initial_values=checkbox_initial_values,
        disable_checkboxes=disable_checkboxes,
        vertical_checkboxes=False,
        checkbox_labels2=checkbox_labels2,
        checkbox_initial_values2=checkbox_initial_values2,
        disable_checkboxes2=disable_checkboxes2,
        radio_labels=radio_labels,
        radio_initial_value=radio_initial_value,
        disable_radios=disable_radios,
        vertical_radios=False
    )
    dlg.CentreOnParent(wx.BOTH)
    result = dlg.ShowModal()

    # Get all dialog return values before destroying the dialog
    dialog_values = get_all_dialog_values(dlg)
    dlg.Destroy()

    # Extract values from dialog_values for consistent access
    selected_radio_index = dialog_values.get('radio')
    checkbox_values = dialog_values.get('checkboxes')
    checkbox_values2 = dialog_values.get('checkboxes2')

    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {button_texts[result -1]}")
    if result == 2:
        print("Aborting ...\n")
        puml("#pink:User Pressed Cancel to abort;\n}\n")
        return -1
    print(f"dialog values: {dialog_values}")

    device = get_phone()
    if not device:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to detect the device.")
        print("You can try scanning for devices and selecting your device (it should be in bootloader mode).")
        print(f"and then press the same {option} button again.")
        puml("#red:Valid device is not detected;\n")
        puml(f"note right\nYou can try scanning for devices and selecting your device (it should be in bootloader mode).\nand then press the same {option} button again.\nend note\n")
        puml("}\n")
        self.clear_device_selection()
        return -1
    device_id = device.id

    # build the script
    config_path = get_config_path()
    tmp_dir = os.path.join(config_path, 'tmp')

    flash_pf_file_win = os.path.join(tmp_dir, "flash-boot.bat")
    flash_pf_file_linux = os.path.join(tmp_dir, "flash-boot.sh")
    cp = None
    if self.config.force_codepage:
        cp = str(self.config.custom_codepage)
        if cp == '':
            cp = None
    else:
        # don't use system codepage, use UTF-8 if not set
        # cp = get_system_codepage()
        cp = "65001"
    if cp:
        first_line_win = f"\nchcp {cp}\n@ECHO OFF\n"
    else:
        first_line_win = f"@ECHO OFF\n"
    first_line_linux = "#!/bin/sh\n"

    version_sig_win = f":: This is a generated file by PixelFlasher v{VERSION}\n:: Android Platform Tools Version: {get_sdk_version()}\n:: Device is rooted: {device.rooted}\n\n"
    version_sig_linux = f"# This is a generated file by PixelFlasher v{VERSION}\n# Android Platform Tools Version: {get_sdk_version()}\n# Device is rooted: {device.rooted}\n\n"

    # delete previous flash-boot.bat file if it exists
    if os.path.exists(flash_pf_file_win):
        os.remove(flash_pf_file_win)

    # delete previous flash-boot.sh file if it exists
    if os.path.exists(flash_pf_file_linux):
        os.remove(flash_pf_file_linux)

    data_win = ''
    data_linux = ''

    # create flash-boot.bat/sh based on the live / flash options.
    f_win = open(flash_pf_file_win.strip(), "w", encoding="ISO-8859-1", errors="replace")
    f_linux = open(flash_pf_file_linux.strip(), "w", encoding="ISO-8859-1", errors="replace")
    data_win = first_line_win
    data_linux = first_line_linux
    data_win += version_sig_win
    data_linux += version_sig_linux
    data_win += r'PATH=%PATH%;"%SYSTEMROOT%\System32"' + "\n\n"

    if boot.is_patched != 1:
        boot_to_flash = os.path.join(selected_dir, "boot.img")
        init_boot_to_flash = os.path.join(selected_dir, "init_boot.img")
        vendor_boot_to_flash = os.path.join(selected_dir, "vendor_boot.img")
    else:
        boot_to_flash = boot_img_path
        init_boot_to_flash = boot_img_path
        vendor_boot_to_flash = boot_img_path

    # Live
    if option == 'Live' and checkbox_values and checkbox_values[0]:
        data_win += "echo Live Booting boot partition ... \n"
        data_win += f"\"{get_fastboot()}\" -s {device_id} boot \"{boot_to_flash}\"\n\n"
        data_linux += "echo Live Booting boot partition ... \n"
        data_linux += f"\"{get_fastboot()}\" -s {device_id} boot \"{boot_to_flash}\"\n\n"

    # Flash
    else:
        # if boot is selected
        if checkbox_values and checkbox_values[0]:
            if selected_radio_index == 0:
                # active slot
                data_win += "echo Flashing boot partition to active slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{boot_to_flash}\"\n"

                data_linux += "echo Flashing boot partition to active slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{boot_to_flash}\"\n"
            elif selected_radio_index == 1:
                # inactive slot
                data_win += "echo Flashing boot partition to inactive slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{boot_to_flash}\"\n"

                data_linux += "echo Flashing boot partition to inactive slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{boot_to_flash}\"\n"
            elif selected_radio_index == 2:
                # both slots
                data_win += "echo Flashing boot partition to active slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{boot_to_flash}\"\n"
                data_win += "echo Flashing boot partition to inactive slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{boot_to_flash}\"\n"

                data_linux += "echo Flashing boot partition to active slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{boot_to_flash}\"\n"
                data_linux += "echo Flashing boot partition to inactive slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{boot_to_flash}\"\n"
            data_win += "\n"
            data_linux += "\n"
            # If flash stock to other partitions is selected
            if checkbox_values2 and checkbox_values2[1]:
                if selected_radio_index == 0:
                    if os.path.exists(init_boot_to_flash):
                        data_win += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                    if os.path.exists(vendor_boot_to_flash):
                        data_win += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                elif selected_radio_index == 1:
                    if os.path.exists(init_boot_to_flash):
                        data_win += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                    if os.path.exists(vendor_boot_to_flash):
                        data_win += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                elif selected_radio_index == 2:
                    if os.path.exists(init_boot_to_flash):
                        data_win += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                        data_win += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                        data_linux += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                    if os.path.exists(vendor_boot_to_flash):
                        data_win += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                        data_win += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                        data_linux += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                data_win += "\n"
                data_linux += "\n"

        # if init_boot is selected
        if checkbox_values and checkbox_values[1]:
            if selected_radio_index == 0:
                # active slot
                data_win += "echo Flashing init_boot partition to active slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{init_boot_to_flash}\"\n"

                data_linux += "echo Flashing init_boot partition to active slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{init_boot_to_flash}\"\n"
            elif selected_radio_index == 1:
                # inactive slot
                data_win += "echo Flashing init_boot partition to inactive slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{init_boot_to_flash}\"\n"

                data_linux += "echo Flashing init_boot partition to inactive slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{init_boot_to_flash}\"\n"
            elif selected_radio_index == 2:
                # both slots
                data_win += "echo Flashing init_boot partition to active slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{init_boot_to_flash}\"\n"
                data_win += "echo Flashing init_boot partition to inactive slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{init_boot_to_flash}\"\n"

                data_linux += "echo Flashing init_boot partition to active slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{init_boot_to_flash}\"\n"
                data_linux += "echo Flashing init_boot partition to inactive slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{init_boot_to_flash}\"\n"
            data_win += "\n"
            data_linux += "\n"
            # If flash stock to other partitions is selected
            if checkbox_values2 and checkbox_values2[1]:
                if selected_radio_index == 0:
                    if os.path.exists(boot_to_flash):
                        data_win += "echo Flashing stock boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                    if os.path.exists(vendor_boot_to_flash):
                        data_win += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                if selected_radio_index == 1:
                    if os.path.exists(boot_to_flash):
                        data_win += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                    if os.path.exists(vendor_boot_to_flash):
                        data_win += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                if selected_radio_index == 2:
                    if os.path.exists(boot_to_flash):
                        data_win += "echo Flashing stock boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                        data_win += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                        data_linux += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                    if os.path.exists(vendor_boot_to_flash):
                        data_win += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                        data_win += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock vendor_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                        data_linux += "echo Flashing stock vendor_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{os.path.join(selected_dir, "vendor_boot.img")}\"\n\n"
                data_win += "\n"
                data_linux += "\n"

        # if vendor_boot is selected
        if checkbox_values and checkbox_values[2]:
            if selected_radio_index == 0:
                # active slot
                data_win += "echo Flashing vendor_boot partition to active slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{vendor_boot_to_flash}\"\n"

                data_linux += "echo Flashing vendor_boot partition to active slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{vendor_boot_to_flash}\"\n"
            elif selected_radio_index == 1:
                # inactive slot
                data_win += "echo Flashing vendor_boot partition to inactive slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{vendor_boot_to_flash}\"\n"

                data_linux += "echo Flashing vendor_boot partition to inactive slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{vendor_boot_to_flash}\"\n"
            if selected_radio_index == 2:
                # both slots
                data_win += "echo Flashing vendor_boot partition to active slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{vendor_boot_to_flash}\"\n"
                data_win += "echo Flashing vendor_boot partition to inactive slot ... \n"
                data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{vendor_boot_to_flash}\"\n"

                data_linux += "echo Flashing vendor_boot partition to active slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} flash vendor_boot \"{vendor_boot_to_flash}\"\n"
                data_linux += "echo Flashing vendor_boot partition to inactive slot ... \n"
                data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash vendor_boot \"{vendor_boot_to_flash}\"\n"
            data_win += "\n"
            data_linux += "\n"
            # If flash stock to other partitions is selected
            if checkbox_values2 and checkbox_values2[1]:
                if selected_radio_index == 0:
                    if os.path.exists(boot_to_flash):
                        data_win += "echo Flashing stock boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                    if os.path.exists(init_boot_to_flash):
                        data_win += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                if selected_radio_index == 1:
                    if os.path.exists(boot_to_flash):
                        data_win += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                    if os.path.exists(init_boot_to_flash):
                        data_win += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                if selected_radio_index == 2:
                    if os.path.exists(boot_to_flash):
                        data_win += "echo Flashing stock boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                        data_win += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                        data_linux += "echo Flashing stock boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash boot \"{os.path.join(selected_dir, "boot.img")}\"\n\n"
                    if os.path.exists(init_boot_to_flash):
                        data_win += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                        data_win += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_win += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"

                        data_linux += "echo Flashing stock init_boot partition to active slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                        data_linux += "echo Flashing stock init_boot partition to inactive slot ... \n"
                        data_linux += f"\"{get_fastboot()}\" -s {device_id} --slot other flash init_boot \"{os.path.join(selected_dir, "init_boot.img")}\"\n\n"
                data_win += "\n"
                data_linux += "\n"

    # save the scripts
    f_win.write(data_win)
    f_win.close()
    f_linux.write(data_linux)
    f_linux.close()

    # make the sh script executable
    if sys.platform != "win32":
        data = data_linux
        flash_pf_file = flash_pf_file_linux
        theCmd = f"chmod 755 \"{flash_pf_file_linux}\""
        debug(theCmd)
        res = run_shell(theCmd)
        if res and isinstance(res, subprocess.CompletedProcess):
            debug(f"Return Code: {res.returncode}")
            debug(f"Stdout: {res.stdout}")
            debug(f"Stderr: {res.stderr}")
            if res.returncode != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set the permissions on {flash_pf_file_linux}")
                print("Aborting ...\n")
                puml("#red:Could not set the permissions on flash script;\n}\n")
                return -1
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set the permissions on {flash_pf_file_linux}")
            print("Aborting ...\n")
            puml("#red:Could not set the permissions on flash script;\n}\n")
            return -1
    else:
        data = data_win
        flash_pf_file = flash_pf_file_win

    title = f"{option} Boot - Confirm Flash"
    message = "\nNote: Pressing OK button will invoke a script that will utilize\n"
    message += "fastboot commands, this could possibly take a long time and PixelFlasher\n"
    message += "will appear frozen. PLEASE BE PATIENT. \n"
    message += "In case it takes excessively long, it could possibly be due to improper or\n"
    message += "faulty fastboot drivers.\n"
    message += "In such cases, killing the fastboot process will resume to normalcy.\n\n"
    message += "Do you want to continue to flash with the above options?\n"
    message += "You can also choose to edit the script before continuing,\nin case you want to customize it.(Only choose this if you know what you are doing)\n\n"
    message += "Press OK to continue or CANCEL to abort.\n"
    print(f"\n*** Dialog ***\n{message}\n______________\n")
    print(f"The script content that will be executed:")
    print(f"___________________________________________________\n{data}")
    print("___________________________________________________\n")
    puml(":Dialog;\n", True)
    puml(f"note right\n{message}\nend note\n")
    puml(":Script;\n")
    puml(f"note right\nFlash Script\n====\n{data}\nend note\n")
    try:
        dlg = MessageBoxEx(
            parent=None,
            title=title,
            message=message,
            button_texts=[_("OK"), _("Edit script before continuing"), _("Cancel")],
            default_button=1,
            disable_buttons=None,
            is_md=False,
            size=(800, 600),
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=None,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()
        dlg.Destroy()
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
        traceback.print_exc()

    if result == 1: # OK
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
        puml(":User Pressed OK;\n")
        # continue flashing
    elif result == 2: # Edit
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Edit Script.")
        puml("#pink:User Pressed Edit Script;\n")
        dlg = FileEditor(self, flash_pf_file, "batch", width=1500, height=600)
        dlg.CenterOnParent()
        result = dlg.ShowModal()
        dlg.Destroy()
        if result == wx.ID_OK:
            # get the contents of modified flash_pf_file
            with open(flash_pf_file, 'r', encoding='ISO-8859-1', errors="replace") as f:
                contents = f.read()
            print(f"\nflash_boot file has been modified!")
            print(f"The modified script content that will be executed:")
            print(f"___________________________________________________\n{contents}")
            print("___________________________________________________\n")
            puml(f"note right\nModified Script\n====\n{contents}\nend note\n")
            # continue flashing
        else:
            print("User cancelled editing flash_boot file.")
            puml(f"note right\nCancelled and Aborted\nend note\n")
            return -1
    elif result == 3: # Cancel
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
        print("Aborting ...\n")
        puml("#pink:User Pressed Cancel;\n}\n")
        return -1

    # reboot to bootloader if needed
    mode = device.get_device_state()
    if mode in ['adb', 'recovery', 'sideload'] and get_adb():
        self.refresh_device(device_id)
        device = get_phone()
        if device:
            res = device.reboot_bootloader()
            if res == 0:
                mode = "fastboot"
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                self.clear_device_selection()
                bootloader_issue_message()
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to detect the device, aborting ...\n")
            puml(f"note right\nERROR: Unable to detect the device, aborting...\nend note\n")
            puml("}\n")
            self.clear_device_selection()
            return -1

    done_flashing = False
    if mode == 'fastboot' and get_fastboot():
        # Check for bootloader unlocked
        if self.config.check_for_bootloader_unlocked:
            res = is_device_unlocked(self, device)
            if res == -1:
                # Device is not detected
                print("Aborting ...\n")
                puml("#red:Device is not detected;\n}\n")
                self.toast(_("Flash action"), _("❌ Device is not detected."))
                return -1
            elif res == 0:
                self.toast(_("Flash action"), _("❌ Bootloader is locked, cannot flash."))
                dlg = MessageBoxEx(
                    parent=None,
                    title=_("Error"),
                    message=_("Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"),
                    button_texts=[_("Yes"), _("No")],
                    default_button=2,
                    disable_buttons=None,
                    is_md=False,
                    size=(800, 600),
                    checkbox_labels=None,
                    checkbox_initial_values=None,
                    disable_checkboxes=None,
                    vertical_checkboxes=False,
                    checkbox_labels2=None,
                    checkbox_initial_values2=None,
                    disable_checkboxes2=None,
                    radio_labels=None,
                    radio_initial_value=None,
                    disable_radios=None,
                    vertical_radios=False
                )
                result = dlg.ShowModal()
                dlg.Destroy()
                if result != 1:
                    print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} User chose not to proceed.")
                    print("Aborting ...\n")
                    puml("#red:Bootloader is locked, can't flash;\n}\n")
                    return -1
                else:
                    print("❌ Bootloader is locked, but user chose to proceed ...")
            else:
                print("✅ Bootloader is unlocked, continuing ...")
        else:
            print("⚠️ Skipping bootloader unlock check ...")

        startFlash = time.time()

        # -------------------------------------------------------------------------
        # Run the script
        # -------------------------------------------------------------------------
        print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Flashing boot: {device_id} ...")
        puml(f":Flashing boot: {device_id};\n", True)
        theCmd = flash_pf_file
        theCmd = f"\"{theCmd}\""
        debug(theCmd)
        res = run_shell2(theCmd, chcp=cp)
        if res and isinstance(res, subprocess.CompletedProcess):
            debug(f"Return Code: {res.returncode}")
            debug(f"Stdout: {res.stdout}")
            debug(f"Stderr: {res.stderr}")
            if res.returncode != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while running flash boot script.")
                print("Aborting ...\n")
                puml("#red:Encountered an error while running flash script.;\n}\n")
                self.toast(_("Flash action"), _("❌ Encountered an error while running the flash boot script."))
                return -1
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while running flash boot script.")
            print("Aborting ...\n")
            puml("#red:Encountered an error while running flash script.;\n}\n")
            self.toast(_("Flash action"), _("❌ Encountered an error while running the flash boot script."))
            return -1
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Done flash boot script execution!")
        puml(f":Done flash bootscript execution;\n", True)

        endFlash = time.time()
        print(f"Flashing elapsed time: {math.ceil(endFlash - startFlash)} seconds")
        print("------------------------------------------------------------------------------\n")
        done_flashing = True
        if option == 'Live':
            res = device.adb_wait_for(timeout=60, wait_for='device')
            update_phones(device.id)
            self.refresh_device(device_id)
            message_after_flashing()
            return
        elif option == 'Flash' and not checkbox_values2[0]:
            puml(":Reboot to System;\n")
            device.reboot_system()
    else:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device: {device.id} not in bootloader mode.")
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Aborting ...\n")
        puml("#red:Device is not in bootloader mode;\n}\n")

    puml(f"#cee7ee:End {option} Boot;\n", True)
    if done_flashing:
        puml(f"note right:Flashing elapsed time: {math.ceil(endFlash - startFlash)} seconds\n")
    puml("}\n")
    self.refresh_device(device_id)
    message_after_flashing()
    return


# ============================================================================
#                               Function flash_phone
# ============================================================================
def flash_phone(self):
    try:
        # 1 Do the necessary validations
        # 2 Prepare the necessary script contents
        # 3 Put the device in the correct state (bootloader / sideload / fastbootd)
        # 4 Run the script
        # 5 Finish up Do the additional checks and flashing / rebooting

        puml("#cyan:Flash Firmware;\n", True)
        puml("partition \"**Flash Firmware**\" {\n")
        temp_dir = None

        # -------------------------------------------------------------------------
        # 1 Do the necessary validations
        # -------------------------------------------------------------------------
        # check for platform tools
        if not get_adb():
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Android Platform Tools must be set.\n")
            puml("#red:Android Platform Tools is not set;\n}\n")
            self.toast(_("Flash action"), _("❌ Android Platform Tools is not set."))
            return -1

        # check for device
        device = get_phone(True)
        if not device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid adb device.")
            puml("#red:Valid device is not selected;\n}\n")
            self.toast(_("Flash action"), _("❌ Valid device is not selected."))
            return -1
        device_id = device.id

        # check for boot selection except for custom flash
        if self.config.flash_mode != 'customFlash':
            boot = get_boot()
            if not boot:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select boot file.")
                puml("#red:boot is not selected;\n}\n")
                self.toast(_("Flash action"), _("❌ boot is not selected."))
                return -1

        # Check if we're flashing older OTA
        if self.config.flash_mode == 'OTA':
            print("Checking OTA version against the currently installed firmware.")
            print(f"Firmware ID:                  {get_firmware_id()}")
            print(f"Currently installed firmware: {device.build}")
            pattern1 = r'(?:.*)-(?:.*)-(?:.*)\.(\d{6})\.(?:.*)'
            pattern2 = r'(?:.*)\.(\d{6})\.(?:.*)'
            match1 = re.search(pattern1, get_firmware_id())
            match2 = re.search(pattern2, device.build)
            if match1 and match2:
                number1 = int(match1.group(1))
                number2 = int(match2.group(1))
                if boot.spl:
                    boot_spl_date = datetime.strptime(boot.spl, "%Y-%m-%d")
                    boot_spl_formatted = int(boot_spl_date.strftime("%y%m%d"))
                else:
                    boot_spl_formatted = 99999999
                print(f"OTA date:                     {number1}")
                print(f"Current firmware date:        {number2}")
                print(f"Target SPL:                   {boot_spl_formatted}")
                print(f"Target Fingerprint:           {boot.fingerprint}\n")
                if number1 < number2 and boot_spl_formatted < number2:
                    message_en = "You can only sideload OTA that is equal or higher than the currently installed version.\n"
                    message_en += "Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n"
                    message_en += "See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n"
                    message_en += "If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n"
                    message = _("You can only sideload OTA that is equal or higher than the currently installed version.\n")
                    message += _("Alternatively, you can flash the full firmware image (with wipe data) to downgrade or patch the current boot image to allow a downgrade without wipe.\n")
                    message += _("See Menu item: Dev Tools | AVB Prepare Downgrade Patch for further details.\n\n")
                    message += _("If you still want to proceed, Click YES to accept and continue. or NO to Abort.\n")
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {message_en}")
                    puml("#red:You can only sideload OTA that is equal or higher than the currently installed version.;\n}\n")
                    dlg = wx.MessageDialog(None, message, _("Confirm"),wx.YES_NO | wx.ICON_EXCLAMATION)
                    result = dlg.ShowModal()
                    if result != wx.ID_YES:
                        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled patching.")
                        puml("#pink:User cancelled patching;\n}\n")
                        return -1
                    else:
                        print("User accepted to proceed.")

        # confirm for wipe data
        wipe_flag = False
        if self.config.flash_mode == 'wipeData':
            print("Flash Mode: Wipe Data")
            puml(f":Flash Mode: Wipe Data;\n")
            dlg = wx.MessageDialog(None, _("You have selected to WIPE data\nAre you sure want to continue?"), _("Wipe Data"), wx.YES_NO | wx.ICON_EXCLAMATION)
            puml(f"note right\nDialog\n====\nYou have selected to WIPE data\nAre you sure want to continue?\nend note\n")
            result = dlg.ShowModal()
            if result != wx.ID_YES:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled flashing.")
                puml("#pink:User cancelled flashing;\n}\n")
                return -1
            self.toast(_("Flash action"), _("✅ Wipe Data is accepted."))
            wipe_flag = True
        # confirm for wipe flag
        if self.config.advanced_options and self.wipe:
            print("Flash Option: Wipe")
            dlg = wx.MessageDialog(None, _("You have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?"), _("Flash option: Wipe"), wx.YES_NO | wx.ICON_EXCLAMATION)
            puml(f"note right\nDialog\n====\nYou have selected the flash option: Wipe\nThis will wipe your data\nAre you sure want to continue?\nend note\n")
            result = dlg.ShowModal()
            if result != wx.ID_YES:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled flashing.")
                puml("#pink:User cancelled flashing;\n}\n")
                return -1
            self.toast(_("Flash action"), _("✅ Wipe is accepted."))
            wipe_flag = True
        # confirm for force flag
        elif self.config.advanced_options and self.config.fastboot_force and self.config.flash_mode != 'OTA':
            print("Flash Option: Force")
            dlg = wx.MessageDialog(None, _("You have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?"), _("Flash option: Force"), wx.YES_NO | wx.ICON_EXCLAMATION)
            puml(f"note right\nDialog\n====\nYou have selected the flash option: Force\nThis will wipe your data\nAre you sure want to continue?\nend note\n")
            result = dlg.ShowModal()
            if result != wx.ID_YES:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled flashing.")
                puml("#pink:User cancelled flashing;\n}\n")
                return -1
            self.toast(_("Flash action"), _("✅ Force flag is accepted."))
        # confirm for both slots flash
        if self.config.flash_both_slots and self.config.flash_mode != 'OTA':
            print("Flash Option: Flash to both slots")
            dlg = wx.MessageDialog(None, _("You have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?"), _("Flash option: Flash to both slots"), wx.YES_NO | wx.ICON_EXCLAMATION)
            puml(f"note right\nDialog\n====\nYou have selected the flash option: Flash to both slots\nPlease make sure your device is not subject to ARB concerns.\nAre you sure want to continue?\nend note\n")
            result = dlg.ShowModal()
            if result != wx.ID_YES:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User canceled flashing.")
                puml("#pink:User cancelled flashing;\n}\n")
                return -1
            self.toast(_("Flash action"), _("✅ Flash to both slots is accepted."))

        # set some variables
        slot_before_flash = device.active_slot
        cwd = os.getcwd()
        config_path = get_config_path()
        factory_images = os.path.join(config_path, 'factory_images')
        temp_dir = None

        if self.config.advanced_options and self.config.flash_mode == 'customFlash':
            package_dir_full = os.path.join(config_path, 'tmp')
        else:
            # check for free space >= 5G
            if self.config.check_for_disk_space and (get_free_space() < 5 or get_free_space(get_config_path()) < 5):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Please check available disk space, you do not have safe levels of available storage to flash without risk.")
                print("Aborting ...\n")
                puml("#red:Not enough disk space;\n}\n")
                self.toast(_("Flash action"), _("❌ Not enough disk space."))
                return -1

            # check for package selection
            package_sig = get_firmware_id()
            if not package_sig:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a OTA or factory firmware file.")
                puml("#red:Factory OTA or firmware is not selected;\n}\n")
                self.toast(_("Flash action"), _("❌ Full OTA or factory image must be selected."))
                return -1

            # check for bootloader rollback protection issue on 'raven', 'oriole', 'bluejay'
            if (
                get_firmware_model() in ['raven', 'oriole', 'bluejay']
                and device.api_level
                and int(device.api_level) < 33
                and not (self.config.advanced_options and self.config.flash_both_slots)
            ):
                title = _("Tensor device not on Android 13 or higher")
                message_en =  "WARNING: Your phone OS version is lower than Android 13.\n\n"
                message_en += "If you are upgrading to Android 13 or newer,\n"
                message_en += "make sure you at least flash the bootloader to both slots.\n"
                message_en += "The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n"
                message_en += "a bootloader update that increments the anti-roll back version for the bootloader.\n"
                message_en += "This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n"
                message_en += "After flashing an Android 13 build on these devices\n"
                message_en += "you will not be able to flash and boot older Android 12 builds.\n\n"
                message_en += "Selecting the option 'Flash to both slots'\n"
                message_en += "Will take care of that.\n\n"
                message_en += "Click OK to continue as is.\n"
                message_en += "or Hit CANCEL to abort and change options."
                message =  _("WARNING: Your phone OS version is lower than Android 13.\n\n")
                message += _("If you are upgrading to Android 13 or newer,\n")
                message += _("make sure you at least flash the bootloader to both slots.\n")
                message += _("The Android 13 update for Pixel 6, Pixel 6 Pro, and the Pixel 6a contains\n")
                message += _("a bootloader update that increments the anti-roll back version for the bootloader.\n")
                message += _("This prevents the device from rolling back to previous vulnerable versions of the bootloader.\n")
                message += _("After flashing an Android 13 build on these devices\n")
                message += _("you will not be able to flash and boot older Android 12 builds.\n\n")
                message += _("Selecting the option 'Flash to both slots'\n")
                message += _("Will take care of that.\n\n")
                message += _("Click OK to continue as is.\n")
                message += _("or Hit CANCEL to abort and change options.")
                puml(":API < 33 and device is Tensor;\n")
                puml(f"note right\nDialog\n====\n{message_en}\nend note\n")
                print(f"\n*** Dialog ***\n{message_en}\n______________\n")
                dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
                result = dlg.ShowModal()
                if result == wx.ID_OK:
                    print("User pressed ok.")
                    puml(":User Pressed OK;\n")
                    self.toast(_("Flash action"), _("✅ Anti rollback warning acknowledged and bypassed."))
                else:
                    print("User pressed cancel.")
                    print("Aborting ...\n")
                    puml("#pink:User Pressed Cancel to abort;\n}\n")
                    return -1

            package_dir_full = os.path.join(factory_images, package_sig)

            # No Wipe downgrade
            if self.config.flash_mode != 'OTA' and self.downgrade:
                # create temporary directory for downgrade
                temp_dir = tempfile.TemporaryDirectory()
                temp_dir_path = temp_dir.name
                downgrade_dir = os.path.join(temp_dir_path, 'downgrade')
                debug(f"Creating temporary directory for downgrade: {downgrade_dir}")
                # copy the package to downgrade directory
                debug(f"Copying {package_dir_full} to {downgrade_dir}")
                shutil.copytree(package_dir_full, downgrade_dir)
                package_dir_full = downgrade_dir
                zip_image_name = f"image-{package_sig}.zip"
                zip_image_path = os.path.join(package_dir_full, zip_image_name)
                # copy the downgrade_boot.img to downgrade directory
                downgrade_file_path, downgrade_boot_exists = get_downgrade_boot_path()
                if downgrade_boot_exists:
                    patched_boot_file = os.path.join(downgrade_dir, 'boot.img')
                    debug(f"Copying downgrade_boot.img to {patched_boot_file}")
                    shutil.copy(downgrade_file_path, patched_boot_file)
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: downgrade_boot.img is not found.")
                    print("Aborting ...\n")
                    puml("#red:downgrade_boot.img is not found;\n}\n")
                    self.toast(_("Flash action"), _("❌ downgrade_boot.img is not found."))
                    return -1

                if os.path.exists(zip_image_path):
                    # replace boot.img in the zip_image_path with patched_boot_file
                    debug(f"Replacing boot.img in {zip_image_path} with {patched_boot_file}")
                    res = replace_file_in_zip_with_7zip(zip_image_path, 'boot.img', patched_boot_file)
                    if res:
                        print(f"boot.img replaced in {zip_image_path}")
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to replace boot.img in {zip_image_path}")
                        print("Aborting ...\n")
                        puml("#red:Unable to replace boot.img in image.zip;\n}\n")
                        self.toast(_("Flash action"), _("❌ Unable to replace boot.img in image.zip."))
                        return -1

        message = ''

        # -------------------------------------------------------------------------
        # 2 Prepare the necessary script contents
        # -------------------------------------------------------------------------
        # if advanced options is set, and we have flash options ...
        fastboot_options = ''
        fastboot_options2 = ''
        sideload_options = ''
        if self.config.advanced_options:
            if self.config.flash_both_slots:
                fastboot_options += '--slot all '
            if self.config.disable_verity:
                fastboot_options += '--disable-verity '
                fastboot_options2 += '--disable-verity '
                sideload_options += '--disable-verity '
            if self.config.disable_verification:
                fastboot_options += '--disable-verification '
                fastboot_options2 += '--disable-verification '
                sideload_options += '--disable-verification '
            if self.config.fastboot_verbose:
                fastboot_options += '--verbose '
                fastboot_options2 += '--verbose '
                sideload_options += '--verbose '
            if self.config.fastboot_force:
                fastboot_options2 += '--force '
            if self.config.flash_mode == 'OTA':
                fastboot_options = sideload_options
            image_mode = get_image_mode()
            if self.config.flash_mode == 'customFlash' and image_mode == 'SIDELOAD':
                message += "   ATTENTION!           Flash Options Don\'t apply to Sideloading. (Except: No Reboot)\n"
                message = f"Custom Flash Options:   {self.config.advanced_options}\n"
            else:
                message = f"Custom Flash Options:   {self.config.advanced_options}\n"
                message += f"Disable Verity:         {self.config.disable_verity}\n"
                message += f"Disable Verification:   {self.config.disable_verification}\n"
                if self.config.flash_mode != 'OTA':
                    message += f"Flash Both Slots:       {self.config.flash_both_slots}\n"
                    message += f"Force:                  {self.config.fastboot_force}\n"
                message += f"Current Slot:           {device.active_slot}\n"
                message += f"Verbose Fastboot:       {self.config.fastboot_verbose}\n"
                message += f"Temporary Root:         {self.config.temporary_root}\n"
                message += f"No Reboot:              {self.config.no_reboot}\n"
                message += f"Wipe:                   {self.wipe}\n"
                message += f"No Wipe Downgrade:      {self.downgrade}\n"
        if self.config.flash_mode != 'OTA':
            message += f"Flash To Inactive Slot: {self.config.flash_to_inactive_slot}\n"

        flash_pf_file_win = os.path.join(package_dir_full, "flash-pf.bat")
        flash_pf_file_linux = os.path.join(package_dir_full, "flash-pf.sh")
        cp = None
        if self.config.force_codepage:
            cp = str(self.config.custom_codepage)
            if cp == '':
                cp = None
        else:
            # don't use system codepage, use UTF-8 if not set
            # cp = get_system_codepage()
            cp = "65001"
        if cp:
            first_line_win = f"\nchcp {cp}\n@ECHO OFF\n"
        else:
            first_line_win = f"@ECHO OFF\n"
        first_line_linux = "#!/bin/sh\n"
        if self.config.advanced_options and self.config.flash_mode == 'customFlash':
            version_sig_win = f":: This is a generated file by PixelFlasher v{VERSION}\n:: cd {package_dir_full}\n:: Android Platform Tools Version: {get_sdk_version()}\n:: Device is rooted: {device.rooted}\n\n"
            version_sig_linux = f"# This is a generated file by PixelFlasher v{VERSION}\n# cd {package_dir_full}\n# Android Platform Tools Version: {get_sdk_version()}\n\n"
        else:
            version_sig_win = f":: This is a generated file by PixelFlasher v{VERSION}\n:: cd {package_dir_full}\n:: pf_boot.img: {boot.boot_path}\n:: Android Platform Tools Version: {get_sdk_version()}\n:: Device is rooted: {device.rooted}\n\n"
            version_sig_linux = f"# This is a generated file by PixelFlasher v{VERSION}\n# cd {package_dir_full}\n# pf_boot.img: {boot.boot_path}\n# Android Platform Tools Version: {get_sdk_version()}\n\n"

        # delete previous flash-pf.bat file if it exists
        if os.path.exists(flash_pf_file_win):
            os.remove(flash_pf_file_win)

        # delete previous flash-pf.sh file if it exists
        if os.path.exists(flash_pf_file_linux):
            os.remove(flash_pf_file_linux)

        data_win = ''
        data_linux = ''

        #-------------------------------
        # if we are in custom Flash mode
        #-------------------------------
        if self.config.advanced_options and self.config.flash_mode == 'customFlash':
            if self.config.flash_to_inactive_slot:
                fastboot_options += '--slot other '
            if image_mode and get_image_path():
                title = "Advanced Flash Options"
                # create flash-pf.bat based on the custom options.
                f_win = open(flash_pf_file_win.strip(), "w", encoding="ISO-8859-1", errors="replace")
                f_linux = open(flash_pf_file_linux.strip(), "w", encoding="ISO-8859-1", errors="replace")
                data_win = first_line_win
                data_linux = first_line_linux
                data_win += r'PATH=%PATH%;"%SYSTEMROOT%\System32"' + "\n\n"
                # Sideload
                if image_mode == 'SIDELOAD':
                    msg  = "\nADB Sideload:           "
                    data_win += f"call \"{get_adb()}\" -s {device_id} sideload \"{get_image_path()}\"\n"
                    data_win += "if errorlevel 1 (\n"
                    data_win += "    echo Error: The sideload command encountered an error, aborting ...\n"
                    data_win += "    echo You should manually reboot to system if necessary.\n"
                    data_win += "    exit/b 1\n"
                    data_win += ")\n"

                    data_linux += f"\"{get_adb()}\" -s {device_id} sideload \"{get_image_path()}\"\n"
                    data_linux += "if [ $? -ne 0 ]; then\n"
                    data_linux += "    echo Error: The sideload command encountered an error, aborting ...\n"
                    data_linux += "    echo You should manually reboot to system if necessary.\n"
                    data_linux += "    exit 1\n"
                    data_linux += "fi\n"
                else:
                    data_win += version_sig_win
                    data_linux += version_sig_linux
                    if image_mode == 'image':
                        action = "update"
                        msg  = f"\nFlash {image_mode:<18}"
                    elif image_mode == 'boot' and self.live_boot_radio_button.Value:
                        action = "boot"
                        msg  = "\nLive Boot to:           "
                        if has_init_boot(device.hardware):
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Live booting Pixel 7 or newer are not supported.")
                            puml("#orange:Live booting Pixel 7 or newer are not supported;\n}\n")
                            self.toast(_("Flash action"), _("⚠️ Live booting Pixel 7 or newer devices is not supported."))
                            # return -1
                    else:
                        action = f"flash {image_mode}"
                        msg  = f"\nFlash {image_mode:<18}"
                    data_tmp = f"\"{get_fastboot()}\" -s {device_id} {fastboot_options} {action} \"{get_image_path()}\"\n"
                    data_win += data_tmp
                    data_linux += data_tmp

                f_win.write(data_win)
                f_win.close()
                f_linux.write(data_linux)
                f_linux.close()
                message += f"{msg}{get_image_path()}\n\n"
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: No image file is selected.")
                puml("#red:Image file is not selected;\n}\n")
                self.toast(_("Flash action"), _("❌ Image file is not selected."))
                return -1

        #---------------------------
        # do the standard flash mode
        #---------------------------
        else:
            add_echo =''
            # check for boot file
            if not os.path.exists(boot.boot_path):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: boot file: {boot.boot_path} is not found.")
                print("Aborting ...\n")
                puml("#red:boot file is not found;\n}\n")
                self.toast(_("Flash action"), _("❌ Boot file is not found."))
                return -1
            else:
                # copy boot file to package directory, but first delete an old one to be sure
                pf = os.path.join(package_dir_full, "pf_boot.img")
                if os.path.exists(pf):
                    os.remove(pf)
                debug(f"Copying {boot.boot_path} to {pf}")
                shutil.copy(boot.boot_path, pf, follow_symlinks=True)
            if not os.path.exists(pf):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} boot file: {pf} is not found.")
                print("Aborting ...\n")
                puml("#red:boot file is not found;\n}\n")
                self.toast(_("Flash action"), _("❌ Boot file is not found."))
                return -1

            # check for rom file (if not OTA)
            if self.config.show_custom_rom_options and self.config.custom_rom and self.config.advanced_options and self.config.flash_mode != 'OTA':
                if not os.path.exists(self.config.custom_rom_path):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: ROM file: {self.config.custom_rom_path} is not found.")
                    print("Aborting ...\n")
                    puml("#red:ROM file is not found;\n}\n")
                    self.toast(_("Flash action"), _("❌ ROM file is not found."))
                    return -1
                else:
                    # copy ROM file to package directory, but first delete an old one to be sure
                    rom_file = ntpath.basename(self.config.custom_rom_path)
                    set_custom_rom_file(rom_file)
                    rom = os.path.join(package_dir_full, rom_file)
                    if os.path.exists(rom):
                        os.remove(rom)
                    debug(f"Copying {self.config.custom_rom_path} to {rom}")
                    shutil.copy(self.config.custom_rom_path, rom, follow_symlinks=True)
                if not os.path.exists(rom):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ROM file: {rom} is not found.")
                    print("Aborting ...\n")
                    puml("#red:ROM file is not found;\n}\n")
                    self.toast(_("Flash action"), _("❌ ROM file is not found."))
                    return -1

            # Make sure Phone model matches firmware model
            if device.true_mode in ['adb', 'f.b'] and ((get_firmware_model() is None or get_firmware_model() == '') or not (len(device.hardware) >= 3 and device.hardware in get_firmware_model())):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Android device model {device.hardware} does not match firmware Model {get_firmware_model()}")
                puml(f"#orange:Hardware does not match firmware;\n")
                puml(f"note right\nAndroid device model {device.hardware}\nfirmware Model {get_firmware_model()}\nend note\n")

                title = _("Device / Firmware Mismatch")
                message_en =  f"ERROR: Your phone model is: {device.hardware}\n\n"
                message_en += f"The selected firmware is for: {get_firmware_model()}\n\n"
                message_en += "Unless you know what you are doing, if you continue flashing\n"
                message_en += "you risk bricking your device, proceed only if you are absolutely\n"
                message_en += "certain that this is what you want, you have been warned.\n\n"
                message_en += "Click OK to accept and continue.\n"
                message_en += "or Hit CANCEL to abort."
                message =  _("ERROR: Your phone model is: %s\n\n") % device.hardware
                message += _("The selected firmware is for: %s\n\n") % get_firmware_model()
                message += _("Unless you know what you are doing, if you continue flashing\n")
                message += _("you risk bricking your device, proceed only if you are absolutely\n")
                message += _("certain that this is what you want, you have been warned.\n\n")
                message += _("Click OK to accept and continue.\n")
                message += _("or Hit CANCEL to abort.")
                print(f"\n*** Dialog ***\n{message_en}\n______________\n")
                puml(":Dialog;\n")
                puml(f"note right\n{message_en}\nend note\n")
                dlg = wx.MessageDialog(None, message, title, wx.CANCEL | wx.OK | wx.ICON_EXCLAMATION)
                result = dlg.ShowModal()
                if result == wx.ID_OK:
                    print("User pressed ok.")
                    puml(":User Pressed OK;\n")
                    self.toast(_("Flash action"), _("✅ Device / Firmware mismatch acknowledged."))
                else:
                    print("User pressed cancel.")
                    print("Aborting ...\n")
                    puml("#pink:User Pressed Cancel to abort;\n}\n")
                    return -1

            # ----------
            # If OTA
            # ----------
            if self.config.flash_mode == 'OTA':
                indent = "    "
                data_win = "@echo off\n"
                data_win += "setlocal enabledelayedexpansion\n"
                data_win += f"chcp {cp}\n"
                data_win += f":: This is a generated file by PixelFlasher v{VERSION}\n"
                data_win += f":: cd {package_dir_full}\n"
                data_win += f":: pf_boot.img: {boot.boot_path}\n"
                data_win += f":: Android Platform Tools Version: {get_sdk_version()}\n"
                data_win += f":: Device is rooted: {device.rooted}\n\n"
                data_win += f"set \"ACTIVE_SLOT={device.active_slot}\"\n"
                data_win += f"set \"INACTIVE_SLOT={device.inactive_slot}\"\n"
                data_win += "echo Current active slot is:   [%ACTIVE_SLOT%]\n"
                data_win += "echo Current inactive slot is: [%INACTIVE_SLOT%]\n"
                data_win += f"call \"{get_adb()}\" -s {device_id} sideload \"{self.config.firmware_path}\"\n"
                data_win += "if errorlevel 1 (\n"
                data_win += "    echo Error: The sideload command encountered an error, aborting ...\n"
                data_win += "    echo You should manually reboot to system if necessary.\n"
                data_win += "    exit /b 1\n"
                data_win += ")\n"

                data_linux = f"# This is a generated file by PixelFlasher v{VERSION}\n"
                data_linux += f"# cd {package_dir_full}\n"
                data_linux += f"# pf_boot.img: {boot.boot_path}\n"
                data_linux += f"# Android Platform Tools Version: {get_sdk_version()}\n\n"
                data_linux += f"ACTIVE_SLOT=\"{device.active_slot}\"\n"
                data_linux += f"INACTIVE_SLOT=\"{device.inactive_slot}\"\n"
                data_linux += "echo Current active Slot is:   [$ACTIVE_SLOT]\n"
                data_linux += "echo Current inactive Slot is: [$INACTIVE_SLOT]\n"
                data_linux += f"\"{get_adb()}\" -s {device_id} sideload \"{self.config.firmware_path}\"\n"
                data_linux += "if [ $? -ne 0 ]; then\n"
                data_linux += "    echo Error: The sideload command encountered an error, aborting ...\n"
                data_linux += "    echo You should manually reboot to system if necessary.\n"
                data_linux += "    exit 1\n"
                data_linux += "fi\n"

            # ----------
            # If not OTA
            # ----------
            else:
                indent = ""
                # Check if the patch file is made by Magisk Zygote64_32
                if "zygote64_32" in boot.magisk_version.lower():
                    # Check we have Magisk Zygote64_32 rooted system already
                    warn = False
                    if device.rooted:
                        # Warn if current firmware is the same as the one being flashed and wipe is not selected.
                        if device.build.lower() in package_sig and not self.config.flash_mode == 'Wipe':
                            warn = True
                    elif not self.config.flash_mode == 'Wipe':
                        warn = True
                    if warn:
                        print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Wipe is required.")
                        puml("#red:Error WARNING, wipe is required;\n")
                        # dialog to accept / abort
                        title = "Wipe is required."
                        buttons_text = ["Continue Flashing (I know what I'm doing)", "Cancel (Recommended)"]
                        message = '''
    The selected patch is created by [Magisk Zygote64_32](https://github.com/Namelesswonder/magisk-files).<br/>

    **PixelFlasher** detected a condition where a wipe is necessary to avoid bootloops.<br/>
    You can learn about it [here](https://xdaforums.com/t/magisk-magisk-zygote64_32-enabling-32-bit-support-for-apps.4521029/post-88504869
    ) and [here](https://xdaforums.com/t/magisk-magisk-zygote64_32-enabling-32-bit-support-for-apps.4521029/)<br/>

    You have not selected the **Wipe Data** option.<br/>

    It is strongly recommended that you Cancel and abort flashing, choose the **Wipe Data** option before continuing to flash.<br/>

    If you insist to continue, you can press the **Continue** button, otherwise please press the **Cancel** button.<br/>
    '''
                        clean_message = message.replace("<br/>", "")
                        print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
                        puml(":Dialog;\n", True)
                        puml(f"note right\n{clean_message}\nend note\n")
                        dlg = MessageBoxEx(
                            parent=self,
                            title=title,
                            message=message,
                            button_texts=buttons_text,
                            default_button=2,
                            disable_buttons=None,
                            is_md=True,
                            size=[700,400],
                            checkbox_labels=None,
                            checkbox_initial_values=None,
                            disable_checkboxes=None,
                            vertical_checkboxes=False,
                            checkbox_labels2=None,
                            checkbox_initial_values2=None,
                            disable_checkboxes2=None,
                            radio_labels=None,
                            radio_initial_value=None,
                            disable_radios=None,
                            vertical_radios=False
                        )
                        dlg.CentreOnParent(wx.BOTH)
                        result = dlg.ShowModal()
                        dlg.Destroy()
                        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
                        puml(f":User Pressed {buttons_text[result - 1]};\n")
                        if result == 2:
                            puml("}\n")
                            print("Aborting ...\n")
                            return -1
                        wipe_flag = True

                # Process flash_all files
                flash_all_win32 = process_flash_all_file(os.path.join(package_dir_full, "flash-all.bat"))
                if (flash_all_win32 == 'ERROR'):
                    print("Make sure you have a supported firmware file.\nAborting ...\n")
                    puml("#red:Error processing flash_all.bat file;\n}\n")
                    return -1
                flash_all_linux = process_flash_all_file(os.path.join(package_dir_full, "flash-all.sh"))
                if (flash_all_linux == 'ERROR'):
                    print("Aborting ...\n")
                    puml("#red:Error processing flash_all.sh file;\n}\n")
                    return -1
                s1 = ''
                s2 = ''
                for f in flash_all_win32:
                    if f.sync_line:
                        s1 += f"{f.sync_line}\n"
                for f in flash_all_linux:
                    if f.sync_line:
                        s2 += f"{f.sync_line}\n"
                # check to see if we have consistent linux / windows files
                if s1 != s2:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Found inconsistency between flash-all.bat and flash-all.sh files.")
                    puml("#yellow:Found an inconsistency between bat and sh files;\n")
                    debug(f"bat file:\n{s1}")
                    debug(f"\nsh file\n{s2}\n")

                if cp:
                    data_win = f"\nchcp {cp}\n"
                else:
                    data_win = ''
                if self.config.flash_mode == 'dryRun':
                    add_echo = 'echo '

                if sys.platform == "win32":
                    flash_all_file = flash_all_win32
                else:
                    flash_all_file = flash_all_linux
                for f in flash_all_file:
                    if f.type == 'init':
                        data_win += f"{f.full_line}\n"
                        data_linux += f"{f.full_line}\n"
                        data_win += f":: This is a generated file by PixelFlasher v{VERSION}\n"
                        data_win += f":: cd {package_dir_full}\n"
                        data_win += f":: pf_boot.img: {boot.boot_path}\n"
                        data_win += f":: Android Platform Tools Version: {get_sdk_version()}\n"
                        data_win += f":: Device is rooted: {device.rooted}\n\n"

                        data_linux += f"# This is a generated file by PixelFlasher v{VERSION}\n"
                        data_linux += f"# cd {package_dir_full}\n"
                        data_linux += f"# pf_boot.img: {boot.boot_path}\n"
                        data_linux += f"# Android Platform Tools Version: {get_sdk_version()}\n\n"
                        if self.config.flash_to_inactive_slot:
                            data_tmp = "\necho Setting active slot to the other ...\n"
                            data_tmp += f"{add_echo}\"{get_fastboot()}\" -s {device_id} --set-active=other\n"
                            data_win += data_tmp
                            data_linux += data_tmp
                        continue
                    if f.type in ['sleep']:
                        sleep_line_win = f"{f.full_line}\n"
                        sleep_line_linux = f"{f.full_line}\n"
                        data_win += sleep_line_win
                        data_linux += sleep_line_linux
                        continue
                    if f.type in ['path']:
                        data_win += f"{f.full_line}\n"
                        data_linux += f"{f.full_line}\n"
                        continue
                    if f.action == 'reboot-bootloader':
                        data_tmp = f"\"{get_fastboot()}\" -s {device_id} {f.action} {f.arg1} {f.arg2}\n"
                        data_win += data_tmp
                        data_linux += data_tmp
                        continue
                    if f.action == 'flash':
                        data_tmp = f"{add_echo}\"{get_fastboot()}\" -s {device_id} {fastboot_options} {f.action} {f.arg1} {f.arg2}\n"
                        data_win += data_tmp
                        data_linux += data_tmp
                        continue
                    if f.action == '-w update':
                        action = '--skip-reboot update'
                        arg1 = f.arg1
                        if self.config.flash_mode == 'wipeData':
                            action = '--skip-reboot -w update'
                        if self.config.show_custom_rom_options and self.config.custom_rom and self.config.advanced_options:
                            arg1 = f"\"{get_custom_rom_file()}\""
                        data_tmp = f"{add_echo}\"{get_fastboot()}\" -s {device_id} {fastboot_options2} {action} {arg1}\n"
                        data_win += data_tmp
                        data_linux += data_tmp
                        # flash on each slot separately
                        # https://xdaforums.com/t/psa-do-not-try-to-boot-into-the-old-slot-after-updating-only-one-slot-to-android-13-unlocking-the-pixel-6-pro-bootloader-central-repository.4352027/post-87309913
                        if self.config.advanced_options and self.config.flash_both_slots:
                            data_tmp = "\necho Switching active slot to the other ...\n"
                            data_tmp += f"{add_echo}\"{get_fastboot()}\" -s {device_id} --set-active=other\n"
                            data_tmp += "\necho rebooting to bootloader ...\n"
                            data_tmp += f"{add_echo}\"{get_fastboot()}\" -s {device_id} reboot bootloader\n"
                            data_tmp += "\necho Sleeping 5-10 seconds ...\n"
                            data_win += data_tmp
                            data_linux += data_tmp
                            data_win += sleep_line_win
                            data_win += sleep_line_win
                            data_linux += sleep_line_linux
                            data_linux += sleep_line_linux
                            data_win += f"{add_echo}\"{get_fastboot()}\" -s {device_id} {fastboot_options2} {action} {arg1}\n"
                            data_linux += f"{add_echo}\"{get_fastboot()}\" -s {device_id} {fastboot_options2} {action} {arg1}\n"
                        # echo add testing of fastbootd mode if we are in dry run mode and sdk < 34
                        sdk_version_components = get_sdk_version().split('.')
                        sdk_major_version = int(sdk_version_components[0])
                        if self.config.flash_mode == 'dryRun' and sdk_major_version < 34:
                            data_tmp = "\necho This is a test for fastbootd mode ...\n"
                            data_tmp += "echo This process will wait for fastbootd indefinitely until it responds ...\n"
                            data_tmp += "echo WARNING! if your device does not boot to fastbootd PixelFlasher will hang and you would have to kill it.. ...\n"
                            data_tmp += "echo rebooting to fastbootd ...\n"
                            data_tmp += f"\"{get_fastboot()}\" -s {device_id} reboot fastboot\n"
                            data_tmp += "\necho It looks like fastbootd worked.\n"
                            data_win += data_tmp
                            data_linux += data_tmp

            if sys.platform == "win32":
                fin = open(flash_pf_file_win, "wt", encoding="ISO-8859-1", errors="replace")
                fin.write(data_win)
                fin.close()
            else:
                fin = open(flash_pf_file_linux, "wt", encoding="ISO-8859-1", errors="replace")
                fin.write(data_linux)
                fin.close()

            title = "Flash Options"
            message = "%s%s \n" % (get_flash_settings(self), message)

        # ============================================
        # Sub Function     reboot_device_to_bootloader
        # ============================================
        def reboot_device_to_bootloader():
            nonlocal device
            if not device:
                device = get_phone(True)
            if device is None:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Can't reboot to bootloader because the device not detected.")
                print("Aborting ...\n")
                puml("#red:Can't reboot to bootloader because the device not detected;\n}\n")
                return -1
            # reboot to bootloader if flashing is necessary
            if self.config.disable_verity or self.config.disable_verification or self.config.flash_mode == 'customFlash' or (boot and not boot.is_stock_boot):
                # Check for bootloader unlocked
                res = is_device_unlocked(self, device)
                if res == -1:
                    # Device is not detected
                    print("Aborting ...\n")
                    puml("#red:Device is not detected;\n}\n")
                    self.toast(_("Flash action"), _("❌ Device is not detected."))
                    return -1
                elif res == 0:
                    self.toast(_("Flash action"), _("❌ Bootloader is locked, cannot flash."))
                    dlg = wx.MessageDialog(None, _("Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"), _("Error"), wx.YES_NO | wx.ICON_ERROR)
                    result = dlg.ShowModal()
                    if result != wx.ID_YES:
                        print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} User chose not to proceed.")
                        print("Aborting ...\n")
                        puml("#red:Bootloader is locked, can't flash;\n}\n")
                        return -1
                    else:
                        print("❌ Bootloader is locked, but user chose to proceed ...")
                else:
                    print("✅ Bootloader is unlocked, continuing ...")

                res = device.reboot_bootloader(fastboot_included = True)
                if res is None or res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                    self.clear_device_selection()
                    print("Aborting ...\n")
                    puml("#red:Encountered an error while rebooting to bootloader;\n}\n")
                    self.toast(_("Flash action"), _("❌ Encountered an error while rebooting to bootloader."))
                    bootloader_issue_message()
                    refresh_and_done()
                    return -1
                self.refresh_device(device_id)
                device = get_phone()
                return 0
            else:
                return 1

        #----------------------------------------
        # common part for package or custom flash
        #----------------------------------------
        # make the sh script executable
        if sys.platform != "win32":
            flash_pf_file = flash_pf_file_linux
            data = data_linux
            theCmd = f"chmod 755 \"{flash_pf_file_linux}\""
            debug(theCmd)
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Return Code: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set the permissions on {flash_pf_file_linux}")
                    print("Aborting ...\n")
                    puml("#red:Could not set the permissions on flash script;\n}\n")
                    return -1
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set the permissions on {flash_pf_file_linux}")
                print("Aborting ...\n")
                puml("#red:Could not set the permissions on flash script;\n}\n")
                return -1
        else:
            flash_pf_file = flash_pf_file_win
            data = data_win

        message += "\nNote: Pressing OK button will invoke a script that will utilize\n"
        if self.config.advanced_options and self.config.flash_mode == 'customFlash' and image_mode == 'SIDELOAD':
            message += "adb command, this could possibly take a long time and PixelFlasher\n"
            message += "will appear frozen. PLEASE BE PATIENT and don\'t interrupt the process.\n\n"
        else:
            message += "fastboot commands, this could possibly take a long time and PixelFlasher\n"
            message += "will appear frozen. PLEASE BE PATIENT. \n"
            message += "In case it takes excessively long, it could possibly be due to improper or\n"
            message += "faulty fastboot drivers.\n"
            message += "In such cases, killing the fastboot process will resume to normalcy.\n\n"
        message += "Do you want to continue to flash with the above options?\n"
        message += "You can also choose to edit the script before continuing,\nin case you want to customize it.(Only choose this if you know what you are doing)\n\n"
        message += "Press OK to continue or CANCEL to abort.\n"
        print(f"\n*** Dialog ***\n{message}\n______________\n")
        print(f"The script content that will be executed:")
        print(f"___________________________________________________\n{data}")
        print("___________________________________________________\n")
        puml(":Dialog;\n", True)
        puml(f"note right\n{message}\nend note\n")
        puml(":Script;\n")
        puml(f"note right\nFlash Script\n====\n{data}\nend note\n")
        try:
            dlg = MessageBoxEx(
                parent=None,
                title=title,
                message=message,
                button_texts=["OK", "Edit script before continuing", "Cancel"],
                default_button=1,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result not in (1, 2, 3):
                result = 3
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
            traceback.print_exc()

        if result == 1: # OK
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Ok.")
            puml(":User Pressed OK;\n")
            # continue flashing
        elif result == 2: # Edit
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Edit Script.")
            puml("#pink:User Pressed Edit Script;\n")
            dlg = FileEditor(self, flash_pf_file, "batch", width=1500, height=600)
            dlg.CenterOnParent()
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_OK:
                # get the contents of modified flash_pf_file
                with open(flash_pf_file, 'r', encoding='ISO-8859-1', errors="replace") as f:
                    contents = f.read()
                print(f"\nflash_pf file has been modified!")
                print(f"The modified script content that will be executed:")
                print(f"___________________________________________________\n{contents}")
                print("___________________________________________________\n")
                puml(f"note right\nModified Script\n====\n{contents}\nend note\n")
                # continue flashing
            else:
                print("User cancelled editing flash_phone file.")
                puml(f"note right\nCancelled and Aborted\nend note\n")
                return -1
        elif result == 3: # Cancel
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
            print("Aborting ...\n")
            puml("#pink:User Pressed Cancel;\n}\n")
            return -1

        # -------------------------------------------------------------------------
        # 3 Put the device in the correct state (bootloader / sideload / fastbootd)
        # -------------------------------------------------------------------------
        print("")
        print("==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} PixelFlasher {VERSION}              Flashing Phone    ")
        print("==============================================================================")
        startFlash = time.time()
        puml(":Start Flashing;\n", True)
        print(f"Android Platform Tools Version: {get_sdk_version()}")
        puml(f"note right\nPixelFlasher {VERSION}\nAndroid Platform Tools Version: {get_sdk_version()}\nend note\n")

        mode = device.get_device_state()
        if mode:
            print(f"Currently the device is in {mode} mode.")

        # If we're doing OTA or Sideload image flashing, be in sideload mode
        if self.config.flash_mode == 'OTA' or (self.config.advanced_options and self.config.flash_mode == 'customFlash' and image_mode == 'SIDELOAD'):
            # Let's cancel previous OTA just to be safe.
            if device.true_mode == 'adb' and device.rooted:
                print("Cancelling a previous OTA update for good measure ...")
                ota_clean_start_time = time.time()
                res = device.reset_ota_update()
                ota_clean_time = time.time() - ota_clean_start_time
                if ota_clean_time > 10:
                    print(f"Cleaning up previous OTA update took {ota_clean_time:.2f} seconds. Cleaning it again one more time for good measure ...")
                    res = device.reset_ota_update()
            else:
                print("Skipping cancelling a previous OTA update. Device needs to be rooted and in adb mode ...")
            res = device.reboot_sideload(90)
            if res == -1:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to sideload")
                print("Aborting ...\n")
                puml("#red:Encountered an error while rebooting to sideload;\n}\n")
                self.toast(_("Flash action"), _("❌ Encountered an error while rebooting to sideload."))
                refresh_and_done()
                return -1
        # Some images need to be flashed in fastbootd mode
        # note: system and vendor, typically get flashed to both slots. '--skip-secondary' will not flash secondary slots in flashall/update
        # TODO check which Pixels and newer support fastbootd, Probably Pixel 5 and newer.
        elif self.config.advanced_options and self.config.flash_mode == 'customFlash' and get_image_mode() in ['super','product','system','system_dlkm','system_ext','vendor','vendor_dlkm']:
            res = device.reboot_fastboot()
            if res == -1:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to fastbootd")
                print("Aborting ...\n")
                puml("#red:Encountered an error while rebooting to fastbootd;\n}\n")
                self.toast(_("Flash action"), _("❌ Encountered an error while rebooting to fastbootd."))
                refresh_and_done()
                return -1
        # be in bootloader mode for flashing
        else:
            res = device.reboot_bootloader()
            if res == -1:
                refresh_and_done()
                print("Aborting ...\n")
                return -1

        # -------------------------------------------------------------------------
        # 4 Run the script
        # -------------------------------------------------------------------------
        print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Flashing device: {device_id} ...")
        puml(f":Flashing device: {device_id};\n", True)
        theCmd = flash_pf_file
        os.chdir(package_dir_full)
        theCmd = f"\"{theCmd}\""
        debug(theCmd)
        res = run_shell2(theCmd, chcp=cp)
        if res and isinstance(res, subprocess.CompletedProcess):
            debug(f"Return Code: {res.returncode}")
            debug(f"Stdout: {res.stdout}")
            debug(f"Stderr: {res.stderr}")
            if res.returncode != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while running flash script.")
                print("Aborting ...\n")
                puml("#red:Encountered an error while running flash script.;\n}\n")
                self.toast(_("Flash action"), _("❌ Encountered an error while running the flash script."))
                return -1
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while running flash script.")
            print("Aborting ...\n")
            puml("#red:Encountered an error while running flash script.;\n}\n")
            self.toast(_("Flash action"), _("❌ Encountered an error while running the flash script."))
            return -1
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Done flash script execution!")
        puml(f":Done flash script execution;\n", True)


        # define sub functions to simplify code
        # ==========================================
        # Sub Function         apply_patch_if_needed
        # ==========================================
        def apply_patch_if_needed():
            nonlocal device
            # flash patched boot / init_boot if dry run is not selected.
            if self.config.check_for_bootloader_unlocked and (not boot.is_stock_boot and self.config.flash_mode != 'dryRun'):
                res = is_device_unlocked(self, device)
                if res == -1:
                    # Device is not detected
                    print("Aborting ...\n")
                    puml("#red:Device is not detected;\n}\n")
                    self.toast(_("Flash action"), _("❌ Device is not detected."))
                    return -1
                elif res == 0:
                    self.toast(_("Flash action"), _("❌ Bootloader is locked, cannot flash."))
                    dlg = MessageBoxEx(
                        parent=None,
                        title=_("Error"),
                        message=_("Your bootloader is locked or you haven't granted su permissions to shell process.\nDo you want to proceed regardless?"),
                        button_texts=[_("Yes"), _("No")],
                        default_button=2,
                        disable_buttons=None,
                        is_md=False,
                        size=(800, 600),
                        checkbox_labels=None,
                        checkbox_initial_values=None,
                        disable_checkboxes=None,
                        vertical_checkboxes=False,
                        checkbox_labels2=None,
                        checkbox_initial_values2=None,
                        disable_checkboxes2=None,
                        radio_labels=None,
                        radio_initial_value=None,
                        disable_radios=None,
                        vertical_radios=False
                    )
                    result = dlg.ShowModal()
                    dlg.Destroy()
                    if result != 1:
                        print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} User chose not to proceed.")
                        print("Aborting ...\n")
                        puml("#red:Bootloader is locked, can't flash;\n}\n")
                        return -1
                    else:
                        print("❌ Bootloader is locked, but user chose to proceed ...")
                else:
                    # we do not want to flash if we have selected Temporary root
                    if self.config.advanced_options and self.config.temporary_root and boot.is_patched:
                        flash = ''
                    else:
                        # flash the patch
                        flash = "flash"

                    if boot.is_init_boot:
                        partition = "init_boot"
                    else:
                        partition = "boot"
                    selected_boot_partition = get_selected_boot_partition()
                    if selected_boot_partition:
                        partition = selected_boot_partition

                    print("\n======================================")
                    print(f"Flashing patched {partition} ...")
                    print("\n======================================")
                    theCmd = f"\"{get_fastboot()}\" -s {device_id} {fastboot_options} {flash} {partition} \"{boot.boot_path}\"\n"
                    debug(theCmd)
                    res = run_shell(theCmd)
                    if res and isinstance(res, subprocess.CompletedProcess):
                        debug(f"Return Code: {res.returncode}")
                        debug(f"Stdout: {res.stdout}")
                        debug(f"Stderr: {res.stderr}")
                        if res.returncode == 0:
                            return 0
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while flashing the patch.")
                    print(f"theCmd: {theCmd}")
                    print("Aborting ...")
                    puml("#red:Encountered an error while flashing the patch.;\n}\n")
                    self.toast(_("Flash action"), _("❌ Encountered an error while flashing the patch."))
                    print("Aborting ...\n")
                    return -1
            return 0

        # ==========================================
        # Sub Function        flash_vbmeta_if_needed
        # ==========================================
        def flash_vbmeta_if_needed():
            # flash vbmeta if disabling verity / verification
            vbmeta_file = os.path.join(package_dir_full, "vbmeta.img")
            if self.config.disable_verity or self.config.disable_verification and os.path.exists(vbmeta_file) and self.config.flash_mode != 'dryRun':
                print("\n====================")
                print("  Flashing vbmeta ...")
                print("\n====================")
                theCmd = f"\"{get_fastboot()}\" -s {device_id} {fastboot_options} flash vbmeta \"{vbmeta_file}\""
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        return 0
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: vbmeta flashing did not return the expected result.")
                print(f"theCmd: {theCmd}")
                print("Aborting ...")
                puml("#red:vbmeta flashing did not return the expected result.;\n}\n")
                self.toast(_("Flash action"), _("❌ vbmeta flashing did not return the expected result."))
                print("Aborting ...\n")
                return -1
            return 0

        # ==========================================
        # Sub Function                 compare_slots
        # ==========================================
        def compare_slots():
            nonlocal device
            # If we're doing Sideload image flashing
            if self.config.flash_mode == 'OTA':
                # check slot
                slot_after_flash = device.get_current_slot()
                print(f"Current slot: [{slot_after_flash}]")
                print("Comparing the current slot with the previous active slot ...")
                if slot_after_flash == "UNKNOWN" or slot_after_flash == slot_before_flash:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: It appears that OTA flashing did not properly switch slots.")
                    print("Aborting ...")
                    puml("#red:It appears that OTA flashing did not properly switch slots.;\n}\n")
                    self.toast(_("Flash action"), _("❌ It appears that OTA flashing did not properly switch slots."))
                    print("Aborting ...\n")
                    return -1
                print("✅ Current slot has changed, this is good.")
            return 0

        # ============================================
        # Sub Function      reboot_to_system_if_needed
        # ============================================
        def reboot_to_system_if_needed():
            nonlocal device
            if not self.config.no_reboot:
                device = get_phone()
                if device:
                    if wipe_flag:
                        timeout = None
                    else:
                        timeout = 90
                    res = device.reboot_system(timeout=timeout)
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to system")
                        print("Aborting ...\n")
                        return -1
            return 0

        # ============================================
        # Sub Function              device_is_detected
        # ============================================
        def device_is_detected():
            # see if we got a device
            nonlocal device
            if not device:
                # sleep 5 seconds and try again
                print("Sleeping 5 seconds to find the device ...")
                puml(f":Sleeping 5 seconds;\n", True)
                time.sleep(5)
                self.refresh_device(device_id)
                device = get_phone()
                if not device:
                    # TODO: Improve the message, we don't need to suggest flashing when doing OTA, depending on the options selected, the suggestions vary.
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Your device is not found in bootloader mode.\nIf your device is actually in bootloader mode,\nhit the scan button and see if PixelFlasher finds it.\nIf it does, you can hit the Flash button again,\notherwise there seems to be a connection issue (USB drivers, cable, PC port ...)\n")
                    print("Aborting ...\n")
                    puml("#red:Device not found after rebooting to bootloader;\n}\n")
                    self.toast(_("Flash action"), _("⚠️ Device is not found after rebooting to bootloader."))
                    print("Aborting ...\n")
                    return -1
            return 0

        # ============================================
        # Sub Function                 get_device_mode
        # ============================================
        def get_device_mode(expect_bootloader=False):
            nonlocal device
            nonlocal device_id
            mode = device.get_device_state(device_id=device_id, timeout=60, retry=3)
            if mode and mode != "ERROR":
                print(f"Currently the device is in {mode} mode.")
                if expect_bootloader and mode != "fastboot":
                    print("ERROR: Expected the device to be in bootloader mode")
                    print("Aborting ...\n")
                    return -1
                image_mode = get_image_mode()
                self.refresh_device(device_id)
                new_device = get_phone(True)
                if new_device:
                    device = new_device
                    return 0
                else:
                    print("ERROR: Device was lost after refresh")
                    print("Aborting ...\n")
                    return -1
            else:
                if mode and mode == "ERROR":
                    print(f"Currently the device is in {mode} mode.")
                print("ERROR: Device could not be detected")
                print("Aborting ...\n")
                return -1

        # ============================================
        # Sub Function                refresh_and_done
        # ============================================
        def refresh_and_done(final_message=False):
            # nonlocal device
            print("Sleeping 10 seconds ...")
            puml(f":Sleeping 10 seconds;\n", True)
            time.sleep(10)
            self.refresh_device(device_id)
            device = get_phone()
            ### Done
            endFlash = time.time()
            print(f"Flashing elapsed time: {math.ceil(endFlash - startFlash)} seconds")
            print("------------------------------------------------------------------------------\n")
            puml("#cee7ee:End Flashing;\n", True)
            puml(f"note right:Flash time: {math.ceil(endFlash - startFlash)} seconds;\n")
            self.toast(_("Flash action"), _("✅ Flashing elapsed time: %s seconds") % (math.ceil(endFlash - startFlash)))
            puml("}\n")
            os.chdir(cwd)
            # if we're sideloading OTA, we should open logcat to show the merging of the OTA
            if self.config.flash_mode == 'OTA':
                if device:
                    self.toast(_("⚠️ Wait for OTA Merging completion."), _("WARNING! Please wait for the OTA merging to complete.\nCheck the logcat window for the completion message.\nYou can close the logcat window when done."))
                    print("\n===================================================================")
                    print("  Opening logcat to show the merging of the OTA progress.")
                    print("  Please wait until the merging is complete.")
                    print("  When the merging is complete, you should see a message:")
                    print("      ActionProcessor: finished ... ErrorCode::kSuccess")
                    print("  You can close the logcat window when done.")
                    print("  If logcat windows is closed before the merging is complete,")
                    print("  (this can happen when you unlock the screen)")
                    print("  you can open it again from PixelFlasher menu:")
                    print("      Device | Logcat filter: update_engine")
                    print("  If you get a blank logcat, this could happen, just play it safe")
                    print("  and wait 10 minutes before you reboot again.")
                    print("===================================================================\n")
                    device.open_update_engine_logcat()
            if final_message:
                message_after_flashing()

        # -------------------------------------------------------------------------
        # 5 Finish up Do the additional checks and flashing / rebooting
        # -------------------------------------------------------------------------
        # At this point when pf_script completes the execution,
        # the device should be in bootloader mode for factory and custom flashing,
        # And in recovery for sideload
        # To be safe let's give it 10 seconds
        print("Sleeping 10 seconds ...")
        puml(f":Sleeping 10 seconds;\n", True)
        time.sleep(10)

        # !!!!!!!!!!!!
        # Custom Flash
        # !!!!!!!!!!!!
        if self.config.flash_mode == 'customFlash':
            # get device state
            res = get_device_mode(expect_bootloader=True)
            if res == -1:
                refresh_and_done()
                return -1

            # if wipe is selected perform wipe.
            if self.wipe and mode == "f.b":
                print("Wiping userdata ...")
                theCmd= f"\"{get_fastboot()}\" -s {device_id} -w"
                debug(theCmd)
                res = run_shell(theCmd)
                wipe_flag = True

            # reboot to system if needed
            reboot_to_system_if_needed()

        # !!!!!!!!!!!!
        # OTA
        # !!!!!!!!!!!!
        elif self.config.flash_mode == 'OTA':
            continue_ota_flag = False

            # # can't determine if device is a phone or a watch
            # if device.hardware is None or device.hardware == "":
            #     # TODO: ask if the device is a phone or watch to continue accordingly.
            #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to detect the device.")
            #     print("Aborting ...\n")
            #     return -1
            # if Device is a Phone
            if device.hardware is None or device.hardware == "" or not is_pixel_watch(device.hardware):
                res = get_device_mode(expect_bootloader=False)
                if res == -1:
                    # On Android 15, sometimes the device is not detected after sideloading the OTA
                    # It typically waits for user interaction to reboot to system.
                    # Ask the user if the device is waiting for user interaction to continue / reboot
                    title = _("Device is not detected.")
                    buttons_text = [_("Done rebooting to bootloader, continue"), _("Cancel")]
                    action_text = 'bootloader'
                    if boot.is_stock_boot:
                        buttons_text = [_("Done rebooting to system, continue"), _("Cancel")]
                        action_text = 'system'

                    message_en = "## Is your device waiting for interaction?\n"
                    message_en += "\n"
                    message_en += "_If it is not, please hit the cancel button._\n"
                    message_en += "\n"
                    message_en += "If your device is waiting for user interaction which can not be programmatically invoked.\n"
                    message_en += "\n"
                    message_en += f"- Using volume keys, scroll up and down and select **Reboot {action_text}**\n"
                    message_en += "- Press the power button to apply.\n"
                    message_en += "\n"
                    message_en += f"When done, the device should reboot to {action_text} <br/>\n"
                    message_en += f"Wait for the device to fully boot to {action_text} <br/>\n\n"
                    message_en += f"Click on **Done rebooting to {action_text}, continue** button <br/>\n"
                    message_en += "or hit the **Cancel** button to abort.\n"

                    message = _("## Is your device waiting for interaction?\n")
                    message += "\n"
                    message += _("_If it is not, please hit the cancel button._\n")
                    message += "\n"
                    message += _("If your device is waiting for user interaction which can not be programmatically invoked.\n")
                    message += "\n"
                    message += _("- Using volume keys, scroll up and down and select **Reboot %s**\n") % action_text
                    message += _("- Press the power button to apply.\n")
                    message += "\n"
                    message += _("When done, the device should reboot to %s <br/>\n") % action_text
                    message += _("Wait for the device to fully boot to %s <br/>\n\n") % action_text
                    message += _("Click on **Done rebooting to %s, continue** button <br/>\n") % action_text
                    message += _("or hit the **Cancel** button to abort.\n")

                    print(f"\n*** Dialog ***\n{message_en}\n______________\n")
                    dlg = MessageBoxEx(
                        parent=self,
                        title=title,
                        message=message,
                        button_texts=buttons_text,
                        default_button=1,
                        disable_buttons=[],
                        is_md=True,
                        size=[800,400],
                        checkbox_labels=None,
                        checkbox_initial_values=None,
                        disable_checkboxes=None,
                        vertical_checkboxes=False,
                        checkbox_labels2=None,
                        checkbox_initial_values2=None,
                        disable_checkboxes2=None,
                        radio_labels=None,
                        radio_initial_value=None,
                        disable_radios=None,
                        vertical_radios=False
                    )
                    dlg.CentreOnParent(wx.BOTH)
                    result = dlg.ShowModal()
                    dlg.Destroy()
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
                    if result == 2:
                        print("Aborting ...")
                        refresh_and_done()
                        return -1
                    # Check device mode again
                    if action_text == 'bootloader':
                        res = get_device_mode(expect_bootloader=True)
                        if res == -1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to detect the device or device is not in bootloader mode.")
                            print("Aborting ...\n")
                            refresh_and_done()
                            return -1
                    else:
                        res = get_device_mode(expect_bootloader=False)
                        if res == -1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to detect the device or device is not in system mode.")
                            print("Aborting ...\n")
                            refresh_and_done()
                            return -1
                        if action_text == 'system':
                            refresh_and_done(True)
                            return 0
                # reboot to bootloader if flashing is necessary
                res = reboot_device_to_bootloader()
                if res == -1:
                    refresh_and_done()
                    return -1
                elif res == 1:
                    reboot_to_system_if_needed()
                else:
                    continue_ota_flag = True

            # if Device is a Watch
            # Pixel Watches cannot be detected or rebooted to bootloader mode once sideloading is completed
            # We need to have user interaction to continue further.
            else:
                # Determine if we need to root, otherwise just display a message to reboot to system
                if self.config.disable_verity or self.config.disable_verification or not boot.is_stock_boot:
                    # display a popup to ask the user to select "Reboot to bootloader" and hit to continue here when done
                    title = _("Waiting for user interaction")
                    buttons_text = [_("Done rebooting to bootloader, continue"), _("Cancel")]

                    message_en = "## Your watch should now be in Android Recovery\n"
                    message_en += "\n"
                    message_en += "_If it is not, please hit the cancel button._\n"
                    message_en += "\n"
                    message_en += "The watch is waiting for user interaction which can not be programmatically invoked.\n"
                    message_en += "\n"
                    message_en += "- Using touch, scroll and select **Reboot to bootloader**\n"
                    message_en += "- Press the side button to apply.\n"
                    message_en += "\n"
                    message_en += "When done, the watch should reboot to bootloader mode <br/>\n"
                    message_en += "Wait for the watch to indicate that it is in bootloader mode <br/>\n\n"
                    message_en += "Click on **Done rebooting to bootloader, continue** button <br/>\n"
                    message_en += "or hit the **Cancel** button to abort.\n"

                    message = _("## Your watch should now be in Android Recovery\n")
                    message += "\n"
                    message += _("_If it is not, please hit the cancel button._\n")
                    message += "\n"
                    message += _("The watch is waiting for user interaction which can not be programmatically invoked.\n")
                    message += "\n"
                    message += _("- Using touch, scroll and select **Reboot to bootloader**\n")
                    message += _("- Press the side button to apply.\n")
                    message += "\n"
                    message += _("When done, the watch should reboot to bootloader mode <br/>\n")
                    message += _("Wait for the watch to indicate that it is in bootloader mode <br/>\n\n")
                    message += _("Click on **Done rebooting to bootloader, continue** button <br/>\n")
                    message += _("or hit the **Cancel** button to abort.\n")

                    print(f"\n*** Dialog ***\n{message_en}\n______________\n")
                    dlg = MessageBoxEx(
                        parent=self,
                        title=title,
                        message=message,
                        button_texts=buttons_text,
                        default_button=1,
                        disable_buttons=[],
                        is_md=True,
                        size=[800,400],
                        checkbox_labels=None,
                        checkbox_initial_values=None,
                        disable_checkboxes=None,
                        vertical_checkboxes=False,
                        checkbox_labels2=None,
                        checkbox_initial_values2=None,
                        disable_checkboxes2=None,
                        radio_labels=None,
                        radio_initial_value=None,
                        disable_radios=None,
                        vertical_radios=False
                    )
                    dlg.CentreOnParent(wx.BOTH)
                    result = dlg.ShowModal()
                    dlg.Destroy()
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
                    if result == 2:
                        print("Aborting ...")
                        refresh_and_done()
                        return -1
                    continue_ota_flag = True
                else:
                    # display a popup to ask the user to select "Reboot to system now"
                    title = _("Waiting for user interaction")
                    buttons_text = [_("Done rebooting to system, continue")]

                    message_en = "## Your watch should now be in Android Recovery\n"
                    message_en += "\n"
                    message_en += "The watch is waiting for user interaction which can not be programmatically invoked.\n"
                    message_en += "\n"
                    message_en += "- Using touch, scroll and select **Reboot to system now**\n"
                    message_en += "- Press the side button to apply.\n"
                    message_en += "\n"
                    message_en += "When applied, the watch should reboot to system. <br/>\n"
                    message_en += "Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n"

                    message = _("## Your watch should now be in Android Recovery\n")
                    message += "\n"
                    message += _("The watch is waiting for user interaction which can not be programmatically invoked.\n")
                    message += "\n"
                    message += _("- Using touch, scroll and select **Reboot to system now**\n")
                    message += _("- Press the side button to apply.\n")
                    message += "\n"
                    message += _("When applied, the watch should reboot to system. <br/>\n")
                    message += _("Click on **Done rebooting to system, continue** button when the watch OS fully loads.\n")

                    print(f"\n*** Dialog ***\n{message_en}\n______________\n")
                    dlg = MessageBoxEx(
                        parent=self,
                        title=title,
                        message=message,
                        button_texts=buttons_text,
                        default_button=1,
                        disable_buttons=[],
                        is_md=True,
                        size=[800,300],
                        checkbox_labels=None,
                        checkbox_initial_values=None,
                        disable_checkboxes=None,
                        vertical_checkboxes=False,
                        checkbox_labels2=None,
                        checkbox_initial_values2=None,
                        disable_checkboxes2=None,
                        radio_labels=None,
                        radio_initial_value=None,
                        disable_radios=None,
                        vertical_radios=False
                    )
                    dlg.CentreOnParent(wx.BOTH)
                    result = dlg.ShowModal()
                    dlg.Destroy()
                    print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")

            # continue with flashing
            if continue_ota_flag:
                # make sure device is detected
                res = device_is_detected()
                if res == -1:
                    refresh_and_done()
                    return -1

                # compare slots
                print("\n=======================================================")
                print("Verifying the current active slot after OTA flashing ...")
                print("\n=======================================================")
                res = compare_slots()
                if res == -1:
                    refresh_and_done()
                    return -1

                if wipe_flag:
                    dlg = wx.MessageDialog(None, _("You have selected  WIPE option.\nAdb debugging will be reset and disabled\nHence patch or vbmeta flashing will be skipped."), _("Wipe Data"), wx.OK | wx.ICON_EXCLAMATION)
                    result = dlg.ShowModal()
                else:
                    # flash vbmeta if disabling verity / verification
                    res = flash_vbmeta_if_needed()
                    if res == -1:
                        refresh_and_done()
                        return -1

                    # apply patch if needed
                    res = apply_patch_if_needed()
                    if res == -1:
                        refresh_and_done()
                        return -1

                # reboot to system if needed
                reboot_to_system_if_needed()

        # !!!!!!!!!!!!
        # Factory
        # !!!!!!!!!!!!
        else:
            # get device state
            res = get_device_mode(expect_bootloader=True)
            if res == -1:
                refresh_and_done()
                return -1

            # reboot to bootloader
            res = reboot_device_to_bootloader()
            if res == -1:
                refresh_and_done()
                return -1

            # apply patch if needed
            res = apply_patch_if_needed()
            if res == -1:
                refresh_and_done()
                return -1

            # reboot to system if needed
            reboot_to_system_if_needed()

        # !!!!!!!!!!!!
        # Done
        # !!!!!!!!!!!!
        refresh_and_done(True)
        return 0

    finally:
        if temp_dir:
            shutil.rmtree(temp_dir.name, ignore_errors=True)

```

`phone.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import contextlib
import re
import subprocess
import time
import traceback
import sqlite3
import json
from datetime import datetime
from urllib.parse import urlparse
from packaging.version import parse
from concurrent.futures import ThreadPoolExecutor, as_completed

from constants import *
from runtime import *
from i18n import _


# ============================================================================
#                               Class Package
# ============================================================================
class Package():
    def __init__(self, value):
        self.value = value
        self.type = ''
        self.installed = False
        self.enabled = False
        self.user0 = False
        self.magisk_denylist = False
        self.details = ''
        self.path = ''
        self.path2 = ''
        self.label = ''
        self.icon = ''
        self.uid = ''


# ============================================================================
#                               Class Backup
# ============================================================================
class Backup():
    def __init__(self, value):
        self.value = value # sha1
        self.date = ''
        self.firmware = ''


# ============================================================================
#                               Class Vbmeta
# ============================================================================
class Vbmeta():
    def __init__(self):
        self.clear()

    def clear(self):
        self.type = '' # one of ["a_only", "ab", "none"]
        self.verity_a = None
        self.verity_b = None
        self.verification_a = None
        self.verification_b = None

# ============================================================================
#                               Class Magisk
# ============================================================================
class Magisk():
    def __init__(self, dirname):
        self.dirname = dirname


# ============================================================================
#                               Class DeviceProps
# ============================================================================
class DeviceProps:
    def __init__(self):
        self.property = {}

    def get(self, key):
        return self.property.get(key, "Property not found")

    def upsert(self, key, value):
        self.property[key] = value


# ============================================================================
#                               Class Device
# ============================================================================
class Device():
    # Class variable
    vendor = "google"

    def __init__(self, id, mode, true_mode = None):
        # Instance variables
        self.id = id
        self.mode = mode
        if true_mode:
            self.true_mode = true_mode
        else:
            self.true_mode = mode
        # The below are for caching.
        self._adb_device_info = None
        self._fastboot_device_info = None
        self._rooted = None
        self._su_version = ''
        self._magisk_version = None
        self._magisk_app_version = None
        self._magisk_version_code = None
        self._magisk_app_version_code = None
        self._get_magisk_detailed_modules = None
        self._magisk_modules_summary = None
        self._magisk_config_path = None
        self._get_apatch_detailed_modules = None
        self._apatch_modules_summary = None
        self._apatch_version = None
        self._apatch_version_code = None
        self._apatch_app_version = None
        self._apatch_app_version_code = None
        self._apatch_next_app_version = None
        self._apatch_next_app_version_code = None
        self._get_ksu_detailed_modules = None
        self._ksu_modules_summary = None
        self._ksu_version = None
        self._ksu_app_version = None
        self._ksu_version_code = None
        self._ksu_app_version_code = None
        self._ksu_next_version = None
        self._ksu_next_app_version = None
        self._ksu_next_version_code = None
        self._ksu_next_app_version_code = None
        self._get_sukisu_detailed_modules = None
        self._sukisu_modules_summary = None
        self._sukisu_version = None
        self._sukisu_version_code = None
        self._sukisu_app_version = None
        self._sukisu_app_version_code = None
        self._get_wild_ksu_detailed_modules = None
        self._wild_ksu_modules_summary = None
        self._wild_ksu_version = None
        self._wild_ksu_version_code = None
        self._wild_ksu_app_version = None
        self._wild_ksu_app_version_code = None
        self._get_lsposed_detailed_modules = None
        self._lsposed_modules_summary = None
        self._has_init_boot = None
        self._kernel = None
        self._magisk_denylist_enforced = None
        self._magisk_zygisk_enabled = None
        self.packages = {}
        self.backups = {}
        self.vbmeta = {}
        self.props = {}
        self._config_kallsyms = None
        self._config_kallsyms_all = None
        self._tmp_readable = None
        self._partitions = None
        self.bootdevice_string = None
        # vbmeta details are lazy loaded
        self._vbmeta = None

    # ----------------------------------------------------------------------------
    #                               property vbmeta
    # ----------------------------------------------------------------------------
    @property
    def vbmeta(self):
        if self._vbmeta is None:
            self._vbmeta = self.get_vbmeta_details()
        return self._vbmeta

    @vbmeta.setter
    def vbmeta(self, value):
        self._vbmeta = value

    # ----------------------------------------------------------------------------
    #                               property adb_device_info
    # ----------------------------------------------------------------------------
    @property
    def adb_device_info(self):
        if self.mode == 'adb':
            if self._adb_device_info is None:
                self._adb_device_info = self.device_info
            else:
                self._adb_device_info = ''
            return self._adb_device_info

    # ----------------------------------------------------------------------------
    #                               property unlock_ability
    # ----------------------------------------------------------------------------
    @property
    def unlock_ability(self):
        if self.mode == 'adb':
            return
        try:
            theCmd = f"\"{get_fastboot()}\" -s {self.id} flashing get_unlock_ability"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                if res.returncode != 0:
                    return 'UNKNOWN'
            else:
                return 'UNKNOWN'
            lines = (f"{res.stderr}{res.stdout}").splitlines()
            for line in lines:
                if "get_unlock_ability:" in line:
                    value = line.split("get_unlock_ability:")[1].strip()
                    if value == '1':
                        return "Yes"
                    elif value == '0':
                        return "No"
                    else:
                        return "UNKNOWN"
            return 'UNKNOWN'  # Value not found
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get unlock ability.")
            puml("#red:ERROR: Could not get unlock ability;\n", True)
            return 'UNKNOWN'

    # ----------------------------------------------------------------------------
    #                               method get_package_details
    # ----------------------------------------------------------------------------
    def get_package_details(self, package):
        if self.true_mode != 'adb':
            return '', ''
        try:
            theCmd = f"\"{get_adb()}\" -s {self.id} shell dumpsys package {package}"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                path = self.get_path_from_details(res.stdout)
                return res.stdout, path
            else:
                return '', ''
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get_package_details.")
            puml("#red:ERROR: Could not get_package_details;\n", True)
            return '', ''

    # ----------------------------------------------------------------------------
    #                               method get_battery_details
    # ----------------------------------------------------------------------------
    def get_battery_details(self):
        if self.true_mode != 'adb':
            return
        try:
            theCmd = f"\"{get_adb()}\" -s {self.id} shell dumpsys battery"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout
            else:
                return '', ''
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get battery details.")
            puml("#red:ERROR: Could not get battery details;\n", True)
            return '', ''

    # ----------------------------------------------------------------------------
    #                               method get_page_size
    # ----------------------------------------------------------------------------
    def get_page_size(self):
        if self.true_mode != 'adb':
            return
        try:
            theCmd = f"\"{get_adb()}\" -s {self.id} shell getconf PAGE_SIZE"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout.strip('\n')
            else:
                return ''
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get page size")
            puml("#red:ERROR: Could not get page size;\n", True)
            return ''

    # -----------------------------------------------
    #    Function get_path_from_package_details
    # -----------------------------------------------
    def get_path_from_details(self, details):
        try:
            pattern = re.compile(r'(?s)Dexopt state:.*?path:(.*?)\n(?!.*path:)', re.DOTALL)
            match = re.search(pattern, details)
            if match:
                return match[1].strip()
            else:
                return ''
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get_path_from_package_details.")
            puml("#red:ERROR: Could not get_path_from_package_details;\n", True)

    # ----------------------------------------------------------------------------
    #                               property fastboot_device_info
    # ----------------------------------------------------------------------------
    @property
    def fastboot_device_info(self):
        if self.mode == 'f.b':
            if self._fastboot_device_info is None:
                self._fastboot_device_info = self.device_info
            else:
                self._fastboot_device_info = ''
            return self._fastboot_device_info

    # ----------------------------------------------------------------------------
    #                               property device_info
    # ----------------------------------------------------------------------------
    @property
    def device_info(self):
        """
            Retrieves device information based on the mode of operation.

            If the mode is 'adb', it uses the `getprop` command to fetch the device information using ADB.
            If the mode is 'f.b', it uses the `getvar all` command to fetch the device information using Fastboot.

            Returns:
                str: The device information.

            Raises:
                RuntimeError: If the ADB or Fastboot command is not found.

            Example:
                ```python
                phone = Phone()
                info = phone.device_info()
                print(info)
                ```
        """
        if self.mode == 'adb':
            if get_adb():
                if self.rooted:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/bin/getprop\'\""
                else:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell /bin/getprop"
                res = run_shell(theCmd, timeout=10)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 127 or "/system/bin/sh: /bin/getprop: not found" in res.stdout:
                    if self.rooted:
                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'getprop\'\""
                    else:
                        theCmd = f"\"{get_adb()}\" -s {self.id} shell getprop"
                    res = run_shell(theCmd, timeout=10)
                return ''.join(res.stdout)
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adb command is not found!")
                puml("#red:ERROR: adb command is not found!;\n", True)
        elif self.mode == 'f.b':
            if get_fastboot():
                theCmd = f"\"{get_fastboot()}\" -s {self.id} getvar all"
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and (res.stdout == ''):
                    return ''.join(res.stderr)
                else:
                    return ''.join(res.stdout)
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: fastboot command is not found!")
                puml("#red:ERROR: fastboot command is not found!;\n", True)

    # ----------------------------------------------------------------------------
    #                               Method init
    # ----------------------------------------------------------------------------
    def init(self, mode):
        try:
            device_props = DeviceProps()
            if mode == 'f.b':
                device_info = self.fastboot_device_info
            else:
                device_info = self.adb_device_info

            if device_info:
                for line in device_info.split('\n'):
                    try:
                        if not line or ':' not in line:
                            continue

                        line = line.strip()
                        if mode == 'f.b':
                            key, value = line.rsplit(':', 1)
                            key = key.replace('(bootloader) ', 'bootloader_')
                        else:
                            key, value = line.rsplit(': ', 1)
                            key = key.strip('[]')
                            value = value.strip('[]')
                    except Exception as e:
                        continue
                    device_props.upsert(key, value)
                self.props = device_props

            # set has_init_boot
            self._has_init_boot = has_init_boot(self.hardware)
            partitions = self.get_partitions()
            if partitions != -1 and ('init_boot' in partitions or 'init_boot_a' in partitions or 'init_boot_b' in partitions):
                self._has_init_boot = True

        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not init device class")
            puml("#red:ERROR: Could not get_package_details;\n", True)

    # ----------------------------------------------------------------------------
    #                               method get_prop
    # ----------------------------------------------------------------------------
    def get_prop(self, prop, prop2=None):
        if self.props is None:
            return ''
        if self.mode == "f.b":
            res = self.props.get(f"bootloader_{prop}")
            # debug(f"prop: {prop} value: [{res}]")
            if res == 'Property not found' or res is None:
                if not prop2:
                    # debug(f"Property {prop} not found.")
                    return ''
                res = self.props.get(f"bootloader_{prop2}")
                # debug(f"prop2: {prop2} value: [{res}]")
                if res == 'Property not found' or res is None:
                    # debug(f"Bootloader property {prop} and {prop2} are not found.")
                    return ''
                return res
        else:
            res = self.props.get(prop)
            # debug(f"prop: {prop} value: [{res}]")
            if res == 'Property not found' or res is None:
                if prop2:
                    res = self.props.get(prop2)
                    # debug(f"prop2: {prop2} value: [{res}]")
                    if res == 'Property not found' or res is None:
                        # debug(f"Bootloader property {prop} and {prop2} are not found.")
                        return ''
                    return res
                else:
                    # debug(f"Property {prop} not found.")
                    return ''
        return res

    # ----------------------------------------------------------------------------
    #                               method dump_prop
    # ----------------------------------------------------------------------------
    def dump_props(self):  # sourcery skip: use-join
        print("\nDumping properties ...")
        data = ''
        for key, value in self.props.property.items():
            data += f"[{key}]: [{value}]\n"
        print(data)

    # ----------------------------------------------------------------------------
    #                               property has_init_boot
    # ----------------------------------------------------------------------------
    @property
    def has_init_boot(self):
        if self._has_init_boot is None:
            return False
        else:
            return self._has_init_boot

    # ----------------------------------------------------------------------------
    #                               property active_slot
    # ----------------------------------------------------------------------------
    @property
    def active_slot(self):
        res = self.get_prop('current-slot', 'ro.boot.slot_suffix')
        if not res:
            return ''
        if res != '':
            res = res.replace("_", "")
        return res

    # ----------------------------------------------------------------------------
    #                               property inactive_slot
    # ----------------------------------------------------------------------------
    @property
    def inactive_slot(self):
        if self.active_slot is None:
            return ''
        if self.active_slot == 'a':
            return 'b'
        else:
            return 'a'

    # ----------------------------------------------------------------------------
    #                               property build
    # ----------------------------------------------------------------------------
    @property
    def build(self):
        try:
            build =  self.get_prop('ro.build.id')
            if build is not None and build != '':
                return build
            build =  self.ro_build_fingerprint
            if self.ro_build_fingerprint != '':
                return build.split('/')[3]
            else:
                return ''
        except Exception:
            return ''

    # ----------------------------------------------------------------------------
    #                               property api_level
    # ----------------------------------------------------------------------------
    @property
    def firmware_date(self):
        if self.build:
            build_date_match = re.search(r'\b(\d{6})\b', self.build.lower())
            if build_date_match:
                build_date = build_date_match[1]
                return int(build_date)

    # ----------------------------------------------------------------------------
    #                               property api_level
    # ----------------------------------------------------------------------------
    @property
    def api_level(self):
        return self.get_prop('ro.build.version.sdk')

    # ----------------------------------------------------------------------------
    #                               property hardware
    # ----------------------------------------------------------------------------
    @property
    def hardware(self):
        res = self.get_prop('product', 'ro.hardware')
        if res:
            return res
        else:
            return ''

    # ----------------------------------------------------------------------------
    #                               property architecture
    # ----------------------------------------------------------------------------
    @property
    def architecture(self):
        return self.get_prop('ro.product.cpu.abi')

    # ----------------------------------------------------------------------------
    #                               property ro_build_fingerprint
    # ----------------------------------------------------------------------------
    @property
    def ro_build_fingerprint(self):
        res = self.get_prop('ro.build.fingerprint')
        if res == '':
            return f"{self.get_prop('ro.product.brand')}/{self.get_prop('ro.product.name')}/{self.get_prop('ro.product.device')}:{self.get_prop('ro.build.version.release')}/{self.get_prop('ro.build.id')}/{self.get_prop('ro.build.version.incremental')}:{self.get_prop('ro.build.type')}/{self.get_prop('ro.build.tags')}"

    # ----------------------------------------------------------------------------
    #                               property ro_boot_flash_locked
    # ----------------------------------------------------------------------------
    @property
    def ro_boot_flash_locked(self):
        res = self.get_prop('ro.boot.flash.locked')
        if res == '0':
            add_unlocked_device(self.id)
        return res

    # ----------------------------------------------------------------------------
    #                               property ro_boot_vbmeta_device_state
    # ----------------------------------------------------------------------------
    @property
    def ro_boot_vbmeta_device_state(self):
        res = self.get_prop('ro.boot.vbmeta.device_state')
        if res == 'unlocked':
            add_unlocked_device(self.id)
        return res

    # ----------------------------------------------------------------------------
    #                               property ro_boot_verifiedbootstate
    # ----------------------------------------------------------------------------
    @property
    def ro_boot_verifiedbootstate(self):
        res = self.get_prop('ro.boot.verifiedbootstate')
        if res in ['red', 'orange']:
            add_unlocked_device(self.id)
        return res

    # ----------------------------------------------------------------------------
    #                               property unlocked
    # ----------------------------------------------------------------------------
    @property
    def unlocked(self):
        res = self.get_prop('unlocked')
        if res != 'yes':
            return False
        add_unlocked_device(self.id)
        return True

    # ----------------------------------------------------------------------------
    #                               property root_symbol
    # ----------------------------------------------------------------------------
    @property
    def root_symbol(self):
        if self.mode == 'f.b':
            return '?'
        elif self.rooted:
            add_unlocked_device(self.id)
            return '✓'
        else:
            return '✗'

    # ----------------------------------------------------------------------------
    #                               property kernel
    # ----------------------------------------------------------------------------
    @property
    def kernel(self):
        if self._kernel is None and self.true_mode == 'adb':
            try:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell uname -a"
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    self._kernel = res.stdout.strip('\n')
                    # self._kernel = 'Linux localhost 6.1.124-Wild+ #1 SMP PREEMPT Tue Aug 12 05:32:09 UTC 2025 aarch64 Toybox' # for testing
                    match = re.search(r"\b(\d+\.\d+\.\d+-android\d+)\b", self._kernel)
                    if match:
                        self._kmi = match[1]
                    else:
                        self._kmi = None
            except Exception:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get kernel information.")
                traceback.print_exc()
                self._rooted = None
                self._su_version = ''
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None
        return self._kernel

    # ----------------------------------------------------------------------------
    #                               property kmi
    # ----------------------------------------------------------------------------
    @property
    def kmi(self):
        try:
            match = re.search(r"\b(\d+\.\d+\.\d+-android\d+)\b", self.kernel)
            if match:
                return match[1]
            else:
                return ''
        except Exception:
            return ''

    # ----------------------------------------------------------------------------
    #                               property kmi_guessed
    # ----------------------------------------------------------------------------
    @property
    def kmi_guessed(self):
        """
        Guess KMI version for custom kernels that have stripped android build tag.
        Maps kernel major.minor versions to Android versions:
        5.10/5.15 -> Android 13
        6.1 -> Android 14
        6.6 -> Android 15
        6.10 -> Android 16
        """
        try:
            # First try to get the actual KMI if available
            actual_kmi = self.kmi
            if actual_kmi:
                return actual_kmi

            # If no actual KMI, try to guess from kernel version
            if not self.kernel:
                return ''

            # Extract kernel version (e.g., "6.1.124" from the kernel string)
            version_match = re.search(r"\b(\d+)\.(\d+)\.(\d+)", self.kernel)
            if not version_match:
                return ''

            major = int(version_match[1])
            minor = int(version_match[2])
            patch = version_match[3]

            # Map kernel versions to Android versions
            # https://www.hestabit.com/blog/complete-list-of-android-versions/
            android_version = None
            if major == 4 and minor in [4, 9]:
                android_version = "9"
            elif major == 4 and minor == 14:
                android_version = "10"
            elif major == 4 and minor == 19:
                android_version = "11"
            elif major == 5 and minor == 4:
                android_version = "12"
            elif major == 5 and minor in [10, 15]:
                android_version = "13"
            elif major == 6 and minor == 1:
                android_version = "14"
            elif major == 6 and minor == 6:
                android_version = "15"
            elif major == 6 and minor == 10:
                android_version = "16"

            if android_version:
                return f"{major}.{minor}.{patch}-android{android_version}"
            else:
                return ''

        except Exception:
            return ''

    # ----------------------------------------------------------------------------
    #                               property is_gki
    # ----------------------------------------------------------------------------
    @property
    def is_gki(self):
        try:
            ro_kernel_version = self.get_prop('ro.kernel.version')
            if parse(ro_kernel_version) >= parse('5.4'):
                return True
            else:
                return False
        except Exception:
            return False

    # ----------------------------------------------------------------------------
    #                               property magisk_path
    # ----------------------------------------------------------------------------
    @property
    def magisk_path(self):
        try:
            magisk_path = get_magisk_package()
            if self.true_mode == 'adb' and magisk_path is not None and magisk_path != '':
                res = self.get_package_path(magisk_path, True)
                if res != -1:
                    return res
                self._rooted = None
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None
                return None
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get magisk path")
            traceback.print_exc()
        return None

    # ----------------------------------------------------------------------------
    #                               property root_version
    # ----------------------------------------------------------------------------
    @property
    def root_version(self):
        try:
            if self.true_mode == 'adb' and self.rooted:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'su -v\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    root_version = res.stdout.strip('\n')
                    return root_version
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get root_version")
            traceback.print_exc()
        return ''

    # ----------------------------------------------------------------------------
    #                               property ksu_path
    # ----------------------------------------------------------------------------
    @property
    def ksu_path(self):
        try:
            if self.true_mode == 'adb':
                res = self.get_package_path(KERNEL_SU_PKG_NAME, True)
                if res != -1:
                    return res
                self._rooted = None
                self._su_version = ''
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None
                return None
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get KernelSU path")
            traceback.print_exc()
        return None

    # ----------------------------------------------------------------------------
    #                               property ksu_next_path
    # ----------------------------------------------------------------------------
    @property
    def ksu_next_path(self):
        try:
            if self.true_mode == 'adb':
                res = self.get_package_path(KSU_NEXT_PKG_NAME, True)
                if res != -1:
                    return res
                self._rooted = None
                self._su_version = ''
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None
                return None
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get KernelSU Next path")
            traceback.print_exc()
        return None

    # ----------------------------------------------------------------------------
    #                               property sukisu_path
    # ----------------------------------------------------------------------------
    @property
    def sukisu_path(self):
        try:
            if self.true_mode == 'adb':
                res = self.get_package_path(SUKISU_PKG_NAME, True)
                if res != -1:
                    return res
                self._rooted = None
                self._su_version = ''
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None
                return None
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get SukiSU path")
            traceback.print_exc()
        return None

    # ----------------------------------------------------------------------------
    #                               property wild_ksu_path
    # ----------------------------------------------------------------------------
    @property
    def wild_ksu_path(self):
        try:
            if self.true_mode == 'adb':
                res = self.get_package_path(WILD_KSU_PKG_NAME, True)
                if res != -1:
                    return res
                self._rooted = None
                self._su_version = ''
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None
                return None
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get Wild_KSU path")
            traceback.print_exc()
        return None

    # ----------------------------------------------------------------------------
    #                               property apatch_path
    # ----------------------------------------------------------------------------
    @property
    def apatch_path(self):
        try:
            if self.true_mode == 'adb':
                res = self.get_package_path(APATCH_PKG_NAME, True)
                if res != -1:
                    return res
                self._rooted = None
                self._su_version = ''
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None
                return None
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get APatch path")
            traceback.print_exc()
        return None

    # ----------------------------------------------------------------------------
    #                               property magisk_version
    # ----------------------------------------------------------------------------
    @property
    def magisk_version(self):
        if self._magisk_version is None and self.true_mode == 'adb' and self.rooted:
            try:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'magisk -c\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    regex = re.compile(r"(.*?):.*\((.*?)\)")
                    m = re.findall(regex, res.stdout)
                    if m:
                        self._magisk_version = f"{m[0][0]}:{m[0][1]}"
                        self._magisk_version_code = f"{m[0][1]}"
                    else:
                        self._magisk_version = res.stdout
                        self._magisk_version_code = res.stdout
                        self._magisk_version_code = self._magisk_version.strip(':')
                    self._magisk_version = self._magisk_version.strip('\n')
            except Exception:
                try:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/adb/magisk/magisk32 -c\'\""
                    res = run_shell(theCmd)
                    if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                        self._magisk_version = res.stdout.strip('\n')
                        self._magisk_version_code = self._magisk_version.strip(':')
                except Exception:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get magisk version, assuming that it is not rooted.")
                    traceback.print_exc()
                    self._rooted = None
                    self._su_version = ''
                    self._magisk_denylist_enforced = None
                    self._magisk_zygisk_enabled = None
        return self._magisk_version

    # ----------------------------------------------------------------------------
    #                               method _get_root_solution_version
    # ----------------------------------------------------------------------------
    def _get_root_solution_version(self, solution_type):
        if solution_type == 'apatch':
            cmd_name = 'apd'
            primary_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'apd -V\'\""
            fallback_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/adb/apd -V\'\""
        elif solution_type == 'ksu':
            cmd_name = 'ksud'
            primary_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud -V\'\""
            fallback_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/adb/ksud -V\'\""
        elif solution_type == 'sukisu':
            cmd_name = 'ksud'
            primary_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud -V\'\""
            fallback_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/adb/ksud -V\'\""
        elif solution_type == 'wild_ksu':
            cmd_name = 'ksud'
            primary_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud -V\'\""
            fallback_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/adb/ksud -V\'\""
        else:
            return None, None

        try:
            res = run_shell(primary_cmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                # Both APatch and KSU return format like "apd 10930" or "ksud 12345"
                output = res.stdout.strip('\n')
                parts = output.split()
                if len(parts) >= 2 and parts[0] == cmd_name:
                    version_code = parts[1]
                    version = f"{cmd_name}:{version_code}"
                    return version, version_code
                else:
                    # Fallback to original parsing for compatibility in case it changes to Magisk style
                    regex = re.compile(r"(.*?):.*\((.*?)\)")
                    m = re.findall(regex, output)
                    if m:
                        version = f"{m[0][0]}:{m[0][1]}"
                        version_code = f"{m[0][1]}"
                        return version, version_code
                    else:
                        version = output
                        version_code = output.strip(':')
                        return version, version_code
        except Exception:
            try:
                res = run_shell(fallback_cmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    output = res.stdout.strip('\n')
                    parts = output.split()
                    if len(parts) >= 2 and parts[0] == cmd_name:
                        version_code = parts[1]
                        version = f"{cmd_name}:{version_code}"
                        return version, version_code
                    else:
                        version = output
                        version_code = output.strip(':')
                        return version, version_code
            except Exception:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get {cmd_name} version, assuming that it is not rooted.")
                traceback.print_exc()
                self._rooted = None
                self._su_version = ''
                self._magisk_denylist_enforced = None
                self._magisk_zygisk_enabled = None

        return None, None

    # ----------------------------------------------------------------------------
    #                               property apatch_version
    # ----------------------------------------------------------------------------
    @property
    def apatch_version(self):
        if self._apatch_version is None and self.true_mode == 'adb' and self.rooted:
            self._apatch_version, self._apatch_version_code = self._get_root_solution_version('apatch')
        return self._apatch_version

    # ----------------------------------------------------------------------------
    #                               property ksu_version
    # ----------------------------------------------------------------------------
    @property
    def ksu_version(self):
        if self._ksu_version is None and self.true_mode == 'adb' and self.rooted:
            self._ksu_version, self._ksu_version_code = self._get_root_solution_version('ksu')
        return self._ksu_version

    # ----------------------------------------------------------------------------
    #                               property sukisu_version
    # ----------------------------------------------------------------------------
    @property
    def sukisu_version(self):
        if self._sukisu_version is None and self.true_mode == 'adb' and self.rooted:
            self._sukisu_version, self._sukisu_version_code = self._get_root_solution_version('sukisu')
        return self._sukisu_version

    # ----------------------------------------------------------------------------
    #                               property wild_ksu_version
    # ----------------------------------------------------------------------------
    @property
    def wild_ksu_version(self):
        if self._wild_ksu_version is None and self.true_mode == 'adb' and self.rooted:
            self._wild_ksu_version, self._wild_ksu_version_code = self._get_root_solution_version('wild_ksu')
        return self._wild_ksu_version

    # ----------------------------------------------------------------------------
    #                               property magisk_version_code
    # ----------------------------------------------------------------------------
    @property
    def magisk_version_code(self):
        if self._magisk_version_code is None:
            return ''
        else:
            return self._magisk_version_code

    # ----------------------------------------------------------------------------
    #                               property apatch_version_code
    # ----------------------------------------------------------------------------
    @property
    def apatch_version_code(self):
        if self._apatch_version_code is None:
            return ''
        else:
            return self._apatch_version_code

    # ----------------------------------------------------------------------------
    #                               property ksu_version_code
    # ----------------------------------------------------------------------------
    @property
    def ksu_version_code(self):
        if self._ksu_version_code is None:
            return ''
        else:
            return self._ksu_version_code

    # ----------------------------------------------------------------------------
    #                               property sukisu_version_code
    # ----------------------------------------------------------------------------
    @property
    def sukisu_version_code(self):
        if self._sukisu_version_code is None:
            return ''
        else:
            return self._sukisu_version_code

    # ----------------------------------------------------------------------------
    #                               property wild_ksu_version_code
    # ----------------------------------------------------------------------------
    @property
    def wild_ksu_version_code(self):
        if self._wild_ksu_version_code is None:
            return ''
        else:
            return self._wild_ksu_version_code

    # ----------------------------------------------------------------------------
    #                               property magisk_config_path
    # ----------------------------------------------------------------------------
    @property
    def magisk_config_path(self):
        if self._magisk_config_path is None and self.true_mode == 'adb' and self.rooted:
            try:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls -1 $(magisk --path)/.magisk/config\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    self._magisk_config_path = res.stdout.strip('\n')
                else:
                    self._magisk_config_path = None
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get magisk sha1.")
                puml("#red:ERROR: Could not get magisk sha1;\n", True)
                self._magisk_config_path = None
        return self._magisk_config_path

    # ----------------------------------------------------------------------------
    #                               property current_device_print
    # ----------------------------------------------------------------------------
    @property
    def current_device_print(self):
        return process_dict(the_dict=self.props.property, add_missing_keys=True, pif_flavor='playintegrityfork_9999999')

    # ----------------------------------------------------------------------------
    #                               property current_device_props_in_json
    # ----------------------------------------------------------------------------
    @property
    def current_device_props_as_json(self):  # sourcery skip: use-join
        return json.dumps(self.props.property, indent=4)

    # ----------------------------------------------------------------------------
    #                               method get_partitions
    # ----------------------------------------------------------------------------
    def get_partitions(self):
        if self._partitions is not None:
            return self._partitions
        try:
            if self.true_mode != 'adb':
                return -1

            self.bootdevice_string = ''
            if self.rooted:
                res, unused = self.check_file('/dev/block/bootdevice/by-name', True, False)
                if res == 1:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cd /dev/block/bootdevice/by-name/; ls -1 .\'\""
                    self.bootdevice_string = '/dev/block/bootdevice/by-name/'
                else:
                    res, unused = self.check_file('/dev/block/by-name', True, False)
                    if res == 1:
                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cd /dev/block/by-name/; ls -1 .\'\""
                        self.bootdevice_string = '/dev/block/by-name/'
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get partitions list.")
                        self.bootdevice_string = None
                        return -1

            else:
                res, unused = self.check_file('/dev/block/bootdevice/by-name', False, False)
                if res == 1:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell cd /dev/block/bootdevice/by-name/; ls -1 ."
                    self.bootdevice_string = '/dev/block/bootdevice/by-name/'
                else:
                    res, unused = self.check_file('/dev/block/by-name', False, False)
                    if res == 1:
                        theCmd = f"\"{get_adb()}\" -s {self.id} shell cd /dev/block/by-name/; ls -1 ."
                        self.bootdevice_string = '/dev/block/by-name/'
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get partitions list.")
                        self.bootdevice_string = None
                        return -1

            try:
                res = run_shell(theCmd, timeout=5)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    list = res.stdout.split('\n')
                else:
                    return -1
                if not list:
                    return -1
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get partitions list.")
                puml("#red:ERROR: Could not get partitions list.;\n", True)
                return -1
            self._partitions = list
            return list
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_partitions.")
            puml("#red:Encountered an error in get_partitions.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               method get_bl_status
    # ----------------------------------------------------------------------------
    def get_bl_status(self):
        bl_status = 'locked'
        if self.rooted:
            bl_status = 'unlocked'
        elif self.ro_boot_flash_locked == False:
            bl_status = 'unlocked'
        elif self.ro_boot_vbmeta_device_state == 'unlocked':
            bl_status = 'unlocked'
        elif self.ro_boot_verifiedbootstate in ['red', 'orange']:
            bl_status = 'unlocked'
        elif self.unlocked:
            bl_status = 'unlocked'
        return bl_status

    # ----------------------------------------------------------------------------
    #                               method get_verity_verification
    # ----------------------------------------------------------------------------
    def get_verity_verification(self, item):
        if self.true_mode != 'adb':
            return -1
        if not self.rooted:
            return -1

        try:
            res = self.push_avbctl()
            if res != 0:
                return -1

            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/local/tmp/avbctl get-{item}\'\""
            print(f"Checking {item} status: ...")
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout
            print(f"Return Code: {res.returncode}")
            print(f"Stdout: {res.stdout}")
            print(f"Stderr: {res.stderr}")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get {item} status.")
            puml(f"#red:ERROR: Could not get {item} status.;\n", True)
            return -1
        finally:
            res = self.delete("/data/local/tmp/avbctl", self.rooted)

    # ----------------------------------------------------------------------------
    #                               method reset_ota_update
    # ----------------------------------------------------------------------------
    def reset_ota_update(self):
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: reset_ota_update function is only available in adb mode.\nAborting ...")
            return -1
        if not self.rooted:
            return -1

        try:
            res = self.push_update_engine_client(local_filename="update_engine_client_r72")
            if res != 0:
                return -1

            print("Cancelling ongoing OTA update (if one is in progress) ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/local/tmp/update_engine_client --cancel\'\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"{res.stdout} {res.stderr}")
                if (res.returncode == 1 or "CANNOT LINK EXECUTABLE" in res.stderr):
                    print("Trying again with an older binary to Cancel ongoing OTA update (if one is in progress) ...")
                    res = self.push_update_engine_client(local_filename="update_engine_client_r28")
                    if res != 0:
                        return -1
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/local/tmp/update_engine_client --cancel\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"{res.stdout} {res.stderr}")
                    if not (res.returncode == 0 or res.returncode == 248):
                        return -1

            print("Resetting an already applied update (if one exists) ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/local/tmp/update_engine_client --reset_status\'\""
            res = run_shell2(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout
            print(f"Return Code: {res.returncode}")
            print(f"Stdout: {res.stdout}")
            print(f"Stderr: {res.stderr}")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an exception if reset_ota_update function.")
            puml(f"#red:ERROR: Encountered an exception if reset_ota_update function.;\n", True)
            return -1
        finally:
            res = self.delete("/data/local/tmp/update_engine_client", self.rooted)


    # ----------------------------------------------------------------------------
    #                               method get_vbmeta_details
    # ----------------------------------------------------------------------------
    def get_vbmeta_details(self):
        if self.true_mode != 'adb' or not self.rooted:
            return None
        try:
            # Use _vbmeta directly to avoid recursion through the property
            if self._vbmeta:
                self._vbmeta.clear()
            vbmeta_a = ''
            vbmeta_b = ''
            vbmeta_a_only = ''
            vbmeta = Vbmeta()
            vbmeta.type = 'none'
            partitions = self.get_partitions()

            if "vbmeta_a" in partitions:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'dd if=/dev/block/bootdevice/by-name/vbmeta_a bs=1 skip=123 count=1 status=none | xxd -p\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    vbmeta.type = 'ab'
                    vbmeta_a = int(res.stdout.strip('\n'))
            if "vbmeta_b" in partitions:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'dd if=/dev/block/bootdevice/by-name/vbmeta_b bs=1 skip=123 count=1 status=none | xxd -p\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    vbmeta.type = 'ab'
                    vbmeta_b = int(res.stdout.strip('\n'))
            if "vbmeta_a" not in partitions and "vbmeta_b" not in partitions and "vbmeta" in partitions:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'dd if=/dev/block/bootdevice/by-name/vbmeta bs=1 skip=123 count=1 status=none | xxd -p\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    vbmeta.type = 'a_only'
                    vbmeta_a_only = int(res.stdout.strip('\n'))

            if vbmeta_a == 0:
                vbmeta.verity_a = True
                vbmeta.verification_a = True
            elif vbmeta_a == 1:
                vbmeta.verity_a = False
                vbmeta.verification_a = True
            elif vbmeta_a == 2:
                vbmeta.verity_a = True
                vbmeta.verification_a = False
            elif vbmeta_a == 3:
                vbmeta.verity_a = False
                vbmeta.verification_a = False

            if vbmeta_b == 0:
                vbmeta.verity_b = True
                vbmeta.verification_b = True
            elif vbmeta_b == 1:
                vbmeta.verity_b = False
                vbmeta.verification_b = True
            elif vbmeta_b == 2:
                vbmeta.verity_b = True
                vbmeta.verification_b = False
            elif vbmeta_b == 3:
                vbmeta.verity_b = False
                vbmeta.verification_b = False

            if vbmeta.type == "a_only":
                if vbmeta_a_only == 0:
                    vbmeta.verity_a = True
                    vbmeta.verification_a = True
                elif vbmeta_a_only == 1:
                    vbmeta.verity_a = False
                    vbmeta.verification_a = True
                elif vbmeta_a_only == 2:
                    vbmeta.verity_a = True
                    vbmeta.verification_a = False
                elif vbmeta_a_only == 3:
                    vbmeta.verity_a = False
                    vbmeta.verification_a = False

            self.vbmeta = vbmeta
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get vbmeta details.")
            puml("#red:ERROR: Could not get vbmeta details.;\n", True)
            return vbmeta
        return vbmeta

    # ----------------------------------------------------------------------------
    #                               method get_magisk_backups
    # ----------------------------------------------------------------------------
    def get_magisk_backups(self):
        if self.true_mode != 'adb' or not self.rooted:
            return -1
        try:
            self.backups.clear()
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls -l -d -1 /data/magisk_backup_*\'\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                list = res.stdout.split('\n')
            else:
                return -1
            if not list:
                return -1
            for item in list:
                if item:
                    regex = re.compile(r"d.+root\sroot\s\w+\s(.*)\s\/data\/magisk_backup_(.*)")
                    m = re.findall(regex, item)
                    if m:
                        backup_date = f"{m[0][0]}"
                        backup_sha1 = f"{m[0][1]}"
                    backup = Backup(backup_sha1)
                    backup.date = backup_date
                    with contextlib.suppress(Exception):
                        backup.firmware = self.get_firmware_from_boot(backup_sha1)
                    self.backups[backup_sha1] = backup
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get backup list.")
            puml("#red:ERROR: Could not get backup list.;\n", True)
            return -1
        return 0

    # ----------------------------------------------------------------------------
    #                      function get_firmware_from_boot
    # ----------------------------------------------------------------------------
    def get_firmware_from_boot(self, sha1):
        try:
            con = get_db_con()
            if con is None:
                return None
            cursor = con.cursor()
            cursor.execute(f"SELECT package_sig FROM PACKAGE WHERE boot_hash = '{sha1}'")
            data = cursor.fetchall()
            if len(data) > 0:
                return data[0][0]
            else:
                return ''
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting firmware from boot.")
            puml("#red:Encountered an error while while getting firmware from boot.;\n")
            traceback.print_exc()

    # ----------------------------------------------------------------------------
    #                               property magisk_backups
    # ----------------------------------------------------------------------------
    @property
    def magisk_backups(self):
        if self.true_mode == 'adb' and self.rooted:
            try:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls -d -1 /data/magisk_backup_*\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    _magisk_backups = res.stdout.replace('/data/magisk_backup_', '').split('\n')
                else:
                    _magisk_backups = None
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get magisk backups.")
                puml("#red:ERROR: Could not get magisk backups;\n", True)
                _magisk_backups = None
        if _magisk_backups:
            return _magisk_backups
        else:
            return ''

    # ----------------------------------------------------------------------------
    #                               property magisk_sha1
    # ----------------------------------------------------------------------------
    @property
    def magisk_sha1(self):
        if self.true_mode == 'adb' and self.rooted:
            try:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cat $(magisk --path)/.magisk/config | grep SHA1 | cut -d \'=\' -f 2\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    _magisk_sha1 = res.stdout.strip('\n')
                else:
                    _magisk_sha1 = ''
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get magisk sha1.")
                puml("#red:ERROR: Could not get magisk sha1;\n", True)
                _magisk_sha1 = ''
        if _magisk_sha1:
            return _magisk_sha1
        else:
            return ''

    # ----------------------------------------------------------------------------
    #                               method exec_magisk_settings
    # ----------------------------------------------------------------------------
    def exec_magisk_settings(self, data, runshell_mode=2):
        if self.true_mode != 'adb' or not self.rooted:
            return
        try:
            if not data:
                return -1

            config = get_config()
            config_path = get_config_path()
            if config.use_busybox_shell:
                busybox_shell_cmd = "/data/adb/magisk/busybox ash"
            else:
                busybox_shell_cmd = ""
            script_path = "/data/local/tmp/pfmagisk_settings.sh"
            exec_cmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'{busybox_shell_cmd} {script_path}\'\""
            the_script = os.path.join(config_path, 'tmp', 'pfmagisk_settings.sh')

            # create the script
            with open(the_script.strip(), "w", encoding="ISO-8859-1", errors="replace", newline='\n') as f:
                # data += "\n"
                f.write(data)
                puml(f"note right\nMagisk update script\n====\n{data}\nend note\n")
            if runshell_mode == 2:
                print("PixelFlasher Magisk update script contents:")
                print(f"___________________________________________________\n{data}")
                print("___________________________________________________\n")

            # Transfer Magisk update script to the phone
            res = self.push_file(f"{the_script}", script_path, with_su=False)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to transfer Magisk update script to the phone;\n")
                return -1

            # set the permissions.
            res = self.set_file_permissions(script_path, "755", False)
            if res != 0:
                print("Aborting ...\n")
                puml("#red:Failed to set the executable bit on Magisk update script;\n")
                return -1

            #------------------------------------
            # Execute the pfmagisk_settings.sh script
            #------------------------------------
            debug("Executing the pfmagisk_settings.sh script ...")
            puml(":Executing the pfmagisk_settings script;\n")
            debug(f"exec_cmd: {exec_cmd}")
            if runshell_mode == 1:
                res = run_shell(exec_cmd)
                return res
            elif runshell_mode == 2:
                res = run_shell2(exec_cmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    # delete existing pfmagisk_settings.sh from phone
                    res2 = self.delete("/data/local/tmp/pfmagisk_settings.sh")
                    if res2 != 0:
                        print("Failed to delete temporary pfmagisk_settings.sh file\n")
                        puml("#red:Failed to delete temporary pfmagisk_settings.sh file;\n")
                        return -1
                    else:
                        return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during pfmagisk_settings script execution")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml("note right:ERROR: during pfmagisk_settings script execution;\n")
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during exec_magisk_settings operation.")
            traceback.print_exc()
            puml("#red:Exception during exec_magisk_settings operation.;\n", True)
            return -1
        finally:
            if script_path:
                res = self.delete(script_path, self.rooted)


    # ----------------------------------------------------------------------------
    #                               method magisk_add_systemless_hosts
    # ----------------------------------------------------------------------------
    def magisk_add_systemless_hosts(self):
        if self.true_mode == 'adb' and self.rooted:
            try:
                print("Magisk adding built-in systemless hosts module ...")
                puml(":Magisk adding built-in systemless hosts module;\n", True)

                data = """
add_hosts_module() {
  # Do not touch existing hosts module
  [ -d $NVBASE/modules/hosts ] && return
  cd $NVBASE/modules
  mkdir -p hosts/system/etc
  cat << EOF > hosts/module.prop
id=hosts
name=Systemless Hosts
version=1.0
versionCode=1
author=Magisk
description=Magisk app built-in systemless hosts module
EOF
  magisk --clone /system/etc/hosts hosts/system/etc/hosts
  touch hosts/update
  cd /
}

NVBASE=/data/adb
add_hosts_module
                """
                res = self.exec_magisk_settings(data)
                if res == 0:
                    print("Magisk adding built-in systemless hosts module succeeded")
                    puml("note right:Magisk adding built-in systemless hosts module;\n")
                    return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to add built-in systemless hosts module.")
                    puml("note right:ERROR: Failed to add built-in systemless hosts module;\n")
                    return -1
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during magisk_add_systemless_hosts operation.")
                traceback.print_exc()
                puml("#red:Exception during magisk_add_systemless_hosts operation.;\n", True)


    # ----------------------------------------------------------------------------
    #                               method magisk_enable_zygisk
    # ----------------------------------------------------------------------------
    def magisk_enable_zygisk(self, enable):
        if self.true_mode == 'adb' and self.rooted:
            try:
                value = "1" if enable else "0"
                print(f"Updating Zygisk flag value to: {value}")
                puml(f":Updating Zygisk flag value to: {value};\n", True)

                data = f"magisk --sqlite \"UPDATE settings SET value = {value} WHERE key = 'zygisk';\""
                res = self.exec_magisk_settings(data)
                if res == 0:
                    print("Updating Zygisk flag succeeded")
                    puml("note right:Updating Zygisk flag succeeded;\n")
                    return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to update Zygisk flag")
                    puml("note right:ERROR: Updating Zygisk flag;\n")
                    return -1
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during magisk_enable_zygisk operation.")
                traceback.print_exc()
                puml("#red:Exception during magisk_enable_zygisk operation.;\n", True)


    # ----------------------------------------------------------------------------
    #                               method magisk_modify_root_access
    # ----------------------------------------------------------------------------
    def magisk_modify_root_access(self, value):
        # https://github.com/topjohnwu/Magisk/blob/a4b8c5e46b02b12b222638edb5c841903678a203/app/core/src/main/java/com/topjohnwu/magisk/core/Config.kt#L60-L61
        # const val ROOT_ACCESS_DISABLED = 0
        # const val ROOT_ACCESS_APPS_ONLY = 1
        # const val ROOT_ACCESS_ADB_ONLY = 2
        # const val ROOT_ACCESS_APPS_AND_ADB = 3
        if self.true_mode == 'adb' and self.rooted:
            try:
                value = str(value)
                print(f"Updating Root Access flag value to: {value}")
                puml(f":Updating Root Access flag value to: {value};\n", True)

                data = f"magisk --sqlite \"INSERT OR REPLACE INTO settings (key, value) VALUES ('root_access', {value});\""
                res = self.exec_magisk_settings(data)
                if res == 0:
                    print("Updating Root Access flag succeeded")
                    puml("note right:Updating Root Access flag succeeded;\n")
                    return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to update Root Access flag")
                    puml("note right:ERROR: Updating Root Access flag;\n")
                    return -1
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during magisk_modify_root_access operation.")
                traceback.print_exc()
                puml("#red:Exception during magisk_modify_root_access operation.;\n", True)


    # ----------------------------------------------------------------------------
    #                               method magisk_enable_denylist
    # ----------------------------------------------------------------------------
    def magisk_enable_denylist(self, enable):
        if self.true_mode != 'adb' or not self.rooted:
            return
        try:
            if get_magisk_package() == MAGISK_DELTA_PKG_NAME:
                print("Magisk denylist is currently not supported in PixelFlasher for Magisk Delta.")
                return
            value = "1" if enable else "0"
            print(f"Updating Enforce denylist flag value to: {value}")
            puml(f":Updating Enforce denylist flag value to: {value};\n", True)

            data = f"magisk --sqlite \"UPDATE settings SET value = {value} WHERE key = 'denylist';\""
            res = self.exec_magisk_settings(data)
            if res == 0:
                print("Updating Enforce denylist flag succeeded")
                puml("note right:Updating Enforce denylist flag succeeded;\n")
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to update Enforce denylist flag")
                puml("note right:ERROR: Updating Enforce denylist flag;\n")
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during magisk_enable_denylist operation.")
            traceback.print_exc()
            puml("#red:Exception during magisk_enable_denylist operation.;\n", True)


    # ----------------------------------------------------------------------------
    #                               method magisk_update_su
    # ----------------------------------------------------------------------------
    def magisk_update_su(self, uid, policy, logging, notification, until=0, label=''):
        if self.true_mode == 'adb' and self.rooted:
            try:
                if policy == "allow":
                    value = 2
                elif policy == "deny":
                    value = 1
                else:
                    return
                print(f"\nSetting SU permissions for: {label}")
                print(f"    uid:          {uid}")
                print(f"    rights:       {policy}")
                print(f"    Notification: {notification}")
                print(f"    Logging:      {logging}")
                puml(f":Setting SU permissions for: {label} {uid};\n", True)

                data = f"magisk --sqlite \"INSERT OR REPLACE INTO policies (uid, policy, logging, notification, until) VALUES ('{uid}', {value}, {logging}, {notification}, {until});\""
                res = self.exec_magisk_settings(data)
                if res == 0:
                    print("Setting SU permissions succeeded")
                    puml("note right:Setting SU permissions succeeded;\n")
                    return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to Setting SU permissions")
                    puml("note right:ERROR: Setting SU permissions flag;\n")
                    return -1
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during magisk_update_su operation.")
                traceback.print_exc()
                puml("#red:Exception during magisk_update_su operation.;\n", True)


    # ----------------------------------------------------------------------------
    #                               Method run_magisk_migration
    # ----------------------------------------------------------------------------
    def run_magisk_migration(self, sha1 = None):
        if self.true_mode == 'adb' and self.rooted:
            try:
                print("Making sure stock_boot.img is found on the device ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls -l /data/adb/magisk/stock_boot.img\'\""
                res = run_shell(theCmd)
                # expect 0
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: /data/adb/magisk/stock_boot.img is not found!")
                        print("Aborting run_migration ...\n")
                        return -2
                else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: /data/adb/magisk/stock_boot.img is not found!")
                        print("Aborting run_migration ...\n")
                        return -2

                print("Triggering Magisk run_migration to create a Backup of source boot.img")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cd /data/adb/magisk; ./magiskboot cleanup; . ./util_functions.sh; run_migrations\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if sha1:
                        magisk_backups = self.magisk_backups
                        if self.magisk_backups and sha1 in magisk_backups:
                            print(f"Magisk backup for {sha1} was successful")
                            return 0
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Magisk backup failed.")
                return -1
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Magisk backup failed.")
                return -1
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: run_migration function is only available in adb mode on rooted devices.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method data_adb_backup
    # ----------------------------------------------------------------------------
    def data_adb_backup(self, filename):
        try:
            if self.true_mode == 'adb' and self.rooted:
                try:
                    print("Creating a backup of /data/adb, please be patient ...")
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'rm -f /data/local/tmp/data_adb.tgz; tar cvfz /data/local/tmp/data_adb.tgz --sparse /data/adb/\'\""
                    res = run_shell(theCmd)
                    # expect 0
                    if res and isinstance(res, subprocess.CompletedProcess):
                        debug(f"Return Code: {res.returncode}")
                        debug(f"Stdout: {res.stdout}")
                        debug(f"Stderr: {res.stderr}")
                        if res.returncode != 0:
                            print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: backup of /data/adb may have failed or produced warnings.")
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to create a backup of /data/adb")
                        print("Aborting ...\n")
                        return -2

                    wx.Yield()
                    # check if backup got created.
                    print("\nChecking to see if backup file [/data/local/tmp/data_adb.tgz] got created ...")
                    res, unused = self.check_file("/data/local/tmp/data_adb.tgz")
                    if res != 1:
                        print("Aborting ...\n")
                        puml("#red:Failed to find /data/local/tmp/data_adb.tgz on the phone;\n}\n")
                        return -2

                    print(f"Pulling /data/local/tmp/data_adb.tgz from the phone to: {filename} ...")
                    res = self.pull_file("/data/local/tmp/data_adb.tgz", f"\"{filename}\"")
                    if res != 0:
                        print("Aborting ...\n")
                        puml("#red:Failed to pull /data/local/tmp/data_adb.tgz from the phone;\n}\n")
                        return -2
                except Exception as e:
                    traceback.print_exc()
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: In function data_adb_backup.")
                    return -1
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: data_adb_backup function is only available in adb mode on rooted devices.")
                return -1
            print("Backup completed.")
            return 0
        finally:
            res = self.delete("/data/local/tmp/data_adb.tgz", self.rooted)

    # ----------------------------------------------------------------------------
    #                               Method data_adb_restore
    # ----------------------------------------------------------------------------
    def data_adb_restore(self, filename):
        if self.true_mode == 'adb' and self.rooted:
            try:
                print(f"Pushing {filename} to /data/local/tmp/data_adb.tgz on the phone ...")
                res = self.push_file(filename, "/data/local/tmp/data_adb.tgz", True)
                if res != 0:
                    print("Aborting ...\n")
                    return -1

                # check if backup got created.
                print("\nChecking to see if backup file [/data/local/tmp/data_adb.tgz] got pushed ...")
                res, unused = self.check_file("/data/local/tmp/data_adb.tgz", True)
                if res != 1:
                    print("Aborting ...\n")
                    puml("#red:Failed to find /data/local/tmp/data_adb.tgz on the phone;\n}\n")
                    return -1

                print("Restoring a backup of /data/adb ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cd /; tar xvfz /data/local/tmp/data_adb.tgz --sparse\'\""
                res = run_shell(theCmd)
                # expect 0
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        print("Restore completed.")
                        return 0
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to restore a backup of /data/adb.")
                print("Aborting ...\n")
                return -2
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: In function data_adb_restore.")
                print("Aborting ...\n")
                return -1
            finally:
                res = self.delete("/data/local/tmp/data_adb.tgz", self.rooted)
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: data_adb_restore function is only available in adb mode on rooted devices.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method data_adb_clear
    # ----------------------------------------------------------------------------
    def data_adb_clear(self):
        if self.true_mode == 'adb' and self.rooted:
            try:
                print("Clearing the contents of /data/adb/ ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'rm -rf /data/adb/*\'\""
                res = run_shell(theCmd)
                # expect 0
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        print("Clearing completed.")
                        return 0
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to clear the contents of /data/adb/")
                print("Aborting ...\n")
                return -2
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: In function data_adb_clear.")
                return -1
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: data_adb_clear function is only available in adb mode on rooted devices.")
            return -1

    # ----------------------------------------------------------------------------
    #                   Method create_magisk_backup (not used)
    # ----------------------------------------------------------------------------
    def create_magisk_backup(self, sha1 = None):
        if self.true_mode == 'adb' and self.rooted and sha1:
            try:
                print("Getting the current SHA1 from Magisk config ...")
                magisk_sha1 = self.magisk_sha1
                print(f"The Current SHA1 in Magisk config is: {magisk_sha1}")

                boot_img = os.path.join(get_boot_images_dir(), sha1, 'boot.img')
                if not os.path.exists(boot_img):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: boot.img with SHA1 of {sha1} is not found.")
                    print("Aborting backup ...\n")
                    return -1
                # Transfer boot image to the device
                print(f"Transferring {boot_img} to the device in /data/local/tmp/stock_boot.img ...")

                res = self.push_file(f"{boot_img}", "/data/local/tmp/stock_boot.img")
                if res != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {boot_img}")
                    return -1

                # copy stock_boot from /data/local/tmp folder
                print("Copying /data/local/tmp/stock_boot.img to /data/adb/magisk/stock_boot.img ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cp /data/adb/magisk/stock_boot.img /data/adb/magisk/stock_boot.img\'\""
                debug(theCmd)
                res = run_shell(theCmd)
                # expect ret 0
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
                        print("Aborting Backup...\n")
                        return -1
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error.")
                    print("Aborting Backup...\n")
                    return -1

                # trigger run migration
                print("Triggering Magisk run_migration to create a Backup ...")
                res = self.run_magisk_migration(sha1)
                if res < 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Magisk backup failed.")
                    return -1

                # read config
                print("Getting the SHA1 from Magisk config again ...")
                magisk_sha1 = self.magisk_sha1
                print(f"SHA1 from Magisk config is: {magisk_sha1}")
                if sha1 != magisk_sha1:
                    print(f"Updating Magisk Config SHA1 to {sha1} to match the SHA1 of the source boot.img ...")
                    res = self.update_magisk_config(sha1)
                    if res == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not update Magisk config")
                        return -1
                    else:
                        print(f"Magisk config successfully updated with SHA1: {sha1}")

                return 0
            except Exception as e:
                traceback.print_exc()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Magisk backup failed.")
                return -1
            finally:
                res = self.delete("/data/local/tmp/stock_boot.img")
        return -1

    # ----------------------------------------------------------------------------
    #                               Method update_magisk_config
    # ----------------------------------------------------------------------------
    def update_magisk_config(self, sha1 = None):
        if self.true_mode != 'adb' or not self.rooted or not sha1:
            return -1
        try:
            magisk_config_path = self.magisk_config_path
            if magisk_config_path:
                print("Getting the current SHA1 from Magisk config ...")
                magisk_sha1 = self.magisk_sha1
                print(f"The Current SHA1 in Magisk config is: {magisk_sha1}")
                print(f"Changing Magisk config SHA1 to: {sha1} ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cd {magisk_config_path}; toybox sed -i \"s/{magisk_sha1}/{sha1}/g\" config\'\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    # Read back to make sure it us updated
                    print("Getting back the SHA1 from Magisk config ...")
                    magisk_sha1 = self.magisk_sha1
                    print(f"SHA1 from Magisk config is: {magisk_sha1}")
                    if magisk_sha1 != sha1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not update Magisk config")
                        return -1
                    else:
                        print(f"Magisk config successfully updated with SHA1: {sha1}")
                        return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not update Magisk config")
                    return -1
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get Magisk config")
                return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get magisk sha1.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method delete
    # ----------------------------------------------------------------------------
    def delete(self, file_path: str, with_su = False, dir = False) -> int:
        """Method deletes a file on the device.

        Args:
            file_path:  Full file path
            with_su:    Perform the action as root (Default: False)
            dir:        Delete a directory instead of file (Default: False [file])

        Returns:
            0           if file is deleted or not found.
            -1          if an exception is raised.
        """
        flag = ''
        if dir:
            flag = 'r'
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not delete {file_path}. Device is not in ADB mode.")
            return -1
        try:
            file_path = remove_quotes(file_path)
            if with_su:
                if self.rooted:
                    debug(f"Deleting {file_path} from the device as root ...")
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'rm -{flag}f \"{file_path}\"\'\""
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not delete {file_path}. Device is not rooted.")
            else:
                debug(f"Deleting {file_path} from the device ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell rm -{flag}f \"{file_path}\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Returncode: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode == 0:
                    return 0
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not delete {file_path}")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not delete {file_path}")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method dump_partition
    # ----------------------------------------------------------------------------
    def dump_partition(self, file_path: str = '', slot: str = '', partition = '') -> int:
        """Method dumps active boot / init_boot partition on device.

        Args:
            file_path:      Full file path (Default in: /data/local/tmp/ <boot | init_boot>)
            partition:      If specified, then the specified partition will be dumped, otherwise it will be boot on init_boot
            slot:           If slot is specified, then it will dump the specified slot instead of the active one. (Default: '')
                            The active slot selection only applies if partition is not specified.
                            If partition is specified, then the dump will be without the _slot, unless slot is also specified.

        Returns:
            0, dumped_path  if boot partition is dumped.
            -1, ''          if an exception is raised.
        """
        if self.true_mode != 'adb' and self.rooted:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not dump partition. Device must be in ADB mode and be rooted.")
            return -1, ''
        try:
            if partition == '':
                if slot not in ['a', 'b']:
                    slot = self.active_slot
                # decide on boot.img or init_boot.img
                if has_init_boot(self.hardware):
                    partition = 'init_boot'
                else:
                    partition = 'boot'
            if slot:
                partition = f"{partition}_{slot}"
            if not file_path:
                file_path = f"/data/local/tmp/{partition}.img"

            debug(f"Dumping partition to file: {file_path} ...")
            puml(f":Dump Partition;\nnote right:Partition: {partition};\n", True)
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'dd if={self.bootdevice_string}/{partition} of={file_path}\'\""
            debug(theCmd)
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Returncode: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode == 0:
                    return 0, file_path
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not dump the partition")
            return -1, ''
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not dump the partition")
            return -1, ''

    # ----------------------------------------------------------------------------
    #                               Method su_cp_on_device
    # ----------------------------------------------------------------------------
    def su_cp_on_device(self, source: str, dest, quiet = False) -> int:
        """Method copies file as su from device to device.

        Args:
            source:     Source file path
            dest:       Destination file path

        Returns:
            0           if copy is successful.
            -1          if an exception is raised.
        """
        if self.true_mode != 'adb' or not self.rooted:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not copy. Device is not in ADB mode or is not rooted.")
            return -1
        try:
            source = remove_quotes(source)
            dest = remove_quotes(dest)
            debug(f"Copying {source} to {dest} ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cp \"{source}\" \"{dest}\";chmod 666 \"{dest}\"\'\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Returncode: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode == 0 and res.stderr == '':
                    return 0
            if not quiet:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not su cp.")
            return -1
        except Exception as e:
            traceback.print_exc()
            if not quiet:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not su cp.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method check_file
    # ----------------------------------------------------------------------------
    def check_file(self, file_path: str, with_su = False, verbose = True):
        """Method checks if a file exists on the device.

        Args:
            file_path:  Full file path
            with_su:    Perform the action as root (Default: False)

        Returns:
            1,  matches       if file is found.
            0,  None          if file is not found.
            -1, None          if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not check {file_path}. Device is not in ADB mode.")
            return -1, None
        if not file_path or file_path.isspace():
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not check empty file path.")
            return -1, None
        try:
            file_path = remove_quotes(file_path)
            if with_su:
                if self.rooted:
                    debug(f"Checking for {file_path} on the device as root ...")
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls \"{file_path}\"\'\""
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not check {file_path}. Device is not rooted.")
            else:
                debug(f"Checking for {file_path} on the device ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell ls \"{file_path}\""
            res = run_shell(theCmd, timeout=3)
            if res and isinstance(res, subprocess.CompletedProcess):
                # don't output debug when checking partitions as it's too verbose
                if not '/dev/block/' in file_path:
                    debug(f"Returncode: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                if  res.returncode == 0:
                    if "No such file or directory" not in f"{res.stdout} {res.stderr}":
                        if verbose:
                            print(f"File: {file_path} is found on the device.")
                        else:
                            debug(f"File: {file_path} is found on the device.")
                        return 1, res.stdout.strip()
                    else:
                        if verbose:
                            print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Got returncode 0 but also file not found message.")
                        else:
                            debug(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Got returncode 0 but also file not found message.")
                        return 0, None
            if verbose:
                print(f"File: {file_path} is not found on the device.")
            else:
                debug(f"File: {file_path} is not found on the device.")
            return 0, None
        except Exception as e:
            traceback.print_exc()
            if verbose:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not check {file_path}")
            else:
                debug(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not check {file_path}")
            return -1, None

    # ----------------------------------------------------------------------------
    #                               Method create_dir
    # ----------------------------------------------------------------------------
    def create_dir(self, dir_path: str, with_su = False) -> int:
        """Method creates a directory on the device.

        Args:
            dir_path:   Full directory path
            with_su:    Perform the action as root (Default: False)

        Returns:
            0           if directory is created.
            -1          if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not check {dir_path}. Device is not in ADB mode.")
            return -1
        try:
            dir_path = remove_quotes(dir_path)
            if with_su:
                if self.rooted:
                    debug(f"Creating directory {dir_path} on the device as root ...")
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'mkdir -p \"{dir_path}\"\'\""
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not create directory {dir_path}. Device is not rooted.")
            else:
                debug(f"Creating directory {dir_path} on the device ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell mkdir -p \"{dir_path}\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Returncode: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode == 0:
                    return 0
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not create directory: {dir_path}")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not create directory: {dir_path}")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method get_logcat
    # ----------------------------------------------------------------------------
    def get_logcat(self, filter: str, with_su = False) -> str:
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get_logcat. Device is not in ADB mode.")
            return -1
        try:
            extra_options = ""
            if filter:
                extra_options = f" | grep -i {filter}"

            debug(f"Getting device logcat with filter [{filter}] ...")
            if with_su:
                if self.rooted:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'logcat -d {extra_options} \'\""
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get logcat as root. Device is not rooted.")
            else:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"logcat -d {extra_options} \""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                return(f"{res.stdout}\n{res.stderr}")
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get logcat")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method file_content
    # ----------------------------------------------------------------------------
    def file_content(self, file_path: str, with_su = False, verbose = True) -> int:
        """Method cats the file content.

        Args:
            file_path:  Full file path
            with_su:    Perform the action as root (Default: False)

        Returns:
            filecontent if it exists
            -1          if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get file content of {file_path}. Device is not in ADB mode.")
            return -1
        try:
            file_path = remove_quotes(file_path)
            if with_su:
                if self.rooted:
                    debug(f"Getting file content of {file_path} on the device as root ...")
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cat \"{file_path}\"\'\""
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get file content of {file_path}. Device is not rooted.")
            else:
                debug(f"Getting file content of {file_path} on the device ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell cat \"{file_path}\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Returncode: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode == 0:
                    return res.stdout
            if verbose:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get file content: {file_path} or file does not exist.")
            else:
                debug(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get file content: {file_path} or file does not exist.")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get file content: {file_path}")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method push_file
    # ----------------------------------------------------------------------------
    def push_file(self, local_file: str, file_path: str, with_su = False) -> int:
        """
            Pushes a file to the device.

            Args:
                local_file (str): Local file path.
                file_path (str): Full file path on the device.
                with_su (bool, optional): Perform the action as root. Defaults to False.

            Returns:
                int: 0 if the file is pushed, -1 if an exception is raised.

            Raises:
                None

            Example:
                ```python
                phone = Phone()
                result = phone.push_file("local_file.txt", "/data/files/file.txt", with_su=True)
                print(result)
                ```
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {file_path}. Device is not in ADB mode.")
            return -1
        try:
            local_file = remove_quotes(local_file)
            file_path = remove_quotes(file_path)
            if with_su:
                if self.rooted:
                    debug(f"Pushing local file as root: {local_file} to the device: {file_path} ...")
                    filename = os.path.basename(urlparse(local_file).path)
                    remote_file = f"\"/data/local/tmp/{filename}\""
                    res = self.push_file(local_file, remote_file, with_su=False)
                    if res != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {local_file}")
                        return -1
                    res = self.su_cp_on_device(remote_file, file_path)
                    if res != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not copy {remote_file}")
                        return -1
                    return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not copy to {file_path}. Device is not rooted.")
                    return -1
            else:
                debug(f"Pushing local file: {local_file} to the device: {file_path} ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} push \"{local_file}\" \"{file_path}\""
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Returncode: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        return 0
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {file_path}")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {file_path}")
            return -1
        finally:
            if with_su:
                res = self.delete(remote_file, with_su=True)

    # ----------------------------------------------------------------------------
    #                               Method pull_file
    # ----------------------------------------------------------------------------
    def pull_file(self, remote_file: str, local_file: str, with_su = False, quiet = False) -> int:
        """Method pulls a file from the device.

        Args:
            remote_file:    Full file path on the device
            local_file:     Local file path.
            with_su:        Perform the action as root (Default: False)

        Returns:
            0               if file is pulled.
            -1              if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not pull {remote_file}. Device is not in ADB mode.")
            return -1
        try:
            remote_file = remove_quotes(remote_file)
            local_file = remove_quotes(local_file)
            if with_su:
                if self.rooted:
                    filename = os.path.basename(urlparse(remote_file).path)
                    temp_remote_file = f"/data/local/tmp/{filename}"
                    # delete the remote target file first
                    res = self.delete(temp_remote_file, with_su=True)
                    if res != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not delete {temp_remote_file}.")
                        return -1
                    res = self.su_cp_on_device(source=remote_file, dest=temp_remote_file, quiet=quiet)
                    if res != 0:
                        if not quiet:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not copy {remote_file} to {temp_remote_file}. Perhaps the file does not exist.")
                        return -1
                    else:
                        remote_file = temp_remote_file
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not pull {remote_file}. Device is not rooted.")
                    return -1

            # delete local file if it exists
            if os.path.exists(local_file):
                debug(f"Deleting local file: {local_file} ...")
                os.remove(local_file)
            debug(f"Pulling remote file: {remote_file} from the device to: {local_file} ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} pull \"{remote_file}\" \"{local_file}\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Returncode: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode == 0:
                    return 0
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not pull {remote_file}")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not pull {remote_file}")
            return -1
        finally:
            if with_su:
                res = self.delete(temp_remote_file, with_su=True)

    # ----------------------------------------------------------------------------
    #                               Method set_file_permissions
    # ----------------------------------------------------------------------------
    def set_file_permissions(self, file_path: str, permissions: str = "755", with_su = False) -> int:
        """Method sets file permissions on the device.

        Args:
            permissions:    Permissions. (Default 755)
            file_path:      Full file path on the device
            with_su:        Perform the action as root (Default: False)

        Returns:
            0               On Success.
            -1              if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set permissions on {file_path}. Device is not in ADB mode.")
            return -1
        try:
            file_path = remove_quotes(file_path)
            if with_su:
                if self.rooted:
                    debug(f"Setting permissions {permissions} on {file_path} as root ...")
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'chmod {permissions} \"{file_path}\"\'\""
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set permissions on {file_path}. Device is not rooted.")
            else:
                debug(f"Setting permissions {permissions} on {file_path} on the device ...")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell chmod {permissions} \"{file_path}\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Returncode: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode == 0:
                    return 0
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set permission on {file_path}")
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set permission on {file_path}")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method push_aapt2
    # ----------------------------------------------------------------------------
    def push_aapt2(self, file_path = "/data/local/tmp/aapt2") -> int:
        """Method pushes aapt2 binary to the device.

        Args:
            file_path:      Full file path on the device (Default: /data/local/tmp/aapt2)

        Returns:
            0               On Success.
            -1              if an exception is raised.
        """
        try:
            # Transfer extraction script to the phone
            path_to_aapt2 = os.path.join(get_bundle_dir(),'bin', f"aapt2_{self.architecture}")
            res = self.push_file(f"{path_to_aapt2}", f"{file_path}")
            if res != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {file_path}")
                return -1
            # set the permissions.
            res = self.set_file_permissions(f"{file_path}", "755")
            if res != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set permission on {file_path}")
                return -1
            return 0
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while pushing aapt.")
            puml("#red:Encountered an error while pushing appt.;\n")
            traceback.print_exc()

    # ----------------------------------------------------------------------------
    #                               Method push_avbctl
    # ----------------------------------------------------------------------------
    def push_avbctl(self, file_path = "/data/local/tmp/avbctl") -> int:
        """Method pushes avbctl binary to the device.

        Args:
            file_path:      Full file path on the device (Default: /data/local/tmp/avbctl)

        Returns:
            0               On Success.
            -1              if an exception is raised.
        """
        try:
            # Transfer extraction script to the phone
            if self.architecture in ['armeabi-v7a', 'arm64-v8a']:
                path_to_avbctl = os.path.join(get_bundle_dir(),'bin', 'avbctl')
                res = self.push_file(f"{path_to_avbctl}", f"{file_path}")
                if res != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {file_path}")
                    return -1
                # set the permissions.
                res = self.set_file_permissions(f"{file_path}", "755")
                if res != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set permission on {file_path}")
                    return -1
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: avbctl is not available for device architecture: {self.architecture}")
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while pushing avbctl")
            puml("#red:Encountered an error while pushing avbctl;\n")
            traceback.print_exc()

    # ----------------------------------------------------------------------------
    #                               Method push_update_engine_client
    # ----------------------------------------------------------------------------
    def push_update_engine_client(self, local_filename = 'update_engine_client_r72', file_path = "/data/local/tmp/update_engine_client") -> int:
        try:
            # Transfer extraction script to the phone
            if self.architecture in ['armeabi-v7a', 'arm64-v8a']:
                path_to_update_engine_client = os.path.join(get_bundle_dir(),'bin', local_filename)
                res = self.push_file(f"{path_to_update_engine_client}", f"{file_path}")
                if res != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not push {file_path}")
                    return -1
                # set the permissions.
                res = self.set_file_permissions(f"{file_path}", "755")
                if res != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not set permission on {file_path}")
                    return -1
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: update_engine_client is not available for device architecture: {self.architecture}")
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while pushing update_engine_client")
            puml("#red:Encountered an error while pushing update_engine_client;\n")
            traceback.print_exc()

    # ----------------------------------------------------------------------------
    #                               Method get_package_path
    # ----------------------------------------------------------------------------
    def get_package_path(self, pkg: str, check_details = True) -> str:
        """Method gets a package's apk path on device.

        Args:
            pkg:        Package

        Returns:
            pkg_path    on success returns package apk path.
            -1          if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} path. Device is not in ADB mode.")
            return -1
        try:
            print(f"Getting package {pkg} path on the device ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell pm path {pkg}"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                pkg_path = ''
                with contextlib.suppress(Exception):
                    pkg_path = res.stdout.split('\n')[0]
                    pkg_path = pkg_path.split(':')[1]
                    print(f"Package Path is: {pkg_path}")
                return pkg_path
            else:
                if check_details:
                    details, pkg_path = self.get_package_details(pkg)
                    if pkg_path:
                        print(f"Package Path is: {pkg_path}")
                        return pkg_path
                print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Could not get package {pkg} path.")
                print(f"{details}")
                return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} path.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method get_package_label
    # ----------------------------------------------------------------------------
    def get_package_label(self, pkg: str, pkg_path = '') -> str:
        """Method package label (App name) given a package name.

        Args:
            pkg:        Package
            pkg_path:   Package APK path, if provided, the Method skips figuring it out (faster). Default ''

        Returns:
            label, icon on success returns label (App name) and Icon path.
            -1          if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} label. Device is not in ADB mode.")
            return -1, -1
        print()
        try:
            if pkg_path == '':
                pkg_path = self.get_package_path(f"{pkg}", True)
                if pkg_path == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} label.")
                    return -1, -1
                print(f"    Package Path: {pkg_path}")
            print(f"Getting package {pkg} label from the device ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"/data/local/tmp/aapt2 d badging {pkg_path} | grep 'application: label='\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                # print(res.stdout)
                regex = re.compile("application: label='(.*)' icon='(.*)'")
                m = re.findall(regex, res.stdout)
                if m:
                    pkg_label = f"{m[0][0]}"
                    pkg_icon = f"{m[0][1]}"
                print(f"{pkg} label is: {pkg_label}")
                return pkg_label, pkg_icon
            elif res.stderr.startswith("ERROR getting 'android:icon'"):
                # try another way
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"/data/local/tmp/aapt2 d badging {pkg_path} | grep 'application-label:'\""
                res = run_shell(theCmd)
                # print(res.stdout)
                regex = re.compile("application-label:'(.*)'")
                m = re.findall(regex, res.stdout)
                if m:
                    pkg_label = f"{m[0]}"
                print(f"{pkg} label is: {pkg_label}")
                return pkg_label, ''
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} label.")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                return -1, -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} label.")
            return -1, -1

    # ----------------------------------------------------------------------------
    #                               Method get_package_permissions
    # ----------------------------------------------------------------------------
    def get_package_permissions(self, pkg: str, pkg_path = '') -> str:
        """Method package permissions (App name) given a package name.

        Args:
            pkg:        Package
            pkg_path:   Package APK path, if provided, the Method skips figuring it out (faster). Default ''

        Returns:
            permissions on success.
            -1          if an exception is raised.
        """
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} permissions. Device is not in ADB mode.")
            return -1, -1
        print()
        try:
            if pkg_path == '':
                pkg_path = self.get_package_path(f"{pkg}", True)
                if pkg_path == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} permissions.")
                    return -1, -1
                debug(f"    Package Path: {pkg_path}")
            print(f"Getting package {pkg} permissions from the device ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"/data/local/tmp/aapt2 d permissions {pkg_path}\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} permissions.")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package {pkg} permissions.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method uiautomator_dump
    # ----------------------------------------------------------------------------
    def uiautomator_dump(self, path: str):
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not uiautomator dump. Device is not in ADB mode.")
            return -1
        try:
            print(f"uiautomator dump {path} path on the device ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell uiautomator dump {path}"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0 and res.stderr == '':
                return path
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: uiautomator dump failed.")
            print(res.stderr)
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: not uiautomator dump.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method click
    # ----------------------------------------------------------------------------
    def click(self, coords):
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not tap. Device is not in ADB mode.")
            return -1
        if coords is None or coords == '' or coords == -1:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not tap. Coordinates are [{coords}]")
            return -1
        try:
            print(f"tap {coords} on the device ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell input tap {coords}"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return 0
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: tap failed.")
            print(res.stderr)
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: tap failed.")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method swipe
    # ----------------------------------------------------------------------------
    def swipe(self, coords):
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not swipe. Device is not in ADB mode.")
            return -1
        if coords is None or coords == '' or coords == -1:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not swipe. Coordinates are [{coords}]")
            return -1
        try:
            # Convert coordinates to integers
            int_coords = ' '.join(map(lambda x: str(int(float(x))), coords.split()))
            print(f"swipe {int_coords} on the device ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell input swipe {int_coords}"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return 0
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: swipe failed.")
            print(res.stderr)
            return -1
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: swipe failed.")
            return -1

    # ----------------------------------------------------------------------------
    #                               property magisk_app_version
    # ----------------------------------------------------------------------------
    @property
    def magisk_app_version(self):
        if self._magisk_app_version is None and self.true_mode == 'adb' and get_magisk_package():
            self._magisk_app_version, self._magisk_app_version_code = self.get_app_version(get_magisk_package())
        return self._magisk_app_version

    # ----------------------------------------------------------------------------
    #                               property ksu_app_version
    # ----------------------------------------------------------------------------
    @property
    def ksu_app_version(self):
        if self._ksu_app_version is None and self.true_mode == 'adb':
            self._ksu_app_version, self._ksu_app_version_code = self.get_app_version(KERNEL_SU_PKG_NAME)
        return self._ksu_app_version

    # ----------------------------------------------------------------------------
    #                               property ksu_next_app_version
    # ----------------------------------------------------------------------------
    @property
    def ksu_next_app_version(self):
        if self._ksu_next_app_version is None and self.true_mode == 'adb':
            self._ksu_next_app_version, self._ksu_next_app_version_code = self.get_app_version(KSU_NEXT_PKG_NAME)
        return self._ksu_next_app_version

    # ----------------------------------------------------------------------------
    #                               property sukisu_app_version
    # ----------------------------------------------------------------------------
    @property
    def sukisu_app_version(self):
        if self._sukisu_app_version is None and self.true_mode == 'adb':
            self._sukisu_app_version, self._sukisu_app_version_code = self.get_app_version(SUKISU_PKG_NAME)
        return self._sukisu_app_version

    # ----------------------------------------------------------------------------
    #                               property wild_ksu_app_version
    # ----------------------------------------------------------------------------
    @property
    def wild_ksu_app_version(self):
        if self._wild_ksu_app_version is None and self.true_mode == 'adb':
            self._wild_ksu_app_version, self._wild_ksu_app_version_code = self.get_app_version(WILD_KSU_PKG_NAME)
        return self._wild_ksu_app_version

    # ----------------------------------------------------------------------------
    #                               property apatch_app_version
    # ----------------------------------------------------------------------------
    @property
    def apatch_app_version(self):
        if self._apatch_app_version is None and self.true_mode == 'adb':
            self._apatch_app_version, self._apatch_app_version_code = self.get_app_version(APATCH_PKG_NAME)
        return self._apatch_app_version

    # ----------------------------------------------------------------------------
    #                               property apatch_next_app_version
    # ----------------------------------------------------------------------------
    @property
    def apatch_next_app_version(self):
        if self._apatch_next_app_version is None and self.true_mode == 'adb':
            self._apatch_next_app_version, self._apatch_next_app_version_code = self.get_app_version(APATCH_NEXT_PKG_NAME)
        return self._apatch_next_app_version

    # ----------------------------------------------------------------------------
    #                               property config_kallsyms
    # ----------------------------------------------------------------------------
    @property
    def config_kallsyms(self):
        if self._config_kallsyms is None and self.true_mode == 'adb':
            self._config_kallsyms = self.get_config_kallsyms()
        return self._config_kallsyms

    # ----------------------------------------------------------------------------
    #                               method get_config_kallsyms
    # ----------------------------------------------------------------------------
    def get_config_kallsyms(self):
        if self.true_mode != 'adb':
            return
        try:
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"zcat /proc/config.gz | grep -w CONFIG_KALLSYMS\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout.strip('\n')
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: when getting config_kallsyms")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                return ''
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get config_kallsyms")
            puml("#red:ERROR: Could not get config_kallsyms;\n", True)
            return ''

    # ----------------------------------------------------------------------------
    #                               property config_kallsyms_all
    # ----------------------------------------------------------------------------
    @property
    def config_kallsyms_all(self):
        if self._config_kallsyms_all is None and self.true_mode == 'adb':
            self._config_kallsyms_all = self.get_config_kallsyms_all()
        return self._config_kallsyms_all

    # ----------------------------------------------------------------------------
    #                               method get_config_kallsyms_all
    # ----------------------------------------------------------------------------
    def get_config_kallsyms_all(self):
        if self.true_mode != 'adb':
            return
        try:
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"zcat /proc/config.gz | grep -w CONFIG_KALLSYMS_ALL\""
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout.strip('\n')
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: when getting config_kallsyms")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                return ''
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get config_kallsyms_all")
            puml("#red:ERROR: Could not get config_kallsyms_all;\n", True)
            return ''

    # ----------------------------------------------------------------------------
    #                               method app_version
    # ----------------------------------------------------------------------------
    def get_app_version(self, pkg):
        version = ''
        versionCode = ''
        if pkg and self.true_mode == 'adb':
            try:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell dumpsys package {pkg}"
                res = run_shell(theCmd)
                data = res.stdout.split('\n')
                for line in data:
                    if re.search('versionCode', line):
                        versionCode = line.split('=')
                        versionCode = versionCode[1]
                        versionCode = versionCode.split(' ')
                        versionCode = versionCode[0]
                    if re.search('versionName', line):
                        version = line.split('=')
                        version = version[1]
            except Exception:
                return '', ''
        # return version, versionCode
        if version == '' and versionCode == '':
            return '', ''
        return f"{str(version)}:{str(versionCode)}", versionCode

    # ----------------------------------------------------------------------------
    #                               property magisk_app_version_code
    # ----------------------------------------------------------------------------
    @property
    def magisk_app_version_code(self):
        if self._magisk_app_version_code is None:
            return ''
        else:
            return self._magisk_app_version_code

    # ----------------------------------------------------------------------------
    #                               property apatch_app_version_code
    # ----------------------------------------------------------------------------
    @property
    def apatch_app_version_code(self):
        if self._apatch_app_version_code is None:
            return ''
        else:
            return self._apatch_app_version_code

    # ----------------------------------------------------------------------------
    #                               property apatch_next_app_version_code
    # ----------------------------------------------------------------------------
    @property
    def apatch_next_app_version_code(self):
        if self._apatch_next_app_version_code is None:
            return ''
        else:
            return self._apatch_next_app_version_code

    # ----------------------------------------------------------------------------
    #                               property ksu_app_version_code
    # ----------------------------------------------------------------------------
    @property
    def ksu_app_version_code(self):
        if self._ksu_app_version_code is None:
            return ''
        else:
            return self._ksu_app_version_code

    # ----------------------------------------------------------------------------
    #                               property ksu_next_app_version_code
    # ----------------------------------------------------------------------------
    @property
    def ksu_next_app_version_code(self):
        if self._ksu_next_app_version_code is None:
            return ''
        else:
            return self._ksu_next_app_version_code

    # ----------------------------------------------------------------------------
    #                               property sukisu_app_version_code
    # ----------------------------------------------------------------------------
    @property
    def sukisu_app_version_code(self):
        if self._sukisu_app_version_code is None:
            return ''
        else:
            return self._sukisu_app_version_code

    # ----------------------------------------------------------------------------
    #                               property wild_ksu_app_version_code
    # ----------------------------------------------------------------------------
    @property
    def wild_ksu_app_version_code(self):
        if self._wild_ksu_app_version_code is None:
            return ''
        else:
            return self._wild_ksu_app_version_code

    # ----------------------------------------------------------------------------
    #                               Method get_uncached_magisk_app_version
    # ----------------------------------------------------------------------------
    def get_uncached_magisk_app_version(self):
        self._magisk_app_version = None
        return self.magisk_app_version

    # ----------------------------------------------------------------------------
    #                               Method get_uncached_ksu_app_version
    # ----------------------------------------------------------------------------
    def get_uncached_ksu_app_version(self):
        self._ksu_app_version = None
        return self.ksu_app_version

    # ----------------------------------------------------------------------------
    #                               Method get_uncached_ksu_next_app_version
    # ----------------------------------------------------------------------------
    def get_uncached_ksu_next_app_version(self):
        self._ksu_next_app_version = None
        return self.ksu_next_app_version

    # ----------------------------------------------------------------------------
    #                               Method get_uncached_sukisu_app_version
    # ----------------------------------------------------------------------------
    def get_uncached_sukisu_app_version(self):
        self._sukisu_app_version = None
        return self.sukisu_app_version

    # ----------------------------------------------------------------------------
    #                               Method get_uncached_wild_ksu_app_version
    # ----------------------------------------------------------------------------
    def get_uncached_wild_ksu_app_version(self):
        self._wild_ksu_app_version = None
        return self.wild_ksu_app_version

    # ----------------------------------------------------------------------------
    #                               Method get_uncached_apatch_app_version
    # ----------------------------------------------------------------------------
    def get_uncached_apatch_app_version(self):
        self._apatch_app_version = None
        return self.apatch_app_version

    # ----------------------------------------------------------------------------
    #                               Method get_uncached_apatch_next_app_version
    # ----------------------------------------------------------------------------
    def get_uncached_apatch_next_app_version(self):
        self._apatch_next_app_version = None
        return self.apatch_next_app_version

    # ----------------------------------------------------------------------------
    #                               Method is_display_unlocked
    # ----------------------------------------------------------------------------
    def is_display_unlocked(self):
        print("Checking to see if display is unlocked ...")
        try:
            if self.true_mode == 'adb':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"dumpsys power | grep \'mHolding\'\""
                res = run_shell(theCmd)
                mHoldingWakeLockSuspendBlocker = False
                mHoldingDisplaySuspendBlocker = False
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    results = res.stdout.strip().split('\n')
                    for m in results:
                        s = False
                        k, v = m.strip().split('=')
                        if v == 'true':
                            s = True
                        if k == 'mHoldingDisplaySuspendBlocker':
                            mHoldingDisplaySuspendBlocker = s
                        elif k == 'mHoldingWakeLockSuspendBlocker':
                            mHoldingWakeLockSuspendBlocker = s
                # https://stackoverflow.com/questions/35275828/is-there-a-way-to-check-if-android-device-screen-is-locked-via-adb
                # I'm not going to check for both flags as it is not reliable
                # But this won't work if display is on but locked :(
                # if mHoldingWakeLockSuspendBlocker and mHoldingDisplaySuspendBlocker:
                if mHoldingDisplaySuspendBlocker:
                    print("Display is unlocked")
                    return True
                else:
                    print("Display is locked")
                    return False
        except Exception:
            print("Display is locked")
            return False

    # ----------------------------------------------------------------------------
    #                               Method stop_magisk
    # ----------------------------------------------------------------------------
    def stop_magisk(self):
        try:
            print("Stopping Magisk ...")
            with contextlib.suppress(Exception):
                self.perform_package_action(get_magisk_package(), 'kill')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during stop_magisk")
            traceback.print_exc()

    # ----------------------------------------------------------------------------
    #                               method _get_json_modules_common
    # ----------------------------------------------------------------------------
    def _get_json_modules_common(self, solution_name):
        try:
            config = get_config()
            if self.true_mode != 'adb' or not self.rooted:
                return []

            if solution_name == 'APatch':
                cmd = 'apd'
            elif solution_name == 'KernelSU':
                cmd = 'ksud'
            elif solution_name == 'SukiSU':
                cmd = 'ksud'
            elif solution_name == 'Wild_KSU':
                cmd = 'ksud'
            else:
                return []

            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'/data/adb/{cmd} module list\'\""
            res = run_shell(theCmd, encoding='utf-8')

            if not (res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error when processing {solution_name} Modules.")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                return []

            modules = []
            try:
                module_data = json.loads(res.stdout)

                for item in module_data:
                    if not item:
                        continue

                    # Create Magisk module object to maintain compatibility with existing code
                    module_id = item.get('id', '')
                    m = Magisk(module_id)

                    # Map JSON fields to Magisk object attributes
                    setattr(m, 'id', module_id)
                    setattr(m, 'name', item.get('name', ''))
                    setattr(m, 'version', item.get('version', ''))
                    setattr(m, 'versionCode', item.get('versionCode', ''))
                    setattr(m, 'author', item.get('author', ''))
                    setattr(m, 'description', item.get('description', ''))
                    setattr(m, 'updateJson', item.get('updateJson', ''))
                    setattr(m, 'updateDetails', {})
                    setattr(m, 'updateAvailable', False)
                    setattr(m, 'updateIssue', False)

                    # Map specific fields to match Magisk structure
                    enabled = item.get('enabled', 'false')
                    remove = item.get('remove', 'false')
                    action = item.get('action', 'false')

                    # Convert string boolean to actual state
                    if remove == 'true':
                        m.state = 'remove'
                    elif enabled == 'false':
                        m.state = 'disabled'
                    else:
                        m.state = 'enabled'

                    # Set hasAction based on action field
                    setattr(m, 'hasAction', action == 'true')

                    # Check for module updates if enabled in config
                    if m.updateJson and config.check_module_updates:
                        setattr(m, 'updateDetails', check_module_update(m.updateJson))

                    # Check if update is available
                    with contextlib.suppress(Exception):
                        if m.versionCode and m.updateDetails and m.updateDetails.versionCode and int(m.updateDetails.versionCode) > int(m.versionCode):
                            m.updateAvailable = True

                    modules.append(m)

                return modules

            except json.JSONDecodeError as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to parse {solution_name} module JSON response")
                print(f"JSON Error: {e}")
                return []

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during {solution_name} modules processing")
            traceback.print_exc()
            return []

    # ----------------------------------------------------------------------------
    #                               method get_apatch_detailed_modules
    # ----------------------------------------------------------------------------
    def get_apatch_detailed_modules(self, refresh=False):
        if self._get_apatch_detailed_modules is None or refresh == True:
            self._get_apatch_detailed_modules = self._get_json_modules_common('APatch')
        return self._get_apatch_detailed_modules

    # ----------------------------------------------------------------------------
    #                               method get_ksu_detailed_modules
    # ----------------------------------------------------------------------------
    def get_ksu_detailed_modules(self, refresh=False):
        if self._get_ksu_detailed_modules is None or refresh == True:
            self._get_ksu_detailed_modules = self._get_json_modules_common('KernelSU')
        return self._get_ksu_detailed_modules

    # ----------------------------------------------------------------------------
    #                               method get_sukisu_detailed_modules
    # ----------------------------------------------------------------------------
    def get_sukisu_detailed_modules(self, refresh=False):
        if self._get_sukisu_detailed_modules is None or refresh == True:
            self._get_sukisu_detailed_modules = self._get_json_modules_common('SukiSU')
        return self._get_sukisu_detailed_modules

    # ----------------------------------------------------------------------------
    #                               method get_wild_ksu_detailed_modules
    # ----------------------------------------------------------------------------
    def get_wild_ksu_detailed_modules(self, refresh=False):
        if self._get_wild_ksu_detailed_modules is None or refresh == True:
            self._get_wild_ksu_detailed_modules = self._get_json_modules_common('Wild_KSU')
        return self._get_wild_ksu_detailed_modules

    # ----------------------------------------------------------------------------
    #                               method get_magisk_detailed_modules
    # ----------------------------------------------------------------------------
    def  get_magisk_detailed_modules(self, refresh=False):
        if self._get_magisk_detailed_modules is None or refresh == True:
            try:
                config = get_config()
                if self.true_mode == 'adb' and self.rooted:
                    if sys.platform == "win32":
                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'for FILE in /data/adb/modules/*; do if test -d \"$FILE\"; then echo $FILE; if test -f \"$FILE/remove\"; then echo \"state=remove\"; elif test -f \"$FILE/disable\"; then echo \"state=disabled\"; else echo \"state=enabled\"; fi; if test -f \"$FILE/action.sh\"; then echo \"hasAction=True\"; else echo \"hasAction=False\"; fi; cat \"$FILE/module.prop\"; echo; echo -----pf; fi; done\'\""
                        res = run_shell(theCmd, encoding='utf-8')
                        if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                            modules = []
                            themodules = res.stdout.split('-----pf\n')
                            for item in themodules:
                                if item:
                                    module_prop = item.split('\n')
                                    filepath = module_prop[0]
                                    module = os.path.basename(urlparse(filepath).path)
                                    if module == 'lost+found':
                                        continue
                                    m = Magisk(module)
                                    setattr(m, 'id', '')
                                    setattr(m, 'version', '')
                                    setattr(m, 'versionCode', '')
                                    setattr(m, 'author', '')
                                    setattr(m, 'description', '')
                                    setattr(m, 'name', '')
                                    setattr(m, 'updateJson', '')
                                    setattr(m, 'updateDetails', {})
                                    setattr(m, 'updateAvailable', False)
                                    setattr(m, 'updateIssue', False)
                                    setattr(m, 'hasAction', False)
                                    for line in module_prop:
                                        # ignore empty lines
                                        if line == '':
                                            continue
                                        # ignore the first line which is the full path
                                        if line == filepath:
                                            continue
                                        # ignore comment lines
                                        if line[:1] == "#":
                                            continue
                                        if line.strip() and '=' in line:
                                            key, value = line.split('=', 1)
                                            setattr(m, key, value)
                                    if m.updateJson and config.check_module_updates:
                                        setattr(m, 'updateDetails', check_module_update(m.updateJson))
                                    with contextlib.suppress(Exception):
                                        if m.versionCode and m.updateDetails and m.updateDetails.versionCode and int(m.updateDetails.versionCode) > int(m.versionCode):
                                            m.updateAvailable = True
                                    modules.append(m)
                            self._get_magisk_detailed_modules = modules
                        else:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error when processing Magisk Modules.")
                            print(f"Return Code: {res.returncode}")
                            print(f"Stdout: {res.stdout}")
                            print(f"Stderr: {res.stderr}")
                    else:
                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls /data/adb/modules\'\""
                        res = run_shell(theCmd)
                        if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                            debug(res.stdout)
                            modules = []
                            self._get_magisk_detailed_modules = res.stdout.split('\n')
                            for module in self._get_magisk_detailed_modules:
                                if module:
                                    m = Magisk(module)
                                    if self.true_mode == 'adb' and get_adb():
                                        # get the uninstall state by checking if there is a remove file in the module directory
                                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls /data/adb/modules/{module}/remove\'\""
                                        res = run_shell(theCmd)
                                        if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                                            m.state = 'remove'
                                        else:
                                            # get the state by checking if there is a disable file in the module directory
                                            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls /data/adb/modules/{module}/disable\'\""
                                            res = run_shell(theCmd)
                                            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                                                m.state = 'disabled'
                                            else:
                                                m.state = 'enabled'
                                        # check if the module has action.sh
                                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ls /data/adb/modules/{module}/action.sh\'\""
                                        res = run_shell(theCmd)
                                        if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                                            m.hasAction = True
                                        else:
                                            m.hasAction = False
                                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'cat /data/adb/modules/{module}/module.prop\'\""
                                        res = run_shell(theCmd)
                                        if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                                            module_prop = res.stdout.split('\n')
                                            setattr(m, 'id', '')
                                            setattr(m, 'version', '')
                                            setattr(m, 'versionCode', '')
                                            setattr(m, 'author', '')
                                            setattr(m, 'description', '')
                                            setattr(m, 'name', '')
                                            setattr(m, 'updateJson', '')
                                            setattr(m, 'updateDetails', {})
                                            setattr(m, 'updateAvailable', False)
                                            setattr(m, 'updateIssue', False)
                                            for line in module_prop:
                                                # ignore comment lines
                                                if line[:1] == "#":
                                                    continue
                                                if line.strip() and '=' in line:
                                                    key, value = line.split('=', 1)
                                                    setattr(m, key, value)
                                            if m.updateJson:
                                                setattr(m, 'updateDetails', check_module_update(m.updateJson))
                                            with contextlib.suppress(Exception):
                                                if m.versionCode and m.updateDetails and m.updateDetails.versionCode and int(m.updateDetails.versionCode) > int(m.versionCode):
                                                    m.updateAvailable = True
                                            modules.append(m)
                            self._get_magisk_detailed_modules = modules
                        else:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error when processing Magisk Modules.")
                            print(f"Return Code: {res.returncode}")
                            print(f"Stdout: {res.stdout}")
                            print(f"Stderr: {res.stderr}")
            except Exception as e:
                self._get_magisk_detailed_modules is None
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Magisk modules processing")
                traceback.print_exc()
                print(f"    Module: {module}\n    Line: {line}")
                print(f"    module.prop:\n-----\n{res.stdout}-----\n")
        return self._get_magisk_detailed_modules

    # ----------------------------------------------------------------------------
    #                               property magisk_modules_summary
    # ----------------------------------------------------------------------------
    @property
    def magisk_modules_summary(self):
        if self._magisk_modules_summary is None:
            if self.get_magisk_detailed_modules():
                summary = ''
                for module in self.get_magisk_detailed_modules():
                    with contextlib.suppress(Exception):
                        updateText = ''
                        if module.updateAvailable:
                            updateText = "\t [Update Available]"
                        summary += f"        {module.name:<36}{module.state:<10}{module.version}{updateText}\n"
                self._magisk_modules_summary = summary
            else:
                self._magisk_modules_summary = ''
        return self._magisk_modules_summary

    # ----------------------------------------------------------------------------
    #                               property apatch_modules_summary
    # ----------------------------------------------------------------------------
    @property
    def apatch_modules_summary(self):
        if self._apatch_modules_summary is None:
            if self.get_apatch_detailed_modules():
                summary = ''
                for module in self.get_apatch_detailed_modules():
                    with contextlib.suppress(Exception):
                        updateText = ''
                        if module.updateAvailable:
                            updateText = "\t [Update Available]"
                        summary += f"        {module.name:<36}{module.state:<10}{module.version}{updateText}\n"
                self._apatch_modules_summary = summary
            else:
                self._apatch_modules_summary = ''
        return self._apatch_modules_summary

    # ----------------------------------------------------------------------------
    #                               property ksu_modules_summary
    # ----------------------------------------------------------------------------
    @property
    def ksu_modules_summary(self):
        if self._ksu_modules_summary is None:
            if self.get_ksu_detailed_modules():
                summary = ''
                for module in self.get_ksu_detailed_modules():
                    with contextlib.suppress(Exception):
                        updateText = ''
                        if module.updateAvailable:
                            updateText = "\t [Update Available]"
                        summary += f"        {module.name:<36}{module.state:<10}{module.version}{updateText}\n"
                self._ksu_modules_summary = summary
            else:
                self._ksu_modules_summary = ''
        return self._ksu_modules_summary

    # ----------------------------------------------------------------------------
    #                               property sukisu_modules_summary
    # ----------------------------------------------------------------------------
    @property
    def sukisu_modules_summary(self):
        if self._sukisu_modules_summary is None:
            if self.get_sukisu_detailed_modules():
                summary = ''
                for module in self.get_sukisu_detailed_modules():
                    with contextlib.suppress(Exception):
                        updateText = ''
                        if module.updateAvailable:
                            updateText = "\t [Update Available]"
                        summary += f"        {module.name:<36}{module.state:<10}{module.version}{updateText}\n"
                self._sukisu_modules_summary = summary
            else:
                self._sukisu_modules_summary = ''
        return self._sukisu_modules_summary

    # ----------------------------------------------------------------------------
    #                               property wild_ksu_modules_summary
    # ----------------------------------------------------------------------------
    @property
    def wild_ksu_modules_summary(self):
        if self._wild_ksu_modules_summary is None:
            if self.get_wild_ksu_detailed_modules():
                summary = ''
                for module in self.get_wild_ksu_detailed_modules():
                    with contextlib.suppress(Exception):
                        updateText = ''
                        if module.updateAvailable:
                            updateText = "\t [Update Available]"
                        summary += f"        {module.name:<36}{module.state:<10}{module.version}{updateText}\n"
                self._wild_ksu_modules_summary = summary
            else:
                self._wild_ksu_modules_summary = ''
        return self._wild_ksu_modules_summary

    # ----------------------------------------------------------------------------
    #                               method get_lsposed_modules
    # ----------------------------------------------------------------------------
    def get_lsposed_modules(self, refresh=False):
        if self._get_lsposed_detailed_modules is None or refresh:
            self._get_lsposed_detailed_modules = self._fetch_lsposed_modules()
        return self._get_lsposed_detailed_modules

    # ----------------------------------------------------------------------------
    #                               method _fetch_lsposed_modules
    # ----------------------------------------------------------------------------
    def _fetch_lsposed_modules(self):
        try:
            if self.true_mode != 'adb' or not self.rooted:
                return []

            config_path = get_config_path()
            tmp_dir = os.path.join(config_path, 'tmp')
            os.makedirs(tmp_dir, exist_ok=True)

            local_db_path = os.path.join(tmp_dir, 'lsposed_modules.db')
            device_db_path = '/data/adb/lspd/config/modules_config.db'

            # Check if database exists on device
            res, _ = self.check_file(device_db_path, with_su=True)
            if res != 1:
                print("LSPosed modules database not found on device")
                return []

            # Pull database file from device
            print("Fetching LSPosed modules database...")
            pull_res = self.pull_file(device_db_path, local_db_path, with_su=True, quiet=True)
            if pull_res != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch LSPosed database")
                return []

            # Parse SQLite database
            modules = []
            try:
                conn = sqlite3.connect(local_db_path)
                cursor = conn.cursor()

                # Different versions of lsposed have different tables
                # check if auto_include column exists
                cursor.execute("PRAGMA table_info(modules)")
                columns = [column[1] for column in cursor.fetchall()]
                has_auto_include = 'auto_include' in columns

                # Build query based on available columns
                if has_auto_include:
                    cursor.execute("""
                        SELECT mid, module_pkg_name, apk_path, enabled, auto_include
                        FROM modules
                    """)
                else:
                    cursor.execute("""
                        SELECT mid, module_pkg_name, apk_path, enabled
                        FROM modules
                    """)

                rows = cursor.fetchall()
                for row in rows:
                    if has_auto_include:
                        mid, module_pkg_name, apk_path, enabled, auto_include = row
                    else:
                        mid, module_pkg_name, apk_path, enabled = row
                        auto_include = False  # Default value when column doesn't exist

                    module = {
                        'id': str(mid),
                        'name': module_pkg_name or '',
                        'package_name': module_pkg_name or '',
                        'apk_path': apk_path or '',
                        'enabled': bool(enabled),
                        'auto_include': bool(auto_include)
                    }
                    modules.append(module)

                conn.close()
                print(f"Found {len(modules)} LSPosed modules")

            except sqlite3.Error as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: SQLite error: {e}")
                print("Unable to read LSPosed database, returning empty module list")
                modules = []

                with contextlib.suppress(Exception):
                    conn.close()

            return modules

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during LSPosed modules fetch")
            traceback.print_exc()
            return []

    # ----------------------------------------------------------------------------
    #                               property lsposed_modules_summary
    # ----------------------------------------------------------------------------
    @property
    def lsposed_modules_summary(self):
        if self._lsposed_modules_summary is None:
            modules = self.get_lsposed_modules()
            if modules:
                summary = ''
                for module in modules:
                    with contextlib.suppress(Exception):
                        enabled_text = 'enabled' if module.get('enabled', False) else 'disabled'
                        summary += f"        {module.get('name', ''):<36}{enabled_text:<10}\n"
                self._lsposed_modules_summary = summary
            else:
                self._lsposed_modules_summary = ''
        return self._lsposed_modules_summary

    # ----------------------------------------------------------------------------
    #                               property su_version
    # ----------------------------------------------------------------------------
    @property
    def su_version(self):
        return self._su_version.strip('\n')

    # ----------------------------------------------------------------------------
    #                               property rooted
    # ----------------------------------------------------------------------------
    @property
    def rooted(self):
        if self._rooted is None and self.true_mode == 'adb':
            if get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c 'ls -l /data/adb/'\""
                res = run_shell(theCmd, timeout=2)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0 and '/system/bin/sh: su: not found' not in res.stdout:
                    self._rooted = True
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell su --version"
                    res = run_shell(theCmd, timeout=2)
                    if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                        self._su_version = res.stdout
                else:
                    # theCmd = f"\"{get_adb()}\" -s {self.id} shell busybox ls"
                    # res = run_shell(theCmd, 8)
                    # if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    #     print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device: appears to be rooted, however adb root access is not granted.\Please grant root access to adb and scan again.")
                    self._rooted = False
                    self._su_version = ''
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adb command is not found!")
                puml("#red:ERROR: adb command is not found;\n", True)
                return False
        return self._rooted

    # ----------------------------------------------------------------------------
    #                               property tmp_readable
    # ----------------------------------------------------------------------------
    @property
    def tmp_readable(self):
        if self._tmp_readable is None and self.true_mode == 'adb':
            if get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} shell ls -l /data/local/tmp/"
                res = run_shell(theCmd, timeout=2)
                if res and isinstance(res, subprocess.CompletedProcess):
                    if 'Permission denied' in f"{res.stdout} {res.stderr}" or res.returncode == 1:
                        self._tmp_readable = False
                    else:
                        self._tmp_readable = True
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adb command is not found!")
                puml("#red:ERROR: adb command is not found;\n", True)
                return False
        return self._tmp_readable

    # ----------------------------------------------------------------------------
    #                               method selinux_load_timestamp
    # ----------------------------------------------------------------------------
    def selinux_load_timestamp(self):
        if self.true_mode == 'adb':
            if get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} shell stat -c %y /sys/fs/selinux/load"
                res = run_shell(theCmd, timeout=8)
                if res and isinstance(res, subprocess.CompletedProcess):
                    return res.stdout.strip('\n')
        return ''

    # ----------------------------------------------------------------------------
    #                               method mount_count
    # ----------------------------------------------------------------------------
    def mount_count(self):
        try:
            if self.true_mode == 'adb':
                if get_adb():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell wc -l /proc/mounts"
                    res = run_shell(theCmd, timeout=8)
                    if res and isinstance(res, subprocess.CompletedProcess):
                        output_parts = res.stdout.strip('\n').split()
                        if output_parts:
                            return output_parts[0]
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting mount count.")
            puml("#red:Encountered an error while getting mount count.;\n")
            traceback.print_exc()
        return ''

    # ----------------------------------------------------------------------------
    #                               property magisk_denylist_enforced
    # ----------------------------------------------------------------------------
    @property
    def magisk_denylist_enforced(self):
        try:
            if self._magisk_denylist_enforced is None and self.true_mode == 'adb':
                if get_adb():
                    data = f"magisk --denylist status"
                    res = self.exec_magisk_settings(data, 1)
                    if res and isinstance(res, subprocess.CompletedProcess):
                        if res.stderr == "Denylist is enforced\n":
                            self._magisk_denylist_enforced = True
                        elif res.stderr == "Denylist is not enforced\n":
                            self._magisk_denylist_enforced = False
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adb command is not found!")
                    puml("#red:ERROR: adb command is not found;\n", True)
                    return False
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting magisk denylist status.")
            puml("#red:Encountered an error while getting magisk denylist status.;\n")
            traceback.print_exc()
        return self._magisk_denylist_enforced

    # ----------------------------------------------------------------------------
    #                               property magisk_zygisk_enabled
    # ----------------------------------------------------------------------------
    @property
    def magisk_zygisk_enabled(self):
        try:
            if self._magisk_zygisk_enabled is None and self.true_mode == 'adb':
                if get_adb():
                    data = f"magisk --sqlite \"SELECT value FROM settings WHERE key='zygisk';\""
                    res = self.exec_magisk_settings(data, 1)
                    if res and isinstance(res, subprocess.CompletedProcess):
                        if res.stdout == "value=1\n":
                            self._magisk_zygisk_enabled = True
                        elif res.stdout == "value=0\n":
                            self._magisk_zygisk_enabled = False
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adb command is not found!")
                    puml("#red:ERROR: adb command is not found;\n", True)
                    return False
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting magisk zygisk status.")
            puml("#red:Encountered an error while getting magisk zygisk status.;\n")
            traceback.print_exc()
        return self._magisk_zygisk_enabled

    # ----------------------------------------------------------------------------
    #                               Method get_details
    # ----------------------------------------------------------------------------
    def get_device_details(self):
        try:
            if self.true_mode != self.mode:
                mode = self.true_mode[:3]
            else:
                mode = self.mode
            if mode is not None:
                self.get_bl_status()
                return f"{self.root_symbol:<3}({mode:<3})   {self.id:<25}{self.hardware:<12}{self.build:<25}"
            else:
                return "ERROR"
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting device details.")
            puml("#red:Encountered an error while getting device details.;\n")
            traceback.print_exc()

    # ----------------------------------------------------------------------------
    #                               Method reboot_system
    # ----------------------------------------------------------------------------
    def reboot_system(self, timeout=60, hint='None'):
        try:
            mode = self.get_device_state()
            print(f"\nRebooting device: {self.id} to system ...")
            puml(f":Rebooting device: {self.id} to system;\n", True)

            if mode in ['adb', 'recovery', 'sideload', 'rescue'] and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} reboot"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    if timeout:
                        res2 = self.adb_wait_for(timeout=timeout, wait_for='device')
                        if res2 == 1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during adb_wait_for in reboot_system")
                            # puml(f"note right:ERROR: during adb_wait_for in reboot_system;\n")
                            return -1
                    puml("note right:State ADB;\n")
                    mode = 'adb'
                    return 0
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_system")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during reboot_system;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('system')
                return -1

            elif mode == 'fastboot' and get_fastboot():
                theCmd = f"\"{get_fastboot()}\" -s {self.id} reboot"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    if timeout:
                        res2 = self.adb_wait_for(timeout=timeout, wait_for='device')
                        # puml(f"note right:Res [{res}];\n")
                    mode = 'adb'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_system")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during adb_wait_for in reboot_system;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('system')
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_system")
            traceback.print_exc()
            puml(f"note right:Exception: during reboot_system;\n")
            return -1
        finally:
            update_phones(self.id, mode)

    # ----------------------------------------------------------------------------
    #                               Method reboot_recovery
    # ----------------------------------------------------------------------------
    def reboot_recovery(self, timeout=60, hint='None'):
        try:
            mode = self.get_device_state()
            print(f"\nRebooting device: {self.id} to recovery ...")
            puml(f":Rebooting device: {self.id} to recovery;\n", True)

            if mode in ['adb', 'recovery', 'sideload', 'rescue'] and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} reboot recovery"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    if timeout:
                        res2 = self.adb_wait_for(timeout=timeout, wait_for='recovery')
                        if res2 == 1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_recovery")
                            return -1
                    puml("note right:State recovery;\n")
                    mode = 'recovery'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_recovery")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during adb_wait_for in reboot_recovery;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('recovery')
                return -1

            elif mode == 'fastboot' and get_fastboot():
                res = 0
                if hint != 'fastbootd':
                    # first reboot to fastbootd
                    res = self.reboot_fastboot(timeout=timeout)
                if res == 0:
                    # next reboot to recovery
                    theCmd = f"\"{get_fastboot()}\" -s {self.id} reboot recovery"
                    debug(theCmd)
                    res2 = run_shell(theCmd, timeout=timeout)
                    if res2 and isinstance(res2, subprocess.CompletedProcess) and res2.returncode == 0:
                        res2 = self.adb_wait_for(timeout=timeout, wait_for='recovery')
                        if res2 == 1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_recovery")
                            return -1
                        mode = 'recovery'
                        return 0

                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_recovery")
                    print(f"Return Code: {res2.returncode}")
                    print(f"Stdout: {res2.stdout}")
                    print(f"Stderr: {res2.stderr}")
                    puml(f"note right:ERROR: during adb_wait_for in reboot_recovery;\n")
                    if 'Write to device failed' in res2.stderr:
                        print_user_interaction_message('recovery')
                    return -1
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_recovery")
                puml(f"note right:ERROR: during adb_wait_for in reboot_recovery;\n")
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_recovery")
            traceback.print_exc()
            puml(f"note right:Exception: during reboot_recovery;\n")
            return -1
        finally:
            update_phones(self.id, mode)

    # ----------------------------------------------------------------------------
    #                               Method reboot_recovery_interactive
    # ----------------------------------------------------------------------------
    def reboot_recovery_interactive(self, timeout=60, hint='None'):
        try:
            # mode = self.get_device_state()
            print(f"\nRebooting device: {self.id} to interactive recovery ...")
            puml(f":Rebooting device: {self.id} to interactive recovery;\n", True)

            res = 0
            if hint != 'fastbootd':
                # first reboot to fastbootd
                res = self.reboot_fastboot(timeout=timeout)
            if res == 0:
                # next reboot to recovery
                res = self.reboot_recovery(timeout=timeout, hint='fastbootd')
                if res == 0:
                    res = self.adb_wait_for(timeout=timeout, wait_for='recovery')
                    mode = 'recovery_interactive'
                    return 0

            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_recovery_interactive")
            puml(f"note right:ERROR: during adb_wait_for in reboot_recovery_interactive;\n")
            return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_recovery")
            traceback.print_exc()
            puml(f"note right:Exception: during reboot_recovery;\n")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method reboot_download
    # ----------------------------------------------------------------------------
    def reboot_download(self, timeout=60, hint='None'):
        try:
            mode = self.get_device_state()
            print(f"\nRebooting device: {self.id} to download ...")
            puml(f":Rebooting device: {self.id} to download;\n", True)

            if mode in ['adb', 'recovery', 'sideload', 'rescue'] and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} reboot download"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    time.sleep(5)
                    mode = self.get_device_state()
                    if mode and mode != 'ERROR':
                        print(f"Device is now in {mode} mode.")
                        # puml(f"note right:ERROR: during get_device_state in reboot_download;\n")
                        id = self.id
                    else:
                        print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} Download state cannot be confirmed, please check your device.")
                        puml(f"note right:Download state cannot be confirmed, please check your device.;\n")
                        id = None
                    mode = 'download'
                    return 0
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_download")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during adb_wait_for in reboot_download;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('download')
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_download")
            traceback.print_exc()
            puml(f"note right:Exception: during reboot_download;\n")
            return -1
        finally:
            update_phones(self.id, mode)

    # ----------------------------------------------------------------------------
    #                               Method reboot_safemode
    # ----------------------------------------------------------------------------
    def reboot_safemode(self, timeout=60, hint='None'):
        try:
            mode = self.get_device_state()
            print(f"\nRebooting device: {self.id} to safe mode ...")
            puml(f":Rebooting device: {self.id} to safe mode;\n", True)

            if mode in ['adb', 'recovery', 'sideload', 'rescue'] and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'setprop persist.sys.safemode 1\'\""
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess):
                    if res.returncode == 0:
                        res2 = self.reboot_system(timeout=timeout)
                        mode = 'safemode'
                        return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while setting safemode prop")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during reboot_safemode;\n")
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_safemode")
            traceback.print_exc()
            return -1
        finally:
            update_phones(self.id, mode)

    # ----------------------------------------------------------------------------
    #                               Method reboot_bootloader
    # ----------------------------------------------------------------------------
    def reboot_bootloader(self, fastboot_included = False, timeout=60, hint='None'):
        try:
            mode = self.get_device_state()
            print(f"\nRebooting device: {self.id} to bootloader ...")
            puml(f":Rebooting device: {self.id} to bootloader;\n", True)

            if mode in ['adb', 'recovery', 'sideload', 'rescue'] and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} reboot bootloader "
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    if timeout:
                        res2 = self.fastboot_wait_for_bootloader(timeout=timeout)
                        if res2 == -1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_bootloader")
                            # puml(f"note right:ERROR: during fastboot_wait_for_bootloader in reboot_bootloader;\n")
                            return -1
                        puml("note right:State Bootloader;\n")
                    mode = 'bootloader'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_bootloader")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during reboot_bootloader;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('bootloader')
                return -1

            elif mode == 'fastboot' and fastboot_included and get_fastboot():
                theCmd = f"\"{get_fastboot()}\" -s {self.id} reboot bootloader"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    res2 = self.fastboot_wait_for_bootloader(timeout=timeout)
                    mode = 'bootloader'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_bootloader")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during reboot_bootloader;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('bootloader')
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_bootloader")
            traceback.print_exc()
            puml(f"note right:Exception: during reboot_bootloader;\n")
            return -1
        finally:
            update_phones(self.id, mode)

    # ----------------------------------------------------------------------------
    #                               Method reboot_fastbootd
    # ----------------------------------------------------------------------------
    def reboot_fastboot(self, timeout=60, hint='None'):
        try:
            mode = self.get_device_state()
            print(f"\nRebooting device: {self.id} to fastbootd ...")
            print("This process will wait for fastbootd indefinitely.")
            print("ℹ️ Info: If your device does not boot to fastbootd PixelFlasher will hang and you'd have to kill it.")
            puml(f":Rebooting device: {self.id} to fastbootd;\n", True)

            if mode in ['adb', 'recovery', 'sideload', 'rescue'] and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} reboot fastboot "
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    if timeout:
                        res2 = self.fastboot_wait_for_bootloader(timeout=timeout)
                        if res2 == 1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_fastboot")
                            # puml(f"note right:ERROR: during fastboot_wait_for_bootloader in reboot_fastboot;\n")
                            return -1
                        puml("note right:State Bootloader;\n")
                    mode = 'fastbootd'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_fastboot")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during reboot_fastboot;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('fastbootd')
                return -1

            elif mode == 'fastboot' and get_fastboot():
                theCmd = f"\"{get_fastboot()}\" -s {self.id} reboot fastboot"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    res2 = self.fastboot_wait_for_bootloader(timeout=timeout)
                    mode = 'fastbootd'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_fastboot")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during adb_wait_for in reboot_fastboot;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('fastbootd')
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_fastbootd")
            traceback.print_exc()
            puml(f"note right:Exception: during reboot_fastboot;\n")
            return -1
        finally:
            update_phones(self.id, mode)

    # ----------------------------------------------------------------------------
    #                               Method reboot_sideload
    # ----------------------------------------------------------------------------
    def reboot_sideload(self, timeout=60, hint='None'):
        try:
            mode = self.get_device_state()
            if mode == 'sideload':
                print(f"\nDevice is already in sideload mode, not rebooting ...")
                return 0
            print(f"\nRebooting device: {self.id} to sideload ...")
            puml(f":Rebooting device: {self.id} to sideload;\n", True)

            if mode in ['adb', 'recovery', 'rescue'] and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} reboot sideload"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    if timeout:
                        res2 = self.adb_wait_for(timeout=timeout, wait_for='sideload')
                        if res2 == 1:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_sideload")
                            return -1
                        puml("note right:State sideload;\n")
                    mode = 'sideload'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_sideload")
                print(f"Return Code: {res.returncode}")
                print(f"Stdout: {res.stdout}")
                print(f"Stderr: {res.stderr}")
                puml(f"note right:ERROR: during reboot_sideload;\n")
                if 'Write to device failed' in res.stderr:
                    print_user_interaction_message('sideload')
                return -1

            elif mode == 'sideload' and get_adb():
                print("Device is already in sideload mode, rebooting to recovery ...")
                # TODO Ask the user if they want to reboot to recovery and then sideload anyways
                # next reboot to recovery
                res = self.reboot_recovery(timeout=timeout)
                if res == 0:
                    res = self.adb_wait_for(timeout=timeout, wait_for='recovery')
                    # next reboot to sideload
                    debug("Calling reboot_sideload ...")
                    res = self.reboot_sideload(timeout=timeout)
                    mode = 'sideload'
                    return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_sideload")
                puml(f"note right:ERROR: during reboot_sideload;\n")
                return -1

            elif mode == 'fastboot' and get_fastboot():
                print("Device could be in bootloader or fastbootd mode, with a hint of {hint} ...")
                res = 0
                if hint != 'fastbootd':
                    # first reboot to fastbootd
                    res = self.reboot_fastboot(timeout=timeout)
                if res == 0:
                    # next reboot to recovery
                    res = self.reboot_recovery(timeout=timeout, hint='fastbootd')
                    if res == 0:
                        res = self.adb_wait_for(timeout=timeout, wait_for='recovery')
                        # next reboot to sideload
                        debug("Calling reboot_sideload ...")
                        res = self.reboot_sideload(timeout=timeout, hint='recovery')
                        mode = 'sideload'
                        return 0

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during reboot_sideload")
                puml(f"note right:ERROR: during adb_wait_for in reboot_sideload;\n")
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during reboot_sideload")
            traceback.print_exc()
            puml(f"note right:Exception: during reboot_sideload;\n")
            return -1
        finally:
            update_phones(self.id, mode)

    # ----------------------------------------------------------------------------
    #                               Method get_device_state
    # ----------------------------------------------------------------------------
    def get_device_state(self, device_id='', timeout=60, retry=0, update=True):
        """
        Gets the state of a device.

        The method retrieves the state of a device identified by the given device ID. It supports retrying the operation multiple times with a specified timeout between each attempt.

        Args:
            device_id (str): The ID of the device. If not provided, the ID of the instance is used.
            timeout (int): The timeout value for each shell command attempt in seconds. Defaults to 60.
            retry (int): The number of retry attempts. Defaults to 0.

        Returns:
            str: The state of the device. Possible values are 'fastboot', 'ERROR', or the device state retrieved from ADB.

        Raises:
            Exception: If an error occurs during the operation.

        """
        try:
            if not device_id:
                device_id = self.id
            retry_text = f"retry [{retry + 1}] times" if retry > 0 else ''
            print(f"\n{datetime.now():%Y-%m-%d %H:%M:%S} Getting device: {device_id} state {retry_text} ...")
            puml(f":Getting device: {device_id} state {retry_text};\n", True)
            mode = None
            for i in range(retry + 1):
                if get_adb():
                    puml(f":[{i + 1}/{retry + 1}] using get-state;\n", True)
                    debug(f"[{i + 1}/{retry + 1}] using get-state")
                    theCmd = f"\"{get_adb()}\" -s {device_id} get-state"
                    debug(theCmd)
                    res = run_shell(theCmd, timeout=timeout)
                    if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                        device_mode = res.stdout.strip('\n')
                        if device_mode == "device":
                            mode = 'adb'
                        else:
                            mode = res.stdout.strip('\n')
                        puml(f"note right:State {mode};\n")
                        debug(f"Device: {device_id} is in {mode} mode.")
                        return mode
                if get_fastboot():
                    puml(f":[{i + 1}/{retry + 1}] using fastboot devices;\n", True)
                    debug(f"[{i + 1}/{retry + 1}] using fastboot devices")
                    theCmd = f"\"{get_fastboot()}\" devices"
                    res = run_shell(theCmd, timeout=timeout)
                    if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0 and device_id in res.stdout:
                        mode = 'fastboot'
                        mode_text = 'bootloader or fastbootd'
                        puml(f"note right:State {mode_text};\n")
                        debug(f"Device: {device_id} is in {mode_text} mode.")
                        return mode
                time.sleep(1)
            return 'ERROR'
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during get_device_state for device: {device_id}")
            traceback.print_exc()
            puml(f"note right:ERROR: Exception during get_device_state for device;\n")
            mode = None
            debug(f"Device is in ERROR mode.")
            return 'ERROR'
        finally:
            if update:
                if mode:
                    update_phones(device_id, mode)
                else:
                    update_phones(device_id)

    # ----------------------------------------------------------------------------
    #                               Method is_device_connected
    # ----------------------------------------------------------------------------
    def is_connected(self, device_id):
        try:
            if not device_id:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device ID is not provided!")
                puml("#red:ERROR: Device ID is not provided;\n", True)
                return False

            res = self.get_device_state(device_id, update=False)
            if res == 'ERROR':
                print(f"Device: {device_id} is not connected.")
                puml(f":Device: {device_id} is not connected;\n", True)
                return False
            elif res == 'fastboot':
                print(f"Device: {device_id} is in fastboot mode.")
                puml(f":Device: {device_id} is in fastboot mode;\n", True)
                self.mode = 'f.b'
                return True
            elif res == 'adb':
                print(f"Device: {device_id} is in adb mode.")
                puml(f":Device: {device_id} is in adb mode;\n", True)
                self.mode = 'adb'
                return True
            else:
                print(f"Device: {device_id} is in {res} mode.")
                puml(f":Device: {device_id} is in {res} mode;\n", True)
                self.mode = 'adb'
                self.true_mode = res
                return True
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during is_device_connected for device: {device_id}")
            traceback.print_exc()
            puml(f"note right:ERROR: Exception during is_device_connected for device: {device_id};\n")
            return False

    # ----------------------------------------------------------------------------
    #                               Method adb_wait_for
    # ----------------------------------------------------------------------------
    def adb_wait_for(self, device_id='', timeout=60, wait_for=''):
        try:
            if not device_id:
                device_id = self.id
            print(f"ADB waiting for device: {device_id} for {wait_for} ...")
            puml(f":ADB waiting for device: {device_id} for {wait_for};\n", True)
            if wait_for not in ['device', 'bootloader', 'sideload', 'recovery', 'rescue', 'disconnect']:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Wrong wait-for [{wait_for}] request!")
                puml(f"#red:ERROR: Wrong wait-for [{wait_for}] request;\n", True)
                return -1

            if get_adb():
                theCmd = f"\"{get_adb()}\" -s {device_id} wait-for-{wait_for}"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    print(f"device: {device_id} is now in {wait_for} mode.")
                    puml(f":device: {device_id} is now in {wait_for} mode;\n", True)
                    return 0
                else:
                    mode = self.get_device_state()
                    if mode:
                        print(f"Device is now in {mode} mode.")
                        puml(f":device is now in {mode} mode;\n", True)
                with contextlib.suppress(Exception):
                    return res.returncode
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during adb_wait_for: {wait_for}")
            traceback.print_exc()
            puml(f"note right:ERROR: Exception during adb_wait_for: {wait_for};\n")
            return -1

    # ----------------------------------------------------------------------------
    #                               Method fastboot_wait_for_bootloader
    # ----------------------------------------------------------------------------
    def fastboot_wait_for_bootloader(self, device_id='', timeout=60):
        try:
            if not get_fastboot():
                return -1

            if not device_id:
                device_id = self.id
            print(f"Fastboot waiting for device: {device_id} ...")
            puml(f":Fastboot waiting for device: {device_id};\n", True)
            start_time = time.time()
            while time.time() - start_time < timeout:
                with contextlib.suppress(Exception):
                    theCmd = f"\"{get_fastboot()}\" devices"
                    res = run_shell(theCmd, timeout=timeout)
                    if res and isinstance(res, subprocess.CompletedProcess) and f"{device_id}\t" in res.stdout:
                        # sometimes fastboot devices returns the device in the list but it's not in bootloader mode
                        # so we need to check the state of the device again
                        time.sleep(1)
                        mode = self.get_device_state(device_id, update=False)
                        if mode == 'fastboot':
                            print(f"device: {device_id} is now in bootloader or fastbootd mode.")
                            puml(f":device: {device_id} is now in bootloader or fastbootd mode;\n", True)
                            return 0
                        else:
                            print(f"device: {device_id} is in {mode} mode.")
                            puml(f":device: {device_id} is in {mode} mode;\n", True)
                            return -1
                time.sleep(1)
            print(f"Timeout: [{timeout}] Fastboot could not detect device: {device_id} in bootloader or fastbootd mode ")
            puml(f":Timeout: [{timeout}] Fastboot could not detect device: {device_id} in bootloader or fastbootd mode;\n", True)
            return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in fastboot_wait_for_bootloader function")
            puml("#red:Encountered an error in fastboot_wait_for_bootloader function;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method get_magisk_denylist
    # ----------------------------------------------------------------------------
    def get_magisk_denylist(self):
        try:
            if self.true_mode != 'adb' or not get_adb() or not self.rooted or 'magisksu' not in self.su_version.lower():
                return []
            print("Getting Magisk denylist ...")
            puml(f":Magisk denylist;\n", True)
            if get_magisk_package() == MAGISK_DELTA_PKG_NAME:
                print("Magisk denylist is currently not supported in PixelFlasher for Magisk Delta.")
                return []
            theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'magisk --denylist ls\'\""
            debug(theCmd)
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Return Code: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting Magisk denylist")
                    return []
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting Magisk denylist")
                return []

            lines = res.stdout.split('\n')
            unique_packages = set()
            for line in lines:
                if line.strip():  # Skip empty lines if any
                    package = line.split('|')[0]
                    unique_packages.add(package)
            return list(unique_packages)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_magisk_denylist")
            puml("#red:Encountered an error in get_magisk_denylist;\n")
            traceback.print_exc()
            return []

    # ----------------------------------------------------------------------------
    #                               Method install_apk
    # ----------------------------------------------------------------------------
    def install_apk(self, app, fastboot_included = False, owner_playstore = False, bypass_low_target = False):
        try:
            if owner_playstore:
                playstore_flag = " -i \"com.android.vending\""
            else:
                playstore_flag = ""

            if bypass_low_target:
                sdk_flag = " --bypass-low-target-sdk-block"
            else:
                sdk_flag = ""

            if self.true_mode == 'adb' and get_adb():
                print(f"Installing {app} on device ...")
                puml(f":Installing {app};\n", True)
                theCmd = f"\"{get_adb()}\" -s {self.id} install {playstore_flag} {sdk_flag} -r \"{app}\""
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        print(f"{res.stdout}")
                        return 0
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while installing \"{app}\"")
                return -1
            if self.mode == 'f.b' and fastboot_included and get_fastboot():
                print("Device is in fastboot mode, will reboot to system and wait 60 seconds for system to load before installing ...")
                self.reboot_system()
                time.sleep(60)
                res = self.refresh_phone_mode()
                if self.true_mode == 'adb' and get_adb():
                    res = self.install_apk(app)
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device could not reboot to adb mode.\n Aborting install ...")
                    print("Please perform the install again when the device is in adb mode.")
                    return -1
                return res
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in install_apk")
            puml("#red:Encountered an error in install_apk;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method get_current_slot
    # ----------------------------------------------------------------------------
    def get_current_slot(self):
        try:
            if self.mode == 'adb' and get_adb():
                return -1
            if self.mode == 'f.b' and get_fastboot():
                print(f"Getting current slot for device: {self.id} ...")
                puml(f":Getting current slot;\n", True)
                theCmd = f"\"{get_fastboot()}\" -s {self.id} getvar current-slot"
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        return 'UNKNOWN'
                else:
                    return 'UNKNOWN'
                lines = (f"{res.stderr}{res.stdout}").splitlines()
                for line in lines:
                    if "current-slot:" in line:
                        value = line.split("current-slot:")[1].strip()
                        if value in ['a', 'b']:
                            return value
                return 'UNKNOWN'
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_current_slot")
            puml("#red:Encountered an error in get_current_slot;\n")
            traceback.print_exc()
            return 'UNKNOWN'

    # ----------------------------------------------------------------------------
    #                               Method get_wm_size
    # ----------------------------------------------------------------------------
    def get_wm_size(self):
        try:
            if self.true_mode != 'adb' and get_adb():
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device is not in adb mode.")
                return -1
            print("Getting device resolution ...")
            theCmd = f"\"{get_adb()}\" -s {self.id} shell wm size"
            debug(theCmd)
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Return Code: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode != 0:
                    return -1
            else:
                return -1
            lines = (f"{res.stdout}").splitlines()
            for line in lines:
                if "Physical size:" in line:
                    return line.split("Physical size:")[1].strip()
            return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_wm_size")
            puml("#red:Encountered an error in get_wm_size;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method swipe_up
    # ----------------------------------------------------------------------------
    def swipe_up(self, percentage=10):
        try:
            if self.true_mode != 'adb' and get_adb():
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device is not in adb mode.")
                return -1
            print("Swipe up ...")
            wm_size = self.get_wm_size()
            x,y = wm_size.split('x')
            coords = f"{int(x) / 2} {int(int(y) * (1 - (percentage / 100)))} {int(x) / 2} {int(int(y) * percentage / 100)}"
            debug(f"coord: {coords}")
            res = self.swipe(coords)
            if res != 0:
                return -1
            return coords
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_wm_size")
            puml("#red:Encountered an error in get_wm_size;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method set_active
    # ----------------------------------------------------------------------------
    def set_active_slot(self, slot):
        try:
            if self.mode == 'adb' and get_adb():
                res = self.reboot_bootloader()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                    self.clear_device_selection()
                    bootloader_issue_message()
                self.refresh_phone_mode()
            if self.mode == 'f.b' and get_fastboot():
                print(f"Setting active slot to slot [{slot}] for device: {self.id} ...")
                puml(f":Setting Active slot to [{slot}];\n", True)
                theCmd = f"\"{get_fastboot()}\" -s {self.id} --set-active={slot}"
                debug(theCmd)
                return run_shell(theCmd)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in set_active_slot")
            puml("#red:Encountered an error in set_active_slot;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method switch_slot
    # ----------------------------------------------------------------------------
    def switch_slot(self, timeout=60):
        try:
            mode = self.get_device_state()
            if mode in ['adb', 'recovery', 'sideload', 'rescue'] and get_adb():
                res = self.reboot_bootloader()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                    self.clear_device_selection()
                    bootloader_issue_message()
            if mode == 'fastboot' and get_fastboot():
                print(f"Switching to other slot. Current slot [{self.active_slot}] for device: {self.id} ...")
                puml(f":Switching slot. Current Slot [{self.active_slot}];\n", True)
                if self.active_slot == 'a':
                    switch_to_slot = 'b'
                elif self.active_slot == 'b':
                    switch_to_slot = 'a'
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unknown Slot.")
                    puml("#red:ERROR: Unknown Slot;\n", True)
                    return 1
                theCmd = f"\"{get_fastboot()}\" -s {self.id} --set-active={switch_to_slot}"
                debug(theCmd)
                res = run_shell(theCmd, timeout=timeout)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during slot switch")
                    return -1
                return res
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during switch_slot")
            traceback.print_exc()
            return -1
        finally:
            update_phones(self.id)

    # ----------------------------------------------------------------------------
    #                               Method erase_partition
    # ----------------------------------------------------------------------------
    def erase_partition(self, partition):
        try:
            if self.mode == 'adb' and get_adb():
                res = self.reboot_bootloader()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                    self.clear_device_selection()
                    bootloader_issue_message()
                self.refresh_phone_mode()
            if self.mode == 'f.b' and get_fastboot():
                print(f"Erasing Partition [{partition}] for device: {self.id} ...")
                puml(f":Erasing Partition [{partition}];\n", True)
                theCmd = f"\"{get_fastboot()}\" -s {self.id} erase {partition}"
                debug(theCmd)
                # return run_shell(theCmd)
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in erase_partition.")
            puml("#red:Encountered an error in erase_partition.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method lock_bootloader
    # ----------------------------------------------------------------------------
    def lock_bootloader(self):
        try:
            if self.mode == 'adb' and get_adb():
                res = self.reboot_bootloader()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                    self.clear_device_selection()
                    bootloader_issue_message()
                self.refresh_phone_mode()
            if self.mode == 'f.b' and get_fastboot():
                # add a popup warning before continuing.
                print(f"Locking bootloader for device: {self.id} ...")
                theCmd = f"\"{get_fastboot()}\" -s {self.id} flashing lock"
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Returncode: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during lock_bootloader")
                    return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in lock_bootloader.")
            puml("#red:Encountered an error in lock_bootloader.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method unlock_bootloader
    # ----------------------------------------------------------------------------
    def unlock_bootloader(self):
        try:
            if self.mode == 'adb' and get_adb():
                res = self.reboot_bootloader()
                if res == -1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while rebooting to bootloader")
                    self.clear_device_selection()
                    bootloader_issue_message()
                self.refresh_phone_mode()
            if self.mode == 'f.b' and get_fastboot():
                print(f"Unlocking bootloader for device: {self.id} ...")
                theCmd = f"\"{get_fastboot()}\" -s {self.id} flashing unlock"
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Returncode: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        return 0
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: during unlock_bootloader")
                    return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in unlock_bootloader.")
            puml("#red:Encountered an error in unlock_bootloader.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method magisk_install_module
    # ----------------------------------------------------------------------------
    def magisk_install_module(self, module):
        try:
            if self.true_mode == 'adb' and self.rooted and get_adb():
                print(f"Installing magisk module {module} ...")
                puml(":Install magisk module;\n", True)
                puml(f"note right:{module};\n")
                sanitized_module = sanitize_filename(module)
                module_name = os.path.basename(sanitized_module)
                res = self.push_file(f"\"{sanitized_module}\"", f"/sdcard/Download/{module_name}", with_su=False)
                if res != 0:
                    puml("#red:Failed to transfer the module file to the phone;\n")
                    print("Aborting ...\n}\n")
                    return -1
                if "kernelsu" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud module install /sdcard/Download/{module_name}\'\""
                elif "sukisu" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud module install /sdcard/Download/{module_name}\'\""
                elif "wild_ksu" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud module install /sdcard/Download/{module_name}\'\""
                elif "apatch" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'apd module install /sdcard/Download/{module_name}\'\""
                else:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'magisk --install-module /sdcard/Download/{module_name}\'\""
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode == 0:
                        return 0
                puml("#red:Failed to transfer the install module;\n")
                print("Aborting ...\n}\n")
                return -1
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml(f"#red:ERROR: Device: {self.id} is not in adb mode;\n", True)
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in magisk_install_module.")
            puml("#red:Encountered an error in magisk_install_module.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method magisk_run_module_action
    # ----------------------------------------------------------------------------
    def magisk_run_module_action(self, dirname):
        try:
            if self.true_mode == 'adb' and get_adb():
                print(f"Running magisk module action for {dirname} ...")
                puml(":Run magisk module action;\n", True)
                puml(f"note right:{dirname};\n")
                res, unused = self.check_file(f"/data/adb/modules/{dirname}/action.sh", True)
                if res != 1:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Module {dirname} does not have action script\nAborting ...\n")
                    puml("#red:Module does not have action script;\n}\n")
                    return -1
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'busybox sh -o standalone /data/adb/modules/{dirname}/action.sh\'\""
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: when running action.sh for module {dirname}.")
                        print("Aborting ...\n")
                        return -1
                print(f"Action.sh for module {dirname} executed successfully.")
                return 0
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in magisk_run_module_action.")
            puml("#red:Encountered an error in magisk_run_module_action.;\n")
            traceback.print_exc()
            return -1



    # ----------------------------------------------------------------------------
    #                               Method enable_magisk_module
    # ----------------------------------------------------------------------------
    def enable_magisk_module(self, dirname):
        try:
            if self.true_mode == 'adb' and get_adb():
                print(f"Enabling magisk module {dirname} ...")
                puml(":Enable magisk module;\n", True)
                puml(f"note right:{dirname};\n")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'rm -f /data/adb/modules/{dirname}/disable\'\""
                debug(theCmd)
                res = run_shell(theCmd)
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml(f"#red:ERROR: Device: {self.id} is not in adb mode;\n", True)
                return 1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in enable_magisk_module.")
            puml("#red:Encountered an error in enable_magisk_module.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method restore_magisk_module
    # ----------------------------------------------------------------------------
    def restore_magisk_module(self, dirname):
        try:
            if self.true_mode == 'adb' and get_adb():
                print(f"Restoring magisk module {dirname} ...")
                puml(":Restore magisk module;\n", True)
                puml(f"note right:{dirname};\n")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'rm -f /data/adb/modules/{dirname}/remove\'\""
                debug(theCmd)
                res = run_shell(theCmd)
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml(f"#red:ERROR: Device: {self.id} is not in adb mode;\n", True)
                return 1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in restore_magisk_module.")
            puml("#red:Encountered an error in restore_magisk_module.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method open_shell
    # ----------------------------------------------------------------------------
    def open_shell(self):
        try:
            config = get_config()
            if self.mode == 'adb' and get_adb():
                print(f"Opening an adb shell command for device: {self.id} ...")
                puml(":Opening an adb shell command;\n", True)
                theCmd = f"\"{get_adb()}\" -s {self.id} shell"
                if sys.platform.startswith("win"):
                    debug(theCmd)
                    subprocess.Popen(theCmd, creationflags=subprocess.CREATE_NEW_CONSOLE, start_new_session=True, env=get_env_variables())
                elif sys.platform.startswith("linux") and config.linux_shell:
                    theCmd = f"{get_linux_shell()} -- /bin/bash -c {theCmd}"
                    debug(theCmd)
                    subprocess.Popen(theCmd, start_new_session=True)
                elif sys.platform.startswith("darwin"):
                    script_file = tempfile.NamedTemporaryFile(delete=False, suffix='.sh')
                    script_file.write(f'#!/bin/bash\n{theCmd}\nrm "{script_file.name}"'.encode('utf-8'))
                    script_file.close()
                    os.chmod(script_file.name, 0o755)
                    subprocess.Popen(['osascript', '-e', f'tell application "Terminal" to do script "{script_file.name}"'], start_new_session=True, env=get_env_variables())
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml("#red:ERROR: The Device: {self.id} is not in adb mode;\n", True)
                return 1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in open_shell.")
            puml("#red:Encountered an error in open_shell.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method open_update_engine_logcat
    # ----------------------------------------------------------------------------
    def open_update_engine_logcat(self):
        try:
            self.logcat(['-v', 'color', '-s', 'update_engine'])
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in open_update_engine_logcat.")
            puml("#red:Encountered an error in open_update_engine_logcat.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method logcat
    # ----------------------------------------------------------------------------
    def logcat(self, args):
        try:
            config = get_config()
            if self.mode == 'adb' and get_adb():
                print(f"Opening logcat for device: {self.id} ...")
                puml(":Opening logcat;\n", True)
                args_str = " ".join(args) if isinstance(args, list) else args
                theCmd = f"\"{get_adb()}\" -s {self.id} logcat {args_str}"
                if sys.platform.startswith("win"):
                    print(theCmd)
                    subprocess.Popen(theCmd, creationflags=subprocess.CREATE_NEW_CONSOLE, start_new_session=True, env=get_env_variables())
                elif sys.platform.startswith("linux") and config.linux_shell:
                    theCmd = f"{get_linux_shell()} -- /bin/bash -c '{theCmd}'"
                    print(theCmd)
                    subprocess.Popen(theCmd, shell=True, start_new_session=True)
                elif sys.platform.startswith("darwin"):
                    script_file = tempfile.NamedTemporaryFile(delete=False, suffix='.sh')
                    script_file.write(f'#!/bin/bash\n{theCmd}\nrm "{script_file.name}"'.encode('utf-8'))
                    script_file.close()
                    os.chmod(script_file.name, 0o755)
                    subprocess.Popen(['osascript', '-e', f'tell application "Terminal" to do script "{script_file.name}"'], start_new_session=True, env=get_env_variables())
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml("#red:ERROR: The Device: {self.id} is not in adb mode;\n", True)
                return 1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error logcat.")
            puml("#red:Encountered an error in logcat.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method scrcpy
    # ----------------------------------------------------------------------------
    def scrcpy(self):
        try:
            config = get_config()
            scrcpy_path = config.scrcpy['path']
            flags = config.scrcpy['flags']
            if not os.path.exists(scrcpy_path):
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: invalid scrcpy path {scrcpy_path} ")
                return 1
            scrcpy_folder = os.path.dirname(scrcpy_path)
            if self.true_mode == 'adb' and get_adb():
                print(f"Launching scrcpy for device: {self.id} ...")
                puml(":Launching scrcpy;\n", True)
                theCmd = f"\"{scrcpy_path}\" -s {self.id} {flags}"
                if sys.platform.startswith("win"):
                    # subprocess.Popen(theCmd, cwd=scrcpy_folder, start_new_session=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
                    debug(theCmd)
                    res = run_shell3(theCmd, directory=scrcpy_folder, detached=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
                elif sys.platform.startswith("linux") and config.linux_shell:
                    # subprocess.Popen([get_linux_shell(), "--", "/bin/bash", "-c", theCmd], start_new_session=True)
                    theCmd = f"{get_linux_shell()} -- /bin/bash -c {theCmd}"
                    debug(theCmd)
                    res = run_shell3(theCmd, detached=True)
                elif sys.platform.startswith("darwin"):
                    script_file = tempfile.NamedTemporaryFile(delete=False, suffix='.sh')
                    script_file_content = f'#!/bin/bash\n{theCmd}\nrm "{script_file.name}"'
                    debug(script_file_content)
                    script_file.write(script_file_content.encode('utf-8'))
                    script_file.close()
                    os.chmod(script_file.name, 0o755)
                    theCmd = f"osascript -e 'tell application \"Terminal\" to do script \"{script_file.name}\"'"
                    debug(theCmd)
                    # subprocess.Popen(['osascript', '-e', f'tell application "Terminal" to do script "{script_file.name}"'], start_new_session=True, env=get_env_variables())
                    res = run_shell3(theCmd, detached=True, env=get_env_variables())
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml("#red:ERROR: The Device: {self.id} is not in adb mode;\n", True)
                return 1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in scrcpy.")
            puml("#red:Encountered an error in scrcpy.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method magisk_uninstall_module
    # ----------------------------------------------------------------------------
    def magisk_uninstall_module(self, dirname):
        try:
            if self.true_mode == 'adb' and get_adb():
                print(f"Uninstalling magisk module {dirname} ...")
                puml(":Uninstall magisk module;\n", True)
                puml(f"note right:{dirname};\n")
                if "kernelsu" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud module uninstall {dirname}\'\""
                if "sukisu" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud module uninstall {dirname}\'\""
                if "wild_ksu" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'ksud module uninstall {dirname}\'\""
                elif "apatch" in self.su_version.lower():
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'apd module uninstall {dirname}\'\""
                else:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'touch /data/adb/modules/{dirname}/remove\'\""
                debug(theCmd)
                res = run_shell(theCmd)
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml("#red:ERROR: The Device: {self.id} is not in adb mode;\n", True)
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in magisk_uninstall_module.")
            puml("#red:Encountered an error in magisk_uninstall_module.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method disable_magisk_module
    # ----------------------------------------------------------------------------
    def disable_magisk_module(self, dirname):
        try:
            if self.true_mode == 'adb' and get_adb():
                print(f"Disabling magisk module {dirname} ...")
                puml(":Disable magisk module;\n", True)
                puml(f"note right:{dirname};\n")
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'touch /data/adb/modules/{dirname}/disable\'\""
                debug(theCmd)
                res = run_shell(theCmd)
                return 0
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: The Device: {self.id} is not in adb mode.")
                puml("#red:ERROR: The Device: {self.id} is not in adb mode;\n", True)
                return 1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in disable_magisk_module.")
            puml("#red:Encountered an error in disable_magisk_module.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method disable_magisk_modules
    # ----------------------------------------------------------------------------
    def disable_magisk_modules(self):
        try:
            print("Disabling magisk modules ...")
            puml(":SOS Disable magisk modules;\n", True)
            if self.true_mode == 'adb' and get_adb():
                theCmd = f"\"{get_adb()}\" -s {self.id} wait-for-device shell magisk --remove-modules"
                debug(theCmd)
                return run_shell(theCmd)
            elif self.mode == 'f.b' and get_fastboot():
                theCmd = f"\"{get_fastboot()}\" -s {self.id} reboot"
                debug(theCmd)
                res = run_shell(theCmd)
                print("Waiting 15 seconds ...")
                time.sleep(15)
                return self.disable_magisk_modules()
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in disable_magisk_modules.")
            puml("#red:Encountered an error in disable_magisk_modules.;\n")
            traceback.print_exc()
            return -1

    # ----------------------------------------------------------------------------
    #                               Method refresh_phone_mode
    # ----------------------------------------------------------------------------
    def refresh_phone_mode(self):
        try:
            if self.mode == 'adb' and get_fastboot():
                theCmd = f"\"{get_fastboot()}\" devices"
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and self.id in res.stdout:
                    self.mode = 'f.b'
            elif self.mode == 'f.b' and get_adb():
                theCmd = f"\"{get_adb()}\" devices"
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and self.id in res.stdout:
                    self.mode = 'adb'
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in refresh_phone_mode.")
            puml("#red:Encountered an error in refresh_phone_mode.;\n")
            traceback.print_exc()
            return -1

    # ============================================================================
    #                               Function ui_action
    # ============================================================================
    def ui_action(self, dump_file, local_file, look_for=None, click=True):
        try:
            # Get uiautomator dump, save as dump_file
            # the_view = "view1.xml"
            res = self.uiautomator_dump(dump_file)
            if res == -1:
                puml("#red:Failed to uiautomator dump;\n}\n")
                return -1

            # Pull dump_file
            print(f"Pulling {dump_file} from the phone to: {local_file} ...")
            res = self.pull_file(dump_file, local_file)
            if res != 0:
                puml("#red:Failed to pull uiautomator dump from the phone;\n}\n")
                return -1

            coords = -1
            if look_for is not None:
                if look_for == "PixelFlasher_Playstore":
                    coords = get_playstore_user_coords(local_file)
                else:
                    # get bounds
                    coords = get_ui_cooridnates(local_file, look_for)

                if click:
                    if coords is None or coords == '' or coords == -1:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not tap. Coordinates are [{coords}]")
                        return -1

                    # Check for Display being locked again
                    if not self.is_display_unlocked():
                        print("ERROR: The device display is Locked!\n")
                        return -1

                    # Click on coordinates
                    res = self.click(coords)
                    if res == -1:
                        puml("#red:Failed to click;\n}\n")
                        return -1

                    # Sleep 2 seconds
                    print("Sleeping 2 seconds to make sure the view is loaded ...")
                    time.sleep(2)

                    # Check for Display being locked again
                    if not self.is_display_unlocked():
                        print("ERROR: The device display is Locked!\n")
                        return -1
                return coords
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while performing ui action")
            puml("#red:Encountered an error while performing ui action;\n")
            traceback.print_exc()

    # ----------------------------------------------------------------------------
    #                               method exec_cmd
    # ----------------------------------------------------------------------------
    def exec_cmd(self, cmd, with_su = False):
        if self.true_mode != 'adb':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not execute command: {cmd}. Device is not in ADB mode.")
            return None
        if cmd and self.mode == 'adb':
            try:
                if with_su:
                    if self.rooted:
                        debug(f"Executing command: {cmd} on the device as root ...")
                        theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'{cmd}\'\""
                    else:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not execute {cmd}. Device is not rooted.")
                else:
                    debug(f"Executing command: {cmd} on the device ...")
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell \"{cmd}\""
                res = run_shell(theCmd)
                data = res.stdout
                debug(f"Return Code: {res.returncode}")
                return data

            except Exception:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while performing exec_cmd")
                puml("#red:Encountered an error while performing exec_cmd;\n")
                traceback.print_exc()
                return None

    # ----------------------------------------------------------------------------
    #                               method perform_package_action
    # ----------------------------------------------------------------------------
    def perform_package_action(self, pkg, action, isSystem=False, url=None):
        # possible actions 'uninstall', 'disable', 'enable', 'launch', 'launch-am', 'launch-am-main', 'kill', killall', 'clear-data', 'clear-cache', 'add-to-denylist', 'rm-from-denylist', 'optimize', 'reset-optimize', 'open-url'
        if self.true_mode != 'adb':
            return
        if action in ['add-to-denylist', 'rm-from-denylist'] and get_magisk_package() == MAGISK_DELTA_PKG_NAME:
                print("Magisk denylist is currently not supported in PixelFlasher for Magisk Delta.")
                return
        try:
            if action == 'uninstall':
                if isSystem:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell pm uninstall -k --user 0 {pkg}"
                else:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell pm uninstall {pkg}"
            elif action == 'disable':
                if isSystem:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell pm uninstall -k --user 0 {pkg}"
                else:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell pm disable-user {pkg}"
            elif action == 'enable':
                if isSystem:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell pm install-existing {pkg}"
                else:
                    theCmd = f"\"{get_adb()}\" -s {self.id} shell pm enable {pkg}"
            elif action == 'launch':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell monkey -p {pkg} -c android.intent.category.LAUNCHER 1"
            elif action == 'launch-am':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell am start -n {pkg}/{pkg}.MainActivity"
            elif action == 'launch-am-main':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell am start -n {pkg}/{pkg}.main.MainActivity"
            elif action == 'kill':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell am force-stop {pkg}"
            elif action == 'killall':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'killall -v {pkg}\'\""
            elif action == 'clear-data':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm clear {pkg}"
            elif action == 'clear-cache':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm clear --cache-only {pkg}"
            elif action == 'add-to-denylist':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'magisk --denylist add {pkg}\'\""
            elif action == 'rm-from-denylist':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell \"su -c \'magisk --denylist rm {pkg}\'\""
            elif action == 'optimize':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell cmd {pkg} compile -m speed-profile -a"
            elif action == 'reset-optimize':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell cmd {pkg} compile --reset -a"
            elif action == 'open-url' and url:
                theCmd = f"\"{get_adb()}\" -s {self.id} shell am start -a android.intent.action.VIEW -d '{url}'"

            return run_shell2(theCmd)
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not {action} {pkg}.")


    # ----------------------------------------------------------------------------
    #                               Method get_package_info
    # ----------------------------------------------------------------------------
    def get_package_info(self, pkg: str) -> dict:
        if self.true_mode != 'adb':
            return None
        try:
            theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -f {pkg}"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                # Check if package is in the output
                if pkg in res.stdout:
                    # Parse the path from output like: package:/data/app/.../base.apk=com.example.package
                    for line in res.stdout.strip().split('\n'):
                        if f'={pkg}' in line and line.startswith('package:'):
                            # Remove everything from last '=' to end, then remove 'package:' prefix exmaple:
                            # From: package:/data/app/~~EbETURkpF3BXLejYNHlp-w==/cypzdi.vdbwdd.oujrgk-HRAnkdg4qf8oozTjdb0UlQ==/base.apk=cypzdi.vdbwdd.oujrgk
                            # To: /data/app/~~EbETURkpF3BXLejYNHlp-w==/cypzdi.vdbwdd.oujrgk-HRAnkdg4qf8oozTjdb0UlQ==/base.apk
                            last_equals_pos = line.rfind('=')
                            path_with_prefix = line[:last_equals_pos]
                            path = path_with_prefix.replace('package:', '', 1)
                            return {'sourceDir': path}
                    # Package exists but couldn't parse path
                    return {'sourceDir': ''}
                else:
                    # Package not found
                    return {}
            else:
                # Command failed
                return {}
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not check package {pkg} info.")
            return None


    # ----------------------------------------------------------------------------
    #                               method get_package_list
    # ----------------------------------------------------------------------------
    def get_package_list(self, state = ''):
        # possible options 'all', 'all+uninstalled', 'disabled', 'enabled', 'system', '3rdparty', 'user0', 'uid'
        if self.true_mode != 'adb':
            return
        try:
            if state == 'all':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages"
            elif state == 'all+uninstalled':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -u"
            elif state == 'disabled':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -d"
            elif state == 'enabled':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -e"
            elif state == 'system':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -s"
            elif state == '3rdparty':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -3"
            elif state == 'user0':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -s --user 0"
            elif state == 'uid':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages -U"
            elif state == 'apex-only':
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages --apex-only --show-versioncode"
            else:
                # Default to all packages if no state specified
                theCmd = f"\"{get_adb()}\" -s {self.id} shell pm list packages"

            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                return res.stdout.replace('package:','')
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package list of {state}.")
            print(f"Return Code: {res.returncode}")
            print(f"Stdout: {res.stdout}")
            print(f"Stderr: {res.stderr}")
            return None
        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get package list of {state}.")
            return None


    # ----------------------------------------------------------------------------
    #                               method get_detailed_packages
    # ----------------------------------------------------------------------------
    def get_detailed_packages(self, simplified=False):
        if self.true_mode != 'adb':
            return -1
        try:
            self.packages.clear()
            # get labels
            labels = get_labels()
            # Get all packages including uninstalled ones
            list = self.get_package_list('all+uninstalled')
            if not list:
                return -1
            for item in list.split("\n"):
                if item:
                    package = Package(item)
                    package.type = "System"
                    package.installed = False
                    with contextlib.suppress(Exception):
                        package.label = labels[item]
                    self.packages[item] = package

            # Get all packages
            list = self.get_package_list('all')
            if list:
                for item in list.split("\n"):
                    if item and item in self.packages:
                        self.packages[item].installed = True

            # Get 3rd party packages
            list = self.get_package_list('3rdparty')
            if list:
                for item in list.split("\n"):
                    if item and item in self.packages:
                        self.packages[item].type = '3rd Party'

            # Get disabled packages
            list = self.get_package_list('disabled')
            if list:
                for item in list.split("\n"):
                    if item and item in self.packages:
                        self.packages[item].enabled = False

            # Get enabled packages
            list = self.get_package_list('enabled')
            if list:
                for item in list.split("\n"):
                    if item and item in self.packages:
                        self.packages[item].enabled = True

            # Get user 0 packages
            list = self.get_package_list('user0')
            if list:
                for item in list.split("\n"):
                    if item and item in self.packages:
                        self.packages[item].user0 = True

            if not simplified:
                # Get magisk denylist packages
                list = self.get_magisk_denylist()
                if list:
                    for item in list:
                        if item and item in self.packages:
                            self.packages[item].magisk_denylist = True

                # Get package UIDs
                list = self.get_package_list('uid')
                if list:
                    for item in list.split("\n"):
                        if item:
                            package, uid = item.split(" ", 1)
                            uid = uid.replace("uid:", "")
                            if package in self.packages:
                                self.packages[package].uid = uid

        except Exception as e:
            traceback.print_exc()
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get detailed packages.")
            puml("#red:ERROR: Could not get detailed packages;\n", True)
            return -1
        return 0


# ============================================================================
#                               Function update_phones
# ============================================================================
def update_phones(device_id, mode=None):
    try:
        phones = get_phones()
        devices = get_device_list()
        # Find the index of the entry you want to replace
        index_to_replace = None
        device_is_found = False

        for i, device in enumerate(phones):
            if device.id == device_id:
                index_to_replace = i
                device = None
                device_is_found = True
                break

        state = None
        if mode:
            if mode in ['device', 'adb', 'recovery', 'sideload', 'rescue', 'safemode', 'recovery_interactive']:
                state = 'adb'
            elif mode in ['fastboot', 'f.b', 'bootloader', 'fastbootd']:
                state = 'f.b'
            else:
                mode = None
            debug(f"mode: {mode}, state: {state}")

        # don't use else here, because mode can be None
        if not mode or not device_is_found:
            if get_adb():
                theCmd = f"\"{get_adb()}\" -s {device_id} get-state"
                debug(theCmd)
                res = run_shell(theCmd, timeout=60)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                    device_mode = res.stdout.strip('\n')
                    debug(f"device_mode: {device_mode}")
                    state = 'adb'
                    device_is_found = True
            if get_fastboot():
                theCmd = f"\"{get_fastboot()}\" -s {device_id} devices"
                debug(theCmd)
                res = run_shell(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0 and 'fastboot' in res.stdout:
                    debug("device_mode: f.b")
                    state = 'f.b'
                    device_is_found = True
            debug(f"mode: None, state: {state}")

        if mode in ['recovery', 'sideload', 'rescue']:
            device = Device(device_id, 'adb', mode)
        else:
            device = Device(device_id, state)
        device.init(state)
        device_details = device.get_device_details()
        print(f"Device: {device_details}")

        # If the device is not in the list, but is found, append it
        if index_to_replace is None and device_details != "ERROR" and device:
            phones.append(device)
            devices.append(device_details)

        # Replace the entry at the found index with the new device_details or remove if it does not exist
        if index_to_replace is not None:
            if device_details != "ERROR" and device:
                phones[index_to_replace] = device
                devices[index_to_replace] = device_details
                debug(f"Device found, updating device entry: {device_id}")
                set_phone_id(device.id)
            else:
                with contextlib.suppress(Exception):
                    debug(f"Device not found, removing device details for entry: {device_id}")
                    del phones[index_to_replace]
                    del devices[index_to_replace]
                    set_phone_id(None)

        set_phones(phones)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while updating phones.")
        traceback.print_exc()
        puml("#red:Encountered an error;\n", True)
        puml(f"note right\n{e}\nend note\n")

    set_device_list(devices)
    return devices


# ============================================================================
#                               Function _init_device_parallel
# Initialize a single device in parallel.
# Returns (device_details, device, device_id) or None on error.
# ============================================================================
def _init_device_parallel(device_info):
    d_id, mode, true_mode, device_type = device_info
    try:
        dev_init_start = time.time()
        if device_type == 'adb':
            device = Device(d_id, 'adb', true_mode)
            device.init('adb')
        else:  # fastboot
            device = Device(d_id, 'f.b')
            device.init('f.b')
        device_details = device.get_device_details()
        dev_init_duration = time.time() - dev_init_start

        # Extract device name and hardware for devices.json
        device_name = getattr(device, 'hardware', '') or ''
        hardware = getattr(device, 'hardware', '') or ''

        return (device_details, device, d_id, device_name, hardware, dev_init_duration)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error initializing device {d_id}: {e}")
        traceback.print_exc()
        return None

# ============================================================================
#                               Function get_connected_devices
# ============================================================================
def get_connected_devices(respect_device_filter=True, scan_all=False):
    devices = []
    phones = []
    all_detected_device_ids = []
    devices_to_init = []  # List of (d_id, mode, true_mode, device_type) tuples
    scan_start = time.time()
    device_init_times = []

    try:
        if get_adb():
            theCmd = f"\"{get_adb()}\" devices"
            debug(theCmd)
            adb_start = time.time()
            res = run_shell(theCmd, timeout=60)
            adb_duration = time.time() - adb_start
            debug(f"ADB devices command took {adb_duration:.2f}s")
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Return Code: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.stdout:
                    for device in res.stdout.split('\n'):
                        if any(keyword in device for keyword in ['device', 'recovery', 'sideload', 'rescue']):
                            if device == "List of devices attached":
                                continue
                            try:
                                d_id = device.split("\t")
                                if len(d_id) != 2:
                                    continue
                                mode = d_id[1].strip()
                                d_id = d_id[0].strip()

                                # Track this device
                                all_detected_device_ids.append(d_id)

                                # Add/update device in devices.json FIRST (before filtering)
                                add_or_update_device(d_id, '', '', connected=True)

                                # Check if device is enabled (unless scan_all is True)
                                if not scan_all and respect_device_filter and not is_device_enabled(d_id):
                                    print(f"Device {d_id} is disabled, skipping...")
                                    continue

                                true_mode = None
                                if mode in ('recovery', 'sideload', 'rescue'):
                                    true_mode = mode

                                # Queue device for parallel initialization
                                devices_to_init.append((d_id, mode, true_mode, 'adb'))
                            except Exception as e:
                                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error processing ADB device.")
                                traceback.print_exc()
                    else:
                        if device.strip() != "":
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unknown device state: {device}\n")
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting connected adb devices.")
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adb command is not found!")

        if get_fastboot():
            theCmd = f"\"{get_fastboot()}\" devices"
            debug(theCmd)
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Return Code: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.stdout:
                    # debug(f"fastboot devices:\n{res.stdout}")
                    for device in res.stdout.split('\n'):
                        try:
                            if 'no permissions' in device:
                                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: No permissions to access fastboot device\nsee [http://developer.android.com/tools/device.html]")
                                puml("#red:No permissions to access fastboot device;\n", True)
                                continue
                            if 'fastboot' in device:
                                d_id = device.split("\t")
                                d_id = d_id[0].strip()

                                # Track this device
                                all_detected_device_ids.append(d_id)

                                # Add/update device in devices.json FIRST (before filtering)
                                add_or_update_device(d_id, '', '', connected=True)

                                # Check if device is enabled (unless scan_all is True)
                                if not scan_all and respect_device_filter and not is_device_enabled(d_id):
                                    print(f"Device {d_id} is disabled, skipping...")
                                    continue

                                # Queue device for parallel initialization
                                devices_to_init.append((d_id, 'fastboot', None, 'fastboot'))
                        except Exception as e:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error processing fastboot device.")
                            traceback.print_exc()
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting fastboot devices.")

        # Initialize devices in parallel using ThreadPoolExecutor
        if devices_to_init:
            parallel_start = time.time()
            print(f"Initializing {len(devices_to_init)} device(s) in parallel...")
            with ThreadPoolExecutor(max_workers=min(len(devices_to_init), 4)) as executor:
                future_to_device = {
                    executor.submit(_init_device_parallel, device_info): device_info for device_info in devices_to_init
                }

                for future in as_completed(future_to_device):
                    result = future.result()
                    if result:
                        device_details, device, d_id, device_name, hardware, duration = result
                        devices.append(device_details)
                        phones.append(device)
                        device_init_times.append((d_id, duration))
                        debug(f"Device {d_id} initialization took {duration:.2f}s")

                        # Update device in devices.json
                        add_or_update_device(d_id, device_name, hardware, connected=True)

            parallel_duration = time.time() - parallel_start
            print(f"Parallel device initialization completed in {parallel_duration:.2f}s")

        # Update connection status for all known devices
        update_all_devices_connection_status(all_detected_device_ids)

        set_phones(phones)

        # Print timing summary
        scan_duration = time.time() - scan_start
        print(f"Device scan completed in {scan_duration:.2f}s")
        if device_init_times:
            total_init_time = sum(t[1] for t in device_init_times)
            avg_init_time = total_init_time / len(device_init_times)
            print(f"  Total device initialization: {total_init_time:.2f}s (avg: {avg_init_time:.2f}s per device)")
            for d_id, duration in device_init_times:
                print(f"    {d_id}: {duration:.2f}s")
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting connected devices.")
        traceback.print_exc()
        puml("#red:Encountered an error;\n", True)
        puml(f"note right\n{e}\nend note\n")

    set_device_list(devices)
    return devices

```

`pif_manager.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import wx
import wx.stc as stc
import traceback
import images as images
import json
import json5
import re
from datetime import datetime
from runtime import *
from file_editor import FileEditor
from i18n import _
from package_manager import PackageManager
from factory_image_selector import show_factory_image_dialog
from message_box_ex import MessageBoxEx

# ============================================================================
#                               Class PifModule
# ============================================================================
class PifModule:
    def __init__(self, id, name, version, version_code, format, path, flavor):
        self.id = id
        self.name = name
        self.version = version
        self.version_code = version_code
        self.format = format
        self.path = path
        self.flavor = flavor

# ============================================================================
#                               Class PifManager
# ============================================================================
class PifManager(wx.Dialog):
    def __init__(self, *args, parent=None, config=None, **kwargs):
        self.config = config
        wx.Dialog.__init__(self, parent, *args, **kwargs, style=wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER)
        # Position the dialog 200 px offset horizontally
        default_pos = self.GetPosition()
        offset_x = default_pos.x + 200
        self.SetPosition((offset_x, default_pos.y))

        self.config = config
        self.SetTitle(_("Pif Manager"))
        self.pif_path = None
        self.device_pif = ''
        self.pi_app = 'gr.nikolasspyr.integritycheck'
        # self.launch_method = 'launch-am'
        self.launch_method = 'launch'
        self.coords = Coords()
        self.enable_buttons = False
        self.pif_exists = False
        self.pif_flavor = 'playintegrityfork_9999999'
        self.favorite_pifs = get_favorite_pifs()
        self.insync = False
        self.pif_format = None
        self.keep_unknown = False
        self.current_pif_module = {}
        self._last_call_was_on_spin = False
        self.beta_pif_version = 'latest'
        self._tf_targets_loaded = False
        self._validation_timer = None  # Timer for debounced validation
        self.download_state = None     # For aborting download/processing

        # Active pif label
        self.active_pif_label = wx.StaticText(parent=self, id=wx.ID_ANY, label=_("Active Pif"))
        self.active_pif_label.SetToolTip(_("Loaded Pif (from Device)"))
        font = wx.Font(12, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        self.active_pif_label.SetFont(font)
        # Modified status
        self.pif_modified_image = wx.StaticBitmap(parent=self)
        self.pif_modified_image.SetBitmap(images.alert_gray_24.GetBitmap())
        self.pif_modified_image.SetToolTip(_("Active pif is not modified."))
        # Save pif
        self.save_pif_button = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.save_pif_button.SetBitmap(images.save_24.GetBitmap())
        self.save_pif_button.SetToolTip(_("Save Active pif content to a json file on disk."))
        # Module version label
        self.pif_selection_combo = wx.ComboBox(self, choices=[], style=wx.CB_READONLY)
        self.pif_selection_combo.SetToolTip(_("Pif Module"))
        # TF Targets
        self.tf_targets_combo = wx.ComboBox(self, choices=[_("TF Targets")], style=wx.CB_READONLY)
        self.tf_targets_combo.SetToolTip(_("TargetedFix Targets"))
        self.tf_targets_combo.SetSelection(0)
        self.tf_targets_combo.SetForegroundColour(wx.Colour(128, 128, 128))  # Gray placeholder text
        self.tf_targets_combo.SetMinSize((130, -1))
        self.tf_targets_combo.Enable(False)
        # Favorite button
        self.favorite_pif_button = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.favorite_pif_button.SetBitmap(images.heart_gray_24.GetBitmap())
        self.favorite_pif_button.SetToolTip(_("Active pif is not saved in favorites."))
        # Combo Box of favorites
        pif_labels = [pif["label"] for pif in self.favorite_pifs.values()]
        self.pif_combo_box = wx.ComboBox(self, choices=pif_labels, style=wx.CB_READONLY)
        # Import button
        self.import_pif_button = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.import_pif_button.SetBitmap(images.import_24.GetBitmap())
        self.import_pif_button.SetToolTip(_("Select a folder to import pif json files."))

        # Active Pif
        self.active_pif_stc = stc.StyledTextCtrl(self)
        self.setup_syntax_highlighting(self.active_pif_stc)
        self.active_pif_stc.SetCaretForeground(wx.BLACK)
        font = wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        self.active_pif_stc.StyleSetFont(wx.stc.STC_STYLE_DEFAULT, font)
        self.active_pif_stc.SetWrapMode(wx.stc.STC_WRAP_NONE)
        self.active_pif_stc.SetUseHorizontalScrollBar(True)
        self.active_pif_stc.SetTabWidth(4)
        self.active_pif_stc.SetIndent(4)
        self.active_pif_stc.SetMarginType(1, stc.STC_MARGIN_NUMBER)
        self.active_pif_stc.SetMarginWidth(1, 30)

        # TargetedFix button row (initially hidden)
        self.tf_add_target_button = wx.Button(self, wx.ID_ANY, _("Add TF Target"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.tf_add_target_button.SetToolTip(_("Add a new TargetedFix target by selecting from package list on device"))

        self.tf_delete_target_button = wx.Button(self, wx.ID_ANY, _("Delete TF Target"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.tf_delete_target_button.SetToolTip(_("Delete the selected TargetedFix target"))
        self.tf_delete_target_button.Enable(False)

        self.tf_edit_targets_button = wx.Button(self, wx.ID_ANY, _("Edit TF Targets"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.tf_edit_targets_button.SetToolTip(_("Edit TargetedFix targets file"))
        # self.tf_edit_targets_button.Enable(False)

        self.tf_push_json_button = wx.Button(self, wx.ID_ANY, _("Push TF Json"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.tf_push_json_button.SetToolTip(_("Push Active pif content as JSON to the selected TargetedFix target"))
        self.tf_push_json_button.Enable(False)

        # TargetedFix button row sizer (initially hidden)
        self.tf_buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.tf_buttons_sizer.Add(self.tf_add_target_button, 0, wx.ALL, 5)
        self.tf_buttons_sizer.Add(self.tf_delete_target_button, 0, wx.ALL, 5)
        self.tf_buttons_sizer.Add(self.tf_edit_targets_button, 0, wx.ALL, 5)
        self.tf_buttons_sizer.Add(self.tf_push_json_button, 0, wx.ALL, 5)
        self.tf_buttons_sizer.AddStretchSpacer()

        # Hide the TargetedFix buttons initially
        self.tf_add_target_button.Show(False)
        self.tf_delete_target_button.Show(False)
        self.tf_edit_targets_button.Show(False)
        self.tf_push_json_button.Show(False)

        # Console label
        self.console_label = wx.StaticText(parent=self, id=wx.ID_ANY, label=_("Output"))
        self.console_label.SetToolTip(_("Console Output:\nIt could be the json output of processed prop\nor it could be the Play Integrity Check result.\n\nThis is not what currently is on the device."))
        font = wx.Font(12, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        self.console_label.SetFont(font)
        # Smart Paste Up
        self.smart_paste_up = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.smart_paste_up.SetBitmap(images.smart_paste_up_24.GetBitmap())
        self.smart_paste_up.SetToolTip(_("Smart Paste:\nSets First API to the set value if it is missing or forced.\nReprocesses the output window content to adapt to current module requirements.\nPastes to Active pif."))
        self.smart_paste_up.Enable(False)
        # Paste Up
        self.paste_up = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.paste_up.SetBitmap(images.paste_up_24.GetBitmap())
        self.paste_up.SetToolTip(_("Paste the console window content to Active pif."))
        self.paste_up.Enable(False)
        # Paste Down
        self.paste_down = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.paste_down.SetBitmap(images.paste_down_24.GetBitmap())
        self.paste_down.SetToolTip(_("Paste the Active pif to console window."))
        self.paste_down.Enable(False)
        # Reprocess
        self.reprocess = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.reprocess.SetBitmap(images.scan_24.GetBitmap())
        self.reprocess.SetToolTip(_("Reprocess current Active Pif window json.\nUseful if you changed module version which might require additional / different fields."))
        self.reprocess.Enable(False)
        # Reprocess Json File(s)
        self.reprocess_json_file = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.reprocess_json_file.SetBitmap(images.json_24.GetBitmap())
        self.reprocess_json_file.SetToolTip(_("Reprocess one or many json file(s)\nUseful if you changed module version which might require additional / different fields.\nIf a single file is selected, the new json will output to console output\nHowever if multiple files are selected, the selected file will be updated in place."))
        # Env to Json
        self.e2j = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.e2j.SetBitmap(images.e2j_24.GetBitmap())
        self.e2j.SetToolTip(_("Convert console content from env (key=value) prop format to json"))
        # Json to Env
        self.j2e = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.j2e.SetBitmap(images.j2e_24.GetBitmap())
        self.j2e.SetToolTip(_("Convert console content from json to env (key=value) prop format"))
        # Get FP Code
        self.get_fp_code = wx.BitmapButton(parent=self, id=wx.ID_ANY, bitmap=wx.NullBitmap, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.BU_AUTODRAW)
        self.get_fp_code.SetBitmap(images.java_24.GetBitmap())
        self.get_fp_code.SetToolTip(_("Process one or many json file(s) to generate the FrameworkPatcher formatted code excerpts.\n"))
        # Add missing keys checkbox
        self.add_missing_keys_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Add missing Keys from device"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.add_missing_keys_checkbox.SetToolTip(_("When Processing or Reprocessing, add missing fields from device."))
        # Force First API
        self.force_first_api_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Force First API to:"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.force_first_api_checkbox.SetToolTip(_("Forces First API value(s) to"))
        # Input box for the API value
        self.api_value_input = wx.TextCtrl(parent=self, id=wx.ID_ANY, value="25", size=(40, -1))
        # sort_keys
        self.sort_keys_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Sort Keys"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.sort_keys_checkbox.SetToolTip(_("Sorts json keys"))
        # keep_unknown
        self.keep_unknown_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Keep All keys"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.keep_unknown_checkbox.SetToolTip(_("Does not remove non standard / unrecognized keys"))
        # add advanced options checkboxes
        self.spoofBuild_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Spoof Build"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.spoofBuild_checkbox.SetValue(True)
        self.spoofProps_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Spoof Props"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.spoofProvider_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Spoof Provider"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.spoofSignature_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Spoof Signature"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.spoofVendingSdk_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Spoof Vending SDK"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.spoofVendingFinger_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Spoof Vending Fingerprint"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)

        # Console
        self.console_stc = stc.StyledTextCtrl(self)
        self.setup_syntax_highlighting(self.console_stc)
        self.console_stc.SetCaretForeground(wx.BLACK)
        font = wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        self.console_stc.StyleSetFont(wx.stc.STC_STYLE_DEFAULT, font)
        self.console_stc.SetWrapMode(wx.stc.STC_WRAP_NONE)
        self.console_stc.SetUseHorizontalScrollBar(True)
        self.console_stc.SetTabWidth(4)
        self.console_stc.SetIndent(4)
        self.console_stc.SetMarginType(1, stc.STC_MARGIN_NUMBER)
        self.console_stc.SetMarginWidth(1, 30)

        # Close button
        self.close_button = wx.Button(self, wx.ID_ANY, _("Close"), wx.DefaultPosition, wx.DefaultSize, 0)

        # Create print button
        self.create_pif_button = wx.Button(self, wx.ID_ANY, _("Create print"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.create_pif_button.SetToolTip(_("Create pif.json / spoof_build_vars"))
        self.create_pif_button.Enable(False)

        # Push print no validation button
        self.push_pif_button = wx.Button(self, wx.ID_ANY, _("Push print, no validation"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.push_pif_button.SetToolTip(_("Pushes the print as is without performing any validation.\nThis is useful to retain comments."))
        self.push_pif_button.Enable(False)

        # Reload print button
        self.reload_pif_button = wx.Button(self, wx.ID_ANY, _("Reload print"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.reload_pif_button.SetToolTip(_("Reload pif.json / spoof_build_vars from device."))
        self.reload_pif_button.Enable(False)

        # Clean DG button
        self.cleanup_dg_button = wx.Button(self, wx.ID_ANY, _("Cleanup DG"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.cleanup_dg_button.SetToolTip(_("Cleanup Droidguard Cache"))
        self.cleanup_dg_button.Enable(False)

        # Push keybox button
        self.push_kb_button = wx.Button(self, wx.ID_ANY, _("Push keybox.xml"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.push_kb_button.SetToolTip(_("Push a valid keybox.xml to device."))
        self.push_kb_button.Enable(False)
        self.push_kb_button.Show(False)

        # Edit Tricky Store target.txt button
        self.edit_ts_target_button = wx.Button(self, wx.ID_ANY, _("Edit TS Target"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.edit_ts_target_button.SetToolTip(_("Edit Tricky Store target.txt file."))
        self.edit_ts_target_button.Enable(False)
        self.edit_ts_target_button.Show(False)

        # Edit Tricky Store security_patch.txt button
        self.edit_security_patch_button = wx.Button(self, wx.ID_ANY, _("Edit TS SP"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.edit_security_patch_button.SetToolTip(_("Edit Tricky Store security_patch.txt file."))
        self.edit_security_patch_button.Enable(False)
        self.edit_security_patch_button.Show(False)

        # Process build.prop button
        self.process_build_prop_button = wx.Button(self, wx.ID_ANY, _("Process build.prop(s)"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.process_build_prop_button.SetToolTip(_("Process build.prop to extract a compatible print."))

        # Process bulk prop
        self.process_bulk_prop_button = wx.Button(self, wx.ID_ANY, _("Process bulk props"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.process_bulk_prop_button.SetToolTip(_("Process a folder containing .prop files and convert then to .json files."))
        self.process_bulk_prop_button.Hide()

        # Process Image
        self.process_img_button = wx.Button(self, wx.ID_ANY, _("Process Image"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.process_img_button.SetToolTip(_("Process an image and get a print from it."))
        self.process_img_button.Hide()
        # if self.config.enable_pixel_img_process:
        self.process_img_button.Show()

        # Check for Auto Push print
        self.auto_update_pif_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Auto Update print"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.auto_update_pif_checkbox.SetToolTip(_("After Processing build.props, the print is automatically pushed to the device and the GMS process is killed."))
        self.auto_update_pif_checkbox.Enable(False)

        # Check for Auto Check Play Integrity
        self.auto_check_pi_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Auto Check Play Integrity"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.auto_check_pi_checkbox.SetToolTip(_("After saving (pushing) print, automatically run Play Integrity Check."))
        self.auto_check_pi_checkbox.Enable(False)

        # Auto Run migrate script
        self.auto_run_migrate_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Auto run migrate.sh"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.auto_run_migrate_checkbox.SetToolTip(_("After saving (pushing) print, automatically run migrate.sh"))
        self.auto_run_migrate_checkbox.Enable(False)

        # option button PI Selection
        self.pi_choices = ["Play Integrity API Checker", "Simple Play Integrity Checker", "Android Integrity Checker", "Play Store"]
        self.pi_option = wx.RadioBox(self, choices=self.pi_choices, style=wx.RA_VERTICAL)

        # Disable UIAutomator
        self.disable_uiautomator_checkbox = wx.CheckBox(parent=self, id=wx.ID_ANY, label=_("Disable UIAutomator"), pos=wx.DefaultPosition, size=wx.DefaultSize, style=0)
        self.disable_uiautomator_checkbox.SetToolTip(_("Disables UIAutomator\nThis is useful for devices with buggy UIAutomator.\nNOTE: Create the coords.json file manually to make use of automated testing."))

        # Play Integrity API Checker button
        self.pi_checker_button = wx.Button(self, wx.ID_ANY, _("Play Integrity Check"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.pi_checker_button.SetToolTip(_("Play Integrity API Checker\nNote: Need to install app from Play store."))

        # Beta Pif version selection
        self.rb_latest = wx.RadioButton(self, wx.ID_ANY, _("Latest"), style=wx.RB_GROUP)
        self.rb_custom = wx.RadioButton(self, wx.ID_ANY, _("Custom"))
        self.rb_custom.SetToolTip(_("Select 'Latest' to get the latest Pixel beta pif (Includes Developer Preview).\nSelect 'Custom' to set a custom Android version code."))
        self.rb_latest.SetValue(True)

        # Custom version input
        self.custom_version = wx.TextCtrl(self, wx.ID_ANY, "17", size=(75, -1))
        self.custom_version.SetToolTip(_("Set a valid Android version code."))
        # self.custom_version.SetToolTip(_("Set a valid two digit Android version code,\nor 'C' for Canary,\nor 'CANARY_rxx' for Canary release.\nExample: 15, 16, 17, C, CANARY_r01\nNote: The custom version is only used when 'Custom' is selected."))
        self.custom_version.Enable(False)

        # Get Beta Pif button
        self.beta_pif_button = wx.Button(self, wx.ID_ANY, _("Get Pixel Beta Pif"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.beta_pif_button.SetToolTip(_("Get the latest Pixel beta pif."))

        # Get the Canary miner button
        self.canary_pif_button = wx.Button(self, wx.ID_ANY, _("Get the Canary miner"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.canary_pif_button.SetToolTip(_("Get the latest Vagelis1608 Canary pif."))

        # Get TheFreeman193 Pif button
        self.freeman_pif_button = wx.Button(self, wx.ID_ANY, _("Get TheFreeman193 Random Pif"), wx.DefaultPosition, wx.DefaultSize, 0)
        self.freeman_pif_button.SetToolTip(_("Get a random pif from TheFreeman193 repository.\nNote: The pif might or might not work."))

        # Make the buttons the same size
        button_width = self.pi_option.GetSize()[0] + 10
        self.create_pif_button.SetMinSize((button_width, -1))
        self.push_pif_button.SetMinSize((button_width, -1))
        self.reload_pif_button.SetMinSize((button_width, -1))
        self.cleanup_dg_button.SetMinSize((button_width, -1))
        self.push_kb_button.SetMinSize((button_width, -1))
        self.edit_ts_target_button.SetMinSize((button_width, -1))
        self.edit_security_patch_button.SetMinSize((button_width, -1))
        self.process_build_prop_button.SetMinSize((button_width, -1))
        self.process_bulk_prop_button.SetMinSize((button_width, -1))
        self.process_img_button.SetMinSize((button_width, -1))
        self.auto_update_pif_checkbox.SetMinSize((button_width, -1))
        self.auto_check_pi_checkbox.SetMinSize((button_width, -1))
        self.auto_run_migrate_checkbox.SetMinSize((button_width, -1))
        self.disable_uiautomator_checkbox.SetMinSize((button_width, -1))
        self.pi_checker_button.SetMinSize((button_width, -1))
        self.canary_pif_button.SetMinSize((button_width, -1))
        self.freeman_pif_button.SetMinSize((button_width, -1))
        self.beta_pif_button.SetMinSize((button_width, -1))

        h_buttons_sizer = wx.BoxSizer(wx.HORIZONTAL)
        h_buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)
        h_buttons_sizer.Add(self.close_button, 0, wx.ALL, 5)
        h_buttons_sizer.Add((0, 0), 1, wx.EXPAND, 5)

        # h_api_sizer
        h_api_sizer = wx.BoxSizer(wx.HORIZONTAL)
        h_api_sizer.Add(self.force_first_api_checkbox, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 0)
        h_api_sizer.Add(self.api_value_input, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)

        self.beta_pif_hsizer = wx.BoxSizer(wx.HORIZONTAL)
        self.beta_pif_hsizer.Add(self.rb_latest, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
        self.beta_pif_hsizer.Add(self.rb_custom, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
        self.beta_pif_hsizer.Add(self.custom_version, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)

        v_buttons_sizer = wx.BoxSizer(wx.VERTICAL)
        v_buttons_sizer.Add(self.create_pif_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.push_pif_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.reload_pif_button, 0, wx.TOP | wx.RIGHT | wx.BOTTOM, 5)
        v_buttons_sizer.Add(self.cleanup_dg_button, 0, wx.TOP | wx.RIGHT | wx.BOTTOM, 5)
        v_buttons_sizer.Add(self.push_kb_button, 0, wx.TOP | wx.RIGHT | wx.BOTTOM, 5)
        v_buttons_sizer.Add(self.edit_ts_target_button, 0, wx.TOP | wx.RIGHT | wx.BOTTOM, 5)
        v_buttons_sizer.Add(self.edit_security_patch_button, 0, wx.TOP | wx.RIGHT | wx.BOTTOM, 5)
        v_buttons_sizer.AddStretchSpacer()
        v_buttons_sizer.Add(self.process_build_prop_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.process_bulk_prop_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.process_img_button, 0, wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.auto_update_pif_checkbox, 0, wx.ALL, 5)
        v_buttons_sizer.Add(self.auto_check_pi_checkbox, 0, wx.ALL, 5)
        v_buttons_sizer.Add(self.auto_run_migrate_checkbox, 0, wx.ALL, 5)
        v_buttons_sizer.Add(self.pi_option, 0, wx.TOP, 5)
        v_buttons_sizer.Add(self.disable_uiautomator_checkbox, 0, wx.TOP | wx.BOTTOM | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.pi_checker_button, 0, wx.TOP | wx.BOTTOM | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.beta_pif_hsizer, 0, wx.EXPAND | wx.TOP | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.beta_pif_button, 0, wx.TOP | wx.BOTTOM | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.canary_pif_button, 0, wx.TOP | wx.BOTTOM | wx.RIGHT, 5)
        v_buttons_sizer.Add(self.freeman_pif_button, 0, wx.TOP | wx.BOTTOM | wx.RIGHT, 5)

        self.vertical_btn_sizer1 = wx.BoxSizer(wx.VERTICAL)
        self.vertical_btn_sizer1.Add(self.paste_up, 0, wx.ALL, 0)
        self.vertical_btn_sizer1.AddStretchSpacer()
        self.vertical_btn_sizer1.Add(self.paste_down, 0, wx.ALL, 0)

        self.vertical_btn_sizer2 = wx.BoxSizer(wx.VERTICAL)
        self.vertical_btn_sizer2.Add(self.reprocess_json_file, 1, wx.ALL, 0)
        self.vertical_btn_sizer2.Add(self.e2j, 1, wx.ALL, 0)
        self.vertical_btn_sizer2.Add(self.j2e, 1, wx.ALL, 0)
        self.vertical_btn_sizer2.Add(self.get_fp_code, 1, wx.ALL, 0)

        self.vertical_cb_sizer1 = wx.BoxSizer(wx.VERTICAL)
        self.vertical_cb_sizer1.Add(self.add_missing_keys_checkbox, 1, wx.ALL, 0)
        self.vertical_cb_sizer1.Add(h_api_sizer, 1, wx.ALL, 0)
        self.vertical_cb_sizer1.Add(self.sort_keys_checkbox, 1, wx.ALL, 0)
        self.vertical_cb_sizer1.Add(self.keep_unknown_checkbox, 1, wx.ALL, 0)

        self.vertical_cb_sizer2 = wx.BoxSizer(wx.VERTICAL)
        self.vertical_cb_sizer2.Add(self.spoofBuild_checkbox, 1, wx.ALL, 0)
        self.vertical_cb_sizer2.Add(self.spoofProps_checkbox, 1, wx.ALL, 0)
        self.vertical_cb_sizer2.Add(self.spoofProvider_checkbox, 1, wx.ALL, 0)
        self.vertical_cb_sizer2.Add(self.spoofSignature_checkbox, 1, wx.ALL, 0)
        self.vertical_cb_sizer2.Add(self.spoofVendingSdk_checkbox, 1, wx.ALL, 0)
        self.vertical_cb_sizer2.Add(self.spoofVendingFinger_checkbox, 1, wx.ALL, 0)

        console_label_sizer = wx.BoxSizer(wx.HORIZONTAL)
        console_label_sizer.AddSpacer(10)
        console_label_sizer.Add(self.console_label, 0, wx.ALIGN_BOTTOM)
        console_label_sizer.AddSpacer(10)
        console_label_sizer.Add(self.smart_paste_up, 0, wx.ALIGN_TOP)
        console_label_sizer.AddSpacer(10)
        console_label_sizer.Add(self.reprocess, 0, wx.ALIGN_TOP)
        console_label_sizer.AddSpacer(10)
        console_label_sizer.Add(self.vertical_btn_sizer1, 1, wx.EXPAND)
        console_label_sizer.AddSpacer(10)
        console_label_sizer.Add(self.vertical_btn_sizer2, 0, wx.EXPAND)
        console_label_sizer.AddSpacer(15)
        console_label_sizer.Add(self.vertical_cb_sizer1, 0, wx.EXPAND)
        console_label_sizer.AddSpacer(15)
        console_label_sizer.Add(self.vertical_cb_sizer2, 0, wx.EXPAND)

        stc_sizer = wx.BoxSizer(wx.VERTICAL)
        stc_sizer.Add(self.active_pif_stc, 1, wx.EXPAND | wx.ALL, 10)
        stc_sizer.Add(self.tf_buttons_sizer, 0, wx.EXPAND | wx.LEFT | wx.RIGHT, 10)
        stc_sizer.Add(console_label_sizer, 0, wx.TOP, 10)
        stc_sizer.Add(self.console_stc, 1, wx.EXPAND | wx.ALL, 10)

        outside_stc_sizer = wx.BoxSizer(wx.HORIZONTAL)
        outside_stc_sizer.Add(stc_sizer, 1, wx.EXPAND | wx.ALL, 0)
        outside_stc_sizer.Add(v_buttons_sizer, 0, wx.EXPAND | wx.ALL, 0)

        active_pif_label_sizer = wx.BoxSizer(wx.HORIZONTAL)
        active_pif_label_sizer.AddSpacer(10)
        active_pif_label_sizer.Add(self.active_pif_label, 0, wx.ALIGN_CENTER_VERTICAL)
        active_pif_label_sizer.AddSpacer(10)
        active_pif_label_sizer.Add(self.pif_modified_image, 0, wx.ALIGN_CENTER_VERTICAL)
        active_pif_label_sizer.AddSpacer(10)
        active_pif_label_sizer.Add(self.save_pif_button, 0, wx.ALIGN_CENTER_VERTICAL)
        active_pif_label_sizer.AddSpacer(50)
        active_pif_label_sizer.Add(self.pif_selection_combo, 0, wx.ALIGN_CENTER_VERTICAL, 5)
        active_pif_label_sizer.AddSpacer(10)
        active_pif_label_sizer.Add(self.tf_targets_combo, 0, wx.ALIGN_CENTER_VERTICAL, 5)
        active_pif_label_sizer.AddSpacer(50)
        active_pif_label_sizer.Add(self.favorite_pif_button, 0, wx.ALIGN_CENTER_VERTICAL)
        active_pif_label_sizer.AddSpacer(10)
        active_pif_label_sizer.Add(self.pif_combo_box, 1, wx.EXPAND)
        active_pif_label_sizer.AddSpacer(10)
        active_pif_label_sizer.Add(self.import_pif_button, 0, wx.ALIGN_CENTER_VERTICAL)

        vSizer = wx.BoxSizer(wx.VERTICAL)
        vSizer.Add(active_pif_label_sizer, 0, wx.TOP, 10)
        vSizer.Add(outside_stc_sizer, 1, wx.EXPAND, 0)
        vSizer.Add(h_buttons_sizer, 0, wx.EXPAND, 10)

        self.SetSizer(vSizer)
        min_width = 800
        min_height = 500
        self.SetMinSize((min_width, min_height))
        self.Layout()

        # Connect Events
        self.save_pif_button.Bind(wx.EVT_BUTTON, self.onSavePif)
        self.pif_selection_combo.Bind(wx.EVT_COMBOBOX, self.onPifSelectionComboBox)
        self.tf_targets_combo.Bind(wx.EVT_COMBOBOX, self.onTFTargetSelectionComboBox)
        self.favorite_pif_button.Bind(wx.EVT_BUTTON, self.onSaveToFavorites)
        self.pif_combo_box.Bind(wx.EVT_COMBOBOX, self.onFavoritesComboBox)
        self.import_pif_button.Bind(wx.EVT_BUTTON, self.onImportFavorites)
        #
        self.active_pif_stc.Bind(wx.stc.EVT_STC_CHANGE, self.ActivePifStcChange)
        self.console_stc.Bind(wx.stc.EVT_STC_CHANGE, self.ConsoleStcChange)
        #
        self.create_pif_button.Bind(wx.EVT_BUTTON, self.onUpdatePrint)
        self.push_pif_button.Bind(wx.EVT_BUTTON, self.onPushPrint)
        self.reload_pif_button.Bind(wx.EVT_BUTTON, self.onReloadPrint)
        self.cleanup_dg_button.Bind(wx.EVT_BUTTON, self.onCleanupDG)
        self.push_kb_button.Bind(wx.EVT_BUTTON, self.onPushKeybox)
        self.edit_ts_target_button.Bind(wx.EVT_BUTTON, self.onEditTSTarget)
        self.edit_security_patch_button.Bind(wx.EVT_BUTTON, self.onEditTSSP)
        #
        self.process_build_prop_button.Bind(wx.EVT_BUTTON, self.onProcessBuildProps)
        self.process_bulk_prop_button.Bind(wx.EVT_BUTTON, self.onProcessBulkProps)
        self.process_img_button.Bind(wx.EVT_BUTTON, self.onProcessImage)
        self.auto_update_pif_checkbox.Bind(wx.EVT_CHECKBOX, self.onAutoUpdatePrint)
        self.auto_check_pi_checkbox.Bind(wx.EVT_CHECKBOX, self.onAutoCheckPlayIntegrity)
        self.auto_run_migrate_checkbox.Bind(wx.EVT_CHECKBOX, self.onAutoRunMigrate)
        #
        self.pi_option.Bind(wx.EVT_RADIOBOX, self.onTestPIAppOptionSelect)
        #
        self.disable_uiautomator_checkbox.Bind(wx.EVT_CHECKBOX, self.onDisableUIAutomator)
        self.pi_checker_button.Bind(wx.EVT_BUTTON, self.onPlayIntegrityCheck)
        #
        self.rb_latest.Bind(wx.EVT_RADIOBUTTON, self.onBetaRadioSelect)
        self.rb_custom.Bind(wx.EVT_RADIOBUTTON, self.onBetaRadioSelect)
        self.custom_version.Bind(wx.EVT_TEXT, self.onBetaVersionChange)
        self.beta_pif_button.Bind(wx.EVT_BUTTON, self.onGetPixelBetaPif)
        self.canary_pif_button.Bind(wx.EVT_BUTTON, self.onGetCanaryPif)
        self.freeman_pif_button.Bind(wx.EVT_BUTTON, self.onGetFreemanPif)
        #
        self.smart_paste_up.Bind(wx.EVT_BUTTON, self.onSmartPasteUp)
        self.reprocess.Bind(wx.EVT_BUTTON, self.onReProcess)
        self.paste_up.Bind(wx.EVT_BUTTON, self.onPasteUp)
        self.paste_down.Bind(wx.EVT_BUTTON, self.onPasteDown)
        self.reprocess_json_file.Bind(wx.EVT_BUTTON, self.onReProcessJsonFiles)
        self.j2e.Bind(wx.EVT_BUTTON, self.onJ2E)
        self.e2j.Bind(wx.EVT_BUTTON, self.onE2J)
        self.get_fp_code.Bind(wx.EVT_BUTTON, self.onGetFrameworkPatcherCode)
        #
        self.add_missing_keys_checkbox.Bind(wx.EVT_CHECKBOX, self.onAddMissingKeysFromDevice)
        self.force_first_api_checkbox.Bind(wx.EVT_CHECKBOX, self.onForceFirstAPI)
        self.api_value_input.Bind(wx.EVT_TEXT, self.onApiValueChange)
        self.sort_keys_checkbox.Bind(wx.EVT_CHECKBOX, self.onSortKeys)
        self.keep_unknown_checkbox.Bind(wx.EVT_CHECKBOX, self.onKeepAllKeys)
        #
        self.spoofBuild_checkbox.Bind(wx.EVT_CHECKBOX, self.onSpoofBuild)
        self.spoofProps_checkbox.Bind(wx.EVT_CHECKBOX, self.onSpoofProps)
        self.spoofProvider_checkbox.Bind(wx.EVT_CHECKBOX, self.onSpoofProvider)
        self.spoofSignature_checkbox.Bind(wx.EVT_CHECKBOX, self.onSpoofSignature)
        self.spoofVendingSdk_checkbox.Bind(wx.EVT_CHECKBOX, self.onSpoofVendingSdk)
        self.spoofVendingFinger_checkbox.Bind(wx.EVT_CHECKBOX, self.onSpoofVendingFinger)
        #
        self.tf_add_target_button.Bind(wx.EVT_BUTTON, self.onAddTFTarget)
        self.tf_delete_target_button.Bind(wx.EVT_BUTTON, self.onDeleteTFTarget)
        self.tf_edit_targets_button.Bind(wx.EVT_BUTTON, self.onEditTFTargets)
        self.tf_push_json_button.Bind(wx.EVT_BUTTON, self.onPushTFProp)
        #
        self.close_button.Bind(wx.EVT_BUTTON, self.onClose)
        self.Bind(wx.EVT_CLOSE, self.onClose)
        self.Bind(wx.EVT_SIZE, self.onResize)
        self.Bind(wx.EVT_SHOW, self.onShow)

        # init button states
        self.init()

        # Autosize the dialog
        self.active_pif_stc.PostSizeEventToParent()
        self.SetSizerAndFit(vSizer)

        print("\nOpening Pif Manager ...")

    # -----------------------------------------------
    #              setup_syntax_highlighting
    # -----------------------------------------------
    def setup_syntax_highlighting(self, stc_ctrl, format_type=None):
        if format_type is None:
            format_type = getattr(self, 'pif_format', 'json')

        # Set font for all styles
        font = wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        bold_font = wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)
        italic_font = wx.Font(9, wx.FONTFAMILY_TELETYPE, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_NORMAL)

        if format_type == 'prop':
            # Properties format (key=value with comments)
            stc_ctrl.SetLexer(stc.STC_LEX_PROPERTIES)

            # Set up properties syntax highlighting with proper fonts
            stc_ctrl.StyleSetSpec(stc.STC_PROPS_DEFAULT, "fore:#7F007F")  # Default/values (purple)
            stc_ctrl.StyleSetFont(stc.STC_PROPS_DEFAULT, font)

            # stc_ctrl.StyleSetSpec(stc.STC_PROPS_COMMENT, "fore:#008000")  # Comments (green)
            stc_ctrl.StyleSetSpec(stc.STC_PROPS_COMMENT, "fore:#808080")  # Comments (gray)
            stc_ctrl.StyleSetFont(stc.STC_PROPS_COMMENT, italic_font)

            stc_ctrl.StyleSetSpec(stc.STC_PROPS_SECTION, "fore:#0000FF")  # Section headers
            stc_ctrl.StyleSetFont(stc.STC_PROPS_SECTION, bold_font)

            stc_ctrl.StyleSetSpec(stc.STC_PROPS_ASSIGNMENT, "fore:#FF0000")  # = sign (red, bold)
            stc_ctrl.StyleSetFont(stc.STC_PROPS_ASSIGNMENT, bold_font)

            stc_ctrl.StyleSetSpec(stc.STC_PROPS_DEFVAL, "fore:#7F007F")  # Values (purple)
            stc_ctrl.StyleSetFont(stc.STC_PROPS_DEFVAL, font)

            # stc_ctrl.StyleSetSpec(stc.STC_PROPS_KEY, "fore:#000080")  # Keys (dark blue, bold)
            # stc_ctrl.StyleSetFont(stc.STC_PROPS_KEY, bold_font)
            stc_ctrl.StyleSetSpec(stc.STC_PROPS_KEY, "fore:#007F00")  # Keys (green)
            stc_ctrl.StyleSetFont(stc.STC_PROPS_KEY, font)

        else:
            # JSON format
            stc_ctrl.SetLexer(stc.STC_LEX_JSON)
            stc_ctrl.StyleSetSpec(stc.STC_JSON_DEFAULT, "fore:#000000")
            stc_ctrl.StyleSetSpec(stc.STC_JSON_NUMBER, "fore:#007F7F")
            stc_ctrl.StyleSetSpec(stc.STC_JSON_STRING, "fore:#7F007F")
            stc_ctrl.StyleSetSpec(stc.STC_JSON_PROPERTYNAME, "fore:#007F00")
            stc_ctrl.StyleSetSpec(stc.STC_JSON_ESCAPESEQUENCE, "fore:#7F7F00")
            stc_ctrl.StyleSetSpec(stc.STC_JSON_KEYWORD, "fore:#00007F,bold")
            stc_ctrl.StyleSetSpec(stc.STC_JSON_OPERATOR, "fore:#7F0000")

    # -----------------------------------------------
    #              update_syntax_highlighting
    # -----------------------------------------------
    def update_syntax_highlighting(self):
        if hasattr(self, 'active_pif_stc') and hasattr(self, 'pif_format'):
            self.setup_syntax_highlighting(self.active_pif_stc, self.pif_format)
            # Force refresh of highlighting
            self.active_pif_stc.Refresh()

        # Also update console syntax highlighting to match
        if hasattr(self, 'console_stc') and hasattr(self, 'pif_format'):
            self.setup_syntax_highlighting(self.console_stc, self.pif_format)
            self.console_stc.Refresh()

    # -----------------------------------------------
    #              Function onShow
    # -----------------------------------------------
    def onShow(self, event):
        if self.IsShown():
            if self.config:
                size = (self.config.pif_width, self.config.pif_height)
            else:
                size=(PIF_WIDTH, PIF_HEIGHT)
            self.SetSize(size)
        event.Skip()

    # -----------------------------------------------
    #              Function init
    # -----------------------------------------------
    def init(self, refresh=False):
        if self.config.pif:
            with contextlib.suppress(KeyError):
                self.add_missing_keys_checkbox.SetValue(self.config.pif['auto_fill'])
            with contextlib.suppress(KeyError):
                self.force_first_api_checkbox.SetValue(self.config.pif['force_first_api'])
            with contextlib.suppress(KeyError):
                self.first_api_value = self.config.pif['first_api_value_when_forced']
                self.force_first_api_checkbox.SetToolTip(f"Forces First API value(s) to {self.first_api_value}")
                self.api_value_input.SetValue(str(self.first_api_value))
            with contextlib.suppress(KeyError):
                self.sort_keys_checkbox.SetValue(self.config.pif['sort_keys'])
            with contextlib.suppress(KeyError):
                self.keep_unknown_checkbox.SetValue(self.config.pif['keep_unknown'])
            with contextlib.suppress(KeyError):
                self.spoofBuild_checkbox.SetValue(self.config.pif['spoofBuild'])
            with contextlib.suppress(KeyError):
                self.spoofProps_checkbox.SetValue(self.config.pif['spoofProps'])
            with contextlib.suppress(KeyError):
                self.spoofProvider_checkbox.SetValue(self.config.pif['spoofProvider'])
            with contextlib.suppress(KeyError):
                self.spoofSignature_checkbox.SetValue(self.config.pif['spoofSignature'])
            with contextlib.suppress(KeyError):
                self.spoofVendingSdk_checkbox.SetValue(self.config.pif['spoofVendingSdk'])
            with contextlib.suppress(KeyError):
                self.spoofVendingFinger_checkbox.SetValue(self.config.pif['spoofVendingFinger'])
            with contextlib.suppress(KeyError):
                self.auto_update_pif_checkbox.SetValue(self.config.pif['auto_update_pif_json'])
            with contextlib.suppress(KeyError):
                self.auto_check_pi_checkbox.SetValue(self.config.pif['auto_check_play_integrity'])
            with contextlib.suppress(KeyError):
                self.auto_run_migrate_checkbox.SetValue(self.config.pif['auto_run_migrate'])
            with contextlib.suppress(KeyError):
                selected_index = self.config.pif['test_app_index']
                if selected_index >= len(self.pi_choices):
                    selected_index = 0
                self.pi_option.SetSelection(selected_index)
                self.pi_selection(self.pi_choices[selected_index])
            with contextlib.suppress(KeyError):
                self.disable_uiautomator_checkbox.SetValue(self.config.pif['disable_uiautomator'])
        if self.config.enable_bulk_prop:
            self.process_bulk_prop_button.Show()

        self.keep_unknown = self.keep_unknown_checkbox.IsChecked()
        self.sort_keys = self.sort_keys_checkbox.IsChecked()

        if self.force_first_api_checkbox.IsChecked():
            self.first_api = self.first_api_value
        else:
            self.first_api = None

        device = get_phone(True)
        if not device:
            self.console_stc.SetText(_("No Device is selected.\nPif Manager features are set to limited mode."))
            return
        if not device.rooted:
            self.console_stc.SetText(_("Device is not rooted or SU permissions to adb shell is not granted.\nPif Manager features are set to limited mode."))
            return
        modules = device.get_magisk_detailed_modules(refresh)

        self.create_pif_button.Enable(False)
        self.push_pif_button.Enable(False)
        self.reload_pif_button.Enable(False)
        self.push_kb_button.Enable(False)
        self.cleanup_dg_button.Enable(False)
        self.push_kb_button.Show(False)
        self.edit_ts_target_button.Enable(False)
        self.edit_ts_target_button.Show(False)
        self.edit_security_patch_button.Enable(False)
        self.edit_security_patch_button.Show(False)
        self.auto_update_pif_checkbox.Enable(False)
        self.auto_check_pi_checkbox.Enable(False)
        self.auto_run_migrate_checkbox.Enable(False)
        self.pi_checker_button.Enable(False)
        self.tf_targets_combo.Enable(False)
        self.tf_targets_combo.Clear()
        self.tf_targets_combo.Append(_("TF Targets"))
        self.tf_targets_combo.SetSelection(0)
        self.tf_targets_combo.SetForegroundColour(wx.Colour(128, 128, 128))
        # self.tf_targets_combo.Show(False)
        self.enable_buttons = False
        self.pif_selection_combo.Clear()
        self.pif_modules = []

        if modules:
            found_pif_module = False
            for module in modules:
                if module.state == 'enabled' and ((module.id == "playintegrityfix" and "Play Integrity" in module.name) or module.id == "tricky_store" or module.id == "targetedfix"):
                    self.pif_format = None
                    self.pif_path = None
                    # playintegrityfix
                    if module.id == "playintegrityfix":
                        self.pif_format = 'json'
                        if "Play Integrity Fork" in module.name:
                            self.pif_path = '/data/adb/modules/playintegrityfix/custom.pif.json'
                            if int(module.versionCode) > 4000:
                                print("Advanced props support enabled.")
                                res, unused = device.check_file('/data/adb/modules/playintegrityfix/example.pif.prop', True)
                                if res == 1:
                                    res, unused = device.check_file('/data/adb/modules/playintegrityfix/custom.pif.prop', True)
                                    if res == 1:
                                        self.pif_format = 'prop'
                                        self.pif_path = '/data/adb/modules/playintegrityfix/custom.pif.prop'
                                        print("ℹ️ custom.pif.prop detected, switching to prop format.")
                                    elif res == 0:
                                        res, unused = device.check_file('/data/adb/modules/playintegrityfix/custom.pif.json', True)
                                        if res == 1:
                                            self.pif_format = 'json'
                                            self.pif_path = '/data/adb/modules/playintegrityfix/custom.pif.json'
                                            print("ℹ️ custom.pif.json detected, switching to json format.")
                                        else:
                                            self.pif_format = 'prop'
                                            self.pif_path = '/data/adb/modules/playintegrityfix/custom.pif.prop'
                                            print("⚠️ custom.pif.prop and custom.pif.json not found, defaulting to prop format.")
                        else:
                            if module.version in ["PROPS-v2.1", "PROPS-v2.0"]:
                                self.pif_path = '/data/adb/modules/playintegrityfix/pif.json'
                            else:
                                self.pif_path = '/data/adb/pif.json'
                        self.auto_check_pi_checkbox.Enable(True)
                        self.auto_run_migrate_checkbox.Enable(True)

                    # tricky_store
                    elif module.id == "tricky_store":
                        self.pif_format = 'prop'
                        self.pif_path = '/data/adb/tricky_store/spoof_build_vars'
                        self.push_kb_button.Enable(True)
                        self.push_kb_button.Show(True)
                        self.edit_ts_target_button.Enable(True)
                        self.edit_ts_target_button.Show(True)
                        self.edit_security_patch_button.Enable(True)
                        self.edit_security_patch_button.Show(True)
                        self.auto_run_migrate_checkbox.Enable(False)

                    # targetedfix
                    elif module.id == "targetedfix":
                        self.pif_format = 'json'
                        self.tf_target_path = f"{TARGETEDFIX_CONFIG_PATH}/target.txt"
                        self.tf_targets_combo.Enable(True)
                        self.auto_run_migrate_checkbox.Enable(False)
                        self.create_pif_button.Enable(False)
                        self.push_pif_button.Enable(False)
                        self.reload_pif_button.Enable(False)
                        self.auto_update_pif_checkbox.Enable(False)
                        self.enable_buttons = False
                        if int(module.versionCode) >= 300:
                            print("ℹ️ Detected newer TargetedFix, switching to prop format.")
                            self.pif_format = 'prop'
                            self.tf_push_json_button.SetLabelText(_("Push TF Prop"))

                    flavor = module.name.replace(" ", "").lower()
                    self.pif_flavor = f"{flavor}_{module.versionCode}"
                    self.pif_modules.append(PifModule(id=module.id, name=module.name, version=module.version, version_code=module.versionCode, format=self.pif_format, path=self.pif_path, flavor=self.pif_flavor))
                    found_pif_module = True
                    self.create_pif_button.Enable(True)
                    self.push_pif_button.Enable(True)
                    self.reload_pif_button.Enable(True)
                    self.cleanup_dg_button.Enable(True)
                    self.auto_update_pif_checkbox.Enable(True)
                    self.pi_checker_button.Enable(True)
                    self.enable_buttons = True
                    module_label = f"{module.name} {module.version} {module.versionCode}"
                    if module.id != "tricky_store":
                        self.pif_selection_combo.Append(module_label)

        if found_pif_module:
            # Update combo box size based on content
            self.update_combo_size(self.pif_selection_combo)

            # Make the selection in priority order: Play Integrity, Trickystore, TargetedFix
            for i in range(self.pif_selection_combo.GetCount()):
                if "Play Integrity" in self.pif_selection_combo.GetString(i):
                    self.pif_selection_combo.SetSelection(i)
                    break
                elif "Tricky" in self.pif_selection_combo.GetString(i):
                    self.pif_selection_combo.SetSelection(i)
                elif "TargetedFix" in self.pif_selection_combo.GetString(i):
                    self.pif_selection_combo.SetSelection(i)
            # If nothing is selected and there are items, select the first item
            if self.pif_selection_combo.GetSelection() == wx.NOT_FOUND and self.pif_selection_combo.GetCount() > 0:
                self.pif_selection_combo.SetSelection(0)

            # Manually trigger the combo box change event
            self.onPifSelectionComboBox(None)

    # -----------------------------------------------
    #                  check_pif_json
    # -----------------------------------------------
    def check_pif_json(self):
        device = get_phone(True)
        if not device.rooted:
            return
        # check for presence of pif.json
        if self.pif_path is None:
            self.pif_exists = False
            self.create_pif_button.Enable(False)
            self.push_pif_button.Enable(False)
            self.reload_pif_button.Enable(False)
            self.cleanup_dg_button.Enable(False)
            self.create_pif_button.SetLabel(_("Create print"))
            self.create_pif_button.SetToolTip(_("Create pif.json / spoof_build_vars."))
            return
        res, unused = device.check_file(self.pif_path, True)
        if res == 1:
            self.pif_exists = True
            self.reload_pif_button.Enable(True)
            self.cleanup_dg_button.Enable(True)
            self.create_pif_button.SetLabel(_("Update print"))
            self.create_pif_button.SetToolTip(_("Update pif.json / spoof_build_vars."))
        else:
            self.pif_exists = False
            self.create_pif_button.SetLabel(_("Create print"))
            self.create_pif_button.SetToolTip(_("Create pif.json / spoof_build_vars."))

    # -----------------------------------------------
    #                  onFavoritesComboBox
    # -----------------------------------------------
    def onFavoritesComboBox(self, event):
        selected_index = event.GetSelection()
        pif_list = list(self.favorite_pifs.values())

        if 0 <= selected_index < len(pif_list):
            selected_pif = pif_list[selected_index]
            pif_object = selected_pif["pif"]
            if self.pif_format == 'prop':
                json_string = json.dumps(pif_object, indent=4, sort_keys=self.sort_keys)
                self.active_pif_stc.SetText(self.J2P(json_string))
            else:
                self.active_pif_stc.SetText(json.dumps(pif_object, indent=4))
        else:
            print("Selected Pif not found, Index out of range")

    # -----------------------------------------------
    #                  onPifSelectionComboBox
    # -----------------------------------------------
    def onPifSelectionComboBox(self, event):
        selection_index = self.pif_selection_combo.GetSelection()
        if selection_index != wx.NOT_FOUND and self.pif_modules and selection_index < len(self.pif_modules):
            selected_module = self.pif_modules[selection_index]
            self.current_pif_module = selected_module
            self.pif_format = selected_module.format
            self.pif_path = selected_module.path
            self.pif_flavor = selected_module.flavor

        if selected_module.id == "tricky_store":
            self.spoofBuild_checkbox.Enable(False)
            self.spoofProps_checkbox.Enable(False)
            self.spoofProvider_checkbox.Enable(False)
            self.spoofSignature_checkbox.Enable(False)
            self.spoofVendingSdk_checkbox.Enable(False)
            self.spoofVendingFinger_checkbox.Enable(False)
            self.auto_run_migrate_checkbox.Enable(False)
        else:
            self.spoofBuild_checkbox.Enable(True)
            self.spoofProps_checkbox.Enable(True)
            self.spoofProvider_checkbox.Enable(True)
            self.spoofSignature_checkbox.Enable(True)
            self.spoofVendingSdk_checkbox.Enable(True)
            self.spoofVendingFinger_checkbox.Enable(True)
            if selected_module.id == "targetedfix":
                # Show TargetedFix buttons
                self.tf_add_target_button.Show(True)
                self.tf_delete_target_button.Show(True)
                self.tf_edit_targets_button.Show(True)
                self.tf_push_json_button.Show(True)
                self.auto_run_migrate_checkbox.Enable(False)
                self.tf_targets_combo.Enable(True)
            else:
                # Play Integrity Fix selected
                self.auto_run_migrate_checkbox.Enable(True)
                # Hide TargetedFix buttons
                self.tf_add_target_button.Show(False)
                self.tf_delete_target_button.Show(False)
                self.tf_edit_targets_button.Show(False)
                self.tf_push_json_button.Show(False)
                self.tf_targets_combo.Enable(False)
                self.tf_targets_combo.Clear()
                self.tf_targets_combo.Append(_("TF Targets"))
                self.tf_targets_combo.SetSelection(0)
                self.tf_targets_combo.SetForegroundColour(wx.Colour(128, 128, 128))

        self.Layout()

        self.update_syntax_highlighting()

        selected_label = f"{selected_module.name} {selected_module.version}"
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} Loading selected Module: {selected_label}")
        print("==============================================================================")
        if selected_module.id == "targetedfix":
            # For TargetedFix, check if we have targets loaded, if not load them
            if self.tf_targets_combo.GetCount() <= 1 and self.tf_targets_combo.GetString(0) == _("TF Targets"):
                # No targets loaded yet, load them now and only once
                targets = self.load_tf_targets()

            # Select the first target
            if self.tf_targets_combo.GetCount() > 0:
                first_item = self.tf_targets_combo.GetString(0)
                if first_item != _("TF Targets"):
                    self.tf_targets_combo.SetSelection(0)  # Select first actual target
                    self.onTFTargetSelectionComboBox(None)
                else:
                    if self.pif_format == 'json':
                        self.active_pif_stc.SetValue("{}")
                    else:
                        self.active_pif_stc.SetValue("")
                    self.console_stc.SetText("No Target selected")
            else:
                if self.pif_format == 'json':
                    self.active_pif_stc.SetValue("{}")
                else:
                    self.active_pif_stc.SetValue("")
                self.console_stc.SetText("No Target selected")
        else:
            self.LoadPif(self.pif_path)


    # -----------------------------------------------
    #                  load_tf_targets
    # -----------------------------------------------
    def load_tf_targets(self):
        try:
            device = get_phone(True)
            if not device.rooted:
                self.populate_tf_targets([])
                return []

            config_path = get_config_path()
            local_target_file = os.path.join(config_path, 'tmp', 'tf_target.txt')

            if not self._tf_targets_loaded:
                res, unused = device.check_file(self.tf_target_path, True)
                if res == 1:
                    self.tf_target_exists = True

                    # Pull the target.txt file to local as tf_target.txt
                    res = device.pull_file(self.tf_target_path, local_target_file, True, quiet=True)
                    if res != 0:
                        # File doesn't exist, create empty local file
                        with open(local_target_file, 'w', encoding='utf-8') as f:
                            f.write('')
                        targets = []
                    else:
                        self._tf_targets_loaded = True
                else:
                    self.tf_target_exists = False
                    # Create empty local file
                    with open(local_target_file, 'w', encoding='utf-8') as f:
                        f.write('')
                    self.populate_tf_targets([])
                    return []

            # check for presence of tf targets file
            if self.tf_target_path is None:
                self.tf_target_exists = False
                self.populate_tf_targets([])
                return []

            else:
                # Read targets from local file
                with open(local_target_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                targets = [target.strip() for target in content.strip().splitlines() if target.strip()]

                # Only pull files that don't exist locally
                for target in targets:
                    # if target is not a commented line, skip
                    if target.startswith('#'):
                        continue
                    local_tf_target_file = os.path.join(config_path, 'tmp', f'{target}.{self.pif_format}')
                    if not os.path.exists(local_tf_target_file) or not self._tf_targets_loaded:
                        remote_tf_target_file = f"{TARGETEDFIX_CONFIG_PATH}/{target}.{self.pif_format}"
                        res = device.pull_file(remote_tf_target_file, local_tf_target_file, True, quiet=True)
                        # If pull fails, create empty JSON file
                        if res != 0:
                            with open(local_tf_target_file, 'w', encoding='utf-8') as f:
                                if self.pif_format == 'json':
                                    f.write('{}')
                                else:
                                    f.write('')

                self.populate_tf_targets(targets)
                return targets

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: loading TargetedFix targets")
            traceback.print_exc()
            self.populate_tf_targets([])
            return []

    # -----------------------------------------------
    #                  populate_tf_targets
    # -----------------------------------------------
    def populate_tf_targets(self, targets):
        try:
            self.tf_targets_combo.Clear()

            if targets and len(targets) > 0:
                # Add all targets to the combo box
                for target in targets:
                    # if target is a commented line, skip
                    if target.startswith('#'):
                        continue
                    self.tf_targets_combo.Append(target)

                # Select the first target
                self.tf_targets_combo.SetSelection(0)

                # Set normal text color (black)
                self.tf_targets_combo.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))

                # Update combo box size based on content
                self.update_combo_size(self.tf_targets_combo)

                # Update button states based on selection
                self.update_tf_button_states()

                print(f"Populated TF targets combo with {len(targets)} targets")
            else:
                # No targets found, add placeholder
                self.tf_targets_combo.Append(_("TF Targets"))
                self.tf_targets_combo.SetSelection(0)
                self.tf_targets_combo.Enabled = False

                # Set gray placeholder text color
                self.tf_targets_combo.SetForegroundColour(wx.Colour(128, 128, 128))

                # Update button states
                self.update_tf_button_states()

                print("No TF targets found, showing placeholder")

            # Force layout refresh
            self.Layout()

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: populating TF targets")
            traceback.print_exc()
            # On error, show placeholder
            self.tf_targets_combo.Clear()
            self.tf_targets_combo.Append(_("TF Targets"))
            self.tf_targets_combo.SetSelection(0)
            self.tf_targets_combo.SetForegroundColour(wx.Colour(128, 128, 128))

    # -----------------------------------------------
    #                  onTFTargetSelectionComboBox
    # -----------------------------------------------
    def onTFTargetSelectionComboBox(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User made a TargetedFix target selection.")
        print("==============================================================================")
        selection_index = self.tf_targets_combo.GetSelection()
        selected_text = self.tf_targets_combo.GetStringSelection()

        # Handle placeholder text selection
        if selected_text == _("TF Targets"):
            # Keep the gray color for placeholder
            self.update_tf_button_states()
            return

        # Handle actual target selection
        self.tf_targets_combo.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))
        print(f"Selected target: {selected_text}")
        self.update_tf_button_states()

        if selected_text:
            # Load from local file instead of device
            config_path = get_config_path()
            local_tf_target_file = os.path.join(config_path, 'tmp', f'{selected_text}.{self.pif_format}')

            if os.path.exists(local_tf_target_file):
                try:
                    with open(local_tf_target_file, 'r', encoding='utf-8') as f:
                        contents = f.read()
                    self.device_pif = contents
                    self.active_pif_stc.SetValue(contents)
                except Exception as e:
                    print(f"Error reading local {self.pif_format} file: {e}")
                    if self.pif_format == 'prop':
                        self.active_pif_stc.SetValue("")
                    else:
                        self.active_pif_stc.SetValue("{}")
            else:
                # Create empty {self.pif_format} if file doesn't exist
                with open(local_tf_target_file, 'w', encoding='utf-8') as f:
                    if self.pif_format == 'json':
                        f.write('{}')
                    else:
                        f.write('')
                if self.pif_format == 'prop':
                    self.active_pif_stc.SetValue("")
                else:
                    self.active_pif_stc.SetValue("{}")

    # -----------------------------------------------
    #                  onTestPIAppOptionSelect
    # -----------------------------------------------
    def onTestPIAppOptionSelect(self, event):
        option = event.GetString()
        self.pi_selection(option)

    # -----------------------------------------------
    #                  pi_selection
    # -----------------------------------------------
    def pi_selection(self, selected_option):
        if selected_option == "Play Integrity API Checker":
            print("Play Integrity API Checker option selected")
            self.pi_app = 'gr.nikolasspyr.integritycheck'
            # self.launch_method = 'launch-am'
            self.launch_method = 'launch'

        elif selected_option == "Simple Play Integrity Checker":
            print("Simple Play Integrity Checker option selected")
            self.pi_app = 'com.henrikherzig.playintegritychecker'
            # self.launch_method = 'launch-am'
            self.launch_method = 'launch'

        elif selected_option == "TB Checker":
            print("TB Checker option selected")
            self.pi_app = 'krypton.tbsafetychecker'
            # self.launch_method = 'launch-am-main'
            self.launch_method = 'launch'

        elif selected_option == "Android Integrity Checker":
            print("Android Integrity Checker option selected")
            self.pi_app = 'com.thend.integritychecker'
            # self.launch_method = 'launch-am-main'
            self.launch_method = 'launch'

        elif selected_option == "Play Store":
            print("Play Store option selected")
            self.pi_app = 'com.android.vending'
            self.launch_method = 'launch'

        elif selected_option == "YASNAC":
            print("YASNAC option selected")
            self.pi_app = 'rikka.safetynetchecker'
            # self.launch_method = 'launch-am-main'
            self.launch_method = 'launch'

        print(f"Auto Update print is set to: {selected_option}")
        self.config.pif['test_app_index'] = self.pi_option.Selection

    # -----------------------------------------------
    #                  __del__
    # -----------------------------------------------
    def __del__(self):
        pass

    # -----------------------------------------------
    #                  onClose
    # -----------------------------------------------
    def onClose(self, e):
        try:
            # Abort any active download/processing
            if self.download_state is not None:
                self.download_state.stop_event.set()
                self.download_state = None

            # Stop the spinner to prevent errors in finally blocks
            try:
                self._on_spin('stop')
            except:
                pass  # Ignore if already destroyed or other errors

            # Clean up the validation timer
            if self._validation_timer is not None:
                self._validation_timer.Stop()

            dialog_size = self.GetSize()
            dialog_x, dialog_y = dialog_size.GetWidth(), dialog_size.GetHeight()
            config = get_config()
            config.pif_width = dialog_x
            config.pif_height = dialog_y
            config.pif = self.config.pif
            set_config(config)
        except Exception:
            traceback.print_exc()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to properly close the window.")
        finally:
            self.Destroy()

    # -----------------------------------------------
    #                  onReloadPrint
    # -----------------------------------------------
    def onReloadPrint(self, e):
        if self.pif_path:
            self.LoadPif(self.pif_path)

    # -----------------------------------------------
    #                  LoadPif
    # -----------------------------------------------
    def LoadPif(self, file_path):
        try:
            device = get_phone(True)
            if not device.rooted:
                return
            self._on_spin('start')
            config_path = get_config_path()
            self.check_pif_json()
            pif_prop = os.path.join(config_path, 'tmp', 'pif.json')
            if self.reload_pif_button.Enabled or "targetedfix" in file_path:
                # pull the file
                res = device.pull_file(remote_file=file_path, local_file=pif_prop, with_su=True, quiet=True)
                if res != 0:
                    print(f"File: {file_path} not found.")
                    self.active_pif_stc.SetValue("")
                    # puml("#red:Failed to pull pif.prop from the phone;\n}\n")
                    self._on_spin('stop')
                    return
            else:
                # we need to create one.
                with open(pif_prop, 'w', encoding='utf-8') as file:
                    pass
            # get the contents of modified pif.json
            encoding = detect_encoding(pif_prop)
            with open(pif_prop, 'r', encoding=encoding, errors="replace") as f:
                contents = f.read()
                self.device_pif = contents
            self.active_pif_stc.SetValue(contents)

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Load {file_path} process.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onUpdatePrint
    # -----------------------------------------------
    def onUpdatePrint(self, e):
        self.create_update_pif(just_push=False)

    # -----------------------------------------------
    #                  onPushPrint
    # -----------------------------------------------
    def onPushPrint(self, e):
        self.create_update_pif(just_push=True)

    # -----------------------------------------------
    #                  onAddTFTarget
    # -----------------------------------------------
    def onAddTFTarget(self, e):
        try:
            print("\n==============================================================================")
            print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Add Target process")
            print("==============================================================================")
            device = get_phone(True)
            if not device or not device.rooted:
                print("Error: Device not available or not rooted")
                return

            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Add TF Target")

            # Create a simplified package manager dialog
            self._on_spin('start')
            # load labels if not already loaded
            if not get_labels() and os.path.exists(get_labels_file_path()):
                with open(get_labels_file_path(), "r", encoding='ISO-8859-1', errors="replace") as f:
                    set_labels(json.load(f))
            dlg = PackageManager(self, title="Select Package for TargetedFix Target", simplified_mode=True)
            self._on_spin('stop')
            result = dlg.ShowModal()

            if result == wx.ID_OK:
                selected_package = dlg.GetSelectedPackage()
                if selected_package:
                    print(f"Selected package: {selected_package}")

                    # Validate target name (package names are already valid)
                    target_name = selected_package

                    # Check if target already exists in local file
                    config_path = get_config_path()
                    local_target_file = os.path.join(config_path, 'tmp', 'tf_target.txt')
                    existing_targets = []
                    if os.path.exists(local_target_file):
                        with open(local_target_file, 'r', encoding='utf-8') as f:
                            existing_targets = [line.strip() for line in f.readlines() if line.strip()]

                    if target_name in existing_targets:
                        wx.MessageBox(f"Target '{target_name}' already exists in the list.", "Target Exists", wx.OK | wx.ICON_WARNING)
                        dlg.Destroy()
                        return

                    # Add to target list file locally and push to device
                    if self.add_target_to_device(target_name):
                        # Just update the combo box locally instead of reloading everything
                        self.tf_targets_combo.Append(target_name)
                        target_index = self.tf_targets_combo.FindString(target_name)
                        if target_index != wx.NOT_FOUND:
                            self.tf_targets_combo.SetSelection(target_index)
                            self.tf_targets_combo.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))
                            self.onTFTargetSelectionComboBox(None)

                        # Update combo box size and button states
                        self.update_combo_size(self.tf_targets_combo)
                        self.update_tf_button_states()

                        print(f"Successfully added target: {target_name}")
                        self.console_stc.SetText(f"Added target: {target_name}")
                    else:
                        wx.MessageBox(f"Failed to add target '{target_name}' to device.", "Error", wx.OK | wx.ICON_ERROR)

            dlg.Destroy()

        except Exception as ex:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during TF add target process.")
            traceback.print_exc()

    # -----------------------------------------------
    #                  add_target_to_device
    # -----------------------------------------------
    def add_target_to_device(self, target_name):
        try:
            config_path = get_config_path()
            local_target_file = os.path.join(config_path, 'tmp', 'tf_target.txt')

            # Read existing targets from local file
            if os.path.exists(local_target_file):
                with open(local_target_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                targets = [target.strip() for target in content.strip().splitlines() if target.strip()]
            else:
                targets = []

            # Add new target if not already present
            if target_name not in targets:
                targets.append(target_name)

                # Write back to local file
                with open(local_target_file, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(targets) + '\n')

                # Create empty local {self.pif_format} file for the target
                local_tf_target_file = os.path.join(config_path, 'tmp', f'{target_name}.{self.pif_format}')
                with open(local_tf_target_file, 'w', encoding='utf-8') as f:
                    if self.pif_format == 'prop':
                        f.write('')
                    else:
                        f.write('{}')

                device = get_phone(True)
                if device and device.rooted:
                    # Push target.txt (using original name on device)
                    res = device.push_file(local_target_file, self.tf_target_path, True)
                    if res != 0:
                        print(f"Failed to push target.txt to device")
                        return False
                    return True
            return True

        except Exception as ex:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: adding target locally: {ex}")
            traceback.print_exc()
            return False

    # -----------------------------------------------
    #                  onDeleteTFTarget
    # -----------------------------------------------
    def onDeleteTFTarget(self, e):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Delete Target process")
        print("==============================================================================")
        # if no target selected, do nothing
        selected_index = self.tf_targets_combo.GetSelection()
        selected_text = self.tf_targets_combo.GetStringSelection()
        if selected_text == _("TF Targets") or selected_index == wx.NOT_FOUND:
            return
        # confirm deletion
        dlg = wx.MessageDialog(self, f"Are you sure you want to delete the target '{selected_text}'?\nThis will remove the target and its associated {self.pif_format} file from the device.", "Confirm Deletion", wx.YES_NO | wx.NO_DEFAULT | wx.ICON_WARNING)
        if dlg.ShowModal() == wx.ID_YES:
            try:
                config_path = get_config_path()
                local_target_file = os.path.join(config_path, 'tmp', 'tf_target.txt')
                local_tf_target_file = os.path.join(config_path, 'tmp', f'{selected_text}.{self.pif_format}')

                print(f"Deleting target: {selected_text}")

                # Remove from local target.txt file
                if os.path.exists(local_target_file):
                    with open(local_target_file, 'r', encoding='utf-8') as f:
                        targets = [line.strip() for line in f.readlines() if line.strip()]

                    # Remove the selected target
                    targets = [target for target in targets if target != selected_text]

                    # Write back to local file
                    with open(local_target_file, 'w', encoding='utf-8') as f:
                        f.write('\n'.join(targets) + '\n' if targets else '')

                # Remove local {self.pif_format} file
                if os.path.exists(local_tf_target_file):
                    os.remove(local_tf_target_file)

                # Push updated files to device
                device = get_phone(True)
                if device and device.rooted:
                    # Push updated target.txt (using original name on device)
                    res = device.push_file(local_target_file, self.tf_target_path, True)
                    if res != 0:
                        print(f"Failed to update target list file: {self.tf_target_path}")
                        return

                    # Delete the {self.pif_format} file from device
                    remote_tf_target_file = f"{TARGETEDFIX_CONFIG_PATH}/{selected_text}.{self.pif_format}"
                    res = device.delete(remote_tf_target_file, with_su=True, dir=False)
                    if res != 0:
                        print(f"Failed to delete {self.pif_format} file: {remote_tf_target_file}")
                        return

                    print(f"Target '{selected_text}' and its {self.pif_format} file have been deleted.")
                    self.console_stc.SetText(f"Deleted target: {selected_text}")

                    # Refresh the targets combo box
                    targets = self.load_tf_targets()
                    if targets and len(targets) > 0:
                        self.tf_targets_combo.SetSelection(0)
                        self.onTFTargetSelectionComboBox(None)
                    else:
                        self.console_stc.AppendText("\nNo Target selected")
            except Exception as ex:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during TF target deletion process.")
                traceback.print_exc()

    # -----------------------------------------------
    #                  onPushTFProp
    # -----------------------------------------------
    def onPushTFProp(self, e):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated Push Target {self.pif_format} process")
        print("==============================================================================")
        # Get the selected target and update the local PROP / JSON file first
        selected_text = self.tf_targets_combo.GetStringSelection()
        if selected_text and selected_text != _("TF Targets"):
            config_path = get_config_path()
            local_tf_target_file = os.path.join(config_path, 'tmp', f'{selected_text}.{self.pif_format}')

            # Save current content to local file
            content = self.active_pif_stc.GetValue()
            with open(local_tf_target_file, 'w', encoding='utf-8') as f:
                f.write(content)

            # Now push the local file to device
            remote_filepath = f"{TARGETEDFIX_CONFIG_PATH}/{selected_text}.{self.pif_format}"
            print(f"Pushing {self.pif_format} for target '{selected_text}' to device...")
            self.create_update_pif(just_push=True, filepath=remote_filepath)

    # -----------------------------------------------
    #                  onCleanupDG
    # -----------------------------------------------
    def onCleanupDG(self, e):
        device = get_phone()
        if not device or not device.rooted:
            return
        print("Cleaning up DG Cache ...")
        device.delete("/data/data/com.google.android.gms/app_dg_cache", with_su = True, dir = True)
        device.delete("/data/data/com.google.android.gms/databases/dg.db*", with_su = True, dir = False)

    # -----------------------------------------------
    #                  UpdatePifJson
    # -----------------------------------------------
    def UpdatePifJson(self, e):
        self.create_update_pif()

    # -----------------------------------------------
    #                  create_update_pif
    # -----------------------------------------------
    def create_update_pif(self, just_push=False, filepath=None):
        try:
            device = get_phone(True)
            if not device.rooted:
                return

            self._on_spin('start')
            config_path = get_config_path()
            pif_prop = os.path.join(config_path, 'tmp', 'pif.json')
            json_data = None

            content = self.active_pif_stc.GetValue()
            if not just_push:
                if self.pif_format == 'prop':
                    json_data = self.P2J(content)
                else:
                    json_data = content
                if json_data:
                    try:
                        data = json.loads(json_data)
                    except Exception:
                        try:
                            data = json5.loads(json_data)
                        except Exception:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Not a valid json.")
                            self._on_spin('stop')
                            return
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Not a valid json.")
                    self._on_spin('stop')
                    return

            # Save the data as normal JSON
            with open(pif_prop, 'w', encoding="ISO-8859-1", errors="replace", newline='\n') as f:
                if just_push:
                    with open(pif_prop, 'w', encoding="ISO-8859-1", errors="replace", newline='\n') as f:
                        f.write(content)
                else:
                    if self.pif_format == 'prop':
                        f.write(self.J2P(json.dumps(data, indent=4, sort_keys=self.sort_keys)))
                    else:
                        json.dump(data, f, indent=4, sort_keys=self.sort_keys)

            # push the file
            if not filepath:
                filepath = self.pif_path
            res = device.push_file(pif_prop, filepath, True)
            if res != 0:
                print("Aborting ...\n")
                # puml("#red:Failed to push pif.json from the phone;\n}\n")
                self._on_spin('stop')
                return -1

            if just_push:
                self.device_pif = content
            else:
                self.device_pif = json.dumps(data, indent=4, sort_keys=self.sort_keys)

            print("Killing Google GMS  ...")
            res = device.perform_package_action(pkg='com.google.android.gms.unstable', action='killall')
            if res.returncode != 0:
                print("Error killing GMS.")
            else:
                print("Killing Google GMS succeeded.")

            print("Killing Android Vending  ...")
            res = device.perform_package_action(pkg='com.android.vending', action='killall')
            if res.returncode != 0:
                print("Error killing Android Vending.")
            else:
                print("Killing Android Vending succeeded.")

            if not just_push:
                self.check_pif_json()
            self.LoadPif(filepath)

            # Auto run migrate if enabled
            if self.auto_run_migrate_checkbox.IsEnabled() and self.auto_run_migrate_checkbox.IsChecked():
                print("Auto Running Migrate ...")
                self.runMigrate()

            # Auto test Play Integrity
            if self.auto_check_pi_checkbox.IsEnabled() and self.auto_check_pi_checkbox.IsChecked():
                print("Auto Testing Play Integrity ...")
                self.onPlayIntegrityCheck(None)
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during pip Create process.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  get_pi_app_coords
    # -----------------------------------------------
    def get_pi_app_coords(self, child=None):
        try:
            device = get_phone()
            if not device.rooted:
                return
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} Getting coordinates for {self.pi_app}")

            # pull view
            config_path = get_config_path()
            pi_app_xml = os.path.join(config_path, 'tmp', 'pi_app.xml')

            if self.pi_app == 'gr.nikolasspyr.integritycheck':
                return  device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "CHECK", False)

            elif self.pi_app == 'com.henrikherzig.playintegritychecker':
                return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "Make Play Integrity Request", False)

            elif self.pi_app == 'krypton.tbsafetychecker':
                return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "Run Play Integrity Check", False)

            elif self.pi_app == 'com.thend.integritychecker':
                return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "android.widget.Button", False)

            elif self.pi_app == 'rikka.safetynetchecker':
                return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "Run SafetyNet Attestation", False)

            elif self.pi_app == 'com.android.vending':
                if child == 'user':
                    # This needs custom handling, as there is no identifiable string to look for
                    return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "PixelFlasher_Playstore", True)
                if child == 'settings':
                    return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "Settings", True)
                if child == 'general':
                    return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "General", True)
                if child == 'scroll':
                    return device.swipe_up()
                if child == 'developer_options':
                    return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "Developer options", True)
                if child == 'test':
                    return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "Check integrity", False)
                if child == 'dismiss':
                    return device.ui_action('/data/local/tmp/pi.xml', pi_app_xml, "Dismiss", False)

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in get_pi_app_coords function")
            traceback.print_exc()

    # -----------------------------------------------
    #                  onGetCanaryPif
    # -----------------------------------------------
    def onGetCanaryPif(self, e):
        try:
            self._on_spin('start')
            device = get_phone()
            if device:
                device_model = device.hardware
            buttons_text = [_("Canary Device"), "Canary Emulator", "Beta Device", _("Cancel")]
            dlg = MessageBoxEx(
                parent=self,
                title=_('Canary Miner Selection'),
                message=_("Please make a selection"),
                button_texts=buttons_text,
                default_button=1,
                disable_buttons=None,
                is_md=False,
                size=(800, 600),
                checkbox_labels=None,
                checkbox_initial_values=None,
                disable_checkboxes=None,
                vertical_checkboxes=False,
                checkbox_labels2=None,
                checkbox_initial_values2=None,
                disable_checkboxes2=None,
                radio_labels=None,
                radio_initial_value=None,
                disable_radios=None,
                vertical_radios=False
            )
            dlg.CentreOnParent(wx.BOTH)
            result = dlg.ShowModal()
            dlg.Destroy()
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {buttons_text[result -1]}")
            miner_url = None
            if result == 1:
                miner_url = "https://github.com/Vagelis1608/get_the_canary_miner/tree/main/devices"
            elif result == 2:
                miner_url = "https://github.com/Vagelis1608/get_the_canary_miner/tree/main/emulator"
            elif result == 3:
                miner_url = "https://github.com/Vagelis1608/get_the_canary_miner/tree/main/betas"
            else:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Cancel.")
                print("Aborting ...\n")
                return -1

            canary_pif = get_canary_miner(device_model='_select_', default_selection=device_model if device else None, miner_url=miner_url)
            if self.pif_format == 'prop':
                self.console_stc.SetValue(self.J2P(canary_pif, quiet=True))
            else:
                self.console_stc.SetValue(self.P2J(canary_pif))
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onGetCanaryPif function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onGetFreemanPif
    # -----------------------------------------------
    def onGetFreemanPif(self, e):
        try:
            device = get_phone()
            if not device:
                abilist = ''
            else:
                if not device.rooted:
                    return
                self._on_spin('start')
                keys = ['ro.product.cpu.abilist', 'ro.product.cpu.abi', 'ro.system.product.cpu.abilist', 'ro.vendor.product.cpu.abilist']
                abilist = get_first_match(device.props.property, keys)

            freeman_pif = get_freeman_pif(abilist)
            if self.pif_format == 'prop':
                self.console_stc.SetValue(self.J2P(freeman_pif))
            else:
                self.console_stc.SetValue(freeman_pif)
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onGetFreemanPif function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onBetaRadioSelect
    # -----------------------------------------------
    def onBetaRadioSelect(self, event):
        is_custom = self.rb_custom.GetValue()
        self.custom_version.Enable(is_custom)

        if self.rb_latest.GetValue():
            self.beta_pif_version = 'latest'
        else:
            # When switching to custom, validate existing text
            try:
                value = self.custom_version.GetValue()
                if value.isdigit() or value.lower() == 'c' or value.startswith('CANARY') or value.lower() == 't':
                    self.beta_pif_version = str(value)
                else:
                    self.beta_pif_version = 'latest'
            except ValueError:
                self.beta_pif_version = 'latest'

            # Set focus to the custom version input and select all text
            if is_custom:
                self.custom_version.SetFocus()
                self.custom_version.SetSelection(-1, -1)

    # -----------------------------------------------
    #                  onBetaVersionChange
    # -----------------------------------------------
    def onBetaVersionChange(self, event):
        text = self.custom_version.GetValue().strip()

        try:
            if text:
                self.beta_pif_version = str(text)
            else:
                self.beta_pif_version = 'latest'
        except ValueError:
            print(f"ERROR: Invalid Android version number: {text}")
            self.custom_version.SetValue('')  # Clear invalid input
            event.Skip(False)  # Prevent invalid input
            return

        # Allow valid changes
        event.Skip()

    # -----------------------------------------------
    #                  onGetPixelBetaPif
    # -----------------------------------------------
    def onGetPixelBetaPif(self, e):
        try:
            self._on_spin('start')
            wx.CallAfter(self.console_stc.SetValue, _("Getting Pixel beta print ...\nPlease be patient this could take some time ..."))
            wx.Yield()
            force_version = None
            device = get_phone()
            if wx.GetKeyState(wx.WXK_CONTROL) and wx.GetKeyState(wx.WXK_SHIFT):
                device_model = "all"
            elif wx.GetKeyState(wx.WXK_CONTROL):
                device_model = "_select_"
            # elif device:
            #     device_model = device.hardware
            else:
                # device_model = "Random"
                device_model = "_select_"
            # Check if self.beta_pif_version is a two digit number then set force_version to that (int)
            if self.beta_pif_version.isdigit() and len(self.beta_pif_version) == 2:
                force_version = int(self.beta_pif_version)
            elif self.beta_pif_version.lower() == 'c':
                catalog, catalog_path = fetch_canary_miner_catalog()
                if not catalog_path:
                    catalog_path = os.path.join(get_config_path(), 'canary_miner_catalog.json').strip()

                if not catalog and catalog_path and os.path.exists(catalog_path):
                    try:
                        with open(catalog_path, 'r', encoding='utf-8') as f:
                            catalog = json.load(f)
                    except Exception:
                        catalog = None

                if catalog:
                    selected_entry = self.select_catalog_image(catalog)
                    if selected_entry:
                        release = selected_entry.get('release', {}) if isinstance(selected_entry, dict) else {}
                        selected_url = release.get('url') if isinstance(release, dict) else None
                        if selected_url and self.process_factory_image_selection(selected_url, "Canary"):
                            return
                        if not selected_url:
                            print("⚠️ WARNING! Selected Canary catalog entry is missing a download URL.")
                        device_model = release.get('target') or selected_entry.get('device_key', device_model)
                    else:
                        print("ℹ️ INFO: Canary catalog selection cancelled by user; skipping automatic retrieval.")
                        wx.CallAfter(self.console_stc.SetValue, _("Canary selection cancelled."))
                        return
            elif self.beta_pif_version.lower() == 't':
                force_version = 't'
                t_factory_images = get_telegram_factory_images()
                if t_factory_images and isinstance(t_factory_images, list):
                    selected_image = self.select_t_image(t_factory_images)
                    if selected_image is None:
                        force_version = None
                        self.console_stc.SetValue(f"{self.console_stc.GetValue()}\n⚠️ WARNING! No valid Telegram factory image selected.")
                        return
                    if self.process_factory_image_selection(selected_image, "Telegram"):
                        return
                    return
                else:
                    force_version = None
                    print(f"⚠️ WARNING! The requested Android beta / canary version is not valid: {self.beta_pif_version}. Using latest version instead.")
            else:
                force_version = None
                if self.rb_custom.GetValue():
                    print(f"⚠️ WARNING! The requested Android beta / canary version is not valid: {self.beta_pif_version}. Using latest version instead.")

            # Create download state for potential abort
            self.download_state = DownloadState()

            beta_pif = get_beta_pif(device_model, force_version, state=self.download_state)

            # Check if window is still valid before proceeding
            if not self or not hasattr(self, 'console_stc') or not self.console_stc:
                # Window was destroyed, just return
                self.download_state = None
                return

            # Check if we got valid results
            # Note: stop_event is set both on success (to stop download early) and on abort
            # So we check if we actually got results, not just if stop_event is set
            if beta_pif == -1 or beta_pif is None:
                self.console_stc.SetValue(_("Failed to get beta print."))
                self.download_state = None
                return
            if self.pif_format == 'prop':
                self.console_stc.SetValue(self.J2P(beta_pif))
            else:
                self.console_stc.SetValue(beta_pif)

            # Clear download state after successful completion
            self.download_state = None

        except Exception:
            # Check if abort was triggered before handling exception
            if self.download_state and self.download_state.stop_event.is_set():
                debug("Download/processing was aborted or window closed")
                self.download_state = None
                return
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onGetPixelBetaPif function")
            traceback.print_exc()
        finally:
            try:
                if self and hasattr(self, '_on_spin'):
                    self._on_spin('stop')
            except Exception:
                pass  # Ignore errors if self is already destroyed
            # Clear download state
            if hasattr(self, 'download_state'):
                self.download_state = None

    # -----------------------------------------------
    #                  select_t_image
    # -----------------------------------------------
    # Create a custom dialog with tree control for selection
    def select_t_image(self, t_factory_images):
        try:
            if not (t_factory_images and isinstance(t_factory_images, list)):
                return None

            build_groups = {}
            for image in t_factory_images:
                if not isinstance(image, dict):
                    continue
                build_id = image.get('build_id', 'Unknown Build')
                build_groups.setdefault(build_id, []).append(image)

            if not build_groups:
                print("⚠️ WARNING! Telegram factory images did not contain any selectable entries.")
                return None

            tree_nodes = []
            for build_id, images in build_groups.items():
                children = []
                for image in images:
                    device_label = image.get('device', 'Unknown Device')
                    image_type = image.get('type', 'Factory Image')
                    children.append({
                        'label': f"{device_label} - {image_type}",
                        'data': image,
                    })
                tree_nodes.append({
                    'label': build_id,
                    'children': children,
                })

            selected_image = show_factory_image_dialog(
                self,
                _("Telegram Factory Images"),
                _("Select a factory image to use:"),
                _("Factory Images"),
                tree_nodes,
                size=(800, 600),
                download_button=True,
            )

            if selected_image and isinstance(selected_image, dict):
                print(f"Selected factory image: {selected_image.get('device', 'Unknown Device')} - {selected_image.get('type', 'Factory Image')}")
                print(f"URL: {selected_image.get('url')}")
                return selected_image.get('url')
            return None
        except Exception as e:
            print(f"Error selecting Telegram factory image: {e}")
            traceback.print_exc()
            return None

    # -----------------------------------------------
    #                  select_catalog_image
    # -----------------------------------------------
    def select_catalog_image(self, catalog):
        try:
            if not isinstance(catalog, dict):
                return None

            tree_data = {}
            sections = (
                ('canaries', _("Canaries")),
                ('betas', _("All Betas")),
            )

            for section_key, section_label in sections:
                section = catalog.get(section_key, {})
                if not isinstance(section, dict):
                    continue
                build_map = {}
                for device_key, device_obj in section.items():
                    if not isinstance(device_obj, dict):
                        continue
                    device_name = device_obj.get('name') or device_key
                    releases = device_obj.get('releases', [])
                    if not isinstance(releases, list):
                        continue
                    for release in releases:
                        if not isinstance(release, dict):
                            continue
                        build_name = release.get('buildName') or release.get('releaseId') or release.get('buildId') or _("Unknown Build")
                        entry = {
                            'category': section_label,
                            'device_key': device_key,
                            'device_name': device_name,
                            'release': release,
                        }
                        build_map.setdefault(build_name, []).append(entry)
                if build_map:
                    tree_data[section_label] = build_map

            if not tree_data:
                print("⚠️ WARNING! Canary Miner catalog did not contain any selectable entries.")
                return None

            def build_sort_value(build_name, entries):
                values = []
                for entry in entries:
                    release = entry.get('release') if isinstance(entry, dict) else None
                    if not isinstance(release, dict):
                        continue
                    for key in ('buildName', 'releaseId', 'buildId'):
                        candidate = release.get(key)
                        if not isinstance(candidate, str):
                            continue
                        match = re.search(r'(\d{6})', candidate)
                        if match:
                            values.append(int(match.group(1)))
                            break
                        match = re.search(r'(\d+)', candidate)
                        if match:
                            values.append(int(match.group(1)))
                            break
                if values:
                    return max(values)
                match = re.search(r'(\d{6})', build_name)
                if match:
                    return int(match.group(1))
                match = re.search(r'(\d+)', build_name)
                if match:
                    return int(match.group(1))
                return 0

            tree_nodes = []
            for section_label, build_map in sorted(tree_data.items()):
                build_children = []
                sorted_builds = sorted(
                    build_map.items(),
                    key=lambda kv: (build_sort_value(kv[0], kv[1]), kv[0]),
                    reverse=True
                )
                for build_name, entries in sorted_builds:
                    release_children = []
                    for entry in entries:
                        release = entry['release']
                        release_id = release.get('releaseId', '') if isinstance(release, dict) else ''
                        device_text = entry['device_name'] or entry['device_key']
                        if entry['device_key'] and entry['device_key'] not in device_text:
                            device_text = f"{device_text} [{entry['device_key']}]"
                        if release_id:
                            device_text = f"{device_text} ({release_id})"
                        release_children.append({
                            'label': device_text,
                            'data': entry,
                        })
                    if release_children:
                        build_children.append({
                            'label': build_name,
                            'children': release_children,
                        })
                if build_children:
                    tree_nodes.append({
                        'label': section_label,
                        'children': build_children,
                    })

            if not tree_nodes:
                print("⚠️ WARNING! Canary Miner catalog did not contain any selectable entries.")
                return None

            return show_factory_image_dialog(
                self,
                _("Canary Miner Catalog"),
                _("Select a Canary or Beta factory image:"),
                _("Catalog"),
                tree_nodes,
            )
        except Exception as e:
            print(f"Error selecting Canary catalog entry: {e}")
            traceback.print_exc()
            return None

    # -----------------------------------------------
    #          process_factory_image_selection
    # -----------------------------------------------
    def process_factory_image_selection(self, image_url, source_label):
        try:
            if not image_url:
                print(f"⚠️ WARNING! No download URL available for {source_label} factory image selection.")
                return False

            # Create download state for potential abort
            self.download_state = DownloadState()

            fingerprint, security_patch = url2fpsp(image_url, "factory", state=self.download_state)
            if fingerprint is None or security_patch is None:
                # Check if window was closed (abort)
                if self.download_state is None or self.download_state.stop_event.is_set():
                    debug("Download/processing was aborted or window closed")
                    return False
                debug(f"Failed to get fingerprint and security patch from partial {image_url}\nTrying the full image ...")
                override_size_limit = get_size_from_url(image_url)
                if override_size_limit is not None:
                    if self.download_state is None or self.download_state.stop_event.is_set():
                        debug("Download/processing was aborted or window closed")
                        return False
                    self.console_stc.SetValue(f"{self.console_stc.GetValue()}\n⚠️ Downloading full {source_label} factory image {override_size_limit} bytes ...\nThis may take quite a while ...")
                    wx.Yield()
                    fingerprint, security_patch = url2fpsp(image_url, "factory", override_size_limit, state=self.download_state)

            # Clear download state after completion
            self.download_state = None

            if fingerprint and security_patch:
                print(f"Security Patch:           {security_patch}")
                pattern = r'([^\/]*)\/([^\/]*)\/([^:]*)[:]([^\/]*)\/([^\/]*)\/([^:]*)[:]([^\/]*)\/([^\/]*)$'
                match = re.search(pattern, fingerprint)
                if match and match.lastindex == 8:
                    product = match[2]
                    device = match[3]
                    latest_version = match[4]
                    build_id = match[5]
                    incremental = match[6]
                    build_type = match[7]
                    build_tags = match[8]
                    device_data = get_android_devices()
                    model = None
                    with contextlib.suppress(Exception):
                        model = device_data[device]['device']
                        # if model starts with "Google ", remove that part
                        if model.startswith("Google "):
                            model = model[7:]
                    pif_data = {
                        "MANUFACTURER": "Google",
                        "MODEL": model,
                        "FINGERPRINT": f"google/{product}/{device}:{latest_version}/{build_id}/{incremental}:{build_type}/{build_tags}",
                        "PRODUCT": product,
                        "DEVICE": device,
                        "SECURITY_PATCH": security_patch,
                        "DEVICE_INITIAL_SDK_INT": "32"
                    }
                    json_string = json.dumps(pif_data, indent=4) + "\n"
                    if self.pif_format == 'prop':
                        self.console_stc.SetValue(self.J2P(json_string))
                    else:
                        self.console_stc.SetValue(json_string)
                    print(f"{source_label} Pixel Beta Profile/Fingerprint:\n{json_string}")
                    return True

            print(f"⚠️ WARNING! Failed to create fingerprint from {source_label.lower()} factory image.")
            wx.CallAfter(self.console_stc.SetValue, _("Failed to get beta print."))
            return False
        except Exception as e:
            print(f"⚠️ WARNING! Exception while processing {source_label.lower()} factory image: {e}")
            traceback.print_exc()
            wx.CallAfter(self.console_stc.SetValue, _("Failed to get beta print."))
            return False

    # -----------------------------------------------
    #                  onPlayIntegrityCheck
    # -----------------------------------------------
    def onPlayIntegrityCheck(self, e):
        try:
            device = get_phone(True)
            if not device:
                return
            if not device.rooted:
                return
            if wx.GetKeyState(wx.WXK_CONTROL):
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Play Integrity API Checker with clear option.")
                clear_first = True
            else:
                print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Play Integrity API Checker.")
                clear_first = False
            self._on_spin('start')

            if not self.insync:
                self.toast(_("Active pif not in sync"), _("⚠️ WARNING! Device pif is not in sync with Active Pif contents.\nThe result will not be reflective of the Active pif you're viewing."))

            # We need to kill TB Checker , Play Store and YASNAC to make sure we read fresh values
            if self.pi_option.StringSelection in ['Android Integrity Checker', 'TB Checker', 'Play Store', 'YASNAC']:
                res = device.perform_package_action(self.pi_app, 'kill', False)

            # launch the app
            res = device.perform_package_action(self.pi_app, self.launch_method, False)
            if res == -1:
                print(f"Error: during launching app {self.pi_app}.")
                return -1

            # See if we have coordinates saved
            coords = self.coords.query_entry(device.id, self.pi_app)
            coord_dismiss = None
            if coords is None or clear_first:
                if self.disable_uiautomator_checkbox.IsChecked():
                    print(f"⚠️ WARNING! You have disabled using UIAutomator.\nPlease uncheck Disable UIAutomator checkbox if you want to enable UIAutomator usage.")
                    return
                # For Play Store, we need to save multiple coordinates
                if self.pi_option.StringSelection == 'Play Store':
                    # Get coordinates for the first time
                    # user
                    coord_user = self.get_pi_app_coords(child='user')
                    if coord_user == -1:
                        print(f"Error: during tapping {self.pi_app} [user] screen.")
                        if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                            del self.coords.data[device.id][self.pi_app]
                            self.coords.save_data()
                        return -1
                    self.coords.update_nested_entry(device.id, self.pi_app, "user", coord_user)

                    # settings
                    coord_settings = self.get_pi_app_coords(child='settings')
                    if coord_settings == -1:
                        print(f"Error: during tapping {self.pi_app} [settings] screen.")
                        if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                            del self.coords.data[device.id][self.pi_app]
                            self.coords.save_data()
                        return -1
                    self.coords.update_nested_entry(device.id, self.pi_app, "settings", coord_settings)

                    # general
                    coord_general = self.get_pi_app_coords(child='general')
                    if coord_general == -1:
                        print(f"Error: during tapping {self.pi_app} [general] screen.")
                        if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                            del self.coords.data[device.id][self.pi_app]
                            self.coords.save_data()
                        return -1
                    self.coords.update_nested_entry(device.id, self.pi_app, "general", coord_general)
                    # page scroll
                    coord_scroll = self.get_pi_app_coords(child='scroll')
                    if coord_scroll == -1:
                        print(f"Error: during swiping {self.pi_app} [scroll] screen.")
                        if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                            del self.coords.data[device.id][self.pi_app]
                            self.coords.save_data()
                        return -1
                    self.coords.update_nested_entry(device.id, self.pi_app, "scroll", coord_scroll)
                    # Developer Options
                    coord_developer_options = self.get_pi_app_coords(child='developer_options')
                    if coord_developer_options == -1:
                        print(f"Error: during tapping {self.pi_app} [developer_options] screen.\nPossibly swipe failed.")
                        if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                            del self.coords.data[device.id][self.pi_app]
                            self.coords.save_data()
                        return -1
                    self.coords.update_nested_entry(device.id, self.pi_app, "developer_options", coord_developer_options)
                    # Check Integrity
                    coord_test = self.get_pi_app_coords(child='test')
                    if coord_test == -1:
                        print(f"Error: during tapping {self.pi_app} [Check Integrity] screen.")
                        if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                            del self.coords.data[device.id][self.pi_app]
                            self.coords.save_data()
                        return -1
                    self.coords.update_nested_entry(device.id, self.pi_app, "test", coord_test)
                    coords = coord_test
                else:
                    # Get coordinates for the first time
                    coords = self.get_pi_app_coords()
                    if coords is not None and coords != -1:
                        # update coords.json
                        self.coords.update_entry(device.id, self.pi_app, coords)
                    else:
                        print("Error: Could not get coordinates.")
                        if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                            del self.coords.data[device.id][self.pi_app]
                            self.coords.save_data()
                        return -1
            elif self.pi_option.StringSelection == 'Play Store':
                coord_user = self.coords.query_nested_entry(device.id, self.pi_app, "user")
                coord_settings = self.coords.query_nested_entry(device.id, self.pi_app, "settings")
                coord_general = self.coords.query_nested_entry(device.id, self.pi_app, "general")
                coord_scroll = self.coords.query_nested_entry(device.id, self.pi_app, "scroll")
                coord_developer_options = self.coords.query_nested_entry(device.id, self.pi_app, "developer_options")
                coord_test = self.coords.query_nested_entry(device.id, self.pi_app, "test")
                coord_dismiss = self.coords.query_nested_entry(device.id, self.pi_app, "dismiss")
                if coord_user is None or coord_user == '' or coord_settings is None or coord_settings == '' or coord_general is None or coord_general == '' or coord_developer_options is None or coord_developer_options == '' or coord_test is None or coord_test == '':
                    print(f"\nError: coordinates for {self.pi_app} is missing from settings\nPlease run the test again so that PixelFlasher can try to get fresh new coordinates.")
                    if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                        del self.coords.data[device.id][self.pi_app]
                        self.coords.save_data()
                    return -1

                # user
                res = device.click(coord_user)
                if res == -1:
                    print(f"Error: during tapping {self.pi_app} [user] screen.")
                    if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                        del self.coords.data[device.id][self.pi_app]
                        self.coords.save_data()
                    return -1
                time.sleep(1)
                # settings
                res = device.click(coord_settings)
                if res == -1:
                    print(f"Error: during tapping {self.pi_app} [settings] screen.")
                    if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                        del self.coords.data[device.id][self.pi_app]
                        self.coords.save_data()
                    return -1
                time.sleep(1)
                # general
                res = device.click(coord_general)
                if res == -1:
                    print(f"Error: during tapping {self.pi_app} [general] screen.")
                    if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                        del self.coords.data[device.id][self.pi_app]
                        self.coords.save_data()
                    return -1
                time.sleep(1)
                res = device.swipe(coord_scroll)
                if res == -1:
                    print(f"Error: during swiping {self.pi_app} [scroll] screen.")
                    if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                        del self.coords.data[device.id][self.pi_app]
                        self.coords.save_data()
                    return -1
                time.sleep(1)
                # developer_options
                res = device.click(coord_developer_options)
                if res == -1:
                    print(f"Error: during tapping {self.pi_app} [developer_options] screen.")
                    if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                        del self.coords.data[device.id][self.pi_app]
                        self.coords.save_data()
                    return -1
                time.sleep(1)
                # test
                coords = coord_test

            # Click on coordinates
            res = device.click(coords)
            if res == -1:
                print(f"\nError: coordinates for {self.pi_app} is missing from settings\nPlease run the test again so that PixelFlasher can try to get fresh new coordinates.")
                if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                    del self.coords.data[device.id][self.pi_app]
                    self.coords.save_data()
                return -1

            # Skip Getting results if UIAutomator is disabled.
            if not self.disable_uiautomator_checkbox.IsChecked():
                # pull view
                config_path = get_config_path()
                pi_xml = os.path.join(config_path, 'tmp', 'pi.xml')
                print("Sleeping 10 seconds to get the results ...")
                time.sleep(5)

                if self.pi_option.StringSelection == 'Android Integrity Checker':
                    device.swipe_up(percentage=20)

                res = device.ui_action('/data/local/tmp/pi.xml', pi_xml)
                if res == -1:
                    print(f"Error: during uiautomator {self.pi_app}.")
                    return -1

                # extract result
                if self.pi_option.StringSelection == 'Play Integrity API Checker':
                    res = process_pi_xml_piac(pi_xml)
                if self.pi_option.StringSelection == 'Simple Play Integrity Checker':
                    res = process_pi_xml_spic(pi_xml)
                if self.pi_option.StringSelection == 'TB Checker':
                    res = process_pi_xml_tb(pi_xml)
                if self.pi_option.StringSelection == 'Android Integrity Checker':
                    res = process_pi_xml_aic(pi_xml)
                if self.pi_option.StringSelection == 'Play Store':
                    res = process_pi_xml_ps(pi_xml)
                    # dismiss
                    if coord_dismiss is None or coord_dismiss == '' or coord_dismiss == -1:
                        coord_dismiss = self.get_pi_app_coords(child='dismiss')
                        if coord_dismiss == -1:
                            print(f"Error: getting coordinates for {self.pi_app} [dismiss] screen.")
                            if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                                del self.coords.data[device.id][self.pi_app]['dismiss']
                                self.coords.save_data()
                        self.coords.update_nested_entry(device.id, self.pi_app, "dismiss", coord_dismiss)
                if self.pi_option.StringSelection == 'YASNAC':
                    res = process_pi_xml_yasnac(pi_xml)

                if res == -1:
                    print(f"Error: during processing the response from {self.pi_app}.")
                    return -1

                self.console_stc.SetValue('')
                if res is None or res == '':
                    if device.id in self.coords.data and self.pi_app in self.coords.data[device.id]:
                        del self.coords.data[device.id][self.pi_app]['dismiss']
                else:
                    self.console_stc.SetValue(res)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Play Integrity API Check process.")
            traceback.print_exc()
        finally:
            if device:
                res = device.delete("/data/local/tmp/pi.xml", device.rooted)
            self._on_spin('stop')

    # -----------------------------------------------
    #                  sort_prop
    # -----------------------------------------------
    def sort_prop(self, file_path):
        filename = os.path.basename(file_path)
        if filename == "build.prop":
            return 1
        elif filename == "system-build.prop":
            return 2
        elif filename == "system.prop":
            return 3
        elif filename == "product-build.prop":
            return 4
        elif filename == "product.prop":
            return 5
        elif filename == "vendor-build.prop":
            return 6
        elif filename == "vendor.prop":
            return 7
        else:
            return 999

    # -----------------------------------------------
    #                  onProcessBuildProps
    # -----------------------------------------------
    def onProcessBuildProps(self, e):
        # sourcery skip: dict-assign-update-to-union
        try:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User pressed Process build.prop")
            wildcard = "Property files (*.prop)|*.prop|All files (*.*)|*.*"
            dialog = wx.FileDialog(self, _("Choose property files to open"), wildcard=wildcard, style=wx.FD_OPEN | wx.FD_MULTIPLE)

            if dialog.ShowModal() == wx.ID_CANCEL:
                print("User cancelled file selection.")
                return

            paths = dialog.GetPaths()
            dialog.Destroy()
            sorted_paths = sorted(paths, key=self.sort_prop)

            print(f"Selected files: {sorted_paths}")

            self._on_spin('start')
            self.process_props(sorted_paths)
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onProcessBuildProps function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  process_props
    # -----------------------------------------------
    def process_props(self, prop_files):
        # sourcery skip: dict-assign-update-to-union
        try:
            processed_dict = {}
            for pathname in reversed(prop_files):
                with open(pathname, 'r', encoding='ISO-8859-1', errors="replace") as f:
                    content = f.readlines()

                contentList = [x.strip().split('#')[0].split('=', 1) for x in content if '=' in x.split('#')[0]]
                contentDict = dict(contentList)

                # Update processed_dict with entries from the current file
                # In place Union operator below fails on Windows 2019 build, so use the update method instead.
                # processed_dict |= contentDict
                processed_dict.update(contentDict)

                # Apply the substitution to the values in processed_dict
                for k, v in contentDict.items():
                    for x in v.split('$')[1:]:
                        key = re.findall(r'\w+', x)[0]
                        v = v.replace(f'${key}', processed_dict[key])
                    processed_dict[k] = v.strip()

            # if running in debugger
            if not getattr( sys, 'frozen', False ):
                # save processed_dict to a file
                config_path = get_config_path()
                processed_dict_file = os.path.join(config_path, 'tmp', 'processed_dict.json')
                with open(processed_dict_file, 'w') as f:
                    json.dump(processed_dict, f, indent=4)

            donor_json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=self.first_api, keep_all=self.keep_unknown)
            if self.pif_format == 'prop':
                self.console_stc.SetValue(self.J2P(donor_json_string))
            else:
                self.console_stc.SetValue(donor_json_string)
            # print(donor_json_string)

            # Auto Update print
            if self.auto_update_pif_checkbox.IsEnabled() and self.auto_update_pif_checkbox.IsChecked():
                self.active_pif_stc.SetValue(self.console_stc.GetValue())
                self.UpdatePifJson(None)

            # Auto run migrate if enabled
            if self.auto_run_migrate_checkbox.IsEnabled() and self.auto_run_migrate_checkbox.IsChecked():
                print("Auto Migrating ...")
                self.runMigrate()

            # Auto test Play Integrity
            if self.auto_update_pif_checkbox.IsEnabled() and self.auto_update_pif_checkbox.IsChecked():
                if self.auto_check_pi_checkbox.IsEnabled() and self.auto_check_pi_checkbox.IsChecked():
                    print("Auto Testing Play Integrity ...")
                    self.onPlayIntegrityCheck(None)

        except Exception:
            print(f"Cannot process file: '{pathname}'.")
            traceback.print_exc()

    # -----------------------------------------------
    #                  onProcessImage
    # -----------------------------------------------
    def onProcessImage(self, e):
        try:
            file_dialog = wx.FileDialog(self, _("Select a Device Image"), wildcard="Device image files (*.img;*.zip)|*.img;*.zip")
            if file_dialog.ShowModal() == wx.ID_OK:
                file_path = file_dialog.GetPath()
                self._on_spin('start')
                wx.CallAfter(self.console_stc.SetValue, _("Processing %s ...\nPlease be patient this could take some time ...") % file_path)
                props_dir = get_pif_from_image(file_path)
                # prop_files = get files from the props_dir (single level) and store them in a list
                if props_dir:
                    prop_files = [os.path.join(props_dir, f) for f in os.listdir(props_dir) if os.path.isfile(os.path.join(props_dir, f))]
                    self.process_props(prop_files)
                else:
                    wx.CallAfter(self.console_stc.SetValue, _("Image format not supported"))
                    self.console_stc.Refresh()
                    self.console_stc.Update()
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onProcessImage function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onProcessBulkProps
    # -----------------------------------------------
    def onProcessBulkProps(self, e):
        # sourcery skip: dict-assign-update-to-union
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User pressed Process build.props Folder")

        with wx.DirDialog(self, _("Select folder to bulk process props files"), style=wx.DD_DEFAULT_STYLE) as folderDialog:
            if folderDialog.ShowModal() == wx.ID_CANCEL:
                print("User cancelled folder selection.")
                return
            selected_folder = folderDialog.GetPath()

        try:
            self._on_spin('start')
            prop_files = [file for file in os.listdir(selected_folder) if file.endswith(".prop")]
            for prop in prop_files:
                prop_path = os.path.join(selected_folder, prop)
                processed_dict = {}
                with open(prop_path, 'r', encoding='ISO-8859-1', errors="replace") as f:
                    content = f.readlines()

                contentList = [x.strip().split('#')[0].split('=', 1) for x in content if '=' in x.split('#')[0]]
                contentDict = dict(contentList)

                # Update processed_dict with entries from the current file
                # In place Union operator below fails on Windows 2019 build, so use the update method instead.
                # processed_dict |= contentDict
                processed_dict.update(contentDict)

                # Apply the substitution to the values in processed_dict
                for k, v in contentDict.items():
                    for x in v.split('$')[1:]:
                        key = re.findall(r'\w+', x)[0]
                        v = v.replace(f'${key}', processed_dict[key])
                    processed_dict[k] = v.strip()

                json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=self.first_api, keep_all=self.keep_unknown)

                # not needed if we don't want to auto-fill first api
                json_dict = json5.loads(json_string)
                keys = ['FIRST_API_LEVEL', 'DEVICE_INITIAL_SDK_INT', '*api_level', 'ro.product.first_api_level']
                first_api = get_first_match(json_dict, keys)
                json_string = json.dumps(json_dict, indent=4, sort_keys=self.sort_keys)
                processed_dict = self.load_json_with_rules(json_string, self.keep_unknown)
                if first_api == '':
                    donor_json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=self.first_api_value, sort_data=self.sort_keys)
                else:
                    donor_json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=None, sort_data=self.sort_keys)

                # save json file
                json_path = os.path.splitext(prop_path)[0] + ".json"
                with open(json_path, 'w', encoding="ISO-8859-1", errors="replace", newline='\n') as f:
                    f.write(donor_json_string)

        except Exception:
            print(f"Cannot process file: '{selected_folder}'.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  ConsoleStcChange
    # -----------------------------------------------
    def ConsoleStcChange(self, event):
        try:
            console_data = self.console_stc.GetValue()
            json_data = None
            if console_data:
                if self.pif_format == 'prop':
                    json_data = self.P2J(console_data)
                else:
                    json_data = console_data

            if json_data:
                try:
                    json.loads(json_data)
                    self.smart_paste_up.Enable(True)
                    self.paste_up.Enable(True)
                except Exception:
                    try:
                        json5.loads(json_data)
                        self.smart_paste_up.Enable(True)
                        self.paste_up.Enable(True)
                    except Exception:
                        self.smart_paste_up.Enable(False)
                        self.paste_up.Enable(False)
            else:
                self.smart_paste_up.Enable(False)
                self.paste_up.Enable(False)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in ConsoleStcChange function")
            traceback.print_exc()
        if event:
            event.Skip()

    # -----------------------------------------------
    #                  ActivePifStcChange
    # -----------------------------------------------
    def ActivePifStcChange(self, event):
        # Allow the default event handler to run first
        if event:
            event.Skip()

        # Use debounced validation to avoid performance issues during typing
        if self._validation_timer is not None:
            self._validation_timer.Stop()

        # Delay validation by 500ms to allow for smooth typing
        self._validation_timer = wx.CallLater(500, self.process_active_pif_updated_value)

    # -----------------------------------------------
    #          process_active_pif_updated_value
    # -----------------------------------------------
    def process_active_pif_updated_value(self):
        try:
            active_data = self.active_pif_stc.GetValue()
            json_data = ''
            if active_data:
                if self.pif_format == 'prop':
                    json_data = self.P2J(active_data)
                else:
                    json_data = active_data

            if not self.enable_buttons:
                self.create_pif_button.Enable(False)
                self.push_pif_button.Enable(False)
                return

            if json_data:
                try:
                    json.loads(json_data)
                    self.paste_down.Enable(True)
                    self.reprocess.Enable(True)
                    if "Targeted Fix" not in self.pif_selection_combo.StringSelection:
                        self.create_pif_button.Enable(True)
                        self.push_pif_button.Enable(True)
                    self.favorite_pif_button.Enable(True)
                    self.save_pif_button.Enable(True)
                except Exception:
                    try:
                        json5.loads(json_data)
                        self.paste_down.Enable(True)
                        self.reprocess.Enable(True)
                        self.create_pif_button.Enable(True)
                        self.push_pif_button.Enable(True)
                        self.favorite_pif_button.Enable(True)
                        self.save_pif_button.Enable(True)
                    except Exception:
                        self.create_pif_button.Enable(False)
                        self.push_pif_button.Enable(False)
                        self.reprocess.Enable(False)
                        self.paste_down.Enable(False)
                        self.favorite_pif_button.Enable(False)
                        self.save_pif_button.Enable(False)
            else:
                self.paste_down.Enable(False)
                self.create_pif_button.Enable(False)
                self.push_pif_button.Enable(False)
                self.reprocess.Enable(False)
                self.favorite_pif_button.Enable(False)
                self.save_pif_button.Enable(False)

            if self.pif_format == 'prop':
                compare_data = self.P2J(self.device_pif)
            else:
                compare_data = self.device_pif
            if json_data != compare_data:
                self.pif_modified_image.SetBitmap(images.alert_red_24.GetBitmap())
                self.pif_modified_image.SetToolTip(_("The contents is different than what is currently on the device.\nUpdate the print before testing."))
                self.insync = False
            else:
                self.pif_modified_image.SetBitmap(images.alert_gray_24.GetBitmap())
                self.pif_modified_image.SetToolTip(_("Active pif is not modified."))
                self.insync = True

            # Check if we should update favorite status (either create button enabled or TargetedFix module)
            is_pif_create_update_enabled = self.create_pif_button.Enabled
            is_targetedfix_module = (
                                        hasattr(self, 'current_pif_module') and
                                        self.current_pif_module and
                                        getattr(self.current_pif_module, 'id', None) == "targetedfix"
                                    )
            is_favorite_enabled = self.favorite_pif_button.Enabled

            if (is_pif_create_update_enabled or is_targetedfix_module) and is_favorite_enabled:
                sorted_json_data = json.dumps(json5.loads(json_data), indent=4, sort_keys=True)
                pif_hash = json_hexdigest(sorted_json_data)
                if pif_hash in self.favorite_pifs:
                    self.favorite_pif_button.SetBitmap(images.heart_red_24.GetBitmap())
                    self.favorite_pif_button.SetToolTip(_("Active pif is saved in favorites."))
                    self.update_combo_box(pif_hash)
                else:
                    self.favorite_pif_button.SetBitmap(images.heart_gray_24.GetBitmap())
                    self.favorite_pif_button.SetToolTip(_("Active pif is not saved in favorites."))

            # Update TargetedFix button states if applicable
            if is_targetedfix_module:
                self.update_tf_button_states()

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in ActivePifStcChange function")
            traceback.print_exc()

    # -----------------------------------------------
    #                  update_combo_box
    # -----------------------------------------------
    def update_combo_box(self, pif_hash=None):
        try:
            pif_labels = [pif["label"] for pif in self.favorite_pifs.values()]
            self.pif_combo_box.SetItems(pif_labels)

            # temporarily unbind so that we don't trigger another ActivePifStcChange with the combo box selection
            self.active_pif_stc.Unbind(wx.stc.EVT_STC_CHANGE, handler=self.ActivePifStcChange)
            # Make the combo box selection
            if pif_hash is None:
                self.pif_combo_box.SetSelection(-1)
            else:
                label = self.favorite_pifs[pif_hash]["label"]
                index = self.pif_combo_box.FindString(label)
                if index != wx.NOT_FOUND:
                    self.pif_combo_box.SetSelection(index)
                else:
                    self.pif_combo_box.SetSelection(-1)
            # rebind the event
            self.active_pif_stc.Bind(wx.stc.EVT_STC_CHANGE, self.ActivePifStcChange)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in update_combo_box function")
            traceback.print_exc()

    # -----------------------------------------------
    #                  onSmartPasteUp
    # -----------------------------------------------
    def onSmartPasteUp(self, event):
        try:
            print("Smart pasting up the console content ...")
            self._on_spin('start')
            console_data = self.console_stc.GetValue()
            json_string = None
            if console_data:
                if self.pif_format == 'prop':
                    json_string = self.P2J(console_data)
                else:
                    json_string = console_data

            json_dict = json5.loads(json_string)
            keys = ['FIRST_API_LEVEL', 'DEVICE_INITIAL_SDK_INT', '*api_level', 'ro.product.first_api_level']
            first_api = get_first_match(json_dict, keys)
            json_string = json.dumps(json_dict, indent=4, sort_keys=self.sort_keys)
            processed_dict = self.load_json_with_rules(json_string, self.pif_flavor)
            if self.force_first_api_checkbox.IsChecked():
                donor_json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=str(self.first_api_value), sort_data=self.sort_keys, keep_all=self.keep_unknown)
            else:
                donor_json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=first_api, sort_data=self.sort_keys, keep_all=self.keep_unknown)
            if self.pif_format == 'prop':
                self.active_pif_stc.SetValue(self.J2P(donor_json_string))
            else:
                self.active_pif_stc.SetValue(donor_json_string)

            # Auto Update print
            if self.auto_update_pif_checkbox.IsEnabled() and self.auto_update_pif_checkbox.IsChecked():
                self.UpdatePifJson(None)

                # Auto run migrate if enabled
                if self.auto_run_migrate_checkbox.IsEnabled() and self.auto_run_migrate_checkbox.IsChecked():
                    print("Auto Migrating ...")
                    self.runMigrate()

            # Auto test Play Integrity
            if self.auto_update_pif_checkbox.IsEnabled() and self.auto_update_pif_checkbox.IsChecked():
                if self.auto_check_pi_checkbox.IsEnabled() and self.auto_check_pi_checkbox.IsChecked():
                    print("Auto Testing Play Integrity ...")
                    self.onPlayIntegrityCheck(None)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onSmartPasteUp function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')
            if event:
                event.Skip()

    # -----------------------------------------------
    #                  onPasteUp
    # -----------------------------------------------
    def onPasteUp(self, event):
        self.active_pif_stc.SetValue(self.console_stc.GetValue())
        event.Skip()

    # -----------------------------------------------
    #                  onPasteDown
    # -----------------------------------------------
    def onPasteDown(self, event):
        self.console_stc.SetValue(self.active_pif_stc.GetValue())
        event.Skip()

    # -----------------------------------------------
    #                  onAddMissingKeysFromDevice
    # -----------------------------------------------
    def onAddMissingKeysFromDevice(self, event):
        self.add_missing_keys_checkbox = event.GetEventObject()
        status = self.add_missing_keys_checkbox.GetValue()
        print(f"Add Missing Keys is set to: {status}")
        self.config.pif['auto_fill'] = status

    # -----------------------------------------------
    #                  onSortKeys
    # -----------------------------------------------
    def onSortKeys(self, event):
        self.sort_keys_checkbox = event.GetEventObject()
        status = self.sort_keys_checkbox.GetValue()
        self.sort_keys = status
        self.config.pif['sort_keys'] = status

    # -----------------------------------------------
    #                  onKeepAllKeys
    # -----------------------------------------------
    def onKeepAllKeys(self, event):
        self.keep_unknown_checkbox = event.GetEventObject()
        status = self.keep_unknown_checkbox.GetValue()
        self.keep_unknown = status
        self.config.pif['keep_unknown'] = status

    # -----------------------------------------------
    #                  onSpoofBuild
    # -----------------------------------------------
    def onSpoofBuild(self, event):
        self.spoofBuild_checkbox = event.GetEventObject()
        status = self.spoofBuild_checkbox.GetValue()
        self.spoofBuild = status
        self.config.pif['spoofBuild'] = status

    # -----------------------------------------------
    #                  onSpoofProps
    # -----------------------------------------------
    def onSpoofProps(self, event):
        self.spoofProps_checkbox = event.GetEventObject()
        status = self.spoofProps_checkbox.GetValue()
        self.spoofProps = status
        self.config.pif['spoofProps'] = status

    # -----------------------------------------------
    #                  onApiValueChange
    # -----------------------------------------------
    def onApiValueChange(self, event):
        try:
            self.first_api_value = int(self.api_value_input.GetValue())
            self.config.pif['first_api_value_when_forced'] = self.first_api_value
            self.force_first_api_checkbox.SetToolTip(f"Forces First API value(s) to {self.first_api_value}")
        except ValueError:
            # Handle the case where the input is not a valid integer
            pass

    # -----------------------------------------------
    #                  onSpoofProvider
    # -----------------------------------------------
    def onSpoofProvider(self, event):
        self.spoofProvider_checkbox = event.GetEventObject()
        status = self.spoofProvider_checkbox.GetValue()
        self.spoofProvider = status
        self.config.pif['spoofProvider'] = status

    # -----------------------------------------------
    #                  onSpoofSignature
    # -----------------------------------------------
    def onSpoofSignature(self, event):
        self.spoofSignature_checkbox = event.GetEventObject()
        status = self.spoofSignature_checkbox.GetValue()
        self.spoofSignature = status
        self.config.pif['spoofSignature'] = status

    # -----------------------------------------------
    #                  onSpoofVendingSdk
    # -----------------------------------------------
    def onSpoofVendingSdk(self, event):
        self.spoofVendingSdk_checkbox = event.GetEventObject()
        status = self.spoofVendingSdk_checkbox.GetValue()
        self.spoofVendingSdk = status
        self.config.pif['spoofVendingSdk'] = status

    # -----------------------------------------------
    #                  onSpoofVendingFinger
    # -----------------------------------------------
    def onSpoofVendingFinger(self, event):
        self.spoofVendingFinger_checkbox = event.GetEventObject()
        status = self.spoofVendingFinger_checkbox.GetValue()
        self.spoofVendingFinger = status
        self.config.pif['spoofVendingFinger'] = status

    # -----------------------------------------------
    #                  onForceFirstAPI
    # -----------------------------------------------
    def onForceFirstAPI(self, event):
        self.force_first_api_checkbox = event.GetEventObject()
        status = self.force_first_api_checkbox.GetValue()
        print(f"Force First API is set to: {status}")
        self.config.pif['force_first_api'] = status
        if status:
            self.first_api = self.first_api_value
        else:
            self.first_api = None

    # -----------------------------------------------
    #                  onAutoUpdatePrint
    # -----------------------------------------------
    def onAutoUpdatePrint(self, event):
        self.auto_update_pif_checkbox = event.GetEventObject()
        status = self.auto_update_pif_checkbox.GetValue()
        print(f"Auto Update print is set to: {status}")
        self.config.pif['auto_update_pif_json'] = status

    # -----------------------------------------------
    #                  onAutoCheckPlayIntegrity
    # -----------------------------------------------
    def onAutoCheckPlayIntegrity(self, event):
        self.auto_check_pi_checkbox = event.GetEventObject()
        status = self.auto_check_pi_checkbox.GetValue()
        print(f"Auto Check Play Integrity is set to: {status}")
        self.config.pif['auto_check_play_integrity'] = status

    # -----------------------------------------------
    #                  onAutoRunMigrate
    # -----------------------------------------------
    def onAutoRunMigrate(self, event):
        self.auto_run_migrate_checkbox = event.GetEventObject()
        status = self.auto_run_migrate_checkbox.GetValue()
        print(f"Auto run migrate.sh is set to: {status}")
        self.config.pif['auto_run_migrate'] = status

    # -----------------------------------------------
    #                  runMigrate
    # -----------------------------------------------
    def runMigrate(self):
        try:
            print("Migrating pif to the latest Pifork format ...")
            device = get_phone(True)
            if not device.rooted:
                return
            if device:
                exec_cmd = "/data/adb/modules/playintegrityfix/migrate.sh -f"
                debug(f"exec_cmd: {exec_cmd}")
                res = device.exec_cmd(exec_cmd, True)
                if res:
                    print(res)

                self.LoadPif(self.pif_path)
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: device is not accessible.")
                return
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in runMigrate function")
            traceback.print_exc()

    # -----------------------------------------------
    #                  onE2J
    # -----------------------------------------------
    def onE2J(self, event):
        try:
            self._on_spin('start')
            self.console_stc.SetValue(self.P2J(self.console_stc.GetValue()))
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onE2J function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onJ2E
    # -----------------------------------------------
    def onJ2E(self, event):
        try:
            self._on_spin('start')
            self.console_stc.SetValue(self.J2P(self.console_stc.GetValue()))
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onJ2E function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  P2J
    # -----------------------------------------------
    def P2J(self, prop_str, sort_keys=None):
        try:
            if prop_str == '':
                return ''
            if is_valid_json(prop_str):
                # debug(f"Contents is already in json format.")
                return prop_str
            if sort_keys is None:
                sort_keys = self.sort_keys

            contentList = []
            # Split the input string into lines
            lines = re.split(r'\r\n|\n', prop_str)
            for line in lines:
                # Strip whitespace and split by '#' to remove comments
                stripped_line = line.strip().split('#')[0]
                # Check if the line contains an '=' character split into key value pair
                if '=' in stripped_line:
                    key_value_pair = stripped_line.split('=', 1)
                    contentList.append(key_value_pair)

            contentDict = dict(contentList)
            for k, v in contentList:
                for x in v.split('$')[1:]:
                    key = re.findall(r'\w+', x)[0]
                    v = v.replace(f'${key}', contentDict[key])
                contentDict[k] = v.strip()
            return json.dumps(contentDict, indent=4, sort_keys=sort_keys)
        except Exception:
            traceback.print_exc()

    # -----------------------------------------------
    #                  J2P
    # -----------------------------------------------
    def J2P(self, json_str, quiet=False):
        try:
            contentDict = json.loads(json_str)
        except Exception:
            try:
                contentDict = json5.loads(json_str)
            except Exception:
                if not quiet:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Not a valid json.")
                return json_str

        try:
            contentList = []
            for k, v in contentDict.items():
                if v:
                    contentList.append(f"{k}={v}")
            # Ensure Unix line endings
            key_value_format = "\n".join(contentList) + "\n"
            return key_value_format
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in J2P function")
            traceback.print_exc()

    # -----------------------------------------------
    #                  onEditTFTargets
    # -----------------------------------------------
    def onEditTFTargets(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated editing TargetedFix target.txt file.")
        print("==============================================================================")
        if self.tf_target_path:
            # Use the local tf_target.txt file instead of pulling from device
            config_path = get_config_path()
            local_target_file = os.path.join(config_path, 'tmp', 'tf_target.txt')

            # Ensure local file exists
            if not os.path.exists(local_target_file):
                with open(local_target_file, 'w', encoding='utf-8') as f:
                    f.write('')

            res = self.edit_local_file(local_target_file, self.tf_target_path)
            if res == 0:
                self.load_tf_targets()
        if event:
            event.Skip()

    # -----------------------------------------------
    #                  onEditTSTarget
    # -----------------------------------------------
    def onEditTSTarget(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated editing Tricky Store target.txt file.")
        print("==============================================================================")
        self.edit_file("/data/adb/tricky_store/target.txt")
        event.Skip()

    # -----------------------------------------------
    #                  onEditTSSP
    # -----------------------------------------------
    def onEditTSSP(self, event):
        print("\n==============================================================================")
        print(f" {datetime.now():%Y-%m-%d %H:%M:%S} User initiated editing Tricky Store security_patch.txt file.")
        print("==============================================================================")
        self.edit_file("/data/adb/tricky_store/security_patch.txt")
        event.Skip()

    # -----------------------------------------------
    #                  edit_local_file
    # -----------------------------------------------
    def edit_local_file(self, local_file_path, remote_file_path):
        try:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Edit local file: {local_file_path}.")

            # Show the file in the editor
            dlg = FileEditor(self, local_file_path, "text", width=1500, height=600)
            dlg.CenterOnParent()
            result = dlg.ShowModal()
            dlg.Destroy()

            if result == wx.ID_OK:
                # get the contents of modified file
                with open(local_file_path, 'r', encoding='utf-8') as f:
                    contents = f.read()

                # push the file back to the device
                device = get_phone(True)
                if device and device.rooted:
                    res = device.push_file(local_file_path, remote_file_path, True)
                    if res != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while pushing the updated {remote_file_path} file. ...\n")
                        return -1

                    print(f"\nTargetedFix {remote_file_path} file has been modified!")
                    print(f"The updated file:")
                    print(f"___________________________________________________\n{contents}")
                    print("___________________________________________________\n")
                    return 0
            else:
                print(f"User cancelled editing {local_file_path} file.")
                return -1

        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function edit_local_file.")
            traceback.print_exc()
            return -1

    # -----------------------------------------------
    #                  edit_file
    # -----------------------------------------------
    def edit_file(self, filename):
        try:
            print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Edit Tricky Store file: {filename}.")
            device = get_phone(True)
            if not device.rooted:
                return
            self._on_spin('start')
            config_path = get_config_path()
            # get the file portion from full path
            just_filename = os.path.basename(filename)
            ts_target_file = os.path.join(config_path, 'tmp', just_filename)
            # pull the file
            res = device.pull_file(filename, ts_target_file, True)
            if res != 0:
                debug(f"file: {filename} not found,\n")
                # create an empty ts_target_file
                with open(ts_target_file, 'w', encoding='ISO-8859-1', errors="replace") as f:
                    f.write('')
                print(f"An empty local {just_filename} file has been created.")
            # get the contents of the file
            encoding = detect_encoding(ts_target_file)
            with open(ts_target_file, 'r', encoding=encoding, errors="replace") as f:
                contents = f.read()
                self.device_pif = contents

            self._on_spin('stop')
            # Show the file in the editor
            dlg = FileEditor(self, ts_target_file, "text", width=1500, height=600)
            dlg.CenterOnParent()
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_OK:
                # get the contents of modified ts_target_file
                with open(ts_target_file, 'r', encoding='ISO-8859-1', errors="replace") as f:
                    contents = f.read()
                # push the file back to the device
                res = device.push_file(ts_target_file, filename, True)
                if res != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while pushing the updated {filename} file. ...\n")
                    return
                print(f"\nTricky Store {filename} file has been modified!")
                print(f"The updated {filename}:")
                print(f"___________________________________________________\n{contents}")
                print("___________________________________________________\n")
            else:
                print(f"User cancelled editing Tricky Store {filename} file.")
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function edit_file.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onPushKeybox
    # -----------------------------------------------
    def onPushKeybox(self, event):
        try:
            with wx.FileDialog(self, _("Select keybox to push"), '', '', wildcard="Keybox files (*.xml)|*.xml", style=wx.FD_OPEN) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled keybox push.")
                    return
                selected_file = fileDialog.GetPath()

            self._on_spin('start')
            device = get_phone()
            if device:
                # push the file
                res = device.push_file(selected_file, "/data/adb/tricky_store/keybox.xml", True)
                if res != 0:
                    print(f"Return Code: {res.returncode}")
                    print(f"Stdout: {res.stdout}")
                    print(f"Stderr: {res.stderr}")
                    print("Aborting ...\n")
                    return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function onPushKeybox.")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  onDisableUIAutomator
    # -----------------------------------------------
    def onDisableUIAutomator(self, event):
        self.disable_uiautomator_checkbox = event.GetEventObject()
        status = self.disable_uiautomator_checkbox.GetValue()
        print(f"Disable UIAutomator is set to: {status}")
        self.config.pif['disable_uiautomator'] = status

    # -----------------------------------------------
    #                  load_json_with_rules
    # -----------------------------------------------
    def load_json_with_rules(self, json_str, keep_unknown=False):
        try:
            if self.pif_format == 'prop':
                json_data = self.P2J(json_str)
            else:
                json_data = json_str

            if json_str == '':
                return ''

            # Load JSON string into a dictionary
            data = json5.loads(json_data)

            # Define the mapping rules
            mapping_rules = {
                "MANUFACTURER": "ro.product.manufacturer",
                "MODEL": "ro.product.model",
                "FINGERPRINT": "ro.build.fingerprint",
                "BRAND": "ro.product.brand",
                "PRODUCT": "ro.product.name",
                "DEVICE": "ro.product.device",
                "SECURITY_PATCH": "ro.build.version.security_patch",
                "*.security_patch": "ro.build.version.security_patch",
                "FIRST_API_LEVEL": "ro.product.first_api_level",
                "*api_level": "ro.product.first_api_level",
                "BUILD_ID": "ro.build.id",
                "ID": "ro.build.id",
                "VNDK_VERSION": "ro.vndk.version",
                "*.vndk_version": "ro.vndk.version",
                "INCREMENTAL": "ro.build.version.incremental",
                "TYPE": "ro.build.type",
                "TAGS": "ro.build.tags",
                "RELEASE": "ro.build.version.release"
            }

            # Create a new dictionary with the modified keys
            modified_data = {mapping_rules.get(key, key): value for key, value in data.items()}

            # Discard keys with empty values if the keep_unknown is not set
            if not keep_unknown:
                modified_data = {key: value for key, value in modified_data.items() if value != ""}

            return modified_data
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in load_json_with_rules function")
            traceback.print_exc()

    # -----------------------------------------------
    #                  onReProcess
    # -----------------------------------------------
    def onReProcess(self, event):
        try:
            print("Reprocessing Active Pif content ...")
            self._on_spin('start')
            active_pif = self.active_pif_stc.GetValue()
            processed_dict = self.load_json_with_rules(active_pif, self.keep_unknown)
            donor_json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=self.first_api, sort_data=self.sort_keys, keep_all=self.keep_unknown)
            if self.pif_format == 'prop':
                self.console_stc.SetValue(self.J2P(donor_json_string))
            else:
                self.console_stc.SetValue(donor_json_string)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onReProcess function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')
            if event:
                event.Skip()

    # -----------------------------------------------
    #                  onReProcessJsonFiles
    # -----------------------------------------------
    def onReProcessJsonFiles(self, event):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User pressed ReProcess Json File(s)")
        wildcard = "Property files (*.json)|*.json|All files (*.*)|*.*"
        dialog = wx.FileDialog(self, _("Choose one or multiple json files to reprocess"), wildcard=wildcard, style=wx.FD_OPEN | wx.FD_MULTIPLE)

        if dialog.ShowModal() == wx.ID_CANCEL:
            print("User cancelled file selection.")
            return
        paths = dialog.GetPaths()
        dialog.Destroy()

        # debug(f"Selected files: {paths}")
        try:
            self._on_spin('start')
            count = len(paths)
            i = 0
            for pathname in paths:
                i += 1
                debug(f"Reprocessing {i}/{count} {pathname} ...")
                with open(pathname, 'r', encoding='ISO-8859-1', errors="replace") as f:
                    data = json5.load(f)
                json_string = json.dumps(data, indent=4, sort_keys=self.sort_keys)
                processed_dict = self.load_json_with_rules(json_string, self.keep_unknown)
                reprocessed_json_string = process_dict(the_dict=processed_dict, add_missing_keys=self.add_missing_keys_checkbox.IsChecked(), pif_flavor=self.pif_flavor, set_first_api=self.first_api, sort_data=self.sort_keys, keep_all=self.keep_unknown)
                if count == 1:
                    self.console_stc.SetValue(reprocessed_json_string)
                else:
                    with open(pathname, 'w', encoding='ISO-8859-1', errors="replace", newline='\n') as f:
                        f.write(reprocessed_json_string)
                        wx.YieldIfNeeded
        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onReProcessJsonFiles function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')
            if event:
                event.Skip()

    # -----------------------------------------------
    #                  onGetFrameworkPatcherCode
    # -----------------------------------------------
    def onGetFrameworkPatcherCode(self, event):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User pressed onGetFrameworkPatcherCode Json File(s)")
        wildcard = "Property files (*.json)|*.json|All files (*.*)|*.*"
        dialog = wx.FileDialog(self, _("Choose one or multiple json files to reprocess"), wildcard=wildcard, style=wx.FD_OPEN | wx.FD_MULTIPLE)

        if dialog.ShowModal() == wx.ID_CANCEL:
            print("User cancelled file selection.")
            return
        paths = dialog.GetPaths()
        dialog.Destroy()

        # debug(f"Selected files: {paths}")
        try:
            self._on_spin('start')
            count = len(paths)
            i = 0
            all_output_lines = []
            for pathname in paths:
                i += 1
                debug(f"Processing {i}/{count} {pathname} ...")
                with open(pathname, 'r', encoding='ISO-8859-1', errors="replace") as f:
                    data = json5.load(f)

                # Extract and format the relevant key values
                keys_of_interest = ["MANUFACTURER", "MODEL", "FINGERPRINT", "BRAND", "PRODUCT", "DEVICE", "RELEASE", "ID", "INCREMENTAL", "TYPE", "TAGS", "SECURITY_PATCH"]
                output_lines = [
                    "// -------------------------------------------------------------------------------------------------------",
                    f"// // {pathname}"
                ]
                for key in keys_of_interest:
                    value = data.get(key, "")
                    output_lines.append(f'// map.put("{key}", "{value}");')

                all_output_lines.extend(output_lines)

            all_output_lines.append("// -------------------------------------------------------------------------------------------------------")
            final_output_text = "\n".join(all_output_lines)
            if self.pif_format == 'prop':
                self.console_stc.SetValue(self.J2P(final_output_text))
            else:
                self.console_stc.SetValue(final_output_text)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onGetFrameworkPatcherCode function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')
            if event:
                event.Skip()

    # -----------------------------------------------
    #                  onSavePif
    # -----------------------------------------------
    def onSavePif(self, event):
        active_data = self.active_pif_stc.GetValue()
        pif_string = None
        if active_data:
            if self.pif_format == 'prop':
                pif_string = self.P2J(active_data)
            else:
                pif_string = active_data

        pif_json = json5.loads(pif_string)
        manufacturer = ''
        with contextlib.suppress(Exception):
            manufacturer = pif_json['MANUFACTURER']
        if manufacturer == '':
            with contextlib.suppress(Exception):
                manufacturer = pif_json['BRAND']
        device = ''
        with contextlib.suppress(Exception):
            device = pif_json['DEVICE']
        fingerprint = ''
        with contextlib.suppress(Exception):
            fingerprint = pif_json['FINGERPRINT']
        build_id = ''
        if fingerprint != '':
            pattern = r'([^\/]*)\/([^\/]*)\/([^:]*):([^\/]*)\/([^\/]*)\/([^:]*):([^\/]*)\/([^\/]*)$'
            match = re.search(pattern, fingerprint)
            if match and match.lastindex == 8:
                buildid = match[5]

        filename = f"{manufacturer}_{device}_{buildid}.json".replace(' ', '_')
        with wx.FileDialog(self, _("Save FP file"), '', filename, wildcard="Json files (*.json)|*.json", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                print(f"User Cancelled saving pif")
                return     # the user changed their mind
            pathname = fileDialog.GetPath()
            with open(pathname, 'w', encoding='utf-8') as f:
                json.dump(pif_json, f, indent=4)

    # -----------------------------------------------
    #                  onSaveToFavorites
    # -----------------------------------------------
    def onSaveToFavorites(self, event):
        try:
            active_data = self.active_pif_stc.GetValue()
            active_pif = None
            if active_data:
                if self.pif_format == 'prop':
                    active_pif = self.P2J(active_data)
                else:
                    active_pif = active_data

            pif_hash = json_hexdigest(active_pif)
            if pif_hash in self.favorite_pifs:
                # Delete from favorites
                del self.favorite_pifs[pif_hash]
                pif_hash = None
                self.update_combo_box()
                # self.pif_combo_box.SetSelection(-1)
            else:
                # Add to favorites
                active_pif_json = json5.loads(active_pif)
                brand = '[NO BRAND]'
                model = '[NO MODEL]'
                id = ''
                with contextlib.suppress(KeyError):
                    brand = active_pif_json['BRAND']
                with contextlib.suppress(KeyError):
                    model = active_pif_json['MODEL']
                with contextlib.suppress(KeyError):
                    id = active_pif_json['ID']
                label = f"{brand} {model} {id}"

                dialog = wx.TextEntryDialog(None, _("Enter a label:"), _("Save Pif to Favorites"))
                dialog.SetValue(label)
                result = dialog.ShowModal()
                if result == wx.ID_OK:
                    label = dialog.GetValue()
                    print("Label:", label)
                    self.favorite_pifs.setdefault(pif_hash, {})["label"] = label
                    self.favorite_pifs.setdefault(pif_hash, {})["date_added"] = f"{datetime.now():%Y-%m-%d %H:%M:%S}"
                    self.favorite_pifs.setdefault(pif_hash, {})["pif"] = active_pif_json
                    dialog.Destroy()
                elif result == wx.ID_CANCEL:
                    print("Dialog canceled")
                    dialog.Destroy()
                    return

            set_favorite_pifs(self.favorite_pifs)

            with open(get_favorite_pifs_file_path(), "w", encoding='ISO-8859-1', errors="replace") as f:
                json.dump(self.favorite_pifs, f, indent=4)

            # self.update_combo_box(pif_hash)
            self.ActivePifStcChange(None)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onSaveToFavorites function")
            traceback.print_exc()
        if event:
            event.Skip()

    # -----------------------------------------------
    #                  onImportFavorites
    # -----------------------------------------------
    def onImportFavorites(self, e):
        try:
            with wx.DirDialog(self, _("Select folder to Import Pifs"), style=wx.DD_DEFAULT_STYLE) as folderDialog:
                if folderDialog.ShowModal() == wx.ID_CANCEL:
                    print("User cancelled folder selection.")
                    return
                selected_folder = folderDialog.GetPath()

            self._on_spin('start')
            count = 0
            for dirpath, dirnames, filenames in os.walk(selected_folder):
                pif_files = [file for file in filenames if file.endswith(".json")]
                for pif_file in pif_files:
                    with open(os.path.join(dirpath, pif_file), 'r', encoding="ISO-8859-1", errors="replace") as f:
                        data = json5.load(f)
                    with contextlib.suppress(KeyError):
                        brand = data['BRAND']
                    with contextlib.suppress(KeyError):
                        model = data['MODEL']
                    with contextlib.suppress(KeyError):
                        id = data['ID']
                    sp = ''
                    with contextlib.suppress(KeyError):
                        sp = data['SECURITY_PATCH']
                    if sp != '':
                        label = f"{brand} {model} {sp}"
                    else:
                        label = f"{brand} {model} {id}"
                    pif_data = json.dumps(data, indent=4)
                    pif_hash = json_hexdigest(pif_data)
                    # Add to favorites
                    print(f"Importing: {label} ...")
                    count += 1
                    self.favorite_pifs.setdefault(pif_hash, {})["label"] = label
                    self.favorite_pifs.setdefault(pif_hash, {})["date_added"] = f"{datetime.now():%Y-%m-%d %H:%M:%S}"
                    self.favorite_pifs.setdefault(pif_hash, {})["pif"] = json.loads(pif_data)
                    wx.YieldIfNeeded()
            print(f"Processed {count} pifs.")

            set_favorite_pifs(self.favorite_pifs)
            with open(get_favorite_pifs_file_path(), "w", encoding='ISO-8859-1', errors="replace") as f:
                json.dump(self.favorite_pifs, f, indent=4)

            # self.update_combo_box(pif_hash)
            self.update_combo_box(None)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in onImportFavorites function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        self._last_call_was_on_spin = True
        wx.YieldIfNeeded()
        if state == 'start':
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
            wx.Yield()
            self.Parent._on_spin('start')
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            wx.Yield()
            self.Parent._on_spin('stop')

    # -----------------------------------------------
    #                  onResize
    # -----------------------------------------------
    def onResize(self, event):
        self.resizing = True
        stc_size = self.active_pif_stc.GetSize()
        x = stc_size.GetWidth()
        if not self._last_call_was_on_spin:
            self.active_pif_stc.SetScrollWidth(x - 60)
        self._last_call_was_on_spin = False
        self.console_stc.SetScrollWidth(x - 60)

        self.Layout()
        if event:
            event.Skip(True)

    # -----------------------------------------------
    #                  toast
    # -----------------------------------------------
    def toast(self, title, message):
        if self.config.show_notifications:
            notification = wx.adv.NotificationMessage(title, message, parent=None, flags=wx.ICON_INFORMATION)
            notification.SetIcon(images.Icon_dark_256.GetIcon())
            notification.Show()

    # -----------------------------------------------
    #                  calculate_combo_width
    # -----------------------------------------------
    def calculate_combo_width(self, combo_box):
        try:
            if combo_box.GetCount() == 0:
                # Let wx handle default size
                return -1

            # Get the device context to measure text
            dc = wx.ClientDC(combo_box)
            dc.SetFont(combo_box.GetFont())

            max_width = 0
            # Measure each item in the combo box
            for i in range(combo_box.GetCount()):
                text = combo_box.GetString(i)
                text_width, _ = dc.GetTextExtent(text)
                max_width = max(max_width, text_width)

            # Add some padding for the dropdown arrow and margins
            # Typical padding: 20px for dropdown arrow + 20px for margins
            optimal_width = max_width + 40

            # Set a reasonable minimum (80px) and maximum (400px)
            optimal_width = max(80, min(optimal_width, 400))

            return optimal_width
        except Exception:
            return -1  # Fallback to default sizing

    # -----------------------------------------------
    #                  update_combo_size
    # -----------------------------------------------
    def update_combo_size(self, combo_box):
        try:
            width = self.calculate_combo_width(combo_box)
            if width > 0:
                current_size = combo_box.GetSize()
                combo_box.SetMinSize((width, current_size.height))
                combo_box.SetSize((width, current_size.height))
                # Force layout update
                self.Layout()
        except Exception:
            # Ignore errors, keep default sizing
            pass

    # -----------------------------------------------
    #                  update_tf_button_states
    # -----------------------------------------------
    def update_tf_button_states(self):
        try:
            selected_text = self.tf_targets_combo.GetStringSelection()
            has_valid_target = selected_text and selected_text != _("TF Targets")
            has_targets = self.tf_targets_combo.GetCount() > 0 and not (self.tf_targets_combo.GetCount() == 1 and self.tf_targets_combo.GetString(0) == _("TF Targets"))

            self.tf_add_target_button.Enable(True)
            if has_valid_target:
                self.tf_delete_target_button.Enable(has_valid_target)
                self.tf_edit_targets_button.Enable(True)

                # Push Json enabled when target selected and active_pif has valid content
                active_data = self.active_pif_stc.GetValue().strip()
                has_valid_json = False
                if active_data:
                    try:
                        if self.pif_format == 'prop':
                            json_data = self.P2J(active_data)
                        else:
                            json_data = active_data
                        if json_data:
                            json.loads(json_data)
                            has_valid_json = True
                    except:
                        try:
                            json5.loads(json_data if 'json_data' in locals() else active_data)
                            has_valid_json = True
                        except:
                            has_valid_json = False
                self.tf_push_json_button.Enable(has_valid_json)
            else:
                self.tf_push_json_button.Enable(False)

        except Exception:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in update_tf_button_states function")
            traceback.print_exc()
        finally:
            self._on_spin('stop')

```

`pyi-hooks-arm64/hook-wx.py`:

```py
#
# Copyright (C) 2026 Badabing2005
# SPDX-FileCopyrightText: 2026 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

# -*- coding: utf-8 -*-
"""
PyInstaller hook for wxPython on Windows ARM64.

This hook forces collection of the entire wx package including ARM64 .pyd files
that PyInstaller cannot analyze when running on x64 hardware.
"""

from PyInstaller.utils.hooks import collect_all, collect_dynamic_libs
import sys
import os

# Find wx without importing it (since ARM64 .pyd can't load on x64)
# Get site-packages path from sys.path
site_packages = None
for path in sys.path:
    if 'site-packages' in path:
        site_packages = path
        break

if not site_packages:
    # Fallback: construct from sys.executable
    site_packages = os.path.join(os.path.dirname(sys.executable), 'Lib', 'site-packages')

wx_dir = os.path.join(site_packages, 'wx')

# Collect all wx files - both as datas and binaries
# This ensures ARM64 .pyd files are included even though they can't be analyzed
binaries = []
datas = []

# Manually collect all files from wx directory if it exists
if os.path.exists(wx_dir):
    for root, dirs, files in os.walk(wx_dir):
        for file in files:
            full_path = os.path.join(root, file)
            # Calculate relative path for destination
            rel_path = os.path.relpath(root, site_packages)
            
            # .pyd files go to binaries, everything else to datas
            if file.endswith('.pyd') or file.endswith('.dll'):
                binaries.append((full_path, rel_path))
            else:
                datas.append((full_path, rel_path))
    
    print(f"ARM64 Hook: Collected wx from {wx_dir}")
    print(f"ARM64 Hook: Found {len(binaries)} binary files")
    print(f"ARM64 Hook: Found {len(datas)} data files")
else:
    print(f"ARM64 Hook: WARNING - wx directory not found at {wx_dir}")
    # Try fallback using collect functions
    binaries = collect_dynamic_libs('wx')
    datas = collect_all('wx')
    print(f"ARM64 Hook (fallback): Found {len(binaries)} binary files")
    print(f"ARM64 Hook (fallback): Found {len(datas)} data files")

```

`requirements.txt`:

```txt
attrdict3>=2.0.2
PyInstaller>=5.9.0
httplib2>=0.21.0
pyinstaller-versionfile>=2.1.1
platformdirs==3.6.0
requests>=2.28.1
darkdetect>=0.7.1
markdown>=3.4.1
pyperclip>=1.8.2
protobuf~=6.31.1; python_version >= "3.9"
protobuf~=4.25.8; python_version == "3.8"
six>=1.16.0
bsdiff4>=1.1.5
lz4>=4.3.2
psutil>=5.9.5
json5>=0.9.14
bs4>=0.0.1
chardet>=5.2.0
cryptography>=42.0.5
rsa>=4.9
polib>=1.1.1
# Use pre-built wheels for wxPython
--find-links https://wxpython.org/Phoenix/snapshot-builds/
--find-links https://extras.wxpython.org/wxPython4/extras/linux/gtk3/ubuntu-20.04/
--find-links https://extras.wxpython.org/wxPython4/extras/linux/gtk3/ubuntu-22.04/
--find-links https://extras.wxpython.org/wxPython4/extras/linux/gtk3/ubuntu-24.04/
wxPython==4.2.2
# wxPython==4.2.1; platform_system == "Linux"
# wxPython>=4.2.1; platform_system != "Linux"

```

`runtime.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import apk
import binascii
import contextlib
import chardet
import fnmatch
import hashlib
import html
import io
import json
import json5
import math
import ntpath
import os
import re
import shutil
import signal
import sqlite3 as sl
import subprocess
import sys
import random
import tarfile
import tempfile
import threading
import time
import traceback
import zipfile
import psutil
import xml.etree.ElementTree as ET
import urllib3
import warnings
from datetime import datetime, timezone, timedelta
from os import path
from urllib.parse import urlparse
import xml.etree.ElementTree as ET
from bs4 import BeautifulSoup
from cryptography import x509
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa, ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from i18n import _, set_language
import lz4.frame
import requests
import wx
from packaging.version import parse
from platformdirs import *
from constants import *
from payload_dumper import extract_payload
from ksu_asset_selector import show_ksu_asset_selector
import cProfile, pstats, io
import avbtool

app_language = 'en'  # Default language is English
_verbose = False
_adb = None
_fastboot = None
_adb_sha256 = None
_fastboot_sha256 = None
_phones = []
_device_list = []
_phone_id = None
# _advanced_options = False
# _update_check = True
_firmware_model = None
_firmware_id = None
_custom_rom_id = None
_logfile = None
_pumlfile = None
_sdk_version = None
_image_mode = None
_image_path = None
_custom_rom_file = None
_message_box_title = None
_message_box_message = None
# _version = None
_db = None
_boot = None
_system_code_page = None
# _codepage_setting = False
# _codepage_value = ''
_magisk_package = ''
# _file_explorer = ''
_linux_shell = ''
_patched_with = ''
# _customize_font = False
# _pf_font_face = ''
# _pf_font_size = 12
_app_labels = {}
_xiaomi_list = {}
_favorite_pifs = {}
_a_only = False
# _offer_patch_methods = False
# _use_busybox_shell = False
_firmware_hash_valid = False
_firmware_has_init_boot = False
_rom_has_init_boot = False
_dlg_checkbox_values = None
# _recovery_patch = False
_config_path = None
_android_versions = {}
_android_devices = {}
_env_variables = os.environ.copy()
_is_ota = False
_sdk_is_ok = False
_low_memory = False
_config = {}
_config_file_path = ''
_unlocked_devices = []
_window_shown = False
_puml_enabled = True
_rooting_app_apks = None
_selected_boot_partition = None


# ============================================================================
#                               Class Boot
# ============================================================================
class Boot():
    def __init__(self):
        self.boot_id = None
        self.boot_hash = None
        self.boot_path = None
        self.is_patched = None
        self.patch_method = None
        self.magisk_version = None
        self.hardware = None
        self.boot_epoch = None
        self.package_id = None
        self.package_boot_hash = None
        self.package_type = None
        self.package_sig = None
        self.package_path = None
        self.package_epoch = None
        self.is_odin = None
        self.is_stock_boot = None
        self.is_init_boot = None
        self.patch_source_sha1 = None
        self.spl = None


# ============================================================================
#                               Class BetaData
# ============================================================================
class BetaData:
    def __init__(self, release_date, build, emulator_support, security_patch_level, google_play_services, beta_expiry_date, incremental, security_patch, devices):
        self.release_date = release_date
        self.build = build
        self.emulator_support = emulator_support
        self.security_patch_level = security_patch_level
        self.google_play_services = google_play_services
        self.beta_expiry_date = beta_expiry_date
        self.incremental = incremental
        self.security_patch = security_patch
        self.devices = devices


# ============================================================================
#                               Class Coords
# ============================================================================
class Coords:
    def __init__(self):
        self.file_path = get_coords_file_path()
        self.data = self.load_data()

    def load_data(self):
        with contextlib.suppress(Exception):
            if path.exists(self.file_path):
                with open(self.file_path, "r", encoding='ISO-8859-1', errors="replace") as file:
                    return json.load(file)
        return {}

    def save_data(self):
        with open(self.file_path, 'w', encoding='ISO-8859-1', errors="replace", newline='\n') as file:
            json.dump(self.data, file, indent=4)

    def query_entry(self, device, package):
        if device in self.data and package in self.data[device]:
            return self.data[device][package]
        return None

    def query_nested_entry(self, device, package, nested_key):
        if device in self.data and package in self.data[device] and nested_key in self.data[device][package]:
            return self.data[device][package][nested_key]
        return None

    def update_entry(self, device, package, coordinates):
        if device not in self.data:
            self.data[device] = {}
        self.data[device][package] = coordinates
        self.save_data()

    def update_nested_entry(self, device, package, nested_key, nested_value):
        if device not in self.data:
            self.data[device] = {}
        if package not in self.data[device]:
            self.data[device][package] = {}
        self.data[device][package][nested_key] = nested_value
        self.save_data()


# ============================================================================
#                               Class ModuleUpdate
# ============================================================================
class ModuleUpdate():
    def __init__(self, url):
        self.url = url


# ============================================================================
#                               Class MagiskApk
# ============================================================================
class MagiskApk():
    def __init__(self, type):
        self.type = type


# ============================================================================
#                               Class DownloadState
# ============================================================================
class DownloadState:
    def __init__(self):
        self.stop_event = threading.Event()
        self.downloaded_bytes = 0
        self.file_size = 0
        self.download_complete = False
        self.fingerprint = None
        self.security_patch = None


# ============================================================================
#                               Function get_app_language
# ============================================================================
def get_app_language():
    global _app_language
    return _app_language


# ============================================================================
#                               Function set_app_language
# ============================================================================
def set_app_language(value):
    global _app_language
    _app_language = value
    # Update the actual translation system
    set_language(value)

# ============================================================================
#                               Function get_config
# ============================================================================
def get_config():
    global _config
    return _config


# ============================================================================
#                               Function set_config
# ============================================================================
def set_config(value):
    global _config
    _config = value


# ============================================================================
#                               Function get_window_shown
# ============================================================================
def get_window_shown():
    global _window_shown
    return _window_shown


# ============================================================================
#                               Function set_window_shown
# ============================================================================
def set_window_shown(value):
    global _window_shown
    _window_shown = value


# ============================================================================
#                               Function check_for_unlocked
# ============================================================================
def check_for_unlocked(item):
    global _unlocked_devices
    if item in _unlocked_devices:
        return True
    else:
        return False


# ============================================================================
#                               Function add_unlocked_device
# ============================================================================
def add_unlocked_device(item):
    global _unlocked_devices
    if item not in _unlocked_devices:
        _unlocked_devices.append(item)


# ============================================================================
#                               Function remove_unlocked_device
# ============================================================================
def remove_unlocked_device(item):
    global _unlocked_devices
    if item in _unlocked_devices:
        _unlocked_devices.remove(item)


# ============================================================================
#                               Function get_unlocked_device
# ============================================================================
def get_unlocked_device():
    global _unlocked_devices
    return _unlocked_devices


# ============================================================================
#                               Function set_console_widget
# ============================================================================
def set_console_widget(widget):
    global _console_widget
    _console_widget = widget


# ============================================================================
#                               Function flush_output
# ============================================================================
def flush_output():
    global _console_widget
    if get_window_shown():
        wx.YieldIfNeeded()
    if _console_widget:
        sys.stdout.flush()
        wx.CallAfter(_console_widget.Update)
        if get_window_shown():
            wx.YieldIfNeeded()


# ============================================================================
#                               Function get_boot
# ============================================================================
def get_boot():
    global _boot
    return _boot


# ============================================================================
#                               Function set_boot
# ============================================================================
def set_boot(value):
    global _boot
    _boot = value


# ============================================================================
#                               Function get_labels
# ============================================================================
def get_labels():
    global _app_labels
    return _app_labels


# ============================================================================
#                               Function set_labels
# ============================================================================
def set_labels(value):
    global _app_labels
    _app_labels = value


# ============================================================================
#                               Function get_xiaomi
# ============================================================================
def get_xiaomi():
    global _xiaomi_list
    return _xiaomi_list


# ============================================================================
#                               Function set_xiaomi
# ============================================================================
def set_xiaomi(value):
    global _xiaomi_list
    _xiaomi_list = value


# ============================================================================
#                               Function get_favorite_pifs
# ============================================================================
def get_favorite_pifs():
    global _favorite_pifs
    return _favorite_pifs


# ============================================================================
#                               Function set_favorite_pifs
# ============================================================================
def set_favorite_pifs(value):
    global _favorite_pifs
    _favorite_pifs = value


# ============================================================================
#                               Function get_low_memory
# ============================================================================
def get_low_memory():
    global _low_memory
    return _low_memory


# ============================================================================
#                               Function set_low_memory
# ============================================================================
def set_low_memory(value):
    global _low_memory
    _low_memory = value


# ============================================================================
#                               Function get_android_versions
# ============================================================================
def get_android_versions():
    global _android_versions
    return _android_versions


# ============================================================================
#                               Function set_android_versions
# ============================================================================
def set_android_versions(value):
    global _android_versions
    _android_versions = value


# ============================================================================
#                               Function get_android_devices
# ============================================================================
def get_android_devices():
    global _android_devices
    return _android_devices


# ============================================================================
#                               Function set_android_devices
# ============================================================================
def set_android_devices(value):
    global _android_devices
    _android_devices = value


# ============================================================================
#                               Function get_env_variables
# ============================================================================
def get_env_variables():
    global _env_variables
    return _env_variables


# ============================================================================
#                               Function set_env_variables
# ============================================================================
def set_env_variables(value):
    global _env_variables
    _env_variables = value


# ============================================================================
#                               Function get_patched_with
# ============================================================================
def get_patched_with():
    global _patched_with
    return _patched_with


# ============================================================================
#                               Function set_patched_with
# ============================================================================
def set_patched_with(value):
    global _patched_with
    _patched_with = value


# ============================================================================
#                               Function get_db
# ============================================================================
def get_db():
    global _db
    return _db


# ============================================================================
#                               Function set_db
# ============================================================================
def set_db(value):
    global _db
    _db = value


# ============================================================================
#                               Function get_boot_images_dir
# ============================================================================
def get_boot_images_dir():
    # boot_images did not change at version 5, so we can keep on using 4
    if parse(VERSION) < parse('4.0.0'):
        return 'boot_images'
    else:
        return 'boot_images4'


# ============================================================================
#                               Function get_factory_images_dir
# ============================================================================
def get_factory_images_dir():
    # factory_images only changed after version 5
    if parse(VERSION) < parse('9.0.0'):
        return 'factory_images'
    else:
        return 'factory_images9'


# ============================================================================
#                               Function get_pf_db
# ============================================================================
def get_pf_db():
    # we have different db schemas for each of these versions
    if parse(VERSION) < parse('4.0.0'):
        return 'PixelFlasher.db'
    elif parse(VERSION) < parse('99.0.0'):
        return 'PixelFlasher4.db'
    else:
        return 'PixelFlasher99.db'


# ============================================================================
#                               Function get_verbose
# ============================================================================
def get_verbose():
    global _verbose
    return _verbose


# ============================================================================
#                               Function set_verbose
# ============================================================================
def set_verbose(value):
    global _verbose
    _verbose = value


# ============================================================================
#                               Function get_a_only
# ============================================================================
def get_a_only():
    global _a_only
    return _a_only


# ============================================================================
#                               Function set_a_only
# ============================================================================
def set_a_only(value):
    global _a_only
    _a_only = value


# ============================================================================
#                   Function get_selected_boot_partition
# ============================================================================
def get_selected_boot_partition():
    global _selected_boot_partition
    return _selected_boot_partition


# ============================================================================
#                   Function set_selected_boot_partition
# ============================================================================
def set_selected_boot_partition(value):
    global _selected_boot_partition
    _selected_boot_partition = value


# ============================================================================
#                               Function get_adb
# ============================================================================
def get_adb():
    global _adb
    return _adb


# ============================================================================
#                               Function set_adb
# ============================================================================
def set_adb(value):
    global _adb
    _adb = value


# ============================================================================
#                               Function get_puml_state
# ============================================================================
def get_puml_state():
    global _puml_enabled
    return _puml_enabled


# ============================================================================
#                               Function set_puml_state
# ============================================================================
def set_puml_state(value):
    global _puml_enabled
    _puml_enabled = value


# ============================================================================
#                               Function get_fastboot
# ============================================================================
def get_fastboot():
    global _fastboot
    return _fastboot


# ============================================================================
#                               Function set_fastboot
# ============================================================================
def set_fastboot(value):
    global _fastboot
    _fastboot = value


# ============================================================================
#                               Function get_adb_sha256
# ============================================================================
def get_adb_sha256():
    global _adb_sha256
    return _adb_sha256


# ============================================================================
#                               Function set_adb_sha256
# ============================================================================
def set_adb_sha256(value):
    global _adb_sha256
    _adb_sha256 = value


# ============================================================================
#                               Function get_fastboot_sha256
# ============================================================================
def get_fastboot_sha256():
    global _fastboot_sha256
    return _fastboot_sha256


# ============================================================================
#                               Function set_fastboot_sha256
# ============================================================================
def set_fastboot_sha256(value):
    global _fastboot_sha256
    _fastboot_sha256 = value


# ============================================================================
#                               Function get_phones
# ============================================================================
def get_phones():
    global _phones
    return _phones


# ============================================================================
#                               Function set_phones
# ============================================================================
def set_phones(value):
    global _phones
    _phones = value


# ============================================================================
#                               Function get_device_list
# ============================================================================
def get_device_list():
    global _device_list
    return _device_list


# ============================================================================
#                               Function set_device_list
# ============================================================================
def set_device_list(value):
    global _device_list
    _device_list = value


# ============================================================================
#                               Function get_phone_id
# ============================================================================
def get_phone_id():
    global _phone_id
    return _phone_id


# ============================================================================
#                               Function set_phone_id
# ============================================================================
def set_phone_id(value):
    global _phone_id
    _phone_id = value


# ============================================================================
#                               Function get_phone
# ============================================================================
def get_phone(make_sure_connected=False):
    devices = get_phones()
    phone_id = get_phone_id()
    if phone_id and devices:
        for phone in devices:
            if phone.id == phone_id:
                if make_sure_connected and not phone.is_connected(phone_id):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device: {phone_id} is not connected.")
                    return None
                return phone


# ============================================================================
#                               Function get_system_codepage
# ============================================================================
def get_system_codepage():
    global _system_code_page
    return _system_code_page


# ============================================================================
#                               Function set_system_codepage
# ============================================================================
def set_system_codepage(value):
    global _system_code_page
    _system_code_page = value


# ============================================================================
#                               Function get_magisk_package
# ============================================================================
def get_magisk_package():
    global _magisk_package
    return _magisk_package


# ============================================================================
#                               Function set_magisk_package
# ============================================================================
def set_magisk_package(value):
    global _magisk_package
    _magisk_package = value


# ============================================================================
#                               Function get_linux_shell
# ============================================================================
def get_linux_shell():
    global _linux_shell
    return _linux_shell


# ============================================================================
#                               Function set_linux_shell
# ============================================================================
def set_linux_shell(value):
    global _linux_shell
    _linux_shell = value


# ============================================================================
#                               Function get_is_ota
# ============================================================================
def get_ota():
    global _is_ota
    return _is_ota


# ============================================================================
#                               Function set_ota
# ============================================================================
def set_ota(self, value):
    global _is_ota
    _is_ota = value
    self.config.firmware_is_ota = value
    if value:
        self.enable_disable_radio_button('OTA', True, selected=True, just_select=True)
        self.config.flash_mode = 'OTA'
    elif self.config.flash_mode == 'OTA':
            self.config.flash_mode = 'dryRun'
            self.enable_disable_radio_button('dryRun', True, selected=True, just_select=True)


# ============================================================================
#                               Function get_sdk_state
# ============================================================================
def get_sdk_state():
    global _sdk_is_ok
    return _sdk_is_ok


# ============================================================================
#                               Function set_sdk_state
# ============================================================================
def set_sdk_state(value):
    global _sdk_is_ok
    _sdk_is_ok = value


# ============================================================================
#                               Function get_firmware_hash_validity
# ============================================================================
def get_firmware_hash_validity():
    global _firmware_hash_valid
    return _firmware_hash_valid


# ============================================================================
#                               Function set_firmware_hash_validity
# ============================================================================
def set_firmware_hash_validity(value):
    global _firmware_hash_valid
    _firmware_hash_valid = value


# ============================================================================
#                               Function get_firmware_has_init_boot
# ============================================================================
def get_firmware_has_init_boot():
    global _firmware_has_init_boot
    return _firmware_has_init_boot


# ============================================================================
#                               Function set_firmware_has_init_boot
# ============================================================================
def set_firmware_has_init_boot(value):
    global _firmware_has_init_boot
    _firmware_has_init_boot = value


# ============================================================================
#                               Function get_rom_has_init_boot
# ============================================================================
def get_rom_has_init_boot():
    global _rom_has_init_boot
    return _rom_has_init_boot


# ============================================================================
#                               Function set_rom_has_init_boot
# ============================================================================
def set_rom_has_init_boot(value):
    global _rom_has_init_boot
    _rom_has_init_boot = value


# ============================================================================
#                               Function get_dlg_checkbox_values
# ============================================================================
def get_dlg_checkbox_values():
    global _dlg_checkbox_values
    return _dlg_checkbox_values


# ============================================================================
#                               Function set_dlg_checkbox_values
# ============================================================================
def set_dlg_checkbox_values(value):
    global _dlg_checkbox_values
    _dlg_checkbox_values = value


# ============================================================================
#                               Function get_firmware_model
# ============================================================================
def get_firmware_model():
    global _firmware_model
    return _firmware_model


# ============================================================================
#                               Function set_firmware_model
# ============================================================================
def set_firmware_model(value):
    global _firmware_model
    _firmware_model = value


# ============================================================================
#                               Function get_firmware_id
# ============================================================================
def get_firmware_id():
    global _firmware_id
    return _firmware_id


# ============================================================================
#                               Function set_firmware_id
# ============================================================================
def set_firmware_id(value):
    global _firmware_id
    _firmware_id = value


# ============================================================================
#                               Function get_custom_rom_id
# ============================================================================
def get_custom_rom_id():
    global _custom_rom_id
    return _custom_rom_id


# ============================================================================
#                               Function set_custom_rom_id
# ============================================================================
def set_custom_rom_id(value):
    global _custom_rom_id
    _custom_rom_id = value


# ============================================================================
#                               Function get_logfile
# ============================================================================
def get_logfile():
    global _logfile
    return _logfile


# ============================================================================
#                               Function set_logfile
# ============================================================================
def set_logfile(value):
    global _logfile
    _logfile = value


# ============================================================================
#                               Function get_pumlfile
# ============================================================================
def get_pumlfile():
    global _pumlfile
    return _pumlfile


# ============================================================================
#                               Function set_pumlfile
# ============================================================================
def set_pumlfile(value):
    global _pumlfile
    _pumlfile = value


# ============================================================================
#                               Function get_sdk_version
# ============================================================================
def get_sdk_version():
    global _sdk_version
    return _sdk_version


# ============================================================================
#                               Function set_sdk_version
# ============================================================================
def set_sdk_version(value):
    global _sdk_version
    _sdk_version = value


# ============================================================================
#                               Function get_image_mode
# ============================================================================
def get_image_mode():
    global _image_mode
    return _image_mode


# ============================================================================
#                               Function set_image_mode
# ============================================================================
def set_image_mode(value):
    global _image_mode
    _image_mode = value


# ============================================================================
#                               Function get_image_path
# ============================================================================
def get_image_path():
    global _image_path
    return _image_path


# ============================================================================
#                               Function set_image_path
# ============================================================================
def set_image_path(value):
    global _image_path
    _image_path = value


# ============================================================================
#                               Function get_custom_rom_file
# ============================================================================
def get_custom_rom_file():
    global _custom_rom_file
    return _custom_rom_file


# ============================================================================
#                               Function set_custom_rom_file
# ============================================================================
def set_custom_rom_file(value):
    global _custom_rom_file
    _custom_rom_file = value


# ============================================================================
#                               Function get_message_box_title
# ============================================================================
def get_message_box_title():
    global _message_box_title
    return _message_box_title


# ============================================================================
#                               Function set_message_box_title
# ============================================================================
def set_message_box_title(value):
    global _message_box_title
    _message_box_title = value


# ============================================================================
#                               Function get_message_box_message
# ============================================================================
def get_message_box_message():
    global _message_box_message
    return _message_box_message


# ============================================================================
#                               Function set_message_box_message
# ============================================================================
def set_message_box_message(value):
    global _message_box_message
    _message_box_message = value


# ============================================================================
#                               Function get_downgrade_boot_path
# ============================================================================
def get_downgrade_boot_path():
    boot = get_boot()
    if not boot:
        return None, False

    boot_path = boot.boot_path
    directory_path = os.path.dirname(boot_path)
    downgrade_file_name = "downgrade_boot.img"
    downgrade_file_path = os.path.join(directory_path, downgrade_file_name)
    if os.path.exists(downgrade_file_path):
        return downgrade_file_path, True
    else:
        return downgrade_file_path, False


# ============================================================================
#                               Function has_init_boot
# ============================================================================
def has_init_boot(device_codename):
    try:
        android_devices = get_android_devices()
        if not android_devices or device_codename not in android_devices:
            return False
        return android_devices[device_codename]['has_init_boot']
    except Exception as e:
        return False


# ============================================================================
#                               Function is_pixel_watch
# ============================================================================
def is_pixel_watch(device_codename):
    try:
        android_devices = get_android_devices()
        if not android_devices or device_codename not in android_devices:
            return False
        return android_devices[device_codename]['is_pixel_watch']
    except Exception as e:
        return False


# ============================================================================
#                               Function puml
# ============================================================================
def puml(message='', left_ts = False, mode='a'):
    if get_puml_state():
        with open(get_pumlfile(), mode, encoding="ISO-8859-1", errors="replace") as puml_file:
            puml_file.write(message)
            if left_ts:
                puml_file.write(f"note left:{datetime.now():%Y-%m-%d %H:%M:%S}\n")


# ============================================================================
#                               Function init_config_path
# ============================================================================
def init_config_path(config_file_path=''):
    try:
        config_path = get_sys_config_path()
        set_config_path(config_path)
        with contextlib.suppress(Exception):
            if config_file_path == '':
                config_file_path = os.path.join(config_path, CONFIG_FILE_NAME)
            print(f"config_file_path: {config_file_path}")
            set_config_file_path(config_file_path)
            if os.path.exists(config_file_path):
                encoding = detect_encoding(config_file_path)
                with open(config_file_path, 'r', encoding=encoding, errors="replace") as f:
                    data = json.load(f)
                pf_home = data['pf_home']
                if pf_home and os.path.exists(pf_home):
                    set_config_path(pf_home)
        config_path = get_config_path()
        directories = ['logs', 'factory_images', get_boot_images_dir(), 'tmp', 'puml']
        for directory in directories:
            full_path = os.path.join(config_path, directory)
            if not os.path.exists(full_path):
                os.makedirs(full_path, exist_ok=True)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while init_config_path")
        traceback.print_exc()


# ============================================================================
#                               Function init_db
# ============================================================================
def init_db():
    try:
        global _db
        config_path = get_sys_config_path()
        # connect / create db
        _db = sl.connect(os.path.join(config_path, get_pf_db()))
        _db.execute("PRAGMA foreign_keys = ON")
        # create tables
        with _db:
            # PACKAGE Table
            _db.execute("""
                CREATE TABLE IF NOT EXISTS PACKAGE (
                    id INTEGER NOT NULL PRIMARY KEY,
                    boot_hash TEXT NOT NULL,
                    type TEXT CHECK (type IN ('firmware', 'rom')) NOT NULL,
                    package_sig TEXT NOT NULL,
                    file_path TEXT NOT NULL UNIQUE,
                    epoch INTEGER NOT NULL
                );
            """)
            # BOOT Table
            _db.execute("""
                CREATE TABLE IF NOT EXISTS BOOT (
                    id INTEGER NOT NULL PRIMARY KEY,
                    boot_hash TEXT NOT NULL UNIQUE,
                    file_path TEXT NOT NULL,
                    is_patched INTEGER CHECK (is_patched IN (0, 1)),
                    magisk_version TEXT,
                    hardware TEXT,
                    epoch INTEGER NOT NULL,
                    patch_method TEXT
                );
            """)
            # PACKAGE_BOOT Table
            _db.execute("""
                CREATE TABLE IF NOT EXISTS PACKAGE_BOOT (
                    package_id INTEGER,
                    boot_id INTEGER,
                    epoch INTEGER NOT NULL,
                    PRIMARY KEY (package_id, boot_id),
                    FOREIGN KEY (package_id) REFERENCES PACKAGE(id),
                    FOREIGN KEY (boot_id) REFERENCES BOOT(id)
                );
            """)

            # Check if the patch_method and is_odin column already exists in the BOOT table
            # Added in version 5.1
            cursor = _db.execute("PRAGMA table_info(BOOT)")
            columns = cursor.fetchall()
            column_names = [column[1] for column in columns]

            if 'patch_method' not in column_names:
                # Add the patch_method column to the BOOT table
                _db.execute("ALTER TABLE BOOT ADD COLUMN patch_method TEXT;")
            if 'is_odin' not in column_names:
                # Add the is_odin column to the BOOT table
                _db.execute("ALTER TABLE BOOT ADD COLUMN is_odin INTEGER;")
            # Added in version 5.4
            if 'is_stock_boot' not in column_names:
                # Add the is_stock_boot column to the BOOT table
                _db.execute("ALTER TABLE BOOT ADD COLUMN is_stock_boot INTEGER;")
            if 'is_init_boot' not in column_names:
                # Add the is_init_boot column to the BOOT table
                _db.execute("ALTER TABLE BOOT ADD COLUMN is_init_boot INTEGER;")
            if 'patch_source_sha1' not in column_names:
                # Add the patch_source_sha1 column to the BOOT table
                _db.execute("ALTER TABLE BOOT ADD COLUMN patch_source_sha1 INTEGER;")

            # Check if the full_ota column already exists in the PACKAGE table
            # Added in version 5.8
            cursor = _db.execute("PRAGMA table_info(PACKAGE)")
            columns = cursor.fetchall()
            column_names = [column[1] for column in columns]

            if 'full_ota' not in column_names:
                # Add the full_ota column to the BOOT table (values: 0:Not Full OTA, 1:Full OTA NULL:UNKNOWN)
                _db.execute("ALTER TABLE PACKAGE ADD COLUMN full_ota INTEGER;")
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while init_db")
        traceback.print_exc()


# ============================================================================
#                               Function get_config_file_path
# ============================================================================
def get_config_file_path():
    # return os.path.join(get_sys_config_path(), CONFIG_FILE_NAME).strip()
    global _config_file_path
    return _config_file_path


# ============================================================================
#                           Function set_config
# ============================================================================
def set_config_file_path(value):
    global _config_file_path
    _config_file_path = value


# ============================================================================
#                       Function get_sys_config_path
# ============================================================================
def get_sys_config_path():
    return user_data_dir(APPNAME, appauthor=False, roaming=True)


# ============================================================================
#                         Function get_config_path
# ============================================================================
def get_config_path():
    global _config_path
    return _config_path


# ============================================================================
#                       Function set_config_path
# ============================================================================
def set_config_path(value):
    global _config_path
    _config_path = value


# ============================================================================
#                      Function get_labels_file_path
# ============================================================================
def get_labels_file_path():
    return os.path.join(get_config_path(), "labels.json").strip()


# ============================================================================
#                     Function get_xiaomi_file_path
# ============================================================================
def get_xiaomi_file_path():
    return os.path.join(get_config_path(), "xiaomi.json").strip()


# ============================================================================
#                    Function get_favorite_pifs_file_path
# ============================================================================
def get_favorite_pifs_file_path():
    return os.path.join(get_config_path(), "favorite_pifs.json").strip()


# ============================================================================
#                 Function get_device_images_history_file_path
# ============================================================================
def get_device_images_history_file_path():
    return os.path.join(get_config_path(), "device_images_history.json").strip()


# ============================================================================
#                        Function get_coords_file_path
# ============================================================================
def get_coords_file_path():
    return os.path.join(get_config_path(), "coords.json").strip()


# ============================================================================
#                        Function get_skip_urls_file_path
# ============================================================================
def get_skip_urls_file_path():
    return os.path.join(get_config_path(), "skip_urls.txt").strip()


# ============================================================================
#                        Function get_wifi_history_file_path
# ============================================================================
def get_wifi_history_file_path():
    return os.path.join(get_config_path(), "wireless.json").strip()


# ============================================================================
#                        Function get_mytools_file_path
# ============================================================================
def get_mytools_file_path():
    return os.path.join(get_config_path(), "mytools.json").strip()


# ============================================================================
#                        Function get_devices_file_path
# ============================================================================
def get_devices_file_path():
    return os.path.join(get_config_path(), "devices.json").strip()


_devices_json_cache = None
_devices_json_cache_mtime = 0
_devices_json_cache_path = None

# ============================================================================
#                           Function load_devices_json
# Cache for devices.json to avoid repeated file I/O
# ============================================================================
def load_devices_json():
    # Load devices.json with caching to improve performance.
    # The file is cached in memory and only reloaded if the file has been modified.
    # This reduces I/O overhead when multiple operations need device data.
    global _devices_json_cache, _devices_json_cache_mtime, _devices_json_cache_path

    try:
        file_path = get_devices_file_path()

        # Check if we have a valid cached version
        if (_devices_json_cache is not None and
            _devices_json_cache_path == file_path and
            os.path.exists(file_path)):

            current_mtime = os.path.getmtime(file_path)
            if current_mtime == _devices_json_cache_mtime:
                return _devices_json_cache

        # Load from disk
        if os.path.exists(file_path):
            encoding = detect_encoding(file_path)
            with open(file_path, 'r', encoding=encoding, errors="replace") as f:
                data = json.load(f)
                devices = data.get('devices', {})

                # Update cache
                _devices_json_cache = devices
                _devices_json_cache_mtime = os.path.getmtime(file_path)
                _devices_json_cache_path = file_path

                return devices
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error loading devices.json: {e}")
    return {}


# ============================================================================
#                         Function invalidate_devices_json_cache
# ============================================================================
def invalidate_devices_json_cache():
    # Invalidate the devices.json cache. Call this after saving devices.json.
    global _devices_json_cache, _devices_json_cache_mtime, _devices_json_cache_path
    _devices_json_cache = None
    _devices_json_cache_mtime = 0
    _devices_json_cache_path = None


# ============================================================================
#                         Function save_devices_json
# ============================================================================
def save_devices_json(devices_data):
    try:
        file_path = get_devices_file_path()
        data = {'devices': devices_data}
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
            f.flush()
            os.fsync(f.fileno())

        # Invalidate cache since file has been modified
        invalidate_devices_json_cache()

        return True
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error saving devices.json: {e}")
        return False


# ============================================================================
#                    Function add_or_update_device
# ============================================================================
def add_or_update_device(device_id, device_name='', hardware='', connected=True):
    try:
        devices = load_devices_json()
        now = datetime.now().isoformat()

        if device_id not in devices:
            # New device - add with enabled=True by default
            devices[device_id] = {
                'enabled': True,
                'device_name': device_name,
                'hardware': hardware,
                'custom_label': '',  # Empty by default, user can set via Manage Devices
                'first_detected': now,
                'last_seen': now,
                'connected': connected
            }
            print(f"New device detected and added to devices.json: {device_id} ({device_name})")
        else:
            # Update existing device
            devices[device_id]['last_seen'] = now
            devices[device_id]['connected'] = connected
            if device_name:
                devices[device_id]['device_name'] = device_name
            if hardware:
                devices[device_id]['hardware'] = hardware

        save_devices_json(devices)
        return True
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error updating device {device_id}: {e}")
        return False


# ============================================================================
#                     Function is_device_enabled
# ============================================================================
def is_device_enabled(device_id):
    try:
        devices = load_devices_json()
        if device_id in devices:
            return devices[device_id].get('enabled', True)
        # If device not in file, it's considered enabled (will be added as enabled)
        return True
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error checking device {device_id}: {e}")
        return True


# ============================================================================
#                     Function toggle_device_enabled
# ============================================================================
def toggle_device_enabled(device_id):
    try:
        devices = load_devices_json()
        if device_id in devices:
            current_state = devices[device_id].get('enabled', True)
            devices[device_id]['enabled'] = not current_state
            save_devices_json(devices)
            return devices[device_id]['enabled']
        return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error toggling device {device_id}: {e}")
        return None


# ============================================================================
#                     Function get_device_display_name
# ============================================================================
def get_device_display_name(device_id, device_info=None):
    # Get display name for a device. Format: device_id : custom_label or device_id : hardware
    # Priority: custom_label > hardware > device_name > device_id
    try:
        devices = load_devices_json()
        if device_id in devices:
            # Priority 1: custom_label (user-defined)
            custom_label = devices[device_id].get('custom_label', '')
            if custom_label:
                return f"{device_id} : {custom_label}"

            # Priority 2: hardware
            hardware = devices[device_id].get('hardware', '')
            if hardware:
                return f"{device_id} : {hardware}"

            # Priority 3: device_name
            device_name = devices[device_id].get('device_name', '')
            if device_name:
                return f"{device_id} : {device_name}"

        # Fallback to device_info if provided
        if device_info and hasattr(device_info, 'hardware'):
            return f"{device_id} : {device_info.hardware}"
        return device_id
    except Exception:
        return device_id


# ============================================================================
#                     Function update_device_custom_label
# ============================================================================
def update_device_custom_label(device_id, custom_label):
    try:
        devices = load_devices_json()
        if device_id in devices:
            devices[device_id]['custom_label'] = custom_label.strip()
            save_devices_json(devices)
            return True
        return False
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error updating custom label for device {device_id}: {e}")
        return False


# ============================================================================
#                         Function delete_device
# ============================================================================
def delete_device(device_id):
    try:
        devices = load_devices_json()
        if device_id in devices:
            del devices[device_id]
            save_devices_json(devices)
            return True
        return False
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error deleting device {device_id}: {e}")
        return False


# ============================================================================
#                Function update_all_devices_connection_status
# ============================================================================
def update_all_devices_connection_status(connected_device_ids):
    try:
        devices = load_devices_json()
        for device_id in devices:
            devices[device_id]['connected'] = device_id in connected_device_ids
        save_devices_json(devices)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Error updating device connection status: {e}")


# ============================================================================
#                        Function get_path_to_7z
# ============================================================================
def get_path_to_7z():
    if sys.platform == "win32":
        path_to_7z =  os.path.join(get_bundle_dir(),'bin', '7z.exe')
    elif sys.platform == "darwin":
        path_to_7z =  os.path.join(get_bundle_dir(),'bin', '7zz')
    else:
        path_to_7z =  os.path.join(get_bundle_dir(),'bin', '7zzs')

    if not os.path.exists(path_to_7z):
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {path_to_7z} is not found")
        return None
    return path_to_7z


# ============================================================================
#                               Function delete_bundled_library
# ============================================================================
# Example usage
# delete_bundled_library("libreadline.so.8, libgtk*")
def delete_bundled_library(library_names):
    try:
        if not getattr(sys, 'frozen', False):
            return
        bundle_dir = sys._MEIPASS
        debug(f"Bundle Directory: {bundle_dir}")
        if bundle_dir:
            names = library_names.split(",")
            for file_name in os.listdir(bundle_dir):
                for name in names:
                    if fnmatch.fnmatch(file_name, name.strip()):
                        file_path = os.path.join(bundle_dir, file_name)
                        print(f"Found library and deleted: {file_path}")
                        os.remove(file_path)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while deleting bundled library")
        traceback.print_exc()


# ============================================================================
#                               Function get_bundle_dir
# ============================================================================
# set by PyInstaller, see http://pyinstaller.readthedocs.io/en/v3.2/runtime-information.html
# https://stackoverflow.com/questions/7674790/bundling-data-files-with-pyinstaller-onefile
def get_bundle_dir():
    if getattr(sys, 'frozen', False):
        # noinspection PyUnresolvedReferences,PyProtectedMember
        # running in a bundle
        return sys._MEIPASS
    else:
        # running live
        return os.path.dirname(os.path.abspath(__file__))


# ============================================================================
#                               Function check_latest_version
# ============================================================================
def check_latest_version():
    try:
        url = 'https://github.com/badabing2005/PixelFlasher/releases/latest'
        response = request_with_fallback(method='GET', url=url)
        # look in history to find the 302, and get the location header
        location = response.history[0].headers['Location']
        # split by '/' and get the last item
        l_version = location.split('/')[-1]
        # If it starts with v, remove it
        if l_version[:1] == "v":
            version = l_version[1:]
        if version.count('.') == 2:
            version = f"{version}.0"
    except Exception:
        version = '0.0.0.0'
    return version


# ============================================================================
#                               Function enabled_disabled
# ============================================================================
def enabled_disabled(data):
    if data:
        return "Enabled"
    else:
        return "Disabled"


# ============================================================================
#                               Function grow_column
# ============================================================================
def grow_column(list, col, value = 20):
    w = list.GetColumnWidth(col)
    list.SetColumnWidth(col, w + value)


# ============================================================================
#                               Function open_folder
# ============================================================================
def open_folder(self, path, isFile = False):
    try:
        if not path:
            return
        if isFile:
            dir_path = os.path.dirname(path)
        else:
            dir_path = path
        if not os.path.exists(dir_path):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: {dir_path} does not exist.")
            return
        if sys.platform == "darwin":
            subprocess.Popen(["open", dir_path], env=get_env_variables())
        elif sys.platform == "win32":
            os.startfile(dir_path)
        # linux
        elif self.config.linux_file_explorer:
            try:
                explorer_name = os.path.basename(self.config.linux_file_explorer.lower())

                # Handle specific file managers that need special treatment
                if explorer_name in ["dolphin", "nautilus"]:
                    try:
                        # Try with --new-window flag first
                        subprocess.Popen([self.config.linux_file_explorer, "--new-window", dir_path], env=get_env_variables())
                        return
                    except:
                        # Fallback to basic launch
                        subprocess.Popen([self.config.linux_file_explorer, dir_path], env=get_env_variables())
                        return
                else:
                    try:
                        # All other file managers work with just the path
                        subprocess.Popen([self.config.linux_file_explorer, dir_path], env=get_env_variables())
                        return
                    except:
                        # Fallback to --new-window launch
                        subprocess.Popen([self.config.linux_file_explorer, "--new-window", dir_path], env=get_env_variables())
                        return

            except FileNotFoundError:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Configured file explorer '{self.config.linux_file_explorer}' not found.")
                return
            except Exception as e:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to launch configured file explorer: {e}")
                return
        else:
            # No file explorer configured, try automatic detection
            # Try xdg-open first as it's the standard way
            try:
                subprocess.Popen(["xdg-open", dir_path], env=get_env_variables())
            except FileNotFoundError:
                # Fallback to common file managers with proper handling
                file_managers = [
                    ("dolphin", ["--new-window"]),
                    ("nautilus", ["--new-window"]),
                    ("thunar", []),
                    ("pcmanfm", []),
                    ("nemo", [])
                ]
                for fm, args in file_managers:
                    try:
                        cmd = [fm] + args + [dir_path]
                        subprocess.Popen(cmd, env=get_env_variables())
                        return  # Success, exit the function
                    except FileNotFoundError:
                        continue
                # If all fail
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: No suitable file explorer found. Please install xdg-utils or set linux_file_explorer in settings.")
                return
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening a folder.")
        traceback.print_exc()


# ============================================================================
#                               Function open_terminal
# ============================================================================
def open_terminal(self, path, isFile=False):
    try:
        if path:
            if isFile:
                dir_path = os.path.dirname(path)
            else:
                dir_path = path
            if sys.platform.startswith("win"):
                subprocess.Popen(["start", "cmd.exe", "/k", "cd", "/d", dir_path], shell=True, env=get_env_variables())
            elif sys.platform.startswith("linux"):
                if self.config.linux_shell:
                    # Handle different terminal applications with their specific arguments
                    terminal_name = os.path.basename(self.config.linux_shell.lower())
                    if terminal_name in ["konsole"]:
                        subprocess.Popen([self.config.linux_shell, "--workdir", dir_path], env=get_env_variables())
                    elif terminal_name in ["gnome-terminal", "xfce4-terminal", "terminator", "alacritty"]:
                        subprocess.Popen([self.config.linux_shell, "--working-directory", dir_path], env=get_env_variables())
                    elif terminal_name in ["kitty"]:
                        subprocess.Popen([self.config.linux_shell, "--directory", dir_path], env=get_env_variables())
                    else:
                        # Fallback: try common arguments or just launch without directory
                        try:
                            subprocess.Popen([self.config.linux_shell, "--working-directory", dir_path], env=get_env_variables())
                        except:
                            try:
                                subprocess.Popen([self.config.linux_shell, "--workdir", dir_path], env=get_env_variables())
                            except:
                                try:
                                    subprocess.Popen([self.config.linux_shell, "--directory", dir_path], env=get_env_variables())
                                except:
                                    # Last resort: change directory then launch terminal
                                    subprocess.Popen(f"cd '{dir_path}' && {self.config.linux_shell}", shell=True, env=get_env_variables())
                else:
                    try:
                        subprocess.Popen(["gnome-terminal", "--working-directory", dir_path], env=get_env_variables())
                    except FileNotFoundError:
                        try:
                            subprocess.Popen(["konsole", "--workdir", dir_path], env=get_env_variables())
                        except FileNotFoundError:
                            try:
                                subprocess.Popen(["xfce4-terminal", "--working-directory", dir_path], env=get_env_variables())
                            except FileNotFoundError:
                                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: No suitable terminal found. Please set linux_shell in config.")
                                return
            elif sys.platform.startswith("darwin"):
                subprocess.Popen(["open", "-a", "Terminal", dir_path], env=get_env_variables())
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while opening a terminal.")
        traceback.print_exc()


# ============================================================================
#                      Function get_compression_method
# ============================================================================
def get_compression_method(zip_path, file_to_replace):
    try:
        path_to_7z = get_path_to_7z()
        theCmd = f"\"{path_to_7z}\" l -slt \"{zip_path}\""
        result = subprocess.run(theCmd, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output = result.stdout.decode()

        # Parse the output to find the compression method
        in_file_section = False
        for line in output.splitlines():
            if line.startswith("Path = "):
                in_file_section = file_to_replace in line
            if in_file_section and line.startswith("Method = "):
                return line.split(" = ")[1]
        return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function get_compression_method.")
        traceback.print_exc()
        return None


# ============================================================================
#                               Function extract_from_nested_tgz
# ============================================================================
def extract_from_nested_tgz(archive_path, file_paths, output_dir):
    """
    Extract files from nested archives (like tgz -> tar -> folder structure).

    Args:
        archive_path: Path to the outer archive file
        file_paths: List of filenames to extract
        output_dir: Directory to extract files to

    Returns:
        True if all files were successfully extracted, False otherwise
    """

    temp_dir = tempfile.mkdtemp(dir=tempfile.gettempdir())
    success = True

    try:
        path_to_7z = get_path_to_7z()

        # First extract the outer archive (tgz) to get the inner archive (tar)
        debug(f"Extracting outer archive to {temp_dir}")

        cmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir}\" \"{archive_path}\""
        debug(f"{cmd}")
        result = run_shell(cmd)
        if result.returncode != 0:
            print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to extract outer archive")
            return False

        # Find the inner tar file
        tar_file = None
        for root, _, files in os.walk(temp_dir):
            for file in files:
                if file.endswith('.tar'):
                    tar_file = os.path.join(root, file)
                    break
            if tar_file:
                break

        if not tar_file:
            print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find inner tar archive")
            return False

        # Extract the tar file to the temp directory
        debug(f"Extracting inner archive {tar_file}")

        inner_extract_dir = os.path.join(temp_dir, "inner")
        os.makedirs(inner_extract_dir, exist_ok=True)

        cmd = f"\"{path_to_7z}\" x -bd -y -o\"{inner_extract_dir}\" \"{tar_file}\""
        debug(f"{cmd}")
        result = run_shell(cmd)
        if result.returncode != 0:
            print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to extract inner archive")
            return False
        # delete the tar file
        os.remove(tar_file)

        # Copy each needed file to the output directory
        for file_name in file_paths.split():
            found = False
            file_path = None

            for root, _, files in os.walk(inner_extract_dir):
                for file in files:
                    if file == file_name:
                        file_path = os.path.join(root, file)
                        found = True
                        break
                if found:
                    break

            if file_path and os.path.exists(file_path):
                output_file = os.path.join(output_dir, file_name)
                shutil.copy2(file_path, output_file)
                debug(f"Extracted {file_name} to {output_file}")
            else:
                print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {file_name} in extracted content")
                success = False

    except Exception as e:
        print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to extract from nested archive: {str(e)}")
        traceback.print_exc()
        success = False
    finally:
        try:
            shutil.rmtree(temp_dir)
        except Exception as e:
            debug(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: cleaning up temp directory: {str(e)}")
    return success


# ============================================================================
#                   Function replace_file_in_zip_with_7zip
# ============================================================================
def replace_file_in_zip_with_7zip(zip_path, file_to_replace, new_file_path):
    try:
        path_to_7z = get_path_to_7z()

        # Delete the existing file
        theCmd = f"\"{path_to_7z}\" d \"{zip_path}\" \"{file_to_replace}\""
        debug(theCmd)
        res = run_shell2(theCmd)

        # add the replacement file
        theCmd = f"\"{path_to_7z}\" a \"{zip_path}\" \"{new_file_path}\" -m0=Deflate -mx=0"
        debug(theCmd)
        res = run_shell2(theCmd)
        if res.returncode == 0:
            debug(f"Successfully replaced {file_to_replace} in {zip_path}")
            return True
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to replace {file_to_replace} in {zip_path}")
            print(res.stderr.decode())
            return False
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function replace_file_in_zip_with_7zip.")
        traceback.print_exc()
        return False


# ============================================================================
#                               Function check_archive_contains_file
# ============================================================================
def check_archive_contains_file(archive_file_path, file_to_check, nested=False, is_recursive=False):
    try:
        debug(f"Looking for {file_to_check} in file {archive_file_path} with nested: {nested}")
        wx.Yield()

        file_ext = os.path.splitext(archive_file_path)[1].lower()

        if file_ext in ['.zip']:
            return check_zip_contains_file(archive_file_path, file_to_check, get_low_memory(), nested, is_recursive)
        elif file_ext in ['.img']:
            return check_img_contains_file(archive_file_path, file_to_check)
        elif file_ext in ['.tgz', '.gz', '.tar', '.md5']:
            return check_tar_contains_file(archive_file_path, file_to_check, nested, is_recursive)
        else:
            debug("Unsupported file format.")
            return ''
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while check_archive_contains_file.")
        traceback.print_exc()


# ============================================================================
#                               Function check_zip_contains_file
# ============================================================================
def check_zip_contains_file(zip_file_path, file_to_check, low_mem, nested=False, is_recursive=False):
    if low_mem:
        return check_zip_contains_file_lowmem(zip_file_path, file_to_check, nested, is_recursive)
    else:
        return check_zip_contains_file_fast(zip_file_path, file_to_check, nested, is_recursive)


# ============================================================================
#                               Function check_zip_contains_file_fast
# ============================================================================
def check_zip_contains_file_fast(zip_file_path, file_to_check, nested=False, is_recursive=False):
    try:
        if not is_recursive:
            debug(f"Looking for {file_to_check} in zipfile {zip_file_path} with zip-nested: {nested}")
            wx.Yield()
        try:
            with zipfile.ZipFile(zip_file_path, 'r') as zip_file:
                for name in zip_file.namelist():
                    if name.endswith(f'/{file_to_check}') or name == file_to_check:
                        if not is_recursive:
                            debug(f"Found: {name}\n")
                        return name
                    elif nested and name.endswith('.zip'):
                        debug(f"Entering nested zip: {name}")
                        with zip_file.open(name, 'r') as nested_zip_file:
                            nested_zip_data = nested_zip_file.read()
                        with io.BytesIO(nested_zip_data) as nested_zip_stream:
                            with zipfile.ZipFile(nested_zip_stream, 'r') as nested_zip:
                                nested_file_path = check_zip_contains_file_fast(nested_zip_stream, file_to_check, nested=True, is_recursive=True)
                                if nested_file_path:
                                    if not is_recursive:
                                        debug(f"Found: {name}/{nested_file_path}\n")
                                    return f'{name}/{nested_file_path}'
        except zipfile.BadZipFile:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: File {zip_file_path} is not a zip file or is corrupt, skipping this file ...")
            return ''
        debug(f"file: {file_to_check} was NOT found in checked zip on stack\n")
        return ''
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to check_zip_contains_file_fast. Reason: {e}")
        traceback.print_exc()
        return ''


# ============================================================================
#                               Function check_file_pattern_in_zip_file
# ============================================================================
def check_file_pattern_in_zip_file(zip_file_path, pattern, return_all_matches=False):
    try:
        with zipfile.ZipFile(zip_file_path, 'r') as myzip:
            if return_all_matches:
                matches = [file for file in myzip.namelist() if fnmatch.fnmatch(file, pattern)]
                return matches
            else:
                for file in myzip.namelist():
                    if fnmatch.fnmatch(file, pattern):
                        return file
        if return_all_matches:
            return []
        else:
            return ''
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to check_file_pattern_in_zip_file. Reason: {e}")
        traceback.print_exc()
        if return_all_matches:
            return []
        else:
            return ''


# ============================================================================
#                               Function check_img_contains_file
# ============================================================================
def check_img_contains_file(img_file_path, file_to_check):
    try:
        result = subprocess.run([get_path_to_7z(), 'l', img_file_path], capture_output=True, text=True)

        if "Unexpected end of archive" in result.stderr:
            print(f"⚠️ Warning: Unexpected end of archive in {img_file_path}")
            return []

        file_list = result.stdout.split('\n')

        matches = []
        for line in file_list:
            columns = line.split()
            if len(columns) < 6:  # Skip lines with less than 6 columns
                continue
            file_path = columns[5].replace('\\\\', '\\')
            if file_path.endswith(file_to_check):
                debug(f"Found: {file_path}\n")
                # matches.append(file_path)
                return file_path

        if not matches:
            debug(f"file: {file_to_check} was NOT found\n")

        return matches
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to check_img_contains_file. Reason: {e}")
        traceback.print_exc()
        return []


# ============================================================================
#                               Function check_zip_contains_file_lowmem
# ============================================================================
def check_zip_contains_file_lowmem(zip_file_path, file_to_check, nested=False, is_recursive=False):
    try:
        if not is_recursive:
            debug(f"Looking for {file_to_check} in zipfile {zip_file_path} with zip-nested: {nested} Low Memory version.")
            wx.Yield()

        stack = [(zip_file_path, '')]
        temp_files = []

        while stack:
            current_zip, current_path = stack.pop()

            try:
                with zipfile.ZipFile(current_zip, 'r') as zip_file:
                    # Check for corrupted files
                    corrupted_file = zip_file.testzip()
                    if corrupted_file is not None:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Corrupted file found: {corrupted_file} in {current_zip} - skipping this zip file ...")
                        continue

                    for name in zip_file.namelist():
                        full_name = os.path.join(current_path, name)
                        debug(f"Checking: {full_name}")

                        if os.path.basename(full_name) == file_to_check:
                            debug(f"Found: {full_name}")
                            return full_name
                        elif nested and name.endswith('.zip'):
                            debug(f"Entering nested zip: {full_name}")
                            with zip_file.open(name, 'r') as nested_zip_file:
                                nested_zip_data = nested_zip_file.read()

                            with tempfile.NamedTemporaryFile(delete=False) as temp_zip_file:
                                temp_zip_file.write(nested_zip_data)
                                temp_zip_path = temp_zip_file.name

                            # Close the temporary zip file
                            temp_zip_file.close()

                            stack.append((temp_zip_path, full_name))
                            temp_files.append(temp_zip_path)
                            if is_recursive:
                                stack.append((temp_zip_path, full_name))  # Add the nested zip to be processed recursively
            except zipfile.BadZipFile:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: File {current_zip} is not a zip file or is corrupt, skipping this file ...")
                continue

        debug(f"File {file_to_check} was NOT found")

        # Clean up the temporary zip files
        for temp_file in temp_files:
            os.remove(temp_file)

        return ''
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to check_zip_contains_file_lowmem. Reason: {e}")
        traceback.print_exc()
        return ''


# ============================================================================
#                               Function check_tar_contains_file
# ============================================================================
def check_tar_contains_file(tar_file_path, file_to_check, nested=False, is_recursive=False):
    try:
        if not is_recursive:
            debug(f"Looking for {file_to_check} in tarfile {tar_file_path} with tar-nested: {nested}")
            wx.Yield()
        with tarfile.open(tar_file_path, 'r') as tar_file:
            for member in tar_file.getmembers():
                if member.name.endswith(f'/{file_to_check}') or member.name == file_to_check:
                    if not is_recursive:
                        debug(f"Found: {member.name}\n")
                    return member.name
                elif nested and member.name.endswith('.tar'):
                    nested_tar_file_path = tar_file.extractfile(member).read()
                    nested_file_path = check_tar_contains_file(nested_tar_file_path, file_to_check, nested=True, is_recursive=True)
                    if nested_file_path:
                        if not is_recursive:
                            debug(f"Found: {member.name}/{nested_file_path}\n")
                        return f'{member.name}/{nested_file_path}'
                elif nested and member.name.endswith('.zip'):
                    with tar_file.extractfile(member) as nested_zip_file:
                        nested_zip_data = nested_zip_file.read()

                    # Create a temporary file to write the nested zip data
                    with tempfile.NamedTemporaryFile(delete=False) as temp_zip_file:
                        temp_zip_file.write(nested_zip_data)
                        temp_zip_path = temp_zip_file.name

                    nested_file_path = check_zip_contains_file(temp_zip_path, file_to_check, get_low_memory(), nested=True, is_recursive=True)
                    if nested_file_path:
                        if not is_recursive:
                            debug(f"Found: {member.name}/{nested_file_path}\n")
                        return f'{member.name}/{nested_file_path}'

                    # Clean up the temporary zip file
                    os.remove(temp_zip_path)
            debug(f"File {file_to_check} was NOT found\n")
            return ''
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while check_tar_contains_file.")
        traceback.print_exc()


# ============================================================================
#                               Function get_zip_file_list
# ============================================================================
def get_zip_file_list(zip_file_path):
    try:
        with zipfile.ZipFile(zip_file_path, 'r') as zip_file:
            file_list = zip_file.namelist()
        return file_list
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting sip file list.")
        traceback.print_exc()


# ============================================================================
#                               Function get_filenames_in_dir
# ============================================================================
def get_filenames_in_dir(directory, isFile = False):
    # sourcery skip: inline-immediately-returned-variable, list-comprehension
    if not directory:
        return
    if isFile:
        dir_path = os.path.dirname(directory)
    else:
        dir_path = directory
    file_names = []
    for file in os.listdir(dir_path):
        if os.path.isfile(os.path.join(dir_path, file)):
            file_names.append(file)
    return file_names


# ============================================================================
#                               Function find_file_by_prefix
# ============================================================================
def find_file_by_prefix(directory, prefix):
    for filename in os.listdir(directory):
        if filename.startswith(prefix):
            return os.path.join(directory, filename)
    return None


# ============================================================================
#                               Function get_ui_coordinates
# ============================================================================
def get_ui_cooridnates(xmlfile, search):
    with open(xmlfile, "r", encoding='ISO-8859-1', errors="replace") as fin:
        data = fin.read()
    regex = re.compile(rf'{search}.*?bounds="\[(\d+),(\d+)\]\[(\d+),(\d+)\]".+')

    m = re.findall(regex, data)
    if m:
        debug(f"Found Bounds: {m[0][0]} {m[0][1]} {m[0][2]} {m[0][3]}")
        x = int((int(m[0][0]) + int(m[0][2])) / 2)
        y = int((int(m[0][1]) + int(m[0][3])) / 2)
        debug(f"Click Coordinates: {x} {y}")
        return f"{x} {y}"


# ============================================================================
#                               Function get_playstore_user_coords
# ============================================================================
def get_playstore_user_coords(xmlfile):
    with open(xmlfile, "r", encoding='ISO-8859-1', errors="replace") as fin:
        xml_content = fin.read()

    # Find the position of "Voice Search"
    user_search_position = xml_content.find('Voice Search')

    # Check if "Voice Search" is found
    if user_search_position == -1:
        # Fallback to old version.
        user_search_position = xml_content.find('Show notifications and offers')

    if user_search_position != -1:
        node = xml_content.find('/node', user_search_position)

        if node != -1:
            bounds_pos = xml_content.find('bounds=', node)

            if bounds_pos != -1:
                value_start_pos = xml_content.find('"', bounds_pos) + 1
                value_end_pos = xml_content.find('"', value_start_pos)
                bounds = xml_content[value_start_pos:value_end_pos]

                bounds_values = re.findall(r'\d+', bounds)
                x = (int(bounds_values[0]) + int(bounds_values[2])) // 2
                y = (int(bounds_values[1]) + int(bounds_values[3])) // 2

                debug(f"Found Bounds: {bounds}")
                debug(f"Click Coordinates: {x} {y}")
                return f"{x} {y}"


# ============================================================================
#                               Function extract_sha1
# ============================================================================
def extract_sha1(binfile, length=8):
    with open(binfile, 'rb') as f:
        s = f.read()
        # Find SHA1=
        pos = s.find(b'\x53\x48\x41\x31\x3D')
        # Move to that location
        if pos != -1:
            # move to 5 characters from the found position
            f.seek(pos + 5, 0)
            # read length bytes
            byte_string = f.read(length)
            # convert byte string to hex string
            hex_string = binascii.hexlify(byte_string).decode('ascii')
            # convert hex string to ASCII string
            ascii_string = binascii.unhexlify(hex_string).decode('ascii', errors='replace')
            # replace non-decodable characters with ~
            ascii_string = ascii_string.replace('\ufffd', '~')
            # replace non-printable characters with !
            ascii_string = ''.join(['!' if ord(c) < 32 or ord(c) > 126 else c for c in ascii_string])
            return ascii_string
        else:
            return None


# ============================================================================
#                               Function compare_sha1
# ============================================================================
def compare_sha1(SHA1, Extracted_SHA1):
    try:
        if len(SHA1) != len(Extracted_SHA1):
            print("⚠️ Warning!: The SHA1 values have different lengths")
            return 0
        else:
            num_match = 0
            max_shift = 4  # Maximum allowed shift

            for i in range(len(SHA1)):
                if SHA1[i] == Extracted_SHA1[i]:
                    num_match += 1
                else:
                    shift_count = 0
                    j = 1
                    while j <= max_shift:
                        # Check if there is a match within the allowed shift range
                        if i + j < len(SHA1) and SHA1[i] == Extracted_SHA1[i + j]:
                            num_match += 1
                            shift_count = j
                            break
                        elif i - j >= 0 and SHA1[i] == Extracted_SHA1[i - j]:
                            num_match += 1
                            shift_count = -j
                            break
                        j += 1

                    # Adjust the position for the next iteration based on the shift count
                    i += shift_count

            # return confidence level
            return num_match / len(SHA1)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while comparing sha1.")
        traceback.print_exc()


# ============================================================================
#                               Function extract_fingerprint
# ============================================================================
def extract_fingerprint(binfile):
    try:
        with open(binfile, 'rb') as f:
            s = f.read()
            # Find fingerprint=
            pos = s.find(b'\x66\x69\x6E\x67\x65\x72\x70\x72\x69\x6E\x74')
            # Move to that location
            if pos == -1:
                return None
            # move to 12 characters from the found position
            f.seek(pos + 12, 0)
            # read 65 bytes
            byte_string = f.read(65)
            # convert byte string to hex string
            hex_string = binascii.hexlify(byte_string).decode('ascii')
            # convert hex string to ASCII string
            ascii_string = binascii.unhexlify(hex_string).decode('ascii', errors='replace')
            # replace non-decodable characters with ~
            ascii_string = ascii_string.replace('\ufffd', '~')
            # replace non-printable characters with !
            ascii_string = ''.join(['!' if ord(c) < 32 or ord(c) > 126 else c for c in ascii_string])
            return ascii_string
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while extracting fingerprint.")
        traceback.print_exc()


# ============================================================================
#                               Function debug
# ============================================================================
def debug(message):
    if get_verbose():
        print(f"debug: {message}", flush=True)


# ============================================================================
#                               Function print_user_interaction_message
# ============================================================================
def print_user_interaction_message(mode):
    message = f'''
\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Programmatic reboot to mode {mode} is failing.
There could be several reasons for this.
- Your device bootloader is locked.
- The device / platform tools does not support this option.
- Your phone is not connected / detected.

Is your device is waiting for interaction? if so perform the actions manually.
- Using volume keys, scroll up and down and select the proper option.
- Press the power button to apply.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n
'''
    print(message)


# ============================================================================
#                               Function md5
# ============================================================================
def md5(fname):
    try:
        hash_md5 = hashlib.md5()
        with open(fname, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error computing md5.")
        traceback.print_exc()


# ============================================================================
#                               Function json_hexdigest
# ============================================================================
def json_hexdigest(json_string):
    # Convert the JSON string to a dictionary to eliminate space being a factor
    dictionary = json5.loads(json_string)

    # Convert the dictionary to a JSON string with sorted keys to keep them consistent
    sorted_json_string = json.dumps(dictionary, sort_keys=True)

    # Create a hash object using md5
    hash_object = hashlib.md5()

    # Update the hash object with the sorted JSON string
    hash_object.update(sorted_json_string.encode('utf-8'))

    # Get the hexadecimal representation of the hash
    return hash_object.hexdigest()


# ============================================================================
#                               Function sha1
# ============================================================================
def sha1(fname):
    try:
        if not fname or not os.path.exists(fname):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: File [{fname}] does not exist, cannot compute sha1")
            return "NA Error"
        hash_sha1 = hashlib.sha1()
        with open(fname, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha1.update(chunk)
        return hash_sha1.hexdigest()
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while computing sha1")
        traceback.print_exc()


# ============================================================================
#                               Function sha256
# ============================================================================
def sha256(fname):
    try:
        hash_sha256 = hashlib.sha256()
        with open(fname, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return hash_sha256.hexdigest()
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while computing sha256")
        traceback.print_exc()


# ============================================================================
#                               Function unpack_lz4
# ============================================================================
def unpack_lz4(source, dest):
    try:
        with open(source, 'rb') as file:
            compressed_data = file.read()
        decompressed_data = lz4.frame.decompress(compressed_data)
        with open(dest, 'wb') as file:
            file.write(decompressed_data)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while unpacking lz4")
        traceback.print_exc()


# ============================================================================
#                               Function create_boot_tar
# ============================================================================
def create_boot_tar(dir, source='boot.img', dest='boot.tar'):
    original_dir = os.getcwd()
    try:
        os.chdir(dir)
        with tarfile.open(dest, 'w', format=tarfile.GNU_FORMAT) as tar:
            tar.add(source, arcname=source)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while creating boot.tar")
        traceback.print_exc()
    finally:
        os.chdir(original_dir)


# ============================================================================
#                               Function get_code_page
# ============================================================================
def get_code_page():
    try:
        if sys.platform != "win32":
            return
        cp = get_system_codepage()
        if cp:
            print(f"Active code page: {cp}")
        else:
            theCmd = "chcp"
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode == 0:
                # extract the code page portion
                try:
                    debug(f"CP: {res.stdout}")
                    cp = res.stdout.split(":")
                    cp = cp[1].strip()
                    cp = int(cp.replace('.',''))
                    print(f"Active code page: {cp}")
                    set_system_codepage(cp)
                except Exception:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to get Active code page.\n")
                    traceback.print_exc()
                    print(f"{res.stderr}")
                    print(f"{res.stdout}")
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to get Active code page.\n")
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting codepage.")
        traceback.print_exc()


# ============================================================================
#                               Function Which
# ============================================================================
def which(program):
    import os
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None


# ============================================================================
#                               Function remove_quotes
# ============================================================================
def remove_quotes(string):
    if string and string.startswith('"') and string.endswith('"'):
        # Remove existing double quotes
        string = string[1:-1]
    return string


# ============================================================================
#                               Function create_support_zip
# ============================================================================
def create_support_zip():
    try:
        print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Creating support.zip file ...")
        config_path = get_config_path()
        sys_config_path = get_sys_config_path()
        config = get_config()
        tmp_dir_full = os.path.join(config_path, 'tmp')
        support_dir_full = os.path.join(config_path, 'support')
        support_zip = os.path.join(tmp_dir_full, 'support.zip')
        temp_dir = tempfile.gettempdir()

        # if a previous support dir exist delete it along with support.zip
        if os.path.exists(support_dir_full):
            debug("Deleting old support files ...")
            delete_all(support_dir_full)
        if os.path.exists(support_zip):
            debug("Deleting old support.zip ...")
            os.remove(support_zip)

        # create support folder if it does not exist
        if not os.path.exists(support_dir_full):
            os.makedirs(support_dir_full, exist_ok=True)

        # copy the default PixelFlasher.json to tmp\support folder
        to_copy = os.path.join(sys_config_path, 'PixelFlasher.json')
        if os.path.exists(to_copy):
            debug(f"Copying {to_copy} to {support_dir_full}")
            shutil.copy(to_copy, support_dir_full, follow_symlinks=True)

        # copy the loaded config json if it is different
        current_config = get_config_file_path()
        if to_copy != current_config:
            filename = ntpath.basename(current_config)
            folder = os.path.dirname(current_config)
            if filename.lower() == "pixelflasher.json":
                filename = "PixelFlasher_Custom.json"
            custom_config_file = os.path.join(folder, filename)
            debug(f"Copying {custom_config_file} to {support_dir_full}")
            shutil.copy(current_config, os.path.join(support_dir_full, filename), follow_symlinks=True)

        # copy PixelFlasher.db to tmp\support folder
        to_copy = os.path.join(sys_config_path, get_pf_db())
        if os.path.exists(to_copy):
            debug(f"Copying {to_copy} to {support_dir_full}")
            shutil.copy(to_copy, support_dir_full, follow_symlinks=True)

        # copy labels.json to tmp\support folder
        to_copy = os.path.join(config_path, 'labels.json')
        if os.path.exists(to_copy):
            debug(f"Copying {to_copy} to {support_dir_full}")
            shutil.copy(to_copy, support_dir_full, follow_symlinks=True)

        # copy logs to support folder
        to_copy = os.path.join(config_path, 'logs')
        logs_dir = os.path.join(support_dir_full, 'logs')
        if os.path.exists(to_copy):
            debug(f"Copying {to_copy} to {support_dir_full}")
            shutil.copytree(to_copy, logs_dir)

        # copy puml to support folder
        to_copy = os.path.join(config_path, 'puml')
        puml_dir = os.path.join(support_dir_full, 'puml')
        if os.path.exists(to_copy):
            debug(f"Copying {to_copy} to {support_dir_full}")
            shutil.copytree(to_copy, puml_dir)

        # create directory/file listing
        if sys.platform == "win32":
            theCmd = f"dir /s /b \"{config_path}\" > \"{os.path.join(support_dir_full, 'files.txt')}\""
        else:
            theCmd = f"ls -lRgn \"{config_path}\" > \"{os.path.join(support_dir_full, 'files.txt')}\""
        debug(f"{theCmd}")
        res = run_shell(theCmd)

        # sanitize json
        file_path = os.path.join(support_dir_full, 'PixelFlasher.json')
        if os.path.exists(file_path) and config.sanitize_support_files:
            sanitize_file(file_path)
        # sanitize files.txt
        file_path = os.path.join(support_dir_full, 'files.txt')
        if os.path.exists(file_path) and config.sanitize_support_files:
            sanitize_file(file_path)

        # for each file in logs, sanitize
        if config.sanitize_support_files:
            for filename in os.listdir(logs_dir):
                file_path = os.path.join(logs_dir, filename)
                if os.path.exists(file_path):
                    sanitize_file(file_path)

            # for each file in logs, sanitize
            for filename in os.listdir(puml_dir):
                file_path = os.path.join(puml_dir, filename)
                if os.path.exists(file_path):
                    sanitize_file(file_path)

        # sanitize db
        file_path = os.path.join(support_dir_full, get_pf_db())
        if os.path.exists(file_path) and config.sanitize_support_files:
            sanitize_db(file_path)

        # create symmetric key
        session_key = Fernet.generate_key()

        # zip support folder
        debug(f"Zipping {support_dir_full} ...")
        zip_file_path = shutil.make_archive(support_dir_full, 'zip', support_dir_full)

        # delete support folder
        if not config.keep_temporary_support_files:
            delete_all(support_dir_full)

        # encrypt support.zip with session key
        symmetric_cipher = Fernet(session_key)
        with open(zip_file_path, 'rb') as f:
            encrypted_data = symmetric_cipher.encrypt(f.read())
        encrypted_zip_file_path = zip_file_path + '.pf'
        with open(encrypted_zip_file_path, 'wb') as f:
            f.write(encrypted_data)

        # delete unencrypted support.zip
        os.remove(zip_file_path)

        # encrypt session key with RSA public key
        encrypted_session_key_path = os.path.join(tmp_dir_full, 'pf.dat')
        encrypt_sk(session_key=session_key, output_file_name=encrypted_session_key_path, public_key=None)

        # zip encrypted support.zip and session key
        final_zip_file_path = zip_file_path
        with zipfile.ZipFile(final_zip_file_path, 'w') as final_zip:
            final_zip.write(encrypted_zip_file_path, arcname='support.pf')
            final_zip.write(encrypted_session_key_path, arcname='pf.dat')

        # delete encrypted support.zip and session key
        os.remove(encrypted_zip_file_path)
        os.remove(encrypted_session_key_path)

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while creating support.zip.")
        traceback.print_exc()


# ============================================================================
#                               Function sanitize_filename
# ============================================================================
def sanitize_filename(filepath, split=False):
    try:
        # Check if the file exists
        if not os.path.exists(filepath):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: File {filepath} does not exist.")
            if split:
                return None, None
            else:
                return None

        directory = os.path.dirname(filepath)
        filename = os.path.basename(filepath)

        suspect_chars = '<>:"|?*()&;'

        # Check if filename needs sanitization
        needs_sanitization = any(char in filename for char in suspect_chars)

        if not needs_sanitization:
            if split:
                return directory, filename
            else:
                return filepath

        # Create sanitized filename by replacing suspect chars with underscore
        sanitized_filename = filename
        for char in suspect_chars:
            sanitized_filename = sanitized_filename.replace(char, '_')

        # Create temp file in system temp directory
        temp_dir = tempfile.gettempdir()
        temp_filepath = os.path.join(temp_dir, sanitized_filename)

        # Copy the original file to temp location with sanitized name
        # Use copy2 to preserve timestamps and metadata
        shutil.copy2(filepath, temp_filepath)

        if split:
            return temp_dir, sanitized_filename
        else:
            return temp_filepath

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while sanitizing filepath {filepath}")
        traceback.print_exc()
        return None, None


# ============================================================================
#                               Function sanitize_file
# ============================================================================
def sanitize_file(filename):
    try:
        debug(f"Sanitizing {filename} ...")
        with contextlib.suppress(Exception):
            with open(filename, "rt", encoding='ISO-8859-1', errors="replace") as fin:
                data = fin.read()
            data = re.sub(r'(\\Users\\+)(?:.*?)(\\+)', r'\1REDACTED\2', data, flags=re.IGNORECASE)
            data = re.sub(r'(\/Users\/+)(?:.*?)(\/+)', r'\1REDACTED\2', data, flags=re.IGNORECASE)
            data = re.sub(r'(\"device\":\s+)(\"\w+?\")', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(device\sid:\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(device:\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(device\s+\')(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(\(usb\)\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(superkey:\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(./boot_patch.sh\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(Rebooting device\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(Flashing device\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(waiting for\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(Serial\sNumber\.+\:\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(fastboot(.exe)?\"? -s\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(adb(.exe)?\"? -s\s+)(\w+)', r'\1REDACTED', data, flags=re.IGNORECASE)
            data = re.sub(r'(\S\  \((?:adb|f\.b|rec|sid)\)   )(.+?)(\s+.*)', r'\1REDACTED\3', data, flags=re.IGNORECASE)
            data = re.sub(r'(?<=List of devices attached\n)((?:\S+\s+device\n)+)', lambda m: re.sub(r'(\S+)(\s+device)', r'REDACTED\2', m.group(0)), data, flags=re.MULTILINE)
            data = re.sub(r'(?<=debug: fastboot devices:\n)((?:\S+\s+fastboot\n)+)', lambda m: re.sub(r'(\S+)(\s+fastboot)', r'REDACTED\2', m.group(0)), data, flags=re.MULTILINE)
            with open(filename, "wt", encoding='ISO-8859-1', errors="replace") as fin:
                fin.write(data)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while sanitizing {filename}")
        traceback.print_exc()


# ============================================================================
#                               Function sanitize_db
# ============================================================================
def sanitize_db(filename):
    try:
        debug(f"Sanitizing {filename} ...")
        con = sl.connect(filename)
        con.execute("PRAGMA secure_delete = ON;")
        cursor = con.cursor()
        with con:
            data = con.execute("SELECT id, file_path FROM BOOT")
            for row in data:
                id = row[0]
                file_path = row[1]
                if sys.platform == "win32":
                    file_path_sanitized = re.sub(r'(\\Users\\+)(?:.*?)(\\+)', r'\1REDACTED\2', file_path, flags=re.IGNORECASE)
                else:
                    file_path_sanitized = re.sub(r'(\/Users\/+)(?:.*?)(\/+)', r'\1REDACTED\2', file_path, flags=re.IGNORECASE)
                cursor.execute("Update BOOT set file_path = ? where id = ?", (file_path_sanitized, id,))
                con.commit()
        with con:
            data = con.execute("SELECT id, file_path FROM PACKAGE")
            for row in data:
                id = row[0]
                file_path = row[1]
                if sys.platform == "win32":
                    file_path_sanitized = re.sub(r'(\\Users\\+)(?:.*?)(\\+)', r'\1REDACTED\2', file_path, flags=re.IGNORECASE)
                else:
                    file_path_sanitized = re.sub(r'(\/Users\/+)(?:.*?)(\/+)', r'\1REDACTED\2', file_path, flags=re.IGNORECASE)
                cursor.execute("Update PACKAGE set file_path = ? where id = ?", (file_path_sanitized, id,))
                con.commit()
        # Wipe the Write-Ahead log data
        con.execute("VACUUM;")
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while sanitizing db {filename}.")
        traceback.print_exc()


# ============================================================================
#                               Function encrypt_file
# ============================================================================
def encrypt_sk(session_key, output_file_name, public_key=None):
    try:
        if public_key is None:
            public_key = serialization.load_pem_public_key(
                b"""-----BEGIN PUBLIC KEY-----
                MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAj/OLsTAnmLVDR0tpTCEF
                TrEi0touCGRCRPmScmZpyY0+b+Iv52gFJMmYaqC+HUbd3F9tdLWFwWmRFSYXFXaV
                STb1F8DbG+dqWMTG6HtilVl8yfX/ihftlfl/Zj6mtMj3BmMNe475GohwZTdfXXkF
                hPRxrx2WIVlzrZAozVdfLCj6o7iCq27Wbsuis7x5LtlM5ojraK7lYPMlCXigR+2N
                VDsaAzCaYZAxn2YXNrtLRcmwsRxEH1YnJgQiH7CqJz8w10ArkOxvZ/vbLq3Yrokd
                JPcPqPWn9Zu0Rb9q3U42ghuO7f5Laqt0ANf4nHaMK+Q3sWZvf/rVpOIlrLVCaa/H
                swIDAQAB
                -----END PUBLIC KEY-----""",
                backend=default_backend()
            )

        encrypted_session_key = public_key.encrypt(
            session_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        with open(output_file_name, 'wb') as f:
            f.write(encrypted_session_key)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an in function encrypt_sk")
        traceback.print_exc()


# ============================================================================
#                               Function purge
# ============================================================================
# This function delete multiple files matching a pattern
def purge(dir, pattern):
    for f in os.listdir(dir):
        if re.search(pattern, f):
            os.remove(os.path.join(dir, f))


# ============================================================================
#                               Function delete_all
# ============================================================================
# This function delete multiple files matching a pattern
def delete_all(dir):
    for filename in os.listdir(dir):
        file_path = os.path.join(dir, filename)
        try:
            if os.path.isfile(file_path) or os.path.islink(file_path):
                os.unlink(file_path)
            elif os.path.isdir(file_path):
                shutil.rmtree(file_path)
        except Exception as e:
            print(f"Failed to delete {file_path}. Reason: {e}")
            traceback.print_exc()


# ============================================================================
#                               Function get_size_from_url
# ============================================================================
def get_size_from_url(url):
    try:
        response = requests.head(url, allow_redirects=True, timeout=10)
        if 'Content-Length' in response.headers:
            file_size = int(response.headers['Content-Length'])
            debug(f"Size of {url} is {file_size} bytes")
            return file_size
        else:
            debug("Could not determine file size from headers")
            return None
    except Exception as e:
        print(f"Error getting file size: {e}")
        return None


# ============================================================================
#                               Function check_module_update
# ============================================================================
def check_module_update(url):
    try:
        skiplist = get_skip_urls_file_path()
        if os.path.exists(skiplist):
            with open(skiplist, 'r', encoding='ISO-8859-1', errors="replace") as f:
                skiplist_urls = f.read().splitlines()
                if url in skiplist_urls:
                    print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Skipping update check for {url}")
                    return None
        payload={}
        headers = {
            'Content-Type': "application/json"
        }
        response = request_with_fallback(method='GET', url=url, headers=headers, data=payload)
        if response != 'ERROR':
            if response.status_code == 404:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Module update not found for URL: {url}")
                return None
            with contextlib.suppress(Exception):
                data = response.json()
                mu = ModuleUpdate(url)
                setattr(mu, 'version', data['version'])
                setattr(mu, 'versionCode', data['versionCode'])
                setattr(mu, 'zipUrl', data['zipUrl'])
                setattr(mu, 'changelog', data['changelog'])
                headers = {}
                response = request_with_fallback(method='GET', url=mu.changelog, headers=headers, data=payload)
                setattr(mu, 'changelog', response.text)
                return mu
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Module update URL has issues, inform the module author: {url}")
            dlg = wx.MessageDialog(None, _("Module update URL has issues, inform the module author: %s\nDo you want to skip checking updates for this module?") % url, _("Error"), wx.YES_NO | wx.ICON_ERROR)
            result = dlg.ShowModal()
            if result == wx.ID_YES:
                # add url to a list of failed urls
                with open(skiplist, 'a') as f:
                    f.write(url + '\n')
                print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Added {url} to update check skip list.")
                return None
            else:
                return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during getUpdateDetails url: {url} processing")
        traceback.print_exc()
        return None


# ============================================================================
#                               Function get_free_space
# ============================================================================
def get_free_space(path=''):
    try:
        path_to_check = path or tempfile.gettempdir()
        path_to_check = os.path.realpath(path_to_check)

        total, used, free = shutil.disk_usage(path_to_check)

        debug(f"Path: {path_to_check} - Total: {round(total / (1024 ** 3), 2)} GB, Used: {round(used / (1024 ** 3), 2)} GB, Free: {round(free / (1024 ** 3), 2)} GB")

        return int(round(free / (1024 ** 3)))
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting free space.")
        traceback.print_exc()


# ============================================================================
#                               Function get_free_memory
# ============================================================================
def get_free_memory():
    memory = psutil.virtual_memory()
    free_memory = memory.available
    total_memory = memory.total
    return free_memory, total_memory


# ============================================================================
#                               Function format_memory_size
# ============================================================================
def format_memory_size(size_bytes):
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024


# ============================================================================
#                               Function parse_device_list_html
# ============================================================================
def parse_device_list_html(ul_content):
    """
    Parse HTML ul content of device names and return both model_list and product_list.

    Args:
        ul_content (str or Tag): HTML ul element with device names, can be a string or BeautifulSoup Tag

    Returns:
        tuple: (model_list, product_list)
    """

    device_data = get_android_devices()
    # Create reverse lookup from display name to codename
    device_to_product = {}
    for product, info in device_data.items():
        device_to_product[info['device'].lower()] = product

    li_items = []

    # Check if ul_content is a BeautifulSoup Tag
    if hasattr(ul_content, 'find_all'):
        # It's a BeautifulSoup Tag, use find_all to extract list items
        li_tags = ul_content.find_all('li')
        li_items = [li.get_text() for li in li_tags]
    else:
        # It's a string, use regex to extract list items
        li_pattern = r'<li>(.*?)</li>'
        li_items = re.findall(li_pattern, ul_content)

    model_list = []
    product_list = []

    for item in li_items:
        # Handle different list item formats
        parts = []

        # Example: "Pixel 9, 9 Pro, 9 Pro XL, and 9 Pro Fold" should be split into 4 devices
        if ',' in item and ('and' in item or '&' in item):
            # Split by commas first
            comma_parts = [p.strip() for p in item.split(',')]
            # Last part might contain "and" or "&"
            last_part = comma_parts.pop()
            if ' and ' in last_part:
                and_parts = last_part.split(' and ')
            elif 'and ' in last_part:
                and_parts = last_part.split('and ')
            elif ' & ' in last_part:
                and_parts = last_part.split(' & ')
            elif '& ' in last_part:
                and_parts = last_part.split('& ')
            else:
                and_parts = [last_part]
            # Remove empty parts from and_parts
            and_parts = [part for part in and_parts if part.strip()]
            # Combine comma parts with and parts
            parts = comma_parts + and_parts

        # Example: "Pixel 6 and 6 Pro" - no commas but has "and"
        elif ' and ' in item or ' & ' in item:
            if ' and ' in item:
                and_parts = item.split(' and ')
            else:
                and_parts = item.split(' & ')

            # Remove empty parts from and_parts
            and_parts = [part for part in and_parts if part.strip()]
            parts = and_parts

        # Simple case example "Pixel 6a" and nothing else.
        else:
            parts = [item]

        # Process all parts to add to model and product lists
        for part in parts:
            part = part.strip()

            # Handle missing 'Pixel' like "9 Pro" -> "Pixel 9 Pro"
            if not part.lower().startswith("pixel"):
                # Find the prefix from the last full device name
                for i in range(len(model_list) - 1, -1, -1):
                    prev_model = model_list[i]
                    if prev_model.lower().startswith("pixel"):
                        prefix = prev_model.split(' ')[0]  # Example: "Pixel"
                        part = f"{prefix} {part}"
                        break

            # Add to model list
            model_list.append(part)

            # Find matching product name
            device_name = part.lower()
            product = None

            # Try exact match
            if device_name in device_to_product:
                product = device_to_product[device_name]
            else:
                # Try partial match for cases like "Pixel 6" -> "Google Pixel 6"
                for display_name, prod_name in device_to_product.items():
                    if device_name in display_name or display_name.endswith(device_name):
                        product = prod_name
                        break

            if product:
                product_list.append(f"{product}_beta")
            else:
                # Fallback for unrecognized devices as UNKNOWN
                print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING! Could not find product name for {part}")
                product_list.append(f"UNKNOWN")

    return model_list, product_list


# ============================================================================
#                 Function get_gsi_data
# ============================================================================
def get_gsi_data(force_version=None):
    try:
        error = False
        # URLs
        gsi_url = "https://developer.android.com/topic/generic-system-image/releases"
        debug(f"Fetching GSI data from {gsi_url} ...")

        # Fetch GSI HTML
        response = request_with_fallback('GET', gsi_url)
        if response == 'ERROR' or response.status_code != 200:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch GSI HTML")
            return None, None
        gsi_html = response.text

        # Parse GSI HTML
        soup = BeautifulSoup(gsi_html, 'html.parser')

        id_to_find = f"android-gsi-{force_version}"
        # get the position of id_to_find
        pos = gsi_html.find(id_to_find)
        if pos == -1:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: GSI version {force_version} not found in HTML")
            return None, None
        # Move to that position
        gsi_html = gsi_html[pos:]
        # Parse the HTML again with the new gsi_html
        soup = BeautifulSoup(gsi_html, 'html.parser')
        # find the first <ul> tag in the new soup
        ul_content = soup.find('ul')
        # use it to extract model_list and product_list
        model_list, product_list = parse_device_list_html(ul_content)

        # Find the anchor tag with the text 'corresponding Google Pixel builds'
        release = soup.find('a', string=lambda x: x and 'corresponding Google Pixel builds' in x)
        if not release:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Release version not found")
            return None, None

        href = release['href']
        release_version = href.split('/')[3]
        if release_version != str(force_version):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Fetched Release version {release_version} does not match requested version {force_version}")

        # Find the build ID inside <code> blocks
        build_id_text = None
        security_patch_level_text = None
        google_play_services = None
        for code in soup.find_all('code'):
            code_text = code.get_text()
            if 'Build:' in code_text:
                build_id_text = code_text
                if 'Security patch level:' in code_text:
                    security_patch_level_text = code_text
                if 'Google Play Services:' in code_text:
                    google_play_services = code_text.split('Google Play Services: ')[1].split('\n')[0]
                break
        if build_id_text:
            build_id = build_id_text.split('Build: ')[1].split()[0]
            # Extract date portion from the build ID (typically in format like BP1A.250405.005.C1)
            # The date part is in the middle segment (YYMMDD format, example: 250405 for April 5, 2025)
            date_match = re.search(r'\.(\d{6})\.', build_id)
            if date_match:
                build_date_str = date_match.group(1)
                build_year = 2000 + int(build_date_str[:2])
                build_month = int(build_date_str[2:4])
                build_day = int(build_date_str[4:6])
                try:
                    build_date = datetime(build_year, build_month, build_day)
                except ValueError:
                    # Invalid date in build ID
                    print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Invalid date in build ID: {build_date_str}")
                    build_date = None
            else:
                build_date = None
                print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Could not extract date from build ID: {build_id}")
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Build ID not found")
            return None, None

        if security_patch_level_text:
            security_patch_level_date = security_patch_level_text.split('Security patch level: ')[1].split('\n')[0]
            release_date = security_patch_level_text.split('Date: ')[1].split('\n')[0]
            beta_release_date = datetime.strptime(release_date, '%B %d, %Y').strftime('%Y-%m-%d')
            # verify if the beta_release_date falls correctly within the build date with a 30-day margin
            if build_date:
                published_date = datetime.strptime(beta_release_date, '%Y-%m-%d')
                delta_days = abs((published_date - build_date).days)
                if delta_days > 60:
                    print(f"\n⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Large discrepancy between published GSI release date ({release_date}) and build ID date ({build_date.strftime('%Y-%m-%d')}). Difference: {delta_days} days")
                    error = True
            beta_expiry = datetime.strptime(beta_release_date, '%Y-%m-%d') + timedelta(weeks=6)
            beta_expiry_date = beta_expiry.strftime('%Y-%m-%d')
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Security patch level date not found")
            return None, None

        # Find the incremental value
        incremental = None
        match = re.search(rf'{build_id}-(\d+)-', gsi_html)
        if match:
            incremental = match.group(1)
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Incremental not found")
            return None, None

        devices = []
        table = soup.find('table')
        if table:
            # Skip the header row
            rows = table.find_all('tr')[1:]
            for row in rows:
                cols = row.find_all('td')
                # Ensure we have at least 2 columns
                if len(cols) >= 2:
                    device = cols[0].text.strip()
                    button = cols[1].find('button')
                    if button and 'data-category' in button.attrs:
                        category = button['data-category']
                        zip_filename = button.text.strip()
                        hashcode = cols[1].find('code')
                        if hashcode:
                            hashcode = hashcode.text.strip()
                        else:
                            hashcode = ""
                        devices.append({
                            'device': device,
                            'category': category,
                            'zip_filename': zip_filename,
                            'hash': hashcode,
                            'url': None  # Placeholder for URL
                        })

        # Find all hrefs and match with zip_filename
        for a_tag in soup.find_all('a', href=True):
            href = a_tag['href']
            for device in devices:
                if device['zip_filename'] in href:
                    device['url'] = href
                    break

        emulator_support = ""
        security_patch = ""
        ret_obj = BetaData(release_date, build_id, emulator_support, security_patch_level_date, google_play_services, beta_expiry_date, incremental, security_patch, devices)
        # append the model_list and product_list to ret_obj
        ret_obj.model_list = model_list
        ret_obj.product_list = product_list
        # append the release['href] to ret_obj
        ret_obj.release_href = release['href']
        return ret_obj, error

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting GSI data.")
        traceback.print_exc()
        return None, None


# ============================================================================
#                 Function get_beta_links
# ============================================================================
def get_beta_links():
    try:
        url_base = "https://developer.android.com/about/versions"

        # Get the latest Android version
        latest_version, latest_version_url = get_latest_android_version(None)
        ota_data = None
        factory_data = None
        if latest_version == -1:
            return None, None, None, None


        # Fetch OTA HTML
        ota_url = f"{url_base}/{latest_version}/download-ota"
        if latest_version_url:
            ota_url = f"{latest_version_url}/download-ota"
        ota_data, ota_error = get_beta_data(ota_url)

        # Fetch Factory HTML
        factory_url = f"{url_base}/{latest_version}/download"
        if latest_version_url:
            factory_url = f"{latest_version_url}/download"
        factory_data, factory_error = get_beta_data(factory_url)

        return ota_data, factory_data, ota_error, factory_error
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting beta links.")
        traceback.print_exc()
        return None, None, None, None


# ============================================================================
#                 Function get_telegram_factory_images
# ============================================================================
def get_telegram_factory_images(max_pages=3):
    try:
        base_url = "https://t.me/s/pixelfactoryimagestracker"
        config_path = get_config_path()
        telegram_factory_images_file = os.path.join(config_path, 'telegram_factory_images.json')

        # Load existing cached data
        cached_images = []
        cached_message_ids = set()
        if os.path.exists(telegram_factory_images_file):
            try:
                with open(telegram_factory_images_file, 'r', encoding='utf-8') as f:
                    cached_data = json.load(f)
                    cached_images = cached_data
                    debug(f"Loaded {len(cached_images)} cached factory images")
                    for image in cached_images:
                        # Create a unique identifier from device, build_id, and url
                        unique_id = f"{image.get('device', '')}|{image.get('build_id', '')}|{image.get('url', '')}"
                        cached_message_ids.add(unique_id)
            except (json.JSONDecodeError, KeyError) as e:
                debug(f"Could not load cached data: {e}, starting fresh")
                cached_images = []
                cached_message_ids = set()

        factory_images = []
        all_message_ids = set()
        found_cached_content = False
        new_images_count = 0

        # Start with the first page
        current_url = base_url
        page_count = 0

        while page_count < max_pages:
            debug(f"Fetching page {page_count + 1} from Telegram channel...")

            response = requests.get(current_url)
            if response.status_code != 200:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch URL: {current_url}")
                break

            telegram_html = response.text
            soup = BeautifulSoup(telegram_html, 'html.parser')

            # Find all message containers
            message_containers = soup.find_all('div', class_='tgme_widget_message')
            if not message_containers:
                debug(f"No more messages found on page {page_count + 1}")
                break

            page_has_new_messages = False
            for container in message_containers:
                # Get message ID to avoid duplicates
                message_id = container.get('data-post')
                if message_id in all_message_ids:
                    continue

                all_message_ids.add(message_id)

                # Find the message text within this container
                message_text_div = container.find('div', class_='tgme_widget_message_text')
                if not message_text_div:
                    continue

                # Check if we've reached content that's already in our cache
                # Create unique identifier for this message
                current_unique_id = None
                if "New Pixel Factory Image Detected" in message_text_div.get_text():
                    # Extract basic info to create unique identifier
                    device_match = re.search(r'<b>Device:<\/b>\s*([^<]+)<br', str(message_text_div))
                    build_id_match = re.search(r'<b>Build ID:<\/b>\s*<code>([^<]+)<\/code>', str(message_text_div))
                    link = message_text_div.find('a', href=True)

                    if device_match and link:
                        device = device_match.group(1).strip()
                        build_id = build_id_match.group(1).strip() if build_id_match else ''
                        download_url = link['href']
                        current_unique_id = f"{device}|{build_id}|{download_url}"

                        # Check if this content is already cached, but don't break yet
                        # Continue processing the rest of the page since newest entries are at the bottom
                        if current_unique_id in cached_message_ids:
                            found_cached_content = True
                            debug(f"Found cached content for {device}, but continuing to process rest of page")
                            continue

                page_has_new_messages = True

                # Check if this is a factory image announcement
                if "New Pixel Factory Image Detected" in message_text_div.get_text():
                    device = None
                    image_type = None
                    build_id = None
                    download_url = None

                    # Extract device info
                    device_match = re.search(r'<b>Device:<\/b>\s*([^<]+)<br', str(message_text_div))
                    if device_match:
                        device = device_match.group(1).strip()

                    # Extract type info
                    type_match = re.search(r'<b>Type:<\/b>\s*([^<]+)<br', str(message_text_div))
                    if type_match:
                        image_type = type_match.group(1).strip()

                    # Extract build ID
                    build_id_match = re.search(r'<b>Build ID:<\/b>\s*<code>([^<]+)<\/code>', str(message_text_div))
                    if build_id_match:
                        build_id = build_id_match.group(1).strip()

                    # Extract download URL
                    link = message_text_div.find('a', href=True)
                    if link:
                        download_url = link['href']

                    # Add to the array if we have all the required fields
                    if device and download_url:
                        factory_images.append({
                            "device": device,
                            "type": image_type,
                            "build_id": build_id,
                            "url": download_url,
                            "message_id": message_id
                        })
                        new_images_count += 1

            # If we found cached content or no new messages, break
            if not page_has_new_messages:
                debug(f"No new messages found on page {page_count + 1}, stopping pagination")
                break
            elif found_cached_content and new_images_count == 0:
                debug(f"Stopped fetching at page {page_count + 1} due to reaching only cached content")
                break

            # Look for "Load more" link or pagination
            next_page_url = None

            # Method 1: Look for "before" parameter in existing links
            before_links = soup.find_all('a', href=True)
            for link in before_links:
                href = link['href']
                if 'before=' in href and 'pixelfactoryimagestracker' in href:
                    next_page_url = href
                    if not next_page_url.startswith('http'):
                        next_page_url = f"https://t.me{next_page_url}"
                    break

            # Method 2: If no pagination link is found, try to construct one using the oldest message ID
            if not next_page_url and message_containers:
                oldest_message = message_containers[-1]
                oldest_message_id = oldest_message.get('data-post')
                if oldest_message_id:
                    # Extract just the message number part
                    message_num = oldest_message_id.split('/')[-1] if '/' in oldest_message_id else oldest_message_id
                    next_page_url = f"{base_url}?before={message_num}"

            if not next_page_url:
                debug(f"No pagination link found on page {page_count + 1}, stopping")
                break

            current_url = next_page_url
            page_count += 1

            # Add a small delay to be respectful to the server
            time.sleep(1)

        # Merge new images with cached images
        # New images go first (they're newer), then cached images
        combined_images = factory_images + cached_images

        # Remove duplicates based on unique identifier while preserving order
        seen_unique_ids = set()
        deduplicated_images = []
        for image in combined_images:
            # Create unique identifier for deduplication
            unique_id = f"{image.get('device', '')}|{image.get('build_id', '')}|{image.get('url', '')}"
            if unique_id not in seen_unique_ids:
                seen_unique_ids.add(unique_id)
                deduplicated_images.append(image)

        # Sort all images by message_id in descending order (newest first)
        # Handle both regular message IDs and entries without message_id
        def sort_key(image):
            msg_id = image.get('message_id')
            if not msg_id:
                # For entries without message_id (cached entries), use a very low number
                return 0
            try:
                return int(msg_id.split('/')[-1])
            except (ValueError, AttributeError):
                return 0

        deduplicated_images.sort(key=sort_key, reverse=True)

        # Remove message_id from final output as it's just for sorting
        for image in deduplicated_images:
            image.pop('message_id', None)

        # Save merged telegram factory_images to file
        if deduplicated_images:
            with open(telegram_factory_images_file, 'w', encoding='utf-8') as f:
                json.dump(deduplicated_images, f, indent=4, ensure_ascii=False)

            if new_images_count > 0:
                debug(f"Found {new_images_count} new factory images, merged with {len(cached_images)} cached images")
                debug(f"Total {len(deduplicated_images)} factory images saved to cache")
            else:
                debug(f"No new images found, using {len(cached_images)} cached factory images")
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} No factory images found in Telegram channel.")

        return deduplicated_images
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting Telegram factory images.")
        traceback.print_exc()
        return -1


# ============================================================================
#                 Function get_api_level
# ============================================================================
def get_api_level(android_version):
    try:
        version_data = get_android_versions()
        # Create reverse lookup from API version to Android version
        version_to_api = {}
        for api_version, info in version_data.items():
            version_to_api[info['Version'].lower()] = api_version
        api_level = version_to_api[str(android_version)]
        return int(api_level)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get API level for Android version {android_version}")
        traceback.print_exc()
        return None


# ============================================================================
#                               Function get_beta_factory_object
# ============================================================================
def get_beta_factory_object(product, canary = True, active = True, latest = True):
    try:
        debug(f"Retrieving canary data for product: {product}")

        if 'beta' not in product:
            product += '_beta'

        page_headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        }

        response = requests.get("https://flash.android.com", headers=page_headers, timeout=20)
        response.raise_for_status()

        soup = BeautifulSoup(response.text, "html.parser")
        body_tag = soup.body
        if body_tag is None:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not locate body tag on flash.android.com")
            return None

        raw_client_config = body_tag.get("data-client-config", "")
        if not raw_client_config:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Missing data-client-config attribute on flash.android.com body")
            return None

        client_config = html.unescape(raw_client_config)
        key_match = re.search(r"\"(AIza[0-9A-Za-z\-_]+)\"", client_config)
        if not key_match:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to extract key from flash.android.com")
            return None

        api_key = key_match.group(1)
        api_url = f"https://content-flashstation-pa.googleapis.com/v1/builds?key={api_key}&product={product}"
        debug(f"Querying Flashstation API: {api_url}")

        api_headers = {
            "User-Agent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Mobile Safari/537.36",
            "Accept": "application/json",
            "Accept-Language": "en-US,en;q=0.9",
            "Referer": "https://flash.android.com",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache",
        }

        api_response = requests.get(api_url, headers=api_headers, timeout=30)
        api_response.raise_for_status()
        data = api_response.json()

        if not latest:
            return data

        builds = data.get("flashstationBuild", [])
        debug(f"Received {len(builds)} builds for {product}")

        filtered_builds = []
        for build in builds:
            preview = build.get("previewMetadata") or {}
            canary_flag = preview.get("canary")
            active_flag = preview.get("active")

            if canary is not None and bool(canary_flag) != bool(canary):
                continue
            if active is not None and bool(active_flag) != bool(active):
                continue

            filtered_builds.append(build)

        if not filtered_builds:
            debug("No builds matched the requested criteria")
            return None

        def build_sort_key(entry):
            build_id = entry.get("buildId", "0")
            try:
                return int(build_id)
            except (TypeError, ValueError):
                return 0

        filtered_builds.sort(key=build_sort_key, reverse=True)

        latest_build = filtered_builds[0].copy()
        latest_build.pop("licenseText", None)
        return latest_build

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to retrieve canary URL for {product}")
        traceback.print_exc()
        return None


# ============================================================================
#                               Function find_canary_url
# ============================================================================
def find_canary_url(api_level=36):
    try:
        for i in range(9, 0, -1):
            url = f"https://dl.google.com/android/repository/sys-img/google_apis/arm64-v8a-{api_level}.0-CANARY_r{i:02d}.zip"
            #debug(f"Checking: {url}")
            response = requests.head(url, allow_redirects=True, timeout=5)
            if response.status_code == 200:
                return url
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in find_canary_url function")
        traceback.print_exc()
    return None


# ============================================================================
#                               Function get_canary_miner
# ============================================================================
def get_canary_miner(device_model='random', default_selection=None, miner_url=None):
    if not miner_url:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: No miner URL provided")
        return -1
    # get file list from miner_url
    try:
        canary_device = None
        canary_url = None
        response = requests.get(miner_url)
        if response.status_code != 200:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch Canary PIFs page")
            return -1
        page_html = response.text
        file_list = []
        directory = path.basename(urlparse(miner_url).path) or "devices"
        file_pattern = rf'{{"name":"([^"]+)","path":"({re.escape(directory)}/[^"]+)","contentType":"file"}}'
        matches = re.findall(file_pattern, page_html)
        for match in matches:
            file_name = match[0]
            if '.pif.prop' not in file_name:
                continue
            file_name = file_name.replace('.pif.prop', '')
            file_path = match[1]
            file_path = f"https://raw.githubusercontent.com/Vagelis1608/get_the_canary_miner/refs/heads/main/{file_path}"
            file_list.append({"device": file_name, "path": file_path})
            if device_model != 'random' and device_model != '_select_' and device_model in file_name:
                canary_url = file_path
                canary_device = device_model

        debug(f"Found {len(file_list)} Canary PIF files")
        if device_model == 'random':
            selected_file = random.choice(file_list)
            canary_url = selected_file['path']
            canary_device = selected_file['device']
        elif device_model == '_select_':
            if len(file_list) == 1:
                only_file = file_list[0]
                debug(f"Only one Canary PIF found, auto-selecting {only_file['device']}")
                canary_url = only_file['path']
                canary_device = only_file['device']
            else:
                canary_url, canary_device = select_pif_device(file_list, default_selection, device_type="Canary")
            if not canary_url:
                return "Selection cancelled."
        elif not canary_url:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find Canary PIF for device model: {device_model}")
            return -1

        response = requests.get(canary_url)
        if response.status_code != 200:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch Canary PIF file for {canary_device}")
            return -1
        pif_content = response.text
        return pif_content

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while getting Canary Miner data.")
        traceback.print_exc()
        return -1


# ============================================================================
#                 Function select_pif_device
# ============================================================================
def select_pif_device(devices_data, default_selection=None, device_type=""):
    try:
        from device_selector import show_device_selector
        selected_device = show_device_selector(
            parent=None,
            devices=devices_data,
            title=f"Select {device_type} Device",
            message=f"Select a {device_type} device:",
            select_device=default_selection
        )
        if selected_device:
            pif_url = selected_device['path']
            pif_device = selected_device['device']
            print(f"  Selected: {pif_device}")
            return pif_url, pif_device
        else:
            print("Selection cancelled.")
            return None, None
    except ImportError:
        selected_url = None


# ============================================================================
#                 Function get_beta_pif
# ============================================================================
def get_beta_pif(device_model='random', force_version=None, state=None):
    # Get the latest Android version
    latest_version, latest_version_url = get_latest_android_version(force_version)
    print(f"Selected Version:         {latest_version}")
    if latest_version == -1:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get the latest Android version")
        return -1

    canary_data = False
    beta_type = "Beta"
    if force_version and str(force_version).startswith('CANARY'):
        # moved this logic to pif manager
        # the code should never get here
        pass
    else:
        # If force_version is provided but no valid latest version is found, use the forced version
        if force_version and latest_version == 0:
            latest_version = force_version
        # set the url to the latest version
        ota_url = f"https://developer.android.com/about/versions/{latest_version}/download-ota"
        factory_url = f"https://developer.android.com/about/versions/{latest_version}/download"
        if not force_version and latest_version_url:
            ota_url = f"{latest_version_url}/download-ota"
            factory_url = f"{latest_version_url}/download"

        # Fetch OTA HTML
        ota_data, ota_error = get_beta_data(ota_url)
        if not ota_data:
            print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get beta or Developer Preview OTA data for Android {latest_version}")
        # print(ota_data.__dict__)

        # Fetch Factory HTML
        factory_data, factory_error = get_beta_data(factory_url)
        if not factory_data:
            print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get beta or Developer Preview Factory data for Android {latest_version}")
        # print(factory_data.__dict__)

        # Fetch GSI HTML
        gsi_data, gsi_error = get_gsi_data(force_version=force_version or latest_version)
        if not gsi_data:
            print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get beta or Developer Preview GSI data for Android {latest_version}")
        # print(gsi_data.__dict__)

        if not ota_data and not factory_data and not gsi_data and not canary_data:
            return -1
        if not ota_data and not factory_data and not canary_data:
            print(f"Getting beta print from GSI data, version {latest_version} ...")

        ota_date_object = None
        factory_date_object = None
        gsi_date_object = None
        model_list = []
        product_list = []
        if ota_data:
            ota_date = ota_data.__dict__['release_date']
            ota_date_object = datetime.strptime(ota_date, "%B %d, %Y")
            if ota_error:
                print(f"Beta OTA Date:            {ota_date} (❌ Problems with download links or hashes)")
            else:
                print(f"Beta OTA Date:            {ota_date}")
        else:
            print(f"Beta OTA:                 Unavailable")

        if factory_data:
            factory_date = factory_data.__dict__['release_date']
            factory_date_object = datetime.strptime(factory_date, "%B %d, %Y")
            if factory_error:
                print(f"Beta Factory Date:        {factory_date} (❌ Problems with download links or hashes)")
            else:
                print(f"Beta Factory Date:        {factory_date}")
        else:
            print(f"Beta Factory:             Unavailable")

        if gsi_data:
            gsi_date = gsi_data.__dict__['release_date']
            gsi_date_object = datetime.strptime(gsi_date, "%B %d, %Y")
            if gsi_error:
                print(f"Beta GSI Date:            {gsi_date} (❌ Possible problems with GSI date)")
            else:
                print(f"Beta GSI Date:            {gsi_date}")
        else:
            print(f"Beta GSI:                 Unavailable")

        # Determine the latest date(s)
        newest_data = []
        dates = []
        if ota_date_object and not ota_error:
            dates.append((ota_date_object, 'ota'))
        if factory_date_object and not factory_error:
            dates.append((factory_date_object, 'factory'))
        if gsi_date_object and not gsi_error:
            dates.append((gsi_date_object, 'gsi'))
        if ota_date_object and ota_error:
            dates.append((ota_date_object, 'ota_error'))
        if factory_date_object and factory_error:
            dates.append((factory_date_object, 'factory_error'))
        if gsi_date_object and gsi_error:
            dates.append((gsi_date_object, 'gsi_error'))

        # Sort dates in descending order
        dates.sort(key=lambda x: (x[0], {'ota': 0, 'factory': 1, 'gsi': 2, 'ota_error': 3, 'factory_error': 4, 'gsi_error': 5}[x[1]]), reverse=True)

        if not dates:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to determine the latest date")
            return -1

        latest_date = dates[0][0]

        # Group dates by their value
        date_groups = {}
        for date, source in dates:
            if date not in date_groups:
                date_groups[date] = []
            date_groups[date].append(source)

        # Process groups in descending date order
        for date in sorted(date_groups.keys(), reverse=True):
            # Sort sources within each date group to maintain ota, factory, gsi order
            sources = sorted(date_groups[date], key=lambda x: {'ota': 0, 'factory': 1, 'gsi': 2, 'ota_error': 3, 'factory_error': 4, 'gsi_error': 5}[x])
            newest_data.extend(sources)

        def get_model_and_prod_list(data):
            for device in data.__dict__['devices']:
                model_list.append(device['device'])
                zip_filename = device['zip_filename']
                product = zip_filename.split('-')[0]
                product_list.append(product)
            return model_list, product_list

        # Show a dialog to list the dates and their sources
        # recommed to select the first one (newest)
        # let the user have the option to select another source if they want

        # setup the dialog options
        title = f"Select Beta print source"
        message = ""
        size = (580, 360)
        button_texts = [_('Automatic'), _('OTA Image'), _('Factory Image'), _('GSI Image'), _("Cancel")]
        default_button = 1

        message = '''
# Available Beta sources<br/>
- **Automatic:** PixelFlasher automatically chooses the most recent option.
- **OTA:** Sourced from Pixel beta OTA images.
- **Factory:** Sourced from Pixel beta factory images.
- **GSI** Sourced from Pixel GSI images.
'''

        # Additional message details
        message += f"<pre>"
        for item in dates:
            the_date = item[0]
            source = item[1]
            source = source.replace("_error", "")
            # message += f"{source}:  {the_date}\n"
            message += f"{source:<10}: {the_date.strftime('%B %d, %Y')}\n"
        message += f"</pre>"

        clean_message = message.replace("<br/>", "").replace("</pre>", "").replace("<pre>", "")
        print(f"\n*** Dialog ***\n{clean_message}\n______________\n")
        puml(":Dialog;\n", True)
        puml(f"note right\n{clean_message}\nend note\n")
        from message_box_ex import MessageBoxEx
        dlg = MessageBoxEx(
            parent=None,
            title=title,
            message=message,
            button_texts=button_texts,
            default_button=default_button,
            disable_buttons=None,
            is_md=True,
            size=size,
            checkbox_labels=None,
            checkbox_initial_values=None,
            disable_checkboxes=None,
            vertical_checkboxes=False,
            checkbox_labels2=None,
            checkbox_initial_values2=None,
            disable_checkboxes2=None,
            radio_labels=None,
            radio_initial_value=0,
            disable_radios=None,
            vertical_radios=False
        )
        dlg.CentreOnParent(wx.BOTH)
        result = dlg.ShowModal()

        dlg.Destroy()
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed {button_texts[result -1]}")

        if result == 1:
            # User selected Automatic
            pass # keep newest_data intact
        elif result == 2:
            # User selected OTA
            newest_data = ['ota']
        elif result == 3:
            # User selected Factory
            newest_data = ['factory']
        elif result == 4:
            # User selected GSI
            newest_data = ['gsi']
        else:
            # result = 5
            # user selected CANCEL
            return -1

        fingerprint = None
        security_patch = None
        for data in newest_data:
            if data in ['ota', 'ota_error'] and ota_data:
                print("  Extracting PIF from Beta OTA ...")
                selected_url = None
                if device_model == '_select_':
                    try:
                        from device_selector import show_device_selector
                        devices = ota_data.__dict__['devices']
                        selected_device = show_device_selector(
                            parent=None,
                            devices=devices,
                            title="Select OTA Device",
                            message="Select an OTA device:"
                        )

                        if selected_device:
                            selected_url = selected_device['url']
                            # Extract codename from zip filename (format: codename-buildid-*.zip)
                            zip_filename = selected_device['zip_filename']
                            device_model = zip_filename.split('-')[0]
                            device_model = device_model.lower().replace('_beta', '').replace('beta_', '')
                            print(f"  Selected: {selected_device['device']} - {selected_device['zip_filename']}")
                        else:
                            print("Selection cancelled.")
                            return "Selection cancelled."
                    except ImportError:
                        selected_url = None
                elif device_model != 'random':
                    # Try to find a device that matches the requested device model
                    for device in ota_data.__dict__['devices']:
                        if device_model.lower() in device['zip_filename'].lower():
                            selected_url = device['url']
                            debug(f"  Found matching OTA device: {device['zip_filename']}")
                            break
                # Fall back to last device if no match found or if random was requested
                if selected_url is None:
                    selected_url = ota_data.__dict__['devices'][-1]['url']
                    debug(f"  Using last OTA device: {ota_data.__dict__['devices'][-1]['zip_filename']}")
                # Grab fp and sp from selected OTA zip
                fingerprint, security_patch = url2fpsp(selected_url, "ota", state=state)
                # Check if abort was triggered (but not if we got valid results - stop_event is set on success too)
                if state and state.stop_event.is_set() and (not fingerprint or not security_patch):
                    debug("Processing aborted by user in OTA")
                    return -1
                if fingerprint and security_patch:
                    model_list = []
                    product_list = []
                    model_list, product_list = get_model_and_prod_list(ota_data)
                    expiry_date = ota_data.__dict__['beta_expiry_date']
                    if model_list and product_list:
                        break
            elif data in ['factory', 'factory_error'] and factory_data:
                print("  Extracting PIF from Beta Factory ...")
                selected_url = None
                if device_model == '_select_':
                    try:
                        from device_selector import show_device_selector
                        devices = factory_data.__dict__['devices']
                        selected_device = show_device_selector(
                            parent=None,
                            devices=devices,
                            title="Select Factory Device",
                            message="Select a Factory device:"
                        )
                        if selected_device:
                            selected_url = selected_device['url']
                            # Extract codename from zip filename (format: codename-buildid-*.zip)
                            zip_filename = selected_device['zip_filename']
                            device_model = zip_filename.split('-')[0]
                            device_model = device_model.lower().replace('_beta', '').replace('beta_', '')
                            print(f"  Selected: {selected_device['device']} - {selected_device['zip_filename']}")
                        else:
                            print("Selection cancelled.")
                            return "Selection cancelled."
                    except ImportError:
                        selected_url = None
                elif device_model != 'random':
                    # Try to find a device that matches the requested model
                    for device in factory_data.__dict__['devices']:
                        if device_model.lower() in device['zip_filename'].lower():
                            selected_url = device['url']
                            debug(f"  Found matching Factory device: {device['zip_filename']}")
                            break
                # Fall back to last device if no match found or if random was requested
                if selected_url is None:
                    selected_url = factory_data.__dict__['devices'][-1]['url']
                    debug(f"  Using last Factory device: {factory_data.__dict__['devices'][-1]['zip_filename']}")
                # Grab fp and sp from selected Factory zip
                fingerprint, security_patch = url2fpsp(selected_url, "factory", state=state)
                # Check if abort was triggered (but not if we got valid results - stop_event is set on success too)
                if state and state.stop_event.is_set() and (not fingerprint or not security_patch):
                    debug("Processing aborted by user in Factory")
                    return -1
                if fingerprint and security_patch:
                    model_list = []
                    product_list = []
                    model_list, product_list = get_model_and_prod_list(factory_data)
                    expiry_date = factory_data.__dict__['beta_expiry_date']
                    if model_list and product_list:
                        break
            elif data in ['gsi', 'gsi_error'] and gsi_data:
                print(f"  Extracting beta print from GSI data version {latest_version} ...")
                fingerprint, security_patch = url2fpsp(gsi_data.__dict__['devices'][0]['url'], "gsi", state=state)
                # Check if abort was triggered (but not if we got valid results - stop_event is set on success too)
                if state and state.stop_event.is_set() and (not fingerprint or not security_patch):
                    debug("Processing aborted by user in GSI")
                    return -1
                incremental = gsi_data.__dict__['incremental']
                expiry_date = gsi_data.__dict__['beta_expiry_date']
                model_list = gsi_data.__dict__['model_list']
                product_list = gsi_data.__dict__['product_list']
                security_patch_level = gsi_data.__dict__['security_patch_level']
                if not model_list or not product_list:
                    model_list = []
                    product_list = []
                    if factory_data:
                        model_list, product_list = get_model_and_prod_list(factory_data)
                if not model_list or not product_list:
                    model_list = []
                    product_list = []
                    if ota_data:
                        model_list, product_list = get_model_and_prod_list(ota_data)
                if model_list and product_list:
                    if not security_patch:
                        # Make sur security_patch_level to YYYY-MM-DD format
                        try:
                            if security_patch_level:
                                # Handle month name format like "September 2020"
                                try:
                                    date_obj = datetime.strptime(security_patch_level, "%B %Y")
                                    security_patch = date_obj.strftime("%Y-%m-05")
                                except ValueError:
                                    # Try other common formats
                                    try:
                                        # handle YYYY-MM format
                                        if re.match(r'^\d{4}-\d{2}$', security_patch_level):
                                            security_patch = f"{security_patch_level}-05"
                                        # handle YYYY-MM-DD format already
                                        elif re.match(r'^\d{4}-\d{2}-\d{2}$', security_patch_level):
                                            security_patch = security_patch_level
                                        else:
                                            # fallback
                                            security_patch = security_patch_level
                                    except:
                                        security_patch = security_patch_level
                            else:
                                security_patch = ""
                        except Exception as e:
                            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to parse security patch level: {security_patch_level}")
                            security_patch = security_patch_level  # Fallback to original value
                    if not fingerprint:
                        build_id = gsi_data.__dict__['build']
                        fingerprint = f"google/gsi_gms_arm64/gsi_arm64:{latest_version}/{build_id}/{incremental}:user/release-keys"
                    if fingerprint and security_patch:
                        break

    build_type = 'user'
    build_tags = 'release-keys'
    if fingerprint and security_patch:
        print(f"Security Patch:           {security_patch}")
        # Extract props from fingerprint
        pattern = r'([^\/]*)\/([^\/]*)\/([^:]*):([^\/]*)\/([^\/]*)\/([^:]*):([^\/]*)\/([^\/]*)$'
        match = re.search(pattern, fingerprint)
        if match and match.lastindex == 8:
            # product_brand = match[1]
            # product_name = match[2]
            # product_device = match[3]
            latest_version = match[4]
            build_id = match[5]
            incremental = match[6]
            if not canary_data:
                build_type = match[7]
                build_tags = match[8]

    def set_random_beta():
        list_count = len(model_list)
        list_rand = random.randint(0, list_count - 1)
        model = model_list[list_rand]
        product = product_list[list_rand]
        device = product.replace('_beta', '')
        return model, product, device

    def get_pif_data(model, product, device, latest_version, build_id, incremental, security_patch, build_type='user', build_tags='release-keys'):
        pif_data = {
            "MANUFACTURER": "Google",
            "MODEL": model,
            "FINGERPRINT": f"google/{product}/{device}:{latest_version}/{build_id}/{incremental}:{build_type}/{build_tags}",
            "PRODUCT": product,
            "DEVICE": device,
            "SECURITY_PATCH": security_patch,
            "DEVICE_INITIAL_SDK_INT": "32"
        }
        return pif_data

    if device_model and product_list and f"{device_model}_beta" in product_list:
        product = f"{device_model}_beta"
        model = model_list[product_list.index(product)]
        device = device_model
    elif device_model == 'all':
        json_string = ""
        i = 0
        for item in model_list:
            model = item
            product = product_list[i]
            device = product.replace('_beta', '')
            pif_data = get_pif_data(model, product, device, latest_version, build_id, incremental, security_patch, build_type, build_tags)
            # {
            #     "MANUFACTURER": "Google",
            #     "MODEL": model,
            #     "FINGERPRINT": f"google/{product}/{device}:{latest_version}/{build_id}/{incremental}:{build_type}/{build_tags}",
            #     "PRODUCT": product,
            #     "DEVICE": device,
            #     "SECURITY_PATCH": security_patch,
            #     "DEVICE_INITIAL_SDK_INT": "32"
            # }
            json_string += json.dumps(pif_data, indent=4) + "\n"
            i = i + 1
        print(f"Beta Print Expiry Date:   {expiry_date}")
        print(f"Pixel Beta Profile/Fingerprint:\n{json_string}")
        return json_string
    else:
        if model_list and product_list:
            model, product, device = set_random_beta()
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: No beta data found.")
            return "No beta print found for the selected version."

    # Dump values to pif.json
    pif_data = get_pif_data(model, product, device, latest_version, build_id, incremental, security_patch, build_type, build_tags)
    # pif_data = {
    #     "MANUFACTURER": "Google",
    #     "MODEL": model,
    #     "FINGERPRINT": f"google/{product}/{device}:{latest_version}/{build_id}/{incremental}:{build_type}/{build_tags}",
    #     "PRODUCT": product,
    #     "DEVICE": device,
    #     "SECURITY_PATCH": security_patch,
    #     "DEVICE_INITIAL_SDK_INT": "32"
    # }

    random_print_json = json.dumps(pif_data, indent=4)
    print(f"{beta_type} Print Expiry Date:   {expiry_date}")
    print(f"Random {beta_type} Profile/Fingerprint:\n{random_print_json}\n")
    return random_print_json


# ============================================================================
#                               Function get_beta_data
# ============================================================================
def get_beta_data(url):
    try:
        debug(f"Fetching beta data from URL: {url}")
        response = requests.get(url)
        if response.status_code != 200:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch URL: {url}")
            return None, None
        ota_html = response.text

        soup = BeautifulSoup(ota_html, 'html.parser')

        # check if the page has beta in it.
        if 'beta' not in soup.get_text().lower():
            # print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: 'Beta' not found For URL: {url}")
            return None, None

        # Extract information from the first table
        table = soup.find('table', class_='responsive fixed')

        # If metadata table is missing, try to fetch it from alternate pages
        if not table:
            # Determine base URL to construct alternates
            # Typical URLs:
            # .../versions/16/qpr3/download-ota
            # .../versions/16/qpr3/download
            # .../versions/16/download-ota

            base_url = url.rsplit('/', 1)[0]
            current_endpoint = url.rsplit('/', 1)[1]

            alternates = []

            # 1. Try the counterpart (download <-> download-ota)
            if 'download-ota' in current_endpoint:
                alternates.append(f"{base_url}/download")
            elif 'download' in current_endpoint:
                alternates.append(f"{base_url}/download-ota")

            # 2. Try release notes
            alternates.append(f"{base_url}/release-notes")

            for alt_url in alternates:
                debug(f"ℹ️ Metadata table not found, checking alternate URL: {alt_url}")
                try:
                    alt_resp = requests.get(alt_url)
                    if alt_resp.status_code == 200:
                        alt_soup = BeautifulSoup(alt_resp.text, 'html.parser')
                        table = alt_soup.find('table', class_='responsive fixed')
                        if table:
                            debug(f"  ✅ Found metadata table at {alt_url}")
                            break
                except Exception as e:
                    print(f"  ❌ Failed to fetch alternate metadata from {alt_url}: {e}")

        release_date = None
        build = None
        emulator_support = None
        security_patch_level = None
        google_play_services = None
        beta_expiry_date = None

        if table:
            rows = table.find_all('tr')
            data = {}
            for row in rows:
                cols = row.find_all('td')
                if len(cols) >= 2:
                    key = cols[0].text.strip().lower().replace(' ', '_')
                    value = cols[1].text.strip()
                    data[key] = value

            release_date = data.get('release_date')
            build = data.get('build')
            if not build:
                wx.Yield()
                # try again to get the build, this time looking for builds
                build = data.get('builds')
            if not build:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Build(s) not found in the data.")
                return None, None
            else:
                # we might get an output like this: 'BP31.250610.004\n      BP31.250610.004.A1 (Pixel 6, 6 Pro)'
                # we need to extract the first build from it, but we also need to keep the other builds for later
                # when we're extracting the devices, we need to match the build with the device.
                builds = build.split('\n')
                if len(builds) > 1:
                    print(f"ℹ️ Multiple Builds are found, selecting the first one: {builds[0].strip()}")
                    build = builds[0].strip()  # Take the first build only
                    print(f"ℹ️ Selected Build:           {build}")
                else:
                    print(f"ℹ️ Single Build is found: {builds[0].strip()}")
                    build = builds[0].strip()
            emulator_support = data.get('emulator_support')
            security_patch_level = data.get('security_patch_level')
            google_play_services = data.get('google_play_services')

            if release_date:
                try:
                    beta_release_date = datetime.strptime(release_date, '%B %d, %Y').strftime('%Y-%m-%d')
                    beta_expiry = datetime.strptime(beta_release_date, '%Y-%m-%d') + timedelta(weeks=6)
                    beta_expiry_date = beta_expiry.strftime('%Y-%m-%d')
                except:
                    pass
        elif soup.find('table', id='images'):
            debug(f"⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Metadata table not found, using dummy metadata.")
            release_date = datetime.now().strftime("%B %d, %Y")
            build = "Unknown"
            emulator_support = "Unknown"
            security_patch_level = "Unknown"
            google_play_services = "Unknown"
            beta_expiry_date = (datetime.now() + timedelta(weeks=6)).strftime('%Y-%m-%d')
        else:
            # print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Required table is not found on the page.")
            return None, None

        # Extract information from the second table
        devices = []
        table = soup.find('table', id='images')
        rows = table.find_all('tr')[1:]  # Skip the header row
        error = False
        for row in rows:
            cols = row.find_all('td')
            device = cols[0].text.strip()
            button = cols[1].find('button')
            category = button['data-category']
            zip_filename = button.text.strip()
            hashcode = cols[1].find('code').text.strip()

            # Check if the build is present in the zip_filename, if not print a warning
            if not build:
                # If we have no build info, we can't verify, but we shouldn't fail the whole process
                pass
            if build and build != "Unknown" and build.lower() not in zip_filename.lower():
                print(f"⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Build '{build}' not found in zip filename '{zip_filename}' for device '{device}'")
                error = True

            # check if the first 8 characters of the hashcode is not in the zip_filename, if not print a warning
            if hashcode[:8].lower() not in zip_filename.lower():
                print(f"⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Hashcode '{hashcode[:8]}' not found in zip filename '{zip_filename}' for device '{device}'")
                error = True

            devices.append({
                'device': device,
                'category': category,
                'zip_filename': zip_filename,
                'hash': hashcode,
                'url': None,  # Placeholder for URL
                'error': error
            })

        # Find all hrefs and match with zip_filename
        for a_tag in soup.find_all('a', href=True):
            href = a_tag['href']
            for device in devices:
                if device['zip_filename'] in href:
                    device['url'] = href
                    break
        incremental = ""
        security_patch = ""
        beta_data = BetaData(release_date, build, emulator_support, security_patch_level, google_play_services, beta_expiry_date, incremental, security_patch, devices)
        return beta_data, error
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_beta_data function")
        traceback.print_exc()
        return None, None


# ============================================================================
#                               Function get_latest_android_version
# ============================================================================
def get_latest_android_version(force_version=None):
    versions_url = "https://developer.android.com/about/versions"
    response = request_with_fallback('GET', versions_url)
    if response == 'ERROR' or response.status_code != 200:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch VERSIONS HTML")
        return -1, ''
    versions_html = response.text

    soup = BeautifulSoup(versions_html, 'html.parser')
    version = 0
    beta_link_url = ''
    beta_links = {}

    for link in soup.find_all('a'):
        # Look for Android Beta link
        span = link.find('span', class_='devsite-nav-text')
        if span and span.get_text(strip=True) == 'Android Beta':
            beta_href = link.get('href')
            if beta_href:
                # Convert relative URL to absolute if needed
                if beta_href.startswith('/'):
                    full_url = f"https://developer.android.com{beta_href}"
                else:
                    full_url = beta_href

                # Extract version from URL
                match = re.search(r'about/versions/(\d+)', full_url)
                if match:
                    ver = int(match.group(1))
                    # Only store if not already present (assuming descending order on page, first is newest)
                    if ver not in beta_links:
                        beta_links[ver] = full_url

        # Look for version links
        href = link.get('href')
        if href and re.match(r'https:\/\/developer\.android\.com\/about\/versions\/\d+', href):
            # capture the d+ part
            link_version = int(re.search(r'\d+', href).group())
            if force_version and not str(force_version).startswith('CANARY'):
                if link_version == force_version:
                    version = link_version
            else:
                if link_version > version:
                    version = link_version

    # Determine best beta link
    if force_version and not str(force_version).startswith('CANARY'):
        # Try to find beta link for forced version
        try:
            force_ver_int = int(force_version)
            if force_ver_int in beta_links:
                beta_link_url = beta_links[force_ver_int]
        except ValueError:
            pass
    else:
        # Find highest version in beta_links
        if beta_links:
            max_ver = max(beta_links.keys())
            beta_link_url = beta_links[max_ver]

    # Check for QPR updates on the specific version page
    if version > 0:
        version_page_url = f"https://developer.android.com/about/versions/{version}"
        print(f"Checking for QPR updates on {version_page_url}...")
        try:
            v_response = request_with_fallback('GET', version_page_url)
            if v_response != 'ERROR' and v_response.status_code == 200:
                v_soup = BeautifulSoup(v_response.text, 'html.parser')
                max_qpr = 0
                qpr_url = ""

                for link in v_soup.find_all('a'):
                    href = link.get('href')
                    if href:
                        # Check for qpr pattern: .../versions/{version}/qpr(\d+)
                        match = re.search(rf'about/versions/{version}/qpr(\d+)', href)
                        if match:
                            qpr_num = int(match.group(1))
                            if qpr_num > max_qpr:
                                max_qpr = qpr_num
                                # Construct base QPR url
                                qpr_url = f"https://developer.android.com/about/versions/{version}/qpr{qpr_num}"

                if max_qpr > 0:
                    print(f"Found newer QPR version:  QPR{max_qpr}")
                    beta_link_url = qpr_url
        except Exception as e:
            print(f"Failed to check for QPR updates: {e}")

    # Resolve any redirects in the beta_link_url
    if beta_link_url and 'qpr' not in beta_link_url.lower():
        beta_link_url = resolve_url_redirects(beta_link_url)

    return version, beta_link_url


# ============================================================================
#                               Function resolve_url_redirects
# ============================================================================
def resolve_url_redirects(url, max_redirects=5):
    try:
        if not url:
            return url

        current_url = url
        redirect_count = 0

        while redirect_count < max_redirects:
            response = request_with_fallback('HEAD', current_url)
            if response == 'ERROR':
                debug(f"Failed to check redirects for URL: {current_url}")
                return current_url

            if response.history:
                # There was a redirect, use the final URL
                new_url = response.url
                debug(f"URL redirected from {current_url} to: {new_url}")

                # Check if we've reached a stable URL (no more redirects)
                if new_url == current_url:
                    break

                current_url = new_url
                redirect_count += 1
            else:
                # No redirect, we've found the final URL
                break

        if redirect_count >= max_redirects:
            debug(f"Maximum redirect limit ({max_redirects}) reached for URL: {url}")

        return current_url

    except Exception as e:
        debug(f"Failed to resolve redirects for URL {url}: {e}")
        return url


# ============================================================================
#                Function get_fp_sp_from_ota_http_range
# ============================================================================
def get_fp_sp_from_ota_http_range(url, state=None, chunk_size=8*1024*1024, overlap=200):
    try:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", urllib3.exceptions.InsecureRequestWarning)

            # Get the file size
            total_size = get_size_from_url(url)
            if total_size is None:
                print(f"⚠️ Could not determine file size for {url}.")
                return None, None

            fingerprint = None
            security_patch = None

            # Set up regex patterns for OTA
            fp_pattern_complete = r"post-build=(.+?)(\s|$)"
            sp_pattern_complete = r"security-patch-level=(.+?)(\s|$)"

            debug(f"Starting OTA chunked download with chunk_size=0x{chunk_size:x}, overlap=0x{overlap:x}")
            i = 0
            while fingerprint is None or security_patch is None:
                # Check if abort was triggered
                if state and state.stop_event.is_set():
                    debug("OTA processing aborted by user")
                    return None, None

                # Calculate start and end ranges with overlap
                start_range = i * chunk_size
                end_range = ((i + 1) * chunk_size) + overlap

                # Check if we've reached the end of the file
                if start_range >= total_size:
                    debug(f"Reached end of file at position {start_range}")
                    break

                # Adjust end_range if it exceeds file size
                if end_range > total_size:
                    end_range = total_size

                # Request range of bytes
                headers = {
                    "Range": f"bytes={start_range}-{end_range - 1}",
                    "Accept-Encoding": "identity"  # Disable compression to avoid gzip issues
                }
                # debug(f"Fetching bytes {start_range} to {end_range - 1} from {url}")
                debug(f"Fetching bytes 0x{start_range:x} to 0x{(end_range - 1):x}")
                wx.Yield()

                try:
                    response = requests.get(url, headers=headers, stream=True, verify=False, timeout=30)

                    if response.status_code == 206:  # Partial content success
                        ## Optional save each binary chunk to file for debugging
                        #
                        # config_path = get_config_path()
                        # debug_dir = os.path.join(config_path, 'debug_chunks')
                        # os.makedirs(debug_dir, exist_ok=True)
                        # chunk_filename = os.path.join(debug_dir, f"chunk_{start_range}_{end_range - 1}.bin")
                        # with open(chunk_filename, 'wb') as chunk_file:
                        #     chunk_file.write(response.content)
                        # print(f"Saved chunk to {chunk_filename}")

                        content = response.content.decode('utf-8', errors='ignore')

                        # Search for fingerprint
                        if fingerprint is None:
                            fp_match = re.search(fp_pattern_complete, content)
                            if fp_match:
                                fingerprint = fp_match.group(1).strip('\x00')
                                debug(f"Found fingerprint: {fingerprint}")
                                wx.Yield()

                        # Search for security patch
                        if security_patch is None:
                            sp_match = re.search(sp_pattern_complete, content)
                            if sp_match:
                                security_patch = sp_match.group(1).strip('\x00')
                                debug(f"Found security patch: {security_patch}")
                                wx.Yield()

                        i += 1
                    else:
                        debug(f"Server returned status {response.status_code}, cannot use partial content")
                        break

                except Exception as e:
                    debug(f"Error fetching range {start_range}-{end_range}: {e}")
                    break

            return fingerprint, security_patch

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_fp_sp_from_ota_http_range function")
        traceback.print_exc()
        return None, None


# ============================================================================
#                               Function url2fpsp
# ============================================================================
def url2fpsp(url, image_type, override_size_limit=None, state=None):
    try:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", urllib3.exceptions.InsecureRequestWarning)

            fingerprint = None
            security_patch = None

            # For OTA images, use HTTP Range requests (more efficient for smaller files)
            if image_type == 'ota':
                chunk_size = override_size_limit if override_size_limit is not None else 8*1024*1024
                fingerprint, security_patch = get_fp_sp_from_ota_http_range(url, state=state, chunk_size=chunk_size)

            # For factory images, use streaming download
            elif image_type == 'factory':
                chunk_size = override_size_limit if override_size_limit is not None else None
                fingerprint, security_patch = get_fp_sp_from_incremental_remote_file(url, image_type, chunk_size, state=state)

            elif image_type == 'gsi':
                response = requests.head(url)
                file_size = int(response.headers["Content-Length"])
                start_byte = max(0, file_size - 8192)
                headers = {
                    "Range": f"bytes={start_byte}-{file_size - 1}",
                    "Accept-Encoding": "identity"  # Disable compression
                }
                response = requests.get(url, headers=headers, stream=True, verify=False)
                end_content = response.content
                content = partial_extract(end_content, "build.prop")
                if content is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to extract build.prop from GSI content")
                    return None, None
                content_str = content.decode('utf-8', errors='ignore')
                fingerprint_match = re.search(r"ro\.system\.build\.fingerprint=(.+)", content_str)
                security_patch_match = re.search(r"ro\.build\.version\.security_patch=(.+)", content_str)

                fingerprint = fingerprint_match.group(1).strip('\x00') if fingerprint_match else None
                security_patch = security_patch_match.group(1).strip('\x00') if security_patch_match else None

            elif image_type == 'canary':
                response = requests.get(url, stream=True, verify=False)
                content = response.content.decode('utf-8', errors='ignore')
                fingerprint_match = re.search(r"^FINGERPRINT=(.+)", content, re.MULTILINE)
                security_patch_match = re.search(r"^SECURITY_PATCH=(.+)", content, re.MULTILINE)
                expiry_date_match = re.search(r"^#\sEstimated\sExpiry:\s(.+)", content, re.MULTILINE)
                if fingerprint_match:
                    fingerprint = fingerprint_match.group(1).strip()
                if security_patch_match:
                    security_patch = security_patch_match.group(1).strip()
                if expiry_date_match:
                    expiry_date = expiry_date_match.group(1).strip()
                return fingerprint, security_patch, expiry_date

            else:
                print(f"Invalid image type: {image_type}")
                return None, None

            # debug("FINGERPRINT:", fingerprint)
            # debug("SECURITY_PATCH:", security_patch)
            return fingerprint, security_patch
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in url2fpsp function")
        traceback.print_exc()
        return None, None


# ============================================================================
#                Function get_fp_sp_from_incremental_remote_file
# ============================================================================
def get_fp_sp_from_incremental_remote_file(url, image_type, chunk_size=None, overlap=None, fallback_size=60*1024*1024, state=None):
    try:
        # Use provided state or create new one
        if state is None:
            state = DownloadState()
        config = get_config()

        # Use config values if not provided
        if chunk_size is None:
            chunk_size = config.pif_chunk_size
        if overlap is None:
            overlap = config.pif_chunk_overlap

        fingerprint = None
        security_patch = None

        # Set up regex patterns based on image type
        if image_type == 'ota':
            fp_pattern_complete = r"post-build=(.+?)(\s|$)"
            sp_pattern_complete = r"security-patch-level=(.+?)(\s|$)"
        elif image_type == 'factory':
            fp_pattern_complete = r"com\.android\.build\.boot\.fingerprint(.+?)\x00"
            sp_pattern_complete = r"com\.android\.build\.boot\.security_patch(.+?)\x00"
        else:
            print(f"Unsupported image type: {image_type}")
            return None, None

        # Extract filename from URL for temp file
        filename = url.split('/')[-1]
        if not filename:
            filename = "downloaded_image.zip"
        temp_file_path = os.path.join(tempfile.gettempdir(), filename)
        debug(f"Streaming download to temp file: {temp_file_path}")

        # Start download thread (daemon)
        debug(f"Starting download thread")
        download_t = threading.Thread(target=download_thread, args=(state, url, temp_file_path), daemon=True)
        download_t.start()

        # Processing in MAIN THREAD
        i = 0
        while not state.stop_event.is_set():
            wx.Yield()
            start_pos = i * chunk_size
            end_pos = start_pos + chunk_size + overlap

            # Wait for enough data to be downloaded
            while state.downloaded_bytes < end_pos:
                if state.download_complete:
                    break
                if state.stop_event.is_set():
                    break
                # debug(f"Waiting for download... Downloaded {state.downloaded_bytes} bytes, need at least {end_pos} bytes")
                time.sleep(0.1)

            if state.stop_event.is_set():
                break

            # Check if we've processed everything
            if state.download_complete and start_pos >= state.downloaded_bytes:
                break

            # Read chunk from file
            try:
                with open(temp_file_path, 'rb') as f:
                    f.seek(start_pos)
                    chunk_data = f.read(chunk_size + overlap)
            except Exception as e:
                debug(f"Error reading chunk: {e}")
                time.sleep(0.1)
                continue

            if not chunk_data:
                if state.download_complete:
                    break
                time.sleep(0.1)
                continue

            # Determine actual end position
            actual_end = start_pos + len(chunk_data)

            # Search in the chunk
            content = chunk_data.decode('utf-8', errors='ignore')

            # Search for fingerprint
            if fingerprint is None:
                fp_match = re.search(fp_pattern_complete, content)
                if fp_match:
                    fingerprint = fp_match.group(1).strip('\x00')
                    state.fingerprint = fingerprint
                    debug(f"Found fingerprint: {fingerprint}")

            # Search for security patch
            if security_patch is None:
                sp_match = re.search(sp_pattern_complete, content)
                if sp_match:
                    security_patch = sp_match.group(1).strip('\x00')
                    state.security_patch = security_patch
                    debug(f"Found security patch: {security_patch}")

            # Stop only if BOTH are found
            if fingerprint and security_patch:
                debug(f"Found both fingerprint and security patch, stopping")
                state.stop_event.set()
                break

            # Progress reporting
            if state.file_size > 0:
                # Always show processing progress
                percent = (actual_end * 100) // state.file_size
                debug(f"Processing bytes 0x{start_pos:x} to 0x{actual_end:x} ({percent}%)")

                # Show download progress only if not 100% complete
                if state.downloaded_bytes < state.file_size:
                    percent_dl = (state.downloaded_bytes * 100) // state.file_size
                    debug(f"Downloaded {state.downloaded_bytes}/{state.file_size} bytes ({percent_dl}%)")
            else:
                debug(f"Processing bytes 0x{start_pos:x} to 0x{actual_end:x}")

            i += 1

        # Wait for download thread to finish
        download_t.join(timeout=5)

        # If found, return (delete temp file on early exit)
        if fingerprint and security_patch:
            debug(f"Found fingerprint: {fingerprint}, security_patch: {security_patch}")
            try:
                os.remove(temp_file_path)
                debug(f"Deleted temp file after early exit")
            except Exception as e:
                debug(f"Failed to delete temp file: {e}")
            return fingerprint, security_patch

        # If not found after processing all chunks, try fallback
        if fingerprint is None or security_patch is None:
            # Check if we were aborted
            if state.stop_event.is_set():
                debug("Processing aborted by user, skipping fallback")
                return None, None

            # Check if download is complete before attempting fallback
            if not state.download_complete:
                debug(f"Download incomplete ({state.downloaded_bytes}/{state.file_size} bytes), cannot use fallback")
                return None, None

            if os.path.exists(temp_file_path):
                debug(f"Processing full file with get_pif_from_image: {temp_file_path}")
                try:
                    props_dir = get_pif_from_image(temp_file_path)
                    if props_dir and os.path.exists(props_dir):
                        # Read prop files from the props directory
                        prop_files = [os.path.join(props_dir, f) for f in os.listdir(props_dir) if os.path.isfile(os.path.join(props_dir, f))]
                        if prop_files:
                            # Parse prop files into a dictionary
                            processed_dict = {}
                            for pathname in prop_files:
                                with open(pathname, 'r', encoding='ISO-8859-1', errors="replace") as f:
                                    content = f.readlines()
                                contentList = [x.strip().split('#')[0].split('=', 1) for x in content if '=' in x.split('#')[0]]
                                contentDict = dict(contentList)
                                processed_dict.update(contentDict)

                            # Extract fingerprint
                            if fingerprint is None:
                                fp_keys = ['ro.build.fingerprint', 'ro.system.build.fingerprint', 'ro.product.build.fingerprint', 'ro.vendor.build.fingerprint']
                                for key in fp_keys:
                                    if key in processed_dict:
                                        fingerprint = processed_dict[key]
                                        debug(f"Found fingerprint from build.prop: {fingerprint}")
                                        break

                            # Extract security_patch
                            if security_patch is None:
                                sp_keys = ['ro.build.version.security_patch', 'ro.system.build.version.security_patch', 'ro.vendor.build.version.security_patch']
                                for key in sp_keys:
                                    if key in processed_dict:
                                        security_patch = processed_dict[key]
                                        debug(f"Found security_patch from build.prop: {security_patch}")
                                        break

                            if fingerprint and security_patch:
                                debug(f"Successfully extracted from full file processing")
                                # Keep temp file for debugging
                                return fingerprint, security_patch
                except Exception as e:
                    debug(f"Error processing with get_pif_from_image: {e}")

        # If still not found
        if fingerprint is None or security_patch is None:
            print(f"⚠️ Could not extract required information.")

        # Clean up temp file if it still exists
        if os.path.exists(temp_file_path):
            try:
                os.remove(temp_file_path)
                debug(f"Deleted temp file: {temp_file_path}")
            except Exception as e:
                debug(f"Failed to delete temp file: {e}")

        return fingerprint, security_patch

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_fp_sp_from_incremental_remote_file")
        traceback.print_exc()
        # Clean up temp file on exception
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            try:
                os.remove(temp_file_path)
                debug(f"Deleted temp file after exception: {temp_file_path}")
            except Exception:
                pass
        return None, None


# ============================================================================
#                Function download_thread
# ============================================================================
def download_thread(state, url, temp_file_path):
    try:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", urllib3.exceptions.InsecureRequestWarning)

            # Get file size first
            response_head = requests.head(url, verify=False, timeout=30)
            state.file_size = int(response_head.headers.get('Content-Length', 0))
            debug(f"File size: {state.file_size} bytes")

            # Open temp file for writing
            temp_file = open(temp_file_path, 'wb')

            # Stream download
            headers = {"Accept-Encoding": "identity"}
            response = requests.get(url, headers=headers, stream=True, verify=False, timeout=60)

            try:
                while not state.stop_event.is_set():
                    data = response.raw.read(8192)

                    if not data:
                        # Check if we've reached end of stream
                        time.sleep(0.1)
                        data = response.raw.read(8192)
                        if not data:
                            break

                    temp_file.write(data)
                    state.downloaded_bytes += len(data)

            finally:
                temp_file.close()
                state.download_complete = True
                debug(f"Download thread complete: {state.downloaded_bytes} bytes")

    except Exception as e:
        debug(f"Download thread error: {e}")
        state.download_complete = True


# ============================================================================
#                               Function partial_extract
# ============================================================================
def partial_extract(content, extract_file):
    try:
        with zipfile.ZipFile(io.BytesIO(content)) as zip_file:
            debug(f"Files in the partial ZIP content:")
            debug(zip_file.namelist())
            # Extracting a specific file by name
            with zip_file.open(extract_file) as file:
                content = file.read()
                return content
    except zipfile.BadZipFile as e:
        print("Unable to read ZIP file:", e)
    except KeyError:
        print("Target file not found in ZIP content.")
    except Exception as e:
        print("An error occurred:", e)


# ============================================================================
#                               Function format_memory_size
# ============================================================================
def get_printable_memory():
    try:
        free_memory, total_memory = get_free_memory()
        formatted_free_memory = format_memory_size(free_memory)
        formatted_total_memory = format_memory_size(total_memory)
        return f"Available Free Memory: {formatted_free_memory} / {formatted_total_memory}"
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_printable_memory function")
        traceback.print_exc()


# ============================================================================
#                               Function device_has_update
# ============================================================================
def device_has_update(data, device_id, target_date):
    try:
        if not data:
            return False
        if device_id in data:
            device_data = data[device_id]

            for download_type in ['ota', 'factory']:
                for download_entry in device_data[download_type]:
                    download_date = download_entry['date']
                    # Compare the download date with the target date
                    if download_date > target_date:
                        return True
        return False
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in device_has_update function")
        traceback.print_exc()


# ============================================================================
#                     Function fetch_canary_miner_catalog
# ============================================================================
def fetch_canary_miner_catalog(catalog_path=None):
    if catalog_path is None:
        catalog_path = os.path.join(get_config_path(), 'canary_miner_catalog.json').strip()

    try:
        from constants import CANARY_MINER_CATALOG_URL
        catalog_url = CANARY_MINER_CATALOG_URL
        if 'github.com' in catalog_url and '/blob/' in catalog_url:
            catalog_url = catalog_url.replace('https://github.com/', 'https://raw.githubusercontent.com/').replace('/blob/', '/')

        res = request_with_fallback(method='GET', url=catalog_url)
        if res == 'ERROR':
            return None, catalog_path

        content = res.content if hasattr(res, 'content') else res.text
        text = content if isinstance(content, str) else content.decode('utf-8', errors='replace')

        try:
            catalog_json = json.loads(text)
            with open(catalog_path, 'w', encoding='utf-8') as f:
                json.dump(catalog_json, f, indent=2)
            return catalog_json, catalog_path
        except Exception:
            with open(catalog_path, 'w', encoding='utf-8') as f:
                f.write(text)
            return None, catalog_path
    except Exception:
        return (None, catalog_path) if catalog_path else (None, None)


# ============================================================================
#                               Function get_google_images
# ============================================================================
def get_google_images(save_to=None):
    try:
        COOKIE = {'Cookie': 'devsite_wall_acks=nexus-ota-tos,nexus-image-tos,watch-image-tos,watch-ota-tos'}
        data = {}

        if save_to is None:
            save_to = os.path.join(get_config_path(), "google_images.json").strip()

        # Fetch the Beta OTA and Beta Factory image data
        ota_beta_data, factory_beta_data, ota_error, factory_error = get_beta_links()
        if ota_beta_data.build:
            ota_build_id = ota_beta_data.build
        else:
            ota_build_id = ''
        if factory_beta_data.build:
            factory_build_id = factory_beta_data.build
        else:
            factory_build_id = ''

        for image_type in ['ota', 'factory', 'ota-watch', 'factory-watch']:
            if image_type == 'ota':
                url = "https://developers.google.com/android/ota"
                download_type = "ota"
                device_type = "phone"
            elif image_type == 'factory':
                url = "https://developers.google.com/android/images"
                download_type = "factory"
                device_type = "phone"
            elif image_type == 'ota-watch':
                url = "https://developers.google.com/android/ota-watch"
                download_type = "ota"
                device_type = "watch"
            elif image_type == 'factory-watch':
                url = "https://developers.google.com/android/images-watch"
                download_type = "factory"
                device_type = "watch"

            response = request_with_fallback(method='GET', url=url, headers=COOKIE)
            if response != 'ERROR':
                html = response.content
                soup = BeautifulSoup(html, 'html.parser')
                marlin_flag = False

                # Find all the <h2> elements containing device names
                device_elements = soup.find_all('h2')
            else:
                device_elements = []

            # Iterate through the device elements
            for device_element in device_elements:
                # Check if the text of the <h2> element should be skipped
                if device_element.text.strip() in [
                        "Terms and conditions",
                        "Updating instructions",
                        "Updating Pixel 6, Pixel 6 Pro, and Pixel 6a devices to Android 13 for the first time",
                        "Use Android Flash Tool",
                        "Flashing instructions",
                        "Special instructions for updating Pixel 6, Pixel 6 Pro, and Pixel 6a devices to Android 13 for the first time",
                        "Manual flashing instructions",
                        "Special instructions for updating Pixel devices to the May 2025 monthly release"
                    ]:
                    continue

                # Extract the device name from the 'id' attribute
                device_id = device_element.get('id')

                # Skip if device_id is None or empty or one of the known invalid ids
                if not device_id or device_id in [
                        "key-takeaways-panel-title"
                    ]:
                    continue

                                # Extract the device name from the 'id' attribute
                device_class = device_element.get('class')
                if device_class and ("no-link" in device_class or "hide-from-toc" in device_class):
                    # debug(f"Skipping element with class: {device_class} and id: {device_id}")
                    continue

                # Extract the device label from the text and strip "id", if it fails, skip it
                try:
                    device_label = device_element.get('data-text').strip('"').split('" for ')[1]
                except Exception as e:
                    print(f"⚠️ {datetime.now():%Y-%m-%d %H:%M:%S} WARNING: Skipping element [{device_id}] with unexpected device format: {device_element.get('data-text')}")
                    continue

                # Initialize a dictionary to store the device's downloads for both OTA and Factory
                downloads_dict = {'ota': [], 'factory': []}

                # Find the <table> element following the <h2> for each device
                table = device_element.find_next('table')

                # Find all <tr> elements in the table
                rows = table.find_all('tr')

                # For factory images, the table format changes from Marlin onwards
                if device_id == 'marlin':
                    marlin_flag = True

                for row in rows:
                    # Extract the fields from each <tr> element
                    columns = row.find_all('td')
                    version = ''
                    with contextlib.suppress(Exception):
                        version = columns[0].text.strip()

                    # Different extraction is necessary per type
                    download_url = ''
                    sha256_checksum = ''
                    if image_type in ['ota', 'ota-watch'] or (marlin_flag and image_type == "factory"):
                        with contextlib.suppress(Exception):
                            sha256_checksum = columns[2].text.strip()
                        with contextlib.suppress(Exception):
                            download_url = columns[1].find('a')['href']
                    elif image_type in ['factory', 'factory-watch']:
                        with contextlib.suppress(Exception):
                            download_url = columns[2].find('a')['href']
                        with contextlib.suppress(Exception):
                            sha256_checksum = columns[3].text.strip()

                    date = ''
                    with contextlib.suppress(Exception):
                        date_match = re.search(r'\b(\d{6})\b', version)
                        date = None
                        if date_match:
                            date = date_match[1]
                        else:
                            date = extract_date_from_google_version(version)

                    # Create a dictionary for each download
                    download_info = {
                        'version': version,
                        'url': download_url,
                        'sha256': sha256_checksum,
                        'date': date
                    }

                    # Check if the download entry already exists, and only add it if it's a new entry
                    if download_info not in downloads_dict[download_type]:
                        downloads_dict[download_type].append(download_info)

                # Add the device name (using 'device_id') and device label (using 'device_label') to the data dictionary
                if device_id not in data:
                    data[device_id] = {
                        'label': device_label,
                        'type': device_type,
                        'ota': [],
                        'factory': []
                    }

                # Append the downloads to the corresponding list based on download_type
                data[device_id]['ota'].extend(downloads_dict['ota'])
                data[device_id]['factory'].extend(downloads_dict['factory'])

                beta_entries = []

                # Check if we have valid beta data for OTA
                if ota_beta_data and isinstance(ota_beta_data, BetaData) and hasattr(ota_beta_data, 'devices'):
                    for beta_item in ota_beta_data.devices:
                        if device_label == beta_item['device']:
                            if beta_item['error']:
                                the_version = f"⚠️ OTA - {beta_item['category']} ({ota_build_id}) - Problem with wrong build or hash"
                            else:
                                the_version = f"OTA - {beta_item['category']} ({ota_build_id})"
                            beta_info = {
                                'version': the_version,
                                'url': beta_item['url'],
                                'sha256': beta_item['hash'],
                                'date': datetime.now().strftime('%y%m%d')
                            }
                            beta_entries.append(beta_info)

                # Check if we have valid beta data for Factory
                if factory_beta_data and isinstance(factory_beta_data, BetaData) and hasattr(factory_beta_data, 'devices'):
                    for beta_item in factory_beta_data.devices:
                        if device_label == beta_item['device']:
                            if beta_item['error']:
                                the_version = f"⚠️ Factory - {beta_item['category']} ({factory_build_id}) - Problem with wrong build or hash"
                            else:
                                the_version = f"Factory - {beta_item['category']} ({factory_build_id})"
                            beta_info = {
                                'version': f"Factory - {beta_item['category']} ({factory_build_id})",
                                'url': beta_item['url'],
                                'sha256': beta_item['hash'],
                                'date': datetime.now().strftime('%y%m%d')
                            }
                            beta_entries.append(beta_info)

                # Only add beta list if there are actual beta entries
                if beta_entries:
                    data[device_id]['beta'] = beta_entries

        # Attempt to fetch and incorporate canary miner catalog if available
        try:
            catalog, catalog_path = fetch_canary_miner_catalog()
            if not catalog_path:
                catalog_path = os.path.join(get_config_path(), 'canary_miner_catalog.json').strip()

            if not catalog and catalog_path and os.path.exists(catalog_path):
                try:
                    with open(catalog_path, 'r', encoding='utf-8') as f:
                        catalog = json.load(f)
                except Exception:
                    catalog = None

            if catalog:
                def extract_sha256_from_url(u):
                    if not u:
                        return ''
                    m = re.search(r"([a-fA-F0-9]{64})", u)
                    if m:
                        return m.group(1)
                    # fallback: last path segment without extension
                    try:
                        name = os.path.basename(urlparse(u).path)
                        # strip extension
                        name = os.path.splitext(name)[0]
                        return name
                    except Exception:
                        return ''

                # Build by_device from catalog structure. Catalog typically has top-level 'canaries' and 'betas'.
                by_device = {}
                if isinstance(catalog, dict):
                    for section_name in ('canaries', 'betas'):
                        section = catalog.get(section_name, {})
                        if not isinstance(section, dict):
                            continue
                        for device_key, device_obj in section.items():
                            releases = []
                            try:
                                releases = device_obj.get('releases', [])
                            except Exception:
                                continue
                            for rel in releases:
                                try:
                                    releaseId = rel.get('releaseId', '') if isinstance(rel, dict) else ''
                                    buildName = rel.get('buildName', '') if isinstance(rel, dict) else ''
                                    url_field = rel.get('url', '') if isinstance(rel, dict) else ''
                                    typ = 'canaries' if section_name == 'canaries' else 'betas'
                                    version = ''
                                    if releaseId and buildName:
                                        version = f"{releaseId} - {buildName}"
                                    elif releaseId:
                                        version = str(releaseId)
                                    elif buildName:
                                        version = str(buildName)
                                    sha = extract_sha256_from_url(url_field)
                                    date = None
                                    if buildName:
                                        m = re.search(r"(\d{6})", str(buildName))
                                        if m:
                                            date = m.group(1)
                                    entry = {'version': version, 'url': url_field, 'sha256': sha, 'date': date}
                                    if device_key not in by_device:
                                        by_device[device_key] = {'canaries': [], 'betas': []}
                                    by_device[device_key][typ].append(entry)
                                except Exception:
                                    continue
                elif isinstance(catalog, list):
                    # fallback: try to process list items
                    for item in catalog:
                        try:
                            if not isinstance(item, dict):
                                continue
                            device_key = get_first_match(item, ['device', 'codename', 'product', 'device_codename'])
                            releaseId = get_first_match(item, ['releaseId', 'release', 'channel'])
                            buildName = get_first_match(item, ['buildName', 'build', 'name'])
                            url_field = get_first_match(item, ['url', 'downloadUrl', 'link'])
                            typ = 'betas'
                            lower = (str(releaseId) + ' ' + str(buildName)).lower()
                            if 'canary' in lower or 'canary' in str(releaseId).lower():
                                typ = 'canaries'
                            version = ''
                            if releaseId and buildName:
                                version = f"{releaseId} - {buildName}"
                            elif releaseId:
                                version = str(releaseId)
                            elif buildName:
                                version = str(buildName)
                            sha = extract_sha256_from_url(url_field)
                            date = None
                            if buildName:
                                m = re.search(r"(\d{6})", str(buildName))
                                if m:
                                    date = m.group(1)
                            entry = {'version': version, 'url': url_field, 'sha256': sha, 'date': date}
                            if device_key not in by_device:
                                by_device[device_key] = {'canaries': [], 'betas': []}
                            by_device[device_key][typ].append(entry)
                        except Exception:
                            continue

                # merge into existing data
                for dev_key, lists in by_device.items():
                    # try to find matching device id in data; device ids in data are keys like 'redfin'.
                    # If device_key matches any of device label or id, attach; otherwise skip.
                    target_key = None
                    if dev_key in data:
                        target_key = dev_key
                    else:
                        # try match by label
                        for did, dval in data.items():
                            label = dval.get('label', '')
                            if label and dev_key and dev_key.lower() in label.lower():
                                target_key = did
                                break
                    if not target_key:
                        # if blank device_key, skip
                        continue

                    # sort newest first by date (None treated as 0)
                    def sort_key(e):
                        try:
                            return int(e['date']) if e.get('date') else 0
                        except Exception:
                            return 0

                    if lists.get('canaries'):
                        sorted_can = sorted(lists['canaries'], key=sort_key, reverse=True)
                        data[target_key]['canaries'] = sorted_can
                    if lists.get('betas'):
                        sorted_bet = sorted(lists['betas'], key=sort_key, reverse=True)
                        # Preserve existing 'beta' key used elsewhere; also add 'betas' for All Betas submenu
                        data[target_key]['betas'] = sorted_bet
        except Exception:
            pass

        # Convert to JSON
        json_data = json.dumps(data, indent=2)

        # Save
        with open(save_to, 'w', encoding='utf-8') as json_file:
            json_file.write(json_data)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_google_images function")
        traceback.print_exc()


# ============================================================================
#                         extract_date_from_google_version
# ============================================================================
def extract_date_from_google_version(version_string):
    try:
        # pattern to find a 3-letter month followed by a year
        pattern = re.compile(r'(\b[A-Za-z]{3}\s\d{4}\b)')
        match = pattern.search(version_string)

        if match:
            date_str = match.group()
            date_obj = datetime.strptime(date_str, '%b %Y')
            # convert to yymm01
            return date_obj.strftime('%y%m01')
        return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in extract_date_from_google_version function")
        traceback.print_exc()


# ============================================================================
#                               Function download_file
# ============================================================================
def download_file(url, filename=None, callback=None, stream=True):
    if not url:
        return
    print(f"\n{datetime.now():%Y-%m-%d %H:%M:%S} Downloading: {url} ...")
    start = time.time()

    try:
        response = request_with_fallback(method='GET', url=url, stream=stream)
        config_path = get_config_path()
        if not filename:
            filename = os.path.basename(urlparse(url).path)
        downloaded_file_path = os.path.join(config_path, 'tmp', filename)
        with open(downloaded_file_path, "wb") as fd:
            for chunk in response.iter_content(chunk_size=131072):
                fd.write(chunk)
        # check if filename got downloaded
        if not os.path.exists(downloaded_file_path):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to download file from  {url}\n")
            print("Aborting ...\n")
            return 'ERROR'
        end = time.time()
        print(f"\nℹ️ {datetime.now():%Y-%m-%d %H:%M:%S} Download: {filename} completed! in {math.ceil(end - start)} seconds")
        # Call the callback function if provided
        if callback:
            callback()
        return downloaded_file_path
    except Exception:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to download file from  {url}\n")
        traceback.print_exc()
        return 'ERROR'


# ============================================================================
#                               Function get_first_match
# ============================================================================
def get_first_match(dictionary, keys):
    try:
        for key in keys:
            if key in dictionary:
                value = dictionary[key]
                break
        else:
            value = ''
        return value
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_first_match function")
        traceback.print_exc()


# ============================================================================
#                               Function delete_keys_from_dict
# ============================================================================
def delete_keys_from_dict(dictionary, keys):
    try:
        for key in keys:
            if key in dictionary:
                del dictionary[key]
        return dictionary
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in delete_keys_from_dict function")
        traceback.print_exc()


# ============================================================================
#                               Function is_valid_json
# ============================================================================
def is_valid_json(json_str):
    try:
        json.loads(json_str)
        return True
    except Exception:
        try:
            json5.loads(json_str)
            return True
        except Exception:
            return False


# ============================================================================
#                               Function process_dict
# ============================================================================
def process_dict(the_dict, add_missing_keys=False, pif_flavor='', set_first_api=None, sort_data=False, keep_all=False):
    try:
        module_versionCode = 0
        module_flavor = None
        config = get_config()
        with contextlib.suppress(Exception):
            module_flavor = pif_flavor.split('_')[0]
            module_versionCode = int(pif_flavor.split('_')[1])
        if module_flavor is None or module_flavor == '':
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to determine module flavor.")
            return ''
        if module_versionCode == 0:
            module_versionCode = 9999999
        android_devices = get_android_devices()
        autofill = False
        if add_missing_keys:
            device = get_phone()
            if device:
                device_dict = device.props.property
                autofill = True
            else:
                print("ERROR: Device is unavailable to add missing fields from device.")

        # FINGERPRINT
        fp_ro_product_brand = ''
        fp_ro_product_name = ''
        fp_ro_product_device = ''
        fp_ro_build_version_release = ''
        fp_ro_build_id = ''
        fp_ro_build_version_incremental = ''
        fp_ro_build_type = ''
        fp_ro_build_tags = ''
        keys = ['ro.build.fingerprint', 'ro.system.build.fingerprint', 'ro.product.build.fingerprint', 'ro.vendor.build.fingerprint']
        ro_build_fingerprint = get_first_match(the_dict, keys)
        if ro_build_fingerprint != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if autofill and ro_build_fingerprint == '':
            ro_build_fingerprint = get_first_match(device_dict, keys)
        if ro_build_fingerprint:
            # Let's extract props from fingerprint in case we need them
            pattern = r'([^\/]*)\/([^\/]*)\/([^:]*):([^\/]*)\/([^\/]*)\/([^:]*):([^\/]*)\/([^\/]*)$'
            match = re.search(pattern, ro_build_fingerprint)
            if match and match.lastindex == 8:
                fp_ro_product_brand = match[1]
                fp_ro_product_name = match[2]
                fp_ro_product_device = match[3]
                fp_ro_build_version_release = match[4]
                fp_ro_build_id = match[5]
                fp_ro_build_version_incremental = match[6]
                fp_ro_build_type = match[7]
                fp_ro_build_tags = match[8]

        # PRODUCT
        keys = ['ro.product.name', 'ro.product.system.name', 'ro.product.product.name', 'ro.product.vendor.name', 'ro.vendor.product.name']
        ro_product_name = get_first_match(the_dict, keys)
        if ro_product_name != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (not ro_product_name or any(keyword in ro_product_name.lower() for keyword in ['mainline', 'generic'])) and fp_ro_product_name:
            debug(f"Properties for PRODUCT are extracted from FINGERPRINT: {fp_ro_product_name}")
            ro_product_name = fp_ro_product_name
        if autofill and ro_product_name == '':
            ro_product_name = get_first_match(device_dict, keys)

        # DEVICE (ro.build.product os fallback, keep it last)
        keys = ['ro.product.device', 'ro.product.system.device', 'ro.product.product.device', 'ro.product.vendor.device', 'ro.vendor.product.device', 'ro.build.product']
        ro_product_device = get_first_match(the_dict, keys)
        if ro_product_device != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (not ro_product_device or any(keyword in ro_product_device.lower() for keyword in ['mainline', 'generic'])) and fp_ro_product_device:
            debug(f"Properties for DEVICE are extracted from FINGERPRINT: {fp_ro_product_device}")
            ro_product_device = fp_ro_product_device
        if autofill and ro_product_device == '':
            ro_product_device = get_first_match(device_dict, keys)

        # MANUFACTURER
        keys = ['ro.product.manufacturer', 'ro.product.system.manufacturer', 'ro.product.product.manufacturer', 'ro.product.vendor.manufacturer', 'ro.vendor.product.manufacturer']
        ro_product_manufacturer = get_first_match(the_dict, keys)
        if ro_product_manufacturer != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if autofill and ro_product_manufacturer == '':
            ro_product_manufacturer = get_first_match(device_dict, keys)

        # BRAND
        keys = ['ro.product.brand', 'ro.product.system.brand', 'ro.product.product.brand', 'ro.product.vendor.brand', 'ro.vendor.product.brand']
        ro_product_brand = get_first_match(the_dict, keys)
        if ro_product_brand != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (ro_product_brand is None or ro_product_brand == '') and fp_ro_product_brand != '':
            debug(f"Properties for BRAND are not found, using value from FINGERPRINT: {fp_ro_product_brand}")
            ro_product_brand = fp_ro_product_brand
        if autofill and ro_product_brand == '':
            ro_product_brand = get_first_match(device_dict, keys)

        # MODEL
        keys = ['ro.product.model', 'ro.product.system.model', 'ro.product.product.model', 'ro.product.vendor.model', 'ro.vendor.product.model']
        ro_product_model = get_first_match(the_dict, keys)
        if (not ro_product_model or any(keyword in ro_product_model.lower() for keyword in ['mainline', 'generic'])):
            ro_product_model_bak = ro_product_model
            # get it from vendor/build.prop (ro.product.vendor.model)
            ro_product_vendor_model = get_first_match(the_dict, ['ro.product.vendor.model'])
            if ro_product_vendor_model and ro_product_vendor_model != '':
                ro_product_model = ro_product_vendor_model
            else:
                # If it is a Google device
                if ro_product_manufacturer == 'Google':
                # get model from android_devices if it is a Google device
                    try:
                        ro_product_model = android_devices[ro_product_device]['device']
                    except KeyError:
                        ro_product_model = ro_product_model_bak
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Key '{ro_product_device}' not found in android_devices.\nMODEL field could be wrong")
        if ro_product_model != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if autofill and ro_product_model == '':
            ro_product_model = get_first_match(device_dict, keys)

        # SECURITY_PATCH
        keys = ['ro.build.version.security_patch', 'ro.vendor.build.security_patch']
        ro_build_version_security_patch = get_first_match(the_dict, keys)
        if ro_build_version_security_patch != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if autofill and ro_build_version_security_patch == '':
            ro_build_version_security_patch = get_first_match(device_dict, keys)

        # FIRST_API_LEVEL
        keys = ['ro.product.first_api_level', 'ro.board.first_api_level', 'ro.board.api_level', 'ro.build.version.sdk', 'ro.system.build.version.sdk', 'ro.build.version.sdk', 'ro.system.build.version.sdk', 'ro.vendor.build.version.sdk', 'ro.product.build.version.sdk']
        if set_first_api:
            ro_product_first_api_level = set_first_api
        else:
            ro_product_first_api_level = get_first_match(the_dict, keys)
            if ro_product_first_api_level and int(ro_product_first_api_level) > 32:
                ro_product_first_api_level = '32'
            if autofill and ro_product_first_api_level == '':
                ro_product_first_api_level = get_first_match(device_dict, keys)
        if ro_product_first_api_level != '':
            the_dict = delete_keys_from_dict(the_dict, keys)

        # BUILD_ID
        keys = ['ro.build.id']
        ro_build_id = get_first_match(the_dict, keys)
        if ro_build_id != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (ro_build_id is None or ro_build_id == '') and fp_ro_build_id != '':
            debug(f"Properties for ID are not found, using value from FINGERPRINT: {fp_ro_build_id}")
            ro_build_id = fp_ro_build_id
        if autofill and ro_build_id == '':
            ro_build_id = get_first_match(device_dict, keys)

        # RELEASE
        keys = ['ro.build.version.release']
        ro_build_version_release = get_first_match(the_dict, keys)
        if ro_build_version_release != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (ro_build_version_release is None or ro_build_version_release == '') and fp_ro_build_version_release != '':
            debug(f"Properties for RELEASE are not found, using value from FINGERPRINT: {fp_ro_build_version_release}")
            ro_build_version_release = fp_ro_build_version_release
        if autofill and ro_build_version_release == '':
            ro_build_version_release = get_first_match(device_dict, keys)

        # INCREMENTAL
        keys = ['ro.build.version.incremental']
        ro_build_version_incremental = get_first_match(the_dict, keys)
        if ro_build_version_incremental != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (ro_build_version_incremental is None or ro_build_version_incremental == '') and fp_ro_build_version_incremental != '':
            debug(f"Properties for INCREMENTAL are not found, using value from FINGERPRINT: {fp_ro_build_version_incremental}")
            ro_build_version_incremental = fp_ro_build_version_incremental
        if autofill and ro_build_version_incremental == '':
            ro_build_version_incremental = get_first_match(device_dict, keys)

        # TYPE
        keys = ['ro.build.type']
        ro_build_type = get_first_match(the_dict, keys)
        if ro_build_type != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (ro_build_type is None or ro_build_type == '') and fp_ro_build_type != '':
            debug(f"Properties for TYPE are not found, using value from FINGERPRINT: {fp_ro_build_type}")
            ro_build_type = fp_ro_build_type
        if autofill and ro_build_type == '':
            ro_build_type = get_first_match(device_dict, keys)

        # TAGS
        keys = ['ro.build.tags']
        ro_build_tags = get_first_match(the_dict, keys)
        if ro_build_tags != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if (ro_build_tags is None or ro_build_tags == '') and fp_ro_build_tags != '':
            debug(f"Properties for TAGS are not found, using value from FINGERPRINT: {fp_ro_build_tags}")
            ro_build_tags = fp_ro_build_tags
        if autofill and ro_build_tags == '':
            ro_build_tags = get_first_match(device_dict, keys)

        # VNDK_VERSION
        keys = ['ro.vndk.version', 'ro.product.vndk.version']
        ro_vndk_version = get_first_match(the_dict, keys)
        if ro_vndk_version != '':
            the_dict = delete_keys_from_dict(the_dict, keys)
        if autofill and ro_vndk_version == '':
            ro_vndk_version = get_first_match(device_dict, keys)

        # Get any missing FINGERPRINT fields
        ffp_ro_product_brand = fp_ro_product_brand if fp_ro_product_brand != '' else ro_product_brand
        ffp_ro_product_name = fp_ro_product_name if fp_ro_product_name != '' else ro_product_name
        ffp_ro_product_device = fp_ro_product_device if fp_ro_product_device != '' else ro_product_device
        ffp_ro_build_version_release = fp_ro_build_version_release if fp_ro_build_version_release != '' else ro_build_version_release
        ffp_ro_build_id = fp_ro_build_id if fp_ro_build_id != '' else ro_build_id
        ffp_ro_build_version_incremental = fp_ro_build_version_incremental if fp_ro_build_version_incremental != '' else ro_build_version_incremental
        ffp_ro_build_type = fp_ro_build_type if fp_ro_build_type != '' else ro_build_type
        ffp_ro_build_tags = fp_ro_build_tags if fp_ro_build_tags != '' else ro_build_tags
        # Rebuild the FINGERPRINT
        if ffp_ro_product_brand and ffp_ro_product_name and ffp_ro_product_device and ffp_ro_build_version_release and ffp_ro_build_id and ffp_ro_build_version_incremental and ffp_ro_build_type and ffp_ro_build_tags:
            ro_build_fingerprint = f"{ffp_ro_product_brand}/{ffp_ro_product_name}/{ffp_ro_product_device}:{ffp_ro_build_version_release}/{ffp_ro_build_id}/{ffp_ro_build_version_incremental}:{ffp_ro_build_type}/{ffp_ro_build_tags}"

        # Global Common
        donor_data = {
            "MANUFACTURER": ro_product_manufacturer,
            "MODEL": ro_product_model,
            "FINGERPRINT": ro_build_fingerprint,
            "BRAND": ro_product_brand,
            "PRODUCT": ro_product_name,
            "DEVICE": ro_product_device,
            "RELEASE": ro_build_version_release,
            "ID": ro_build_id,
            "INCREMENTAL": ro_build_version_incremental,
            "TYPE": ro_build_type,
            "TAGS": ro_build_tags,
            "SECURITY_PATCH": ro_build_version_security_patch,
            # "BOARD": ro_product_board,
            # "HARDWARE": ro_product_hardware,
            "DEVICE_INITIAL_SDK_INT": ro_product_first_api_level
        }

        # Play Integrity Fork
        if module_flavor == 'playintegrityfork':
            # Common in Play Integrity Fork (v4 and newer)
            # donor_data["INCREMENTAL"] = ro_build_version_incremental
            # donor_data["TYPE"] = ro_build_type
            # donor_data["TAGS"] = ro_build_tags
            # donor_data["RELEASE"] = ro_build_version_release
            # donor_data["DEVICE_INITIAL_SDK_INT"] = ro_product_first_api_level
            # donor_data["ID"] = ro_build_id

            # v5 or newer
            if module_versionCode >= 5000 and module_flavor != 'trickystore':
                donor_data["*api_level"] = ro_product_first_api_level
                donor_data["*.security_patch"] = ro_build_version_security_patch
                donor_data["*.build.id"] = ro_build_id
                if module_versionCode <= 7000:
                    donor_data["VERBOSE_LOGS"] = "0"
            if module_versionCode > 9000 and module_flavor != 'trickystore':
                spoofBuild_value = config.pif.get('spoofBuild', True)
                donor_data["spoofBuild"] = "1" if spoofBuild_value else "0"
                spoofProps_value = config.pif.get('spoofProps', False)
                donor_data["spoofProps"] = "1" if spoofProps_value else "0"
                spoofProvider_value = config.pif.get('spoofProvider', False)
                donor_data["spoofProvider"] = "1" if spoofProvider_value else "0"
                spoofSignature_value = config.pif.get('spoofSignature', False)
                donor_data["spoofSignature"] = "1" if spoofSignature_value else "0"
                spoofVendingSdk_value = config.pif.get('spoofVendingSdk', False)
                donor_data["spoofVendingSdk"] = "1" if spoofVendingSdk_value else "0"
                spoofVendingFinger_value = config.pif.get('spoofVendingFinger', False)
                donor_data["spoofVendingFinger"] = "1" if spoofVendingFinger_value else "0"
            if module_versionCode > 7000 and module_flavor != 'trickystore':
                donor_data["verboseLogs"] = "0"
            # donor_data["*.vndk_version"] = ro_vndk_version

            # Discard keys with empty values if the flag is set
            modified_donor_data = {key: value for key, value in donor_data.items() if value != ""}

        # Chit's module and other forks
        elif module_flavor == 'playintegrityfix':
            donor_data["FIRST_API_LEVEL"] = ro_product_first_api_level
            donor_data["BUILD_ID"] = ro_build_id
            donor_data["VNDK_VERSION"] = ro_vndk_version
            donor_data["FORCE_BASIC_ATTESTATION"] = "true"
            # donor_data["KERNEL"] = "Goolag-perf"

            # No discard keys with empty values on chit's module
            modified_donor_data = donor_data
        else:
            modified_donor_data = donor_data

        # Keep unknown props if the flag is set
        if keep_all:
            for key, value in the_dict.items():
                if key not in modified_donor_data:
                    modified_donor_data[key] = value

        if not keep_all:
            filtered_data = {}
            for key, value in modified_donor_data.items():
                if value:
                    filtered_data[key] = value
            modified_donor_data = filtered_data

        if not sort_data:
            return json.dumps(modified_donor_data, indent=4)
        sorted_donor_data = dict(sorted(modified_donor_data.items()))
        return json.dumps(sorted_donor_data, indent=4)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception in function process_dict.")
        traceback.print_exc()
        return ''


# ============================================================================
#                               Function detect_encoding
# ============================================================================
def detect_encoding(filename):
    try:
        with open(filename, 'rb') as file:
            result = chardet.detect(file.read())
        return result['encoding']
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in detect_encoding function")
        traceback.print_exc()


# ============================================================================
#                               Function process_pi_xml_piac
# ============================================================================
def process_pi_xml_piac(filename):
    try:
        encoding = detect_encoding(filename)
        with open(filename, 'r', encoding=encoding, errors="replace") as file:
            xml_string = file.read()

        # Parse the XML string
        root = ET.fromstring(xml_string)

        # Specify the resource-ids to identify the nodes of interest
        resource_ids_list = [
            'gr.nikolasspyr.integritycheck:id/basic_integrity_icon',
            'gr.nikolasspyr.integritycheck:id/device_integrity_icon',
            'gr.nikolasspyr.integritycheck:id/strong_integrity_icon'
        ]

        # Check if the XML contains the specific string
        if 'The calling app is making too many requests to the API' in xml_string:
            return "Quota Reached.\nPlay Integrity API Checker\nis making too many requests to the Google API."

        # Print the 'content-desc' values along with a modified version of the resource-id
        result = ''
        for resource_id in resource_ids_list:
            nodes = root.findall(f'.//node[@resource-id="{resource_id}"]')
            for node in nodes:
                value = node.get('content-desc', '')
                modified_resource_id = resource_id.replace('gr.nikolasspyr.integritycheck:id/', '').replace('_icon', '')
                result += f"{modified_resource_id}:\t{value}\n"
        if result == '':
            return -1
        debug(result)
        return result
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in process_pi_xml_piac function")
        traceback.print_exc()
        return -1


# ============================================================================
#                               Function process_pi_xml_spic
# ============================================================================
def process_pi_xml_spic(filename):
    try:
        encoding = detect_encoding(filename)
        with open(filename, 'r', encoding=encoding, errors="replace") as file:
            xml_content = file.read()

        # Check if the XML contains the specific string
        if 'Integrity API error (-8)' in xml_content:
            return "Quota Reached.\nSimple Play Integrity Checker\nis making too many requests to the Google API."

        # Find the position of "Play Integrity Result:"
        play_integrity_result_pos = xml_content.find("Play Integrity Result:")

        # If "Play Integrity Result:" is found, continue searching for index="3"
        if play_integrity_result_pos != -1:
            index_3_pos = xml_content.find('index="3"', play_integrity_result_pos)

            # If index="3" is found, extract the value after it
            if index_3_pos != -1:
                # Adjust the position to point at the end of 'index="3"' and then get the next value between double quotes.
                index_3_pos += len('index="3"')
                value_start_pos = xml_content.find('"', index_3_pos) + 1
                value_end_pos = xml_content.find('"', value_start_pos)
                value_after_index_3 = xml_content[value_start_pos:value_end_pos]
                debug(value_after_index_3)
                if value_after_index_3 == "NO_INTEGRITY":
                    result = "[✗] [✗] [✗]"
                elif value_after_index_3 == "MEETS_BASIC_INTEGRITY":
                    result = "[✓] [✗] [✗]"
                elif value_after_index_3 == "MEETS_DEVICE_INTEGRITY":
                    result = "[✓] [✓] [✗]"
                elif value_after_index_3 == "MEETS_STRONG_INTEGRITY":
                    result = "[✓] [✓] [✓]"
                elif value_after_index_3 == "MEETS_VIRTUAL_INTEGRITY":
                    result = "[o] [o] [o]"
                return f"{result} {value_after_index_3}"
            else:
                print("Error")
                return -1
        else:
            print("'Play Integrity Result:' not found")
            return -1
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in process_pi_xml_spic function")
        traceback.print_exc()
        return -1


# ============================================================================
#                               Function process_pi_xml_aic
# ============================================================================
def process_pi_xml_aic(filename):
    try:
        encoding = detect_encoding(filename)
        with open(filename, 'r', encoding=encoding, errors="replace") as file:
            xml_content = file.read()

        # Check if the XML contains the specific string
        if 'Integrity API error' in xml_content:
            return "Quota Reached.\nAndroid Integrity Checker\nis making too many requests to the Google API."

        # Find the position of "Play Integrity Result:"
        device_recognition_verdict_pos = xml_content.find("Device recognition verdict")

        # If "Device recognition verdict" is found, continue searching for index="3"
        if device_recognition_verdict_pos != -1:
            index_6_pos = xml_content.find('index="6"', device_recognition_verdict_pos)

            # If index="6" is found, extract the value after it
            if index_6_pos != -1:
                # Adjust the position to point at the end of 'index="3"' and then get the next value between double quotes.
                index_6_pos += len('index="6"')
                value_start_pos = xml_content.find('"', index_6_pos) + 1
                value_end_pos = xml_content.find('"', value_start_pos)
                value_after_index_6 = xml_content[value_start_pos:value_end_pos]
                debug(value_after_index_6)
                result = ''
                if 'MEETS_BASIC_INTEGRITY' in value_after_index_6:
                    result += '[✓]'
                else:
                    result += '[✗]'

                if 'MEETS_DEVICE_INTEGRITY' in value_after_index_6:
                    result += ' [✓]'
                else:
                    result += ' [✗]'

                if 'MEETS_STRONG_INTEGRITY' in value_after_index_6:
                    result += ' [✓]'
                else:
                    result += ' [✗]'

                return f"{result}\n{value_after_index_6}"
            else:
                print("Error")
                return -1
        else:
            print("'Play Integrity Result:' not found")
            return -1
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in process_pi_xml_spic function")
        traceback.print_exc()
        return -1


# ============================================================================
#                               Function process_pi_xml_tb
# ============================================================================
def process_pi_xml_tb(filename):
    try:
        encoding = detect_encoding(filename)
        with open(filename, 'r', encoding=encoding, errors="replace") as file:
            xml_content = file.read()

        # Find the position of "Play Integrity Result:"
        play_integrity_result_pos = xml_content.find("Result Play integrity")

        # If "Result Play integrity" is found, continue searching for index="3"
        if play_integrity_result_pos != -1:
            basic_integrity_pos = xml_content.find('"Basic integrity"', play_integrity_result_pos)

            # If "Basic integrity" is found, continue looking for text=
            if basic_integrity_pos != -1:
                # find next text= position
                basic_integrity_result_pos = xml_content.find('text=', basic_integrity_pos)

                # Adjust the position to point at the end of 'text=' and then get the next value between double quotes.
                basic_integrity_result_pos += len('text=')

                value_start_pos = xml_content.find('"', basic_integrity_result_pos) + 1
                value_end_pos = xml_content.find('"', value_start_pos)
                basic_integrity = xml_content[value_start_pos:value_end_pos]

                device_integrity_pos = xml_content.find('"Device integrity"', value_end_pos)
                # If "Device integrity" is found, continue looking for text=
                if device_integrity_pos != -1:
                    # find next text= position
                    device_integrity_result_pos = xml_content.find('text=', device_integrity_pos)

                    # Adjust the position to point at the end of 'text=' and then get the next value between double quotes.
                    device_integrity_result_pos += len('text=')

                    value_start_pos = xml_content.find('"', device_integrity_result_pos) + 1
                    value_end_pos = xml_content.find('"', value_start_pos)
                    device_integrity = xml_content[value_start_pos:value_end_pos]


                    strong_integrity_pos = xml_content.find('"Strong integrity"', value_end_pos)
                    # If "Device integrity" is found, continue looking for text=
                    if strong_integrity_pos != -1:
                        # find next text= position
                        strong_integrity_result_pos = xml_content.find('text=', strong_integrity_pos)

                        # Adjust the position to point at the end of 'text=' and then get the next value between double quotes.
                        strong_integrity_result_pos += len('text=')

                        value_start_pos = xml_content.find('"', strong_integrity_result_pos) + 1
                        value_end_pos = xml_content.find('"', value_start_pos)
                        strong_integrity = xml_content[value_start_pos:value_end_pos]

                    result = f"Basic integrity:  {basic_integrity}\n"
                    result += f"Device integrity: {device_integrity}\n"
                    result += f"Strong integrity: {strong_integrity}\n"

                    debug(result)
                    return result
            else:
                print("Error")
                return -1
        else:
            print("'Result Play integrity' not found")
            return -1
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in process_pi_xml_tb function")
        traceback.print_exc()
        return -1


# ============================================================================
#                               Function process_pi_xml_ps
# ============================================================================
def process_pi_xml_ps(filename):
    try:
        encoding = detect_encoding(filename)
        with open(filename, 'r', encoding=encoding, errors="replace") as file:
            xml_content = file.read()

        # Find the position of text="Labels:
        labels_pos = xml_content.find('text="Labels:')

        # If found
        if labels_pos != -1:

            # Adjust the position to point at the end of 'text=' and then get the next value between [ ].
            labels_pos += len('text="Labels:')

            value_start_pos = xml_content.find('[', labels_pos) + 1
            value_end_pos = xml_content.find(']', value_start_pos)
            result = xml_content[value_start_pos:value_end_pos]
            debug(result)
            return result
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in process_pi_xml_ps function")
        traceback.print_exc()
        return -1


# ============================================================================
#                               Function process_pi_xml_yasnac
# ============================================================================
def process_pi_xml_yasnac(filename):
    try:
        encoding = detect_encoding(filename)
        with open(filename, 'r', encoding=encoding, errors="replace") as file:
            xml_content = file.read()

        # Find the position of text="Result"
        yasnac_result_pos = xml_content.find('text="Result"')

        # If found, continue searching for text="Basic integrity"
        if yasnac_result_pos != -1:
            basic_integrity_pos = xml_content.find('"Basic integrity"', yasnac_result_pos)

            # If "Basic integrity" is found, continue looking for text=
            if basic_integrity_pos != -1:
                # find next text= position
                basic_integrity_result_pos = xml_content.find('text=', basic_integrity_pos)

                # Adjust the position to point at the end of 'text=' and then get the next value between double quotes.
                basic_integrity_result_pos += len('text=')

                value_start_pos = xml_content.find('"', basic_integrity_result_pos) + 1
                value_end_pos = xml_content.find('"', value_start_pos)
                basic_integrity = xml_content[value_start_pos:value_end_pos]

                cts_profile_match_pos = xml_content.find('"CTS profile match"', value_end_pos)
                # If "CTS profile match" is found, continue looking for text=
                if cts_profile_match_pos != -1:
                    # find next text= position
                    cts_profile_match_result_pos = xml_content.find('text=', cts_profile_match_pos)

                    # Adjust the position to point at the end of 'text=' and then get the next value between double quotes.
                    cts_profile_match_result_pos += len('text=')

                    value_start_pos = xml_content.find('"', cts_profile_match_result_pos) + 1
                    value_end_pos = xml_content.find('"', value_start_pos)
                    cts_profile_match = xml_content[value_start_pos:value_end_pos]


                    evaluation_type_pos = xml_content.find('"Evaluation type"', value_end_pos)
                    # If "Evaluation type" is found, continue looking for text=
                    if evaluation_type_pos != -1:
                        # find next text= position
                        evaluation_type_result_pos = xml_content.find('text=', evaluation_type_pos)

                        # Adjust the position to point at the end of 'text=' and then get the next value between double quotes.
                        evaluation_type_result_pos += len('text=')

                        value_start_pos = xml_content.find('"', evaluation_type_result_pos) + 1
                        value_end_pos = xml_content.find('"', value_start_pos)
                        evaluation_type = xml_content[value_start_pos:value_end_pos]

                    result = f"Basic integrity:   {basic_integrity}\n"
                    result += f"CTS profile match: {cts_profile_match}\n"
                    result += f"Evaluation type:   {evaluation_type}\n"

                    debug(result)
                    return result
            else:
                print("Error")
                return -1
        else:
            print("'Result' not found")
            return -1
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in process_pi_xml_yasnac function")
        traceback.print_exc()
        return -1


# ============================================================================
#                               Function get_xiaomi_apk
# ============================================================================
def get_xiaomi_apk(filename):
    try:
        xiaomi_pifs = get_xiaomi()
        # Fetch RSS feed and extract the latest link
        print("Checking for latest xiaomi apk link ...")
        response = request_with_fallback(method='GET', url=XIAOMI_URL)

        latest_link = response.text.split('<link>')[2].split('</link>')[0]
        print(f"Xiaomi apk link: {latest_link}")
        match = re.search(r'([^/]+\.apk)', latest_link)
        value = None
        if match:
            apk_name = match[1]
            key = os.path.splitext(apk_name)[0]
            value = xiaomi_pifs.get(key)

        if not value:
            print("Downloading xiaomi apk ...")
            download_file(url=latest_link, filename=filename)
        else:
            print("No new Xiaomi update!")
        return key
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_xiaomi_apk function")
        traceback.print_exc()
        return None


# ============================================================================
#                               Function extract_from_zip
# ============================================================================
def extract_from_zip(zip_path, to_extract, extracted_file_path, quiet=False):
    try:
        print(f"Extracting {to_extract} from {zip_path}...")
        if quiet:
            with contextlib.suppress(Exception):
                with zipfile.ZipFile(zip_path, "r") as archive:
                    archive.extract(to_extract, extracted_file_path)
        else:
            with zipfile.ZipFile(zip_path, "r") as archive:
                archive.extract(to_extract, extracted_file_path)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in extract_from_zip function")
        traceback.print_exc()


# ============================================================================
#                               Function axml2xml
# ============================================================================
def axml2xml(inputfile, outputfile=None):
    try:
        print(f"Decoding extracted xml file: {inputfile} ...")
        buff = ""
        if path.exists(inputfile):
            ap = apk.AXMLPrinter(open(inputfile, "rb").read())
            if ap is None:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to parse the AXML file {inputfile}.")
                return
            # Check if the buffer is empty (happens for Android packages binary format)
            if not ap.get_buff():
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unable to decode {inputfile} - unsupported format.")
                return
            buff = ap.get_xml_obj().toprettyxml()
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: XML input file {inputfile} is not found.")
            return

        if outputfile:
            with open(outputfile, "w") as fd:
                fd.write( buff )
        return(buff)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in axml2xml function")
        traceback.print_exc()


# ============================================================================
#                               Function xiaomi_xml_to_json
# ============================================================================
def xiaomi_xml_to_json(decoded_xml, json_path=None):
    # sourcery skip: use-dictionary-union
    try:
        print(f"Extracting pif data from {decoded_xml} ...")
        # Parse the XML string
        root = ET.fromstring(decoded_xml)

        # Extract key-value pairs under android.os.Build
        build_data = {}
        build_class = root.find(".//class[@name='android.os.Build']")
        if build_class:
            for field in build_class.iter("field"):
                field_name = field.get("name")
                field_value = field.get("value")
                build_data[field_name] = field_value

        # Extract key-value pairs under android.os.Build$VERSION
        version_data = {}
        version_class = root.find(".//class[@name='android.os.Build$VERSION']")
        if version_class:
            for field in version_class.iter("field"):
                field_name = field.get("name")
                field_value = field.get("value")
                version_data[field_name] = field_value

        # Flatten the key-value pairs
        flattened_data = {**build_data, **version_data}
        # flattened_data = build_data | version_data

        # Save the data as JSON
        if json_path:
            with open(json_path, "w") as json_file:
                json.dump(flattened_data, json_file, indent=4)

        return json.dumps(flattened_data, indent=4)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in xiaomi_xml_to_json function")
        traceback.print_exc()


# ============================================================================
#                               Function get_xiaomi_pif
# ============================================================================
def get_xiaomi_pif():  # sourcery skip: move-assign
    try:
        xiaomi_pifs = get_xiaomi()
        config_path = get_config_path()
        tmp_dir_full = os.path.join(config_path, 'tmp')
        xiaomi_dir_full = os.path.join(config_path, 'xiaomi')
        xiaomi_apk = os.path.join(tmp_dir_full, 'xiaomi.apk')
        to_extract = "res/xml/inject_fields.xml"

        # download apk if we need to download
        key = get_xiaomi_apk(xiaomi_apk)
        xiaomi_axml = os.path.join(xiaomi_dir_full, f"{key}")
        xiaomi_xml = os.path.join(xiaomi_dir_full, f"{key}.xml")
        xiaomi_json = os.path.join(xiaomi_dir_full, f"{key}.json")
        if key in xiaomi_pifs:
            pif_object = xiaomi_pifs.get(key)
            if pif_object is not None:
                pif_value = pif_object.get("pif")
                if pif_value is not None:
                    print("Xiaomi Pif:")
                    print(json.dumps(pif_value, indent=4))
                    return json.dumps(pif_value, indent=4)
            del xiaomi_pifs[key]

        # Extract res/xml/inject_fields.xml
        if path.exists(xiaomi_apk):
            extract_from_zip(xiaomi_apk, to_extract, xiaomi_axml)
            xiaomi_pifs.setdefault(key, {})["axml_path"] = xiaomi_axml
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Xiaomi download failed.")

        # Decode xml
        if path.exists(xiaomi_axml):
            xiaomi_xml_content = axml2xml(os.path.join(xiaomi_axml, to_extract), xiaomi_xml)
            xiaomi_pifs.setdefault(key, {})["xml_path"] = xiaomi_xml
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Xiaomi axml not found")

        # Extract the build fields and convert to json
        xiaomi_json = xiaomi_xml_to_json(xiaomi_xml_content, xiaomi_json)
        if xiaomi_json:
            xiaomi_pifs.setdefault(key, {})["pif"] = json.loads(xiaomi_json)
            set_xiaomi(xiaomi_pifs)

            print("Caching data ...")
            with open(get_xiaomi_file_path(), "w", encoding='ISO-8859-1', errors="replace") as f:
                # Write the dictionary to the file in JSON format
                json.dump(xiaomi_pifs, f, indent=4)
        return xiaomi_json

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_xiaomi_pif function")
        traceback.print_exc()


# ============================================================================
#                               Function get_freeman_pif
# ============================================================================
def get_freeman_pif(abi_list=None):
    print("\n===== PIFS Random Profile/Fingerprint Picker =====\nCopyright (C) MIT License 2023 Nicholas Bissell (TheFreeman193)")

    try:
        config_path = get_config_path()
        tmp_dir_full = os.path.join(config_path, 'tmp')
        freeman_dir_full = os.path.join(config_path, 'TheFreeman193_JSON')
        zip_file = os.path.join(tmp_dir_full, 'PIFS.zip')

        if not os.path.exists(freeman_dir_full):
            if not os.path.exists(zip_file):
                print("Downloading profile/fingerprint repo from GitHub...")
                download_file(FREEMANURL, zip_file)
            temp_dir = tempfile.mkdtemp()
            with zipfile.ZipFile(zip_file, 'r') as zip_ref:
                zip_ref.extractall(temp_dir)
            # Move the extracted 'JSON' directory contents directly to the target directory
            json_contents_path = os.path.join(temp_dir, "PIFS-main", "JSON")
            shutil.move(json_contents_path, freeman_dir_full)
            # Remove the temporary directory
            shutil.rmtree(temp_dir)

        if abi_list:
            if abi_list == "arm64-v8a":
                abi_list = "arm64-v8a,armeabi-v7a,armeabi"
            print(f"Will use profile/fingerprint with ABI list '{abi_list}'")
            file_list = [os.path.join(root, file) for root, dirs, files in os.walk(f"{freeman_dir_full}/{abi_list}") for file in files]
        else:
            print("Couldn't detect ABI list. Will use profile/fingerprint from anywhere.")
            file_list = [os.path.join(root, file) for root, dirs, files in os.walk(f"{freeman_dir_full}") for file in files]

            if not file_list:
                print("Couldn't find any profiles/fingerprints. Is the JSON directory empty?")
                return

        f_count = len(file_list)
        debug(f"Matching json count: {f_count}")
        if f_count == 0:
            print("Couldn't parse JSON file list!")
            return

        print("Picking a random profile/fingerprint...")
        random_fp_num = random.randint(1, f_count)
        rand_fp = file_list[random_fp_num - 1]

        print(f"\nRandom profile/fingerprint file: '{os.path.basename(rand_fp)}'\n")
        with open(rand_fp, "r") as file:
            json_content = json.load(file)
            return json.dumps(json_content, indent=4)

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_freeman_pif function")
        traceback.print_exc()


# ============================================================================
#                               Function get_pif_from_image
# ============================================================================
def get_pif_from_image(image_file):
    config_path = get_config_path()
    config = get_config()
    path_to_7z = get_path_to_7z()
    temp_dir = tempfile.TemporaryDirectory()
    temp_dir_path = temp_dir.name
    # create props folder
    props_folder = os.path.join(config_path, "props")
    package_sig = os.path.splitext(os.path.basename(image_file))[0]
    props_path = os.path.join(props_folder, package_sig)
    if os.path.exists(props_path):
        shutil.rmtree(props_path)
    os.makedirs(props_path, exist_ok=True)

    file_to_process = image_file
    basename = ntpath.basename(image_file)
    filename, extension = os.path.splitext(basename)
    extension = extension.lower()

    # ==================================================
    # Sub Function  process_system_vendor_product_images
    # ==================================================
    def process_system_vendor_product_images():
        # process system.img
        try:
            img_archive = os.path.join(temp_dir_path, "system.img")
            if os.path.exists(img_archive):
                found_system_build_prop = check_archive_contains_file(archive_file_path=img_archive, file_to_check="build.prop", nested=False, is_recursive=False)
                if found_system_build_prop:
                    print(f"Extracting build.prop from {img_archive} ...")
                    theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{props_path}\" \"{img_archive}\" {found_system_build_prop}"
                    debug(theCmd)
                    res = run_shell2(theCmd)
                    if os.path.exists(os.path.join(props_path, found_system_build_prop)):
                        os.rename(os.path.join(props_path, found_system_build_prop), os.path.join(props_path, "system-build.prop"))
                else:
                    print(f"build.prop not found in {img_archive}")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing system.img:")
            traceback.print_exc()

        # process vendor.img
        try:
            img_archive = os.path.join(temp_dir_path, "vendor.img")
            if os.path.exists(img_archive):
                found_vendor_img_prop = check_archive_contains_file(archive_file_path=img_archive, file_to_check="build.prop", nested=False, is_recursive=False)
                if found_vendor_img_prop:
                    print(f"Extracting build.prop from {img_archive} ...")
                    theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{props_path}\" \"{img_archive}\" {found_vendor_img_prop}"
                    debug(theCmd)
                    res = run_shell2(theCmd)
                    if os.path.exists(os.path.join(props_path, found_vendor_img_prop)):
                        os.rename(os.path.join(props_path, found_vendor_img_prop), os.path.join(props_path, "vendor-build.prop"))
                else:
                    print(f"build.prop not found in {img_archive}")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing vendor.img:")
            traceback.print_exc()

        # process product.img
        try:
            img_archive = os.path.join(temp_dir_path, "product.img")
            if os.path.exists(img_archive):
                found_product_img_prop = check_archive_contains_file(archive_file_path=img_archive, file_to_check="build.prop", nested=False, is_recursive=False)
                if found_product_img_prop:
                    print(f"Extracting build.prop from {img_archive} ...")
                    theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{props_path}\" \"{img_archive}\" {found_product_img_prop}"
                    debug(theCmd)
                    res = run_shell2(theCmd)
                    if os.path.exists(os.path.join(props_path, found_product_img_prop)):
                        os.rename(os.path.join(props_path, found_product_img_prop), os.path.join(props_path, "product-build.prop"))
                else:
                    print(f"build.prop not found in {img_archive}")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing product.img:")
            traceback.print_exc()

    # ==================================================
    # Sub Function  check_for_system_vendor_product_imgs
    # ==================================================
    def check_for_system_vendor_product_imgs(filename):
        # check if image file is included and contains what we need
        if os.path.exists(filename):
            # extract system.img
            found_system_img = check_archive_contains_file(archive_file_path=filename, file_to_check="system.img", nested=False, is_recursive=False)
            if found_system_img:
                print(f"Extracting system.img from {filename} ...")
                theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{filename}\" system.img"
                debug(theCmd)
                res = run_shell2(theCmd)

            # extract vendor.img
            found_vendor_img = check_archive_contains_file(archive_file_path=filename, file_to_check="vendor.img", nested=False, is_recursive=False)
            if found_vendor_img:
                print(f"Extracting system.img from {filename} ...")
                theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{filename}\" vendor.img"
                debug(theCmd)
                res = run_shell2(theCmd)

            # extract product.img
            found_product_img = check_archive_contains_file(archive_file_path=filename, file_to_check="product.img", nested=False, is_recursive=False)
            if found_product_img:
                print(f"Extracting system.img from {filename} ...")
                theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{filename}\" product.img"
                debug(theCmd)
                res = run_shell2(theCmd)

    try:
        # .img file
        if extension == ".img":
            if filename in ["system", "vendor", "product"]:
                # copy the image file to the temp directory
                shutil.copy2(file_to_process, temp_dir_path)
            else:
                shutil.copy2(file_to_process, os.path.join(temp_dir_path, "system.img"))
            process_system_vendor_product_images()
            return props_path

        found_flash_all_bat = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="flash-all.bat", nested=False)
        if found_flash_all_bat:
            found_flash_all_sh = check_archive_contains_file(archive_file_path=file_to_process, file_to_check="flash-all.sh", nested=False)

        if found_flash_all_bat and found_flash_all_sh:
            # -----------------------------
            # Pixel factory file
            # -----------------------------
            package_sig = found_flash_all_bat.split('/')[0]
            if not package_sig:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract package signature from {found_flash_all_bat}")
                return
            package_dir_full = os.path.join(temp_dir_path, package_sig)
            image_file_path = os.path.join(package_dir_full, f"image-{package_sig}.zip")
            # Unzip the factory image
            debug(f"Unzipping Image: {file_to_process} into {package_dir_full} ...")
            theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{file_to_process}\""
            debug(theCmd)
            res = run_shell2(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess):
                debug(f"Return Code: {res.returncode}")
                debug(f"Stdout: {res.stdout}")
                debug(f"Stderr: {res.stderr}")
                if res.returncode != 0:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {file_to_process}")
                    print("Aborting ...\n")
                    return
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {file_to_process}")
                print("Aborting ...\n")
                return

            # check if image file is included and contains what we need
            if os.path.exists(image_file_path):
                check_for_system_vendor_product_imgs(image_file_path)
                process_system_vendor_product_images()
                return props_path

        elif check_zip_contains_file(file_to_process, "payload.bin", config.low_mem):
            # -----------------------------
            # Firmware with payload.bin
            # -----------------------------
            print("Detected a firmware, with payload.bin")
            # extract the payload.bin into a temporary directory
            print(f"Extracting payload.bin from {file_to_process} ...")
            theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{file_to_process}\" payload.bin"
            debug(f"{theCmd}")
            res = run_shell(theCmd)
            if res and isinstance(res, subprocess.CompletedProcess) and res.returncode != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract payload.bin.")
                print(f"Return Code: {res.returncode}.")
                print(f"Stdout: {res.stdout}.")
                print(f"Stderr: {res.stderr}.")
                print("Aborting ...\n")
                return

            payload_file_path = os.path.join(temp_dir_path, "payload.bin")
            if os.path.exists(payload_file_path):
                extract_payload(payload_file_path, out=temp_dir_path, diff=False, old='old', images='system,vendor,product')
                process_system_vendor_product_images()
                return props_path
            return

        elif check_zip_contains_file(file_to_process, "servicefile.xml", config.low_mem):
            # -----------------------------
            # Motorola Firmware
            # -----------------------------
            sparse_chunk_pattern = "system.img_sparsechunk.*"
            sparse_chunks = check_file_pattern_in_zip_file(file_to_process, sparse_chunk_pattern, return_all_matches=True)
            if sparse_chunks:
                print("Detected a Motorola firmware")
                # # Extract sparse chunks
                # for chunk in sparse_chunks:
                #     print(f"Extracting {chunk} from {file_to_process} ...")
                #     theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{file_to_process}\" \"{chunk}\""
                #     debug(theCmd)
                #     res = run_shell2(theCmd)
                #     if res.returncode != 0:
                #         print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {chunk}.")
                #         print(f"Return Code: {res.returncode}")
                #         print(f"Stdout: {res.stdout}")
                #         print(f"Stderr: {res.stderr}")
                #         print("Aborting ...\n")
                #         return
                # # Combine sparse chunks
                # combined_sparse_path = os.path.join(temp_dir_path, "combined_system.img")
                # with open(combined_sparse_path, 'wb') as combined_file:
                #     for chunk in sparse_chunks:
                #         chunk_path = os.path.join(temp_dir_path, chunk)
                #         with open(chunk_path, 'rb') as chunk_file:
                #             combined_file.write(chunk_file.read())
                # # converting to raw image
                # raw_image_path = os.path.join(temp_dir_path, "system.img")
                # subprocess.run(["simg2img", combined_sparse_path, raw_image_path], check=True)

        elif check_zip_contains_file(file_to_process, "system.img", config.low_mem):
            check_for_system_vendor_product_imgs(file_to_process)
            process_system_vendor_product_images()
            return props_path

        elif check_zip_contains_file(file_to_process, "vendor.img", config.low_mem):
            check_for_system_vendor_product_imgs(file_to_process)
            process_system_vendor_product_images()
            return props_path

        elif check_zip_contains_file(file_to_process, "product.img", config.low_mem):
            check_for_system_vendor_product_imgs(file_to_process)
            process_system_vendor_product_images()
            return props_path

        else:
            found_ap = check_file_pattern_in_zip_file(file_to_process, "AP_*.tar.md5")
            if found_ap is not None and found_ap != "":
                # -----------------------------
                # Samsung firmware
                # -----------------------------
                print("Detected a Samsung firmware")

                # extract AP file
                print(f"Extracting {found_ap} from {image_file} ...")
                theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{image_file}\" {found_ap}"
                debug(theCmd)
                res = run_shell2(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {found_ap}.")
                        print("Aborting ...\n")
                        return
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract {found_ap}.")
                    print("Aborting ...\n")
                    return
                image_file_path = os.path.join(temp_dir_path, found_ap)
                if not os.path.exists(image_file_path):
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {image_file_path}.")
                    return
                # extract image file
                print(f"Extracting {image_file_path} ...")
                theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{image_file_path}\" \"meta-data\""
                debug(theCmd)
                res = run_shell2(theCmd)
                if res and isinstance(res, subprocess.CompletedProcess):
                    debug(f"Return Code: {res.returncode}")
                    debug(f"Stdout: {res.stdout}")
                    debug(f"Stderr: {res.stderr}")
                    if res.returncode != 0:
                        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract meta-data.")
                        print("Aborting ...\n")
                        return
                else:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract meta-data.")
                    print("Aborting ...\n")
                    return

                # get a file listing
                file_list = get_file_list_from_directory(temp_dir_path)
                found_fota_zip = False
                for file_path in file_list:
                    if "fota.zip" in file_path:
                        found_fota_zip = True
                        break

                if found_fota_zip:
                    # extract fota.zip
                    print(f"Extracting fota.zip from {image_file_path} ...")
                    theCmd = f"\"{path_to_7z}\" x -bd -y -o\"{temp_dir_path}\" \"{file_path}\" \"SYSTEM\" \"VENDOR\""
                    debug(theCmd)
                    res = run_shell2(theCmd)

                    source_path = os.path.join(temp_dir_path, "VENDOR", "build.prop")
                    destination_path = os.path.join(props_path, "system-build.prop")
                    if os.path.exists(source_path):
                        shutil.copy(source_path, destination_path)

                    source_path = os.path.join(temp_dir_path, "SYSTEM", "build.prop")
                    destination_path = os.path.join(props_path, "vendor-build.prop")
                    if os.path.exists(source_path):
                        shutil.copy(source_path, destination_path)

                    return props_path

                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unexpected image layout for {file_to_process}")
                return

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while processing ota/firmware file:")
        traceback.print_exc()
    finally:
        temp_dir.cleanup()


# ============================================================================
#                               Function extract_motorola_image
# ============================================================================
def extract_motorola_image(moto_img_path, output_img_path):
    """
    Extracts a Motorola image file, skipping its custom header.

    :param moto_img_path: Path to the Motorola image file.
    :param output_img_path: Path where the extracted raw image will be saved.
    """
    # Motorola header signature for identification
    moto_header_signature = b"MOTO\x13W\x9b\x00MOT_PIV_FULL256"
    header_length = len(moto_header_signature)  # Adjust based on actual header length

    try:
        with open(moto_img_path, 'rb') as moto_file:
            # check for the Motorola header
            header = moto_file.read(header_length)
            if header.startswith(moto_header_signature):
                print("Motorola image detected, proceeding with extraction...")
                # Skip the header to get to the actual image data
                # moto_file.seek(header_length, os.SEEK_SET)  # Uncomment if additional bytes need to be skipped
                # Read the rest of the file
                image_data = moto_file.read()
                # Save the extracted data to a new file
                with open(output_img_path, 'wb') as output_file:
                    output_file.write(image_data)
                print(f"Motorola Extraction complete. Raw image saved to {output_img_path}")
            else:
                print("File does not have the expected Motorola header.")
    except IOError as e:
        print(f"Error opening or reading file: {e}")


# ============================================================================
#                               Function get_file_list_from_directory
# ============================================================================
def get_file_list_from_directory(directory):
    try:
        file_list = []
        for dirpath, dirnames, filenames in os.walk(directory):
            for filename in filenames:
                file_list.append(os.path.join(dirpath, filename))
        return file_list
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_file_list_from_directory function")
        traceback.print_exc()


# ============================================================================
#                               Function patch_binary_file
# ============================================================================
def patch_binary_file(file_path, hex_offset, text, output_file_path=None):
    try:
        with open(file_path, 'rb') as f:
            data = f.read()
        # convert to decimal
        offset = int(hex_offset, 16)
        # Patch the data
        data = data[:offset] + text.encode() + data[offset + len(text):]

        if output_file_path is None:
            output_file_path = file_path

        with open(output_file_path, 'wb') as f:
            f.write(data)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in patch_binary_file function")
        traceback.print_exc()


# ============================================================================
#                 Function bootloader_issue_message
# ============================================================================
def bootloader_issue_message():
    print("ℹ️ This issue is most likely related to communication between your device and your computer.")
    print("Please ensure that you have installed the latest Google USB Drivers in both adb and bootloader (fastboot) modes.")
    print("If the problem persists, try using a different USB cable or port.")
    print("USB 2.0 ports are reportedly more stable than USB 3.0 ports.\n")


# ============================================================================
#                 Function download_ksu_latest_release_asset
# ============================================================================
def download_ksu_latest_release_asset(user, repo, asset_name=None, anykernel=True, custom_kernel=None, include_prerelease = False, latest_any=False, version_choice=False, get_all=False, search_all_releases=False):
    try:
        # For ShirkNeko and other custom kernels that might use pre-releases, check pre-releases first
        include_prerelease = custom_kernel in ['ShirkNeko', 'MiRinFork', 'WildKernels']

        if asset_name:
            look_for = asset_name
        else:
            look_for = "[all entries]"

        debug(f"Fetching latest release from {user}/{repo} matching {look_for} (include_prerelease: {include_prerelease})...")
        wx.Yield()
        response_data = get_gh_release_object(user=user, repo=repo, include_prerelease=include_prerelease, latest_any=latest_any)
        if response_data is None:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to fetch release data from {user}/{repo}")
            return None

        assets = response_data.get('assets', [])
        if not asset_name:
            return assets

        # Split the asset_name into parts
        parts = asset_name.split('-')
        base_name = parts[0]
        base_name = f"{base_name}"
        version_parts = parts[1].split('.')
        fixed_version = '.'.join(version_parts[:-1])
        variable_version = int(version_parts[-1])

        # Prepare the regular expression pattern
        if anykernel:
            if get_all:
                version_choice = True
                pattern = re.compile(rf"^.*\.zip$")
                debug(f"Using pattern for all assets of {custom_kernel}: {pattern.pattern}")
            elif custom_kernel:
                if custom_kernel in ["MiRinFork", 'ShirkNeko']:
                    # MiRinFork format: android14-6.1.145-2025-08-AnyKernel3.zip
                    # ShirkNeko format:  android14-6.1.124-2025-02-AnyKernel3.zip
                    pattern = re.compile(rf"^{base_name}-{fixed_version}\.([0-9]+)-.*-AnyKernel3\.zip$")
                    debug(f"Using pattern for {custom_kernel}: {pattern.pattern}")
                elif custom_kernel == "WildKernels":
                    # Latest format: 6.1.57-android14-2023-12-Normal-AnyKernel3.zip
                    #                6.1.57-android14-2024-01-Bypass-AnyKernel3.zip
                    # version_choice = True
                    pattern = re.compile(rf"^{fixed_version}\.([0-9]+)-{base_name}-[0-9]{{4}}-[0-9]{{2}}-(?:Normal|Bypass)-AnyKernel3\.zip$")
                    debug(f"Using pattern for {custom_kernel}: {pattern.pattern}")
                else:
                    # Fallback pattern for other custom kernels
                    pattern = re.compile(rf"^{base_name}-{fixed_version}\.([0-9]+)-.*-AnyKernel3\.zip$")
                    debug(f"Using fallback pattern for {custom_kernel}: {pattern.pattern}")
            else:
                pattern = re.compile(rf"^AnyKernel3-{base_name}-{fixed_version}\.([0-9]+)(_.*|)\.zip$")
                debug(f"Using AnyKernel pattern: {pattern.pattern}")
        else:
            pattern = re.compile(rf"^{base_name}-{fixed_version}\.([0-9]+)(_.*|)-boot\.img\.gz$")
            debug(f"Using boot.img pattern: {pattern.pattern}")

        # Find the best match based on configuration
        config = get_config()
        selection_mode = getattr(config, 'ksu_asset_selection_mode', 0)
        if version_choice:
            selection_mode = 2  # Force user selectable mode

        best_match = None
        best_version = -1
        matching_assets = []
        fallback_match = None
        fallback_version = float('inf')
        all_matching_assets = []

        # For WildKernels, track Normal and Bypass builds separately for prioritization
        normal_assets = []
        bypass_assets = []

        for asset in assets:
            match = pattern.match(asset['name'])
            if match:
                # Handle case when get_all is True and pattern has no capture groups
                if get_all and custom_kernel:
                    # Default version for get_all mode
                    asset_version = 0
                elif len(match.groups()) > 0:
                    asset_version = int(match[1])
                else:
                    asset_version = 0
                matching_assets.append((asset['name'], asset_version))
                asset_info = {
                    'asset': asset,
                    'version': asset_version
                }
                all_matching_assets.append(asset_info)

                # For WildKernels, categorize by build type for prioritization
                if custom_kernel == "WildKernels":
                    if '-Normal-' in asset['name']:
                        normal_assets.append(asset_info)
                    elif '-Bypass-' in asset['name']:
                        bypass_assets.append(asset_info)

        # Create prioritized asset list: Normal first, then Bypass, then all others
        prioritized_assets = normal_assets + bypass_assets + all_matching_assets

        # Process assets in priority order
        for asset_info in prioritized_assets:
            asset = asset_info['asset']
            asset_version = asset_info['version']

            # First priority: find highest version <= requested version
            if asset_version <= variable_version and asset_version > best_version:
                best_match = asset
                best_version = asset_version
                if asset_version == variable_version and selection_mode == 0:
                    break

            # Fallback: track lowest version > requested version
            elif asset_version > variable_version and asset_version < fallback_version:
                fallback_match = asset
                fallback_version = asset_version

        # Apply selection logic based on mode
        if selection_mode == 1:  # Highest Available
            if all_matching_assets:
                highest_asset = max(all_matching_assets, key=lambda x: x['version'])
                best_match = highest_asset['asset']
                best_version = highest_asset['version']
                print(f"ℹ️ Using highest available version: {best_version}")
        elif selection_mode == 2:  # User selectable
            if all_matching_assets:
                try:
                    # Sort assets by version (highest first) for better display
                    sorted_assets = sorted(all_matching_assets, key=lambda x: x['version'], reverse=True)
                    asset_list = [item['asset'] for item in sorted_assets]

                    # Determine suggested asset (current logic)
                    suggested_asset = best_match if best_match else fallback_match

                    selected_asset = show_ksu_asset_selector(
                        parent=None,
                        assets=asset_list,
                        title="Select KernelSU Asset",
                        message=f"Multiple KernelSU assets found for {base_name}-{fixed_version}.x\nRequested version: {variable_version}",
                        suggested_asset=suggested_asset,
                        initial_filter=f"{fixed_version}."
                    )

                    if selected_asset:
                        best_match = selected_asset
                        # Extract version from selected asset
                        match = pattern.match(selected_asset['name'])
                        if match:
                            if len(match.groups()) > 0:
                                best_version = int(match[1])
                            else:
                                best_version = 0
                        print(f"ℹ️ User selected version: {best_version}")
                    else:
                        print("ℹ️ User cancelled selection, using suggested asset, aborting ...")
                        return None
                except ImportError:
                    print("⚠️ Asset selector not available, falling back to default selection")

        wx.Yield()
        # Default mode (0) or fallback logic
        if selection_mode == 0 or (selection_mode == 2 and not best_match):
            # If no version <= requested found, use the closest higher version
            if not best_match and fallback_match:
                best_match = fallback_match
                best_version = fallback_version
                print(f"⚠️ No version <= {variable_version} found, using closest higher version: {fallback_version}")

        if matching_assets:
            print(f"Assets matched {len(matching_assets)} assets:")
            for name, version in matching_assets:
                print(f"  - {name} (version: {version})")
                wx.Yield()

        if best_match:
            print(f"Selected best match KernelSU: {best_match['name']}")
            download_file(best_match['browser_download_url'])
            print(f"Downloaded {best_match['name']}")
            return best_match['name']

        should_search = search_all_releases
        if not should_search:
            print(f"⚠️ Automatic good match for asset {asset_name} not found in the latest release of {user}/{repo}")
            prompt_msg = f"The asset '{asset_name}' was not found in the latest release of {user}/{repo}.\n\nWould you like to search in older releases?"
            response = wx.MessageBox(prompt_msg, "Asset Not Found", wx.YES_NO | wx.ICON_QUESTION)
            should_search = (response == wx.YES)

        if should_search:
            print(f"ℹ️ Searching older releases...")
            wx.Yield()
            all_releases = get_gh_release_object(user=user, repo=repo, include_prerelease=include_prerelease, latest_any=latest_any, get_all_releases=True)
            if all_releases:
                for release in all_releases:
                    release_tag = release.get('tag_name', 'unknown')
                    release_assets = release.get('assets', [])
                    for asset in release_assets:
                        match = pattern.match(asset['name'])
                        if match:
                            asset_version = 0
                            if len(match.groups()) > 0:
                                asset_version = int(match[1])
                            if asset_version <= variable_version and asset_version > best_version:
                                best_match = asset
                                best_version = asset_version
                                matched_release_tag = release_tag
                            elif asset_version > variable_version and asset_version < fallback_version:
                                fallback_match = asset
                                fallback_version = asset_version
                                fallback_release_tag = release_tag
                    if best_match:
                        break
                if best_match:
                    print(f"ℹ️ Found matching asset in release {matched_release_tag}: {best_match['name']}")
                    download_file(best_match['browser_download_url'])
                    print(f"Downloaded {best_match['name']}")
                    return best_match['name']
                elif fallback_match:
                    print(f"ℹ️ Found asset in release {fallback_release_tag} (closest higher version): {fallback_match['name']}")
                    download_file(fallback_match['browser_download_url'])
                    print(f"Downloaded {fallback_match['name']}")
                    return fallback_match['name']
                else:
                    print(f"⚠️ No matching asset found in any release for {asset_name}")
            else:
                print(f"⚠️ No releases found to search")

        if not should_search or not best_match:
            print("ℹ️ To see all available assets, enable the checkbox [Search older releases if asset not found in latest] when selecting kernel flavor.\n")
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in download_ksu_latest_release_asset function")
        traceback.print_exc()


# ============================================================================
#                 Function download_gh_pre_release_asset_regex
# ============================================================================
def download_gh_pre_release_asset_regex(user, repo, asset_name_pattern):
    try:
        release_object = get_gh_release_object(user=user, repo=repo, include_prerelease=True, latest_any=False)
        if release_object is None:
            print(f"No releases found for {user}/{repo}")
            return
        asset = gh_asset_utility(release_object=release_object, asset_name_pattern=asset_name_pattern, download=True)
        if asset:
            print(f"Downloaded asset: {asset}")
            return asset
        else:
            print(f"No asset matches the pattern {asset_name_pattern} in the latest pre-release of {user}/{repo}")
            return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in download_gh_pre_release_asset_regex function")
        traceback.print_exc()
        return None


# ============================================================================
#                 Function download_gh_latest_release_asset_regex
# ============================================================================
def download_gh_latest_release_asset_regex(user, repo, asset_name_pattern):
    try:
        release_object = get_gh_release_object(user=user, repo=repo, include_prerelease=False, latest_any=False)
        if release_object is None:
            print(f"No releases found for {user}/{repo}")
            return None
        asset = gh_asset_utility(release_object=release_object, asset_name_pattern=asset_name_pattern, download=True)
        if asset:
            print(f"Downloaded asset: {asset}")
            return asset
        else:
            print(f"No asset matches the pattern {asset_name_pattern} in the latest release of {user}/{repo}")
            return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in download_gh_latest_release_asset_regex function")
        traceback.print_exc()
        return None


# ============================================================================
#                 Function download_gh_latest_any_asset_regex
# ============================================================================
def download_gh_latest_any_asset_regex(user, repo, asset_name_pattern):
    try:
        release_object = get_gh_release_object(user=user, repo=repo, include_prerelease=True, latest_any=True)
        if release_object is None:
            print(f"No releases found for {user}/{repo}")
            return
        asset = gh_asset_utility(release_object=release_object, asset_name_pattern=asset_name_pattern, download=True)
        if asset:
            print(f"Downloaded asset: {asset}")
            return asset
        else:
            print(f"No asset matches the pattern {asset_name_pattern} in the latest pre-release of {user}/{repo}")
            return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in download_gh_pre_release_asset_regex function")
        traceback.print_exc()
        return None


# ============================================================================
#                 Function get_gh_pre_release_asset_regex
# ============================================================================
def get_gh_pre_release_asset_regex(user, repo, asset_name_pattern):
    try:
        release_object = get_gh_release_object(user=user, repo=repo, include_prerelease=True, latest_any=False)
        if release_object is None:
            print(f"No releases found for {user}/{repo}")
            return
        asset = gh_asset_utility(release_object=release_object, asset_name_pattern=asset_name_pattern, download=False)
        if asset:
            print(f"Found asset: {asset}")
            return asset
        else:
            print(f"No asset matches the pattern {asset_name_pattern} in the latest pre-release of {user}/{repo}")
            return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_gh_pre_release_asset_regex function")
        traceback.print_exc()
        return None


# ============================================================================
#                 Function get_gh_latest_release_asset_regex
# ============================================================================
def get_gh_latest_release_asset_regex(user, repo, asset_name_pattern):
    try:
        release_object = get_gh_release_object(user=user, repo=repo, include_prerelease=False, latest_any=False)
        if release_object is None:
            print(f"No releases found for {user}/{repo}")
            return
        asset = gh_asset_utility(release_object=release_object, asset_name_pattern=asset_name_pattern, download=False)
        if asset:
            print(f"Found asset: {asset}")
            return asset
        else:
            print(f"No asset matches the pattern {asset_name_pattern} in the latest release of {user}/{repo}")
            return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_gh_latest_release_asset_regex function")
        traceback.print_exc()
        return None


# ============================================================================
#                 Function get_gh_latest_any_asset_regex
# ============================================================================
def get_gh_latest_release_asset_regex(user, repo, asset_name_pattern):
    try:
        release_object = get_gh_release_object(user=user, repo=repo, include_prerelease=False, latest_any=True)
        if release_object is None:
            print(f"No releases found for {user}/{repo}")
            return
        asset = gh_asset_utility(release_object=release_object, asset_name_pattern=asset_name_pattern, download=False)
        if asset:
            print(f"Found asset: {asset}")
            return asset
        else:
            print(f"No asset matches the pattern {asset_name_pattern} in the latest release of {user}/{repo}")
            return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_gh_latest_release_asset_regex function")
        traceback.print_exc()
        return None


# ============================================================================
#                 Function gh_asset_utility
# ============================================================================
def gh_asset_utility(release_object, asset_name_pattern, download):
    try:
        if not release_object:
            print(f"No release object provided.")
            return

        assets = release_object.get('assets', [])

        # Prepare the regular expression pattern
        pattern = re.compile(asset_name_pattern)

        # Find the best match
        best_match = None
        for asset in assets:
            match = pattern.match(asset['name'])
            if match:
                best_match = asset
                break

        if best_match:
            print(f"Found match: {best_match['name']}")
            if not download:
                return best_match['browser_download_url']
            download_file(best_match['browser_download_url'])
            print(f"Downloaded {best_match['name']}")
            return best_match['name']
        else:
            print(f"No asset matches the pattern {asset_name_pattern} in the latest release of the provided release object")
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in gh_asset_utility function")
        traceback.print_exc()


# ============================================================================
#                   Function get_gh_latest_release_notes
# ============================================================================
def get_gh_latest_release_notes(owner, repo):
    try:
        url = f"https://api.github.com/repos/{owner}/{repo}/releases/latest"
        response = requests.get(url)
        data = response.json()

        if 'body' in data:
            return data['body']
        else:
            return "# No release notes found for the latest release."
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_gh_latest_release_notes function")
        traceback.print_exc()


# ============================================================================
#                   Function get_gh_latest_release_version
# ============================================================================
def get_gh_latest_release_version(user, repo, include_prerelease=False):
    try:
        # Get all releases
        url = f"https://api.github.com/repos/{user}/{repo}/releases"
        response = request_with_fallback(method='GET', url=url)
        releases = response.json()

        # Filter releases based on the include_prerelease flag
        if not include_prerelease:
            releases = [release for release in releases if not release['prerelease']]
        else:
            releases = [release for release in releases if release['prerelease']]

        # Get the latest release
        latest_release = releases[0] if releases else None

        if not latest_release:
            print(f"No releases found for {user}/{repo}")
            return ''

        return latest_release.get('tag_name', '')
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_gh_latest_release_version function")
        traceback.print_exc()
        return ''


# ============================================================================
#                   Function get_gh_release_object
# ============================================================================
def get_gh_release_object(user, repo, include_prerelease=False, latest_any=False, get_all_releases=False):
    try:
        # Get everything about releases
        url = f"https://api.github.com/repos/{user}/{repo}/releases"
        response = request_with_fallback(method='GET', url=url)
        if response.status_code != 200:
            print(f"Failed to fetch releases from {user}/{repo}. HTTP Status Code: {response.status_code}")
            return None
        releases = response.json()

        # Filter releases based on the flags
        if latest_any:
            # Don't filter - use all releases to pick the absolute latest
            filtered_releases = releases
        elif not include_prerelease:
            filtered_releases = [release for release in releases if not release['prerelease']]
        else:
            filtered_releases = [release for release in releases if release['prerelease']]

        if get_all_releases:
            return filtered_releases

        # Get the latest release
        latest_release = filtered_releases[0] if filtered_releases else None

        if not latest_release:
            release_type = "any releases" if latest_any else ("pre-releases" if include_prerelease else "releases")
            print(f"No {release_type} found for {user}/{repo}")
            return None

        return latest_release
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_gh_release_object function")
        traceback.print_exc()
        return None


# ============================================================================
#                               Function extract_magiskboot
# ============================================================================
def extract_magiskboot(apk_path, architecture, output_path):
    try:
        path_to_7z = get_path_to_7z()
        file_path_in_apk = f"lib/{architecture}/libmagiskboot.so"
        output_file_path = os.path.join(output_path, "magiskboot")

        cmd = f"\"{path_to_7z}\" e \"{apk_path}\" -o\"{output_path}\" -r {file_path_in_apk} -y"
        debug(cmd)
        res = run_shell2(cmd)
        if res and isinstance(res, subprocess.CompletedProcess):
            debug(f"Return Code: {res.returncode}")
            debug(f"Stdout: {res.stdout}")
            debug(f"Stderr: {res.stderr}")
            if res.returncode != 0:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract from {apk_path}")
                puml("#red:ERROR: Could not extract image;\n")
                print("Aborting ...\n")
                return
        else:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not extract from {apk_path}")
            puml("#red:ERROR: Could not extract image;\n")
            print("Aborting ...\n")
            return

        if os.path.exists(output_file_path):
            os.remove(output_file_path)
        os.rename(os.path.join(output_path, "libmagiskboot.so"), output_file_path)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in extract_magiskboot function")
        traceback.print_exc()


# ============================================================================
#                               Function request_with_fallback
# ============================================================================
def request_with_fallback(method, url, headers=None, data=None, stream=False, nocache=False):
    response = 'ERROR'
    # Initialize headers if None
    headers = headers or {}

    # Add nocache headers only when requested
    if nocache:
        headers.update({
            'Cache-Control': 'no-cache, max-age=0',
            'Pragma': 'no-cache'
        })

    try:
        if check_internet():
            with requests.Session() as session:
                response = session.request(method, url, headers=headers, data=data, stream=stream)
                response.raise_for_status()
    except requests.exceptions.SSLError:
        print(f"⚠️ WARNING! Encountered SSL certification error while connecting to: {url}")
        print("Retrying with SSL certificate verification disabled. ...")
        print("For security, you should double check and make sure your system or communication is not compromised.")
        if check_internet():
            with requests.Session() as session:
                response = session.request(method, url, headers=headers, data=data, verify=False, stream=stream)
    except requests.exceptions.HTTPError as err:
        print(f"HTTP error occurred: {err}")
    except requests.exceptions.Timeout:
        print("The request timed out")
    except requests.exceptions.TooManyRedirects:
        print("Too many redirects")
    except requests.exceptions.RequestException as err:
        print(f"An error occurred: {err}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    return response


# ============================================================================
#                               Function check_internet
# ============================================================================
def check_internet():
    url = "http://www.google.com"
    timeout = 5
    try:
        unused = requests.get(url, timeout=timeout)
        return True
    except requests.ConnectionError as e:
        print("No internet connection available.")
        print(e)
    return False


# ============================================================================
#                               Function load_kb_index
# ============================================================================
def load_kb_index():
    try:
        kb_index_path = os.path.join(get_config_path(), 'kb_index.json')
        if os.path.exists(kb_index_path):
            with open(kb_index_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to load kb_index.json: {e}")
        return {}


# ============================================================================
#                               Function save_kb_index
# ============================================================================
def save_kb_index(kb_index):
    try:
        kb_index_path = os.path.join(get_config_path(), 'kb_index.json')
        with open(kb_index_path, 'w', encoding='utf-8') as f:
            json.dump(kb_index, f, indent=2)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to save kb_index.json: {e}")


# ============================================================================
#                               Function check_kb
# Credit to hldr4  for the original suggestion
# https://gist.github.com/hldr4/b933f584b2e2c3088bcd56eb056587f8
# ============================================================================
def check_kb(filename, force_fresh=False):
    url = "https://android.googleapis.com/attestation/status"
    headers = {
        'Cache-Control': 'no-cache, max-age=0',
        'Pragma': 'no-cache'
    }

    try:
        # Load kb_index
        config = get_config()
        if config.kb_index:
            kb_index = load_kb_index()

        # Check for cached CRL data first to avoid multiple network requests
        config_path = get_config_path()
        crl_cache_path = os.path.join(config_path, 'tmp', 'crl_cache.json')
        crl_data = None
        last_modified = 'Unknown'
        content_date = 'Unknown'
        use_cache = False

        # Check if cached file exists and is fresh (less than 15 minute old), unless force_fresh is True
        if not force_fresh and os.path.exists(crl_cache_path):
            cache_age = time.time() - os.path.getmtime(crl_cache_path)
            if cache_age < 900:  # 15 minutes
                try:
                    with open(crl_cache_path, 'r', encoding='utf-8') as f:
                        cached_data = json.load(f)
                        crl_data = cached_data['crl_data']
                        last_modified = cached_data.get('last_modified', 'Unknown')
                        content_date = cached_data.get('content_date', 'Unknown')
                        use_cache = True
                        debug(f"Using cached CRL data (age: {cache_age:.1f} seconds)")
                except (json.JSONDecodeError, KeyError, IOError) as e:
                    debug(f"Failed to load cached CRL data: {e}")

        # If no valid cache, fetch from server
        if not use_cache:
            # Add timestamp to URL to ensure fresh data
            timestamp = int(time.time())
            cache_bust_url = f"{url}?_t={timestamp}"

            # Enhanced cache-busting headers
            fresh_headers = headers.copy()
            fresh_headers.update({
                'Cache-Control': 'no-cache, no-store, must-revalidate, max-age=0',
                'Pragma': 'no-cache',
                'Expires': '0',
                'If-Modified-Since': 'Thu, 01 Jan 1970 00:00:00 GMT',
                'Accept-Encoding': 'identity'
            })

            crl = request_with_fallback(method='GET', url=cache_bust_url, headers=fresh_headers, nocache=True)
            if crl is not None and crl != 'ERROR':
                last_modified = crl.headers.get('last-modified', 'Unknown')
                content_date = crl.headers.get('date', 'Unknown')
                crl_data = crl.json()

                # Cache the data
                try:
                    cache_data = {
                        'crl_data': crl_data,
                        'last_modified': last_modified,
                        'content_date': content_date,
                        'cached_at': datetime.now().isoformat()
                    }
                    with open(crl_cache_path, 'w', encoding='utf-8') as f:
                        json.dump(cache_data, f, indent=2)
                    debug("CRL data cached successfully")
                except IOError as e:
                    debug(f"Failed to cache CRL data: {e}")
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not fetch CRL from {url}")
                return ['invalid']

        # Display CRL info
        print("------------------------------------------------------------------------")
        print(f"CRL Last Modified:     {last_modified}")
        print(f"Server Response Date:  {content_date}")
        crl = crl_data

        print(f"\nChecking keybox: {filename} ...")

        # Calculate file hash for kb_index
        if config.kb_index:
            file_hash = sha1(filename)

        shadow_banned_list = SHADOW_BANNED_ISSUERS
        is_sw_signed = False
        is_google_signed = False
        is_expired = False
        expiring_soon = False
        is_revoked = False
        is_shadow_banned = False
        long_chain = False
        results = []
        ecdsa_root_ca_sn = None
        rsa_root_ca_sn = None

        # Parse keybox XML
        try:
            tree = ET.parse(filename)
            root = tree.getroot()
        except Exception as e:
            print(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not parse keybox XML {filename}")
            print(e)
            results.append('invalid')
            return results

        # 1. Validate root element is AndroidAttestation
        if root.tag != 'AndroidAttestation':
            print(f"❌ ERROR: Root element is not AndroidAttestation, found: {root.tag}")
            results.append('invalid_structure')
            return results

        # 2. Check NumberOfKeyboxes
        num_keyboxes = root.find('NumberOfKeyboxes')
        if num_keyboxes is None:
            print("❌ ERROR: Missing NumberOfKeyboxes element")
            results.append('invalid_structure')
            return results
        expected_keyboxes = int(num_keyboxes.text)
        print(f"Expected number of keyboxes: {expected_keyboxes}")

        # 3. Process each Keybox
        keyboxes = root.findall('Keybox')
        if not keyboxes:
            print("❌ ERROR: No Keybox elements found")
            results.append('invalid_structure')
            return results

        if len(keyboxes) != expected_keyboxes:
            print(f"⚠️ WARNING: NumberOfKeyboxes ({expected_keyboxes}) does not match actual keyboxes found ({len(keyboxes)})")

        k = 1
        for keybox in keyboxes:
            wx.Yield()
            device_id = keybox.get('DeviceID')
            if not device_id:
                print("❌ ERROR: Keybox missing DeviceID attribute")
                results.append('invalid_structure')
            print(f"\nProcessing Keybox {k}/{expected_keyboxes} for Device ID: {device_id}")

            if config.kb_index:
                # Initialize keybox data collection for this specific keybox
                keybox_data_collection = {}

            # 4. Verify both RSA and ECDSA algorithms are present
            required_algorithms = {'rsa', 'ecdsa'}
            found_algorithms = set()

            ecdsa_chain = 'valid'
            rsa_chain = 'valid'
            for key_element in keybox.findall('Key'):
                wx.Yield()
                algorithm = key_element.get('algorithm')
                if not algorithm:
                    print("  ❌ ERROR: Key element missing algorithm attribute")
                    continue

                # Process the Chain
                algorithm = algorithm.lower()
                print(f"\n→ Processing {algorithm} chain:")
                found_algorithms.add(algorithm)

                # 5. Check PrivateKey
                private_key = key_element.find('PrivateKey')
                if private_key is None:
                    print(f"  ❌ ERROR: No PrivateKey found for {algorithm} key")
                    results.append('missing_private_key')
                    continue

                # 6. Check CertificateChain
                cert_chain = key_element.find('CertificateChain')
                if cert_chain is None:
                    print(f"  ❌ ERROR: No CertificateChain found for {algorithm} key")
                    results.append('missing_chain')
                    continue

                # 7. Verify number of certificates matches
                num_certs_elem = cert_chain.find('NumberOfCertificates')
                if num_certs_elem is None:
                    print(f"  ❌ ERROR: Missing NumberOfCertificates for {algorithm} chain")
                    results.append('invalid_chain')
                    continue

                expected_certs = int(num_certs_elem.text)
                actual_certs = len(cert_chain.findall('Certificate'))
                if actual_certs != expected_certs:
                    print(f"  ⚠️ WARNING: NumberOfCertificates ({expected_certs}) does not match actual certificates found ({actual_certs})")

                # 8. Process certificates
                certs = cert_chain.findall('Certificate')
                if len(certs) < 2:
                    print(f"  ❌ ERROR: {algorithm} chain must have at least 2 certificates (leaf and root)")
                    results.append('invalid_chain')
                    continue

                # Store chain length for kb_index
                chain_length = len(certs)

                # Validate certificate chain
                try:
                    cert_chain = []
                    # Parse private key from the keybox
                    private_key_text = private_key.text.strip()
                    private_key_text = re.sub(re.compile(r'^\s+', re.MULTILINE), '', private_key_text)
                    private_key_text = clean_pem_key(private_key_text)
                    private_key_obj = None

                    try:
                        private_key_obj = serialization.load_pem_private_key(
                            private_key_text.encode(),
                            password=None
                        )
                    except Exception as e:
                        if "EC curves with explicit parameters" in str(e) or "unsupported" in str(e).lower():
                            # Set private_key_obj to a special sentinel value to indicate skipped validation.
                            private_key_obj = "UNSUPPORTED_CURVE"
                        else:
                            print(f"  ❌ ERROR: Failed to parse private key for {algorithm} key: {e}")
                            results.append('invalid_private_key')

                    # Parse certificates in the chain
                    if len(certs) > 4:
                        long_chain = True
                    tab_text = ""
                    for cert in certs:
                        wx.Yield()
                        cert_text = cert.text.strip()
                        parsed_cert = x509.load_pem_x509_certificate(cert_text.encode())
                        cert_chain.append(parsed_cert)
                        ecdsa_leaf = "valid"
                        rsa_leaf = "valid"
                        cert_status = "valid"

                        cert_sn, cert_issuer, cert_subject, sig_algo, expiry, key_usages, parsed, crl_distribution_points = parse_cert(cert.text)

                        # Format the issuer field
                        formatted_issuer, issuer_sn = format_dn(cert_issuer)

                        if issuer_sn in shadow_banned_list:
                            is_shadow_banned = True

                        # Format the issued to field
                        formatted_issued_to, issued_to_sn = format_dn(cert_subject)

                        # indent the chain
                        tab_text += "  "

                        # redact if verbose is not set
                        if get_verbose():
                            cert_sn_text = cert_sn
                            formatted_issued_to_text = formatted_issued_to
                            formatted_issuer_text = formatted_issuer
                        else:
                            cert_sn_text = "REDACTED"
                            formatted_issued_to_text = "REDACTED"
                            formatted_issuer_text = "REDACTED"

                        print(f'{tab_text}Certificate SN:          {cert_sn_text}')
                        print(f'{tab_text}Issued to:               {formatted_issued_to_text}')
                        print(f'{tab_text}Issuer:                  {formatted_issuer_text}')
                        print(f'{tab_text}Signature Algorithm:     {sig_algo}')
                        print(f'{tab_text}Key Usage:               {key_usages}')
                        if crl_distribution_points:
                            print(f'{tab_text}CRL Distribution Points: {crl_distribution_points}')
                        expired_text = ""
                        if expiry < datetime.now(timezone.utc):
                            expired_text = " (EXPIRED)"
                        print(f"{tab_text}Validity:                {parsed.not_valid_before_utc.date()} to {expiry.date()} {expired_text}\n")

                        if "Software Attestation" in cert_issuer:
                            is_sw_signed = True
                            cert_status = "sw_signed"

                        if issuer_sn in ['f92009e853b6b045']:
                            is_google_signed = True

                        if expiry < datetime.now(timezone.utc):
                            is_expired = True
                            print(f"{tab_text}❌❌❌ Certificate is EXPIRED")
                            cert_status = "expired"
                        elif expiry < datetime.now(timezone.utc) + timedelta(days=30):
                            expiring_soon = True
                            print(f"{tab_text}⚠️ Certificate is EXPIRING SOON")

                        if cert_sn.strip().lower() in (sn.strip().lower() for sn in crl["entries"].keys()):
                            print(f"{tab_text}❌❌❌ Certificate is REVOKED")
                            print(f"{tab_text}❌❌❌ Reason: {crl['entries'][cert_sn]['reason']} ***")
                            is_revoked = True
                            cert_status = "revoked"

                        # Collect status
                        if algorithm == "ecdsa":
                            if tab_text == "  ":
                                ecdsa_leaf = cert_status
                            else:
                                if ecdsa_chain == 'valid':
                                    ecdsa_chain = cert_status
                            if is_google_signed:
                                ecdsa_root_ca_sn = cert_sn
                        elif algorithm == "rsa":
                            if tab_text == "  ":
                                rsa_leaf = cert_status
                            else:
                                if rsa_chain == 'valid':
                                    rsa_chain = cert_status
                            if is_google_signed:
                                rsa_root_ca_sn = cert_sn

                        if config.kb_index:
                            # Add the leaf cert details to keybox_data_collection
                            if algorithm == "ecdsa" and tab_text == "  ":
                                keybox_data_collection["ecdsa_sn"] = cert_sn
                                keybox_data_collection["ecdsa_issuer"] = formatted_issuer
                                keybox_data_collection["ecdsa_leaf"] = ecdsa_leaf
                                keybox_data_collection["ecdsa_length"] = chain_length
                                keybox_data_collection["ecdsa_not_before"] = parsed.not_valid_before_utc.strftime("%Y-%m-%d %H:%M:%S UTC")
                                keybox_data_collection["ecdsa_not_after"] = expiry.strftime("%Y-%m-%d %H:%M:%S UTC")
                            elif algorithm == "rsa" and tab_text == "  ":
                                keybox_data_collection["rsa_sn"] = cert_sn
                                keybox_data_collection["rsa_issuer"] = formatted_issuer
                                keybox_data_collection["rsa_leaf"] = rsa_leaf
                                keybox_data_collection["rsa_length"] = chain_length
                                keybox_data_collection["rsa_not_before"] = parsed.not_valid_before_utc.strftime("%Y-%m-%d %H:%M:%S UTC")
                                keybox_data_collection["rsa_not_after"] = expiry.strftime("%Y-%m-%d %H:%M:%S UTC")

                    if config.kb_index:
                        keybox_data_collection["ecdsa_chain"] = ecdsa_chain
                        keybox_data_collection["rsa_chain"] = rsa_chain

                    # First is leaf, last is root
                    leaf_cert = cert_chain[0]
                    root_cert = cert_chain[-1]
                    intermediate_certs = cert_chain[1:-1]

                    # Verify the private key matches the leaf certificate's public key
                    if private_key_obj is not None and private_key_obj != "UNSUPPORTED_CURVE" and leaf_cert is not None:
                        try:
                            leaf_public_key = leaf_cert.public_key()

                            # For RSA keys
                            if isinstance(private_key_obj, rsa.RSAPrivateKey) and isinstance(leaf_public_key, rsa.RSAPublicKey):
                                priv_public_numbers = private_key_obj.public_key().public_numbers()
                                leaf_public_numbers = leaf_public_key.public_numbers()

                                if (priv_public_numbers.n == leaf_public_numbers.n and
                                    priv_public_numbers.e == leaf_public_numbers.e):
                                    print(f"  ✅ Private key matches leaf certificate for {algorithm} chain")
                                else:
                                    print(f"  ❌ ERROR: Private key does not match leaf certificate for {algorithm} chain")
                                    results.append('key_mismatch')

                            # For ECDSA keys
                            elif isinstance(private_key_obj, ec.EllipticCurvePrivateKey) and isinstance(leaf_public_key, ec.EllipticCurvePublicKey):
                                priv_public_key = private_key_obj.public_key()

                                priv_public_bytes = priv_public_key.public_bytes(
                                    encoding=serialization.Encoding.PEM,
                                    format=serialization.PublicFormat.SubjectPublicKeyInfo
                                )

                                leaf_public_bytes = leaf_public_key.public_bytes(
                                    encoding=serialization.Encoding.PEM,
                                    format=serialization.PublicFormat.SubjectPublicKeyInfo
                                )

                                if priv_public_bytes == leaf_public_bytes:
                                    print(f"  ✅ Private key matches leaf certificate for {algorithm} chain")
                                else:
                                    print(f"  ❌ ERROR: Private key does not match leaf certificate for {algorithm} chain")
                                    results.append('key_mismatch')
                            else:
                                print(f"  ❌ ERROR: Mismatched key types between private key and certificate for {algorithm} chain")
                                results.append('key_mismatch')
                        except Exception as e:
                            print(f"  ❌ ERROR: Failed to verify key pair match: {e}")
                            results.append('key_mismatch')
                    elif private_key_obj == "UNSUPPORTED_CURVE":
                        print(f"  ⚠️ WARNING: Skipped private key validation due to unsupported curve format")

                    # Validate the certificate chain
                    try:
                        # Verify leaf is signed by first intermediate (or root if no intermediates)
                        current_cert = leaf_cert
                        next_cert = intermediate_certs[0] if intermediate_certs else root_cert

                        # Verify leaf cert is signed by next cert in chain
                        public_key = next_cert.public_key()
                        if isinstance(public_key, rsa.RSAPublicKey):
                            try:
                                public_key.verify(
                                    current_cert.signature,
                                    current_cert.tbs_certificate_bytes,
                                    padding.PKCS1v15(),
                                    current_cert.signature_hash_algorithm
                                )
                            except Exception as e:
                                print(f"  ❌ ERROR: RSA Certificate chain validation failed for {algorithm}: {e}")
                                results.append('invalid_chain')
                        elif isinstance(public_key, ec.EllipticCurvePublicKey):
                            try:
                                public_key.verify(
                                    current_cert.signature,
                                    current_cert.tbs_certificate_bytes,
                                    ec.ECDSA(current_cert.signature_hash_algorithm)
                                )
                            except Exception as e:
                                print(f"  ❌ ERROR: ECDSA Certificate chain validation failed for {algorithm}: {e}")
                                results.append('invalid_chain')

                        # Verify the rest of the chain
                        for i in range(len(intermediate_certs)):
                            wx.Yield()
                            current_cert = intermediate_certs[i]
                            next_cert = intermediate_certs[i + 1] if i + 1 < len(intermediate_certs) else root_cert

                            # Verify current_cert was signed by next_cert
                            public_key = next_cert.public_key()
                            if isinstance(public_key, rsa.RSAPublicKey):
                                try:
                                    public_key.verify(
                                        current_cert.signature,
                                        current_cert.tbs_certificate_bytes,
                                        padding.PKCS1v15(),
                                        current_cert.signature_hash_algorithm
                                    )
                                except Exception as e:
                                    print(f"  ❌ RSA Certificate chain validation failed for {algorithm}: {e}")
                                    results.append('invalid_chain')
                            elif isinstance(public_key, ec.EllipticCurvePublicKey):
                                try:
                                    public_key.verify(
                                        current_cert.signature,
                                        current_cert.tbs_certificate_bytes,
                                        ec.ECDSA(current_cert.signature_hash_algorithm)
                                    )
                                except Exception as e:
                                    print(f"  ❌ ECDSA Certificate chain validation failed for {algorithm}: {e}")
                                    results.append('invalid_chain')
                            else:
                                print(f"  ❌ ERROR: Unsupported public key type for {algorithm}")
                                results.append('invalid_chain')
                                # raise ValueError("Unsupported public key type")

                        # Finally verify root signed the last intermediate (if any intermediates exist)
                        if intermediate_certs:
                            public_key = root_cert.public_key()
                            if isinstance(public_key, rsa.RSAPublicKey):
                                public_key.verify(
                                    intermediate_certs[-1].signature,
                                    intermediate_certs[-1].tbs_certificate_bytes,
                                    padding.PKCS1v15(),
                                    intermediate_certs[-1].signature_hash_algorithm
                                )
                            elif isinstance(public_key, ec.EllipticCurvePublicKey):
                                public_key.verify(
                                    intermediate_certs[-1].signature,
                                    intermediate_certs[-1].tbs_certificate_bytes,
                                    ec.ECDSA(intermediate_certs[-1].signature_hash_algorithm)
                                )

                        print(f"  ✅ Certificate chain validation successful for {algorithm}")

                    except Exception as e:
                        print(f"  ❌ Certificate chain validation failed for {algorithm}: {e}")
                        results.append('invalid_chain')

                except Exception as e:
                    print(f"❌ ERROR validating certificate chain: {e}")
                    results.append('invalid_chain')

            # Check if all required algorithms were found
            missing_algorithms = required_algorithms - found_algorithms
            if missing_algorithms:
                print(f"\n❌ Missing required algorithm chains: {', '.join(missing_algorithms)}")
                results.append('missing_algorithms')

            if config.kb_index:
                # Update kb_index, use ECDSA serial number as the key.
                file_key = filename
                if len(keyboxes) > 1:
                    file_key = f"{filename}__{k}"

                ecdsa_sn = keybox_data_collection.get("ecdsa_sn")
                if ecdsa_sn:
                    # Check if this is a new keybox or existing one
                    is_new_keybox = ecdsa_sn not in kb_index
                    is_new_file = True

                    if is_new_keybox:
                        # Initialize new keybox entry
                        kb_index[ecdsa_sn] = {
                            "ecdsa_sn": ecdsa_sn,
                            "files": []
                        }
                        print(f"  🆕 New keybox detected with ECDSA SN: {ecdsa_sn}")
                    else:
                        # Check if current file is already in the files list
                        for file_entry in kb_index[ecdsa_sn]["files"]:
                            if file_entry["path"] == file_key:
                                is_new_file = False
                                break

                        if is_new_file:
                            print(f"  🔄 Duplicate keybox detected - same ECDSA SN ({ecdsa_sn}) but new file: {file_key}")

                    # Track changes in root level values for existing keyboxes
                    changes_detected = []
                    if not is_new_keybox:
                        # Compare current values with existing ones
                        fields_to_check = [
                            ("ecdsa_issuer", "ECDSA Issuer"),
                            ("ecdsa_leaf", "ECDSA Leaf Status"),
                            ("ecdsa_chain", "ECDSA Chain Status"),
                            ("ecdsa_length", "ECDSA Chain Length"),
                            ("ecdsa_not_before", "ECDSA Not Before"),
                            ("ecdsa_not_after", "ECDSA Not After"),
                            ("rsa_sn", "RSA Serial Number"),
                            ("rsa_issuer", "RSA Issuer"),
                            ("rsa_leaf", "RSA Leaf Status"),
                            ("rsa_chain", "RSA Chain Status"),
                            ("rsa_length", "RSA Chain Length"),
                            ("rsa_not_before", "RSA Not Before"),
                            ("rsa_not_after", "RSA Not After")
                        ]

                        for field_key, field_name in fields_to_check:
                            old_value = kb_index[ecdsa_sn].get(field_key)
                            new_value = keybox_data_collection.get(field_key)

                            if old_value != new_value:
                                changes_detected.append(f"       - {field_name}: '{old_value}' → '{new_value}'")

                    # Report changes if any were detected
                    if changes_detected:
                        print(f"  🔑 Changes detected for ECDSA SN {ecdsa_sn}:")
                        for change in changes_detected:
                            print(change)

                    # Update certificate details
                    kb_index[ecdsa_sn].update({
                        "ecdsa_issuer": keybox_data_collection.get("ecdsa_issuer"),
                        "ecdsa_leaf": keybox_data_collection.get("ecdsa_leaf"),
                        "ecdsa_chain": keybox_data_collection.get("ecdsa_chain"),
                        "ecdsa_length": keybox_data_collection.get("ecdsa_length"),
                        "ecdsa_not_before": keybox_data_collection.get("ecdsa_not_before"),
                        "ecdsa_not_after": keybox_data_collection.get("ecdsa_not_after"),
                        "rsa_sn": keybox_data_collection.get("rsa_sn"),
                        "rsa_issuer": keybox_data_collection.get("rsa_issuer"),
                        "rsa_leaf": keybox_data_collection.get("rsa_leaf"),
                        "rsa_chain": keybox_data_collection.get("rsa_chain"),
                        "rsa_length": keybox_data_collection.get("rsa_length"),
                        "rsa_not_before": keybox_data_collection.get("rsa_not_before"),
                        "rsa_not_after": keybox_data_collection.get("rsa_not_after"),
                        "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    })

                    # Add new file entry if it doesn't exist
                    if is_new_file:
                        kb_index[ecdsa_sn]["files"].append({
                            "path": file_key,
                            "hash": file_hash,
                            "ecdsa_root_ca_sn": ecdsa_root_ca_sn,
                            "rsa_root_ca_sn": rsa_root_ca_sn
                        })
                    else:
                        # Update existing file entry hash
                        for i, file_entry in enumerate(kb_index[ecdsa_sn]["files"]):
                            if file_entry["path"] == file_key:
                                kb_index[ecdsa_sn]["files"][i]["hash"] = file_hash
                                kb_index[ecdsa_sn]["files"][i]["ecdsa_root_ca_sn"] = ecdsa_root_ca_sn
                                kb_index[ecdsa_sn]["files"][i]["rsa_root_ca_sn"] = rsa_root_ca_sn
                                break

            k += 1

        if is_revoked:
            print(f"\n❌❌❌ Keybox {filename} contains revoked certificates!")
            results.append('revoked')
        else:
            print(f"\n✅ certificates in Keybox {filename} are not on the revocation list")
            results.append('valid')
        if is_expired:
            print(f"\n❌❌❌ Keybox {filename} contains expired certificates!")
            results.append('expired')
        if is_sw_signed or not is_google_signed:
            print(f"⚠️ Keybox {filename} is possibly software signed! This is not a hardware-backed keybox!")
            results.append('aosp')
        if expiring_soon:
            print(f"⚠️ Keybox {filename} contains certificates that are expiring soon!")
            results.append('expiring_soon')
        if long_chain:
            print(f"⚠️ Keybox {filename} contains certificates longer chain than normal, this may no work.")
            results.append('long_chain')
        if is_shadow_banned:
            print(f"\n❌❌❌ Keybox {filename} has certificate(s) issued by an authority in shadow banned list!")
            results.append('shadow_banned')
        print('')

        # Save kb_index if it was used
        if config.kb_index:
            save_kb_index(kb_index)

        return results
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in check_kb function")
        print(e)
        traceback.print_exc()


# ============================================================================
#                               Function to clean_pem_key
# ============================================================================
def clean_pem_key(key_text):
    # Key with spaces instead of newlines (common in XML)
    if '-----BEGIN' in key_text and '\n' not in key_text:
        # Split at the BEGIN marker
        parts = re.split(r'(-----BEGIN [^-]+-----)', key_text)
        if len(parts) >= 3:
            header = parts[1]
            # Split at the END marker
            content_parts = re.split(r'(-----END [^-]+-----)', parts[2])
            if len(content_parts) >= 2:
                # Extract the base64 content and format with newlines
                content = content_parts[0].strip()
                content_chunks = content.split()
                formatted_content = '\n'.join(content_chunks)
                footer = content_parts[1]
                # Reassemble the key
                key_text = f"{header}\n{formatted_content}\n{footer}"
    return key_text


# ============================================================================
#                               Function to parse the certificate
# ============================================================================
def parse_cert(cert):
    import logging
    from cryptography.x509.oid import ExtensionOID

    cert = "\n".join(line.strip() for line in cert.strip().split("\n"))
    parsed = x509.load_pem_x509_certificate(cert.encode(), default_backend())
    issuer = None
    subject = None
    serial_number = None
    sig_algo = None
    expiry = None
    key_usages = 'None'
    crl_distribution_points = None

    try:
        issuer = parsed.issuer.rfc4514_string()
    except Exception as e:
        logging.error(f"Issuer extraction failed: {e}")
    try:
        subject = parsed.subject.rfc4514_string()
    except Exception as e:
        logging.error(f"Subject extraction failed: {e}")
    try:
        serial_number = f'{parsed.serial_number:x}'
    except Exception as e:
        logging.error(f"Serial number extraction failed: {e}")
    try:
        sig_algo = parsed.signature_algorithm_oid._name
    except Exception as e:
        logging.error(f"Signature algorithm extraction failed: {e}")
    try:
        expiry = parsed.not_valid_after_utc
        if expiry.tzinfo is None:
            expiry = expiry.replace(tzinfo=timezone.utc)
    except Exception as e:
        logging.error(f"Expiry extraction failed: {e}")
    try:
        key_usage_ext = parsed.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
        key_usage = key_usage_ext.value
        allowed_usages = []
        if key_usage.digital_signature:
            allowed_usages.append("Digital Signature")
        if key_usage.content_commitment:
            allowed_usages.append("Content Commitment")
        if key_usage.key_encipherment:
            allowed_usages.append("Key Encipherment")
        if key_usage.data_encipherment:
            allowed_usages.append("Data Encipherment")
        if key_usage.key_agreement:
            allowed_usages.append("Key Agreement")
            # Only check encipher_only and decipher_only if key_agreement is True
            if key_usage.encipher_only:
                allowed_usages.append("Encipher Only")
            if key_usage.decipher_only:
                allowed_usages.append("Decipher Only")
        if key_usage.key_cert_sign:
            allowed_usages.append("Certificate Signing")
        if key_usage.crl_sign:
            allowed_usages.append("CRL Signing")
        if allowed_usages:
            key_usages = ", ".join(allowed_usages)
    except Exception as e:
        logging.error(f"Key usage extraction failed: {e}")

    # Extract CRL Distribution Points
    try:
        crl_ext = parsed.extensions.get_extension_for_oid(ExtensionOID.CRL_DISTRIBUTION_POINTS)
        if crl_ext:
            crl_points = []
            for point in crl_ext.value:
                if point.full_name:
                    for name in point.full_name:
                        if name.value:
                            crl_points.append(name.value)
            if crl_points:
                crl_distribution_points = crl_points
    except Exception as e:
        if not "ObjectIdentifier(oid=2.5.29.31" in str(e):
            logging.error(f"CRL distribution points extraction failed: {e}")

    return serial_number, issuer, subject, sig_algo, expiry, key_usages, parsed, crl_distribution_points


# ============================================================================
#                               Function to format the DN string
# ============================================================================
def format_dn(dn):
    try:
        formatted = []
        sn = ""
        # Split the DN string by commas not preceded by a backslash (escape character)
        parts = re.split(r'(?<!\\),', dn)
        for part in parts:
            # Replace escaped commas with actual commas
            part = part.replace("\\,", ",")
            if part.startswith("2.5.4.5="):
                sn = part.split("=")[1]
                formatted.insert(0, sn)
            else:
                formatted.append(part.split("=")[1])
        if formatted:
            return ", ".join(formatted), sn
        else:
            return "UNKNOWN", sn
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in format_dn function")
        print(e)
        traceback.print_exc()
        return "UNKNOWN", sn


# ============================================================================
#                               Function analyze_kb_file
# ============================================================================
def analyze_kb_file(filepath=None, ecdsa_sn=None, ecdsa_issuer=None, rsa_sn=None, rsa_issuer=None, verbose=False):
    try:
        kb_index = load_kb_index()
        if not kb_index:
            print("No kb_index.json data found or file is empty.")
            return

        target_ecdsa_sn = None
        target_data = None

        # Direct lookup by ECDSA SN
        if ecdsa_sn and ecdsa_sn in kb_index:
            target_ecdsa_sn = ecdsa_sn
            target_data = kb_index[ecdsa_sn]

        # Search by filepath if ECDSA SN not provided
        elif filepath:
            for ecdsa_serial, data in kb_index.items():
                files = data.get('files', [])
                for file_entry in files:
                    file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else file_entry
                    if file_path == filepath:
                        target_ecdsa_sn = ecdsa_serial
                        target_data = data
                        break
                if target_data:
                    break

        # Fallback search by other criteria
        elif ecdsa_issuer or rsa_sn or rsa_issuer:
            for ecdsa_serial, data in kb_index.items():
                if ((ecdsa_issuer and data.get('ecdsa_issuer') == ecdsa_issuer) or
                    (rsa_sn and data.get('rsa_sn') == rsa_sn) or
                    (rsa_issuer and data.get('rsa_issuer') == rsa_issuer)):
                    target_ecdsa_sn = ecdsa_serial
                    target_data = data
                    break

        if not target_data:
            print("❌ ERROR: No keybox found matching the specified criteria.")
            return

        target_files = target_data.get('files', [])

        if verbose:
            print("=" * 80)
            print("KEYBOX FILE ANALYSIS REPORT")
            print("=" * 80)
            if filepath:
                print(f"Target File: {filepath}")
            print(f"Target ECDSA SN: {target_ecdsa_sn}")
            print("-" * 80)

            # Display keybox information
            print(f"ECDSA SN:     {target_ecdsa_sn}")
            print(f"RSA SN:       {target_data.get('rsa_sn', 'N/A')}")
            print(f"ECDSA Issuer: {target_data.get('ecdsa_issuer', 'N/A')}")
            print(f"RSA Issuer:   {target_data.get('rsa_issuer', 'N/A')}")
            print(f"ECDSA Leaf:   {target_data.get('ecdsa_leaf', 'N/A')}")
            print(f"ECDSA Chain:  {target_data.get('ecdsa_chain', 'N/A')}")
            print(f"RSA Leaf:     {target_data.get('rsa_leaf', 'N/A')}")
            print(f"RSA Chain:    {target_data.get('rsa_chain', 'N/A')}")
            print(f"Files Count:  {len(target_files)}")
            print("Files:")
            for file_entry in target_files:
                file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else file_entry
                file_hash = file_entry.get('hash', 'N/A') if isinstance(file_entry, dict) else 'N/A'
                if file_hash != 'N/A':
                    print(f"  - {file_path} (hash: {file_hash})")
                else:
                    print(f"  - {file_path}")

        # Find matches with other keyboxes
        hash_matches = []
        rsa_sn_matches = []
        ecdsa_issuer_matches = []
        rsa_issuer_matches = []

        # Get target hashes for comparison
        target_hashes = set()
        for file_entry in target_files:
            file_hash = file_entry.get('hash', '') if isinstance(file_entry, dict) else ''
            if file_hash:
                target_hashes.add(file_hash)

        # Compare with other keyboxes
        for ecdsa_serial, data in kb_index.items():
            if ecdsa_serial == target_ecdsa_sn:
                # If we're analyzing the same ECDSA serial number, we need to check for hash matches within the same group
                # but exclude the target file if analyzing a specific file
                files = data.get('files', [])
                for file_entry in files:
                    file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else file_entry
                    file_hash = file_entry.get('hash', '') if isinstance(file_entry, dict) else ''

                    # Only include if it's not the target file we're analyzing AND has matching hash
                    if file_hash in target_hashes and (not filepath or file_path != filepath):
                        hash_matches.append(file_path)

                # Also check for RSA SN matches within the same group
                if target_data.get('rsa_sn', 'N/A') != 'N/A' and data.get('rsa_sn') == target_data.get('rsa_sn'):
                    for file_entry in files:
                        file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else file_entry
                        # Only include if it's not the target file we're analyzing
                        if not filepath or file_path != filepath:
                            rsa_sn_matches.append(file_path)

                continue

            files = data.get('files', [])

            # Check for matching hashes
            for file_entry in files:
                file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else file_entry
                file_hash = file_entry.get('hash', '') if isinstance(file_entry, dict) else ''
                if file_hash in target_hashes:
                    hash_matches.append(file_path)

            # Check for matching RSA SN
            if target_data.get('rsa_sn', 'N/A') != 'N/A' and data.get('rsa_sn') == target_data.get('rsa_sn'):
                rsa_sn_matches.extend([f.get('path', '') if isinstance(f, dict) else f for f in files])

            # Check for matching ECDSA Issuer
            if target_data.get('ecdsa_issuer', 'N/A') != 'N/A' and data.get('ecdsa_issuer') == target_data.get('ecdsa_issuer'):
                ecdsa_issuer_matches.extend([f.get('path', '') if isinstance(f, dict) else f for f in files])

            # Check for matching RSA Issuer
            if target_data.get('rsa_issuer', 'N/A') != 'N/A' and data.get('rsa_issuer') == target_data.get('rsa_issuer'):
                rsa_issuer_matches.extend([f.get('path', '') if isinstance(f, dict) else f for f in files])

        to_print = f"  FILES WITH IDENTICAL HASH (hash: {list(target_hashes)[0] if target_hashes else 'N/A'}):"
        print("  " + "." * (len(to_print) -2))
        print(to_print)
        if hash_matches:
            for file_path in hash_matches:
                print(f"    - {file_path}")
        else:
            print("    No other files with identical hash found.")

        to_print = f"  FILES WITH IDENTICAL ECDSA SERIAL NUMBER ({target_data.get('ecdsa_sn', 'N/A')}):"
        print("  " + "." * (len(to_print) -2))
        print(to_print)

        # Get all files with the same ECDSA serial number (excluding the target file if analyzing a specific file)
        ecdsa_sn_matches = []
        target_files = target_data.get('files', [])

        if filepath:
            # If analyzing a specific file, exclude it from the list
            for file_entry in target_files:
                file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else file_entry
                if file_path != filepath:
                    ecdsa_sn_matches.append(file_path)
        else:
            # If searching by ECDSA SN directly, show all files
            for file_entry in target_files:
                file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else file_entry
                ecdsa_sn_matches.append(file_path)

        if ecdsa_sn_matches:
            for file_path in ecdsa_sn_matches:
                print(f"    - {file_path}")
        else:
            print("    No other files with identical ECDSA serial number found.")

        to_print = f"  FILES WITH IDENTICAL RSA SERIAL NUMBER ({target_data.get('rsa_sn', 'N/A')}):"
        print("  " + "." * (len(to_print) -2))
        print(to_print)
        if rsa_sn_matches:
            for file_path in rsa_sn_matches:
                print(f"    - {file_path}")
        else:
            print("    No other files with identical RSA serial number found.")

        to_print = f"  FILES WITH SAME ECDSA ISSUER ({target_data.get('ecdsa_issuer', 'N/A')}):"
        print("  " + "." * (len(to_print) -2))
        print(to_print)
        if ecdsa_issuer_matches:
            for file_path in ecdsa_issuer_matches:
                print(f"    - {file_path}")
        else:
            print("    No other files with same ECDSA issuer found.")

        to_print = f"  FILES WITH SAME RSA ISSUER ({target_data.get('rsa_issuer', 'N/A')}):"
        print("  " + "." * (len(to_print) -2))
        print(to_print)
        if rsa_issuer_matches:
            for file_path in rsa_issuer_matches:
                print(f"    - {file_path}")
        else:
            print("    No other files with same RSA issuer found.")

        print("  -------")
        print("  SUMMARY")
        print("  -------")
        print(f"  Hash matches:                      {len(hash_matches)}")
        print(f"  ECDSA SN matches:                  {len(ecdsa_sn_matches)}")
        print(f"  RSA SN matches:                    {len(rsa_sn_matches)}")
        print(f"  ECDSA Issuer matches:              {len(ecdsa_issuer_matches)}")
        print(f"  RSA Issuer matches:                {len(rsa_issuer_matches)}")

        all_matches = set(hash_matches + ecdsa_sn_matches + rsa_sn_matches + ecdsa_issuer_matches + rsa_issuer_matches)
        print(f"  Total unique files with any match: {len(all_matches)}")

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in analyze_kb_file function")
        traceback.print_exc()


# ============================================================================
#                               Function kb_add_missing_files
# ============================================================================
def kb_add_missing_files(target_path, check_validity=True, dry_run=False, verbose=False):
    try:
        if not target_path or not os.path.exists(target_path):
            print(f"❌ ERROR: Target path '{target_path}' does not exist or is not provided")
            return None

        kb_index = load_kb_index()

        # Get all existing file paths from kb_index
        existing_files = set()
        for ecdsa_sn, entry in kb_index.items():
            files = entry.get('files', [])
            for file_entry in files:
                file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                existing_files.add(os.path.normpath(file_path))

        # Scan for keybox files in target path
        keybox_files = []
        total_scanned = 0

        print(f"Scanning directory: {target_path}")
        print("Looking for keybox files (*.xml)...")

        for root, dirs, files in os.walk(target_path):
            for file in files:
                total_scanned += 1
                if file.lower().endswith('.xml'):
                    file_path = os.path.join(root, file)
                    normalized_path = os.path.normpath(file_path)

                    # Check if this file is already in kb_index
                    if normalized_path not in existing_files:
                        keybox_files.append(file_path)
                        if verbose:
                            print(f"  Found potential keybox: {file_path}")

        print(f"Found {len(keybox_files)} potentially missing keybox files")

        # Initialize results
        results = {
            'total_scanned': total_scanned,
            'missing_files_found': len(keybox_files),
            'valid_files': [],
            'invalid_files': [],
            'added_count': 0
        }

        if not keybox_files:
            print("No missing keybox files found")
            return results

        # Check validity if requested
        if check_validity:
            print("Validating keybox files...")
            for file_path in keybox_files:
                wx.Yield()
                try:
                    # Basic XML validation
                    tree = ET.parse(file_path)
                    root = tree.getroot()

                    # Check if it's a valid keybox file
                    if root.tag == 'AndroidAttestation':
                        keyboxes = root.findall('Keybox')
                        if keyboxes:
                            print(f"  ✅ Valid keybox: {os.path.basename(file_path)}")
                            results['valid_files'].append(file_path)
                        else:
                            print(f"  ❌ Invalid keybox (no Keybox elements): {os.path.basename(file_path)}")
                            results['invalid_files'].append(file_path)
                    else:
                        print(f"  ❌ Invalid keybox (not AndroidAttestation): {os.path.basename(file_path)}")
                        results['invalid_files'].append(file_path)

                except Exception as e:
                    print(f"  ❌ Invalid keybox (parse error): {os.path.basename(file_path)} - {str(e)}")
                    results['invalid_files'].append(file_path)
        else:
            # If not checking validity, assume all are valid
            results['valid_files'] = keybox_files[:]

        # Add valid files to kb_index if not in dry_run mode
        if not dry_run and results['valid_files']:
            print(f"Adding {len(results['valid_files'])} valid keybox files to kb_index...")

            for file_path in results['valid_files']:
                wx.Yield()
                try:
                    print(f"  Processing: {os.path.basename(file_path)}")

                    # Check the keybox to get certificate details
                    kb_results = check_kb(file_path, force_fresh=False)

                    if kb_results and 'invalid' not in kb_results:
                        results['added_count'] += 1
                        if verbose:
                            print(f"    ✅ Added to kb_index")
                    else:
                        print(f"    ⚠️ Keybox validation failed, not added to index")
                        results['invalid_files'].append(file_path)
                        if file_path in results['valid_files']:
                            results['valid_files'].remove(file_path)

                except Exception as e:
                    print(f"    ❌ Error processing keybox: {str(e)}")
                    results['invalid_files'].append(file_path)
                    if file_path in results['valid_files']:
                        results['valid_files'].remove(file_path)

        elif dry_run:
            print("DRY RUN: kb_index is not updated")
            results['added_count'] = len(results['valid_files'])

        return results

    except Exception as e:
        print(f"❌ ERROR: Encountered an error in kb_add_missing_files function")
        traceback.print_exc()
        return None


# ============================================================================
#                 Function: kb_stats
# ============================================================================
def kb_stats(verbose=False, list_unique_files=False, list_valid_entries=False, list_non_common_entries=False, target_path=None, check_file_existence=False, list_non_existent=False, remove_non_existent=False, add_missing_files=False):
    try:
        kb_index = load_kb_index()
        if not kb_index:
            print("❌ ERROR: No kb_index.json data found or file is empty.")
            print("Please ensure keybox files have been processed first and KB indexing is enabled.")
            return None

        print(f"\n" + "=" * 80)
        print("KEYBOX STATISTICS ANALYSIS")
        print("=" * 80)

        # Initialize counters
        stats = {
            'total_entries': len(kb_index),
            'total_files': 0,
            'unique_file_entries': 0,
            'unique_valid_ecdsa_only': 0,
            'unique_valid_all_chains': 0,
            'entries_valid_ecdsa': 0,
            'entries_valid_all_chains': 0,
            'entries_valid_ecdsa_revoked_chain': 0,
            'revoked_ecdsa_leaf': 0,
            'expired_ecdsa_leaf': 0,
            'valid_ecdsa_chain': 0,
            'revoked_ecdsa_chain': 0,
            'unique_ecdsa_issuers': set(),
            'unique_rsa_issuers': set(),
            'unique_ecdsa_root_ca_sns': {},
            'unique_rsa_root_ca_sns': {},
            'non_common_keyboxes_path': {
                'valid_ecdsa': [],
                'invalid': [],
                'valid_count': 0,
                'invalid_count': 0
            },
            'non_existent_files': [],
            'non_existent_count': 0,
            'valid_ecdsa_revoked_chain_entries': [],
            'unique_file_list': [],
            'valid_ecdsa_entries': [],
            'valid_all_chains_entries': [],
            'parsing_errors': 0
        }

        # Track entries to remove if requested
        entries_to_update = []

        # Analyze each entry
        for ecdsa_sn, entry in kb_index.items():
            try:
                # Count total files
                files = entry.get('files', [])
                stats['total_files'] += len(files)

                # Check file existence if requested
                if check_file_existence:
                    existing_files = []
                    for file_entry in files:
                        file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                        if os.path.exists(file_path):
                            existing_files.append(file_entry)
                        else:
                            stats['non_existent_files'].append({
                                'ecdsa_sn': ecdsa_sn,
                                'file_path': file_path,
                                'file_entry': file_entry
                            })
                            stats['non_existent_count'] += 1

                    # Update the files list if we're removing non-existent files
                    if remove_non_existent and len(existing_files) != len(files):
                        entries_to_update.append({
                            'ecdsa_sn': ecdsa_sn,
                            'existing_files': existing_files
                        })

                # Get validation statuses
                ecdsa_leaf = entry.get('ecdsa_leaf', '')
                ecdsa_chain = entry.get('ecdsa_chain', '')
                rsa_leaf = entry.get('rsa_leaf', '')
                rsa_chain = entry.get('rsa_chain', '')

                # Get root CA SNs from the first file entry
                ecdsa_root_ca_sn = None
                rsa_root_ca_sn = None
                if files and isinstance(files[0], dict):
                    ecdsa_root_ca_sn = files[0].get('ecdsa_root_ca_sn')
                    rsa_root_ca_sn = files[0].get('rsa_root_ca_sn')

                ecdsa_leaf_valid = ecdsa_leaf == 'valid' and ecdsa_root_ca_sn
                ecdsa_chain_valid = ecdsa_chain == 'valid'
                rsa_leaf_valid = rsa_leaf == 'valid' and rsa_root_ca_sn
                rsa_chain_valid = rsa_chain == 'valid'

                # Check for single file entries
                if len(files) == 1:
                    stats['unique_file_entries'] += 1
                    stats['unique_file_list'].append({
                        'ecdsa_sn': ecdsa_sn,
                        'file': files[0],
                        'ecdsa_leaf': ecdsa_leaf,
                        'ecdsa_chain': ecdsa_chain,
                        'rsa_leaf': rsa_leaf,
                        'rsa_chain': rsa_chain
                    })

                    # Count unique file entries with valid certificates
                    if ecdsa_leaf_valid and ecdsa_chain_valid:
                        stats['unique_valid_ecdsa_only'] += 1
                    if ecdsa_leaf_valid and ecdsa_chain_valid and rsa_leaf_valid and rsa_chain_valid:
                        stats['unique_valid_all_chains'] += 1

                # Count certificate statuses
                if ecdsa_leaf == 'revoked':
                    stats['revoked_ecdsa_leaf'] += 1
                if ecdsa_leaf == 'expired':
                    stats['expired_ecdsa_leaf'] += 1
                if ecdsa_chain_valid:
                    stats['valid_ecdsa_chain'] += 1
                if ecdsa_chain == 'revoked':
                    stats['revoked_ecdsa_chain'] += 1

                # Count entries with valid certificates
                if ecdsa_leaf_valid and ecdsa_chain_valid:
                    stats['entries_valid_ecdsa'] += 1
                    stats['valid_ecdsa_entries'].append({
                        'ecdsa_sn': ecdsa_sn,
                        'files': files,
                        'file_count': len(files),
                        'ecdsa_issuer': entry.get('ecdsa_issuer', ''),
                        'rsa_issuer': entry.get('rsa_issuer', ''),
                        'rsa_leaf': rsa_leaf,
                        'rsa_chain': rsa_chain
                    })

                # Count entries with valid ECDSA leaf but revoked ECDSA chain
                if ecdsa_leaf_valid and ecdsa_chain == 'revoked':
                    ecdsa_length = entry.get('ecdsa_length', 0)
                    if ecdsa_length <= 3:
                        stats['entries_valid_ecdsa_revoked_chain'] += 1
                        stats['valid_ecdsa_revoked_chain_entries'].append({
                            'ecdsa_sn': ecdsa_sn,
                            'files': files,
                            'file_count': len(files),
                            'ecdsa_leaf': ecdsa_leaf,
                            'ecdsa_chain': ecdsa_chain,
                            'rsa_leaf': rsa_leaf,
                            'rsa_chain': rsa_chain,
                            'ecdsa_issuer': entry.get('ecdsa_issuer', ''),
                            'rsa_issuer': entry.get('rsa_issuer', '')
                        })

                if ecdsa_leaf_valid and ecdsa_chain_valid and rsa_leaf_valid and rsa_chain_valid:
                    stats['entries_valid_all_chains'] += 1
                    stats['valid_all_chains_entries'].append({
                        'ecdsa_sn': ecdsa_sn,
                        'files': files,
                        'file_count': len(files),
                        'ecdsa_issuer': entry.get('ecdsa_issuer', ''),
                        'rsa_issuer': entry.get('rsa_issuer', '')
                    })

                # Collect unique issuers
                ecdsa_issuer = entry.get('ecdsa_issuer', '')
                rsa_issuer = entry.get('rsa_issuer', '')
                if ecdsa_issuer:
                    stats['unique_ecdsa_issuers'].add(ecdsa_issuer)
                if rsa_issuer:
                    stats['unique_rsa_issuers'].add(rsa_issuer)

                # Collect unique root CA serial numbers from files
                for file_entry in files:
                    file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)

                    # Process ECDSA root CA serial numbers
                    ecdsa_root_ca_sn = file_entry.get('ecdsa_root_ca_sn', '') if isinstance(file_entry, dict) else ''
                    if ecdsa_root_ca_sn:
                        if ecdsa_root_ca_sn not in stats['unique_ecdsa_root_ca_sns']:
                            stats['unique_ecdsa_root_ca_sns'][ecdsa_root_ca_sn] = []
                        stats['unique_ecdsa_root_ca_sns'][ecdsa_root_ca_sn].append(file_path)

                    # Process RSA root CA serial numbers
                    rsa_root_ca_sn = file_entry.get('rsa_root_ca_sn', '') if isinstance(file_entry, dict) else ''
                    if rsa_root_ca_sn:
                        if rsa_root_ca_sn not in stats['unique_rsa_root_ca_sns']:
                            stats['unique_rsa_root_ca_sns'][rsa_root_ca_sn] = []
                        stats['unique_rsa_root_ca_sns'][rsa_root_ca_sn].append(file_path)

                # Check for entries not in target path - only if target_path is specified
                if target_path:
                    has_common_path = False
                    for file_entry in files:
                        file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                        # Normalize path separators for cross-platform comparison
                        if os.path.normpath(target_path).lower() in os.path.normpath(file_path).lower():
                            has_common_path = True
                            break

                    if not has_common_path:
                        entry_info = {
                            'ecdsa_sn': ecdsa_sn,
                            'files': files,
                            'file_count': len(files),
                            'ecdsa_leaf': ecdsa_leaf,
                            'ecdsa_chain': ecdsa_chain,
                            'rsa_leaf': rsa_leaf,
                            'rsa_chain': rsa_chain,
                            'ecdsa_issuer': ecdsa_issuer,
                            'rsa_issuer': rsa_issuer
                        }

                        if ecdsa_leaf_valid and ecdsa_chain_valid:
                            stats['non_common_keyboxes_path']['valid_ecdsa'].append(entry_info)
                            stats['non_common_keyboxes_path']['valid_count'] += 1
                        else:
                            stats['non_common_keyboxes_path']['invalid'].append(entry_info)
                            stats['non_common_keyboxes_path']['invalid_count'] += 1

            except Exception as e:
                print(f"⚠️ Warning: Error processing entry {ecdsa_sn}: {e}")
                stats['parsing_errors'] += 1
                continue

        # Update kb_index if removing non-existent files
        if remove_non_existent and entries_to_update:
            for entry_update in entries_to_update:
                ecdsa_sn = entry_update['ecdsa_sn']
                existing_files = entry_update['existing_files']

                if len(existing_files) == 0:
                    # Remove entire entry if no files exist
                    del kb_index[ecdsa_sn]
                    print(f"  Removed entire entry for ECDSA SN: {ecdsa_sn} (no existing files)")
                else:
                    # Update files list with only existing files
                    kb_index[ecdsa_sn]['files'] = existing_files
                    print(f"  Updated files list for ECDSA SN: {ecdsa_sn} ({len(existing_files)} files remain)")

            # Save updated kb_index
            save_kb_index(kb_index)
            print(f"Updated kb_index.json with {len(entries_to_update)} entries modified")

        # Print results
        print(f"Total entries (keys):                                    {stats['total_entries']:>8,}")
        print(f"Total files:                                             {stats['total_files']:>8,}")
        print()
        print(f"Unique file entries (single file per key) total:         {stats['unique_file_entries']:>8,}")
        print(f"  - Entries with valid ECDSA leaf & chain:               {stats['unique_valid_ecdsa_only']:>8,}")
        print(f"  - Entries with all valid chains (ECDSA + RSA):         {stats['unique_valid_all_chains']:>8,}")
        print()
        print(f"Entries with valid ECDSA leaf & chain:                   {stats['entries_valid_ecdsa']:>8,}")
        print(f"Entries with all valid chains (ECDSA + RSA):             {stats['entries_valid_all_chains']:>8,}")
        print(f"Entries with valid ECDSA leaf but revoked ECDSA chain:   {stats['entries_valid_ecdsa_revoked_chain']:>8,}")
        print()
        print(f"Revoked ECDSA leaf certificates:                         {stats['revoked_ecdsa_leaf']:>8,}")
        print(f"Expired ECDSA leaf certificates:                         {stats['expired_ecdsa_leaf']:>8,}")
        print(f"Valid ECDSA certificate chains:                          {stats['valid_ecdsa_chain']:>8,}")
        print(f"Revoked ECDSA certificate chains:                        {stats['revoked_ecdsa_chain']:>8,}")
        print()
        print(f"Unique ECDSA issuers:                                    {len(stats['unique_ecdsa_issuers']):>8,}")
        print(f"Unique RSA issuers:                                      {len(stats['unique_rsa_issuers']):>8,}")
        print(f"Unique ECDSA root CA serial numbers:                     {len(stats['unique_ecdsa_root_ca_sns']):>8,}")
        print(f"Unique RSA root CA serial numbers:                       {len(stats['unique_rsa_root_ca_sns']):>8,}")

        if target_path:
            print()
            print(f"Entries NOT in '{target_path}':")
            print(f"  Valid ECDSA (leaf & chain):                            {stats['non_common_keyboxes_path']['valid_count']:>8,}")
            print(f"  Invalid/Other:                                         {stats['non_common_keyboxes_path']['invalid_count']:>8,}")

        if check_file_existence:
            print()
            print(f"Non-existent files:                                      {stats['non_existent_count']:>8,}")

        if stats['parsing_errors'] > 0:
            print(f"\nParsing errors encountered:                            {stats['parsing_errors']:>8,}")

        # List unique files if requested
        if list_unique_files and stats['unique_file_list']:
            print(f"\n" + "=" * 80)
            print(f"UNIQUE FILE ENTRIES LIST ({len(stats['unique_file_list'])} entries)")
            print("=" * 80)
            for i, entry in enumerate(stats['unique_file_list'], 1):
                file_path = entry['file'].get('path', '') if isinstance(entry['file'], dict) else str(entry['file'])
                print(f"{i:3d}. ECDSA SN: {entry['ecdsa_sn']}")
                print(f"     Status: ECDSA({entry['ecdsa_leaf']}/{entry['ecdsa_chain']}) RSA({entry['rsa_leaf']}/{entry['rsa_chain']})")
                print(f"     File: {file_path}")
                print()

        # List valid entries if requested
        if list_valid_entries:
            if stats['valid_ecdsa_entries']:
                print(f"\n" + "=" * 80)
                print(f"ENTRIES WITH VALID ECDSA LEAF & CHAIN ({len(stats['valid_ecdsa_entries'])} entries)")
                print("=" * 80)
                for i, entry in enumerate(stats['valid_ecdsa_entries'], 1):
                    print(f"{i:3d}. ECDSA SN: {entry['ecdsa_sn']}")
                    print(f"     RSA Status: {entry['rsa_leaf']}/{entry['rsa_chain']}")
                    print(f"     ECDSA Issuer: {entry['ecdsa_issuer']}")
                    if entry['rsa_issuer']:
                        print(f"     RSA Issuer: {entry['rsa_issuer']}")
                    print(f"     Files: {entry['file_count']}")
                    # List the actual files
                    kb_entry = kb_index.get(entry['ecdsa_sn'], {})
                    files = kb_entry.get('files', [])
                    for j, file_entry in enumerate(files, 1):
                        file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                        # print(f"       {j}. {file_path}")
                        print(f"       - {file_path}")
                    print()

            if stats['valid_all_chains_entries']:
                print(f"\n" + "=" * 80)
                print(f"ENTRIES WITH ALL VALID CHAINS ({len(stats['valid_all_chains_entries'])} entries)")
                print("=" * 80)
                for i, entry in enumerate(stats['valid_all_chains_entries'], 1):
                    print(f"{i:3d}. ECDSA SN: {entry['ecdsa_sn']}")
                    print(f"     ECDSA Issuer: {entry['ecdsa_issuer']}")
                    print(f"     RSA Issuer: {entry['rsa_issuer']}")
                    print(f"     Files: {entry['file_count']}")
                    # List the actual files
                    kb_entry = kb_index.get(entry['ecdsa_sn'], {})
                    files = kb_entry.get('files', [])
                    for j, file_entry in enumerate(files, 1):
                        file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                        # print(f"       {j}. {file_path}")
                        print(f"       - {file_path}")
                    print()

        # List valid entries with revoked chains if verbose
        if verbose and stats['valid_ecdsa_revoked_chain_entries']:
            print(f"\n" + "=" * 80)
            print(f"ENTRIES WITH VALID ECDSA LEAF BUT REVOKED CHAIN ({len(stats['valid_ecdsa_revoked_chain_entries'])} entries)")
            print("=" * 80)
            for i, entry in enumerate(stats['valid_ecdsa_revoked_chain_entries'], 1):
                print(f"{i:3d}. ECDSA SN: {entry['ecdsa_sn']}")
                print(f"     Status: ECDSA({entry['ecdsa_leaf']}/{entry['ecdsa_chain']}) RSA({entry['rsa_leaf']}/{entry['rsa_chain']})")
                print(f"     ECDSA Issuer: {entry['ecdsa_issuer']}")
                if entry['rsa_issuer']:
                    print(f"     RSA Issuer: {entry['rsa_issuer']}")
                print(f"     Files: {entry['file_count']}")
                # List the actual files
                kb_entry = kb_index.get(entry['ecdsa_sn'], {})
                files = kb_entry.get('files', [])
                for j, file_entry in enumerate(files, 1):
                    file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                    print(f"       {j}. {file_path}")
                print()

        # List non-existent files if requested
        if list_non_existent and stats['non_existent_files']:
            print(f"\n" + "=" * 80)
            print(f"NON-EXISTENT FILES ({len(stats['non_existent_files'])} files)")
            print("=" * 80)

            # Group non-existent files by ECDSA SN to show existing files for context
            grouped_missing = {}
            for file_info in stats['non_existent_files']:
                ecdsa_sn = file_info['ecdsa_sn']
                if ecdsa_sn not in grouped_missing:
                    grouped_missing[ecdsa_sn] = []
                grouped_missing[ecdsa_sn].append(file_info['file_path'])

            counter = 1
            for ecdsa_sn, missing_files in grouped_missing.items():
                print(f"{counter:3d}. ECDSA SN: {ecdsa_sn}")

                # Get all files for this ECDSA SN from kb_index
                entry = kb_index.get(ecdsa_sn, {})
                all_files = entry.get('files', [])

                # Separate existing and missing files
                existing_files = []
                for file_entry in all_files:
                    file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                    if file_path not in missing_files and os.path.exists(file_path):
                        existing_files.append(file_path)

                # Print missing files
                for missing_file in missing_files:
                    print(f"     Missing: {missing_file}")

                # Print existing files
                if existing_files:
                    for existing_file in existing_files:
                        print(f"     Present: {existing_file}")
                else:
                    print(f"     Present: None")

                print()
                counter += 1

        # List non-common path entries if requested
        if list_non_common_entries:
            if stats['non_common_keyboxes_path']['valid_ecdsa']:
                print(f"\n" + "=" * 80)
                print(f"ENTRIES WITH VALID ECDSA NOT IN COMMON PATH ({len(stats['non_common_keyboxes_path']['valid_ecdsa'])} entries)")
                print("=" * 80)
                for i, entry in enumerate(stats['non_common_keyboxes_path']['valid_ecdsa'], 1):
                    print(f"{i:3d}. ECDSA SN: {entry['ecdsa_sn']}")
                    print(f"     Status: ECDSA({entry['ecdsa_leaf']}/{entry['ecdsa_chain']}) RSA({entry['rsa_leaf']}/{entry['rsa_chain']})")
                    print(f"     Files: {entry['file_count']}")
                    n = 5  # Number of files to show
                    for j, file_entry in enumerate(entry['files'][:n], 1):  # Show first n files
                        file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                        print(f"     {j}. {file_path}")
                    if len(entry['files']) > n:
                        print(f"     ... and {len(entry['files']) - n} more files")
                    print()

            if stats['non_common_keyboxes_path']['invalid']:
                print(f"\n" + "=" * 80)
                print(f"ENTRIES WITH INVALID/OTHER STATUS NOT IN COMMON PATH ({len(stats['non_common_keyboxes_path']['invalid'])} entries)")
                print("=" * 80)
                for i, entry in enumerate(stats['non_common_keyboxes_path']['invalid'], 1):
                    print(f"{i:3d}. ECDSA SN: {entry['ecdsa_sn']}")
                    print(f"     Status: ECDSA({entry['ecdsa_leaf']}/{entry['ecdsa_chain']}) RSA({entry['rsa_leaf']}/{entry['rsa_chain']})")
                    print(f"     Files: {entry['file_count']}")
                    n = 5 # Number of files to show
                    for j, file_entry in enumerate(entry['files'][:n], 1):  # Show first n files
                        file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                        print(f"     {j}. {file_path}")
                    if len(entry['files']) > n:
                        print(f"     ... and {len(entry['files']) - n} more files")
                    print()

        # Verbose output
        if verbose:
            print(f"\n" + "=" * 80)
            print("DETAILED BREAKDOWN")
            print("=" * 80)

            if stats['unique_ecdsa_issuers']:
                print(f"\nUnique ECDSA Issuers ({len(stats['unique_ecdsa_issuers'])}):")
                for issuer in sorted(stats['unique_ecdsa_issuers']):
                    print(f"  - {issuer}")

            if stats['unique_rsa_issuers']:
                print(f"\nUnique RSA Issuers ({len(stats['unique_rsa_issuers'])}):")
                for issuer in sorted(stats['unique_rsa_issuers']):
                    print(f"  - {issuer}")

            if stats['unique_ecdsa_root_ca_sns']:
                print(f"\nUnique ECDSA Root CA Serial Numbers ({len(stats['unique_ecdsa_root_ca_sns'])}):")
                for ecdsa_root_ca_sn in sorted(stats['unique_ecdsa_root_ca_sns'].keys()):
                    print(f"  - {ecdsa_root_ca_sn} ({len(stats['unique_ecdsa_root_ca_sns'][ecdsa_root_ca_sn])} files):")
                    for file_path in sorted(stats['unique_ecdsa_root_ca_sns'][ecdsa_root_ca_sn]):
                        print(f"    - {file_path}")

            if stats['unique_rsa_root_ca_sns']:
                print(f"\nUnique RSA Root CA Serial Numbers ({len(stats['unique_rsa_root_ca_sns'])}):")
                for rsa_root_ca_sn in sorted(stats['unique_rsa_root_ca_sns'].keys()):
                    print(f"  - {rsa_root_ca_sn} ({len(stats['unique_rsa_root_ca_sns'][rsa_root_ca_sn])} files):")
                    for file_path in sorted(stats['unique_rsa_root_ca_sns'][rsa_root_ca_sn]):
                        print(f"    - {file_path}")

        # Add missing files
        if add_missing_files and target_path:
            print(f"\n" + "=" * 80)
            print("SCANNING FOR MISSING KEYBOX FILES")
            print("=" * 80)

            missing_files_results = kb_add_missing_files(

                target_path=target_path,
                check_validity=True,
                dry_run=False,
                verbose=verbose
            )

            if missing_files_results:
                stats['missing_files_scan'] = missing_files_results
                print(f"Missing files scan completed:")
                print(f"  Files scanned: {missing_files_results['total_scanned']:>8,}")
                print(f"  Missing files found: {missing_files_results['missing_files_found']:>8,}")
                if 'valid_files' in missing_files_results:
                    print(f"  Valid files found: {len(missing_files_results['valid_files']):>8,}")
                    print(f"  Invalid files found: {len(missing_files_results['invalid_files']):>8,}")
                print(f"  Files added to kb_index: {missing_files_results['added_count']:>8,}")
        elif add_missing_files and not target_path:
            print(f"\n⚠️ Warning: add_missing_files requested but no target_path specified")

        print("=" * 80)
        return stats

    except Exception as e:
        print(f"❌ ERROR: Unexpected error during analysis: {e}")
        traceback.print_exc()
        return None


# ============================================================================
#                               Function update_kb_index_with_crl
# ============================================================================
def update_kb_index_with_crl():
    try:
        url = "https://android.googleapis.com/attestation/status"
        headers = {
            'Cache-Control': 'no-cache, max-age=0',
            'Pragma': 'no-cache'
        }

        print("Fetching Certificate Revocation List...")

        # Add timestamp to URL to ensure fresh data
        timestamp = int(time.time())
        cache_bust_url = f"{url}?_t={timestamp}"

        # Enhanced cache-busting headers
        fresh_headers = headers.copy()
        fresh_headers.update({
            'Cache-Control': 'no-cache, no-store, must-revalidate, max-age=0',
            'Pragma': 'no-cache',
            'Expires': '0',
            'If-Modified-Since': 'Thu, 01 Jan 1970 00:00:00 GMT',
            'Accept-Encoding': 'identity'
        })

        # Fetch CRL from server
        crl = request_with_fallback(method='GET', url=cache_bust_url, headers=fresh_headers, nocache=True)

        if crl is None or crl == 'ERROR':
            print(f"❌ ERROR: Could not fetch CRL from {url}")
            return {'error': 'Failed to fetch CRL'}

        crl_data = crl.json()

        # Load kb_index
        kb_index = load_kb_index()
        if not kb_index:
            print("❌ ERROR: No kb_index.json data found or file is empty.")
            return {'error': 'No kb_index data found'}

        # Extract revoked entries from CRL
        revoked_entries = set()
        if 'entries' in crl_data:
            for entry_key in crl_data['entries'].keys():
                revoked_entries.add(entry_key.strip().lower())

        print(f"Processing {len(kb_index)} keybox entries against {len(revoked_entries)} revoked certificates...")

        # Track changes
        changes_summary = {
            'total_entries_checked': len(kb_index),
            'entries_modified': 0,
            'ecdsa_leaf_revoked': [],
            'ecdsa_chain_revoked': [],
            'rsa_leaf_revoked': [],
            'rsa_chain_revoked': [],
            'total_changes': 0
        }

        # Process each entry in kb_index
        for ecdsa_sn, entry in kb_index.items():
            entry_modified = False
            changes_for_entry = []

            # Check ECDSA serial number (leaf certificate)
            if entry.get('ecdsa_sn'):
                ecdsa_sn_check = entry['ecdsa_sn'].strip().lower()
                if ecdsa_sn_check in revoked_entries and entry.get('ecdsa_leaf') != 'revoked':
                    old_value = entry.get('ecdsa_leaf', 'unknown')
                    entry['ecdsa_leaf'] = 'revoked'
                    changes_for_entry.append(f"ecdsa_leaf: '{old_value}' → 'revoked'")
                    changes_summary['ecdsa_leaf_revoked'].append({
                        'ecdsa_sn': ecdsa_sn,
                        'old_value': old_value
                    })
                    entry_modified = True

            # Check ECDSA issuer (certificate chain)
            if entry.get('ecdsa_issuer'):
                ecdsa_issuer_check = entry['ecdsa_issuer'].strip().lower()
                if ecdsa_issuer_check in revoked_entries and entry.get('ecdsa_chain') != 'revoked':
                    old_value = entry.get('ecdsa_chain', 'unknown')
                    entry['ecdsa_chain'] = 'revoked'
                    changes_for_entry.append(f"ecdsa_chain: '{old_value}' → 'revoked'")
                    changes_summary['ecdsa_chain_revoked'].append({
                        'ecdsa_sn': ecdsa_sn,
                        'ecdsa_issuer': ecdsa_issuer_check,
                        'old_value': old_value
                    })
                    entry_modified = True

            # Check RSA serial number (leaf certificate)
            if entry.get('rsa_sn'):
                rsa_sn_check = entry['rsa_sn'].strip().lower()
                if rsa_sn_check in revoked_entries and entry.get('rsa_leaf') != 'revoked':
                    old_value = entry.get('rsa_leaf', 'unknown')
                    entry['rsa_leaf'] = 'revoked'
                    changes_for_entry.append(f"rsa_leaf: '{old_value}' → 'revoked'")
                    changes_summary['rsa_leaf_revoked'].append({
                        'ecdsa_sn': ecdsa_sn,
                        'rsa_sn': rsa_sn_check,
                        'old_value': old_value
                    })
                    entry_modified = True

            # Check RSA issuer (certificate chain)
            if entry.get('rsa_issuer'):
                rsa_issuer_check = entry['rsa_issuer'].strip().lower()
                if rsa_issuer_check in revoked_entries and entry.get('rsa_chain') != 'revoked':
                    old_value = entry.get('rsa_chain', 'unknown')
                    entry['rsa_chain'] = 'revoked'
                    changes_for_entry.append(f"rsa_chain: '{old_value}' → 'revoked'")
                    changes_summary['rsa_chain_revoked'].append({
                        'ecdsa_sn': ecdsa_sn,
                        'rsa_issuer': rsa_issuer_check,
                        'old_value': old_value
                    })
                    entry_modified = True

            # Update last_updated timestamp if entry was modified
            if entry_modified:
                entry['last_updated'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                changes_summary['entries_modified'] += 1
                changes_summary['total_changes'] += len(changes_for_entry)
                print(f"🏷️ Updated ECDSA SN {ecdsa_sn}:")
                for change in changes_for_entry:
                    print(f"    - {change}")

                # Show files associated with this keybox
                files = entry.get('files', [])
                print(f"    Files ({len(files)}):")
                for file_entry in files:
                    file_path = file_entry.get('path', '') if isinstance(file_entry, dict) else str(file_entry)
                    print(f"      - {file_path}")
                print()

        # Save updated kb_index if there were changes
        if changes_summary['entries_modified'] > 0:
            save_kb_index(kb_index)
            print(f"\n✅ Updated kb_index.json with {changes_summary['entries_modified']} modified entries")
        else:
            print("\n✅ No entries needed to be updated based on current CRL")

        # Print summary report
        print("\n" + "=" * 80)
        print("KEYBOX INDEX CRL UPDATE SUMMARY")
        print("=" * 80)
        print(f"Total entries checked:            {changes_summary['total_entries_checked']:>8,}")
        print(f"Entries modified:                 {changes_summary['entries_modified']:>8,}")
        print(f"Total individual changes:         {changes_summary['total_changes']:>8,}")
        print()
        print(f"ECDSA leaf certificates revoked:  {len(changes_summary['ecdsa_leaf_revoked']):>8,}")
        print(f"ECDSA chain certificates revoked: {len(changes_summary['ecdsa_chain_revoked']):>8,}")
        print(f"RSA leaf certificates revoked:    {len(changes_summary['rsa_leaf_revoked']):>8,}")
        print(f"RSA chain certificates revoked:   {len(changes_summary['rsa_chain_revoked']):>8,}")
        print("=" * 80)

        return changes_summary

    except Exception as e:
        print(f"❌ ERROR: Encountered an error in update_kb_index_with_crl function")
        traceback.print_exc()
        return {'error': str(e)}


# ============================================================================
#                               Function get_boot_image_info
# ============================================================================
def get_boot_image_info(boot_image_path):
    try:
        tool = avbtool.AvbTool()
        if not os.path.exists(boot_image_path):
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Boot image file not found: {boot_image_path}")
            return
        info = tool.run(['avbtool.py','info_image', '--image', boot_image_path])
        print('')
        return info

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_boot_image_info function")
        print(e)
        traceback.print_exc()


# ============================================================================
#                               Function add_hash_footer
# ============================================================================
def add_hash_footer(boot_image_path,
                    partition_size,
                    partition_name,
                    salt,
                    rollback_index,
                    algorithm,
                    hash_algorithm,
                    prop_com_android_build_boot_os_version,
                    prop_com_android_build_boot_fingerprint,
                    prop_com_android_build_boot_security_patch_level
                ):

    try:
        tool = avbtool.AvbTool()
        tool.run(['avbtool.py','add_hash_footer',
                    '--image', boot_image_path,
                    '--partition_size', partition_size,
                    '--partition_name', partition_name,
                    '--salt', salt,
                    '--rollback_index', rollback_index,
                    '--key', os.path.join(get_bundle_dir(), 'testkey_rsa4096.pem'),
                    '--algorithm', algorithm,
                    '--hash_algorithm', hash_algorithm,
                    '--prop', f'com.android.build.boot.os_version:{prop_com_android_build_boot_os_version}',
                    '--prop', f'com.android.build.boot.fingerprint:{prop_com_android_build_boot_fingerprint}',
                    '--prop', f'com.android.build.boot.security_patch:{prop_com_android_build_boot_security_patch_level}'
                ])

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in add_hash_footer function")
        print(e)
        traceback.print_exc()


# ============================================================================
#                               Function run_tool
# ============================================================================
def run_tool(tool_details):
    try:
        config = get_config()
        command = tool_details['command']
        arguments = tool_details['arguments']
        directory = tool_details['directory']
        method = tool_details.get('method', 'Method 3')
        if method == 'Method 1':
            shell_method = 'run_shell'
        elif method == 'Method 2':
            shell_method = 'run_shell2'
        elif method == 'Method 3':
            shell_method = 'run_shell3'
        elif method == 'Method 4':
            # this one is not a function
            shell_method = 'run_shell4'
        detached = tool_details.get('detached', True)

        theCmd = f"\"{command}\" {arguments}"
        if sys.platform.startswith("win"):
            debug(theCmd)
            if shell_method == 'run_shell4':
                subprocess.Popen(theCmd, creationflags=subprocess.CREATE_NEW_CONSOLE, start_new_session=detached, env=get_env_variables())
            else:
                # Dynamic function invocation
                res = globals()[shell_method](theCmd, directory=directory, detached=detached, creationflags=subprocess.CREATE_NEW_CONSOLE)
        elif sys.platform.startswith("linux") and config.linux_shell:
            theCmd = f"{get_linux_shell()} -- /bin/bash -c {theCmd}"
            debug(theCmd)
            if shell_method == 'run_shell4':
                subprocess.Popen(theCmd, start_new_session=detached)
            else:
                # Dynamic function invocation
                res = globals()[shell_method](theCmd, detached=detached)
        elif sys.platform.startswith("darwin"):
            script_file = tempfile.NamedTemporaryFile(delete=False, suffix='.sh')
            script_file_content = f'#!/bin/bash\n{theCmd}\nrm "{script_file.name}"'
            debug(script_file_content)
            script_file.write(script_file_content.encode('utf-8'))
            script_file.close()
            os.chmod(script_file.name, 0o755)
            theCmd = f"osascript -e 'tell application \"Terminal\" to do script \"{script_file.name}\"'"
            debug(theCmd)
            if shell_method == 'run_shell4':
                subprocess.Popen(['osascript', '-e', f'tell application "Terminal" to do script "{script_file.name}"'], start_new_session=detached, env=get_env_variables())
            else:
                # Dynamic function invocation with additional environment variables
                res = globals()[shell_method](theCmd, detached=detached, env=get_env_variables())

        return 0
    except Exception as e:
        print(f"Failed to run tool: {e}")


# ============================================================================
#                           Function get_db_con
# ============================================================================
def get_db_con():
    try:
        con = get_db()
        if con is None:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get database connection.")
            return None
        con.execute("PRAGMA foreign_keys = ON")
        con.commit()
        return con
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in get_db_con function")
        traceback.print_exc()
        return None


# ============================================================================
#               Function find_package_ids_with_same_package_boot_hash
# ============================================================================
def find_package_ids_with_same_package_boot_hash(boot_hash):
    con = get_db_con()
    if con is None:
        return []

    sql = """
        SELECT p.id
        FROM PACKAGE p
        WHERE p.boot_hash = ?;
    """
    try:
        with con:
            data = con.execute(sql, (boot_hash,))
            package_ids = [row[0] for row in data.fetchall()]
        return package_ids
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while fetching package IDs.")
        puml("#red:Encountered an error while fetching package IDs;\n", True)
        traceback.print_exc()
        return []


# ============================================================================
#               Function get_package_sig
# ============================================================================
def get_package_sig(package_id):
    con = get_db_con()
    if con is None:
        return None

    sql = """
        SELECT p.package_sig
        FROM PACKAGE p
        WHERE p.id = ?;
    """
    try:
        with con:
            data = con.execute(sql, (package_id,))
            row = data.fetchone()
            if row:
                return row[0]
            else:
                return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while fetching package_sig.")
        puml("#red:Encountered an error while fetching package_sig;\n", True)
        traceback.print_exc()
        return None


# ============================================================================
#               Function get_boot_id_by_file_path
# ============================================================================
def get_boot_id_by_file_path(file_path):
    con = get_db_con()
    if con is None:
        return None

    sql = """
        SELECT b.id
        FROM boot b
        WHERE b.file_path = ?;
    """
    try:
        with con:
            data = con.execute(sql, (file_path,))
            row = data.fetchone()
            if row:
                return row[0]
            else:
                return None
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function get_boot_id_by_file_path.")
        puml("#red:Encountered an error in function get_boot_id_by_file_path;\n", True)
        traceback.print_exc()
        return None


# ============================================================================
#               Function delete_package_boot_record
# ============================================================================
def delete_package_boot_record(boot_id, package_id):
    con = get_db_con()
    if con is None or boot_id is None or package_id is None or boot_id == 0 or package_id == 0 or boot_id == '' or package_id == '':
        return False

    sql = """
        DELETE FROM PACKAGE_BOOT
        WHERE boot_id = ? AND package_id = ?;
    """
    try:
        with con:
            con.execute(sql, (boot_id, package_id))
        con.commit()
        return True
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function delete_package_boot_record.")
        puml("#red:Encountered an error in function delete_package_boot_record;\n", True)
        traceback.print_exc()
        return False


# ============================================================================
#               Function delete_boot_record
# ============================================================================
def delete_boot_record(boot_id, delete_file=''):
    con = get_db_con()
    if con is None or boot_id is None or boot_id == 0 or boot_id == '':
        return None

    sql = """
        DELETE FROM BOOT
        WHERE id = ?;
    """
    try:
        with con:
            data = con.execute(sql, (boot_id,))
        con.commit()
        print(f"Cleared db entry for BOOT: {boot_id}")
        # delete the boot file
        if delete_file != '':
            print(f"Deleting Boot file: {delete_file} ...")
            if os.path.exists(delete_file):
                os.remove(delete_file)
                boot_dir = os.path.dirname(delete_file)
                # if deleting init_boot.img and boot.img exists, delete that as well
                boot_img_path = os.path.join(boot_dir, 'boot.img')
                if os.path.exists(boot_img_path) and delete_file.endswith('init_boot.img'):
                    print(f"Deleting {boot_img_path} ...")
                    os.remove(boot_img_path)
            else:
                print(f"⚠️ Warning: Boot file: {delete_file} does not exist")
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function delete_boot_record.")
        puml("#red:Encountered an error in function delete_boot_record;\n", True)
        traceback.print_exc()
        return None


# ============================================================================
#               Function delete_last_boot_record
# ============================================================================
def delete_last_boot_record(boot_id, boot_path=''):
    con = get_db_con()
    if con is None or boot_id is None or boot_id == 0 or boot_id == '':
        return False

    # Check to see if this is the last entry for the boot_id, if it is delete it,
    try:
        cursor = con.cursor()
        cursor.execute("SELECT * FROM PACKAGE_BOOT WHERE boot_id = ?", (boot_id,))
        data = cursor.fetchall()
        if len(data) == 0:
            # delete the boot from db
            delete_boot_record(boot_id, boot_path)
        return True
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function delete_last_boot_record.")
        puml("#red:Encountered an error in function delete_last_boot_record;\n", True)
        traceback.print_exc()
        print("Aborting ...")
        return False

# ============================================================================
#               Function delete_last_package_record
# ============================================================================
# Check to see if this is the last entry for the package_id, if it is,
# delete the package from db and output a message that a firmware should be selected.
# Also delete unpacked files from factory_images cache
def delete_last_package_record(package_ids, boot_dir):
    con = get_db_con()
    if con is None:
        return False

    try:
        cursor = con.cursor()
        package_ids_tuple = tuple(package_ids)
        placeholders = []
        for unused in package_ids_tuple:
            placeholders.append('?')
        placeholders = ','.join(placeholders)
        query = f"SELECT * FROM PACKAGE_BOOT WHERE package_id IN ({placeholders})"
        cursor.execute(query, package_ids_tuple)
        data = cursor.fetchall()
        if len(data) == 0:
            delete_package = True
            # see if there are any other files in the directory
            files = get_filenames_in_dir(boot_dir)
            if files:
                delete_package = False

            if delete_package:
                config_path = get_config_path()
                for package_id in package_ids:
                    package_sig = get_package_sig(package_id)
                    sql = """
                        DELETE FROM PACKAGE
                        WHERE id = ?;
                    """
                    with con:
                        con.execute(sql, (package_id,))
                    con.commit()
                    if package_sig:
                        print(f"Cleared db entry for PACKAGE: {package_sig}")
                        package_path = os.path.join(config_path, 'factory_images', package_sig)
                        with contextlib.suppress(Exception):
                            print(f"Deleting Firmware cache for: {package_path} ...")
                            delete_all(package_path)
                    else:
                        print(f"⚠️ Warning: Package Signature for package_id: {package_id} does not exist")
        return True
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function delete_last_package_record.")
        puml("#red:Encountered an error in function delete_last_package_record;\n", True)
        traceback.print_exc()
        print("Aborting ...")
        return False


# ============================================================================
#               Function insert_boot_record
# ============================================================================
def insert_boot_record(boot_hash, file_path, is_patched, magisk_version, hardware, patch_method, is_odin, is_stock_boot, is_init_boot, patch_source_sha1):
    con = get_db_con()
    if con is None:
        return None

    try:
        cursor = con.cursor()
        sql = """
            INSERT INTO BOOT (boot_hash, file_path, is_patched, magisk_version, hardware, epoch, patch_method, is_odin, is_stock_boot, is_init_boot, patch_source_sha1)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT (boot_hash) DO NOTHING
        """
        data = (boot_hash, file_path, is_patched, magisk_version, hardware, time.time(), patch_method, is_odin, is_stock_boot, is_init_boot, patch_source_sha1)
        debug(f"Creating BOOT record, boot_hash: {boot_hash}")
        try:
            cursor.execute(sql, data)
            con.commit()
            boot_id = cursor.lastrowid
            debug(f"DB BOOT record ID: {boot_id}")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while inserting BOOT record.")
            puml("#red:Encountered an error while inserting BOOT record;\n", True)
            traceback.print_exc()
            boot_id = 0
        return boot_id
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function insert_boot_record.")
        puml("#red:Encountered an error in function insert_boot_record;\n", True)
        traceback.print_exc()
        return 0


# ============================================================================
#               Function insert_package_boot_record
# ============================================================================
def insert_package_boot_record(package_id, boot_id):
    con = get_db_con()
    if con is None:
        return None

    try:
        cursor = con.cursor()

        sql = """
            INSERT INTO PACKAGE_BOOT (package_id, boot_id, epoch)
            VALUES (?, ?, ?)
            ON CONFLICT (package_id, boot_id) DO NOTHING
        """
        data = (package_id, boot_id, time.time())
        try:
            cursor.execute(sql, data)
            con.commit()
            package_boot_id = cursor.lastrowid
            debug(f"DB Package_Boot record ID: {package_boot_id}\n")
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while inserting PACKAGE_BOOT record.")
            puml("#red:Encountered an error while inserting PACKAGE_BOOT record;\n", True)
            traceback.print_exc()
            package_boot_id = 0
        return package_boot_id
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error in function insert_package_boot_record.")
        puml("#red:Encountered an error in function insert_package_boot_record;\n", True)
        traceback.print_exc()
        return 0


# ============================================================================
#                               Function magisk_apks
# ============================================================================
def get_rooting_app_apks():
    global _rooting_app_apks
    if _rooting_app_apks is None:
        try:
            apks = []
            mlist = [
                'Magisk Stable',
                'Magisk Beta',
                'Magisk Debug',
                'Magisk Release',
                'Magisk Pre-Release',
                'KitsuneMagisk Fork',
                "KernelSU",
                'KernelSU-Next',
                'APatch',
                "SukiSU",
                "Wild_KSU",
                "Magisk zygote64_32 canary",
                "Magisk special 30600",
                "Magisk special 27001",
                "Magisk special 26401",
                'Magisk special 25203'
            ]
            for i in mlist:
                wx.Yield()
                apk = get_rooting_app_details(i)
                if apk:
                    apks.append(apk)
            _rooting_app_apks = apks
        except Exception as e:
            _rooting_app_apks is None
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Rooting App downloads link: {i} processing")
            traceback.print_exc()
    return _rooting_app_apks


# ============================================================================
#                               Function get_rooting_app_details
# ============================================================================
def get_rooting_app_details(channel):
    ma = MagiskApk(channel)
    if channel == 'Magisk Stable':
        url = "https://raw.githubusercontent.com/topjohnwu/magisk-files/master/stable.json"

    elif channel == 'Magisk Beta':
        url = "https://raw.githubusercontent.com/topjohnwu/magisk-files/master/beta.json"

    elif channel == 'Magisk Canary':
        url = "https://raw.githubusercontent.com/topjohnwu/magisk-files/master/canary.json"

    elif channel == 'Magisk Debug':
        url = "https://raw.githubusercontent.com/topjohnwu/magisk-files/master/debug.json"

    elif channel == 'Magisk Alpha':
        try:
            # Now published at appcenter: https://install.appcenter.ms/users/vvb2060/apps/magisk/distribution_groups/public
            info_endpoint = "https://install.appcenter.ms/api/v0.1/apps/vvb2060/magisk/distribution_groups/public/public_releases?scope=tester"
            release_endpoint = "https://install.appcenter.ms/api/v0.1/apps/vvb2060/magisk/distribution_groups/public/releases/{}"
            res = request_with_fallback(method='GET', url=info_endpoint)
            latest_id = res.json()[0]['id']
            res = request_with_fallback(method='GET', url=release_endpoint.format(latest_id))
            latest_release = res.json()
            setattr(ma, 'version', latest_release['short_version'])
            setattr(ma, 'versionCode', latest_release['version'])
            setattr(ma, 'link', latest_release['download_url'])
            setattr(ma, 'note_link', "note_link")
            setattr(ma, 'package', latest_release['bundle_identifier'])
            setattr(ma, 'release_notes', latest_release['release_notes'])
            return ma
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Alpha processing")
            traceback.print_exc()
            return
    elif channel == 'KitsuneMagisk Fork':
        url = "https://1q23lyc45.github.io/canary.json"

    elif channel == 'Magisk Delta Canary':
        url = "https://raw.githubusercontent.com/HuskyDG/magisk-files/main/canary.json"

    elif channel == 'Magisk Delta Debug':
        url = "https://raw.githubusercontent.com/HuskyDG/magisk-files/main/debug.json"

    elif channel == 'Magisk Release':
        try:
            # https://github.com/topjohnwu/Magisk/releases
            release = get_gh_release_object(user='topjohnwu', repo='Magisk', include_prerelease=False, latest_any=False)
            if release:
                release_version = release['tag_name']
                release_notes = release['body']
                release_url = gh_asset_utility(release_object=release, asset_name_pattern=r'^Magisk.*\.apk$', download=False)
                if release_notes is None:
                    release_version = "No release notes available"
                if release_url is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find Magisk Release APK")
                    return
                match = re.search(r'_([0-9]+)-', release_url)
                if match:
                    release_versionCode =  match.group(1)
                else:
                    if release_version:
                        release_versionCode = f"{release_version.replace('v', '').replace('.', '')}00"
                    else:
                        release_versionCode = 0
                setattr(ma, 'version', release_version)
                setattr(ma, 'versionCode', release_versionCode)
                setattr(ma, 'link', release_url)
                setattr(ma, 'note_link', "note_link")
                setattr(ma, 'package', MAGISK_PKG_NAME)
                setattr(ma, 'release_notes', release_notes)
                return ma
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {channel} on GitHub")
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Magisk Release processing")
            traceback.print_exc()
            return

    elif channel == 'Magisk Pre-Release':
        try:
            # https://github.com/topjohnwu/Magisk/releases
            release = get_gh_release_object(user='topjohnwu', repo='Magisk', include_prerelease=True, latest_any=True)
            if release:
                release_version = release['tag_name']
                release_notes = release['body']
                release_url = gh_asset_utility(release_object=release, asset_name_pattern=r'^Magisk.*\.apk$', download=False)
                if release_notes is None:
                    release_version = "No release notes available"
                if release_url is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find Magisk Release APK")
                    return
                match = re.search(r'_([0-9]+)-', release_url)
                if match:
                    release_versionCode =  match.group(1)
                else:
                    if release_version:
                        release_versionCode = release_versionCode = f"{release_version.replace('v', '').replace('.', '')}00"
                    else:
                        release_versionCode = 0
                setattr(ma, 'version', release_version)
                setattr(ma, 'versionCode', release_versionCode)
                setattr(ma, 'link', release_url)
                setattr(ma, 'note_link', "note_link")
                setattr(ma, 'package', MAGISK_PKG_NAME)
                setattr(ma, 'release_notes', release_notes)
                return ma
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {channel} on GitHub")
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Magisk Release processing")
            traceback.print_exc()
            return

    elif channel == 'KernelSU':
        try:
            # https://github.com/tiann/KernelSU/releases
            release = get_gh_release_object(user='tiann', repo='KernelSU', include_prerelease=False, latest_any=False)
            if release:
                release_version = release['tag_name']
                release_notes = release['body']
                release_url = gh_asset_utility(release_object=release, asset_name_pattern=r'^KernelSU.*\.apk$', download=False)
                if release_notes is None:
                    release_version = "No release notes available"
                if release_url is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find KernelSU APK")
                    return
                match = re.search(r'_([0-9]+)-', release_url)
                if match:
                    release_versionCode =  match.group(1)
                else:
                    if release_version:
                        release_versionCode = release_version
                    else:
                        release_versionCode = 0
                setattr(ma, 'version', release_version)
                setattr(ma, 'versionCode', release_versionCode)
                setattr(ma, 'link', release_url)
                setattr(ma, 'note_link', "note_link")
                setattr(ma, 'package', KERNEL_SU_PKG_NAME)
                setattr(ma, 'release_notes', release_notes)
                return ma
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {channel} on GitHub")
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during KernelSU processing")
            traceback.print_exc()
            return

    elif channel == 'KernelSU-Next':
        try:
            # https://github.com/rifsxd/KernelSU-Next/releases
            release = get_gh_release_object(user='rifsxd', repo='KernelSU-Next', include_prerelease=False, latest_any=False)
            if release:
                release_version = release['tag_name']
                release_notes = release['body']
                release_url = gh_asset_utility(release_object=release, asset_name_pattern=r'^KernelSU_Next(?!.*spoofed).*\.apk$', download=False)
                if release_notes is None:
                    release_version = "No release notes available"
                if release_url is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find KernelSU-Next APK")
                    return
                match = re.search(r'_([0-9]+)-', release_url)
                if match:
                    release_versionCode =  match.group(1)
                else:
                    if release_version:
                        release_versionCode = release_version
                    else:
                        release_versionCode = 0
                setattr(ma, 'version', release_version)
                setattr(ma, 'versionCode', release_versionCode)
                setattr(ma, 'link', release_url)
                setattr(ma, 'note_link', "note_link")
                setattr(ma, 'package', KSU_NEXT_PKG_NAME)
                setattr(ma, 'release_notes', release_notes)
                return ma
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {channel} on GitHub")
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during KernelSU-Next processing")
            traceback.print_exc()
            return

    elif channel == 'SukiSU':
        try:
            # https://github.com/SukiSU-Ultra/SukiSU-Ultra/releases
            release = get_gh_release_object(user='SukiSU-Ultra', repo='SukiSU-Ultra', include_prerelease=False, latest_any=False)
            if release:
                release_version = release['tag_name']
                release_notes = release['body']
                release_url = gh_asset_utility(release_object=release, asset_name_pattern=r'^SukiSU.*\.apk$', download=False)
                if release_notes is None:
                    release_version = "No release notes available"
                if release_url is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find SukiSU APK")
                    return
                match = re.search(r'_([0-9]+)-', release_url)
                if match:
                    release_versionCode =  match.group(1)
                else:
                    if release_version:
                        release_versionCode = release_version
                    else:
                        release_versionCode = 0
                setattr(ma, 'version', release_version)
                setattr(ma, 'versionCode', release_versionCode)
                setattr(ma, 'link', release_url)
                setattr(ma, 'note_link', "note_link")
                setattr(ma, 'package', SUKISU_PKG_NAME)
                setattr(ma, 'release_notes', release_notes)
                return ma
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {channel} on GitHub")
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during SukiSU processing")
            traceback.print_exc()
            return

    elif channel == 'Wild_KSU':
        try:
            # https://github.com/WildKernels/Wild_KSU/releases
            release = get_gh_release_object(user='WildKernels', repo='Wild_KSU', include_prerelease=False, latest_any=False)
            if release:
                release_version = release['tag_name']
                release_notes = release['body']
                release_url = gh_asset_utility(release_object=release, asset_name_pattern=r'^Wild_KSU(?!.*spoofed).*\.apk$', download=False)
                if release_notes is None:
                    release_version = "No release notes available"
                if release_url is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find Wild_KSU APK")
                    return
                match = re.search(r'_([0-9]+)-', release_url)
                if match:
                    release_versionCode =  match.group(1)
                else:
                    if release_version:
                        release_versionCode = release_version
                    else:
                        release_versionCode = 0
                setattr(ma, 'version', release_version)
                setattr(ma, 'versionCode', release_versionCode)
                setattr(ma, 'link', release_url)
                setattr(ma, 'note_link', "note_link")
                setattr(ma, 'package', WILD_KSU_PKG_NAME)
                setattr(ma, 'release_notes', release_notes)
                return ma
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {channel} on GitHub")
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Wild_KSU processing")
            traceback.print_exc()
            return

    elif channel == 'APatch':
        try:
            # https://github.com/bmax121/APatch/releases
            release = get_gh_release_object(user='bmax121', repo='APatch', include_prerelease=False, latest_any=False)
            if release:
                release_version = release['tag_name']
                release_notes = release['body']
                release_url = gh_asset_utility(release_object=release, asset_name_pattern=r'^APatch_.*\.apk$', download=False)
                if release_notes is None:
                    release_version = "No release notes available"
                if release_url is None:
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find APatch APK")
                    return
                match = re.search(r'_([0-9]+)-', release_url)
                if match:
                    release_versionCode =  match.group(1)
                else:
                    if release_version:
                        release_versionCode = release_version
                    else:
                        release_versionCode = 0
                setattr(ma, 'version', release_version)
                setattr(ma, 'versionCode', release_versionCode)
                setattr(ma, 'link', release_url)
                setattr(ma, 'note_link', "note_link")
                setattr(ma, 'package', APATCH_PKG_NAME)
                setattr(ma, 'release_notes', release_notes)
                return ma
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find {channel} on GitHub")
                return
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during APatch processing")
            traceback.print_exc()
            return

    elif channel == 'Magisk zygote64_32 stable':
        url = "https://raw.githubusercontent.com/Namelesswonder/magisk-files/main/stable.json"

    elif channel == 'Magisk zygote64_32 beta':
        url = "https://raw.githubusercontent.com/Namelesswonder/magisk-files/main/beta.json"

    elif channel == 'Magisk zygote64_32 canary':
        # url = "https://raw.githubusercontent.com/Namelesswonder/magisk-files/main/canary.json"
        url = "https://raw.githubusercontent.com/ActiveIce/Magisk_zygote64_32/master/canary.json"

    elif channel == 'Magisk zygote64_32 debug':
        url = "https://raw.githubusercontent.com/Namelesswonder/magisk-files/main/debug.json"

    elif channel == 'Magisk special 25203':
        url = ""
        setattr(ma, 'version', "f9e82c9e")
        setattr(ma, 'versionCode', "25203")
        setattr(ma, 'link', "https://github.com/badabing2005/Magisk/releases/download/versionCode_25203/app-release.apk")
        setattr(ma, 'note_link', "note_link")
        setattr(ma, 'package', MAGISK_PKG_NAME)
        release_notes = """
## 2022.10.03 Special Magisk v25.2 Build\n\n
This is a special Magisk build by XDA Member [gecowa6967](https://xdaforums.com/m/gecowa6967.11238881/)\n\n
- Based on build versionCode: 25203 versionName: f9e82c9e\n
- Modified to disable loading modules.\n
- Made to recover from bootloops due to bad / incompatible Modules.\n\n
### Steps to follow
If your are bootlooping due to bad modules, and if you load stock boot image, it works fine but you're not rooted to removed modules, then follow these steps.\n\n
- Uninstall the currently installed Magisk Manager.\n
- Install this special version.\n
- Create a patched boot / init_boot using this Magisk Manager version.\n
- Flash the patched image.\n
- You should now be able to get root access, and your modules will not load.\n
- Delete / Disable suspect modules.\n
- Uninstall this Magisk Manager.\n
- Install your Magisk Manager of choice.\n
- Create patched boot / init_boot image.\n
- Flash the patched image.\n
- You should be good to go.\n\n
### Full Details: [here](https://xdaforums.com/t/magisk-general-support-discussion.3432382/page-2667#post-87520397)\n
        """
        setattr(ma, 'release_notes', release_notes)
        return ma

    elif channel == 'Magisk special 26401':
        url = ""
        setattr(ma, 'version', "76aef836")
        setattr(ma, 'versionCode', "26401")
        setattr(ma, 'link', "https://github.com/badabing2005/Magisk/releases/download/versionCode_26401/app-release.apk")
        setattr(ma, 'note_link', "note_link")
        setattr(ma, 'package', MAGISK_PKG_NAME)
        release_notes = """
## 2023.11.12 Special Magisk v26.4 Build\n\n
This is a special Magisk build\n\n
- Based on build versionCode: 26401 versionName: 76aef836\n
- Modified to disable loading modules while keep root.\n
- Made to recover from bootloops due to bad / incompatible Modules.\n\n
### Steps to follow [here](https://github.com/badabing2005/Magisk)\n
        """
        setattr(ma, 'release_notes', release_notes)
        return ma
    elif channel == 'Magisk special 27001':
        url = ""
        setattr(ma, 'version', "79fd3e40")
        setattr(ma, 'versionCode', "27001")
        setattr(ma, 'link', "https://github.com/badabing2005/Magisk/releases/download/versionCode_27001/app-release.apk")
        setattr(ma, 'note_link', "note_link")
        setattr(ma, 'package', MAGISK_PKG_NAME)
        release_notes = """
## 2024.02.12 Special Magisk v27.0 Build\n\n
This is a special Magisk build\n\n
- Based on build versionCode: 27001 versionName: 79fd3e40\n
- Modified to disable loading modules while keep root.\n
- Made to recover from bootloops due to bad / incompatible Modules.\n\n
### Steps to follow [here](https://github.com/badabing2005/Magisk)\n
        """
        setattr(ma, 'release_notes', release_notes)
        return ma
    elif channel == 'Magisk special 30600':
        url = ""
        setattr(ma, 'version', "0d63870f")
        setattr(ma, 'versionCode', "30600")
        setattr(ma, 'link', "https://github.com/badabing2005/Magisk/releases/download/versionCode_30600/app-release.apk")
        setattr(ma, 'note_link', "note_link")
        setattr(ma, 'package', MAGISK_PKG_NAME)
        release_notes = """
## 2025.12.05 Special Magisk v30.6 Build\n\n
This is a special Magisk build\n\n
- Based on build versionCode: 30600 versionName: 0d63870f\n
- Modified to disable loading modules while keep root.\n
- Made to recover from bootloops due to bad / incompatible Modules.\n\n
### Steps to follow [here](https://github.com/badabing2005/Magisk)\n
        """
        setattr(ma, 'release_notes', release_notes)
        return ma

    else:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Unknown Magisk channel {channel}\n")
        return

    try:
        payload={}
        headers = {
            'Content-Type': "application/json"
        }
        response = request_with_fallback(method='GET', url=url, headers=headers, data=payload)
        if response.status_code != 200:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get Magisk downloads links: {url}")
            return
        data = response.json()
        setattr(ma, 'version', data['magisk']['version'])
        setattr(ma, 'versionCode', data['magisk']['versionCode'])
        setattr(ma, 'link', data['magisk']['link'])
        note_link = data['magisk']['note']
        setattr(ma, 'note_link', note_link)
        setattr(ma, 'package', MAGISK_PKG_NAME)
        if channel in ['Magisk Delta Canary', 'Magisk Delta Debug', 'KitsuneMagisk Fork']:
            setattr(ma, 'package', MAGISK_DELTA_PKG_NAME)
        # Get the note contents
        headers = {}
        with contextlib.suppress(Exception):
            setattr(ma, 'release_notes', '')
            response = request_with_fallback(method='GET', url=ma.note_link, headers=headers, data=payload)
            if response.status_code != 200:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not get Magisk download release_notes: {url}")
                return
            setattr(ma, 'release_notes', response.text)
        return ma
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Exception during Magisk downloads links: {url} processing")
        traceback.print_exc()
        return


# ============================================================================
#                    Function parse_bootloader_version
# ============================================================================
def parse_bootloader_version(version):
    # Parse version string in format "Major.minor-patch"
    if not version:
        return None
    try:
        major_minor, patch = version.split('-', 1)
        major, minor = major_minor.split('.', 1)
        return (int(major), int(minor), int(patch))
    except (ValueError, AttributeError):
        print(f"⚠️ Warning: Unable to parse bootloader version: {version}")
        return None


# ============================================================================
#                    Function is_bootloader_version_older
# ============================================================================
def is_bootloader_version_older(version, min_version):
    v1 = parse_bootloader_version(version)
    v2 = parse_bootloader_version(min_version)
    if not v1 or not v2:
        # Can't determine, assume it's not older
        return False

    # Compare major.minor-patch components
    return (v1[0] < v2[0] or
            (v1[0] == v2[0] and v1[1] < v2[1]) or
            (v1[0] == v2[0] and v1[1] == v2[1] and v1[2] < v2[2]))


# ============================================================================
#                    Function get_bootloader_versions
# ============================================================================
def get_bootloader_versions():
    try:
        device = get_phone()
        if not device:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: You must first select a valid device.")
            return

        if not device.rooted:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device is not rooted.")
            puml("#red:Device is not rooted;\n}\n")
            return

        res = device.get_partitions()
        if res == -1:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Failed to get partitions from the device, aborting ...")
            puml("#red:Failed to get partitions from the device;\n}\n")
            return


        if 'abl_a' not in res or 'abl_b' not in res:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Device does not have abl_a and/or abl_b partitions, aborting ...")
            puml("#red:Device does not have abl_a and abl_b partitions;\n}\n")
            return

        # first delete existing abl_a and abl_b dumps if it exists on the phone
        path = "/data/local/tmp/abl_a.img"
        res = device.delete(path, True)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to delete old abl_a image from the phone;\n}\n")
            return
        path = "/data/local/tmp/abl_b.img"
        res = device.delete(path, True)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to delete old abl_b image from the phone;\n}\n")
            return

        # dump abl_a and abl_b to the phone
        res, file_path = device.dump_partition(partition='abl', slot='a')
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to dump abl_a partition to the phone;\n}\n")
            return
        res, file_path = device.dump_partition(partition='abl', slot='b')
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to dump abl_a partition to the phone;\n}\n")
            return

        # pull abl_a and abl_b from the phone
        temp_dir = tempfile.mkdtemp(dir=tempfile.gettempdir())
        path = "/data/local/tmp/abl_a.img"
        res = device.pull_file(path, os.path.join(temp_dir, "abl_a.img"), False)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to pull abl_a image from the phone;\n}\n")
            res = device.delete(path, True)
            return
        res = device.delete(path, True)
        path = "/data/local/tmp/abl_b.img"
        res = device.pull_file(path, os.path.join(temp_dir, "abl_b.img"), False)
        if res != 0:
            print("Aborting ...\n")
            puml("#red:Failed to pull abl_b image from the phone;\n}\n")
            res = device.delete(path, True)
            return
        res = device.delete(path, True)

        # Open the bootloader versions from the dumped images
        with open(os.path.join(temp_dir, "abl_a.img"), 'rb') as f:
            abl_a_data = f.read()
        with open(os.path.join(temp_dir, "abl_b.img"), 'rb') as f:
            abl_b_data = f.read()

        # Get the device codename(s)
        android_device = get_android_devices()
        device_codenames = None
        if android_device:
            device_codenames = f"{android_device[device.hardware]['bootloader_codename']}-"

        # Convert single string codename to a list with one element if it's not already a list
        if device_codenames is not None and not isinstance(device_codenames, list):
            device_codenames = [device_codenames]

        if device_codenames is None:
            device_codenames = [
                b"cloudripper-", b"slider-", b"bluejay-", b"ripcurrent-",
                b"akita-", b"ripcurrentpro-"
            ]
        else:
            # Convert string codenames to bytes for compatibility with binary data search
            device_codenames = [codename.encode('utf-8') if isinstance(codename, str) else codename for codename in device_codenames]

        # Process abl_a
        abl_a_version = None
        for codename in device_codenames:
            pos = abl_a_data.find(codename)
            if pos != -1:
                prefix_len = len(codename)
                pos += prefix_len
                end_pos = abl_a_data.find(b'\x00', pos)
                if end_pos != -1:
                    abl_a_version = abl_a_data[pos:end_pos].decode('utf-8').strip('\x00')
                    debug(f"Found bootloader version in abl_a.img with prefix {codename.decode()}")
                    break
        if abl_a_version is None:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find bootloader version in abl_a.img")
            puml("#red:Could not find bootloader version in abl_a.img;\n}\n")
            return

        # Process abl_b
        abl_b_version = None
        for codename in device_codenames:
            pos = abl_b_data.find(codename)
            if pos != -1:
                prefix_len = len(codename)
                pos += prefix_len
                end_pos = abl_b_data.find(b'\x00', pos)
                if end_pos != -1:
                    abl_b_version = abl_b_data[pos:end_pos].decode('utf-8').strip('\x00')
                    debug(f"Found bootloader version in abl_b.img with prefix {codename.decode()}")
                    break
        if abl_b_version is None:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not find bootloader version in abl_b.img")
            puml("#red:Could not find bootloader version in abl_b.img;\n}\n")
            return

        # Define the minimum safe versions for different ARB effected devices
        min_versions = {
            "bluejay": "15.3-13239612",
            "oriole": "15.3-13239612",
            "raven": "15.3-13239612",
            "akita": "15.3-13266201",
            "shiba": "15.3-13272266",
            "husky": "15.3-13272266"
        }

        print("\n=================================================")
        print(f"Slot A Bootloader Version: {abl_a_version}")
        print(f"Slot B Bootloader Version: {abl_b_version}")

        # see if any of the devices are at risk of bricking due to Anti-Rollback Protection `ARB`
        if device.hardware in min_versions:
            min_safe_version = min_versions[device.hardware]

            # Check slot A
            if is_bootloader_version_older(abl_a_version, min_safe_version):
                print(f"\n☠️ WARNING: Slot A bootloader version {abl_a_version} is older than the minimum safe version {min_safe_version}")
                print(f"☠️ Your device may be at risk of bricking due to Anti-Rollback Protection (ARB)")
                puml(f"note right #yellow\nWARNING: Slot A bootloader version {abl_a_version} is older than\nthe minimum safe version {min_safe_version}\nYour device may be at risk of bricking due to ARB\nend note\n")
            else:
                print(f"✅ Slot A bootloader version {abl_a_version} is safe because it is newer than the minimum safe version {min_safe_version}")

            # Check slot B
            if is_bootloader_version_older(abl_b_version, min_safe_version):
                print(f"\n☠️ WARNING: Slot B bootloader version {abl_b_version} is older than the minimum safe version {min_safe_version}")
                print(f"☠️ Your device may be at risk of bricking due to Anti-Rollback Protection (ARB)")
                puml(f"note right #yellow\nWARNING: Slot B bootloader version {abl_b_version} is older than\nthe minimum safe version {min_safe_version}\nYour device may be at risk of bricking due to ARB\nend note\n")
            else:
                print(f"✅ Slot B bootloader version {abl_b_version} is safe because it is newer than the minimum safe version {min_safe_version}")
        else:
            print(f"\nℹ️ Info: Device hardware {device.hardware} is not currently in PixelFlasher's Anti-Rollback Protection (ARB) checks")
            print("Please report this to the author if you think it should be included.")

        print("=================================================\n")
        puml(f"note right\nABL_A Version: {abl_a_version}\nABL_B Version: {abl_b_version}\nend note\n")

    except IOError:
        traceback.print_exc()
    finally:
        try:
            shutil.rmtree(temp_dir)
        except Exception as e:
            debug(f"❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: cleaning up temp directory: {str(e)}")


# ============================================================================
#                               Function extract_strings
# ============================================================================
def extract_strings(filename):
    with open(filename, "rb") as f:
        data = f.read()
    return re.findall(rb'[\x20-\x7E]{4,}', data)


# ============================================================================
#                               Function extract_kernel_info
# ============================================================================
def extract_kernel_info(boot_img_path):
    strings = [s.decode(errors="ignore") for s in extract_strings(boot_img_path)]
    version_regex = re.compile(r'^\d+\.\d+\.\d+[-\w]+')
    date_regex = re.compile(r'(?:#\d+ )?SMP PREEMPT .+\d{4}')

    # Step 1: Get the prefix portion, don't look into multiline strings
    prefix = None
    for i, line in enumerate(strings):
        if version_regex.match(line):
            prefix = line
            break

    # Step 2: Get the longest candidate by searching all lines
    version_regex2 = re.compile(r'\d+\.\d+\.\d+[-\w]+')
    version_candidates = []
    date_candidates = []

    for line in strings:
        vmatch = version_regex2.search(line)
        if vmatch:
            version_candidates.append(vmatch.group(0))
        dmatch = date_regex.search(line)
        if dmatch:
            date_candidates.append(dmatch.group(0))

    build_number = max(version_candidates, key=len) if version_candidates else None
    build_date = max(date_candidates, key=len) if date_candidates else None

    # Step 3: Filter out anything before the prefix in the longest candidate
    if prefix and build_number and prefix in build_number:
        idx = build_number.index(prefix)
        build_number = build_number[idx:]

    return build_number, build_date


# ============================================================================
#                               Function run_shell
# ============================================================================
# We use this when we want to capture the returncode and also selectively
# output what we want to console. Nothing is sent to console, both stdout and
# stderr are only available when the call is completed.
def run_shell(cmd, timeout=None, encoding='ISO-8859-1'):
    try:
        flush_output()
        process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=encoding, errors="replace", env=get_env_variables())
        # Wait for the process to complete or timeout
        stdout, stderr = process.communicate(timeout=timeout)
        # Return the response
        return subprocess.CompletedProcess(args=cmd, returncode=process.returncode, stdout=stdout, stderr=stderr)

    except subprocess.TimeoutExpired as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Command {cmd} timed out after {timeout} seconds")
        puml("#red:Command {cmd} timed out;\n", True)
        puml(f"note right\n{e}\nend note\n")
        # Send CTRL + C signal to the process
        process.send_signal(signal.SIGTERM)
        process.terminate()
        return subprocess.CompletedProcess(args=cmd, returncode=-1, stdout='', stderr='')

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while executing run_shell {cmd}")
        traceback.print_exc()
        puml("#red:Encountered an error;\n", True)
        puml(f"note right\n{e}\nend note\n")
        raise e
        # return subprocess.CompletedProcess(args=cmd, returncode=-2, stdout='', stderr='')


# ============================================================================
#                               Function run_shell2
# ============================================================================
# This one pipes the stdout and stderr to Console text widget in realtime,
def run_shell2(cmd, timeout=None, detached=False, directory=None, encoding='utf-8', chcp=None):
    try:
        flush_output()

        env = get_env_variables()
        env["PYTHONIOENCODING"] = encoding
        if chcp is not None:
            env["CHCP"] = chcp

        if directory is None:
            proc = subprocess.Popen(
                f"{cmd}",
                shell=True,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                encoding=encoding,
                errors="replace",
                start_new_session=detached,
                env=env
            )
        else:
            proc = subprocess.Popen(
                f"{cmd}",
                cwd=directory,
                shell=True,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                encoding=encoding,
                errors="replace",
                start_new_session=detached,
                env=env
            )

        print
        while True:
            line = proc.stdout.readline()
            wx.YieldIfNeeded()
            if line.strip() != "":
                print(line.strip())
            if not line:
                break
            if timeout is not None and time.time() > timeout:
                proc.terminate()
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Command {cmd} timed out after {timeout} seconds")
                puml("#red:Command timed out;\n", True)
                puml(f"note right\nCommand {cmd} timed out after {timeout} seconds\nend note\n")
                return subprocess.CompletedProcess(args=cmd, returncode=-1, stdout='', stderr='')
        proc.wait()
        # Wait for the process to complete and capture the output
        stdout, stderr = proc.communicate()
        return subprocess.CompletedProcess(args=cmd, returncode=proc.returncode, stdout=stdout, stderr=stderr)
    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while executing run_shell2 {cmd}")
        traceback.print_exc()
        puml("#red:Encountered an error;\n", True)
        puml(f"note right\n{e}\nend note\n")
        raise e
        # return subprocess.CompletedProcess(args=cmd, returncode=-2, stdout='', stderr='')


# ============================================================================
#                               Function run_shell3
# ============================================================================
# This one pipes the stdout and stderr to Console text widget in realtime,
def run_shell3(cmd, timeout=None, detached=False, directory=None, encoding='ISO-8859-1', creationflags=0, env=None):
    try:
        flush_output()
        proc_args = {
            "args": f"{cmd}",
            "shell": True,
            "stdin": subprocess.PIPE,
            "stdout": subprocess.PIPE,
            "stderr": subprocess.STDOUT,
            "encoding": encoding,
            "errors": "replace",
            "start_new_session": detached,
        }
        if env is not None:
            proc_args["env"] = env
        if creationflags is not None:
            proc_args["creationflags"] = creationflags
        if directory is not None:
            proc_args["cwd"] = directory

        proc = subprocess.Popen(**proc_args)

        def read_output():
            print
            start_time = time.time()
            output = []
            while True:
                line = proc.stdout.readline()
                wx.YieldIfNeeded()
                if line.strip() != "":
                    print(line.strip())
                    output.append(line.strip())
                if not line:
                    break
                if timeout is not None and time.time() - start_time > timeout:
                    proc.terminate()
                    print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Command {cmd} timed out after {timeout} seconds")
                    puml("#red:Command timed out;\n", True)
                    puml(f"note right\nCommand {cmd} timed out after {timeout} seconds\nend note\n")
                    return subprocess.CompletedProcess(args=cmd, returncode=-1, stdout='\n'.join(output), stderr='')

        threading.Thread(target=read_output, daemon=True).start()
        if not detached:
            proc.wait()
        return proc

    except Exception as e:
        print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while executing run_shell3 {cmd}")
        traceback.print_exc()
        puml("#red:Encountered an error;\n", True)
        puml(f"note right\n{e}\nend note\n")
        raise e
        # return subprocess.CompletedProcess(args=cmd, returncode=-2, stdout='', stderr='')


# def run_shell(*args, **kwargs):
#     pr = cProfile.Profile()
#     pr.enable()
#     result = run_shell1(*args, **kwargs)  # Call your function here
#     pr.disable()
#     s = io.StringIO()
#     ps = pstats.Stats(pr, stream=s).sort_stats('tottime')
#     ps.print_stats()

#     # Get the calling function and line number
#     stack = traceback.extract_stack()
#     filename, lineno, function_name, unused = stack[-3]  # -3 because -1 is current function, -2 is the function that called this function
#     print(f"Called from {function_name} at {filename}:{lineno}")

#     print(s.getvalue())
#     return result


```

`set_version.py`:

```py
#!/usr/bin/env python3

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

"""
A Script To easily change the version number in all involved files.
"""
import fileinput
import os
import re

cwd = os.getcwd()
file1 = os.path.join(cwd, 'build-on-mac.spec')
file2 = os.path.join(cwd, 'build.sh')
file3 = os.path.join(cwd, 'constants.py')
file4 = os.path.join(cwd, 'windows-metadata.yaml')
file5 = os.path.join(cwd, 'windows-version-info.txt')
file6 = os.path.join(cwd, 'build-on-mac-intel-only.spec')

s1 = r"\s+(version=)'(\d+\.\d+\.\d+.\d+)',"
s2 = r"(VERSION=)(\d+\.\d+\.\d+.\d+)"
s3 = r"(VERSION = )'(\d+\.\d+\.\d+.\d+)'"
s4 = r"(Version: )(\d+\.\d+\.\d+.\d+)"

s5_1 = r"(filevers=)\((\d+\,\d+\,\d+,\d+)\)"
s5_2 = r"(prodvers=)\((\d+\,\d+\,\d+,\d+)\)"
s5_3 = r"(FileVersion', )u'(\d+\.\d+\.\d+.\d+)'"
s5_4 = r"(ProductVersion', )u'(\d+\.\d+\.\d+.\d+)'"
s5 = (s5_1, s5_2, s5_3, s5_4)

alist = [(file1, s1), (file2, s2), (file3, s3), (file4, s4), (file6, s1)]

# ============================================================================
#                               Function get_values
# ============================================================================
def get_values(thelist, update):
    # for index, tuple in enumerate(thelist):
    for tuple in thelist:
        file = tuple[0]
        s = tuple[1]
        with open(file, "rt", encoding='ISO-8859-1', errors="replace") as fin:
            data = fin.read()
        r = re.findall(s, data)
        print(file)
        if r:
            print(f"\t{r[0][0]}{r[0][1]}")
            if update:
                set_values(file, r[0][1], target_version)
        else:
            print("\tNO MATCH IS FOUND.")


    print(file5)
    with open(file5, "rt", encoding='ISO-8859-1', errors="replace") as fin:
        data = fin.read()
    for item in s5:
        r = re.findall(item, data)
        if r:
            print(f"\t{r[0][0]}{r[0][1]}")
    if r and update:
        set_values(file5, r[0][1], target_version)
        source_comma_version = r[0][1].replace('.', ',')
        set_values(file5, source_comma_version, target_comma_version)


# ============================================================================
#                               Function set_values
# ============================================================================
def set_values(file, search, replace):
    try:
        with open(file, 'r', encoding='ISO-8859-1', errors="replace") as f:
            content = f.read()
            # content_new = re.sub(search, replace, content, flags = re.M)
            content_new = content.replace(search, replace)
        print(f"\t\tReplacing {search} with {replace} ...")
        with open(file, 'w', encoding="ISO-8859-1", errors="replace", newline='\n') as f:
            f.write(content_new)
    except Exception as e:
        print(f"\n❌ ERROR: {e}")
        return False


# ============================================================================
#                               MAIN
# ============================================================================
target_version = ''
print("Getting current values ...")
get_values(alist, False)
target_version = input("\nEnter the new Version: ")
target_comma_version = target_version.replace('.', ',')
print(f"\nSetting Versions to: {target_version} ...")
get_values(alist, True)
print("Getting updated values ...")
get_values(alist, False)


```

`testkey_rsa4096.pem`:

```pem
-----BEGIN RSA PRIVATE KEY-----
MIIJKQIBAAKCAgEA2ASv49OEbH4NiT3CjNMSVeliyfEPXswWcqtEfCxlSpS1FisA
uwbvEwdTTPlkuSh6G4SYiNhnpCP5p0vcSg/3OhiuVKgV/rCtrDXaO60nvK/o0y83
NNZRK2xaJ9eWBq9ruIDK+jC0sYWzTaqqwxY0Grjnx/r5CXerl5PrRK7PILzwgBHb
IwxHcblt1ntgR4cWVpO3wiqasEwBDDDYk4fw7W6LvjBb9qav3YB8RV6PkZNeRP64
ggfuecq/MXNiWOPNxLzCER2hSr/+J32h9jWjXsrcVy8+8Mldhmr4r2an7c247aFf
upuFGtUJrpROO8/LXMl5gPfMpkqoatjTMRH59gJjKhot0RpmGxZBvb33TcBK5SdJ
X39Y4yct5clmDlI4Fjj7FutTP+b96aJeJVnYeUX/A0wmogBajsJRoRX5e/RcgZsY
RzXYLQXprQ81dBWjjovMJ9p8XeT6BNMFC7o6sklFL0fHDUE/l4BNP8G1u3Bfpzev
SCISRS71D4eS4oQB+RIPFBUkzomZ7rnEF3BwFeq+xmwfYrP0LRaH+1YeRauuMuRe
ke1TZl697a3mEjkNg8noa2wtpe7EWmaujJfXDWxJx/XEkjGLCe4z2qk3tkkY+A5g
Rcgzke8gVxC+eC2DJtbKYfkv4L8FMFJaEhwAp13MfC7FlYujO/BDLl7dANsCAwEA
AQKCAgAWoL8P/WsktjuSwb5sY/vKtgzcHH1Ar942GsysuTXPDy686LpF3R8T/jNy
n7k2UBAia8xSoWCR6BbRuHeV5oA+PLGeOpE7QaSfonB+yc+cy0x3Or3ssfqEsu/q
toGHp75/8DXS6WE0K04x94u1rdC9b9sPrrGBlWCLGzqM0kbuJfyHXdd3n2SofAUO
b5QRSgxD+2tHUpEroHqHnWJCaf4J0QegX45yktlfOYNK/PHLDQXV8ly/ejc32M4Y
Tv7hUtOOJTuq8VCg9OWZm2Zo1QuM9XEJTPCp5l3+o5vzO6yhk2gotDvD32CdA+3k
tLJRP54M1Sn+IXb1gGKN9rKAtGJbenWIPlNObhQgkbwG89Qd+5rfMXsiPv1Hl1tK
+tqwjD82/H3/ElaaMnwHCpeoGSp95OblAoBjzjMP2KsbvKSdL8O/rf1c3uOw9+DF
cth0SA8y3ZzI11gJtb2QMGUrCny5n4sPGGbc3x38NdLhwbkPKZy60OiT4g2kNpdY
dIitmAML2otttiF4AJM6AraPk8YVzkPLTksoL3azPBya5lIoDI2H3QvTtSvpXkXP
yKchsDSWYbdqfplqC/X0Djp2/Zd8jpN5I6+1aSmpTmbwx/JTllY1N89FRZLIdxoh
2k81LPiXhE6uRbjioJUlbnEWIpY2y2N2Clmxpjh0/IcXd1XImQKCAQEA7Zai+yjj
8xit24aO9Tf3mZBXBjSaDodjC2KS1yCcAIXp6S7aH0wZipyZpQjys3zaBQyMRYFG
bQqIfVAa6inWyDoofbAJHMu5BVcHFBPZvSS5YhDjc8XZ5dqSCxzIz9opIqAbm+b4
aEV/3A3Jki5Dy8y/5j21GAK4Y4mqQOYzne7bDGi3Hyu041MGM4qfIcIkS5N1eHW4
sDZJh6+K5tuxN5TX3nDZSpm9luNH8mLGgKAZ15b1LqXAtM5ycoBY9Hv082suPPom
O+r0ybdRX6nDSH8+11y2KiP2kdVIUHCGkwlqgrux5YZyjCZPwOvEPhzSoOS+vBiF
UVXA8idnxNLk1QKCAQEA6MIihDSXx+350fWqhQ/3Qc6gA/t2C15JwJ9+uFWA+gjd
c/hn5HcmnmBJN4R04nLG/aU9SQur87a4mnC/Mp9JIARjHlZ/WNT4U0sJyPEVRg5U
Z9VajAucWwi0JyJYCO1EMMy68Jp8qlTriK/L7nbD86JJ5ASxjojiN/0psK/Pk60F
Rr+shKPi3jRQ1BDjDtAxOfo4ctf/nFbUM4bY0FNPQMP7WesoSKU0NBCRR6d0d2tq
YflMjIQHx+N74P5jEdSCHTVGQm+dj47pUt3lLPLWc0bX1G/GekwXP4NUsR/70Hsi
bwxkNnK2TSGzkt2rcOnutP125rJu6WpV7SNrq9rm7wKCAQAfMROcnbWviKHqnDPQ
hdR/2K9UJTvEhInASOS2UZWpi+s1rez9BuSjigOx4wbaAZ4t44PW7C3uyt84dHfU
HkIQb3I5bg8ENMrJpK9NN33ykwuzkDwMSwFcZ+Gci97hSubzoMl/IkeiiN1MapL4
GhLUgsD+3UMVL+Y9SymK8637IgyoCGdiND6/SXsa8SwLJo3VTjqx4eKpX7cvlSBL
RrRxc50TmwUsAhsd4CDl9YnSATLjVvJBeYlfM2tbFPaYwl1aR8v+PWkfnK0efm60
fHki33HEnGteBPKuGq4vwVYpn6bYGwQz+f6335/A2DMfZHFSpjVURHPcRcHbCMla
0cUxAoIBAQC25eYNkO478mo+bBbEXJlkoqLmvjAyGrNFo48F9lpVH6Y0vNuWkXJN
PUgLUhAu6RYotjGENqG17rz8zt/PPY9Ok2P3sOx8t00y1mIn/hlDZXs55FM0fOMu
PZaiscAPs7HDzvyOmDah+fzi+ZD8H2M3DS2W+YE0iaeJa2vZJS2t02W0BGXiDI33
IZDqMyLYvwwPjOnShJydEzXID4xLl0tNjzLxo3GSNA7jYqlmbtV8CXIc7rMSL6WV
ktIDKKJcnmpn3TcKeX6MEjaSIT82pNOS3fY3PmXuL+CMzfw8+u77Eecq78fHaTiL
P5JGM93F6mzi19EY0tmInUBMCWtQLcENAoIBAQCg0KaOkb8T36qzPrtgbfou0E2D
ufdpL1ugmD4edOFKQB5fDFQhLnSEVSJq3KUg4kWsXapQdsBd6kLdxS+K6MQrLBzr
4tf0c7UCF1AzWk6wXMExZ8mRb2RkGZYQB2DdyhFB3TPmnq9CW8JCq+6kxg/wkU4s
vM4JXzgcqVoSf42QJl+B9waeWhg0BTWx01lal4ds88HvEKmE0ik5GwiDbr7EvDDw
E6UbZtQcIoSTIIZDgYqVFfR2DAho3wXJRsOXh433lEJ8X7cCDzrngFbQnlKrpwML
Xgm0SIUc+Nf5poMM3rfLFK77t/ob4w+5PwRKcoSniyAxrHd6bwykYA8Vuydv
-----END RSA PRIVATE KEY-----

```

`update_metadata_pb2.py`:

```py
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: update_metadata.proto

import sys
_b=sys.version_info[0]<3 and (lambda x:x) or (lambda x:x.encode('latin1'))
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor.FileDescriptor(
  name='update_metadata.proto',
  package='chromeos_update_engine',
  syntax='proto2',
  serialized_pb=_b('\n\x15update_metadata.proto\x12\x16\x63hromeos_update_engine\"1\n\x06\x45xtent\x12\x13\n\x0bstart_block\x18\x01 \x01(\x04\x12\x12\n\nnum_blocks\x18\x02 \x01(\x04\"z\n\nSignatures\x12@\n\nsignatures\x18\x01 \x03(\x0b\x32,.chromeos_update_engine.Signatures.Signature\x1a*\n\tSignature\x12\x0f\n\x07version\x18\x01 \x01(\r\x12\x0c\n\x04\x64\x61ta\x18\x02 \x01(\x0c\"+\n\rPartitionInfo\x12\x0c\n\x04size\x18\x01 \x01(\x04\x12\x0c\n\x04hash\x18\x02 \x01(\x0c\"w\n\tImageInfo\x12\r\n\x05\x62oard\x18\x01 \x01(\t\x12\x0b\n\x03key\x18\x02 \x01(\t\x12\x0f\n\x07\x63hannel\x18\x03 \x01(\t\x12\x0f\n\x07version\x18\x04 \x01(\t\x12\x15\n\rbuild_channel\x18\x05 \x01(\t\x12\x15\n\rbuild_version\x18\x06 \x01(\t\"\xd3\x03\n\x10InstallOperation\x12;\n\x04type\x18\x01 \x02(\x0e\x32-.chromeos_update_engine.InstallOperation.Type\x12\x13\n\x0b\x64\x61ta_offset\x18\x02 \x01(\r\x12\x13\n\x0b\x64\x61ta_length\x18\x03 \x01(\r\x12\x33\n\x0bsrc_extents\x18\x04 \x03(\x0b\x32\x1e.chromeos_update_engine.Extent\x12\x12\n\nsrc_length\x18\x05 \x01(\x04\x12\x33\n\x0b\x64st_extents\x18\x06 \x03(\x0b\x32\x1e.chromeos_update_engine.Extent\x12\x12\n\ndst_length\x18\x07 \x01(\x04\x12\x18\n\x10\x64\x61ta_sha256_hash\x18\x08 \x01(\x0c\x12\x17\n\x0fsrc_sha256_hash\x18\t \x01(\x0c\"\x92\x01\n\x04Type\x12\x0b\n\x07REPLACE\x10\x00\x12\x0e\n\nREPLACE_BZ\x10\x01\x12\x08\n\x04MOVE\x10\x02\x12\n\n\x06\x42SDIFF\x10\x03\x12\x0f\n\x0bSOURCE_COPY\x10\x04\x12\x11\n\rSOURCE_BSDIFF\x10\x05\x12\x08\n\x04ZERO\x10\x06\x12\x0b\n\x07\x44ISCARD\x10\x07\x12\x0e\n\nREPLACE_XZ\x10\x08\x12\x0c\n\x08PUFFDIFF\x10\t\"\xa6\x03\n\x0fPartitionUpdate\x12\x16\n\x0epartition_name\x18\x01 \x02(\t\x12\x17\n\x0frun_postinstall\x18\x02 \x01(\x08\x12\x18\n\x10postinstall_path\x18\x03 \x01(\t\x12\x17\n\x0f\x66ilesystem_type\x18\x04 \x01(\t\x12M\n\x17new_partition_signature\x18\x05 \x03(\x0b\x32,.chromeos_update_engine.Signatures.Signature\x12\x41\n\x12old_partition_info\x18\x06 \x01(\x0b\x32%.chromeos_update_engine.PartitionInfo\x12\x41\n\x12new_partition_info\x18\x07 \x01(\x0b\x32%.chromeos_update_engine.PartitionInfo\x12<\n\noperations\x18\x08 \x03(\x0b\x32(.chromeos_update_engine.InstallOperation\x12\x1c\n\x14postinstall_optional\x18\t \x01(\x08\"\xc4\x05\n\x14\x44\x65ltaArchiveManifest\x12\x44\n\x12install_operations\x18\x01 \x03(\x0b\x32(.chromeos_update_engine.InstallOperation\x12K\n\x19kernel_install_operations\x18\x02 \x03(\x0b\x32(.chromeos_update_engine.InstallOperation\x12\x18\n\nblock_size\x18\x03 \x01(\r:\x04\x34\x30\x39\x36\x12\x19\n\x11signatures_offset\x18\x04 \x01(\x04\x12\x17\n\x0fsignatures_size\x18\x05 \x01(\x04\x12>\n\x0fold_kernel_info\x18\x06 \x01(\x0b\x32%.chromeos_update_engine.PartitionInfo\x12>\n\x0fnew_kernel_info\x18\x07 \x01(\x0b\x32%.chromeos_update_engine.PartitionInfo\x12>\n\x0fold_rootfs_info\x18\x08 \x01(\x0b\x32%.chromeos_update_engine.PartitionInfo\x12>\n\x0fnew_rootfs_info\x18\t \x01(\x0b\x32%.chromeos_update_engine.PartitionInfo\x12\x39\n\x0eold_image_info\x18\n \x01(\x0b\x32!.chromeos_update_engine.ImageInfo\x12\x39\n\x0enew_image_info\x18\x0b \x01(\x0b\x32!.chromeos_update_engine.ImageInfo\x12\x18\n\rminor_version\x18\x0c \x01(\r:\x01\x30\x12;\n\npartitions\x18\r \x03(\x0b\x32\'.chromeos_update_engine.PartitionUpdateB\x02H\x03')
)



_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(
  name='Type',
  full_name='chromeos_update_engine.InstallOperation.Type',
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name='REPLACE', index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='REPLACE_BZ', index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='MOVE', index=2, number=2,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='BSDIFF', index=3, number=3,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='SOURCE_COPY', index=4, number=4,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='SOURCE_BSDIFF', index=5, number=5,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='ZERO', index=6, number=6,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='DISCARD', index=7, number=7,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='REPLACE_XZ', index=8, number=8,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='PUFFDIFF', index=9, number=9,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=712,
  serialized_end=858,
)
_sym_db.RegisterEnumDescriptor(_INSTALLOPERATION_TYPE)


_EXTENT = _descriptor.Descriptor(
  name='Extent',
  full_name='chromeos_update_engine.Extent',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='start_block', full_name='chromeos_update_engine.Extent.start_block', index=0,
      number=1, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='num_blocks', full_name='chromeos_update_engine.Extent.num_blocks', index=1,
      number=2, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=49,
  serialized_end=98,
)


_SIGNATURES_SIGNATURE = _descriptor.Descriptor(
  name='Signature',
  full_name='chromeos_update_engine.Signatures.Signature',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='version', full_name='chromeos_update_engine.Signatures.Signature.version', index=0,
      number=1, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='data', full_name='chromeos_update_engine.Signatures.Signature.data', index=1,
      number=2, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value=_b(""),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=180,
  serialized_end=222,
)

_SIGNATURES = _descriptor.Descriptor(
  name='Signatures',
  full_name='chromeos_update_engine.Signatures',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='signatures', full_name='chromeos_update_engine.Signatures.signatures', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[_SIGNATURES_SIGNATURE, ],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=100,
  serialized_end=222,
)


_PARTITIONINFO = _descriptor.Descriptor(
  name='PartitionInfo',
  full_name='chromeos_update_engine.PartitionInfo',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='size', full_name='chromeos_update_engine.PartitionInfo.size', index=0,
      number=1, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='hash', full_name='chromeos_update_engine.PartitionInfo.hash', index=1,
      number=2, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value=_b(""),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=224,
  serialized_end=267,
)


_IMAGEINFO = _descriptor.Descriptor(
  name='ImageInfo',
  full_name='chromeos_update_engine.ImageInfo',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='board', full_name='chromeos_update_engine.ImageInfo.board', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='key', full_name='chromeos_update_engine.ImageInfo.key', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='channel', full_name='chromeos_update_engine.ImageInfo.channel', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='version', full_name='chromeos_update_engine.ImageInfo.version', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='build_channel', full_name='chromeos_update_engine.ImageInfo.build_channel', index=4,
      number=5, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='build_version', full_name='chromeos_update_engine.ImageInfo.build_version', index=5,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=269,
  serialized_end=388,
)


_INSTALLOPERATION = _descriptor.Descriptor(
  name='InstallOperation',
  full_name='chromeos_update_engine.InstallOperation',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='type', full_name='chromeos_update_engine.InstallOperation.type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='data_offset', full_name='chromeos_update_engine.InstallOperation.data_offset', index=1,
      number=2, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='data_length', full_name='chromeos_update_engine.InstallOperation.data_length', index=2,
      number=3, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='src_extents', full_name='chromeos_update_engine.InstallOperation.src_extents', index=3,
      number=4, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='src_length', full_name='chromeos_update_engine.InstallOperation.src_length', index=4,
      number=5, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='dst_extents', full_name='chromeos_update_engine.InstallOperation.dst_extents', index=5,
      number=6, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='dst_length', full_name='chromeos_update_engine.InstallOperation.dst_length', index=6,
      number=7, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='data_sha256_hash', full_name='chromeos_update_engine.InstallOperation.data_sha256_hash', index=7,
      number=8, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value=_b(""),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='src_sha256_hash', full_name='chromeos_update_engine.InstallOperation.src_sha256_hash', index=8,
      number=9, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value=_b(""),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _INSTALLOPERATION_TYPE,
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=391,
  serialized_end=858,
)


_PARTITIONUPDATE = _descriptor.Descriptor(
  name='PartitionUpdate',
  full_name='chromeos_update_engine.PartitionUpdate',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='partition_name', full_name='chromeos_update_engine.PartitionUpdate.partition_name', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='run_postinstall', full_name='chromeos_update_engine.PartitionUpdate.run_postinstall', index=1,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='postinstall_path', full_name='chromeos_update_engine.PartitionUpdate.postinstall_path', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='filesystem_type', full_name='chromeos_update_engine.PartitionUpdate.filesystem_type', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='new_partition_signature', full_name='chromeos_update_engine.PartitionUpdate.new_partition_signature', index=4,
      number=5, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='old_partition_info', full_name='chromeos_update_engine.PartitionUpdate.old_partition_info', index=5,
      number=6, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='new_partition_info', full_name='chromeos_update_engine.PartitionUpdate.new_partition_info', index=6,
      number=7, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='operations', full_name='chromeos_update_engine.PartitionUpdate.operations', index=7,
      number=8, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='postinstall_optional', full_name='chromeos_update_engine.PartitionUpdate.postinstall_optional', index=8,
      number=9, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=861,
  serialized_end=1283,
)


_DELTAARCHIVEMANIFEST = _descriptor.Descriptor(
  name='DeltaArchiveManifest',
  full_name='chromeos_update_engine.DeltaArchiveManifest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='install_operations', full_name='chromeos_update_engine.DeltaArchiveManifest.install_operations', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='kernel_install_operations', full_name='chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='block_size', full_name='chromeos_update_engine.DeltaArchiveManifest.block_size', index=2,
      number=3, type=13, cpp_type=3, label=1,
      has_default_value=True, default_value=4096,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='signatures_offset', full_name='chromeos_update_engine.DeltaArchiveManifest.signatures_offset', index=3,
      number=4, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='signatures_size', full_name='chromeos_update_engine.DeltaArchiveManifest.signatures_size', index=4,
      number=5, type=4, cpp_type=4, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='old_kernel_info', full_name='chromeos_update_engine.DeltaArchiveManifest.old_kernel_info', index=5,
      number=6, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='new_kernel_info', full_name='chromeos_update_engine.DeltaArchiveManifest.new_kernel_info', index=6,
      number=7, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='old_rootfs_info', full_name='chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info', index=7,
      number=8, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='new_rootfs_info', full_name='chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info', index=8,
      number=9, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='old_image_info', full_name='chromeos_update_engine.DeltaArchiveManifest.old_image_info', index=9,
      number=10, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='new_image_info', full_name='chromeos_update_engine.DeltaArchiveManifest.new_image_info', index=10,
      number=11, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='minor_version', full_name='chromeos_update_engine.DeltaArchiveManifest.minor_version', index=11,
      number=12, type=13, cpp_type=3, label=1,
      has_default_value=True, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='partitions', full_name='chromeos_update_engine.DeltaArchiveManifest.partitions', index=12,
      number=13, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto2',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=1286,
  serialized_end=1994,
)

_SIGNATURES_SIGNATURE.containing_type = _SIGNATURES
_SIGNATURES.fields_by_name['signatures'].message_type = _SIGNATURES_SIGNATURE
_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE
_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT
_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT
_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION
_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE
_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO
_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO
_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION
_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION
_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION
_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO
_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO
_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO
_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO
_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO
_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO
_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE
DESCRIPTOR.message_types_by_name['Extent'] = _EXTENT
DESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES
DESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO
DESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO
DESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION
DESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE
DESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST
_sym_db.RegisterFileDescriptor(DESCRIPTOR)

Extent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(
  DESCRIPTOR = _EXTENT,
  __module__ = 'update_metadata_pb2'
  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
  ))
_sym_db.RegisterMessage(Extent)

Signatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(

  Signature = _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), dict(
    DESCRIPTOR = _SIGNATURES_SIGNATURE,
    __module__ = 'update_metadata_pb2'
    # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
    ))
  ,
  DESCRIPTOR = _SIGNATURES,
  __module__ = 'update_metadata_pb2'
  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
  ))
_sym_db.RegisterMessage(Signatures)
_sym_db.RegisterMessage(Signatures.Signature)

PartitionInfo = _reflection.GeneratedProtocolMessageType('PartitionInfo', (_message.Message,), dict(
  DESCRIPTOR = _PARTITIONINFO,
  __module__ = 'update_metadata_pb2'
  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
  ))
_sym_db.RegisterMessage(PartitionInfo)

ImageInfo = _reflection.GeneratedProtocolMessageType('ImageInfo', (_message.Message,), dict(
  DESCRIPTOR = _IMAGEINFO,
  __module__ = 'update_metadata_pb2'
  # @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)
  ))
_sym_db.RegisterMessage(ImageInfo)

InstallOperation = _reflection.GeneratedProtocolMessageType('InstallOperation', (_message.Message,), dict(
  DESCRIPTOR = _INSTALLOPERATION,
  __module__ = 'update_metadata_pb2'
  # @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
  ))
_sym_db.RegisterMessage(InstallOperation)

PartitionUpdate = _reflection.GeneratedProtocolMessageType('PartitionUpdate', (_message.Message,), dict(
  DESCRIPTOR = _PARTITIONUPDATE,
  __module__ = 'update_metadata_pb2'
  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
  ))
_sym_db.RegisterMessage(PartitionUpdate)

DeltaArchiveManifest = _reflection.GeneratedProtocolMessageType('DeltaArchiveManifest', (_message.Message,), dict(
  DESCRIPTOR = _DELTAARCHIVEMANIFEST,
  __module__ = 'update_metadata_pb2'
  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
  ))
_sym_db.RegisterMessage(DeltaArchiveManifest)


DESCRIPTOR.has_options = True
DESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('H\003'))
# @@protoc_insertion_point(module_scope)
```

`wifi.py`:

```py
#!/usr/bin/env python

# This file is part of PixelFlasher https://github.com/badabing2005/PixelFlasher
#
# Copyright (C) 2025 Badabing2005
# SPDX-FileCopyrightText: 2025 Badabing2005
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Also add information on how to contact you by electronic and paper mail.
#
# If your software can interact with users remotely through a computer network,
# you should also make sure that it provides a way for users to get its source.
# For example, if your program is a web application, its interface could
# display a "Source" link that leads users to an archive of the code. There are
# many ways you could offer source, and different solutions will be better for
# different programs; see section 13 for the specific requirements.
#
# You should also get your employer (if you work as a programmer) or school, if
# any, to sign a "copyright disclaimer" for the program, if necessary. For more
# information on this, and how to apply and follow the GNU AGPL, see
# <https://www.gnu.org/licenses/>.

import contextlib
import json
import json5
from datetime import datetime

import wx
import wx.html
import wx.lib.mixins.listctrl as listmix
import wx.lib.wxpTag

import images as images
from phone import get_connected_devices
from runtime import *

dark_green = wx.Colour(0, 100, 0)

# ============================================================================
#                               Class ListCtrl
# ============================================================================
class ListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
        listmix.ListCtrlAutoWidthMixin.__init__(self)


# ============================================================================
#                               Class Wireless
# ============================================================================
class Wireless(wx.Dialog, listmix.ColumnSorterMixin):
    def __init__(self, *args, **kwargs):
        wx.Dialog.__init__(self, *args, **kwargs, style = wx.RESIZE_BORDER | wx.DEFAULT_DIALOG_STYLE)
        self.SetTitle("ADB Wireless")
        self.history = {}
        self.load_history()

        self.searchCtrl = wx.SearchCtrl(self, style=wx.TE_PROCESS_ENTER)
        self.searchCtrl.ShowCancelButton(True)

        self.il = wx.ImageList(16, 16)
        # self.idx1 = self.il.Add(images.official_16.GetBitmap())
        self.sm_up = self.il.Add(images.SmallUpArrow.GetBitmap())
        self.sm_dn = self.il.Add(images.SmallDnArrow.GetBitmap())

        self.list = ListCtrl(self, -1, size=(-1, -1), style=wx.LC_REPORT | wx.BORDER_SUNKEN | wx.LC_SINGLE_SEL)

        if sys.platform == "win32":
            self.list.SetHeaderAttr(wx.ItemAttr(wx.Colour('BLACK'),wx.Colour('DARK GREY'), wx.Font(wx.FontInfo(10).Bold())))
        self.list.SetImageList(self.il, wx.IMAGE_LIST_SMALL)
        self.list.EnableCheckBoxes(enable=False)
        listmix.ColumnSorterMixin.__init__(self, 6)
        self.Refresh()

        self.ip_ctrl = wx.SearchCtrl(self, style=wx.TE_LEFT)
        ip_ctrl_default_height = self.ip_ctrl.GetSize().GetHeight()
        self.ip_ctrl.SetMinSize((200, ip_ctrl_default_height))
        self.ip_ctrl.ShowCancelButton(True)
        self.ip_ctrl.SetDescriptiveText("IP/Hostname")
        self.ip_ctrl.ShowSearchButton(False)

        self.port = wx.SearchCtrl(self, style=wx.TE_LEFT)
        self.port.ShowCancelButton(True)
        self.port.SetDescriptiveText("Port (Default:5555)")
        self.port.ShowSearchButton(False)

        self.pairing_code = wx.SearchCtrl(self, style=wx.TE_LEFT)
        self.pairing_code.ShowCancelButton(True)
        self.pairing_code.SetDescriptiveText("Pairing Code")
        self.pairing_code.ShowSearchButton(False)

        self.connect_button = wx.Button(self, wx.ID_ANY, u"Connect", wx.DefaultPosition, wx.DefaultSize, 0)
        self.connect_button.SetToolTip(u"Connect to device")
        self.connect_button.Disable()

        self.disconnect_button = wx.Button(self, wx.ID_ANY, u"Disconnect", wx.DefaultPosition, wx.DefaultSize, 0)
        self.disconnect_button.SetToolTip(u"Disconnect device")
        self.disconnect_button.Disable()

        self.pair_button = wx.Button(self, wx.ID_ANY, u"Pair", wx.DefaultPosition, wx.DefaultSize, 0)
        self.pair_button.SetToolTip(u"Pairs with device (only needed once per device)")
        self.pair_button.Disable()

        self.close_button = wx.Button(self, wx.ID_ANY, u"Close", wx.DefaultPosition, wx.DefaultSize, 0)
        self.close_button.SetToolTip(u"Closes this dialog")

        vSizer = wx.BoxSizer(wx.VERTICAL)
        search_hsizer = wx.BoxSizer( wx.HORIZONTAL )
        search_hsizer.Add(self.searchCtrl, 1, wx.ALL, 20)

        entry_vSizer = wx.BoxSizer(wx.VERTICAL)
        entry_vSizer.Add(self.ip_ctrl, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.port, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.Add(self.pairing_code, 0, wx.ALL|wx.EXPAND, 10)
        entry_vSizer.AddSpacer(40)
        entry_vSizer.Add(self.connect_button, 0, wx.EXPAND | wx.ALL, 10)
        entry_vSizer.Add(self.disconnect_button, 0, wx.EXPAND | wx.ALL, 10)
        entry_vSizer.Add(self.pair_button, 0, wx.EXPAND | wx.ALL, 10)
        entry_vSizer.Add((0, 0), proportion=1, flag=wx.EXPAND, border=0)
        entry_vSizer.Add(self.close_button, 0, wx.EXPAND | wx.ALL, 10)

        main_hSizer = wx.BoxSizer(wx.HORIZONTAL)
        main_hSizer.Add(self.list, 1, wx.ALL|wx.EXPAND, 10)
        main_hSizer.Add(entry_vSizer, 0, wx.ALL|wx.EXPAND, 0)

        vSizer.Add(search_hsizer, 0, wx.EXPAND, 10)
        vSizer.Add(main_hSizer , 1, wx.ALL|wx.EXPAND, 10)

        self.SetSizer(vSizer)
        self.Layout()
        self.Centre(wx.BOTH)

        # Autosize the dialog
        self.list.PostSizeEventToParent()
        self.SetSizerAndFit(vSizer)
        self.SetSize(vSizer.MinSize.Width + 80, vSizer.MinSize.Height + 400)

        # Connect Events
        self.searchCtrl.Bind(wx.EVT_TEXT_ENTER, self.OnSearch)
        self.searchCtrl.Bind(wx.EVT_SEARCH, self.OnSearch)
        self.searchCtrl.Bind(wx.EVT_SEARCHCTRL_CANCEL_BTN, self.OnCancel)
        self.connect_button.Bind(wx.EVT_BUTTON, self.OnConnect)
        self.disconnect_button.Bind(wx.EVT_BUTTON, self.OnDisconnect)
        self.pair_button.Bind(wx.EVT_BUTTON, self.OnPair)
        self.close_button.Bind(wx.EVT_BUTTON, self.OnClose)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self.list)
        self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.OnItemDeSelected, self.list)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.OnColClick, self.list)
        self.ip_ctrl.Bind(wx.EVT_TEXT, self.on_ip_change)
        self.pairing_code.Bind(wx.EVT_TEXT, self.on_pairing_change)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    # -----------------------------------------------
    #              Function PopulateList
    # -----------------------------------------------
    def PopulateList(self):
        try:
            info = wx.ListItem()
            info.Mask = wx.LIST_MASK_TEXT | wx.LIST_MASK_IMAGE | wx.LIST_MASK_FORMAT
            info.Image = -1
            info.Align = 0
            info.Width = -1
            info.SetWidth(-1)
            info.Text = "Date"
            self.list.InsertColumn(0, info)

            info.Align = wx.LIST_FORMAT_LEFT # 0
            info.Text = "Action"
            self.list.InsertColumn(1, info)

            info.Align = wx.LIST_FORMAT_LEFT # 0
            info.Text = "IP/Hostname"
            self.list.InsertColumn(2, info)

            info.Align = wx.LIST_FORMAT_LEFT # 0
            info.Text = "Port"
            self.list.InsertColumn(3, info)

            info.Align = wx.LIST_FORMAT_LEFT # 0
            info.Text = "Pairing Code"
            self.list.InsertColumn(4, info)

            info.Align = wx.LIST_FORMAT_LEFT # 0
            info.Text = "Note"
            self.list.InsertColumn(5, info)

            itemDataMap = {}
            query = self.searchCtrl.GetValue().lower()
            if self.history:
                i = 0
                items = self.history.items()
                # date in epoch is the key
                for key, data in items:
                    action = data["action"]
                    ip = data["ip"]
                    port = data["port"]
                    pair = data["pair"]
                    if pair is None:
                        pair = ''
                    note = data["note"]
                    if note is None:
                        note = ''
                    status = data["status"]
                    ts = datetime.fromtimestamp(int(key))
                    action_date = ts.strftime('%Y-%m-%d %H:%M:%S')
                    alltext = f"{action_date} {action.lower()} {status.lower()} {ip.lower()} {port.lower()} {pair.lower()} {note.lower()}"
                    if query.lower() in alltext:
                        index = self.list.InsertItem(self.list.GetItemCount(), action_date)
                        itemDataMap[i + 1] = (key, action, ip, port, pair, note)
                        row = self.list.GetItem(index)
                        self.list.SetItem(index, 1, action)
                        self.list.SetItem(index, 2, ip)
                        self.list.SetItem(index, 3, port)
                        self.list.SetItem(index, 4, pair)
                        self.list.SetItem(index, 5, note)
                        if status == 'Success':
                            row.SetTextColour(dark_green)
                        elif status == 'Failed':
                            row.SetTextColour(wx.RED)
                        self.list.SetItem(row)
                        self.list.SetItemData(index, i + 1)
                        # hide image
                        self.list.SetItemColumnImage(i, 0, -1)
                        i += 1
            self.list.SetColumnWidth(0, -2)
            grow_column(self.list, 0, 20)
            self.list.SetColumnWidth(1, -2)
            grow_column(self.list, 1, 20)
            self.list.SetColumnWidth(2, -2)
            grow_column(self.list, 1, 40)
            self.list.SetColumnWidth(3, -2)
            grow_column(self.list, 1, 40)
            self.list.SetColumnWidth(4, -2)
            grow_column(self.list, 1, 20)
            self.list.SetColumnWidth(5, 200)
            grow_column(self.list, 1, 20)

            self.currentItem = 0
            if itemDataMap:
                return itemDataMap
            else:
                return -1
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while populating wifi history")
            puml("#red:Encountered an error while populating wifi history;\n")
            traceback.print_exc()

    # -----------------------------------------------
    #                  on_ip_change
    # -----------------------------------------------
    def on_ip_change(self, event):
        text = self.ip_ctrl.GetValue()
        if text.strip():
            self.connect_button.Enable()
            self.disconnect_button.Enable()
        else:
            self.connect_button.Disable()
            self.disconnect_button.Disable()

    # -----------------------------------------------
    #                  on_pairing_change
    # -----------------------------------------------
    def on_pairing_change(self, event):
        text = self.pairing_code.GetValue()
        if text.strip():
            self.pair_button.Enable()
        else:
            self.pair_button.Disable()

    # -----------------------------------------------
    #                  onSearch
    # -----------------------------------------------
    def OnSearch(self, event):
        query = self.searchCtrl.GetValue()
        print(f"Searching for: {query}")
        self.Refresh()

    # -----------------------------------------------
    #                  onCancel
    # -----------------------------------------------
    def OnCancel(self, event):
        self.searchCtrl.SetValue("")
        self.Refresh()

    # -----------------------------------------------
    #                  load_history
    # -----------------------------------------------
    def load_history(self):
        if os.path.exists(get_wifi_history_file_path()):
            with contextlib.suppress(FileNotFoundError):
                with open(get_wifi_history_file_path(), "r", encoding='ISO-8859-1', errors="replace") as file:
                    self.history = json5.load(file)

    # -----------------------------------------------
    #                  save_history
    # -----------------------------------------------
    def save_history(self):
        with open(get_wifi_history_file_path(), "w", encoding='ISO-8859-1', errors="replace") as file:
            json.dump(self.history, file, indent=4)

    # -----------------------------------------------
    #                  OnClose
    # -----------------------------------------------
    def OnClose(self, e):
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} User Pressed Close.")
        self.EndModal(wx.ID_CANCEL)

    # ============================================================================
    #                               Function wifi_adb_action
    # ============================================================================
    def wifi_adb_action(self, ip, port = "5555", disconnect = False, pairing_code = ''):
        if disconnect:
            command = 'disconnect'
        elif pairing_code != '':
            command = 'pair'
        else:
            command = 'connect'
        print(f"Remote ADB {command}ing: {ip}:{port} {pairing_code}")
        if get_adb():
            puml(":Wifi ADB;\n", True)
            ip = ip.strip()
            port = port.strip()
            if port == '':
                port = "5555"
            theCmd = f"\"{get_adb()}\" {command} {ip}:{port} {pairing_code}"
            res = run_shell(theCmd)
            puml(f"note right\n=== {command} to: {ip}:{port} {pairing_code}\nend note\n")
            if res.returncode == 0 and 'cannot' not in res.stdout and 'failed' not in res.stdout:
                print(f"ADB {command}ed: {ip}:{port}")
                puml(f"#palegreen:Succeeded;\n")
                if command != 'pair':
                    self.Parent.device_choice.SetItems(get_connected_devices())
                    self.Parent._select_configured_device()
                    print(f"Please select the device: {ip}:{port}")
                return
            else:
                print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Could not {command} {ip}:{port} {pairing_code}\n")
                print(f"{res.stderr}")
                print(f"{res.stdout}")
                puml(f"#red:**Failed**\n{res.stderr}\n{res.stdout};\n")
                return f"{res.stderr} {res.stdout}"

    # -----------------------------------------------
    #                  OnConnect
    # -----------------------------------------------
    def OnConnect(self, e):
        try:
            if self.ip_ctrl.Value:
                self._on_spin('start')
                res = self.wifi_adb_action(self.ip_ctrl.Value, self.port.Value)
                if res:
                    self.add_to_history(action='connect', status="Failed", note=res)
                else:
                    self.add_to_history(action='connect', status="Success")
                    port = self.port.Value
                    if port == '':
                        port = "5555"
                    device_id = f"{self.ip_ctrl.Value}:{port}"
                    set_phone_id(device_id)
                    self.Parent.config.device = device_id
                    self.Parent.refresh_device(device_id)
                self._on_spin('stop')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while wifi connecting")
            puml("#red:Encountered an error while wifi connecting;\n")
            self._on_spin('stop')
            traceback.print_exc()

    # -----------------------------------------------
    #                  OnDisconnect
    # -----------------------------------------------
    def OnDisconnect(self, e):
        try:
            if self.ip_ctrl.Value:
                self._on_spin('start')
                res = self.wifi_adb_action(self.ip_ctrl.Value, self.port.Value, disconnect=True)
                if res:
                    self.add_to_history(action='disconnect', status="Failed", note=res)
                else:
                    self.add_to_history(action='disconnect', status="Success")
                    self.Parent.device_choice.Popup()
                self._on_spin('stop')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while disconnecting a wireless device")
            puml("#red:Encountered an error while disconnecting a wireless device;\n")
            self._on_spin('stop')
            traceback.print_exc()

    # -----------------------------------------------
    #                  OnPair
    # -----------------------------------------------
    def OnPair(self, e):
        try:
            if self.pairing_code.Value:
                self._on_spin('start')
                res = self.wifi_adb_action(self.ip_ctrl.Value, self.port.Value, disconnect=False, pairing_code=self.pairing_code.Value)
                if res is None:
                    self.add_to_history(action='pair', status="Success")
                else:
                    self.add_to_history(action='pair', status="Failed", note=res)
                self._on_spin('stop')
        except Exception as e:
            print(f"\n❌ {datetime.now():%Y-%m-%d %H:%M:%S} ERROR: Encountered an error while pairing a device")
            puml("#red:Encountered an error while pairing a device;\n")
            self._on_spin('stop')
            traceback.print_exc()

    # -----------------------------------------------
    #                  GetListCtrl
    # -----------------------------------------------
    # Used by the ColumnSorterMixin, see wx/lib/mixins/listctrl.py
    def GetListCtrl(self):
        return self.list

    # -----------------------------------------------
    #                  GetSortImages
    # -----------------------------------------------
    # Used by the ColumnSorterMixin, see wx/lib/mixins/listctrl.py
    def GetSortImages(self):
        return (self.sm_dn, self.sm_up)


    # -----------------------------------------------
    #                  getColumnText
    # -----------------------------------------------
    def getColumnText(self, index, col):
        item = self.list.GetItem(index, col)
        return item.GetText()

    # -----------------------------------------------
    #                  OnItemSelected
    # -----------------------------------------------
    def OnItemDeSelected(self, event):
        self.ip_ctrl.Clear()
        self.port.Clear()
        self.pairing_code.Clear()
        event.Skip()

    # -----------------------------------------------
    #                  OnItemSelected
    # -----------------------------------------------
    def OnItemSelected(self, event):
        self.currentItem = event.Index
        self.ip_ctrl.SetValue(self.getColumnText(self.currentItem, 2))
        self.port.SetValue(self.getColumnText(self.currentItem, 3))
        if self.getColumnText(self.currentItem, 4).strip() != '':
            self.pairing_code.SetValue(self.getColumnText(self.currentItem, 4))
        event.Skip()

    # -----------------------------------------------
    #                  OnColClick
    # -----------------------------------------------
    def OnColClick(self, event):
        col = event.GetColumn()
        if col == -1:
            return # clicked outside any column.
        rowid = self.list.GetColumn(col)
        # print(f"Sorting on Column {rowid.GetText()}")
        event.Skip()

    # -----------------------------------------------
    #          Function simulate_column_click
    # -----------------------------------------------
    def simulate_column_click(self, col):
        fake_event = wx.ListEvent(wx.EVT_LIST_COL_CLICK.typeId, self.list.GetId())
        fake_event.SetEventObject(self.list)
        fake_event.SetColumn(col)
        self.list.ProcessEvent(fake_event)

    # -----------------------------------------------
    #          Function add_to_history
    # -----------------------------------------------
    def add_to_history(self, action, status, note=None):
        ip = self.ip_ctrl.GetValue()
        port = self.port.GetValue()
        pair = self.pairing_code.GetValue()
        record = {
            "action": action,
            "status": status,
            "ip": ip,
            "port": port,
            "pair": pair,
            "note": note
        }
        current_timestamp = int(time.time())
        self.history[str(current_timestamp)] = record
        self.save_history()
        self.Refresh()

    # -----------------------------------------------
    #                  Function Refresh
    # -----------------------------------------------
    def Refresh(self):
        self.list.Freeze()
        self.list.ClearAll()
        itemDataMap = self.PopulateList()
        if itemDataMap != -1:
            self.itemDataMap = itemDataMap
        # reverse sort by date
        self.simulate_column_click(0)
        self.simulate_column_click(0)
        self.list.Thaw()

    # -----------------------------------------------
    #                  _on_spin
    # -----------------------------------------------
    def _on_spin(self, state):
        wx.YieldIfNeeded()
        if state == 'start':
            self.SetCursor(wx.Cursor(wx.CURSOR_WAIT))
            self.Parent._on_spin('start')
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.Parent._on_spin('stop')

```

`windows-metadata.yaml`:

```yaml
# https://github.com/DudeNr33/pyinstaller-versionfile
# create-version-file windows-metadata.yaml --outfile windows-version-info.txt
Version: 8.15.0.0
FileDescription: PixelFlasher
InternalName: PixelFlasher
OriginalFilename: PixelFlasher.exe
ProductName: PixelFlasher

```

`windows-version-info.txt`:

```txt
# UTF-8
#
# For more details about fixed file info 'ffi' see:
# http://msdn.microsoft.com/en-us/library/ms646997.aspx

VSVersionInfo(
  ffi=FixedFileInfo(
    # filevers and prodvers should be always a tuple with four items: (1, 2, 3, 4)
    # Set not needed items to zero 0. Must always contain 4 elements.
    filevers=(8,15,0,0),
    prodvers=(8,15,0,0),
    # Contains a bitmask that specifies the valid bits 'flags'r
    mask=0x3f,
    # Contains a bitmask that specifies the Boolean attributes of the file.
    flags=0x0,
    # The operating system for which this file was designed.
    # 0x4 - NT and there is no need to change it.
    OS=0x40004,
    # The general type of file.
    # 0x1 - the file is an application.
    fileType=0x1,
    # The function of the file.
    # 0x0 - the function is not defined for this fileType
    subtype=0x0,
    # Creation date and time stamp.
    date=(0, 0)
   ),
  kids=[
    StringFileInfo(
      [
      StringTable(
        u'040904B0',
        [StringStruct(u'CompanyName', u''),
        StringStruct(u'FileDescription', u'PixelFlasher'),
        StringStruct(u'FileVersion', u'8.15.0.0'),
        StringStruct(u'InternalName', u'PixelFlasher'),
        StringStruct(u'LegalCopyright', u''),
        StringStruct(u'OriginalFilename', u'PixelFlasher.exe'),
        StringStruct(u'ProductName', u'PixelFlasher'),
        StringStruct(u'ProductVersion', u'8.15.0.0')])
      ]),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)

```