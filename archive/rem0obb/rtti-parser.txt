Project Path: arc_rem0obb_rtti-parser_ex94tejj

Source Tree:

```txt
arc_rem0obb_rtti-parser_ex94tejj
├── LICENSE
├── README.md
├── example
│   ├── test_diamond_inheritance.elf
│   └── test_template.elf
├── git_resources
│   ├── decompiler_after.png
│   ├── decompiler_before.png
│   ├── function_window_after.png
│   ├── function_window_before.png
│   ├── sample_output.png
│   └── structs_window_after.png
├── rtti_parse.py
└── rtti_parser_core
    ├── __init__.py
    ├── binary_stream.py
    ├── common.py
    ├── consts.py
    ├── elf.py
    ├── rtti.py
    ├── settings.py
    └── vtable.py

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
### RTTI parser

Parses RTTI information from executable with support for IDA 9.2

### Example

**HexRays decompiler view**

Before:

![decompiler view before](git_resources/decompiler_before.png)

After:

![decompiler view after](git_resources/decompiler_after.png)

**Functions window**

Before:

![functions window before](git_resources/function_window_before.png)

After:

![functions window after](git_resources/function_window_after.png)

**Structs window**

![structs windows](git_resources/structs_window_after.png)

### Install & Run

1. `git clone git@github.com:rem0obb/better-rtti-parser.git`
2. Click on "IDA > File > Script file" and choose rtti_parse.py
3. Happy RE time!

### Why another RTTI parser ?

Known tools didn't have functionality to rename functions based on typeinfo ( e.g. sub_4B5A to BaseClass::AnotherClass::sub_4B5A ). So, I decided to spend few more hours to rewrite code, learn how to write IDA plugins. Finally, it works pretty fast, I really liked it, so I'll continue to update it.


### Known issues

#### Can't rename byte at 'xxx' because the name is already used in the program.

**Problem**:

It's a bug that will be fixed in later commits. Probably, will add number prefix to names as IDA does for functions.

**Steps to resolve**

Click on ignore for this database and continue. 

### Current cover 

- [x] GNU g++ 64-bit 
- [x] IDA Pro 7.4, 7.6, 9.2
- [x] Rename functions to BaseClass::AnotherClass::sub_4B5A format
- [x] Create structures for vtables
- [x] Fix: some functions are only renamed, but retyping fails
- [x] Fix: place "v" at the end of symbol only if there are no parameters for function
- [x] Beta support for ARM 32-bit
- [ ] Find destructors ( Not really sure how accurate it will be )
- [ ] Make class graph
- [ ] IDA Pro 7.0-7.3 support
- [ ] GNU G++ 32-bit
- [ ] MSVC 64-bit
- [ ] MSVC 32-bit

### Test environment

- Windows 10 2021 H1, Linux
- IDA Pro 7.6, 9.2
- Python 3.10 ( I'm surprised this python version works well )
- x64 GNU g++ binary

### Examples

Check out example folder. There are .elf files for you to test.

Example output ->

![an image should be here](git_resources/sample_output.png)

### Credits

1. [better-rtti-parser](https://github.com/MlsDmitry/better-rtti-parser)

```

`rtti_parse.py`:

```py
from rtti_parser_core.vtable import TypeInfoVtable
from rtti_parser_core.elf import read_elf_sym_crossplatform
from rtti_parser_core.common import search, demangle
from rtti_parser_core.rtti import BasicClass, SiClass, VmiClass
import time
import logging

import idc
import idautils
import ida_name
import ida_ida
import ida_bytes
import idaapi
import ida_segment


idaapi.require('rtti_parser_core.binary_stream')
idaapi.require('rtti_parser_core.vtable')
idaapi.require('rtti_parser_core.consts')
idaapi.require('rtti_parser_core.elf')
idaapi.require('rtti_parser_core.common')
idaapi.require('rtti_parser_core.rtti')


class TiClassKind:
    CLASS_TYPE = '__class_type_info'
    # CLASS_TYPE = '_ZTVN10__cxxabiv117__class_type_infoE'
    # SI_CLASS_TYPE = '_ZTVN10__cxxabiv120__si_class_type_infoE'
    SI_CLASS_TYPE = '__si_class_type_infoE'
    # VMI_CLASS_TYPE = '_ZTVN10__cxxabiv121__vmi_class_type_infoE'
    VMI_CLASS_TYPE = '__vmi_class_type_infoE'


"""
These are symbols, that used to find typeinfos and vtables
"""
symbol_table = {
    TiClassKind.CLASS_TYPE: BasicClass,
    TiClassKind.SI_CLASS_TYPE: SiClass,
    TiClassKind.VMI_CLASS_TYPE: VmiClass
}

typeinfo_counter = 0
vtable_counter = 0
func_counter = 0


def sanitize_ea(ea):
    """Convert tuple/str to integer EA and avoid crashes on IDA 9.2."""
    if ea is None:
        return idc.BADADDR

    if isinstance(ea, int):
        return ea

    if isinstance(ea, tuple):
        for item in ea:
            if isinstance(item, int):
                return item
            try:
                return int(item)
            except:
                pass
        return idc.BADADDR

    if isinstance(ea, str):
        try:
            return int(ea, 16)
        except:
            return idc.BADADDR

    try:
        return int(ea)
    except:
        return idc.BADADDR


def XrefsToCompat(ea):
    """IDA 9.2 requires the flags parameter sometimes."""
    try:
        return idautils.XrefsTo(ea, 0)
    except TypeError:
        return idautils.XrefsTo(ea)


def get_item_head_compat(ea):
    """IDA 9.2 sometimes requires int only."""
    ea = sanitize_ea(ea)
    try:
        return ida_bytes.get_item_head(ea)
    except:
        try:
            return ida_bytes.get_item_head(int(ea))
        except:
            return idc.BADADDR
            
def process_class_info(symbol_name, ea):
    global typeinfo_counter, vtable_counter, func_counter

    for typeinfo_ea in XrefsToCompat(ea):
        if typeinfo_ea.frm == idc.BADADDR:
            continue

        classtype = symbol_table[symbol_name](typeinfo_ea.frm)

        # skip this one, because name hasn't been read.
        if not classtype.read_name():
            print(
                f'Failed to read name of typeinfo. mangled is: {classtype.type_name} at {hex(typeinfo_ea.frm)}'
            )
            continue
        # will get rid of global variables later
        typeinfo_counter += 1

        classtype.read_typeinfo()

        print(f'Found typeinfo for {classtype.dn_name} at {hex(typeinfo_ea.frm)}')

        # read vtable
        if not classtype.read_vtable():
            print(
                f'Failed to find vtable for {classtype.dn_name}'
            )
            continue

        vtable_counter += 1
        func_counter += len(classtype.vtable.entries)

        # create struct for vtable
        if classtype.create_vtable_struct():
            # retype functions
            classtype.retype_vtable_functions()
        else:
            print(
                f'vtable struct for {classtype.dn_name} not created !')


def process():
    start_time = time.time()
    for symbol_name in symbol_table:
        addr_ea = search(symbol_name)
        # get start of the string
        addr_ea = get_item_head_compat(addr_ea)
        print(f'Found {symbol_name} at {hex(addr_ea)}')

        # get only firest xref
        elf_sym_struct_ea = next(XrefsToCompat(addr_ea), None)
        if not elf_sym_struct_ea:
            print(
                f'No Code refs found for {symbol_name}'
            )
            continue

        # parse Elf<64/32>_Sym struct
        elf_sym_s = read_elf_sym_crossplatform(
            elf_sym_struct_ea.frm)

        if not elf_sym_s or elf_sym_s.st_value == idc.BADADDR:
            print(
                f'No st_value in Elf Sym struct. ea: {hex(elf_sym_struct_ea.frm)}. elf_sym struct: {elf_sym_s}')
            continue

        print(f'elf_sym_s address is: {hex(elf_sym_s.st_value)}')

        typeinfo_vtable = TypeInfoVtable(
            symbol_name, demangle(symbol_name), elf_sym_s.st_value)

        typeinfo_vtable.read()
        # using typeinfo offset to search for other typeinfos
        process_class_info(symbol_name, typeinfo_vtable.typeinfo_offset_ea)

    print(f'Completed in {round(time.time() - start_time, 2)}s')
    print(f'Total new classes: {typeinfo_counter}\n\
Total vtables: {vtable_counter}\n\
Total reanmed funcitons {func_counter}')


class BetterRTTIParserPlugin(idaapi.plugin_t):
    flags = 0
    comment = 'Parse RTTI information from executable'
    help = 'Parse RTTI information from executable'
    wanted_name = 'Better RTTI Parser'
    wanted_hotkey = ''

    def init(self):
        return idaapi.PLUGIN_OK

    def run(self, arg):
        process()

    def term(self):
        pass

def PLUGIN_ENTRY():
    try:
        return BetterRTTIParserPlugin()

    except Exception as err:
        import traceback
        print('rtti_parse.py Error: %s\n%s' % str((err), traceback.format_exc()))
        raise

if __name__ == '__main__':
    process()
```

`rtti_parser_core/binary_stream.py`:

```py

import ida_bytes


class IdaBinaryStreamBase:
    def __init__(self, start_ea):
        self.start_ea = start_ea
        self.offset = 0

    def read_byte(self) -> int:
        byte = ida_bytes.get_db_byte(self.start_ea + self.offset)
        self.offset += 1
        return byte

    def read_ushort(self) -> int:
        ushort = ida_bytes.get_word(self.start_ea + self.offset)
        self.offset += 2
        return ushort

    def read_uint(self) -> int:
        uint = ida_bytes.get_dword(self.start_ea + self.offset)
        self.offset += 4
        return uint

    def reset(self) -> None:
        self.offset = 0

    def get_current_position(self) -> int:
        return self.start_ea + self.offset


class Ida64BinaryStream(IdaBinaryStreamBase):
    def __init__(self, start_ea):
        super().__init__(start_ea)

    def read_pointer(self) -> int:
        pointer = ida_bytes.get_qword(self.start_ea + self.offset)
        self.offset += 8
        return pointer


class Ida32BinaryStream(IdaBinaryStreamBase):
    def __init__(self, start_ea):
        super().__init__(start_ea)

    def read_pointer(self) -> int:
        return self.read_uint()

```

`rtti_parser_core/common.py`:

```py
import logging
import re

from collections import namedtuple

import ida_bytes
import ida_typeinf
import idc
import ida_segment
import ida_name
import idaapi
import ida_hexrays
import ida_funcs

from rtti_parser_core.binary_stream import Ida64BinaryStream, Ida32BinaryStream, IdaBinaryStreamBase
from rtti_parser_core.consts import BIT64_MODE, BAD_RET

logger = logging.getLogger(__name__)


class FunctionSignature:
    """
    :param return type:     Return type of function
    :param call_convention: Calling convention used in function
    :param func_name:       Mangled function name
    :param func_args:       Array of type of function arguments

    :ivar ret:              Return type of function
    :ivar conv:             Calling convention used in function
    :ivar func_name:        Mangled function name
    :ivar args:             Array of type of function arguments
    """

    def __init__(self, return_type, call_convention, func_name, func_args):
        self.ret = return_type
        self.conv = call_convention
        self.func_name = func_name
        self.args = func_args

    def make_sig(self):
        return f'{self.ret} {self.conv} {self.func_name}({", ".join(self.args)})'


func_sig_pattern = re.compile(r'(\w+) (__\w+)(?:\()(\w.*)(?:\))')


def string2hex(string, encoding='ascii'):
    """
    String to hex string with space seperation for each byte. Ex: '54 64 0A'
    """
    return bytearray(string, encoding=encoding).hex(' ')


def prepare_data_for_search(data):
    if isinstance(data, str):
        hexstr = string2hex(data)
    elif isinstance(data, bytearray) or isinstance(data, bytes):
        hexstr = data.hex(' ')
    else:
        raise Exception(f'Unsupported type of data {type(data)}')

    return hexstr


def search_75(start_ea, data, search_flags):
    hexstr = prepare_data_for_search(data)
    
    return idc.find_binary(start_ea, search_flags, hexstr)
    
def get_search_down_flag():
    # IDA 7.x
    if hasattr(idc, "SEARCH_DOWN"):
        return idc.SEARCH_DOWN

    # IDA 8.x / 9.x
    if hasattr(ida_bytes, "BIN_SEARCH_FORWARD"):
        return ida_bytes.BIN_SEARCH_FORWARD

    return 0


def get_search_up_flag():
    if hasattr(idc, "SEARCH_UP"):
        return idc.SEARCH_UP
    if hasattr(ida_bytes, "BIN_SEARCH_BACKWARD"):
        return ida_bytes.BIN_SEARCH_BACKWARD
    return 0


def search(data, start_ea=None, end_ea=None, search_flags=None) -> int:
    if start_ea is None:
        start_ea = idc.get_inf_attr(idc.INF_MIN_EA)
    if end_ea is None:
        end_ea = idc.get_inf_attr(idc.INF_MAX_EA)

    if search_flags is None:
        search_flags = get_search_down_flag()

    if idaapi.IDA_SDK_VERSION <= 750:
        return search_75(start_ea, data, search_flags)
    
    pattern_obj = ida_bytes.compiled_binpat_vec_t()

    hexstr = prepare_data_for_search(data)
    print(f"Searching {data} as hexstr {hexstr}")

    ida_bytes.parse_binpat_str(pattern_obj, 0, hexstr, 16)

    return ida_bytes.bin_search(start_ea, end_ea, pattern_obj, search_flags)


def check_compiler_support():
    """
    Check if compiler is supported.

    Currently only GNU C++ is supported
    """
    return ida_typeinf.is_gcc32() or ida_typeinf.is_gcc64()


def is_in_text_segment(ea):
    text_segment = ida_segment.get_segm_by_name('.text')
    if not text_segment:
        raise Exception(
            'No text segment found thus cannot determine if address is in range of executable segment.')
    return text_segment.start_ea <= ea <= text_segment.end_ea


def get_ida_bit_depended_stream(start_ea) -> IdaBinaryStreamBase:
    if BIT64_MODE:
        return Ida64BinaryStream(start_ea)
    else:
        return Ida32BinaryStream(start_ea)


def demangle(mangled_name):
    return ida_name.demangle_name(mangled_name, idc.get_inf_attr(idc.INF_LONG_DEMNAMES))


def get_function_name(ea):
    return idaapi.get_func_name(ea)


def is_vtable_entry(pointer):
    return is_in_text_segment(pointer)


def simplify_demangled_name(name):
    name = name.split("::")[-1] if "::" in name else name
    name = name.split("<")[0]
    invalid_chars = '<> '
    for c in invalid_chars:
        name = name.replace(c, '_')
    return name.strip('_')


def get_function_signature(func_ea) -> FunctionSignature:
    signature = idc.get_type(func_ea)
    if not signature:
        print(
            f'idc.get_type failed at {func_ea:X}'
        )
        return None
        
    parsed_sig = re.match(func_sig_pattern, signature)
    if not parsed_sig:
        print(f'Failed to run re.match for sig: {signature}')
        return None

    return FunctionSignature(
        parsed_sig.group(1),            # return type
        parsed_sig.group(2),            # calling convention
        idc.get_name(func_ea),
        parsed_sig.group(3).split(', ')  # arguments
    )

def make_class_symbol_name(func_ea, typenames):
    """
    Mangles name for class
    :param func_ea:     Function address
    :param typenames:   List of names which will be mangled
    """
    ret = '_ZN'
    
    sig = get_function_signature(func_ea)
    
    for typename in typenames:
        ret += str(len(typename))
        ret += typename

    ret += 'E'
     
    if sig and len(sig.args) == 0:
        ret += 'v'
        
    return ret
        

def make_class_method(func_ea, typename):
    if not typename or typename == "???":
        return False
    sig = get_function_signature(func_ea)
    if not sig:
        return False
    sig.conv = '__thiscall'
    if len(sig.args) == 0:
        sig.args.append("")
    sig.args[0] = typename + '*'
    sig.name = f'sub_{func_ea:X}'
    full_sig = sig.make_sig()
    ret = idc.SetType(func_ea, full_sig)
    return ret


def create_find_struct(name):
    sid = idc.get_struc_id(name)
    # if not, then create it
    if sid != BAD_RET:
        return sid

    # ok, it doesn't exists, so we'll create it
    sid = idc.add_struc(-1, name, None)

    return sid if sid != BAD_RET else None

```

`rtti_parser_core/consts.py`:

```py
import idaapi

def is_64bit():
    # IDA 9.2
    if hasattr(idaapi, "inf_is_64bit"):
        return idaapi.inf_is_64bit()

    # IDA 7.x / 8.x
    info = idaapi.get_inf_structure()
    return info.is_64bit()

BIT64_MODE = is_64bit()

print(BIT64_MODE)

if BIT64_MODE:
    PTR_SIZE = 8
    BAD_RET = 0xffffffffffffffff
else:
    PTR_SIZE = 4
    BAD_RET = 0xffffffff
```

`rtti_parser_core/elf.py`:

```py
import logging

from io import BytesIO
from dataclasses import dataclass

from rtti_parser_core.binary_stream import Ida64BinaryStream
from rtti_parser_core.consts import BIT64_MODE

import idaapi
import idautils
import ida_bytes
import ida_segment

from rtti_parser_core.common import get_ida_bit_depended_stream

logger = logging.getLogger(__name__)


@dataclass()
class Elf_Sym:
    st_name = 0
    st_info = 0
    st_other = 0
    st_shndx = 0
    st_value = 0
    st_size = 0


def read_elf_sym_crossplatform(ea):
    """
    :param ea:  Address of Elf<64/32>_Sym struct.
    :rval:      Return Elf64_Sym struct 

    References:
    https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-79797/index.html
    http://web.mit.edu/freebsd/head/sys/sys/elf64.h
    """

    stream = get_ida_bit_depended_stream(ea)
    print(f'mode {BIT64_MODE}')
    if BIT64_MODE:
        return read_elf64_sym(stream)
    else:
        return read_elf32_sym(stream)


def read_elf64_sym(stream):
    elfsym = Elf_Sym()

    elfsym.st_name = stream.read_uint()
    elfsym.st_info = stream.read_byte()
    elfsym.st_other = stream.read_byte()
    elfsym.st_shndx = stream.read_ushort()
    elfsym.st_value = stream.read_pointer()
    elfsym.st_size = stream.read_pointer()

    return elfsym


def read_elf32_sym(stream):
    elfsym = Elf_Sym()

    elfsym.st_name = stream.read_uint()
    elfsym.st_value = stream.read_pointer()
    elfsym.st_size = stream.read_uint()
    elfsym.st_info = stream.read_byte()
    elfsym.st_other = stream.read_byte()
    elfsym.st_shndx = stream.read_ushort()

    return elfsym


"""
32-bit

/* ELF standard typedefs (yet more proof that <stdint.h> was way overdue) */
typedef uint16_t Elf32_Half;
typedef int16_t Elf32_SHalf;
typedef uint32_t Elf32_Word;
typedef int32_t Elf32_Sword;
typedef uint64_t Elf32_Xword;
typedef int64_t Elf32_Sxword;

typedef uint32_t Elf32_Off;
typedef uint32_t Elf32_Addr;
typedef uint16_t Elf32_Section;

typedef struct elf32_sym {
    Elf32_Word st_name;
    Elf32_Addr st_value;
    Elf32_Word st_size;
    unsigned char st_info;
    unsigned char st_other;
    Elf32_Half st_shndx;
} Elf32_Sym;

64-bit

/* ELF standard typedefs (yet more proof that <stdint.h> was way overdue) */
typedef uint16_t Elf64_Half;
typedef int16_t Elf64_SHalf;
typedef uint32_t Elf64_Word;
typedef int32_t Elf64_Sword;
typedef uint64_t Elf64_Xword;
typedef int64_t Elf64_Sxword;

typedef uint64_t Elf64_Off;
typedef uint64_t Elf64_Addr;
typedef uint16_t Elf64_Section;

typedef struct elf64_sym {
    Elf64_Word st_name;
    unsigned char st_info;
    unsigned char st_other;
    Elf64_Half st_shndx;
    Elf64_Addr st_value;
    Elf64_Xword st_size;
} Elf64_Sym;
"""

```

`rtti_parser_core/rtti.py`:

```py
import logging

import idc
import ida_name
import idautils
import idaapi
import ida_typeinf

from rtti_parser_core.common import create_find_struct, demangle, get_function_name, get_ida_bit_depended_stream, is_in_text_segment, is_vtable_entry, make_class_method, make_class_symbol_name, simplify_demangled_name
from rtti_parser_core import consts
from rtti_parser_core.vtable import Vtable

logger = logging.getLogger(__name__)


class BasicClass:
    """
    Basic class does not inherit from any class

    :ivar ea:           Location of typeinfo for this class
    :ivar type_name:    Type name in mangled form
    :ivar dn_name:      Demangled type name
    :ivar vtable:       Vtable object. See core.vtable.Vtable for more details
    :ivar cls_sid:      Class struct ID from idc.add_struc
    :ivar vtable_sid:   Vtable struct ID from idc.add_struc
    """

    def __init__(self, ea):
        self.ea = ea

        # TODO add support for 32 binary stream
        self.stream = get_ida_bit_depended_stream(ea)
        # there is offset to class table. just ignore it by reading extra pointer ( size depended )
        self.stream.read_pointer()

        self.type_name = None
        self.dn_name = None
        self.vtable = None
        self.cls_sid = None
        self.vtable_sid = None

    def read_name(self):
        mangled_name_ea = self.stream.read_pointer()

        name = idc.get_strlit_contents(
            mangled_name_ea)
        if not name:
            print(f'Could not read C-string at {hex(mangled_name_ea)}')
            return None

        # we need _ZTS prefix to make this name demanglable as string for typeinfo
        # https://github.com/gcc-mirror/gcc/blob/16e2427f50c208dfe07d07f18009969502c25dc8/gcc/cp/mangle.c#L4082 <-- code
        self.type_name = '_ZTS' + name.decode('ascii')

        self.dn_name = demangle(self.type_name)

        if not self.dn_name:
            print(f'Could not demangle {self.type_name}')
            return None

        # if 'name' in self.dn_name:
        self.dn_name = self.dn_name.replace(
            "`typeinfo name for", '').replace('\'', '')

        return self.dn_name

    def read_vtable(self):
        for ref in idautils.DataRefsTo(self.ea):
            
            stream = get_ida_bit_depended_stream(ref - consts.PTR_SIZE)

            if stream.read_pointer() != 0:
                continue

            # ignore. typeinfo address
            stream.read_pointer()

            # get rid of off_xxx
            idc.set_name(stream.get_current_position(),
                         simplify_demangled_name(self.dn_name) + '_vtable')

            self.vtable = Vtable(self.type_name, self.dn_name,
                                 stream.get_current_position())

            self.vtable.read()
            
            break
        return self.vtable

    def read_typeinfo(self):
        """
        No additional typeinfo is present in Basic class
        """
        pass

    def create_class_struct(self):
        # remove everything before :: and inside <>
        typename = simplify_demangled_name(self.dn_name)

        self.cls_sid = create_find_struct(typename)

        return self.cls_sid

    def create_vtable_struct(self):
        # remove everything before :: and inside <>
        typename = simplify_demangled_name(self.dn_name)

        self.vtable_sid = create_find_struct(typename)

        return self.vtable_sid

    def get_class_name(self):
        return [simplify_demangled_name(self.dn_name)]

    def retype_vtable_function(self, typename, func_ea, func_name):
        new_name = make_class_symbol_name(
            func_ea, [*self.get_class_name(), func_name])
        # rename function
        idc.set_name(func_ea, new_name)
        # apply type name to function
        if make_class_method(func_ea, typename):
            print(f'Applied signature to {func_name}')

    def retype_vtable_functions(self):
        for func_ea, _ in self.vtable.entries.items():

            # TODO change to something cross-platform
            if self.vtable_sid == consts.BAD_RET:
                print(
                    'No structure has been created by code. Try to delete it manually for this class')
                break

            typename = idc.get_struc_name(self.vtable_sid)

            custom_name = f'sub_{func_ea:X}'
            self.retype_vtable_function(typename, func_ea, custom_name)


class SiClassFlags:
    virtual_mask = 0x1
    public_mask = 0x2
    offset_shift = 0x8


class SiClass(BasicClass):
    """
    Single-inherited class 

    :ivar base_ea:          Address to typeinfo of inherited class
    :ivar base_typename:    Demangled typename of inherited(base) class
    """

    def __init__(self, ea):
        super().__init__(ea)

        self.base_ea = None
        self.base_typename = None

    def read_typeinfo(self):
        self.base_ea = self.stream.read_pointer()
        self.base_typename = get_typeinfo_dn_name(self.base_ea)

    def get_class_name(self):
        return [
            simplify_demangled_name(self.base_typename),
            simplify_demangled_name(self.dn_name)
        ]


class VmiClassFlags:
    non_diamond_repeat_mask = 0x1
    diamond_shaped_mask = 0x2
    flags_unknown_mask = 0x8


class VmiClass(BasicClass):
    """
    Multi-inherited class
    """

    def __init__(self, ea):
        super().__init__(ea)

        self.flags = None
        self.base_count = 0
        self.bases = {}

    def read_typeinfo(self):
        self.flags = self.stream.read_uint()
        self.base_count = self.stream.read_uint()

        for _ in range(self.base_count):
            base_ea = self.stream.read_pointer()
            flags = self.stream.read_pointer()

            name = get_typeinfo_dn_name(base_ea)

            print(f'[{self.dn_name}] Found base class at {hex(base_ea)}')

            self.bases[base_ea] = get_typeinfo_dn_name(base_ea)

            # demangled_name = demangle(self.bases[base_ea])
            print(
                f'[{self.dn_name}] Found {name} base class at {hex(base_ea)}')

    def get_class_name(self):
        parts = [simplify_demangled_name(dn_name)
                 for dn_name in self.bases.values()]
        return [*parts, simplify_demangled_name(self.dn_name)]


def get_typeinfo_dn_name(typeinfo_ea):
    classtype = BasicClass(typeinfo_ea)
    classtype.read_name()
    return classtype.dn_name

```

`rtti_parser_core/settings.py`:

```py
# format for naming vtable structs
vtable_struct_format = '{}_v'
ida_offset_vtable_format = '{}_vtable'
```

`rtti_parser_core/vtable.py`:

```py
import logging

from collections import namedtuple

from rtti_parser_core.common import get_function_name, get_ida_bit_depended_stream, is_vtable_entry, demangle



class Vtable:
    """
    Vtable class represents vtable type in ida

    :param type_name:   Name of type which corresponds to this vtable
    :param ea:          Address of start of vtable

    :ivar entries:      Represents pointers to class virtual methods
    :ivar dn_name:      Demangled type name
    """

    def __init__(self, type_name, dn_name, ea):
        self.type_name = type_name
        self.dn_name = dn_name
        self.ea = ea

        self.stream = get_ida_bit_depended_stream(ea)
        self.entries = {}

    def add_entry(self, func_ea, func_name):
        self.entries[func_ea] = func_name

    def read(self):
        while True:
            pointer = self.stream.read_pointer()

            if not is_vtable_entry(pointer):
                break

            print(
                f'New vtable entry {self.dn_name}::{demangle(get_function_name(pointer))}'
            )

            self.add_entry(pointer, get_function_name(pointer))


class TypeInfoVtable(Vtable):
    def __init__(self, type_name, dn_name, ea):
        super().__init__(type_name, dn_name, ea)

        self.typeinfo_ea = None
        self.typeinfo_offset_ea = None
        self.vfuncs = []

    def read(self):
        # skip base offset and virtual base offset
        self.stream.read_pointer()
        # read typeinfo address
        self.typeinfo_ea = self.stream.read_pointer()
        # there is offset that used in all other typeinfos
        self.typeinfo_offset_ea = self.stream.get_current_position()
        # destructor
        self.stream.read_pointer()

        while True:
            func_ea = self.stream.read_pointer()

            if not is_vtable_entry(func_ea):
                break

            self.vfuncs.append(func_ea)

```