Project Path: arc_KiFilterFiberContext_windows-software-policy_sl02gfpo

Source Tree:

```txt
arc_KiFilterFiberContext_windows-software-policy_sl02gfpo
├── README.md
├── SystemPolicyInfo
│   ├── SystemPolicyInfo.vcxproj
│   ├── SystemPolicyInfo.vcxproj.filters
│   ├── defs.h
│   └── example.c
├── SystemPolicyInfo.sln
└── clipsp-unpack.py

```

`README.md`:

```md
# SystemPolicyInfo
Research on the client licensing system in the Windows kernel exposed from the `SystemPolicyInformation` class in the `NtQuerySystemInformation` system call.

## Overview
There are two primary usermode services that interact directly with client licensing: `clipc.dll` (Client Licensing Platform Client) and `clipsvc.dll` (Client License Service).  The kernel image that handles client license queries is `clipsp.sys` (Client License System Policy).  As the focus is on the internals of the licensing routines in the kernel, not much will be mentioned about the usermode services.

The client starts the license service through the service manager and communicates with the service through [remote procedure calls (RPC)](https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page).  The service registers several handlers that are used in the [Software Licensing API](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/secslapi/software-licensing-api-portal).  

Handlers that must interface with kernel licensing information will invokve `NtQuerySystemInformation` with the `SystemPolicyInformation` information class.  The `SystemPolicyInformation` class structure for data transfer has been documented by [Geoff Chappell](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/policy.htm).  The structure is shown below:
```cpp
typedef struct _SYSTEM_POLICY_INFORMATION
{
    PVOID InputData;
    PVOID OutputData;
    ULONG InputSize;
    ULONG OutputSize;
    ULONG Version;
    NTSTATUS Status;
} SYSTEM_POLICY_INFORMATION, * PSYSTEM_POLICY_INFORMATION;
```
The reference page in MSDN for the information class offers an even more incomplete structure and suggests using the higher-level SL API.  As such, the internal structures used by the kernel are undocumented.  Every internal structure documented in my research has been reverse engineered and named according to its inferred usage and may not accurately reflect the actual internal use.  

## Input Structure
Brief reverse engineering of the ClipSVC license handlers reveal that input and output structures are encrypted and decrypted using a cipher implemented by Microsoft's internal obfuscator: WarBird.  
```cpp
// setup decryption cipher and key
pDecryptionCipher = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0xA0);

if ( !pDecryptionCipher )
    goto LABEL_2;

decryptionCipher = pDecryptionCipher;       

*pDecryptionCipher = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[0];
pDecryptionCipher[1] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[1];
pDecryptionCipher[2] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[2];
pDecryptionCipher[3] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[3];
pDecryptionCipher[4] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[4];
pDecryptionCipher[5] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[5];
pDecryptionCipher[6] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[6];
pDecryptionCipher[7] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[7];
pDecryptionCipher[8] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[8];
pDecryptionCipher[9] = `WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher[9];

pDecryptionKey = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 8);
if ( !pDecryptionKey )
{
    LABEL_2:
    ReturnStatus = STATUS_NO_MEMORY;
    goto END;
}
decryptionKey = pDecryptionKey;
*pDecryptionKey = `WarbirdUmGetDecryptionKey'::`2'::nDecryptionKey;
```

Microsoft WarBird has been researched in prior years and exposes various different obfuscation passes including virtual-machine obfuscation, code packing, and even functionality integrated the windows kernel to [decrypt and execute signed payloads on the heap using a feistel cipher](https://www.youtube.com/watch?v=gu_i6LYuePg) by exposing a special system information class: `SystemControlFlowTransition`. 

The internal structure parsed by the kernel consists three blocks of data containing the encrypted data, the decryption arguments for the WarBird cipher, and a 64bit decryption key.  The decrypted input data contains the policy information type, argument count, and the cipher arguments and key to encrypt the data.  An XOR checksum for the decrypted data is appended onto the encrypted data and is verified after decryption.  The decryption cipher block is formatted with arguments for cipher subroutines positioned at the top and arguments at the bottom.  The kernel will pass the parameters in reverse order for 16 iterations.  The keys and cipher arguments are hardcoded depending on the policy class.
```cpp
// +-------------------+ +-------------------+
// |       Size        | |                   |        Block B
// +-------------------+ +-------------------+     ------------  0x0
// |                   | |                   |  ^
// |                   | |    0xC998E51B     |  |
// |   Function Args   | |    0xA3A9632E     |  |
// |      8 bytes      | |                   |  |    128 bytes
// |                   | |                   |  |
// |                   | |    0x00000000     |  |
// |                   | |                   |  |
// +-------------------+ +-------------------+      ----------   0x7E
// |                   | |                   |
// |    Fn Ptr Index   | |    0x050B1902     |  ^    32 bytes
// |      2 bytes      | |    0x1F1F1F1F     |  |                0x9E
// +-------------------+ +-------------------+  |   ----------   0xA0
typedef struct _WB_CIPHER
{
    UCHAR FnArgs[128];
    UCHAR FnIndex[32];
} WB_CIPHER, * WB_CIPHER;

typedef struct PWB_KEY
{
    ULONGLONG Key;
} WB_KEY, * PWB_KEY;

typedef struct _SP_ENCRYPTED_HEADER
{
    UCHAR EncryptedBody[ SP_DATA_SIZE ];
    ULONGLONG XorChkKey;
} SP_ENCRYPTED_HEADER;

typedef struct _SP_ENCRYPTED_DATA
{
    ULONG EncryptedDataSize;
    SP_ENCRYPTED_HEADER EncryptedHeaderData;

    ULONG DecryptArgSize;
    WB_CIPHER DecryptArgs;

    ULONG KeySize;
    WB_KEY DecryptKey;
} SP_ENCRYPTED_DATA, * PSP_ENCRYPTED_DATA;
```

The decrypted input structure contains the amount of parameters relative to the policy information type and a header that specifies the information type along with arguments needed for the WarBird cipher to encrypt the data.
```cpp
typedef struct _SP_DECRYPTED_HEADER
{
    ULONG PolicyTypeSize;
    SYSTEM_POLICY_CLASS PolicyType;

    ULONG EncyptArgSize;
    WB_CIPHER EncryptArgs;

    ULONG KeySize;
    WB_KEY EncryptKey;

    SP_BODY Body;
} SP_DECRYPTED_HEADER;

typedef struct _SP_DECRYPTED_DATA
{
    ULONG ParameterCount;
    ULONG DecryptedSize;

    SP_DECRYPTED_HEADER HeaderData;

    ULONG a;
    USHORT b;
} SP_DECRYPTED_DATA;
```
Once the WarBird cipher and keys needed to encrypt and decrypt the data are prepared, the data is encrypted and execution is passed onto `NtQuerySystemInformation`.  The information class switch table will eventually dispatch the data to `SPCall2ServerInternal`, where it will decrypt and verify the data and invoke one of the internal license routines.  A few of the reversed policy classes are shown:
```cpp
typedef enum _SYSTEM_POLICY_CLASS
{
    QueryPolicy,
    UpdatePolicies,
    AuthenticateCaller,
    WaitForDisplayWindow = 5,
    FileUsnQuery = 22,
    FileIntegrityUpdate,
    FileIntegrityQuery,
    UpdateLicense = 100,
    RemoveLicense,
    NotImplemented,
    CreateLicenseEfsHeader,
    LicenseEfsHeaderContainsFek,
    GetLicenseChallange,
    GetBaseContentKeyFromLicense,
    GetBaseContentKeyFromKeyID,
    IsAppLicensed = 109,
    DumpLicenseGroup,
    Clear,
    ClepSign,
    ClepKdf,
    UpdateOsLicenseBlob = 204, 
    CheckLicense,
    GetCurrentHardwareID,
    CreateLicenseKeyIDEfsHeader,
    GetAppPolicyValue,
    QueryCachedOptionalInfo,
    AcRequest,
    AcHmac,
    UpdateImdsResponse
} SYSTEM_POLICY_CLASS;
```
## License Initialization
A few of the licensing routines will further dispatch to a function located in a global table, `nt!g_kernelCallbacks`.  This global function table contains function pointers inside of `clipsp.sys`, which handles client license system policy.  During license data initialization, the kernel will first setup license state in a global server silo (`PspHostSiloGlobals->ExpLicenseState`) and will load license values from the registry under `ProductOptions`.  It will then call `ExInitLicenseData` which will update the license data and setup [Kernel Data Protection](https://www.microsoft.com/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-platform-security-technology-for-preventing-data-corruption/).  The routine will eventually call `ClipInitHandles`, which initializes globals used for client licensing callbacks along with `g_kernelCallbacks`.  The kernel does not actually setup the global kernel callback table in `ClipInitHandles`, but instead it will pass the table to `ClipSpInitialize` located in `clipsp.sys`.  

## Code Unpacking

The client licensing system policy image (`clipsp`) is responsible for handling the internals of system policy functionality in the kernel.  As such, it is obfuscated with Microsoft WarBird to prevent reverse engineering.  The image contains several sections with high entropy (`PAGEwx1` etc.) and names that indicate it will be unpacked and executed during runtime.

Clipsp will call upon the Warbird Runtime to unpack the code prior to execution and repack afterward.  The functions will allocate several [memory descriptor lists](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls)  (MDLs) to remap the physical pages to a rwx virtual address in system space.  Dumping the image at runtime will not be reliable as the sections are repacked after execution and only those necessary for execution will be unpacked.  A simple method to automatically unpack the sections is to emulate the decryption routines with a binary emulation framework such as Qiling.  I have written a simple [unpacker script](https://github.com/encls/SystemPolicyInfo/blob/master/clipsp-unpack.py) in Python that will emulate various kernel APIs and dump the unpacked section once the MDL is freed.

## License Internals
Further analysis can be done after replacing the packed sections with the unpacked code.  `ClipSpInitialize` will call onto `SpInitialize` to populate `g_kernelCallbacks`, setup registry keys and initialize [CNG Providers](https://docs.microsoft.com/en-us/windows/win32/seccertenroll/understanding-cryptographic-providers) and crytographic keys.

![image](https://user-images.githubusercontent.com/51222153/155431170-b1926650-e231-4bb7-a11e-ce54b9933f53.png)

The `SpInitializeDeviceExtension` subroutine will first verify access rights to a special registry key located at `\\Registry\\Machine\\System\\CurrentControlSet\\Control\\{7746D80F-97E0-4E26-9543-26B41FC22F79}` reserved for digital entitlement.  Access to the specific registry key is intended only for license use and attempts at accessing it from an unprivileged process will result in `ACCESS_DENIED`.  Furthermore, it will access several subkeys under the same key including `{A25AE4F2-1B96-4CED-8007-AA30E9B1A218}`, `{D73E01AC-F5A0-4D80-928B-33C1920C38BA}`, `{59AEE675-B203-4D61-9A1F-04518A20F359}`, `{FB9F5B62-B48B-45F5-8586-E514958C92E2}` and `{221601AB-48C7-4970-B0EC-96E66F578407}`.

Further reverse engineering of the individual callbacks requires reverse engineering of the `_EXP_LICENSE_STATE` structure in `_ESERVERSILO_GLOBALS`.

## References
- [Reversal of Warbird integration in the MSVC compiler](https://github.com/KiFilterFiberContext/warbird-obfuscate)
- [Warbird Runtime Reversed Engineered Code](https://github.com/KiFilterFiberContext/microsoft-warbird/)
- [Hooking ClipSp.sys for encrypted shellcode execution](https://github.com/KiFilterFiberContext/warbird-hook/)

```

`SystemPolicyInfo.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30907.101
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SystemPolicyInfo", "SystemPolicyInfo\SystemPolicyInfo.vcxproj", "{0CED21CD-A302-40C6-840F-DF68FBB845C5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Debug|x64.ActiveCfg = Debug|x64
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Debug|x64.Build.0 = Debug|x64
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Debug|x86.ActiveCfg = Debug|Win32
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Debug|x86.Build.0 = Debug|Win32
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Release|x64.ActiveCfg = Release|x64
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Release|x64.Build.0 = Release|x64
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Release|x86.ActiveCfg = Release|Win32
		{0CED21CD-A302-40C6-840F-DF68FBB845C5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8A7443DC-8BF6-40B0-B777-03A8B1D76BB1}
	EndGlobalSection
EndGlobal

```

`SystemPolicyInfo/SystemPolicyInfo.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{0ced21cd-a302-40c6-840f-df68fbb845c5}</ProjectGuid>
    <RootNamespace>SystemPolicyInfo</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="example.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SystemPolicyInfo/SystemPolicyInfo.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="example.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`SystemPolicyInfo/defs.h`:

```h
#pragma once


//
// struct naming is inferred
//

//
// -- clipsp overview (wip) --
// naming convention: Client License System Policy
//
// clipsp has no valid PDB in the MS symbol server unlike most system libraries
// loading the PDB in IDA will produce invalid instruction disassembly in sections
// however, symbol information is present in the pdb file
//
// llvm-pdbutil.exe dump -publics .\clipsp.pdb | Select-String ClipSp
// 
// 46852 | S_PUB32[ size = 44 ] `ClipSpIsDeviceLicensePresent`
// 55992 | S_PUB32[ size = 52 ] `ClipSpInsertTBActivationPolicyValue`
// 59096 | S_PUB32[ size = 32 ] `ClipSpDecryptFek`
// 35228 | S_PUB32[ size = 52 ] `ClipSpCreateDirectoryLicenseHeader`
// 45600 | S_PUB32[ size = 36 ] `ClipSpIsAppLicensedEx`
// 56444 | S_PUB32[ size = 36 ] `ClipSpIsWindowsToGo`
// 32460 | S_PUB32[ size = 40 ] `ClipSpDumpLicenseGroup`
// 48524 | S_PUB32[ size = 36 ] `ClipSpUpdateLicense`
// 71156 | S_PUB32[ size = 36 ] `ClipSpUninitialize`
// 36808 | S_PUB32[ size = 52 ] `ClipSpCreateFileLicenseHeaderAndKey`
// 61420 | S_PUB32[ size = 32 ] `ClipSpAcRequest`
// 38676 | S_PUB32[ size = 72 ] `_tlgDefineProvider_annotation__Tlgg_hClipSpProviderProv`
// 30388 | S_PUB32[ size = 28 ] `ClipSpFreeFek`
// 72560 | S_PUB32[ size = 28 ] `ClipSpClear`
// 35508 | S_PUB32[ size = 48 ] `ClipSpQueryLicenseValueFromHost`
// 60680 | S_PUB32[ size = 48 ] `ClipSpLicenseEfsHeaderContainsFek`
// 34312 | S_PUB32[ size = 36 ] `ClipSpCheckLicense`
// 47976 | S_PUB32[ size = 40 ] `ClipSpGetLicenseChallange`
// 45532 | S_PUB32[ size = 32 ] `ClipSpClepSign`
// 62960 | S_PUB32[ size = 28 ] `ClipSpClepKdf`
// 51836 | S_PUB32[ size = 36 ] `ClipSpDecryptFekEx`
// 70332 | S_PUB32[ size = 48 ] `ClipSpGetBaseContentKeyFromKeyID`
// 46224 | S_PUB32[ size = 36 ] `ClipSpRemoveLicense`
// 36164 | S_PUB32[ size = 56 ] `ClipSpGetActivationPolicyValueFromCache`
// 38064 | S_PUB32[ size = 44 ] `ClipSpGetCurrentHardwareID`
// 35636 | S_PUB32[ size = 44 ] `ClipSpQueryCachedOptionalInfo`
// 38476 | S_PUB32[ size = 52 ] `ClipSpGetBaseContentKeyFromLicense`
// 63444 | S_PUB32[ size = 28 ] `ClipSpAcHmac`
// 37552 | S_PUB32[ size = 28 ] `ClipSpDump`
// 34520 | S_PUB32[ size = 32 ] `ClipSpInitialize`
// 40992 | S_PUB32[ size = 48 ] `ClipSpCreateLicenseKeyIDEfsHeader`
// 40288 | S_PUB32[ size = 40 ] `ClipSpUpdateOsLicenseBlob`
// 49032 | S_PUB32[ size = 36 ] `ClipSpIsAppLicensed`
// 57056 | S_PUB32[ size = 44 ] `ClipSpCreateLicenseEfsHeader`
// 56076 | S_PUB32[ size = 40 ] `ClipSpGetAppPolicyValue`
//
//
// clipsp contains 6 PAGEwx sections with high (over 7) entropy
// potentially contains packed code
// service routine segments (.PAGEwx) must be unpacked prior to execution
//
// likely protected by WarBird (microsoft obfuscator)
// pdb file info includes WarbirdRuntimeGenAsm object file 
//
// nt!g_kernelCallbacks contain callbacks for system policy services
// kd> dqs nt!g_kernelCallbacks
// fffff801`32d3b350  00000000`00000001
// fffff801`32d3b358  fffff801`354c6c20 clipsp + 0xb6c20
// fffff801`32d3b360  fffff801`354c2c30 clipsp + 0xb2c30
// ...
//
// g_kernelCallbacks is initialized in clipsp!ClipSpInitialize
// nt!PspInitializeServerSiloDeferred -> unnamed function -> nt!ExInitLicenseData -> nt!ClipInitHandles -> clipsp!ClipSpInitialize
//
// license policy initialized from registery hive ControlSet001\Control\ProductOptions 
// license state stored in PspHostSiloGlobals->ExpLicenseState
// license state structure (_EXP_LICENSE_STATE) is undocumented in pdb type info 
//
// usermode interfaces with the software licensing API
// calls into clipc.dll (client licensing platform client) ?
// 
// global symbols reveal usage of Warbird UM cipher to encrypt/decrypt data passed into the system policy kernel service
// WarbirdUmGetDecryptionCipher'::`2'::DecryptionCipher and WarbirdUmGetDecryptionKey'::`2'::nDecryptionKey
// WarbirdUmGetEncryptionCipher'::`2'::EncryptionCipher and WarbirdUmGetEncryptionKey'::`2'::nEncryptionKey
//
// ... deal with clipsp unpacking...

//
// 4 bytes (ulong)
// methods are mostly undocumented or have no symbol names
//
typedef enum _SYSTEM_POLICY_CLASS
{
    QueryPolicy,
    UpdatePolicies,
    AuthenticateCaller,
    WaitForDisplayWindow = 5,
    FileUsnQuery = 22,
    FileIntegrityUpdate,
    FileIntegrityQuery,
    UpdateLicense = 100,
    RemoveLicense,
    NotImplemented,
    GetLicenseChallenge = 105,
    IsAppLicensed = 109,
    ClepSign = 112,
    ClepKdf,
    UpdateOsPfnInRegistry = 204, 
    CheckLicense,
    GetCurrentHardwareID,
    GetAppPolicyValue = 208
} SYSTEM_POLICY_CLASS;

//
// 160 byte structure
// used for decrypting and encrypting policy data
// +-------------------+ +-------------------+
// |       Size        | |                   |        Block B
// +-------------------+ +-------------------+     ------------  0x0
// |                   | |                   |  ^
// |                   | |    0xC998E51B     |  |
// |   Function Args   | |    0xA3A9632E     |  |
// |      8 bytes      | |                   |  |    128 bytes
// |                   | |                   |  |
// |                   | |    0x00000000     |  |
// |                   | |                   |  |
// +-------------------+ +-------------------+      ----------   0x7E
// |                   | |                   |
// |    Fn Ptr Index   | |    0x050B1902     |  ^    32 bytes
// |      2 bytes      | |    0x1F1F1F1F     |  |                0x9E
// +-------------------+ +-------------------+  |   ----------   0xA0
// 
typedef struct _WB_CIPHER
{
    //
    // arguments to encryption routines (starts from second to last)
    // index A routine: (i-6, i-5, i-4, i-3) 
    // index B routine: (i-2, i-1, i, i+1)
    //
    UCHAR FnArgs[128];

    //
    // index for encryption routine fn table (starts from second to last)
    // only called when index is below 0x1F
    // copied in two byte pairs (A, B)
    //
    UCHAR FnIndex[32];
} WB_CIPHER, * PWB_CIPHER;

//
// key used in argument encryption andd decryption
// 64 bit
//
typedef struct PWB_KEY
{
    ULONGLONG Key;
} WB_KEY, * PWB_KEY;

//
// licensemanagerapi!InvokeLicenseManagerRequired -> NtQuerySystemInformation -> ExpQuerySystemInformation -> ExHandleSPCall2 -> SPCall2ServerInternal -> SPCallServerHandleIsAppLicensed -> (no symbols) nt!g_kernelCallbacks[13] (ClipSpIsAppLicensed)
//
typedef struct _SP_APP_LICENSED_BODY
{
    ULONG UnknownSizeA;
    ULONGLONG UnknownA; // de d0 a6 da a5 10 00 00

    ULONG UnknownSizeB;
    ULONG UnknownB; // 3

    ULONG MaxStringSize;
    WCHAR AppName[ANYSIZE_ARRAY];

    ULONG UnknownSizeC; 
    WCHAR UnknownWideChar; // 0x00 
    
    ULONG UnknownSizeD; // 0x1c
    UCHAR UnknownD[28]; // 01 05 00 00 00 00 00 05 15 00 00 00 79 da-c9 84 23 e2 f9 82 2c 25 c0 58 e8 03 00 00

    ULONG UnknownSizeE;
    ULONG UnknownE; // 2
} SP_APP_LICENSED_BODY;

//
// Decrypted header
// Size specified in decrypted data
//
typedef struct _SP_DECRYPTED_HEADER
{
    ULONG PolicyTypeSize;
    SYSTEM_POLICY_CLASS PolicyType;

    ULONG EncyptArgSize;
    WB_CIPHER EncryptArgs;

    ULONG KeySize;
    WB_KEY EncryptKey;

    // SLS_APP_LICENSED_BODY Body;
} SP_DECRYPTED_HEADER;

//
// > 8 bytes
// encrypted data appended with xor checksum of decrypted data
//
typedef struct _SP_ENCRYPTED_HEADER
{
    UCHAR EncryptedBody[ANYSIZE_ARRAY];
    ULONGLONG XorChkKey;
} SLS_ENCRYPTED_HEADER;

//
// encrypted input size - 8 bytes (removing XorChkKey?)
// decrypted header data from block B decryption routine
//
typedef struct _SP_DECRYPTED_DATA
{
    ULONG ParameterCount;
    ULONG DecryptedSize;

    SP_DECRYPTED_HEADER HeaderData;

    ULONG a;
    USHORT b;
} SP_DECRYPTED_DATA;

//
// input/output structure for system call
// block sizes + 12 must equal input length
//
typedef struct _SP_ENCRYPTED_DATA
{
    ULONG EncryptedDataSize;
    SLS_ENCRYPTED_HEADER EncryptedHeaderData;

    ULONG DecryptArgSize;
    WB_CIPHER DecryptArgs;

    ULONG KeySize;
    WB_KEY DecryptKey;
} SP_ENCRYPTED_DATA, * PSP_ENCRYPTED_DATA;

//            Data
// +-------------------------+
// |                         |
// |         Header          |
// +-------------------------+
// |                         |
// |                         |
// |                         |
// |                         |
// |                         |
// |                         |
// |          Body           |
// |                         |
// |                         |
// |                         |
// |                         |
// |                         |
// |                         |
// |                         |
// +-------------------------+
//

//
// 48 bytes
// struct manages all three policy blocks in kernel
// initial data is copied from POLICY_BLOCK header
// block data is allocated on paged pool (SLS software licensing server tag) and holds POLICY_BLOCK info
//
typedef struct _SP_DATA
{
    //
    // BlockA size > 0x8
    //
    ULONG EncryptedDataSize;
    ULONG ReservedA;
    PSP_ENCRYPTED_DATA EncryptedData;

    //
    // BlockB size == 0xA0 (160)
    //
    ULONG EncyptDecryptArgSize;
    ULONG ReservedB;
    PWB_CIPHER EncryptDecryptArgs;

    //
    // BlockC size == 0x8
    //
    ULONG KeySize;
    ULONG ReservedC;
    PWB_KEY EncryptDecryptKey;
} SP_DATA;

```

`SystemPolicyInfo/example.c`:

```c
#include <stdio.h>
#include <windows.h>
#include <stdint.h>

#include "defs.h"

typedef NTSTATUS( NTAPI* pNtQuerySystemInformation )( ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength );

#define SystemPolicyInformation 134

//
// constant encryption/decryption keys and context 
// SPCallServerHandleIsAppLicensed
//
static const uint8_t DECRYPT_ARGS[ 128 ] = {
    0xc9, 0x98, 0xe5, 0x1b, 0xa3, 0xa9, 0x63, 0x2e, 0x56, 0xe1, 0xe2, 0x53, 0xe0, 0x65, 0x77, 0x7c,
    0x3e, 0x26, 0x3d, 0x34, 0x5f, 0xb9, 0x87, 0xce, 0x86, 0xa9, 0xe7, 0xf2, 0x98, 0x08, 0x83, 0x14,
    0x85, 0x1e, 0x83, 0x91, 0x9d, 0xbd, 0x3c, 0xc3, 0x22, 0x0c, 0x21, 0xbe, 0x4a, 0x78, 0x05, 0xb2,
    0xce, 0x2d, 0x0e, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t DECRYPT_INDEX[ 32 ] = {
    0x1d, 0x0e, 0x0f, 0x09, 0x1b, 0x01, 0x1a, 0x18, 0x1e, 0x05, 0x0b, 0x19, 0x02, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f
};

static const uint64_t DECRYPT_KEY = 0x584ab5b117cb1ec8;

static const uint8_t ENCRYPT_ARGS[ 128 ] = {
    0x95, 0x97, 0x99, 0xc4, 0x2f, 0x89, 0xc6, 0x57, 0x24, 0x4e, 0x89, 0x6e, 0x58, 0x98, 0x8d, 0x2f,
    0x22, 0xd9, 0xde, 0xbf, 0x11, 0x69, 0x56, 0xdc, 0x39, 0xf1, 0xe6, 0x44, 0xbb, 0x2e, 0xb3, 0x4c,
    0xa9, 0x08, 0x59, 0x23, 0x9a, 0x62, 0x56, 0x6e, 0x7b, 0xda, 0xd3, 0xf1, 0x1e, 0x22, 0x42, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const uint8_t ENCRYPT_INDEX[ 32 ] = {
    0x14, 0x02, 0x0f, 0x0c, 0x16, 0x19, 0x1c, 0x09, 0x03, 0x15, 0x06, 0x1d, 0x1f, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f
};

static const uint64_t ENCRYPT_KEY = 0x5e6069ab7f13f107;


typedef struct _SYSTEM_POLICY_INFORMATION
{
    PVOID InputData;
    PVOID OutputData;
    ULONG InputSize;
    ULONG OutputSize;
    ULONG Version;
    NTSTATUS Status;
} SYSTEM_POLICY_INFORMATION, * PSYSTEM_POLICY_INFORMATION;

int main( void )
{
    NTSTATUS status = 0;
    ULONG RetLength = 0;

    pNtQuerySystemInformation NtQuerySystemInformation = ( pNtQuerySystemInformation ) GetProcAddress( GetModuleHandleW( L"ntdll.dll" ), "NtQuerySystemInformation" );
    if ( !NtQuerySystemInformation )
        return 1;

    SYSTEM_POLICY_INFORMATION PolicyInput;

    //
    // input structure
    //
    SLS_ENCRYPTED_DATA EncryptedData;

    SLS_DECRYPTED_DATA DecryptedData;
    SLS_DECRYPTED_HEADER SPDecryptedHdr;

    SLS_ENCRYPT_DECRYPT_ARGS SPDecryptArgs;
    SLS_KEY SPDecryptKey;

    SLS_ENCRYPT_DECRYPT_ARGS SPEncryptArgs;
    SLS_KEY SPEncryptKey;

    //
    // setup initial decrypted (original) data
    //
    DecryptedData.ParameterCount = 9;  // depends on system policy type
    DecryptedData.DecryptedSize = 382; // EncryptedSize (w/out xorkey) - 14 decimal (280)

    SPDecryptedHdr.PolicyTypeSize = sizeof( ULONG );
    SPDecryptedHdr.PolicyType = IsAppLicensed;

    RtlZeroMemory( &SPDecryptArgs, sizeof( SLS_ENCRYPT_DECRYPT_ARGS ) );

    //
    // setup input data decryption keys
    //
    SPDecryptKey.Key = DECRYPT_KEY;

    //
    // setup input data decrypt arguments
    //
    memcpy( SPDecryptArgs.FnArgs, DECRYPT_ARGS, 128 );
    memcpy( SPDecryptArgs.FnIndex, DECRYPT_INDEX, 32 );

    RtlZeroMemory( &SPEncryptArgs, sizeof( SLS_ENCRYPT_DECRYPT_ARGS ) );

    const WCHAR* app = L"Microsoft.XboxIdentityProvider_12.67.21001.0_x64__8wekyb3d8bbwe";

    status = NtQuerySystemInformation( SystemPolicyInformation, &PolicyInput, sizeof( SYSTEM_POLICY_INFORMATION ), &RetLength );
    printf( "status: 0x%08x\nlength: %i\n", status, RetLength );

    return 0;
}

```

`clipsp-unpack.py`:

```py
from qiling.os.windows.const import *
from qiling.os.windows.fncc import *
from qiling.os.const import *
from qiling.os.windows.utils import *
from qiling.os.windows.thread import *
from qiling.os.windows.handle import *
from qiling.exception import *
from qiling.os.windows.api import *
from qiling.os.windows.structs import *
from qiling import *

@winsdkapi(cc=STDCALL, replace_params={"FastMutex": POINTER})
def hook_ExAcquireFastMutex(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={"FastMutex": POINTER})
def hook_ExReleaseFastMutex(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={"FastMutex": POINTER})
def hook_KeReleaseGuardedMutex(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={
        "VirtualAddress": POINTER,
        "Length": ULONG,
        "SecondaryBuffer": BOOLEAN,
        "ChargeQuota": BOOLEAN,
        "Irp": POINTER,
    })
def hook_IoAllocateMdl(ql, address, params):
    objcls = {
        QL_ARCH.X86   : MDL32,
        QL_ARCH.X8664 : MDL64
    }[ql.archtype]

    mdl = objcls() # MDL64()
    addr = ql.os.heap.alloc(ctypes.sizeof(objcls))  

    mdl.Next.value = 0
    mdl.Size = params['Length']
    mdl.MdlFlags = 1 # locked
    mdl.Process.value = ql.eprocess_address    
    mdl.MappedSystemVa.value = params['VirtualAddress']
    mdl.StartVa.value = params['VirtualAddress']
    mdl.ByteCount = params['Length']
    mdl.ByteOffset = 0

    ql.mem.write(addr, bytes(mdl)[:])
    
    return addr


@winsdkapi(cc=STDCALL, replace_params={"MemoryDescriptorList": POINTER,"AccessMode": ULONG,"Operation": ULONG})
def hook_MmProbeAndLockPages(ql, addr, params):
    return None


# might need to update MDL VA member
@winsdkapi(cc=STDCALL, replace_params={
        "MemoryDescriptorList": POINTER,
        "VirtualAddress": POINTER,
        "Size": ULONG,
        "Flags": ULONG,
    })
def hook_MmChangeImageProtection(ql, addr, params):
    return True


@winsdkapi(cc=STDCALL, replace_params={"AddressWithinSection": POINTER})
def hook_MmLockPagableImageSection(ql, addr, params):
    return params["AddressWithinSection"]


@winsdkapi(cc=STDCALL, replace_params={"ImageSectionHandle": POINTER})
def hook_MmUnlockPagableImageSection(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={"MemoryDescriptorList": POINTER})
def hook_MmUnlockPages(ql, addr, params):
    MemoryDescriptorList = params['MemoryDescriptorList']
    
    if ql.archtype == QL_ARCH.X8664:
        mdl_buffer = ql.mem.read(MemoryDescriptorList, ctypes.sizeof(MDL64))
        mdl = MDL64.from_buffer(mdl_buffer)
        mdl.Flags = 0 
    else:
        mdl_buffer = ql.mem.read(MemoryDescriptorList, ctypes.sizeof(MDL32))
        mdl = MDL32.from_buffer(mdl_buffer)
        mdl.Flags = 0

    ql.mem.write(addr, bytes(mdl)[:])


@winsdkapi(cc=STDCALL, replace_params={"Mdl": POINTER})
def hook_IoFreeMdl(ql, address, params):
    addr = params['Mdl']
    
    if ql.archtype == QL_ARCH.X8664:
        mdl_buffer = ql.mem.read(addr, ctypes.sizeof(MDL64))
        mdl = MDL64.from_buffer(mdl_buffer)
    else:
        mdl_buffer = ql.mem.read(addr, ctypes.sizeof(MDL32))
        mdl = MDL32.from_buffer(mdl_buffer)

    size = mdl.Size
    va = mdl.StartVa.value

    print(f"Dumping {hex(size)} bytes to section_{hex(va)}")
    
    mem = ql.mem.read(va, size)
    with open(f"section_{hex(va)}", "wb") as f:
        f.write(mem)
    
    ql.os.heap.free(addr)
    
    return None


@winsdkapi(cc=STDCALL, replace_params={"BaseAddress": POINTER, "MemoryDescriptorList": POINTER})
def hook_MmUnmapLockedPages(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={"PushLock": POINTER, "Flags": ULONG})
def hook_FltAcquirePushLockSharedEx(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={"PushLock": POINTER, "Flags": ULONG})
def hook_FltAcquirePushLockExclusiveEx(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={"PushLock": POINTER, "Flags": ULONG})
def hook_FltReleasePushLockEx(ql, addr, params):
    return None


@winsdkapi(cc=STDCALL, replace_params={"PushLock": POINTER})
def hook_FltInitializePushLock(ql, addr, params):
    return None


# read string from memory address
def readstr_wide(ql, addr):
    res = ""
    while True:
        # read one byte at a time
        c = ql.mem.read(addr, 2).decode()
        if c == '\x00\x00':
            break
        res += c
        addr += 2
    return res


@winsdkapi(cc=STDCALL, replace_params={
        "SourceID": POINTER,
        "CustomValue": POINTER,
        "DefaultPath": POINTER,
        "StateLocationType": ULONG,
        "TargetPath": POINTER,
        "BufferLengthIn": ULONG,
        "BufferLengthOut": POINTER,
    })
def hook_RtlGetPersistedStateLocation(ql, address, params):
    srcid = params["SourceID"]
    custom = params["CustomValue"]
    state_type = params["StateLocationType"]
    target = params["TargetPath"]

    keys = ["\Registry\Machine\System\CurrentControlSet\Control\StateSeparation\RedirectionMap\Keys",
            "\Registry\Machine\System\CurrentControlSet\Control\StateSeparation\RedirectionMap\Files"]

    key = keys[state_type]
    
    print(f"key: {key}")
    print(f"srcid: {readstr_wide(ql, srcid)} {readstr_wide(ql, custom)}")
    
    ql.os.registry_manager.access(key)
    
    return 0


def trace(ql, address, size, md):
    buf = ql.mem.read(address, size)
    for i in md.disasm(buf, address):
        print(":: 0x%x:\t%s\t%s" %(i.address, i.mnemonic, i.op_str))


if __name__ == "__main__":
    ql = Qiling(["ClipSp.sys"], "D:\\qiling\\examples\\rootfs\\x8664_windows", verbose=QL_VERBOSE.DEBUG)

    md = ql.create_disassembler()
    md.detail = True

    ql.set_api("ExAcquireFastMutex", hook_ExAcquireFastMutex)
    ql.set_api("ExReleaseFastMutex", hook_ExReleaseFastMutex)
    ql.set_api("IoAllocateMdl", hook_IoAllocateMdl)
    ql.set_api("MmProbeAndLockPages", hook_MmProbeAndLockPages)
    ql.set_api("MmChangeImageProtection", hook_MmChangeImageProtection)
    ql.set_api("MmLockPagableImageSection", hook_MmLockPagableImageSection)
    ql.set_api("MmUnlockPages", hook_MmUnlockPages)
    ql.set_api("IoFreeMdl", hook_IoFreeMdl)
    ql.set_api("MmUnmapLockedPages", hook_MmUnmapLockedPages)
    ql.set_api("KeReleaseGuardedMutex", hook_KeReleaseGuardedMutex)
    ql.set_api("FltAcquirePushLockSharedEx", hook_FltAcquirePushLockSharedEx)
    ql.set_api("FltReleasePushLockEx", hook_FltReleasePushLockEx)
    ql.set_api("MmUnlockPagableImageSection", hook_MmUnlockPagableImageSection)
    ql.set_api("FltAcquirePushLockExclusiveEx", hook_FltAcquirePushLockExclusiveEx)
    ql.set_api("RtlGetPersistedStateLocation", hook_RtlGetPersistedStateLocation)
    ql.set_api("FltInitializePushLock", hook_FltInitializePushLock)

    ql.reg.rcx = 0
    ql.reg.rdx = ql.os.heap.alloc(0x30)

    ql.run(begin=0x1C00F98FC, end=0x1C00F992F)

```