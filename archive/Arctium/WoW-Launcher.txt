Project Path: arc_Arctium_WoW-Launcher_9ed8e6bk

Source Tree:

```txt
arc_Arctium_WoW-Launcher_9ed8e6bk
├── Arctium Game Launcher.slnx
├── LICENSE
├── README.md
└── src
    ├── Arctium.Game.Launcher.csproj
    ├── Constants
    │   ├── GameVersion.cs
    │   └── MemProtection.cs
    ├── IO
    │   └── WinMemory.cs
    ├── LaunchOptions.cs
    ├── Launcher.cs
    ├── Misc
    │   ├── Extensions.cs
    │   ├── Helpers.cs
    │   └── NativeWindows.cs
    ├── Patches
    │   ├── Common.cs
    │   └── Windows.cs
    ├── Patterns
    │   ├── Common.cs
    │   └── Windows.cs
    ├── Program.cs
    ├── Structures
    │   ├── MemoryBasicInformation.cs
    │   ├── ProcessBasicInformation.cs
    │   ├── ProcessInformation.cs
    │   └── StartupInfo.cs
    ├── Usings.cs
    └── logo.ico

```

`Arctium Game Launcher.slnx`:

```slnx
<Solution>
  <Configurations>
    <Platform Name="x64" />
  </Configurations>
  <Project Path="src/Arctium.Game.Launcher.csproj">
    <Platform Project="x64" />
  </Project>
</Solution>

```

`LICENSE`:

```
MIT License

Copyright (c) 2021-2026 Arctium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Arctium Game Launcher (Public version)
A game launcher for World of Warcraft that allows you to connect to custom servers with a valid tls certificate attached.

**NOTE**: This is not the full-featured launcher. For mod loading, developer mode, extended tooling, and binary releases, use the official launcher at https://arctium.io

### License, Copyright & Contributions

Please see our Open Source project [Documentation Repo](https://github.com/Arctium/Documentation)

## Important Scope & Limitations

This public launcher has a very strict and intentionally limited feature set.

### What was removed
- No developer mode
- No Arctium server connection  
  (Names remain unchanged by design)
- No mod loading
- No experimental or legacy features
- No binary releases
- No support for deprecated client branches

If you need any of the above, please use the full-featured launcher

### What This Launcher Can Do

- Launch modern World of Warcraft clients
- Connect to custom servers with a valid TLS certificate attached
- Allow custom client version & cdn urls  
  Useful for launching older clients or serving data from your own CDN

## Supported Clients
| Client Branch | Min Supported Version | Max Supported Version |
|-------------------------|------------|------------|
| Mainline                | 10.1.5     | **\*** |
| Classic Era             | 1.14.4     | **\*** |
| Classic                 | 3.4.2      | **\*** |
| Classic Anniversary     | 2.5.5      | **\*** |
| Classic Titan           | 3.80.0     | **\*** |

**\* = all future versions in that branch (unless otherwise stated)**

## Special Request <3
Please do NOT remove the name `arctium` from the final binary.
Blizzard filters their crash logs based on localhost and the string `arctium` in the binary name. 

### NOTE FOR SERVER CONNECTIONS
* A valid certificate matching your authentication/bnet server host name.
  That certificate needs to be loaded by the authentication/bnet server too

### Binary Releases
There are no binary releases of this version. Our **full-featured** launcher has binary releases at https://arctium.io

## Building

### Build Prerequisites
* [.NET Core SDK 10.0.0 or later](https://dotnet.microsoft.com/download/dotnet/10.0)
* Optional for native builds: C++ workload through Visual Studio 2026 or latest C++ build tools

### Build Instructions Windows (native)
* Execute `dotnet publish -r win-x64 -c Configuration -p:platform="x64" -p:PublishAot=true`
* Native output is placed in the `build` folder.

## Usage

### Windows Usage
1. Copy `Actium Game Launcher.exe` to your World of Warcraft folder.
2. Edit the `WTF/Config.wtf` to set your portal or use a different config file with the `-config Config2.wtf` launch arg.
3. Run the `Actium Game Launcher.exe`

### Launch Parameters
Use `--help`

```

`src/Arctium.Game.Launcher.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputPath>../build/$(Configuration)/bin</OutputPath>
    <AssemblyName>Arctium Game Launcher</AssemblyName>
    <ApplicationIcon>logo.ico</ApplicationIcon>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>disable</Nullable>
    <LangVersion>preview</LangVersion>
    <Copyright>Arctium</Copyright>
    <Platforms>x64</Platforms>
    <ImplicitUsings>enable</ImplicitUsings>
    <DefineConstants>$(DefineConstants);$(Platform)</DefineConstants>
    <Configurations>Debug;Release</Configurations>
  </PropertyGroup>

  <PropertyGroup>
    <ServerGarbageCollection>true</ServerGarbageCollection>
    <GarbageCollectionAdaptationMode>1</GarbageCollectionAdaptationMode>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="10.0.2" />
    <PackageReference Include="System.CommandLine" Version="2.0.0-beta4.22272.1" />

  </ItemGroup>
</Project>

```

`src/Constants/GameVersion.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Constants;

enum GameVersion
{
    Retail,
    Classic,
    ClassicEra,
    ClassicAnniversary,
    ClassicTitan
}

```

`src/Constants/MemProtection.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Constants;

enum MemProtection
{
    ReadWrite = 0x4,
}

```

`src/IO/WinMemory.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using static Arctium.Game.Launcher.Misc.NativeWindows;
using static Arctium.Game.Launcher.Misc.Helpers;

namespace Arctium.Game.Launcher.IO;

class WinMemory
{
    public byte[] Data { get; set; }
    public nint BaseAddress { get; }
    
    readonly nint _processHandle;

    public WinMemory(ProcessInformation processInformation)
    {
        _processHandle = processInformation.ProcessHandle;

        if (processInformation.ProcessHandle == 0)
            throw new InvalidOperationException("No valid process found.");

        BaseAddress = ReadImageBaseFromPEB(processInformation.ProcessHandle);

        if (BaseAddress == 0)
            throw new InvalidOperationException("Error while reading PEB data.");
    }

    public void RefreshMemoryData(int size)
    {
        // Reset previous memory data.
        if (Data != null)
            Array.Clear(Data, 0, Data.Length);

        while (Data == null || Unsafe.ReadUnaligned<long>(ref Data[0]) == 0)
        {
            Console.WriteLine("Refreshing client data...");
            ReadToData(BaseAddress, size);
        }
    }

    public nint Read(nint address)
    {
        try
        {
            var buffer = new byte[8];

            if (ReadProcessMemory(_processHandle, address, buffer, buffer.Length, out var dummy))
                return buffer.ToNint();

        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        return 0;
    }

    public void ReadToData(nint address, int size)
    {
        try
        {
            Data ??= new byte[size];

            ReadProcessMemory(_processHandle, address, Data, size, out var dummy);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }


    public byte[] Read(nint address, int size)
    {
        try
        {
            var buffer = new byte[size];

            if (ReadProcessMemory(_processHandle, address, buffer, size, out var dummy))
                return buffer;

        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        return null;
    }

    public void Write(nint address, byte[] data, MemProtection newProtection = MemProtection.ReadWrite)
    {
        try
        {
            VirtualProtectEx(_processHandle, address, (uint)data.Length, (uint)newProtection, out var oldProtect);

            WriteProcessMemory(_processHandle, address, data, data.Length, out var written);

            FlushInstructionCache(_processHandle, address, (uint)data.Length);
            VirtualProtectEx(_processHandle, address, (uint)data.Length, oldProtect, out oldProtect);

        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }

    public async Task TryPatchPatterns(byte[][] patches, string patchName, bool? printInfo = null, bool exitOnFail = true, bool patchAll = false, params short[][] patterns)
    {
        if (patches.Length == 0 || patterns.Length == 0)
            return;

        if (!patchAll && await PatchMemory(patterns[0], patches[0], $"{patchName}", printInfo, exitOnFail))
            return;

        for (var i = 0; i < patterns.Length; i++)
        {
            Console.ResetColor();

            if (await PatchMemory(patterns[i], patches[i], $"{patchName} {i + 1}", printInfo, exitOnFail: false) && !patchAll)
                break;
        }
    }

    public Task<bool> PatchMemory(short[] pattern, byte[] patch, string patchName, bool? printInfo = null, bool exitOnFail = true)
    {
        printInfo ??= IsDebugBuild();

        if (printInfo.Value)
            Console.WriteLine($"[{patchName}] Patching...");

        long patchOffset = Data.FindPattern(pattern, BaseAddress);

        // No result for the given pattern.
        if (patchOffset == 0)
        {
            if (exitOnFail)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"[{patchName}] No result found.");
                Console.WriteLine("Press any key to exit...");

                // Only wait if a console is available.
                if (!Console.IsInputRedirected)
                    Console.ReadKey();

                Launcher.CancellationTokenSource.Cancel();

                return Task.FromResult(false);
            }

            if (printInfo.Value)
            {
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine($"[{patchName}] No result found. This is just a warning! KEEP GOING...");
                Console.ResetColor();
            }

            return Task.FromResult(false);
        }

        while (Read((nint)patchOffset, patch.Length)?.SequenceEqual(patch) == false)
            Write((nint)patchOffset, patch);

        if (printInfo.Value)
        {
            Console.Write($"[{patchName}] at 0x{patchOffset:X}");
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine(" Done.");
            Console.ResetColor();
            Console.WriteLine();
        }

        return Task.FromResult(true);
    }

    nint ReadImageBaseFromPEB(nint processHandle)
    {
        try
        {
            ProcessBasicInformation peb = default;

            if (NtQueryInformationProcess(processHandle, 0, ref peb, ProcessBasicInformation.Size, out _) == 0)
                return Read(peb.PebBaseAddress + 0x10);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        return 0;
    }
}

```

`src/LaunchOptions.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.CommandLine.Builder;
using System.CommandLine.Parsing;

namespace Arctium.Game.Launcher;

static class LaunchOptions
{
    public static Option<GameVersion> Version = new("--version", () => GameVersion.Retail);
    public static Option<string> GamePath = new("--path");
    public static Option<string> GameBinary = new("--binary");
    public static Option<bool> KeepCache = new("--keepcache", () => true);
    public static Option<string> VersionUrl = new("--versionurl");
    public static Option<string> CdnsUrl = new("--cdnsurl");
    public static Option<string> ProductName = new("--product", () => "wow");
    public static Option<string> CdnRegion = new("--region", () => "EU");
    public static Option<string> BgsPortal = new("--portal");

    // Game command line options.
    public static Option<string> GameConfig = new("-config", () => "Config.wtf");

    public static Parser Instance => new CommandLineBuilder(ConfigureCommandLine(RootCommand))
        .UseHelp()
        .UseParseDirective()
        .CancelOnProcessTermination()
        .UseParseErrorReporting()
        .UseSuggestDirective()
        .Build();

    public static RootCommand RootCommand = new("Arctium Game Launcher")
    {
        Version,
        GamePath,
        GameBinary,
        KeepCache,
        VersionUrl,
        CdnsUrl,
        ProductName,
        CdnRegion,
        BgsPortal,
        GameConfig,
    };

    static Command ConfigureCommandLine(Command rootCommand)
    {
        // Do not show errors for unknown command line parameters.
        rootCommand.TreatUnmatchedTokensAsErrors = false;

        return rootCommand;
    }
}

```

`src/Launcher.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.CommandLine.Parsing;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Authentication;
using static Arctium.Game.Launcher.Misc.Helpers;

namespace Arctium.Game.Launcher;

static class Launcher
{
    public static nint GameProcessHandle { get; private set; }
    public static readonly CancellationTokenSource CancellationTokenSource = new();

    static readonly List<GameVersion> _tryClients =
    [
        GameVersion.Retail,
        GameVersion.Classic, GameVersion.ClassicEra, GameVersion.ClassicAnniversary,
        GameVersion.ClassicTitan
    ];

    static bool _useVersionV2;
    static byte[] _binaryData;

    public static async ValueTask<string> PrepareGameLaunch(ParseResult commandLineResult, GameVersion? branchOverwrite)
    {
        Console.ResetColor();

        var gameVersion = commandLineResult.GetValueForOption(LaunchOptions.Version);

        if (branchOverwrite.HasValue)
            gameVersion = branchOverwrite.Value;

        var (subFolder, binaryName, majorGameVersion, minGameBuild) = gameVersion switch
        {
            GameVersion.Retail => ("_retail_", "Wow.exe", [10, 11, 12], 50401),
            GameVersion.Classic => ("_classic_", "WowClassic.exe", [2, 3, 4, 5], 50063),
            GameVersion.ClassicEra => ("_classic_era_", "WowClassic.exe", [1], 51001),
            GameVersion.ClassicAnniversary => ("_anniversary_", "WowClassic.exe", [2], 65340),
            GameVersion.ClassicTitan => ("_classic_titan_", "WowClassic.exe", new[] { 3 }, 64393),
            _ => throw new NotImplementedException("Invalid game version specified."),
        };

        _tryClients.RemoveAll(c => c == gameVersion);

        Console.ForegroundColor = ConsoleColor.Yellow;

        Console.WriteLine($"Mode: Public Custom Server ({gameVersion})");
        Console.ResetColor();

        var currentFolder = AppDomain.CurrentDomain.BaseDirectory;
        var gameFolder = $"{currentFolder}/{subFolder}";

        if (commandLineResult.HasOption(LaunchOptions.GameBinary))
            binaryName = commandLineResult.GetValueForOption(LaunchOptions.GameBinary);

        var gameBinaryPath = $"{gameFolder}/{binaryName}";

        if (commandLineResult.HasOption(LaunchOptions.GamePath))
        {
            gameFolder = commandLineResult.GetValueForOption(LaunchOptions.GamePath);
            gameBinaryPath = $"{gameFolder}/{binaryName}";
        }
        else if (!File.Exists(gameBinaryPath))
        {
            // Also support game installations without branch sub folders.
            gameFolder = currentFolder;
            gameBinaryPath = $"{gameFolder}/{binaryName}";
        }

        gameFolder = gameFolder.Replace("\\/", "/").Replace("\\", "/");
        gameBinaryPath = gameBinaryPath.Replace("\\/", "/").Replace("\\", "/");

        if (!File.Exists(gameBinaryPath) || !majorGameVersion.Contains(GetVersionValueFromClient(gameBinaryPath).Major))
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"No {gameVersion} client found at '{gameBinaryPath}'");

            if (_tryClients.Count > 0)
            {
                var nextClient = _tryClients.First();

                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine($"Trying a different branch...");
                Console.ResetColor();

                return await PrepareGameLaunch(commandLineResult, nextClient);
            }
            else
            {
                Console.WriteLine();
                Console.WriteLine($"No supported client found.");
            }

            return string.Empty;
        }

        var gameClientBuild = GetVersionValueFromClient(gameBinaryPath).Build;

        if (gameClientBuild < minGameBuild && gameClientBuild != 0)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"Your found client version {gameClientBuild} is not supported.");
            Console.WriteLine($"The minimum required build is {minGameBuild}");

            return string.Empty;
        }

        // Delete the cache folder by default.
        if (!commandLineResult.GetValueForOption(LaunchOptions.KeepCache))
        {
            try
            {
                // Trying to delete the cache folder.
                Directory.Delete($"{gameFolder}/Cache", true);
            }
            catch (Exception)
            {
                // We don't care if it worked. Swallow it!
            }
        }

        var configPath = $"{gameFolder}/WTF/{commandLineResult.GetValueForOption(LaunchOptions.GameConfig)}";

        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine();
        Console.WriteLine($"Client Config: \"{configPath}\"");
        Console.ResetColor();

        (string IPAddress, string HostName, int Port) portal = new();


        var config = File.ReadAllText(configPath);
        var bgsPortal = commandLineResult.GetValueForOption(LaunchOptions.BgsPortal);

        portal = ParseOrSetPortal(ref config, bgsPortal);

        if (!string.IsNullOrEmpty(bgsPortal))
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"Config Portal Overwrite:\"{bgsPortal}\"");
            Console.ResetColor();
            Console.WriteLine();

            File.WriteAllText(configPath, config);
        }

        _binaryData = File.ReadAllBytes(gameBinaryPath);
        _useVersionV2 = UsesVersionV2(_binaryData);

        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine($"Client Path: '{gameBinaryPath}'");
        Console.WriteLine($"Client Portal: '{portal.HostName}:{portal.Port}'");
        Console.ForegroundColor = ConsoleColor.Gray;


        if (string.IsNullOrEmpty(portal.HostName) || string.IsNullOrWhiteSpace(portal.HostName))
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine();
            Console.WriteLine("Client Portal should not be empty.");
            Console.WriteLine("Be sure to have a valid portal in your Config.wtf file.");
            Console.ResetColor();

            return string.Empty;
        }

        // Return if no valid ip address has been found.
        if (string.IsNullOrEmpty(portal.IPAddress) || string.IsNullOrWhiteSpace(portal.IPAddress))
            return string.Empty;

        // Check for valid certificate.
        try
        {
            using var tcpClient = new TcpClient();

            // 3.5 seconds timeout.
            const int timeout = 3500;

            tcpClient.ReceiveTimeout = timeout;
            tcpClient.SendTimeout = timeout;

            using var tcpClientTimeout = new CancellationTokenSource(TimeSpan.FromMilliseconds(timeout));

            await tcpClient.ConnectAsync(portal.HostName, portal.Port, tcpClientTimeout.Token);

            using var sslStream = new SslStream(tcpClient.GetStream(), false,
                (_, _, _, sslPolicyErrors) =>
                {
                    // Redirect to the trusted cert warning.
                    if (sslPolicyErrors != SslPolicyErrors.None)
                        throw new AuthenticationException();

                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.WriteLine($"Certificate for server '{portal.HostName}' successfully validated.");
                    Console.WriteLine();
                    Console.ResetColor();

                    return true;
                },
                null
            );

            sslStream.AuthenticateAsClient(portal.HostName);
        }
        catch (IOException exception)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"Server {portal.HostName}:{portal.Port}: {exception.Message}");
            Console.ResetColor();

            return string.Empty;
        }
        catch (AuthenticationException)
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"Server with host name {portal.HostName}:{portal.Port} does not have a trusted certificate attached.");
            Console.WriteLine("If you are the server owner be sure to generate one and replace the default bnet server certificate.");
            Console.WriteLine("One way to generate one is through Let's Encrypt.");
            Console.ResetColor();

            return string.Empty;
        }
        catch (Exception exception) when (exception is SocketException or OperationCanceledException)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"{portal.HostName}:{portal.Port} is offline or not reachable from the current network.");
            Console.ResetColor();

            return string.Empty;
        }

        return gameBinaryPath;
    }

    public static bool LaunchGame(string appPath, string gameCommandLine, ParseResult commandLineResult)
    {
        // Build the version URL from the game binary build.
        var clientVersion = GetVersionValueFromClient(appPath);

        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine($"Client Build {clientVersion}");
        Console.ResetColor();

        // Assign the region and product dependent version url to check it's online status.
        string[] versionUrls = CreateVersionUrls(commandLineResult, clientVersion);

        static string[] CreateVersionUrls(ParseResult commandLineResult, (int Major, int Minor, int Revision, int Build) clientVersion)
        {
            var versionUrl = commandLineResult.GetValueForOption(LaunchOptions.VersionUrl);

            // Always return a forced version url parameter.
            if (!string.IsNullOrEmpty(versionUrl))
                return [versionUrl, versionUrl, versionUrl];

            return [];
        }

        bool hasCustomVersionUrl = commandLineResult.HasOption(LaunchOptions.VersionUrl);
        bool hasCustomCdnUrl = commandLineResult.HasOption(LaunchOptions.CdnsUrl);

        if (hasCustomCdnUrl || hasCustomVersionUrl)
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine("Warning: Custom version servers were specified.");
            Console.WriteLine("The game will connect to these servers.");
            Console.ResetColor();
        }

        var cdnsUrl = commandLineResult.GetValueForOption(LaunchOptions.CdnsUrl);

        if (hasCustomCdnUrl && (!CheckUrl(cdnsUrl, fallbackUrls: [Patterns.Common.CdnsUrl]).GetAwaiter().GetResult()))
            cdnsUrl = Patterns.Common.CdnsUrl;

        Console.ForegroundColor = ConsoleColor.Cyan;

        Console.WriteLine();
        Console.WriteLine("Game CDN connection info:");
        Console.WriteLine($"Version source(s):");

        if (versionUrls.Length == 0)
        {
            foreach (var vUrl in new[] { Patterns.Common.VersionUrl, Patterns.Common.Version2Url, Patterns.Common.Version2ChinaUrl })
                Console.WriteLine($"- {vUrl}");
        }
        else
        {
            if (versionUrls.All(element => element.Equals(versionUrls[0])))
                Console.WriteLine($"- {versionUrls[0]}");
            else
            {
                foreach (var vUrl in versionUrls)
                    Console.WriteLine($"- {vUrl}");
            }
        }

        Console.WriteLine($"CDNs source: {cdnsUrl}");
        Console.WriteLine();
        Console.ResetColor();

        var startupInfo = new StartupInfo();
        var processInfo = new ProcessInformation();

        try
        {
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("Starting game client...");

            var createSuccess = NativeWindows.CreateProcess(null, $"\"{appPath}\" {gameCommandLine}", 0, 0, false, 4, 0, new FileInfo(appPath).DirectoryName,
                ref startupInfo, out processInfo);

            // On some systems we have to launch the game with the application name used.
            if (!createSuccess)
                createSuccess = NativeWindows.CreateProcess(appPath, $" {gameCommandLine}", 0, 0, false, 4, 0, new FileInfo(appPath).DirectoryName, ref startupInfo, out processInfo);

            // Start process with suspend flags.
            if (createSuccess)
            {
                GameProcessHandle = processInfo.ProcessHandle;

                using var gameAppData = File.OpenRead(appPath);

                var appDataLength = gameAppData.Length;
                var memory = new WinMemory(processInfo);

                if (memory.BaseAddress != 0)
                {
                    Process gameProcess = Process.GetProcessById((int)processInfo.ProcessId);

                    // Refresh the client data before patching.
                    memory.RefreshMemoryData((int)appDataLength);

                    // Custom CDN related patches.
                    if ((hasCustomVersionUrl && hasCustomCdnUrl))
                    {
                        var versionUrlPatches = new byte[versionUrls.Length][];

                        for (var i = 0; i < versionUrls.Length; i++)
                            versionUrlPatches[i] = Encoding.UTF8.GetBytes(versionUrls[i] + '\0');

                        // 11.1.7 added new v2 links.
                        if (_useVersionV2)
                        {
                            Task.WaitAll(
                            [
                                memory.TryPatchPatterns(versionUrlPatches, "Version URL", true, false, true,
                                                        Patterns.Common.Version2UrlNew.ToPattern(), Patterns.Common.Version2ChinaUrlNew.ToPattern()),
                            ], CancellationTokenSource.Token);
                        }
                        else
                        {
                            Task.WaitAll(
                            [
                                memory.TryPatchPatterns(versionUrlPatches, "Version URL", true, false, true,
                                                        Patterns.Common.VersionUrl.ToPattern(), Patterns.Common.Version2Url.ToPattern(), Patterns.Common.Version2ChinaUrl.ToPattern()),
                                memory.PatchMemory(Patterns.Common.CdnsUrl.ToPattern(), Encoding.UTF8.GetBytes(cdnsUrl), "CDNs URL", exitOnFail: false),
                            ], CancellationTokenSource.Token);
                        }
                    }

                    // Wait for all direct memory patch tasks to complete.
                    Task.WaitAll(
                    [
                        memory.PatchMemory(Patterns.Common.ConnectToModulus, Patches.Common.RsaModulus, "ConnectTo RsaModulus"),
                        memory.PatchMemory(Patterns.Common.CryptoEdPublicKey, Patches.Common.CryptoEdPublicKey, "GameCrypto Ed25519 PublicKey"),
                        memory.PatchMemory(Patterns.Common.Portal, Patches.Common.Portal, "Login Portal"),
                        memory.PatchMemory(Patterns.Windows.LauncherLogin, Patches.Windows.LauncherLogin, "Launcher Login Registry")
                    ], CancellationTokenSource.Token);

                    NativeWindows.NtResumeProcess(processInfo.ProcessHandle);

                    Console.WriteLine("Done :) ");

                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.WriteLine("You can login now.");
                    Console.WriteLine("Closing in 3 seconds...");
                    Thread.Sleep(3000);
                    Console.ResetColor();

                    return true;
                }
            }
        }
        // Only exit and do not print any exception messages to the console.
        catch (OperationCanceledException)
        {
            NativeWindows.TerminateProcess(processInfo.ProcessHandle, 0);
        }
        // Just print out the exception we have and kill the game process.
        catch (Exception ex)
        {
            Console.WriteLine(ex);
            Console.WriteLine(ex.StackTrace);

            NativeWindows.TerminateProcess(processInfo.ProcessHandle, 0);
        }
        finally
        {
            NativeWindows.CloseHandle(processInfo.ProcessHandle);
            NativeWindows.CloseHandle(processInfo.ThreadHandle);
        }

        return false;
    }
}

```

`src/Misc/Extensions.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Misc;

static class Extensions
{
    public static nint ToNint(this byte[] buffer) => (nint)BitConverter.ToInt64(buffer, 0);

    public static long FindPattern(this byte[] data, short[] pattern, long start, long baseOffset = 0)
    {
        long matches;

        for (long i = start; i < data.Length; i++)
        {
            if (pattern.Length > (data.Length - i))
                return 0;

            for (matches = 0; matches < pattern.Length; matches++)
            {
                if ((pattern[matches] != -1) && (data[i + matches] != (byte)pattern[matches]))
                    break;
            }

            if (matches == pattern.Length)
                return baseOffset + i;
        }

        return 0;
    }

    public static long FindPattern(this byte[] data, short[] pattern, long baseOffset = 0) => FindPattern(data, pattern, 0L, baseOffset);
    public static short[] ToPattern(this string data) => Encoding.UTF8.GetBytes(data).Select(b => (short)b).ToArray();
}

```

`src/Misc/Helpers.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Net;
using System.Net.Sockets;

namespace Arctium.Game.Launcher.Misc;

static class Helpers
{
    public static bool IsDebugBuild()
    {
#if DEBUG
        return true;
#else
        return false;
#endif
    }

    public static void PublisherCheck()
    {
        // "Arctium" should not be removed from the final binary name.
        if (!Process.GetCurrentProcess().ProcessName.Contains("arctium", StringComparison.InvariantCultureIgnoreCase))
            Process.GetCurrentProcess().Kill();
    }

    public static (int Major, int Minor, int Revision, int Build) GetVersionValueFromClient(string fileName)
    {
        var fileVersionInfo = FileVersionInfo.GetVersionInfo(fileName);
        var major = fileVersionInfo.FileMajorPart;
        var minor = fileVersionInfo.FileMinorPart;
        var build = fileVersionInfo.FileBuildPart;
        var privatePart = fileVersionInfo.FilePrivatePart;

        // Special case for build numbers greater than 65535.
        // Note: fileVersionInfo.FileVersion is an alternative based on string parsing.
        if (build >= 6553 && privatePart < ushort.MaxValue)
        {
            privatePart = build * 10 + privatePart;
            build = minor;
            minor = major % 100;
            major /= 100;
        }

        return (major, minor, build, privatePart);
    }

    public static void PrintHeader()
    {
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine("Arctium Game Launcher");
        Console.ResetColor();
        Console.Write("Game: ");
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine("World of Warcraft");
        Console.ResetColor();
        Console.Write("Support: ");
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine("https://arctium.io");
        Console.ResetColor();
        Console.WriteLine();
        Console.WriteLine($"Operating System: {RuntimeInformation.OSDescription}");
    }

    public static (string IPAddress, string HostName, int Port) ParseOrSetPortal(ref string config, string customPortal = null)
    {
        const string portalKey = "SET portal";

        var portalIndex = config.IndexOf(portalKey, StringComparison.OrdinalIgnoreCase);

        if (portalIndex == -1)
        {
            if (string.IsNullOrEmpty(customPortal))
                throw new ArgumentException("Config file does not contain a valid portal variable.");

            // Append a new portal variable to the config.
            config += $"{Environment.NewLine}{portalKey} \"{customPortal}\"";
        }

        // Re-evaluate the portal variable.
        portalIndex = config.IndexOf(portalKey, StringComparison.OrdinalIgnoreCase);

        if (portalIndex == -1)
            throw new ArgumentException("Config file does not contain a valid portal variable.");

        var startQuoteIndex = config.IndexOf('"', portalIndex);

        if (startQuoteIndex == -1)
            throw new ArgumentException("Invalid format for the portal variable.");

        var endQuoteIndex = config.IndexOf('"', startQuoteIndex + 1);

        if (endQuoteIndex == -1)
            throw new ArgumentException("Invalid format for the portal variable.");

        var portalLength = endQuoteIndex - startQuoteIndex - 1;
        var portalSpan = config.AsSpan(startQuoteIndex + 1, portalLength);
        var colonIndex = portalSpan.IndexOf(':');
        var ipSpan = colonIndex != -1 ? portalSpan[..colonIndex] : portalSpan;
        var port = colonIndex != -1 ? int.Parse(portalSpan[(colonIndex + 1)..]) : 1119;

        // Check if we have more than one portal line.
        var lastPortalIndex = config.IndexOf(portalKey, portalIndex + portalLength, StringComparison.OrdinalIgnoreCase);

        if (lastPortalIndex != -1 && lastPortalIndex != portalIndex)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine();
            Console.WriteLine("Client portal is set multiple times. Please check your config file!");
            Console.ResetColor();

            return (string.Empty, string.Empty, port);
        }

        var portalString = ipSpan.ToString().Trim();

        // Override portal variable if a custom one is provided.
        if (!string.IsNullOrEmpty(customPortal))
        {
            portalString = customPortal;
            config = string.Concat(config.AsSpan(0, startQuoteIndex + 1), portalString, config.AsSpan(endQuoteIndex));

            // Let's re-parse the new portal for verification purposes.
            return ParseOrSetPortal(ref config);
        }

        try
        {
            if (IPAddress.TryParse(portalString, out var ipAddress))
                return (ipAddress.ToString(), portalString, port);

            var ipv4Address = Dns.GetHostAddresses(portalString).FirstOrDefault(a => a.AddressFamily == AddressFamily.InterNetwork);

            if (ipv4Address == null)
            {
                var ipv6Address = Dns.GetHostAddresses(portalString).FirstOrDefault(a => a.AddressFamily == AddressFamily.InterNetworkV6);

                if (ipv6Address == null)
                    throw new Exception("No IPv4/IPv6 address found for the provided host name.");

                return (ipv6Address.ToString(), portalString, port);
            }

            return (ipv4Address.ToString(), portalString, port);
        }
        catch (SocketException socketException) when (socketException.SocketErrorCode == SocketError.HostNotFound)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"DNS resolution failed for portal: {portalString}");
            Console.ForegroundColor = ConsoleColor.Gray;

            return (string.Empty, portalString, port);
        }
        catch (SocketException)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("No valid portal found.");
            Console.ForegroundColor = ConsoleColor.Gray;

            return (string.Empty, portalString, port);
        }
    }

    public static async Task<bool> CheckUrl(string url, string[] fallbackUrls)
    {
        using var httpClient = new HttpClient();

        httpClient.Timeout = TimeSpan.FromSeconds(5);

        try
        {
            var result = await httpClient.GetAsync(url);

            if (!result.IsSuccessStatusCode)
            {
                Console.WriteLine();
                Console.WriteLine($"{url} not reachable. Falling back to: ");

                foreach (var furl in fallbackUrls)
                    Console.WriteLine($"- {furl}");
            }

            return result.IsSuccessStatusCode;
        }
        catch (Exception)
        {
            Console.WriteLine();
            Console.WriteLine($"{url} not reachable. Falling back to: ");

            foreach (var furl in fallbackUrls)
                Console.WriteLine($"- {furl}");

            return false;
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool UsesVersionV2(byte[] appPath)
    {
        return appPath.FindPattern(Patterns.Common.Version2UrlNew.ToPattern()) > 0;
    }
}

```

`src/Misc/NativeWindows.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Misc;

static class NativeWindows
{
    [DllImport("kernel32.dll", EntryPoint = "CreateProcessA", SetLastError = true)]
    public static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, nint lpProcessAttributes, nint lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, nint lpEnvironment, string lpCurrentDirectory, ref StartupInfo lpStartupInfo, out ProcessInformation lpProcessInformation);

    [DllImport("kernel32.dll", EntryPoint = "TerminateProcess")]
    public static extern void TerminateProcess(nint processHandle, int exitCode);

    [DllImport("kernel32.dll", EntryPoint = "CloseHandle")]
    public static extern void CloseHandle(nint handle);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool VirtualProtectEx(nint hProcess, nint lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool ReadProcessMemory(nint hProcess, nint lpBaseAddress, byte[] lpBuffer, int nSize, out int lpNumberOfBytesRead);

    [DllImport("kernel32.dll", SetLastError = true)]
    internal static extern bool WriteProcessMemory(nint hProcess, nint lpBaseAddress, byte[] lpBuffer, int nSize, out int lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", EntryPoint = "FlushInstructionCache", SetLastError = true)]
    public static extern bool FlushInstructionCache(nint hProcess, nint lpBaseAddress, uint dwSize);

    [DllImport("ntdll.dll", SetLastError = true)]
    public static extern int NtQueryInformationProcess(nint hProcess, int pic, ref ProcessBasicInformation pbi, int cb, out int pSize);

    [DllImport("ntdll.dll", SetLastError = true)]
    public static extern nint NtResumeProcess(nint processHandle);

    [DllImport("ntdll.dll", SetLastError = true)]
    public static extern nint NtSuspendProcess(nint processHandle);
}

```

`src/Patches/Common.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Patches;

static class Common
{
    // ConnectTo & ChangeProtocol modulus.
    public static byte[] RsaModulus = { 0x5F, 0xD6, 0x80, 0x0B, 0xA7, 0xFF, 0x01, 0x40, 0xC7, 0xBC, 0x8E, 0xF5, 0x6B, 0x27, 0xB0, 0xBF,
                                        0xF0, 0x1D, 0x1B, 0xFE, 0xDD, 0x0B, 0x1F, 0x3D, 0xB6, 0x6F, 0x1A, 0x48, 0x0D, 0xFB, 0x51, 0x08,
                                        0x65, 0x58, 0x4F, 0xDB, 0x5C, 0x6E, 0xCF, 0x64, 0xCB, 0xC1, 0x6B, 0x2E, 0xB8, 0x0F, 0x5D, 0x08,
                                        0x5D, 0x89, 0x06, 0xA9, 0x77, 0x8B, 0x9E, 0xAA, 0x04, 0xB0, 0x83, 0x10, 0xE2, 0x15, 0x4D, 0x08,
                                        0x77, 0xD4, 0x7A, 0x0E, 0x5A, 0xB0, 0xBB, 0x00, 0x61, 0xD7, 0xA6, 0x75, 0xDF, 0x06, 0x64, 0x88,
                                        0xBB, 0xB9, 0xCA, 0xB0, 0x18, 0x8B, 0x54, 0x13, 0xE2, 0xCB, 0x33, 0xDF, 0x17, 0xD8, 0xDA, 0xA9,
                                        0xA5, 0x60, 0xA3, 0x1F, 0x4E, 0x27, 0x05, 0x98, 0x6F, 0xAA, 0xEE, 0x14, 0x3B, 0xF3, 0x97, 0xA8,
                                        0x12, 0x02, 0x94, 0x0D, 0x84, 0xDC, 0x0E, 0xF1, 0x76, 0x23, 0x95, 0x36, 0x13, 0xF9, 0xA9, 0xC5,
                                        0x48, 0xDB, 0xDA, 0x86, 0xBE, 0x29, 0x22, 0x54, 0x44, 0x9D, 0x9F, 0x80, 0x7B, 0x07, 0x80, 0x30,
                                        0xEA, 0xD2, 0x83, 0xCC, 0xCE, 0x37, 0xD1, 0xD1, 0xCF, 0x85, 0xBE, 0x91, 0x25, 0xCE, 0xC0, 0xCC,
                                        0x55, 0xC8, 0xC0, 0xFB, 0x38, 0xC5, 0x49, 0x03, 0x6A, 0x02, 0xA9, 0x9F, 0x9F, 0x86, 0xFB, 0xC7,
                                        0xCB, 0xC6, 0xA5, 0x82, 0xA2, 0x30, 0xC2, 0xAC, 0xE6, 0x98, 0xDA, 0x83, 0x64, 0x43, 0x7F, 0x0D,
                                        0x13, 0x18, 0xEB, 0x90, 0x53, 0x5B, 0x37, 0x6B, 0xE6, 0x0D, 0x80, 0x1E, 0xEF, 0xED, 0xC7, 0xB8,
                                        0x68, 0x9B, 0x4C, 0x09, 0x7B, 0x60, 0xB2, 0x57, 0xD8, 0x59, 0x8D, 0x7F, 0xEA, 0xCD, 0xEB, 0xC4,
                                        0x60, 0x9F, 0x45, 0x7A, 0xA9, 0x26, 0x8A, 0x2F, 0x85, 0x0C, 0xF2, 0x19, 0xC6, 0x53, 0x92, 0xF7,
                                        0xF0, 0xB8, 0x32, 0xCB, 0x5B, 0x66, 0xCE, 0x51, 0x54, 0xB4, 0xC3, 0xD3, 0xD4, 0xDC, 0xB3, 0xEE };

    public static byte[] CryptoEdPublicKey = { 0x02, 0x59, 0x6F, 0x0D, 0x0C, 0x06, 0x1A, 0x8B, 0x30, 0x74, 0x59, 0x88, 0xFD, 0x72, 0xC5, 0x9E,
                                               0x29, 0xEC, 0x36, 0x7F, 0xB0, 0xF3, 0x41, 0xF2, 0x8E, 0x0F, 0x08, 0xD0, 0x37, 0xBA, 0xFC, 0x69 };

    public static byte[] Portal = new byte[Patterns.Common.Portal.Length];
}

```

`src/Patches/Windows.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Patches;

static class Windows
{
    // Registry entry used for -launcherlogin.
    public static byte[] LauncherLogin = Encoding.UTF8.GetBytes(@"Software\Custom Game Server Dev\Battle.net\Launch Options\");
}

```

`src/Patterns/Common.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Patterns;

static class Common
{
    public static short[] ConnectToModulus = { 0x91, 0xD5, 0x9B, 0xB7, 0xD4, 0xE1, 0x83, 0xA5 };
    public static short[] CryptoRsaModulus = { 0x71, 0xFD, 0xFA, 0x60, 0x14, 0x0D, 0xF2, 0x05 };
    public static short[] CryptoEdPublicKey = { 0x15, 0xD6, 0x18, 0xBD, 0x7D, 0xB5, 0x77, 0xBD, 0x9A, 0x8D, 0x45, 0x76, 0x9C, 0x59, 0xE4, 0xFC, 0x63 };

    public static string VersionUrl = "http://%s.patch.battle.net:1119/%s/versions";
    public static string Version2Url = "https://%s.version.battle.net/v2/products/%s/versions";
    public static string Version2UrlNew = "https://%s.version.battle.net/v2/products/%s/%s";
    public static string Version2ChinaUrl = "https://cn.version.battlenet.com.cn/v2/products/%s/versions";
    public static string Version2ChinaUrlNew = "https://cn.version.battlenet.com.cn/v2/products/%s/%s";
    public static string CdnsUrl = "http://%s.patch.battle.net:1119/%s/cdns";
    public static short[] Portal = ".actual.battle.net\0".ToPattern();
}

```

`src/Patterns/Windows.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Patterns;

static class Windows
{
    // Registry entry used for -launcherlogin.
    public static short[] LauncherLogin = @"Software\Blizzard Entertainment\Battle.net\Launch Options\".ToPattern();
}

```

`src/Program.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.CommandLine.Parsing;
using Arctium.Game.Launcher;

using static Arctium.Game.Launcher.Misc.Helpers;

PublisherCheck();
PrintHeader();

var versionInfo = FileVersionInfo.GetVersionInfo(Environment.ProcessPath);
Console.WriteLine($"Using {(int)(Environment.ProcessorCount * 0.75)} of {Environment.ProcessorCount} processors.");
Console.WriteLine();

PublisherCheck();

LaunchOptions.RootCommand.SetHandler(async context =>
{
    try
    {
        // Prefer / instead of \ for the client path.
        var appPath = (await Launcher.PrepareGameLaunch(context.ParseResult, default)).Replace("\\", "/");
        var gameCommandLine = string.Join(" ", context.ParseResult.UnmatchedTokens);

        // Add config parameter to the game command line.
        gameCommandLine += $" -config {context.ParseResult.GetValueForOption(LaunchOptions.GameConfig)}";

        if (string.IsNullOrEmpty(appPath) || !Launcher.LaunchGame(appPath, gameCommandLine, context.ParseResult))
            WaitAndExit(5000);
    }
    catch (Exception ex)
    {
        if (Launcher.GameProcessHandle != nint.Zero)
            NativeWindows.TerminateProcess(Launcher.GameProcessHandle, 0);

        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine(ex.Message);
        Console.ResetColor();
    }
});

await LaunchOptions.Instance.InvokeAsync(args);

static void WaitAndExit(int ms = 2000)
{
    Console.ForegroundColor = ConsoleColor.Gray;
    Console.WriteLine($"Closing in {ms / 1000} seconds...");

    Thread.Sleep(ms);

    Environment.Exit(0);
}
```

`src/Structures/MemoryBasicInformation.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Structures;

[StructLayout(LayoutKind.Sequential)]
struct MemoryBasicInformation
{
    public nint BaseAddress;
    public nint AllocationBase;
    public MemProtection AllocationProtect;
    public nint RegionSize;
    public int State;
    public MemProtection Protect;
    public int Type;

    public static int Size => Marshal.SizeOf<MemoryBasicInformation>();
}

```

`src/Structures/ProcessBasicInformation.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Structures;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
struct ProcessBasicInformation
{
    public nint ExitStatus;
    public nint PebBaseAddress;
    public nint AffinityMask;
    public nint BasePriority;
    public nint UniqueProcessId;
    public nint InheritedFromUniqueProcessId;

    public static int Size => Marshal.SizeOf<ProcessBasicInformation>();
}

```

`src/Structures/ProcessInformation.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Structures;

struct ProcessInformation
{
    public nint ProcessHandle;
    public nint ThreadHandle;
    public uint ProcessId;
    public uint ThreadId;

    public static int Size => Marshal.SizeOf<ProcessInformation>();
}

```

`src/Structures/StartupInfo.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace Arctium.Game.Launcher.Structures;

struct StartupInfo
{
    public uint Cb;
    public string Reserved;
    public string Desktop;
    public string Title;
    public uint X;
    public uint Y;
    public uint XSize;
    public uint YSize;
    public uint XCountChars;
    public uint YCountChars;
    public uint FillAttribute;
    public uint Flags;
    public short ShowWindow;
    public short Reserved2;
    public nint ReservedHandle;
    public nint StdInputHandle;
    public nint StdOutputHandle;
    public nint StdErrorHandle;

    public static int Size => Marshal.SizeOf<StartupInfo>();
}

```

`src/Usings.cs`:

```cs
// Copyright (c) Arctium.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

global using System.CommandLine;
global using System.Diagnostics;
global using System.Runtime.CompilerServices;
global using System.Runtime.InteropServices;
global using System.Text;

global using Arctium.Game.Launcher.Constants;
global using Arctium.Game.Launcher.IO;
global using Arctium.Game.Launcher.Misc;
global using Arctium.Game.Launcher.Structures;

```