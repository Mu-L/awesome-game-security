Project Path: arc_noahware_hyper-reV_3xsua6h0

Source Tree:

```txt
arc_noahware_hyper-reV_3xsua6h0
├── LICENSE
├── README.md
├── hyper-reV.sln
├── hyperv-attachment
│   ├── ext
│   │   └── ia32-doc
│   │       └── ia32.hpp
│   ├── hyperv-attachment.vcxproj
│   ├── hyperv-attachment.vcxproj.filters
│   └── src
│       ├── apic
│       │   ├── apic.cpp
│       │   ├── apic.h
│       │   ├── apic_def.h
│       │   └── apic_intrin.h
│       ├── arch
│       │   ├── amd_def.h
│       │   ├── arch.cpp
│       │   └── arch.h
│       ├── arch_config.h
│       ├── crt
│       │   ├── crt.cpp
│       │   └── crt.h
│       ├── hypercall
│       │   ├── hypercall.cpp
│       │   └── hypercall.h
│       ├── interrupts
│       │   ├── interrupt_entry.asm
│       │   ├── interrupts.cpp
│       │   └── interrupts.h
│       ├── logs
│       │   ├── logs.cpp
│       │   └── logs.h
│       ├── main.cpp
│       ├── memory_manager
│       │   ├── heap_manager.cpp
│       │   ├── heap_manager.h
│       │   ├── memory_manager.cpp
│       │   └── memory_manager.h
│       ├── slat
│       │   ├── cr3
│       │   │   ├── cr3.cpp
│       │   │   ├── cr3.h
│       │   │   ├── deep_copy.cpp
│       │   │   ├── deep_copy.h
│       │   │   ├── intel_invept.asm
│       │   │   ├── pte.cpp
│       │   │   └── pte.h
│       │   ├── hook
│       │   │   ├── amd_page_split.cpp
│       │   │   ├── amd_page_split.h
│       │   │   ├── hook.cpp
│       │   │   ├── hook.h
│       │   │   ├── hook_entry.cpp
│       │   │   └── hook_entry.h
│       │   ├── slat.cpp
│       │   ├── slat.h
│       │   ├── slat_def.h
│       │   └── violation
│       │       ├── violation.cpp
│       │       └── violation.h
│       └── structures
│           └── virtual_address.h
├── images
│   ├── amd_slat_violation.png
│   ├── boot_process.png
│   └── intel_slat_violation.png
├── load-hyper-reV.bat
├── shared
│   ├── hypercall
│   │   └── hypercall_def.h
│   └── structures
│       ├── memory_operation.h
│       └── trap_frame.h
├── uefi-boot
│   ├── ext
│   │   ├── edk2
│   │   │   ├── build
│   │   │   │   ├── BaseCacheMaintenanceLib
│   │   │   │   │   └── BaseCacheMaintenanceLib.vcxproj
│   │   │   │   ├── BaseCpuLib
│   │   │   │   │   └── BaseCpuLib.vcxproj
│   │   │   │   ├── BaseCryptLib
│   │   │   │   │   └── BaseCryptLib.vcxproj
│   │   │   │   ├── BaseDebugPrintErrorLevelLib
│   │   │   │   │   └── BaseDebugPrintErrorLevelLib.vcxproj
│   │   │   │   ├── BaseLib
│   │   │   │   │   ├── BaseLib.vcxproj
│   │   │   │   │   ├── vshacks.h
│   │   │   │   │   └── vshacks.nasm
│   │   │   │   ├── BaseMemoryLib
│   │   │   │   │   └── BaseMemoryLib.vcxproj
│   │   │   │   ├── BasePrintLib
│   │   │   │   │   └── BasePrintLib.vcxproj
│   │   │   │   ├── BaseSynchronizationLib
│   │   │   │   │   └── BaseSynchronizationLib.vcxproj
│   │   │   │   ├── EDK-II.sln
│   │   │   │   ├── GlueLib
│   │   │   │   │   ├── GlueLib.vcxproj
│   │   │   │   │   ├── guid.c
│   │   │   │   │   ├── initlib.c
│   │   │   │   │   └── pcd.c
│   │   │   │   ├── IntrinsicLib
│   │   │   │   │   └── IntrinsicLib.vcxproj
│   │   │   │   ├── MSBuild
│   │   │   │   │   ├── nasm.props
│   │   │   │   │   ├── nasm.targets
│   │   │   │   │   └── nasm.xml
│   │   │   │   ├── OpensslLib
│   │   │   │   │   └── OpensslLib.vcxproj
│   │   │   │   ├── UefiApplicationEntryPoint
│   │   │   │   │   └── UefiApplicationEntryPoint.vcxproj
│   │   │   │   ├── UefiBootServicesTableLib
│   │   │   │   │   └── UefiBootServicesTableLib.vcxproj
│   │   │   │   ├── UefiDebugLibConOut
│   │   │   │   │   └── UefiDebugLibConOut.vcxproj
│   │   │   │   ├── UefiDevicePathLibDevicePathProtocol
│   │   │   │   │   └── UefiDevicePathLibDevicePathProtocol.vcxproj
│   │   │   │   ├── UefiDriverEntryPoint
│   │   │   │   │   └── UefiDriverEntryPoint.vcxproj
│   │   │   │   ├── UefiFileHandleLib
│   │   │   │   │   └── UefiFileHandleLib.vcxproj
│   │   │   │   ├── UefiHiiLib
│   │   │   │   │   └── UefiHiiLib.vcxproj
│   │   │   │   ├── UefiHiiServicesLib
│   │   │   │   │   └── UefiHiiServicesLib.vcxproj
│   │   │   │   ├── UefiLib
│   │   │   │   │   └── UefiLib.vcxproj
│   │   │   │   ├── UefiMemoryAllocationLib
│   │   │   │   │   └── UefiMemoryAllocationLib.vcxproj
│   │   │   │   ├── UefiMemoryLib
│   │   │   │   │   └── UefiMemoryLib.vcxproj
│   │   │   │   ├── UefiRuntimeLib
│   │   │   │   │   └── UefiRuntimeLib.vcxproj
│   │   │   │   ├── UefiRuntimeServicesTableLib
│   │   │   │   │   └── UefiRuntimeServicesTableLib.vcxproj
│   │   │   │   ├── UefiShellLib
│   │   │   │   │   └── UefiShellLib.vcxproj
│   │   │   │   ├── UefiSortLib
│   │   │   │   │   └── UefiSortLib.vcxproj
│   │   │   │   ├── edk2.default.props
│   │   │   │   └── edk2.props
│   │   │   └── src
│   │   ├── ia32-doc
│   │   │   └── ia32_compact.h
│   │   └── openssl
│   ├── src
│   │   ├── bootmgfw
│   │   │   ├── bootmgfw.c
│   │   │   └── bootmgfw.h
│   │   ├── disk
│   │   │   ├── disk.c
│   │   │   └── disk.h
│   │   ├── hooks
│   │   │   ├── hooks.c
│   │   │   └── hooks.h
│   │   ├── hvloader
│   │   │   ├── hvloader.c
│   │   │   └── hvloader.h
│   │   ├── hyperv_attachment
│   │   │   ├── hyperv_attachment.c
│   │   │   └── hyperv_attachment.h
│   │   ├── image
│   │   │   ├── image.c
│   │   │   └── image.h
│   │   ├── main.c
│   │   ├── memory_manager
│   │   │   ├── memory_manager.c
│   │   │   └── memory_manager.h
│   │   ├── structures
│   │   │   ├── ntdef.h
│   │   │   ├── relocation_entry.h
│   │   │   └── virtual_address.h
│   │   └── winload
│   │       ├── winload.c
│   │       └── winload.h
│   ├── uefi-boot.vcxproj
│   ├── uefi.default.props
│   └── uefi.props
└── usermode
    ├── ext
    │   └── portable_executable
    │       ├── data_directory.cpp
    │       ├── data_directory.hpp
    │       ├── dos_header.cpp
    │       ├── dos_header.hpp
    │       ├── export_directory.cpp
    │       ├── export_directory.hpp
    │       ├── file.cpp
    │       ├── file.hpp
    │       ├── file_header.hpp
    │       ├── image.cpp
    │       ├── image.hpp
    │       ├── imports_directory.cpp
    │       ├── imports_directory.hpp
    │       ├── nt_headers.cpp
    │       ├── nt_headers.hpp
    │       ├── optional_header.hpp
    │       ├── relocations_directory.cpp
    │       ├── relocations_directory.hpp
    │       ├── section_header.cpp
    │       └── section_header.hpp
    ├── src
    │   ├── commands
    │   │   ├── commands.cpp
    │   │   └── commands.h
    │   ├── hook
    │   │   ├── hook.cpp
    │   │   ├── hook.h
    │   │   ├── hook_disassembly.cpp
    │   │   ├── hook_disassembly.h
    │   │   ├── kernel_detour_holder.cpp
    │   │   └── kernel_detour_holder.h
    │   ├── hypercall
    │   │   ├── hypercall.cpp
    │   │   ├── hypercall.h
    │   │   └── vmexit.asm
    │   ├── main.cpp
    │   └── system
    │       ├── system.cpp
    │       ├── system.h
    │       └── system_def.h
    ├── usermode.vcxproj
    ├── usermode.vcxproj.filters
    └── vcpkg.json

```

`LICENSE`:

```
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
## Contents
1. Introduction
2. Prior to boot
3. Boot process
    - 3.1. Restoration of bootmgfw.efi
	- 3.2. Heap
	- 3.3. Starting bootmgfw.efi
	- 3.4. winload.efi
	- 3.5. hvloader.dll & Hyper-V launch hook
		- 3.5.1. Loading hyperv-attachment
4. hyperv-attachment/post Hyper-V launch info
	- 4.1. How does it support different architectures?
	- 4.2. Entry point (pre Hyper-V launch)
	- 4.3. First VM exit
	- 4.4. APIC
	- 4.5. SLAT
		- 4.5.1. Code hooks on Intel
		- 4.5.2. Code hooks on AMD
		- 4.5.3. Code hook features common to both AMD and Intel
			- 4.5.3.1. Page split/merge
			- 4.5.3.2. Synchronization using NMIs
				- 4.5.3.2.1. NMIs in host state
				- 4.5.3.2.2. NMIs in guest state
			- 4.5.3.3. Deep copy of Hyper-V SLAT CR3
	- 4.6. Returning execution to Hyper-V
	- 4.7. Hypercalls
		- 4.7.1 Hypercalls list & descriptions
5. Avoiding detection
6. Usermode app information
	- 6.1. Command usages and descriptions list
	- 6.2. Kernel hooks
	- 6.3. Command aliases
	- 6.4. Flushing logs
7. How to compile / use
	- 7.1. 'uefi-boot' compilation
	- 7.2. Architecture-specific compilation
	- 7.3. Load script
	- 7.4. Usage with Secure Boot
	- 7.5. Usage with TPM
8. Source code
9. Tested Windows versions
10. Credits

# 1. Introduction
hyper-reV is [memory introspection](https://hvmi.readthedocs.io/en/latest/chapters/1-overview.html) and reverse engineering [hypervisor](https://www.redhat.com/en/topics/virtualization/what-is-a-hypervisor) powered by leveraging [Hyper-V](https://en.wikipedia.org/wiki/Hyper-V). There is also a usermode component The project provides the following abilities for the guest - meaning the Windows operating system virtualized by Hyper-V - to: read and write to guest [virtual memory](https://wiki.osdev.org/Memory_management#Virtual_Address_Space) and [physical memory](https://wiki.osdev.org/Memory_management#Physical_Address_Space), translate guest virtual addresses to their corresponding guest physical addresses, [SLAT](https://en.wikipedia.org/wiki/Second_Level_Address_Translation) code hooks (also known as EPT/NPT hooks), and hiding entire pages of physical memory from the guest. The fact that it leverages Hyper-V means that it will also work under systems protected by [HVCI](https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity?tabs=security).

There is also a usermode component which serves as a [kernel debugger](https://en.wikipedia.org/wiki/Kernel_debugger).

# 2. Prior to boot
The 'uefi-boot' module is hyper-reV's UEFI driver. A copy of bootmgfw.efi is made. The contents of bootmgfw.efi are then replaced with the 'uefi-boot' module so that it will be executed at the next boot. The hyperv-attachment (the module inserted into Hyper-V) is also saved on disk in the same directory as bootmgfw.efi.

# 3. Boot process

![Boot process flow chart](images/boot_process.png)

## 3.1. Restoration of bootmgfw.efi
Once the 'uefi-boot' module is started, the original bootmgfw.efi file and any timestamp related metadata are restored to hide that the file has been tampered with. 

## 3.2. Heap
A [heap](https://wiki.osdev.org/Heap) is also [allocated](https://wiki.osdev.org/Memory_Allocation) using [UEFI boot_services!AllocatePages](https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-allocatepages) (so it is 4kB aligned, rather than using [boot_services!AllocatePool](https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id16) which does not guarantee that alignment).

This heap is used for allocating:
  - The hyperv-attachment runtime image buffer (then the hyperv-attachment file is deleted from disk as soon as it has been loaded into memory).
  - The [PML4 and PDPT](https://wiki.osdev.org/Page_Tables#48-bit_virtual_address_space) for the [identity map](https://wiki.osdev.org/Identity_Paging) which is later used.
  - The hyperv-attachment's internal heap.
  - The deep copy of Hyper-V's SLAT [CR3](https://wiki.osdev.org/CPU_Registers_x86#CR3)  (see 4.5).

All of this memory is later hidden from the guest by pointing each page in guest SLAT mappings to a dummy page.

## 3.3. Starting bootmgfw.efi
The original bootmgfw.efi image is then loaded through [UEFI boot_services!LoadImage](https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id37). A hook on bootmgfw.efi!ImgpLoadPEImage (a routine which loads a portable executable image) is applied. bootmgfw.efi is started using [UEFI boot_services!StartImage](https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id38).

## 3.4. winload.efi
Once the winload.efi image is being loaded by bootmgfw.efi, it is intercepted by the bootmgfw.efi!ImgpLoadPEImage hook. The bootmgfw.efi hooks are then fully removed before applying a hook to winload.efi!ImgpLoadPEImage. This winload.efi!ImgpLoadPEImage hook allows the loading of hvloader.dll to be intercepted once winload.efi loads it.

## 3.5. hvloader.dll & Hyper-V launch
Once the loading of hvloader.dll is intercepted via the winload.efi!ImgpLoadPEImage hook, a hook is applied deep in the Hyper-V launch routine within hvloader.dll after removing the hooks on winload.efi. Below is a stripped down decompilation of the Hyper-V launch routine that is hooked (it is called within hvloader.dll!HvlLaunchHypervisor):

```cpp
void __fastcall hv_launch(std::uint64_t hyperv_cr3, std::uint8_t* hyperv_entry_point, std::uint8_t* entry_point_gadget, std::uint64_t guest_kernel_cr3)
{
	__writecr3(guest_kernel_cr3);
	__asm { jmp entry_point_gadget }
}
```

This hooked Hyper-V launch routine will jump to a gadget which will end up in Hyper-V's entry point. The parameters are as follows:
  - rcx = a CR3 which Hyper-V copies certain PML4es from.
  - rdx = the virtual address of the relocated Hyper-V's entry point.
  - r8 = the address of the gadget which jumps to Hyper-V's entry point.
  - r9 = the guest's kernel CR3 (e.g. 0x1AE000 on Windows 11 24H2).

## 3.5.1. Loading hyperv-attachment
Continuing with the hook, a PML4e is inserted into the CR3 held in rcx. This PML4e contains an identity map of host physical memory. The physical memory backing the hyperv-attachment is also mapped in by this identity map, so there is a valid virtual mapping of the hyperv-attachment in Hyper-V's address space. The loaded hyperv-attachment image is [relocated](https://sabotagesec.com/pe-relocation-table/) by (virtual base of the PML4e/identity map + physical base address of hyperv-attachment image). This relocation means that the hyperv-attachment will be able to execute under Hyper-V's address space once it is launched.

As @Iraq1337 described in [his post](https://www.unknowncheats.me/forum/4323297-post8.html), there are a few copies of Hyper-V in physical memory which are not SLAT protected (the guest can read them). Only the final Hyper-V image buffer is hidden from the guest. In the hypervisor launch hook, rdx holds a virtual address backing the final image buffer, which WILL be SLAT protected, so patches can be applied to it without them being disclosed to the guest. In the launch routine hook, a hook is placed on Hyper-V's VM exit handler, pointing it to a code cave where a [far/long jump instruction](https://www.felixcloutier.com/x86/jmp) will detour to the hyperv-attachment's VM exit handler. All of this is done after the Hyper-V launch routine hook is removed.

# 4. hyperv-attachment/post Hyper-V launch info

## 4.1. How does it support different architectures?
The hyperv-attachment supports both Intel and AMD. This is possible through some abstraction of architecture-specific code and a few #ifdefs, meaning both architectures are supported in the same codebase. The steps to compile the hyperv-attachment for Intel or AMD are described in '7. How to compile / use'.

## 4.2. Entry point (pre Hyper-V launch)
The hyperv-attachment's entry point is called in the Hyper-V launch detour and does the following:
  - Sets up a heap manager.
  - Sets up initial SLAT context allocations.
  - Sets up processor state logs context.
  - Intakes some info from the uefi-boot image module for later usage (e.g. the physical base address and size of the uefi-boot image).

Host (the hypervisor running on the hardware which controls the guest) physical memory is accessed by the hyperv-attachment through the identity map that was set up before.

## 4.3. First VM exit
In the first VM exit, the hyperv-attachment does the following:
  - Sets up a NMI ([non maskable interrupt](https://wiki.osdev.org/Non_Maskable_Interrupt)) handler in Hyper-V's global IDT ([interrupt descriptor table](https://wiki.osdev.org/Interrupt_Descriptor_Table)).
  - Sets up the APIC ([Advanced Programmable Interrupt Controller](https://wiki.osdev.org/APIC)), which is later used to fire NMIs to all host logical processors to synchronize SLAT caches.
  - Nulls out the uefi-boot image to prevent the guest from searching for it.

Some processes cannot be done in the first VM exit (especially ones relating to SLAT), as Hyper-V has not fully finished initializing yet. After a certain amount of VM exits have taken place, the hyperv-attachment hides the heap (the one that was set up originally in the uefi-boot image) via SLAT. The hidden uefi-boot heap memory includes hyperv-attachment's internal heap, image allocation and identity map page table structures that were allocated. This is achieved by setting the page frame numbers of all the [page table entries](https://wiki.osdev.org/Page_Tables) to that of a free dummy page in the heap.

## 4.4. APIC
At the first VM exit, basic information of [APIC](https://wiki.osdev.org/APIC) is fetched through the 'APIC base' located at the [MSR](https://wiki.osdev.org/Model_Specific_Registers) 0x1B. If APIC is already enabled, then it is checked whether xAPIC or x2APIC is used. If APIC is not already enabled, then the highest possible version of APIC is enabled. For xAPIC, the ICR (interrupt command register) can be accessed through its host physical address at the [Local APIC](https://wiki.osdev.org/APIC#Local_APIC_configuration). For x2APIC, the ICR is accessed through the MSRs representing the Local APIC.

Through the ICR, commands can be sent to the Local APIC. This is later used to send Non Maskable Interrupts to all processors but the currently executing one by formulating an ICR request. Later on in the post, it is described how those NMIs are used for synchronizing SLAT code hooks (EPT/NPT hooks). The APIC library which was internally developed for this project and released separately [can be found here](https://github.com/noahware/APIC).

## 4.5. SLAT
A SLAT CR3 is a CR3 which describes SLAT/translations of guest physical memory to host physical memory. On AMD this is called a nested CR3. On Intel this is called an [EPT](https://en.wikipedia.org/wiki/Second_Level_Address_Translation#Extended_Page_Tables) pointer.

The Hyper-V SLAT CR3 is the global SLAT CR3 created by Hyper-V. This is shared by all logical processors in Hyper-V in both Intel and AMD.

The hook SLAT CR3 is explained 4.5.3.3. It is the SLAT CR3 that the hyperv-attachment creates by making a deep copy of the Hyper-V SLAT CR3.

The SLAT [code hooks](https://stackoverflow.com/questions/467557/what-is-meant-by-the-term-hook-in-programming) were implemented as follows:

## 4.5.1. Code hooks on Intel
![Intel SLAT violation flowchart](images/intel_slat_violation.png)

There is only 1 pointer (Intel's SLAT CR3), shared by all logical processors in Hyper-V.

The current core's EPT pointer changes between the hook SLAT CR3 and the Hyper-V SLAT CR3 in the EPT violation handler as needed. This is because both these SLAT CR3s hold mappings for the target page, but with different permissions.

When a hook is added, the following happens to the target page:
  - The page is made --x (non readable, non writable, but is executable) in the Hyper-V SLAT CR3.
  - The page's page frame number is set to that of the shadow page in the Hyper-V SLAT CR3.
  - The page is made rw- (is readable, is writable, but non executable) in the hook SLAT CR3.
  - The page's page frame number is set to that of the original page in the hook SLAT CR3.

When the target page is executed under the Hyper-V SLAT CR3, the shadow page is executed. No reads or writes can occur to the target page either, as the permission is --x.

Now if a read or write occurs in the guest to the hooked page, an EPT violation will be raised. In the EPT violation handler, the current core's EPT pointer is set to the hook SLAT CR3. This means that the target page can now be read/written to, but just under the original page frame number (so the contents of the shadow page are hidden).

In case of execution of the page again, these changes reversed and vice versa.

This is very performant as EPT violations only occur when the permissions of the page require to be changed.

## 4.5.2. Code hooks on AMD
![AMD SLAT violation flowchart](images/amd_slat_violation.png)

AMD's SLAT implementation is called [NPT](https://en.wikipedia.org/wiki/Second_Level_Address_Translation#Rapid_Virtualization_Indexing).

As there is no 'read access' bit in the page table entries, execute-only pages are not possible in AMD through NPT. This makes the implementation is less performant as a [nested page fault](https://tandasat.github.io/Hypervisor-101-in-Rust/memory-virtualization/nested-page-fault.html) has to occur for every execution of the target page.

In the hook SLAT CR3, all non-hooked pages are set as non executable, meaning it can only execute the pages that are hooked.

When a hook is added, the following happens to the target page:
  - The page is set to non-executable in the Hyper-V SLAT CR3 (so it CAN NOT execute under the Hyper-V SLAT CR3).
  - In the hook SLAT CR3 the page is made executable (so it CAN execute under the hook SLAT CR3).
  - In the hook SLAT CR3 the page frame number is set to that of the shadow page.

When the hooked page is executed under the Hyper-V SLAT CR3, a nested page fault is raised as the hooked page is non executable in that SLAT CR3. In the nested page fault handler, the current core's SLAT CR3 is set to the hook SLAT CR3. When execution is returned to the guest, the hooked page is now executable (and executing the shadow page with the 'hidden contents').

Once execution reaches a non-hooked page when under the hook SLAT CR3 (signalled by a nested page fault caused by execution of any non-hooked page), the current core's SLAT CR3 is reverted to the Hyper-V SLAT CR3 and execution can continue as normal until a hooked page is executed again.

When a page is hooked, the page before and after the target page are set to be executable in the hook SLAT CR3. This prevents issues where there are instructions split over the page boundary of a hooked page (as suggested by @papstuc).

To get the [VMCB](https://blog.back.engineering/04/08/2022/#virtual-machine-control-block-vmcb---parts), @Iraq1337 gave example code of how he does it and the setting up of the hook SLAT CR3. He also explained the logic behind NPT hooks.

## 4.5.3. Code hook features common to both AMD and Intel

## 4.5.3.1. Page split/merge
If a large page has to be split ([PDe or PDPTe](https://wiki.osdev.org/Page_Tables#48-bit_virtual_address_space)), to be able to get a [PTe](https://wiki.osdev.org/Page_Tables#48-bit_virtual_address_space) to represent the target 4kB guest physical page to hook, those entries are merged back together when the hook is removed (if no other hooks are in that merge range).

This is done to save some heap memory that was used to allocate those lower paging structures and it also improves SLAT performance. The hook_entry_t linked list structure which is used to describe a SLAT code hook fits in just 16 bytes, allowing 256 EPT/NPT hooks to be described in just 4kB.

## 4.5.3.2. Synchronization using NMIs
APIC is used to send NMIs to all host logical processors to invalidate SLAT caches. This is paired with a bitmap signaling what logical processors need to invalidate their caches. This was done as there was an issue with synchronization of hooks (where @papstuc suggested to synchronize the SLAT caches). Once a logical processor receives the NMI, the following will happen depending on if the processor was in host or guest state:

## 4.5.3.2.1. NMIs in host state
If the processor was in host state when the NMI hit the processor, it will be delivered to the handler described in the IDT of the host. In the interrupt entry, [all general purpose and XMM registers](https://wiki.osdev.org/CPU_Registers_x86-64) are saved on the stack before calling the NMI processor function. The NMI processor function clears the SLAT cache if it was signaled to be cleared in the bitmap.

The reason why the SLAT cache is not always cleared in every NMI is because [Hyper-V uses NMIs for inter processor communication](https://forum.osdev.org/viewtopic.php?p=345109#p345109). That is why there is a bitmap which signals if a logical processor still requires a cache flush.

Once the NMI processor returns, all of the general purpose and XMM registers are restored to their original values. After this, the hyperv-attachment's NMI handler jumps to the original NMI handler that Hyper-V had set up in the IDT (or return from the interrupt directly if there was no handler set up by Hyper-V for some reason).

Host NMIs are not currently handled in AMD, but it makes little difference as there are many frequent guest NMI exits which the hyperv-attachment can use to flush the SLAT cache. Intel handles both host and guest-exiting NMIs.

## 4.5.3.2.2. NMIs in guest state
If the processor was in a guest state when the NMI hit the processor, the guest will VM exit with a reason of a 'physical NMI' and the same NMI processor function is called from the VM exit handler with no need to preserve registers.

## 4.5.3.3. Deep copy of Hyper-V SLAT CR3

When the first SLAT hook is added, a deep copy is done of the Hyper-V SLAT CR3. This means that all of the SLAT entries are copied. This is done into the hook SLAT CR3.

## 4.6. Returning execution to Hyper-V
If a VM exit is not handled by the hyperv-attachment, execution is transferred to Hyper-V's original VM exit handler.

## 4.7. Hypercalls
The hyperv-attachment exposes [hypercalls](https://wiki.xenproject.org/wiki/Hypercall) for the guest to make. The project monitors the usage of the [CPUID instruction](https://wiki.osdev.org/CPUID) to process hypercalls from the guest. When the execution of a CPUID instruction happens in the guest, a VM exit occurs. In its CPUID handler, the hyperv-attachment checks if it is a valid hypercall coming from hyper-reV (through some unique values in registers). If it is not a valid hypercall coming from hyper-reV, execution is returned to Hyper-V (as mentioned in 4.6).

## 4.7.1. Hypercalls list & descriptions
guest_physical_memory_operation - read / write guest physical memory
guest_virtual_memory_operation - read / write guest virtual memory
translate_guest_virtual_address - translate a guest virtual address to a guest physical address
read_guest_cr3 - get the current guest CR3
add_slat_code_hook - add a SLAT code hook
remove_slat_code_hook - remove a SLAT code hook
hide_guest_physical_page - hide a guest physical page from the guest
log_current_state - log the current processor state in a trap frame, logs can be flushed later
flush_logs - flush all the logs to a guest virtual buffer
get_heap_free_page_count - get the amount of free pages left in hyperv-attachment's heap

# 5. Avoiding detection
One of the main goals of this project is to avoid the detection vectors that other similar projects have. By allocating the hyperv-attachment independently from the Hyper-V image, the project evades the detection of memory allocations located after the Hyper-V image allocation being shifted by the size of the inserted image.

In addition, the project only applies hooks to the final Hyper-V image protected by SLAT. This avoids the detection of a guest searching for copies of the Hyper-V image (e.g. one from when it is initially loaded from disk) which are not protected by SLAT. Furthermore, bootmgfw.efi's (Windows' bootloader which is replaced prior to boot with the uefi-boot.efi module) original file metadata (e.g. time modified) is restored to hide that it has been tampered with.

# 6. Usermode app information
The usermode app serves as a kernel debugger, as well as an example of what can be achieved with the project's capabilities. It has many 'commands' you may execute through the command line interface. The app uses [CLI11](https://github.com/CLIUtils/CLI11) for command parsing. 

## 6.1. Command usages and descriptions list
rgpm - reads memory from a given guest physical address.
Usage: rgpm physical_address size

wgpm - writes memory to a given guest physical address
Usage: wgpm physical_address value size

cgpm - copies memory from a given source to a destination (guest physical addresses)
Usage: cgpm destination_physical_address source_physical_address size

gvat - translates a guest virtual address to its corresponding guest physical address, with the given guest CR3 value
Usage: gvat virtual_address CR3

rgvm - reads memory from a given guest virtual address (when given the corresponding guest CR3 value)
Usage: rgvm virtual_address CR3 size

wgvm - writes memory from a given guest virtual address (when given the corresponding guest CR3 value)
Usage: wgvm virtual_address CR3 value size

cgvm - copies memory from a given source to a destination (guest virtual addresses) (when given the corresponding guest CR3 values)
Usage: cgvm destination_virtual_address destination_CR3 source_virtual_address source_CR3 size

akh - add a hook on specified kernel code (given the guest virtual address) (asmbytes in form: 0xE8 0x12 0x23 0x34 0x45)
Usage: akh [OPTIONS] virtual_address
Example: akh ntoskrnl.exe!PsLookupProcessByProcessId --monitor --asmbytes 0x90 0x90 --post_original_asmbytes 0x90
Options:
--asmbytes
--post_original_asmbytes
--monitor

rkh - remove a previously placed hook on specified kernel code (given the guest virtual address)
Usage: rkh virtual_address

gva - get the numerical value of an alias
Usage: gva alias_name

hgpp - hide a physical page's real contents from the guest
Usage: hgpp physical_address

fl - flush trap frame logs from hooks
Usage: fl

hfpc - get hyperv-attachment's heap free page count
Usage: hfpc

lkm - print list of loaded kernel modules
Usage: lkm

kme - list the exports of a loaded kernel module (when given the name)
Usage: kme module_name

dkm - dump kernel module to a file on disk
Usage: dkm module_name output_directory

## 6.2. Kernel hooks
On startup, the app finds a suitable page in ntoskrnl.exe (the main Windows kernel image) to use as the 'detour holder'. This is where the original bytes of the hooked routine that have been overwritten by the [inline hook](https://www.codereversing.com/archives/592) on the shadow page will reside.

By using a pre-existing page, a new kernel executable page does not have to be allocated (which would have been suspicious to some security tools had an unknown kernel page being caught executing). This page is SLAT hooked so the executable contents will be hidden from the guest.

This page from ntoskrnl.exe might not typically be executed, so it may be wiser to load an unused kernel driver that will not be actively executing, and use a random page from its .text section as the detour holder instead.

Utilizing SLAT code hooks, kernel routines can be hooked with the usermode app. This is done by applying an inline hook on the shadow page, which then jumps to a location holding the original bytes, a typical detour.

The command allows the user to specify some assembly (in hex form) to be executed either before/after the original bytes execute (via --asmbytes / --post_original_asmbytes in command arguments), as well as making the hooked routine log the processor state whenever it is executed (via --monitor in the command arguments).

Unlike most other hypervisor assisted debuggers, this project fully resolves [rip relative operands](https://wiki.osdev.org/X86-64_Instruction_Encoding#RIP/EIP-relative_addressing) to their absolute values. This means that the user can place hooks on a routine where the original bytes have rip relative operands (e.g. jz 50 or relative call/jmp to a routine). This also resolves rip relative memory accesses (e.g. cmp [rip+x], 0).

## 6.3. Command aliases
The usermode app also parses all loaded kernel modules, so the user can reference a module's exports or base address by name (e.g. ntoskrnl.exe!PsLookupProcessByProcessId or ntoskrnl.exe). In addition, the current CR3 that the process executes under can be referenced using 'current_cr3'.

## 6.4. Flushing logs
The logs [capture general purpose registers (from rax-r15)](https://wiki.osdev.org/CPU_Registers_x86-64), the [rip](https://wiki.osdev.org/CPU_Registers_x86#Pointer_Registers), the CR3, and a snapshot of [the stack](https://wiki.osdev.org/Stack).

These logs are generated by placing the '--monitor' flag on the kernel hook command. This way, when the hook is executed, it calls to the hypervisor to log the processor state each time. When the logs are flushed using the 'fl' / flush logs command in the usermode app, it looks as follows:

0. rip=0xFFFFF8049B0BA5E6 rax=0x3 rcx=0x538
rdx=0xFFFFAF869BF2F260 rbx=0x0 rsp=0xFFFFAF869BF2F208 rbp=0xFFFFAF869BF2F360
rsi=0x80 rdi=0x538 r8=0xFFFFAF869BF2F5A0 r9=0xFFFFE486C68FA800
r10=0xFFFFF8049B0BA5E0 r11=0xFFFFAF869BF2F458 r12=0xFFFFF8042D693000 r13=0xFFFFE486CD91E000 r14=0xFFFFAF869BF2F2A8
r15=0x0 CR3=0x1B473C000

stack data:
  0xFFFFF8042D6A7724
  0x0
  0x8
  0xFFFF3B4D56ACD14A
  0x0

# 7. How to compile / use

## 7.1. 'uefi-boot' compilation
To compile the uefi-boot module, you must install NASM (https://nasm.us) and "check that the environment variable NASM_PREFIX is correctly set to NASM installation path" (quoted from https://github.com/ionescu007/VisualUefi/#Installation).

All submodules must be cloned (VisualUEFI / EDK2). They will reside in uefi-boot\ext.

The command to clone the repository (including submodules):

```
git clone --recurse-submodules https://github.com/noahware/hyper-reV.git
```

In addition, you must build the EDK2 libraries by opening uefi-boot\ext\edk2\build\EDK-II.sln and building the entire solution.

## 7.2. Architecture-specific compilation
The hyperv-attachment must be selected to be built for either Intel or AMD.

To compile the hyperv-attachment for Intel: #define _INTELMACHINE in arch_config.h (which is in the hyperv-attachment src directory).

To compile for AMD, simply comment that aforementioned #define line out and rebuild. 

The binaries of the uefi-boot module and usermode app will work for both Intel and AMD no matter the configuration specified in the hyperv-attachment.

## 7.3. Load script
There is a script ('load-hyper-reV.bat') in the root directory of the project which will place the uefi-boot module and the hyperv-attachment in the EFI partition when ran as administrator in the same directory as the uefi-boot.efi and the hyperv-attachment.dll files. Once you run this, hyper-reV will load at the next boot.

## 7.4. Usage with Secure Boot
To load the project with [secure boot](https://access.redhat.com/articles/5254641) enabled, a vulnerable [bootloader](https://wiki.osdev.org/Bootloader) could be exploited, as described in [this post](https://habr.com/articles/446238/).

## 7.5. Usage with TPM
If evading an advanced security tool, it is not recommend to run the project with [TPM](https://en.wikipedia.org/wiki/Trusted_Platform_Module) enabled if the security tool performs [boot attestation](https://learn.microsoft.com/en-us/azure/attestation/tpm-attestation-concepts). This is because it can see that the uefi-boot binary was loaded (through info stored in the TPM PCRs or through [measured boot](https://learn.microsoft.com/en-us/azure/security/fundamentals/measured-boot-host-attestation) logs). This paragraph's information is from [Zepta's post](https://www.unknowncheats.me/forum/anti-cheat-bypass/623028-measuredboot-tpm.html).

# 8. Source code
The source code can be found on this [GitHub](https://github.com/noahware/hyper-reV).

# 9. Tested Windows versions
The project has been tested on the following versions on both Intel and AMD:

Windows 10 21H2, Windows 10 22H2, Windows 11 22H2, Windows 11 23H2, Windows 11 24H2.

Ensure the latest minor updates for those major Windows versions are applied if the project does not work. The system must also be able to run Hyper-V.

# 10. Credits
[John / @Iraq1337](https://github.com/vmp38) - invaluable advice, especially with AMD theory, examples of nested CR3 identity mapping and a way to get the VMCB. In addition, he also suggested to apply patches to Hyper-V right before it launches.

[@papstuc](https://github.com/papstuc) - crucial advice, especially for the suggestion of synchronizing EPT/NPT cache across all processors, his idea for AMD NPT hooks on page splits and [his Windows file format parsing library](https://github.com/papstuc/portable_executable) used in the usermode app.

mylostchristmas - found that the prior method of allocating SLAT protected SLAB pages via winload.efi's SLAB allocator did not function the same way on 24H2. This functionality was then removed from the project and replaced with in-house SLAT protection.
```

`hyper-reV.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35514.174
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "uefi-boot", "uefi-boot\uefi-boot.vcxproj", "{A8C03EEB-3FE7-4EAB-B1F8-273A441BC8B9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "hyperv-attachment", "hyperv-attachment\hyperv-attachment.vcxproj", "{13A77C37-9BB2-445D-8E81-9687E455C2E6}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "usermode", "usermode\usermode.vcxproj", "{2EA786E4-1147-4804-AEAD-17975E24EC46}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A8C03EEB-3FE7-4EAB-B1F8-273A441BC8B9}.Release|x64.ActiveCfg = Release|x64
		{A8C03EEB-3FE7-4EAB-B1F8-273A441BC8B9}.Release|x64.Build.0 = Release|x64
		{13A77C37-9BB2-445D-8E81-9687E455C2E6}.Release|x64.ActiveCfg = Release|x64
		{13A77C37-9BB2-445D-8E81-9687E455C2E6}.Release|x64.Build.0 = Release|x64
		{2EA786E4-1147-4804-AEAD-17975E24EC46}.Release|x64.ActiveCfg = Release|x64
		{2EA786E4-1147-4804-AEAD-17975E24EC46}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`hyperv-attachment/ext/ia32-doc/ia32.hpp`:

```hpp
/** @file */
#pragma once
using uint8_t = unsigned char;
using uint16_t = unsigned short;
using uint32_t = unsigned int;
using uint64_t = unsigned long long;

#if defined(_MSC_EXTENSIONS)
#pragma warning(push)
#pragma warning(disable: 4201)
#endif

/**
 * @defgroup intel_manual \
 *           Intel Manual
 *
 * @remarks All references are based on <b>Intel(R) 64 and IA-32 architectures software developer's manual combined volumes:
 *          1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4</b> (June 2021) and <b>Intel(R) Virtualization Technology for Directed I/O</b>
 *          (April 2021)
 * @{
 */
 /**
  * @defgroup control_registers \
  *           Control registers
  *
  * Control registers (CR0, CR1, CR2, CR3, and CR4) determine operating mode of the processor and the characteristics of the
  * currently executing task. These registers are 32 bits in all 32-bit modes and compatibility mode.
  * In 64-bit mode, control registers are expanded to 64 bits. The MOV CRn instructions are used to manipulate the register
  * bits. Operand-size prefixes for these instructions are ignored. The following is also true:
  * - The control registers can be read and loaded (or modified) using the move-to-or-from-control-registers forms of the
  * MOV instruction. In protected mode, the MOV instructions allow the control registers to be read or loaded (at privilege
  * level 0 only). This restriction means that application programs or operating-system procedures (running at privilege
  * levels 1, 2, or 3) are prevented from reading or loading the control registers.
  * - Bits 63:32 of CR0 and CR4 are reserved and must be written with zeros. Writing a nonzero value to any of the upper 32
  * bits results in a general-protection exception, \#GP(0).
  * - All 64 bits of CR2 are writable by software.
  * - Bits 51:40 of CR3 are reserved and must be 0.
  * - The MOV CRn instructions do not check that addresses written to CR2 and CR3 are within the linear-address or
  * physical-address limitations of the implementation.
  * - Register CR8 is available in 64-bit mode only. The control registers are summarized below, and each architecturally
  * defined control field in these control registers is described individually.
  * - CR0 - Contains system control flags that control operating mode and states of the processor.
  * - CR1 - Reserved.
  * - CR2 - Contains the page-fault linear address (the linear address that caused a page fault).
  * - CR3 - Contains the physical address of the base of the paging-structure hierarchy and two flags (PCD and PWT). Only
  * the most-significant bits (less the lower 12 bits) of the base address are specified; the lower 12 bits of the address
  * are assumed to be 0. The first paging structure must thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags
  * control caching of that paging structure in the processor's internal data caches (they do not control TLB caching of
  * page-directory information). When using the physical address extension, the CR3 register contains the base address of
  * the page-directorypointer table. In IA-32e mode, the CR3 register contains the base address of the PML4 table.
  * - CR4 - Contains a group of flags that enable several architectural extensions, and indicate operating system or
  * executive support for specific processor capabilities.
  * - CR8 - Provides read and write access to the Task Priority Register (TPR). It specifies the priority threshold value
  * that operating systems use to control the priority class of external interrupts allowed to interrupt the processor. This
  * register is available only in 64-bit mode. However, interrupt filtering continues to apply in compatibility mode.
  *
  * @see Vol3A[2.5(CONTROL REGISTERS)] (reference)
  * @{
  */
typedef union
{
    struct
    {
        /**
         * @brief Protection Enable
         *
         * [Bit 0] Enables protected mode when set; enables real-address mode when clear. This flag does not enable paging
         * directly. It only enables segment-level protection. To enable paging, both the PE and PG flags must be set.
         *
         * @see Vol3A[9.9(Mode Switching)]
         */
        uint64_t protection_enable : 1;
#define CR0_PROTECTION_ENABLE_BIT                                    0
#define CR0_PROTECTION_ENABLE_FLAG                                   0x01
#define CR0_PROTECTION_ENABLE_MASK                                   0x01
#define CR0_PROTECTION_ENABLE(_)                                     (((_) >> 0) & 0x01)

        /**
         * @brief Monitor Coprocessor
         *
         * [Bit 1] Controls the interaction of the WAIT (or FWAIT) instruction with the TS flag (bit 3 of CR0). If the MP flag is
         * set, a WAIT instruction generates a device-not-available exception (\#NM) if the TS flag is also set. If the MP flag is
         * clear, the WAIT instruction ignores the setting of the TS flag.
         */
        uint64_t monitor_coprocessor : 1;
#define CR0_MONITOR_COPROCESSOR_BIT                                  1
#define CR0_MONITOR_COPROCESSOR_FLAG                                 0x02
#define CR0_MONITOR_COPROCESSOR_MASK                                 0x01
#define CR0_MONITOR_COPROCESSOR(_)                                   (((_) >> 1) & 0x01)

        /**
         * @brief FPU Emulation
         *
         * [Bit 2] Indicates that the processor does not have an internal or external x87 FPU when set; indicates an x87 FPU is
         * present when clear. This flag also affects the execution of MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * When the EM flag is set, execution of an x87 FPU instruction generates a device-not-available exception (\#NM). This
         * flag must be set when the processor does not have an internal x87 FPU or is not connected to an external math
         * coprocessor. Setting this flag forces all floating-point instructions to be handled by software emulation.
         * Also, when the EM flag is set, execution of an MMX instruction causes an invalid-opcode exception (\#UD) to be
         * generated. Thus, if an IA-32 or Intel 64 processor incorporates MMX technology, the EM flag must be set to 0 to enable
         * execution of MMX instructions. Similarly for SSE/SSE2/SSE3/SSSE3/SSE4 extensions, when the EM flag is set, execution of
         * most SSE/SSE2/SSE3/SSSE3/SSE4 instructions causes an invalid opcode exception (\#UD) to be generated. If an IA-32 or
         * Intel 64 processor incorporates the SSE/SSE2/SSE3/SSSE3/SSE4 extensions, the EM flag must be set to 0 to enable
         * execution of these extensions. SSE/SSE2/SSE3/SSSE3/SSE4 instructions not affected by the EM flag include: PAUSE,
         * PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         */
        uint64_t emulate_fpu : 1;
#define CR0_EMULATE_FPU_BIT                                          2
#define CR0_EMULATE_FPU_FLAG                                         0x04
#define CR0_EMULATE_FPU_MASK                                         0x01
#define CR0_EMULATE_FPU(_)                                           (((_) >> 2) & 0x01)

        /**
         * @brief Task Switched
         *
         * [Bit 3] Allows the saving of the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context on a task switch to be delayed until an
         * x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction is actually executed by the new task. The processor sets this flag on
         * every task switch and tests it when executing x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         * - If the TS flag is set and the EM flag (bit 2 of CR0) is clear, a device-not-available exception (\#NM) is raised prior
         * to the execution of any x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction; with the exception of PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * - If the TS flag is set and the MP flag (bit 1 of CR0) and EM flag are clear, an \#NM exception is not raised prior to
         * the execution of an x87 FPU WAIT/FWAIT instruction.
         * - If the EM flag is set, the setting of the TS flag has no effect on the execution of x87
         * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
         *   The processor does not automatically save the context of the x87 FPU, XMM, and MXCSR registers on a task switch.
         *   Instead, it sets the TS flag, which causes the processor to raise an \#NM exception whenever it encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction in the instruction stream for the new task (with the exception of the
         *   instructions listed above).
         *   The fault handler for the \#NM exception can then be used to clear the TS flag (with the CLTS instruction) and save
         *   the context of the x87 FPU, XMM, and MXCSR registers. If the task never encounters an x87
         *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction, the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context is never saved.
         */
        uint64_t task_switched : 1;
#define CR0_TASK_SWITCHED_BIT                                        3
#define CR0_TASK_SWITCHED_FLAG                                       0x08
#define CR0_TASK_SWITCHED_MASK                                       0x01
#define CR0_TASK_SWITCHED(_)                                         (((_) >> 3) & 0x01)

        /**
         * @brief Extension Type
         *
         * [Bit 4] Reserved in the Pentium 4, Intel Xeon, P6 family, and Pentium processors. In the Pentium 4, Intel Xeon, and P6
         * family processors, this flag is hardcoded to 1. In the Intel386 and Intel486 processors, this flag indicates support of
         * Intel 387 DX math coprocessor instructions when set.
         */
        uint64_t extension_type : 1;
#define CR0_EXTENSION_TYPE_BIT                                       4
#define CR0_EXTENSION_TYPE_FLAG                                      0x10
#define CR0_EXTENSION_TYPE_MASK                                      0x01
#define CR0_EXTENSION_TYPE(_)                                        (((_) >> 4) & 0x01)

        /**
         * @brief Numeric Error
         *
         * [Bit 5] Enables the native (internal) mechanism for reporting x87 FPU errors when set; enables the PC-style x87 FPU
         * error reporting mechanism when clear. When the NE flag is clear and the IGNNE\# input is asserted, x87 FPU errors are
         * ignored. When the NE flag is clear and the IGNNE\# input is deasserted, an unmasked x87 FPU error causes the processor
         * to assert the FERR\# pin to generate an external interrupt and to stop instruction execution immediately before
         * executing the next waiting floating-point instruction or WAIT/FWAIT instruction.
         * The FERR\# pin is intended to drive an input to an external interrupt controller (the FERR\# pin emulates the ERROR\#
         * pin of the Intel 287 and Intel 387 DX math coprocessors). The NE flag, IGNNE\# pin, and FERR\# pin are used with
         * external logic to implement PC-style error reporting. Using FERR\# and IGNNE\# to handle floating-point exceptions is
         * deprecated by modern operating systems; this non-native approach also limits newer processors to operate with one
         * logical processor active.
         *
         * @see Vol1[8.7(Handling x87 FPU Exceptions in Software)]
         * @see Vol1[A.1(APPENDIX A | EFLAGS Cross-Reference)]
         */
        uint64_t numeric_error : 1;
#define CR0_NUMERIC_ERROR_BIT                                        5
#define CR0_NUMERIC_ERROR_FLAG                                       0x20
#define CR0_NUMERIC_ERROR_MASK                                       0x01
#define CR0_NUMERIC_ERROR(_)                                         (((_) >> 5) & 0x01)
        uint64_t reserved1 : 10;

        /**
         * @brief Write Protect
         *
         * [Bit 16] When set, inhibits supervisor-level procedures from writing into readonly pages; when clear, allows
         * supervisor-level procedures to write into read-only pages (regardless of the U/S bit setting). This flag facilitates
         * implementation of the copy-onwrite method of creating a new process (forking) used by operating systems such as UNIX.
         *
         * @see Vol3A[4.1.3(Paging-Mode Modifiers)]
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        uint64_t write_protect : 1;
#define CR0_WRITE_PROTECT_BIT                                        16
#define CR0_WRITE_PROTECT_FLAG                                       0x10000
#define CR0_WRITE_PROTECT_MASK                                       0x01
#define CR0_WRITE_PROTECT(_)                                         (((_) >> 16) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief Alignment Mask
         *
         * [Bit 18] Enables automatic alignment checking when set; disables alignment checking when clear. Alignment checking is
         * performed only when the AM flag is set, the AC flag in the EFLAGS register is set, CPL is 3, and the processor is
         * operating in either protected or virtual-8086 mode.
         */
        uint64_t alignment_mask : 1;
#define CR0_ALIGNMENT_MASK_BIT                                       18
#define CR0_ALIGNMENT_MASK_FLAG                                      0x40000
#define CR0_ALIGNMENT_MASK_MASK                                      0x01
#define CR0_ALIGNMENT_MASK(_)                                        (((_) >> 18) & 0x01)
        uint64_t reserved3 : 10;

        /**
         * @brief Not Write-through
         *
         * [Bit 29] When the NW and CD flags are clear, write-back (for Pentium 4, Intel Xeon, P6 family, and Pentium processors)
         * or write-through (for Intel486 processors) is enabled for writes that hit the cache and invalidation cycles are enabled.
         */
        uint64_t not_write_through : 1;
#define CR0_NOT_WRITE_THROUGH_BIT                                    29
#define CR0_NOT_WRITE_THROUGH_FLAG                                   0x20000000
#define CR0_NOT_WRITE_THROUGH_MASK                                   0x01
#define CR0_NOT_WRITE_THROUGH(_)                                     (((_) >> 29) & 0x01)

        /**
         * @brief Cache Disable
         *
         * [Bit 30] When the CD and NW flags are clear, caching of memory locations for the whole of physical memory in the
         * processor's internal (and external) caches is enabled. When the CD flag is set, caching is restricted. To prevent the
         * processor from accessing and updating its caches, the CD flag must be set and the caches must be invalidated so that no
         * cache hits can occur.
         *
         * @see Vol3A[11.5.3(Preventing Caching)]
         * @see Vol3A[11.5(CACHE CONTROL)]
         */
        uint64_t cache_disable : 1;
#define CR0_CACHE_DISABLE_BIT                                        30
#define CR0_CACHE_DISABLE_FLAG                                       0x40000000
#define CR0_CACHE_DISABLE_MASK                                       0x01
#define CR0_CACHE_DISABLE(_)                                         (((_) >> 30) & 0x01)

        /**
         * @brief Paging Enable
         *
         * [Bit 31] Enables paging when set; disables paging when clear. When paging is disabled, all linear addresses are treated
         * as physical addresses. The PG flag has no effect if the PE flag (bit 0 of register CR0) is not also set; setting the PG
         * flag when the PE flag is clear causes a general-protection exception (\#GP).
         * On Intel 64 processors, enabling and disabling IA-32e mode operation also requires modifying CR0.PG.
         *
         * @see Vol3A[4(PAGING)]
         */
        uint64_t paging_enable : 1;
#define CR0_PAGING_ENABLE_BIT                                        31
#define CR0_PAGING_ENABLE_FLAG                                       0x80000000
#define CR0_PAGING_ENABLE_MASK                                       0x01
#define CR0_PAGING_ENABLE(_)                                         (((_) >> 31) & 0x01)
        uint64_t reserved4 : 32;
    };

    uint64_t flags;
} cr0;

typedef union
{
    struct
    {
        uint64_t reserved1 : 3;

        /**
         * @brief Page-level Write-Through
         *
         * [Bit 3] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        uint64_t page_level_write_through : 1;
#define CR3_PAGE_LEVEL_WRITE_THROUGH_BIT                             3
#define CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG                            0x08
#define CR3_PAGE_LEVEL_WRITE_THROUGH_MASK                            0x01
#define CR3_PAGE_LEVEL_WRITE_THROUGH(_)                              (((_) >> 3) & 0x01)

        /**
         * @brief Page-level Cache Disable
         *
         * [Bit 4] Controls the memory type used to access the first paging structure of the current paging-structure hierarchy.
         * This bit is not used if paging is disabled, with PAE paging, or with 4-level paging2 if CR4.PCIDE=1.
         *
         * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
         */
        uint64_t page_level_cache_disable : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT                             4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG                            0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK                            0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_)                              (((_) >> 4) & 0x01)
        uint64_t reserved2 : 7;

        /**
         * @brief Address of page directory
         *
         * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit paging) or PML4 table (64-bit paging) used
         * for linear-address translation.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         * @see Vol3A[4.5(4-LEVEL PAGING)]
         */
        uint64_t address_of_page_directory : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT                            12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG                           0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK                           0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved3 : 16;
    };

    uint64_t flags;
} cr3;

typedef union
{
    struct
    {
        /**
         * @brief Virtual-8086 Mode Extensions
         *
         * [Bit 0] Enables interrupt- and exception-handling extensions in virtual-8086 mode when set; disables the extensions when
         * clear. Use of the virtual mode extensions can improve the performance of virtual-8086 applications by eliminating the
         * overhead of calling the virtual- 8086 monitor to handle interrupts and exceptions that occur while executing an 8086
         * program and, instead, redirecting the interrupts and exceptions back to the 8086 program's handlers. It also provides
         * hardware support for a virtual interrupt flag (VIF) to improve reliability of running 8086 programs in multitasking and
         * multiple-processor environments.
         *
         * @see Vol3B[20.3(INTERRUPT AND EXCEPTION HANDLING IN VIRTUAL-8086 MODE)]
         */
        uint64_t virtual_mode_extensions : 1;
#define CR4_VIRTUAL_MODE_EXTENSIONS_BIT                              0
#define CR4_VIRTUAL_MODE_EXTENSIONS_FLAG                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS_MASK                             0x01
#define CR4_VIRTUAL_MODE_EXTENSIONS(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief Protected-Mode Virtual Interrupts
         *
         * [Bit 1] Enables hardware support for a virtual interrupt flag (VIF) in protected mode when set; disables the VIF flag in
         * protected mode when clear.
         *
         * @see Vol3B[20.4(PROTECTED-MODE VIRTUAL INTERRUPTS)]
         */
        uint64_t protected_mode_virtual_interrupts : 1;
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT                    1
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG                   0x02
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK                   0x01
#define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_)                     (((_) >> 1) & 0x01)

        /**
         * @brief Time Stamp Disable
         *
         * [Bit 2] Restricts the execution of the RDTSC instruction to procedures running at privilege level 0 when set; allows
         * RDTSC instruction to be executed at any privilege level when clear. This bit also applies to the RDTSCP instruction if
         * supported (if CPUID.80000001H:EDX[27] = 1).
         */
        uint64_t timestamp_disable : 1;
#define CR4_TIMESTAMP_DISABLE_BIT                                    2
#define CR4_TIMESTAMP_DISABLE_FLAG                                   0x04
#define CR4_TIMESTAMP_DISABLE_MASK                                   0x01
#define CR4_TIMESTAMP_DISABLE(_)                                     (((_) >> 2) & 0x01)

        /**
         * @brief Debugging Extensions
         *
         * [Bit 3] References to debug registers DR4 and DR5 cause an undefined opcode (\#UD) exception to be generated when set;
         * when clear, processor aliases references to registers DR4 and DR5 for compatibility with software written to run on
         * earlier IA-32 processors.
         *
         * @see Vol3B[17.2.2(Debug Registers DR4 and DR5)]
         */
        uint64_t debugging_extensions : 1;
#define CR4_DEBUGGING_EXTENSIONS_BIT                                 3
#define CR4_DEBUGGING_EXTENSIONS_FLAG                                0x08
#define CR4_DEBUGGING_EXTENSIONS_MASK                                0x01
#define CR4_DEBUGGING_EXTENSIONS(_)                                  (((_) >> 3) & 0x01)

        /**
         * @brief Page Size Extensions
         *
         * [Bit 4] Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging to pages of 4 KBytes when clear.
         *
         * @see Vol3A[4.3(32-BIT PAGING)]
         */
        uint64_t page_size_extensions : 1;
#define CR4_PAGE_SIZE_EXTENSIONS_BIT                                 4
#define CR4_PAGE_SIZE_EXTENSIONS_FLAG                                0x10
#define CR4_PAGE_SIZE_EXTENSIONS_MASK                                0x01
#define CR4_PAGE_SIZE_EXTENSIONS(_)                                  (((_) >> 4) & 0x01)

        /**
         * @brief Physical Address Extension
         *
         * [Bit 5] When set, enables paging to produce physical addresses with more than 32 bits. When clear, restricts physical
         * addresses to 32 bits. PAE must be set before entering IA-32e mode.
         *
         * @see Vol3A[4(PAGING)]
         */
        uint64_t physical_address_extension : 1;
#define CR4_PHYSICAL_ADDRESS_EXTENSION_BIT                           5
#define CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG                          0x20
#define CR4_PHYSICAL_ADDRESS_EXTENSION_MASK                          0x01
#define CR4_PHYSICAL_ADDRESS_EXTENSION(_)                            (((_) >> 5) & 0x01)

        /**
         * @brief Machine-Check Enable
         *
         * [Bit 6] Enables the machine-check exception when set; disables the machine-check exception when clear.
         *
         * @see Vol3B[15(MACHINE-CHECK ARCHITECTURE)]
         */
        uint64_t machine_check_enable : 1;
#define CR4_MACHINE_CHECK_ENABLE_BIT                                 6
#define CR4_MACHINE_CHECK_ENABLE_FLAG                                0x40
#define CR4_MACHINE_CHECK_ENABLE_MASK                                0x01
#define CR4_MACHINE_CHECK_ENABLE(_)                                  (((_) >> 6) & 0x01)

        /**
         * @brief Page Global Enable
         *
         * [Bit 7] (Introduced in the P6 family processors.) Enables the global page feature when set; disables the global page
         * feature when clear. The global page feature allows frequently used or shared pages to be marked as global to all users
         * (done with the global flag, bit 8, in a page-directory or page-table entry). Global pages are not flushed from the
         * translation-lookaside buffer (TLB) on a task switch or a write to register CR3. When enabling the global page feature,
         * paging must be enabled (by setting the PG flag in control register CR0) before the PGE flag is set. Reversing this
         * sequence may affect program correctness, and processor performance will be impacted.
         *
         * @see Vol3A[4.10(CACHING TRANSLATION INFORMATION)]
         */
        uint64_t page_global_enable : 1;
#define CR4_PAGE_GLOBAL_ENABLE_BIT                                   7
#define CR4_PAGE_GLOBAL_ENABLE_FLAG                                  0x80
#define CR4_PAGE_GLOBAL_ENABLE_MASK                                  0x01
#define CR4_PAGE_GLOBAL_ENABLE(_)                                    (((_) >> 7) & 0x01)

        /**
         * @brief Performance-Monitoring Counter Enable
         *
         * [Bit 8] Enables execution of the RDPMC instruction for programs or procedures running at any protection level when set;
         * RDPMC instruction can be executed only at protection level 0 when clear.
         */
        uint64_t performance_monitoring_counter_enable : 1;
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT                8
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG               0x100
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK               0x01
#define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_)                 (((_) >> 8) & 0x01)

        /**
         * @brief Operating System Support for FXSAVE and FXRSTOR instructions
         *
         * [Bit 9] When set, this flag:
         * -# indicates to software that the operating system supports the use of the FXSAVE and FXRSTOR instructions,
         * -# enables the FXSAVE and FXRSTOR instructions to save and restore the contents of the XMM and MXCSR registers along
         * with the contents of the x87 FPU and MMX registers, and
         * -# enables the processor to execute SSE/SSE2/SSE3/SSSE3/SSE4 instructions, with the exception of the PAUSE, PREFETCHh,
         * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
         * If this flag is clear, the FXSAVE and FXRSTOR instructions will save and restore the contents of the x87 FPU and MMX
         * registers, but they may not save and restore the contents of the XMM and MXCSR registers. Also, the processor will
         * generate an invalid opcode exception (\#UD) if it attempts to execute any SSE/SSE2/SSE3 instruction, with the exception
         * of PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT. The operating system or executive must
         * explicitly set this flag.
         *
         * @remarks CPUID feature flag FXSR indicates availability of the FXSAVE/FXRSTOR instructions. The OSFXSR bit provides
         *          operating system software with a means of enabling FXSAVE/FXRSTOR to save/restore the contents of the X87 FPU, XMM and
         *          MXCSR registers. Consequently OSFXSR bit indicates that the operating system provides context switch support for
         *          SSE/SSE2/SSE3/SSSE3/SSE4.
         */
        uint64_t os_fxsave_fxrstor_support : 1;
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT                            9
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG                           0x200
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK                           0x01
#define CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_)                             (((_) >> 9) & 0x01)

        /**
         * @brief Operating System Support for Unmasked SIMD Floating-Point Exceptions
         *
         * [Bit 10] Operating System Support for Unmasked SIMD Floating-Point Exceptions - When set, indicates that the operating
         * system supports the handling of unmasked SIMD floating-point exceptions through an exception handler that is invoked
         * when a SIMD floating-point exception (\#XM) is generated. SIMD floating-point exceptions are only generated by
         * SSE/SSE2/SSE3/SSE4.1 SIMD floating-point instructions.
         * The operating system or executive must explicitly set this flag. If this flag is not set, the processor will generate an
         * invalid opcode exception (\#UD) whenever it detects an unmasked SIMD floating-point exception.
         */
        uint64_t os_xmm_exception_support : 1;
#define CR4_OS_XMM_EXCEPTION_SUPPORT_BIT                             10
#define CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG                            0x400
#define CR4_OS_XMM_EXCEPTION_SUPPORT_MASK                            0x01
#define CR4_OS_XMM_EXCEPTION_SUPPORT(_)                              (((_) >> 10) & 0x01)

        /**
         * @brief User-Mode Instruction Prevention
         *
         * [Bit 11] When set, the following instructions cannot be executed if CPL > 0: SGDT, SIDT, SLDT, SMSW, and STR. An attempt
         * at such execution causes a general-protection exception (\#GP).
         */
        uint64_t usermode_instruction_prevention : 1;
#define CR4_USERMODE_INSTRUCTION_PREVENTION_BIT                      11
#define CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG                     0x800
#define CR4_USERMODE_INSTRUCTION_PREVENTION_MASK                     0x01
#define CR4_USERMODE_INSTRUCTION_PREVENTION(_)                       (((_) >> 11) & 0x01)

        /**
         * @brief 57-bit Linear Addresses
         *
         * [Bit 12] When set in IA-32e mode, the processor uses 5-level paging to translate 57-bit linear addresses. When clear in
         * IA-32e mode, the processor uses 4-level paging to translate 48-bit linear addresses. This bit cannot be modified in
         * IA-32e mode.
         *
         * @see Vol3C[4(PAGING)]
         */
        uint64_t linear_addresses_57_bit : 1;
#define CR4_LINEAR_ADDRESSES_57_BIT_BIT                              12
#define CR4_LINEAR_ADDRESSES_57_BIT_FLAG                             0x1000
#define CR4_LINEAR_ADDRESSES_57_BIT_MASK                             0x01
#define CR4_LINEAR_ADDRESSES_57_BIT(_)                               (((_) >> 12) & 0x01)

        /**
         * @brief VMX-Enable
         *
         * [Bit 13] Enables VMX operation when set.
         *
         * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
         */
        uint64_t vmx_enable : 1;
#define CR4_VMX_ENABLE_BIT                                           13
#define CR4_VMX_ENABLE_FLAG                                          0x2000
#define CR4_VMX_ENABLE_MASK                                          0x01
#define CR4_VMX_ENABLE(_)                                            (((_) >> 13) & 0x01)

        /**
         * @brief SMX-Enable
         *
         * [Bit 14] Enables SMX operation when set.
         *
         * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
         */
        uint64_t smx_enable : 1;
#define CR4_SMX_ENABLE_BIT                                           14
#define CR4_SMX_ENABLE_FLAG                                          0x4000
#define CR4_SMX_ENABLE_MASK                                          0x01
#define CR4_SMX_ENABLE(_)                                            (((_) >> 14) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief FSGSBASE-Enable
         *
         * [Bit 16] Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.
         */
        uint64_t fsgsbase_enable : 1;
#define CR4_FSGSBASE_ENABLE_BIT                                      16
#define CR4_FSGSBASE_ENABLE_FLAG                                     0x10000
#define CR4_FSGSBASE_ENABLE_MASK                                     0x01
#define CR4_FSGSBASE_ENABLE(_)                                       (((_) >> 16) & 0x01)

        /**
         * @brief PCID-Enable
         *
         * [Bit 17] Enables process-context identifiers (PCIDs) when set. Can be set only in IA-32e mode (if IA32_EFER.LMA = 1).
         *
         * @see Vol3A[4.10.1(Process-Context Identifiers (PCIDs))]
         */
        uint64_t pcid_enable : 1;
#define CR4_PCID_ENABLE_BIT                                          17
#define CR4_PCID_ENABLE_FLAG                                         0x20000
#define CR4_PCID_ENABLE_MASK                                         0x01
#define CR4_PCID_ENABLE(_)                                           (((_) >> 17) & 0x01)

        /**
         * @brief XSAVE and Processor Extended States-Enable
         *
         * [Bit 18] When set, this flag:
         * -# indicates (via CPUID.01H:ECX.OSXSAVE[bit 27]) that the operating system supports the use of the XGETBV, XSAVE and
         * XRSTOR instructions by general software;
         * -# enables the XSAVE and XRSTOR instructions to save and restore the x87 FPU state (including MMX registers), the SSE
         * state (XMM registers and MXCSR), along with other processor extended states enabled in XCR0;
         * -# enables the processor to execute XGETBV and XSETBV instructions in order to read and write XCR0.
         *
         * @see Vol3A[2.6(EXTENDED CONTROL REGISTERS (INCLUDING XCR0))]
         * @see Vol3A[13(SYSTEM PROGRAMMING FOR INSTRUCTION SET EXTENSIONS AND PROCESSOR EXTENDED)]
         */
        uint64_t os_xsave : 1;
#define CR4_OS_XSAVE_BIT                                             18
#define CR4_OS_XSAVE_FLAG                                            0x40000
#define CR4_OS_XSAVE_MASK                                            0x01
#define CR4_OS_XSAVE(_)                                              (((_) >> 18) & 0x01)

        /**
         * @brief Key-Locker-Enable
         *
         * [Bit 19] When set, the LOADIWKEY instruction is enabled; in addition, if support for the AES Key Locker instructions has
         * been activated by system firmware, CPUID.19H:EBX.AESKLE[bit 0] is enumerated as 1 and the AES Key Locker instructions
         * are enabled. When clear, CPUID.19H:EBX.AESKLE[bit 0] is enumerated as 0 and execution of any Key Locker instruction
         * causes an invalid-opcode exception (\#UD).
         */
        uint64_t key_locker_enable : 1;
#define CR4_KEY_LOCKER_ENABLE_BIT                                    19
#define CR4_KEY_LOCKER_ENABLE_FLAG                                   0x80000
#define CR4_KEY_LOCKER_ENABLE_MASK                                   0x01
#define CR4_KEY_LOCKER_ENABLE(_)                                     (((_) >> 19) & 0x01)

        /**
         * @brief SMEP-Enable
         *
         * [Bit 20] Enables supervisor-mode execution prevention (SMEP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        uint64_t smep_enable : 1;
#define CR4_SMEP_ENABLE_BIT                                          20
#define CR4_SMEP_ENABLE_FLAG                                         0x100000
#define CR4_SMEP_ENABLE_MASK                                         0x01
#define CR4_SMEP_ENABLE(_)                                           (((_) >> 20) & 0x01)

        /**
         * @brief SMAP-Enable
         *
         * [Bit 21] Enables supervisor-mode access prevention (SMAP) when set.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        uint64_t smap_enable : 1;
#define CR4_SMAP_ENABLE_BIT                                          21
#define CR4_SMAP_ENABLE_FLAG                                         0x200000
#define CR4_SMAP_ENABLE_MASK                                         0x01
#define CR4_SMAP_ENABLE(_)                                           (((_) >> 21) & 0x01)

        /**
         * @brief Protection-Key-Enable
         *
         * [Bit 22] Enables 4-level paging to associate each linear address with a protection key. The PKRU register specifies, for
         * each protection key, whether user-mode linear addresses with that protection key can be read or written. This bit also
         * enables access to the PKRU register using the RDPKRU and WRPKRU instructions.
         */
        uint64_t protection_key_enable : 1;
#define CR4_PROTECTION_KEY_ENABLE_BIT                                22
#define CR4_PROTECTION_KEY_ENABLE_FLAG                               0x400000
#define CR4_PROTECTION_KEY_ENABLE_MASK                               0x01
#define CR4_PROTECTION_KEY_ENABLE(_)                                 (((_) >> 22) & 0x01)

        /**
         * @brief Control-flow Enforcement Technology
         *
         * [Bit 23] Enables control-flow enforcement technology when set. This flag can be set only if CR0.WP is set, and it must
         * be clear before CR0.WP can be cleared.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t control_flow_enforcement_enable : 1;
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_BIT                      23
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_FLAG                     0x800000
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_MASK                     0x01
#define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE(_)                       (((_) >> 23) & 0x01)

        /**
         * @brief Enable protection keys for supervisor-mode pages
         *
         * [Bit 24] 4-level paging and 5-level paging associate each supervisor-mode linear address with a protection key. When
         * set, this flag allows use of the IA32_PKRS MSR to specify, for each protection key, whether supervisor-mode linear
         * addresses with that protection key can be read or written.
         */
        uint64_t protection_key_for_supervisor_mode_enable : 1;
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_BIT            24
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_FLAG           0x1000000
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_MASK           0x01
#define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE(_)             (((_) >> 24) & 0x01)
        uint64_t reserved2 : 39;
    };

    uint64_t flags;
} cr4;

typedef union
{
    struct
    {
        /**
         * @brief Task Priority Level
         *
         * [Bits 3:0] This sets the threshold value corresponding to the highestpriority interrupt to be blocked. A value of 0
         * means all interrupts are enabled. This field is available in 64- bit mode. A value of 15 means all interrupts will be
         * disabled.
         */
        uint64_t task_priority_level : 4;
#define CR8_TASK_PRIORITY_LEVEL_BIT                                  0
#define CR8_TASK_PRIORITY_LEVEL_FLAG                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL_MASK                                 0x0F
#define CR8_TASK_PRIORITY_LEVEL(_)                                   (((_) >> 0) & 0x0F)

        /**
         * @brief Reserved
         *
         * [Bits 63:4] Reserved and must be written with zeros. Failure to do this causes a general-protection exception.
         */
        uint64_t reserved : 60;
#define CR8_RESERVED_BIT                                             4
#define CR8_RESERVED_FLAG                                            0xFFFFFFFFFFFFFFF0
#define CR8_RESERVED_MASK                                            0xFFFFFFFFFFFFFFF
#define CR8_RESERVED(_)                                              (((_) >> 4) & 0xFFFFFFFFFFFFFFF)
    };

    uint64_t flags;
} cr8;

/**
 * @}
 */

 /**
  * @defgroup debug_registers \
  *           Debug registers
  *
  * Eight debug registers control the debug operation of the processor. These registers can be written to and read using the
  * move to/from debug register form of the MOV instruction. A debug register may be the source or destination operand for
  * one of these instructions.
  * Debug registers are privileged resources; a MOV instruction that accesses these registers can only be executed in
  * real-address mode, in SMM or in protected mode at a CPL of 0. An attempt to read or write the debug registers from any
  * other privilege level generates a general-protection exception (\#GP). The primary function of the debug registers is to
  * set up and monitor from 1 to 4 breakpoints, numbered 0 though 3. For each breakpoint, the following information can be
  * specified:
  * - The linear address where the breakpoint is to occur.
  * - The length of the breakpoint location: 1, 2, 4, or 8 bytes.
  * - The operation that must be performed at the address for a debug exception to be generated.
  * - Whether the breakpoint is enabled.
  * - Whether the breakpoint condition was present when the debug exception was generated.
  *
  * @see Vol3B[17.2.4(Debug Control Register (DR7))]
  * @see Vol3B[17.2(DEBUG REGISTERS)] (reference)
  * @{
  */
typedef union
{
    struct
    {
        /**
         * @brief B0 through B3 (breakpoint condition detected) flags
         *
         * [Bits 3:0] Indicates (when set) that its associated breakpoint condition was met when a debug exception was generated.
         * These flags are set if the condition described for each breakpoint by the LENn, and R/Wn flags in debug control register
         * DR7 is true. They may or may not be set if the breakpoint is not enabled by the Ln or the Gn flags in register DR7.
         * Therefore on a \#DB, a debug handler should check only those B0-B3 bits which correspond to an enabled breakpoint.
         */
        uint64_t breakpoint_condition : 4;
#define DR6_BREAKPOINT_CONDITION_BIT                                 0
#define DR6_BREAKPOINT_CONDITION_FLAG                                0x0F
#define DR6_BREAKPOINT_CONDITION_MASK                                0x0F
#define DR6_BREAKPOINT_CONDITION(_)                                  (((_) >> 0) & 0x0F)
        uint64_t reserved1 : 9;

        /**
         * @brief BD (debug register access detected) flag
         *
         * [Bit 13] Indicates that the next instruction in the instruction stream accesses one of the debug registers (DR0 through
         * DR7). This flag is enabled when the GD (general detect) flag in debug control register DR7 is set.
         *
         * @see Vol3B[17.2.4(Debug Control Register (DR7))]
         */
        uint64_t debug_register_access_detected : 1;
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT                       13
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG                      0x2000
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK                      0x01
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED(_)                        (((_) >> 13) & 0x01)

        /**
         * @brief BS (single step) flag
         *
         * [Bit 14] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        uint64_t single_instruction : 1;
#define DR6_SINGLE_INSTRUCTION_BIT                                   14
#define DR6_SINGLE_INSTRUCTION_FLAG                                  0x4000
#define DR6_SINGLE_INSTRUCTION_MASK                                  0x01
#define DR6_SINGLE_INSTRUCTION(_)                                    (((_) >> 14) & 0x01)

        /**
         * @brief BT (task switch) flag
         *
         * [Bit 15] Indicates (when set) that the debug exception was triggered by the singlestep execution mode (enabled with the
         * TF flag in the EFLAGS register). The single-step mode is the highestpriority debug exception. When the BS flag is set,
         * any of the other debug status bits also may be set.
         */
        uint64_t task_switch : 1;
#define DR6_TASK_SWITCH_BIT                                          15
#define DR6_TASK_SWITCH_FLAG                                         0x8000
#define DR6_TASK_SWITCH_MASK                                         0x01
#define DR6_TASK_SWITCH(_)                                           (((_) >> 15) & 0x01)

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 16] Indicates (when clear) that a debug exception (\#DB) or breakpoint exception (\#BP) occurred inside an RTM
         * region while advanced debugging of RTM transactional regions was enabled. This bit is set for any other debug exception
         * (including all those that occur when advanced debugging of RTM transactional regions is not enabled). This bit is always
         * 1 if the processor does not support RTM.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        uint64_t restricted_transactional_memory : 1;
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      16
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x10000
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 16) & 0x01)
        uint64_t reserved2 : 47;
    };

    uint64_t flags;
} dr6;

typedef union
{
    struct
    {
        /**
         * @brief L0 through L3 (local breakpoint enable) flags (bits 0, 2, 4, and 6)
         *
         * [Bit 0] Enables (when set) the breakpoint condition for the associated breakpoint for the current task. When a
         * breakpoint condition is detected and its associated Ln flag is set, a debug exception is generated. The processor
         * automatically clears these flags on every task switch to avoid unwanted breakpoint conditions in the new task.
         */
        uint64_t local_breakpoint_0 : 1;
#define DR7_LOCAL_BREAKPOINT_0_BIT                                   0
#define DR7_LOCAL_BREAKPOINT_0_FLAG                                  0x01
#define DR7_LOCAL_BREAKPOINT_0_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_0(_)                                    (((_) >> 0) & 0x01)

        /**
         * @brief G0 through G3 (global breakpoint enable) flags (bits 1, 3, 5, and 7)
         *
         * [Bit 1] Enables (when set) the breakpoint condition for the associated breakpoint for all tasks. When a breakpoint
         * condition is detected and its associated Gn flag is set, a debug exception is generated. The processor does not clear
         * these flags on a task switch, allowing a breakpoint to be enabled for all tasks.
         */
        uint64_t global_breakpoint_0 : 1;
#define DR7_GLOBAL_BREAKPOINT_0_BIT                                  1
#define DR7_GLOBAL_BREAKPOINT_0_FLAG                                 0x02
#define DR7_GLOBAL_BREAKPOINT_0_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_0(_)                                   (((_) >> 1) & 0x01)
        uint64_t local_breakpoint_1 : 1;
#define DR7_LOCAL_BREAKPOINT_1_BIT                                   2
#define DR7_LOCAL_BREAKPOINT_1_FLAG                                  0x04
#define DR7_LOCAL_BREAKPOINT_1_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_1(_)                                    (((_) >> 2) & 0x01)
        uint64_t global_breakpoint_1 : 1;
#define DR7_GLOBAL_BREAKPOINT_1_BIT                                  3
#define DR7_GLOBAL_BREAKPOINT_1_FLAG                                 0x08
#define DR7_GLOBAL_BREAKPOINT_1_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_1(_)                                   (((_) >> 3) & 0x01)
        uint64_t local_breakpoint_2 : 1;
#define DR7_LOCAL_BREAKPOINT_2_BIT                                   4
#define DR7_LOCAL_BREAKPOINT_2_FLAG                                  0x10
#define DR7_LOCAL_BREAKPOINT_2_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_2(_)                                    (((_) >> 4) & 0x01)
        uint64_t global_breakpoint_2 : 1;
#define DR7_GLOBAL_BREAKPOINT_2_BIT                                  5
#define DR7_GLOBAL_BREAKPOINT_2_FLAG                                 0x20
#define DR7_GLOBAL_BREAKPOINT_2_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_2(_)                                   (((_) >> 5) & 0x01)
        uint64_t local_breakpoint_3 : 1;
#define DR7_LOCAL_BREAKPOINT_3_BIT                                   6
#define DR7_LOCAL_BREAKPOINT_3_FLAG                                  0x40
#define DR7_LOCAL_BREAKPOINT_3_MASK                                  0x01
#define DR7_LOCAL_BREAKPOINT_3(_)                                    (((_) >> 6) & 0x01)
        uint64_t global_breakpoint_3 : 1;
#define DR7_GLOBAL_BREAKPOINT_3_BIT                                  7
#define DR7_GLOBAL_BREAKPOINT_3_FLAG                                 0x80
#define DR7_GLOBAL_BREAKPOINT_3_MASK                                 0x01
#define DR7_GLOBAL_BREAKPOINT_3(_)                                   (((_) >> 7) & 0x01)

        /**
         * @brief LE (local exact breakpoint enable)
         *
         * [Bit 8] This feature is not supported in the P6 family processors, later IA-32 processors, and Intel 64 processors. When
         * set, these flags cause the processor to detect the exact instruction that caused a data breakpoint condition. For
         * backward and forward compatibility with other Intel processors, we recommend that the LE and GE flags be set to 1 if
         * exact breakpoints are required.
         */
        uint64_t local_exact_breakpoint : 1;
#define DR7_LOCAL_EXACT_BREAKPOINT_BIT                               8
#define DR7_LOCAL_EXACT_BREAKPOINT_FLAG                              0x100
#define DR7_LOCAL_EXACT_BREAKPOINT_MASK                              0x01
#define DR7_LOCAL_EXACT_BREAKPOINT(_)                                (((_) >> 8) & 0x01)
        uint64_t global_exact_breakpoint : 1;
#define DR7_GLOBAL_EXACT_BREAKPOINT_BIT                              9
#define DR7_GLOBAL_EXACT_BREAKPOINT_FLAG                             0x200
#define DR7_GLOBAL_EXACT_BREAKPOINT_MASK                             0x01
#define DR7_GLOBAL_EXACT_BREAKPOINT(_)                               (((_) >> 9) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief RTM (restricted transactional memory) flag
         *
         * [Bit 11] Enables (when set) advanced debugging of RTM transactional regions. This advanced debugging is enabled only if
         * IA32_DEBUGCTL.RTM is also set.
         *
         * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM))]
         */
        uint64_t restricted_transactional_memory : 1;
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT                      11
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG                     0x800
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK                     0x01
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_)                       (((_) >> 11) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief GD (general detect enable) flag
         *
         * [Bit 13] Enables (when set) debug-register protection, which causes a debug exception to be generated prior to any MOV
         * instruction that accesses a debug register. When such a condition is detected, the BD flag in debug status register DR6
         * is set prior to generating the exception. This condition is provided to support in-circuit emulators.
         * When the emulator needs to access the debug registers, emulator software can set the GD flag to prevent interference
         * from the program currently executing on the processor.
         * The processor clears the GD flag upon entering to the debug exception handler, to allow the handler access to the debug
         * registers.
         */
        uint64_t general_detect : 1;
#define DR7_GENERAL_DETECT_BIT                                       13
#define DR7_GENERAL_DETECT_FLAG                                      0x2000
#define DR7_GENERAL_DETECT_MASK                                      0x01
#define DR7_GENERAL_DETECT(_)                                        (((_) >> 13) & 0x01)
        uint64_t reserved3 : 2;

        /**
         * @brief R/W0 through R/W3 (read/write) fields (bits 16, 17, 20, 21, 24, 25, 28, and 29)
         *
         * [Bits 17:16] Specifies the breakpoint condition for the corresponding breakpoint. The DE (debug extensions) flag in
         * control register CR4 determines how the bits in the R/Wn fields are interpreted. When the DE flag is set, the processor
         * interprets bits as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Break on I/O reads or writes.
         * - 11 - Break on data reads or writes but not instruction fetches.
         * When the DE flag is clear, the processor interprets the R/Wn bits the same as for the Intel386(TM) and Intel486(TM)
         * processors, which is as follows:
         * - 00 - Break on instruction execution only.
         * - 01 - Break on data writes only.
         * - 10 - Undefined.
         * - 11 - Break on data reads or writes but not instruction fetches.
         */
        uint64_t read_write_0 : 2;
#define DR7_READ_WRITE_0_BIT                                         16
#define DR7_READ_WRITE_0_FLAG                                        0x30000
#define DR7_READ_WRITE_0_MASK                                        0x03
#define DR7_READ_WRITE_0(_)                                          (((_) >> 16) & 0x03)

        /**
         * @brief LEN0 through LEN3 (Length) fields (bits 18, 19, 22, 23, 26, 27, 30, and 31)
         *
         * [Bits 19:18] Specify the size of the memory location at the address specified in the corresponding breakpoint address
         * register (DR0 through DR3). These fields are interpreted as follows:
         * - 00 - 1-byte length.
         * - 01 - 2-byte length.
         * - 10 - Undefined (or 8 byte length, see note below).
         * - 11 - 4-byte length.
         * If the corresponding RWn field in register DR7 is 00 (instruction execution), then the LENn field should also be 00. The
         * effect of using other lengths is undefined.
         *
         * @see Vol3B[17.2.5(Breakpoint Field Recognition)]
         */
        uint64_t length_0 : 2;
#define DR7_LENGTH_0_BIT                                             18
#define DR7_LENGTH_0_FLAG                                            0xC0000
#define DR7_LENGTH_0_MASK                                            0x03
#define DR7_LENGTH_0(_)                                              (((_) >> 18) & 0x03)
        uint64_t read_write_1 : 2;
#define DR7_READ_WRITE_1_BIT                                         20
#define DR7_READ_WRITE_1_FLAG                                        0x300000
#define DR7_READ_WRITE_1_MASK                                        0x03
#define DR7_READ_WRITE_1(_)                                          (((_) >> 20) & 0x03)
        uint64_t length_1 : 2;
#define DR7_LENGTH_1_BIT                                             22
#define DR7_LENGTH_1_FLAG                                            0xC00000
#define DR7_LENGTH_1_MASK                                            0x03
#define DR7_LENGTH_1(_)                                              (((_) >> 22) & 0x03)
        uint64_t read_write_2 : 2;
#define DR7_READ_WRITE_2_BIT                                         24
#define DR7_READ_WRITE_2_FLAG                                        0x3000000
#define DR7_READ_WRITE_2_MASK                                        0x03
#define DR7_READ_WRITE_2(_)                                          (((_) >> 24) & 0x03)
        uint64_t length_2 : 2;
#define DR7_LENGTH_2_BIT                                             26
#define DR7_LENGTH_2_FLAG                                            0xC000000
#define DR7_LENGTH_2_MASK                                            0x03
#define DR7_LENGTH_2(_)                                              (((_) >> 26) & 0x03)
        uint64_t read_write_3 : 2;
#define DR7_READ_WRITE_3_BIT                                         28
#define DR7_READ_WRITE_3_FLAG                                        0x30000000
#define DR7_READ_WRITE_3_MASK                                        0x03
#define DR7_READ_WRITE_3(_)                                          (((_) >> 28) & 0x03)
        uint64_t length_3 : 2;
#define DR7_LENGTH_3_BIT                                             30
#define DR7_LENGTH_3_FLAG                                            0xC0000000
#define DR7_LENGTH_3_MASK                                            0x03
#define DR7_LENGTH_3(_)                                              (((_) >> 30) & 0x03)
        uint64_t reserved4 : 32;
    };

    uint64_t flags;
} dr7;

/**
 * @}
 */

 /**
  * @defgroup cpuid \
  *           CPUID
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @brief Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String
   *
   * When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic
   * processor information. The value is returned in the EAX register and is processor specific.
   * A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel"
   * and is expressed:
   * - EBX <- 756e6547h (* "Genu", with G in the low eight bits of BL *)
   * - EDX <- 49656e69h (* "ineI", with i in the low eight bits of DL *)
   * - ECX <- 6c65746eh (* "ntel", with n in the low eight bits of CL *)
   */
#define CPUID_SIGNATURE                                              0x00000000
typedef struct
{
    /**
     * @brief EAX
     *
     * Maximum Input Value for Basic CPUID Information.
     */
    uint32_t max_cpuid_input_value;

    /**
     * @brief EBX
     *
     * "Genu"
     */
    uint32_t ebx_value_genu;

    /**
     * @brief ECX
     *
     * "ntel"
     */
    uint32_t ecx_value_ntel;

    /**
     * @brief EDX
     *
     * "ineI"
     */
    uint32_t edx_value_inei;
} cpuid_eax_00;


/**
 * @brief Returns Model, Family, Stepping Information, Additional Information and Feature Information
 *
 * Returns:
 *   * Model, Family, Stepping Information in EAX
 *   * Additional Information in EBX
 *   * Feature Information in ECX and EDX
 */
#define CPUID_VERSION_INFORMATION                                    0x00000001
typedef struct
{
    /**
     * @brief When CPUID executes with EAX set to 01H, version information is returned in EAX
     */
    union
    {
        struct
        {
            uint32_t stepping_id : 4;
#define CPUID_VERSION_INFORMATION_STEPPING_ID_BIT                    0
#define CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID_MASK                   0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID(_)                     (((_) >> 0) & 0x0F)
            uint32_t model : 4;
#define CPUID_VERSION_INFORMATION_MODEL_BIT                          4
#define CPUID_VERSION_INFORMATION_MODEL_FLAG                         0xF0
#define CPUID_VERSION_INFORMATION_MODEL_MASK                         0x0F
#define CPUID_VERSION_INFORMATION_MODEL(_)                           (((_) >> 4) & 0x0F)
            uint32_t family_id : 4;
#define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT                      8
#define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG                     0xF00
#define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK                     0x0F
#define CPUID_VERSION_INFORMATION_FAMILY_ID(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 13:12] - 0 - Original OEM Processor
             * - 1 - Intel OverDrive(R) Processor
             * - 2 - Dual processor (not applicable to Intel486 processors)
             * - 3 - Intel reserved
             */
            uint32_t processor_type : 2;
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT                 12
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG                0x3000
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK                0x03
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_)                  (((_) >> 12) & 0x03)
            uint32_t reserved1 : 2;

            /**
             * [Bits 19:16] The Extended Model ID needs to be examined only when the Family ID is 06H or 0FH.
             */
            uint32_t extended_model_id : 4;
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT              16
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG             0xF0000
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK             0x0F
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_)               (((_) >> 16) & 0x0F)

            /**
             * [Bits 27:20] The Extended Family ID needs to be examined only when the Family ID is 0FH.
             */
            uint32_t extended_family_id : 8;
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT             20
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG            0xFF00000
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK            0xFF
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_)              (((_) >> 20) & 0xFF)
            uint32_t reserved2 : 4;
        };

        uint32_t flags;
    } cpuid_version_information;

    /**
     * @brief When CPUID executes with EAX set to 01H, additional information is returned to the EBX register
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] This number provides an entry into a brand string table that contains brand strings for IA-32 processors.
             * More information about this field is provided later in this section.
             */
            uint32_t brand_index : 8;
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT                 0
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK                0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_)                  (((_) >> 0) & 0xFF)

            /**
             * @brief Value * 8 = cache line size in bytes; used also by CLFLUSHOPT
             *
             * [Bits 15:8] This number indicates the size of the cache line flushed by the CLFLUSH and CLFLUSHOPT instructions in
             * 8-byte increments. This field was introduced in the Pentium 4 processor.
             */
            uint32_t clflush_line_size : 8;
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT           8
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG          0xFF00
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK          0xFF
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_)            (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Maximum number of addressable IDs for logical processors in this physical package.
             *
             * @remarks The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number of unique initial APIC IDs
             *          reserved for addressing different logical processors in a physical package. This field is only valid if
             *          CPUID.1.EDX.HTT[bit 28] = 1.
             */
            uint32_t max_addressable_ids : 8;
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT         16
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG        0xFF0000
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK        0xFF
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_)          (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] This number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field
             * was introduced in the Pentium 4 processor.
             */
            uint32_t initial_apic_id : 8;
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT             24
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG            0xFF000000
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK            0xFF
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_)              (((_) >> 24) & 0xFF)
        };

        uint32_t flags;
    } cpuid_additional_information;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Streaming SIMD Extensions 3 (SSE3)
             *
             * [Bit 0] A value of 1 indicates the processor supports this technology.
             */
            uint32_t streaming_simd_extensions_3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT 0
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 0) & 0x01)

            /**
             * @brief PCLMULQDQ instruction
             *
             * [Bit 1] A value of 1 indicates the processor supports the PCLMULQDQ instruction.
             */
            uint32_t pclmulqdq_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT      1
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG     0x02
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_)       (((_) >> 1) & 0x01)

            /**
             * @brief 64-bit DS Area
             *
             * [Bit 2] A value of 1 indicates the processor supports DS area using 64-bit layout.
             */
            uint32_t ds_area_64bit_layout : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT       2
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK      0x01
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_)        (((_) >> 2) & 0x01)

            /**
             * @brief MONITOR/MWAIT instruction
             *
             * [Bit 3] A value of 1 indicates the processor supports this feature.
             */
            uint32_t monitor_mwait_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT  3
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_)   (((_) >> 3) & 0x01)

            /**
             * @brief CPL Qualified Debug Store
             *
             * [Bit 4] A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch
             * message storage qualified by CPL.
             */
            uint32_t cpl_qualified_debug_store : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT  4
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_)   (((_) >> 4) & 0x01)

            /**
             * @brief Virtual Machine Extensions
             *
             * [Bit 5] A value of 1 indicates that the processor supports this technology.
             */
            uint32_t virtual_machine_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT 5
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_)  (((_) >> 5) & 0x01)

            /**
             * @brief Safer Mode Extensions
             *
             * [Bit 6] A value of 1 indicates that the processor supports this technology.
             *
             * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
             */
            uint32_t safer_mode_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT      6
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG     0x40
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK     0x01
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_)       (((_) >> 6) & 0x01)

            /**
             * @brief Enhanced Intel SpeedStep(R) technology
             *
             * [Bit 7] A value of 1 indicates that the processor supports this technology.
             */
            uint32_t enhanced_intel_speedstep_technology : 1;
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT 7
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_) (((_) >> 7) & 0x01)

            /**
             * @brief Thermal Monitor 2
             *
             * [Bit 8] A value of 1 indicates whether the processor supports this technology.
             */
            uint32_t thermal_monitor_2 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT          8
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG         0x100
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_)           (((_) >> 8) & 0x01)

            /**
             * @brief Supplemental Streaming SIMD Extensions 3 (SSSE3)
             *
             * [Bit 9] A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0
             * indicates the instruction extensions are not present in the processor.
             */
            uint32_t supplemental_streaming_simd_extensions_3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT 9
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) (((_) >> 9) & 0x01)

            /**
             * @brief L1 Context ID
             *
             * [Bit 10] A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0
             * indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode)
             * for details.
             */
            uint32_t l1_context_id : 1;
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT              10
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG             0x400
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_)               (((_) >> 10) & 0x01)

            /**
             * @brief IA32_DEBUG_INTERFACE MSR for silicon debug
             *
             * [Bit 11] A value of 1 indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.
             */
            uint32_t silicon_debug : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT              11
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG             0x800
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_)               (((_) >> 11) & 0x01)

            /**
             * @brief FMA extensions using YMM state
             *
             * [Bit 12] A value of 1 indicates the processor supports FMA (Fused Multiple Add) extensions using YMM state.
             */
            uint32_t fma_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT             12
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG            0x1000
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_)              (((_) >> 12) & 0x01)

            /**
             * @brief CMPXCHG16B instruction
             *
             * [Bit 13] A value of 1 indicates that the feature is available.
             */
            uint32_t cmpxchg16b_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT     13
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG    0x2000
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK    0x01
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_)      (((_) >> 13) & 0x01)

            /**
             * @brief xTPR Update Control
             *
             * [Bit 14] A value of 1 indicates that the processor supports changing IA32_MISC_ENABLE[bit 23].
             */
            uint32_t xtpr_update_control : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT        14
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG       0x4000
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_)         (((_) >> 14) & 0x01)

            /**
             * @brief Perfmon and Debug Capability
             *
             * [Bit 15] A value of 1 indicates the processor supports the performance and debug feature indication MSR
             * IA32_PERF_CAPABILITIES.
             */
            uint32_t perfmon_and_debug_capability : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT 15
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_) (((_) >> 15) & 0x01)
            uint32_t reserved1 : 1;

            /**
             * @brief Process-context identifiers
             *
             * [Bit 17] A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.
             */
            uint32_t process_context_identifiers : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT 17
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_) (((_) >> 17) & 0x01)

            /**
             * @brief Direct Cache Access
             *
             * [Bit 18] A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device (Direct
             * Cache Access).
             */
            uint32_t direct_cache_access : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT        18
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG       0x40000
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK       0x01
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_)         (((_) >> 18) & 0x01)

            /**
             * @brief SSE4.1 support
             *
             * [Bit 19] A value of 1 indicates that the processor supports SSE4.1.
             */
            uint32_t sse41_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT              19
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG             0x80000
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_)               (((_) >> 19) & 0x01)

            /**
             * @brief SSE4.2 support
             *
             * [Bit 20] A value of 1 indicates that the processor supports SSE4.2.
             */
            uint32_t sse42_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT              20
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG             0x100000
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK             0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_)               (((_) >> 20) & 0x01)

            /**
             * @brief x2APIC support
             *
             * [Bit 21] A value of 1 indicates that the processor supports x2APIC feature.
             */
            uint32_t x2apic_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT             21
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG            0x200000
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK            0x01
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_)              (((_) >> 21) & 0x01)

            /**
             * @brief MOVBE instruction
             *
             * [Bit 22] A value of 1 indicates that the processor supports MOVBE instruction.
             */
            uint32_t movbe_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT          22
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG         0x400000
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK         0x01
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_)           (((_) >> 22) & 0x01)

            /**
             * @brief POPCNT instruction
             *
             * [Bit 23] A value of 1 indicates that the processor supports the POPCNT instruction.
             */
            uint32_t popcnt_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT         23
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG        0x800000
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_)          (((_) >> 23) & 0x01)

            /**
             * @brief TSC Deadline
             *
             * [Bit 24] A value of 1 indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline
             * value.
             */
            uint32_t tsc_deadline : 1;
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT               24
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG              0x1000000
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK              0x01
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_)                (((_) >> 24) & 0x01)

            /**
             * @brief AESNI instruction extensions
             *
             * [Bit 25] A value of 1 indicates that the processor supports the AESNI instruction extensions.
             */
            uint32_t aesni_instruction_extensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT 25
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_) (((_) >> 25) & 0x01)

            /**
             * @brief XSAVE/XRSTOR instruction extensions
             *
             * [Bit 26] A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the
             * XSETBV/XGETBV instructions, and XCR0.
             */
            uint32_t xsave_xrstor_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT   26
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG  0x4000000
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK  0x01
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_)    (((_) >> 26) & 0x01)

            /**
             * @brief CR4.OSXSAVE[bit 18] set
             *
             * [Bit 27] A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18] to enable XSETBV/XGETBV instructions to access
             * XCR0 and to support processor extended state management using XSAVE/XRSTOR.
             */
            uint32_t osx_save : 1;
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT                   27
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG                  0x8000000
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK                  0x01
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_)                    (((_) >> 27) & 0x01)

            /**
             * @brief AVX instruction extensions support
             *
             * [Bit 28] A value of 1 indicates the processor supports the AVX instruction extensions.
             */
            uint32_t avx_support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT                28
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG               0x10000000
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_)                 (((_) >> 28) & 0x01)

            /**
             * @brief 16-bit floating-point conversion instructions support
             *
             * [Bit 29] A value of 1 indicates that processor supports 16-bit floating-point conversion instructions.
             */
            uint32_t half_precision_conversion_instructions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT 29
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_) (((_) >> 29) & 0x01)

            /**
             * @brief RDRAND instruction support
             *
             * [Bit 30] A value of 1 indicates that processor supports RDRAND instruction.
             */
            uint32_t rdrand_instruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT         30
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG        0x40000000
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK        0x01
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_)          (((_) >> 30) & 0x01)
            uint32_t reserved2 : 1;
        };

        uint32_t flags;
    } cpuid_feature_information_ecx;

    /**
     * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX and EDX
     */
    union
    {
        struct
        {
            /**
             * @brief Floating Point Unit On-Chip
             *
             * [Bit 0] The processor contains an x87 FPU.
             */
            uint32_t floating_point_unit_on_chip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT 0
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_) (((_) >> 0) & 0x01)

            /**
             * @brief Virtual 8086 Mode Enhancements
             *
             * [Bit 1] Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode
             * virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and
             * EFLAGS.VIF and EFLAGS.VIP flags.
             */
            uint32_t virtual_8086_mode_enhancements : 1;
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT 1
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_) (((_) >> 1) & 0x01)

            /**
             * @brief Debugging Extensions
             *
             * [Bit 2] Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to
             * DR4 and DR5.
             */
            uint32_t debugging_extensions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT       2
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG      0x04
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_)        (((_) >> 2) & 0x01)

            /**
             * @brief Page Size Extension
             *
             * [Bit 3] Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit
             * in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
             */
            uint32_t page_size_extension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT        3
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG       0x08
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK       0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_)         (((_) >> 3) & 0x01)

            /**
             * @brief Time Stamp Counter
             *
             * [Bit 4] The RDTSC instruction is supported, including CR4.TSD for controlling privilege.
             */
            uint32_t timestamp_counter : 1;
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT          4
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG         0x10
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK         0x01
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_)           (((_) >> 4) & 0x01)

            /**
             * @brief Model Specific Registers RDMSR and WRMSR Instructions
             *
             * [Bit 5] The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.
             */
            uint32_t rdmsr_wrmsr_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT   5
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG  0x20
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK  0x01
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_)    (((_) >> 5) & 0x01)

            /**
             * @brief Physical Address Extension
             *
             * [Bit 6] Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the
             * page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.
             */
            uint32_t physical_address_extension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT 6
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_)  (((_) >> 6) & 0x01)

            /**
             * @brief Machine Check Exception
             *
             * [Bit 7] Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not
             * define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine
             * Check exception handlers may have to depend on processor version to do model specific processing of the exception, or
             * test for the presence of the Machine Check feature.
             */
            uint32_t machine_check_exception : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT    7
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG   0x80
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_)     (((_) >> 7) & 0x01)

            /**
             * @brief CMPXCHG8B Instruction
             *
             * [Bit 8] The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).
             */
            uint32_t cmpxchg8b : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT                  8
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG                 0x100
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK                 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_)                   (((_) >> 8) & 0x01)

            /**
             * @brief APIC On-Chip
             *
             * [Bit 9] The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped
             * commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be
             * relocated).
             */
            uint32_t apic_on_chip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT               9
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG              0x200
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_)                (((_) >> 9) & 0x01)
            uint32_t reserved1 : 1;

            /**
             * @brief SYSENTER and SYSEXIT Instructions
             *
             * [Bit 11] The SYSENTER and SYSEXIT and associated MSRs are supported.
             */
            uint32_t sysenter_sysexit_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT 11
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_) (((_) >> 11) & 0x01)

            /**
             * @brief Memory Type Range Registers
             *
             * [Bit 12] MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how
             * many variable MTRRs are supported, and whether fixed MTRRs are supported.
             */
            uint32_t memory_type_range_registers : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT 12
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_) (((_) >> 12) & 0x01)

            /**
             * @brief Page Global Bit
             *
             * [Bit 13] The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common
             * to different processes and need not be flushed. The CR4.PGE bit controls this feature.
             */
            uint32_t page_global_bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT            13
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG           0x2000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_)             (((_) >> 13) & 0x01)

            /**
             * @brief Machine Check Architecture
             *
             * [Bit 14] A value of 1 indicates the Machine Check Architecture of reporting machine errors is supported. The MCG_CAP MSR
             * contains feature bits describing how many banks of error reporting MSRs are supported.
             */
            uint32_t machine_check_architecture : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT 14
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_)  (((_) >> 14) & 0x01)

            /**
             * @brief Conditional Move Instructions
             *
             * [Bit 15] The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the
             * CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported
             */
            uint32_t conditional_move_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT 15
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_) (((_) >> 15) & 0x01)

            /**
             * @brief Page Attribute Table
             *
             * [Bit 16] Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an
             * operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.
             */
            uint32_t page_attribute_table : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT       16
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG      0x10000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_)        (((_) >> 16) & 0x01)

            /**
             * @brief 36-Bit Page Size Extension
             *
             * [Bit 17] 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature
             * indicates that upper bits of the physical address of a 4-MByte page are encoded in bits 20:13 of the page-directory
             * entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.
             */
            uint32_t page_size_extension_36bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT  17
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_)   (((_) >> 17) & 0x01)

            /**
             * @brief Processor Serial Number
             *
             * [Bit 18] The processor supports the 96-bit processor identification number feature and the feature is enabled.
             */
            uint32_t processor_serial_number : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT    18
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG   0x40000
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK   0x01
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_)     (((_) >> 18) & 0x01)

            /**
             * @brief CLFLUSH Instruction
             *
             * [Bit 19] CLFLUSH Instruction is supported.
             */
            uint32_t clflush : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT                    19
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG                   0x80000
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK                   0x01
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_)                     (((_) >> 19) & 0x01)
            uint32_t reserved2 : 1;

            /**
             * @brief Debug Store
             *
             * [Bit 21] The processor supports the ability to write debug information into a memory resident buffer. This feature is
             * used by the branch trace store (BTS) and processor event-based sampling (PEBS) facilities.
             *
             * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
             */
            uint32_t debug_store : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT                21
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG               0x200000
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_)                 (((_) >> 21) & 0x01)

            /**
             * @brief Thermal Monitor and Software Controlled Clock Facilities
             *
             * [Bit 22] The processor implements internal MSRs that allow processor temperature to be monitored and processor
             * performance to be modulated in predefined duty cycles under software control.
             */
            uint32_t thermal_control_msrs_for_acpi : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT 22
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_) (((_) >> 22) & 0x01)

            /**
             * @brief Intel MMX Technology
             *
             * [Bit 23] The processor supports the Intel MMX technology.
             */
            uint32_t mmx_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT                23
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG               0x800000
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_)                 (((_) >> 23) & 0x01)

            /**
             * @brief FXSAVE and FXRSTOR Instructions
             *
             * [Bit 24] The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context.
             * Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports
             * the FXSAVE and FXRSTOR instructions.
             */
            uint32_t fxsave_fxrstor_instructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT 24
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_) (((_) >> 24) & 0x01)

            /**
             * @brief SSE extensions support
             *
             * [Bit 25] The processor supports the SSE extensions.
             */
            uint32_t sse_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT                25
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG               0x2000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK               0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_)                 (((_) >> 25) & 0x01)

            /**
             * @brief SSE2 extensions support
             *
             * [Bit 26] The processor supports the SSE2 extensions.
             */
            uint32_t sse2_support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT               26
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG              0x4000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK              0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_)                (((_) >> 26) & 0x01)

            /**
             * @brief Self Snoop
             *
             * [Bit 27] The processor supports the management of conflicting memory types by performing a snoop of its own cache
             * structure for transactions issued to the bus.
             */
            uint32_t self_snoop : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT                 27
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG                0x8000000
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK                0x01
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_)                  (((_) >> 27) & 0x01)

            /**
             * @brief Max APIC IDs reserved field is Valid
             *
             * [Bit 28] A value of 0 for HTT indicates there is only a single logical processor in the package and software should
             * assume only a single APIC ID is reserved. A value of 1 for HTT indicates the value in CPUID.1.EBX[23:16] (the Maximum
             * number of addressable IDs for logical processors in this package) is valid for the package.
             */
            uint32_t hyper_threading_technology : 1;
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT 28
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_)  (((_) >> 28) & 0x01)

            /**
             * @brief Thermal Monitor
             *
             * [Bit 29] The processor implements the thermal monitor automatic thermal control circuitry (TCC).
             */
            uint32_t thermal_monitor : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT            29
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG           0x20000000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK           0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_)             (((_) >> 29) & 0x01)
            uint32_t reserved3 : 1;

            /**
             * @brief Pending Break Enable
             *
             * [Bit 31] The processor supports the use of the FERR\#/PBE\# pin when the processor is in the stop-clock state (STPCLK\#
             * is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal
             * operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.
             */
            uint32_t pending_break_enable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT       31
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG      0x80000000
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK      0x01
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_)        (((_) >> 31) & 0x01)
        };

        uint32_t flags;
    } cpuid_feature_information_edx;

} cpuid_eax_01;


/**
 * @brief Deterministic Cache Parameters Leaf
 *
 * When CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data that
 * describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid index
 * values start from 0.
 * Software can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an index
 * value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally defined
 * fields reported by deterministic cache parameters are documented in Table 3-8.
 * This Cache Size in Bytes
 * - = (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)
 * - = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)
 * The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores in a physical package.
 * This information is constant for all valid index values. Software can query the raw data reported by executing CPUID
 * with EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm.
 *
 * @see Vol3A[8(Multiple-Processor Management)]
 */
#define CPUID_CACHE_PARAMETERS                                       0x00000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] - 0 = Null - No more caches.
             * - 1 = Data Cache.
             * - 2 = Instruction Cache.
             * - 3 = Unified Cache.
             * - 4-31 = Reserved.
             */
            uint32_t cache_type_field : 5;
#define CPUID_EAX_CACHE_TYPE_FIELD_BIT                               0
#define CPUID_EAX_CACHE_TYPE_FIELD_FLAG                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD_MASK                              0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD(_)                                (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Cache Level (starts at 1).
             */
            uint32_t cache_level : 3;
#define CPUID_EAX_CACHE_LEVEL_BIT                                    5
#define CPUID_EAX_CACHE_LEVEL_FLAG                                   0xE0
#define CPUID_EAX_CACHE_LEVEL_MASK                                   0x07
#define CPUID_EAX_CACHE_LEVEL(_)                                     (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Self Initializing cache level (does not need SW initialization).
             */
            uint32_t self_initializing_cache_level : 1;
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT                  8
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG                 0x100
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK                 0x01
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_)                   (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Fully Associative cache.
             */
            uint32_t fully_associative_cache : 1;
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT                        9
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG                       0x200
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK                       0x01
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_)                         (((_) >> 9) & 0x01)
            uint32_t reserved1 : 4;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this cache.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs
             *       reserved for addressing different logical processors sharing this cache.
             */
            uint32_t max_addressable_ids_for_logical_processors_sharing_this_cache : 12;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT 14
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) (((_) >> 14) & 0xFFF)

            /**
             * [Bits 31:26] Maximum number of addressable IDs for processor cores in the physical package.
             *
             * @note Add one to the return value to get the result.
             *       The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for
             *       addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.
             *       The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.
             */
            uint32_t max_addressable_ids_for_processor_cores_in_physical_package : 6;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT 26
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) (((_) >> 26) & 0x3F)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 11:0] System Coherency Line Size.
             *
             * @note Add one to the return value to get the result.
             */
            uint32_t system_coherency_line_size : 12;
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT                     0
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK                    0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_)                      (((_) >> 0) & 0xFFF)

            /**
             * [Bits 21:12] Physical Line partitions.
             *
             * @note Add one to the return value to get the result.
             */
            uint32_t physical_line_partitions : 10;
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT                       12
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG                      0x3FF000
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK                      0x3FF
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_)                        (((_) >> 12) & 0x3FF)

            /**
             * [Bits 31:22] Ways of associativity.
             *
             * @note Add one to the return value to get the result.
             */
            uint32_t ways_of_associativity : 10;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT                          22
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG                         0xFFC00000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK                         0x3FF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_)                           (((_) >> 22) & 0x3FF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             *
             * @note Add one to the return value to get the result.
             */
            uint32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * @brief Write-Back Invalidate/Invalidate
             *
             * [Bit 0] - 0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.
             * - 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.
             */
            uint32_t write_back_invalidate : 1;
#define CPUID_EDX_WRITE_BACK_INVALIDATE_BIT                          0
#define CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE_MASK                         0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE(_)                           (((_) >> 0) & 0x01)

            /**
             * @brief Cache Inclusiveness
             *
             * [Bit 1] - 0 = Cache is not inclusive of lower cache levels.
             * - 1 = Cache is inclusive of lower cache levels.
             */
            uint32_t cache_inclusiveness : 1;
#define CPUID_EDX_CACHE_INCLUSIVENESS_BIT                            1
#define CPUID_EDX_CACHE_INCLUSIVENESS_FLAG                           0x02
#define CPUID_EDX_CACHE_INCLUSIVENESS_MASK                           0x01
#define CPUID_EDX_CACHE_INCLUSIVENESS(_)                             (((_) >> 1) & 0x01)

            /**
             * @brief Complex Cache Indexing
             *
             * [Bit 2] - 0 = Direct mapped cache.
             * - 1 = A complex function is used to index the cache, potentially using all address bits.
             */
            uint32_t complex_cache_indexing : 1;
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT                         2
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG                        0x04
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK                        0x01
#define CPUID_EDX_COMPLEX_CACHE_INDEXING(_)                          (((_) >> 2) & 0x01)
            uint32_t reserved1 : 29;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_04;


/**
 * @brief MONITOR/MWAIT Leaf
 *
 * When CPUID executes with EAX set to 05H, the processor returns information about features available to MONITOR/MWAIT
 * instructions. The MONITOR instruction is used for address-range monitoring in conjunction with MWAIT instruction. The
 * MWAIT instruction optionally provides additional extensions for advanced power management.
 */
#define CPUID_MONITOR_MWAIT                                          0x00000005
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's monitor granularity).
             */
            uint32_t smallest_monitor_line_size : 16;
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT                     0
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK                    0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_)                      (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Largest monitor-line size in bytes (default is processor's monitor granularity).
             */
            uint32_t largest_monitor_line_size : 16;
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT                      0
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK                     0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_)                       (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported.
             */
            uint32_t enumeration_of_monitor_mwait_extensions : 1;
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT        0
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK       0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_)         (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports treating interrupts as break-event for MWAIT, even when interrupts disabled.
             */
            uint32_t supports_treating_interrupts_as_break_event_for_mwait : 1;
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT 1
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG 0x02
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK 0x01
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_) (((_) >> 1) & 0x01)
            uint32_t reserved1 : 30;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of C0 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c0_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT                      0
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_)                       (((_) >> 0) & 0x0F)

            /**
             * [Bits 7:4] Number of C1 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c1_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT                      4
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG                     0xF0
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_)                       (((_) >> 4) & 0x0F)

            /**
             * [Bits 11:8] Number of C2 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c2_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT                      8
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG                     0xF00
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_)                       (((_) >> 8) & 0x0F)

            /**
             * [Bits 15:12] Number of C3 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c3_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT                      12
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG                     0xF000
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_)                       (((_) >> 12) & 0x0F)

            /**
             * [Bits 19:16] Number of C4 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c4_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT                      16
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG                     0xF0000
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_)                       (((_) >> 16) & 0x0F)

            /**
             * [Bits 23:20] Number of C5 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c5_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT                      20
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG                     0xF00000
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_)                       (((_) >> 20) & 0x0F)

            /**
             * [Bits 27:24] Number of C6 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c6_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT                      24
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG                     0xF000000
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_)                       (((_) >> 24) & 0x0F)

            /**
             * [Bits 31:28] Number of C7 sub C-states supported using MWAIT.
             */
            uint32_t number_of_c7_sub_c_states : 4;
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT                      28
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG                     0xF0000000
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK                     0x0F
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_)                       (((_) >> 28) & 0x0F)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_05;


/**
 * @brief Thermal and Power Management Leaf
 *
 * When CPUID executes with EAX set to 06H, the processor returns information about thermal and power management features.
 */
#define CPUID_THERMAL_AND_POWER_MANAGEMENT                           0x00000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] Digital temperature sensor is supported if set.
             */
            uint32_t temperature_sensor_supported : 1;
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT                   0
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK                  0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_)                    (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Intel Turbo Boost Technology available (see description of IA32_MISC_ENABLE[38]).
             */
            uint32_t intel_turbo_boost_technology_available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT         1
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG        0x02
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK        0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
             */
            uint32_t apic_timer_always_running : 1;
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT                      2
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG                     0x04
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK                     0x01
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_)                       (((_) >> 2) & 0x01)
            uint32_t reserved1 : 1;

            /**
             * [Bit 4] PLN. Power limit notification controls are supported if set.
             */
            uint32_t power_limit_notification : 1;
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT                       4
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG                      0x10
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK                      0x01
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_)                        (((_) >> 4) & 0x01)

            /**
             * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
             */
            uint32_t clock_modulation_duty : 1;
#define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT                          5
#define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG                         0x20
#define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK                         0x01
#define CPUID_EAX_CLOCK_MODULATION_DUTY(_)                           (((_) >> 5) & 0x01)

            /**
             * [Bit 6] PTM. Package thermal management is supported if set.
             */
            uint32_t package_thermal_management : 1;
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT                     6
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG                    0x40
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK                    0x01
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_)                      (((_) >> 6) & 0x01)

            /**
             * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are
             * supported if set.
             */
            uint32_t hwp_base_registers : 1;
#define CPUID_EAX_HWP_BASE_REGISTERS_BIT                             7
#define CPUID_EAX_HWP_BASE_REGISTERS_FLAG                            0x80
#define CPUID_EAX_HWP_BASE_REGISTERS_MASK                            0x01
#define CPUID_EAX_HWP_BASE_REGISTERS(_)                              (((_) >> 7) & 0x01)

            /**
             * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
             */
            uint32_t hwp_notification : 1;
#define CPUID_EAX_HWP_NOTIFICATION_BIT                               8
#define CPUID_EAX_HWP_NOTIFICATION_FLAG                              0x100
#define CPUID_EAX_HWP_NOTIFICATION_MASK                              0x01
#define CPUID_EAX_HWP_NOTIFICATION(_)                                (((_) >> 8) & 0x01)

            /**
             * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set.
             */
            uint32_t hwp_activity_window : 1;
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT                            9
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG                           0x200
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK                           0x01
#define CPUID_EAX_HWP_ACTIVITY_WINDOW(_)                             (((_) >> 9) & 0x01)

            /**
             * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set.
             */
            uint32_t hwp_energy_performance_preference : 1;
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT              10
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG             0x400
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK             0x01
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_)               (((_) >> 10) & 0x01)

            /**
             * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set.
             */
            uint32_t hwp_package_level_request : 1;
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT                      11
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG                     0x800
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK                     0x01
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_)                       (((_) >> 11) & 0x01)
            uint32_t reserved2 : 1;

            /**
             * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set.
             */
            uint32_t hdc : 1;
#define CPUID_EAX_HDC_BIT                                            13
#define CPUID_EAX_HDC_FLAG                                           0x2000
#define CPUID_EAX_HDC_MASK                                           0x01
#define CPUID_EAX_HDC(_)                                             (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
             */
            uint32_t intel_turbo_boost_max_technology_3_available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT   14
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG  0x4000
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK  0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_)    (((_) >> 14) & 0x01)

            /**
             * [Bit 15] HWP Capabilities. Highest Performance change is supported if set.
             */
            uint32_t hwp_capabilities : 1;
#define CPUID_EAX_HWP_CAPABILITIES_BIT                               15
#define CPUID_EAX_HWP_CAPABILITIES_FLAG                              0x8000
#define CPUID_EAX_HWP_CAPABILITIES_MASK                              0x01
#define CPUID_EAX_HWP_CAPABILITIES(_)                                (((_) >> 15) & 0x01)

            /**
             * [Bit 16] HWP PECI override is supported if set.
             */
            uint32_t hwp_peci_override : 1;
#define CPUID_EAX_HWP_PECI_OVERRIDE_BIT                              16
#define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG                             0x10000
#define CPUID_EAX_HWP_PECI_OVERRIDE_MASK                             0x01
#define CPUID_EAX_HWP_PECI_OVERRIDE(_)                               (((_) >> 16) & 0x01)

            /**
             * [Bit 17] Flexible HWP is supported if set.
             */
            uint32_t flexible_hwp : 1;
#define CPUID_EAX_FLEXIBLE_HWP_BIT                                   17
#define CPUID_EAX_FLEXIBLE_HWP_FLAG                                  0x20000
#define CPUID_EAX_FLEXIBLE_HWP_MASK                                  0x01
#define CPUID_EAX_FLEXIBLE_HWP(_)                                    (((_) >> 17) & 0x01)

            /**
             * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if set.
             */
            uint32_t fast_access_mode_for_hwp_request_msr : 1;
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT           18
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG          0x40000
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK          0x01
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_)            (((_) >> 18) & 0x01)
            uint32_t reserved3 : 1;

            /**
             * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
             */
            uint32_t ignoring_idle_logical_processor_hwp_request : 1;
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT    20
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG   0x100000
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK   0x01
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_)     (((_) >> 20) & 0x01)
            uint32_t reserved4 : 2;

            /**
             * [Bit 23] Intel Thread Director supported if set. IA32_HW_FEEDBACK_CHAR and IA32_HW_FEEDBACK_THREAD_CONFIG MSRs are
             * supported if set.
             */
            uint32_t intel_thread_director : 1;
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_BIT                          23
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_FLAG                         0x800000
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_MASK                         0x01
#define CPUID_EAX_INTEL_THREAD_DIRECTOR(_)                           (((_) >> 23) & 0x01)
            uint32_t reserved5 : 8;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] Number of Interrupt Thresholds in Digital Thermal Sensor.
             */
            uint32_t number_of_interrupt_thresholds_in_thermal_sensor : 4;
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT 0
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_) (((_) >> 0) & 0x0F)
            uint32_t reserved1 : 28;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a
             * measure of delivered processor performance (since last reset of the counters), as a percentage of the expected processor
             * performance when running at the TSC frequency.
             */
            uint32_t hardware_coordination_feedback_capability : 1;
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT      0
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK     0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_)       (((_) >> 0) & 0x01)
            uint32_t reserved1 : 2;

            /**
             * [Bit 3] Number of Intel Thread Director classes supported by the processor. Information for that many classes is written
             * into the Intel Thread Director Table by the hardware.
             */
            uint32_t number_of_intel_thread_director_classes : 1;
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_BIT        3
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_FLAG       0x08
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_MASK       0x01
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES(_)         (((_) >> 3) & 0x01)
            uint32_t reserved2 : 4;

            /**
             * [Bits 15:8] The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also
             * implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H).
             */
            uint32_t performance_energy_bias_preference : 8;
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT             8
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG            0xFF00
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK            0xFF
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_)              (((_) >> 8) & 0xFF)
            uint32_t reserved3 : 16;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_06;


/**
 * @brief Structured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)
 *
 * When CPUID executes with EAX set to 07H and ECX = 0, the processor returns information about the maximum input value for
 * sub-leaves that contain extended feature flags.
 * When CPUID executes with EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the
 * processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the highest leaf 7
 * sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.
 */
#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS                      0x00000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value for supported leaf 7 sub-leaves.
             */
            uint32_t number_of_sub_leaves : 32;
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT                           0
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK                          0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_)                            (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.
             */
            uint32_t fsgsbase : 1;
#define CPUID_EBX_FSGSBASE_BIT                                       0
#define CPUID_EBX_FSGSBASE_FLAG                                      0x01
#define CPUID_EBX_FSGSBASE_MASK                                      0x01
#define CPUID_EBX_FSGSBASE(_)                                        (((_) >> 0) & 0x01)

            /**
             * [Bit 1] IA32_TSC_ADJUST MSR is supported if 1.
             */
            uint32_t ia32_tsc_adjust_msr : 1;
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT                            1
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG                           0x02
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK                           0x01
#define CPUID_EBX_IA32_TSC_ADJUST_MSR(_)                             (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports Intel(R) Software Guard Extensions (Intel(R) SGX Extensions) if 1.
             */
            uint32_t sgx : 1;
#define CPUID_EBX_SGX_BIT                                            2
#define CPUID_EBX_SGX_FLAG                                           0x04
#define CPUID_EBX_SGX_MASK                                           0x01
#define CPUID_EBX_SGX(_)                                             (((_) >> 2) & 0x01)

            /**
             * [Bit 3] BMI1.
             */
            uint32_t bmi1 : 1;
#define CPUID_EBX_BMI1_BIT                                           3
#define CPUID_EBX_BMI1_FLAG                                          0x08
#define CPUID_EBX_BMI1_MASK                                          0x01
#define CPUID_EBX_BMI1(_)                                            (((_) >> 3) & 0x01)

            /**
             * [Bit 4] HLE.
             */
            uint32_t hle : 1;
#define CPUID_EBX_HLE_BIT                                            4
#define CPUID_EBX_HLE_FLAG                                           0x10
#define CPUID_EBX_HLE_MASK                                           0x01
#define CPUID_EBX_HLE(_)                                             (((_) >> 4) & 0x01)

            /**
             * [Bit 5] AVX2.
             */
            uint32_t avx2 : 1;
#define CPUID_EBX_AVX2_BIT                                           5
#define CPUID_EBX_AVX2_FLAG                                          0x20
#define CPUID_EBX_AVX2_MASK                                          0x01
#define CPUID_EBX_AVX2(_)                                            (((_) >> 5) & 0x01)

            /**
             * [Bit 6] x87 FPU Data Pointer updated only on x87 exceptions if 1.
             */
            uint32_t fdp_excptn_only : 1;
#define CPUID_EBX_FDP_EXCPTN_ONLY_BIT                                6
#define CPUID_EBX_FDP_EXCPTN_ONLY_FLAG                               0x40
#define CPUID_EBX_FDP_EXCPTN_ONLY_MASK                               0x01
#define CPUID_EBX_FDP_EXCPTN_ONLY(_)                                 (((_) >> 6) & 0x01)

            /**
             * [Bit 7] Supports Supervisor-Mode Execution Prevention if 1.
             */
            uint32_t smep : 1;
#define CPUID_EBX_SMEP_BIT                                           7
#define CPUID_EBX_SMEP_FLAG                                          0x80
#define CPUID_EBX_SMEP_MASK                                          0x01
#define CPUID_EBX_SMEP(_)                                            (((_) >> 7) & 0x01)

            /**
             * [Bit 8] BMI2.
             */
            uint32_t bmi2 : 1;
#define CPUID_EBX_BMI2_BIT                                           8
#define CPUID_EBX_BMI2_FLAG                                          0x100
#define CPUID_EBX_BMI2_MASK                                          0x01
#define CPUID_EBX_BMI2(_)                                            (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Supports Enhanced REP MOVSB/STOSB if 1.
             */
            uint32_t enhanced_rep_movsb_stosb : 1;
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT                       9
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG                      0x200
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK                      0x01
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_)                        (((_) >> 9) & 0x01)

            /**
             * [Bit 10] If 1, supports INVPCID instruction for system software that manages process-context identifiers.
             */
            uint32_t invpcid : 1;
#define CPUID_EBX_INVPCID_BIT                                        10
#define CPUID_EBX_INVPCID_FLAG                                       0x400
#define CPUID_EBX_INVPCID_MASK                                       0x01
#define CPUID_EBX_INVPCID(_)                                         (((_) >> 10) & 0x01)

            /**
             * [Bit 11] RTM.
             */
            uint32_t rtm : 1;
#define CPUID_EBX_RTM_BIT                                            11
#define CPUID_EBX_RTM_FLAG                                           0x800
#define CPUID_EBX_RTM_MASK                                           0x01
#define CPUID_EBX_RTM(_)                                             (((_) >> 11) & 0x01)

            /**
             * [Bit 12] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Monitoring capability if 1.
             */
            uint32_t rdt_m : 1;
#define CPUID_EBX_RDT_M_BIT                                          12
#define CPUID_EBX_RDT_M_FLAG                                         0x1000
#define CPUID_EBX_RDT_M_MASK                                         0x01
#define CPUID_EBX_RDT_M(_)                                           (((_) >> 12) & 0x01)

            /**
             * [Bit 13] Deprecates FPU CS and FPU DS values if 1.
             */
            uint32_t deprecates : 1;
#define CPUID_EBX_DEPRECATES_BIT                                     13
#define CPUID_EBX_DEPRECATES_FLAG                                    0x2000
#define CPUID_EBX_DEPRECATES_MASK                                    0x01
#define CPUID_EBX_DEPRECATES(_)                                      (((_) >> 13) & 0x01)

            /**
             * [Bit 14] Supports Intel(R) Memory Protection Extensions if 1.
             */
            uint32_t mpx : 1;
#define CPUID_EBX_MPX_BIT                                            14
#define CPUID_EBX_MPX_FLAG                                           0x4000
#define CPUID_EBX_MPX_MASK                                           0x01
#define CPUID_EBX_MPX(_)                                             (((_) >> 14) & 0x01)

            /**
             * [Bit 15] Supports Intel(R) Resource Director Technology (Intel(R) RDT) Allocation capability if 1.
             */
            uint32_t rdt : 1;
#define CPUID_EBX_RDT_BIT                                            15
#define CPUID_EBX_RDT_FLAG                                           0x8000
#define CPUID_EBX_RDT_MASK                                           0x01
#define CPUID_EBX_RDT(_)                                             (((_) >> 15) & 0x01)

            /**
             * [Bit 16] AVX512F.
             */
            uint32_t avx512f : 1;
#define CPUID_EBX_AVX512F_BIT                                        16
#define CPUID_EBX_AVX512F_FLAG                                       0x10000
#define CPUID_EBX_AVX512F_MASK                                       0x01
#define CPUID_EBX_AVX512F(_)                                         (((_) >> 16) & 0x01)

            /**
             * [Bit 17] AVX512DQ.
             */
            uint32_t avx512dq : 1;
#define CPUID_EBX_AVX512DQ_BIT                                       17
#define CPUID_EBX_AVX512DQ_FLAG                                      0x20000
#define CPUID_EBX_AVX512DQ_MASK                                      0x01
#define CPUID_EBX_AVX512DQ(_)                                        (((_) >> 17) & 0x01)

            /**
             * [Bit 18] RDSEED.
             */
            uint32_t rdseed : 1;
#define CPUID_EBX_RDSEED_BIT                                         18
#define CPUID_EBX_RDSEED_FLAG                                        0x40000
#define CPUID_EBX_RDSEED_MASK                                        0x01
#define CPUID_EBX_RDSEED(_)                                          (((_) >> 18) & 0x01)

            /**
             * [Bit 19] ADX.
             */
            uint32_t adx : 1;
#define CPUID_EBX_ADX_BIT                                            19
#define CPUID_EBX_ADX_FLAG                                           0x80000
#define CPUID_EBX_ADX_MASK                                           0x01
#define CPUID_EBX_ADX(_)                                             (((_) >> 19) & 0x01)

            /**
             * [Bit 20] Supports Supervisor-Mode Access Prevention (and the CLAC/STAC instructions) if 1.
             */
            uint32_t smap : 1;
#define CPUID_EBX_SMAP_BIT                                           20
#define CPUID_EBX_SMAP_FLAG                                          0x100000
#define CPUID_EBX_SMAP_MASK                                          0x01
#define CPUID_EBX_SMAP(_)                                            (((_) >> 20) & 0x01)

            /**
             * [Bit 21] AVX512_IFMA.
             */
            uint32_t avx512_ifma : 1;
#define CPUID_EBX_AVX512_IFMA_BIT                                    21
#define CPUID_EBX_AVX512_IFMA_FLAG                                   0x200000
#define CPUID_EBX_AVX512_IFMA_MASK                                   0x01
#define CPUID_EBX_AVX512_IFMA(_)                                     (((_) >> 21) & 0x01)
            uint32_t reserved1 : 1;

            /**
             * [Bit 23] CLFLUSHOPT.
             */
            uint32_t clflushopt : 1;
#define CPUID_EBX_CLFLUSHOPT_BIT                                     23
#define CPUID_EBX_CLFLUSHOPT_FLAG                                    0x800000
#define CPUID_EBX_CLFLUSHOPT_MASK                                    0x01
#define CPUID_EBX_CLFLUSHOPT(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bit 24] CLWB.
             */
            uint32_t clwb : 1;
#define CPUID_EBX_CLWB_BIT                                           24
#define CPUID_EBX_CLWB_FLAG                                          0x1000000
#define CPUID_EBX_CLWB_MASK                                          0x01
#define CPUID_EBX_CLWB(_)                                            (((_) >> 24) & 0x01)

            /**
             * [Bit 25] Intel Processor Trace.
             */
            uint32_t intel : 1;
#define CPUID_EBX_INTEL_BIT                                          25
#define CPUID_EBX_INTEL_FLAG                                         0x2000000
#define CPUID_EBX_INTEL_MASK                                         0x01
#define CPUID_EBX_INTEL(_)                                           (((_) >> 25) & 0x01)

            /**
             * [Bit 26] (Intel(R) Xeon Phi(TM) only).
             */
            uint32_t avx512pf : 1;
#define CPUID_EBX_AVX512PF_BIT                                       26
#define CPUID_EBX_AVX512PF_FLAG                                      0x4000000
#define CPUID_EBX_AVX512PF_MASK                                      0x01
#define CPUID_EBX_AVX512PF(_)                                        (((_) >> 26) & 0x01)

            /**
             * [Bit 27] (Intel(R) Xeon Phi(TM) only).
             */
            uint32_t avx512er : 1;
#define CPUID_EBX_AVX512ER_BIT                                       27
#define CPUID_EBX_AVX512ER_FLAG                                      0x8000000
#define CPUID_EBX_AVX512ER_MASK                                      0x01
#define CPUID_EBX_AVX512ER(_)                                        (((_) >> 27) & 0x01)

            /**
             * [Bit 28] AVX512CD.
             */
            uint32_t avx512cd : 1;
#define CPUID_EBX_AVX512CD_BIT                                       28
#define CPUID_EBX_AVX512CD_FLAG                                      0x10000000
#define CPUID_EBX_AVX512CD_MASK                                      0x01
#define CPUID_EBX_AVX512CD(_)                                        (((_) >> 28) & 0x01)

            /**
             * [Bit 29] Supports Intel(R) Secure Hash Algorithm Extensions (Intel(R) SHA Extensions) if 1.
             */
            uint32_t sha : 1;
#define CPUID_EBX_SHA_BIT                                            29
#define CPUID_EBX_SHA_FLAG                                           0x20000000
#define CPUID_EBX_SHA_MASK                                           0x01
#define CPUID_EBX_SHA(_)                                             (((_) >> 29) & 0x01)

            /**
             * [Bit 30] AVX512BW.
             */
            uint32_t avx512bw : 1;
#define CPUID_EBX_AVX512BW_BIT                                       30
#define CPUID_EBX_AVX512BW_FLAG                                      0x40000000
#define CPUID_EBX_AVX512BW_MASK                                      0x01
#define CPUID_EBX_AVX512BW(_)                                        (((_) >> 30) & 0x01)

            /**
             * [Bit 31] AVX512VL.
             */
            uint32_t avx512vl : 1;
#define CPUID_EBX_AVX512VL_BIT                                       31
#define CPUID_EBX_AVX512VL_FLAG                                      0x80000000
#define CPUID_EBX_AVX512VL_MASK                                      0x01
#define CPUID_EBX_AVX512VL(_)                                        (((_) >> 31) & 0x01)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] (Intel(R) Xeon Phi(TM) only).
             */
            uint32_t prefetchwt1 : 1;
#define CPUID_ECX_PREFETCHWT1_BIT                                    0
#define CPUID_ECX_PREFETCHWT1_FLAG                                   0x01
#define CPUID_ECX_PREFETCHWT1_MASK                                   0x01
#define CPUID_ECX_PREFETCHWT1(_)                                     (((_) >> 0) & 0x01)

            /**
             * [Bit 1] AVX512_VBMI.
             */
            uint32_t avx512_vbmi : 1;
#define CPUID_ECX_AVX512_VBMI_BIT                                    1
#define CPUID_ECX_AVX512_VBMI_FLAG                                   0x02
#define CPUID_ECX_AVX512_VBMI_MASK                                   0x01
#define CPUID_ECX_AVX512_VBMI(_)                                     (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports user-mode instruction prevention if 1.
             */
            uint32_t umip : 1;
#define CPUID_ECX_UMIP_BIT                                           2
#define CPUID_ECX_UMIP_FLAG                                          0x04
#define CPUID_ECX_UMIP_MASK                                          0x01
#define CPUID_ECX_UMIP(_)                                            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports protection keys for user-mode pages if 1.
             */
            uint32_t pku : 1;
#define CPUID_ECX_PKU_BIT                                            3
#define CPUID_ECX_PKU_FLAG                                           0x08
#define CPUID_ECX_PKU_MASK                                           0x01
#define CPUID_ECX_PKU(_)                                             (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, OS has set CR4.PKE to enable protection keys (and the RDPKRU/WRPKRU instructions).
             */
            uint32_t ospke : 1;
#define CPUID_ECX_OSPKE_BIT                                          4
#define CPUID_ECX_OSPKE_FLAG                                         0x10
#define CPUID_ECX_OSPKE_MASK                                         0x01
#define CPUID_ECX_OSPKE(_)                                           (((_) >> 4) & 0x01)

            /**
             * [Bit 5] WAITPKG.
             */
            uint32_t waitpkg : 1;
#define CPUID_ECX_WAITPKG_BIT                                        5
#define CPUID_ECX_WAITPKG_FLAG                                       0x20
#define CPUID_ECX_WAITPKG_MASK                                       0x01
#define CPUID_ECX_WAITPKG(_)                                         (((_) >> 5) & 0x01)

            /**
             * [Bit 6] AVX512_VBMI2.
             */
            uint32_t avx512_vbmi2 : 1;
#define CPUID_ECX_AVX512_VBMI2_BIT                                   6
#define CPUID_ECX_AVX512_VBMI2_FLAG                                  0x40
#define CPUID_ECX_AVX512_VBMI2_MASK                                  0x01
#define CPUID_ECX_AVX512_VBMI2(_)                                    (((_) >> 6) & 0x01)

            /**
             * [Bit 7] Supports CET shadow stack features if 1. Processors that set this bit define bits 1:0 of the IA32_U_CET and
             * IA32_S_CET MSRs. Enumerates support for the following MSRs: IA32_INTERRUPT_SPP_TABLE_ADDR, IA32_PL3_SSP, IA32_PL2_SSP,
             * IA32_PL1_SSP, and IA32_PL0_SSP.
             */
            uint32_t cet_ss : 1;
#define CPUID_ECX_CET_SS_BIT                                         7
#define CPUID_ECX_CET_SS_FLAG                                        0x80
#define CPUID_ECX_CET_SS_MASK                                        0x01
#define CPUID_ECX_CET_SS(_)                                          (((_) >> 7) & 0x01)

            /**
             * [Bit 8] GFNI.
             */
            uint32_t gfni : 1;
#define CPUID_ECX_GFNI_BIT                                           8
#define CPUID_ECX_GFNI_FLAG                                          0x100
#define CPUID_ECX_GFNI_MASK                                          0x01
#define CPUID_ECX_GFNI(_)                                            (((_) >> 8) & 0x01)

            /**
             * [Bit 9] VAES.
             */
            uint32_t vaes : 1;
#define CPUID_ECX_VAES_BIT                                           9
#define CPUID_ECX_VAES_FLAG                                          0x200
#define CPUID_ECX_VAES_MASK                                          0x01
#define CPUID_ECX_VAES(_)                                            (((_) >> 9) & 0x01)

            /**
             * [Bit 10] VPCLMULQDQ.
             */
            uint32_t vpclmulqdq : 1;
#define CPUID_ECX_VPCLMULQDQ_BIT                                     10
#define CPUID_ECX_VPCLMULQDQ_FLAG                                    0x400
#define CPUID_ECX_VPCLMULQDQ_MASK                                    0x01
#define CPUID_ECX_VPCLMULQDQ(_)                                      (((_) >> 10) & 0x01)

            /**
             * [Bit 11] AVX512_VNNI.
             */
            uint32_t avx512_vnni : 1;
#define CPUID_ECX_AVX512_VNNI_BIT                                    11
#define CPUID_ECX_AVX512_VNNI_FLAG                                   0x800
#define CPUID_ECX_AVX512_VNNI_MASK                                   0x01
#define CPUID_ECX_AVX512_VNNI(_)                                     (((_) >> 11) & 0x01)

            /**
             * [Bit 12] AVX512_BITALG.
             */
            uint32_t avx512_bitalg : 1;
#define CPUID_ECX_AVX512_BITALG_BIT                                  12
#define CPUID_ECX_AVX512_BITALG_FLAG                                 0x1000
#define CPUID_ECX_AVX512_BITALG_MASK                                 0x01
#define CPUID_ECX_AVX512_BITALG(_)                                   (((_) >> 12) & 0x01)

            /**
             * [Bit 13] If 1, the following MSRs are supported: IA32_TME_CAPABILITY, IA32_TME_ACTIVATE, IA32_TME_EXCLUDE_MASK, and
             * IA32_TME_EXCLUDE_BASE.
             */
            uint32_t tme_en : 1;
#define CPUID_ECX_TME_EN_BIT                                         13
#define CPUID_ECX_TME_EN_FLAG                                        0x2000
#define CPUID_ECX_TME_EN_MASK                                        0x01
#define CPUID_ECX_TME_EN(_)                                          (((_) >> 13) & 0x01)

            /**
             * [Bit 14] AVX512_VPOPCNTDQ.
             */
            uint32_t avx512_vpopcntdq : 1;
#define CPUID_ECX_AVX512_VPOPCNTDQ_BIT                               14
#define CPUID_ECX_AVX512_VPOPCNTDQ_FLAG                              0x4000
#define CPUID_ECX_AVX512_VPOPCNTDQ_MASK                              0x01
#define CPUID_ECX_AVX512_VPOPCNTDQ(_)                                (((_) >> 14) & 0x01)
            uint32_t reserved1 : 1;

            /**
             * [Bit 16] Supports 57-bit linear addresses and five-level paging if 1.
             */
            uint32_t la57 : 1;
#define CPUID_ECX_LA57_BIT                                           16
#define CPUID_ECX_LA57_FLAG                                          0x10000
#define CPUID_ECX_LA57_MASK                                          0x01
#define CPUID_ECX_LA57(_)                                            (((_) >> 16) & 0x01)

            /**
             * [Bits 21:17] The value of MAWAU used by the BNDLDX and BNDSTX instructions in 64-bit mode.
             */
            uint32_t mawau : 5;
#define CPUID_ECX_MAWAU_BIT                                          17
#define CPUID_ECX_MAWAU_FLAG                                         0x3E0000
#define CPUID_ECX_MAWAU_MASK                                         0x1F
#define CPUID_ECX_MAWAU(_)                                           (((_) >> 17) & 0x1F)

            /**
             * [Bit 22] RDPID and IA32_TSC_AUX are available if 1.
             */
            uint32_t rdpid : 1;
#define CPUID_ECX_RDPID_BIT                                          22
#define CPUID_ECX_RDPID_FLAG                                         0x400000
#define CPUID_ECX_RDPID_MASK                                         0x01
#define CPUID_ECX_RDPID(_)                                           (((_) >> 22) & 0x01)

            /**
             * [Bit 23] KL. Supports Key Locker if 1.
             */
            uint32_t kl : 1;
#define CPUID_ECX_KL_BIT                                             23
#define CPUID_ECX_KL_FLAG                                            0x800000
#define CPUID_ECX_KL_MASK                                            0x01
#define CPUID_ECX_KL(_)                                              (((_) >> 23) & 0x01)
            uint32_t reserved2 : 1;

            /**
             * [Bit 25] Supports cache line demote if 1.
             */
            uint32_t cldemote : 1;
#define CPUID_ECX_CLDEMOTE_BIT                                       25
#define CPUID_ECX_CLDEMOTE_FLAG                                      0x2000000
#define CPUID_ECX_CLDEMOTE_MASK                                      0x01
#define CPUID_ECX_CLDEMOTE(_)                                        (((_) >> 25) & 0x01)
            uint32_t reserved3 : 1;

            /**
             * [Bit 27] Supports MOVDIRI if 1.
             */
            uint32_t movdiri : 1;
#define CPUID_ECX_MOVDIRI_BIT                                        27
#define CPUID_ECX_MOVDIRI_FLAG                                       0x8000000
#define CPUID_ECX_MOVDIRI_MASK                                       0x01
#define CPUID_ECX_MOVDIRI(_)                                         (((_) >> 27) & 0x01)

            /**
             * [Bit 28] Supports MOVDIR64B if 1.
             */
            uint32_t movdir64b : 1;
#define CPUID_ECX_MOVDIR64B_BIT                                      28
#define CPUID_ECX_MOVDIR64B_FLAG                                     0x10000000
#define CPUID_ECX_MOVDIR64B_MASK                                     0x01
#define CPUID_ECX_MOVDIR64B(_)                                       (((_) >> 28) & 0x01)
            uint32_t reserved4 : 1;

            /**
             * [Bit 30] Supports SGX Launch Configuration if 1.
             */
            uint32_t sgx_lc : 1;
#define CPUID_ECX_SGX_LC_BIT                                         30
#define CPUID_ECX_SGX_LC_FLAG                                        0x40000000
#define CPUID_ECX_SGX_LC_MASK                                        0x01
#define CPUID_ECX_SGX_LC(_)                                          (((_) >> 30) & 0x01)

            /**
             * [Bit 31] Supports protection keys for supervisor-mode pages if 1.
             */
            uint32_t pks : 1;
#define CPUID_ECX_PKS_BIT                                            31
#define CPUID_ECX_PKS_FLAG                                           0x80000000
#define CPUID_ECX_PKS_MASK                                           0x01
#define CPUID_ECX_PKS(_)                                             (((_) >> 31) & 0x01)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            uint32_t reserved1 : 2;

            /**
             * [Bit 2] (Intel(R) Xeon Phi(TM) only.)
             */
            uint32_t avx512_4vnniw : 1;
#define CPUID_EDX_AVX512_4VNNIW_BIT                                  2
#define CPUID_EDX_AVX512_4VNNIW_FLAG                                 0x04
#define CPUID_EDX_AVX512_4VNNIW_MASK                                 0x01
#define CPUID_EDX_AVX512_4VNNIW(_)                                   (((_) >> 2) & 0x01)

            /**
             * [Bit 3] (Intel(R) Xeon Phi(TM) only.)
             */
            uint32_t avx512_4fmaps : 1;
#define CPUID_EDX_AVX512_4FMAPS_BIT                                  3
#define CPUID_EDX_AVX512_4FMAPS_FLAG                                 0x08
#define CPUID_EDX_AVX512_4FMAPS_MASK                                 0x01
#define CPUID_EDX_AVX512_4FMAPS(_)                                   (((_) >> 3) & 0x01)

            /**
             * [Bit 4] Fast Short REP MOV.
             */
            uint32_t fast_short_rep_mov : 1;
#define CPUID_EDX_FAST_SHORT_REP_MOV_BIT                             4
#define CPUID_EDX_FAST_SHORT_REP_MOV_FLAG                            0x10
#define CPUID_EDX_FAST_SHORT_REP_MOV_MASK                            0x01
#define CPUID_EDX_FAST_SHORT_REP_MOV(_)                              (((_) >> 4) & 0x01)
            uint32_t reserved2 : 3;

            /**
             * [Bit 8] AVX512_VP2INTERSECT.
             */
            uint32_t avx512_vp2intersect : 1;
#define CPUID_EDX_AVX512_VP2INTERSECT_BIT                            8
#define CPUID_EDX_AVX512_VP2INTERSECT_FLAG                           0x100
#define CPUID_EDX_AVX512_VP2INTERSECT_MASK                           0x01
#define CPUID_EDX_AVX512_VP2INTERSECT(_)                             (((_) >> 8) & 0x01)
            uint32_t reserved3 : 1;

            /**
             * [Bit 10] MD_CLEAR supported.
             */
            uint32_t md_clear : 1;
#define CPUID_EDX_MD_CLEAR_BIT                                       10
#define CPUID_EDX_MD_CLEAR_FLAG                                      0x400
#define CPUID_EDX_MD_CLEAR_MASK                                      0x01
#define CPUID_EDX_MD_CLEAR(_)                                        (((_) >> 10) & 0x01)
            uint32_t reserved4 : 3;

            /**
             * [Bit 14] SERIALIZE supported.
             */
            uint32_t serialize : 1;
#define CPUID_EDX_SERIALIZE_BIT                                      14
#define CPUID_EDX_SERIALIZE_FLAG                                     0x4000
#define CPUID_EDX_SERIALIZE_MASK                                     0x01
#define CPUID_EDX_SERIALIZE(_)                                       (((_) >> 14) & 0x01)

            /**
             * [Bit 15] If 1, the processor is identified as a hybrid part.
             */
            uint32_t hybrid : 1;
#define CPUID_EDX_HYBRID_BIT                                         15
#define CPUID_EDX_HYBRID_FLAG                                        0x8000
#define CPUID_EDX_HYBRID_MASK                                        0x01
#define CPUID_EDX_HYBRID(_)                                          (((_) >> 15) & 0x01)
            uint32_t reserved5 : 2;

            /**
             * [Bit 18] Supports PCONFIG if 1.
             */
            uint32_t pconfig : 1;
#define CPUID_EDX_PCONFIG_BIT                                        18
#define CPUID_EDX_PCONFIG_FLAG                                       0x40000
#define CPUID_EDX_PCONFIG_MASK                                       0x01
#define CPUID_EDX_PCONFIG(_)                                         (((_) >> 18) & 0x01)
            uint32_t reserved6 : 1;

            /**
             * [Bit 20] Supports CET indirect branch tracking features if 1. Processors that set this bit define bits 5:2 and bits
             * 63:10 of the IA32_U_CET and IA32_S_CET MSRs.
             */
            uint32_t cet_ibt : 1;
#define CPUID_EDX_CET_IBT_BIT                                        20
#define CPUID_EDX_CET_IBT_FLAG                                       0x100000
#define CPUID_EDX_CET_IBT_MASK                                       0x01
#define CPUID_EDX_CET_IBT(_)                                         (((_) >> 20) & 0x01)
            uint32_t reserved7 : 5;

            /**
             * [Bit 26] Enumerates support for indirect branch restricted speculation (IBRS) and the indirect branch predictor barrier
             * (IBPB). Processors that set this bit support the IA32_SPEC_CTRL MSR and the IA32_PRED_CMD MSR. They allow software to
             * set IA32_SPEC_CTRL[0] (IBRS) and IA32_PRED_CMD[0] (IBPB).
             */
            uint32_t ibrs_ibpb : 1;
#define CPUID_EDX_IBRS_IBPB_BIT                                      26
#define CPUID_EDX_IBRS_IBPB_FLAG                                     0x4000000
#define CPUID_EDX_IBRS_IBPB_MASK                                     0x01
#define CPUID_EDX_IBRS_IBPB(_)                                       (((_) >> 26) & 0x01)

            /**
             * [Bit 27] Enumerates support for single thread indirect branch predictors (STIBP). Processors that set this bit support
             * the IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[1] (STIBP).
             */
            uint32_t stibp : 1;
#define CPUID_EDX_STIBP_BIT                                          27
#define CPUID_EDX_STIBP_FLAG                                         0x8000000
#define CPUID_EDX_STIBP_MASK                                         0x01
#define CPUID_EDX_STIBP(_)                                           (((_) >> 27) & 0x01)

            /**
             * [Bit 28] Enumerates support for L1D_FLUSH. Processors that set this bit support the IA32_FLUSH_CMD MSR. They allow
             * software to set IA32_FLUSH_CMD[0] (L1D_FLUSH).
             */
            uint32_t l1d_flush : 1;
#define CPUID_EDX_L1D_FLUSH_BIT                                      28
#define CPUID_EDX_L1D_FLUSH_FLAG                                     0x10000000
#define CPUID_EDX_L1D_FLUSH_MASK                                     0x01
#define CPUID_EDX_L1D_FLUSH(_)                                       (((_) >> 28) & 0x01)

            /**
             * [Bit 29] Enumerates support for the IA32_ARCH_CAPABILITIES MSR.
             */
            uint32_t ia32_arch_capabilities : 1;
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_BIT                         29
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_FLAG                        0x20000000
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_MASK                        0x01
#define CPUID_EDX_IA32_ARCH_CAPABILITIES(_)                          (((_) >> 29) & 0x01)

            /**
             * [Bit 30] Enumerates support for the IA32_CORE_CAPABILITIES MSR.
             */
            uint32_t ia32_core_capabilities : 1;
#define CPUID_EDX_IA32_CORE_CAPABILITIES_BIT                         30
#define CPUID_EDX_IA32_CORE_CAPABILITIES_FLAG                        0x40000000
#define CPUID_EDX_IA32_CORE_CAPABILITIES_MASK                        0x01
#define CPUID_EDX_IA32_CORE_CAPABILITIES(_)                          (((_) >> 30) & 0x01)

            /**
             * [Bit 31] Enumerates support for Speculative Store Bypass Disable (SSBD). Processors that set this bit support the
             * IA32_SPEC_CTRL MSR. They allow software to set IA32_SPEC_CTRL[2] (SSBD).
             */
            uint32_t ssbd : 1;
#define CPUID_EDX_SSBD_BIT                                           31
#define CPUID_EDX_SSBD_FLAG                                          0x80000000
#define CPUID_EDX_SSBD_MASK                                          0x01
#define CPUID_EDX_SSBD(_)                                            (((_) >> 31) & 0x01)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_07;


/**
 * @brief Direct Cache Access Information Leaf
 *
 * When CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabilities.
 */
#define CPUID_DIRECT_CACHE_ACCESS_INFORMATION                        0x00000009
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            uint32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_09;


/**
 * @brief Architectural Performance Monitoring Leaf
 *
 * When CPUID executes with EAX set to 0AH, the processor returns information about support for architectural performance
 * monitoring capabilities. Architectural performance monitoring is supported if the version ID is greater than Pn 0. For
 * each version of architectural performance monitoring capability, software must enumerate this leaf to discover the
 * programming facilities and the architectural performance events available in the processor.
 *
 * @see Vol3C[23(Introduction to Virtual-Machine Extensions)]
 */
#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING                   0x0000000A
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Version ID of architectural performance monitoring.
             */
            uint32_t version_id_of_architectural_performance_monitoring : 8;
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT 0
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_) (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Number of general-purpose performance monitoring counter per logical processor.
             */
            uint32_t number_of_performance_monitoring_counter_per_logical_processor : 8;
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT 8
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) (((_) >> 8) & 0xFF)

            /**
             * [Bits 23:16] Bit width of general-purpose, performance monitoring counter.
             */
            uint32_t bit_width_of_performance_monitoring_counter : 8;
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT    16
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG   0xFF0000
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK   0xFF
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_)     (((_) >> 16) & 0xFF)

            /**
             * [Bits 31:24] Length of EBX bit vector to enumerate architectural performance monitoring events.
             */
            uint32_t ebx_bit_vector_length : 8;
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT                          24
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG                         0xFF000000
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK                         0xFF
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_)                           (((_) >> 24) & 0xFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] Core cycle event not available if 1.
             */
            uint32_t core_cycle_event_not_available : 1;
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT                 0
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK                0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_)                  (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Instruction retired event not available if 1.
             */
            uint32_t instruction_retired_event_not_available : 1;
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT        1
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG       0x02
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK       0x01
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Reference cycles event not available if 1.
             */
            uint32_t reference_cycles_event_not_available : 1;
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT           2
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG          0x04
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK          0x01
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_)            (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Last-level cache reference event not available if 1.
             */
            uint32_t last_level_cache_reference_event_not_available : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT 3
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG 0x08
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_)  (((_) >> 3) & 0x01)

            /**
             * [Bit 4] Last-level cache misses event not available if 1.
             */
            uint32_t last_level_cache_misses_event_not_available : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT    4
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG   0x10
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK   0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_)     (((_) >> 4) & 0x01)

            /**
             * [Bit 5] Branch instruction retired event not available if 1.
             */
            uint32_t branch_instruction_retired_event_not_available : 1;
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT 5
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x20
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)  (((_) >> 5) & 0x01)

            /**
             * [Bit 6] Branch mispredict retired event not available if 1.
             */
            uint32_t branch_mispredict_retired_event_not_available : 1;
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT  6
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x40
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 6) & 0x01)
            uint32_t reserved1 : 25;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of fixed-function performance counters (if Version ID > 1).
             */
            uint32_t number_of_fixed_function_performance_counters : 5;
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT  0
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_)   (((_) >> 0) & 0x1F)

            /**
             * [Bits 12:5] Bit width of fixed-function performance counters (if Version ID > 1).
             */
            uint32_t bit_width_of_fixed_function_performance_counters : 8;
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT 5
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1FE0
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0xFF
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_) (((_) >> 5) & 0xFF)
            uint32_t reserved1 : 2;

            /**
             * [Bit 15] AnyThread deprecation.
             */
            uint32_t any_thread_deprecation : 1;
#define CPUID_EDX_ANY_THREAD_DEPRECATION_BIT                         15
#define CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG                        0x8000
#define CPUID_EDX_ANY_THREAD_DEPRECATION_MASK                        0x01
#define CPUID_EDX_ANY_THREAD_DEPRECATION(_)                          (((_) >> 15) & 0x01)
            uint32_t reserved2 : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0a;


/**
 * @brief Extended Topology Enumeration Leaf
 *
 * When CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumeration data.
 * Software must detect the presence of CPUID leaf 0BH by verifying
 * - the highest leaf index supported by CPUID is >= 0BH, and
 * - CPUID.0BH:EBX[15:0] reports a non-zero value.
 *
 * @note Most of Leaf 0BH output depends on the initial value in ECX. The EDX output of leaf 0BH is always valid and does
 *       not vary with input value in ECX. Output value in ECX[7:0] always equals input value in ECX[7:0]. Sub-leaf index 0
 *       enumerates SMT level. Each subsequent higher sub-leaf index enumerates a higherlevel topological entity in hierarchical
 *       order. For sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0. If an input value
 *       n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return 0 in ECX[15:8].
 */
#define CPUID_EXTENDED_TOPOLOGY                                      0x0000000B
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type. All logical
             * processors with the same next level ID share current level.
             *
             * @note Software should use this field (EAX[4:0]) to enumerate processor topology of the system.
             */
            uint32_t x2apic_id_to_unique_topology_id_shift : 5;
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT          0
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK         0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_)           (((_) >> 0) & 0x1F)
            uint32_t reserved1 : 27;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Number of logical processors at this level type. The number reflects configuration as shipped by Intel.
             *
             * @note Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field
             *       (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to
             *       BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware
             *       configurations.
             */
            uint32_t number_of_logical_processors_at_this_level_type : 16;
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT 0
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_) (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Level number. Same value in ECX input.
             */
            uint32_t level_number : 8;
#define CPUID_ECX_LEVEL_NUMBER_BIT                                   0
#define CPUID_ECX_LEVEL_NUMBER_FLAG                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER_MASK                                  0xFF
#define CPUID_ECX_LEVEL_NUMBER(_)                                    (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Level type.
             *
             * @note The value of the "level type" field is not related to level numbers in any way, higher "level type" values do not
             *       mean higher levels. Level type field has the following encoding:
             *       - 0: Invalid.
             *       - 1: SMT.
             *       - 2: Core.
             *       - 3-255: Reserved.
             */
            uint32_t level_type : 8;
#define CPUID_ECX_LEVEL_TYPE_BIT                                     8
#define CPUID_ECX_LEVEL_TYPE_FLAG                                    0xFF00
#define CPUID_ECX_LEVEL_TYPE_MASK                                    0xFF
#define CPUID_ECX_LEVEL_TYPE(_)                                      (((_) >> 8) & 0xFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] x2APIC ID the current logical processor.
             */
            uint32_t x2apic_id : 32;
#define CPUID_EDX_X2APIC_ID_BIT                                      0
#define CPUID_EDX_X2APIC_ID_FLAG                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID_MASK                                     0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0b;

/**
 * @defgroup cpuid_eax_0d \
 *           EAX = 0x0D
 *
 * When CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the bit-vector
 * representation of all processor state extensions that are supported in the processor and storage size requirements of
 * the XSAVE/XRSTOR area.
 * When CPUID executes with EAX set to 0DH and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns
 * information about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. Software
 * can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain size and offset
 * information for each processor extended state save area:
 * <pre> For i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1) // VECTOR is the 64-bit value
 * of EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI; </pre>
 * @{
 */
#define CPUID_EXTENDED_STATE_INFORMATION                             0x0000000D
 /**
  * @brief Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)
  */
typedef struct
{
    /**
     * @brief Reports the supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1 only if EAX[n] is 1
     */
    union
    {
        struct
        {
            /**
             * [Bit 0] x87 state.
             */
            uint32_t x87_state : 1;
#define CPUID_EAX_X87_STATE_BIT                                      0
#define CPUID_EAX_X87_STATE_FLAG                                     0x01
#define CPUID_EAX_X87_STATE_MASK                                     0x01
#define CPUID_EAX_X87_STATE(_)                                       (((_) >> 0) & 0x01)

            /**
             * [Bit 1] SSE state.
             */
            uint32_t sse_state : 1;
#define CPUID_EAX_SSE_STATE_BIT                                      1
#define CPUID_EAX_SSE_STATE_FLAG                                     0x02
#define CPUID_EAX_SSE_STATE_MASK                                     0x01
#define CPUID_EAX_SSE_STATE(_)                                       (((_) >> 1) & 0x01)

            /**
             * [Bit 2] AVX state.
             */
            uint32_t avx_state : 1;
#define CPUID_EAX_AVX_STATE_BIT                                      2
#define CPUID_EAX_AVX_STATE_FLAG                                     0x04
#define CPUID_EAX_AVX_STATE_MASK                                     0x01
#define CPUID_EAX_AVX_STATE(_)                                       (((_) >> 2) & 0x01)

            /**
             * [Bits 4:3] MPX state.
             */
            uint32_t mpx_state : 2;
#define CPUID_EAX_MPX_STATE_BIT                                      3
#define CPUID_EAX_MPX_STATE_FLAG                                     0x18
#define CPUID_EAX_MPX_STATE_MASK                                     0x03
#define CPUID_EAX_MPX_STATE(_)                                       (((_) >> 3) & 0x03)

            /**
             * [Bits 7:5] AVX-512 state.
             */
            uint32_t avx_512_state : 3;
#define CPUID_EAX_AVX_512_STATE_BIT                                  5
#define CPUID_EAX_AVX_512_STATE_FLAG                                 0xE0
#define CPUID_EAX_AVX_512_STATE_MASK                                 0x07
#define CPUID_EAX_AVX_512_STATE(_)                                   (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Used for IA32_XSS.
             */
            uint32_t used_for_ia32_xss_1 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT                            8
#define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG                           0x100
#define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_1(_)                             (((_) >> 8) & 0x01)

            /**
             * [Bit 9] PKRU state.
             */
            uint32_t pkru_state : 1;
#define CPUID_EAX_PKRU_STATE_BIT                                     9
#define CPUID_EAX_PKRU_STATE_FLAG                                    0x200
#define CPUID_EAX_PKRU_STATE_MASK                                    0x01
#define CPUID_EAX_PKRU_STATE(_)                                      (((_) >> 9) & 0x01)
            uint32_t reserved1 : 3;

            /**
             * [Bit 13] Used for IA32_XSS.
             */
            uint32_t used_for_ia32_xss_2 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT                            13
#define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG                           0x2000
#define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK                           0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_2(_)                             (((_) >> 13) & 0x01)
            uint32_t reserved2 : 18;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by enabled features in XCR0.
             * May be different than ECX if some features at the end of the XSAVE save area are not enabled.
             */
            uint32_t max_size_required_by_enabled_features_in_xcr0 : 32;
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT  0
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_)   (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the XSAVE/XRSTOR save area
             * required by all supported features in the processor, i.e., all the valid bit fields in XCR0.
             */
            uint32_t max_size_of_xsave_xrstor_save_area : 32;
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT             0
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK            0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_)              (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the supported bits of the upper 32 bits of XCR0. XCR0[n+32] can be set to 1 only if EDX[n] is 1.
             */
            uint32_t xcr0_supported_bits : 32;
#define CPUID_EDX_XCR0_SUPPORTED_BITS_BIT                            0
#define CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS_MASK                           0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0d_ecx_00;

/**
 * @brief Direct Cache Access Information Leaf
 */
typedef struct
{
    union
    {
        struct
        {
            uint32_t reserved1 : 1;

            /**
             * [Bit 1] Supports XSAVEC and the compacted form of XRSTOR if set.
             */
            uint32_t supports_xsavec_and_compacted_xrstor : 1;
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT           1
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG          0x02
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK          0x01
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_)            (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports XGETBV with ECX = 1 if set.
             */
            uint32_t supports_xgetbv_with_ecx_1 : 1;
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT                     2
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG                    0x04
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK                    0x01
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
             */
            uint32_t supports_xsave_xrstor_and_ia32_xss : 1;
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT             3
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG            0x08
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK            0x01
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_)              (((_) >> 3) & 0x01)
            uint32_t reserved2 : 28;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.
             */
            uint32_t size_of_xsave_aread : 32;
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT                            0
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK                           0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD(_)                             (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Used for XCR0.
             */
            uint32_t used_for_xcr0_1 : 8;
#define CPUID_ECX_USED_FOR_XCR0_1_BIT                                0
#define CPUID_ECX_USED_FOR_XCR0_1_FLAG                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1_MASK                               0xFF
#define CPUID_ECX_USED_FOR_XCR0_1(_)                                 (((_) >> 0) & 0xFF)

            /**
             * [Bit 8] PT state.
             */
            uint32_t pt_state : 1;
#define CPUID_ECX_PT_STATE_BIT                                       8
#define CPUID_ECX_PT_STATE_FLAG                                      0x100
#define CPUID_ECX_PT_STATE_MASK                                      0x01
#define CPUID_ECX_PT_STATE(_)                                        (((_) >> 8) & 0x01)

            /**
             * [Bit 9] Used for XCR0.
             */
            uint32_t used_for_xcr0_2 : 1;
#define CPUID_ECX_USED_FOR_XCR0_2_BIT                                9
#define CPUID_ECX_USED_FOR_XCR0_2_FLAG                               0x200
#define CPUID_ECX_USED_FOR_XCR0_2_MASK                               0x01
#define CPUID_ECX_USED_FOR_XCR0_2(_)                                 (((_) >> 9) & 0x01)
            uint32_t reserved1 : 1;

            /**
             * [Bit 11] CET user state.
             */
            uint32_t cet_user_state : 1;
#define CPUID_ECX_CET_USER_STATE_BIT                                 11
#define CPUID_ECX_CET_USER_STATE_FLAG                                0x800
#define CPUID_ECX_CET_USER_STATE_MASK                                0x01
#define CPUID_ECX_CET_USER_STATE(_)                                  (((_) >> 11) & 0x01)

            /**
             * [Bit 12] CET supervisor state.
             */
            uint32_t cet_supervisor_state : 1;
#define CPUID_ECX_CET_SUPERVISOR_STATE_BIT                           12
#define CPUID_ECX_CET_SUPERVISOR_STATE_FLAG                          0x1000
#define CPUID_ECX_CET_SUPERVISOR_STATE_MASK                          0x01
#define CPUID_ECX_CET_SUPERVISOR_STATE(_)                            (((_) >> 12) & 0x01)

            /**
             * [Bit 13] HDC state.
             */
            uint32_t hdc_state : 1;
#define CPUID_ECX_HDC_STATE_BIT                                      13
#define CPUID_ECX_HDC_STATE_FLAG                                     0x2000
#define CPUID_ECX_HDC_STATE_MASK                                     0x01
#define CPUID_ECX_HDC_STATE(_)                                       (((_) >> 13) & 0x01)
            uint32_t reserved2 : 1;

            /**
             * [Bit 15] LBR state.
             */
            uint32_t lbr_state : 1;
#define CPUID_ECX_LBR_STATE_BIT                                      15
#define CPUID_ECX_LBR_STATE_FLAG                                     0x8000
#define CPUID_ECX_LBR_STATE_MASK                                     0x01
#define CPUID_ECX_LBR_STATE(_)                                       (((_) >> 15) & 0x01)

            /**
             * [Bit 16] HWP state.
             */
            uint32_t hwp_state : 1;
#define CPUID_ECX_HWP_STATE_BIT                                      16
#define CPUID_ECX_HWP_STATE_FLAG                                     0x10000
#define CPUID_ECX_HWP_STATE_MASK                                     0x01
#define CPUID_ECX_HWP_STATE(_)                                       (((_) >> 16) & 0x01)
            uint32_t reserved3 : 15;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the supported bits of the upper 32 bits of the IA32_XSS MSR. IA32_XSS[n+32] can be set to 1 only if
             * EDX[n] is 1
             */
            uint32_t supported_upper_ia32_xss_bits : 32;
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_BIT                  0
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_FLAG                 0xFFFFFFFF
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_MASK                 0xFFFFFFFF
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS(_)                   (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0d_ecx_01;

/**
 * @brief Processor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)
 *
 * @note Leaf 0DH output depends on the initial value in ECX. Each sub-leaf index (starting at position 2) is supported if
 *       it corresponds to a supported bit in either the XCR0 register or the IA32_XSS MSR.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 <= n <= 31) is invalid if sub-leaf 0
 *       returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 <= n <= 63) is invalid if sub-leaf 0 returns 0 in
 *       EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the save area for an extended state feature
             * associated with a valid sub-leaf index, n.
             */
            uint32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] The offset in bytes of this extended state component's save area from the beginning of the XSAVE/XRSTOR
             * area.
             * This field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Is set if the bit n (corresponding to the sub-leaf index) is supported in the IA32_XSS MSR; it is clear if bit n
             * is instead supported in XCR0.
             */
            uint32_t ecx_2 : 1;
#define CPUID_ECX_ECX_2_BIT                                          0
#define CPUID_ECX_ECX_2_FLAG                                         0x01
#define CPUID_ECX_ECX_2_MASK                                         0x01
#define CPUID_ECX_ECX_2(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Is set if, when the compacted format of an XSAVE area is used, this extended state component located on the next
             * 64-byte boundary following the preceding state component (otherwise, it is located immediately following the preceding
             * state component).
             */
            uint32_t ecx_1 : 1;
#define CPUID_ECX_ECX_1_BIT                                          1
#define CPUID_ECX_ECX_1_FLAG                                         0x02
#define CPUID_ECX_ECX_1_MASK                                         0x01
#define CPUID_ECX_ECX_1(_)                                           (((_) >> 1) & 0x01)
            uint32_t reserved1 : 30;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] This field reports 0 if the sub-leaf index, n, is invalid; otherwise it is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0d_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_0f \
  *           EAX = 0x0F
  *
  * When CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS monitoring resource types that are supported in the processor and maximum range of RMID values the
  * processor can use to monitor of any supported resource types. Each bit, starting from bit 1, corresponds to a specific
  * resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID) that software must use to
  * query QoS monitoring capability available for that type. See Table 3-8.
  * When CPUID executes with EAX set to 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * software can use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR MSR.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION 0x0000000F
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)
   *
   * @note Leaf 0FH output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource type starting at bit
   *       position 1 of EDX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            uint32_t rmid_max_range : 32;
#define CPUID_EBX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_EBX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            uint32_t reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Intel RDT Monitoring if 1.
             */
            uint32_t supports_l3_cache_intel_rdt_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_)          (((_) >> 1) & 0x01)
            uint32_t reserved2 : 30;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0f_ecx_00;

/**
 * @brief L3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)
 *
 * @note Leaf 0FH output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).
             */
            uint32_t conversion_factor : 32;
#define CPUID_EBX_CONVERSION_FACTOR_BIT                              0
#define CPUID_EBX_CONVERSION_FACTOR_FLAG                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR_MASK                             0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum range (zero-based) of RMID within this physical processor of all types.
             */
            uint32_t rmid_max_range : 32;
#define CPUID_ECX_RMID_MAX_RANGE_BIT                                 0
#define CPUID_ECX_RMID_MAX_RANGE_FLAG                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE_MASK                                0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bit 0] Supports L3 occupancy monitoring if 1.
             */
            uint32_t supports_l3_occupancy_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT               0
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK              0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_)                (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Supports L3 Total Bandwidth monitoring if 1.
             */
            uint32_t supports_l3_total_bandwidth_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT         1
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG        0x02
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_)          (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L3 Local Bandwidth monitoring if 1.
             */
            uint32_t supports_l3_local_bandwidth_monitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT         2
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG        0x04
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK        0x01
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_)          (((_) >> 2) & 0x01)
            uint32_t reserved1 : 29;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_0f_ecx_01;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_10 \
  *           EAX = 0x10
  *
  * When CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the bit-vector
  * representation of QoS Enforcement resource types that are supported in the processor. Each bit, starting from bit 1,
  * corresponds to a specific resource type if the bit is set. The bit position corresponds to the sub-leaf index (or ResID)
  * that software must use to query QoS enforcement capability available for that type.
  * When CPUID executes with EAX set to 10H and ECX = n (n >= 1, and is a valid ResID), the processor returns information
  * about available classes of service and range of QoS mask MSRs that software can use to configure each class of services
  * using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.
  * @{
  */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION 0x00000010
  /**
   * @brief Intel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H, ECX = 0)
   *
   * @note Leaf 10H output depends on the initial value in ECX. Sub-leaf index 0 reports valid resource identification
   *       (ResID) starting at bit position 1 of EBX.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H).
             */
            uint32_t ia32_platform_dca_cap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT                          0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK                         0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)                           (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            uint32_t reserved1 : 1;

            /**
             * [Bit 1] Supports L3 Cache Allocation Technology if 1.
             */
            uint32_t supports_l3_cache_allocation_technology : 1;
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT        1
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x02
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 1) & 0x01)

            /**
             * [Bit 2] Supports L2 Cache Allocation Technology if 1.
             */
            uint32_t supports_l2_cache_allocation_technology : 1;
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT        2
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG       0x04
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK       0x01
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_)         (((_) >> 2) & 0x01)

            /**
             * [Bit 3] Supports Memory Bandwidth Allocation if 1.
             */
            uint32_t supports_memory_bandwidth_allocation : 1;
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT           3
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG          0x08
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK          0x01
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_)            (((_) >> 3) & 0x01)
            uint32_t reserved2 : 28;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_00;

/**
 * @brief L3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 1)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            uint32_t length_of_capacity_bit_mask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            uint32_t reserved1 : 27;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            uint32_t ebx_0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            uint32_t reserved1 : 2;

            /**
             * [Bit 2] Code and Data Prioritization Technology supported if 1.
             */
            uint32_t code_and_data_priorization_technology_supported : 1;
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT 2
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG 0x04
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK 0x01
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_) (((_) >> 2) & 0x01)
            uint32_t reserved2 : 29;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            uint32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_01;

/**
 * @brief L2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 2)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID using minus-one notation.
             */
            uint32_t length_of_capacity_bit_mask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT                    0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK                   0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)                     (((_) >> 0) & 0x1F)
            uint32_t reserved1 : 27;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
             */
            uint32_t ebx_0 : 32;
#define CPUID_EBX_EBX_0_BIT                                          0
#define CPUID_EBX_EBX_0_FLAG                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK                                         0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)                                           (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            uint32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_02;

/**
 * @brief Memory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 3)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 11:0] Reports the maximum MBA throttling value supported for the corresponding ResID using minus-one notation.
             */
            uint32_t max_mba_throttling_value : 12;
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT                       0
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK                      0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_)                        (((_) >> 0) & 0xFFF)
            uint32_t reserved1 : 20;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            uint32_t reserved1 : 2;

            /**
             * [Bit 2] Reports whether the response of the delay values is linear.
             */
            uint32_t response_of_delay_is_linear : 1;
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT                    2
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG                   0x04
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK                   0x01
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_)                     (((_) >> 2) & 0x01)
            uint32_t reserved2 : 29;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Highest COS number supported for this ResID.
             */
            uint32_t highest_cos_number_supported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT                   0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK                  0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)                    (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_10_ecx_03;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_12 \
  *           EAX = 0x12
  *
  * When CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about Intel SGX capabilities.
  * When CPUID executes with EAX set to 12H and ECX = 1H, the processor returns information about Intel SGX attributes.
  * When CPUID executes with EAX set to 12H and ECX = n (n > 1), the processor returns information about Intel SGX Enclave
  * Page Cache.
  * @{
  */
#define CPUID_INTEL_SGX                                              0x00000012
  /**
   * @brief Intel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)
   *
   * @note Leaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf functions.
             */
            uint32_t sgx1 : 1;
#define CPUID_EAX_SGX1_BIT                                           0
#define CPUID_EAX_SGX1_FLAG                                          0x01
#define CPUID_EAX_SGX1_MASK                                          0x01
#define CPUID_EAX_SGX1(_)                                            (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf functions.
             */
            uint32_t sgx2 : 1;
#define CPUID_EAX_SGX2_BIT                                           1
#define CPUID_EAX_SGX2_FLAG                                          0x02
#define CPUID_EAX_SGX2_MASK                                          0x01
#define CPUID_EAX_SGX2(_)                                            (((_) >> 1) & 0x01)
            uint32_t reserved1 : 3;

            /**
             * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.
             */
            uint32_t sgx_enclv_advanced : 1;
#define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT                             5
#define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG                            0x20
#define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLV_ADVANCED(_)                              (((_) >> 5) & 0x01)

            /**
             * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, and ELDUC.
             */
            uint32_t sgx_encls_advanced : 1;
#define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT                             6
#define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG                            0x40
#define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK                            0x01
#define CPUID_EAX_SGX_ENCLS_ADVANCED(_)                              (((_) >> 6) & 0x01)
            uint32_t reserved2 : 25;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Bit vector of supported extended SGX features.
             */
            uint32_t miscselect : 32;
#define CPUID_EBX_MISCSELECT_BIT                                     0
#define CPUID_EBX_MISCSELECT_FLAG                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT_MASK                                    0xFFFFFFFF
#define CPUID_EBX_MISCSELECT(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] The maximum supported enclave size in non-64-bit mode is 2^(EDX[7:0]).
             */
            uint32_t max_enclave_size_not64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT                         0
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK                        0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_)                          (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] The maximum supported enclave size in 64-bit mode is 2^(EDX[15:8]).
             */
            uint32_t max_enclave_size_64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT                            8
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG                           0xFF00
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK                           0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64(_)                             (((_) >> 8) & 0xFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_00;

/**
 * @brief Intel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)
 *
 * @note Leaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[31:0] that software can set with ECREATE.
             */
            uint32_t valid_secs_attributes_0 : 32;
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT                        0
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK                       0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[63:32] that software can set with ECREATE.
             */
            uint32_t valid_secs_attributes_1 : 32;
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT                        0
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK                       0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[95:64] that software can set with ECREATE.
             */
            uint32_t valid_secs_attributes_2 : 32;
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT                        0
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK                       0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[127:96] that software can set with ECREATE.
             */
            uint32_t valid_secs_attributes_3 : 32;
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT                        0
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK                       0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_01;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 0.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 0. Indicates this sub-leaf is invalid.
             */
            uint32_t sub_leaf_type : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            uint32_t reserved1 : 28;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is zero.
             */
            uint32_t zero : 32;
#define CPUID_EBX_ZERO_BIT                                           0
#define CPUID_EBX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EBX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EBX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is zero.
             */
            uint32_t zero : 32;
#define CPUID_ECX_ZERO_BIT                                           0
#define CPUID_ECX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_ECX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_ECX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is zero.
             */
            uint32_t zero : 32;
#define CPUID_EDX_ZERO_BIT                                           0
#define CPUID_EDX_ZERO_FLAG                                          0xFFFFFFFF
#define CPUID_EDX_ZERO_MASK                                          0xFFFFFFFF
#define CPUID_EDX_ZERO(_)                                            (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_0;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 *       This structure describes sub-leaf type 1.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 3:0] Sub-leaf Type 1. This sub-leaf enumerates an EPC section. EBX:EAX and EDX:ECX provide information on the
             * Enclave Page Cache (EPC) section.
             */
            uint32_t sub_leaf_type : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT                                  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK                                 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)                                   (((_) >> 0) & 0x0F)
            uint32_t reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC section.
             */
            uint32_t epc_base_physical_address_1 : 20;
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT                    12
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG                   0xFFFFF000
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK                   0xFFFFF
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_)                     (((_) >> 12) & 0xFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the physical address of the base of the EPC section.
             */
            uint32_t epc_base_physical_address_2 : 20;
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT                    0
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK                   0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_)                     (((_) >> 0) & 0xFFFFF)
            uint32_t reserved1 : 12;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 3:0] EPC section property encoding defined as follows:
             * - If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as 0.
             * - If EAX[3:0] 0001b, then this section has confidentiality and integrity protection.
             * All other encodings are reserved.
             */
            uint32_t epc_section_property : 4;
#define CPUID_ECX_EPC_SECTION_PROPERTY_BIT                           0
#define CPUID_ECX_EPC_SECTION_PROPERTY_FLAG                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY_MASK                          0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY(_)                            (((_) >> 0) & 0x0F)
            uint32_t reserved1 : 8;

            /**
             * [Bits 31:12] Bits 31:12 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            uint32_t epc_size_1 : 20;
#define CPUID_ECX_EPC_SIZE_1_BIT                                     12
#define CPUID_ECX_EPC_SIZE_1_FLAG                                    0xFFFFF000
#define CPUID_ECX_EPC_SIZE_1_MASK                                    0xFFFFF
#define CPUID_ECX_EPC_SIZE_1(_)                                      (((_) >> 12) & 0xFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 19:0] Bits 51:32 of the size of the corresponding EPC section within the Processor Reserved Memory.
             */
            uint32_t epc_size_2 : 20;
#define CPUID_EDX_EPC_SIZE_2_BIT                                     0
#define CPUID_EDX_EPC_SIZE_2_FLAG                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2_MASK                                    0xFFFFF
#define CPUID_EDX_EPC_SIZE_2(_)                                      (((_) >> 0) & 0xFFFFF)
            uint32_t reserved1 : 12;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_1;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_14 \
  *           EAX = 0x14
  *
  * When CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about Intel Processor Trace
  * extensions.
  * When CPUID executes with EAX set to 14H and ECX = n (n > 0 and less than the number of non-zero bits in CPUID.(EAX=14H,
  * ECX= 0H).EAX), the processor returns information about packet generation in Intel Processor Trace.
  * @{
  */
#define CPUID_INTEL_PROCESSOR_TRACE_INFORMATION                      0x00000014
  /**
   * @brief Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)
   *
   * @note Leaf 14H main leaf (ECX = 0).
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
             */
            uint32_t max_sub_leaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_MATCH MSR can be accessed.
             */
            uint32_t flag0 : 1;
#define CPUID_EBX_FLAG0_BIT                                          0
#define CPUID_EBX_FLAG0_FLAG                                         0x01
#define CPUID_EBX_FLAG0_MASK                                         0x01
#define CPUID_EBX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, indicates support of Configurable PSB and Cycle-Accurate Mode.
             */
            uint32_t flag1 : 1;
#define CPUID_EBX_FLAG1_BIT                                          1
#define CPUID_EBX_FLAG1_FLAG                                         0x02
#define CPUID_EBX_FLAG1_MASK                                         0x01
#define CPUID_EBX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of IP Filtering, TraceStop filtering, and preservation of Intel PT MSRs across warm
             * reset.
             */
            uint32_t flag2 : 1;
#define CPUID_EBX_FLAG2_BIT                                          2
#define CPUID_EBX_FLAG2_FLAG                                         0x04
#define CPUID_EBX_FLAG2_MASK                                         0x01
#define CPUID_EBX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of MTC timing packet and suppression of COFI-based packets.
             */
            uint32_t flag3 : 1;
#define CPUID_EBX_FLAG3_BIT                                          3
#define CPUID_EBX_FLAG3_FLAG                                         0x08
#define CPUID_EBX_FLAG3_MASK                                         0x01
#define CPUID_EBX_FLAG3(_)                                           (((_) >> 3) & 0x01)

            /**
             * [Bit 4] If 1, indicates support of PTWRITE. Writes can set IA32_RTIT_CTL[12] (PTWEn) and IA32_RTIT_CTL[5] (FUPonPTW),
             * and PTWRITE can generate packets.
             */
            uint32_t flag4 : 1;
#define CPUID_EBX_FLAG4_BIT                                          4
#define CPUID_EBX_FLAG4_FLAG                                         0x10
#define CPUID_EBX_FLAG4_MASK                                         0x01
#define CPUID_EBX_FLAG4(_)                                           (((_) >> 4) & 0x01)

            /**
             * [Bit 5] If 1, indicates support of Power Event Trace. Writes can set IA32_RTIT_CTL[4] (PwrEvtEn), enabling Power Event
             * Trace packet generation.
             */
            uint32_t flag5 : 1;
#define CPUID_EBX_FLAG5_BIT                                          5
#define CPUID_EBX_FLAG5_FLAG                                         0x20
#define CPUID_EBX_FLAG5_MASK                                         0x01
#define CPUID_EBX_FLAG5(_)                                           (((_) >> 5) & 0x01)

            /**
             * [Bit 6] If 1, indicates support for PSB and PH preservation. Writes can set IA32_RTIT CTL[56] (InjectPsb-PmiOnEnable),
             * enabling the processor to setIA32_12TIT STATUS[7] (PendTopaPMI) and/or IA32_RTIT_STATUS[6] (PendPSB) in order to
             * preserve ToPA PMIs and/or PSBs otherwise lost due to Intel PT disable. Writes can also set PendToPAPMI and PendPSB.
             */
            uint32_t flag6 : 1;
#define CPUID_EBX_FLAG6_BIT                                          6
#define CPUID_EBX_FLAG6_FLAG                                         0x40
#define CPUID_EBX_FLAG6_MASK                                         0x01
#define CPUID_EBX_FLAG6(_)                                           (((_) >> 6) & 0x01)

            /**
             * [Bit 7] If 1, writes can set IA32_RTIT_CTL[31] (EventEn), enabling Event Trace packet generation.
             */
            uint32_t flag7 : 1;
#define CPUID_EBX_FLAG7_BIT                                          7
#define CPUID_EBX_FLAG7_FLAG                                         0x80
#define CPUID_EBX_FLAG7_MASK                                         0x01
#define CPUID_EBX_FLAG7(_)                                           (((_) >> 7) & 0x01)

            /**
             * [Bit 8] If 1, writes can set IA32_RTIT_CTL[55] (DisTNT), disabling TNT packet generation.
             */
            uint32_t flag8 : 1;
#define CPUID_EBX_FLAG8_BIT                                          8
#define CPUID_EBX_FLAG8_FLAG                                         0x100
#define CPUID_EBX_FLAG8_MASK                                         0x01
#define CPUID_EBX_FLAG8(_)                                           (((_) >> 8) & 0x01)
            uint32_t reserved1 : 23;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme;
             * IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.
             */
            uint32_t flag0 : 1;
#define CPUID_ECX_FLAG0_BIT                                          0
#define CPUID_ECX_FLAG0_FLAG                                         0x01
#define CPUID_ECX_FLAG0_MASK                                         0x01
#define CPUID_ECX_FLAG0(_)                                           (((_) >> 0) & 0x01)

            /**
             * [Bit 1] If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the MaskOrTableOffset
             * field of IA32_RTIT_OUTPUT_MASK_PTRS.
             */
            uint32_t flag1 : 1;
#define CPUID_ECX_FLAG1_BIT                                          1
#define CPUID_ECX_FLAG1_FLAG                                         0x02
#define CPUID_ECX_FLAG1_MASK                                         0x01
#define CPUID_ECX_FLAG1(_)                                           (((_) >> 1) & 0x01)

            /**
             * [Bit 2] If 1, indicates support of Single-Range Output scheme.
             */
            uint32_t flag2 : 1;
#define CPUID_ECX_FLAG2_BIT                                          2
#define CPUID_ECX_FLAG2_FLAG                                         0x04
#define CPUID_ECX_FLAG2_MASK                                         0x01
#define CPUID_ECX_FLAG2(_)                                           (((_) >> 2) & 0x01)

            /**
             * [Bit 3] If 1, indicates support of output to Trace Transport subsystem.
             */
            uint32_t flag3 : 1;
#define CPUID_ECX_FLAG3_BIT                                          3
#define CPUID_ECX_FLAG3_FLAG                                         0x08
#define CPUID_ECX_FLAG3_MASK                                         0x01
#define CPUID_ECX_FLAG3(_)                                           (((_) >> 3) & 0x01)
            uint32_t reserved1 : 27;

            /**
             * [Bit 31] If 1, generated packets which contain IP payloads have LIP values, which include the CS base component.
             */
            uint32_t flag31 : 1;
#define CPUID_ECX_FLAG31_BIT                                         31
#define CPUID_ECX_FLAG31_FLAG                                        0x80000000
#define CPUID_ECX_FLAG31_MASK                                        0x01
#define CPUID_ECX_FLAG31(_)                                          (((_) >> 31) & 0x01)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_14_ecx_00;

/**
 * @brief Intel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 2:0] Number of configurable Address Ranges for filtering.
             */
            uint32_t number_of_configurable_address_ranges_for_filtering : 3;
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT 0
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_) (((_) >> 0) & 0x07)
            uint32_t reserved1 : 13;

            /**
             * [Bits 31:16] Bitmap of supported MTC period encodings.
             */
            uint32_t bitmap_of_supported_mtc_period_encodings : 16;
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT       16
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG      0xFFFF0000
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK      0xFFFF
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_)        (((_) >> 16) & 0xFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bitmap of supported Cycle Threshold value encodings.
             */
            uint32_t bitmap_of_supported_cycle_threshold_value_encodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT 0
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_) (((_) >> 0) & 0xFFFF)

            /**
             * [Bits 31:16] Bitmap of supported Configurable PSB frequency encodings.
             */
            uint32_t bitmap_of_supported_configurable_psb_frequency_encodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT 16
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_) (((_) >> 16) & 0xFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_14_ecx_01;

/**
 * @}
 */


 /**
  * @brief Stamp Counter and Nominal Core Crystal Clock Information Leaf
  *
  * When CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about Time Stamp Counter and
  * Core Crystal Clock.
  *
  * @note If EBX[31:0] is 0, the TSC/"core crystal clock" ratio is not enumerated. EBX[31:0]/EAX[31:0] indicates the ratio
  *       of the TSC frequency and the core crystal clock frequency.
  *       If ECX is 0, the nominal core crystal clock frequency is not enumerated. "TSC frequency" = "core crystal clock
  *       frequency" * EBX/EAX.
  */
#define CPUID_TIME_STAMP_COUNTER_INFORMATION                         0x00000015
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the denominator of the TSC/"core crystal clock" ratio.
             */
            uint32_t denominator : 32;
#define CPUID_EAX_DENOMINATOR_BIT                                    0
#define CPUID_EAX_DENOMINATOR_FLAG                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR_MASK                                   0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the numerator of the TSC/"core crystal clock" ratio.
             */
            uint32_t numerator : 32;
#define CPUID_EBX_NUMERATOR_BIT                                      0
#define CPUID_EBX_NUMERATOR_FLAG                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR_MASK                                     0xFFFFFFFF
#define CPUID_EBX_NUMERATOR(_)                                       (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] An unsigned integer which is the nominal frequency of the core crystal clock in Hz.
             */
            uint32_t nominal_frequency : 32;
#define CPUID_ECX_NOMINAL_FREQUENCY_BIT                              0
#define CPUID_ECX_NOMINAL_FREQUENCY_FLAG                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY_MASK                             0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY(_)                               (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_15;


/**
 * @brief Processor Frequency Information Leaf
 *
 * When CPUID executes with EAX set to 16H, the processor returns information about Processor Frequency Information.
 *
 * @note Data is returned from this interface in accordance with the processor's specification and does not reflect actual
 *       values. Suitable use of this data includes the display of processor information in like manner to the processor brand
 *       string and for determining the appropriate range to use when displaying processor information e.g. frequency history
 *       graphs. The returned information should not be used for any other purpose as the returned information does not
 *       accurately correlate to information / counters returned by other processor interfaces.
 *       While a processor may support the Processor Frequency Information leaf, fields that return a value of zero are not
 *       supported.
 */
#define CPUID_PROCESSOR_FREQUENCY_INFORMATION                        0x00000016
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 15:0] Processor Base Frequency (in MHz).
             */
            uint32_t procesor_base_frequency_mhz : 16;
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT                    0
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK                   0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_)                     (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Maximum Frequency (in MHz).
             */
            uint32_t processor_maximum_frequency_mhz : 16;
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT                0
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK               0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_)                 (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] Bus (Reference) Frequency (in MHz).
             */
            uint32_t bus_frequency_mhz : 16;
#define CPUID_ECX_BUS_FREQUENCY_MHZ_BIT                              0
#define CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ_MASK                             0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ(_)                               (((_) >> 0) & 0xFFFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_16;

/**
 * @defgroup cpuid_eax_17 \
 *           EAX = 0x17
 *
 * When CPUID executes with EAX set to 17H, the processor returns information about the System-On-Chip Vendor Attribute
 * Enumeration.
 * @{
 */
#define CPUID_SOC_VENDOR_INFORMATION                                 0x00000017
 /**
  * @brief System-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)
  *
  * @note Leaf 17H main leaf (ECX = 0). Leaf 17H output depends on the initial value in ECX. Leaf 17H sub-leaves 1 through 3
  *       reports SOC Vendor Brand String. Leaf 17H is valid if MaxSOCID_Index >= 3. Leaf 17H sub-leaves 4 and above are reserved.
  */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 17H.
             */
            uint32_t max_soc_id_index : 32;
#define CPUID_EAX_MAX_SOC_ID_INDEX_BIT                               0
#define CPUID_EAX_MAX_SOC_ID_INDEX_FLAG                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX_MASK                              0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX(_)                                (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 15:0] SOC Vendor ID.
             */
            uint32_t soc_vendor_id : 16;
#define CPUID_EBX_SOC_VENDOR_ID_BIT                                  0
#define CPUID_EBX_SOC_VENDOR_ID_FLAG                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID_MASK                                 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID(_)                                   (((_) >> 0) & 0xFFFF)

            /**
             * [Bit 16] If 1, the SOC Vendor ID field is assigned via an industry standard enumeration scheme. Otherwise, the SOC
             * Vendor ID field is assigned by Intel.
             */
            uint32_t is_vendor_scheme : 1;
#define CPUID_EBX_IS_VENDOR_SCHEME_BIT                               16
#define CPUID_EBX_IS_VENDOR_SCHEME_FLAG                              0x10000
#define CPUID_EBX_IS_VENDOR_SCHEME_MASK                              0x01
#define CPUID_EBX_IS_VENDOR_SCHEME(_)                                (((_) >> 16) & 0x01)
            uint32_t reserved1 : 15;
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number an SOC vendor assigns to its SOC projects.
             */
            uint32_t project_id : 32;
#define CPUID_ECX_PROJECT_ID_BIT                                     0
#define CPUID_ECX_PROJECT_ID_FLAG                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID_MASK                                    0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID(_)                                      (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] A unique number within an SOC project that an SOC vendor assigns.
             */
            uint32_t stepping_id : 32;
#define CPUID_EDX_STEPPING_ID_BIT                                    0
#define CPUID_EDX_STEPPING_ID_FLAG                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID_MASK                                   0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID(_)                                     (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_17_ecx_00;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)
 *
 * @note Leaf 17H output depends on the initial value in ECX. SOC Vendor Brand String is a UTF-8 encoded string padded with
 *       trailing bytes of 00H. The complete SOC Vendor Brand String is constructed by concatenating in ascending order of
 *       EAX:EBX:ECX:EDX and from the sub-leaf 1 fragment towards sub-leaf 3.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            uint32_t soc_vendor_brand_string : 32;
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            uint32_t soc_vendor_brand_string : 32;
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            uint32_t soc_vendor_brand_string : 32;
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
             */
            uint32_t soc_vendor_brand_string : 32;
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT                        0
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK                       0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING(_)                         (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_17_ecx_01_03;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)
 *
 * @note Leaf 17H output depends on the initial value in ECX.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reserved = 0.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_17_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_18 \
  *           EAX = 0x18
  *
  * When CPUID executes with EAX set to 18H, the processor returns information about the Deterministic Address Translation
  * Parameters.
  * @{
  */
#define CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS           0x00000018
  /**
   * @brief Deterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)
   *
   * @note Each sub-leaf enumerates a different address translation structure.
   *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
   *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
   *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
   *       or than a valid sub-leaf of a higher or lower-level structure.
   */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf 18H.
             */
            uint32_t max_sub_leaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT                                   0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK                                  0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)                                    (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            uint32_t page_entries_4kb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            uint32_t page_entries_2mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            uint32_t page_entries_4mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            uint32_t page_entries_1gb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            uint32_t reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            uint32_t partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            uint32_t reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            uint32_t ways_of_associativity_00 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_)                        (((_) >> 16) & 0xFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            uint32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            uint32_t translation_cache_type_field : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            uint32_t translation_cache_level : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            uint32_t fully_associative_structure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            uint32_t reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            uint32_t max_addressable_ids_for_logical_processors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            uint32_t reserved2 : 6;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_18_ecx_00;

/**
 * @brief Deterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX >= 1)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n exceeds the value
 *       that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid if EDX[4:0] returns 0. Valid sub-leaves do not need to
 *       be contiguous or in any particular order. A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf
 *       or than a valid sub-leaf of a higher or lower-level structure.
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bit 0] 4K page size entries supported by this structure.
             */
            uint32_t page_entries_4kb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT                     0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)                      (((_) >> 0) & 0x01)

            /**
             * [Bit 1] 2MB page size entries supported by this structure.
             */
            uint32_t page_entries_2mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT                     1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG                    0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bit 2] 4MB page size entries supported by this structure.
             */
            uint32_t page_entries_4mb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT                     2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG                    0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)                      (((_) >> 2) & 0x01)

            /**
             * [Bit 3] 1 GB page size entries supported by this structure.
             */
            uint32_t page_entries_1gb_supported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT                     3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG                    0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK                    0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)                      (((_) >> 3) & 0x01)
            uint32_t reserved1 : 4;

            /**
             * [Bits 10:8] Partitioning (0: Soft partitioning between the logical processors sharing this structure).
             */
            uint32_t partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT                                   8
#define CPUID_EBX_PARTITIONING_FLAG                                  0x700
#define CPUID_EBX_PARTITIONING_MASK                                  0x07
#define CPUID_EBX_PARTITIONING(_)                                    (((_) >> 8) & 0x07)
            uint32_t reserved2 : 5;

            /**
             * [Bits 31:16] W = Ways of associativity.
             */
            uint32_t ways_of_associativity_01 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT                       16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG                      0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK                      0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_)                        (((_) >> 16) & 0xFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Number of Sets.
             */
            uint32_t number_of_sets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT                                 0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK                                0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)                                  (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 4:0] Translation cache type field.
             * - 00000b: Null (indicates this sub-leaf is not valid).
             * - 00001b: Data TLB.
             * - 00010b: Instruction TLB.
             * - 00011b: Unified TLB.
             * All other encodings are reserved.
             *
             * @note Some unified TLBs will allow a single TLB entry to satisfy data read/write and instruction fetches. Others will
             *       require separate entries (e.g., one loaded on data read/write and another loaded on an instruction fetch) . Please see
             *       the Intel(R) 64 and IA-32 Architectures Optimization Reference Manual for details of a particular product.
             */
            uint32_t translation_cache_type_field : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT                   0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK                  0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)                    (((_) >> 0) & 0x1F)

            /**
             * [Bits 7:5] Translation cache level (starts at 1).
             */
            uint32_t translation_cache_level : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT                        5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG                       0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK                       0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)                         (((_) >> 5) & 0x07)

            /**
             * [Bit 8] Fully associative structure.
             */
            uint32_t fully_associative_structure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT                    8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG                   0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK                   0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)                     (((_) >> 8) & 0x01)
            uint32_t reserved1 : 5;

            /**
             * [Bits 25:14] Maximum number of addressable IDs for logical processors sharing this translation cache.
             *
             * @note Add one to the return value to get the result.
             */
            uint32_t max_addressable_ids_for_logical_processors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT     14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG    0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK    0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)      (((_) >> 14) & 0xFFF)
            uint32_t reserved2 : 6;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_18_ecx_01p;

/**
 * @}
 */


 /**
  * @brief Extended Function CPUID Information
  *
  * When CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes for
  * returning extended processor information. The value is returned in the EAX register and is processor specific.
  */
#define CPUID_EXTENDED_FUNCTION_INFORMATION                          0x80000000
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Maximum Input Value for Extended Function CPUID Information.
             */
            uint32_t max_extended_functions : 32;
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT                         0
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK                        0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_)                          (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000000;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CPU_SIGNATURE                                 0x80000001
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bit 0] LAHF/SAHF available in 64-bit mode.
             */
            uint32_t lahf_sahf_available_in_64_bit_mode : 1;
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT             0
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK            0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_)              (((_) >> 0) & 0x01)
            uint32_t reserved1 : 4;

            /**
             * [Bit 5] LZCNT.
             */
            uint32_t lzcnt : 1;
#define CPUID_ECX_LZCNT_BIT                                          5
#define CPUID_ECX_LZCNT_FLAG                                         0x20
#define CPUID_ECX_LZCNT_MASK                                         0x01
#define CPUID_ECX_LZCNT(_)                                           (((_) >> 5) & 0x01)
            uint32_t reserved2 : 2;

            /**
             * [Bit 8] PREFETCHW.
             */
            uint32_t prefetchw : 1;
#define CPUID_ECX_PREFETCHW_BIT                                      8
#define CPUID_ECX_PREFETCHW_FLAG                                     0x100
#define CPUID_ECX_PREFETCHW_MASK                                     0x01
#define CPUID_ECX_PREFETCHW(_)                                       (((_) >> 8) & 0x01)
            uint32_t reserved3 : 23;
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            uint32_t reserved1 : 11;

            /**
             * [Bit 11] SYSCALL/SYSRET available in 64-bit mode.
             */
            uint32_t syscall_sysret_available_in_64_bit_mode : 1;
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT        11
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG       0x800
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK       0x01
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_)         (((_) >> 11) & 0x01)
            uint32_t reserved2 : 8;

            /**
             * [Bit 20] Execute Disable Bit available.
             */
            uint32_t execute_disable_bit_available : 1;
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT                  20
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG                 0x100000
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK                 0x01
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_)                   (((_) >> 20) & 0x01)
            uint32_t reserved3 : 5;

            /**
             * [Bit 26] 1-GByte pages are available if 1.
             */
            uint32_t pages_1gb_available : 1;
#define CPUID_EDX_PAGES_1GB_AVAILABLE_BIT                            26
#define CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG                           0x4000000
#define CPUID_EDX_PAGES_1GB_AVAILABLE_MASK                           0x01
#define CPUID_EDX_PAGES_1GB_AVAILABLE(_)                             (((_) >> 26) & 0x01)

            /**
             * [Bit 27] RDTSCP and IA32_TSC_AUX are available if 1.
             */
            uint32_t rdtscp_available : 1;
#define CPUID_EDX_RDTSCP_AVAILABLE_BIT                               27
#define CPUID_EDX_RDTSCP_AVAILABLE_FLAG                              0x8000000
#define CPUID_EDX_RDTSCP_AVAILABLE_MASK                              0x01
#define CPUID_EDX_RDTSCP_AVAILABLE(_)                                (((_) >> 27) & 0x01)
            uint32_t reserved4 : 1;

            /**
             * [Bit 29] Intel(R) 64 Architecture available if 1.
             */
            uint32_t ia64_available : 1;
#define CPUID_EDX_IA64_AVAILABLE_BIT                                 29
#define CPUID_EDX_IA64_AVAILABLE_FLAG                                0x20000000
#define CPUID_EDX_IA64_AVAILABLE_MASK                                0x01
#define CPUID_EDX_IA64_AVAILABLE(_)                                  (((_) >> 29) & 0x01)
            uint32_t reserved5 : 2;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000001;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING1                                          0x80000002

 /**
  * Extended Function CPUID Information.
  */
#define CPUID_BRAND_STRING2                                          0x80000003

  /**
   * Extended Function CPUID Information.
   */
#define CPUID_BRAND_STRING3                                          0x80000004
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String.
             */
            uint32_t processor_brand_string_1 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_2 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_3 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_4 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000002;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_5 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_6 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT                       0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK                      0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_7 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT                       0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK                      0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_8 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT                       0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK                      0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000003;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_9 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT                       0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK                      0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_)                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_10 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT                      0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK                     0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_11 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT                      0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK                     0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] Processor Brand String Continued.
             */
            uint32_t processor_brand_string_12 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT                      0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK                     0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12(_)                       (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000004;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000005;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CACHE_INFO                                    0x80000006
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 7:0] Cache Line size in bytes.
             */
            uint32_t cache_line_size_in_bytes : 8;
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_BIT                       0
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_FLAG                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_MASK                      0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES(_)                        (((_) >> 0) & 0xFF)
            uint32_t reserved1 : 4;

            /**
             * [Bits 15:12] L2 Associativity field.
             * L2 associativity field encodings:
             * - 00H - Disabled.
             * - 01H - Direct mapped.
             * - 02H - 2-way.
             * - 04H - 4-way.
             * - 06H - 8-way.
             * - 08H - 16-way.
             * - 0FH - Fully associative.
             */
            uint32_t l2_associativity_field : 4;
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT                         12
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG                        0xF000
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK                        0x0F
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_)                          (((_) >> 12) & 0x0F)

            /**
             * [Bits 31:16] Cache size in 1K units.
             */
            uint32_t cache_size_in_1k_units : 16;
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT                         16
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG                        0xFFFF0000
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK                        0xFFFF
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_)                          (((_) >> 16) & 0xFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000006;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_TIME_STAMP_COUNTER                            0x80000007
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bits 31:0] EAX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EAX_RESERVED_BIT                                       0
#define CPUID_EAX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            uint32_t reserved1 : 8;

            /**
             * [Bit 8] Invariant TSC available if 1.
             */
            uint32_t invariant_tsc_available : 1;
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT                        8
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG                       0x100
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK                       0x01
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE(_)                         (((_) >> 8) & 0x01)
            uint32_t reserved2 : 23;
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000007;


/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_VIRTUAL_PHYSICAL_ADDRESS_SIZE                 0x80000008
typedef struct
{
    /**
     * @brief Linear/Physical Address size
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Number of Physical Address Bits.
             */
            uint32_t number_of_physical_address_bits : 8;
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_BIT                0
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_FLAG               0xFF
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_MASK               0xFF
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS(_)                 (((_) >> 0) & 0xFF)

            /**
             * [Bits 15:8] Number of Linear Address Bits.
             */
            uint32_t number_of_linear_address_bits : 8;
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_BIT                  8
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_FLAG                 0xFF00
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_MASK                 0xFF
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS(_)                   (((_) >> 8) & 0xFF)
            uint32_t reserved1 : 16;
        };

        uint32_t flags;
    } eax;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EBX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EBX_RESERVED_BIT                                       0
#define CPUID_EBX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ebx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] ECX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_ECX_RESERVED_BIT                                       0
#define CPUID_ECX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } ecx;

    union
    {
        struct
        {
            /**
             * [Bits 31:0] EDX is reserved.
             */
            uint32_t reserved : 32;
#define CPUID_EDX_RESERVED_BIT                                       0
#define CPUID_EDX_RESERVED_FLAG                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK                                      0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)                                        (((_) >> 0) & 0xFFFFFFFF)
        };

        uint32_t flags;
    } edx;

} cpuid_eax_80000008;

/**
 * @}
 */

 /**
  * @defgroup model_specific_registers \
  *           Model Specific Registers
  *
  * @see Vol2A[3.2(CPUID)] (reference)
  * @{
  */
  /**
   * @defgroup ia32_p5_mc \
   *           IA32_P5_MC_(x)
   *
   * When machine-check exceptions are enabled for the Pentium processor (MCE flag is set in control register CR4), the
   * machine-check exception handler uses the RDMSR instruction to read the error type from the P5_MC_TYPE register and the
   * machine check address from the P5_MC_ADDR register. The handler then normally reports these register values to the
   * system console before aborting execution.
   *
   * @see Vol3B[15.10.2(Pentium Processor Machine-Check Exception Handling)] (reference)
   * @{
   */
   /**
    * Machine-check exception address.
    *
    * @remarks 05_01H
    * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
    */
#define IA32_P5_MC_ADDR                                              0x00000000

    /**
     * Machine-check exception type.
     *
     * @remarks 05_01H
     * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
     */
#define IA32_P5_MC_TYPE                                              0x00000001
     /**
      * @}
      */

      /**
       * System coherence line size.
       *
       * @remarks 0F_03H
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)]
       * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)] (reference)
       */
#define IA32_MONITOR_FILTER_LINE_SIZE                                0x00000006

       /**
        * Value as returned by instruction RDTSC.
        *
        * @remarks 05_01H
        * @see Vol3B[17.17(TIME-STAMP COUNTER)]
        */
#define IA32_TIME_STAMP_COUNTER                                      0x00000010

        /**
         * The operating system can use this MSR to determine "slot" information for the processor and the proper microcode update
         * to load.
         *
         * @remarks 06_01H
         */
#define IA32_PLATFORM_ID                                             0x00000017
typedef union
{
    struct
    {
        uint64_t reserved1 : 50;

        /**
         * @brief Platform Id <b>(RO)</b>
         *
         * [Bits 52:50] Contains information concerning the intended platform for the processor.
         *
         *
         * 52 | 51 | 50 | _
         * --:|:--:|:---|-----------------
         * 0  | 0  | 0  | Processor Flag 0
         * 0  | 0  | 1  | Processor Flag 1
         * 0  | 1  | 0  | Processor Flag 2
         * 0  | 1  | 1  | Processor Flag 3
         * 1  | 0  | 0  | Processor Flag 4
         * 1  | 0  | 1  | Processor Flag 5
         * 1  | 1  | 0  | Processor Flag 6
         * 1  | 1  | 1  | Processor Flag 7
         */
        uint64_t platform_id : 3;
#define IA32_PLATFORM_ID_PLATFORM_ID_BIT                             50
#define IA32_PLATFORM_ID_PLATFORM_ID_FLAG                            0x1C000000000000
#define IA32_PLATFORM_ID_PLATFORM_ID_MASK                            0x07
#define IA32_PLATFORM_ID_PLATFORM_ID(_)                              (((_) >> 50) & 0x07)
        uint64_t reserved2 : 11;
    };

    uint64_t flags;
} ia32_platform_id_register;


/**
 * This register holds the APIC base address, permitting the relocation of the APIC memory map.
 *
 * @remarks 06_01H
 * @see Vol3A[10.4.4(Local APIC Status and Location)]
 * @see Vol3A[10.4.5(Relocating the Local APIC Registers)]
 */
#define IA32_APIC_BASE                                               0x0000001B
typedef union
{
    struct
    {
        uint64_t reserved1 : 8;

        /**
         * [Bit 8] BSP flag.
         */
        uint64_t bsp_flag : 1;
#define IA32_APIC_BASE_BSP_FLAG_BIT                                  8
#define IA32_APIC_BASE_BSP_FLAG_FLAG                                 0x100
#define IA32_APIC_BASE_BSP_FLAG_MASK                                 0x01
#define IA32_APIC_BASE_BSP_FLAG(_)                                   (((_) >> 8) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bit 10] Enable x2APIC mode.
         */
        uint64_t enable_x2apic_mode : 1;
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT                        10
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG                       0x400
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK                       0x01
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE(_)                         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] APIC Global Enable.
         */
        uint64_t apic_global_enable : 1;
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT                        11
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG                       0x800
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK                       0x01
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_)                         (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] APIC Base.
         */
        uint64_t apic_base : 36;
#define IA32_APIC_BASE_APIC_BASE_BIT                                 12
#define IA32_APIC_BASE_APIC_BASE_FLAG                                0xFFFFFFFFF000
#define IA32_APIC_BASE_APIC_BASE_MASK                                0xFFFFFFFFF
#define IA32_APIC_BASE_APIC_BASE(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved3 : 16;
    };

    uint64_t flags;
} ia32_apic_base_register;


/**
 * Control Features in Intel 64 Processor.
 *
 * @remarks If any one enumeration condition for defined bit field holds.
 */
#define IA32_FEATURE_CONTROL                                         0x0000003A
typedef union
{
    struct
    {
        /**
         * @brief Lock bit <b>(R/WO)</b>
         *
         * [Bit 0] When set, locks this MSR from being written; writes to this bit will result in GP(0).
         *
         * @note Once the Lock bit is set, the contents of this register cannot be modified. Therefore the lock bit must be set
         *       after configuring support for Intel Virtualization Technology and prior to transferring control to an option ROM or the
         *       OS. Hence, once the Lock bit is set, the entire IA32_FEATURE_CONTROL contents are preserved across RESET when PWRGOOD is
         *       not deasserted.
         * @remarks If any one enumeration condition for defined bit field position greater than bit 0 holds.
         */
        uint64_t lock_bit : 1;
#define IA32_FEATURE_CONTROL_LOCK_BIT_BIT                            0
#define IA32_FEATURE_CONTROL_LOCK_BIT_FLAG                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT_MASK                           0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT(_)                             (((_) >> 0) & 0x01)

        /**
         * @brief Enable VMX inside SMX operation <b>(R/WL)</b>
         *
         * [Bit 1] This bit enables a system executive to use VMX in conjunction with SMX to support Intel(R) Trusted Execution
         * Technology. BIOS must set this bit only when the CPUID function 1 returns VMX feature flag and SMX feature flag set (ECX
         * bits 5 and 6 respectively).
         *
         * @remarks If CPUID.01H:ECX[5] = 1 && CPUID.01H:ECX[6] = 1
         */
        uint64_t enable_vmx_inside_smx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT               1
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG              0x02
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK              0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_)                (((_) >> 1) & 0x01)

        /**
         * @brief Enable VMX outside SMX operation <b>(R/WL)</b>
         *
         * [Bit 2] This bit enables VMX for a system executive that does not require SMX. BIOS must set this bit only when the
         * CPUID function 1 returns the VMX feature flag set (ECX bit 5).
         *
         * @remarks If CPUID.01H:ECX[5] = 1
         */
        uint64_t enable_vmx_outside_smx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT              2
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG             0x04
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK             0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_)               (((_) >> 2) & 0x01)
        uint64_t reserved1 : 5;

        /**
         * @brief SENTER Local Function Enable <b>(R/WL)</b>
         *
         * [Bits 14:8] When set, each bit in the field represents an enable control for a corresponding SENTER function. This field
         * is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        uint64_t senter_local_function_enables : 7;
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT       8
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG      0x7F00
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK      0x7F
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_)        (((_) >> 8) & 0x7F)

        /**
         * @brief SENTER Global Enable <b>(R/WL)</b>
         *
         * [Bit 15] This bit must be set to enable SENTER leaf functions. This bit is supported only if CPUID.1:ECX.[bit 6] is set.
         *
         * @remarks If CPUID.01H:ECX[6] = 1
         */
        uint64_t senter_global_enable : 1;
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT                15
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG               0x8000
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK               0x01
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_)                 (((_) >> 15) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief SGX Launch Control Enable <b>(R/WL)</b>
         *
         * [Bit 17] This bit must be set to enable runtime reconfiguration of SGX Launch Control via the IA32_SGXLEPUBKEYHASHn MSR.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): ECX[30] = 1
         */
        uint64_t sgx_launch_control_enable : 1;
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT           17
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG          0x20000
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK          0x01
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_)            (((_) >> 17) & 0x01)

        /**
         * @brief SGX Global Enable <b>(R/WL)</b>
         *
         * [Bit 18] This bit must be set to enable SGX leaf functions.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
         */
        uint64_t sgx_global_enable : 1;
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT                   18
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG                  0x40000
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK                  0x01
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_)                    (((_) >> 18) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * @brief LMCE On <b>(R/WL)</b>
         *
         * [Bit 20] When set, system software can program the MSRs associated with LMCE to configure delivery of some machine check
         * exceptions to a single logical processor.
         *
         * @remarks If IA32_MCG_CAP[27] = 1
         */
        uint64_t lmce_on : 1;
#define IA32_FEATURE_CONTROL_LMCE_ON_BIT                             20
#define IA32_FEATURE_CONTROL_LMCE_ON_FLAG                            0x100000
#define IA32_FEATURE_CONTROL_LMCE_ON_MASK                            0x01
#define IA32_FEATURE_CONTROL_LMCE_ON(_)                              (((_) >> 20) & 0x01)
        uint64_t reserved4 : 43;
    };

    uint64_t flags;
} ia32_feature_control_register;


/**
 * Per Logical Processor TSC Adjust.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[1] = 1
 */
#define IA32_TSC_ADJUST                                              0x0000003B
typedef struct
{
    /**
     * Local offset value of the IA32_TSC for a logical processor. Reset value is zero. A write to IA32_TSC will modify the
     * local offset in IA32_TSC_ADJUST and the content of IA32_TSC, but does not affect the internal invariant TSC hardware.
     */
    uint64_t thread_adjust;
} ia32_tsc_adjust_register;


/**
 * Speculation Control. The MSR bits are defined as logical processor scope. On some core implementations, the bits may
 * impact sibling logical processors on the same core. This MSR has a value of 0 after reset and is unaffected by INIT\# or
 * SIPI\#.
 *
 * @remarks If any one of the enumeration conditions for defined bit field positions holds.
 */
#define IA32_SPEC_CTRL                                               0x00000048
typedef union
{
    struct
    {
        /**
         * [Bit 0] IBRS: Indirect Branch Restricted Speculation (IBRS). Restricts speculation of indirect branch.
         *
         * @remarks If CPUID.(EAX=07H,ECX=0):EDX[26]=1
         */
        uint64_t ibrs : 1;
#define IA32_SPEC_CTRL_IBRS_BIT                                      0
#define IA32_SPEC_CTRL_IBRS_FLAG                                     0x01
#define IA32_SPEC_CTRL_IBRS_MASK                                     0x01
#define IA32_SPEC_CTRL_IBRS(_)                                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] STIBP: Single Thread Indirect Branch Predictors (STIBP). Prevents indirect branch predictions on all logical
         * processors on the core from being controlled by any sibling logical processor in the same core.
         *
         * @remarks If CPUID.(EAX=07H,ECX=0):EDX[27]=1
         */
        uint64_t stibp : 1;
#define IA32_SPEC_CTRL_STIBP_BIT                                     1
#define IA32_SPEC_CTRL_STIBP_FLAG                                    0x02
#define IA32_SPEC_CTRL_STIBP_MASK                                    0x01
#define IA32_SPEC_CTRL_STIBP(_)                                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] SSBD: Speculative Store Bypass Disable (SSBD). Delays speculative execution of a load until the addresses for
         * all older stores are known.
         *
         * @remarks If CPUID.(EAX=07H,ECX=0):EDX[31]=1
         */
        uint64_t ssbd : 1;
#define IA32_SPEC_CTRL_SSBD_BIT                                      2
#define IA32_SPEC_CTRL_SSBD_FLAG                                     0x04
#define IA32_SPEC_CTRL_SSBD_MASK                                     0x01
#define IA32_SPEC_CTRL_SSBD(_)                                       (((_) >> 2) & 0x01)
        uint64_t reserved1 : 61;
    };

    uint64_t flags;
} ia32_spec_ctrl_register;


/**
 * Prediction Command. Gives software a way to issue commands that affect the state of predictors.
 *
 * @remarks If any one of the enumeration conditions for defined bit field positions holds.
 */
#define IA32_PRED_CMD                                                0x00000049
typedef union
{
    struct
    {
        /**
         * [Bit 0] IBPB: Indirect Branch Prediction Barrier (IBPB).
         *
         * @remarks If CPUID.(EAX=07H,ECX=0):EDX[26]=1
         */
        uint64_t ibpb : 1;
#define IA32_PRED_CMD_IBPB_BIT                                       0
#define IA32_PRED_CMD_IBPB_FLAG                                      0x01
#define IA32_PRED_CMD_IBPB_MASK                                      0x01
#define IA32_PRED_CMD_IBPB(_)                                        (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_pred_cmd_register;


/**
 * @brief BIOS Update Trigger <b>(W)</b>
 *
 * Executing a WRMSR instruction to this MSR causes a microcode update to be loaded into the processor. A processor may
 * prevent writing to this MSR when loading guest states on VM entries or saving guest states on VM exits.
 *
 * @remarks 06_01H
 * @see Vol3A[9.11.6(Microcode Update Loader)]
 */
#define IA32_BIOS_UPDATE_TRIGGER                                     0x00000079

 /**
  * @brief BIOS Update Signature <b>(RO)</b>
  *
  * Returns the microcode update signature following the execution of CPUID.01H. A processor may prevent writing to this MSR
  * when loading guest states on VM entries or saving guest states on VM exits.
  *
  * @remarks 06_01H
  */
#define IA32_BIOS_UPDATE_SIGNATURE                                   0x0000008B
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Reserved.
         */
        uint64_t reserved : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_BIT                      0
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_FLAG                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_MASK                     0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_)                       (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief Microcode update signature
         *
         * [Bits 63:32] This field contains the signature of the currently loaded microcode update when read following the
         * execution of the CPUID instruction, function 1. It is required that this register field be pre-loaded with zero prior to
         * executing the CPUID, function 1. If the field remains equal to zero, then there is no microcode update loaded. Another
         * nonzero value will be the signature.
         *
         * @see Vol3A[9.11.7.1(Determining the Signature)] (reference)
         */
        uint64_t microcode_update_signature : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT    32
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG   0xFFFFFFFF00000000
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK   0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_)     (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_bios_update_signature_register;

/**
 * @defgroup ia32_sgxlepubkeyhash \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 *
 * Bits (64*n+63):(64*n) of the SHA256 digest of the SIGSTRUCT.MODULUS for SGX Launch Enclave. On reset, the default value
 * is the digest of Intel's signing key.
 *
 * @remarks Read permitted If CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && CPUID.(EAX=07H,ECX=0H):ECX[30]=1. Write permitted if
 *          CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && IA32_FEATURE_CONTROL[17] = 1 && IA32_FEATURE_CONTROL[0] = 1.
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0                                        0x0000008C
#define IA32_SGXLEPUBKEYHASH1                                        0x0000008D
#define IA32_SGXLEPUBKEYHASH2                                        0x0000008E
#define IA32_SGXLEPUBKEYHASH3                                        0x0000008F
 /**
  * @}
  */


  /**
   * SMM Monitor Configuration.
   *
   * @remarks If CPUID.01H: ECX[5]=1 || CPUID.01H: ECX[6] = 1
   */
#define IA32_SMM_MONITOR_CTL                                         0x0000009B
typedef union
{
    struct
    {
        /**
         * @brief Valid <b>(R/W)</b>
         *
         * [Bit 0] The STM may be invoked using VMCALL only if this bit is 1. Because VMCALL is used to activate the dual-monitor
         * treatment, the dual-monitor treatment cannot be activated if the bit is 0. This bit is cleared when the logical
         * processor is reset.
         *
         * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        uint64_t valid : 1;
#define IA32_SMM_MONITOR_CTL_VALID_BIT                               0
#define IA32_SMM_MONITOR_CTL_VALID_FLAG                              0x01
#define IA32_SMM_MONITOR_CTL_VALID_MASK                              0x01
#define IA32_SMM_MONITOR_CTL_VALID(_)                                (((_) >> 0) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief Controls SMI unblocking by VMXOFF
         *
         * [Bit 2] Determines whether executions of VMXOFF unblock SMIs under the default treatment of SMIs and SMM. Executions of
         * VMXOFF unblock SMIs unless bit 2 is 1 (the value of bit 0 is irrelevant).
         *
         * @remarks If IA32_VMX_MISC[28]
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        uint64_t smi_unblocking_by_vmxoff : 1;
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT            2
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG           0x04
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK           0x01
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_)             (((_) >> 2) & 0x01)
        uint64_t reserved2 : 9;

        /**
         * @brief MSEG Base <b>(R/W)</b>
         *
         * [Bits 31:12] Value that, when shifted left 12 bits, is the physical address of MSEG (the MSEG base address).
         *
         * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
         */
        uint64_t mseg_base : 20;
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT                           12
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG                          0xFFFFF000
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK                          0xFFFFF
#define IA32_SMM_MONITOR_CTL_MSEG_BASE(_)                            (((_) >> 12) & 0xFFFFF)
        uint64_t reserved3 : 32;
    };

    uint64_t flags;
} ia32_smm_monitor_ctl_register;

typedef struct
{
    /**
     * @brief MSEG revision identifier
     *
     * Different processors may use different MSEG revision identifiers. These identifiers enable software to avoid using an
     * MSEG header formatted for one processor on a processor that uses a different format. Software can discover the MSEG
     * revision identifier that a processor uses by reading the VMX capability MSR IA32_VMX_MISC.
     *
     * @see Vol3D[A.6(MISCELLANEOUS DATA)]
     */
    uint32_t mseg_header_revision;

    /**
     * @brief SMM-transfer monitor features field
     *
     * Bits 31:1 of this field are reserved and must be zero. Bit 0 of the field is the IA-32e mode SMM feature bit. It
     * indicates whether the logical processor will be in IA-32e mode after the STM is activated.
     *
     * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
     */
    uint32_t monitor_features;

    /**
     * Define values for the MonitorFeatures field of MSEG_HEADER.
     */
#define IA32_STM_FEATURES_IA32E                                      0x00000001

     /**
      * Fields that determine how processor state is loaded when the STM is activated. SMM code should establish these fields so
      * that activating of the STM invokes the STM's initialization code.
      *
      * @see Vol3C[34.15.6.5(Loading Host State)]
      */
    uint32_t gdtr_limit;
    uint32_t gdtr_base_offset;
    uint32_t cs_selector;
    uint32_t eip_offset;
    uint32_t esp_offset;
    uint32_t cr3_offset;
} ia32_mseg_header;


/**
 * Base address of the logical processor's SMRAM image.
 *
 * @remarks If IA32_VMX_MISC[15]
 */
#define IA32_SMBASE                                                  0x0000009E
 /**
  * @defgroup ia32_pmc \
  *           IA32_PMC(n)
  *
  * General Performance Counters.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PMC0                                                    0x000000C1
#define IA32_PMC1                                                    0x000000C2
#define IA32_PMC2                                                    0x000000C3
#define IA32_PMC3                                                    0x000000C4
#define IA32_PMC4                                                    0x000000C5
#define IA32_PMC5                                                    0x000000C6
#define IA32_PMC6                                                    0x000000C7
#define IA32_PMC7                                                    0x000000C8
  /**
   * @}
   */


   /**
    * TSC Frequency Clock Counter.
    *
    * @remarks If CPUID.06H: ECX[0] = 1
    */
#define IA32_MPERF                                                   0x000000E7
typedef struct
{
    /**
     * @brief C0 TSC Frequency Clock Count
     *
     * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0. Cleared upon overflow /
     * wrap-around of IA32_APERF.
     */
    uint64_t c0_mcnt;
} ia32_mperf_register;


/**
 * Actual Performance Clock Counter
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_APERF                                                   0x000000E8
typedef struct
{
    /**
     * @brief C0 Actual Frequency Clock Count
     *
     * Accumulates core clock counts at the coordinated clock frequency, when the logical processor is in C0. Cleared upon
     * overflow / wrap-around of IA32_MPERF.
     */
    uint64_t c0_acnt;
} ia32_aperf_register;


/**
 * MTRR Capability.
 *
 * @see Vol3A[11.11.2.1(IA32_MTRR_DEF_TYPE MSR)]
 * @see Vol3A[11.11.1(MTRR Feature Identification)] (reference)
 */
#define IA32_MTRR_CAPABILITIES                                       0x000000FE
typedef union
{
    struct
    {
        /**
         * @brief VCNT (variable range registers count) field
         *
         * [Bits 7:0] Indicates the number of variable ranges implemented on the processor.
         */
        uint64_t variable_range_count : 8;
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_BIT              0
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_FLAG             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_MASK             0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_)               (((_) >> 0) & 0xFF)

        /**
         * @brief FIX (fixed range registers supported) flag
         *
         * [Bit 8] Fixed range MTRRs (IA32_MTRR_FIX64K_00000 through IA32_MTRR_FIX4K_0F8000) are supported when set; no fixed range
         * registers are supported when clear.
         */
        uint64_t fixed_range_supported : 1;
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT             8
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG            0x100
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK            0x01
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_)              (((_) >> 8) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief WC (write combining) flag
         *
         * [Bit 10] The write-combining (WC) memory type is supported when set; the WC type is not supported when clear.
         */
        uint64_t wc_supported : 1;
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT                      10
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG                     0x400
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK                     0x01
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_)                       (((_) >> 10) & 0x01)

        /**
         * @brief SMRR (System-Management Range Register) flag
         *
         * [Bit 11] The system-management range register (SMRR) interface is supported when bit 11 is set; the SMRR interface is
         * not supported when clear.
         */
        uint64_t smrr_supported : 1;
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT                    11
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG                   0x800
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK                   0x01
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_)                     (((_) >> 11) & 0x01)
        uint64_t reserved2 : 52;
    };

    uint64_t flags;
} ia32_mtrr_capabilities_register;


/**
 * Enumeration of Architectural Features.
 *
 * @remarks If CPUID.(EAX=07H,ECX=0):EDX[29]=1
 */
#define IA32_ARCH_CAPABILITIES                                       0x0000010A
typedef union
{
    struct
    {
        /**
         * [Bit 0] RDCL_NO: The processor is not susceptible to Rogue Data Cache Load (RDCL).
         */
        uint64_t rdcl_no : 1;
#define IA32_ARCH_CAPABILITIES_RDCL_NO_BIT                           0
#define IA32_ARCH_CAPABILITIES_RDCL_NO_FLAG                          0x01
#define IA32_ARCH_CAPABILITIES_RDCL_NO_MASK                          0x01
#define IA32_ARCH_CAPABILITIES_RDCL_NO(_)                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] IBRS_ALL: The processor supports enhanced IBRS.
         */
        uint64_t ibrs_all : 1;
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_BIT                          1
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_FLAG                         0x02
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_MASK                         0x01
#define IA32_ARCH_CAPABILITIES_IBRS_ALL(_)                           (((_) >> 1) & 0x01)

        /**
         * [Bit 2] RSBA: The processor supports RSB Alternate. Alternative branch predictors may be used by RET instructions when
         * the RSB is empty. SW using retpoline may be affected by this behavior.
         */
        uint64_t rsba : 1;
#define IA32_ARCH_CAPABILITIES_RSBA_BIT                              2
#define IA32_ARCH_CAPABILITIES_RSBA_FLAG                             0x04
#define IA32_ARCH_CAPABILITIES_RSBA_MASK                             0x01
#define IA32_ARCH_CAPABILITIES_RSBA(_)                               (((_) >> 2) & 0x01)

        /**
         * [Bit 3] SKIP_L1DFL_VMENTRY: A value of 1 indicates the hypervisor need not flush the L1D on VM entry.
         */
        uint64_t skip_l1dfl_vmentry : 1;
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_BIT                3
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_FLAG               0x08
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_MASK               0x01
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY(_)                 (((_) >> 3) & 0x01)

        /**
         * [Bit 4] SSB_NO: Processor is not susceptible to Speculative Store Bypass.
         */
        uint64_t ssb_no : 1;
#define IA32_ARCH_CAPABILITIES_SSB_NO_BIT                            4
#define IA32_ARCH_CAPABILITIES_SSB_NO_FLAG                           0x10
#define IA32_ARCH_CAPABILITIES_SSB_NO_MASK                           0x01
#define IA32_ARCH_CAPABILITIES_SSB_NO(_)                             (((_) >> 4) & 0x01)

        /**
         * [Bit 5] MDS_NO: Processor is not susceptible to Microarchitectural Data Sampling (MDS).
         */
        uint64_t mds_no : 1;
#define IA32_ARCH_CAPABILITIES_MDS_NO_BIT                            5
#define IA32_ARCH_CAPABILITIES_MDS_NO_FLAG                           0x20
#define IA32_ARCH_CAPABILITIES_MDS_NO_MASK                           0x01
#define IA32_ARCH_CAPABILITIES_MDS_NO(_)                             (((_) >> 5) & 0x01)

        /**
         * [Bit 6] IF_PSCHANGE_MC_NO: The processor is not susceptible to a machine check error due to modifying the size of a code
         * page without TLB invalidation.
         */
        uint64_t if_pschange_mc_no : 1;
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_BIT                 6
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_FLAG                0x40
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_MASK                0x01
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO(_)                  (((_) >> 6) & 0x01)

        /**
         * [Bit 7] TSX_CTRL: If 1, indicates presence of IA32_TSX_CTRL MSR.
         */
        uint64_t tsx_ctrl : 1;
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_BIT                          7
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_FLAG                         0x80
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_MASK                         0x01
#define IA32_ARCH_CAPABILITIES_TSX_CTRL(_)                           (((_) >> 7) & 0x01)

        /**
         * [Bit 8] TAA_NO: If 1, processor is not affected by TAA.
         */
        uint64_t taa_no : 1;
#define IA32_ARCH_CAPABILITIES_TAA_NO_BIT                            8
#define IA32_ARCH_CAPABILITIES_TAA_NO_FLAG                           0x100
#define IA32_ARCH_CAPABILITIES_TAA_NO_MASK                           0x01
#define IA32_ARCH_CAPABILITIES_TAA_NO(_)                             (((_) >> 8) & 0x01)
        uint64_t reserved1 : 55;
    };

    uint64_t flags;
} ia32_arch_capabilities_register;


/**
 * Flush Command. Gives software a way to invalidate structures with finer granularity than other architectural methods.
 *
 * @remarks If any one of the enumeration conditions for defined bit field positions holds.
 */
#define IA32_FLUSH_CMD                                               0x0000010B
typedef union
{
    struct
    {
        /**
         * [Bit 0] L1D_FLUSH: Writeback and invalidate the L1 data cache.
         *
         * @remarks If CPUID.(EAX=07H,ECX=0):EDX[28]=1
         */
        uint64_t l1d_flush : 1;
#define IA32_FLUSH_CMD_L1D_FLUSH_BIT                                 0
#define IA32_FLUSH_CMD_L1D_FLUSH_FLAG                                0x01
#define IA32_FLUSH_CMD_L1D_FLUSH_MASK                                0x01
#define IA32_FLUSH_CMD_L1D_FLUSH(_)                                  (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_flush_cmd_register;


/**
 * Flush Command. Gives software a way to invalidate structures with finer granularity than other architectural methods.
 *
 * @remarks Thread scope. Not architecturally serializing.
 *          Available when CPUID.ARCH_CAP(EAX=7H,ECX = 0):EDX[29] = 1 and IA32_ARCH_CAPABILITIES.bit 7 = 1.
 */
#define IA32_TSX_CTRL                                                0x00000122
typedef union
{
    struct
    {
        /**
         * [Bit 0] RTM_DISABLE: When set to 1, XBEGIN will always abort with EAX code 0.
         */
        uint64_t rtm_disable : 1;
#define IA32_TSX_CTRL_RTM_DISABLE_BIT                                0
#define IA32_TSX_CTRL_RTM_DISABLE_FLAG                               0x01
#define IA32_TSX_CTRL_RTM_DISABLE_MASK                               0x01
#define IA32_TSX_CTRL_RTM_DISABLE(_)                                 (((_) >> 0) & 0x01)

        /**
         * [Bit 1] TSX_CPUID_CLEAR: When set to 1, CPUID.07H.EBX.RTM [bit 11] and CPUID.07H.EBX.HLE [bit 4] report 0. When set to 0
         * and the SKU supports TSX, these bits will return 1.
         */
        uint64_t tsx_cpuid_clear : 1;
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_BIT                            1
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_FLAG                           0x02
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_MASK                           0x01
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR(_)                             (((_) >> 1) & 0x01)
        uint64_t reserved1 : 62;
    };

    uint64_t flags;
} ia32_tsx_ctrl_register;


/**
 * @brief SYSENTER_CS_MSR <b>(R/W)</b>
 *
 * The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used
 * to determine the segment selector of the privilege level 0 stack segment. This value cannot indicate a null selector.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_CS                                             0x00000174
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] CS Selector.
         */
        uint64_t cs_selector : 16;
#define IA32_SYSENTER_CS_CS_SELECTOR_BIT                             0
#define IA32_SYSENTER_CS_CS_SELECTOR_FLAG                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR_MASK                            0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR(_)                              (((_) >> 0) & 0xFFFF)

        /**
         * [Bits 31:16] Not used.
         *
         * @remarks Can be read and written.
         */
        uint64_t not_used_1 : 16;
#define IA32_SYSENTER_CS_NOT_USED_1_BIT                              16
#define IA32_SYSENTER_CS_NOT_USED_1_FLAG                             0xFFFF0000
#define IA32_SYSENTER_CS_NOT_USED_1_MASK                             0xFFFF
#define IA32_SYSENTER_CS_NOT_USED_1(_)                               (((_) >> 16) & 0xFFFF)

        /**
         * [Bits 63:32] Not used.
         *
         * @remarks Writes ignored; reads return zero.
         */
        uint64_t not_used_2 : 32;
#define IA32_SYSENTER_CS_NOT_USED_2_BIT                              32
#define IA32_SYSENTER_CS_NOT_USED_2_FLAG                             0xFFFFFFFF00000000
#define IA32_SYSENTER_CS_NOT_USED_2_MASK                             0xFFFFFFFF
#define IA32_SYSENTER_CS_NOT_USED_2(_)                               (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_sysenter_cs_register;


/**
 * @brief SYSENTER_ESP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack).
 * This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_ESP                                            0x00000175

 /**
  * @brief SYSENTER_EIP_MSR <b>(R/W)</b>
  *
  * The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating
  * procedure or routine). In protected mode, only bits 31:0 are loaded.
  *
  * @remarks 06_01H
  * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
  */
#define IA32_SYSENTER_EIP                                            0x00000176

  /**
   * Global Machine Check Capability.
   *
   * @remarks 06_01H
   */
#define IA32_MCG_CAP                                                 0x00000179
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Number of reporting banks.
         */
        uint64_t count : 8;
#define IA32_MCG_CAP_COUNT_BIT                                       0
#define IA32_MCG_CAP_COUNT_FLAG                                      0xFF
#define IA32_MCG_CAP_COUNT_MASK                                      0xFF
#define IA32_MCG_CAP_COUNT(_)                                        (((_) >> 0) & 0xFF)

        /**
         * [Bit 8] IA32_MCG_CTL is present if this bit is set.
         */
        uint64_t mcg_ctl_p : 1;
#define IA32_MCG_CAP_MCG_CTL_P_BIT                                   8
#define IA32_MCG_CAP_MCG_CTL_P_FLAG                                  0x100
#define IA32_MCG_CAP_MCG_CTL_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_CTL_P(_)                                    (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Extended machine check state registers are present if this bit is set.
         */
        uint64_t mcg_ext_p : 1;
#define IA32_MCG_CAP_MCG_EXT_P_BIT                                   9
#define IA32_MCG_CAP_MCG_EXT_P_FLAG                                  0x200
#define IA32_MCG_CAP_MCG_EXT_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_EXT_P(_)                                    (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Support for corrected MC error event is present.
         *
         * @remarks 06_01H
         */
        uint64_t mcp_cmci_p : 1;
#define IA32_MCG_CAP_MCP_CMCI_P_BIT                                  10
#define IA32_MCG_CAP_MCP_CMCI_P_FLAG                                 0x400
#define IA32_MCG_CAP_MCP_CMCI_P_MASK                                 0x01
#define IA32_MCG_CAP_MCP_CMCI_P(_)                                   (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Threshold-based error status register are present if this bit is set.
         */
        uint64_t mcg_tes_p : 1;
#define IA32_MCG_CAP_MCG_TES_P_BIT                                   11
#define IA32_MCG_CAP_MCG_TES_P_FLAG                                  0x800
#define IA32_MCG_CAP_MCG_TES_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_TES_P(_)                                    (((_) >> 11) & 0x01)
        uint64_t reserved1 : 4;

        /**
         * [Bits 23:16] Number of extended machine check state registers present.
         */
        uint64_t mcg_ext_cnt : 8;
#define IA32_MCG_CAP_MCG_EXT_CNT_BIT                                 16
#define IA32_MCG_CAP_MCG_EXT_CNT_FLAG                                0xFF0000
#define IA32_MCG_CAP_MCG_EXT_CNT_MASK                                0xFF
#define IA32_MCG_CAP_MCG_EXT_CNT(_)                                  (((_) >> 16) & 0xFF)

        /**
         * [Bit 24] The processor supports software error recovery if this bit is set.
         */
        uint64_t mcg_ser_p : 1;
#define IA32_MCG_CAP_MCG_SER_P_BIT                                   24
#define IA32_MCG_CAP_MCG_SER_P_FLAG                                  0x1000000
#define IA32_MCG_CAP_MCG_SER_P_MASK                                  0x01
#define IA32_MCG_CAP_MCG_SER_P(_)                                    (((_) >> 24) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bit 26] Indicates that the processor allows platform firmware to be invoked when an error is detected so that it may
         * provide additional platform specific information in an ACPI format "Generic Error Data Entry" that augments the data
         * included in machine check bank registers.
         *
         * @remarks 06_3EH
         */
        uint64_t mcg_elog_p : 1;
#define IA32_MCG_CAP_MCG_ELOG_P_BIT                                  26
#define IA32_MCG_CAP_MCG_ELOG_P_FLAG                                 0x4000000
#define IA32_MCG_CAP_MCG_ELOG_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_ELOG_P(_)                                   (((_) >> 26) & 0x01)

        /**
         * [Bit 27] Indicates that the processor supports extended state in IA32_MCG_STATUS and associated MSR necessary to
         * configure Local Machine Check Exception (LMCE).
         *
         * @remarks 06_3EH
         */
        uint64_t mcg_lmce_p : 1;
#define IA32_MCG_CAP_MCG_LMCE_P_BIT                                  27
#define IA32_MCG_CAP_MCG_LMCE_P_FLAG                                 0x8000000
#define IA32_MCG_CAP_MCG_LMCE_P_MASK                                 0x01
#define IA32_MCG_CAP_MCG_LMCE_P(_)                                   (((_) >> 27) & 0x01)
        uint64_t reserved3 : 36;
    };

    uint64_t flags;
} ia32_mcg_cap_register;


/**
 * Global Machine Check Status.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_STATUS                                              0x0000017A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Restart IP valid.
         *
         * @remarks 06_01H
         */
        uint64_t ripv : 1;
#define IA32_MCG_STATUS_RIPV_BIT                                     0
#define IA32_MCG_STATUS_RIPV_FLAG                                    0x01
#define IA32_MCG_STATUS_RIPV_MASK                                    0x01
#define IA32_MCG_STATUS_RIPV(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Error IP valid.
         *
         * @remarks 06_01H
         */
        uint64_t eipv : 1;
#define IA32_MCG_STATUS_EIPV_BIT                                     1
#define IA32_MCG_STATUS_EIPV_FLAG                                    0x02
#define IA32_MCG_STATUS_EIPV_MASK                                    0x01
#define IA32_MCG_STATUS_EIPV(_)                                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Machine check in progress.
         *
         * @remarks 06_01H
         */
        uint64_t mcip : 1;
#define IA32_MCG_STATUS_MCIP_BIT                                     2
#define IA32_MCG_STATUS_MCIP_FLAG                                    0x04
#define IA32_MCG_STATUS_MCIP_MASK                                    0x01
#define IA32_MCG_STATUS_MCIP(_)                                      (((_) >> 2) & 0x01)

        /**
         * [Bit 3] If IA32_MCG_CAP.LMCE_P[27] = 1.
         */
        uint64_t lmce_s : 1;
#define IA32_MCG_STATUS_LMCE_S_BIT                                   3
#define IA32_MCG_STATUS_LMCE_S_FLAG                                  0x08
#define IA32_MCG_STATUS_LMCE_S_MASK                                  0x01
#define IA32_MCG_STATUS_LMCE_S(_)                                    (((_) >> 3) & 0x01)
        uint64_t reserved1 : 60;
    };

    uint64_t flags;
} ia32_mcg_status_register;


/**
 * Global Machine Check Control.
 *
 * @remarks If IA32_MCG_CAP.CTL_P[8] = 1
 */
#define IA32_MCG_CTL                                                 0x0000017B
 /**
  * @defgroup ia32_perfevtsel \
  *           IA32_PERFEVTSEL(n)
  *
  * Performance Event Select Register n.
  *
  * @remarks If CPUID.0AH: EAX[15:8] > n
  * @{
  */
#define IA32_PERFEVTSEL0                                             0x00000186
#define IA32_PERFEVTSEL1                                             0x00000187
#define IA32_PERFEVTSEL2                                             0x00000188
#define IA32_PERFEVTSEL3                                             0x00000189
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Selects a performance event logic unit.
         */
        uint64_t event_select : 8;
#define IA32_PERFEVTSEL_EVENT_SELECT_BIT                             0
#define IA32_PERFEVTSEL_EVENT_SELECT_FLAG                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT_MASK                            0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT(_)                              (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Qualifies the microarchitectural condition to detect on the selected event logic.
         */
        uint64_t u_mask : 8;
#define IA32_PERFEVTSEL_U_MASK_BIT                                   8
#define IA32_PERFEVTSEL_U_MASK_FLAG                                  0xFF00
#define IA32_PERFEVTSEL_U_MASK_MASK                                  0xFF
#define IA32_PERFEVTSEL_U_MASK(_)                                    (((_) >> 8) & 0xFF)

        /**
         * [Bit 16] Counts while in privilege level is not ring 0.
         */
        uint64_t usr : 1;
#define IA32_PERFEVTSEL_USR_BIT                                      16
#define IA32_PERFEVTSEL_USR_FLAG                                     0x10000
#define IA32_PERFEVTSEL_USR_MASK                                     0x01
#define IA32_PERFEVTSEL_USR(_)                                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] Counts while in privilege level is ring 0.
         */
        uint64_t os : 1;
#define IA32_PERFEVTSEL_OS_BIT                                       17
#define IA32_PERFEVTSEL_OS_FLAG                                      0x20000
#define IA32_PERFEVTSEL_OS_MASK                                      0x01
#define IA32_PERFEVTSEL_OS(_)                                        (((_) >> 17) & 0x01)

        /**
         * [Bit 18] Enables edge detection if set.
         */
        uint64_t edge : 1;
#define IA32_PERFEVTSEL_EDGE_BIT                                     18
#define IA32_PERFEVTSEL_EDGE_FLAG                                    0x40000
#define IA32_PERFEVTSEL_EDGE_MASK                                    0x01
#define IA32_PERFEVTSEL_EDGE(_)                                      (((_) >> 18) & 0x01)

        /**
         * [Bit 19] Enables pin control.
         */
        uint64_t pc : 1;
#define IA32_PERFEVTSEL_PC_BIT                                       19
#define IA32_PERFEVTSEL_PC_FLAG                                      0x80000
#define IA32_PERFEVTSEL_PC_MASK                                      0x01
#define IA32_PERFEVTSEL_PC(_)                                        (((_) >> 19) & 0x01)

        /**
         * [Bit 20] Enables interrupt on counter overflow.
         */
        uint64_t intr : 1;
#define IA32_PERFEVTSEL_INTR_BIT                                     20
#define IA32_PERFEVTSEL_INTR_FLAG                                    0x100000
#define IA32_PERFEVTSEL_INTR_MASK                                    0x01
#define IA32_PERFEVTSEL_INTR(_)                                      (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, it enables counting the associated event conditions occurring across all logical processors
         * sharing a processor core. When set to 0, the counter only increments the associated event conditions occurring in the
         * logical processor which programmed the MSR.
         */
        uint64_t any_thread : 1;
#define IA32_PERFEVTSEL_ANY_THREAD_BIT                               21
#define IA32_PERFEVTSEL_ANY_THREAD_FLAG                              0x200000
#define IA32_PERFEVTSEL_ANY_THREAD_MASK                              0x01
#define IA32_PERFEVTSEL_ANY_THREAD(_)                                (((_) >> 21) & 0x01)

        /**
         * [Bit 22] Enables the corresponding performance counter to commence counting when this bit is set.
         */
        uint64_t en : 1;
#define IA32_PERFEVTSEL_EN_BIT                                       22
#define IA32_PERFEVTSEL_EN_FLAG                                      0x400000
#define IA32_PERFEVTSEL_EN_MASK                                      0x01
#define IA32_PERFEVTSEL_EN(_)                                        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] Invert the CMASK.
         */
        uint64_t inv : 1;
#define IA32_PERFEVTSEL_INV_BIT                                      23
#define IA32_PERFEVTSEL_INV_FLAG                                     0x800000
#define IA32_PERFEVTSEL_INV_MASK                                     0x01
#define IA32_PERFEVTSEL_INV(_)                                       (((_) >> 23) & 0x01)

        /**
         * [Bits 31:24] When CMASK is not zero, the corresponding performance counter increments each cycle if the event count is
         * greater than or equal to the CMASK.
         */
        uint64_t cmask : 8;
#define IA32_PERFEVTSEL_CMASK_BIT                                    24
#define IA32_PERFEVTSEL_CMASK_FLAG                                   0xFF000000
#define IA32_PERFEVTSEL_CMASK_MASK                                   0xFF
#define IA32_PERFEVTSEL_CMASK(_)                                     (((_) >> 24) & 0xFF)
        uint64_t reserved1 : 32;
    };

    uint64_t flags;
} ia32_perfevtsel_register;

/**
 * @}
 */


 /**
  * Current Performance Status.
  *
  * @remarks 0F_03H
  * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
  */
#define IA32_PERF_STATUS                                             0x00000198
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Current performance State Value.
         */
        uint64_t state_value : 16;
#define IA32_PERF_STATUS_STATE_VALUE_BIT                             0
#define IA32_PERF_STATUS_STATE_VALUE_FLAG                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE_MASK                            0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE(_)                              (((_) >> 0) & 0xFFFF)
        uint64_t reserved1 : 48;
    };

    uint64_t flags;
} ia32_perf_status_register;


/**
 * @brief Performance Control <b>(R/W)</b>
 *
 * Performance Control. Software makes a request for a new Performance state (P-State) by writing this MSR.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_CTL                                                0x00000199
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Target performance State Value.
         */
        uint64_t target_state_value : 16;
#define IA32_PERF_CTL_TARGET_STATE_VALUE_BIT                         0
#define IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE_MASK                        0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE(_)                          (((_) >> 0) & 0xFFFF)
        uint64_t reserved1 : 16;

        /**
         * [Bit 32] IDA Engage.
         *
         * @remarks 06_0FH (Mobile only)
         */
        uint64_t ida_engage : 1;
#define IA32_PERF_CTL_IDA_ENGAGE_BIT                                 32
#define IA32_PERF_CTL_IDA_ENGAGE_FLAG                                0x100000000
#define IA32_PERF_CTL_IDA_ENGAGE_MASK                                0x01
#define IA32_PERF_CTL_IDA_ENGAGE(_)                                  (((_) >> 32) & 0x01)
        uint64_t reserved2 : 31;
    };

    uint64_t flags;
} ia32_perf_ctl_register;


/**
 * Clock Modulation Control.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.3(Software Controlled Clock Modulation)]
 */
#define IA32_CLOCK_MODULATION                                        0x0000019A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Extended On-Demand Clock Modulation Duty Cycle.
         *
         * @remarks If CPUID.06H:EAX[5] = 1
         */
        uint64_t extended_on_demand_clock_modulation_duty_cycle : 1;
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 0
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 0) & 0x01)

        /**
         * @brief On-Demand Clock Modulation Duty Cycle
         *
         * [Bits 3:1] On-Demand Clock Modulation Duty Cycle: Specific encoded values for target duty cycle modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t on_demand_clock_modulation_duty_cycle : 3;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT 1
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x0E
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x07
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_) (((_) >> 1) & 0x07)

        /**
         * @brief On-Demand Clock Modulation Enable
         *
         * [Bit 4] On-Demand Clock Modulation Enable: Set 1 to enable modulation.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t on_demand_clock_modulation_enable : 1;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT  4
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG 0x10
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK 0x01
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_)   (((_) >> 4) & 0x01)
        uint64_t reserved1 : 59;
    };

    uint64_t flags;
} ia32_clock_modulation_register;


/**
 * @brief Thermal Interrupt Control <b>(R/W)</b>
 *
 * Thermal Interrupt Control. Enables and disables the generation of an interrupt on temperature transitions detected with
 * the processor's thermal sensors and thermal monitor.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_INTERRUPT                                         0x0000019B
typedef union
{
    struct
    {
        /**
         * [Bit 0] High-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t high_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT   0
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK  0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_)    (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Low-Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t low_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT    1
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG   0x02
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK   0x01
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_)     (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t prochot_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT            2
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG           0x04
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)             (((_) >> 2) & 0x01)

        /**
         * [Bit 3] FORCEPR\# Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t forcepr_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT            3
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG           0x08
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK           0x01
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_)             (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t critical_temperature_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT 4
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 4) & 0x01)
        uint64_t reserved1 : 3;

        /**
         * [Bits 14:8] Threshold \#1 Value
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t threshold1_value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT                    8
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG                   0x7F00
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_)                     (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Threshold \#1 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t threshold1_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT         15
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG        0x8000
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)          (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Threshold \#2 Value.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t threshold2_value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT                    16
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG                   0x7F0000
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK                   0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_)                     (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Threshold \#2 Interrupt Enable.
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t threshold2_interrupt_enable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT         23
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG        0x800000
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK        0x01
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)          (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Power Limit Notification Enable.
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        uint64_t power_limit_notification_enable : 1;
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT     24
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG    0x1000000
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK    0x01
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_)      (((_) >> 24) & 0x01)
        uint64_t reserved2 : 39;
    };

    uint64_t flags;
} ia32_therm_interrupt_register;


/**
 * @brief Thermal Status Information <b>(RO)</b>
 *
 * Thermal Status Information. Contains status information about the processor's thermal sensor and automatic thermal
 * monitoring facilities.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_STATUS                                            0x0000019C
typedef union
{
    struct
    {
        /**
         * [Bit 0] Thermal Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t thermal_status : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_BIT                         0
#define IA32_THERM_STATUS_THERMAL_STATUS_FLAG                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_MASK                        0x01
#define IA32_THERM_STATUS_THERMAL_STATUS(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Thermal Status Log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t thermal_status_log : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT                     1
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG                    0x02
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK                    0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG(_)                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] PROCHOT \# or FORCEPR\# event
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t prochot_forcepr_event : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT                  2
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG                 0x04
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK                 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] PROCHOT \# or FORCEPR\# log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t prochot_forcepr_log : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT                    3
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG                   0x08
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK                   0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Critical Temperature Status
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t critical_temperature_status : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT            4
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG           0x10
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK           0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)             (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Critical Temperature Status log
         *
         * @remarks If CPUID.01H:EDX[22] = 1
         */
        uint64_t critical_temperature_status_log : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT        5
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG       0x20
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK       0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_)         (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Thermal Threshold \#1 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        uint64_t thermal_threshold1_status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT              6
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG             0x40
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)               (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Thermal Threshold \#1 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        uint64_t thermal_threshold1_log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT                 7
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG                0x80
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)                  (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Thermal Threshold \#2 Status
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        uint64_t thermal_threshold2_status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT              8
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG             0x100
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK             0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)               (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Thermal Threshold \#2 log
         *
         * @remarks If CPUID.01H:ECX[8] = 1
         */
        uint64_t thermal_threshold2_log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT                 9
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG                0x200
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK                0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Power Limitation Status
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        uint64_t power_limitation_status : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT                10
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG               0x400
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK               0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_)                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Power Limitation log
         *
         * @remarks If CPUID.06H:EAX[4] = 1
         */
        uint64_t power_limitation_log : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT                   11
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG                  0x800
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK                  0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG(_)                    (((_) >> 11) & 0x01)

        /**
         * [Bit 12] Current Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        uint64_t current_limit_status : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT                   12
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG                  0x1000
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK                  0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_)                    (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Current Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        uint64_t current_limit_log : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT                      13
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG                     0x2000
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK                     0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] Cross Domain Limit Status
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        uint64_t cross_domain_limit_status : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT              14
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG             0x4000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK             0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_)               (((_) >> 14) & 0x01)

        /**
         * [Bit 15] Cross Domain Limit log
         *
         * @remarks If CPUID.06H:EAX[7] = 1
         */
        uint64_t cross_domain_limit_log : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT                 15
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG                0x8000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK                0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_)                  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Digital Readout
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        uint64_t digital_readout : 7;
#define IA32_THERM_STATUS_DIGITAL_READOUT_BIT                        16
#define IA32_THERM_STATUS_DIGITAL_READOUT_FLAG                       0x7F0000
#define IA32_THERM_STATUS_DIGITAL_READOUT_MASK                       0x7F
#define IA32_THERM_STATUS_DIGITAL_READOUT(_)                         (((_) >> 16) & 0x7F)
        uint64_t reserved1 : 4;

        /**
         * [Bits 30:27] Resolution in Degrees Celsius
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        uint64_t resolution_in_degrees_celsius : 4;
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT          27
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG         0x78000000
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK         0x0F
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_)           (((_) >> 27) & 0x0F)

        /**
         * [Bit 31] Reading Valid
         *
         * @remarks If CPUID.06H:EAX[0] = 1
         */
        uint64_t reading_valid : 1;
#define IA32_THERM_STATUS_READING_VALID_BIT                          31
#define IA32_THERM_STATUS_READING_VALID_FLAG                         0x80000000
#define IA32_THERM_STATUS_READING_VALID_MASK                         0x01
#define IA32_THERM_STATUS_READING_VALID(_)                           (((_) >> 31) & 0x01)
        uint64_t reserved2 : 32;
    };

    uint64_t flags;
} ia32_therm_status_register;


/**
 * @brief Enable Misc. Processor Features <b>(R/W)</b>
 *
 * Allows a variety of processor functions to be enabled and disabled.
 */
#define IA32_MISC_ENABLE                                             0x000001A0
typedef union
{
    struct
    {
        /**
         * @brief Fast-Strings Enable
         *
         * [Bit 0] When set, the fast-strings feature (for REP MOVS and REP STORS) is enabled (default). When clear, fast-strings
         * are disabled.
         *
         * @remarks 0F_0H
         */
        uint64_t fast_strings_enable : 1;
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT                     0
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK                    0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_)                      (((_) >> 0) & 0x01)
        uint64_t reserved1 : 2;

        /**
         * @brief Automatic Thermal Control Circuit Enable <b>(R/W)</b>
         *
         * [Bit 3] - 1 = Setting this bit enables the thermal control circuit (TCC) portion of the Intel Thermal Monitor feature.
         * This allows the processor to automatically reduce power consumption in response to TCC activation.
         * - 0 = Disabled.
         *
         * @note In some products clearing this bit might be ignored in critical thermal conditions, and TM1, TM2 and adaptive
         *       thermal throttling will still be activated. The default value of this field varies with product.
         * @remarks 0F_0H
         */
        uint64_t automatic_thermal_control_circuit_enable : 1;
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT 3
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG 0x08
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_) (((_) >> 3) & 0x01)
        uint64_t reserved2 : 3;

        /**
         * @brief Performance Monitoring Available <b>(R)</b>
         *
         * [Bit 7] - 1 = Performance monitoring enabled.
         * - 0 = Performance monitoring disabled.
         *
         * @remarks 0F_0H
         */
        uint64_t performance_monitoring_available : 1;
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT        7
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG       0x80
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_)         (((_) >> 7) & 0x01)
        uint64_t reserved3 : 3;

        /**
         * @brief Branch Trace Storage Unavailable <b>(RO)</b>
         *
         * [Bit 11] - 1 = Processor doesn't support branch trace storage (BTS).
         * - 0 = BTS is supported.
         *
         * @remarks 0F_0H
         */
        uint64_t branch_trace_storage_unavailable : 1;
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT        11
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG       0x800
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK       0x01
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_)         (((_) >> 11) & 0x01)

        /**
         * @brief Processor Event Based Sampling (PEBS) Unavailable <b>(RO)</b>
         *
         * [Bit 12] - 1 = PEBS is not supported.
         * - 0 = PEBS is supported.
         *
         * @remarks 06_0FH
         */
        uint64_t processor_event_based_sampling_unavailable : 1;
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT 12
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG 0x1000
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_) (((_) >> 12) & 0x01)
        uint64_t reserved4 : 3;

        /**
         * @brief Enhanced Intel SpeedStep Technology Enable <b>(R/W)</b>
         *
         * [Bit 16] - 0 = Enhanced Intel SpeedStep Technology disabled.
         * - 1 = Enhanced Intel SpeedStep Technology enabled.
         *
         * @remarks If CPUID.01H: ECX[7] = 1
         */
        uint64_t enhanced_intel_speedstep_technology_enable : 1;
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT 16
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG 0x10000
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_) (((_) >> 16) & 0x01)
        uint64_t reserved5 : 1;

        /**
         * @brief ENABLE MONITOR FSM <b>(R/W)</b>
         *
         * [Bit 18] When this bit is set to 0, the MONITOR feature flag is not set (CPUID.01H:ECX[bit3] = 0). This indicates that
         * MONITOR/MWAIT are not supported. Software attempts to execute MONITOR/MWAIT will cause \#UD when this bit is 0.
         * When this bit is set to 1 (default), MONITOR/MWAIT are supported (CPUID.01H:ECX[bit 3] = 1). If the SSE3 feature flag
         * ECX[0] is not set (CPUID.01H:ECX[bit 0] = 0), the OS must not attempt to alter this bit. BIOS must leave it in the
         * default state. Writing this bit when the SSE3 feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks 0F_03H
         */
        uint64_t enable_monitor_fsm : 1;
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT                      18
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG                     0x40000
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK                     0x01
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_)                       (((_) >> 18) & 0x01)
        uint64_t reserved6 : 3;

        /**
         * @brief Limit CPUID Maxval <b>(R/W)</b>
         *
         * [Bit 22] When this bit is set to 1, CPUID.00H returns a maximum value in EAX[7:0] of 2. BIOS should contain a setup
         * question that allows users to specify when the installed OS does not support CPUID functions greater than 2.
         * Before setting this bit, BIOS must execute the CPUID.0H and examine the maximum value returned in EAX[7:0]. If the
         * maximum value is greater than 2, this bit is supported.
         * Otherwise, this bit is not supported. Setting this bit when the maximum value is not greater than 2 may generate a \#GP
         * exception. Setting this bit may cause unexpected behavior in software that depends on the availability of CPUID leaves
         * greater than 2.
         *
         * @remarks 0F_03H
         */
        uint64_t limit_cpuid_maxval : 1;
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT                      22
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG                     0x400000
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK                     0x01
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_)                       (((_) >> 22) & 0x01)

        /**
         * @brief xTPR Message Disable <b>(R/W)</b>
         *
         * [Bit 23] When set to 1, xTPR messages are disabled. xTPR messages are optional messages that allow the processor to
         * inform the chipset of its priority.
         *
         * @remarks If CPUID.01H:ECX[14] = 1
         */
        uint64_t xtpr_message_disable : 1;
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT                    23
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG                   0x800000
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK                   0x01
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_)                     (((_) >> 23) & 0x01)
        uint64_t reserved7 : 10;

        /**
         * @brief XD Bit Disable <b>(R/W)</b>
         *
         * [Bit 34] When set to 1, the Execute Disable Bit feature (XD Bit) is disabled and the XD Bit extended feature flag will
         * be clear (CPUID.80000001H: EDX[20]=0).
         * When set to a 0 (default), the Execute Disable Bit feature (if available) allows the OS to enable PAE paging and take
         * advantage of data only pages.
         * BIOS must not alter the contents of this bit location, if XD bit is not supported. Writing this bit to 1 when the XD Bit
         * extended feature flag is set to 0 may generate a \#GP exception.
         *
         * @remarks If CPUID.80000001H:EDX[20] = 1
         */
        uint64_t xd_bit_disable : 1;
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT                          34
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG                         0x400000000
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK                         0x01
#define IA32_MISC_ENABLE_XD_BIT_DISABLE(_)                           (((_) >> 34) & 0x01)
        uint64_t reserved8 : 29;
    };

    uint64_t flags;
} ia32_misc_enable_register;


/**
 * Performance Energy Bias Hint.
 *
 * @remarks If CPUID.6H:ECX[3] = 1
 */
#define IA32_ENERGY_PERF_BIAS                                        0x000001B0
typedef union
{
    struct
    {
        /**
         * @brief Power Policy Preference
         *
         * [Bits 3:0] - 0 indicates preference to highest performance.
         * - 15 indicates preference to maximize energy saving.
         */
        uint64_t power_policy_preference : 4;
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_BIT            0
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_FLAG           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_MASK           0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_)             (((_) >> 0) & 0x0F)
        uint64_t reserved1 : 60;
    };

    uint64_t flags;
} ia32_energy_perf_bias_register;


/**
 * @brief Package Thermal Status Information <b>(RO)</b>
 *
 * Package Thermal Status Information. Contains status information about the package's thermal sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_STATUS                                    0x000001B1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg Thermal Status
         */
        uint64_t thermal_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_BIT                 0
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_FLAG                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_MASK                0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_)                  (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Thermal Status Log
         */
        uint64_t thermal_status_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT             1
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG            0x02
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK            0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_)              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT \# event
         */
        uint64_t prochot_event : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT                  2
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG                 0x04
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK                 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_)                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Pkg PROCHOT \# log
         */
        uint64_t prochot_log : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT                    3
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG                   0x08
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK                   0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Pkg Critical Temperature Status
         */
        uint64_t critical_temperature_status : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT    4
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG   0x10
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK   0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Pkg Critical Temperature Status Log
         */
        uint64_t critical_temperature_status_log : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT 5
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_) (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Pkg Thermal Threshold \#1 Status
         */
        uint64_t thermal_threshold1_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT      6
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG     0x40
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)       (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Pkg Thermal Threshold \#1 log
         */
        uint64_t thermal_threshold1_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT         7
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG        0x80
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)          (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Pkg Thermal Threshold \#2 Status
         */
        uint64_t thermal_threshold2_status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT      8
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG     0x100
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK     0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] Pkg Thermal Threshold \#2 log
         */
        uint64_t thermal_threshold2_log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT         9
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG        0x200
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK        0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)          (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Pkg Power Limitation Status
         */
        uint64_t power_limitation_status : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT        10
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG       0x400
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK       0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_)         (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Pkg Power Limitation log
         */
        uint64_t power_limitation_log : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT           11
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG          0x800
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK          0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_)            (((_) >> 11) & 0x01)
        uint64_t reserved1 : 4;

        /**
         * [Bits 22:16] Pkg Digital Readout
         */
        uint64_t digital_readout : 7;
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT                16
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG               0x7F0000
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK               0x7F
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_)                 (((_) >> 16) & 0x7F)
        uint64_t reserved2 : 41;
    };

    uint64_t flags;
} ia32_package_therm_status_register;


/**
 * @brief Package Thermal Interrupt Control <b>(RO)</b>
 *
 * Enables and disables the generation of an interrupt on temperature transitions detected with the package's thermal
 * sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_INTERRUPT                                 0x000001B2
typedef union
{
    struct
    {
        /**
         * [Bit 0] Pkg High-Temperature Interrupt Enable.
         */
        uint64_t high_temperature_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT 0
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Pkg Low-Temperature Interrupt Enable.
         */
        uint64_t low_temperature_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT 1
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_) (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Pkg PROCHOT\# Interrupt Enable.
         */
        uint64_t prochot_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT    2
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG   0x04
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK   0x01
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)     (((_) >> 2) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * [Bit 4] Pkg Overheat Interrupt Enable.
         */
        uint64_t overheat_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT   4
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG  0x10
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK  0x01
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_)    (((_) >> 4) & 0x01)
        uint64_t reserved2 : 3;

        /**
         * [Bits 14:8] Pkg Threshold \#1 Value
         */
        uint64_t threshold1_value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT            8
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG           0x7F00
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_)             (((_) >> 8) & 0x7F)

        /**
         * [Bit 15] Pkg Threshold \#1 Interrupt Enable.
         */
        uint64_t threshold1_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT 15
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)  (((_) >> 15) & 0x01)

        /**
         * [Bits 22:16] Pkg Threshold \#2 Value.
         */
        uint64_t threshold2_value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT            16
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG           0x7F0000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK           0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_)             (((_) >> 16) & 0x7F)

        /**
         * [Bit 23] Pkg Threshold \#2 Interrupt Enable.
         */
        uint64_t threshold2_interrupt_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT 23
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)  (((_) >> 23) & 0x01)

        /**
         * [Bit 24] Pkg Power Limit Notification Enable.
         */
        uint64_t power_limit_notification_enable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT 24
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_) (((_) >> 24) & 0x01)
        uint64_t reserved3 : 39;
    };

    uint64_t flags;
} ia32_package_therm_interrupt_register;


/**
 * Trace/Profile Resource Control.
 *
 * @remarks 06_0EH
 */
#define IA32_DEBUGCTL                                                0x000001D9
typedef union
{
    struct
    {
        /**
         * [Bit 0] Setting this bit to 1 enables the processor to record a running trace of the most recent branches taken by the
         * processor in the LBR stack.
         *
         * @remarks 06_01H
         */
        uint64_t lbr : 1;
#define IA32_DEBUGCTL_LBR_BIT                                        0
#define IA32_DEBUGCTL_LBR_FLAG                                       0x01
#define IA32_DEBUGCTL_LBR_MASK                                       0x01
#define IA32_DEBUGCTL_LBR(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Setting this bit to 1 enables the processor to treat EFLAGS.TF as single-step on branches instead of single-step
         * on instructions.
         *
         * @remarks 06_01H
         */
        uint64_t btf : 1;
#define IA32_DEBUGCTL_BTF_BIT                                        1
#define IA32_DEBUGCTL_BTF_FLAG                                       0x02
#define IA32_DEBUGCTL_BTF_MASK                                       0x01
#define IA32_DEBUGCTL_BTF(_)                                         (((_) >> 1) & 0x01)
        uint64_t reserved1 : 4;

        /**
         * [Bit 6] Setting this bit to 1 enables branch trace messages to be sent.
         *
         * @remarks 06_0EH
         */
        uint64_t tr : 1;
#define IA32_DEBUGCTL_TR_BIT                                         6
#define IA32_DEBUGCTL_TR_FLAG                                        0x40
#define IA32_DEBUGCTL_TR_MASK                                        0x01
#define IA32_DEBUGCTL_TR(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Setting this bit enables branch trace messages (BTMs) to be logged in a BTS buffer.
         *
         * @remarks 06_0EH
         */
        uint64_t bts : 1;
#define IA32_DEBUGCTL_BTS_BIT                                        7
#define IA32_DEBUGCTL_BTS_FLAG                                       0x80
#define IA32_DEBUGCTL_BTS_MASK                                       0x01
#define IA32_DEBUGCTL_BTS(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bit 8] When clear, BTMs are logged in a BTS buffer in circular fashion. When this bit is set, an interrupt is generated
         * by the BTS facility when the BTS buffer is full.
         *
         * @remarks 06_0EH
         */
        uint64_t btint : 1;
#define IA32_DEBUGCTL_BTINT_BIT                                      8
#define IA32_DEBUGCTL_BTINT_FLAG                                     0x100
#define IA32_DEBUGCTL_BTINT_MASK                                     0x01
#define IA32_DEBUGCTL_BTINT(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bit 9] When set, BTS or BTM is skipped if CPL = 0.
         *
         * @remarks 06_0FH
         */
        uint64_t bts_off_os : 1;
#define IA32_DEBUGCTL_BTS_OFF_OS_BIT                                 9
#define IA32_DEBUGCTL_BTS_OFF_OS_FLAG                                0x200
#define IA32_DEBUGCTL_BTS_OFF_OS_MASK                                0x01
#define IA32_DEBUGCTL_BTS_OFF_OS(_)                                  (((_) >> 9) & 0x01)

        /**
         * [Bit 10] When set, BTS or BTM is skipped if CPL > 0.
         *
         * @remarks 06_0FH
         */
        uint64_t bts_off_usr : 1;
#define IA32_DEBUGCTL_BTS_OFF_USR_BIT                                10
#define IA32_DEBUGCTL_BTS_OFF_USR_FLAG                               0x400
#define IA32_DEBUGCTL_BTS_OFF_USR_MASK                               0x01
#define IA32_DEBUGCTL_BTS_OFF_USR(_)                                 (((_) >> 10) & 0x01)

        /**
         * [Bit 11] When set, the LBR stack is frozen on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        uint64_t freeze_lbrs_on_pmi : 1;
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT                         11
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG                        0x800
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK                        0x01
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_)                          (((_) >> 11) & 0x01)

        /**
         * [Bit 12] When set, each ENABLE bit of the global counter control MSR are frozen (address 38FH) on a PMI request.
         *
         * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
         */
        uint64_t freeze_perfmon_on_pmi : 1;
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT                      12
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG                     0x1000
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK                     0x01
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_)                       (((_) >> 12) & 0x01)

        /**
         * [Bit 13] When set, enables the logical processor to receive and generate PMI on behalf of the uncore.
         *
         * @remarks 06_1AH
         */
        uint64_t enable_uncore_pmi : 1;
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT                          13
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG                         0x2000
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK                         0x01
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_)                           (((_) >> 13) & 0x01)

        /**
         * [Bit 14] When set, freezes perfmon and trace messages while in SMM.
         *
         * @remarks If IA32_PERF_CAPABILITIES[12] = 1
         */
        uint64_t freeze_while_smm : 1;
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT                           14
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG                          0x4000
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK                          0x01
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM(_)                            (((_) >> 14) & 0x01)

        /**
         * [Bit 15] When set, enables DR7 debug bit on XBEGIN.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[11] = 1)
         */
        uint64_t rtm_debug : 1;
#define IA32_DEBUGCTL_RTM_DEBUG_BIT                                  15
#define IA32_DEBUGCTL_RTM_DEBUG_FLAG                                 0x8000
#define IA32_DEBUGCTL_RTM_DEBUG_MASK                                 0x01
#define IA32_DEBUGCTL_RTM_DEBUG(_)                                   (((_) >> 15) & 0x01)
        uint64_t reserved2 : 48;
    };

    uint64_t flags;
} ia32_debugctl_register;


/**
 * @brief SMRR Base Address <b>(Writeable only in SMM)</b>
 *
 * SMRR Base Address. Base address of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP.SMRR[11] = 1
 */
#define IA32_SMRR_PHYSBASE                                           0x000001F2
typedef union
{
    struct
    {
        /**
         * @brief Type
         *
         * [Bits 7:0] Type. Specifies memory type of the range.
         */
        uint64_t type : 8;
#define IA32_SMRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_SMRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_SMRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        uint64_t reserved1 : 4;

        /**
         * [Bits 31:12] SMRR physical Base Address.
         */
        uint64_t smrr_physical_base_address : 20;
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT            12
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG           0xFFFFF000
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK           0xFFFFF
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_)             (((_) >> 12) & 0xFFFFF)
        uint64_t reserved2 : 32;
    };

    uint64_t flags;
} ia32_smrr_physbase_register;


/**
 * @brief SMRR Range Mask <b>(Writeable only in SMM)</b>
 *
 * Range Mask of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP[SMRR] = 1
 */
#define IA32_SMRR_PHYSMASK                                           0x000001F3
typedef union
{
    struct
    {
        uint64_t reserved1 : 11;

        /**
         * [Bit 11] Enable range mask.
         */
        uint64_t enable_range_mask : 1;
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_BIT                     11
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_FLAG                    0x800
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_MASK                    0x01
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_)                      (((_) >> 11) & 0x01)

        /**
         * [Bits 31:12] SMRR address range mask.
         */
        uint64_t smrr_address_range_mask : 20;
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT               12
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG              0xFFFFF000
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK              0xFFFFF
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_)                (((_) >> 12) & 0xFFFFF)
        uint64_t reserved2 : 32;
    };

    uint64_t flags;
} ia32_smrr_physmask_register;


/**
 * DCA Capability.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_PLATFORM_DCA_CAP                                        0x000001F8

 /**
  * If set, CPU supports Prefetch-Hint type.
  *
  * @remarks If CPUID.01H: ECX[18] = 1
  */
#define IA32_CPU_DCA_CAP                                             0x000001F9

  /**
   * DCA type 0 Status and Control register.
   *
   * @remarks If CPUID.01H: ECX[18] = 1
   */
#define IA32_DCA_0_CAP                                               0x000001FA
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set by HW when DCA is fuseenabled and no defeatures are set.
         */
        uint64_t dca_active : 1;
#define IA32_DCA_0_CAP_DCA_ACTIVE_BIT                                0
#define IA32_DCA_0_CAP_DCA_ACTIVE_FLAG                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE_MASK                               0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE(_)                                 (((_) >> 0) & 0x01)

        /**
         * [Bits 2:1] TRANSACTION.
         */
        uint64_t transaction : 2;
#define IA32_DCA_0_CAP_TRANSACTION_BIT                               1
#define IA32_DCA_0_CAP_TRANSACTION_FLAG                              0x06
#define IA32_DCA_0_CAP_TRANSACTION_MASK                              0x03
#define IA32_DCA_0_CAP_TRANSACTION(_)                                (((_) >> 1) & 0x03)

        /**
         * [Bits 6:3] DCA_TYPE.
         */
        uint64_t dca_type : 4;
#define IA32_DCA_0_CAP_DCA_TYPE_BIT                                  3
#define IA32_DCA_0_CAP_DCA_TYPE_FLAG                                 0x78
#define IA32_DCA_0_CAP_DCA_TYPE_MASK                                 0x0F
#define IA32_DCA_0_CAP_DCA_TYPE(_)                                   (((_) >> 3) & 0x0F)

        /**
         * [Bits 10:7] DCA_QUEUE_SIZE.
         */
        uint64_t dca_queue_size : 4;
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT                            7
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG                           0x780
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK                           0x0F
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_)                             (((_) >> 7) & 0x0F)
        uint64_t reserved1 : 2;

        /**
         * [Bits 16:13] Writes will update the register but have no HW side-effect.
         */
        uint64_t dca_delay : 4;
#define IA32_DCA_0_CAP_DCA_DELAY_BIT                                 13
#define IA32_DCA_0_CAP_DCA_DELAY_FLAG                                0x1E000
#define IA32_DCA_0_CAP_DCA_DELAY_MASK                                0x0F
#define IA32_DCA_0_CAP_DCA_DELAY(_)                                  (((_) >> 13) & 0x0F)
        uint64_t reserved2 : 7;

        /**
         * [Bit 24] SW can request DCA block by setting this bit.
         */
        uint64_t sw_block : 1;
#define IA32_DCA_0_CAP_SW_BLOCK_BIT                                  24
#define IA32_DCA_0_CAP_SW_BLOCK_FLAG                                 0x1000000
#define IA32_DCA_0_CAP_SW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_SW_BLOCK(_)                                   (((_) >> 24) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * [Bit 26] Set when DCA is blocked by HW (e.g. CR0.CD = 1).
         */
        uint64_t hw_block : 1;
#define IA32_DCA_0_CAP_HW_BLOCK_BIT                                  26
#define IA32_DCA_0_CAP_HW_BLOCK_FLAG                                 0x4000000
#define IA32_DCA_0_CAP_HW_BLOCK_MASK                                 0x01
#define IA32_DCA_0_CAP_HW_BLOCK(_)                                   (((_) >> 26) & 0x01)
        uint64_t reserved4 : 37;
    };

    uint64_t flags;
} ia32_dca_0_cap_register;

/**
 * @defgroup ia32_mtrr_physbase \
 *           IA32_MTRR_PHYSBASE(n)
 *
 * IA32_MTRR_PHYSBASE(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Specifies the memory type for the range.
         */
        uint64_t type : 8;
#define IA32_MTRR_PHYSBASE_TYPE_BIT                                  0
#define IA32_MTRR_PHYSBASE_TYPE_FLAG                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE_MASK                                 0xFF
#define IA32_MTRR_PHYSBASE_TYPE(_)                                   (((_) >> 0) & 0xFF)
        uint64_t reserved1 : 4;

        /**
         * [Bits 47:12] Specifies the base address of the address range. This 24-bit value, in the case where MAXPHYADDR is 36
         * bits, is extended by 12 bits at the low end to form the base address (this automatically aligns the address on a 4-KByte
         * boundary).
         */
        uint64_t page_frame_number : 36;
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved2 : 16;
    };

    uint64_t flags;
} ia32_mtrr_physbase_register;

#define IA32_MTRR_PHYSBASE0                                          0x00000200
#define IA32_MTRR_PHYSBASE1                                          0x00000202
#define IA32_MTRR_PHYSBASE2                                          0x00000204
#define IA32_MTRR_PHYSBASE3                                          0x00000206
#define IA32_MTRR_PHYSBASE4                                          0x00000208
#define IA32_MTRR_PHYSBASE5                                          0x0000020A
#define IA32_MTRR_PHYSBASE6                                          0x0000020C
#define IA32_MTRR_PHYSBASE7                                          0x0000020E
#define IA32_MTRR_PHYSBASE8                                          0x00000210
#define IA32_MTRR_PHYSBASE9                                          0x00000212
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_physmask \
  *           IA32_MTRR_PHYSMASK(n)
  *
  * IA32_MTRR_PHYSMASK(0-9).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
  * @{
  */
typedef union
{
    struct
    {
        uint64_t reserved1 : 11;

        /**
         * [Bit 11] Enables the register pair when set; disables register pair when clear.
         */
        uint64_t valid : 1;
#define IA32_MTRR_PHYSMASK_VALID_BIT                                 11
#define IA32_MTRR_PHYSMASK_VALID_FLAG                                0x800
#define IA32_MTRR_PHYSMASK_VALID_MASK                                0x01
#define IA32_MTRR_PHYSMASK_VALID(_)                                  (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Specifies a mask (24 bits if the maximum physical address size is 36 bits, 28 bits if the maximum physical
         * address size is 40 bits). The mask determines the range of the region being mapped, according to the following
         * relationships:
         * - Address_Within_Range AND PhysMask = PhysBase AND PhysMask
         * - This value is extended by 12 bits at the low end to form the mask value.
         * - The width of the PhysMask field depends on the maximum physical address size supported by the processor.
         * CPUID.80000008H reports the maximum physical address size supported by the processor. If CPUID.80000008H is not
         * available, software may assume that the processor supports a 36-bit physical address size.
         *
         * @see Vol3A[11.11.3(Example Base and Mask Calculations)]
         */
        uint64_t page_frame_number : 36;
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT                     12
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG                    0xFFFFFFFFF000
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK                    0xFFFFFFFFF
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_)                      (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved2 : 16;
    };

    uint64_t flags;
} ia32_mtrr_physmask_register;

#define IA32_MTRR_PHYSMASK0                                          0x00000201
#define IA32_MTRR_PHYSMASK1                                          0x00000203
#define IA32_MTRR_PHYSMASK2                                          0x00000205
#define IA32_MTRR_PHYSMASK3                                          0x00000207
#define IA32_MTRR_PHYSMASK4                                          0x00000209
#define IA32_MTRR_PHYSMASK5                                          0x0000020B
#define IA32_MTRR_PHYSMASK6                                          0x0000020D
#define IA32_MTRR_PHYSMASK7                                          0x0000020F
#define IA32_MTRR_PHYSMASK8                                          0x00000211
#define IA32_MTRR_PHYSMASK9                                          0x00000213
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_fix \
  *           IA32_MTRR_FIX(x)
  *
  * IA32_MTRR_FIX(x).
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  * @see Vol3A[11.11.2.2(Fixed Range MTRRs)]
  * @{
  */
  /**
   * @defgroup ia32_mtrr_fix64k \
   *           IA32_MTRR_FIX64K(x)
   *
   * IA32_MTRR_FIX64K(x).
   * @{
   */
#define IA32_MTRR_FIX64K_BASE                                        0x00000000
#define IA32_MTRR_FIX64K_SIZE                                        0x00010000
#define IA32_MTRR_FIX64K_00000                                       0x00000250
   /**
    * @}
    */

    /**
     * @defgroup ia32_mtrr_fix16k \
     *           IA32_MTRR_FIX16K(x)
     *
     * IA32_MTRR_FIX16K(x).
     * @{
     */
#define IA32_MTRR_FIX16K_BASE                                        0x00080000
#define IA32_MTRR_FIX16K_SIZE                                        0x00004000
#define IA32_MTRR_FIX16K_80000                                       0x00000258
#define IA32_MTRR_FIX16K_A0000                                       0x00000259
     /**
      * @}
      */

      /**
       * @defgroup ia32_mtrr_fix4k \
       *           IA32_MTRR_FIX4K(x)
       *
       * IA32_MTRR_FIX4K(x).
       * @{
       */
#define IA32_MTRR_FIX4K_BASE                                         0x000C0000
#define IA32_MTRR_FIX4K_SIZE                                         0x00001000
#define IA32_MTRR_FIX4K_C0000                                        0x00000268
#define IA32_MTRR_FIX4K_C8000                                        0x00000269
#define IA32_MTRR_FIX4K_D0000                                        0x0000026A
#define IA32_MTRR_FIX4K_D8000                                        0x0000026B
#define IA32_MTRR_FIX4K_E0000                                        0x0000026C
#define IA32_MTRR_FIX4K_E8000                                        0x0000026D
#define IA32_MTRR_FIX4K_F0000                                        0x0000026E
#define IA32_MTRR_FIX4K_F8000                                        0x0000026F
       /**
        * @}
        */

        /**
         * Architecture defined number of fixed range MTRRs (1 for 64k, 2 for 16k, 8 for 4k).
         */
#define IA32_MTRR_FIX_COUNT                                          ((1 + 2 + 8) * 8)

         /**
          * Architecture defined number of variable range MTRRs. See: Table 2-2. IA-32 Architectural MSRs
          *
          * @see Vol3A[2.1(ARCHITECTURAL MSRS)]
          */
#define IA32_MTRR_VARIABLE_COUNT                                     0x0000000A

          /**
           * A size of array to store all possible MTRRs.
           */
#define IA32_MTRR_COUNT                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
           /**
            * @}
            */


            /**
             * IA32_PAT.
             *
             * @remarks If CPUID.01H: EDX.MTRR[16] = 1
             */
#define IA32_PAT                                                     0x00000277
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] PA0.
         */
        uint64_t pa0 : 3;
#define IA32_PAT_PA0_BIT                                             0
#define IA32_PAT_PA0_FLAG                                            0x07
#define IA32_PAT_PA0_MASK                                            0x07
#define IA32_PAT_PA0(_)                                              (((_) >> 0) & 0x07)
        uint64_t reserved1 : 5;

        /**
         * [Bits 10:8] PA1.
         */
        uint64_t pa1 : 3;
#define IA32_PAT_PA1_BIT                                             8
#define IA32_PAT_PA1_FLAG                                            0x700
#define IA32_PAT_PA1_MASK                                            0x07
#define IA32_PAT_PA1(_)                                              (((_) >> 8) & 0x07)
        uint64_t reserved2 : 5;

        /**
         * [Bits 18:16] PA2.
         */
        uint64_t pa2 : 3;
#define IA32_PAT_PA2_BIT                                             16
#define IA32_PAT_PA2_FLAG                                            0x70000
#define IA32_PAT_PA2_MASK                                            0x07
#define IA32_PAT_PA2(_)                                              (((_) >> 16) & 0x07)
        uint64_t reserved3 : 5;

        /**
         * [Bits 26:24] PA3.
         */
        uint64_t pa3 : 3;
#define IA32_PAT_PA3_BIT                                             24
#define IA32_PAT_PA3_FLAG                                            0x7000000
#define IA32_PAT_PA3_MASK                                            0x07
#define IA32_PAT_PA3(_)                                              (((_) >> 24) & 0x07)
        uint64_t reserved4 : 5;

        /**
         * [Bits 34:32] PA4.
         */
        uint64_t pa4 : 3;
#define IA32_PAT_PA4_BIT                                             32
#define IA32_PAT_PA4_FLAG                                            0x700000000
#define IA32_PAT_PA4_MASK                                            0x07
#define IA32_PAT_PA4(_)                                              (((_) >> 32) & 0x07)
        uint64_t reserved5 : 5;

        /**
         * [Bits 42:40] PA5.
         */
        uint64_t pa5 : 3;
#define IA32_PAT_PA5_BIT                                             40
#define IA32_PAT_PA5_FLAG                                            0x70000000000
#define IA32_PAT_PA5_MASK                                            0x07
#define IA32_PAT_PA5(_)                                              (((_) >> 40) & 0x07)
        uint64_t reserved6 : 5;

        /**
         * [Bits 50:48] PA6.
         */
        uint64_t pa6 : 3;
#define IA32_PAT_PA6_BIT                                             48
#define IA32_PAT_PA6_FLAG                                            0x7000000000000
#define IA32_PAT_PA6_MASK                                            0x07
#define IA32_PAT_PA6(_)                                              (((_) >> 48) & 0x07)
        uint64_t reserved7 : 5;

        /**
         * [Bits 58:56] PA7.
         */
        uint64_t pa7 : 3;
#define IA32_PAT_PA7_BIT                                             56
#define IA32_PAT_PA7_FLAG                                            0x700000000000000
#define IA32_PAT_PA7_MASK                                            0x07
#define IA32_PAT_PA7(_)                                              (((_) >> 56) & 0x07)
        uint64_t reserved8 : 5;
    };

    uint64_t flags;
} ia32_pat_register;

/**
 * @defgroup ia32_mc_ctl2 \
 *           IA32_MC(i)_CTL2
 *
 * MSR to enable/disable CMCI capability for bank n.
 *
 * @remarks If IA32_MCG_CAP[10] = 1 && IA32_MCG_CAP[7:0] > n
 * @see Vol3B[15.3.2.5(IA32_MCi_CTL2 MSRs)]
 * @{
 */
#define IA32_MC0_CTL2                                                0x00000280
#define IA32_MC1_CTL2                                                0x00000281
#define IA32_MC2_CTL2                                                0x00000282
#define IA32_MC3_CTL2                                                0x00000283
#define IA32_MC4_CTL2                                                0x00000284
#define IA32_MC5_CTL2                                                0x00000285
#define IA32_MC6_CTL2                                                0x00000286
#define IA32_MC7_CTL2                                                0x00000287
#define IA32_MC8_CTL2                                                0x00000288
#define IA32_MC9_CTL2                                                0x00000289
#define IA32_MC10_CTL2                                               0x0000028A
#define IA32_MC11_CTL2                                               0x0000028B
#define IA32_MC12_CTL2                                               0x0000028C
#define IA32_MC13_CTL2                                               0x0000028D
#define IA32_MC14_CTL2                                               0x0000028E
#define IA32_MC15_CTL2                                               0x0000028F
#define IA32_MC16_CTL2                                               0x00000290
#define IA32_MC17_CTL2                                               0x00000291
#define IA32_MC18_CTL2                                               0x00000292
#define IA32_MC19_CTL2                                               0x00000293
#define IA32_MC20_CTL2                                               0x00000294
#define IA32_MC21_CTL2                                               0x00000295
#define IA32_MC22_CTL2                                               0x00000296
#define IA32_MC23_CTL2                                               0x00000297
#define IA32_MC24_CTL2                                               0x00000298
#define IA32_MC25_CTL2                                               0x00000299
#define IA32_MC26_CTL2                                               0x0000029A
#define IA32_MC27_CTL2                                               0x0000029B
#define IA32_MC28_CTL2                                               0x0000029C
#define IA32_MC29_CTL2                                               0x0000029D
#define IA32_MC30_CTL2                                               0x0000029E
#define IA32_MC31_CTL2                                               0x0000029F
typedef union
{
    struct
    {
        /**
         * [Bits 14:0] Corrected error count threshold.
         */
        uint64_t corrected_error_count_threshold : 15;
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT             0
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK            0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_)              (((_) >> 0) & 0x7FFF)
        uint64_t reserved1 : 15;

        /**
         * [Bit 30] CMCI_EN.
         */
        uint64_t cmci_en : 1;
#define IA32_MC_CTL2_CMCI_EN_BIT                                     30
#define IA32_MC_CTL2_CMCI_EN_FLAG                                    0x40000000
#define IA32_MC_CTL2_CMCI_EN_MASK                                    0x01
#define IA32_MC_CTL2_CMCI_EN(_)                                      (((_) >> 30) & 0x01)
        uint64_t reserved2 : 33;
    };

    uint64_t flags;
} ia32_mc_ctl2_register;

/**
 * @}
 */


 /**
  * IA32_MTRR_DEF_TYPE.
  *
  * @remarks If CPUID.01H: EDX.MTRR[12] = 1
  */
#define IA32_MTRR_DEF_TYPE                                           0x000002FF
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Default Memory Type.
         */
        uint64_t default_memory_type : 3;
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT                   0
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_)                    (((_) >> 0) & 0x07)
        uint64_t reserved1 : 7;

        /**
         * [Bit 10] Fixed Range MTRR Enable.
         */
        uint64_t fixed_range_mtrr_enable : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT               10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG              0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK              0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_)                (((_) >> 10) & 0x01)

        /**
         * [Bit 11] MTRR Enable.
         */
        uint64_t mtrr_enable : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT                           11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG                          0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK                          0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_)                            (((_) >> 11) & 0x01)
        uint64_t reserved2 : 52;
    };

    uint64_t flags;
} ia32_mtrr_def_type_register;

/**
 * @defgroup ia32_fixed_ctr \
 *           IA32_FIXED_CTR(n)
 *
 * Fixed-Function Performance Counter n.
 *
 * @remarks If CPUID.0AH: EDX[4:0] > n
 * @{
 */
 /**
  * Counts Instr_Retired.Any.
  */
#define IA32_FIXED_CTR0                                              0x00000309

  /**
   * Counts CPU_CLK_Unhalted.Core
   */
#define IA32_FIXED_CTR1                                              0x0000030A

   /**
    * Counts CPU_CLK_Unhalted.Ref
    */
#define IA32_FIXED_CTR2                                              0x0000030B
    /**
     * @}
     */


     /**
      * Read Only MSR that enumerates the existence of performance monitoring features.
      *
      * @remarks If CPUID.01H: ECX[15] = 1
      */
#define IA32_PERF_CAPABILITIES                                       0x00000345
typedef union
{
    struct
    {
        /**
         * [Bits 5:0] LBR format.
         */
        uint64_t lbr_format : 6;
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT                        0
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK                       0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT(_)                         (((_) >> 0) & 0x3F)

        /**
         * [Bit 6] PEBS Trap.
         */
        uint64_t pebs_trap : 1;
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT                         6
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG                        0x40
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK                        0x01
#define IA32_PERF_CAPABILITIES_PEBS_TRAP(_)                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] PEBSSaveArchRegs.
         */
        uint64_t pebs_save_arch_regs : 1;
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT               7
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG              0x80
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK              0x01
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_)                (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] PEBS Record Format.
         */
        uint64_t pebs_record_format : 4;
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT                8
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG               0xF00
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK               0x0F
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_)                 (((_) >> 8) & 0x0F)

        /**
         * [Bit 12] Freeze while SMM is supported.
         */
        uint64_t freeze_while_smm_is_supported : 1;
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT     12
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG    0x1000
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK    0x01
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_)      (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Full width of counter writable via IA32_A_PMCx.
         */
        uint64_t full_width_counter_write : 1;
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT          13
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG         0x2000
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK         0x01
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_)           (((_) >> 13) & 0x01)
        uint64_t reserved1 : 50;
    };

    uint64_t flags;
} ia32_perf_capabilities_register;


/**
 * @brief Fixed-Function Performance Counter Control <b>(R/W)</b>
 *
 * Fixed-Function Performance Counter Control. Counter increments while the results of ANDing respective enable bit in
 * IA32_PERF_GLOBAL_CTRL with the corresponding OS or USR bits in this MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 1
 */
#define IA32_FIXED_CTR_CTRL                                          0x0000038D
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN0_OS: Enable Fixed Counter 0 to count while CPL = 0.
         */
        uint64_t en0_os : 1;
#define IA32_FIXED_CTR_CTRL_EN0_OS_BIT                               0
#define IA32_FIXED_CTR_CTRL_EN0_OS_FLAG                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS(_)                                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN0_Usr: Enable Fixed Counter 0 to count while CPL > 0.
         */
        uint64_t en0_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN0_USR_BIT                              1
#define IA32_FIXED_CTR_CTRL_EN0_USR_FLAG                             0x02
#define IA32_FIXED_CTR_CTRL_EN0_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_USR(_)                               (((_) >> 1) & 0x01)

        /**
         * [Bit 2] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         */
        uint64_t any_thread0 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT                          2
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG                         0x04
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0(_)                           (((_) >> 2) & 0x01)

        /**
         * [Bit 3] EN0_PMI: Enable PMI when fixed counter 0 overflows.
         */
        uint64_t en0_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN0_PMI_BIT                              3
#define IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG                             0x08
#define IA32_FIXED_CTR_CTRL_EN0_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN0_PMI(_)                               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] EN1_OS: Enable Fixed Counter 1 to count while CPL = 0.
         */
        uint64_t en1_os : 1;
#define IA32_FIXED_CTR_CTRL_EN1_OS_BIT                               4
#define IA32_FIXED_CTR_CTRL_EN1_OS_FLAG                              0x10
#define IA32_FIXED_CTR_CTRL_EN1_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN1_OS(_)                                (((_) >> 4) & 0x01)

        /**
         * [Bit 5] EN1_Usr: Enable Fixed Counter 1 to count while CPL > 0.
         */
        uint64_t en1_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN1_USR_BIT                              5
#define IA32_FIXED_CTR_CTRL_EN1_USR_FLAG                             0x20
#define IA32_FIXED_CTR_CTRL_EN1_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_USR(_)                               (((_) >> 5) & 0x01)

        /**
         * [Bit 6] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        uint64_t any_thread1 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT                          6
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG                         0x40
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1(_)                           (((_) >> 6) & 0x01)

        /**
         * [Bit 7] EN1_PMI: Enable PMI when fixed counter 1 overflows.
         */
        uint64_t en1_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN1_PMI_BIT                              7
#define IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG                             0x80
#define IA32_FIXED_CTR_CTRL_EN1_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN1_PMI(_)                               (((_) >> 7) & 0x01)

        /**
         * [Bit 8] EN2_OS: Enable Fixed Counter 2 to count while CPL = 0.
         */
        uint64_t en2_os : 1;
#define IA32_FIXED_CTR_CTRL_EN2_OS_BIT                               8
#define IA32_FIXED_CTR_CTRL_EN2_OS_FLAG                              0x100
#define IA32_FIXED_CTR_CTRL_EN2_OS_MASK                              0x01
#define IA32_FIXED_CTR_CTRL_EN2_OS(_)                                (((_) >> 8) & 0x01)

        /**
         * [Bit 9] EN2_Usr: Enable Fixed Counter 2 to count while CPL > 0.
         */
        uint64_t en2_usr : 1;
#define IA32_FIXED_CTR_CTRL_EN2_USR_BIT                              9
#define IA32_FIXED_CTR_CTRL_EN2_USR_FLAG                             0x200
#define IA32_FIXED_CTR_CTRL_EN2_USR_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_USR(_)                               (((_) >> 9) & 0x01)

        /**
         * [Bit 10] AnyThread: When set to 1, it enables counting the associated event conditions occurring across all logical
         * processors sharing a processor core. When set to 0, the counter only increments the associated event conditions
         * occurring in the logical processor which programmed the MSR.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        uint64_t any_thread2 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT                          10
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG                         0x400
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK                         0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2(_)                           (((_) >> 10) & 0x01)

        /**
         * [Bit 11] EN2_PMI: Enable PMI when fixed counter 2 overflows.
         */
        uint64_t en2_pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN2_PMI_BIT                              11
#define IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG                             0x800
#define IA32_FIXED_CTR_CTRL_EN2_PMI_MASK                             0x01
#define IA32_FIXED_CTR_CTRL_EN2_PMI(_)                               (((_) >> 11) & 0x01)
        uint64_t reserved1 : 52;
    };

    uint64_t flags;
} ia32_fixed_ctr_ctrl_register;


/**
 * Global Performance Counter Status.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_STATUS                                      0x0000038E
typedef union
{
    struct
    {
        /**
         * [Bit 0] Ovf_PMC0: Overflow status of IA32_PMC0.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 0
         */
        uint64_t ovf_pmc0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_BIT                         0
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_FLAG                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_)                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Ovf_PMC1: Overflow status of IA32_PMC1.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 1
         */
        uint64_t ovf_pmc1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT                         1
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG                        0x02
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_)                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Ovf_PMC2: Overflow status of IA32_PMC2.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 2
         */
        uint64_t ovf_pmc2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT                         2
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG                        0x04
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_)                          (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Ovf_PMC3: Overflow status of IA32_PMC3.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > 3
         */
        uint64_t ovf_pmc3 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT                         3
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG                        0x08
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_)                          (((_) >> 3) & 0x01)
        uint64_t reserved1 : 28;

        /**
         * [Bit 32] Ovf_FixedCtr0: Overflow status of IA32_FIXED_CTR0.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        uint64_t ovf_fixedctr0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT                    32
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG                   0x100000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_)                     (((_) >> 32) & 0x01)

        /**
         * [Bit 33] Ovf_FixedCtr1: Overflow status of IA32_FIXED_CTR1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        uint64_t ovf_fixedctr1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT                    33
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG                   0x200000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_)                     (((_) >> 33) & 0x01)

        /**
         * [Bit 34] Ovf_FixedCtr2: Overflow status of IA32_FIXED_CTR2.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 1
         */
        uint64_t ovf_fixedctr2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT                    34
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG                   0x400000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK                   0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_)                     (((_) >> 34) & 0x01)
        uint64_t reserved2 : 20;

        /**
         * [Bit 55] Trace_ToPA_PMI: A PMI occurred due to a ToPA entry memory buffer that was completely filled.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        uint64_t trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT                   55
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG                  0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_)                    (((_) >> 55) & 0x01)
        uint64_t reserved3 : 2;

        /**
         * [Bit 58] LBR_Frz. LBRs are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_LBR_ON_PMI=1.
         * * The LBR stack overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT                          58
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG                         0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_)                           (((_) >> 58) & 0x01)

        /**
         * [Bit 59] CTR_Frz. Performance counters in the core PMU are frozen due to:
         * * IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI=1.
         * * One or more core PMU counters overflowed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT                          59
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG                         0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_)                           (((_) >> 59) & 0x01)

        /**
         * [Bit 60] ASCI: Data in the performance counters in the core PMU may include contributions from the direct or indirect
         * operation Intel SGX to protect an enclave.
         *
         * @remarks If CPUID.(EAX=07H, ECX=0):EBX[2] = 1
         */
        uint64_t asci : 1;
#define IA32_PERF_GLOBAL_STATUS_ASCI_BIT                             60
#define IA32_PERF_GLOBAL_STATUS_ASCI_FLAG                            0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_ASCI_MASK                            0x01
#define IA32_PERF_GLOBAL_STATUS_ASCI(_)                              (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Uncore counter overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 2
         */
        uint64_t ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT                       61
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG                      0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK                      0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_)                        (((_) >> 61) & 0x01)

        /**
         * [Bit 62] OvfBuf: DS SAVE area Buffer overflow status.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        uint64_t ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT                          62
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG                         0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK                         0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF(_)                           (((_) >> 62) & 0x01)

        /**
         * [Bit 63] CondChgd: Status bits of this register have changed.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        uint64_t cond_chgd : 1;
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT                        63
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK                       0x01
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD(_)                         (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ia32_perf_global_status_register;


/**
 * @brief Global Performance Counter Control <b>(R/W)</b>
 *
 * Global Performance Counter Control. Counter increments while the result of ANDing the respective enable bit in this MSR
 * with the corresponding OS or USR bits in the general-purpose or fixed counter control MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_CTRL                                        0x0000038F
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] EN_PMC(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        uint64_t en_pmcn : 32;
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_BIT                            0
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_FLAG                           0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_MASK                           0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN(_)                             (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 63:32] EN_FIXED_CTR(n). Enable bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        uint64_t en_fixed_ctrn : 32;
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_BIT                      32
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_FLAG                     0xFFFFFFFF00000000
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_MASK                     0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN(_)                       (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_perf_global_ctrl_register;


/**
 * Global Performance Counter Overflow Reset Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_RESET                                0x00000390
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to clear Ovf_PMC(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        uint64_t clear_ovf_pmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT             0
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK            0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_)              (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to clear Ovf_FIXED_CTR(n) bit. Clear bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        uint64_t clear_ovf_fixed_ctrn : 3;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT       32
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG      0x700000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK      0x07
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_)        (((_) >> 32) & 0x07)
        uint64_t reserved1 : 20;

        /**
         * [Bit 55] Set 1 to clear Trace_ToPA_PMI bit.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
         */
        uint64_t clear_trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT       55
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG      0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK      0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_)        (((_) >> 55) & 0x01)
        uint64_t reserved2 : 2;

        /**
         * [Bit 58] Set 1 to clear LBR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t clear_lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT              58
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG             0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_)               (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to clear CTR_Frz bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t clear_ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT              59
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG             0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_)               (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to clear ASCI bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t clear_asci : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT                 60
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG                0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK                0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_)                  (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to clear Ovf_Uncore bit.
         *
         * @remarks 06_2EH
         */
        uint64_t clear_ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT           61
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG          0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK          0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_)            (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to clear OvfBuf bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        uint64_t clear_ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT              62
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG             0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK             0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_)               (((_) >> 62) & 0x01)

        /**
         * [Bit 63] Set 1 to clear CondChgd bit.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 0
         */
        uint64_t clear_cond_chgd : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT            63
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG           0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK           0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_)             (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ia32_perf_global_status_reset_register;


/**
 * Global Performance Counter Overflow Set Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_SET                                  0x00000391
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Set 1 to cause Ovf_PMC(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        uint64_t ovf_pmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT                     0
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK                    0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_)                      (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] Set 1 to cause Ovf_FIXED_CTR(n) = 1. Set bitmask. Only the first n-1 bits are valid. Bits 31:n are
         * reserved.
         *
         * @remarks If CPUID.0AH: EDX[4:0] > n
         */
        uint64_t ovf_fixed_ctrn : 3;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT               32
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG              0x700000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK              0x07
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_)                (((_) >> 32) & 0x07)
        uint64_t reserved1 : 20;

        /**
         * [Bit 55] Set 1 to cause Trace_ToPA_PMI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t trace_topa_pmi : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT               55
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG              0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK              0x01
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_)                (((_) >> 55) & 0x01)
        uint64_t reserved2 : 2;

        /**
         * [Bit 58] Set 1 to cause LBR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t lbr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT                      58
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG                     0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_)                       (((_) >> 58) & 0x01)

        /**
         * [Bit 59] Set 1 to cause CTR_Frz = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t ctr_frz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT                      59
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG                     0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_)                       (((_) >> 59) & 0x01)

        /**
         * [Bit 60] Set 1 to cause ASCI = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t asci : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT                         60
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG                        0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK                        0x01
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI(_)                          (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Set 1 to cause Ovf_Uncore = 1.
         *
         * @remarks 06_2EH
         */
        uint64_t ovf_uncore : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT                   61
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG                  0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK                  0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_)                    (((_) >> 61) & 0x01)

        /**
         * [Bit 62] Set 1 to cause OvfBuf = 1.
         *
         * @remarks If CPUID.0AH: EAX[7:0] > 3
         */
        uint64_t ovf_buf : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT                      62
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG                     0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK                     0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_)                       (((_) >> 62) & 0x01)
        uint64_t reserved3 : 1;
    };

    uint64_t flags;
} ia32_perf_global_status_set_register;


/**
 * Indicator that core perfmon interface is in use.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_INUSE                                       0x00000392
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] IA32_PERFEVTSEL(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         *
         * @remarks If CPUID.0AH: EAX[15:8] > n
         */
        uint64_t ia32_perfevtseln_in_use : 32;
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT           0
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK          0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_)            (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 34:32] IA32_FIXED_CTR(n) in use. Status bitmask. Only the first n-1 bits are valid. Bits 31:n are reserved.
         */
        uint64_t ia32_fixed_ctrn_in_use : 3;
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT            32
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG           0x700000000
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK           0x07
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_)             (((_) >> 32) & 0x07)
        uint64_t reserved1 : 28;

        /**
         * [Bit 63] PMI in use.
         */
        uint64_t pmi_in_use : 1;
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT                        63
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG                       0x8000000000000000
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK                       0x01
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_)                         (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ia32_perf_global_inuse_register;


/**
 * PEBS Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PEBS_ENABLE                                             0x000003F1
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable PEBS on IA32_PMC0.
         *
         * @remarks 06_0FH
         */
        uint64_t enable_pebs : 1;
#define IA32_PEBS_ENABLE_ENABLE_PEBS_BIT                             0
#define IA32_PEBS_ENABLE_ENABLE_PEBS_FLAG                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS_MASK                            0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bits 3:1] Reserved or model specific.
         */
        uint64_t reservedormodelspecific1 : 3;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT                1
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG               0x0E
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK               0x07
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_)                 (((_) >> 1) & 0x07)
        uint64_t reserved1 : 28;

        /**
         * [Bits 35:32] Reserved or model specific.
         */
        uint64_t reservedormodelspecific2 : 4;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT                32
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG               0xF00000000
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK               0x0F
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_)                 (((_) >> 32) & 0x0F)
        uint64_t reserved2 : 28;
    };

    uint64_t flags;
} ia32_pebs_enable_register;

/**
 * @defgroup ia32_mc_ctl \
 *           IA32_MC(i)_CTL
 *
 * IA32_MC(0-28)_CTL.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_CTL                                                 0x00000400
#define IA32_MC1_CTL                                                 0x00000404
#define IA32_MC2_CTL                                                 0x00000408
#define IA32_MC3_CTL                                                 0x0000040C
#define IA32_MC4_CTL                                                 0x00000410
#define IA32_MC5_CTL                                                 0x00000414
#define IA32_MC6_CTL                                                 0x00000418
#define IA32_MC7_CTL                                                 0x0000041C
#define IA32_MC8_CTL                                                 0x00000420
#define IA32_MC9_CTL                                                 0x00000424
#define IA32_MC10_CTL                                                0x00000428
#define IA32_MC11_CTL                                                0x0000042C
#define IA32_MC12_CTL                                                0x00000430
#define IA32_MC13_CTL                                                0x00000434
#define IA32_MC14_CTL                                                0x00000438
#define IA32_MC15_CTL                                                0x0000043C
#define IA32_MC16_CTL                                                0x00000440
#define IA32_MC17_CTL                                                0x00000444
#define IA32_MC18_CTL                                                0x00000448
#define IA32_MC19_CTL                                                0x0000044C
#define IA32_MC20_CTL                                                0x00000450
#define IA32_MC21_CTL                                                0x00000454
#define IA32_MC22_CTL                                                0x00000458
#define IA32_MC23_CTL                                                0x0000045C
#define IA32_MC24_CTL                                                0x00000460
#define IA32_MC25_CTL                                                0x00000464
#define IA32_MC26_CTL                                                0x00000468
#define IA32_MC27_CTL                                                0x0000046C
#define IA32_MC28_CTL                                                0x00000470
 /**
  * @}
  */

  /**
   * @defgroup ia32_mc_status \
   *           IA32_MC(i)_STATUS
   *
   * IA32_MC(0-28)_STATUS.
   *
   * @remarks If IA32_MCG_CAP.CNT > n
   * @{
   */
#define IA32_MC0_STATUS                                              0x00000401
#define IA32_MC1_STATUS                                              0x00000405
#define IA32_MC2_STATUS                                              0x00000409
#define IA32_MC3_STATUS                                              0x0000040D
#define IA32_MC4_STATUS                                              0x00000411
#define IA32_MC5_STATUS                                              0x00000415
#define IA32_MC6_STATUS                                              0x00000419
#define IA32_MC7_STATUS                                              0x0000041D
#define IA32_MC8_STATUS                                              0x00000421
#define IA32_MC9_STATUS                                              0x00000425
#define IA32_MC10_STATUS                                             0x00000429
#define IA32_MC11_STATUS                                             0x0000042D
#define IA32_MC12_STATUS                                             0x00000431
#define IA32_MC13_STATUS                                             0x00000435
#define IA32_MC14_STATUS                                             0x00000439
#define IA32_MC15_STATUS                                             0x0000043D
#define IA32_MC16_STATUS                                             0x00000441
#define IA32_MC17_STATUS                                             0x00000445
#define IA32_MC18_STATUS                                             0x00000449
#define IA32_MC19_STATUS                                             0x0000044D
#define IA32_MC20_STATUS                                             0x00000451
#define IA32_MC21_STATUS                                             0x00000455
#define IA32_MC22_STATUS                                             0x00000459
#define IA32_MC23_STATUS                                             0x0000045D
#define IA32_MC24_STATUS                                             0x00000461
#define IA32_MC25_STATUS                                             0x00000465
#define IA32_MC26_STATUS                                             0x00000469
#define IA32_MC27_STATUS                                             0x0000046D
#define IA32_MC28_STATUS                                             0x00000471
   /**
    * @}
    */

    /**
     * @defgroup ia32_mc_addr \
     *           IA32_MC(i)_ADDR
     *
     * IA32_MC(0-28)_ADDR.
     *
     * @remarks If IA32_MCG_CAP.CNT > n
     * @{
     */
#define IA32_MC0_ADDR                                                0x00000402
#define IA32_MC1_ADDR                                                0x00000406
#define IA32_MC2_ADDR                                                0x0000040A
#define IA32_MC3_ADDR                                                0x0000040E
#define IA32_MC4_ADDR                                                0x00000412
#define IA32_MC5_ADDR                                                0x00000416
#define IA32_MC6_ADDR                                                0x0000041A
#define IA32_MC7_ADDR                                                0x0000041E
#define IA32_MC8_ADDR                                                0x00000422
#define IA32_MC9_ADDR                                                0x00000426
#define IA32_MC10_ADDR                                               0x0000042A
#define IA32_MC11_ADDR                                               0x0000042E
#define IA32_MC12_ADDR                                               0x00000432
#define IA32_MC13_ADDR                                               0x00000436
#define IA32_MC14_ADDR                                               0x0000043A
#define IA32_MC15_ADDR                                               0x0000043E
#define IA32_MC16_ADDR                                               0x00000442
#define IA32_MC17_ADDR                                               0x00000446
#define IA32_MC18_ADDR                                               0x0000044A
#define IA32_MC19_ADDR                                               0x0000044E
#define IA32_MC20_ADDR                                               0x00000452
#define IA32_MC21_ADDR                                               0x00000456
#define IA32_MC22_ADDR                                               0x0000045A
#define IA32_MC23_ADDR                                               0x0000045E
#define IA32_MC24_ADDR                                               0x00000462
#define IA32_MC25_ADDR                                               0x00000466
#define IA32_MC26_ADDR                                               0x0000046A
#define IA32_MC27_ADDR                                               0x0000046E
#define IA32_MC28_ADDR                                               0x00000472
     /**
      * @}
      */

      /**
       * @defgroup ia32_mc_misc \
       *           IA32_MC(i)_MISC
       *
       * IA32_MC(0-28)_MISC.
       *
       * @remarks If IA32_MCG_CAP.CNT > n
       * @{
       */
#define IA32_MC0_MISC                                                0x00000403
#define IA32_MC1_MISC                                                0x00000407
#define IA32_MC2_MISC                                                0x0000040B
#define IA32_MC3_MISC                                                0x0000040F
#define IA32_MC4_MISC                                                0x00000413
#define IA32_MC5_MISC                                                0x00000417
#define IA32_MC6_MISC                                                0x0000041B
#define IA32_MC7_MISC                                                0x0000041F
#define IA32_MC8_MISC                                                0x00000423
#define IA32_MC9_MISC                                                0x00000427
#define IA32_MC10_MISC                                               0x0000042B
#define IA32_MC11_MISC                                               0x0000042F
#define IA32_MC12_MISC                                               0x00000433
#define IA32_MC13_MISC                                               0x00000437
#define IA32_MC14_MISC                                               0x0000043B
#define IA32_MC15_MISC                                               0x0000043F
#define IA32_MC16_MISC                                               0x00000443
#define IA32_MC17_MISC                                               0x00000447
#define IA32_MC18_MISC                                               0x0000044B
#define IA32_MC19_MISC                                               0x0000044F
#define IA32_MC20_MISC                                               0x00000453
#define IA32_MC21_MISC                                               0x00000457
#define IA32_MC22_MISC                                               0x0000045B
#define IA32_MC23_MISC                                               0x0000045F
#define IA32_MC24_MISC                                               0x00000463
#define IA32_MC25_MISC                                               0x00000467
#define IA32_MC26_MISC                                               0x0000046B
#define IA32_MC27_MISC                                               0x0000046F
#define IA32_MC28_MISC                                               0x00000473
       /**
        * @}
        */


        /**
         * Reporting Register of Basic VMX Capabilities.
         *
         * @remarks If CPUID.01H:ECX.[5] = 1
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         * @see Vol3D[A.1(Basic VMX Information)] (reference)
         */
#define IA32_VMX_BASIC                                               0x00000480
typedef union
{
    struct
    {
        /**
         * @brief VMCS revision identifier used by the processor
         *
         * [Bits 30:0] 31-bit VMCS revision identifier used by the processor. Processors that use the same VMCS revision identifier
         * use the same size for VMCS regions.
         */
        uint64_t vmcs_revision_id : 31;
#define IA32_VMX_BASIC_VMCS_REVISION_ID_BIT                          0
#define IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID_MASK                         0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID(_)                           (((_) >> 0) & 0x7FFFFFFF)

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        uint64_t must_be_zero : 1;
#define IA32_VMX_BASIC_MUST_BE_ZERO_BIT                              31
#define IA32_VMX_BASIC_MUST_BE_ZERO_FLAG                             0x80000000
#define IA32_VMX_BASIC_MUST_BE_ZERO_MASK                             0x01
#define IA32_VMX_BASIC_MUST_BE_ZERO(_)                               (((_) >> 31) & 0x01)

        /**
         * @brief Size of the VMCS
         *
         * [Bits 44:32] Report the number of bytes that software should allocate for the VMXON region and any VMCS region. It is a
         * value greater than 0 and at most 4096 (bit 44 is set if and only if bits 43:32 are clear).
         */
        uint64_t vmcs_size_in_bytes : 13;
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_BIT                        32
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_FLAG                       0x1FFF00000000
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_MASK                       0x1FFF
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES(_)                         (((_) >> 32) & 0x1FFF)
        uint64_t reserved1 : 3;

        /**
         * @brief Width of physical address used for the VMCS
         *        - 0 -> limited to the available amount of physical RAM
         *        - 1 -> within the first 4 GB
         *
         * [Bit 48] Indicates the width of the physical addresses that may be used for the VMXON region, each VMCS, and data
         * structures referenced by pointers in a VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions). If the bit
         * is 0, these addresses are limited to the processor's physical-address width.2 If the bit is 1, these addresses are
         * limited to 32 bits. This bit is always 0 for processors that support Intel 64 architecture.
         */
        uint64_t vmcs_physical_address_width : 1;
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT               48
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG              0x1000000000000
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK              0x01
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_)                (((_) >> 48) & 0x01)

        /**
         * @brief Whether the processor supports the dual-monitor treatment of system-management interrupts and system-management
         *        code (always 1)
         *
         * [Bit 49] Read as 1, the logical processor supports the dual-monitor treatment of system-management interrupts and
         * system-management mode.
         *
         * @see Vol3C[34.15(DUAL-MONITOR TREATMENT OF SMIs AND SMM)]
         */
        uint64_t dual_monitor_support : 1;
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT                      49
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG                     0x2000000000000
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK                     0x01
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_)                       (((_) >> 49) & 0x01)

        /**
         * @brief Memory type that must be used for the VMCS
         *
         * [Bits 53:50] Report the memory type that should be used for the VMCS, for data structures referenced by pointers in the
         * VMCS (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions), and for the MSEG header. If software needs to
         * access these data structures (e.g., to modify the contents of the MSR bitmaps), it can configure the paging structures
         * to map them into the linear-address space. If it does so, it should establish mappings that use the memory type reported
         * bits 53:50 in this MSR.
         * As of this writing, all processors that support VMX operation indicate the write-back type.
         */
        uint64_t memory_type : 4;
#define IA32_VMX_BASIC_MEMORY_TYPE_BIT                               50
#define IA32_VMX_BASIC_MEMORY_TYPE_FLAG                              0x3C000000000000
#define IA32_VMX_BASIC_MEMORY_TYPE_MASK                              0x0F
#define IA32_VMX_BASIC_MEMORY_TYPE(_)                                (((_) >> 50) & 0x0F)

        /**
         * @brief Whether the processor provides additional information for exits due to INS/OUTS
         *
         * [Bit 54] When set to 1, the processor reports information in the VM-exit instruction-information field on VM exits due
         * to execution of the INS and OUTS instructions. This reporting is done only if this bit is read as 1.
         *
         * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)]
         */
        uint64_t ins_outs_reporting : 1;
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT                        54
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG                       0x40000000000000
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK                       0x01
#define IA32_VMX_BASIC_INS_OUTS_REPORTING(_)                         (((_) >> 54) & 0x01)

        /**
         * @brief Whether default 1 bits in control MSRs (pin/proc/exit/entry) may be cleared to 0 and that 'true' control MSRs are
         *        supported
         *
         * [Bit 55] Is read as 1 if any VMX controls that default to 1 may be cleared to 0. It also reports support for the VMX
         * capability MSRs IA32_VMX_TRUE_PINBASED_CTLS, IA32_VMX_TRUE_PROCBASED_CTLS, IA32_VMX_TRUE_EXIT_CTLS, and
         * IA32_VMX_TRUE_ENTRY_CTLS.
         *
         * @see Vol3D[A.2(RESERVED CONTROLS AND DEFAULT SETTINGS)]
         * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
         * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.4(VM-EXIT CONTROLS)]
         * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
         */
        uint64_t vmx_controls : 1;
#define IA32_VMX_BASIC_VMX_CONTROLS_BIT                              55
#define IA32_VMX_BASIC_VMX_CONTROLS_FLAG                             0x80000000000000
#define IA32_VMX_BASIC_VMX_CONTROLS_MASK                             0x01
#define IA32_VMX_BASIC_VMX_CONTROLS(_)                               (((_) >> 55) & 0x01)
        uint64_t reserved2 : 8;
    };

    uint64_t flags;
} ia32_vmx_basic_register;


/**
 * Capability Reporting Register of Pin-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PINBASED_CTLS                                       0x00000481
typedef union
{
    struct
    {
        /**
         * @brief External interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 0] If this control is 1, external interrupts cause VM exits. Otherwise, they are delivered normally through the
         * guest interrupt-descriptor table (IDT). If this control is 1, the value of RFLAGS.IF does not affect interrupt blocking.
         */
        uint64_t external_interrupt_exiting : 1;
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT        0
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK       0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_)         (((_) >> 0) & 0x01)
        uint64_t reserved1 : 2;

        /**
         * @brief Non-maskable interrupts cause VM-exits if set; otherwise dispatched through the guest's IDT
         *
         * [Bit 3] If this control is 1, non-maskable interrupts (NMIs) cause VM exits. Otherwise, they are delivered normally
         * using descriptor 2 of the IDT. This control also determines interactions between IRET and blocking by NMI.
         *
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        uint64_t nmi_exiting : 1;
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT                       3
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG                      0x08
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING(_)                        (((_) >> 3) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief Virtual NMIs
         *
         * [Bit 5] If this control is 1, NMIs are never blocked and the "blocking by NMI" bit (bit 3) in the interruptibility-state
         * field indicates "virtual-NMI blocking". This control also interacts with the "NMI-window exiting" VM-execution control.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         */
        uint64_t virtual_nmi : 1;
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT                       5
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG                      0x20
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK                      0x01
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_)                        (((_) >> 5) & 0x01)

        /**
         * @brief Activate VMX preemption timer
         *
         * [Bit 6] If this control is 1, the VMX-preemption timer counts down in VMX non-root operation. A VM exit occurs when the
         * timer counts down to zero.
         *
         * @see Vol3C[25.5.1(VMX-Preemption Timer)]
         * @see Vol3C[25.2(OTHER CAUSES OF VM EXITS)]
         */
        uint64_t activate_vmx_preemption_timer : 1;
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT     6
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG    0x40
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK    0x01
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_)      (((_) >> 6) & 0x01)

        /**
         * @brief Process interrupts with the posted-interrupt notification vector
         *
         * [Bit 7] If this control is 1, the processor treats interrupts with the posted-interrupt notification vector specially,
         * updating the virtual-APIC page with posted-interrupt requests.
         *
         * @see Vol3C[24.6.8(Controls for APIC Virtualization)]
         * @see Vol3C[29.6(POSTED-INTERRUPT PROCESSING)]
         */
        uint64_t process_posted_interrupts : 1;
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT         7
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG        0x80
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK        0x01
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_)          (((_) >> 7) & 0x01)
        uint64_t reserved3 : 56;
    };

    uint64_t flags;
} ia32_vmx_pinbased_ctls_register;


/**
 * Capability Reporting Register of Primary Processor-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS                                      0x00000482
typedef union
{
    struct
    {
        uint64_t reserved1 : 2;

        /**
         * @brief VM-exit as soon as RFLAGS.IF=1 and no blocking is active
         *
         * [Bit 2] If this control is 1, a VM exit occurs at the beginning of any instruction if RFLAGS.IF = 1 and there are no
         * other blocking of interrupts.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        uint64_t interrupt_window_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_BIT         2
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_FLAG        0x04
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_)          (((_) >> 2) & 0x01)

        /**
         * @brief Use timestamp counter offset
         *
         * [Bit 3] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC offset field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        uint64_t use_tsc_offsetting : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT               3
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG              0x08
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_)                (((_) >> 3) & 0x01)
        uint64_t reserved2 : 3;

        /**
         * @brief VM-exit when executing the HLT instruction
         *
         * [Bit 7] This control determines whether executions of HLT cause VM exits.
         */
        uint64_t hlt_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT                      7
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG                     0x80
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_)                       (((_) >> 7) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * @brief VM-exit when executing the INVLPG instruction
         *
         * [Bit 9] This control determines whether executions of INVLPG cause VM exits.
         */
        uint64_t invlpg_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT                   9
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG                  0x200
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_)                    (((_) >> 9) & 0x01)

        /**
         * @brief VM-exit when executing the MWAIT instruction
         *
         * [Bit 10] This control determines whether executions of MWAIT cause VM exits.
         */
        uint64_t mwait_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT                    10
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG                   0x400
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_)                     (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing the RDPMC instruction
         *
         * [Bit 11] This control determines whether executions of RDPMC cause VM exits.
         */
        uint64_t rdpmc_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT                    11
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG                   0x800
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_)                     (((_) >> 11) & 0x01)

        /**
         * @brief VM-exit when executing the RDTSC/RDTSCP instruction
         *
         * [Bit 12] This control determines whether executions of RDTSC and RDTSCP cause VM exits.
         */
        uint64_t rdtsc_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT                    12
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG                   0x1000
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_)                     (((_) >> 12) & 0x01)
        uint64_t reserved4 : 2;

        /**
         * @brief VM-exit when executing the MOV to CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 15] In conjunction with the CR3-target controls, this control determines whether executions of MOV to CR3 cause VM
         * exits. The first processors to support the virtual-machine extensions supported only the 1-setting of this control.
         *
         * @see Vol3C[24.6.7(CR3-Target Controls)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        uint64_t cr3_load_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT                 15
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG                0x8000
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_)                  (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing the MOV from CR3 instruction (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 16] This control determines whether executions of MOV from CR3 cause VM exits. The first processors to support the
         * virtual-machine extensions supported only the 1-setting of this control.
         */
        uint64_t cr3_store_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT                16
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG               0x10000
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_)                 (((_) >> 16) & 0x01)

        /**
         * @brief Determines whether the tertiary processor based VM-execution controls are used
         *
         * [Bit 17] This control determines whether the tertiary processor-based VM-execution controls are used. If this control is
         * 0, the logical processor operates as if all the tertiary processor-based VM-execution controls were also 0.
         */
        uint64_t activate_tertiary_controls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_BIT       17
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_FLAG      0x20000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_MASK      0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS(_)        (((_) >> 17) & 0x01)
        uint64_t reserved5 : 1;

        /**
         * @brief VM-exit on CR8 loads
         *
         * [Bit 19] This control determines whether executions of MOV to CR8 cause VM exits.
         */
        uint64_t cr8_load_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT                 19
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG                0x80000
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_)                  (((_) >> 19) & 0x01)

        /**
         * @brief VM-exit on CR8 stores
         *
         * [Bit 20] This control determines whether executions of MOV from CR8 cause VM exits.
         */
        uint64_t cr8_store_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT                20
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG               0x100000
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_)                 (((_) >> 20) & 0x01)

        /**
         * @brief Use TPR shadow
         *
         * [Bit 21] Setting this control to 1 enables TPR virtualization and other APIC-virtualization features.
         *
         * @see Vol3C[29(APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS)]
         */
        uint64_t use_tpr_shadow : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT                   21
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG                  0x200000
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_)                    (((_) >> 21) & 0x01)

        /**
         * @brief VM-exit when virtual NMI blocking is disabled
         *
         * [Bit 22] If this control is 1, a VM exit occurs at the beginning of any instruction if there is no virtual-NMI blocking.
         *
         * @see Vol3C[24.4.2(Guest Non-Register State)]
         */
        uint64_t nmi_window_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT               22
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG              0x400000
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_)                (((_) >> 22) & 0x01)

        /**
         * @brief VM-exit when executing a MOV DRx instruction
         *
         * [Bit 23] This control determines whether executions of MOV DR cause VM exits.
         */
        uint64_t mov_dr_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT                   23
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG                  0x800000
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_)                    (((_) >> 23) & 0x01)

        /**
         * @brief VM-exit when executing IO instructions
         *
         * [Bit 24] This control determines whether executions of I/O instructions (IN, INS/INSB/INSW/INSD, OUT, and
         * OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
         */
        uint64_t unconditional_io_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT         24
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG        0x1000000
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK        0x01
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_)          (((_) >> 24) & 0x01)

        /**
         * @brief Use IO bitmaps
         *
         * [Bit 25] This control determines whether I/O bitmaps are used to restrict executions of I/O instructions For this
         * control, "0" means "do not use I/O bitmaps" and "1" means "use I/O bitmaps." If the I/O bitmaps are used, the setting of
         * the "unconditional I/O exiting" control is ignored.
         *
         * @see Vol3C[24.6.4(I/O-Bitmap Addresses)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        uint64_t use_io_bitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT                   25
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG                  0x2000000
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_)                    (((_) >> 25) & 0x01)
        uint64_t reserved6 : 1;

        /**
         * @brief Monitor trap flag
         *
         * [Bit 27] If this control is 1, the monitor trap flag debugging feature is enabled.
         *
         * @see Vol3C[25.5.2(Monitor Trap Flag)]
         */
        uint64_t monitor_trap_flag : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT                27
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG               0x8000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_)                 (((_) >> 27) & 0x01)

        /**
         * @brief Use MSR bitmaps
         *
         * [Bit 28] This control determines whether MSR bitmaps are used to control execution of the RDMSR and WRMSR instructions.
         * For this control, "0" means "do not use MSR bitmaps" and "1" means "use MSR bitmaps." If the MSR bitmaps are not used,
         * all executions of the RDMSR and WRMSR instructions cause VM exits.
         *
         * @see Vol3C[24.6.9(MSR-Bitmap Address)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        uint64_t use_msr_bitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT                  28
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG                 0x10000000
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_)                   (((_) >> 28) & 0x01)

        /**
         * @brief VM-exit when executing the MONITOR instruction
         *
         * [Bit 29] This control determines whether executions of MONITOR cause VM exits.
         */
        uint64_t monitor_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT                  29
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG                 0x20000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_)                   (((_) >> 29) & 0x01)

        /**
         * @brief VM-exit when executing the PAUSE instruction
         *
         * [Bit 30] This control determines whether executions of PAUSE cause VM exits.
         */
        uint64_t pause_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT                    30
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG                   0x40000000
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_)                     (((_) >> 30) & 0x01)

        /**
         * @brief Determines whether the secondary processor based VM-execution controls are used
         *
         * [Bit 31] This control determines whether the secondary processor-based VM-execution controls are used. If this control
         * is 0, the logical processor operates as if all the secondary processor-based VM-execution controls were also 0.
         */
        uint64_t activate_secondary_controls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT      31
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG     0x80000000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)       (((_) >> 31) & 0x01)
        uint64_t reserved7 : 32;
    };

    uint64_t flags;
} ia32_vmx_procbased_ctls_register;


/**
 * Capability Reporting Register of Primaryr VM-Exit Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.4.1(Primaryr VM-Exit Controls)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS                                           0x00000483
typedef union
{
    struct
    {
        uint64_t reserved1 : 2;

        /**
         * @brief Save guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are saved on VM exit. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        uint64_t save_debug_controls : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_BIT                   2
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_FLAG                  0x04
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_)                    (((_) >> 2) & 0x01)
        uint64_t reserved2 : 6;

        /**
         * @brief Return to long mode after a VM-exit
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether a logical processor is in
         * 64-bit mode after the next VM exit. Its value is loaded into CS.L, IA32_EFER.LME, and IA32_EFER.LMA on every VM exit.1
         * This control must be 0 on processors that do not support Intel 64 architecture.
         */
        uint64_t host_address_space_size : 1;
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT               9
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG              0x200
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK              0x01
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_)                (((_) >> 9) & 0x01)
        uint64_t reserved3 : 2;

        /**
         * @brief Whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-exit
         *
         * [Bit 12] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit.
         */
        uint64_t load_ia32_perf_global_ctrl : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT            12
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG           0x1000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK           0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)             (((_) >> 12) & 0x01)
        uint64_t reserved4 : 2;

        /**
         * @brief Acknowledge external interrupts with the irq controller if one caused a VM-exit
         *
         * [Bit 15] This control affects VM exits due to external interrupts:
         * - If such a VM exit occurs and this control is 1, the logical processor acknowledges the interrupt controller, acquiring
         * the interrupt's vector. The vector is stored in the VM-exit interruption-information field, which is marked valid.
         * - If such a VM exit occurs and this control is 0, the interrupt is not acknowledged and the VM-exit
         * interruption-information field is marked invalid.
         */
        uint64_t acknowledge_interrupt_on_exit : 1;
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT         15
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG        0x8000
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK        0x01
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_)          (((_) >> 15) & 0x01)
        uint64_t reserved5 : 2;

        /**
         * @brief Whether the guest IA32_PAT MSR is saved on VM-exit
         *
         * [Bit 18] This control determines whether the IA32_PAT MSR is saved on VM exit.
         */
        uint64_t save_ia32_pat : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT                         18
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG                        0x40000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_)                          (((_) >> 18) & 0x01)

        /**
         * @brief Whether the host IA32_PAT MSR is loaded on VM-exit
         *
         * [Bit 19] This control determines whether the IA32_PAT MSR is loaded on VM exit.
         */
        uint64_t load_ia32_pat : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT                         19
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG                        0x80000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK                        0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_)                          (((_) >> 19) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is saved on VM-exit
         *
         * [Bit 20] This control determines whether the IA32_EFER MSR is saved on VM exit.
         */
        uint64_t save_ia32_efer : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT                        20
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG                       0x100000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_)                         (((_) >> 20) & 0x01)

        /**
         * @brief Whether the host IA32_EFER MSR is loaded on VM-exit
         *
         * [Bit 21] This control determines whether the IA32_EFER MSR is loaded on VM exit.
         */
        uint64_t load_ia32_efer : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT                        21
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG                       0x200000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_)                         (((_) >> 21) & 0x01)

        /**
         * @brief Whether the value of the VMX preemption timer is saved on every VM-exit
         *
         * [Bit 22] This control determines whether the value of the VMX-preemption timer is saved on VM exit.
         */
        uint64_t save_vmx_preemption_timer_value : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT       22
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG      0x400000
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK      0x01
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_)        (((_) >> 22) & 0x01)

        /**
         * [Bit 23] This control determines whether the IA32_BNDCFGS MSR is cleared on VM exit.
         */
        uint64_t clear_ia32_bndcfgs : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT                    23
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG                   0x800000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_)                     (((_) >> 23) & 0x01)

        /**
         * [Bit 24] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM exit or
         * a VMCS packet on an SMM VM exit.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        uint64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT                   24
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG                  0x1000000
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_)                    (((_) >> 24) & 0x01)

        /**
         * [Bit 25] This control determines whether the IA32_RTIT_CTL MSR is cleared on VM exit.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        uint64_t clear_ia32_rtit_ctl : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_BIT                   25
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_FLAG                  0x2000000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL(_)                    (((_) >> 25) & 0x01)

        /**
         * [Bit 26] This control determines whether the IA32_LBR_CTL MSR is cleared on VM exit.
         */
        uint64_t clear_ia32_lbr_ctl : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_BIT                    26
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_FLAG                   0x4000000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_MASK                   0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL(_)                     (((_) >> 26) & 0x01)

        /**
         * [Bit 27] This control determines whether UINV is cleared on VM exit.
         */
        uint64_t clear_uinv : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_UINV_BIT                            27
#define IA32_VMX_EXIT_CTLS_CLEAR_UINV_FLAG                           0x8000000
#define IA32_VMX_EXIT_CTLS_CLEAR_UINV_MASK                           0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_UINV(_)                             (((_) >> 27) & 0x01)

        /**
         * [Bit 28] This control determines whether CET-related MSRs and SPP are loaded on VM exit.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t load_ia32_cet_state : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_BIT                   28
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_FLAG                  0x10000000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_MASK                  0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE(_)                    (((_) >> 28) & 0x01)

        /**
         * [Bit 29] This control determines whether the IA32_PKRS MSR is loaded on VM exit.
         */
        uint64_t load_ia32_pkrs : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_BIT                        29
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_FLAG                       0x20000000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_MASK                       0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS(_)                         (((_) >> 29) & 0x01)

        /**
         * [Bit 30] This control determines whether the IA32_PERF_GLOBAL_CTL MSR is saved on VM exit.
         */
        uint64_t save_ia32_perf_global_ctl : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PERF_GLOBAL_CTL_BIT             30
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PERF_GLOBAL_CTL_FLAG            0x40000000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PERF_GLOBAL_CTL_MASK            0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PERF_GLOBAL_CTL(_)              (((_) >> 30) & 0x01)

        /**
         * [Bit 31] This control determines whether the secondary VM-exit controls are used. If this control is 0, the logical
         * processor operates as if all the secondary VM-exit controls were also 0.
         */
        uint64_t activate_secondary_controls : 1;
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT           31
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG          0x80000000
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK          0x01
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)            (((_) >> 31) & 0x01)
        uint64_t reserved6 : 32;
    };

    uint64_t flags;
} ia32_vmx_exit_ctls_register;


/**
 * Capability Reporting Register of VM-Entry Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[24.8.1(VM-Entry Controls)] (reference)
 */
#define IA32_VMX_ENTRY_CTLS                                          0x00000484
typedef union
{
    struct
    {
        uint64_t reserved1 : 2;

        /**
         * @brief Load guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the 'first' VT-x capable CPUs; this actually
         *        includes the newest Nehalem CPUs)
         *
         * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are loaded on VM entry. The first processors to
         * support the virtual-machine extensions supported only the 1-setting of this control.
         */
        uint64_t load_debug_controls : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_BIT                  2
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_FLAG                 0x04
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_)                   (((_) >> 2) & 0x01)
        uint64_t reserved2 : 6;

        /**
         * @brief 64 bits guest mode. Must be 0 for CPUs that don't support AMD64
         *
         * [Bit 9] On processors that support Intel 64 architecture, this control determines whether the logical processor is in
         * IA-32e mode after VM entry. Its value is loaded into IA32_EFER.LMA as part of VM entry. This control must be 0 on
         * processors that do not support Intel 64 architecture.
         */
        uint64_t ia32e_mode_guest : 1;
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT                     9
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG                    0x200
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK                    0x01
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_)                      (((_) >> 9) & 0x01)

        /**
         * @brief In SMM mode after VM-entry
         *
         * [Bit 10] This control determines whether the logical processor is in system-management mode (SMM) after VM entry. This
         * control must be 0 for any VM entry from outside SMM.
         */
        uint64_t entry_to_smm : 1;
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT                         10
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG                        0x400
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK                        0x01
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_)                          (((_) >> 10) & 0x01)

        /**
         * @brief Disable dual treatment of SMI and SMM; must be zero for VM-entry outside of SMM
         *
         * [Bit 11] If set to 1, the default treatment of SMIs and SMM is in effect after the VM entry. This control must be 0 for
         * any VM entry from outside SMM
         *
         * @see Vol3C[34.15.7(Deactivating the Dual-Monitor Treatment)]
         */
        uint64_t deactivate_dual_monitor_treatment : 1;
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT    11
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG   0x800
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK   0x01
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_)     (((_) >> 11) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * @brief Whether the guest IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-entry
         *
         * [Bit 13] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry.
         */
        uint64_t load_ia32_perf_global_ctrl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT           13
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG          0x2000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK          0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)            (((_) >> 13) & 0x01)

        /**
         * @brief Whether the guest IA32_PAT MSR is loaded on VM-entry
         *
         * [Bit 14] This control determines whether the IA32_PAT MSR is loaded on VM entry.
         */
        uint64_t load_ia32_pat : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT                        14
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG                       0x4000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK                       0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_)                         (((_) >> 14) & 0x01)

        /**
         * @brief Whether the guest IA32_EFER MSR is loaded on VM-entry
         *
         * [Bit 15] This control determines whether the IA32_EFER MSR is loaded on VM entry.
         */
        uint64_t load_ia32_efer : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT                       15
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG                      0x8000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_)                        (((_) >> 15) & 0x01)

        /**
         * [Bit 16] This control determines whether the IA32_BNDCFGS MSR is loaded on VM entry.
         */
        uint64_t load_ia32_bndcfgs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT                    16
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG                   0x10000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK                   0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_)                     (((_) >> 16) & 0x01)

        /**
         * [Bit 17] If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on a VM entry or
         * a VMCS packet on a VM entry that returns from SMM.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        uint64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT                  17
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG                 0x20000
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK                 0x01
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_)                   (((_) >> 17) & 0x01)

        /**
         * [Bit 18] This control determines whether the IA32_RTIT_CTL MSR is loaded on VM entry.
         */
        uint64_t load_ia32_rtit_ctl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT                   18
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG                  0x40000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK                  0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_)                    (((_) >> 18) & 0x01)

        /**
         * [Bit 19] This control determines whether UINV is loaded on VM entry.
         */
        uint64_t load_uinv : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_UINV_BIT                            19
#define IA32_VMX_ENTRY_CTLS_LOAD_UINV_FLAG                           0x80000
#define IA32_VMX_ENTRY_CTLS_LOAD_UINV_MASK                           0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_UINV(_)                             (((_) >> 19) & 0x01)

        /**
         * [Bit 20] This control determines whether CET-related MSRs and SPP are loaded on VM entry.
         */
        uint64_t load_cet_state : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT                       20
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG                      0x100000
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_)                        (((_) >> 20) & 0x01)

        /**
         * [Bit 21] This control determines whether the IA32_LBR_CTL MSR is loaded on VM entry.
         */
        uint64_t load_ia32_lbr_ctl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_BIT                    21
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_FLAG                   0x200000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_MASK                   0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL(_)                     (((_) >> 21) & 0x01)

        /**
         * [Bit 22] This control determines whether the IA32_PKRS MSR is loaded on VM entry.
         */
        uint64_t load_ia32_pkrs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_BIT                       22
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_FLAG                      0x400000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_MASK                      0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS(_)                        (((_) >> 22) & 0x01)
        uint64_t reserved4 : 41;
    };

    uint64_t flags;
} ia32_vmx_entry_ctls_register;


/**
 * Reporting Register of Miscellaneous VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.6(MISCELLANEOUS DATA)]
 * @see Vol3D[A.6(Miscellaneous Data)] (reference)
 */
#define IA32_VMX_MISC                                                0x00000485
typedef union
{
    struct
    {
        /**
         * @brief Relationship between the preemption timer and tsc; count down every time bit x of the tsc changes
         *
         * [Bits 4:0] Report a value X that specifies the relationship between the rate of the VMX-preemption timer and that of the
         * timestamp counter (TSC). Specifically, the VMX-preemption timer (if it is active) counts down by 1 every time bit X in
         * the TSC changes due to a TSC increment.
         */
        uint64_t preemption_timer_tsc_relationship : 5;
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT          0
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK         0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_)           (((_) >> 0) & 0x1F)

        /**
         * @brief Whether VM-exit stores EFER.LMA into the "IA32e mode guest" field
         *
         * [Bit 5] When set to 1, VM exits store the value of IA32_EFER.LMA into the "IA-32e mode guest" VM-entry control. This bit
         * is read as 1 on any logical processor that supports the 1-setting of the "unrestricted guest" VM-execution control.
         *
         * @see Vol3C[27.2(RECORDING VM-EXIT INFORMATION AND UPDATING VM-ENTRY CONTROL FIELDS)]
         */
        uint64_t store_efer_lma_on_vmexit : 1;
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT                   5
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG                  0x20
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK                  0x01
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_)                    (((_) >> 5) & 0x01)

        /**
         * @brief Activity states supported by the implementation
         *
         * [Bits 8:6] Report, as a bitmap, the activity states supported by the implementation:
         * - Bit 6 reports (if set) the support for activity state 1 (HLT).
         * - Bit 7 reports (if set) the support for activity state 2 (shutdown).
         * - Bit 8 reports (if set) the support for activity state 3 (wait-for-SIPI).
         * If an activity state is not supported, the implementation causes a VM entry to fail if it attempts to establish that
         * activity state. All implementations support VM entry to activity state 0 (active).
         */
        uint64_t activity_states : 3;
#define IA32_VMX_MISC_ACTIVITY_STATES_BIT                            6
#define IA32_VMX_MISC_ACTIVITY_STATES_FLAG                           0x1C0
#define IA32_VMX_MISC_ACTIVITY_STATES_MASK                           0x07
#define IA32_VMX_MISC_ACTIVITY_STATES(_)                             (((_) >> 6) & 0x07)
        uint64_t reserved1 : 5;

        /**
         * @brief Intel Processor Trace (Intel PT) can be used in VMX operation
         *
         * [Bit 14] When set to 1, Intel(R) Processor Trace (Intel PT) can be used in VMX operation. If the processor supports Intel
         * PT but does not allow it to be used in VMX operation, execution of VMXON clears IA32_RTIT_CTL.TraceEn; any attempt to
         * write IA32_RTIT_CTL while in VMX operation (including VMX root operation) causes a general-protection exception.
         *
         * @see Vol3C[30.3(VMX INSTRUCTIONS | VMXON-Enter VMX Operation)]
         */
        uint64_t intel_pt_available_in_vmx : 1;
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT                  14
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG                 0x4000
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK                 0x01
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Whether RDMSR can be used to read IA32_SMBASE_MSR in SMM
         *
         * [Bit 15] When set to 1, the RDMSR instruction can be used in system-management mode (SMM) to read the IA32_SMBASE MSR
         * (MSR address 9EH).
         *
         * @see Vol3C[34.15.6.3(Saving Guest State)]
         */
        uint64_t rdmsr_can_read_ia32_smbase_msr_in_smm : 1;
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT      15
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG     0x8000
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK     0x01
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_)       (((_) >> 15) & 0x01)

        /**
         * @brief Number of CR3 target values supported by the processor (0-256)
         *
         * [Bits 24:16] Indicate the number of CR3-target values supported by the processor. This number is a value between 0 and
         * 256, inclusive (bit 24 is set if and only if bits 23:16 are clear).
         */
        uint64_t cr3_target_count : 9;
#define IA32_VMX_MISC_CR3_TARGET_COUNT_BIT                           16
#define IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG                          0x1FF0000
#define IA32_VMX_MISC_CR3_TARGET_COUNT_MASK                          0x1FF
#define IA32_VMX_MISC_CR3_TARGET_COUNT(_)                            (((_) >> 16) & 0x1FF)

        /**
         * @brief Maximum number of MSRs in the VMCS. (N+1)*512
         *
         * [Bits 27:25] Used to compute the recommended maximum number of MSRs that should appear in the VM-exit MSR-store list,
         * the VM-exit MSR-load list, or the VM-entry MSR-load list. Specifically, if the value bits 27:25 of IA32_VMX_MISC is N,
         * then 512 * (N + 1) is the recommended maximum number of MSRs to be included in each list. If the limit is exceeded,
         * undefined processor behavior may result (including a machine check during the VMX transition).
         */
        uint64_t max_number_of_msr : 3;
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT                          25
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG                         0xE000000
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK                         0x07
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_)                           (((_) >> 25) & 0x07)

        /**
         * @brief Whether bit 2 of IA32_SMM_MONITOR_CTL can be set to 1
         *
         * [Bit 28] When set to 1, bit 2 of the IA32_SMM_MONITOR_CTL can be set to 1. VMXOFF unblocks SMIs unless
         * IA32_SMM_MONITOR_CTL[bit 2] is 1.
         *
         * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
         */
        uint64_t smm_monitor_ctl_b2 : 1;
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT                         28
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG                        0x10000000
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK                        0x01
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_)                          (((_) >> 28) & 0x01)

        /**
         * @brief Whether VMWRITE can be used to write VM-exit information fields
         *
         * [Bit 29] When set to 1, software can use VMWRITE to write to any supported field in the VMCS; otherwise, VMWRITE cannot
         * be used to modify VM-exit information fields.
         */
        uint64_t vmwrite_vmexit_info : 1;
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT                        29
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG                       0x20000000
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK                       0x01
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_)                         (((_) >> 29) & 0x01)

        /**
         * [Bit 30] When set to 1, VM entry allows injection of a software interrupt, software exception, or privileged software
         * exception with an instruction length of 0.
         */
        uint64_t zero_length_instruction_vmentry_injection : 1;
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT  30
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG 0x40000000
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK 0x01
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_)   (((_) >> 30) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief MSEG revision identifier used by the processor
         *
         * [Bits 63:32] Report the 32-bit MSEG revision identifier used by the processor.
         */
        uint64_t mseg_id : 32;
#define IA32_VMX_MISC_MSEG_ID_BIT                                    32
#define IA32_VMX_MISC_MSEG_ID_FLAG                                   0xFFFFFFFF00000000
#define IA32_VMX_MISC_MSEG_ID_MASK                                   0xFFFFFFFF
#define IA32_VMX_MISC_MSEG_ID(_)                                     (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_vmx_misc_register;


/**
 * Capability Reporting Register of CR0 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED0                                          0x00000486

 /**
  * Capability Reporting Register of CR0 Bits Fixed to 1.
  *
  * @remarks If CPUID.01H:ECX.[5] = 1
  * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
  * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
  */
#define IA32_VMX_CR0_FIXED1                                          0x00000487

  /**
   * Capability Reporting Register of CR4 Bits Fixed to 0.
   *
   * @remarks If CPUID.01H:ECX.[5] = 1
   * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
   * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
   */
#define IA32_VMX_CR4_FIXED0                                          0x00000488

   /**
    * Capability Reporting Register of CR4 Bits Fixed to 1.
    *
    * @remarks If CPUID.01H:ECX.[5] = 1
    * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
    * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
    */
#define IA32_VMX_CR4_FIXED1                                          0x00000489

    /**
     * Capability Reporting Register of VMCS Field Enumeration.
     *
     * @remarks If CPUID.01H:ECX.[5] = 1
     * @see Vol3D[A.9(VMCS ENUMERATION)]
     * @see Vol3D[A.9(VMCS Enumeration)] (reference)
     */
#define IA32_VMX_VMCS_ENUM                                           0x0000048A
typedef union
{
    struct
    {
        /**
         * [Bit 0] Indicates access type.
         */
        uint64_t access_type : 1;
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_BIT                           0
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_FLAG                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_MASK                          0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_)                            (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Highest index value used for any VMCS encoding.
         */
        uint64_t highest_index_value : 9;
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT                   1
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG                  0x3FE
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK                  0x1FF
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_)                    (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Indicate the field's type.
         */
        uint64_t field_type : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT                            10
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG                           0xC00
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK                           0x03
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE(_)                             (((_) >> 10) & 0x03)
        uint64_t reserved1 : 1;

        /**
         * [Bits 14:13] Indicate the field's width.
         */
        uint64_t field_width : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT                           13
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG                          0x6000
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK                          0x03
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_)                            (((_) >> 13) & 0x03)
        uint64_t reserved2 : 49;
    };

    uint64_t flags;
} ia32_vmx_vmcs_enum_register;


/**
 * Capability Reporting Register of Secondary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] )
 * @see Vol3D[A.3.3(Secondary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS2                                     0x0000048B
typedef union
{
    struct
    {
        /**
         * @brief Virtualize APIC access
         *
         * [Bit 0] If this control is 1, the logical processor treats specially accesses to the page with the APICaccess address.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         */
        uint64_t virtualize_apic_accesses : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_BIT        0
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_FLAG       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_)         (((_) >> 0) & 0x01)

        /**
         * @brief EPT supported/enabled
         *
         * [Bit 1] If this control is 1, extended page tables (EPT) are enabled.
         *
         * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))]
         */
        uint64_t enable_ept : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT                      1
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG                     0x02
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_)                       (((_) >> 1) & 0x01)

        /**
         * @brief Descriptor table instructions cause VM-exits
         *
         * [Bit 2] This control determines whether executions of LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, and STR cause VM exits.
         */
        uint64_t descriptor_table_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT        2
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG       0x04
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_)         (((_) >> 2) & 0x01)

        /**
         * @brief RDTSCP supported/enabled
         *
         * [Bit 3] If this control is 0, any execution of RDTSCP causes an invalid-opcode exception (\#UD).
         */
        uint64_t enable_rdtscp : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT                   3
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG                  0x08
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_)                    (((_) >> 3) & 0x01)

        /**
         * @brief Virtualize x2APIC mode
         *
         * [Bit 4] If this control is 1, the logical processor treats specially RDMSR and WRMSR to APIC MSRs (in the range
         * 800H-8FFH).
         *
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        uint64_t virtualize_x2apic_mode : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT          4
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG         0x10
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK         0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_)           (((_) >> 4) & 0x01)

        /**
         * @brief VPID supported/enabled
         *
         * [Bit 5] If this control is 1, cached translations of linear addresses are associated with a virtualprocessor identifier
         * (VPID).
         *
         * @see Vol3C[28.1(VIRTUAL PROCESSOR IDENTIFIERS (VPIDS))]
         */
        uint64_t enable_vpid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT                     5
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG                    0x20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK                    0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_)                      (((_) >> 5) & 0x01)

        /**
         * @brief VM-exit when executing the WBINVD instruction
         *
         * [Bit 6] This control determines whether executions of WBINVD cause VM exits.
         */
        uint64_t wbinvd_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT                  6
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG                 0x40
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_)                   (((_) >> 6) & 0x01)

        /**
         * @brief Unrestricted guest execution
         *
         * [Bit 7] This control determines whether guest software may run in unpaged protected mode or in realaddress mode.
         */
        uint64_t unrestricted_guest : 1;
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT              7
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG             0x80
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_)               (((_) >> 7) & 0x01)

        /**
         * @brief APIC register virtualization
         *
         * [Bit 8] If this control is 1, the logical processor virtualizes certain APIC accesses.
         *
         * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
         * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
         */
        uint64_t apic_register_virtualization : 1;
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT    8
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG   0x100
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK   0x01
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_)     (((_) >> 8) & 0x01)

        /**
         * @brief Virtual-interrupt delivery
         *
         * [Bit 9] This controls enables the evaluation and delivery of pending virtual interrupts as well as the emulation of
         * writes to the APIC registers that control interrupt prioritization.
         */
        uint64_t virtual_interrupt_delivery : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT      9
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG     0x200
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_)       (((_) >> 9) & 0x01)

        /**
         * @brief A specified number of pause loops cause a VM-exit
         *
         * [Bit 10] This control determines whether a series of executions of PAUSE can cause a VM exit.
         *
         * @see Vol3C[24.6.13(Controls for PAUSE-Loop Exiting)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        uint64_t pause_loop_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT              10
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG             0x400
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK             0x01
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_)               (((_) >> 10) & 0x01)

        /**
         * @brief VM-exit when executing RDRAND instructions
         *
         * [Bit 11] This control determines whether executions of RDRAND cause VM exits.
         */
        uint64_t rdrand_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT                  11
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG                 0x800
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_)                   (((_) >> 11) & 0x01)

        /**
         * @brief Enables INVPCID instructions
         *
         * [Bit 12] If this control is 0, any execution of INVPCID causes a \#UD.
         */
        uint64_t enable_invpcid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT                  12
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG                 0x1000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_)                   (((_) >> 12) & 0x01)

        /**
         * @brief Enables VMFUNC instructions
         *
         * [Bit 13] Setting this control to 1 enables use of the VMFUNC instruction in VMX non-root operation.
         *
         * @see Vol3C[25.5.5(VM Functions)]
         */
        uint64_t enable_vm_functions : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT             13
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG            0x2000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_)              (((_) >> 13) & 0x01)

        /**
         * @brief Enables VMCS shadowing
         *
         * [Bit 14] If this control is 1, executions of VMREAD and VMWRITE in VMX non-root operation may access a shadow VMCS
         * (instead of causing VM exits).
         *
         * @see {'Vol3C[24.10(VMCS TYPES': 'ORDINARY AND SHADOW)]'}
         * @see Vol3C[30.3(VMX INSTRUCTIONS)]
         */
        uint64_t vmcs_shadowing : 1;
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT                  14
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG                 0x4000
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_)                   (((_) >> 14) & 0x01)

        /**
         * @brief Enables ENCLS VM-exits
         *
         * [Bit 15] If this control is 1, executions of ENCLS consult the ENCLS-exiting bitmap to determine whether the instruction
         * causes a VM exit.
         *
         * @see Vol3C[24.6.16(ENCLS-Exiting Bitmap)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        uint64_t enable_encls_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT            15
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG           0x8000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK           0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_)             (((_) >> 15) & 0x01)

        /**
         * @brief VM-exit when executing RDSEED
         *
         * [Bit 16] This control determines whether executions of RDSEED cause VM exits.
         */
        uint64_t rdseed_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT                  16
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG                 0x10000
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_)                   (((_) >> 16) & 0x01)

        /**
         * @brief Enables page-modification logging
         *
         * [Bit 17] If this control is 1, an access to a guest-physical address that sets an EPT dirty bit first adds an entry to
         * the page-modification log.
         *
         * @see Vol3C[28.2.5(Page-Modification Logging)]
         */
        uint64_t enable_pml : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT                      17
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG                     0x20000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK                     0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_)                       (((_) >> 17) & 0x01)

        /**
         * @brief Controls whether EPT-violations may cause
         *
         * [Bit 18] If this control is 1, EPT violations may cause virtualization exceptions (\#VE) instead of VM exits.
         *
         * @see Vol3C[25.5.6(Virtualization Exceptions)]
         */
        uint64_t ept_violation : 1;
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT                   18
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG                  0x40000
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_)                    (((_) >> 18) & 0x01)

        /**
         * @brief Conceal VMX non-root operation from Intel processor trace (PT)
         *
         * [Bit 19] If this control is 1, Intel Processor Trace suppresses from PIPs an indication that the processor was in VMX
         * non-root operation and omits a VMCS packet from any PSB+ produced in VMX nonroot operation.
         *
         * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
         */
        uint64_t conceal_vmx_from_pt : 1;
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT             19
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG            0x80000
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK            0x01
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_)              (((_) >> 19) & 0x01)

        /**
         * @brief Enables XSAVES/XRSTORS instructions
         *
         * [Bit 20] If this control is 0, any execution of XSAVES or XRSTORS causes a \#UD.
         */
        uint64_t enable_xsaves : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT                   20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG                  0x100000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK                  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_)                    (((_) >> 20) & 0x01)

        /**
         * [Bit 21] If this control is 1, PASID translation is performed for executions of ENQCMD and ENQCMDS.
         *
         * @see Vol3C[27.5.8(PASID Translation)]
         */
        uint64_t enable_pasid_translation : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PASID_TRANSLATION_BIT        21
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PASID_TRANSLATION_FLAG       0x200000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PASID_TRANSLATION_MASK       0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PASID_TRANSLATION(_)         (((_) >> 21) & 0x01)

        /**
         * [Bit 22] If this control is 1, EPT execute permissions are based on whether the linear address being accessed is
         * supervisor mode or user mode.
         *
         * @see Vol3C[28(VMX SUPPORT FOR ADDRESS TRANSLATION)]
         */
        uint64_t mode_based_execute_control_for_ept : 1;
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT 22
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_) (((_) >> 22) & 0x01)

        /**
         * [Bit 23] If this control is 1, EPT write permissions may be specified at the granularity of 128 bytes.
         *
         * @see Vol3C[28.2.4(Sub-Page Write Permissions)]
         */
        uint64_t sub_page_write_permissions_for_ept : 1;
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_BIT 23
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_FLAG 0x800000
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT(_) (((_) >> 23) & 0x01)

        /**
         * [Bit 24] If this control is 1, all output addresses used by Intel Processor Trace are treated as guestphysical addresses
         * and translated using EPT.
         *
         * @see Vol3C[25.5.3(Translation of Guest-Physical Addresses Using EPT)]
         */
        uint64_t pt_uses_guest_physical_addresses : 1;
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_BIT 24
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_FLAG 0x1000000
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES(_) (((_) >> 24) & 0x01)

        /**
         * @brief Use TSC scaling
         *
         * [Bit 25] This control determines whether executions of RDTSC, executions of RDTSCP, and executions of RDMSR that read
         * from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the TSC multiplier field.
         *
         * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        uint64_t use_tsc_scaling : 1;
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT                 25
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG                0x2000000
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK                0x01
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_)                  (((_) >> 25) & 0x01)

        /**
         * @brief Enables TPAUSE/UMONITOR/UMWAIT instructions
         *
         * [Bit 26] If this control is 0, any execution of TPAUSE, UMONITOR, or UMWAIT causes a \#UD.
         */
        uint64_t enable_user_wait_pause : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_BIT          26
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_FLAG         0x4000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_MASK         0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE(_)           (((_) >> 26) & 0x01)

        /**
         * @brief Enables the PCONFIG instruction
         *
         * [Bit 27] If this control is 0, any execution of PCONFIG causes a \#UD.
         */
        uint64_t enable_pconfig : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PCONFIG_BIT                  27
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PCONFIG_FLAG                 0x8000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PCONFIG_MASK                 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PCONFIG(_)                   (((_) >> 27) & 0x01)

        /**
         * @brief Enables ENCLV VM-exits
         *
         * [Bit 28] If this control is 1, executions of ENCLV consult the ENCLV-exiting bitmap to determine whether the instruction
         * causes a VM exit.
         *
         * @see Vol3C[24.6.17(ENCLV-Exiting Bitmap)]
         * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
         */
        uint64_t enable_enclv_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_BIT            28
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_FLAG           0x10000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_MASK           0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING(_)             (((_) >> 28) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief Enables VM-exits on bus lock assertions
         *
         * [Bit 30] This control determines whether assertion of a bus lock causes a VM exit.
         *
         * @see Vol3C[27.2(OTHER CAUSES OF VM EXIT)]
         */
        uint64_t enable_vmm_bus_lock_detection : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VMM_BUS_LOCK_DETECTION_BIT   30
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VMM_BUS_LOCK_DETECTION_FLAG  0x40000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VMM_BUS_LOCK_DETECTION_MASK  0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VMM_BUS_LOCK_DETECTION(_)    (((_) >> 30) & 0x01)

        /**
         * @brief Enables VM-exits on instructions that block for a certain amount of time
         *
         * [Bit 31] If this control is 1, a VM exit occurs if certain operations prevent the processor from reaching an instruction
         * boundary within a specified amount of time.
         *
         * @see Vol3C[26.6.25(Instruction-Timeout Contro)]
         * @see Vol3C[27.2(OTHER CAUSES OF VM EXIT)]
         */
        uint64_t enable_instruction_timeout_exit : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INSTRUCTION_TIMEOUT_EXIT_BIT 31
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INSTRUCTION_TIMEOUT_EXIT_FLAG 0x80000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INSTRUCTION_TIMEOUT_EXIT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INSTRUCTION_TIMEOUT_EXIT(_)  (((_) >> 31) & 0x01)
        uint64_t reserved2 : 32;
    };

    uint64_t flags;
} ia32_vmx_procbased_ctls2_register;


/**
 * Capability Reporting Register of EPT and VPID.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] && (IA32_VMX_PROCBASED_CTLS2[33] ||
 *          IA32_VMX_PROCBASED_CTLS2[37]) )
 * @see Vol3D[A.10(VPID AND EPT CAPABILITIES)]
 * @see Vol3D[A.10(VPID and EPT Capabilities)] (reference)
 */
#define IA32_VMX_EPT_VPID_CAP                                        0x0000048C
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set to 1, the processor supports execute-only translations by EPT. This support allows software to
         * configure EPT paging-structure entries in which bits 1:0 are clear (indicating that data accesses are not allowed) and
         * bit 2 is set (indicating that instruction fetches are allowed).
         */
        uint64_t execute_only_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT                 0
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_)                  (((_) >> 0) & 0x01)
        uint64_t reserved1 : 5;

        /**
         * [Bit 6] Indicates support for a page-walk length of 4.
         */
        uint64_t page_walk_length_4 : 1;
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT                 6
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG                0x40
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK                0x01
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_)                  (((_) >> 6) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bit 8] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * uncacheable (UC).
         *
         * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP))]
         */
        uint64_t memory_type_uncacheable : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT            8
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG           0x100
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK           0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_)             (((_) >> 8) & 0x01)
        uint64_t reserved3 : 5;

        /**
         * [Bit 14] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
         * write-back (WB).
         */
        uint64_t memory_type_write_back : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT             14
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG            0x4000
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_)              (((_) >> 14) & 0x01)
        uint64_t reserved4 : 1;

        /**
         * [Bit 16] When set to 1, the logical processor allows software to configure a EPT PDE to map a 2-Mbyte page (by setting
         * bit 7 in the EPT PDE).
         */
        uint64_t pde_2mb_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT                      16
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG                     0x10000
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK                     0x01
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_)                       (((_) >> 16) & 0x01)

        /**
         * [Bit 17] When set to 1, the logical processor allows software to configure a EPT PDPTE to map a 1-Gbyte page (by setting
         * bit 7 in the EPT PDPTE).
         */
        uint64_t pdpte_1gb_pages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT                    17
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG                   0x20000
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK                   0x01
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_)                     (((_) >> 17) & 0x01)
        uint64_t reserved5 : 2;

        /**
         * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        uint64_t invept : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_BIT                             20
#define IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG                            0x100000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_MASK                            0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT(_)                              (((_) >> 20) & 0x01)

        /**
         * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t ept_accessed_and_dirty_flags : 1;
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT       21
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG      0x200000
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK      0x01
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_)        (((_) >> 21) & 0x01)

        /**
         * [Bit 22] When set to 1, the processor reports advanced VM-exit information for EPT violations. This reporting is done
         * only if this bit is read as 1.
         *
         * @see Vol3C[27.2.1(Basic VM-Exit Information)]
         */
        uint64_t advanced_vmexit_ept_violations_information : 1;
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT 22
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG 0x400000
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_) (((_) >> 22) & 0x01)

        /**
         * [Bit 23] If bit 23 is read as 1, supervisor shadow-stack control is supported.
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t supervisor_shadow_stack : 1;
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_BIT            23
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_FLAG           0x800000
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_MASK           0x01
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK(_)             (((_) >> 23) & 0x01)
        uint64_t reserved6 : 1;

        /**
         * [Bit 25] When set to 1, the single-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        uint64_t invept_single_context : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT              25
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG             0x2000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK             0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_)               (((_) >> 25) & 0x01)

        /**
         * [Bit 26] When set to 1, the all-context INVEPT type is supported.
         *
         * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
         * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
         */
        uint64_t invept_all_contexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT                26
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG               0x4000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK               0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_)                 (((_) >> 26) & 0x01)
        uint64_t reserved7 : 5;

        /**
         * [Bit 32] When set to 1, the INVVPID instruction is supported.
         */
        uint64_t invvpid : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_BIT                            32
#define IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG                           0x100000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_MASK                           0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID(_)                             (((_) >> 32) & 0x01)
        uint64_t reserved8 : 7;

        /**
         * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
         */
        uint64_t invvpid_individual_address : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT         40
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG        0x10000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK        0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_)          (((_) >> 40) & 0x01)

        /**
         * [Bit 41] When set to 1, the single-context INVVPID type is supported.
         */
        uint64_t invvpid_single_context : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT             41
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG            0x20000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK            0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_)              (((_) >> 41) & 0x01)

        /**
         * [Bit 42] When set to 1, the all-context INVVPID type is supported.
         */
        uint64_t invvpid_all_contexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT               42
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG              0x40000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK              0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_)                (((_) >> 42) & 0x01)

        /**
         * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is supported.
         */
        uint64_t invvpid_single_context_retain_globals : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT 43
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG 0x80000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_) (((_) >> 43) & 0x01)
        uint64_t reserved9 : 4;

        /**
         * [Bits 53:48] Enumerate the maximum HLAT prefix size. It is expected that any processor that supports the 1-setting of
         * the "enable HLAT" VM-execution control will enumerate this value as 1.
         *
         * @see Vol3A[4.5.1(Ordinary Paging and HLAT Paging)]
         */
        uint64_t max_hlat_prefix_size : 6;
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_BIT               48
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_FLAG              0x3F000000000000
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_MASK              0x3F
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE(_)                (((_) >> 48) & 0x3F)
        uint64_t reserved10 : 10;
    };

    uint64_t flags;
} ia32_vmx_ept_vpid_cap_register;

/**
 * @defgroup ia32_vmx_true_ctls \
 *           IA32_VMX_TRUE_(x)_CTLS
 *
 * Capability Reporting Register of Pin-Based VM-Execution Flex Controls, Primary Processor-Based VM-Execution Flex
 * Controls, VM-Exit Flex Controls and VM-Entry Flex Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[A.3.1(Pin-Based VMExecution Controls)] (reference)
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)] (reference)
 * @see Vol3D[A.4(VM-Exit Controls)] (reference)
 * @see Vol3D[A.5(VM-Entry Controls)] (reference)
 * @{
 */
#define IA32_VMX_TRUE_PINBASED_CTLS                                  0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS                                 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS                                      0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS                                     0x00000490
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] Indicate the allowed 0-settings of these controls. VM entry allows control X to be 0 if bit X in the MSR is
         * cleared to 0; if bit X in the MSR is set to 1, VM entry fails if control X is 0.
         */
        uint64_t allowed_0_settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT                    0
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * [Bits 63:32] Indicate the allowed 1-settings of these controls. VM entry allows control X to be 1 if bit 32+X in the MSR
         * is set to 1; if bit 32+X in the MSR is cleared to 0, VM entry fails if control X is 1.
         */
        uint64_t allowed_1_settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT                    32
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG                   0xFFFFFFFF00000000
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK                   0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_vmx_true_ctls_register;

/**
 * @}
 */


 /**
  * Capability Reporting Register of VMFunction Controls.
  *
  * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
  * @see Vol3D[A.11(VM FUNCTIONS)]
  * @see Vol3D[24.6.14(VM-Function Controls)] (reference)
  */
#define IA32_VMX_VMFUNC                                              0x00000491
typedef union
{
    struct
    {
        /**
         * [Bit 0] The EPTP-switching VM function changes the EPT pointer to a value chosen from the EPTP list.
         *
         * @see Vol3C[25.5.5.3(EPTP Switching)]
         */
        uint64_t eptp_switching : 1;
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_BIT                           0
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_FLAG                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_MASK                          0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING(_)                            (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_vmx_vmfunc_register;


/**
 * Capability Reporting Register of Tertiary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[49] )
 * @see Vol3D[A.3.4(Tertiary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS3                                     0x00000492
typedef union
{
    struct
    {
        /**
         * @brief Executions of LOADIWKEY cause VM exits
         *
         * [Bit 0] This control determines whether executions of LOADIWKEY cause VM exits.
         */
        uint64_t loadiwkey_exiting : 1;
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_BIT               0
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_FLAG              0x01
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_MASK              0x01
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING(_)                (((_) >> 0) & 0x01)

        /**
         * @brief Enables hypervisor-managed linear-address translation
         *
         * [Bit 1] This control enables hypervisor-managed linear-address translation.
         *
         * @see Vol3A[4.5.1(Ordinary Paging and HLAT Paging)]
         */
        uint64_t enable_hlat : 1;
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_BIT                     1
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_FLAG                    0x02
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_MASK                    0x01
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT(_)                      (((_) >> 1) & 0x01)

        /**
         * @brief If this control is 1, EPT permissions can be specified to allow writes only for paging-related control updates
         *
         * [Bit 2] If this control is 1, EPT permissions can be specified to allow writes only for paging-related control updates.
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t ept_paging_write : 1;
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_BIT                2
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_FLAG               0x04
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_MASK               0x01
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE(_)                 (((_) >> 2) & 0x01)

        /**
         * [Bit 3] If this control is 1, EPT permissions can be specified to prevent accesses using linear addresses verification
         * whose translation has certain properties.
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t guest_paging : 1;
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_BIT                    3
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_FLAG                   0x08
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_MASK                   0x01
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING(_)                     (((_) >> 3) & 0x01)

        /**
         * @brief Enables virtualization of IPIs
         *
         * [Bit 4] If this control is 1, virtualization of interprocessor interrupts (IPIs) is enabled.
         *
         * @see Vol3C[31.1.6(IPI Virtualization)]
         */
        uint64_t enable_ipi_virtualization : 1;
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_IPI_VIRTUALIZATION_BIT       4
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_IPI_VIRTUALIZATION_FLAG      0x10
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_IPI_VIRTUALIZATION_MASK      0x01
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_IPI_VIRTUALIZATION(_)        (((_) >> 4) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief Enables RDMSRLIST/WRMSRLIST instructions
         *
         * [Bit 6] If this control is 0, any execution of RDMSRLIST or WRMSRLIST causes a \#UD.
         */
        uint64_t enable_rdmsrlist_wrmsrlist : 1;
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_RDMSRLIST_WRMSRLIST_BIT      6
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_RDMSRLIST_WRMSRLIST_FLAG     0x40
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_RDMSRLIST_WRMSRLIST_MASK     0x01
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_RDMSRLIST_WRMSRLIST(_)       (((_) >> 6) & 0x01)

        /**
         * @brief Changes access to the IA32_SPEC_CTRL MSR
         *
         * [Bit 7] If this control is 1, the operation of the RDMSR and WRMSR instructions is changed when accessing the
         * IA32_SPEC_CTRL MSR.
         *
         * @see Vol3C[26.6.26(Fields Controlling Virtualization of the IA32_SPEC_CTRL MSR)]
         * @see Vol3C[27.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         */
        uint64_t virtualize_ia32_spec_ctrl : 1;
#define IA32_VMX_PROCBASED_CTLS3_VIRTUALIZE_IA32_SPEC_CTRL_BIT       7
#define IA32_VMX_PROCBASED_CTLS3_VIRTUALIZE_IA32_SPEC_CTRL_FLAG      0x80
#define IA32_VMX_PROCBASED_CTLS3_VIRTUALIZE_IA32_SPEC_CTRL_MASK      0x01
#define IA32_VMX_PROCBASED_CTLS3_VIRTUALIZE_IA32_SPEC_CTRL(_)        (((_) >> 7) & 0x01)
        uint64_t reserved2 : 56;
    };

    uint64_t flags;
} ia32_vmx_procbased_ctls3_register;


/**
 * Capability Reporting Register of Secondary VM-Exit Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_EXIT_CTLS[63] )
 * @see Vol3D[A.4.2(Secondary VM-Exit Controls)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS2                                          0x00000493
typedef union
{
    struct
    {
        uint64_t reserved1 : 3;

        /**
         * @brief Enables indication of when a VM-exit causes a shadow stack to become prematurely busy
         *
         * [Bit 3] If this control is 1, VM exits that cause a shadow stack to become prematurely busy indicate this fact and save
         * additional information into the VMCS.
         *
         * @see Vol1[18.2.3(Supervisor Shadow Stack Token)]
         */
        uint64_t enable_prematurely_busy_shadow_stack_indication : 1;
#define IA32_VMX_EXIT_CTLS2_ENABLE_PREMATURELY_BUSY_SHADOW_STACK_INDICATION_BIT 3
#define IA32_VMX_EXIT_CTLS2_ENABLE_PREMATURELY_BUSY_SHADOW_STACK_INDICATION_FLAG 0x08
#define IA32_VMX_EXIT_CTLS2_ENABLE_PREMATURELY_BUSY_SHADOW_STACK_INDICATION_MASK 0x01
#define IA32_VMX_EXIT_CTLS2_ENABLE_PREMATURELY_BUSY_SHADOW_STACK_INDICATION(_) (((_) >> 3) & 0x01)
        uint64_t reserved2 : 60;
    };

    uint64_t flags;
} ia32_vmx_exit_ctls2_register;

/**
 * @defgroup ia32_a_pmc \
 *           IA32_A_PMC(n)
 *
 * Full Width Writable IA32_PMC(n) Alias.
 *
 * @remarks (If CPUID.0AH: EAX[15:8] > 0) && IA32_PERF_CAPABILITIES[13] = 1
 * @{
 */
#define IA32_A_PMC0                                                  0x000004C1
#define IA32_A_PMC1                                                  0x000004C2
#define IA32_A_PMC2                                                  0x000004C3
#define IA32_A_PMC3                                                  0x000004C4
#define IA32_A_PMC4                                                  0x000004C5
#define IA32_A_PMC5                                                  0x000004C6
#define IA32_A_PMC6                                                  0x000004C7
#define IA32_A_PMC7                                                  0x000004C8
 /**
  * @}
  */


  /**
   * Allows software to signal some MCEs to only a single logical processor in the system.
   *
   * @remarks If IA32_MCG_CAP.LMCE_P = 1
   * @see Vol3B[15.3.1.4(IA32_MCG_EXT_CTL MSR)]
   */
#define IA32_MCG_EXT_CTL                                             0x000004D0
typedef union
{
    struct
    {
        uint64_t lmce_en : 1;
#define IA32_MCG_EXT_CTL_LMCE_EN_BIT                                 0
#define IA32_MCG_EXT_CTL_LMCE_EN_FLAG                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN_MASK                                0x01
#define IA32_MCG_EXT_CTL_LMCE_EN(_)                                  (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_mcg_ext_ctl_register;


/**
 * @brief Status and SVN Threshold of SGX Support for ACM <b>(RO)</b>
 *
 * Intel SGX only allows launching ACMs with an Intel SGX SVN that is at the same level or higher than the expected Intel
 * SGX SVN. The expected Intel SGX SVN is specified by BIOS and locked down by the processor on the first successful
 * execution of an Intel SGX instruction that doesn't return an error code. Intel SGX provides interfaces for system
 * software to discover whether a non faulting Intel SGX instruction has been executed, and evaluate the suitability of the
 * Intel SGX SVN value of any ACM that is expected to be launched by the OS or the VMM.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))] (reference)
 */
#define IA32_SGX_SVN_STATUS                                          0x00000500
typedef union
{
    struct
    {
        /**
         * [Bit 0] - If 1, indicates that a non-faulting Intel SGX instruction has been executed, consequently, launching a
         * properly signed ACM but with Intel SGX SVN value less than the BIOS specified Intel SGX SVN threshold would lead to an
         * TXT shutdown.
         * - If 0, indicates that the processor will allow a properly signed ACM to launch irrespective of the Intel SGX SVN value
         * of the ACM.
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        uint64_t lock : 1;
#define IA32_SGX_SVN_STATUS_LOCK_BIT                                 0
#define IA32_SGX_SVN_STATUS_LOCK_FLAG                                0x01
#define IA32_SGX_SVN_STATUS_LOCK_MASK                                0x01
#define IA32_SGX_SVN_STATUS_LOCK(_)                                  (((_) >> 0) & 0x01)
        uint64_t reserved1 : 15;

        /**
         * @brief Reflects the expected threshold of Intel SGX SVN for the SINIT ACM
         *
         * [Bits 23:16] - If CPUID.01H:ECX.SMX = 1, this field reflects the expected threshold of Intel SGX SVN for the SINIT ACM.
         * - If CPUID.01H:ECX.SMX = 0, this field is reserved (0).
         *
         * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
         */
        uint64_t sgx_svn_sinit : 8;
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT                        16
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG                       0xFF0000
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK                       0xFF
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_)                         (((_) >> 16) & 0xFF)
        uint64_t reserved2 : 40;
    };

    uint64_t flags;
} ia32_sgx_svn_status_register;


/**
 * Trace Output Base Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0): ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.7(IA32_RTIT_OUTPUT_BASE MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_BASE                                        0x00000560
typedef union
{
    struct
    {
        uint64_t reserved1 : 7;

        /**
         * @brief Base physical address
         *
         * [Bits 47:7] The base physical address. How this address is used depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is the base physical address of a single, contiguous physical output region. This could be mapped to DRAM or
         * to MMIO, depending on the value. The base address should be aligned with the size of the region, such that none of the
         * 1s in the mask value overlap with 1s in the base address. If the base is not aligned, an operational error will result.
         * - 1: The base physical address of the current ToPA table. The address must be 4K aligned. Writing an address in which
         * bits 11:7 are non-zero will not cause a \#GP, but an operational error will be signaled once TraceEn is set.
         *
         * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)]
         * @see Vol3C[35.3.9(Operational Errors)]
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        uint64_t base_physical_address : 41;
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT              7
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG             0xFFFFFFFFFF80
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK             0x1FFFFFFFFFF
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_)               (((_) >> 7) & 0x1FFFFFFFFFF)
        uint64_t reserved2 : 16;
    };

    uint64_t flags;
} ia32_rtit_output_base_register;


/**
 * Trace Output Mask Pointers Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0):ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_MASK_PTRS                                   0x00000561
typedef union
{
    struct
    {
        /**
         * [Bits 6:0] Forced to 1, writes are ignored.
         */
        uint64_t lower_mask : 7;
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT                    0
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK                   0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_)                     (((_) >> 0) & 0x7F)

        /**
         * @brief MaskOrTableOffset
         *
         * [Bits 31:7] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This field holds bits 31:7 of the mask value for the single, contiguous physical output region. The size of this
         * field indicates that regions can be of size 128B up to 4GB. This value (combined with the lower 7 bits, which are
         * reserved to 1) will be ANDed with the OutputOffset field to determine the next write address. All 1s in this field
         * should be consecutive and starting at bit 7, otherwise the region will not be contiguous, and an operational error will
         * be signaled when TraceEn is set.
         * - 1: This field holds bits 27:3 of the offset pointer into the current ToPA table. This value can be added to the
         * IA32_RTIT_OUTPUT_BASE value to produce a pointer to the current ToPA table entry, which itself is a pointer to the
         * current output region. In this scenario, the lower 7 reserved bits are ignored. This field supports tables up to 256
         * MBytes in size.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        uint64_t mask_or_table_offset : 25;
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT          7
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG         0xFFFFFF80
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK         0x1FFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_)           (((_) >> 7) & 0x1FFFFFF)

        /**
         * @brief Output Offset
         *
         * [Bits 63:32] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
         * - 0: This is bits 31:0 of the offset pointer into the single, contiguous physical output region. This value will be
         * added to the IA32_RTIT_OUTPUT_BASE value to form the physical address at which the next byte of packet output data will
         * be written. This value must be less than or equal to the MaskOrTableOffset field, otherwise an operational error will be
         * signaled when TraceEn is set.
         * - 1: This field holds bits 31:0 of the offset pointer into the current ToPA output region. This value will be added to
         * the output region base field, found in the current ToPA table entry, to form the physical address at which the next byte
         * of trace output data will be written. This value must be less than the ToPA entry size, otherwise an operational error
         * will be signaled when TraceEn is set.
         *
         * @see Vol3C[35.3.9(Operational Errors)]
         */
        uint64_t output_offset : 32;
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT                 32
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG                0xFFFFFFFF00000000
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK                0xFFFFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_)                  (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_rtit_output_mask_ptrs_register;


/**
 * Trace Control Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)] (reference)
 */
#define IA32_RTIT_CTL                                                0x00000570
typedef union
{
    struct
    {
        /**
         * @brief TraceEn
         *
         * [Bit 0] If 1, enables tracing; else tracing is disabled.
         * When this bit transitions from 1 to 0, all buffered packets are flushed out of internal buffers. A further store, fence,
         * or architecturally serializing instruction may be required to ensure that packet data can be observed at the trace
         * endpoint.
         * Note that the processor will clear this bit on \#SMI (Section) and warm reset. Other MSR bits of IA32_RTIT_CTL (and
         * other trace configuration MSRs) are not impacted by these events.
         *
         * @see Vol3C[35.2.7.3(Enabling and Disabling Packet Generation with TraceEn)]
         */
        uint64_t trace_enabled : 1;
#define IA32_RTIT_CTL_TRACE_ENABLED_BIT                              0
#define IA32_RTIT_CTL_TRACE_ENABLED_FLAG                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED_MASK                             0x01
#define IA32_RTIT_CTL_TRACE_ENABLED(_)                               (((_) >> 0) & 0x01)

        /**
         * @brief CYCEn
         *
         * [Bit 1] - 0: Disables CYC Packet.
         * - 1: Enables CYC Packet.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.4.2.14(Cycle Count (CYC) Packet)]
         */
        uint64_t cyc_enabled : 1;
#define IA32_RTIT_CTL_CYC_ENABLED_BIT                                1
#define IA32_RTIT_CTL_CYC_ENABLED_FLAG                               0x02
#define IA32_RTIT_CTL_CYC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_CYC_ENABLED(_)                                 (((_) >> 1) & 0x01)

        /**
         * @brief OS
         *
         * [Bit 2] - 0: Packet generation is disabled when CPL = 0.
         * - 1: Packet generation may be enabled when CPL = 0.
         */
        uint64_t os : 1;
#define IA32_RTIT_CTL_OS_BIT                                         2
#define IA32_RTIT_CTL_OS_FLAG                                        0x04
#define IA32_RTIT_CTL_OS_MASK                                        0x01
#define IA32_RTIT_CTL_OS(_)                                          (((_) >> 2) & 0x01)

        /**
         * @brief User
         *
         * [Bit 3] - 0: Packet generation is disabled when CPL > 0.
         * - 1: Packet generation may be enabled when CPL > 0.
         */
        uint64_t user : 1;
#define IA32_RTIT_CTL_USER_BIT                                       3
#define IA32_RTIT_CTL_USER_FLAG                                      0x08
#define IA32_RTIT_CTL_USER_MASK                                      0x01
#define IA32_RTIT_CTL_USER(_)                                        (((_) >> 3) & 0x01)

        /**
         * @brief PwrEvtEn
         *
         * [Bit 4] - 0: Power Event Trace packets are disabled.
         * - 1: Power Event Trace packets are enabled.
         *
         * @see Vol3C[35.2.3(Power Event Tracing)]
         */
        uint64_t power_event_trace_enabled : 1;
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT                  4
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG                 0x10
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK                 0x01
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_)                   (((_) >> 4) & 0x01)

        /**
         * @brief FUPonPTW
         *
         * [Bit 5] - 0: PTW packets are not followed by FUPs.
         * - 1: PTW packets are followed by FUPs.
         */
        uint64_t fup_on_ptw : 1;
#define IA32_RTIT_CTL_FUP_ON_PTW_BIT                                 5
#define IA32_RTIT_CTL_FUP_ON_PTW_FLAG                                0x20
#define IA32_RTIT_CTL_FUP_ON_PTW_MASK                                0x01
#define IA32_RTIT_CTL_FUP_ON_PTW(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief FabricEn
         *
         * [Bit 6] - 0: Trace output is directed to the memory subsystem, mechanism depends on IA32_RTIT_CTL.ToPA.
         * - 1: Trace output is directed to the trace transport subsystem, IA32_RTIT_CTL.ToPA is ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):ECX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):ECX[bit 3] = 0
         */
        uint64_t fabric_enabled : 1;
#define IA32_RTIT_CTL_FABRIC_ENABLED_BIT                             6
#define IA32_RTIT_CTL_FABRIC_ENABLED_FLAG                            0x40
#define IA32_RTIT_CTL_FABRIC_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_FABRIC_ENABLED(_)                              (((_) >> 6) & 0x01)

        /**
         * @brief CR3 filter
         *
         * [Bit 7] - 0: Disables CR3 filtering.
         * - 1: Enables CR3 filtering.
         */
        uint64_t cr3_filter : 1;
#define IA32_RTIT_CTL_CR3_FILTER_BIT                                 7
#define IA32_RTIT_CTL_CR3_FILTER_FLAG                                0x80
#define IA32_RTIT_CTL_CR3_FILTER_MASK                                0x01
#define IA32_RTIT_CTL_CR3_FILTER(_)                                  (((_) >> 7) & 0x01)

        /**
         * @brief ToPA
         *
         * [Bit 8] - 0: Single-range output scheme enabled.
         * - 1: ToPA output scheme enabled.
         *
         * @remarks 0: If CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 1 and IA32_RTIT_CTL.FabricEn=0 1: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 1, and IA32_RTIT_CTL.FabricEn=0
         *          WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit and FabricEn would cause \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.SNGLRGNOUT[bit 2] = 0 WRMSR to IA32_RTIT_CTL that sets this bit causes \#GP: If CPUID.(EAX=14H,
         *          ECX=0):ECX.TOPA[bit 0] = 0
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
         */
        uint64_t topa : 1;
#define IA32_RTIT_CTL_TOPA_BIT                                       8
#define IA32_RTIT_CTL_TOPA_FLAG                                      0x100
#define IA32_RTIT_CTL_TOPA_MASK                                      0x01
#define IA32_RTIT_CTL_TOPA(_)                                        (((_) >> 8) & 0x01)

        /**
         * @brief MTCEn
         *
         * [Bit 9] - 0: Disables MTC Packet.
         * - 1: Enables MTC Packet.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.4.2.16(Overflow (OVF) Packet)]
         */
        uint64_t mtc_enabled : 1;
#define IA32_RTIT_CTL_MTC_ENABLED_BIT                                9
#define IA32_RTIT_CTL_MTC_ENABLED_FLAG                               0x200
#define IA32_RTIT_CTL_MTC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_MTC_ENABLED(_)                                 (((_) >> 9) & 0x01)

        /**
         * @brief TSCEn
         *
         * [Bit 10] - 0: Disable TSC packets.
         * - 1: Enable TSC packets.
         *
         * @see Vol3C[35.4.2.11(Timestamp Counter (TSC) Packet)]
         */
        uint64_t tsc_enabled : 1;
#define IA32_RTIT_CTL_TSC_ENABLED_BIT                                10
#define IA32_RTIT_CTL_TSC_ENABLED_FLAG                               0x400
#define IA32_RTIT_CTL_TSC_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_TSC_ENABLED(_)                                 (((_) >> 10) & 0x01)

        /**
         * @brief DisRETC
         *
         * [Bit 11] - 0: Enable RET compression.
         * - 1: Disable RET compression.
         *
         * @see Vol3C[35.2.1.2(Indirect Transfer COFI)]
         */
        uint64_t ret_compression_disabled : 1;
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT                   11
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG                  0x800
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK                  0x01
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_)                    (((_) >> 11) & 0x01)

        /**
         * @brief PTWEn
         *
         * [Bit 12] - 0: PTWRITE packet generation disabled.
         * - 1: PTWRITE packet generation enabled.
         */
        uint64_t ptw_enabled : 1;
#define IA32_RTIT_CTL_PTW_ENABLED_BIT                                12
#define IA32_RTIT_CTL_PTW_ENABLED_FLAG                               0x1000
#define IA32_RTIT_CTL_PTW_ENABLED_MASK                               0x01
#define IA32_RTIT_CTL_PTW_ENABLED(_)                                 (((_) >> 12) & 0x01)

        /**
         * @brief BranchEn
         *
         * [Bit 13] - 0: Disable COFI-based packets.
         * - 1: Enable COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec, MODE.TSX.
         *
         * @see Vol3C[35.2.5.4(Branch Enable (BranchEn))]
         */
        uint64_t branch_enabled : 1;
#define IA32_RTIT_CTL_BRANCH_ENABLED_BIT                             13
#define IA32_RTIT_CTL_BRANCH_ENABLED_FLAG                            0x2000
#define IA32_RTIT_CTL_BRANCH_ENABLED_MASK                            0x01
#define IA32_RTIT_CTL_BRANCH_ENABLED(_)                              (((_) >> 13) & 0x01)

        /**
         * @brief MTCFreq
         *
         * [Bits 17:14] Defines MTC packet Frequency, which is based on the core crystal clock, or Always Running Timer (ART). MTC
         * will be sent each time the selected ART bit toggles. The following Encodings are defined:
         * 0: ART(0), 1: ART(1), 2: ART(2), 3: ART(3), 4: ART(4), 5: ART(5), 6: ART(6), 7: ART(7), 8: ART(8), 9: ART(9), 10:
         * ART(10), 11: ART(11), 12: ART(12), 13: ART(13), 14: ART(14), 15: ART(15)
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.MTC[bit 3] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        uint64_t mtc_frequency : 4;
#define IA32_RTIT_CTL_MTC_FREQUENCY_BIT                              14
#define IA32_RTIT_CTL_MTC_FREQUENCY_FLAG                             0x3C000
#define IA32_RTIT_CTL_MTC_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_MTC_FREQUENCY(_)                               (((_) >> 14) & 0x0F)
        uint64_t reserved1 : 1;

        /**
         * @brief CYCThresh
         *
         * [Bits 22:19] CYC packet threshold. CYC packets will be sent with the first eligible packet after N cycles have passed
         * since the last CYC packet. If CycThresh is 0 then N=0, otherwise N is defined as 2(CycThresh-1). The following Encodings
         * are defined:
         * 0: 0, 1: 1, 2: 2, 3: 4, 4: 8, 5: 16, 6: 32, 7: 64, 8: 128, 9: 256, 10: 512, 11: 1024, 12: 2048, 13: 4096, 14: 8192, 15:
         * 16384
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.6(Cycle-Accurate Mode)]
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        uint64_t cyc_threshold : 4;
#define IA32_RTIT_CTL_CYC_THRESHOLD_BIT                              19
#define IA32_RTIT_CTL_CYC_THRESHOLD_FLAG                             0x780000
#define IA32_RTIT_CTL_CYC_THRESHOLD_MASK                             0x0F
#define IA32_RTIT_CTL_CYC_THRESHOLD(_)                               (((_) >> 19) & 0x0F)
        uint64_t reserved2 : 1;

        /**
         * @brief PSBFreq
         *
         * [Bits 27:24] Indicates the frequency of PSB packets. PSB packet frequency is based on the number of Intel PT packet
         * bytes output, so this field allows the user to determine the increment of IA32_IA32_RTIT_STATUS.PacketByteCnt that
         * should cause a PSB to be generated. Note that PSB insertion is not precise, but the average output bytes per PSB should
         * approximate the SW selected period. The following Encodings are defined:
         * 0: 2K, 1: 4K, 2: 8K, 3: 16K, 4: 32K, 5: 64K, 6: 128K, 7: 256K, 8: 512K, 9: 1M, 10: 2M, 11: 4M, 12: 8M, 13: 16M, 14: 32M,
         * 15: 64M
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
         * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
         */
        uint64_t psb_frequency : 4;
#define IA32_RTIT_CTL_PSB_FREQUENCY_BIT                              24
#define IA32_RTIT_CTL_PSB_FREQUENCY_FLAG                             0xF000000
#define IA32_RTIT_CTL_PSB_FREQUENCY_MASK                             0x0F
#define IA32_RTIT_CTL_PSB_FREQUENCY(_)                               (((_) >> 24) & 0x0F)
        uint64_t reserved3 : 4;

        /**
         * @brief ADDR0_CFG
         *
         * [Bits 35:32] Configures the base/limit register pair IA32_RTIT_ADDR0_A/B based on the following encodings:
         * - 0: ADDR0 range unused.
         * - 1: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 0) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] >= 0
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        uint64_t addr0_cfg : 4;
#define IA32_RTIT_CTL_ADDR0_CFG_BIT                                  32
#define IA32_RTIT_CTL_ADDR0_CFG_FLAG                                 0xF00000000
#define IA32_RTIT_CTL_ADDR0_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR0_CFG(_)                                   (((_) >> 32) & 0x0F)

        /**
         * @brief ADDR1_CFG
         *
         * [Bits 39:36] Configures the base/limit register pair IA32_RTIT_ADDR1_A/B based on the following encodings:
         * - 0: ADDR1 range unused.
         * - 1: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 1) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 2
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        uint64_t addr1_cfg : 4;
#define IA32_RTIT_CTL_ADDR1_CFG_BIT                                  36
#define IA32_RTIT_CTL_ADDR1_CFG_FLAG                                 0xF000000000
#define IA32_RTIT_CTL_ADDR1_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR1_CFG(_)                                   (((_) >> 36) & 0x0F)

        /**
         * @brief ADDR2_CFG
         *
         * [Bits 43:40] Configures the base/limit register pair IA32_RTIT_ADDR2_A/B based on the following encodings:
         * - 0: ADDR2 range unused.
         * - 1: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 2) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 3
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        uint64_t addr2_cfg : 4;
#define IA32_RTIT_CTL_ADDR2_CFG_BIT                                  40
#define IA32_RTIT_CTL_ADDR2_CFG_FLAG                                 0xF0000000000
#define IA32_RTIT_CTL_ADDR2_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR2_CFG(_)                                   (((_) >> 40) & 0x0F)

        /**
         * @brief ADDR3_CFG
         *
         * [Bits 47:44] Configures the base/limit register pair IA32_RTIT_ADDR3_A/B based on the following encodings:
         * - 0: ADDR3 range unused.
         * - 1: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a FilterEn range. FilterEn will only be set when the IP is
         * within this range, though other FilterEn ranges can additionally be used.
         * - 2: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a TraceStop range. TraceStop will be asserted if code
         * branches into this range.
         * - 3..15: Reserved (\#GP).
         *
         * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 3) Reserved if CPUID.(EAX=14H, ECX=1):EBX.RANGECNT[2:0] < 4
         * @see Vol3C[35.2.4.3(Filtering by IP)]
         * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
         */
        uint64_t addr3_cfg : 4;
#define IA32_RTIT_CTL_ADDR3_CFG_BIT                                  44
#define IA32_RTIT_CTL_ADDR3_CFG_FLAG                                 0xF00000000000
#define IA32_RTIT_CTL_ADDR3_CFG_MASK                                 0x0F
#define IA32_RTIT_CTL_ADDR3_CFG(_)                                   (((_) >> 44) & 0x0F)
        uint64_t reserved4 : 8;

        /**
         * @brief InjectPsbPmiOnEnable
         *
         * [Bit 56] - 1: Enables use of IA32_RTIT_STATUS bits PendPSB[6] and PendTopaPMI[7].
         * - 0: IA32_RTIT_STATUS bits 6 and 7 are ignored.
         *
         * @remarks Reserved if CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 0
         * @see Vol3C[35.2.7.4(IA32_RTIT_STATUS MSR)]
         */
        uint64_t inject_psb_pmi_on_enable : 1;
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT                   56
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG                  0x100000000000000
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK                  0x01
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_)                    (((_) >> 56) & 0x01)
        uint64_t reserved5 : 7;
    };

    uint64_t flags;
} ia32_rtit_ctl_register;


/**
 * Tracing Status Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 */
#define IA32_RTIT_STATUS                                             0x00000571
typedef union
{
    struct
    {
        /**
         * @brief FilterEn (writes ignored)
         *
         * [Bit 0] This bit is written by the processor, and indicates that tracing is allowed for the current IP. Writes are
         * ignored.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[2] = 1)
         * @see Vol3C[35.2.5.5(Filter Enable (FilterEn))]
         */
        uint64_t filter_enabled : 1;
#define IA32_RTIT_STATUS_FILTER_ENABLED_BIT                          0
#define IA32_RTIT_STATUS_FILTER_ENABLED_FLAG                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED_MASK                         0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED(_)                           (((_) >> 0) & 0x01)

        /**
         * @brief ContexEn (writes ignored)
         *
         * [Bit 1] The processor sets this bit to indicate that tracing is allowed for the current context. Writes are ignored.
         *
         * @see Vol3C[35.2.5.3(Context Enable (ContextEn))]
         */
        uint64_t context_enabled : 1;
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT                         1
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG                        0x02
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_CONTEXT_ENABLED(_)                          (((_) >> 1) & 0x01)

        /**
         * @brief TriggerEn (writes ignored)
         *
         * [Bit 2] The processor sets this bit to indicate that tracing is enabled. Writes are ignored.
         *
         * @see Vol3C[35.2.5.2(Trigger Enable (TriggerEn))]
         */
        uint64_t trigger_enabled : 1;
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT                         2
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG                        0x04
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK                        0x01
#define IA32_RTIT_STATUS_TRIGGER_ENABLED(_)                          (((_) >> 2) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief Error
         *
         * [Bit 4] The processor sets this bit to indicate that an operational error has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA Errors)]
         */
        uint64_t error : 1;
#define IA32_RTIT_STATUS_ERROR_BIT                                   4
#define IA32_RTIT_STATUS_ERROR_FLAG                                  0x10
#define IA32_RTIT_STATUS_ERROR_MASK                                  0x01
#define IA32_RTIT_STATUS_ERROR(_)                                    (((_) >> 4) & 0x01)

        /**
         * @brief Stopped
         *
         * [Bit 5] The processor sets this bit to indicate that a ToPA Stop condition has been encountered. When this bit is set,
         * TriggerEn is cleared to 0 and packet generation is disabled.
         * When TraceEn is cleared, software can write this bit. Once it is set, only software can clear it. It is not recommended
         * that software ever set this bit, except in cases where it is restoring a prior saved state.
         *
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA STOP)]
         */
        uint64_t stopped : 1;
#define IA32_RTIT_STATUS_STOPPED_BIT                                 5
#define IA32_RTIT_STATUS_STOPPED_FLAG                                0x20
#define IA32_RTIT_STATUS_STOPPED_MASK                                0x01
#define IA32_RTIT_STATUS_STOPPED(_)                                  (((_) >> 5) & 0x01)

        /**
         * @brief Pend PSB
         *
         * [Bit 6] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a PSB+ to be
         * inserted has been reached. The processor will clear this bit when the PSB+ has been inserted into the trace. If PendPSB
         * = 1 and InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PSB+ will be inserted into the
         * trace.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         */
        uint64_t pend_psb : 1;
#define IA32_RTIT_STATUS_PEND_PSB_BIT                                6
#define IA32_RTIT_STATUS_PEND_PSB_FLAG                               0x40
#define IA32_RTIT_STATUS_PEND_PSB_MASK                               0x01
#define IA32_RTIT_STATUS_PEND_PSB(_)                                 (((_) >> 6) & 0x01)

        /**
         * @brief Pend ToPA PMI
         *
         * [Bit 7] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this bit when the threshold for a ToPA PMI to
         * be inserted has been reached. Software should clear this bit once the ToPA PMI has been handled. If PendTopaPMI = 1 and
         * InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a PMI will be pended.
         *
         * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
         * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA PMI)]
         */
        uint64_t pend_topa_pmi : 1;
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT                           7
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG                          0x80
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK                          0x01
#define IA32_RTIT_STATUS_PEND_TOPA_PMI(_)                            (((_) >> 7) & 0x01)
        uint64_t reserved2 : 24;

        /**
         * @brief PacketByteCnt
         *
         * [Bits 48:32] This field is written by the processor, and holds a count of packet bytes that have been sent out. The
         * processor also uses this field to determine when the next PSB packet should be inserted. Note that the processor may
         * clear or modify this field at any time while IA32_RTIT_CTL.TraceEn=1. It will have a stable value when
         * IA32_RTIT_CTL.TraceEn=0.
         *
         * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] > 3)
         * @see Vol3C[35.4.2.17(Packet Stream Boundary (PSB) Packet)]
         */
        uint64_t packet_byte_count : 17;
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_BIT                       32
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_FLAG                      0x1FFFF00000000
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_MASK                      0x1FFFF
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT(_)                        (((_) >> 32) & 0x1FFFF)
        uint64_t reserved3 : 15;
    };

    uint64_t flags;
} ia32_rtit_status_register;


/**
 * @brief Trace Filter CR3 Match Register <b>(R/W)</b>
 *
 * The IA32_RTIT_CR3_MATCH register is compared against CR3 when IA32_RTIT_CTL.CR3Filter is 1. Bits 63:5 hold the CR3
 * address value to match, bits 4:0 are reserved to 0.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.4.2(Filtering by CR3)]
 * @see Vol3C[35.2.7.6(IA32_RTIT_CR3_MATCH MSR)] (reference)
 */
#define IA32_RTIT_CR3_MATCH                                          0x00000572
typedef union
{
    struct
    {
        uint64_t reserved1 : 5;

        /**
         * [Bits 63:5] CR3[63:5] value to match.
         */
        uint64_t cr3_value_to_match : 59;
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_BIT                   5
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_FLAG                  0xFFFFFFFFFFFFFFE0
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_MASK                  0x7FFFFFFFFFFFFFF
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_)                    (((_) >> 5) & 0x7FFFFFFFFFFFFFF)
    };

    uint64_t flags;
} ia32_rtit_cr3_match_register;

/**
 * @defgroup ia32_rtit_addr \
 *           IA32_RTIT_ADDR(x)
 *
 * The role of the IA32_RTIT_ADDRn_A/B register pairs, for each n, is determined by the corresponding ADDRn_CFG fields in
 * IA32_RTIT_CTL. The number of these register pairs is enumerated by CPUID.(EAX=14H, ECX=1):EAX.RANGECNT[2:0].
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)]
 * @see Vol3C[35.2.7.5(IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs)] (reference)
 * @{
 */
 /**
  * @defgroup ia32_rtit_addr_a \
  *           IA32_RTIT_ADDR(n)_A
  *
  * Region n Start Address.
  *
  * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
  * @{
  */
#define IA32_RTIT_ADDR0_A                                            0x00000580
#define IA32_RTIT_ADDR1_A                                            0x00000582
#define IA32_RTIT_ADDR2_A                                            0x00000584
#define IA32_RTIT_ADDR3_A                                            0x00000586
  /**
   * @}
   */

   /**
    * @defgroup ia32_rtit_addr_b \
    *           IA32_RTIT_ADDR(n)_B
    *
    * Region n End Address.
    *
    * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
    * @{
    */
#define IA32_RTIT_ADDR0_B                                            0x00000581
#define IA32_RTIT_ADDR1_B                                            0x00000583
#define IA32_RTIT_ADDR2_B                                            0x00000585
#define IA32_RTIT_ADDR3_B                                            0x00000587
    /**
     * @}
     */

typedef union
{
    struct
    {
        /**
         * [Bits 47:0] Virtual Address.
         */
        uint64_t virtual_address : 48;
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT                           0
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK                          0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_)                            (((_) >> 0) & 0xFFFFFFFFFFFF)

        /**
         * [Bits 63:48] SignExt_VA.
         */
        uint64_t sign_ext_va : 16;
#define IA32_RTIT_ADDR_SIGN_EXT_VA_BIT                               48
#define IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG                              0xFFFF000000000000
#define IA32_RTIT_ADDR_SIGN_EXT_VA_MASK                              0xFFFF
#define IA32_RTIT_ADDR_SIGN_EXT_VA(_)                                (((_) >> 48) & 0xFFFF)
    };

    uint64_t flags;
} ia32_rtit_addr_register;

/**
 * @}
 */


 /**
  * DS Save Area. Points to the linear address of the first byte of the DS buffer management area, which is used to manage
  * the BTS and PEBS buffers.
  * Returns:
  * - [63:0] The linear address of the first byte of the DS buffer management area, if IA-32e mode is active.
  * - [31:0] The linear address of the first byte of the DS buffer management area, if not in IA-32e mode.
  * - [63:32] Reserved if not in IA-32e mode.
  *
  * @remarks If CPUID.01H:EDX.DS[21] = 1
  * @see Vol3B[18.6.3.4(Debug Store (DS) Mechanism)]
  */
#define IA32_DS_AREA                                                 0x00000600

  /**
   * Configure User Mode CET
   *
   * @remarks - Bits 1:0 are defined if CPUID.(EAX=07H,ECX=0H):ECX.CET_SS[07] = 1. - Bits 5:2 and bits 63:10 are defined if
   *          CPUID.(EAX=07H,ECX=0H):EDX.CET_IBT[20] = 1.
   */
#define IA32_U_CET                                                   0x000006A0
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set to 1, enable shadow stacks at CPL3.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t sh_stk_en : 1;
#define IA32_U_CET_SH_STK_EN_BIT                                     0
#define IA32_U_CET_SH_STK_EN_FLAG                                    0x01
#define IA32_U_CET_SH_STK_EN_MASK                                    0x01
#define IA32_U_CET_SH_STK_EN(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] When set to 1, enables the WRSSD/WRSSQ instructions.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t wr_shstk_en : 1;
#define IA32_U_CET_WR_SHSTK_EN_BIT                                   1
#define IA32_U_CET_WR_SHSTK_EN_FLAG                                  0x02
#define IA32_U_CET_WR_SHSTK_EN_MASK                                  0x01
#define IA32_U_CET_WR_SHSTK_EN(_)                                    (((_) >> 1) & 0x01)

        /**
         * [Bit 2] When set to 1, enables indirect branch tracking
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t endbr_en : 1;
#define IA32_U_CET_ENDBR_EN_BIT                                      2
#define IA32_U_CET_ENDBR_EN_FLAG                                     0x04
#define IA32_U_CET_ENDBR_EN_MASK                                     0x01
#define IA32_U_CET_ENDBR_EN(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Enable legacy compatibility treatment for indirect branch tracking.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t leg_iw_en : 1;
#define IA32_U_CET_LEG_IW_EN_BIT                                     3
#define IA32_U_CET_LEG_IW_EN_FLAG                                    0x08
#define IA32_U_CET_LEG_IW_EN_MASK                                    0x01
#define IA32_U_CET_LEG_IW_EN(_)                                      (((_) >> 3) & 0x01)

        /**
         * [Bit 4] When set to 1, enables use of no-track prefix for indirect branch tracking.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t no_track_en : 1;
#define IA32_U_CET_NO_TRACK_EN_BIT                                   4
#define IA32_U_CET_NO_TRACK_EN_FLAG                                  0x10
#define IA32_U_CET_NO_TRACK_EN_MASK                                  0x01
#define IA32_U_CET_NO_TRACK_EN(_)                                    (((_) >> 4) & 0x01)

        /**
         * [Bit 5] When set to 1, disables suppression of CET indirect branch tracking on legacy compatibility.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t suppress_dis : 1;
#define IA32_U_CET_SUPPRESS_DIS_BIT                                  5
#define IA32_U_CET_SUPPRESS_DIS_FLAG                                 0x20
#define IA32_U_CET_SUPPRESS_DIS_MASK                                 0x01
#define IA32_U_CET_SUPPRESS_DIS(_)                                   (((_) >> 5) & 0x01)
        uint64_t reserved1 : 4;

        /**
         * [Bit 10] When set to 1, indirect branch tracking is suppressed. This bit can be written to 1 only if TRACKER is written
         * as IDLE.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t suppress : 1;
#define IA32_U_CET_SUPPRESS_BIT                                      10
#define IA32_U_CET_SUPPRESS_FLAG                                     0x400
#define IA32_U_CET_SUPPRESS_MASK                                     0x01
#define IA32_U_CET_SUPPRESS(_)                                       (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Value of the indirect branch tracking state machine. Values: IDLE (0), WAIT_FOR_ENDBRANCH(1).
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t tracker : 1;
#define IA32_U_CET_TRACKER_BIT                                       11
#define IA32_U_CET_TRACKER_FLAG                                      0x800
#define IA32_U_CET_TRACKER_MASK                                      0x01
#define IA32_U_CET_TRACKER(_)                                        (((_) >> 11) & 0x01)

        /**
         * [Bits 63:12] Linear address bits 63:12 of a legacy code page bitmap used for legacy compatibility when indirect branch
         * tracking is enabled. If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32
         * of the MSRs are reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical
         * address. In protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0
         * must be 0 (hardware requires bits 1:0 to be 0).
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t eb_leg_bitmap_base : 52;
#define IA32_U_CET_EB_LEG_BITMAP_BASE_BIT                            12
#define IA32_U_CET_EB_LEG_BITMAP_BASE_FLAG                           0xFFFFFFFFFFFFF000
#define IA32_U_CET_EB_LEG_BITMAP_BASE_MASK                           0xFFFFFFFFFFFFF
#define IA32_U_CET_EB_LEG_BITMAP_BASE(_)                             (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    uint64_t flags;
} ia32_u_cet_register;


/**
 * Configure Supervisor Mode CET
 *
 * @remarks - Bits 1:0 are defined if CPUID.(EAX=07H,ECX=0H):ECX.CET_SS[07] = 1. - Bits 5:2 and bits 63:10 are defined if
 *          CPUID.(EAX=07H,ECX=0H):EDX.CET_IBT[20] = 1.
 */
#define IA32_S_CET                                                   0x000006A2
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set to 1, enable shadow stacks at CPL0.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t sh_stk_en : 1;
#define IA32_S_CET_SH_STK_EN_BIT                                     0
#define IA32_S_CET_SH_STK_EN_FLAG                                    0x01
#define IA32_S_CET_SH_STK_EN_MASK                                    0x01
#define IA32_S_CET_SH_STK_EN(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] When set to 1, enables the WRSSD/WRSSQ instructions.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t wr_shstk_en : 1;
#define IA32_S_CET_WR_SHSTK_EN_BIT                                   1
#define IA32_S_CET_WR_SHSTK_EN_FLAG                                  0x02
#define IA32_S_CET_WR_SHSTK_EN_MASK                                  0x01
#define IA32_S_CET_WR_SHSTK_EN(_)                                    (((_) >> 1) & 0x01)

        /**
         * [Bit 2] When set to 1, enables indirect branch tracking
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t endbr_en : 1;
#define IA32_S_CET_ENDBR_EN_BIT                                      2
#define IA32_S_CET_ENDBR_EN_FLAG                                     0x04
#define IA32_S_CET_ENDBR_EN_MASK                                     0x01
#define IA32_S_CET_ENDBR_EN(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Enable legacy compatibility treatment for indirect branch tracking.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t leg_iw_en : 1;
#define IA32_S_CET_LEG_IW_EN_BIT                                     3
#define IA32_S_CET_LEG_IW_EN_FLAG                                    0x08
#define IA32_S_CET_LEG_IW_EN_MASK                                    0x01
#define IA32_S_CET_LEG_IW_EN(_)                                      (((_) >> 3) & 0x01)

        /**
         * [Bit 4] When set to 1, enables use of no-track prefix for indirect branch tracking.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t no_track_en : 1;
#define IA32_S_CET_NO_TRACK_EN_BIT                                   4
#define IA32_S_CET_NO_TRACK_EN_FLAG                                  0x10
#define IA32_S_CET_NO_TRACK_EN_MASK                                  0x01
#define IA32_S_CET_NO_TRACK_EN(_)                                    (((_) >> 4) & 0x01)

        /**
         * [Bit 5] When set to 1, disables suppression of CET indirect branch tracking on legacy compatibility.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t suppress_dis : 1;
#define IA32_S_CET_SUPPRESS_DIS_BIT                                  5
#define IA32_S_CET_SUPPRESS_DIS_FLAG                                 0x20
#define IA32_S_CET_SUPPRESS_DIS_MASK                                 0x01
#define IA32_S_CET_SUPPRESS_DIS(_)                                   (((_) >> 5) & 0x01)
        uint64_t reserved1 : 4;

        /**
         * [Bit 10] When set to 1, indirect branch tracking is suppressed. This bit can be written to 1 only if TRACKER is written
         * as IDLE.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t suppress : 1;
#define IA32_S_CET_SUPPRESS_BIT                                      10
#define IA32_S_CET_SUPPRESS_FLAG                                     0x400
#define IA32_S_CET_SUPPRESS_MASK                                     0x01
#define IA32_S_CET_SUPPRESS(_)                                       (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Value of the indirect branch tracking state machine. Values: IDLE (0), WAIT_FOR_ENDBRANCH(1).
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t tracker : 1;
#define IA32_S_CET_TRACKER_BIT                                       11
#define IA32_S_CET_TRACKER_FLAG                                      0x800
#define IA32_S_CET_TRACKER_MASK                                      0x01
#define IA32_S_CET_TRACKER(_)                                        (((_) >> 11) & 0x01)

        /**
         * [Bits 63:12] Linear address bits 63:12 of a legacy code page bitmap used for legacy compatibility when indirect branch
         * tracking is enabled. If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32
         * of the MSRs are reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical
         * address. In protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0
         * must be 0 (hardware requires bits 1:0 to be 0).
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint64_t eb_leg_bitmap_base : 52;
#define IA32_S_CET_EB_LEG_BITMAP_BASE_BIT                            12
#define IA32_S_CET_EB_LEG_BITMAP_BASE_FLAG                           0xFFFFFFFFFFFFF000
#define IA32_S_CET_EB_LEG_BITMAP_BASE_MASK                           0xFFFFFFFFFFFFF
#define IA32_S_CET_EB_LEG_BITMAP_BASE(_)                             (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    uint64_t flags;
} ia32_s_cet_register;


/**
 * Linear address to be loaded into SSP on transition to privilege level 0.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32 of the MSRs are
 * reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical address. In
 * protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0 must be 0
 * (hardware requires bits 1:0 to be 0).
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
 */
#define IA32_PL0_SSP                                                 0x000006A4

 /**
  * Linear address to be loaded into SSP on transition to privilege level 1.
  * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32 of the MSRs are
  * reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical address. In
  * protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0 must be 0
  * (hardware requires bits 1:0 to be 0).
  *
  * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
  */
#define IA32_PL1_SSP                                                 0x000006A5

  /**
   * Linear address to be loaded into SSP on transition to privilege level 2.
   * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32 of the MSRs are
   * reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical address. In
   * protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0 must be 0
   * (hardware requires bits 1:0 to be 0).
   *
   * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
   */
#define IA32_PL2_SSP                                                 0x000006A6

   /**
    * Linear address to be loaded into SSP on transition to privilege level 3.
    * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits 63:32 of the MSRs are
    * reserved. On processors that support Intel 64 architecture this value cannot represent a non-canonical address. In
    * protected mode, only 31:0 are loaded. The linear address written must be aligned to 8 bytes and bits 2:0 must be 0
    * (hardware requires bits 1:0 to be 0).
    *
    * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
    */
#define IA32_PL3_SSP                                                 0x000006A7

    /**
     * Linear address of a table of seven shadow stack pointers that are selected in IA-32e mode using the IST index (when not
     * 0) from the interrupt gate descriptor.
     * This MSR is not present on processors that do not support Intel 64 architecture. This field cannot represent a
     * non-canonical address.
     *
     * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
     */
#define IA32_INTERRUPT_SSP_TABLE_ADDR                                0x000006A8

     /**
      * TSC Target of Local APIC's TSC Deadline Mode.
      *
      * @remarks If CPUID.01H:ECX.[24] = 1
      */
#define IA32_TSC_DEADLINE                                            0x000006E0

      /**
       * Enable/disable HWP.
       *
       * @remarks If CPUID.06H:EAX.[7] = 1
       */
#define IA32_PM_ENABLE                                               0x00000770
typedef union
{
    struct
    {
        /**
         * [Bit 0] HWP_ENABLE.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.2(Enabling HWP)]
         */
        uint64_t hwp_enable : 1;
#define IA32_PM_ENABLE_HWP_ENABLE_BIT                                0
#define IA32_PM_ENABLE_HWP_ENABLE_FLAG                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE_MASK                               0x01
#define IA32_PM_ENABLE_HWP_ENABLE(_)                                 (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_pm_enable_register;


/**
 * HWP Performance Range Enumeration.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_CAPABILITIES                                        0x00000771
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Highest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        uint64_t highest_performance : 8;
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_BIT                0
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_FLAG               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_MASK               0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_)                 (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Guaranteed_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        uint64_t guaranteed_performance : 8;
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT             8
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG            0xFF00
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK            0xFF
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_)              (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Most_Efficient_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        uint64_t most_efficient_performance : 8;
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT         16
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG        0xFF0000
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK        0xFF
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_)          (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Lowest_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
         */
        uint64_t lowest_performance : 8;
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT                 24
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG                0xFF000000
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK                0xFF
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_)                  (((_) >> 24) & 0xFF)
        uint64_t reserved1 : 32;
    };

    uint64_t flags;
} ia32_hwp_capabilities_register;


/**
 * Power Management Control Hints for All Logical Processors in a Package.
 *
 * @remarks If CPUID.06H:EAX.[11] = 1
 */
#define IA32_HWP_REQUEST_PKG                                         0x00000772
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t minimum_performance : 8;
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_BIT                 0
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_FLAG                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_)                  (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t maximum_performance : 8;
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT                 8
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG                0xFF00
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_)                  (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t desired_performance : 8;
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT                 16
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG                0xFF0000
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK                0xFF
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_)                  (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t energy_performance_preference : 8;
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT       24
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG      0xFF000000
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK      0xFF
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_)        (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t activity_window : 10;
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT                     32
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG                    0x3FF00000000
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK                    0x3FF
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_)                      (((_) >> 32) & 0x3FF)
        uint64_t reserved1 : 22;
    };

    uint64_t flags;
} ia32_hwp_request_pkg_register;


/**
 * Control HWP Native Interrupts.
 *
 * @remarks If CPUID.06H:EAX.[8] = 1
 */
#define IA32_HWP_INTERRUPT                                           0x00000773
typedef union
{
    struct
    {
        /**
         * [Bit 0] EN_Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        uint64_t en_guaranteed_performance_change : 1;
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_BIT      0
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_FLAG     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_MASK     0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_)       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] EN_Excursion_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[8] = 1
         * @see Vol3B[14.4.6(HWP Notifications)]
         */
        uint64_t en_excursion_minimum : 1;
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT                  1
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG                 0x02
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK                 0x01
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_)                   (((_) >> 1) & 0x01)
        uint64_t reserved1 : 62;
    };

    uint64_t flags;
} ia32_hwp_interrupt_register;


/**
 * Power Management Control Hints to a Logical Processor.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_REQUEST                                             0x00000774
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Minimum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t minimum_performance : 8;
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_BIT                     0
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_FLAG                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_)                      (((_) >> 0) & 0xFF)

        /**
         * [Bits 15:8] Maximum_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t maximum_performance : 8;
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT                     8
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG                    0xFF00
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_)                      (((_) >> 8) & 0xFF)

        /**
         * [Bits 23:16] Desired_Performance.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t desired_performance : 8;
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT                     16
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG                    0xFF0000
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK                    0xFF
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_)                      (((_) >> 16) & 0xFF)

        /**
         * [Bits 31:24] Energy_Performance_Preference.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[10] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t energy_performance_preference : 8;
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT           24
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG          0xFF000000
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK          0xFF
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_)            (((_) >> 24) & 0xFF)

        /**
         * [Bits 41:32] Activity_Window.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[9] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t activity_window : 10;
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT                         32
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG                        0x3FF00000000
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK                        0x3FF
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW(_)                          (((_) >> 32) & 0x3FF)

        /**
         * [Bit 42] Package_Control.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[11] = 1
         * @see Vol3B[14.4.4(Managing HWP)]
         */
        uint64_t package_control : 1;
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT                         42
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG                        0x40000000000
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK                        0x01
#define IA32_HWP_REQUEST_PACKAGE_CONTROL(_)                          (((_) >> 42) & 0x01)
        uint64_t reserved1 : 21;
    };

    uint64_t flags;
} ia32_hwp_request_register;


/**
 * Log bits indicating changes to Guaranteed & excursions to Minimum.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_STATUS                                              0x00000777
typedef union
{
    struct
    {
        /**
         * [Bit 0] Guaranteed_Performance_Change.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        uint64_t guaranteed_performance_change : 1;
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_BIT            0
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_FLAG           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_MASK           0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_)             (((_) >> 0) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * [Bit 2] Excursion_To_Minimum.
         *
         * @remarks If CPUID.06H:EAX.[7] = 1
         * @see Vol3B[14.4.5(HWP Feedback)]
         */
        uint64_t excursion_to_minimum : 1;
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT                     2
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG                    0x04
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK                    0x01
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_)                      (((_) >> 2) & 0x01)
        uint64_t reserved2 : 61;
    };

    uint64_t flags;
} ia32_hwp_status_register;


/**
 * x2APIC ID Register.
 *
 * @remarks If CPUID.01H:ECX[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @see Vol3A[10.12(EXTENDED XAPIC (X2APIC))]
 */
#define IA32_X2APIC_APICID                                           0x00000802

 /**
  * x2APIC Version Register.
  *
  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
  */
#define IA32_X2APIC_VERSION                                          0x00000803

  /**
   * x2APIC Task Priority Register.
   *
   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
   */
#define IA32_X2APIC_TPR                                              0x00000808

   /**
    * x2APIC Processor Priority Register.
    *
    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
    */
#define IA32_X2APIC_PPR                                              0x0000080A

    /**
     * x2APIC EOI Register.
     *
     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
     */
#define IA32_X2APIC_EOI                                              0x0000080B

     /**
      * x2APIC Logical Destination Register.
      *
      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
      */
#define IA32_X2APIC_LDR                                              0x0000080D

      /**
       * x2APIC Spurious Interrupt Vector Register.
       *
       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
       */
#define IA32_X2APIC_SIVR                                             0x0000080F
       /**
        * @defgroup ia32_x2apic_isr \
        *           IA32_X2APIC_ISR(n)
        *
        * x2APIC In-Service Register Bits (n * 32 + 31):(n * 32).
        *
        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
        * @{
        */
#define IA32_X2APIC_ISR0                                             0x00000810
#define IA32_X2APIC_ISR1                                             0x00000811
#define IA32_X2APIC_ISR2                                             0x00000812
#define IA32_X2APIC_ISR3                                             0x00000813
#define IA32_X2APIC_ISR4                                             0x00000814
#define IA32_X2APIC_ISR5                                             0x00000815
#define IA32_X2APIC_ISR6                                             0x00000816
#define IA32_X2APIC_ISR7                                             0x00000817
        /**
         * @}
         */

         /**
          * @defgroup ia32_x2apic_tmr \
          *           IA32_X2APIC_TMR(n)
          *
          * x2APIC Trigger Mode Register Bits (n * 32 + 31):(n * 32).
          *
          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
          * @{
          */
#define IA32_X2APIC_TMR0                                             0x00000818
#define IA32_X2APIC_TMR1                                             0x00000819
#define IA32_X2APIC_TMR2                                             0x0000081A
#define IA32_X2APIC_TMR3                                             0x0000081B
#define IA32_X2APIC_TMR4                                             0x0000081C
#define IA32_X2APIC_TMR5                                             0x0000081D
#define IA32_X2APIC_TMR6                                             0x0000081E
#define IA32_X2APIC_TMR7                                             0x0000081F
          /**
           * @}
           */

           /**
            * @defgroup ia32_x2apic_irr \
            *           IA32_X2APIC_IRR(n)
            *
            * x2APIC Interrupt Request Register Bits (n * 32 + 31):(n * 32).
            *
            * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
            * @{
            */
#define IA32_X2APIC_IRR0                                             0x00000820
#define IA32_X2APIC_IRR1                                             0x00000821
#define IA32_X2APIC_IRR2                                             0x00000822
#define IA32_X2APIC_IRR3                                             0x00000823
#define IA32_X2APIC_IRR4                                             0x00000824
#define IA32_X2APIC_IRR5                                             0x00000825
#define IA32_X2APIC_IRR6                                             0x00000826
#define IA32_X2APIC_IRR7                                             0x00000827
            /**
             * @}
             */


             /**
              * x2APIC Error Status Register.
              *
              * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
              */
#define IA32_X2APIC_ESR                                              0x00000828

              /**
               * x2APIC LVT Corrected Machine Check Interrupt Register.
               *
               * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
               */
#define IA32_X2APIC_LVT_CMCI                                         0x0000082F

               /**
                * x2APIC Interrupt Command Register.
                *
                * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                */
#define IA32_X2APIC_ICR                                              0x00000830

                /**
                 * x2APIC LVT Timer Interrupt Register.
                 *
                 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                 */
#define IA32_X2APIC_LVT_TIMER                                        0x00000832

                 /**
                  * x2APIC LVT Thermal Sensor Interrupt Register.
                  *
                  * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                  */
#define IA32_X2APIC_LVT_THERMAL                                      0x00000833

                  /**
                   * x2APIC LVT Performance Monitor Interrupt Register.
                   *
                   * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                   */
#define IA32_X2APIC_LVT_PMI                                          0x00000834

                   /**
                    * x2APIC LVT LINT0 Register.
                    *
                    * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                    */
#define IA32_X2APIC_LVT_LINT0                                        0x00000835

                    /**
                     * x2APIC LVT LINT1 Register.
                     *
                     * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                     */
#define IA32_X2APIC_LVT_LINT1                                        0x00000836

                     /**
                      * x2APIC LVT Error Register.
                      *
                      * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                      */
#define IA32_X2APIC_LVT_ERROR                                        0x00000837

                      /**
                       * x2APIC Initial Count Register.
                       *
                       * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                       */
#define IA32_X2APIC_INIT_COUNT                                       0x00000838

                       /**
                        * x2APIC Current Count Register.
                        *
                        * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                        */
#define IA32_X2APIC_CUR_COUNT                                        0x00000839

                        /**
                         * x2APIC Divide Configuration Register.
                         *
                         * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                         */
#define IA32_X2APIC_DIV_CONF                                         0x0000083E

                         /**
                          * x2APIC Self IPI Register.
                          *
                          * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
                          */
#define IA32_X2APIC_SELF_IPI                                         0x0000083F

                          /**
                           * Silicon Debug Feature Control.
                           *
                           * @remarks If CPUID.01H:ECX.[11] = 1
                           */
#define IA32_DEBUG_INTERFACE                                         0x00000C80
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] BIOS set 1 to enable Silicon debug features. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        uint64_t enable : 1;
#define IA32_DEBUG_INTERFACE_ENABLE_BIT                              0
#define IA32_DEBUG_INTERFACE_ENABLE_FLAG                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE_MASK                             0x01
#define IA32_DEBUG_INTERFACE_ENABLE(_)                               (((_) >> 0) & 0x01)
        uint64_t reserved1 : 29;

        /**
         * @brief Lock <b>(R/W)</b>
         *
         * [Bit 30] If 1, locks any further change to the MSR. The lock bit is set automatically on the first SMI assertion even if
         * not explicitly set by BIOS. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        uint64_t lock : 1;
#define IA32_DEBUG_INTERFACE_LOCK_BIT                                30
#define IA32_DEBUG_INTERFACE_LOCK_FLAG                               0x40000000
#define IA32_DEBUG_INTERFACE_LOCK_MASK                               0x01
#define IA32_DEBUG_INTERFACE_LOCK(_)                                 (((_) >> 30) & 0x01)

        /**
         * @brief Debug Occurred <b>(R/O)</b>
         *
         * [Bit 31] This "sticky bit" is set by hardware to indicate the status of bit 0. Default is 0.
         *
         * @remarks If CPUID.01H:ECX.[11] = 1
         */
        uint64_t debug_occurred : 1;
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT                      31
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG                     0x80000000
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK                     0x01
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_)                       (((_) >> 31) & 0x01)
        uint64_t reserved2 : 32;
    };

    uint64_t flags;
} ia32_debug_interface_register;


/**
 * L3 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=1):ECX.[2] = 1 )
 */
#define IA32_L3_QOS_CFG                                              0x00000C81
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        uint64_t enable : 1;
#define IA32_L3_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L3_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L3_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L3_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_l3_qos_cfg_register;


/**
 * L2 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=2):ECX.[2] = 1 )
 */
#define IA32_L2_QOS_CFG                                              0x00000C82
typedef union
{
    struct
    {
        /**
         * @brief Enable <b>(R/W)</b>
         *
         * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data Prioritization (CDP) mode.
         */
        uint64_t enable : 1;
#define IA32_L2_QOS_CFG_ENABLE_BIT                                   0
#define IA32_L2_QOS_CFG_ENABLE_FLAG                                  0x01
#define IA32_L2_QOS_CFG_ENABLE_MASK                                  0x01
#define IA32_L2_QOS_CFG_ENABLE(_)                                    (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_l2_qos_cfg_register;


/**
 * Monitoring Event Select Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_EVTSEL                                               0x00000C8D
typedef union
{
    struct
    {
        /**
         * @brief Event ID
         *
         * [Bits 7:0] ID of a supported monitoring event to report via IA32_QM_CTR.
         */
        uint64_t event_id : 8;
#define IA32_QM_EVTSEL_EVENT_ID_BIT                                  0
#define IA32_QM_EVTSEL_EVENT_ID_FLAG                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID_MASK                                 0xFF
#define IA32_QM_EVTSEL_EVENT_ID(_)                                   (((_) >> 0) & 0xFF)
        uint64_t reserved1 : 24;

        /**
         * @brief Resource Monitoring ID
         *
         * [Bits 63:32] ID for monitoring hardware to report monitored data via IA32_QM_CTR.
         *
         * @remarks Bits [N+31:32] N = Ceil (Log2 (CPUID.(EAX= 0FH,ECX=0H).EBX[31:0] + 1))
         */
        uint64_t resource_monitoring_id : 32;
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT                    32
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF00000000
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_)                     (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_qm_evtsel_register;


/**
 * Monitoring Counter Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_CTR                                                  0x00000C8E
typedef union
{
    struct
    {
        /**
         * [Bits 61:0] Resource Monitored Data.
         */
        uint64_t resource_monitored_data : 62;
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_BIT                      0
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_FLAG                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_MASK                     0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA(_)                       (((_) >> 0) & 0x3FFFFFFFFFFFFFFF)

        /**
         * @brief Unavailable
         *
         * [Bit 62] If 1, indicates data for this RMID is not available or not monitored for this resource or RMID.
         */
        uint64_t unavailable : 1;
#define IA32_QM_CTR_UNAVAILABLE_BIT                                  62
#define IA32_QM_CTR_UNAVAILABLE_FLAG                                 0x4000000000000000
#define IA32_QM_CTR_UNAVAILABLE_MASK                                 0x01
#define IA32_QM_CTR_UNAVAILABLE(_)                                   (((_) >> 62) & 0x01)

        /**
         * @brief Error
         *
         * [Bit 63] If 1, indicates an unsupported RMID or event type was written to IA32_PQR_QM_EVTSEL.
         */
        uint64_t error : 1;
#define IA32_QM_CTR_ERROR_BIT                                        63
#define IA32_QM_CTR_ERROR_FLAG                                       0x8000000000000000
#define IA32_QM_CTR_ERROR_MASK                                       0x01
#define IA32_QM_CTR_ERROR(_)                                         (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ia32_qm_ctr_register;


/**
 * Resource Association Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[12] = 1) or (CPUID.(EAX=07H, ECX=0):EBX[15] = 1 ) )
 */
#define IA32_PQR_ASSOC                                               0x00000C8F
typedef union
{
    struct
    {
        /**
         * @brief Resource Monitoring ID <b>(R/W)</b>
         *
         * [Bits 31:0] ID for monitoring hardware to track internal operation, e.g., memory access.
         *
         * @remarks Bits [N-1:0] N = Ceil (Log2 (CPUID.(EAX= 0FH, ECX=0H).EBX[31:0] +1)) 31:N Reserved
         */
        uint64_t resource_monitoring_id : 32;
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_BIT                    0
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_FLAG                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_MASK                   0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_)                     (((_) >> 0) & 0xFFFFFFFF)

        /**
         * @brief COS <b>(R/W)</b>
         *
         * [Bits 63:32] The class of service (COS) to enforce (on writes); returns the current COS when read.
         *
         * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[15] = 1 )
         */
        uint64_t cos : 32;
#define IA32_PQR_ASSOC_COS_BIT                                       32
#define IA32_PQR_ASSOC_COS_FLAG                                      0xFFFFFFFF00000000
#define IA32_PQR_ASSOC_COS_MASK                                      0xFFFFFFFF
#define IA32_PQR_ASSOC_COS(_)                                        (((_) >> 32) & 0xFFFFFFFF)
    };

    uint64_t flags;
} ia32_pqr_assoc_register;


/**
 * Supervisor State of MPX Configuration.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0H):EBX[14] = 1)
 */
#define IA32_BNDCFGS                                                 0x00000D90
typedef union
{
    struct
    {
        /**
         * [Bit 0] Enable Intel MPX in supervisor mode.
         */
        uint64_t enable : 1;
#define IA32_BNDCFGS_ENABLE_BIT                                      0
#define IA32_BNDCFGS_ENABLE_FLAG                                     0x01
#define IA32_BNDCFGS_ENABLE_MASK                                     0x01
#define IA32_BNDCFGS_ENABLE(_)                                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Preserve the bounds registers for near branch instructions in the absence of the BND prefix.
         */
        uint64_t bnd_preserve : 1;
#define IA32_BNDCFGS_BND_PRESERVE_BIT                                1
#define IA32_BNDCFGS_BND_PRESERVE_FLAG                               0x02
#define IA32_BNDCFGS_BND_PRESERVE_MASK                               0x01
#define IA32_BNDCFGS_BND_PRESERVE(_)                                 (((_) >> 1) & 0x01)
        uint64_t reserved1 : 10;

        /**
         * [Bits 63:12] Base Address of Bound Directory.
         */
        uint64_t bound_directory_base_address : 52;
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT                12
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG               0xFFFFFFFFFFFFF000
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK               0xFFFFFFFFFFFFF
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_)                 (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    uint64_t flags;
} ia32_bndcfgs_register;


/**
 * Extended Supervisor State Mask.
 *
 * @remarks If ( CPUID.(0DH, 1):EAX.[3] = 1
 */
#define IA32_XSS                                                     0x00000DA0
typedef union
{
    struct
    {
        uint64_t reserved1 : 8;

        /**
         * [Bit 8] Trace Packet Configuration State.
         */
        uint64_t trace_packet_configuration_state : 1;
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_BIT                8
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_FLAG               0x100
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_MASK               0x01
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_)                 (((_) >> 8) & 0x01)
        uint64_t reserved2 : 55;
    };

    uint64_t flags;
} ia32_xss_register;


/**
 * Package Level Enable/disable HDC.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PKG_HDC_CTL                                             0x00000DB0
typedef union
{
    struct
    {
        /**
         * @brief HDC_Pkg_Enable <b>(R/W)</b>
         *
         * [Bit 0] Force HDC idling or wake up HDC-idled logical processors in the package.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.2(Package level Enabling HDC)]
         */
        uint64_t hdc_pkg_enable : 1;
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_BIT                          0
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_FLAG                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_MASK                         0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_)                           (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_pkg_hdc_ctl_register;


/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PM_CTL1                                                 0x00000DB1
typedef union
{
    struct
    {
        /**
         * @brief HDC_Allow_Block <b>(R/W)</b>
         *
         * [Bit 0] Allow/Block this logical processor for package level HDC control.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.3(Logical-Processor Level HDC Control)]
         */
        uint64_t hdc_allow_block : 1;
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_BIT                             0
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_FLAG                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_MASK                            0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK(_)                              (((_) >> 0) & 0x01)
        uint64_t reserved1 : 63;
    };

    uint64_t flags;
} ia32_pm_ctl1_register;


/**
 * Per-Logical_Processor HDC Idle Residency.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_THREAD_STALL                                            0x00000DB2
typedef struct
{
    /**
     * @brief Stall_Cycle_Cnt <b>(R/W)</b>
     *
     * Stalled cycles due to HDC forced idle on this logical processor.
     *
     * @remarks If CPUID.06H:EAX.[13] = 1
     * @see Vol3B[14.5.4.1(IA32_THREAD_STALL)]
     */
    uint64_t stall_cycle_count;
} ia32_thread_stall_register;


/**
 * Extended Feature Enables.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_EFER                                                    0xC0000080
typedef union
{
    struct
    {
        /**
         * @brief SYSCALL Enable <b>(R/W)</b>
         *
         * [Bit 0] Enables SYSCALL/SYSRET instructions in 64-bit mode.
         */
        uint64_t syscall_enable : 1;
#define IA32_EFER_SYSCALL_ENABLE_BIT                                 0
#define IA32_EFER_SYSCALL_ENABLE_FLAG                                0x01
#define IA32_EFER_SYSCALL_ENABLE_MASK                                0x01
#define IA32_EFER_SYSCALL_ENABLE(_)                                  (((_) >> 0) & 0x01)
        uint64_t reserved1 : 7;

        /**
         * @brief IA-32e Mode Enable <b>(R/W)</b>
         *
         * [Bit 8] Enables IA-32e mode operation.
         */
        uint64_t ia32e_mode_enable : 1;
#define IA32_EFER_IA32E_MODE_ENABLE_BIT                              8
#define IA32_EFER_IA32E_MODE_ENABLE_FLAG                             0x100
#define IA32_EFER_IA32E_MODE_ENABLE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ENABLE(_)                               (((_) >> 8) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief IA-32e Mode Active <b>(R)</b>
         *
         * [Bit 10] Indicates IA-32e mode is active when set.
         */
        uint64_t ia32e_mode_active : 1;
#define IA32_EFER_IA32E_MODE_ACTIVE_BIT                              10
#define IA32_EFER_IA32E_MODE_ACTIVE_FLAG                             0x400
#define IA32_EFER_IA32E_MODE_ACTIVE_MASK                             0x01
#define IA32_EFER_IA32E_MODE_ACTIVE(_)                               (((_) >> 10) & 0x01)

        /**
         * [Bit 11] Execute Disable Bit Enable.
         */
        uint64_t execute_disable_bit_enable : 1;
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT                     11
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG                    0x800
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK                    0x01
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_)                      (((_) >> 11) & 0x01)
        uint64_t reserved3 : 52;
    };

    uint64_t flags;
} ia32_efer_register;


/**
 * System Call Target Address.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_STAR                                                    0xC0000081

 /**
  * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
  *
  * Target RIP for the called procedure when SYSCALL is executed in 64-bit mode.
  *
  * @remarks If CPUID.80000001:EDX.[29] = 1
  */
#define IA32_LSTAR                                                   0xC0000082

  /**
   * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
   *
   * Not used, as the SYSCALL instruction is not recognized in compatibility mode.
   *
   * @remarks If CPUID.80000001:EDX.[29] = 1
   */
#define IA32_CSTAR                                                   0xC0000083

   /**
    * System Call Flag Mask.
    *
    * @remarks If CPUID.80000001:EDX.[29] = 1
    */
#define IA32_FMASK                                                   0xC0000084

    /**
     * Map of BASE Address of FS.
     *
     * @remarks If CPUID.80000001:EDX.[29] = 1
     */
#define IA32_FS_BASE                                                 0xC0000100

     /**
      * Map of BASE Address of GS.
      *
      * @remarks If CPUID.80000001:EDX.[29] = 1
      */
#define IA32_GS_BASE                                                 0xC0000101

      /**
       * Swap Target of BASE Address of GS.
       *
       * @remarks If CPUID.80000001:EDX.[29] = 1
       */
#define IA32_KERNEL_GS_BASE                                          0xC0000102

       /**
        * Auxiliary TSC.
        *
        * @remarks If CPUID.80000001H: EDX[27] = 1 or CPUID.(EAX=7,ECX=0):ECX[bit 22] = 1
        */
#define IA32_TSC_AUX                                                 0xC0000103
typedef union
{
    struct
    {
        /**
         * [Bits 31:0] AUX. Auxiliary signature of TSC.
         */
        uint64_t tsc_auxiliary_signature : 32;
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_BIT                     0
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_FLAG                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_MASK                    0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_)                      (((_) >> 0) & 0xFFFFFFFF)
        uint64_t reserved1 : 32;
    };

    uint64_t flags;
} ia32_tsc_aux_register;

/**
 * @}
 */

 /**
  * @defgroup paging \
  *           Paging
  * @{
  */
  /**
   * @defgroup paging_32 \
   *           32-Bit Paging
   *
   * A logical processor uses 32-bit paging if CR0.PG = 1 and CR4.PAE = 0. 32-bit paging translates 32-bit linear addresses
   * to 40-bit physical addresses. Although 40 bits corresponds to 1 TByte, linear addresses are limited to 32 bits; at most
   * 4 GBytes of linear-address space may be accessed at any given time.
   * 32-bit paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to locate
   * the first paging-structure, the page directory. 32-bit paging may map linear addresses to either 4-KByte pages or
   * 4-MByte pages.
   *
   * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
   * @{
   */
   /**
    * @brief Format of a 32-Bit Page-Directory Entry that Maps a 4-MByte Page
    */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-MByte page.
         */
        uint32_t present : 1;
#define PDE_4MB_32_PRESENT_BIT                                       0
#define PDE_4MB_32_PRESENT_FLAG                                      0x01
#define PDE_4MB_32_PRESENT_MASK                                      0x01
#define PDE_4MB_32_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint32_t write : 1;
#define PDE_4MB_32_WRITE_BIT                                         1
#define PDE_4MB_32_WRITE_FLAG                                        0x02
#define PDE_4MB_32_WRITE_MASK                                        0x01
#define PDE_4MB_32_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint32_t supervisor : 1;
#define PDE_4MB_32_SUPERVISOR_BIT                                    2
#define PDE_4MB_32_SUPERVISOR_FLAG                                   0x04
#define PDE_4MB_32_SUPERVISOR_MASK                                   0x01
#define PDE_4MB_32_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t page_level_write_through : 1;
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t page_level_cache_disable : 1;
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint32_t accessed : 1;
#define PDE_4MB_32_ACCESSED_BIT                                      5
#define PDE_4MB_32_ACCESSED_FLAG                                     0x20
#define PDE_4MB_32_ACCESSED_MASK                                     0x01
#define PDE_4MB_32_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint32_t dirty : 1;
#define PDE_4MB_32_DIRTY_BIT                                         6
#define PDE_4MB_32_DIRTY_FLAG                                        0x40
#define PDE_4MB_32_DIRTY_MASK                                        0x01
#define PDE_4MB_32_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page table).
         */
        uint32_t large_page : 1;
#define PDE_4MB_32_LARGE_PAGE_BIT                                    7
#define PDE_4MB_32_LARGE_PAGE_FLAG                                   0x80
#define PDE_4MB_32_LARGE_PAGE_MASK                                   0x01
#define PDE_4MB_32_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        uint32_t global : 1;
#define PDE_4MB_32_GLOBAL_BIT                                        8
#define PDE_4MB_32_GLOBAL_FLAG                                       0x100
#define PDE_4MB_32_GLOBAL_MASK                                       0x01
#define PDE_4MB_32_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        uint32_t ignored_1 : 3;
#define PDE_4MB_32_IGNORED_1_BIT                                     9
#define PDE_4MB_32_IGNORED_1_FLAG                                    0xE00
#define PDE_4MB_32_IGNORED_1_MASK                                    0x07
#define PDE_4MB_32_IGNORED_1(_)                                      (((_) >> 9) & 0x07)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 4-MByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t pat : 1;
#define PDE_4MB_32_PAT_BIT                                           12
#define PDE_4MB_32_PAT_FLAG                                          0x1000
#define PDE_4MB_32_PAT_MASK                                          0x01
#define PDE_4MB_32_PAT(_)                                            (((_) >> 12) & 0x01)

        /**
         * [Bits 20:13] Bits (M-1):32 of physical address of the 4-MByte page referenced by this entry.
         */
        uint32_t page_frame_number_low : 8;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT                         13
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG                        0x1FE000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK                        0xFF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_)                          (((_) >> 13) & 0xFF)
        uint32_t reserved1 : 1;

        /**
         * [Bits 31:22] Bits 31:22 of physical address of the 4-MByte page referenced by this entry.
         */
        uint32_t page_frame_number_high : 10;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT                        22
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG                       0xFFC00000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK                       0x3FF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_)                         (((_) >> 22) & 0x3FF)
    };

    uint32_t flags;
} pde_4mb_32;

/**
 * @brief Format of a 32-Bit Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        uint32_t present : 1;
#define PDE_32_PRESENT_BIT                                           0
#define PDE_32_PRESENT_FLAG                                          0x01
#define PDE_32_PRESENT_MASK                                          0x01
#define PDE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint32_t write : 1;
#define PDE_32_WRITE_BIT                                             1
#define PDE_32_WRITE_FLAG                                            0x02
#define PDE_32_WRITE_MASK                                            0x01
#define PDE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint32_t supervisor : 1;
#define PDE_32_SUPERVISOR_BIT                                        2
#define PDE_32_SUPERVISOR_FLAG                                       0x04
#define PDE_32_SUPERVISOR_MASK                                       0x01
#define PDE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t page_level_write_through : 1;
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t page_level_cache_disable : 1;
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint32_t accessed : 1;
#define PDE_32_ACCESSED_BIT                                          5
#define PDE_32_ACCESSED_FLAG                                         0x20
#define PDE_32_ACCESSED_MASK                                         0x01
#define PDE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Ignored.
         */
        uint32_t ignored_1 : 1;
#define PDE_32_IGNORED_1_BIT                                         6
#define PDE_32_IGNORED_1_FLAG                                        0x40
#define PDE_32_IGNORED_1_MASK                                        0x01
#define PDE_32_IGNORED_1(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] If CR4.PSE = 1, must be 0 (otherwise, this entry maps a 4-MByte page); otherwise, ignored.
         */
        uint32_t large_page : 1;
#define PDE_32_LARGE_PAGE_BIT                                        7
#define PDE_32_LARGE_PAGE_FLAG                                       0x80
#define PDE_32_LARGE_PAGE_MASK                                       0x01
#define PDE_32_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 11:8] Ignored.
         */
        uint32_t ignored_2 : 4;
#define PDE_32_IGNORED_2_BIT                                         8
#define PDE_32_IGNORED_2_FLAG                                        0xF00
#define PDE_32_IGNORED_2_MASK                                        0x0F
#define PDE_32_IGNORED_2(_)                                          (((_) >> 8) & 0x0F)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        uint32_t page_frame_number : 20;
#define PDE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PDE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PDE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    uint32_t flags;
} pde_32;

/**
 * @brief Format of a 32-Bit Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        uint32_t present : 1;
#define PTE_32_PRESENT_BIT                                           0
#define PTE_32_PRESENT_FLAG                                          0x01
#define PTE_32_PRESENT_MASK                                          0x01
#define PTE_32_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint32_t write : 1;
#define PTE_32_WRITE_BIT                                             1
#define PTE_32_WRITE_FLAG                                            0x02
#define PTE_32_WRITE_MASK                                            0x01
#define PTE_32_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint32_t supervisor : 1;
#define PTE_32_SUPERVISOR_BIT                                        2
#define PTE_32_SUPERVISOR_FLAG                                       0x04
#define PTE_32_SUPERVISOR_MASK                                       0x01
#define PTE_32_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t page_level_write_through : 1;
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t page_level_cache_disable : 1;
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint32_t accessed : 1;
#define PTE_32_ACCESSED_BIT                                          5
#define PTE_32_ACCESSED_FLAG                                         0x20
#define PTE_32_ACCESSED_MASK                                         0x01
#define PTE_32_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint32_t dirty : 1;
#define PTE_32_DIRTY_BIT                                             6
#define PTE_32_DIRTY_FLAG                                            0x40
#define PTE_32_DIRTY_MASK                                            0x01
#define PTE_32_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint32_t pat : 1;
#define PTE_32_PAT_BIT                                               7
#define PTE_32_PAT_FLAG                                              0x80
#define PTE_32_PAT_MASK                                              0x01
#define PTE_32_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        uint32_t global : 1;
#define PTE_32_GLOBAL_BIT                                            8
#define PTE_32_GLOBAL_FLAG                                           0x100
#define PTE_32_GLOBAL_MASK                                           0x01
#define PTE_32_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        uint32_t ignored_1 : 3;
#define PTE_32_IGNORED_1_BIT                                         9
#define PTE_32_IGNORED_1_FLAG                                        0xE00
#define PTE_32_IGNORED_1_MASK                                        0x07
#define PTE_32_IGNORED_1(_)                                          (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        uint32_t page_frame_number : 20;
#define PTE_32_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_32_PAGE_FRAME_NUMBER_FLAG                                0xFFFFF000
#define PTE_32_PAGE_FRAME_NUMBER_MASK                                0xFFFFF
#define PTE_32_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFF)
    };

    uint32_t flags;
} pte_32;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        uint32_t present : 1;
#define PT_ENTRY_32_PRESENT_BIT                                      0
#define PT_ENTRY_32_PRESENT_FLAG                                     0x01
#define PT_ENTRY_32_PRESENT_MASK                                     0x01
#define PT_ENTRY_32_PRESENT(_)                                       (((_) >> 0) & 0x01)
        uint32_t write : 1;
#define PT_ENTRY_32_WRITE_BIT                                        1
#define PT_ENTRY_32_WRITE_FLAG                                       0x02
#define PT_ENTRY_32_WRITE_MASK                                       0x01
#define PT_ENTRY_32_WRITE(_)                                         (((_) >> 1) & 0x01)
        uint32_t supervisor : 1;
#define PT_ENTRY_32_SUPERVISOR_BIT                                   2
#define PT_ENTRY_32_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_32_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_32_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        uint32_t page_level_write_through : 1;
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        uint32_t page_level_cache_disable : 1;
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        uint32_t accessed : 1;
#define PT_ENTRY_32_ACCESSED_BIT                                     5
#define PT_ENTRY_32_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_32_ACCESSED_MASK                                    0x01
#define PT_ENTRY_32_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        uint32_t dirty : 1;
#define PT_ENTRY_32_DIRTY_BIT                                        6
#define PT_ENTRY_32_DIRTY_FLAG                                       0x40
#define PT_ENTRY_32_DIRTY_MASK                                       0x01
#define PT_ENTRY_32_DIRTY(_)                                         (((_) >> 6) & 0x01)
        uint32_t large_page : 1;
#define PT_ENTRY_32_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_32_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_32_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_32_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        uint32_t global : 1;
#define PT_ENTRY_32_GLOBAL_BIT                                       8
#define PT_ENTRY_32_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_32_GLOBAL_MASK                                      0x01
#define PT_ENTRY_32_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 11:9] Ignored.
         */
        uint32_t ignored_1 : 3;
#define PT_ENTRY_32_IGNORED_1_BIT                                    9
#define PT_ENTRY_32_IGNORED_1_FLAG                                   0xE00
#define PT_ENTRY_32_IGNORED_1_MASK                                   0x07
#define PT_ENTRY_32_IGNORED_1(_)                                     (((_) >> 9) & 0x07)

        /**
         * [Bits 31:12] Physical address of the 4-KByte page referenced by this entry.
         */
        uint32_t page_frame_number : 20;
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG                           0xFFFFF000
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK                           0xFFFFF
#define PT_ENTRY_32_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFF)
    };

    uint32_t flags;
} pt_entry_32;

/**
 * @defgroup paging_structures_entry_count_32 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PDE_ENTRY_COUNT_32                                           0x00000400
#define PTE_ENTRY_COUNT_32                                           0x00000400
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @defgroup paging_64 \
    *           64-Bit (4-Level) Paging
    *
    * A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, and IA32_EFER.LME = 1. With 4-level paging, linear
    * address are translated using a hierarchy of in-memory paging structures located using the contents of CR3. 4-level
    * paging translates 48-bit linear addresses to 52-bit physical addresses. Although 52 bits corresponds to 4 PBytes, linear
    * addresses are limited to 48 bits; at most 256 TBytes of linear-address space may be accessed at any given time.
    * 4-level paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3 is used to
    * locate the first paging-structure, the PML4 table. Use of CR3 with 4-level paging depends on whether processcontext
    * identifiers (PCIDs) have been enabled by setting CR4.PCIDE.
    *
    * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
    * @{
    */
    /**
     * @brief Format of a 4-Level PML4 Entry (PML4E) that References a Page-Directory-Pointer Table
     */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page-directory-pointer table.
         */
        uint64_t present : 1;
#define PML4E_64_PRESENT_BIT                                         0
#define PML4E_64_PRESENT_FLAG                                        0x01
#define PML4E_64_PRESENT_MASK                                        0x01
#define PML4E_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t write : 1;
#define PML4E_64_WRITE_BIT                                           1
#define PML4E_64_WRITE_FLAG                                          0x02
#define PML4E_64_WRITE_MASK                                          0x01
#define PML4E_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 512-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t supervisor : 1;
#define PML4E_64_SUPERVISOR_BIT                                      2
#define PML4E_64_SUPERVISOR_FLAG                                     0x04
#define PML4E_64_SUPERVISOR_MASK                                     0x01
#define PML4E_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_write_through : 1;
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page-directory-pointer table
         * referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_cache_disable : 1;
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t accessed : 1;
#define PML4E_64_ACCESSED_BIT                                        5
#define PML4E_64_ACCESSED_FLAG                                       0x20
#define PML4E_64_ACCESSED_MASK                                       0x01
#define PML4E_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * [Bit 7] Reserved (must be 0).
         */
        uint64_t must_be_zero : 1;
#define PML4E_64_MUST_BE_ZERO_BIT                                    7
#define PML4E_64_MUST_BE_ZERO_FLAG                                   0x80
#define PML4E_64_MUST_BE_ZERO_MASK                                   0x01
#define PML4E_64_MUST_BE_ZERO(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bits 10:8] Ignored.
         */
        uint64_t ignored_1 : 3;
#define PML4E_64_IGNORED_1_BIT                                       8
#define PML4E_64_IGNORED_1_FLAG                                      0x700
#define PML4E_64_IGNORED_1_MASK                                      0x07
#define PML4E_64_IGNORED_1(_)                                        (((_) >> 8) & 0x07)

        /**
         * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
         * ordinary paging)
         *
         * @see Vol3A[4.5.5(Restart of HLAT Paging)]
         */
        uint64_t restart : 1;
#define PML4E_64_RESTART_BIT                                         11
#define PML4E_64_RESTART_FLAG                                        0x800
#define PML4E_64_RESTART_MASK                                        0x01
#define PML4E_64_RESTART(_)                                          (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page-directory-pointer table referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define PML4E_64_PAGE_FRAME_NUMBER_BIT                               12
#define PML4E_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PML4E_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PML4E_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        uint64_t ignored_2 : 11;
#define PML4E_64_IGNORED_2_BIT                                       52
#define PML4E_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PML4E_64_IGNORED_2_MASK                                      0x7FF
#define PML4E_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 512-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t execute_disable : 1;
#define PML4E_64_EXECUTE_DISABLE_BIT                                 63
#define PML4E_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PML4E_64_EXECUTE_DISABLE_MASK                                0x01
#define PML4E_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} pml4e_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 1-GByte page.
         */
        uint64_t present : 1;
#define PDPTE_1GB_64_PRESENT_BIT                                     0
#define PDPTE_1GB_64_PRESENT_FLAG                                    0x01
#define PDPTE_1GB_64_PRESENT_MASK                                    0x01
#define PDPTE_1GB_64_PRESENT(_)                                      (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t write : 1;
#define PDPTE_1GB_64_WRITE_BIT                                       1
#define PDPTE_1GB_64_WRITE_FLAG                                      0x02
#define PDPTE_1GB_64_WRITE_MASK                                      0x01
#define PDPTE_1GB_64_WRITE(_)                                        (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t supervisor : 1;
#define PDPTE_1GB_64_SUPERVISOR_BIT                                  2
#define PDPTE_1GB_64_SUPERVISOR_FLAG                                 0x04
#define PDPTE_1GB_64_SUPERVISOR_MASK                                 0x01
#define PDPTE_1GB_64_SUPERVISOR(_)                                   (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_write_through : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                    3
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                   0x08
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 1-GByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_cache_disable : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                    4
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                   0x10
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                   0x01
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_)                     (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t accessed : 1;
#define PDPTE_1GB_64_ACCESSED_BIT                                    5
#define PDPTE_1GB_64_ACCESSED_FLAG                                   0x20
#define PDPTE_1GB_64_ACCESSED_MASK                                   0x01
#define PDPTE_1GB_64_ACCESSED(_)                                     (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 1-GByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t dirty : 1;
#define PDPTE_1GB_64_DIRTY_BIT                                       6
#define PDPTE_1GB_64_DIRTY_FLAG                                      0x40
#define PDPTE_1GB_64_DIRTY_MASK                                      0x01
#define PDPTE_1GB_64_DIRTY(_)                                        (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        uint64_t large_page : 1;
#define PDPTE_1GB_64_LARGE_PAGE_BIT                                  7
#define PDPTE_1GB_64_LARGE_PAGE_FLAG                                 0x80
#define PDPTE_1GB_64_LARGE_PAGE_MASK                                 0x01
#define PDPTE_1GB_64_LARGE_PAGE(_)                                   (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        uint64_t global : 1;
#define PDPTE_1GB_64_GLOBAL_BIT                                      8
#define PDPTE_1GB_64_GLOBAL_FLAG                                     0x100
#define PDPTE_1GB_64_GLOBAL_MASK                                     0x01
#define PDPTE_1GB_64_GLOBAL(_)                                       (((_) >> 8) & 0x01)

        /**
         * [Bits 10:9] Ignored.
         */
        uint64_t ignored_1 : 2;
#define PDPTE_1GB_64_IGNORED_1_BIT                                   9
#define PDPTE_1GB_64_IGNORED_1_FLAG                                  0x600
#define PDPTE_1GB_64_IGNORED_1_MASK                                  0x03
#define PDPTE_1GB_64_IGNORED_1(_)                                    (((_) >> 9) & 0x03)

        /**
         * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
         * ordinary paging)
         *
         * @see Vol3A[4.5.5(Restart of HLAT Paging)]
         */
        uint64_t restart : 1;
#define PDPTE_1GB_64_RESTART_BIT                                     11
#define PDPTE_1GB_64_RESTART_FLAG                                    0x800
#define PDPTE_1GB_64_RESTART_MASK                                    0x01
#define PDPTE_1GB_64_RESTART(_)                                      (((_) >> 11) & 0x01)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 1-GByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t pat : 1;
#define PDPTE_1GB_64_PAT_BIT                                         12
#define PDPTE_1GB_64_PAT_FLAG                                        0x1000
#define PDPTE_1GB_64_PAT_MASK                                        0x01
#define PDPTE_1GB_64_PAT(_)                                          (((_) >> 12) & 0x01)
        uint64_t reserved1 : 17;

        /**
         * [Bits 47:30] Physical address of the 1-GByte page referenced by this entry.
         */
        uint64_t page_frame_number : 18;
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT                           30
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG                          0xFFFFC0000000
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK                          0x3FFFF
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER(_)                            (((_) >> 30) & 0x3FFFF)
        uint64_t reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        uint64_t ignored_2 : 7;
#define PDPTE_1GB_64_IGNORED_2_BIT                                   52
#define PDPTE_1GB_64_IGNORED_2_FLAG                                  0x7F0000000000000
#define PDPTE_1GB_64_IGNORED_2_MASK                                  0x7F
#define PDPTE_1GB_64_IGNORED_2(_)                                    (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        uint64_t protection_key : 4;
#define PDPTE_1GB_64_PROTECTION_KEY_BIT                              59
#define PDPTE_1GB_64_PROTECTION_KEY_FLAG                             0x7800000000000000
#define PDPTE_1GB_64_PROTECTION_KEY_MASK                             0x0F
#define PDPTE_1GB_64_PROTECTION_KEY(_)                               (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t execute_disable : 1;
#define PDPTE_1GB_64_EXECUTE_DISABLE_BIT                             63
#define PDPTE_1GB_64_EXECUTE_DISABLE_FLAG                            0x8000000000000000
#define PDPTE_1GB_64_EXECUTE_DISABLE_MASK                            0x01
#define PDPTE_1GB_64_EXECUTE_DISABLE(_)                              (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} pdpte_1gb_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that References a Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page directory.
         */
        uint64_t present : 1;
#define PDPTE_64_PRESENT_BIT                                         0
#define PDPTE_64_PRESENT_FLAG                                        0x01
#define PDPTE_64_PRESENT_MASK                                        0x01
#define PDPTE_64_PRESENT(_)                                          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t write : 1;
#define PDPTE_64_WRITE_BIT                                           1
#define PDPTE_64_WRITE_FLAG                                          0x02
#define PDPTE_64_WRITE_MASK                                          0x01
#define PDPTE_64_WRITE(_)                                            (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t supervisor : 1;
#define PDPTE_64_SUPERVISOR_BIT                                      2
#define PDPTE_64_SUPERVISOR_FLAG                                     0x04
#define PDPTE_64_SUPERVISOR_MASK                                     0x01
#define PDPTE_64_SUPERVISOR(_)                                       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_write_through : 1;
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                        3
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                       0x08
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page directory referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_cache_disable : 1;
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                        4
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                       0x10
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                       0x01
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                         (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t accessed : 1;
#define PDPTE_64_ACCESSED_BIT                                        5
#define PDPTE_64_ACCESSED_FLAG                                       0x20
#define PDPTE_64_ACCESSED_MASK                                       0x01
#define PDPTE_64_ACCESSED(_)                                         (((_) >> 5) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 1-GByte page).
         */
        uint64_t large_page : 1;
#define PDPTE_64_LARGE_PAGE_BIT                                      7
#define PDPTE_64_LARGE_PAGE_FLAG                                     0x80
#define PDPTE_64_LARGE_PAGE_MASK                                     0x01
#define PDPTE_64_LARGE_PAGE(_)                                       (((_) >> 7) & 0x01)

        /**
         * [Bits 10:8] Ignored.
         */
        uint64_t ignored_1 : 3;
#define PDPTE_64_IGNORED_1_BIT                                       8
#define PDPTE_64_IGNORED_1_FLAG                                      0x700
#define PDPTE_64_IGNORED_1_MASK                                      0x07
#define PDPTE_64_IGNORED_1(_)                                        (((_) >> 8) & 0x07)

        /**
         * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
         * ordinary paging)
         *
         * @see Vol3A[4.5.5(Restart of HLAT Paging)]
         */
        uint64_t restart : 1;
#define PDPTE_64_RESTART_BIT                                         11
#define PDPTE_64_RESTART_FLAG                                        0x800
#define PDPTE_64_RESTART_MASK                                        0x01
#define PDPTE_64_RESTART(_)                                          (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page directory referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define PDPTE_64_PAGE_FRAME_NUMBER_BIT                               12
#define PDPTE_64_PAGE_FRAME_NUMBER_FLAG                              0xFFFFFFFFF000
#define PDPTE_64_PAGE_FRAME_NUMBER_MASK                              0xFFFFFFFFF
#define PDPTE_64_PAGE_FRAME_NUMBER(_)                                (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        uint64_t ignored_2 : 11;
#define PDPTE_64_IGNORED_2_BIT                                       52
#define PDPTE_64_IGNORED_2_FLAG                                      0x7FF0000000000000
#define PDPTE_64_IGNORED_2_MASK                                      0x7FF
#define PDPTE_64_IGNORED_2(_)                                        (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t execute_disable : 1;
#define PDPTE_64_EXECUTE_DISABLE_BIT                                 63
#define PDPTE_64_EXECUTE_DISABLE_FLAG                                0x8000000000000000
#define PDPTE_64_EXECUTE_DISABLE_MASK                                0x01
#define PDPTE_64_EXECUTE_DISABLE(_)                                  (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} pdpte_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 2-MByte page.
         */
        uint64_t present : 1;
#define PDE_2MB_64_PRESENT_BIT                                       0
#define PDE_2MB_64_PRESENT_FLAG                                      0x01
#define PDE_2MB_64_PRESENT_MASK                                      0x01
#define PDE_2MB_64_PRESENT(_)                                        (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t write : 1;
#define PDE_2MB_64_WRITE_BIT                                         1
#define PDE_2MB_64_WRITE_FLAG                                        0x02
#define PDE_2MB_64_WRITE_MASK                                        0x01
#define PDE_2MB_64_WRITE(_)                                          (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t supervisor : 1;
#define PDE_2MB_64_SUPERVISOR_BIT                                    2
#define PDE_2MB_64_SUPERVISOR_FLAG                                   0x04
#define PDE_2MB_64_SUPERVISOR_MASK                                   0x01
#define PDE_2MB_64_SUPERVISOR(_)                                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_write_through : 1;
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT                      3
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                     0x08
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_)                       (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 2-MByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_cache_disable : 1;
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT                      4
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                     0x10
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK                     0x01
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_)                       (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t accessed : 1;
#define PDE_2MB_64_ACCESSED_BIT                                      5
#define PDE_2MB_64_ACCESSED_FLAG                                     0x20
#define PDE_2MB_64_ACCESSED_MASK                                     0x01
#define PDE_2MB_64_ACCESSED(_)                                       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 2-MByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t dirty : 1;
#define PDE_2MB_64_DIRTY_BIT                                         6
#define PDE_2MB_64_DIRTY_FLAG                                        0x40
#define PDE_2MB_64_DIRTY_MASK                                        0x01
#define PDE_2MB_64_DIRTY(_)                                          (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
         */
        uint64_t large_page : 1;
#define PDE_2MB_64_LARGE_PAGE_BIT                                    7
#define PDE_2MB_64_LARGE_PAGE_FLAG                                   0x80
#define PDE_2MB_64_LARGE_PAGE_MASK                                   0x01
#define PDE_2MB_64_LARGE_PAGE(_)                                     (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        uint64_t global : 1;
#define PDE_2MB_64_GLOBAL_BIT                                        8
#define PDE_2MB_64_GLOBAL_FLAG                                       0x100
#define PDE_2MB_64_GLOBAL_MASK                                       0x01
#define PDE_2MB_64_GLOBAL(_)                                         (((_) >> 8) & 0x01)

        /**
         * [Bits 10:9] Ignored.
         */
        uint64_t ignored_1 : 2;
#define PDE_2MB_64_IGNORED_1_BIT                                     9
#define PDE_2MB_64_IGNORED_1_FLAG                                    0x600
#define PDE_2MB_64_IGNORED_1_MASK                                    0x03
#define PDE_2MB_64_IGNORED_1(_)                                      (((_) >> 9) & 0x03)

        /**
         * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
         * ordinary paging)
         *
         * @see Vol3A[4.5.5(Restart of HLAT Paging)]
         */
        uint64_t restart : 1;
#define PDE_2MB_64_RESTART_BIT                                       11
#define PDE_2MB_64_RESTART_FLAG                                      0x800
#define PDE_2MB_64_RESTART_MASK                                      0x01
#define PDE_2MB_64_RESTART(_)                                        (((_) >> 11) & 0x01)

        /**
         * [Bit 12] Indirectly determines the memory type used to access the 2-MByte page referenced by this entry.
         *
         * @note The PAT is supported on all processors that support 4-level paging.
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t pat : 1;
#define PDE_2MB_64_PAT_BIT                                           12
#define PDE_2MB_64_PAT_FLAG                                          0x1000
#define PDE_2MB_64_PAT_MASK                                          0x01
#define PDE_2MB_64_PAT(_)                                            (((_) >> 12) & 0x01)
        uint64_t reserved1 : 8;

        /**
         * [Bits 47:21] Physical address of the 2-MByte page referenced by this entry.
         */
        uint64_t page_frame_number : 27;
#define PDE_2MB_64_PAGE_FRAME_NUMBER_BIT                             21
#define PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG                            0xFFFFFFE00000
#define PDE_2MB_64_PAGE_FRAME_NUMBER_MASK                            0x7FFFFFF
#define PDE_2MB_64_PAGE_FRAME_NUMBER(_)                              (((_) >> 21) & 0x7FFFFFF)
        uint64_t reserved2 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        uint64_t ignored_2 : 7;
#define PDE_2MB_64_IGNORED_2_BIT                                     52
#define PDE_2MB_64_IGNORED_2_FLAG                                    0x7F0000000000000
#define PDE_2MB_64_IGNORED_2_MASK                                    0x7F
#define PDE_2MB_64_IGNORED_2(_)                                      (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        uint64_t protection_key : 4;
#define PDE_2MB_64_PROTECTION_KEY_BIT                                59
#define PDE_2MB_64_PROTECTION_KEY_FLAG                               0x7800000000000000
#define PDE_2MB_64_PROTECTION_KEY_MASK                               0x0F
#define PDE_2MB_64_PROTECTION_KEY(_)                                 (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t execute_disable : 1;
#define PDE_2MB_64_EXECUTE_DISABLE_BIT                               63
#define PDE_2MB_64_EXECUTE_DISABLE_FLAG                              0x8000000000000000
#define PDE_2MB_64_EXECUTE_DISABLE_MASK                              0x01
#define PDE_2MB_64_EXECUTE_DISABLE(_)                                (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} pde_2mb_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that References a Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to reference a page table.
         */
        uint64_t present : 1;
#define PDE_64_PRESENT_BIT                                           0
#define PDE_64_PRESENT_FLAG                                          0x01
#define PDE_64_PRESENT_MASK                                          0x01
#define PDE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t write : 1;
#define PDE_64_WRITE_BIT                                             1
#define PDE_64_WRITE_FLAG                                            0x02
#define PDE_64_WRITE_MASK                                            0x01
#define PDE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte region controlled by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t supervisor : 1;
#define PDE_64_SUPERVISOR_BIT                                        2
#define PDE_64_SUPERVISOR_FLAG                                       0x04
#define PDE_64_SUPERVISOR_MASK                                       0x01
#define PDE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_write_through : 1;
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the page table referenced by this
         * entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_cache_disable : 1;
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether this entry has been used for linear-address translation.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t accessed : 1;
#define PDE_64_ACCESSED_BIT                                          5
#define PDE_64_ACCESSED_FLAG                                         0x20
#define PDE_64_ACCESSED_MASK                                         0x01
#define PDE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 2-MByte page).
         */
        uint64_t large_page : 1;
#define PDE_64_LARGE_PAGE_BIT                                        7
#define PDE_64_LARGE_PAGE_FLAG                                       0x80
#define PDE_64_LARGE_PAGE_MASK                                       0x01
#define PDE_64_LARGE_PAGE(_)                                         (((_) >> 7) & 0x01)

        /**
         * [Bits 10:8] Ignored.
         */
        uint64_t ignored_1 : 3;
#define PDE_64_IGNORED_1_BIT                                         8
#define PDE_64_IGNORED_1_FLAG                                        0x700
#define PDE_64_IGNORED_1_MASK                                        0x07
#define PDE_64_IGNORED_1(_)                                          (((_) >> 8) & 0x07)

        /**
         * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
         * ordinary paging)
         *
         * @see Vol3A[4.5.5(Restart of HLAT Paging)]
         */
        uint64_t restart : 1;
#define PDE_64_RESTART_BIT                                           11
#define PDE_64_RESTART_FLAG                                          0x800
#define PDE_64_RESTART_MASK                                          0x01
#define PDE_64_RESTART(_)                                            (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned page table referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define PDE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PDE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PDE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PDE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved2 : 4;

        /**
         * [Bits 62:52] Ignored.
         */
        uint64_t ignored_2 : 11;
#define PDE_64_IGNORED_2_BIT                                         52
#define PDE_64_IGNORED_2_FLAG                                        0x7FF0000000000000
#define PDE_64_IGNORED_2_MASK                                        0x7FF
#define PDE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7FF)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 2-MByte region
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t execute_disable : 1;
#define PDE_64_EXECUTE_DISABLE_BIT                                   63
#define PDE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PDE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PDE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} pde_64;

/**
 * @brief Format of a 4-Level Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Present; must be 1 to map a 4-KByte page.
         */
        uint64_t present : 1;
#define PTE_64_PRESENT_BIT                                           0
#define PTE_64_PRESENT_FLAG                                          0x01
#define PTE_64_PRESENT_MASK                                          0x01
#define PTE_64_PRESENT(_)                                            (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t write : 1;
#define PTE_64_WRITE_BIT                                             1
#define PTE_64_WRITE_FLAG                                            0x02
#define PTE_64_WRITE_MASK                                            0x01
#define PTE_64_WRITE(_)                                              (((_) >> 1) & 0x01)

        /**
         * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t supervisor : 1;
#define PTE_64_SUPERVISOR_BIT                                        2
#define PTE_64_SUPERVISOR_FLAG                                       0x04
#define PTE_64_SUPERVISOR_MASK                                       0x01
#define PTE_64_SUPERVISOR(_)                                         (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_write_through : 1;
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT                          3
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                         0x08
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK                         0x01
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH(_)                           (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the 4-KByte page referenced by
         * this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t page_level_cache_disable : 1;
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT                          4
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                         0x10
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK                         0x01
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE(_)                           (((_) >> 4) & 0x01)

        /**
         * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t accessed : 1;
#define PTE_64_ACCESSED_BIT                                          5
#define PTE_64_ACCESSED_FLAG                                         0x20
#define PTE_64_ACCESSED_MASK                                         0x01
#define PTE_64_ACCESSED(_)                                           (((_) >> 5) & 0x01)

        /**
         * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.8(Accessed and Dirty Flags)]
         */
        uint64_t dirty : 1;
#define PTE_64_DIRTY_BIT                                             6
#define PTE_64_DIRTY_FLAG                                            0x40
#define PTE_64_DIRTY_MASK                                            0x01
#define PTE_64_DIRTY(_)                                              (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page referenced by this entry.
         *
         * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families))]
         */
        uint64_t pat : 1;
#define PTE_64_PAT_BIT                                               7
#define PTE_64_PAT_FLAG                                              0x80
#define PTE_64_PAT_MASK                                              0x01
#define PTE_64_PAT(_)                                                (((_) >> 7) & 0x01)

        /**
         * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise.
         *
         * @see Vol3A[4.10(Caching Translation Information)]
         */
        uint64_t global : 1;
#define PTE_64_GLOBAL_BIT                                            8
#define PTE_64_GLOBAL_FLAG                                           0x100
#define PTE_64_GLOBAL_MASK                                           0x01
#define PTE_64_GLOBAL(_)                                             (((_) >> 8) & 0x01)

        /**
         * [Bits 10:9] Ignored.
         */
        uint64_t ignored_1 : 2;
#define PTE_64_IGNORED_1_BIT                                         9
#define PTE_64_IGNORED_1_FLAG                                        0x600
#define PTE_64_IGNORED_1_MASK                                        0x03
#define PTE_64_IGNORED_1(_)                                          (((_) >> 9) & 0x03)

        /**
         * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1, linear-address translation is restarted with
         * ordinary paging)
         *
         * @see Vol3A[4.5.5(Restart of HLAT Paging)]
         */
        uint64_t restart : 1;
#define PTE_64_RESTART_BIT                                           11
#define PTE_64_RESTART_FLAG                                          0x800
#define PTE_64_RESTART_MASK                                          0x01
#define PTE_64_RESTART(_)                                            (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define PTE_64_PAGE_FRAME_NUMBER_BIT                                 12
#define PTE_64_PAGE_FRAME_NUMBER_FLAG                                0xFFFFFFFFF000
#define PTE_64_PAGE_FRAME_NUMBER_MASK                                0xFFFFFFFFF
#define PTE_64_PAGE_FRAME_NUMBER(_)                                  (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        uint64_t ignored_2 : 7;
#define PTE_64_IGNORED_2_BIT                                         52
#define PTE_64_IGNORED_2_FLAG                                        0x7F0000000000000
#define PTE_64_IGNORED_2_MASK                                        0x7F
#define PTE_64_IGNORED_2(_)                                          (((_) >> 52) & 0x7F)

        /**
         * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the page; ignored otherwise.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        uint64_t protection_key : 4;
#define PTE_64_PROTECTION_KEY_BIT                                    59
#define PTE_64_PROTECTION_KEY_FLAG                                   0x7800000000000000
#define PTE_64_PROTECTION_KEY_MASK                                   0x0F
#define PTE_64_PROTECTION_KEY(_)                                     (((_) >> 59) & 0x0F)

        /**
         * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from the 1-GByte page
         * controlled by this entry); otherwise, reserved (must be 0).
         *
         * @see Vol3A[4.6(Access Rights)]
         */
        uint64_t execute_disable : 1;
#define PTE_64_EXECUTE_DISABLE_BIT                                   63
#define PTE_64_EXECUTE_DISABLE_FLAG                                  0x8000000000000000
#define PTE_64_EXECUTE_DISABLE_MASK                                  0x01
#define PTE_64_EXECUTE_DISABLE(_)                                    (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} pte_64;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
    struct
    {
        uint64_t present : 1;
#define PT_ENTRY_64_PRESENT_BIT                                      0
#define PT_ENTRY_64_PRESENT_FLAG                                     0x01
#define PT_ENTRY_64_PRESENT_MASK                                     0x01
#define PT_ENTRY_64_PRESENT(_)                                       (((_) >> 0) & 0x01)
        uint64_t write : 1;
#define PT_ENTRY_64_WRITE_BIT                                        1
#define PT_ENTRY_64_WRITE_FLAG                                       0x02
#define PT_ENTRY_64_WRITE_MASK                                       0x01
#define PT_ENTRY_64_WRITE(_)                                         (((_) >> 1) & 0x01)
        uint64_t supervisor : 1;
#define PT_ENTRY_64_SUPERVISOR_BIT                                   2
#define PT_ENTRY_64_SUPERVISOR_FLAG                                  0x04
#define PT_ENTRY_64_SUPERVISOR_MASK                                  0x01
#define PT_ENTRY_64_SUPERVISOR(_)                                    (((_) >> 2) & 0x01)
        uint64_t page_level_write_through : 1;
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT                     3
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG                    0x08
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_)                      (((_) >> 3) & 0x01)
        uint64_t page_level_cache_disable : 1;
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT                     4
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG                    0x10
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK                    0x01
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_)                      (((_) >> 4) & 0x01)
        uint64_t accessed : 1;
#define PT_ENTRY_64_ACCESSED_BIT                                     5
#define PT_ENTRY_64_ACCESSED_FLAG                                    0x20
#define PT_ENTRY_64_ACCESSED_MASK                                    0x01
#define PT_ENTRY_64_ACCESSED(_)                                      (((_) >> 5) & 0x01)
        uint64_t dirty : 1;
#define PT_ENTRY_64_DIRTY_BIT                                        6
#define PT_ENTRY_64_DIRTY_FLAG                                       0x40
#define PT_ENTRY_64_DIRTY_MASK                                       0x01
#define PT_ENTRY_64_DIRTY(_)                                         (((_) >> 6) & 0x01)
        uint64_t large_page : 1;
#define PT_ENTRY_64_LARGE_PAGE_BIT                                   7
#define PT_ENTRY_64_LARGE_PAGE_FLAG                                  0x80
#define PT_ENTRY_64_LARGE_PAGE_MASK                                  0x01
#define PT_ENTRY_64_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)
        uint64_t global : 1;
#define PT_ENTRY_64_GLOBAL_BIT                                       8
#define PT_ENTRY_64_GLOBAL_FLAG                                      0x100
#define PT_ENTRY_64_GLOBAL_MASK                                      0x01
#define PT_ENTRY_64_GLOBAL(_)                                        (((_) >> 8) & 0x01)

        /**
         * [Bits 10:9] Ignored.
         */
        uint64_t ignored_1 : 2;
#define PT_ENTRY_64_IGNORED_1_BIT                                    9
#define PT_ENTRY_64_IGNORED_1_FLAG                                   0x600
#define PT_ENTRY_64_IGNORED_1_MASK                                   0x03
#define PT_ENTRY_64_IGNORED_1(_)                                     (((_) >> 9) & 0x03)
        uint64_t restart : 1;
#define PT_ENTRY_64_RESTART_BIT                                      11
#define PT_ENTRY_64_RESTART_FLAG                                     0x800
#define PT_ENTRY_64_RESTART_MASK                                     0x01
#define PT_ENTRY_64_RESTART(_)                                       (((_) >> 11) & 0x01)

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT                            12
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define PT_ENTRY_64_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved1 : 4;

        /**
         * [Bits 58:52] Ignored.
         */
        uint64_t ignored_2 : 7;
#define PT_ENTRY_64_IGNORED_2_BIT                                    52
#define PT_ENTRY_64_IGNORED_2_FLAG                                   0x7F0000000000000
#define PT_ENTRY_64_IGNORED_2_MASK                                   0x7F
#define PT_ENTRY_64_IGNORED_2(_)                                     (((_) >> 52) & 0x7F)
        uint64_t protection_key : 4;
#define PT_ENTRY_64_PROTECTION_KEY_BIT                               59
#define PT_ENTRY_64_PROTECTION_KEY_FLAG                              0x7800000000000000
#define PT_ENTRY_64_PROTECTION_KEY_MASK                              0x0F
#define PT_ENTRY_64_PROTECTION_KEY(_)                                (((_) >> 59) & 0x0F)
        uint64_t execute_disable : 1;
#define PT_ENTRY_64_EXECUTE_DISABLE_BIT                              63
#define PT_ENTRY_64_EXECUTE_DISABLE_FLAG                             0x8000000000000000
#define PT_ENTRY_64_EXECUTE_DISABLE_MASK                             0x01
#define PT_ENTRY_64_EXECUTE_DISABLE(_)                               (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} pt_entry_64;

/**
 * @defgroup paging_structures_entry_count_64 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PML4E_ENTRY_COUNT_64                                         0x00000200
#define PDPTE_ENTRY_COUNT_64                                         0x00000200
#define PDE_ENTRY_COUNT_64                                           0x00000200
#define PTE_ENTRY_COUNT_64                                           0x00000200
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @}
    */

typedef enum
{
    /**
     * If the INVPCID type is 0, the logical processor invalidates mappings-except global translations-associated with the PCID
     * specified in the INVPCID descriptor and that would be used to translate the linear address specified in the INVPCID
     * descriptor.2 (The instruction may also invalidate global translations, as well as mappings associated with other PCIDs
     * and for other linear addresses.)
     */
    invpcid_individual_address = 0x00000000,

    /**
     * If the INVPCID type is 1, the logical processor invalidates all mappings-except global translations-associated with the
     * PCID specified in the INVPCID descriptor. (The instruction may also invalidate global translations, as well as mappings
     * associated with other PCIDs.)
     */
    invpcid_single_context = 0x00000001,

    /**
     * If the INVPCID type is 2, the logical processor invalidates mappings-including global translations-associated with all
     * PCIDs.
     */
    invpcid_all_context_with_globals = 0x00000002,

    /**
     * If the INVPCID type is 3, the logical processor invalidates mappings-except global translations- associated with all
     * PCIDs. (The instruction may also invalidate global translations.)
     */
    invpcid_all_context = 0x00000003,
} invpcid_type;

typedef union
{
    struct
    {
        uint64_t pcid : 12;
#define INVPCID_DESCRIPTOR_PCID_BIT                                  0
#define INVPCID_DESCRIPTOR_PCID_FLAG                                 0xFFF
#define INVPCID_DESCRIPTOR_PCID_MASK                                 0xFFF
#define INVPCID_DESCRIPTOR_PCID(_)                                   (((_) >> 0) & 0xFFF)

        /**
         * [Bits 63:12] Must be zero.
         */
        uint64_t reserved1 : 52;
#define INVPCID_DESCRIPTOR_RESERVED1_BIT                             12
#define INVPCID_DESCRIPTOR_RESERVED1_FLAG                            0xFFFFFFFFFFFFF000
#define INVPCID_DESCRIPTOR_RESERVED1_MASK                            0xFFFFFFFFFFFFF
#define INVPCID_DESCRIPTOR_RESERVED1(_)                              (((_) >> 12) & 0xFFFFFFFFFFFFF)
        uint64_t linear_address : 64;
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_BIT                        64
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_FLAG                       0xFFFFFFFFFFFFFFFF0000000000000000
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_MASK                       0xFFFFFFFFFFFFFFFF
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS(_)                         (((_) >> 64) & 0xFFFFFFFFFFFFFFFF)
    };

    uint64_t flags;
} invpcid_descriptor;

/**
 * @defgroup segment_descriptors \
 *           Segment descriptors
 * @{
 */
 /**
  * @brief Pseudo-Descriptor Format (32-bit)
  *
  * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
  */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    uint16_t limit;

    /**
     * Base Address.
     */
    uint32_t base_address;
} segment_descriptor_register_32;
#pragma pack(pop)

/**
 * @brief Pseudo-Descriptor Format (64-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Limit.
     */
    uint16_t limit;

    /**
     * Base Address.
     */
    uint64_t base_address;
} segment_descriptor_register_64;
#pragma pack(pop)

/**
 * @brief Segment access rights
 *
 * @see Vol2A[3.2(Instructions (A-L) | LAR-Load Access Rights Byte)] (reference)
 */
typedef union
{
    struct
    {
        uint32_t reserved1 : 8;

        /**
         * @brief Type field
         *
         * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
         * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
         * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
         * data, and system descriptors.
         *
         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
         */
        uint32_t type : 4;
#define SEGMENT_ACCESS_RIGHTS_TYPE_BIT                               8
#define SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                              0xF00
#define SEGMENT_ACCESS_RIGHTS_TYPE_MASK                              0x0F
#define SEGMENT_ACCESS_RIGHTS_TYPE(_)                                (((_) >> 8) & 0x0F)

        /**
         * @brief S (descriptor type) flag
         *
         * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
         * flag is set).
         */
        uint32_t descriptor_type : 1;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                    12
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG                   0x1000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK                   0x01
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                     (((_) >> 12) & 0x01)

        /**
         * @brief DPL (descriptor privilege level) field
         *
         * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
         * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
         */
        uint32_t descriptor_privilege_level : 2;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT         13
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG        0x6000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK        0x03
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)          (((_) >> 13) & 0x03)

        /**
         * @brief P (segment-present) flag
         *
         * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
         * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
         * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
         * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
         */
        uint32_t present : 1;
#define SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                            15
#define SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                           0x8000
#define SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                           0x01
#define SEGMENT_ACCESS_RIGHTS_PRESENT(_)                             (((_) >> 15) & 0x01)
        uint32_t reserved2 : 4;

        /**
         * @brief Available bit
         *
         * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
         */
        uint32_t system : 1;
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT                             20
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG                            0x100000
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK                            0x01
#define SEGMENT_ACCESS_RIGHTS_SYSTEM(_)                              (((_) >> 20) & 0x01)

        /**
         * @brief L (64-bit code segment) flag
         *
         * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
         * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
         * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
         * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
         * 0.
         */
        uint32_t long_mode : 1;
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                          21
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                         0x200000
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                         0x01
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                           (((_) >> 21) & 0x01)

        /**
         * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
         *
         * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
         * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
         * to 0 for 16-bit code and data segments.)
         * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
         * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
         * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
         * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
         * than the default.
         * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
         * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
         * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
         * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
         * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
         * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
         * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
         */
        uint32_t default_big : 1;
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                        22
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                       0x400000
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                         (((_) >> 22) & 0x01)

        /**
         * @brief G (granularity) flag
         *
         * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
         * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
         * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
         * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
         * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
         */
        uint32_t granularity : 1;
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                        23
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                       0x800000
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                       0x01
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                         (((_) >> 23) & 0x01)
        uint32_t reserved3 : 8;
    };

    uint32_t flags;
} segment_access_rights;

/**
 * @brief General Segment Descriptor (32-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[5.2(FIELDS AND FLAGS USED FOR SEGMENT-LEVEL AND PAGE-LEVEL PROTECTION)]
 * @see Vol3A[5.2.1(Code-Segment Descriptor in 64-bit Mode)]
 * @see Vol3A[5.8.3(Call Gates)]
 * @see Vol3A[6.11(IDT DESCRIPTORS)]
 * @see Vol3A[6.14.1(64-Bit Mode IDT)]
 * @see Vol3A[7.2.2(TSS Descriptor)]
 * @see Vol3A[7.2.3(TSS Descriptor in 64-bit mode)]
 * @see Vol3A[7.2.5(Task-Gate Descriptor)]
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    uint16_t segment_limit_low;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    uint16_t base_address_low;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            uint32_t base_address_middle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            uint32_t type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            uint32_t descriptor_type : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            uint32_t descriptor_privilege_level : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            uint32_t present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            uint32_t segment_limit_high : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            uint32_t system : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            uint32_t long_mode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            uint32_t default_big : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            uint32_t granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            uint32_t base_address_high : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        uint32_t flags;
    };

} segment_descriptor_32;

/**
 * @brief General Segment Descriptor (64-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a
 * segment, as well as access control and status information. Segment descriptors are typically created by compilers,
 * linkers, loaders, or the operating system or executive, but not application programs.
 *
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
    /**
     * @brief Segment limit field (15:00)
     *
     * Specifies the size of the segment. The processor puts together the two segment limit fields to form a 20-bit value. The
     * processor interprets the segment limit in one of two ways, depending on the setting of the G (granularity) flag:
     * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in byte increments.
     * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes, in 4-KByte increments.
     * The processor uses the segment limit in two different ways, depending on whether the segment is an expand-up or an
     * expand-down segment. For expand-up segments, the offset in a logical address can range from 0 to the segment limit.
     * Offsets greater than the segment limit generate general-protection exceptions (\#GP, for all segments other than SS) or
     * stack-fault exceptions (\#SS for the SS segment). For expand-down segments, the segment limit has the reverse function;
     * the offset can range from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B flag.
     * Offsets less than or equal to the segment limit generate general-protection exceptions or stack-fault exceptions.
     * Decreasing the value in the segment limit field for an expanddown segment allocates new memory at the bottom of the
     * segment's address space, rather than at the top. IA-32 architecture stacks always grow downwards, making this mechanism
     * convenient for expandable stacks.
     *
     * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
     */
    uint16_t segment_limit_low;

    /**
     * @brief Base address field (15:00)
     *
     * Defines the location of byte 0 of the segment within the 4-GByte linear address space. The processor puts together the
     * three base address fields to form a single 32-bit value. Segment base addresses should be aligned to 16-byte boundaries.
     * Although 16-byte alignment is not required, this alignment allows programs to maximize performance by aligning code and
     * data on 16-byte boundaries.
     */
    uint16_t base_address_low;
    /**
     * @brief Segment descriptor fields
     */
    union
    {
        struct
        {
            /**
             * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for more details.
             */
            uint32_t base_address_middle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT                             0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK                            0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)                              (((_) >> 0) & 0xFF)

            /**
             * @brief Type field
             *
             * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the
             * direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an
             * application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code,
             * data, and system descriptors.
             *
             * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
             */
            uint32_t type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * @brief S (descriptor type) flag
             *
             * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S
             * flag is set).
             */
            uint32_t descriptor_type : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT                                 12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG                                0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK                                0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)                                  (((_) >> 12) & 0x01)

            /**
             * @brief DPL (descriptor privilege level) field
             *
             * [Bits 14:13] Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the
             * most privileged level. The DPL is used to control access to the segment. See Section 5.5, "Privilege Levels", for a
             * description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector.
             */
            uint32_t descriptor_privilege_level : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * @brief P (segment-present) flag
             *
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the
             * processor generates a segment-not-present exception (\#NP) when a segment selector that points to the segment descriptor
             * is loaded into a segment register. Memory management software can use this flag to control which segments are actually
             * loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
             */
            uint32_t present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW for more details.
             */
            uint32_t segment_limit_high : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT                              16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG                             0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK                             0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)                               (((_) >> 16) & 0x0F)

            /**
             * @brief Available bit
             *
             * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available for use by system software.
             */
            uint32_t system : 1;
#define SEGMENT__SYSTEM_BIT                                          20
#define SEGMENT__SYSTEM_FLAG                                         0x100000
#define SEGMENT__SYSTEM_MASK                                         0x01
#define SEGMENT__SYSTEM(_)                                           (((_) >> 20) & 0x01)

            /**
             * @brief L (64-bit code segment) flag
             *
             * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment descriptor indicates whether a code segment
             * contains native 64-bit code. A value of 1 indicates instructions in this code segment are executed in 64-bit mode. A
             * value of 0 indicates the instructions in this code segment are executed in compatibility mode. If L-bit is set, then
             * D-bit must be cleared. When not in IA-32e mode or for non-code segments, bit 21 is reserved and should always be set to
             * 0.
             */
            uint32_t long_mode : 1;
#define SEGMENT__LONG_MODE_BIT                                       21
#define SEGMENT__LONG_MODE_FLAG                                      0x200000
#define SEGMENT__LONG_MODE_MASK                                      0x01
#define SEGMENT__LONG_MODE(_)                                        (((_) >> 21) & 0x01)

            /**
             * @brief D/B (default operation size/default stack pointer size and/or upper bound) flag
             *
             * [Bit 22] Performs different functions depending on whether the segment descriptor is an executable code segment, an
             * expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and
             * to 0 for 16-bit code and data segments.)
             * - Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and
             * operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
             * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
             * be used to select an operand size other than the default, and the prefix 67H can be used select an address size other
             * than the default.
             * - Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the
             * size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a
             * 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer
             * is used, which is stored in the 16- bit SP register. If the stack segment is set up to be an expand-down data segment
             * (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.
             * - Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag
             * is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
             */
            uint32_t default_big : 1;
#define SEGMENT__DEFAULT_BIG_BIT                                     22
#define SEGMENT__DEFAULT_BIG_FLAG                                    0x400000
#define SEGMENT__DEFAULT_BIG_MASK                                    0x01
#define SEGMENT__DEFAULT_BIG(_)                                      (((_) >> 22) & 0x01)

            /**
             * @brief G (granularity) flag
             *
             * [Bit 23] Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is
             * interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not
             * affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve
             * least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when
             * the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
             */
            uint32_t granularity : 1;
#define SEGMENT__GRANULARITY_BIT                                     23
#define SEGMENT__GRANULARITY_FLAG                                    0x800000
#define SEGMENT__GRANULARITY_MASK                                    0x01
#define SEGMENT__GRANULARITY(_)                                      (((_) >> 23) & 0x01)

            /**
             * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for more details.
             */
            uint32_t base_address_high : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT                               24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG                              0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK                              0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)                                (((_) >> 24) & 0xFF)
        };

        uint32_t flags;
    };


    /**
     * Base address field (32:63); see description of $BASE_LOW for more details.
     */
    uint32_t base_address_upper;

    /**
     * This field must be set to zero.
     */
    uint32_t must_be_zero;
} segment_descriptor_64;

/**
 * @brief Interrupt Gate Descriptor (64-bit)
 *
 * @see Vol3A[6.14.1(64-Bit Mode IDT)] (reference)
 */
typedef struct
{
    /**
     * Offset to procedure entry point (15:00).
     */
    uint16_t offset_low;

    /**
     * Segment selector for destination code segment.
     */
    uint16_t segment_selector;
    union
    {
        struct
        {
            /**
             * [Bits 2:0] Index into the TSS Interrupt Stack Table.
             */
            uint32_t interrupt_stack_table : 3;
#define SEGMENT__INTERRUPT_STACK_TABLE_BIT                           0
#define SEGMENT__INTERRUPT_STACK_TABLE_FLAG                          0x07
#define SEGMENT__INTERRUPT_STACK_TABLE_MASK                          0x07
#define SEGMENT__INTERRUPT_STACK_TABLE(_)                            (((_) >> 0) & 0x07)

            /**
             * [Bits 7:3] This field must be set to zero.
             */
            uint32_t must_be_zero_0 : 5;
#define SEGMENT__MUST_BE_ZERO_0_BIT                                  3
#define SEGMENT__MUST_BE_ZERO_0_FLAG                                 0xF8
#define SEGMENT__MUST_BE_ZERO_0_MASK                                 0x1F
#define SEGMENT__MUST_BE_ZERO_0(_)                                   (((_) >> 3) & 0x1F)

            /**
             * [Bits 11:8] Indicates the segment or gate type.
             */
            uint32_t type : 4;
#define SEGMENT__TYPE_BIT                                            8
#define SEGMENT__TYPE_FLAG                                           0xF00
#define SEGMENT__TYPE_MASK                                           0x0F
#define SEGMENT__TYPE(_)                                             (((_) >> 8) & 0x0F)

            /**
             * [Bit 12] This field must be set to zero.
             */
            uint32_t must_be_zero_1 : 1;
#define SEGMENT__MUST_BE_ZERO_1_BIT                                  12
#define SEGMENT__MUST_BE_ZERO_1_FLAG                                 0x1000
#define SEGMENT__MUST_BE_ZERO_1_MASK                                 0x01
#define SEGMENT__MUST_BE_ZERO_1(_)                                   (((_) >> 12) & 0x01)

            /**
             * [Bits 14:13] Specifies the segment privilege level.
             */
            uint32_t descriptor_privilege_level : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT                      13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG                     0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK                     0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)                       (((_) >> 13) & 0x03)

            /**
             * [Bit 15] Indicates whether the segment is present in memory (set) or not present (clear).
             */
            uint32_t present : 1;
#define SEGMENT__PRESENT_BIT                                         15
#define SEGMENT__PRESENT_FLAG                                        0x8000
#define SEGMENT__PRESENT_MASK                                        0x01
#define SEGMENT__PRESENT(_)                                          (((_) >> 15) & 0x01)

            /**
             * [Bits 31:16] Offset to procedure entry point (31:16).
             */
            uint32_t offset_middle : 16;
#define SEGMENT__OFFSET_MIDDLE_BIT                                   16
#define SEGMENT__OFFSET_MIDDLE_FLAG                                  0xFFFF0000
#define SEGMENT__OFFSET_MIDDLE_MASK                                  0xFFFF
#define SEGMENT__OFFSET_MIDDLE(_)                                    (((_) >> 16) & 0xFFFF)
        };

        uint32_t flags;
    };


    /**
     * Offset to procedure entry point (63:32).
     */
    uint32_t offset_high;
    uint32_t reserved;
} segment_descriptor_interrupt_gate_64;

#define SEGMENT_DESCRIPTOR_TYPE_SYSTEM                               0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA                         0x00000001
/**
 * @defgroup segment_descriptor_code_and_data_type \
 *           Code- and Data-Segment Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is set, the descriptor is for either a code or a data segment.
 * The highest order bit of the type field (bit 11 of the second double word of the segment descriptor) then determines
 * whether the descriptor is for a data segment (clear) or a code segment (set). For data segments, the three low-order
 * bits of the type field (bits 8, 9, and 10) are interpreted as accessed (A), write-enable (W), and expansion-direction
 * (E). See Table 3-1 for a description of the encoding of the bits in the type field for code and data segments. Data
 * segments can be read-only or read/write segments, depending on the setting of the write-enable bit.
 *
 * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)] (reference)
 * @{
 */
 /**
  * Read-Only.
  */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY                       0x00000000

  /**
   * Data Read-Only, accessed.
   */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED              0x00000001

   /**
    * Data Read/Write.
    */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE                      0x00000002

    /**
     * Data Read/Write, accessed.
     */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED             0x00000003

     /**
      * Data Read-Only, expand-down.
      */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN           0x00000004

      /**
       * Data Read-Only, expand-down, accessed.
       */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED  0x00000005

       /**
        * Data Read/Write, expand-down.
        */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN          0x00000006

        /**
         * Data Read/Write, expand-down, accessed.
         */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED 0x00000007

         /**
          * Code Execute-Only.
          */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY                    0x00000008

          /**
           * Code Execute-Only, accessed.
           */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED           0x00000009

           /**
            * Code Execute/Read.
            */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ                    0x0000000A

            /**
             * Code Execute/Read, accessed.
             */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED           0x0000000B

             /**
              * Code Execute-Only, conforming.
              */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING         0x0000000C

              /**
               * Code Execute-Only, conforming, accessed.
               */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED 0x0000000D

               /**
                * Code Execute/Read, conforming.
                */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING         0x0000000E

                /**
                 * Code Execute/Read, conforming, accessed.
                 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED 0x0000000F
                 /**
                  * @}
                  */

                  /**
                   * @defgroup segment_descriptor_system_type \
                   *           System Descriptor Types
                   *
                   * When the S (descriptor type) flag in a segment descriptor is clear, the descriptor type is a system descriptor. The
                   * processor recognizes the following types of system descriptors:
                   * - Local descriptor-table (LDT) segment descriptor.
                   * - Task-state segment (TSS) descriptor.
                   * - Call-gate descriptor.
                   * - Interrupt-gate descriptor.
                   * - Trap-gate descriptor.
                   * - Task-gate descriptor.
                   * These descriptor types fall into two categories: system-segment descriptors and gate descriptors. Systemsegment
                   * descriptors point to system segments (LDT and TSS segments). Gate descriptors are in themselves "gates," which hold
                   * pointers to procedure entry points in code segments (call, interrupt, and trap gates) or which hold segment selectors
                   * for TSS's (task gates).
                   *
                   * @see Vol3A[3.5(SYSTEM DESCRIPTOR TYPES)] (reference)
                   * @{
                   */
                   /**
                    * - 32-Bit Mode: Reserved
                    * - IA-32e Mode: Reserved
                    */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1                           0x00000000

                    /**
                     * - 32-Bit Mode: 16-bit TSS (Available)
                     * - IA-32e Mode: Reserved
                     */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE                     0x00000001

                     /**
                      * - 32-Bit Mode: LDT
                      * - IA-32e Mode: LDT
                      */
#define SEGMENT_DESCRIPTOR_TYPE_LDT                                  0x00000002

                      /**
                       * - 32-Bit Mode: 16-bit TSS (Busy)
                       * - IA-32e Mode: Reserved
                       */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY                          0x00000003

                       /**
                        * - 32-Bit Mode: 16-bit Call Gate
                        * - IA-32e Mode: Reserved
                        */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16                         0x00000004

                        /**
                         * - 32-Bit Mode: Task Gate
                         * - IA-32e Mode: Reserved
                         */
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE                            0x00000005

                         /**
                          * - 32-Bit Mode: 16-bit Interrupt Gate
                          * - IA-32e Mode: Reserved
                          */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16                    0x00000006

                          /**
                           * - 32-Bit Mode: 16-bit Trap Gate
                           * - IA-32e Mode: Reserved
                           */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16                         0x00000007

                           /**
                            * - 32-Bit Mode: Reserved
                            * - IA-32e Mode: Reserved
                            */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2                           0x00000008

                            /**
                             * - 32-Bit Mode: 32-bit TSS (Available)
                             * - IA-32e Mode: 64-bit TSS (Available)
                             */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE                        0x00000009

                             /**
                              * - 32-Bit Mode: Reserved
                              * - IA-32e Mode: Reserved
                              */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3                           0x0000000A

                              /**
                               * - 32-Bit Mode: 32-bit TSS (Busy)
                               * - IA-32e Mode: 64-bit TSS (Busy)
                               */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY                             0x0000000B

                               /**
                                * - 32-Bit Mode: 32-bit Call Gate
                                * - IA-32e Mode: 64-bit Call Gate
                                */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE                            0x0000000C

                                /**
                                 * - 32-Bit Mode: Reserved
                                 * - IA-32e Mode: Reserved
                                 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4                           0x0000000D

                                 /**
                                  * - 32-Bit Mode: 32-bit Interrupt Gate
                                  * - IA-32e Mode: 64-bit Interrupt Gate
                                  */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE                       0x0000000E

                                  /**
                                   * - 32-Bit Mode: 32-bit Trap Gate
                                   * - IA-32e Mode: 64-bit Trap Gate
                                   */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE                            0x0000000F
                                   /**
                                    * @}
                                    */

                                    /**
                                     * @brief A segment selector is a 16-bit identifier for a segment. It does not point directly to the segment, but instead
                                     *        points to the segment descriptor that defines the segment
                                     *
                                     * @see Vol3A[3.4.2(Segment Selectors)] (reference)
                                     */
typedef union
{
    struct
    {
        /**
         * [Bits 1:0] Specifies the privilege level of the selector. The privilege level can range from 0 to 3, with 0 being the
         * most privileged level.
         *
         * @see Vol3A[5.5(Privilege Levels)]
         */
        uint16_t request_privilege_level : 2;
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT                 0
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK                0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_)                  (((_) >> 0) & 0x03)

        /**
         * [Bit 2] Specifies the descriptor table to use: clearing this flag selects the GDT; setting this flag selects the current
         * LDT.
         */
        uint16_t table : 1;
#define SEGMENT_SELECTOR_TABLE_BIT                                   2
#define SEGMENT_SELECTOR_TABLE_FLAG                                  0x04
#define SEGMENT_SELECTOR_TABLE_MASK                                  0x01
#define SEGMENT_SELECTOR_TABLE(_)                                    (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] Selects one of 8192 descriptors in the GDT or LDT. The processor multiplies the index value by 8 (the number
         * of bytes in a segment descriptor) and adds the result to the base address of the GDT or LDT (from the GDTR or LDTR
         * register, respectively).
         */
        uint16_t index : 13;
#define SEGMENT_SELECTOR_INDEX_BIT                                   3
#define SEGMENT_SELECTOR_INDEX_FLAG                                  0xFFF8
#define SEGMENT_SELECTOR_INDEX_MASK                                  0x1FFF
#define SEGMENT_SELECTOR_INDEX(_)                                    (((_) >> 3) & 0x1FFF)
    };

    uint16_t flags;
} segment_selector;

/**
 * @}
 */

 /**
  * @brief Task State Segment (64-bit)
  *
  * @see Vol3C[7.7(Task Management in 64-bit Mode)] (reference)
  */
#pragma pack(push, 1)
typedef struct
{
    /**
     * Reserved bits. Set to 0.
     */
    uint32_t reserved_0;

    /**
     * Stack pointer for privilege level 0.
     */
    uint64_t rsp0;

    /**
     * Stack pointer for privilege level 1.
     */
    uint64_t rsp1;

    /**
     * Stack pointer for privilege level 2.
     */
    uint64_t rsp2;

    /**
     * Reserved bits. Set to 0.
     */
    uint64_t reserved_1;

    /**
     * Interrupt stack table pointer (1).
     */
    uint64_t ist1;

    /**
     * Interrupt stack table pointer (2).
     */
    uint64_t ist2;

    /**
     * Interrupt stack table pointer (3).
     */
    uint64_t ist3;

    /**
     * Interrupt stack table pointer (4).
     */
    uint64_t ist4;

    /**
     * Interrupt stack table pointer (5).
     */
    uint64_t ist5;

    /**
     * Interrupt stack table pointer (6).
     */
    uint64_t ist6;

    /**
     * Interrupt stack table pointer (7).
     */
    uint64_t ist7;

    /**
     * Reserved bits. Set to 0.
     */
    uint64_t reserved_2;

    /**
     * Reserved bits. Set to 0.
     */
    uint16_t reserved_3;

    /**
     * The 16-bit offset to the I/O permission bit map from the 64-bit TSS base.
     */
    uint16_t io_map_base;
} task_state_segment_64;
#pragma pack(pop)

/**
 * @defgroup vmx \
 *           VMX
 * @{
 */
 /**
  * @{
  */
  /**
   * @defgroup vmx_basic_exit_reasons \
   *           VMX Basic Exit Reasons
   *
   * VMX Basic Exit Reasons.
   *
   * @see Vol3D[C(VMX BASIC EXIT REASONS)] (reference)
   * @{
   */
   /**
    * @brief Exception or non-maskable interrupt (NMI)
    *
    * Either:
    * -# Guest software caused an exception and the bit in the exception bitmap associated with exception's vector was 1. This
    * case includes executions of BOUND that cause \#BR, executions of INT1 (they cause \#DB), executions of INT3 (they cause
    * \#BP), executions of INTO that cause \#OF, and executions of UD0, UD1, and UD2 (they cause \#UD).
    * -# An NMI was delivered to the logical processor and the "NMI exiting" VM-execution control was 1.
    */
#define VMX_EXIT_REASON_EXCEPTION_OR_NMI                             0x00000000

    /**
     * @brief External interrupt
     *
     * An external interrupt arrived and the "external-interrupt exiting" VM-execution control was 1.
     */
#define VMX_EXIT_REASON_EXTERNAL_INTERRUPT                           0x00000001

     /**
      * @brief Triple fault
      *
      * The logical processor encountered an exception while attempting to call the double-fault handler and that exception did
      * not itself cause a VM exit due to the exception bitmap.
      */
#define VMX_EXIT_REASON_TRIPLE_FAULT                                 0x00000002

      /**
       * @brief INIT signal
       *
       * An INIT signal arrived.
       */
#define VMX_EXIT_REASON_INIT_SIGNAL                                  0x00000003

       /**
        * @brief Start-up IPI (SIPI)
        *
        * A SIPI arrived while the logical processor was in the "wait-for-SIPI" state.
        */
#define VMX_EXIT_REASON_STARTUP_IPI                                  0x00000004

        /**
         * @brief I/O system-management interrupt (SMI)
         *
         * An SMI arrived immediately after retirement of an I/O instruction and caused an SMM VM exit.
         *
         * @see Vol3C[34.15.2(SMM VM Exits)]
         */
#define VMX_EXIT_REASON_IO_SMI                                       0x00000005

         /**
          * @brief Other SMI
          *
          * An SMI arrived and caused an SMM VM exit but not immediately after retirement of an I/O instruction.
          *
          * @see Vol3C[34.15.2(SMM VM Exits)]
          */
#define VMX_EXIT_REASON_SMI                                          0x00000006

          /**
           * @brief Interrupt window exiting
           *
           * At the beginning of an instruction, RFLAGS.IF was 1; events were not blocked by STI or by MOV SS; and the
           * "interrupt-window exiting" VM-execution control was 1.
           */
#define VMX_EXIT_REASON_INTERRUPT_WINDOW                             0x00000007

           /**
            * @brief NMI window exiting
            *
            * At the beginning of an instruction, there was no virtual-NMI blocking; events were not blocked by MOV SS; and the
            * "NMI-window exiting" VM-execution control was 1.
            */
#define VMX_EXIT_REASON_NMI_WINDOW                                   0x00000008

            /**
             * @brief Task switch
             *
             * Guest software attempted a task switch.
             */
#define VMX_EXIT_REASON_TASK_SWITCH                                  0x00000009

             /**
              * @brief CPUID
              *
              * Guest software attempted to execute CPUID.
              */
#define VMX_EXIT_REASON_EXECUTE_CPUID                                0x0000000A

              /**
               * @brief GETSEC
               *
               * Guest software attempted to execute GETSEC.
               */
#define VMX_EXIT_REASON_EXECUTE_GETSEC                               0x0000000B

               /**
                * @brief HLT
                *
                * Guest software attempted to execute HLT and the "HLT exiting" VM-execution control was 1.
                */
#define VMX_EXIT_REASON_EXECUTE_HLT                                  0x0000000C

                /**
                 * @brief INVD
                 *
                 * Guest software attempted to execute INVD.
                 */
#define VMX_EXIT_REASON_EXECUTE_INVD                                 0x0000000D

                 /**
                  * @brief INVLPG
                  *
                  * Guest software attempted to execute INVLPG and the "INVLPG exiting" VM-execution control was 1.
                  */
#define VMX_EXIT_REASON_EXECUTE_INVLPG                               0x0000000E

                  /**
                   * @brief RDPMC
                   *
                   * Guest software attempted to execute RDPMC and the "RDPMC exiting" VM-execution control was 1.
                   */
#define VMX_EXIT_REASON_EXECUTE_RDPMC                                0x0000000F

                   /**
                    * @brief RDTSC
                    *
                    * Guest software attempted to execute RDTSC and the "RDTSC exiting" VM-execution control was 1.
                    */
#define VMX_EXIT_REASON_EXECUTE_RDTSC                                0x00000010

                    /**
                     * @brief RSM in SMM
                     *
                     * Guest software attempted to execute RSM in SMM.
                     */
#define VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM                           0x00000011

                     /**
                      * @brief VMCALL
                      *
                      * VMCALL was executed either by guest software (causing an ordinary VM exit) or by the executive monitor (causing an SMM
                      * VM exit).
                      *
                      * @see Vol3C[34.15.2(SMM VM Exits)]
                      */
#define VMX_EXIT_REASON_EXECUTE_VMCALL                               0x00000012

                      /**
                       * @brief VMCLEAR
                       *
                       * Guest software attempted to execute VMCLEAR.
                       */
#define VMX_EXIT_REASON_EXECUTE_VMCLEAR                              0x00000013

                       /**
                        * @brief VMLAUNCH
                        *
                        * Guest software attempted to execute VMLAUNCH.
                        */
#define VMX_EXIT_REASON_EXECUTE_VMLAUNCH                             0x00000014

                        /**
                         * @brief VMPTRLD
                         *
                         * Guest software attempted to execute VMPTRLD.
                         */
#define VMX_EXIT_REASON_EXECUTE_VMPTRLD                              0x00000015

                         /**
                          * @brief VMPTRST
                          *
                          * Guest software attempted to execute VMPTRST.
                          */
#define VMX_EXIT_REASON_EXECUTE_VMPTRST                              0x00000016

                          /**
                           * @brief VMREAD
                           *
                           * Guest software attempted to execute VMREAD.
                           */
#define VMX_EXIT_REASON_EXECUTE_VMREAD                               0x00000017

                           /**
                            * @brief VMRESUME
                            *
                            * Guest software attempted to execute VMRESUME.
                            */
#define VMX_EXIT_REASON_EXECUTE_VMRESUME                             0x00000018

                            /**
                             * @brief VMWRITE
                             *
                             * Guest software attempted to execute VMWRITE.
                             */
#define VMX_EXIT_REASON_EXECUTE_VMWRITE                              0x00000019

                             /**
                              * @brief VMXOFF
                              *
                              * Guest software attempted to execute VMXOFF.
                              */
#define VMX_EXIT_REASON_EXECUTE_VMXOFF                               0x0000001A

                              /**
                               * @brief VMXON
                               *
                               * Guest software attempted to execute VMXON.
                               */
#define VMX_EXIT_REASON_EXECUTE_VMXON                                0x0000001B

                               /**
                                * @brief Control-register accesses
                                *
                                * Guest software attempted to access CR0, CR3, CR4, or CR8 using CLTS, LMSW, or MOV CR and the VM-execution control fields
                                * indicate that a VM exit should occur. This basic exit reason is not used for trap-like VM exits following executions of
                                * the MOV to CR8 instruction when the "use TPR shadow" VM-execution control is 1. Such VM exits instead use basic exit
                                * reason 43.
                                *
                                * @see Vol3C[25.1(INSTRUCTIONS THAT CAUSE VM EXITS)]
                                */
#define VMX_EXIT_REASON_MOV_CR                                       0x0000001C

                                /**
                                 * @brief Debug-register accesses
                                 *
                                 * Guest software attempted a MOV to or from a debug register and the "MOV-DR exiting" VM-execution control was 1.
                                 */
#define VMX_EXIT_REASON_MOV_DR                                       0x0000001D

                                 /**
                                  * @brief I/O instruction
                                  *
                                  * Guest software attempted to execute an I/O instruction and either:
                                  * -# The "use I/O bitmaps" VM-execution control was 0 and the "unconditional I/O exiting" VM-execution control was 1.
                                  * -# The "use I/O bitmaps" VM-execution control was 1 and a bit in the I/O bitmap associated with one of the ports
                                  * accessed by the I/O instruction was 1.
                                  */
#define VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION                       0x0000001E

                                  /**
                                   * @brief RDMSR
                                   *
                                   * Guest software attempted to execute RDMSR and either:
                                   * -# The "use MSR bitmaps" VM-execution control was 0.
                                   * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                   * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low MSRs is 1, where n was
                                   * the value of RCX.
                                   * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high MSRs is 1, where n is
                                   * the value of RCX & 00001FFFH.
                                   */
#define VMX_EXIT_REASON_EXECUTE_RDMSR                                0x0000001F

                                   /**
                                    * @brief WRMSR
                                    *
                                    * Guest software attempted to execute WRMSR and either:
                                    * -# The "use MSR bitmaps" VM-execution control was 0.
                                    * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                    * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in write bitmap for low MSRs is 1, where n
                                    * was the value of RCX.
                                    * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for high MSRs is 1, where n is
                                    * the value of RCX & 00001FFFH.
                                    */
#define VMX_EXIT_REASON_EXECUTE_WRMSR                                0x00000020

                                    /**
                                     * @brief VM-entry failure due to invalid guest state
                                     *
                                     * A VM entry failed one of the checks identified in Section 26.3.1.
                                     */
#define VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE                    0x00000021

                                     /**
                                      * @brief VM-entry failure due to MSR loading
                                      *
                                      * A VM entry failed in an attempt to load MSRs. See Section 26.4.
                                      */
#define VMX_EXIT_REASON_ERROR_MSR_LOAD                               0x00000022

                                      /**
                                       * @brief Guest software executed MWAIT
                                       *
                                       * Guest software attempted to execute MWAIT and the "MWAIT exiting" VM-execution control was 1.
                                       */
#define VMX_EXIT_REASON_EXECUTE_MWAIT                                0x00000024

                                       /**
                                        * @brief VM-exit due to monitor trap flag
                                        *
                                        * A VM entry occurred due to the 1-setting of the "monitor trap flag" VM-execution control and injection of an MTF VM exit
                                        * as part of VM entry.
                                        *
                                        * @see Vol3C[25.5.2(Monitor Trap Flag)]
                                        */
#define VMX_EXIT_REASON_MONITOR_TRAP_FLAG                            0x00000025

                                        /**
                                         * @brief Guest software attempted to execute MONITOR
                                         *
                                         * Guest software attempted to execute MONITOR and the "MONITOR exiting" VM-execution control was 1.
                                         */
#define VMX_EXIT_REASON_EXECUTE_MONITOR                              0x00000027

                                         /**
                                          * @brief Guest software attempted to execute PAUSE
                                          *
                                          * Either guest software attempted to execute PAUSE and the "PAUSE exiting" VM-execution control was 1 or the "PAUSE-loop
                                          * exiting" VM-execution control was 1 and guest software executed a PAUSE loop with execution time exceeding PLE_Window.
                                          *
                                          * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                                          */
#define VMX_EXIT_REASON_EXECUTE_PAUSE                                0x00000028

                                          /**
                                           * @brief VM-entry failure due to machine-check
                                           *
                                           * A machine-check event occurred during VM entry.
                                           *
                                           * @see Vol3C[26.8(MACHINE-CHECK EVENTS DURING VM ENTRY)]
                                           */
#define VMX_EXIT_REASON_ERROR_MACHINE_CHECK                          0x00000029

                                           /**
                                            * @brief TPR below threshold
                                            *
                                            * The logical processor determined that the value of bits 7:4 of the byte at offset 080H on the virtual-APIC page was
                                            * below that of the TPR threshold VM-execution control field while the "use TPR shadow" VMexecution control was 1 either
                                            * as part of TPR virtualization or VM entry.
                                            *
                                            * @see Vol3C[29.1.2(TPR Virtualization)]
                                            * @see Vol3C[26.6.7(VM Exits Induced by the TPR Threshold)]
                                            */
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD                          0x0000002B

                                            /**
                                             * @brief APIC access
                                             *
                                             * Guest software attempted to access memory at a physical address on the APIC-access page and the "virtualize APIC
                                             * accesses" VM-execution control was 1.
                                             *
                                             * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
                                             */
#define VMX_EXIT_REASON_APIC_ACCESS                                  0x0000002C

                                             /**
                                              * @brief Virtualized EOI
                                              *
                                              * EOI virtualization was performed for a virtual interrupt whose vector indexed a bit set in the EOIexit bitmap.
                                              */
#define VMX_EXIT_REASON_VIRTUALIZED_EOI                              0x0000002D

                                              /**
                                               * @brief Access to GDTR or IDTR
                                               *
                                               * Guest software attempted to execute LGDT, LIDT, SGDT, or SIDT and the "descriptor-table exiting" VM-execution control
                                               * was 1.
                                               */
#define VMX_EXIT_REASON_GDTR_IDTR_ACCESS                             0x0000002E

                                               /**
                                                * @brief Access to LDTR or TR
                                                *
                                                * Guest software attempted to execute LLDT, LTR, SLDT, or STR and the "descriptor-table exiting" VM-execution control was
                                                * 1.
                                                */
#define VMX_EXIT_REASON_LDTR_TR_ACCESS                               0x0000002F

                                                /**
                                                 * @brief EPT violation
                                                 *
                                                 * An attempt to access memory with a guest-physical address was disallowed by the configuration of the EPT paging
                                                 * structures.
                                                 */
#define VMX_EXIT_REASON_EPT_VIOLATION                                0x00000030

                                                 /**
                                                  * @brief EPT misconfiguration
                                                  *
                                                  * An attempt to access memory with a guest-physical address encountered a misconfigured EPT paging-structure entry.
                                                  */
#define VMX_EXIT_REASON_EPT_MISCONFIGURATION                         0x00000031

                                                  /**
                                                   * @brief INVEPT
                                                   *
                                                   * Guest software attempted to execute INVEPT.
                                                   */
#define VMX_EXIT_REASON_EXECUTE_INVEPT                               0x00000032

                                                   /**
                                                    * @brief RDTSCP
                                                    *
                                                    * Guest software attempted to execute RDTSCP and the "enable RDTSCP" and "RDTSC exiting" VM-execution controls were both
                                                    * 1.
                                                    */
#define VMX_EXIT_REASON_EXECUTE_RDTSCP                               0x00000033

                                                    /**
                                                     * @brief VMX-preemption timer expired
                                                     *
                                                     * The preemption timer counted down to zero.
                                                     */
#define VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED                 0x00000034

                                                     /**
                                                      * @brief INVVPID
                                                      *
                                                      * Guest software attempted to execute INVVPID.
                                                      */
#define VMX_EXIT_REASON_EXECUTE_INVVPID                              0x00000035

                                                      /**
                                                       * @brief WBINVD
                                                       *
                                                       * Guest software attempted to execute WBINVD and the "WBINVD exiting" VM-execution control was 1.
                                                       */
#define VMX_EXIT_REASON_EXECUTE_WBINVD                               0x00000036

                                                       /**
                                                        * @brief XSETBV - Guest software attempted to execute XSETBV
                                                        *
                                                        * Guest software attempted to execute XSETBV.
                                                        */
#define VMX_EXIT_REASON_EXECUTE_XSETBV                               0x00000037

                                                        /**
                                                         * @brief APIC write
                                                         *
                                                         * Guest software completed a write to the virtual-APIC page that must be virtualized by VMM software.
                                                         *
                                                         * @see Vol3C[29.4.3.3(APIC-Write VM Exits)]
                                                         */
#define VMX_EXIT_REASON_APIC_WRITE                                   0x00000038

                                                         /**
                                                          * @brief RDRAND
                                                          *
                                                          * Guest software attempted to execute RDRAND and the "RDRAND exiting" VM-execution control was 1.
                                                          */
#define VMX_EXIT_REASON_EXECUTE_RDRAND                               0x00000039

                                                          /**
                                                           * @brief INVPCID
                                                           *
                                                           * Guest software attempted to execute INVPCID and the "enable INVPCID" and "INVLPG exiting" VM-execution controls were
                                                           * both 1.
                                                           */
#define VMX_EXIT_REASON_EXECUTE_INVPCID                              0x0000003A

                                                           /**
                                                            * @brief VMFUNC
                                                            *
                                                            * Guest software invoked a VM function with the VMFUNC instruction and the VM function either was not enabled or generated
                                                            * a function-specific condition causing a VM exit.
                                                            */
#define VMX_EXIT_REASON_EXECUTE_VMFUNC                               0x0000003B

                                                            /**
                                                             * @brief ENCLS
                                                             *
                                                             * Guest software attempted to execute ENCLS and "enable ENCLS exiting" VM-execution control was 1 and either:
                                                             * -# EAX < 63 and the corresponding bit in the ENCLS-exiting bitmap is 1; or
                                                             * -# EAX >= 63 and bit 63 in the ENCLS-exiting bitmap is 1.
                                                             */
#define VMX_EXIT_REASON_EXECUTE_ENCLS                                0x0000003C

                                                             /**
                                                              * @brief RDSEED
                                                              *
                                                              * Guest software attempted to execute RDSEED and the "RDSEED exiting" VM-execution control was 1.
                                                              */
#define VMX_EXIT_REASON_EXECUTE_RDSEED                               0x0000003D

                                                              /**
                                                               * @brief Page-modification log full
                                                               *
                                                               * The processor attempted to create a page-modification log entry and the value of the PML index was not in the range
                                                               * 0-511.
                                                               */
#define VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL                   0x0000003E

                                                               /**
                                                                * @brief XSAVES
                                                                *
                                                                * Guest software attempted to execute XSAVES, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                */
#define VMX_EXIT_REASON_EXECUTE_XSAVES                               0x0000003F

                                                                /**
                                                                 * @brief XRSTORS
                                                                 *
                                                                 * Guest software attempted to execute XRSTORS, the "enable XSAVES/XRSTORS" was 1, and a bit was set in the logical-AND of
                                                                 * the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting bitmap.
                                                                 */
#define VMX_EXIT_REASON_EXECUTE_XRSTORS                              0x00000040

                                                                 /**
                                                                  * @brief PCONFIG
                                                                  *
                                                                  * Guest software attempted to execute PCONFIG, "enable PCONFIG" VM-execution control was 1, and either (1) EAX < 63 and
                                                                  * the corresponding bit in the PCONFIG-exiting bitmap is 1; or (2) EAX ? 63 and bit 63 in the PCONFIG-exiting bitmap is 1.
                                                                  */
#define VMX_EXIT_REASON_EXECUTE_PCONFIG                              0x00000041

                                                                  /**
                                                                   * @brief SPP-related event
                                                                   *
                                                                   * SPP-related event. The processor attempted to determine an access's sub-page write permission and encountered an SPP
                                                                   * miss or an SPP misconfiguration.
                                                                   *
                                                                   * @see Vol3C[30.3.4.2(Determining an Access's Sub-Page Write Permission)]
                                                                   */
#define VMX_EXIT_REASON_SPP_RELATED_EVENT                            0x00000042

                                                                   /**
                                                                    * @brief UMWAIT
                                                                    *
                                                                    * Guest software attempted to execute UMWAIT and the "enable user wait and pause" and "RDTSC exiting" VM-execution
                                                                    * controls were both 1.
                                                                    */
#define VMX_EXIT_REASON_EXECUTE_UMWAIT                               0x00000043

                                                                    /**
                                                                     * @brief TPAUSE
                                                                     *
                                                                     * Guest software attempted to execute TPAUSE and the "enable user wait and pause" and "RDTSC exiting" VM-execution
                                                                     * controls were both 1.
                                                                     */
#define VMX_EXIT_REASON_EXECUTE_TPAUSE                               0x00000044

                                                                     /**
                                                                      * @brief LOADIWKEY
                                                                      *
                                                                      * Guest software attempted to execute LOADIWKEY and the "LOADIWKEY exiting" VM-execution control was 1.
                                                                      */
#define VMX_EXIT_REASON_EXECUTE_LOADIWKEY                            0x00000045

                                                                      /**
                                                                       * @brief ENCLV
                                                                       *
                                                                       * Guest software attempted to execute ENCLV, the "enable ENCLV exiting" VM-execution control was 1, and either (1) EAX <
                                                                       * 63 and the corresponding bit in the ENCLV-exiting bitmap is 1; or (2) EAX ? 63 and bit 63 in the ENCLV-exiting bitmap is
                                                                       * 1.
                                                                       */
#define VMX_EXIT_REASON_EXECUTE_ENCLV                                0x00000046

                                                                       /**
                                                                        * @brief ENQCMD PASID translation failure
                                                                        *
                                                                        * A VM exit occurred during PASID translation because the present bit was clear in a PASID-directory entry, the valid bit
                                                                        * was clear in a PASID-table entry, or one of the entries set a reserved bit.
                                                                        */
#define VMX_EXIT_REASON_EXECUTE_ENQCMD                               0x00000048

                                                                        /**
                                                                         * @brief ENQCMDS PASID translation failure
                                                                         *
                                                                         * A VM exit occurred during PASID translation because the present bit was clear in a PASID-directory entry, the valid bit
                                                                         * was clear in a PASID-table entry, or one of the entries set a reserved bit.
                                                                         */
#define VMX_EXIT_REASON_EXECUTE_ENQCMDS                              0x00000049

                                                                         /**
                                                                          * @brief Bus lock
                                                                          *
                                                                          * The processor asserted a bus lock while the "bus-lock detection" VM-execution control was 1. (Such VM exits will also
                                                                          * set bit 26 of the exit-reason field.)
                                                                          */
#define VMX_EXIT_REASON_BUS_LOCK_ASSERTION                           0x0000004A

                                                                          /**
                                                                           * @brief Instruction timeout
                                                                           *
                                                                           * The "instruction timeout" VM-execution control was 1 and certain operations prevented the processor from reaching an
                                                                           * instruction boundary within the amount of time specified by the instruction-timeout control.
                                                                           */
#define VMX_EXIT_REASON_INSTRUCTION_TIMEOUT                          0x0000004B

                                                                           /**
                                                                            * @brief SEAMCALL
                                                                            *
                                                                            * Guest software attempted to execute SEAMCALL.
                                                                            */
#define VMX_EXIT_REASON_EXECUTE_SEAMCALL                             0x0000004C

                                                                            /**
                                                                             * @brief TDCALL
                                                                             *
                                                                             * Guest software attempted to execute TDCALL.
                                                                             */
#define VMX_EXIT_REASON_EXECUTE_TDCALL                               0x0000004D

                                                                             /**
                                                                              * @brief RDMSRLIST
                                                                              *
                                                                              * Guest software attempted to execute RDMSRLIST and either the "use MSR bitmaps" VM-execution control was 0 or any of the
                                                                              * following holds for the index an MSR being accessed:
                                                                              * * The index is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                                                              * * The index is in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low MSRs is 1, where n is the
                                                                              * index.
                                                                              * * The index is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high MSRs is 1, where n is the
                                                                              * logical AND of the index and the value 00001FFFH.
                                                                              */
#define VMX_EXIT_REASON_EXECUTE_RDMSRLIST                            0x0000004E

                                                                              /**
                                                                               * @brief WRMSRLIST
                                                                               *
                                                                               * Guest software attempted to execute WRMSRLIST and either the "use MSR bitmaps" VM-execution control was 0 or any of the
                                                                               * following holds for the index an MSR being accessed:
                                                                               * * The index is neither in the range 00000000H - 00001FFFH nor in the range C0000000H - C0001FFFH.
                                                                               * * The index is in the range 00000000H - 00001FFFH and the nth bit in write bitmap for low MSRs is 1, where n is the
                                                                               * index.
                                                                               * * The index is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for high MSRs is 1, where n is the
                                                                               * logical AND of the index and the value 00001FFFH.
                                                                               */
#define VMX_EXIT_REASON_EXECUTE_WRMSRLIST                            0x0000004F
                                                                               /**
                                                                                * @}
                                                                                */

                                                                                /**
                                                                                 * @defgroup vmx_instruction_error_numbers \
                                                                                 *           VM-Instruction Error Numbers
                                                                                 *
                                                                                 * VM-Instruction Error Numbers.
                                                                                 *
                                                                                 * @see Vol3C[30.4(VM INSTRUCTION ERROR NUMBERS)] (reference)
                                                                                 * @{
                                                                                 */
                                                                                 /**
                                                                                  * VMCALL executed in VMX root operation.
                                                                                  */
#define VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION                       0x00000001

                                                                                  /**
                                                                                   * VMCLEAR with invalid physical address.
                                                                                   */
#define VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS                   0x00000002

                                                                                   /**
                                                                                    * VMCLEAR with VMXON pointer.
                                                                                    */
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER                      0x00000003

                                                                                    /**
                                                                                     * VMLAUNCH with non-clear VMCS.
                                                                                     */
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS                             0x00000004

                                                                                     /**
                                                                                      * VMRESUME with non-launched VMCS.
                                                                                      */
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS                         0x00000005

                                                                                      /**
                                                                                       * VMRESUME after VMXOFF (VMXOFF and VMXON between VMLAUNCH and VMRESUME).
                                                                                       */
#define VMX_ERROR_VMRESUME_AFTER_VMXOFF                              0x00000006

                                                                                       /**
                                                                                        * VM entry with invalid control field(s).
                                                                                        */
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS                     0x00000007

                                                                                        /**
                                                                                         * VM entry with invalid host-state field(s).
                                                                                         */
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE                         0x00000008

                                                                                         /**
                                                                                          * VMPTRLD with invalid physical address.
                                                                                          */
#define VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS                   0x00000009

                                                                                          /**
                                                                                           * VMPTRLD with VMXON pointer.
                                                                                           */
#define VMX_ERROR_VMPTRLD_VMXON_POINTER                              0x0000000A

                                                                                           /**
                                                                                            * VMPTRLD with incorrect VMCS revision identifier.
                                                                                            */
#define VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID                 0x0000000B

                                                                                            /**
                                                                                             * VMREAD/VMWRITE from/to unsupported VMCS component.
                                                                                             */
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT                   0x0000000C

                                                                                             /**
                                                                                              * VMWRITE to read-only VMCS component.
                                                                                              */
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT                         0x0000000D

                                                                                              /**
                                                                                               * VMXON executed in VMX root operation.
                                                                                               */
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP                               0x0000000F

                                                                                               /**
                                                                                                * VM entry with invalid executive-VMCS pointer.
                                                                                                */
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER             0x00000010

                                                                                                /**
                                                                                                 * VM entry with non-launched executive VMCS.
                                                                                                 */
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS                0x00000011

                                                                                                 /**
                                                                                                  * VM entry with executive-VMCS pointer not VMXON pointer (when attempting to deactivate the dual-monitor treatment of SMIs
                                                                                                  * and SMM).
                                                                                                  */
#define VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR                         0x00000012

                                                                                                  /**
                                                                                                   * VMCALL with non-clear VMCS (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                                   */
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS                              0x00000013

                                                                                                   /**
                                                                                                    * VMCALL with invalid VM-exit control fields.
                                                                                                    */
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS                       0x00000014

                                                                                                    /**
                                                                                                     * VMCALL with incorrect MSEG revision identifier (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                                     */
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID                    0x00000016

                                                                                                     /**
                                                                                                      * VMXOFF under dual-monitor treatment of SMIs and SMM.
                                                                                                      */
#define VMX_ERROR_VMXOFF_DUAL_MONITOR                                0x00000017

                                                                                                      /**
                                                                                                       * VMCALL with invalid SMM-monitor features (when attempting to activate the dual-monitor treatment of SMIs and SMM).
                                                                                                       */
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR                         0x00000018

                                                                                                       /**
                                                                                                        * VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return from SMM).
                                                                                                        */
#define VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL               0x00000019

                                                                                                        /**
                                                                                                         * VM entry with events blocked by MOV SS.
                                                                                                         */
#define VMX_ERROR_VMENTRY_MOV_SS                                     0x0000001A

                                                                                                         /**
                                                                                                          * Invalid operand to INVEPT/INVVPID.
                                                                                                          */
#define VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND                     0x0000001C
                                                                                                          /**
                                                                                                           * @}
                                                                                                           */

                                                                                                           /**
                                                                                                            * @defgroup vmx_exceptions \
                                                                                                            *           Virtualization Exceptions
                                                                                                            *
                                                                                                            * Virtualization Exceptions.
                                                                                                            *
                                                                                                            * @see Vol3C[25.5.6(Virtualization Exceptions)] (reference)
                                                                                                            * @{
                                                                                                            */
typedef struct
{
    /**
     * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit occurred instead of the
     * virtualization exception. For EPT violations, this value is 48 (00000030H).
     */
    uint32_t reason;

    /**
     * FFFFFFFFH
     */
    uint32_t exception_mask;

    /**
     * The 64-bit value that would have been saved into the VMCS as an exit qualification had a VM exit occurred instead of the
     * virtualization exception.
     */
    uint64_t exit;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a VM exit occurred instead of
     * the virtualization exception.
     */
    uint64_t guest_linear_address;

    /**
     * The 64-bit value that would have been saved into the VMCS as a guest-physical address had a VM exit occurred instead of
     * the virtualization exception.
     */
    uint64_t guest_physical_address;

    /**
     * The current 16-bit value of the EPTP index VM-execution control.
     *
     * @see Vol3C[24.6.18(Controls for Virtualization Exceptions)]
     * @see Vol3C[25.5.5.3(EPTP Switching)]
     */
    uint16_t current_eptp_index;
} vmx_virtualization_exception_information;

/**
 * @}
 */

 /**
  * @defgroup vmx_basic_exit_information \
  *           Basic VM-Exit Information
  *
  * Basic VM-Exit Information.
  *
  * @see Vol3C[27.2.1(Basic VM-Exit Information)] (reference)
  * @{
  */
  /**
   * @brief Exit Qualification for Debug Exceptions
   */
typedef union
{
    struct
    {
        /**
         * @brief B0 - B3
         *
         * [Bits 3:0] When set, each of these bits indicates that the corresponding breakpoint condition was met. Any of these bits
         * may be set even if its corresponding enabling bit in DR7 is not set.
         */
        uint64_t breakpoint_condition : 4;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_BIT 0
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_) (((_) >> 0) & 0x0F)
        uint64_t reserved1 : 9;

        /**
         * @brief BD
         *
         * [Bit 13] When set, this bit indicates that the cause of the debug exception is "debug register access detected."
         */
        uint64_t debug_register_access_detected : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT 13
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) (((_) >> 13) & 0x01)

        /**
         * @brief BS
         *
         * [Bit 14] When set, this bit indicates that the cause of the debug exception is either the execution of a single
         * instruction (if RFLAGS.TF = 1 and IA32_DEBUGCTL.BTF = 0) or a taken branch (if RFLAGS.TF = DEBUGCTL.BTF = 1).
         */
        uint64_t single_instruction : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT 14
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_) (((_) >> 14) & 0x01)
        uint64_t reserved2 : 49;
    };

    uint64_t flags;
} vmx_exit_qualification_debug_exception;

/**
 * @brief Exit Qualification for Task Switch
 */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Selector of task-state segment (TSS) to which the guest attempted to switch.
         */
        uint64_t selector : 16;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT              0
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK             0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_)               (((_) >> 0) & 0xFFFF)
        uint64_t reserved1 : 14;

        /**
         * [Bits 31:30] Source of task switch initiation.
         */
        uint64_t source : 2;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT                30
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG               0xC0000000
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_)                 (((_) >> 30) & 0x03)
#define VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION                 0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION                 0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION                  0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT                 0x00000003
        uint64_t reserved2 : 32;
    };

    uint64_t flags;
} vmx_exit_qualification_task_switch;

/**
 * @brief Exit Qualification for Control-Register Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Number of control register (0 for CLTS and LMSW). Bit 3 is always 0 on processors that do not support Intel
         * 64 architecture as they do not support CR8.
         */
        uint64_t control_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT           0
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_)            (((_) >> 0) & 0x0F)
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                          0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                          0x00000008

        /**
         * [Bits 5:4] Access type.
         */
        uint64_t access_type : 2;
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT                4
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG               0x30
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK               0x03
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_)                 (((_) >> 4) & 0x03)
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR                      0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR                    0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS                           0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW                           0x00000003

        /**
         * [Bit 6] LMSW operand type. For CLTS and MOV CR, cleared to 0.
         */
        uint64_t lmsw_operand_type : 1;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT          6
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG         0x40
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK         0x01
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_)           (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER                      0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                        0x00000001
        uint64_t reserved1 : 1;

        /**
         * [Bits 11:8] For MOV CR, the general-purpose register.
         */
        uint64_t general_purpose_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                            0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                            0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                            0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                            0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                            0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                            0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                            0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                            0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                             0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                             0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                            0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                            0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                            0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                            0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                            0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                            0x0000000F
        uint64_t reserved2 : 4;

        /**
         * [Bits 31:16] For LMSW, the LMSW source data. For CLTS and MOV CR, cleared to 0.
         */
        uint64_t lmsw_source_data : 16;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT           16
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG          0xFFFF0000
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK          0xFFFF
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_)            (((_) >> 16) & 0xFFFF)
        uint64_t reserved3 : 32;
    };

    uint64_t flags;
} vmx_exit_qualification_mov_cr;

/**
 * @brief Exit Qualification for MOV DR
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Number of debug register.
         */
        uint64_t debug_register : 3;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_BIT             0
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_FLAG            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_MASK            0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_)              (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1                          0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6                          0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7                          0x00000007
        uint64_t reserved1 : 1;

        /**
         * [Bit 4] Direction of access (0 = MOV to DR; 1 = MOV from DR).
         */
        uint64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT        4
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG       0x10
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_)         (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR                   0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR                 0x00000001
        uint64_t reserved2 : 3;

        /**
         * [Bits 11:8] General-purpose register.
         */
        uint64_t general_purpose_register : 4;
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT   8
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG  0xF00
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK  0x0F
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_)    (((_) >> 8) & 0x0F)
        uint64_t reserved3 : 52;
    };

    uint64_t flags;
} vmx_exit_qualification_mov_dr;

/**
 * @brief Exit Qualification for I/O Instructions
 */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] Size of access.
         */
        uint64_t size_of_access : 3;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_BIT     0
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_FLAG    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_MASK    0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_)      (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_WIDTH_1_BYTE                          0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2_BYTE                          0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4_BYTE                          0x00000003

        /**
         * [Bit 3] Direction of the attempted access (0 = OUT, 1 = IN).
         */
        uint64_t direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT 3
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_) (((_) >> 3) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                         0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                          0x00000001

        /**
         * [Bit 4] String instruction (0 = not string; 1 = string).
         */
        uint64_t string_instruction : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT 4
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_)  (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                  0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                      0x00000001

        /**
         * [Bit 5] REP prefixed (0 = not REP; 1 = REP).
         */
        uint64_t rep_prefixed : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT       5
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG      0x20
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK      0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_)        (((_) >> 5) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                        0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                            0x00000001

        /**
         * [Bit 6] Operand encoding (0 = DX, 1 = immediate).
         */
        uint64_t operand_encoding : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT   6
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG  0x40
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK  0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_)    (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                           0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE                    0x00000001
        uint64_t reserved1 : 9;

        /**
         * [Bits 31:16] Port number (as specified in DX or in an immediate operand).
         */
        uint64_t port_number : 16;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT        16
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG       0xFFFF0000
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK       0xFFFF
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_)         (((_) >> 16) & 0xFFFF)
        uint64_t reserved2 : 32;
    };

    uint64_t flags;
} vmx_exit_qualification_io_instruction;

/**
 * @brief Exit Qualification for APIC-Access VM Exits from Linear Accesses and Guest-Physical Accesses
 */
typedef union
{
    struct
    {
        /**
         * [Bits 11:0] - If the APIC-access VM exit is due to a linear access, the offset of access within the APIC page.
         * - Undefined if the APIC-access VM exit is due a guest-physical access.
         */
        uint64_t page_offset : 12;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_BIT           0
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_FLAG          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_MASK          0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_)            (((_) >> 0) & 0xFFF)

        /**
         * [Bits 15:12] Access type.
         */
        uint64_t access_type : 4;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT           12
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG          0xF000
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK          0x0F
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_)            (((_) >> 12) & 0x0F)
        /**
         * Linear access for a data read during instruction execution.
         */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ                      0x00000000

         /**
          * Linear access for a data write during instruction execution.
          */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE                     0x00000001

          /**
           * Linear access for an instruction fetch.
           */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH         0x00000002

           /**
            * Linear access (read or write) during event delivery.
            */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY            0x00000003

            /**
             * Guest-physical access during event delivery.
             */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY          0x0000000A

             /**
              * Guest-physical access for an instruction fetch or during instruction execution.
              */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH       0x0000000F
        uint64_t reserved1 : 48;
    };

    uint64_t flags;
} vmx_exit_qualification_apic_access;

/**
 * @brief Exit Qualification for EPT Violations
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Set if the access causing the EPT violation was a data read.
         */
        uint64_t read_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_BIT         0
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_FLAG        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_MASK        0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_)          (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Set if the access causing the EPT violation was a data write.
         */
        uint64_t write_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT        1
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG       0x02
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_)         (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
         */
        uint64_t execute_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT      2
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG     0x04
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_)       (((_) >> 2) & 0x01)

        /**
         * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was readable).
         */
        uint64_t ept_readable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT        3
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG       0x08
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK       0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_)         (((_) >> 3) & 0x01)

        /**
         * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation (indicates whether the guest-physical address was writeable).
         */
        uint64_t ept_writeable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT       4
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG      0x10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK      0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_)        (((_) >> 4) & 0x01)

        /**
         * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to translate the guest-physical address of the
         * access causing the EPT violation.
         * If the "mode-based execute control for EPT" VM-execution control is 0, this indicates whether the guest-physical address
         * was executable. If that control is 1, this indicates whether the guest-physical address was executable for
         * supervisor-mode linear addresses.
         */
        uint64_t ept_executable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT      5
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG     0x20
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_)       (((_) >> 5) & 0x01)

        /**
         * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value of this bit is undefined. If that
         * control is 1, this bit is the logical-AND of bit 10 in the EPT paging-structures entries used to translate the
         * guest-physical address of the access causing the EPT violation. In this case, it indicates whether the guest-physical
         * address was executable for user-mode linear addresses.
         */
        uint64_t ept_executable_for_user_mode : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT 6
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_) (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address field is valid for all EPT violations
         * except those resulting from an attempt to load the guest PDPTEs as part of the execution of the MOV CR instruction.
         */
        uint64_t valid_guest_linear_address : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT 7
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG 0x80
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_) (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 7 is 1:
         * - Set if the access causing the EPT violation is to a guest-physical address that is the translation of a linear
         * address.
         * - Clear if the access causing the EPT violation is to a paging-structure entry as part of a page walk or the update of
         * an accessed or dirty bit.
         * Reserved if bit 7 is 0 (cleared to 0).
         */
        uint64_t caused_by_translation : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT 8
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG 0x100
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_) (((_) >> 8) & 0x01)

        /**
         * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address and 1 if it is a user-mode linear
         * address. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, the translation of every linear address is a user-mode linear address and thus this bit will be 1.)
         */
        uint64_t user_mode_linear_address : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT 9
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG 0x200
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_) (((_) >> 9) & 0x01)

        /**
         * [Bit 10] This bit is 0 if paging translates the linear address to a read-only page and 1 if it translates to a
         * read/write page. Otherwise, this bit is undefined
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, every linear address is read/write and thus this bit will be 1.)
         */
        uint64_t readable_writable_page : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT 10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG 0x400
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_) (((_) >> 10) & 0x01)

        /**
         * [Bit 11] This bit is 0 if paging translates the linear address to an executable page and 1 if it translates to an
         * execute-disable page. Otherwise, this bit is undefined.
         *
         * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
         *          CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE = 0, every linear address is executable and thus this bit will be 0.)
         */
        uint64_t execute_disable_page : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT 11
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG 0x800
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_) (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        uint64_t nmi_unblocking : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT      12
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG     0x1000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK     0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_)       (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Set if the access causing the EPT violation was a shadow-stack access.
         */
        uint64_t shadow_stack_access : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_BIT 13
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS(_)  (((_) >> 13) & 0x01)

        /**
         * [Bit 14] If supervisor shadow-stack control is enabled (by setting bit 7 of EPTP), this bit is the same as bit 60 in the
         * EPT paging-structure entry that maps the page of the guest-physical address of the access causing the EPT violation.
         * Otherwise (or if translation of the guest-physical address terminates before reaching an EPT paging-structure entry that
         * maps a page), this bit is undefined.
         */
        uint64_t supervisor_shadow_stack : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_BIT 14
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK(_) (((_) >> 14) & 0x01)

        /**
         * [Bit 15] This bit is set if the EPT violation was caused as a result of guest-paging verification.
         */
        uint64_t guest_paging_verification : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_BIT 15
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_FLAG 0x8000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION(_) (((_) >> 15) & 0x01)

        /**
         * [Bit 16] This bit is set if the access was asynchronous to instruction execution not the result of event delivery. (The
         * bit is set if the access is related to trace output by Intel PT; see Section 25.5.4.) Otherwise, this bit is cleared.
         */
        uint64_t asynchronous_to_instruction : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_BIT 16
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_FLAG 0x10000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION(_) (((_) >> 16) & 0x01)
        uint64_t reserved1 : 47;
    };

    uint64_t flags;
} vmx_exit_qualification_ept_violation;

/**
 * @}
 */

 /**
  * @defgroup vmx_vmexit_instruction_information \
  *           Information for VM Exits Due to Instruction Execution
  *
  * Information for VM Exits Due to Instruction Execution.
  *
  * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)] (reference)
  * @{
  */
  /**
   * @brief VM-Exit Instruction-Information Field as Used for INS and OUTS
   */
typedef union
{
    struct
    {
        uint64_t reserved1 : 7;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        uint64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT        7
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG       0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK       0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_)         (((_) >> 7) & 0x07)
        uint64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        uint64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT    15
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG   0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK   0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_)     (((_) >> 15) & 0x07)
        uint64_t reserved3 : 46;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_ins_outs;

/**
 * @brief VM-Exit Instruction-Information Field as Used for INVEPT, INVPCID, and INVVPID
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        uint64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT           0
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK          0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_)            (((_) >> 0) & 0x03)
        uint64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        uint64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT      7
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG     0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK     0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_)       (((_) >> 7) & 0x07)
        uint64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for VM exits due to execution of INS.
         */
        uint64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        uint64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        uint64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        uint64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT     23
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG    0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK    0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_)      (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        uint64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        uint64_t register_2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT        28
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG       0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK       0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_)         (((_) >> 28) & 0x0F)
        uint64_t reserved3 : 32;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_invalidate;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        uint64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT     0
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK    0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_)      (((_) >> 0) & 0x03)
        uint64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        uint64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT 7
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_) (((_) >> 7) & 0x07)
        uint64_t reserved2 : 1;

        /**
         * @brief Operand size
         *
         * [Bit 11] 0: 16-bit
         * 1: 32-bit
         * Undefined for VM exits from 64-bit mode.
         */
        uint64_t operand_size : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT 11
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG 0x800
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_) (((_) >> 11) & 0x01)
        uint64_t reserved3 : 3;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        uint64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        uint64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        uint64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        uint64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_) (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        uint64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SGDT
         * 1: SIDT
         * 2: LGDT
         * 3: LIDT
         */
        uint64_t instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT 28
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_)  (((_) >> 28) & 0x03)
        uint64_t reserved4 : 34;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_gdtr_idtr_access;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LLDT, LTR, SLDT, and STR
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        uint64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_)        (((_) >> 0) & 0x03)
        uint64_t reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        uint64_t reg_1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT         3
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG        0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK        0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_)          (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        uint64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        uint64_t memory_register : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        uint64_t reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        uint64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        uint64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        uint64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        uint64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        uint64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * @brief Instruction identity
         *
         * [Bits 29:28] 0: SLDT
         * 1: STR
         * 2: LLDT
         * 3: LTR
         */
        uint64_t instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT   28
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG  0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_)    (((_) >> 28) & 0x03)
        uint64_t reserved3 : 34;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_ldtr_tr_access;

/**
 * @brief VM-Exit Instruction-Information Field as Used for RDRAND and RDSEED
 */
typedef union
{
    struct
    {
        uint64_t reserved1 : 3;

        /**
         * [Bits 6:3] Destination register.
         */
        uint64_t destination_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_BIT 3
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_) (((_) >> 3) & 0x0F)
        uint64_t reserved2 : 4;

        /**
         * @brief Operand size
         *
         * [Bits 12:11] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit
         * The value 3 is not used.
         */
        uint64_t operand_size : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT   11
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG  0x1800
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK  0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_)    (((_) >> 11) & 0x03)
        uint64_t reserved3 : 51;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_rdrand_rdseed;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMCLEAR, VMPTRLD, VMPTRST, VMXON, XRSTORS, and XSAVES
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for instructions with no index register (bit 22 is set).
         */
        uint64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_)        (((_) >> 0) & 0x03)
        uint64_t reserved1 : 5;

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used.
         */
        uint64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
        uint64_t reserved2 : 5;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used.
         */
        uint64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for instructions with no index register (bit 22 is set).
         */
        uint64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
         */
        uint64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory instructions with no base register (bit 27 is
         * set).
         */
        uint64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        uint64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)
        uint64_t reserved3 : 36;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_vmx_and_xsaves;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMREAD and VMWRITE
 */
typedef union
{
    struct
    {
        /**
         * @brief Scaling
         *
         * [Bits 1:0] 0: no scaling
         * 1: scale by 2
         * 2: scale by 4
         * 3: scale by 8 (used only on processors that support Intel 64 architecture)
         * Undefined for register instructions (bit 10 is set) and for memory instructions with no index register (bit 10 is clear
         * and bit 22 is set).
         */
        uint64_t scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT       0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK      0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_)        (((_) >> 0) & 0x03)
        uint64_t reserved1 : 1;

        /**
         * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
         */
        uint64_t register_1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT    3
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG   0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_)     (((_) >> 3) & 0x0F)

        /**
         * @brief Address size
         *
         * [Bits 9:7] 0: 16-bit
         * 1: 32-bit
         * 2: 64-bit (used only on processors that support Intel 64 architecture)
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        uint64_t address_size : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

        /**
         * [Bit 10] Mem/Reg (0 = memory; 1 = register).
         */
        uint64_t memory_register : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT 10
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_) (((_) >> 10) & 0x01)
        uint64_t reserved2 : 4;

        /**
         * @brief Segment register
         *
         * [Bits 17:15] 0: ES
         * 1: CS
         * 2: SS
         * 3: DS
         * 4: FS
         * 5: GS
         * Other values not used. Undefined for register instructions (bit 10 is set).
         */
        uint64_t segment_register : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT 15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_) (((_) >> 15) & 0x07)

        /**
         * [Bits 21:18] General-purpose register. Undefined for register instructions (bit 10 is set) and for memory instructions
         * with no index register (bit 10 is clear and bit 22 is set).
         */
        uint64_t general_purpose_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT 18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_) (((_) >> 18) & 0x0F)

        /**
         * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register instructions (bit 10 is set).
         */
        uint64_t general_purpose_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT 22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) (((_) >> 22) & 0x01)

        /**
         * [Bits 26:23] BaseReg (encoded as Reg1 above). Undefined for register instructions (bit 10 is set) and for memory
         * instructions with no base register (bit 10 is clear and bit 27 is set).
         */
        uint64_t base_register : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT 23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_)  (((_) >> 23) & 0x0F)

        /**
         * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
         */
        uint64_t base_register_invalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT 27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_) (((_) >> 27) & 0x01)

        /**
         * [Bits 31:28] Reg2 (same encoding as IndexReg above).
         */
        uint64_t register_2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT    28
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG   0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK   0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_)     (((_) >> 28) & 0x0F)
        uint64_t reserved3 : 32;
    };

    uint64_t flags;
} vmx_vmexit_instruction_info_vmread_vmwrite;

/**
 * @}
 */

 /**
  * @brief - The low 16 bits correspond to bits 23:8 of the upper 32 bits of a 64-bit segment descriptor. While bits 19:16
  *        of code-segment and data-segment descriptors correspond to the upper 4 bits of the segment limit, the corresponding bits
  *        (bits 11:8) are reserved in this VMCS field.
  *        - Bit 16 indicates an unusable segment. Attempts to use such a segment fault except in 64-bit mode. In general, a
  *        segment register is unusable if it has been loaded with a null selector.
  *        - Bits 31:17 are reserved
  *
  * @note There are a few exceptions to this statement. For example, a segment with a non-null selector may be unusable
  *       following a task switch that fails after its commit point. In contrast, the TR register is usable after processor reset
  *       despite having a null selector
  * @see SEGMENT_DESCRIPTOR_32
  * @see SEGMENT_DESCRIPTOR_64
  * @see XXX_ACCESS_RIGHTS fields of 32_BIT_GUEST_STATE_FIELDS
  * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 3:0] Segment type.
         */
        uint32_t type : 4;
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT                           0
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK                          0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_)                            (((_) >> 0) & 0x0F)

        /**
         * [Bit 4] S - Descriptor type (0 = system; 1 = code or data).
         */
        uint32_t descriptor_type : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT                4
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG               0x10
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK               0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)                 (((_) >> 4) & 0x01)

        /**
         * [Bits 6:5] DPL - Descriptor privilege level.
         */
        uint32_t descriptor_privilege_level : 2;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT     5
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG    0x60
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK    0x03
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)      (((_) >> 5) & 0x03)

        /**
         * [Bit 7] P - Segment present.
         */
        uint32_t present : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT                        7
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG                       0x80
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK                       0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_)                         (((_) >> 7) & 0x01)
        uint32_t reserved1 : 4;

        /**
         * [Bit 12] AVL - Available for use by system software.
         */
        uint32_t available_bit : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT                  12
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG                 0x1000
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK                 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_)                   (((_) >> 12) & 0x01)

        /**
         * [Bit 13] Reserved (except for CS). L - 64-bit mode active (for CS only).
         */
        uint32_t long_mode : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT                      13
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG                     0x2000
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK                     0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)                       (((_) >> 13) & 0x01)

        /**
         * [Bit 14] D/B - Default operation size (0 = 16-bit segment; 1 = 32-bit segment).
         */
        uint32_t default_big : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT                    14
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG                   0x4000
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)                     (((_) >> 14) & 0x01)

        /**
         * [Bit 15] G - Granularity.
         */
        uint32_t granularity : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT                    15
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG                   0x8000
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK                   0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)                     (((_) >> 15) & 0x01)

        /**
         * [Bit 16] Segment unusable (0 = usable; 1 = unusable).
         */
        uint32_t unusable : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT                       16
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG                      0x10000
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK                      0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_)                        (((_) >> 16) & 0x01)
        uint32_t reserved2 : 15;
    };

    uint32_t flags;
} vmx_segment_access_rights;

/**
 * @brief The IA-32 architecture includes features that permit certain events to be blocked for a period of time. This
 *        field contains information about such blocking
 *
 * @see INTERRUPTIBILITY_STATE of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Execution of STI with RFLAGS.IF = 0 blocks maskable interrupts on the instruction boundary following its
         * execution.1 Setting this bit indicates that this blocking is in effect.
         *
         * @see Vol2B[4(STI-Set Interrupt Flag)]
         */
        uint32_t blocking_by_sti : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_BIT               0
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_FLAG              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_)                (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Execution of a MOV to SS or a POP to SS blocks or suppresses certain debug exceptions as well as interrupts
         * (maskable and nonmaskable) on the instruction boundary following its execution. Setting this bit indicates that this
         * blocking is in effect. This document uses the term "blocking by MOV SS," but it applies equally to POP SS.
         *
         * @see Vol3A[6.8.3(Masking Exceptions and Interrupts When Switching Stacks)]
         */
        uint32_t blocking_by_mov_ss : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT            1
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG           0x02
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK           0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_)             (((_) >> 1) & 0x01)

        /**
         * [Bit 2] System-management interrupts (SMIs) are disabled while the processor is in system-management mode (SMM). Setting
         * this bit indicates that blocking of SMIs is in effect.
         *
         * @see Vol3C[34.2(System Management Interrupt (SMI))]
         */
        uint32_t blocking_by_smi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT               2
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG              0x04
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_)                (((_) >> 2) & 0x01)

        /**
         * [Bit 3] Delivery of a non-maskable interrupt (NMI) or a system-management interrupt (SMI) blocks subsequent NMIs until
         * the next execution of IRET. Setting this bit indicates that blocking of NMIs is in effect. Clearing this bit does not
         * imply that NMIs are not (temporarily) blocked for other reasons. If the "virtual NMIs" VM-execution control is 1, this
         * bit does not control the blocking of NMIs. Instead, it refers to "virtual-NMI blocking" (the fact that guest software is
         * not ready for an NMI).
         *
         * @see Vol3C[6.7.1(Handling Multiple NMIs)]
         * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
         * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)]
         */
        uint32_t blocking_by_nmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT               3
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG              0x08
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK              0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_)                (((_) >> 3) & 0x01)

        /**
         * [Bit 4] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        uint32_t enclave_interruption : 1;
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT          4
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG         0x10
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK         0x01
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_)           (((_) >> 4) & 0x01)
        uint32_t reserved1 : 27;
    };

    uint32_t flags;
} vmx_interruptibility_state;

typedef enum
{
    /**
     * The logical processor is executing instructions normally.
     */
    vmx_active = 0x00000000,

    /**
     * The logical processor is inactive because it executed the HLT instruction.
     */
    vmx_hlt = 0x00000001,

    /**
     * The logical processor is inactive because it incurred a triple fault1 or some other serious error.
     */
    vmx_shutdown = 0x00000002,

    /**
     * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).
     */
    vmx_wait_for_sipi = 0x00000003,
} vmx_guest_activity_state;

/**
 * @brief IA-32 processors may recognize one or more debug exceptions without immediately delivering them. This field
 *        contains information about such exceptions
 *
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set, indicates that the corresponding breakpoint condition was met. May be set even if the corresponding
         * enabling bit in DR7 is not set.
         */
        uint64_t b0 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0_BIT                          0
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0_FLAG                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0(_)                           (((_) >> 0) & 0x01)

        /**
         * [Bit 1] When set, indicates that the corresponding breakpoint condition was met. May be set even if the corresponding
         * enabling bit in DR7 is not set.
         */
        uint64_t b1 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_BIT                          1
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_FLAG                         0x02
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1(_)                           (((_) >> 1) & 0x01)

        /**
         * [Bit 2] When set, indicates that the corresponding breakpoint condition was met. May be set even if the corresponding
         * enabling bit in DR7 is not set.
         */
        uint64_t b2 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_BIT                          2
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_FLAG                         0x04
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2(_)                           (((_) >> 2) & 0x01)

        /**
         * [Bit 3] When set, indicates that the corresponding breakpoint condition was met. May be set even if the corresponding
         * enabling bit in DR7 is not set.
         */
        uint64_t b3 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_BIT                          3
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_FLAG                         0x08
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3(_)                           (((_) >> 3) & 0x01)
        uint64_t reserved1 : 8;

        /**
         * [Bit 12] When set, this bit indicates that at least one data or I/O breakpoint was met and was enabled in DR7.
         */
        uint64_t enabled_breakpoint : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_BIT          12
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_FLAG         0x1000
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_MASK         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT(_)           (((_) >> 12) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bit 14] When set, this bit indicates that a debug exception would have been triggered by single-step execution mode.
         */
        uint64_t bs : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_BIT                          14
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_FLAG                         0x4000
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_MASK                         0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS(_)                           (((_) >> 14) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * [Bit 16] When set, this bit indicates that a debug exception (\#DB) or a breakpoint exception (\#BP) occurred inside an
         * RTM region while advanced debugging of RTM transactional regions was enabled.
         */
        uint64_t rtm : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_BIT                         16
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_FLAG                        0x10000
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_MASK                        0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM(_)                          (((_) >> 16) & 0x01)
        uint64_t reserved4 : 47;
    };

    uint64_t flags;
} vmx_pending_debug_exceptions;

/**
 * @}
 */

 /**
  * @brief Format of Exit Reason
  *
  * Exit reason (32 bits). This field encodes the reason for the VM exit and has the structure.
  *
  * @see Vol3C[24.9.1(Basic VM-Exit Information)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 15:0] Provides basic information about the cause of the VM exit (if bit 31 is clear) or of the VM-entry failure
         * (if bit 31 is set).
         */
        uint32_t basic_exit_reason : 16;
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT                      0
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK                     0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_)                       (((_) >> 0) & 0xFFFF)

        /**
         * [Bit 16] Always cleared to 0.
         */
        uint32_t always0 : 1;
#define VMX_VMEXIT_REASON_ALWAYS0_BIT                                16
#define VMX_VMEXIT_REASON_ALWAYS0_FLAG                               0x10000
#define VMX_VMEXIT_REASON_ALWAYS0_MASK                               0x01
#define VMX_VMEXIT_REASON_ALWAYS0(_)                                 (((_) >> 16) & 0x01)
        uint32_t reserved1 : 10;
#define VMX_VMEXIT_REASON_RESERVED1_BIT                              17
#define VMX_VMEXIT_REASON_RESERVED1_FLAG                             0x7FE0000
#define VMX_VMEXIT_REASON_RESERVED1_MASK                             0x3FF
#define VMX_VMEXIT_REASON_RESERVED1(_)                               (((_) >> 17) & 0x3FF)

        /**
         * [Bit 27] A VM exit saves this bit as 1 to indicate that the VM exit was incident to enclave mode.
         */
        uint32_t enclave_mode : 1;
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT                           27
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG                          0x8000000
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK                          0x01
#define VMX_VMEXIT_REASON_ENCLAVE_MODE(_)                            (((_) >> 27) & 0x01)

        /**
         * [Bit 28] Pending MTF VM exit.
         */
        uint32_t pending_mtf_vm_exit : 1;
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT                    28
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG                   0x10000000
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK                   0x01
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_)                     (((_) >> 28) & 0x01)

        /**
         * [Bit 29] VM exit from VMX root operation.
         */
        uint32_t vm_exit_from_vmx_root : 1;
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_BIT                  29
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_FLAG                 0x20000000
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_MASK                 0x01
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT(_)                   (((_) >> 29) & 0x01)
        uint32_t reserved2 : 1;
#define VMX_VMEXIT_REASON_RESERVED2_BIT                              30
#define VMX_VMEXIT_REASON_RESERVED2_FLAG                             0x40000000
#define VMX_VMEXIT_REASON_RESERVED2_MASK                             0x01
#define VMX_VMEXIT_REASON_RESERVED2(_)                               (((_) >> 30) & 0x01)

        /**
         * [Bit 31] VM-entry failure:
         *   - 0 = true VM exit
         *   - 1 = VM-entry failure
         */
        uint32_t vm_entry_failure : 1;
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT                       31
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG                      0x80000000
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK                      0x01
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_)                        (((_) >> 31) & 0x01)
    };

    uint32_t flags;
} vmx_vmexit_reason;

typedef struct
{
#define IO_BITMAP_A_MIN                                              0x00000000
#define IO_BITMAP_A_MAX                                              0x00007FFF
#define IO_BITMAP_B_MIN                                              0x00008000
#define IO_BITMAP_B_MAX                                              0x0000FFFF
    uint8_t io_a[4096];
    uint8_t io_b[4096];
} vmx_io_bitmap;

typedef struct
{
#define MSR_ID_LOW_MIN                                               0x00000000
#define MSR_ID_LOW_MAX                                               0x00001FFF
#define MSR_ID_HIGH_MIN                                              0xC0000000
#define MSR_ID_HIGH_MAX                                              0xC0001FFF
    uint8_t rdmsr_low[1024];
    uint8_t rdmsr_high[1024];
    uint8_t wrmsr_low[1024];
    uint8_t wrmsr_high[1024];
} vmx_msr_bitmap;

/**
 * @defgroup ept \
 *           The extended page-table mechanism
 *
 * The extended page-table mechanism (EPT) is a feature that can be used to support the virtualization of physical memory.
 * When EPT is in use, certain addresses that would normally be treated as physical addresses (and used to access memory)
 * are instead treated as guest-physical addresses. Guest-physical addresses are translated by traversing a set of EPT
 * paging structures to produce physical addresses that are used to access memory.
 *
 * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))] (reference)
 * @{
 */
 /**
  * @brief Extended-Page-Table Pointer (EPTP)
  *
  * The extended-page-table pointer (EPTP) contains the address of the base of EPT PML4 table, as well as other EPT
  * configuration information.
  *
  * @see Vol3C[28.2.2(EPT Translation Mechanism]
  * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 2:0] EPT paging-structure memory type:
         * - 0 = Uncacheable (UC)
         * - 6 = Write-back (WB)
         * Other values are reserved.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t memory_type : 3;
#define EPT_POINTER_MEMORY_TYPE_BIT                                  0
#define EPT_POINTER_MEMORY_TYPE_FLAG                                 0x07
#define EPT_POINTER_MEMORY_TYPE_MASK                                 0x07
#define EPT_POINTER_MEMORY_TYPE(_)                                   (((_) >> 0) & 0x07)

        /**
         * [Bits 5:3] This value is 1 less than the EPT page-walk length.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t page_walk_length : 3;
#define EPT_POINTER_PAGE_WALK_LENGTH_BIT                             3
#define EPT_POINTER_PAGE_WALK_LENGTH_FLAG                            0x38
#define EPT_POINTER_PAGE_WALK_LENGTH_MASK                            0x07
#define EPT_POINTER_PAGE_WALK_LENGTH(_)                              (((_) >> 3) & 0x07)
#define EPT_PAGE_WALK_LENGTH_4                                       0x00000003

        /**
         * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t enable_access_and_dirty_flags : 1;
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT                6
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG               0x40
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK               0x01
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_)                 (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Setting this control to 1 enables enforcement of access rights for supervisor shadow-stack pages.
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t enable_supervisor_shadow_stack_pages : 1;
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_BIT         7
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_FLAG        0x80
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_MASK        0x01
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES(_)          (((_) >> 7) & 0x01)
        uint64_t reserved1 : 4;

        /**
         * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4 table.
         */
        uint64_t page_frame_number : 36;
#define EPT_POINTER_PAGE_FRAME_NUMBER_BIT                            12
#define EPT_POINTER_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFFFF000
#define EPT_POINTER_PAGE_FRAME_NUMBER_MASK                           0xFFFFFFFFF
#define EPT_POINTER_PAGE_FRAME_NUMBER(_)                             (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved2 : 16;
    };

    uint64_t flags;
} ept_pointer;

/**
 * @brief Format of an EPT PML4 Entry (PML4E) that References an EPT Page-Directory-Pointer Table
 *
 * A 4-KByte naturally aligned EPT PML4 table is located at the physical address specified in bits 51:12 of the
 * extended-page-table pointer (EPTP), a VM-execution control field. An EPT PML4 table comprises 512 64-bit entries (EPT
 * PML4Es). An EPT PML4E is selected using the physical address defined as follows:
 * - Bits 63:52 are all 0.
 * - Bits 51:12 are from the EPTP.
 * - Bits 11:3 are bits 47:39 of the guest-physical address.
 * - Bits 2:0 are all 0.
 * Because an EPT PML4E is identified using bits 47:39 of the guest-physical address, it controls access to a 512- GByte
 * region of the guest-physical-address space.
 *
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)]
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte region controlled by this entry.
         */
        uint64_t read_access : 1;
#define EPT_PML4E_READ_ACCESS_BIT                                    0
#define EPT_PML4E_READ_ACCESS_FLAG                                   0x01
#define EPT_PML4E_READ_ACCESS_MASK                                   0x01
#define EPT_PML4E_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte region controlled by this entry.
         */
        uint64_t write_access : 1;
#define EPT_PML4E_WRITE_ACCESS_BIT                                   1
#define EPT_PML4E_WRITE_ACCESS_FLAG                                  0x02
#define EPT_PML4E_WRITE_ACCESS_MASK                                  0x01
#define EPT_PML4E_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 512-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 512-GByte region controlled by this entry.
         */
        uint64_t execute_access : 1;
#define EPT_PML4E_EXECUTE_ACCESS_BIT                                 2
#define EPT_PML4E_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_PML4E_EXECUTE_ACCESS_MASK                                0x01
#define EPT_PML4E_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
        uint64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 512-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t accessed : 1;
#define EPT_PML4E_ACCESSED_BIT                                       8
#define EPT_PML4E_ACCESSED_FLAG                                      0x100
#define EPT_PML4E_ACCESSED_MASK                                      0x01
#define EPT_PML4E_ACCESSED(_)                                        (((_) >> 8) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 512-GByte region
         * controlled by this entry. If that control is 0, this bit is ignored.
         */
        uint64_t user_mode_execute : 1;
#define EPT_PML4E_USER_MODE_EXECUTE_BIT                              10
#define EPT_PML4E_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_PML4E_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_PML4E_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define EPT_PML4E_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_PML4E_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_PML4E_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_PML4E_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved4 : 16;
    };

    uint64_t flags;
} ept_pml4e;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte page referenced by this entry.
         */
        uint64_t read_access : 1;
#define EPT_PDPTE_1GB_READ_ACCESS_BIT                                0
#define EPT_PDPTE_1GB_READ_ACCESS_FLAG                               0x01
#define EPT_PDPTE_1GB_READ_ACCESS_MASK                               0x01
#define EPT_PDPTE_1GB_READ_ACCESS(_)                                 (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page referenced by this entry.
         */
        uint64_t write_access : 1;
#define EPT_PDPTE_1GB_WRITE_ACCESS_BIT                               1
#define EPT_PDPTE_1GB_WRITE_ACCESS_FLAG                              0x02
#define EPT_PDPTE_1GB_WRITE_ACCESS_MASK                              0x01
#define EPT_PDPTE_1GB_WRITE_ACCESS(_)                                (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte page controlled by this entry.
         */
        uint64_t execute_access : 1;
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_BIT                             2
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_FLAG                            0x04
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_MASK                            0x01
#define EPT_PDPTE_1GB_EXECUTE_ACCESS(_)                              (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t memory_type : 3;
#define EPT_PDPTE_1GB_MEMORY_TYPE_BIT                                3
#define EPT_PDPTE_1GB_MEMORY_TYPE_FLAG                               0x38
#define EPT_PDPTE_1GB_MEMORY_TYPE_MASK                               0x07
#define EPT_PDPTE_1GB_MEMORY_TYPE(_)                                 (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 1-GByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t ignore_pat : 1;
#define EPT_PDPTE_1GB_IGNORE_PAT_BIT                                 6
#define EPT_PDPTE_1GB_IGNORE_PAT_FLAG                                0x40
#define EPT_PDPTE_1GB_IGNORE_PAT_MASK                                0x01
#define EPT_PDPTE_1GB_IGNORE_PAT(_)                                  (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
         */
        uint64_t large_page : 1;
#define EPT_PDPTE_1GB_LARGE_PAGE_BIT                                 7
#define EPT_PDPTE_1GB_LARGE_PAGE_FLAG                                0x80
#define EPT_PDPTE_1GB_LARGE_PAGE_MASK                                0x01
#define EPT_PDPTE_1GB_LARGE_PAGE(_)                                  (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t accessed : 1;
#define EPT_PDPTE_1GB_ACCESSED_BIT                                   8
#define EPT_PDPTE_1GB_ACCESSED_FLAG                                  0x100
#define EPT_PDPTE_1GB_ACCESSED_MASK                                  0x01
#define EPT_PDPTE_1GB_ACCESSED(_)                                    (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 1-GByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t dirty : 1;
#define EPT_PDPTE_1GB_DIRTY_BIT                                      9
#define EPT_PDPTE_1GB_DIRTY_FLAG                                     0x200
#define EPT_PDPTE_1GB_DIRTY_MASK                                     0x01
#define EPT_PDPTE_1GB_DIRTY(_)                                       (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        uint64_t user_mode_execute : 1;
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_BIT                          10
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_FLAG                         0x400
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_MASK                         0x01
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE(_)                           (((_) >> 10) & 0x01)
        uint64_t reserved1 : 19;

        /**
         * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        uint64_t page_frame_number : 18;
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_BIT                          30
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_FLAG                         0xFFFFC0000000
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_MASK                         0x3FFFF
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER(_)                           (((_) >> 30) & 0x3FFFF)
        uint64_t reserved2 : 9;

        /**
         * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution control is 1, indicates limits on the
         * guest paging structures used to access the 1-GByte page controlled by this entry (see Section 28.3.3.2). If that control
         * is 0, this bit is ignored.
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t verify_guest_paging : 1;
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_BIT                        57
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_FLAG                       0x200000000000000
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_MASK                       0x01
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING(_)                         (((_) >> 57) & 0x01)

        /**
         * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution control is 1, indicates that guest paging
         * may update the 1-GByte page controlled by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t paging_write_access : 1;
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_BIT                        58
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_FLAG                       0x400000000000000
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_MASK                       0x01
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS(_)                         (((_) >> 58) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether supervisor shadow stack accesses are allowed
         * to guest-physical addresses in the 1-GByte page mapped by this entry (see Section 28.3.3.2)
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t supervisor_shadow_stack : 1;
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_BIT                    60
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_FLAG                   0x1000000000000000
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_MASK                   0x01
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK(_)                     (((_) >> 60) & 0x01)
        uint64_t reserved4 : 2;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        uint64_t suppress_ve : 1;
#define EPT_PDPTE_1GB_SUPPRESS_VE_BIT                                63
#define EPT_PDPTE_1GB_SUPPRESS_VE_FLAG                               0x8000000000000000
#define EPT_PDPTE_1GB_SUPPRESS_VE_MASK                               0x01
#define EPT_PDPTE_1GB_SUPPRESS_VE(_)                                 (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ept_pdpte_1gb;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that References an EPT Page Directory
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte region controlled by this entry.
         */
        uint64_t read_access : 1;
#define EPT_PDPTE_READ_ACCESS_BIT                                    0
#define EPT_PDPTE_READ_ACCESS_FLAG                                   0x01
#define EPT_PDPTE_READ_ACCESS_MASK                                   0x01
#define EPT_PDPTE_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte region controlled by this entry.
         */
        uint64_t write_access : 1;
#define EPT_PDPTE_WRITE_ACCESS_BIT                                   1
#define EPT_PDPTE_WRITE_ACCESS_FLAG                                  0x02
#define EPT_PDPTE_WRITE_ACCESS_MASK                                  0x01
#define EPT_PDPTE_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 1-GByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 1-GByte region controlled by this entry.
         */
        uint64_t execute_access : 1;
#define EPT_PDPTE_EXECUTE_ACCESS_BIT                                 2
#define EPT_PDPTE_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_PDPTE_EXECUTE_ACCESS_MASK                                0x01
#define EPT_PDPTE_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
        uint64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t accessed : 1;
#define EPT_PDPTE_ACCESSED_BIT                                       8
#define EPT_PDPTE_ACCESSED_FLAG                                      0x100
#define EPT_PDPTE_ACCESSED_MASK                                      0x01
#define EPT_PDPTE_ACCESSED(_)                                        (((_) >> 8) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        uint64_t user_mode_execute : 1;
#define EPT_PDPTE_USER_MODE_EXECUTE_BIT                              10
#define EPT_PDPTE_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_PDPTE_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_PDPTE_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define EPT_PDPTE_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_PDPTE_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_PDPTE_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_PDPTE_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved4 : 16;
    };

    uint64_t flags;
} ept_pdpte;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that Maps a 2-MByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte page referenced by this entry.
         */
        uint64_t read_access : 1;
#define EPT_PDE_2MB_READ_ACCESS_BIT                                  0
#define EPT_PDE_2MB_READ_ACCESS_FLAG                                 0x01
#define EPT_PDE_2MB_READ_ACCESS_MASK                                 0x01
#define EPT_PDE_2MB_READ_ACCESS(_)                                   (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page referenced by this entry.
         */
        uint64_t write_access : 1;
#define EPT_PDE_2MB_WRITE_ACCESS_BIT                                 1
#define EPT_PDE_2MB_WRITE_ACCESS_FLAG                                0x02
#define EPT_PDE_2MB_WRITE_ACCESS_MASK                                0x01
#define EPT_PDE_2MB_WRITE_ACCESS(_)                                  (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte page controlled by this entry.
         */
        uint64_t execute_access : 1;
#define EPT_PDE_2MB_EXECUTE_ACCESS_BIT                               2
#define EPT_PDE_2MB_EXECUTE_ACCESS_FLAG                              0x04
#define EPT_PDE_2MB_EXECUTE_ACCESS_MASK                              0x01
#define EPT_PDE_2MB_EXECUTE_ACCESS(_)                                (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t memory_type : 3;
#define EPT_PDE_2MB_MEMORY_TYPE_BIT                                  3
#define EPT_PDE_2MB_MEMORY_TYPE_FLAG                                 0x38
#define EPT_PDE_2MB_MEMORY_TYPE_MASK                                 0x07
#define EPT_PDE_2MB_MEMORY_TYPE(_)                                   (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 2-MByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t ignore_pat : 1;
#define EPT_PDE_2MB_IGNORE_PAT_BIT                                   6
#define EPT_PDE_2MB_IGNORE_PAT_FLAG                                  0x40
#define EPT_PDE_2MB_IGNORE_PAT_MASK                                  0x01
#define EPT_PDE_2MB_IGNORE_PAT(_)                                    (((_) >> 6) & 0x01)

        /**
         * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
         */
        uint64_t large_page : 1;
#define EPT_PDE_2MB_LARGE_PAGE_BIT                                   7
#define EPT_PDE_2MB_LARGE_PAGE_FLAG                                  0x80
#define EPT_PDE_2MB_LARGE_PAGE_MASK                                  0x01
#define EPT_PDE_2MB_LARGE_PAGE(_)                                    (((_) >> 7) & 0x01)

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t accessed : 1;
#define EPT_PDE_2MB_ACCESSED_BIT                                     8
#define EPT_PDE_2MB_ACCESSED_FLAG                                    0x100
#define EPT_PDE_2MB_ACCESSED_MASK                                    0x01
#define EPT_PDE_2MB_ACCESSED(_)                                      (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 2-MByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t dirty : 1;
#define EPT_PDE_2MB_DIRTY_BIT                                        9
#define EPT_PDE_2MB_DIRTY_FLAG                                       0x200
#define EPT_PDE_2MB_DIRTY_MASK                                       0x01
#define EPT_PDE_2MB_DIRTY(_)                                         (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        uint64_t user_mode_execute : 1;
#define EPT_PDE_2MB_USER_MODE_EXECUTE_BIT                            10
#define EPT_PDE_2MB_USER_MODE_EXECUTE_FLAG                           0x400
#define EPT_PDE_2MB_USER_MODE_EXECUTE_MASK                           0x01
#define EPT_PDE_2MB_USER_MODE_EXECUTE(_)                             (((_) >> 10) & 0x01)
        uint64_t reserved1 : 10;

        /**
         * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
         */
        uint64_t page_frame_number : 27;
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_BIT                            21
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_FLAG                           0xFFFFFFE00000
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_MASK                           0x7FFFFFF
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER(_)                             (((_) >> 21) & 0x7FFFFFF)
        uint64_t reserved2 : 9;

        /**
         * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution control is 1, indicates limits on the
         * guest paging structures used to access the 2-MByte page controlled by this entry (see Section 28.3.3.2). If that control
         * is 0, this bit is ignored.
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t verify_guest_paging : 1;
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_BIT                          57
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_FLAG                         0x200000000000000
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_MASK                         0x01
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING(_)                           (((_) >> 57) & 0x01)

        /**
         * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution control is 1, indicates that guest paging
         * may update the 2-MByte page controlled by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t paging_write_access : 1;
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_BIT                          58
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_FLAG                         0x400000000000000
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_MASK                         0x01
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS(_)                           (((_) >> 58) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether supervisor shadow stack accesses are allowed
         * to guest-physical addresses in the 2-MByte page mapped by this entry (see Section 28.3.3.2)
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t supervisor_shadow_stack : 1;
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_BIT                      60
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_FLAG                     0x1000000000000000
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_MASK                     0x01
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK(_)                       (((_) >> 60) & 0x01)
        uint64_t reserved4 : 2;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        uint64_t suppress_ve : 1;
#define EPT_PDE_2MB_SUPPRESS_VE_BIT                                  63
#define EPT_PDE_2MB_SUPPRESS_VE_FLAG                                 0x8000000000000000
#define EPT_PDE_2MB_SUPPRESS_VE_MASK                                 0x01
#define EPT_PDE_2MB_SUPPRESS_VE(_)                                   (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ept_pde_2mb;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that References an EPT Page Table
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte region controlled by this entry.
         */
        uint64_t read_access : 1;
#define EPT_PDE_READ_ACCESS_BIT                                      0
#define EPT_PDE_READ_ACCESS_FLAG                                     0x01
#define EPT_PDE_READ_ACCESS_MASK                                     0x01
#define EPT_PDE_READ_ACCESS(_)                                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte region controlled by this entry.
         */
        uint64_t write_access : 1;
#define EPT_PDE_WRITE_ACCESS_BIT                                     1
#define EPT_PDE_WRITE_ACCESS_FLAG                                    0x02
#define EPT_PDE_WRITE_ACCESS_MASK                                    0x01
#define EPT_PDE_WRITE_ACCESS(_)                                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 2-MByte region controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 2-MByte region controlled by this entry.
         */
        uint64_t execute_access : 1;
#define EPT_PDE_EXECUTE_ACCESS_BIT                                   2
#define EPT_PDE_EXECUTE_ACCESS_FLAG                                  0x04
#define EPT_PDE_EXECUTE_ACCESS_MASK                                  0x01
#define EPT_PDE_EXECUTE_ACCESS(_)                                    (((_) >> 2) & 0x01)
        uint64_t reserved1 : 5;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte region
         * controlled by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t accessed : 1;
#define EPT_PDE_ACCESSED_BIT                                         8
#define EPT_PDE_ACCESSED_FLAG                                        0x100
#define EPT_PDE_ACCESSED_MASK                                        0x01
#define EPT_PDE_ACCESSED(_)                                          (((_) >> 8) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte region controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        uint64_t user_mode_execute : 1;
#define EPT_PDE_USER_MODE_EXECUTE_BIT                                10
#define EPT_PDE_USER_MODE_EXECUTE_FLAG                               0x400
#define EPT_PDE_USER_MODE_EXECUTE_MASK                               0x01
#define EPT_PDE_USER_MODE_EXECUTE(_)                                 (((_) >> 10) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define EPT_PDE_PAGE_FRAME_NUMBER_BIT                                12
#define EPT_PDE_PAGE_FRAME_NUMBER_FLAG                               0xFFFFFFFFF000
#define EPT_PDE_PAGE_FRAME_NUMBER_MASK                               0xFFFFFFFFF
#define EPT_PDE_PAGE_FRAME_NUMBER(_)                                 (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved4 : 16;
    };

    uint64_t flags;
} ept_pde;

/**
 * @brief Format of an EPT Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Read access; indicates whether reads are allowed from the 4-KByte page referenced by this entry.
         */
        uint64_t read_access : 1;
#define EPT_PTE_READ_ACCESS_BIT                                      0
#define EPT_PTE_READ_ACCESS_FLAG                                     0x01
#define EPT_PTE_READ_ACCESS_MASK                                     0x01
#define EPT_PTE_READ_ACCESS(_)                                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page referenced by this entry.
         */
        uint64_t write_access : 1;
#define EPT_PTE_WRITE_ACCESS_BIT                                     1
#define EPT_PTE_WRITE_ACCESS_FLAG                                    0x02
#define EPT_PTE_WRITE_ACCESS_MASK                                    0x01
#define EPT_PTE_WRITE_ACCESS(_)                                      (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
         * instruction fetches are allowed from the 4-KByte page controlled by this entry.
         * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
         * allowed from supervisor-mode linear addresses in the 4-KByte page controlled by this entry.
         */
        uint64_t execute_access : 1;
#define EPT_PTE_EXECUTE_ACCESS_BIT                                   2
#define EPT_PTE_EXECUTE_ACCESS_FLAG                                  0x04
#define EPT_PTE_EXECUTE_ACCESS_MASK                                  0x01
#define EPT_PTE_EXECUTE_ACCESS(_)                                    (((_) >> 2) & 0x01)

        /**
         * [Bits 5:3] EPT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t memory_type : 3;
#define EPT_PTE_MEMORY_TYPE_BIT                                      3
#define EPT_PTE_MEMORY_TYPE_FLAG                                     0x38
#define EPT_PTE_MEMORY_TYPE_MASK                                     0x07
#define EPT_PTE_MEMORY_TYPE(_)                                       (((_) >> 3) & 0x07)

        /**
         * [Bit 6] Ignore PAT memory type for this 4-KByte page.
         *
         * @see Vol3C[28.2.6(EPT and memory Typing)]
         */
        uint64_t ignore_pat : 1;
#define EPT_PTE_IGNORE_PAT_BIT                                       6
#define EPT_PTE_IGNORE_PAT_FLAG                                      0x40
#define EPT_PTE_IGNORE_PAT_MASK                                      0x01
#define EPT_PTE_IGNORE_PAT(_)                                        (((_) >> 6) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 4-KByte page
         * referenced by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t accessed : 1;
#define EPT_PTE_ACCESSED_BIT                                         8
#define EPT_PTE_ACCESSED_FLAG                                        0x100
#define EPT_PTE_ACCESSED_MASK                                        0x01
#define EPT_PTE_ACCESSED(_)                                          (((_) >> 8) & 0x01)

        /**
         * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 4-KByte page referenced
         * by this entry. Ignored if bit 6 of EPTP is 0.
         *
         * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
         */
        uint64_t dirty : 1;
#define EPT_PTE_DIRTY_BIT                                            9
#define EPT_PTE_DIRTY_FLAG                                           0x200
#define EPT_PTE_DIRTY_MASK                                           0x01
#define EPT_PTE_DIRTY(_)                                             (((_) >> 9) & 0x01)

        /**
         * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
         * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 4-KByte page controlled
         * by this entry. If that control is 0, this bit is ignored.
         */
        uint64_t user_mode_execute : 1;
#define EPT_PTE_USER_MODE_EXECUTE_BIT                                10
#define EPT_PTE_USER_MODE_EXECUTE_FLAG                               0x400
#define EPT_PTE_USER_MODE_EXECUTE_MASK                               0x01
#define EPT_PTE_USER_MODE_EXECUTE(_)                                 (((_) >> 10) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
         */
        uint64_t page_frame_number : 36;
#define EPT_PTE_PAGE_FRAME_NUMBER_BIT                                12
#define EPT_PTE_PAGE_FRAME_NUMBER_FLAG                               0xFFFFFFFFF000
#define EPT_PTE_PAGE_FRAME_NUMBER_MASK                               0xFFFFFFFFF
#define EPT_PTE_PAGE_FRAME_NUMBER(_)                                 (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved3 : 9;

        /**
         * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution control is 1, indicates limits on the
         * guest paging structures used to access the 4-KByte page controlled by this entry (see Section 28.3.3.2). If that control
         * is 0, this bit is ignored.
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t verify_guest_paging : 1;
#define EPT_PTE_VERIFY_GUEST_PAGING_BIT                              57
#define EPT_PTE_VERIFY_GUEST_PAGING_FLAG                             0x200000000000000
#define EPT_PTE_VERIFY_GUEST_PAGING_MASK                             0x01
#define EPT_PTE_VERIFY_GUEST_PAGING(_)                               (((_) >> 57) & 0x01)

        /**
         * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution control is 1, indicates that guest paging
         * may update the 4-KByte page controlled by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t paging_write_access : 1;
#define EPT_PTE_PAGING_WRITE_ACCESS_BIT                              58
#define EPT_PTE_PAGING_WRITE_ACCESS_FLAG                             0x400000000000000
#define EPT_PTE_PAGING_WRITE_ACCESS_MASK                             0x01
#define EPT_PTE_PAGING_WRITE_ACCESS(_)                               (((_) >> 58) & 0x01)
        uint64_t reserved4 : 1;

        /**
         * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether supervisor shadow stack accesses are allowed
         * to guest-physical addresses in the 4-KByte page mapped by this entry (see Section 28.3.3.2)
         *
         * @see Vol3C[28.3.3.2(EPT Violations)]
         */
        uint64_t supervisor_shadow_stack : 1;
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_BIT                          60
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_FLAG                         0x1000000000000000
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_MASK                         0x01
#define EPT_PTE_SUPERVISOR_SHADOW_STACK(_)                           (((_) >> 60) & 0x01)

        /**
         * [Bit 61] Sub-page write permissions. If the "sub-page write permissions for EPT" VM-execution control is 1, writes to
         * individual 128-byte regions of the 4-KByte page referenced by this entry may be allowed even if the page would normally
         * not be writable (see Section 28.3.4). If "sub-page write permissions for EPT" VM-execution control is 0, this bit is
         * ignored.
         *
         * @see Vol3C[28.3.4(Sub-Page Write Permissions)]
         */
        uint64_t sub_page_write_permissions : 1;
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_BIT                       61
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_FLAG                      0x2000000000000000
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_MASK                      0x01
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS(_)                        (((_) >> 61) & 0x01)
        uint64_t reserved5 : 1;

        /**
         * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
         * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
         * 0, this bit is ignored.
         *
         * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
         */
        uint64_t suppress_ve : 1;
#define EPT_PTE_SUPPRESS_VE_BIT                                      63
#define EPT_PTE_SUPPRESS_VE_FLAG                                     0x8000000000000000
#define EPT_PTE_SUPPRESS_VE_MASK                                     0x01
#define EPT_PTE_SUPPRESS_VE(_)                                       (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ept_pte;

/**
 * @brief Format of a common EPT Entry
 */
typedef union
{
    struct
    {
        uint64_t read_access : 1;
#define EPT_ENTRY_READ_ACCESS_BIT                                    0
#define EPT_ENTRY_READ_ACCESS_FLAG                                   0x01
#define EPT_ENTRY_READ_ACCESS_MASK                                   0x01
#define EPT_ENTRY_READ_ACCESS(_)                                     (((_) >> 0) & 0x01)
        uint64_t write_access : 1;
#define EPT_ENTRY_WRITE_ACCESS_BIT                                   1
#define EPT_ENTRY_WRITE_ACCESS_FLAG                                  0x02
#define EPT_ENTRY_WRITE_ACCESS_MASK                                  0x01
#define EPT_ENTRY_WRITE_ACCESS(_)                                    (((_) >> 1) & 0x01)
        uint64_t execute_access : 1;
#define EPT_ENTRY_EXECUTE_ACCESS_BIT                                 2
#define EPT_ENTRY_EXECUTE_ACCESS_FLAG                                0x04
#define EPT_ENTRY_EXECUTE_ACCESS_MASK                                0x01
#define EPT_ENTRY_EXECUTE_ACCESS(_)                                  (((_) >> 2) & 0x01)
        uint64_t memory_type : 3;
#define EPT_ENTRY_MEMORY_TYPE_BIT                                    3
#define EPT_ENTRY_MEMORY_TYPE_FLAG                                   0x38
#define EPT_ENTRY_MEMORY_TYPE_MASK                                   0x07
#define EPT_ENTRY_MEMORY_TYPE(_)                                     (((_) >> 3) & 0x07)
        uint64_t ignore_pat : 1;
#define EPT_ENTRY_IGNORE_PAT_BIT                                     6
#define EPT_ENTRY_IGNORE_PAT_FLAG                                    0x40
#define EPT_ENTRY_IGNORE_PAT_MASK                                    0x01
#define EPT_ENTRY_IGNORE_PAT(_)                                      (((_) >> 6) & 0x01)
        uint64_t large_page : 1;
#define EPT_ENTRY_LARGE_PAGE_BIT                                     7
#define EPT_ENTRY_LARGE_PAGE_FLAG                                    0x80
#define EPT_ENTRY_LARGE_PAGE_MASK                                    0x01
#define EPT_ENTRY_LARGE_PAGE(_)                                      (((_) >> 7) & 0x01)
        uint64_t accessed : 1;
#define EPT_ENTRY_ACCESSED_BIT                                       8
#define EPT_ENTRY_ACCESSED_FLAG                                      0x100
#define EPT_ENTRY_ACCESSED_MASK                                      0x01
#define EPT_ENTRY_ACCESSED(_)                                        (((_) >> 8) & 0x01)
        uint64_t dirty : 1;
#define EPT_ENTRY_DIRTY_BIT                                          9
#define EPT_ENTRY_DIRTY_FLAG                                         0x200
#define EPT_ENTRY_DIRTY_MASK                                         0x01
#define EPT_ENTRY_DIRTY(_)                                           (((_) >> 9) & 0x01)
        uint64_t user_mode_execute : 1;
#define EPT_ENTRY_USER_MODE_EXECUTE_BIT                              10
#define EPT_ENTRY_USER_MODE_EXECUTE_FLAG                             0x400
#define EPT_ENTRY_USER_MODE_EXECUTE_MASK                             0x01
#define EPT_ENTRY_USER_MODE_EXECUTE(_)                               (((_) >> 10) & 0x01)
        uint64_t reserved1 : 1;
        uint64_t page_frame_number : 36;
#define EPT_ENTRY_PAGE_FRAME_NUMBER_BIT                              12
#define EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG                             0xFFFFFFFFF000
#define EPT_ENTRY_PAGE_FRAME_NUMBER_MASK                             0xFFFFFFFFF
#define EPT_ENTRY_PAGE_FRAME_NUMBER(_)                               (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved2 : 15;
        uint64_t suppress_ve : 1;
#define EPT_ENTRY_SUPPRESS_VE_BIT                                    63
#define EPT_ENTRY_SUPPRESS_VE_FLAG                                   0x8000000000000000
#define EPT_ENTRY_SUPPRESS_VE_MASK                                   0x01
#define EPT_ENTRY_SUPPRESS_VE(_)                                     (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} ept_entry;

/**
 * @defgroup ept_table_level \
 *           EPT Table level numbers
 *
 * EPT Table level numbers.
 * @{
 */
#define EPT_LEVEL_PML4E                                              0x00000003
#define EPT_LEVEL_PDPTE                                              0x00000002
#define EPT_LEVEL_PDE                                                0x00000001
#define EPT_LEVEL_PTE                                                0x00000000
 /**
  * @}
  */

  /**
   * @defgroup ept_entry_count \
   *           EPT Entry counts
   *
   * EPT Entry counts.
   * @{
   */
#define EPT_PML4E_ENTRY_COUNT                                        0x00000200
#define EPT_PDPTE_ENTRY_COUNT                                        0x00000200
#define EPT_PDE_ENTRY_COUNT                                          0x00000200
#define EPT_PTE_ENTRY_COUNT                                          0x00000200
   /**
    * @}
    */

    /**
     * @}
     */

typedef enum
{
    /**
     * If the INVEPT type is 1, the logical processor invalidates all guest-physical mappings and combined mappings associated
     * with the EP4TA specified in the INVEPT descriptor. Combined mappings for that EP4TA are invalidated for all VPIDs and
     * all PCIDs. (The instruction may invalidate mappings associated with other EP4TAs.)
     */
    invept_single_context = 0x00000001,

    /**
     * If the INVEPT type is 2, the logical processor invalidates guest-physical mappings and combined mappings associated with
     * all EP4TAs (and, for combined mappings, for all VPIDs and PCIDs).
     */
    invept_all_context = 0x00000002,
} invept_type;

typedef enum
{
    /**
     * If the INVVPID type is 0, the logical processor invalidates linear mappings and combined mappings associated with the
     * VPID specified in the INVVPID descriptor and that would be used to translate the linear address specified in of the
     * INVVPID descriptor. Linear mappings and combined mappings for that VPID and linear address are invalidated for all PCIDs
     * and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other VPIDs and
     * for other linear addresses).
     */
    invvpid_individual_address = 0x00000000,

    /**
     * If the INVVPID type is 1, the logical processor invalidates all linear mappings and combined mappings associated with
     * the VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for
     * all PCIDs and, for combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated with other
     * VPIDs).
     */
    invvpid_single_context = 0x00000001,

    /**
     * If the INVVPID type is 2, the logical processor invalidates linear mappings and combined mappings associated with all
     * VPIDs except VPID 0000H and with all PCIDs. (The instruction may also invalidate linear mappings with VPID 0000H.)
     * Combined mappings are invalidated for all EP4TAs.
     */
    invvpid_all_context = 0x00000002,

    /**
     * If the INVVPID type is 3, the logical processor invalidates linear mappings and combined mappings associated with the
     * VPID specified in the INVVPID descriptor. Linear mappings and combined mappings for that VPID are invalidated for all
     * PCIDs and, for combined mappings, all EP4TAs. The logical processor is not required to invalidate information that was
     * used for global translations (although it may do so). (The instruction may also invalidate mappings associated with
     * other VPIDs).
     *
     * @see Vol3C[4.10(Caching Translation Information)]
     */
    invvpid_single_context_retaining_globals = 0x00000003,
} invvpid_type;

typedef struct
{
    uint64_t ept_pointer;

    /**
     * Must be zero.
     */
    uint64_t reserved;
} invept_descriptor;

typedef struct
{
    uint16_t vpid;

    /**
     * Must be zero.
     */
    uint16_t reserved1;

    /**
     * Must be zero.
     */
    uint32_t reserved2;
    uint64_t linear_address;
} invvpid_descriptor;

/**
 * @brief Hypervisor-Managed linear-Address Translation Pointer (HLATP)
 *
 * The hypervisor-managed linear-address translation pointer (HLAT pointer or HLATP) is used by HLAT paging to locate and
 * access the first paging structure used for linear-address translation.
 *
 * @see Vol3A[4.5(4-LEVEL PAGING AND 5-LEVEL PAGING)]
 */
typedef union
{
    struct
    {
        uint64_t reserved1 : 3;

        /**
         * [Bit 3] Page-level write-through; indirectly determines the memory type used to access the first HLAT paging structure
         * during linear-address translation.
         */
        uint64_t page_level_write_through : 1;
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_BIT                    3
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_FLAG                   0x08
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_MASK                   0x01
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH(_)                     (((_) >> 3) & 0x01)

        /**
         * [Bit 4] Page-level cache disable; indirectly determines the memory type used to access the first HLAT paging structure
         * during linear-address translation.
         */
        uint64_t page_level_cache_disable : 1;
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_BIT                    4
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_FLAG                   0x10
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_MASK                   0x01
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE(_)                     (((_) >> 4) & 0x01)
        uint64_t reserved2 : 7;

        /**
         * [Bits 47:12] Guest-physical address (4KB-aligned) of the first HLAT paging structure during linear-address translation)
         */
        uint64_t page_frame_number : 36;
#define HLAT_POINTER_PAGE_FRAME_NUMBER_BIT                           12
#define HLAT_POINTER_PAGE_FRAME_NUMBER_FLAG                          0xFFFFFFFFF000
#define HLAT_POINTER_PAGE_FRAME_NUMBER_MASK                          0xFFFFFFFFF
#define HLAT_POINTER_PAGE_FRAME_NUMBER(_)                            (((_) >> 12) & 0xFFFFFFFFF)
        uint64_t reserved3 : 16;
    };

    uint64_t flags;
} hlat_pointer;

/**
 * @brief Format of the VMCS Region
 *
 * A logical processor uses virtual-machine control data structures (VMCSs) while it is in VMX operation. These manage
 * transitions into and out of VMX non-root operation (VM entries and VM exits) as well as processor behavior in VMX
 * non-root operation. This structure is manipulated by the new instructions VMCLEAR, VMPTRLD, VMREAD, and VMWRITE.
 * A VMCS region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Processors that maintain VMCS data in different formats (see below) use different VMCS revision identifiers.
         * These identifiers enable software to avoid using a VMCS region formatted for one processor on a processor that uses a
         * different format.
         * Software should write the VMCS revision identifier to the VMCS region before using that region for a VMCS. The VMCS
         * revision identifier is never written by the processor; VMPTRLD fails if its operand references a VMCS region whose VMCS
         * revision identifier differs from that used by the processor.
         * Software can discover the VMCS revision identifier that a processor uses by reading the VMX capability MSR
         * IA32_VMX_BASIC.
         *
         * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         */
        uint32_t revision_id : 31;

        /**
         * @brief Shadow-VMCS indicator
         *
         * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on whether the VMCS is to be an ordinary VMCS
         * or a shadow VMCS. VMPTRLD fails if the shadow-VMCS indicator is set and the processor does not support the 1-setting of
         * the "VMCS shadowing" VM-execution control. Software can discover support for this setting by reading the VMX capability
         * MSR IA32_VMX_PROCBASED_CTLS2.
         *
         * @see Vol3C[24.10(VMCS TYPES ORDINARY AND SHADOW)]
         */
        uint32_t shadow_vmcs_indicator : 1;
    };


    /**
     * @brief VMX-abort indicator
     *
     * The contents of these bits do not control processor operation in any way. A logical processor writes a non-zero value
     * into these bits if a VMX abort occurs. Software may also write into this field.
     *
     * @see Vol3D[27.7(VMX Aborts)]
     */
    uint32_t abort_indicator;

    /**
     * @brief VMCS data (implementation-specific format)
     *
     * These parts of the VMCS control VMX non-root operation and the VMX transitions.
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should
     * maintain the VMCS region and related structures in writeback cacheable memory. Future implementations may allow or
     * require a different memory type. Software should consult the VMX capability MSR IA32_VMX_BASIC.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    uint8_t data[4088];
} vmcs;

/**
 * @brief Format of the VMXON Region
 *
 * Before executing VMXON, software allocates a region of memory that the logical processor uses to support VMX operation.
 * This region is called the VMXON region.
 * A VMXON region comprises up to 4-KBytes. The exact size is implementation specific and can be determined by consulting
 * the VMX capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.11.5(VMXON Region)] (reference)
 */
typedef struct
{
    struct
    {
        /**
         * @brief VMCS revision identifier
         *
         * [Bits 30:0] Before executing VMXON, software should write the VMCS revision identifier to the VMXON region.
         * (Specifically, it should write the 31-bit VMCS revision identifier to bits 30:0 of the first 4 bytes of the VMXON
         * region; bit 31 should be cleared to 0.)
         *
         * @see VMCS
         * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)]
         * @see Vol3C[24.11.5(VMXON Region)]
         */
        uint32_t revision_id : 31;

        /**
         * [Bit 31] Bit 31 is always 0.
         */
        uint32_t must_be_zero : 1;
    };


    /**
     * @brief VMXON data (implementation-specific format)
     *
     * The format of these data is implementation-specific. To ensure proper behavior in VMX operation, software should not
     * access or modify the VMXON region of a logical processor between execution of VMXON and VMXOFF on that logical
     * processor. Doing otherwise may lead to unpredictable behavior.
     *
     * @see Vol3C[24.11.4(Software Access to Related Structures)]
     * @see Vol3D[A.1(BASIC VMX INFORMATION)]
     */
    uint8_t data[4092];
} vmxon;

/**
 * @defgroup vmcs_fields \
 *           VMCS (VM Control Structure)
 *
 * Every component of the VMCS is encoded by a 32-bit field that can be used by VMREAD and VMWRITE. This enumerates all
 * fields in the VMCS and their encodings. Fields are grouped by width (16-bit, 32-bit, etc.) and type (guest-state,
 * host-state, etc.).
 *
 * @see Vol3D[B(APPENDIX B FIELD ENCODING IN VMCS)] (reference)
 * @{
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] Access type (0 = full; 1 = high); must be full for 16-bit, 32-bit, and natural-width fields.
         */
        uint16_t access_type : 1;
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT                      0
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK                     0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bits 9:1] Index.
         */
        uint16_t index : 9;
#define VMCS_COMPONENT_ENCODING_INDEX_BIT                            1
#define VMCS_COMPONENT_ENCODING_INDEX_FLAG                           0x3FE
#define VMCS_COMPONENT_ENCODING_INDEX_MASK                           0x1FF
#define VMCS_COMPONENT_ENCODING_INDEX(_)                             (((_) >> 1) & 0x1FF)

        /**
         * [Bits 11:10] Type:
         * 0: control
         * 1: VM-exit information
         * 2: guest state
         * 3: host state
         */
        uint16_t type : 2;
#define VMCS_COMPONENT_ENCODING_TYPE_BIT                             10
#define VMCS_COMPONENT_ENCODING_TYPE_FLAG                            0xC00
#define VMCS_COMPONENT_ENCODING_TYPE_MASK                            0x03
#define VMCS_COMPONENT_ENCODING_TYPE(_)                              (((_) >> 10) & 0x03)

        /**
         * [Bit 12] Reserved (must be 0).
         */
        uint16_t must_be_zero : 1;
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT                     12
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG                    0x1000
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK                    0x01
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_)                      (((_) >> 12) & 0x01)

        /**
         * [Bits 14:13] Width:
         * 0: 16-bit
         * 1: 64-bit
         * 2: 32-bit
         * 3: natural-width
         */
        uint16_t width : 2;
#define VMCS_COMPONENT_ENCODING_WIDTH_BIT                            13
#define VMCS_COMPONENT_ENCODING_WIDTH_FLAG                           0x6000
#define VMCS_COMPONENT_ENCODING_WIDTH_MASK                           0x03
#define VMCS_COMPONENT_ENCODING_WIDTH(_)                             (((_) >> 13) & 0x03)
        uint16_t reserved1 : 1;
    };

    uint16_t flags;
} vmcs_component_encoding;

/**
 * @defgroup vmcs_16_bit \
 *           16-Bit Fields
 *
 * 16-Bit Fields.
 *
 * @see Vol3D[B.1(16-BIT FIELDS)] (reference)
 * @{
 */
 /**
  * @defgroup vmcs_16_bit_control_fields \
  *           16-Bit Control Fields
  *
  * 16-Bit Control Fields.
  * @{
  */
  /**
   * Virtual-processor identifier (VPID).
   *
   * @remarks This field exists only on processors that support the 1-setting of the "enable VPID" VM-execution control.
   */
#define VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER                       0x00000000

   /**
    * Posted-interrupt notification vector.
    *
    * @remarks This field exists only on processors that support the 1-setting of the "process posted interrupts" VM-execution
    *          control.
    */
#define VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR               0x00000002

    /**
     * EPTP index.
     *
     * @remarks This field exists only on processors that support the 1-setting of the "EPT-violation \#VE" VM-execution
     *          control.
     */
#define VMCS_CTRL_EPTP_INDEX                                         0x00000004

     /**
      * HLAT prefix size.
      *
      * @remarks This field exists only on processors that support the 1-setting of the "enable HLAT" VM-execution control.
      */
#define VMCS_CTRL_HLAT_PREFIX_SIZE                                   0x00000006

      /**
       * Last PID-pointer index.
       *
       * @remarks This field exists only on processors that support the 1-setting of the "IPI virtualization" VM-execution
       *          control
       */
#define VMCS_CTRL_LAST_PID_POINTER_INDEX                             0x00000008
       /**
        * @}
        */

        /**
         * @defgroup vmcs_16_bit_guest_state_fields \
         *           16-Bit Guest-State Fields
         *
         * 16-Bit Guest-State Fields.
         * @{
         */
         /**
          * Guest ES selector.
          */
#define VMCS_GUEST_ES_SELECTOR                                       0x00000800

          /**
           * Guest CS selector.
           */
#define VMCS_GUEST_CS_SELECTOR                                       0x00000802

           /**
            * Guest SS selector.
            */
#define VMCS_GUEST_SS_SELECTOR                                       0x00000804

            /**
             * Guest DS selector.
             */
#define VMCS_GUEST_DS_SELECTOR                                       0x00000806

             /**
              * Guest FS selector.
              */
#define VMCS_GUEST_FS_SELECTOR                                       0x00000808

              /**
               * Guest GS selector.
               */
#define VMCS_GUEST_GS_SELECTOR                                       0x0000080A

               /**
                * Guest LDTR selector.
                */
#define VMCS_GUEST_LDTR_SELECTOR                                     0x0000080C

                /**
                 * Guest TR selector.
                 */
#define VMCS_GUEST_TR_SELECTOR                                       0x0000080E

                 /**
                  * Guest interrupt status.
                  *
                  * @remarks This field exists only on processors that support the 1-setting of the "virtual-interrupt delivery"
                  *          VM-execution control.
                  */
#define VMCS_GUEST_INTERRUPT_STATUS                                  0x00000810

                  /**
                   * PML index.
                   *
                   * @remarks This field exists only on processors that support the 1-setting of the "enable PML" VM-execution control.
                   */
#define VMCS_GUEST_PML_INDEX                                         0x00000812

                   /**
                    * UINV.
                    *
                    * @remarks This field exists only on processors that support the 1-setting of either the "clear UINV" VM-exit control or
                    *          the "load UINV" VM-entry control.
                    */
#define VMCS_GUEST_UINV                                              0x00000814
                    /**
                     * @}
                     */

                     /**
                      * @defgroup vmcs_16_bit_host_state_fields \
                      *           16-Bit Host-State Fields
                      *
                      * 16-Bit Host-State Fields.
                      * @{
                      */
                      /**
                       * Host ES selector.
                       */
#define VMCS_HOST_ES_SELECTOR                                        0x00000C00

                       /**
                        * Host CS selector.
                        */
#define VMCS_HOST_CS_SELECTOR                                        0x00000C02

                        /**
                         * Host SS selector.
                         */
#define VMCS_HOST_SS_SELECTOR                                        0x00000C04

                         /**
                          * Host DS selector.
                          */
#define VMCS_HOST_DS_SELECTOR                                        0x00000C06

                          /**
                           * Host FS selector.
                           */
#define VMCS_HOST_FS_SELECTOR                                        0x00000C08

                           /**
                            * Host GS selector.
                            */
#define VMCS_HOST_GS_SELECTOR                                        0x00000C0A

                            /**
                             * Host TR selector.
                             */
#define VMCS_HOST_TR_SELECTOR                                        0x00000C0C
                             /**
                              * @}
                              */

                              /**
                               * @}
                               */

                               /**
                                * @defgroup vmcs_64_bit \
                                *           64-Bit Fields
                                *
                                * 64-Bit Fields.
                                *
                                * @see Vol3D[B.2(64-BIT FIELDS)] (reference)
                                * @{
                                */
                                /**
                                 * @defgroup vmcs_64_bit_control_fields \
                                 *           64-Bit Control Fields
                                 *
                                 * 64-Bit Control Fields.
                                 * @{
                                 */
                                 /**
                                  * Address of I/O bitmap A.
                                  */
#define VMCS_CTRL_IO_BITMAP_A_ADDRESS                                0x00002000

                                  /**
                                   * Address of I/O bitmap B.
                                   */
#define VMCS_CTRL_IO_BITMAP_B_ADDRESS                                0x00002002

                                   /**
                                    * Address of MSR bitmaps.
                                    */
#define VMCS_CTRL_MSR_BITMAP_ADDRESS                                 0x00002004

                                    /**
                                     * VM-exit MSR-store address.
                                     */
#define VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS                           0x00002006

                                     /**
                                      * VM-exit MSR-load address.
                                      */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS                            0x00002008

                                      /**
                                       * VM-entry MSR-load address.
                                       */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS                           0x0000200A

                                       /**
                                        * Executive-VMCS pointer.
                                        */
#define VMCS_CTRL_EXECUTIVE_VMCS_POINTER                             0x0000200C

                                        /**
                                         * PML address.
                                         */
#define VMCS_CTRL_PML_ADDRESS                                        0x0000200E

                                         /**
                                          * TSC offset.
                                          */
#define VMCS_CTRL_TSC_OFFSET                                         0x00002010

                                          /**
                                           * Virtual-APIC address.
                                           */
#define VMCS_CTRL_VIRTUAL_APIC_ADDRESS                               0x00002012

                                           /**
                                            * APIC-access address.
                                            */
#define VMCS_CTRL_APIC_ACCESS_ADDRESS                                0x00002014

                                            /**
                                             * Posted-interrupt descriptor address
                                             */
#define VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS                0x00002016

                                             /**
                                              * VM-function controls.
                                              */
#define VMCS_CTRL_VMFUNC_CONTROLS                                    0x00002018

                                              /**
                                               * EPT pointer.
                                               */
#define VMCS_CTRL_EPT_POINTER                                        0x0000201A

                                               /**
                                                * EOI-exit bitmap 0.
                                                */
#define VMCS_CTRL_EOI_EXIT_BITMAP_0                                  0x0000201C

                                                /**
                                                 * EOI-exit bitmap 1.
                                                 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_1                                  0x0000201E

                                                 /**
                                                  * EOI-exit bitmap 2.
                                                  */
#define VMCS_CTRL_EOI_EXIT_BITMAP_2                                  0x00002020

                                                  /**
                                                   * EOI-exit bitmap 3.
                                                   */
#define VMCS_CTRL_EOI_EXIT_BITMAP_3                                  0x00002022

                                                   /**
                                                    * EPTP-list address.
                                                    */
#define VMCS_CTRL_EPT_POINTER_LIST_ADDRESS                           0x00002024

                                                    /**
                                                     * VMREAD-bitmap address.
                                                     */
#define VMCS_CTRL_VMREAD_BITMAP_ADDRESS                              0x00002026

                                                     /**
                                                      * VMWRITE-bitmap address.
                                                      */
#define VMCS_CTRL_VMWRITE_BITMAP_ADDRESS                             0x00002028

                                                      /**
                                                       * Virtualization-exception information address.
                                                       */
#define VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS       0x0000202A

                                                       /**
                                                        * XSS-exiting bitmap.
                                                        */
#define VMCS_CTRL_XSS_EXITING_BITMAP                                 0x0000202C

                                                        /**
                                                         * ENCLS-exiting bitmap.
                                                         */
#define VMCS_CTRL_ENCLS_EXITING_BITMAP                               0x0000202E

                                                         /**
                                                          * Sub-page-permission-table pointer.
                                                          */
#define VMCS_CTRL_SUB_PAGE_PERMISSION_TABLE_POINTER                  0x00002030

                                                          /**
                                                           * TSC multiplier.
                                                           */
#define VMCS_CTRL_TSC_MULTIPLIER                                     0x00002032

                                                           /**
                                                            * Tertiary processor-based VM-execution controls.
                                                            */
#define VMCS_CTRL_TERTIARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS     0x00002034

                                                            /**
                                                             * ENCLV-exiting bitmap.
                                                             */
#define VMCS_CTRL_ENCLV_EXITING_BITMAP                               0x00002036

                                                             /**
                                                              * Low PASID directory address.
                                                              */
#define VMCS_CTRL_LOW_PASID_DIRECTORY_ADDRESS                        0x00002038

                                                              /**
                                                               * High PASID directory address.
                                                               */
#define VMCS_CTRL_HIGH_PASID_DIRECTORY_ADDRESS                       0x0000203A

                                                               /**
                                                                * Shared EPT pointer.
                                                                */
#define VMCS_CTRL_SHARED_EPT_POINTER                                 0x0000203C

                                                                /**
                                                                 * PCONFIG-exiting bitmap.
                                                                 */
#define VMCS_CTRL_PCONFIG_EXITING_BITMAP                             0x0000203E

                                                                 /**
                                                                  * Hypervisor-managed linear-address translation pointer.
                                                                  */
#define VMCS_CTRL_HLAT_POINTER                                       0x00002040

                                                                  /**
                                                                   * PID-pointer table address.
                                                                   */
#define VMCS_CTRL_PID_POINTER_TABLE_ADDRESS                          0x00002042

                                                                   /**
                                                                    * Secondary VM-exit controls.
                                                                    */
#define VMCS_CTRL_SECONDARY_VMEXIT_CONTROLS                          0x00002044

                                                                    /**
                                                                     * IA32_SPEC_CTRL mask.
                                                                     */
#define VMCS_CTRL_IA32_SPEC_CTRL_MASK                                0x0000204A

                                                                     /**
                                                                      * IA32_SPEC_CTRL shadow.
                                                                      */
#define VMCS_CTRL_IA32_SPEC_CTRL_SHADOW                              0x0000204C
                                                                      /**
                                                                       * @}
                                                                       */

                                                                       /**
                                                                        * @defgroup vmcs_64_bit_read_only_data_fields \
                                                                        *           64-Bit Read-Only Data Field
                                                                        *
                                                                        * 64-Bit Read-Only Data Field.
                                                                        * @{
                                                                        */
                                                                        /**
                                                                         * Guest-physical address.
                                                                         */
#define VMCS_GUEST_PHYSICAL_ADDRESS                                  0x00002400
                                                                         /**
                                                                          * @}
                                                                          */

                                                                          /**
                                                                           * @defgroup vmcs_64_bit_guest_state_fields \
                                                                           *           64-Bit Guest-State Fields
                                                                           *
                                                                           * 64-Bit Guest-State Fields.
                                                                           * @{
                                                                           */
                                                                           /**
                                                                            * VMCS link pointer.
                                                                            */
#define VMCS_GUEST_VMCS_LINK_POINTER                                 0x00002800

                                                                            /**
                                                                             * Guest IA32_DEBUGCTL.
                                                                             */
#define VMCS_GUEST_DEBUGCTL                                          0x00002802

                                                                             /**
                                                                              * Guest IA32_PAT.
                                                                              */
#define VMCS_GUEST_PAT                                               0x00002804

                                                                              /**
                                                                               * Guest IA32_EFER.
                                                                               */
#define VMCS_GUEST_EFER                                              0x00002806

                                                                               /**
                                                                                * Guest IA32_PERF_GLOBAL_CTRL.
                                                                                */
#define VMCS_GUEST_PERF_GLOBAL_CTRL                                  0x00002808

                                                                                /**
                                                                                 * Guest PDPTE0.
                                                                                 */
#define VMCS_GUEST_PDPTE0                                            0x0000280A

                                                                                 /**
                                                                                  * Guest PDPTE1.
                                                                                  */
#define VMCS_GUEST_PDPTE1                                            0x0000280C

                                                                                  /**
                                                                                   * Guest PDPTE2.
                                                                                   */
#define VMCS_GUEST_PDPTE2                                            0x0000280E

                                                                                   /**
                                                                                    * Guest PDPTE3.
                                                                                    */
#define VMCS_GUEST_PDPTE3                                            0x00002810

                                                                                    /**
                                                                                     * Guest IA32_BNDCFGS.
                                                                                     */
#define VMCS_GUEST_BNDCFGS                                           0x00002812

                                                                                     /**
                                                                                      * Guest IA32_RTIT_CTL.
                                                                                      */
#define VMCS_GUEST_RTIT_CTL                                          0x00002814

                                                                                      /**
                                                                                       * Guest IA32_LBR_CTL.
                                                                                       */
#define VMCS_GUEST_LBR_CTL                                           0x00002816

                                                                                       /**
                                                                                        * Guest IA32_PKRS
                                                                                        */
#define VMCS_GUEST_PKRS                                              0x00002818
                                                                                        /**
                                                                                         * @}
                                                                                         */

                                                                                         /**
                                                                                          * @defgroup vmcs_64_bit_host_state_fields \
                                                                                          *           64-Bit Host-State Fields
                                                                                          *
                                                                                          * 64-Bit Host-State Fields.
                                                                                          * @{
                                                                                          */
                                                                                          /**
                                                                                           * Host IA32_PAT.
                                                                                           */
#define VMCS_HOST_PAT                                                0x00002C00

                                                                                           /**
                                                                                            * Host IA32_EFER.
                                                                                            */
#define VMCS_HOST_EFER                                               0x00002C02

                                                                                            /**
                                                                                             * Host IA32_PERF_GLOBAL_CTRL.
                                                                                             */
#define VMCS_HOST_PERF_GLOBAL_CTRL                                   0x00002C04

                                                                                             /**
                                                                                              * Host IA32_PKRS
                                                                                              */
#define VMCS_HOST_PKRS                                               0x00002C06
                                                                                              /**
                                                                                               * @}
                                                                                               */

                                                                                               /**
                                                                                                * @}
                                                                                                */

                                                                                                /**
                                                                                                 * @defgroup vmcs_32_bit \
                                                                                                 *           32-Bit Fields
                                                                                                 *
                                                                                                 * 32-Bit Fields.
                                                                                                 *
                                                                                                 * @see Vol3D[B.3(32-BIT FIELDS)] (reference)
                                                                                                 * @{
                                                                                                 */
                                                                                                 /**
                                                                                                  * @defgroup vmcs_32_bit_control_fields \
                                                                                                  *           32-Bit Control Fields
                                                                                                  *
                                                                                                  * 32-Bit Control Fields.
                                                                                                  * @{
                                                                                                  */
                                                                                                  /**
                                                                                                   * Pin-based VM-execution controls.
                                                                                                   */
#define VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS                    0x00004000

                                                                                                   /**
                                                                                                    * Primary processor-based VM-execution controls.
                                                                                                    */
#define VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS              0x00004002

                                                                                                    /**
                                                                                                     * Exception bitmap.
                                                                                                     */
#define VMCS_CTRL_EXCEPTION_BITMAP                                   0x00004004

                                                                                                     /**
                                                                                                      * Page-fault error-code mask.
                                                                                                      */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK                          0x00004006

                                                                                                      /**
                                                                                                       * Page-fault error-code match.
                                                                                                       */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH                         0x00004008

                                                                                                       /**
                                                                                                        * CR3-target count.
                                                                                                        */
#define VMCS_CTRL_CR3_TARGET_COUNT                                   0x0000400A

                                                                                                        /**
                                                                                                         * Primary VM-exit controls.
                                                                                                         */
#define VMCS_CTRL_PRIMARY_VMEXIT_CONTROLS                            0x0000400C

                                                                                                         /**
                                                                                                          * VM-exit MSR-store count.
                                                                                                          */
#define VMCS_CTRL_VMEXIT_MSR_STORE_COUNT                             0x0000400E

                                                                                                          /**
                                                                                                           * VM-exit MSR-load count.
                                                                                                           */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT                              0x00004010

                                                                                                           /**
                                                                                                            * VM-entry controls.
                                                                                                            */
#define VMCS_CTRL_VMENTRY_CONTROLS                                   0x00004012

                                                                                                            /**
                                                                                                             * VM-entry MSR-load count.
                                                                                                             */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT                             0x00004014

                                                                                                             /**
                                                                                                              * VM-entry interruption-information field.
                                                                                                              */
#define VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD             0x00004016

                                                                                                              /**
                                                                                                               * VM-entry exception error code.
                                                                                                               */
#define VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE                       0x00004018

                                                                                                               /**
                                                                                                                * VM-entry instruction length.
                                                                                                                */
#define VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH                         0x0000401A

                                                                                                                /**
                                                                                                                 * TPR threshold.
                                                                                                                 */
#define VMCS_CTRL_TPR_THRESHOLD                                      0x0000401C

                                                                                                                 /**
                                                                                                                  * Secondary processor-based VM-execution controls.
                                                                                                                  */
#define VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS    0x0000401E

                                                                                                                  /**
                                                                                                                   * PLE_Gap.
                                                                                                                   */
#define VMCS_CTRL_PLE_GAP                                            0x00004020

                                                                                                                   /**
                                                                                                                    * PLE_Window.
                                                                                                                    */
#define VMCS_CTRL_PLE_WINDOW                                         0x00004022
                                                                                                                    /**
                                                                                                                     * @}
                                                                                                                     */

                                                                                                                     /**
                                                                                                                      * @defgroup vmcs_32_bit_read_only_data_fields \
                                                                                                                      *           32-Bit Read-Only Data Fields
                                                                                                                      *
                                                                                                                      * 32-Bit Read-Only Data Fields.
                                                                                                                      * @{
                                                                                                                      */
                                                                                                                      /**
                                                                                                                       * VM-instruction error.
                                                                                                                       */
#define VMCS_VM_INSTRUCTION_ERROR                                    0x00004400

                                                                                                                       /**
                                                                                                                        * Exit reason.
                                                                                                                        */
#define VMCS_EXIT_REASON                                             0x00004402

                                                                                                                        /**
                                                                                                                         * VM-exit interruption information.
                                                                                                                         */
#define VMCS_VMEXIT_INTERRUPTION_INFORMATION                         0x00004404

                                                                                                                         /**
                                                                                                                          * VM-exit interruption error code.
                                                                                                                          */
#define VMCS_VMEXIT_INTERRUPTION_ERROR_CODE                          0x00004406

                                                                                                                          /**
                                                                                                                           * IDT-vectoring information field.
                                                                                                                           */
#define VMCS_IDT_VECTORING_INFORMATION                               0x00004408

                                                                                                                           /**
                                                                                                                            * IDT-vectoring error code.
                                                                                                                            */
#define VMCS_IDT_VECTORING_ERROR_CODE                                0x0000440A

                                                                                                                            /**
                                                                                                                             * VM-exit instruction length.
                                                                                                                             */
#define VMCS_VMEXIT_INSTRUCTION_LENGTH                               0x0000440C

                                                                                                                             /**
                                                                                                                              * VM-exit instruction information.
                                                                                                                              */
#define VMCS_VMEXIT_INSTRUCTION_INFO                                 0x0000440E
                                                                                                                              /**
                                                                                                                               * @}
                                                                                                                               */

                                                                                                                               /**
                                                                                                                                * @defgroup vmcs_32_bit_guest_state_fields \
                                                                                                                                *           32-Bit Guest-State Fields
                                                                                                                                *
                                                                                                                                * 32-Bit Guest-State Fields.
                                                                                                                                * @{
                                                                                                                                */
                                                                                                                                /**
                                                                                                                                 * Guest ES limit.
                                                                                                                                 */
#define VMCS_GUEST_ES_LIMIT                                          0x00004800

                                                                                                                                 /**
                                                                                                                                  * Guest CS limit.
                                                                                                                                  */
#define VMCS_GUEST_CS_LIMIT                                          0x00004802

                                                                                                                                  /**
                                                                                                                                   * Guest SS limit.
                                                                                                                                   */
#define VMCS_GUEST_SS_LIMIT                                          0x00004804

                                                                                                                                   /**
                                                                                                                                    * Guest DS limit.
                                                                                                                                    */
#define VMCS_GUEST_DS_LIMIT                                          0x00004806

                                                                                                                                    /**
                                                                                                                                     * Guest FS limit.
                                                                                                                                     */
#define VMCS_GUEST_FS_LIMIT                                          0x00004808

                                                                                                                                     /**
                                                                                                                                      * Guest GS limit.
                                                                                                                                      */
#define VMCS_GUEST_GS_LIMIT                                          0x0000480A

                                                                                                                                      /**
                                                                                                                                       * Guest LDTR limit.
                                                                                                                                       */
#define VMCS_GUEST_LDTR_LIMIT                                        0x0000480C

                                                                                                                                       /**
                                                                                                                                        * Guest TR limit.
                                                                                                                                        */
#define VMCS_GUEST_TR_LIMIT                                          0x0000480E

                                                                                                                                        /**
                                                                                                                                         * Guest GDTR limit.
                                                                                                                                         */
#define VMCS_GUEST_GDTR_LIMIT                                        0x00004810

                                                                                                                                         /**
                                                                                                                                          * Guest IDTR limit.
                                                                                                                                          */
#define VMCS_GUEST_IDTR_LIMIT                                        0x00004812

                                                                                                                                          /**
                                                                                                                                           * Guest ES access rights.
                                                                                                                                           */
#define VMCS_GUEST_ES_ACCESS_RIGHTS                                  0x00004814

                                                                                                                                           /**
                                                                                                                                            * Guest CS access rights.
                                                                                                                                            */
#define VMCS_GUEST_CS_ACCESS_RIGHTS                                  0x00004816

                                                                                                                                            /**
                                                                                                                                             * Guest SS access rights.
                                                                                                                                             */
#define VMCS_GUEST_SS_ACCESS_RIGHTS                                  0x00004818

                                                                                                                                             /**
                                                                                                                                              * Guest DS access rights.
                                                                                                                                              */
#define VMCS_GUEST_DS_ACCESS_RIGHTS                                  0x0000481A

                                                                                                                                              /**
                                                                                                                                               * Guest FS access rights.
                                                                                                                                               */
#define VMCS_GUEST_FS_ACCESS_RIGHTS                                  0x0000481C

                                                                                                                                               /**
                                                                                                                                                * Guest GS access rights.
                                                                                                                                                */
#define VMCS_GUEST_GS_ACCESS_RIGHTS                                  0x0000481E

                                                                                                                                                /**
                                                                                                                                                 * Guest LDTR access rights.
                                                                                                                                                 */
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                                0x00004820

                                                                                                                                                 /**
                                                                                                                                                  * Guest TR access rights.
                                                                                                                                                  */
#define VMCS_GUEST_TR_ACCESS_RIGHTS                                  0x00004822

                                                                                                                                                  /**
                                                                                                                                                   * Guest interruptibility state.
                                                                                                                                                   */
#define VMCS_GUEST_INTERRUPTIBILITY_STATE                            0x00004824

                                                                                                                                                   /**
                                                                                                                                                    * Guest activity state.
                                                                                                                                                    */
#define VMCS_GUEST_ACTIVITY_STATE                                    0x00004826

                                                                                                                                                    /**
                                                                                                                                                     * Guest SMBASE.
                                                                                                                                                     */
#define VMCS_GUEST_SMBASE                                            0x00004828

                                                                                                                                                     /**
                                                                                                                                                      * Guest IA32_SYSENTER_CS.
                                                                                                                                                      */
#define VMCS_GUEST_SYSENTER_CS                                       0x0000482A

                                                                                                                                                      /**
                                                                                                                                                       * VMX-preemption timer value.
                                                                                                                                                       */
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE                        0x0000482E
                                                                                                                                                       /**
                                                                                                                                                        * @}
                                                                                                                                                        */

                                                                                                                                                        /**
                                                                                                                                                         * @defgroup vmcs_32_bit_host_state_fields \
                                                                                                                                                         *           32-Bit Host-State Field
                                                                                                                                                         *
                                                                                                                                                         * 32-Bit Host-State Field.
                                                                                                                                                         * @{
                                                                                                                                                         */
                                                                                                                                                         /**
                                                                                                                                                          * Host IA32_SYSENTER_CS.
                                                                                                                                                          */
#define VMCS_HOST_SYSENTER_CS                                        0x00004C00
                                                                                                                                                          /**
                                                                                                                                                           * @}
                                                                                                                                                           */

                                                                                                                                                           /**
                                                                                                                                                            * @}
                                                                                                                                                            */

                                                                                                                                                            /**
                                                                                                                                                             * @defgroup vmcs_natural_width \
                                                                                                                                                             *           Natural-Width Fields
                                                                                                                                                             *
                                                                                                                                                             * Natural-Width Fields.
                                                                                                                                                             *
                                                                                                                                                             * @see Vol3D[B.4(NATURAL-WIDTH FIELDS)] (reference)
                                                                                                                                                             * @{
                                                                                                                                                             */
                                                                                                                                                             /**
                                                                                                                                                              * @defgroup vmcs_natural_width_control_fields \
                                                                                                                                                              *           Natural-Width Control Fields
                                                                                                                                                              *
                                                                                                                                                              * Natural-Width Control Fields
                                                                                                                                                              * @{
                                                                                                                                                              */
                                                                                                                                                              /**
                                                                                                                                                               * CR0 guest/host mask.
                                                                                                                                                               */
#define VMCS_CTRL_CR0_GUEST_HOST_MASK                                0x00006000

                                                                                                                                                               /**
                                                                                                                                                                * CR4 guest/host mask.
                                                                                                                                                                */
#define VMCS_CTRL_CR4_GUEST_HOST_MASK                                0x00006002

                                                                                                                                                                /**
                                                                                                                                                                 * CR0 read shadow.
                                                                                                                                                                 */
#define VMCS_CTRL_CR0_READ_SHADOW                                    0x00006004

                                                                                                                                                                 /**
                                                                                                                                                                  * CR4 read shadow.
                                                                                                                                                                  */
#define VMCS_CTRL_CR4_READ_SHADOW                                    0x00006006

                                                                                                                                                                  /**
                                                                                                                                                                   * CR3-target value 0.
                                                                                                                                                                   */
#define VMCS_CTRL_CR3_TARGET_VALUE_0                                 0x00006008

                                                                                                                                                                   /**
                                                                                                                                                                    * CR3-target value 1.
                                                                                                                                                                    */
#define VMCS_CTRL_CR3_TARGET_VALUE_1                                 0x0000600A

                                                                                                                                                                    /**
                                                                                                                                                                     * CR3-target value 2.
                                                                                                                                                                     */
#define VMCS_CTRL_CR3_TARGET_VALUE_2                                 0x0000600C

                                                                                                                                                                     /**
                                                                                                                                                                      * CR3-target value 3.
                                                                                                                                                                      */
#define VMCS_CTRL_CR3_TARGET_VALUE_3                                 0x0000600E
                                                                                                                                                                      /**
                                                                                                                                                                       * @}
                                                                                                                                                                       */

                                                                                                                                                                       /**
                                                                                                                                                                        * @defgroup vmcs_natural_width_read_only_data_fields \
                                                                                                                                                                        *           Natural-Width Read-Only Data Fields
                                                                                                                                                                        *
                                                                                                                                                                        * Natural-Width Read-Only Data Fields.
                                                                                                                                                                        * @{
                                                                                                                                                                        */
                                                                                                                                                                        /**
                                                                                                                                                                         * Exit qualification.
                                                                                                                                                                         */
#define VMCS_EXIT_QUALIFICATION                                      0x00006400

                                                                                                                                                                         /**
                                                                                                                                                                          * I/O RCX.
                                                                                                                                                                          */
#define VMCS_IO_RCX                                                  0x00006402

                                                                                                                                                                          /**
                                                                                                                                                                           * I/O RSI.
                                                                                                                                                                           */
#define VMCS_IO_RSI                                                  0x00006404

                                                                                                                                                                           /**
                                                                                                                                                                            * I/O RDI.
                                                                                                                                                                            */
#define VMCS_IO_RDI                                                  0x00006406

                                                                                                                                                                            /**
                                                                                                                                                                             * I/O RIP.
                                                                                                                                                                             */
#define VMCS_IO_RIP                                                  0x00006408

                                                                                                                                                                             /**
                                                                                                                                                                              * Guest-linear address.
                                                                                                                                                                              */
#define VMCS_EXIT_GUEST_LINEAR_ADDRESS                               0x0000640A
                                                                                                                                                                              /**
                                                                                                                                                                               * @}
                                                                                                                                                                               */

                                                                                                                                                                               /**
                                                                                                                                                                                * @defgroup vmcs_natural_width_guest_state_fields \
                                                                                                                                                                                *           Natural-Width Guest-State Fields
                                                                                                                                                                                *
                                                                                                                                                                                * Natural-Width Guest-State Fields.
                                                                                                                                                                                * @{
                                                                                                                                                                                */
                                                                                                                                                                                /**
                                                                                                                                                                                 * Guest CR0.
                                                                                                                                                                                 */
#define VMCS_GUEST_CR0                                               0x00006800

                                                                                                                                                                                 /**
                                                                                                                                                                                  * Guest CR3.
                                                                                                                                                                                  */
#define VMCS_GUEST_CR3                                               0x00006802

                                                                                                                                                                                  /**
                                                                                                                                                                                   * Guest CR4.
                                                                                                                                                                                   */
#define VMCS_GUEST_CR4                                               0x00006804

                                                                                                                                                                                   /**
                                                                                                                                                                                    * Guest ES base.
                                                                                                                                                                                    */
#define VMCS_GUEST_ES_BASE                                           0x00006806

                                                                                                                                                                                    /**
                                                                                                                                                                                     * Guest CS base.
                                                                                                                                                                                     */
#define VMCS_GUEST_CS_BASE                                           0x00006808

                                                                                                                                                                                     /**
                                                                                                                                                                                      * Guest SS base.
                                                                                                                                                                                      */
#define VMCS_GUEST_SS_BASE                                           0x0000680A

                                                                                                                                                                                      /**
                                                                                                                                                                                       * Guest DS base.
                                                                                                                                                                                       */
#define VMCS_GUEST_DS_BASE                                           0x0000680C

                                                                                                                                                                                       /**
                                                                                                                                                                                        * Guest FS base.
                                                                                                                                                                                        */
#define VMCS_GUEST_FS_BASE                                           0x0000680E

                                                                                                                                                                                        /**
                                                                                                                                                                                         * Guest GS base.
                                                                                                                                                                                         */
#define VMCS_GUEST_GS_BASE                                           0x00006810

                                                                                                                                                                                         /**
                                                                                                                                                                                          * Guest LDTR base.
                                                                                                                                                                                          */
#define VMCS_GUEST_LDTR_BASE                                         0x00006812

                                                                                                                                                                                          /**
                                                                                                                                                                                           * Guest TR base.
                                                                                                                                                                                           */
#define VMCS_GUEST_TR_BASE                                           0x00006814

                                                                                                                                                                                           /**
                                                                                                                                                                                            * Guest GDTR base.
                                                                                                                                                                                            */
#define VMCS_GUEST_GDTR_BASE                                         0x00006816

                                                                                                                                                                                            /**
                                                                                                                                                                                             * Guest IDTR base.
                                                                                                                                                                                             */
#define VMCS_GUEST_IDTR_BASE                                         0x00006818

                                                                                                                                                                                             /**
                                                                                                                                                                                              * Guest DR7.
                                                                                                                                                                                              */
#define VMCS_GUEST_DR7                                               0x0000681A

                                                                                                                                                                                              /**
                                                                                                                                                                                               * Guest RSP.
                                                                                                                                                                                               */
#define VMCS_GUEST_RSP                                               0x0000681C

                                                                                                                                                                                               /**
                                                                                                                                                                                                * Guest RIP.
                                                                                                                                                                                                */
#define VMCS_GUEST_RIP                                               0x0000681E

                                                                                                                                                                                                /**
                                                                                                                                                                                                 * Guest RFLAGS.
                                                                                                                                                                                                 */
#define VMCS_GUEST_RFLAGS                                            0x00006820

                                                                                                                                                                                                 /**
                                                                                                                                                                                                  * Guest pending debug exceptions.
                                                                                                                                                                                                  */
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                          0x00006822

                                                                                                                                                                                                  /**
                                                                                                                                                                                                   * Guest IA32_SYSENTER_ESP.
                                                                                                                                                                                                   */
#define VMCS_GUEST_SYSENTER_ESP                                      0x00006824

                                                                                                                                                                                                   /**
                                                                                                                                                                                                    * Guest IA32_SYSENTER_EIP.
                                                                                                                                                                                                    */
#define VMCS_GUEST_SYSENTER_EIP                                      0x00006826

                                                                                                                                                                                                    /**
                                                                                                                                                                                                     * Guest IA32_S_CET.
                                                                                                                                                                                                     */
#define VMCS_GUEST_S_CET                                             0x00006828

                                                                                                                                                                                                     /**
                                                                                                                                                                                                      * Guest SSP.
                                                                                                                                                                                                      */
#define VMCS_GUEST_SSP                                               0x0000682A

                                                                                                                                                                                                      /**
                                                                                                                                                                                                       * Guest IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                                       */
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR                          0x0000682C
                                                                                                                                                                                                       /**
                                                                                                                                                                                                        * @}
                                                                                                                                                                                                        */

                                                                                                                                                                                                        /**
                                                                                                                                                                                                         * @defgroup vmcs_natural_width_host_state_fields \
                                                                                                                                                                                                         *           Natural-Width Host-State Fields
                                                                                                                                                                                                         *
                                                                                                                                                                                                         * Natural-Width Host-State Fields.
                                                                                                                                                                                                         * @{
                                                                                                                                                                                                         */
                                                                                                                                                                                                         /**
                                                                                                                                                                                                          * Host CR0.
                                                                                                                                                                                                          */
#define VMCS_HOST_CR0                                                0x00006C00

                                                                                                                                                                                                          /**
                                                                                                                                                                                                           * Host CR3.
                                                                                                                                                                                                           */
#define VMCS_HOST_CR3                                                0x00006C02

                                                                                                                                                                                                           /**
                                                                                                                                                                                                            * Host CR4.
                                                                                                                                                                                                            */
#define VMCS_HOST_CR4                                                0x00006C04

                                                                                                                                                                                                            /**
                                                                                                                                                                                                             * Host FS base.
                                                                                                                                                                                                             */
#define VMCS_HOST_FS_BASE                                            0x00006C06

                                                                                                                                                                                                             /**
                                                                                                                                                                                                              * Host GS base.
                                                                                                                                                                                                              */
#define VMCS_HOST_GS_BASE                                            0x00006C08

                                                                                                                                                                                                              /**
                                                                                                                                                                                                               * Host TR base.
                                                                                                                                                                                                               */
#define VMCS_HOST_TR_BASE                                            0x00006C0A

                                                                                                                                                                                                               /**
                                                                                                                                                                                                                * Host GDTR base.
                                                                                                                                                                                                                */
#define VMCS_HOST_GDTR_BASE                                          0x00006C0C

                                                                                                                                                                                                                /**
                                                                                                                                                                                                                 * Host IDTR base.
                                                                                                                                                                                                                 */
#define VMCS_HOST_IDTR_BASE                                          0x00006C0E

                                                                                                                                                                                                                 /**
                                                                                                                                                                                                                  * Host IA32_SYSENTER_ESP.
                                                                                                                                                                                                                  */
#define VMCS_HOST_SYSENTER_ESP                                       0x00006C10

                                                                                                                                                                                                                  /**
                                                                                                                                                                                                                   * Host IA32_SYSENTER_EIP.
                                                                                                                                                                                                                   */
#define VMCS_HOST_SYSENTER_EIP                                       0x00006C12

                                                                                                                                                                                                                   /**
                                                                                                                                                                                                                    * Host RSP.
                                                                                                                                                                                                                    */
#define VMCS_HOST_RSP                                                0x00006C14

                                                                                                                                                                                                                    /**
                                                                                                                                                                                                                     * Host RIP.
                                                                                                                                                                                                                     */
#define VMCS_HOST_RIP                                                0x00006C16

                                                                                                                                                                                                                     /**
                                                                                                                                                                                                                      * Host IA32_S_CET.
                                                                                                                                                                                                                      */
#define VMCS_HOST_S_CET                                              0x00006C18

                                                                                                                                                                                                                      /**
                                                                                                                                                                                                                       * Host SSP.
                                                                                                                                                                                                                       */
#define VMCS_HOST_SSP                                                0x00006C1A

                                                                                                                                                                                                                       /**
                                                                                                                                                                                                                        * Host IA32_INTERRUPT_SSP_TABLE_ADDR.
                                                                                                                                                                                                                        */
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR                           0x00006C1C
                                                                                                                                                                                                                        /**
                                                                                                                                                                                                                         * @}
                                                                                                                                                                                                                         */

                                                                                                                                                                                                                         /**
                                                                                                                                                                                                                          * @}
                                                                                                                                                                                                                          */

                                                                                                                                                                                                                          /**
                                                                                                                                                                                                                           * @}
                                                                                                                                                                                                                           */

                                                                                                                                                                                                                           /**
                                                                                                                                                                                                                            * @brief Valid interruption types
                                                                                                                                                                                                                            */
typedef enum
{
    /**
     * External interrupt.
     */
    external_interrupt = 0x00000000,

    /**
     * Non-maskable interrupt (NMI).
     */
    non_maskable_interrupt = 0x00000002,

    /**
     * Hardware exception (e.g,. \#PF).
     */
    hardware_exception = 0x00000003,

    /**
     * Software interrupt (INT n).
     */
    software_interrupt = 0x00000004,

    /**
     * Privileged software exception (INT1).
     */
    privileged_software_exception = 0x00000005,

    /**
     * Software exception (INT3 or INTO).
     */
    software_exception = 0x00000006,

    /**
     * Other event. This type is used for injection of events that are not delivered through the IDT.
     */
    other_event = 0x00000007,
} interruption_type;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.8.3(VM-Entry Controls for Event Injection)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Vector of interrupt or exception
         *
         * [Bits 7:0] Determines which entry in the IDT is used or which other event is injected.
         */
        uint32_t vector : 8;
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_BIT                     0
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_FLAG                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_MASK                    0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR(_)                      (((_) >> 0) & 0xFF)

        /**
         * @brief Interruption type
         *
         * [Bits 10:8] Determines details of how the injection is performed.
         */
        uint32_t interruption_type : 3;
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT          8
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG         0x700
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK         0x07
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)           (((_) >> 8) & 0x07)

        /**
         * @brief Deliver error code (0 = do not deliver; 1 = deliver)
         *
         * [Bit 11] Determines whether delivery pushes an error code on the guest stack.
         */
        uint32_t deliver_error_code : 1;
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT         11
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG        0x800
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK        0x01
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_)          (((_) >> 11) & 0x01)
        uint32_t reserved1 : 19;

        /**
         * @brief Valid
         *
         * [Bit 31] VM entry injects an event if and only if the valid bit is 1. The valid bit in this field is cleared on every VM
         * exit.
         */
        uint32_t valid : 1;
#define VMENTRY_INTERRUPT_INFORMATION_VALID_BIT                      31
#define VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG                     0x80000000
#define VMENTRY_INTERRUPT_INFORMATION_VALID_MASK                     0x01
#define VMENTRY_INTERRUPT_INFORMATION_VALID(_)                       (((_) >> 31) & 0x01)
    };

    uint32_t flags;
} vmentry_interrupt_information;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all guest state and MSRs
 *        have been loaded). This process is called event injection and is controlled by these VM-entry control fields
 *
 * @see Vol3A[24.9.2(Information for VM Exits Due to Vectored Events)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bits 7:0] Vector of interrupt or exception.
         */
        uint32_t vector : 8;
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_BIT                      0
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_FLAG                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_MASK                     0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR(_)                       (((_) >> 0) & 0xFF)

        /**
         * [Bits 10:8] Interruption type.
         */
        uint32_t interruption_type : 3;
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT           8
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG          0x700
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK          0x07
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)            (((_) >> 8) & 0x07)

        /**
         * [Bit 11] Deliver error code (0 = do not deliver; 1 = deliver).
         */
        uint32_t error_code_valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT            11
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG           0x800
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK           0x01
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_)             (((_) >> 11) & 0x01)

        /**
         * [Bit 12] NMI unblocking due to IRET.
         */
        uint32_t nmi_unblocking : 1;
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT              12
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG             0x1000
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK             0x01
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_)               (((_) >> 12) & 0x01)
        uint32_t reserved1 : 18;

        /**
         * [Bit 31] Valid.
         */
        uint32_t valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_VALID_BIT                       31
#define VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG                      0x80000000
#define VMEXIT_INTERRUPT_INFORMATION_VALID_MASK                      0x01
#define VMEXIT_INTERRUPT_INFORMATION_VALID(_)                        (((_) >> 31) & 0x01)
    };

    uint32_t flags;
} vmexit_interrupt_information;

/**
 * @}
 */

 /**
  * @defgroup apic \
  *           Advanced Programmable Interrupt Controller (APIC)
  *
  * Software interacts with the local APIC by reading and writing its registers. APIC registers are memory-mapped to a
  * 4-KByte region of the processor's physical address space with an initial starting address of FEE00000H. For correct APIC
  * operation, this address space must be mapped to an area of memory that has been designated as strong uncacheable (UC).
  *
  * @remarks Registers are 32 bits, 64 bits, or 256 bits in width; all are aligned on 128-bit boundaries. All 32-bit
  *          registers should be accessed using 128-bit aligned 32-bit loads or stores. Some processors may support loads and stores
  *          of less than 32 bits to some of the APIC registers. This is model specific behavior and is not guaranteed to work on all
  *          processors. Any FP/MMX/SSE access to an APIC register, or any access that touches bytes 4 through 15 of an APIC register
  *          may cause undefined behavior and must not be executed. This undefined behavior could include hangs, incorrect results or
  *          unexpected exceptions, including machine checks, and may vary between implementations. Wider registers (64-bit or
  *          256-bit) must be accessed using multiple 32-bit loads or stores, with all accesses being 128-bit aligned.
  * @see Vol3A[10.4.1(The Local APIC Block Diagram)] (reference)
  * @{
  */
  /**
   * Local APIC Base Address.
   *
   * @remarks Reserved.
   */
#define APIC_BASE_ADDRESS                                            0xFEE00000

   /**
    * Local APIC ID Register.
    */
#define APIC_ID                                                      0x00000020

    /**
     * Local APIC Version Register.
     */
#define APIC_VERSION                                                 0x00000030

     /**
      * Task Priority Register (TPR).
      */
#define APIC_TASK_PRIORITY                                           0x00000080

      /**
       * Arbitration Priority Register (APR).
       */
#define APIC_ARBITRATION_PRIORITY                                    0x00000090

       /**
        * Processor Priority Register (PPR).
        */
#define APIC_PROCESSOR_PRIORITY                                      0x000000A0

        /**
         * EOI Register.
         */
#define APIC_EOI                                                     0x000000B0

         /**
          * Remote Read Register (RRD).
          */
#define APIC_REMOTE_READ                                             0x000000C0

          /**
           * Logical Destination Register.
           */
#define APIC_LOGICAL_DESTINATION                                     0x000000D0

           /**
            * Destination Format Register.
            *
            * @see Vol3A[10.6.2.2(Logical Destination Mode)]
            */
#define APIC_DESTINATION_FORMAT                                      0x000000E0

            /**
             * Spurious Interrupt Vector Register.
             *
             * @see Vol3A[10.9(SPURIOUS INTERRUPT)]
             */
#define APIC_SPURIOUS_INTERRUPT_VECTOR                               0x000000F0

             /**
              * In-Service Register (ISR); bits 31:0.
              */
#define APIC_IN_SERVICE_BITS_31_0                                    0x00000100

              /**
               * In-Service Register (ISR); bits 63:32.
               */
#define APIC_IN_SERVICE_BITS_63_32                                   0x00000110

               /**
                * In-Service Register (ISR); bits 95:64.
                */
#define APIC_IN_SERVICE_BITS_95_64                                   0x00000120

                /**
                 * In-Service Register (ISR); bits 127:96.
                 */
#define APIC_IN_SERVICE_BITS_127_96                                  0x00000130

                 /**
                  * In-Service Register (ISR); bits 159:128.
                  */
#define APIC_IN_SERVICE_BITS_159_128                                 0x00000140

                  /**
                   * In-Service Register (ISR); bits 191:160.
                   */
#define APIC_IN_SERVICE_BITS_191_160                                 0x00000150

                   /**
                    * In-Service Register (ISR); bits 223:192.
                    */
#define APIC_IN_SERVICE_BITS_223_192                                 0x00000160

                    /**
                     * In-Service Register (ISR); bits 255:224.
                     */
#define APIC_IN_SERVICE_BITS_255_224                                 0x00000170

                     /**
                      * Trigger Mode Register (TMR); bits 31:0.
                      */
#define APIC_TRIGGER_MODE_BITS_31_0                                  0x00000180

                      /**
                       * Trigger Mode Register (TMR); bits 63:32.
                       */
#define APIC_TRIGGER_MODE_BITS_63_32                                 0x00000190

                       /**
                        * Trigger Mode Register (TMR); bits 95:64.
                        */
#define APIC_TRIGGER_MODE_BITS_95_64                                 0x000001A0

                        /**
                         * Trigger Mode Register (TMR); bits 127:96.
                         */
#define APIC_TRIGGER_MODE_BITS_127_96                                0x000001B0

                         /**
                          * Trigger Mode Register (TMR); bits 159:128.
                          */
#define APIC_TRIGGER_MODE_BITS_159_128                               0x000001C0

                          /**
                           * Trigger Mode Register (TMR); bits 191:160.
                           */
#define APIC_TRIGGER_MODE_BITS_191_160                               0x000001D0

                           /**
                            * Trigger Mode Register (TMR); bits 223:192.
                            */
#define APIC_TRIGGER_MODE_BITS_223_192                               0x000001E0

                            /**
                             * Trigger Mode Register (TMR); bits 255:224.
                             */
#define APIC_TRIGGER_MODE_BITS_255_224                               0x000001F0

                             /**
                              * Interrupt Request Register (IRR); bits 31:0.
                              */
#define APIC_INTERRUPT_REQUEST_BITS_31_0                             0x00000200

                              /**
                               * Interrupt Request Register (IRR); bits 63:32.
                               */
#define APIC_INTERRUPT_REQUEST_BITS_63_32                            0x00000210

                               /**
                                * Interrupt Request Register (IRR); bits 95:64.
                                */
#define APIC_INTERRUPT_REQUEST_BITS_95_64                            0x00000220

                                /**
                                 * Interrupt Request Register (IRR); bits 127:96.
                                 */
#define APIC_INTERRUPT_REQUEST_BITS_127_96                           0x00000230

                                 /**
                                  * Interrupt Request Register (IRR); bits 159:128.
                                  */
#define APIC_INTERRUPT_REQUEST_BITS_159_128                          0x00000240

                                  /**
                                   * Interrupt Request Register (IRR); bits 191:160.
                                   */
#define APIC_INTERRUPT_REQUEST_BITS_191_160                          0x00000250

                                   /**
                                    * Interrupt Request Register (IRR); bits 223:192.
                                    */
#define APIC_INTERRUPT_REQUEST_BITS_223_192                          0x00000260

                                    /**
                                     * Interrupt Request Register (IRR); bits 255:224.
                                     */
#define APIC_INTERRUPT_REQUEST_BITS_255_224                          0x00000270

                                     /**
                                      * Error Status Register.
                                      */
#define APIC_ERROR_STATUS                                            0x00000280

                                      /**
                                       * LVT Corrected Machine Check Interrupt (CMCI) Register.
                                       */
#define APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT                   0x000002F0

                                       /**
                                        * Interrupt Command Register (ICR); bits 0-31.
                                        */
#define APIC_INTERRUPT_COMMAND_BITS_0_31                             0x00000300

                                        /**
                                         * Interrupt Command Register (ICR); bits 32-63.
                                         */
#define APIC_INTERRUPT_COMMAND_BITS_32_63                            0x00000310

                                         /**
                                          * LVT Timer Register.
                                          */
#define APIC_LVT_TIMER                                               0x00000320

                                          /**
                                           * LVT Thermal Sensor Register.
                                           */
#define APIC_LVT_THERMAL_SENSOR                                      0x00000330

                                           /**
                                            * LVT Performance Monitoring Counters Register.
                                            */
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS                     0x00000340

                                            /**
                                             * LVT LINT0 Register.
                                             */
#define APIC_LVT_LINT0                                               0x00000350

                                             /**
                                              * LVT LINT1 Register.
                                              */
#define APIC_LVT_LINT1                                               0x00000360

                                              /**
                                               * LVT Error Register.
                                               */
#define APIC_LVT_ERROR                                               0x00000370

                                               /**
                                                * Initial Count Register (for Timer).
                                                */
#define APIC_INITIAL_COUNT                                           0x00000380

                                                /**
                                                 * Current Count Register (for Timer).
                                                 */
#define APIC_CURRENT_COUNT                                           0x00000390

                                                 /**
                                                  * Divide Configuration Register (for Timer).
                                                  */
#define APIC_DIVIDE_CONFIGURATION                                    0x000003E0
                                                  /**
                                                   * @}
                                                   */

                                                   /**
                                                    * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. The status
                                                    * flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the
                                                    * ADD, SUB, MUL, and DIV instructions.
                                                    * The system flags and IOPL field in the EFLAGS register control operating-system or executive operations.
                                                    *
                                                    * @see Vol1[3.4.3(EFLAGS)] (reference)
                                                    */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the mostsignificant bit of the result;
         * cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in
         * multiple-precision arithmetic.
         */
        uint32_t carry_flag : 1;
#define EFLAGS_CARRY_FLAG_BIT                                        0
#define EFLAGS_CARRY_FLAG_FLAG                                       0x01
#define EFLAGS_CARRY_FLAG_MASK                                       0x01
#define EFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        uint32_t read_as_1 : 1;
#define EFLAGS_READ_AS_1_BIT                                         1
#define EFLAGS_READ_AS_1_FLAG                                        0x02
#define EFLAGS_READ_AS_1_MASK                                        0x01
#define EFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.
         */
        uint32_t parity_flag : 1;
#define EFLAGS_PARITY_FLAG_BIT                                       2
#define EFLAGS_PARITY_FLAG_FLAG                                      0x04
#define EFLAGS_PARITY_FLAG_MASK                                      0x01
#define EFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        uint32_t reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This
         * flag is used in binary-coded decimal (BCD) arithmetic.
         */
        uint32_t auxiliary_carry_flag : 1;
#define EFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define EFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define EFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define EFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        uint32_t reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] Set if the result is zero; cleared otherwise.
         */
        uint32_t zero_flag : 1;
#define EFLAGS_ZERO_FLAG_BIT                                         6
#define EFLAGS_ZERO_FLAG_FLAG                                        0x40
#define EFLAGS_ZERO_FLAG_MASK                                        0x01
#define EFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a
         * positive value and 1 indicates a negative value.)
         */
        uint32_t sign_flag : 1;
#define EFLAGS_SIGN_FLAG_BIT                                         7
#define EFLAGS_SIGN_FLAG_FLAG                                        0x80
#define EFLAGS_SIGN_FLAG_MASK                                        0x01
#define EFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] Set to enable single-step mode for debugging; clear to disable single-step mode.
         */
        uint32_t trap_flag : 1;
#define EFLAGS_TRAP_FLAG_BIT                                         8
#define EFLAGS_TRAP_FLAG_FLAG                                        0x100
#define EFLAGS_TRAP_FLAG_MASK                                        0x01
#define EFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] Controls the response of the processor to maskable interrupt requests. Set to respond to maskable interrupts;
         * cleared to inhibit maskable interrupts.
         */
        uint32_t interrupt_enable_flag : 1;
#define EFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define EFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define EFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting the DF flag causes the string
         * instructions to auto-decrement (to process strings from high addresses to low addresses). Clearing the DF flag causes
         * the string instructions to auto-increment (process strings from low addresses to high addresses).
         */
        uint32_t direction_flag : 1;
#define EFLAGS_DIRECTION_FLAG_BIT                                    10
#define EFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define EFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define EFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] Set if the integer result is too large a positive number or too small a negative number (excluding the
         * sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for
         * signed-integer (two's complement) arithmetic.
         */
        uint32_t overflow_flag : 1;
#define EFLAGS_OVERFLOW_FLAG_BIT                                     11
#define EFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define EFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define EFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] Indicates the I/O privilege level of the currently running program or task. The current privilege level
         * (CPL) of the currently running program or task must be less than or equal to the I/O privilege level to access the I/O
         * address space. The POPF and IRET instructions can modify this field only when operating at a CPL of 0.
         */
        uint32_t io_privilege_level : 2;
#define EFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define EFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define EFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define EFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the current task is linked to the previously
         * executed task; cleared when the current task is not linked to another task.
         */
        uint32_t nested_task_flag : 1;
#define EFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define EFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define EFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define EFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        uint32_t reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] Controls the processor's response to debug exceptions.
         */
        uint32_t resume_flag : 1;
#define EFLAGS_RESUME_FLAG_BIT                                       16
#define EFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define EFLAGS_RESUME_FLAG_MASK                                      0x01
#define EFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode without virtual-8086 mode semantics.
         */
        uint32_t virtual_8086_mode_flag : 1;
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of user-mode data accesses is enabled if and only
         * if this flag is 1. If the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode pages
         * are allowed if and only if this bit is 1.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        uint32_t alignment_check_flag : 1;
#define EFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define EFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define EFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To use this flag and the VIP flag the
         * virtual mode extensions are enabled by setting the VME flag in control register CR4.)
         */
        uint32_t virtual_interrupt_flag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is pending. (Software sets and clears
         * this flag; the processor only reads it.) Used in conjunction with the VIF flag.
         */
        uint32_t virtual_interrupt_pending_flag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] The ability of a program to set or clear this flag indicates support for the CPUID instruction.
         */
        uint32_t identification_flag : 1;
#define EFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define EFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define EFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define EFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        uint32_t reserved4 : 10;
    };

    uint32_t flags;
} eflags;

/**
 * The 64-bit RFLAGS register contains a group of status flags, a control flag, and a group of system flags in 64-bit mode.
 * The upper 32 bits of RFLAGS register is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS.
 *
 * @see EFLAGS
 * @see Vol1[3.4.3.4(RFLAGS Register in 64-Bit Mode)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * @brief Carry flag
         *
         * [Bit 0] See the description in EFLAGS.
         */
        uint64_t carry_flag : 1;
#define RFLAGS_CARRY_FLAG_BIT                                        0
#define RFLAGS_CARRY_FLAG_FLAG                                       0x01
#define RFLAGS_CARRY_FLAG_MASK                                       0x01
#define RFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)

        /**
         * [Bit 1] Reserved - always 1
         */
        uint64_t read_as_1 : 1;
#define RFLAGS_READ_AS_1_BIT                                         1
#define RFLAGS_READ_AS_1_FLAG                                        0x02
#define RFLAGS_READ_AS_1_MASK                                        0x01
#define RFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)

        /**
         * @brief Parity flag
         *
         * [Bit 2] See the description in EFLAGS.
         */
        uint64_t parity_flag : 1;
#define RFLAGS_PARITY_FLAG_BIT                                       2
#define RFLAGS_PARITY_FLAG_FLAG                                      0x04
#define RFLAGS_PARITY_FLAG_MASK                                      0x01
#define RFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * @brief Auxiliary Carry flag
         *
         * [Bit 4] See the description in EFLAGS.
         */
        uint64_t auxiliary_carry_flag : 1;
#define RFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
#define RFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
#define RFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
#define RFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief Zero flag
         *
         * [Bit 6] See the description in EFLAGS.
         */
        uint64_t zero_flag : 1;
#define RFLAGS_ZERO_FLAG_BIT                                         6
#define RFLAGS_ZERO_FLAG_FLAG                                        0x40
#define RFLAGS_ZERO_FLAG_MASK                                        0x01
#define RFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)

        /**
         * @brief Sign flag
         *
         * [Bit 7] See the description in EFLAGS.
         */
        uint64_t sign_flag : 1;
#define RFLAGS_SIGN_FLAG_BIT                                         7
#define RFLAGS_SIGN_FLAG_FLAG                                        0x80
#define RFLAGS_SIGN_FLAG_MASK                                        0x01
#define RFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)

        /**
         * @brief Trap flag
         *
         * [Bit 8] See the description in EFLAGS.
         */
        uint64_t trap_flag : 1;
#define RFLAGS_TRAP_FLAG_BIT                                         8
#define RFLAGS_TRAP_FLAG_FLAG                                        0x100
#define RFLAGS_TRAP_FLAG_MASK                                        0x01
#define RFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)

        /**
         * @brief Interrupt enable flag
         *
         * [Bit 9] See the description in EFLAGS.
         */
        uint64_t interrupt_enable_flag : 1;
#define RFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
#define RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
#define RFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
#define RFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)

        /**
         * @brief Direction flag
         *
         * [Bit 10] See the description in EFLAGS.
         */
        uint64_t direction_flag : 1;
#define RFLAGS_DIRECTION_FLAG_BIT                                    10
#define RFLAGS_DIRECTION_FLAG_FLAG                                   0x400
#define RFLAGS_DIRECTION_FLAG_MASK                                   0x01
#define RFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)

        /**
         * @brief Overflow flag
         *
         * [Bit 11] See the description in EFLAGS.
         */
        uint64_t overflow_flag : 1;
#define RFLAGS_OVERFLOW_FLAG_BIT                                     11
#define RFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
#define RFLAGS_OVERFLOW_FLAG_MASK                                    0x01
#define RFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)

        /**
         * @brief I/O privilege level field
         *
         * [Bits 13:12] See the description in EFLAGS.
         */
        uint64_t io_privilege_level : 2;
#define RFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
#define RFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
#define RFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
#define RFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)

        /**
         * @brief Nested task flag
         *
         * [Bit 14] See the description in EFLAGS.
         */
        uint64_t nested_task_flag : 1;
#define RFLAGS_NESTED_TASK_FLAG_BIT                                  14
#define RFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
#define RFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
#define RFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
        uint64_t reserved3 : 1;

        /**
         * @brief Resume flag
         *
         * [Bit 16] See the description in EFLAGS.
         */
        uint64_t resume_flag : 1;
#define RFLAGS_RESUME_FLAG_BIT                                       16
#define RFLAGS_RESUME_FLAG_FLAG                                      0x10000
#define RFLAGS_RESUME_FLAG_MASK                                      0x01
#define RFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)

        /**
         * @brief Virtual-8086 mode flag
         *
         * [Bit 17] See the description in EFLAGS.
         */
        uint64_t virtual_8086_mode_flag : 1;
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
#define RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)

        /**
         * @brief Alignment check (or access control) flag
         *
         * [Bit 18] See the description in EFLAGS.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        uint64_t alignment_check_flag : 1;
#define RFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
#define RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
#define RFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
#define RFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)

        /**
         * @brief Virtual interrupt flag
         *
         * [Bit 19] See the description in EFLAGS.
         */
        uint64_t virtual_interrupt_flag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
#define RFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)

        /**
         * @brief Virtual interrupt pending flag
         *
         * [Bit 20] See the description in EFLAGS.
         */
        uint64_t virtual_interrupt_pending_flag : 1;
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
#define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)

        /**
         * @brief Identification flag
         *
         * [Bit 21] See the description in EFLAGS.
         */
        uint64_t identification_flag : 1;
#define RFLAGS_IDENTIFICATION_FLAG_BIT                               21
#define RFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
#define RFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
#define RFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
        uint64_t reserved4 : 42;
    };

    uint64_t flags;
} rflags;

/**
 * @defgroup exceptions \
 *           Exceptions
 * @{
 */
 /**
  * @brief Control Protection Exception
  *
  * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))] (reference)
  */
typedef union
{
    struct
    {
        /**
         * [Bits 14:0] One of the following values:
         * 1 - NEAR-RET: Indicates the \#CP was caused by a near RET instruction.
         * 2 - FAR-RET/IRET: Indicates the \#CP was caused by a FAR RET or IRET instruction.
         * 3 - ENDBRANCH: indicates the \#CP was due to missing ENDBRANCH at target of an indirect call or jump instruction.
         * 4 - RSTORSSP: Indicates the \#CP was caused by a shadow-stack-restore token check failure in the RSTORSSP instruction.
         * 5 - SETSSBSY: Indicates \#CP was caused by a supervisor shadow stack token check failure in the SETSSBSY instruction.
         */
        uint32_t cpec : 15;
#define CONTROL_PROTECTION_EXCEPTION_CPEC_BIT                        0
#define CONTROL_PROTECTION_EXCEPTION_CPEC_FLAG                       0x7FFF
#define CONTROL_PROTECTION_EXCEPTION_CPEC_MASK                       0x7FFF
#define CONTROL_PROTECTION_EXCEPTION_CPEC(_)                         (((_) >> 0) & 0x7FFF)

        /**
         * [Bit 15] If set to 1, indicates the \#CP occurred during enclave execution.
         */
        uint32_t encl : 1;
#define CONTROL_PROTECTION_EXCEPTION_ENCL_BIT                        15
#define CONTROL_PROTECTION_EXCEPTION_ENCL_FLAG                       0x8000
#define CONTROL_PROTECTION_EXCEPTION_ENCL_MASK                       0x01
#define CONTROL_PROTECTION_EXCEPTION_ENCL(_)                         (((_) >> 15) & 0x01)
        uint32_t reserved1 : 16;
    };

    uint32_t flags;
} control_protection_exception;

/**
 * @brief Exceptions that can occur when the instruction is executed in protected mode.
 *        Each exception is given a mnemonic that consists of a pound sign (\#) followed by two letters and an optional error code
 *        in parentheses. For example, \#GP(0) denotes a general protection exception with an error code of 0
 *
 * @see Vol2A[3.1.1.13(Protected Mode Exceptions Section)] (reference)
 * @see Vol3A[6.3.1(External Interrupts)] (reference)
 */
typedef enum
{
    /**
     * #DE - Divide Error.
     * Source: DIV and IDIV instructions.
     * Error Code: No.
     */
    divide_error = 0x00000000,

    /**
     * #DB - Debug.
     * Source: Any code or data reference.
     * Error Code: No.
     */
    debug = 0x00000001,

    /**
     * Nonmaskable Interrupt.
     * Source: Generated externally by asserting the processor's NMI pin or
     *         through an NMI request set by the I/O APIC to the local APIC.
     * Error Code: No.
     */
    nmi = 0x00000002,

    /**
     * #BP - Breakpoint.
     * Source: INT3 instruction.
     * Error Code: No.
     */
    breakpoint = 0x00000003,

    /**
     * #OF - Overflow.
     * Source: INTO instruction.
     * Error Code: No.
     */
    overflow = 0x00000004,

    /**
     * #BR - BOUND Range Exceeded.
     * Source: BOUND instruction.
     * Error Code: No.
     */
    bound_range_exceeded = 0x00000005,

    /**
     * #UD - Invalid Opcode (Undefined Opcode).
     * Source: UD instruction or reserved opcode.
     * Error Code: No.
     */
    invalid_opcode = 0x00000006,

    /**
     * #NM - Device Not Available (No Math Coprocessor).
     * Source: Floating-point or WAIT/FWAIT instruction.
     * Error Code: No.
     */
    device_not_available = 0x00000007,

    /**
     * #DF - Double Fault.
     * Source: Any instruction that can generate an exception, an NMI, or an INTR.
     * Error Code: Yes (zero).
     */
    double_fault = 0x00000008,

    /**
     * #\## - Coprocessor Segment Overrun (reserved).
     * Source: Floating-point instruction.
     * Error Code: No.
     *
     * @note Processors after the Intel386 processor do not generate this exception.
     */
    coprocessor_segment_overrun = 0x00000009,

    /**
     * #TS - Invalid TSS.
     * Source: Task switch or TSS access.
     * Error Code: Yes.
     */
    invalid_tss = 0x0000000A,

    /**
     * #NP - Segment Not Present.
     * Source: Loading segment registers or accessing system segments.
     * Error Code: Yes.
     */
    segment_not_present = 0x0000000B,

    /**
     * #SS - Stack Segment Fault.
     * Source: Stack operations and SS register loads.
     * Error Code: Yes.
     */
    stack_segment_fault = 0x0000000C,

    /**
     * #GP - General Protection.
     * Source: Any memory reference and other protection checks.
     * Error Code: Yes.
     */
    general_protection = 0x0000000D,

    /**
     * #PF - Page Fault.
     * Source: Any memory reference.
     * Error Code: Yes.
     */
    page_fault = 0x0000000E,

    /**
     * #MF - Floating-Point Error (Math Fault).
     * Source: Floating-point or WAIT/FWAIT instruction.
     * Error Code: No.
     */
    x87_floating_point_error = 0x00000010,

    /**
     * #AC - Alignment Check.
     * Source: Any data reference in memory.
     * Error Code: Yes.
     */
    alignment_check = 0x00000011,

    /**
     * #MC - Machine Check.
     * Source: Model dependent machine check errors.
     * Error Code: No.
     */
    machine_check = 0x00000012,

    /**
     * #XM - SIMD Floating-Point Numeric Error.
     * Source: SSE/SSE2/SSE3 floating-point instructions.
     * Error Code: No.
     */
    simd_floating_point_error = 0x00000013,

    /**
     * #VE - Virtualization Exception.
     * Source: EPT violations.
     * Error Code: No.
     */
    virtualization_exception = 0x00000014,

    /**
     * #CP - Control Protection Exception.
     * Source: Control flow transfer attempt violated the control flow enforcement technology constraints.
     * Error Code: Yes.
     */
    control_protection = 0x00000015,
} exception_vector;

/**
 * @brief When an exception condition is related to a specific segment selector or IDT vector, the processor pushes an
 *        error code onto the stack of the exception handler (whether it is a procedure or task). The error code resembles a
 *        segment selector; however, instead of a TI flag and RPL field, the error code contains 3 different flags
 *
 * @see Vol3A[6.13(ERROR CODE)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] When set, indicates that the exception occurred during delivery of an event external to the program, such as an
         * interrupt or an earlier exception. The bit is cleared if the exception occurred during delivery of a software interrupt
         * (INT n, INT3, or INTO).
         */
        uint32_t external_event : 1;
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT                      0
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK                     0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_)                       (((_) >> 0) & 0x01)

        /**
         * [Bit 1] When set, indicates that the index portion of the error code refers to a gate descriptor in the IDT; when clear,
         * indicates that the index refers to a descriptor in the GDT or the current LDT.
         */
        uint32_t descriptor_location : 1;
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT                 1
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG                0x02
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK                0x01
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_)                  (((_) >> 1) & 0x01)

        /**
         * [Bit 2] Only used when the IDT flag is clear. When set, the TI flag indicates that the index portion of the error code
         * refers to a segment or gate descriptor in the LDT; when clear, it indicates that the index refers to a descriptor in the
         * current GDT.
         */
        uint32_t gdt_ldt : 1;
#define EXCEPTION_ERROR_CODE_GDT_LDT_BIT                             2
#define EXCEPTION_ERROR_CODE_GDT_LDT_FLAG                            0x04
#define EXCEPTION_ERROR_CODE_GDT_LDT_MASK                            0x01
#define EXCEPTION_ERROR_CODE_GDT_LDT(_)                              (((_) >> 2) & 0x01)

        /**
         * [Bits 15:3] The segment selector index field provides an index into the IDT, GDT, or current LDT to the segment or gate
         * selector being referenced by the error code. In some cases the error code is null (all bits are clear except possibly
         * EXT). A null error code indicates that the error was not caused by a reference to a specific segment or that a null
         * segment selector was referenced in an operation.
         *
         * @note The format of the error code is different for page-fault exceptions (#PF).
         */
        uint32_t index : 13;
#define EXCEPTION_ERROR_CODE_INDEX_BIT                               3
#define EXCEPTION_ERROR_CODE_INDEX_FLAG                              0xFFF8
#define EXCEPTION_ERROR_CODE_INDEX_MASK                              0x1FFF
#define EXCEPTION_ERROR_CODE_INDEX(_)                                (((_) >> 3) & 0x1FFF)
        uint32_t reserved1 : 16;
    };

    uint32_t flags;
} exception_error_code;

/**
 * @brief Page fault exception
 *
 * @see Vol3A[4.7(PAGE-FAULT EXCEPTIONS)] (reference)
 */
typedef union
{
    struct
    {
        /**
         * [Bit 0] This flag is 0 if there is no translation for the linear address because the P flag was 0 in one of the
         * pagingstructure entries used to translate that address.
         */
        uint32_t present : 1;
#define PAGE_FAULT_EXCEPTION_PRESENT_BIT                             0
#define PAGE_FAULT_EXCEPTION_PRESENT_FLAG                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_PRESENT(_)                              (((_) >> 0) & 0x01)

        /**
         * [Bit 1] If the access causing the page-fault exception was a write, this flag is 1; otherwise, it is 0. This flag
         * describes the access causing the page-fault exception, not the access rights specified by paging.
         */
        uint32_t write : 1;
#define PAGE_FAULT_EXCEPTION_WRITE_BIT                               1
#define PAGE_FAULT_EXCEPTION_WRITE_FLAG                              0x02
#define PAGE_FAULT_EXCEPTION_WRITE_MASK                              0x01
#define PAGE_FAULT_EXCEPTION_WRITE(_)                                (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a supervisor-mode access did
         * so. This flag describes the access causing the page-fault exception, not the access rights specified by paging.
         *
         * @see Vol3A[4.6(ACCESS RIGHTS)]
         */
        uint32_t user_mode_access : 1;
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT                    2
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG                   0x04
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK                   0x01
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_)                     (((_) >> 2) & 0x01)

        /**
         * [Bit 3] This flag is 1 if there is no translation for the linear address because a reserved bit was set in one of the
         * pagingstructure entries used to translate that address. (Because reserved bits are not checked in a paging-structure
         * entry whose P flag is 0, bit 3 of the error code can be set only if bit 0 is also set). Bits reserved in the
         * paging-structure entries are reserved for future functionality. Software developers should be aware that such bits may
         * be used in the future and that a paging-structure entry that causes a page-fault exception on one processor might not do
         * so in the future.
         */
        uint32_t reserved_bit_violation : 1;
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT              3
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG             0x08
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK             0x01
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_)               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] This flag is 1 if (1) the access causing the page-fault exception was an instruction fetch; and (2) either (a)
         * CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1 (either PAE paging or 4-level paging is in use); and (ii) IA32_EFER.NXE = 1.
         * Otherwise, the flag is 0. This flag describes the access causing the page-fault exception, not the access rights
         * specified by paging.
         */
        uint32_t execute : 1;
#define PAGE_FAULT_EXCEPTION_EXECUTE_BIT                             4
#define PAGE_FAULT_EXCEPTION_EXECUTE_FLAG                            0x10
#define PAGE_FAULT_EXCEPTION_EXECUTE_MASK                            0x01
#define PAGE_FAULT_EXCEPTION_EXECUTE(_)                              (((_) >> 4) & 0x01)

        /**
         * [Bit 5] This flag is 1 if (1) IA32_EFER.LMA = CR4.PKE = 1; (2) the access causing the page-fault exception was a data
         * access; (3) the linear address was a user-mode address with protection key i; and (5) the PKRU register is such that
         * either (a) ADi = 1; or (b) the following all hold: (i) WDi = 1; (ii) the access is a write access; and (iii) either
         * CR0.WP = 1 or the access causing the page-fault exception was a user-mode access.
         *
         * @see Vol3A[4.6.2(Protection Keys)]
         */
        uint32_t protection_key_violation : 1;
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT            5
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG           0x20
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK           0x01
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_)             (((_) >> 5) & 0x01)

        /**
         * [Bit 6] If the access causing the page-fault exception was a shadow-stack access (including shadow-stack accesses in
         * enclave mode), this flag is 1; otherwise, it is 0. This flag describes the access causing the page-fault exception, not
         * the access rights specified by paging.
         *
         * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
         */
        uint32_t shadow_stack : 1;
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_BIT                        6
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_FLAG                       0x40
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_MASK                       0x01
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK(_)                         (((_) >> 6) & 0x01)

        /**
         * [Bit 7] This flag is 1 if there is no translation for the linear address using HLAT paging because, in one of the
         * paging- structure entries used to translate that address, either the P flag was 0 or a reserved bit was set. An error
         * code will set this flag only if it clears bit o or sets bit 3. This flag will not be set by a page fault resulting from
         * a violation of access rights, nor for one encountered during ordinary paging, including the case in which there has been
         * a restart of HLAT paging.
         *
         * @see Vol3A[4.5.1(Ordinary Paging and HLAT Paging)]
         */
        uint32_t hlat : 1;
#define PAGE_FAULT_EXCEPTION_HLAT_BIT                                7
#define PAGE_FAULT_EXCEPTION_HLAT_FLAG                               0x80
#define PAGE_FAULT_EXCEPTION_HLAT_MASK                               0x01
#define PAGE_FAULT_EXCEPTION_HLAT(_)                                 (((_) >> 7) & 0x01)
        uint32_t reserved1 : 7;

        /**
         * [Bit 15] This flag is 1 if the exception is unrelated to paging and resulted from violation of SGX-specific
         * access-control requirements. Because such a violation can occur only if there is no ordinary page fault, this flag is
         * set only if the P flag (bit 0) is 1 and the RSVD flag (bit 3) and the PK flag (bit 5) are both 0.
         */
        uint32_t sgx : 1;
#define PAGE_FAULT_EXCEPTION_SGX_BIT                                 15
#define PAGE_FAULT_EXCEPTION_SGX_FLAG                                0x8000
#define PAGE_FAULT_EXCEPTION_SGX_MASK                                0x01
#define PAGE_FAULT_EXCEPTION_SGX(_)                                  (((_) >> 15) & 0x01)
        uint32_t reserved2 : 16;
    };

    uint32_t flags;
} page_fault_exception;

/**
 * @}
 */

 /**
  * @defgroup memory_type \
  *           Memory caching type
  *
  * The processor allows any area of system memory to be cached in the L1, L2, and L3 caches. In individual pages or regions
  * of system memory, it allows the type of caching (also called memory type) to be specified.
  *
  * @see Vol3A[11.11(MEMORY TYPE RANGE REGISTERS (MTRRS))]
  * @see Vol3A[11.5(CACHE CONTROL)]
  * @see Vol3A[11.3(METHODS OF CACHING AVAILABLE)] (reference)
  * @{
  */
  /**
   * @brief Strong Uncacheable (UC)
   *
   * System memory locations are not cached. All reads and writes appear on the system bus and are executed in program order
   * without reordering. No speculative memory accesses, pagetable walks, or prefetches of speculated branch targets are
   * made. This type of cache-control is useful for memory-mapped I/O devices. When used with normal RAM, it greatly reduces
   * processor performance.
   */
#define MEMORY_TYPE_UNCACHEABLE                                      0x00000000

   /**
    * @brief Write Combining (WC)
    *
    * System memory locations are not cached (as with uncacheable memory) and coherency is not enforced by the processor's bus
    * coherency protocol. Speculative reads are allowed. Writes may be delayed and combined in the write combining buffer (WC
    * buffer) to reduce memory accesses. If the WC buffer is partially filled, the writes may be delayed until the next
    * occurrence of a serializing event; such as, an SFENCE or MFENCE instruction, CPUID execution, a read or write to
    * uncached memory, an interrupt occurrence, or a LOCK instruction execution. This type of cache-control is appropriate for
    * video frame buffers, where the order of writes is unimportant as long as the writes update memory so they can be seen on
    * the graphics display. This memory type is available in the Pentium Pro and Pentium II processors by programming the
    * MTRRs; or in processor families starting from the Pentium III processors by programming the MTRRs or by selecting it
    * through the PAT.
    *
    * @see Vol3A[11.3.1(Buffering of Write Combining Memory Locations)]
    */
#define MEMORY_TYPE_WRITE_COMBINING                                  0x00000001

    /**
     * @brief Write-through (WT)
     *
     * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
     * cache fills. Speculative reads are allowed. All writes are written to a cache line (when possible) and through to system
     * memory. When writing through to memory, invalid cache lines are never filled, and valid cache lines are either filled or
     * invalidated. Write combining is allowed. This type of cache-control is appropriate for frame buffers or when there are
     * devices on the system bus that access system memory, but do not perform snooping of memory accesses. It enforces
     * coherency between caches in the processors and system memory.
     */
#define MEMORY_TYPE_WRITE_THROUGH                                    0x00000004

     /**
      * @brief Write protected (WP)
      *
      * Reads come from cache lines when possible, and read misses cause cache fills. Writes are propagated to the system bus
      * and cause corresponding cache lines on all processors on the bus to be invalidated. Speculative reads are allowed. This
      * memory type is available in processor families starting from the P6 family processors by programming the MTRRs.
      */
#define MEMORY_TYPE_WRITE_PROTECTED                                  0x00000005

      /**
       * @brief Write-back (WB)
       *
       * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits; read misses cause
       * cache fills. Speculative reads are allowed. Write misses cause cache line fills (in processor families starting with the
       * P6 family processors), and writes are performed entirely in the cache, when possible. Write combining is allowed. The
       * write-back memory type reduces bus traffic by eliminating many unnecessary writes to system memory. Writes to a cache
       * line are not immediately forwarded to system memory; instead, they are accumulated in the cache. The modified cache
       * lines are written to system memory later, when a write-back operation is performed. Write-back operations are triggered
       * when cache lines need to be deallocated, such as when new cache lines are being allocated in a cache that is already
       * full. They also are triggered by the mechanisms used to maintain cache consistency. This type of cache-control provides
       * the best performance, but it requires that all devices that access system memory on the system bus be able to snoop
       * memory accesses to insure system memory and cache coherency.
       */
#define MEMORY_TYPE_WRITE_BACK                                       0x00000006

       /**
        * @brief Uncacheable (UC-)
        *
        * Has same characteristics as the strong uncacheable (UC) memory type, except that this memory type can be overridden by
        * programming the MTRRs for the WC memory type. This memory type is available in processor families starting from the
        * Pentium III processors and can only be selected through the PAT.
        */
#define MEMORY_TYPE_UNCACHEABLE_MINUS                                0x00000007
#define MEMORY_TYPE_INVALID                                          0x000000FF
        /**
         * @}
         */

         /**
          * @defgroup vtd \
          *           VTD
          * @{
          */
          /**
           * @brief The Root Table Address Register points to a table of root-entries, when the Translation Table Mode (TTM) field in
           *        the register is 00b
           *
           * @see VTd[9.1(Root Entry)]
           */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0] This field indicates whether the root-entry is present.
             * * 0: Indicates the root-entry is not present. All other fields are ignored by hardware.
             * * 1: Indicates the root-entry is present.
             */
            uint64_t present : 1;
#define VTD_Lower64_PRESENT_BIT                                      0
#define VTD_Lower64_PRESENT_FLAG                                     0x01
#define VTD_Lower64_PRESENT_MASK                                     0x01
#define VTD_Lower64_PRESENT(_)                                       (((_) >> 0) & 0x01)
            uint64_t reserved1 : 11;

            /**
             * [Bits 63:12] Pointer to Context-table for this bus. The Context-table is 4KB in size and size aligned. Hardware treats
             * bits 63:HAW as reserved (0), where HAW is the host address width of the platform.
             */
            uint64_t context_table_pointer : 52;
#define VTD_Lower64_CONTEXT_TABLE_POINTER_BIT                        12
#define VTD_Lower64_CONTEXT_TABLE_POINTER_FLAG                       0xFFFFFFFFFFFFF000
#define VTD_Lower64_CONTEXT_TABLE_POINTER_MASK                       0xFFFFFFFFFFFFF
#define VTD_Lower64_CONTEXT_TABLE_POINTER(_)                         (((_) >> 12) & 0xFFFFFFFFFFFFF)
        };

        uint64_t flags;
    } lower64;

    union
    {
        struct
        {
            /**
             * [Bits 63:0] Reserved. Must be 0.
             */
            uint64_t reserved : 64;
#define VTD_Upper64_RESERVED_BIT                                     0
#define VTD_Upper64_RESERVED_FLAG                                    0xFFFFFFFFFFFFFFFF
#define VTD_Upper64_RESERVED_MASK                                    0xFFFFFFFFFFFFFFFF
#define VTD_Upper64_RESERVED(_)                                      (((_) >> 0) & 0xFFFFFFFFFFFFFFFF)
        };

        uint64_t flags;
    } upper64;

} vtd_root_entry;

/**
 * @brief Context-entries support translation of requests-without-PASID. Context-entries are referenced through
 *        root-entries
 *
 * @see VTd[9.3(Context Entry)]
 */
typedef struct
{
    union
    {
        struct
        {
            /**
             * [Bit 0]
             * * 0: Indicates the context-entry is not present. All other fields except Fault Processing Disable (FPD) field are
             * ignored by hardware.
             * * 1: Indicates the context-entry is present.
             */
            uint64_t present : 1;
#define VTD_Lower64_PRESENT_BIT                                      0
#define VTD_Lower64_PRESENT_FLAG                                     0x01
#define VTD_Lower64_PRESENT_MASK                                     0x01
#define VTD_Lower64_PRESENT(_)                                       (((_) >> 0) & 0x01)

            /**
             * [Bit 1] Enables or disables recording/reporting of qualified non-recoverable faults.
             * * 0: Qualified non-recoverable faults are recorded/reported for requests processed through this context-entry.
             * * 1: Qualified non-recoverable faults are not recorded/reported for requests processed through this context-entry.
             * This field is evaluated by hardware irrespective of the setting of the present (P) field.
             */
            uint64_t fault_processing_disable : 1;
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_BIT                     1
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_FLAG                    0x02
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_MASK                    0x01
#define VTD_Lower64_FAULT_PROCESSING_DISABLE(_)                      (((_) >> 1) & 0x01)

            /**
             * [Bits 3:2] This field is applicable only for requests-without-PASID, as hardware blocks all requests-with- PASID in
             * legacy mode before they can use context table.
             * * 00b: Untranslated requests are translated using second-level paging structures referenced through SLPTPTR field.
             * Translated requests and Translation Requests are blocked.
             * * 01b: Untranslated, Translated and Translation Requests are supported. This encoding is treated as reserved by hardware
             * implementations not supporting Device-TLBs (DT=0 in Extended Capability Register).
             * * 10b: Untranslated requests are processed as pass-through. SLPTPTR field is ignored by hardware. Translated and
             * Translation Requests are blocked. This encoding is treated by hardware as reserved for hardware implementations not
             * supporting Pass Through (PT=0 in Extended Capability Register).
             * * 11b: Reserved.
             */
            uint64_t translation_type : 2;
#define VTD_Lower64_TRANSLATION_TYPE_BIT                             2
#define VTD_Lower64_TRANSLATION_TYPE_FLAG                            0x0C
#define VTD_Lower64_TRANSLATION_TYPE_MASK                            0x03
#define VTD_Lower64_TRANSLATION_TYPE(_)                              (((_) >> 2) & 0x03)
            uint64_t reserved1 : 8;

            /**
             * [Bits 63:12] When the Translation-Type (TT) field is 00b or 01b, this field points to the base of second level paging
             * entries (described in Section 9.8).
             * Hardware treats bits 63:HAW as reserved (0), where HAW is the host address width of the platform.
             * This field is ignored by hardware when Translation-Type (TT) field is 10b (pass-through).
             */
            uint64_t second_level_page_translation_pointer : 52;
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_BIT        12
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_FLAG       0xFFFFFFFFFFFFF000
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_MASK       0xFFFFFFFFFFFFF
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER(_)         (((_) >> 12) & 0xFFFFFFFFFFFFF)
        };

        uint64_t flags;
    } lower64;

    union
    {
        struct
        {
            /**
             * [Bits 2:0] When the Translation-type (TT) field is 00b or 01b, this field indicates the adjusted guest address- width
             * (AGAW) to be used by hardware for the second-level page-table walk. The following encodings are defined for this field:
             * * 000b: Reserved
             * * 001b: 39-bit AGAW (3-level page table)
             * * 010b: 48-bit AGAW (4-level page table)
             * * 011b: 57-bit AGAW (5-level page table)
             * * 100b-111b: Reserved
             * The value specified in this field must match an AGAW value supported by hardware (as reported in the SAGAW field in the
             * Capability Register).
             * When the Translation-type (TT) field indicates pass-through processing (10b), this field must be programmed to indicate
             * the largest AGAW value supported by hardware.
             * Untranslated requests-without-PASID processed through this context-entry and accessing addresses above 2X-1 (where X is
             * the AGAW value indicated by this field) are blocked and treated as translation faults.
             */
            uint64_t address_width : 3;
#define VTD_Upper64_ADDRESS_WIDTH_BIT                                0
#define VTD_Upper64_ADDRESS_WIDTH_FLAG                               0x07
#define VTD_Upper64_ADDRESS_WIDTH_MASK                               0x07
#define VTD_Upper64_ADDRESS_WIDTH(_)                                 (((_) >> 0) & 0x07)

            /**
             * [Bits 6:3] Hardware ignores the programming of this field.
             */
            uint64_t ignored : 4;
#define VTD_Upper64_IGNORED_BIT                                      3
#define VTD_Upper64_IGNORED_FLAG                                     0x78
#define VTD_Upper64_IGNORED_MASK                                     0x0F
#define VTD_Upper64_IGNORED(_)                                       (((_) >> 3) & 0x0F)
            uint64_t reserved1 : 1;

            /**
             * [Bits 17:8] Identifier for the domain to which this context-entry maps. Hardware may use the domain identifier to tag
             * its internal caches.
             * The Capability Register reports the domain-id width supported by hardware. For implementations supporting less than
             * 16-bit domain-ids, unused bits of this field are treated as reserved by hardware. For example, for implementation
             * supporting 8-bit domain-ids, bits 87:80 of this field are treated as reserved.
             * Context-entries programmed with the same domain identifier must always reference same address translation (SLPTPTR
             * field). Context-entries referencing same address translation are recommended to be programmed with same domain id for
             * hardware efficiency.
             * When Caching Mode (CM) field in Capability Register is reported as Set, the domain-id value of zero is architecturally
             * reserved. Software must not use domain-id value of zero when CM is Set.
             */
            uint64_t domain_identifier : 10;
#define VTD_Upper64_DOMAIN_IDENTIFIER_BIT                            8
#define VTD_Upper64_DOMAIN_IDENTIFIER_FLAG                           0x3FF00
#define VTD_Upper64_DOMAIN_IDENTIFIER_MASK                           0x3FF
#define VTD_Upper64_DOMAIN_IDENTIFIER(_)                             (((_) >> 8) & 0x3FF)
            uint64_t reserved2 : 46;
        };

        uint64_t flags;
    } upper64;

} vtd_context_entry;

/**
 * @defgroup vtd_entry_count \
 *           Table entry counts
 *
 * Table entry counts.
 * @{
 */
#define VTD_ROOT_ENTRY_COUNT                                         0x00000100
#define VTD_CONTEXT_ENTRY_COUNT                                      0x00000100
 /**
  * @}
  */

  /**
   * Register to report the implementation version. Backward compatibility for the architecture is maintained with new
   * revision numbers, allowing software to load remapping hardware drivers written for prior versions.
   *
   * @remarks VER_REG
   * @see VTd[10.4.1(Version Register)]
   */
#define VTD_VERSION                                                  0x00000000
typedef union
{
    struct
    {
        /**
         * @brief Minor Version number <b>(RO)</b>
         *
         * [Bits 3:0] Indicates Minor Version of Implementation.
         */
        uint32_t minor : 4;
#define VTD_VERSION_MINOR_BIT                                        0
#define VTD_VERSION_MINOR_FLAG                                       0x0F
#define VTD_VERSION_MINOR_MASK                                       0x0F
#define VTD_VERSION_MINOR(_)                                         (((_) >> 0) & 0x0F)

        /**
         * @brief Major Version number <b>(RO)</b>
         *
         * [Bits 7:4] Indicates Major Version of Implementation.
         */
        uint32_t major : 4;
#define VTD_VERSION_MAJOR_BIT                                        4
#define VTD_VERSION_MAJOR_FLAG                                       0xF0
#define VTD_VERSION_MAJOR_MASK                                       0x0F
#define VTD_VERSION_MAJOR(_)                                         (((_) >> 4) & 0x0F)
        uint32_t reserved1 : 24;
    };

    uint32_t flags;
} vtd_version_register;


/**
 * Register to report general remapping hardware capabilities.
 *
 * @remarks CAP_REG
 * @see VTd[10.4.2(Capability Register)]
 */
#define VTD_CAPABILITY                                               0x00000008
typedef union
{
    struct
    {
        /**
         * @brief Number of domains supported <b>(RO)</b>
         *
         * [Bits 2:0]
         * * 000b: Hardware supports 4-bit domain-ids with support for up to 16 domains.
         * * 001b: Hardware supports 6-bit domain-ids with support for up to 64 domains.
         * * 010b: Hardware supports 8-bit domain-ids with support for up to 256 domains.
         * * 011b: Hardware supports 10-bit domain-ids with support for up to 1024 domains.
         * * 100b: Hardware supports 12-bit domain-ids with support for up to 4K domains.
         * * 101b: Hardware supports 14-bit domain-ids with support for up to 16K domains.
         * * 110b: Hardware supports 16-bit domain-ids with support for up to 64K domains.
         * * 111b: Reserved.
         */
        uint64_t number_of_domains_supported : 3;
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_BIT               0
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_FLAG              0x07
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_MASK              0x07
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED(_)                (((_) >> 0) & 0x07)

        /**
         * @brief Advanced Fault Logging <b>(RO)</b>
         *
         * [Bit 3]
         * * 0: Indicates advanced fault logging is not supported. Only primary fault logging is supported.
         * * 1: Indicates advanced fault logging is supported.
         */
        uint64_t advanced_fault_logging : 1;
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_BIT                    3
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_FLAG                   0x08
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_MASK                   0x01
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING(_)                     (((_) >> 3) & 0x01)

        /**
         * @brief Required Write-Buffer Flushing <b>(RO)</b>
         *
         * [Bit 4]
         * * 0: Indicates no write-buffer flushing is needed to ensure changes to memory-resident structures are visible to
         * hardware.
         * * 1: Indicates software must explicitly flush the write buffers to ensure updates made to memory-resident remapping
         * structures are visible to hardware.
         */
        uint64_t required_write_buffer_flushing : 1;
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_BIT            4
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_FLAG           0x10
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_MASK           0x01
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING(_)             (((_) >> 4) & 0x01)

        /**
         * @brief Protected Low-Memory Region <b>(RO)</b>
         *
         * [Bit 5]
         * * 0: Indicates protected low-memory region is not supported.
         * * 1: Indicates protected low-memory region is supported.
         */
        uint64_t protected_low_memory_region : 1;
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_BIT               5
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_FLAG              0x20
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_MASK              0x01
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION(_)                (((_) >> 5) & 0x01)

        /**
         * @brief Protected High-Memory Region <b>(RO)</b>
         *
         * [Bit 6]
         * * 0: Indicates protected high-memory region is not supported.
         * * 1: Indicates protected high-memory region is supported.
         */
        uint64_t protected_high_memory_region : 1;
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_BIT              6
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_FLAG             0x40
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_MASK             0x01
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION(_)               (((_) >> 6) & 0x01)

        /**
         * @brief Caching Mode <b>(RO)</b>
         *
         * [Bit 7] This field applies to all DMA and Interrupt remap tables except FLtables. Hardware will not cache faulting
         * FL-only translations in IOTLB or FL-paging-structure caches.
         * * 0: Not-present and erroneous entries are not cached in any of the remapping caches. Invalidations are not required for
         * modifications to individual not present or invalid entries. However, any modifications that result in decreasing the
         * effective permissions or partial permission increases require invalidations for them to be effective.
         * * 1: Not-present and erroneous mappings may be cached in the remapping caches. Any software updates to the remapping
         * structures (including updates to "not-present" or erroneous entries) require explicit invalidation.
         */
        uint64_t caching_mode : 1;
#define VTD_CAPABILITY_CACHING_MODE_BIT                              7
#define VTD_CAPABILITY_CACHING_MODE_FLAG                             0x80
#define VTD_CAPABILITY_CACHING_MODE_MASK                             0x01
#define VTD_CAPABILITY_CACHING_MODE(_)                               (((_) >> 7) & 0x01)

        /**
         * @brief Supported Adjusted Guest Address Widths <b>(RO)</b>
         *
         * [Bits 12:8] This 5-bit field indicates the supported adjusted guest address widths (which in turn represents the levels
         * of page-table walks for the 4KB base page size) supported by the hardware implementation.
         * A value of 1 in any of these bits indicates the corresponding adjusted guest address width is supported. The adjusted
         * guest address widths corresponding to various bit positions within this field are:
         * * 0: Reserved
         * * 1: 39-bit AGAW (3-level page-table)
         * * 2: 48-bit AGAW (4-level page-table)
         * * 3: 57-bit AGAW (5-level page-table)
         * * 4: Reserved
         * Software must ensure that the adjusted guest address width used to set up the page tables is one of the supported guest
         * address widths reported in this field.
         * Hardware implementations reporting second-level translation support (SLTS) field as Clear also report this field as 0.
         */
        uint64_t supported_adjusted_guest_address_widths : 5;
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_BIT   8
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_FLAG  0x1F00
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_MASK  0x1F
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS(_)    (((_) >> 8) & 0x1F)
        uint64_t reserved1 : 3;

        /**
         * @brief Maximum Guest Address Width <b>(RO)</b>
         *
         * [Bits 21:16] This field indicates the maximum guest physical address width supported by second-level translation in
         * remapping hardware. The Maximum Guest Address Width (MGAW) is computed as (N+1), where N is the valued reported in this
         * field. For example, a hardware implementation supporting 48-bit MGAW reports a value of 47 (101111b) in this field.
         * If the value in this field is X, untranslated DMA requests with addresses above 2(X+1)-1 that are subjected to
         * second-level translation are blocked by hardware. Device-TLB translation requests to addresses above 2(X+1)-1 that are
         * subjected to second-level translation from allowed devices return a null Translation-Completion Data with R=W=0.
         * Guest addressability for a given DMA request is limited to the minimum of the value reported through this field and the
         * adjusted guest address width of the corresponding page-table structure. (Adjusted guest address widths supported by
         * hardware are reported through the SAGAW field).
         * Implementations must support MGAW at least equal to the physical addressability (host address width) of the platform.
         */
        uint64_t maximum_guest_address_width : 6;
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_BIT               16
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_FLAG              0x3F0000
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_MASK              0x3F
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH(_)                (((_) >> 16) & 0x3F)

        /**
         * @brief Zero Length Read <b>(RO)</b>
         *
         * [Bit 22]
         * * 0: Indicates the remapping hardware unit blocks (and treats as fault) zero length DMA read requests to write-only
         * pages.
         * * 1: Indicates the remapping hardware unit supports zero length DMA read requests to write-only pages.
         * DMA remapping hardware implementations are recommended to report ZLR field as Set.
         */
        uint64_t zero_length_read : 1;
#define VTD_CAPABILITY_ZERO_LENGTH_READ_BIT                          22
#define VTD_CAPABILITY_ZERO_LENGTH_READ_FLAG                         0x400000
#define VTD_CAPABILITY_ZERO_LENGTH_READ_MASK                         0x01
#define VTD_CAPABILITY_ZERO_LENGTH_READ(_)                           (((_) >> 22) & 0x01)

        /**
         * @brief Deprecated <b>(RO)</b>
         *
         * [Bit 23] This field must be reported as 0 to ensure backward compatibility with older software.
         */
        uint64_t deprecated : 1;
#define VTD_CAPABILITY_DEPRECATED_BIT                                23
#define VTD_CAPABILITY_DEPRECATED_FLAG                               0x800000
#define VTD_CAPABILITY_DEPRECATED_MASK                               0x01
#define VTD_CAPABILITY_DEPRECATED(_)                                 (((_) >> 23) & 0x01)

        /**
         * @brief Fault-recording Register offset <b>(RO)</b>
         *
         * [Bits 33:24] This field specifies the offset of the first fault recording register relative to the register base address
         * of this remapping hardware unit. If the register base address is X, and the value reported in this field is Y, the
         * address for the first fault recording register is calculated as X+(16*Y).
         */
        uint64_t fault_recording_register_offset : 10;
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_BIT           24
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_FLAG          0x3FF000000
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_MASK          0x3FF
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET(_)            (((_) >> 24) & 0x3FF)

        /**
         * @brief Second Level Large Page Support <b>(RO)</b>
         *
         * [Bits 37:34] This field indicates the large page sizes supported by hardware.
         * A value of 1 in any of these bits indicates the corresponding large page size is supported. The large-page sizes
         * corresponding to various bit positions within this field are:
         * * 0: 21-bit offset to page frame (2MB)
         * * 1: 30-bit offset to page frame (1GB)
         * * 2: Reserved
         * * 3: Reserved
         * Hardware implementations supporting a specific large-page size must support all smaller large-page sizes. i.e., only
         * valid values for this field are 0000b, 0001b, 0011b.
         */
        uint64_t second_level_large_page_support : 4;
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_BIT           34
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_FLAG          0x3C00000000
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_MASK          0x0F
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT(_)            (((_) >> 34) & 0x0F)
        uint64_t reserved2 : 1;

        /**
         * @brief Page Selective Invalidation <b>(RO)</b>
         *
         * [Bit 39]
         * * 0: Hardware supports only global and domain-selective invalidates for IOTLB.
         * * 1: Hardware supports page-selective, domain-selective, and global invalidates for IOTLB.
         * Hardware implementations reporting this field as Set are recommended to support a Maximum Address Mask Value (MAMV)
         * value of at least 9 (or 18 if supporting 1GB pages with second level translation).
         * This field is applicable only for IOTLB invalidations for second-level translation. Irrespective of value reported in
         * this field, implementations supporting SMTS must support page/address selective IOTLB invalidation for first-level
         * translation.
         */
        uint64_t page_selective_invalidation : 1;
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_BIT               39
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_FLAG              0x8000000000
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_MASK              0x01
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION(_)                (((_) >> 39) & 0x01)

        /**
         * @brief Number of Fault-recording Registers <b>(RO)</b>
         *
         * [Bits 47:40] Number of fault recording registers is computed as N+1, where N is the value reported in this field.
         * Implementations must support at least one fault recording register (NFR = 0) for each remapping hardware unit in the
         * platform.
         * The maximum number of fault recording registers per remapping hardware unit is 256.
         */
        uint64_t number_of_fault_recording_registers : 8;
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_BIT       40
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_FLAG      0xFF0000000000
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_MASK      0xFF
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS(_)        (((_) >> 40) & 0xFF)

        /**
         * @brief Maximum Address Mask Value <b>(RO)</b>
         *
         * [Bits 53:48] The value in this field indicates the maximum supported value for the Address Mask (AM) field in the
         * Invalidation Address register (IVA_REG), and IOTLB Invalidation Descriptor (iotlb_inv_dsc) used for invalidations of
         * second-level translation.
         * This field is valid when the PSI field in Capability register is reported as Set.
         * Independent of value reported in this field, implementations supporting SMTS must support address-selective PASID-based
         * IOTLB invalidations (p_iotlb_inv_dsc) with any defined address mask.
         */
        uint64_t maximum_address_mask_value : 6;
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_BIT                48
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_FLAG               0x3F000000000000
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_MASK               0x3F
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE(_)                 (((_) >> 48) & 0x3F)

        /**
         * @brief Write Draining <b>(RO)</b>
         *
         * [Bit 54]
         * * 0: Hardware does not support draining of write requests on IOTLB Invalidation.
         * * 1: Hardware supports draining of write requests on IOTLB Invalidation.
         * Hardware implementation with Major Version 2 or higher (VER_REG), always performs required drain without software
         * explicitly requesting a drain in IOTLB invalidation. This field is deprecated and hardware will always report it as 1 to
         * maintain backward compatibility with software.
         */
        uint64_t write_draining : 1;
#define VTD_CAPABILITY_WRITE_DRAINING_BIT                            54
#define VTD_CAPABILITY_WRITE_DRAINING_FLAG                           0x40000000000000
#define VTD_CAPABILITY_WRITE_DRAINING_MASK                           0x01
#define VTD_CAPABILITY_WRITE_DRAINING(_)                             (((_) >> 54) & 0x01)

        /**
         * @brief Read Draining <b>(RO)</b>
         *
         * [Bit 55]
         * * 0: Hardware does not support draining of read requests on IOTLB Invalidation.
         * * 1: Hardware supports draining of read requests on IOTLB Invalidation.
         * Hardware implementation with Major Version 2 or higher (VER_REG), always performs required drain without software
         * explicitly requesting a drain in IOTLB invalidation. This field is deprecated and hardware will always report it as 1 to
         * maintain backward compatibility with software.
         */
        uint64_t read_draining : 1;
#define VTD_CAPABILITY_READ_DRAINING_BIT                             55
#define VTD_CAPABILITY_READ_DRAINING_FLAG                            0x80000000000000
#define VTD_CAPABILITY_READ_DRAINING_MASK                            0x01
#define VTD_CAPABILITY_READ_DRAINING(_)                              (((_) >> 55) & 0x01)

        /**
         * @brief First Level 1-GByte Page Support <b>(RO)</b>
         *
         * [Bit 56] A value of 1 in this field indicates 1-GByte page size is supported for first-level translation.
         * Hardware implementation reporting First-level Translation Support (FLTS) as Clear also report this field as Clear.
         */
        uint64_t first_level_1gbyte_page_support : 1;
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_BIT           56
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_FLAG          0x100000000000000
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_MASK          0x01
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT(_)            (((_) >> 56) & 0x01)
        uint64_t reserved3 : 2;

        /**
         * @brief Posted Interrupts Support <b>(RO)</b>
         *
         * [Bit 59]
         * * 0: Hardware does not support Posting of Interrupts.
         * * 1: Hardware supports Posting of Interrupts.
         * Hardware implementation reporting Interrupt Remapping support (IR) field in Extended Capability Register as Clear also
         * report this field as Clear.
         */
        uint64_t posted_interrupts_support : 1;
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_BIT                 59
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_FLAG                0x800000000000000
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_MASK                0x01
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT(_)                  (((_) >> 59) & 0x01)

        /**
         * @brief First Level 5-level Paging Support <b>(RO)</b>
         *
         * [Bit 60]
         * * 0: Hardware does not support 5-level paging for first-level translation.
         * * 1: Hardware supports 5-level paging for first-level translation.
         * Hardware implementation reporting First-level Translation Support (FLTS) as Clear also report this field as Clear.
         */
        uint64_t first_level_5level_paging_support : 1;
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_BIT         60
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_FLAG        0x1000000000000000
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_MASK        0x01
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT(_)          (((_) >> 60) & 0x01)
        uint64_t reserved4 : 1;

        /**
         * @brief Enhanced Set Interrupt Remap Table Pointer Support <b>(RO)</b>
         *
         * [Bit 62]
         * * 0: Hardware does not invalidate all Interrupt remapping hardware translation caches as part of SIRTP flow.
         * * 1: Hardware invalidates all Interrupt remapping hardware translation caches as part of SIRTP flow.
         */
        uint64_t enhanced_set_interrupt_remap_table_pointer_support : 1;
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_BIT 62
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_FLAG 0x4000000000000000
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_MASK 0x01
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT(_) (((_) >> 62) & 0x01)

        /**
         * @brief Enhanced Set Root Table Pointer Support <b>(RO)</b>
         *
         * [Bit 63]
         * * 0: Hardware does not invalidate all DMA remapping hardware translation caches as part of SRTP flow.
         * * 1: Hardware invalidates all DMA remapping hardware translation caches as part of SRTP flow.
         */
        uint64_t enhanced_set_root_table_pointer_support : 1;
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_BIT   63
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_FLAG  0x8000000000000000
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_MASK  0x01
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT(_)    (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} vtd_capability_register;


/**
 * Register to report remapping hardware extended capabilities
 *
 * @remarks ECAP_REG
 * @see VTd[10.4.3(Extended Capability Register)]
 */
#define VTD_EXTENDED_CAPABILITY                                      0x00000010
typedef union
{
    struct
    {
        /**
         * @brief Page-walk Coherency <b>(RO)</b>
         *
         * [Bit 0] This field indicates if hardware access to the root, scalable-mode root, context, scalable-mode-context,
         * scalable-mode PASIDdirectory, scalable-mode PASID-table, and interrupt-remap tables, and legacy-mode second-level paging
         * structures are coherent (snooped) or not.
         * * 0:Indicates hardware accesses to remapping structures are non-coherent.
         * * 1:Indicates hardware accesses to remapping structures are coherent.
         * Hardware access to advanced fault log, invalidation queue, invalidation semaphore, page-request queue are always
         * snooped.
         */
        uint64_t page_walk_coherency : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_BIT              0
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_FLAG             0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_MASK             0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY(_)               (((_) >> 0) & 0x01)

        /**
         * @brief Queued Invalidation support <b>(RO)</b>
         *
         * [Bit 1]
         * * 0: Hardware does not support queued invalidations.
         * * 1: Hardware supports queued invalidations.
         */
        uint64_t queued_invalidation_support : 1;
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_BIT      1
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_FLAG     0x02
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_MASK     0x01
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT(_)       (((_) >> 1) & 0x01)

        /**
         * @brief Device-TLB support <b>(RO)</b>
         *
         * [Bit 2]
         * * 0: Hardware does not support Device-TLBs.
         * * 1: Hardware supports Device-TLBs.
         * Hardware implementation reporting Queued Invalidation support (QI) field as Clear also report this field as Clear.
         */
        uint64_t device_tlb_support : 1;
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_BIT               2
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_FLAG              0x04
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_MASK              0x01
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT(_)                (((_) >> 2) & 0x01)

        /**
         * @brief Interrupt Remapping support <b>(RO)</b>
         *
         * [Bit 3]
         * * 0: Hardware does not support interrupt remapping.
         * * 1: Hardware supports interrupt remapping.
         * Hardware implementation reporting Queued Invalidation support (QI) field as Clear also report this field as Clear.
         */
        uint64_t interrupt_remapping_support : 1;
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_BIT      3
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_FLAG     0x08
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_MASK     0x01
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT(_)       (((_) >> 3) & 0x01)

        /**
         * @brief Extended Interrupt Mode <b>(RO)</b>
         *
         * [Bit 4]
         * * 0: On Intel(R) 64 platforms, hardware supports only 8-bit APIC-IDs (xAPIC Mode).
         * * 1: On Intel(R) 64 platforms, hardware supports 32-bit APICIDs (x2APIC mode).
         * Hardware implementation reporting Interrupt Remapping support (IR) field as Clear also report this field as Clear.
         */
        uint64_t extended_interrupt_mode : 1;
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_BIT          4
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_FLAG         0x10
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_MASK         0x01
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE(_)           (((_) >> 4) & 0x01)

        /**
         * @brief Deprecated1 <b>(RO)</b>
         *
         * [Bit 5] This field must be reported as 0 to ensure backward compatibility with older software.
         */
        uint64_t deprecated1 : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_BIT                      5
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_FLAG                     0x20
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_MASK                     0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1(_)                       (((_) >> 5) & 0x01)

        /**
         * @brief Pass Through <b>(RO)</b>
         *
         * [Bit 6]
         * * 0: Hardware does not support pass-through translation type in context-entries and scalable-mode-pasid-table-entries.
         * * 1: Hardware supports pass-through translation type in context and scalable-mode-pasid-table-entries.
         */
        uint64_t pass_through : 1;
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_BIT                     6
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_FLAG                    0x40
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_MASK                    0x01
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH(_)                      (((_) >> 6) & 0x01)

        /**
         * @brief Snoop Control <b>(RO)</b>
         *
         * [Bit 7]
         * * 0: Hardware does not support 1-setting of the SNP field in the page-table entries.
         * * 1: Hardware supports the 1-setting of the SNP field in the page-table entries.
         * Implementations are recommended to support Snoop Control to support software usages that require Snoop Control for
         * assignment of devices behind a remapping hardware unit.
         */
        uint64_t snoop_control : 1;
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_BIT                    7
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_FLAG                   0x80
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_MASK                   0x01
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL(_)                     (((_) >> 7) & 0x01)

        /**
         * @brief IOTLB Register Offset <b>(RO)</b>
         *
         * [Bits 17:8] This field specifies the offset to the IOTLB registers relative to the register base address of this
         * remapping hardware unit.
         * If the register base address is X, and the value reported in this field is Y, the address for the IOTLB registers is
         * calculated as X+(16*Y).
         */
        uint64_t iotlb_register_offset : 10;
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_BIT            8
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_FLAG           0x3FF00
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_MASK           0x3FF
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET(_)             (((_) >> 8) & 0x3FF)
        uint64_t reserved1 : 2;

        /**
         * @brief Maximum Handle Mask Value <b>(RO)</b>
         *
         * [Bits 23:20] The value in this field indicates the maximum supported value for the Interrupt Mask (IM) field in the
         * Interrupt Entry Cache Invalidation Descriptor (iec_inv_dsc).
         * This field is unused and is reported as 0 if Interrupt Remapping support (IR) field is Clear.
         */
        uint64_t maximum_handle_mask_value : 4;
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_BIT        20
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_FLAG       0xF00000
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_MASK       0x0F
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE(_)         (((_) >> 20) & 0x0F)

        /**
         * @brief Deprecated2 <b>(RO)</b>
         *
         * [Bit 24] In prior versions of this specification this bit was used to enumerate "Extended mode address translation"
         * which is now deprecated. This field must be reported as 0 to ensure backward compatibility with any software that
         * enables extended mode address translation.
         */
        uint64_t deprecated2 : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_BIT                      24
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_FLAG                     0x1000000
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_MASK                     0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2(_)                       (((_) >> 24) & 0x01)

        /**
         * @brief Memory Type Support <b>(RO)</b>
         *
         * [Bit 25]
         * * 0: Hardware does not support Memory Type in first-level translation and Extended Memory type in second-level
         * translation.
         * * 1: Hardware supports Memory Type in first-level translation and Extended Memory type in second-level translation.
         * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field as Clear also report this field as
         * Clear. Remapping hardware units with, one or more devices that operate in processor coherency domain, under its scope
         * must report this field as Set.
         */
        uint64_t memory_type_support : 1;
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_BIT              25
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_FLAG             0x2000000
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_MASK             0x01
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT(_)               (((_) >> 25) & 0x01)

        /**
         * @brief Nested Translation Support <b>(RO)</b>
         *
         * [Bit 26]
         * * 0: Hardware does not support nested translations.
         * * 1: Hardware supports nested translations.
         * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field as Clear or First-level Translation
         * Support (FLTS) field as Clear or Second-level Translation Support (SLTS) field as Clear also report this field as Clear.
         */
        uint64_t nested_translation_support : 1;
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_BIT       26
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_FLAG      0x4000000
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_MASK      0x01
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT(_)        (((_) >> 26) & 0x01)
        uint64_t reserved2 : 1;

        /**
         * @brief Deprecated3 <b>(RO)</b>
         *
         * [Bit 28] This field must be reported as 0 to ensure backward compatibility with older software.
         */
        uint64_t deprecated3 : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_BIT                      28
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_FLAG                     0x10000000
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_MASK                     0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3(_)                       (((_) >> 28) & 0x01)

        /**
         * @brief Page Request Support <b>(RO)</b>
         *
         * [Bit 29]
         * * 0: Hardware does not support page requests.
         * * 1: Hardware supports page requests.
         * Hardware implementation reporting Device-TLB support (DT) field as Clear or Scalable Mode Translation Support (SMTS)
         * field as Clear also report this field as Clear.
         */
        uint64_t page_request_support : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_BIT             29
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_FLAG            0x20000000
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_MASK            0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT(_)              (((_) >> 29) & 0x01)

        /**
         * @brief Execute Request Support <b>(RO)</b>
         *
         * [Bit 30]
         * * 0: Hardware does not support requests-with-PASID seeking execute permission.
         * * 1: Hardware supports requests-with-PASID seeking execute permission.
         * Hardware implementations reporting Process Address Space ID support (PASID) field as Clear must report this field as
         * Clear.
         */
        uint64_t execute_request_support : 1;
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_BIT          30
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_FLAG         0x40000000
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_MASK         0x01
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT(_)           (((_) >> 30) & 0x01)
        uint64_t reserved3 : 2;

        /**
         * @brief No Write Flag Support <b>(RO)</b>
         *
         * [Bit 33]
         * * 0: Hardware ignores the 'No Write' (NW) flag in Device-TLB translation-requests, and behaves as if NW is always 0.
         * * 1: Hardware supports the 'No Write' (NW) flag in Device-TLB translation-requests.
         * Hardware implementations reporting Device-TLB support (DT) field as Clear also report this field as Clear.
         */
        uint64_t no_write_flag_support : 1;
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_BIT            33
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_FLAG           0x200000000
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_MASK           0x01
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT(_)             (((_) >> 33) & 0x01)

        /**
         * @brief Extended Accessed Flag Support <b>(RO)</b>
         *
         * [Bit 34]
         * * 0: Hardware does not support the extended-accessed (EA) bit in first-level paging-structure entries.
         * * 1: Hardware supports the extended-accessed (EA) bit in first-level paging-structure entries.
         * Hardware implementations reporting Scalable-Mode Page-walk Coherency Support (SWPWCS) as Clear also report this field as
         * Clear.
         */
        uint64_t extended_accessed_flag_support : 1;
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_BIT   34
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_FLAG  0x400000000
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_MASK  0x01
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT(_)    (((_) >> 34) & 0x01)

        /**
         * @brief PASID Size Supported <b>(RO)</b>
         *
         * [Bits 39:35] This field reports the PASID size supported by the remapping hardware for requests-with-PASID. A value of N
         * in this field indicates hardware supports PASID field of N+1 bits (For example, value of 7 in this field, indicates
         * 8-bit PASIDs are supported).
         * Requests-with-PASID with PASID value beyond the limit specified by this field are treated as error by the remapping
         * hardware. This field is unused and reported as 0 if Scalable Mode Translation Support (SMTS) field is Clear.
         */
        uint64_t pasid_size_supported : 5;
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_BIT             35
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_FLAG            0xF800000000
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_MASK            0x1F
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED(_)              (((_) >> 35) & 0x1F)

        /**
         * @brief Process Address Space ID Support <b>(RO)</b>
         *
         * [Bit 40]
         * * 0: Hardware does not support requests tagged with Process Address Space IDs.
         * * 1: Hardware supports requests tagged with Process Address Space IDs.
         * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field as Clear also report this field as
         * Clear.
         */
        uint64_t process_address_space_id_support : 1;
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_BIT 40
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_FLAG 0x10000000000
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT(_)  (((_) >> 40) & 0x01)

        /**
         * @brief Device-TLB Invalidation Throttle <b>(RO)</b>
         *
         * [Bit 41]
         * * 0: Hardware does not support Device-TLB Invalidation Throttling.
         * * 1: Hardware supports Device-TLB Invalidation Throttling.
         * Hardware implementations reporting Device-TLB support (DT) as Clear also report this field as Clear.
         */
        uint64_t device_tlb_invalidation_throttle : 1;
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_BIT 41
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_FLAG 0x20000000000
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE(_)  (((_) >> 41) & 0x01)

        /**
         * @brief Page-request Drain Support <b>(RO)</b>
         *
         * [Bit 42]
         * * 0: Hardware does not support Page-request Drain (PD) flag in inv_wait_dsc.
         * * 1: Hardware supports Page-request Drain (PD) flag in inv_wait_dsc.
         * Hardware implementations reporting Device-TLB support (DT) as Clear also report this field as Clear.
         */
        uint64_t page_request_drain_support : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_BIT       42
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_FLAG      0x40000000000
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_MASK      0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT(_)        (((_) >> 42) & 0x01)

        /**
         * @brief Scalable Mode Translation Support <b>(RO)</b>
         *
         * [Bit 43]
         * * 0: Hardware does not support Scalable Mode DMA Remapping.
         * * 1: Hardware supports Scalable Mode DMA Remapping through scalable-mode context-table and PASID-table structures.
         * Hardware implementation reporting Queued Invalidation (QI) field as Clear also report this field as Clear.
         * Hardware implementation reporting First-Level Translation Support (FLTS), Second-level Translation Support (SLTS) and
         * Pass-through Support (PT) as Clear also report this field as Clear.
         */
        uint64_t scalable_mode_translation_support : 1;
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_BIT 43
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_FLAG 0x80000000000
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT(_) (((_) >> 43) & 0x01)

        /**
         * @brief Virtual Command Support <b>(RO)</b>
         *
         * [Bit 44]
         * * 0: Hardware does not support command submission to virtual-DMA Remapping hardware.
         * * 1: Hardware does support command submission to virtual- DMA Remapping hardware.
         * Hardware implementations of this architecture report a value of 0 in this field. Software implementations (emulation) of
         * this architecture may report VCS=1.
         * Software managing remapping hardware should be written to handle both values of VCS.
         */
        uint64_t virtual_command_support : 1;
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_BIT          44
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_FLAG         0x100000000000
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_MASK         0x01
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT(_)           (((_) >> 44) & 0x01)

        /**
         * @brief Second-Level Accessed/Dirty Support <b>(RO)</b>
         *
         * [Bit 45]
         * * 0: Hardware does not support Accessed/Dirty bits in Second- Level translation.
         * * 1: Hardware supports Accessed/Dirty bits in Second-Level translation.
         * Hardware implementations reporting Scalable-Mode Page-walk Coherency Support (SMPWCS) as Clear also report this field as
         * Clear.
         */
        uint64_t second_level_accessed_dirty_support : 1;
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_BIT 45
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_FLAG 0x200000000000
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT(_) (((_) >> 45) & 0x01)

        /**
         * @brief Second-level Translation Support <b>(RO)</b>
         *
         * [Bit 46]
         * * 0: Hardware does not support PASID Granular Translation Type of second-level (PGTT=010b) in scalable-mode PASIDTable
         * entry.
         * * 1: Hardware supports PASID Granular Translation Type of second-level (PGTT=010b) in scalable-mode PASID-Table entry.
         */
        uint64_t second_level_translation_support : 1;
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_BIT 46
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_FLAG 0x400000000000
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT(_)  (((_) >> 46) & 0x01)

        /**
         * @brief First-level Translation Support <b>(RO)</b>
         *
         * [Bit 47]
         * * 0: Hardware does not support PASID Granular Translation Type of first-level (PGTT=001b) in scalable-mode PASIDTable
         * entry.
         * * 1: Hardware supports PASID Granular Translation Type of first-level (PGTT=001b) in scalable-mode PASID-Table entry.
         * Hardware implementations reporting Scalable Mode Translation Support (SMTS) as Clear also report this field as Clear
         */
        uint64_t first_level_translation_support : 1;
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_BIT  47
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_FLAG 0x800000000000
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT(_)   (((_) >> 47) & 0x01)

        /**
         * @brief Scalable-Mode Page-walk Coherency <b>(RO)</b>
         *
         * [Bit 48]
         * * 0: Hardware access to paging structures accessed through PASID-table entry are not snooped.
         * * 1: Hardware access to paging structures accessed through PASID-table entry are snooped if PWSNP field in PASID-table
         * entry is Set. Paging-structures accessed through PASID-table entry are not snooped if PWSNP field in PASID-table entry
         * is Clear.
         * Hardware implementations reporting Scalable Mode Translation Support (SMTS) as Clear also report this field as Clear.
         */
        uint64_t scalable_mode_page_walk_coherency : 1;
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_BIT 48
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_FLAG 0x1000000000000
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY(_) (((_) >> 48) & 0x01)

        /**
         * @brief RID-PASID Support <b>(RO)</b>
         *
         * [Bit 49]
         * * 0: Hardware does not support RID_PASID field in scalable mode context-entry. It uses the value of 0 for RID_PASID.
         * * 1: Hardware supports the RID_PASID field in scalable-mode context-entry.
         * Hardware implementations reporting Scalable Mode Translation Support (SMTS) as Clear also report this field as Clear.
         */
        uint64_t rid_pasid_support : 1;
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_BIT                49
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_FLAG               0x2000000000000
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_MASK               0x01
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT(_)                 (((_) >> 49) & 0x01)
        uint64_t reserved4 : 2;

        /**
         * @brief Abort DMA Mode Support <b>(RO)</b>
         *
         * [Bit 52]
         * * 0: Hardware does not support Abort DMA Mode.
         * * 1: Hardware supports Abort DMA Mode.
         */
        uint64_t abort_dma_mode_support : 1;
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_BIT           52
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_FLAG          0x10000000000000
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_MASK          0x01
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT(_)            (((_) >> 52) & 0x01)

        /**
         * @brief RID_PRIV Support <b>(RO)</b>
         *
         * [Bit 53]
         * * 0: Hardware does not support the RID_PRIV field in the scalable-mode context-entry. It uses the value of 0 for
         * RID_PRIV.
         * * 1: Hardware supports the RID_PRIV field in the scalable mode context-entry.
         * Hardware implementations reporting Supervisor Request Support (SRS) as Clear also report this field as Clear.
         */
        uint64_t rid_priv_support : 1;
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_BIT                 53
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_FLAG                0x20000000000000
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_MASK                0x01
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT(_)                  (((_) >> 53) & 0x01)
        uint64_t reserved5 : 10;
    };

    uint64_t flags;
} vtd_extended_capability_register;


/**
 * Register to control remapping hardware. If multiple control fields in this register need to be modified, software must
 * serialize the modifications through multiple writes to this register.
 * For example, to update a bit field in this register at offset X with value of Y, software must follow below steps:
 * 1. Tmp = Read GSTS_REG
 * 2. Status = (Tmp & 96FFFFFFh) // Reset the one-shot bits
 * 3. if (Y) {Command = (Status | (1 << X))} else {Command = (Status & ~(1 << X))}
 * 4. Write Command to GCMD_REG
 * 5. Wait until GSTS_REG[X] indicates command is serviced.
 *
 * @remarks GCMD_REG
 * @see VTd[10.4.4(Global Command Register)]
 */
#define VTD_GLOBAL_COMMAND                                           0x00000018
typedef union
{
    struct
    {
        uint32_t reserved1 : 23;

        /**
         * @brief Compatibility Format Interrupt <b>(WO)</b>
         *
         * [Bit 23] This field is valid only for Intel(R) 64 implementations supporting interrupt remapping.
         * Software writes to this field to enable or disable Compatibility Format interrupts on Intel(R) 64 platforms. The value in
         * this field is effective only when interrupt-remapping is enabled and Extended Interrupt Mode (x2APIC mode) is not
         * enabled.
         * * 0: Block Compatibility format interrupts.
         * * 1: Process Compatibility format interrupts as pass-through (bypass interrupt remapping).
         * Hardware reports the status of updating this field through the CFIS field in the Global Status register.
         * The value returned on a read of this field is undefined.
         */
        uint32_t compatibility_format_interrupt : 1;
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_BIT        23
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_FLAG       0x800000
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_MASK       0x01
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT(_)         (((_) >> 23) & 0x01)

        /**
         * @brief Set Interrupt Remap Table Pointer <b>(WO)</b>
         *
         * [Bit 24] This field is valid only for implementations supporting interrupt remapping.
         * Software sets this field to set/update the interrupt remapping table pointer used by hardware. The interrupt remapping
         * table pointer is specified through the Interrupt Remapping Table Address (IRTA_REG) register.
         * Hardware reports the status of the 'Set Interrupt Remap Table Pointer' operation through the IRTPS field in the Global
         * Status register.
         * The 'Set Interrupt Remap Table Pointer' operation must be performed before enabling or re-enabling (after disabling)
         * interrupt-remapping hardware through the IRE field.
         * Clearing this bit has no effect. The value returned on a read of this field is undefined.
         */
        uint32_t set_interrupt_remap_table_pointer : 1;
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_BIT     24
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_FLAG    0x1000000
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_MASK    0x01
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER(_)      (((_) >> 24) & 0x01)

        /**
         * @brief Interrupt Remapping Enable <b>(WO)</b>
         *
         * [Bit 25] This field is valid only for implementations supporting interrupt remapping.
         * * 0: Disable interrupt-remapping hardware
         * * 1: Enable interrupt-remapping hardware
         * Hardware reports the status of the interrupt remapping enable operation through the IRES field in the Global Status
         * register.
         * There may be active interrupt requests in the platform when software updates this field. Hardware must enable or disable
         * interrupt-remapping logic only at deterministic transaction boundaries, so that any in-flight interrupts are either
         * subject to remapping or not at all.
         * For implementations reporting the Enhanced Set Interrupt Remap Table Pointer Support (ESIRTPS) field as Set, hardware
         * performs global invalidation on all Interrupt remapping caches as part of Interrupt Remapping Disable operation.
         * Hardware implementations must drain any in-flight interrupts requests queued in the Root-Complex before completing the
         * interrupt-remapping enable command and reflecting the status of the command through the IRES field in the Global Status
         * register.
         * The value returned on a read of this field is undefined.
         */
        uint32_t interrupt_remapping_enable : 1;
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_BIT            25
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_FLAG           0x2000000
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_MASK           0x01
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE(_)             (((_) >> 25) & 0x01)

        /**
         * @brief Queued Invalidation Enable <b>(WO)</b>
         *
         * [Bit 26] This field is valid only for implementations supporting queued invalidations.
         * Software writes to this field to enable or disable queued invalidations.
         * * 0: Disable queued invalidations.
         * * 1: Enable use of queued invalidations.
         * Hardware reports the status of queued invalidation enable operation through QIES field in the Global Status register.
         * The value returned on a read of this field is undefined.
         */
        uint32_t queued_invalidation_enable : 1;
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_BIT            26
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_FLAG           0x4000000
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_MASK           0x01
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE(_)             (((_) >> 26) & 0x01)

        /**
         * @brief Write Buffer Flush <b>(WO)</b>
         *
         * [Bit 27] This bit is valid only for implementations requiring write buffer flushing.
         * Software sets this field to request that hardware flush the Root-Complex internal write buffers. This is done to ensure
         * any updates to the memory resident remapping structures are not held in any internal write posting buffers.
         * Hardware reports the status of the write buffer flushing operation through the WBFS field in the Global Status register.
         * Clearing this bit has no effect. The value returned on a read of this field is undefined.
         */
        uint32_t write_buffer_flush : 1;
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_BIT                    27
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_FLAG                   0x8000000
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_MASK                   0x01
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH(_)                     (((_) >> 27) & 0x01)

        /**
         * @brief Enable Advanced Fault Logging <b>(WO)</b>
         *
         * [Bit 28] This field is valid only for implementations supporting advanced fault logging.
         * Software writes to this field to request hardware to enable or disable advanced fault logging:
         * * 0: Disable advanced fault logging. In this case, translation faults are reported through the Fault Recording
         * registers.
         * * 1: Enable use of memory-resident fault log. When enabled, translation faults are recorded in the memory-resident log.
         * The fault log pointer must be set in hardware (through the SFL field) before enabling advanced fault logging. Hardware
         * reports the status of the advanced fault logging enable operation through the AFLS field in the Global Status register.
         * The value returned on read of this field is undefined.
         */
        uint32_t enable_advanced_fault_logging : 1;
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_BIT         28
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_FLAG        0x10000000
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_MASK        0x01
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING(_)          (((_) >> 28) & 0x01)

        /**
         * @brief Set Fault Log <b>(WO)</b>
         *
         * [Bit 29] This field is valid only for implementations supporting advanced fault logging.
         * Software sets this field to request hardware to set/update the fault-log pointer used by hardware. The fault-log pointer
         * is specified through Advanced Fault Log register.
         * Hardware reports the status of the 'Set Fault Log' operation through the FLS field in the Global Status register.
         * The fault log pointer must be set before enabling advanced fault logging (through EAFL field). Once advanced fault
         * logging is enabled, the fault log pointer may be updated through this field while DMA remapping is active.
         * Clearing this bit has no effect. The value returned on read of this field is undefined.
         */
        uint32_t set_fault_log : 1;
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_BIT                         29
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_FLAG                        0x20000000
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_MASK                        0x01
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG(_)                          (((_) >> 29) & 0x01)

        /**
         * @brief Set Root Table Pointer <b>(WO)</b>
         *
         * [Bit 30] Software sets this field to set/update the root-table pointer (and translation table mode) used by hardware.
         * The root-table pointer (and translation table mode) is specified through the Root Table Address (RTADDR_REG) register.
         * Hardware reports the status of the 'Set Root Table Pointer' operation through the RTPS field in the Global Status
         * register.
         * The 'Set Root Table Pointer' operation must be performed before enabling or re-enabling (after disabling) DMA remapping
         * through the TE field. For details on invalidation that software may have to perform after the
         * Clearing this bit has no effect. The value returned on a read of this field is undefined.
         */
        uint32_t set_root_table_pointer : 1;
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_BIT                30
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_FLAG               0x40000000
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_MASK               0x01
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER(_)                 (((_) >> 30) & 0x01)

        /**
         * @brief Translation Enable <b>(WO)</b>
         *
         * [Bit 31] Software writes to this field to request hardware to enable/disable DMA remapping:
         * * 0: Disable DMA remapping
         * * 1: Enable DMA remapping
         * Hardware reports the status of the translation enable operation through the TES field in the Global Status register.
         * There may be active DMA requests in the platform when software updates this field. Hardware must enable or disable
         * remapping logic only at deterministic transaction boundaries, so that any in-flight transaction is either subject to
         * remapping or not at all.
         * Hardware implementations supporting DMA draining must drain any inflight DMA read/write requests queued within the
         * Root-Complex before completing the translation enable command and reflecting the status of the command through the TES
         * field in the Global Status register.
         * For implementations reporting Scalable Mode Translation Support (SMTS) field as Set, hardware performs global
         * invalidation on all DMA remapping translation caches as part of Translation Disable operation.
         * The value returned on a read of this field is undefined.
         */
        uint32_t translation_enable : 1;
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_BIT                    31
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_FLAG                   0x80000000
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_MASK                   0x01
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE(_)                     (((_) >> 31) & 0x01)
    };

    uint32_t flags;
} vtd_global_command_register;


/**
 * Register to report general remapping hardware status.
 *
 * @remarks GSTS_REG
 * @see VTd[10.4.5(Global Status Register)]
 */
#define VTD_GLOBAL_STATUS                                            0x0000001C
typedef union
{
    struct
    {
        uint32_t reserved1 : 23;

        /**
         * @brief Compatibility Format Interrupt Status <b>(RO)</b>
         *
         * [Bit 23] This field indicates the status of Compatibility format interrupts on Intel(R) 64 implementations supporting
         * interrupt-remapping. The value reported in this field is applicable only when interrupt-remapping is enabled and
         * extended interrupt mode (x2APIC mode) is not enabled.
         * * 0: Compatibility format interrupts are blocked.
         * * 1: Compatibility format interrupts are processed as pass-through (bypassing interrupt remapping).
         */
        uint32_t compatibility_format_interrupt_status : 1;
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_BIT  23
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_FLAG 0x800000
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS(_)   (((_) >> 23) & 0x01)

        /**
         * @brief Interrupt Remapping Table Pointer Status <b>(RO)</b>
         *
         * [Bit 24] This field indicates the status of the interrupt remapping table pointer in hardware.
         * This field is cleared by hardware when software sets the SIRTP field in the Global Command register. This field is Set
         * by hardware when hardware completes the 'Set Interrupt Remap Table Pointer' operation using the value provided in the
         * Interrupt Remapping Table Address register.
         */
        uint32_t interrupt_remapping_table_pointer_status : 1;
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_BIT 24
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_FLAG 0x1000000
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS(_) (((_) >> 24) & 0x01)

        /**
         * @brief Interrupt Remapping Enable Status <b>(RO)</b>
         *
         * [Bit 25] This field indicates the status of Interrupt-remapping hardware.
         * * 0: Interrupt-remapping hardware is not enabled
         * * 1: Interrupt-remapping hardware is enabled
         */
        uint32_t interrupt_remapping_enable_status : 1;
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_BIT      25
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_FLAG     0x2000000
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_MASK     0x01
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS(_)       (((_) >> 25) & 0x01)

        /**
         * @brief Queued Invalidation Enable Status <b>(RO)</b>
         *
         * [Bit 26] This field indicates queued invalidation enable status.
         * * 0: queued invalidation is not enabled
         * * 1: queued invalidation is enabled
         */
        uint32_t queued_invalidation_enable_status : 1;
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_BIT      26
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_FLAG     0x4000000
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_MASK     0x01
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS(_)       (((_) >> 26) & 0x01)

        /**
         * @brief Write Buffer Flush Status <b>(RO)</b>
         *
         * [Bit 27] This field is valid only for implementations requiring write buffer flushing. This field indicates the status
         * of the write buffer flush command. It is
         * * Set by hardware when software sets the WBF field in the Global Command register.
         * * Cleared by hardware when hardware completes the write buffer flushing operation.
         */
        uint32_t write_buffer_flush_status : 1;
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_BIT              27
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_FLAG             0x8000000
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_MASK             0x01
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS(_)               (((_) >> 27) & 0x01)

        /**
         * @brief Advanced Fault Logging Status <b>(RO)</b>
         *
         * [Bit 28] This field is valid only for implementations supporting advanced fault logging. It indicates the advanced fault
         * logging status:
         * * 0: Advanced Fault Logging is not enabled
         * * 1: Advanced Fault Logging is enabled
         */
        uint32_t advanced_fault_logging_status : 1;
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_BIT          28
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_FLAG         0x10000000
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_MASK         0x01
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS(_)           (((_) >> 28) & 0x01)

        /**
         * @brief Fault Log Status <b>(RO)</b>
         *
         * [Bit 29] This field:
         * * Is cleared by hardware when software Sets the SFL field in the Global Command register.
         * * Is Set by hardware when hardware completes the 'Set Fault Log Pointer' operation using the value provided in the
         * Advanced Fault Log register.
         */
        uint32_t fault_log_status : 1;
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_BIT                       29
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_FLAG                      0x20000000
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_MASK                      0x01
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS(_)                        (((_) >> 29) & 0x01)

        /**
         * @brief Root Table Pointer Status <b>(RO)</b>
         *
         * [Bit 30] This field indicates the status of the root-table pointer in hardware.
         * This field is cleared by hardware when software sets the SRTP field in the Global Command register. This field is set by
         * hardware when hardware completes the 'Set Root Table Pointer' operation using the value provided in the Root Table
         * Address register.
         */
        uint32_t root_table_pointer_status : 1;
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_BIT              30
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_FLAG             0x40000000
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_MASK             0x01
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS(_)               (((_) >> 30) & 0x01)

        /**
         * @brief Translation Enable Status <b>(RO)</b>
         *
         * [Bit 31] This field indicates the status of DMA-remapping hardware.
         * * 0: DMA remapping is not enabled
         * * 1: DMA remapping is enabled
         */
        uint32_t translation_enable_status : 1;
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_BIT              31
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_FLAG             0x80000000
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_MASK             0x01
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS(_)               (((_) >> 31) & 0x01)
    };

    uint32_t flags;
} vtd_global_status_register;


/**
 * Register providing the base address of root-table and the translation table mode. Software programs the desired values
 * in this register but these values take effect only after software executes Set Root Table Pointer command through the
 * SRTP field in the Global Command Register (GCMD_REG).
 *
 * @remarks RTADDR_REG
 * @see VTd[10.4.6(Root Table Address Register)]
 */
#define VTD_ROOT_TABLE_ADDRESS                                       0x00000020
typedef union
{
    struct
    {
        uint64_t reserved1 : 10;

        /**
         * @brief Translation Table Mode <b>(RW)</b>
         *
         * [Bits 11:10] This field specifies the translation mode used for DMA remapping.
         * * 00: legacy mode - uses root tables and context tables.
         * * 01: scalable mode - uses scalable-mode root tables and scalable mode context tables.
         * * 10: reserved - in prior version of this specification, this encoding was used to enable extended mode which is no
         * longer supported.
         * * 11: abort-dma mode.
         * For implementations reporting Enhanced SRTP Support (ESRTPS) field as Clear in the Capability register, software must
         * not modify this field while DMA remapping is active (TES=1 in Global Status register).
         * The value of this field takes effect only after software executes Set Root Table Pointer command.
         */
        uint64_t translation_table_mode : 2;
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_BIT            10
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_FLAG           0xC00
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_MASK           0x03
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE(_)             (((_) >> 10) & 0x03)

        /**
         * @brief Root Table Address <b>(RW)</b>
         *
         * [Bits 63:12] This field points to the base of the page-aligned, 4KB-sized root-table in system memory. Hardware may
         * ignore and not implement bits 63:HAW, where HAW is the host address width.
         * The value of this field takes effect only after software executes Set Root Table Pointer command.
         */
        uint64_t root_table_address : 52;
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_BIT                12
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_FLAG               0xFFFFFFFFFFFFF000
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_MASK               0xFFFFFFFFFFFFF
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS(_)                 (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    uint64_t flags;
} vtd_root_table_address_register;


/**
 * Register to manage context-cache.The act of writing the uppermost byte of the CCMD_REG with the ICC field Set causes the
 * hardware to perform the context-cache invalidation.
 *
 * @remarks CCMD_RE
 * @see VTd[10.4.7(Context Command Register)]
 */
#define VTD_CONTEXT_COMMAND                                          0x00000028
typedef union
{
    struct
    {
        /**
         * @brief Domain-ID <b>(RW)</b>
         *
         * [Bits 15:0] Indicates the id of the domain whose context-entries need to be selectively invalidated. This field must be
         * programmed by software for both domain selective and device-selective invalidation requests.
         * The Capability register reports the domain-id width supported by hardware. Software must ensure that the value written
         * to this field is within this limit. Hardware ignores (and may not implement) bits 15:N, where N is the supported
         * domain-id width reported in the Capability register.
         */
        uint64_t domain_id : 16;
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_BIT                            0
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_FLAG                           0xFFFF
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_MASK                           0xFFFF
#define VTD_CONTEXT_COMMAND_DOMAIN_ID(_)                             (((_) >> 0) & 0xFFFF)

        /**
         * @brief Source-ID <b>(WO)</b>
         *
         * [Bits 31:16] Indicates the source-id of the device whose corresponding context-entry needs to be selectively
         * invalidated.This field along with the FM field must be programmed by software for device-selective invalidation
         * requests.
         * The value returned on a read of this field is undefined.
         */
        uint64_t source_id : 16;
#define VTD_CONTEXT_COMMAND_SOURCE_ID_BIT                            16
#define VTD_CONTEXT_COMMAND_SOURCE_ID_FLAG                           0xFFFF0000
#define VTD_CONTEXT_COMMAND_SOURCE_ID_MASK                           0xFFFF
#define VTD_CONTEXT_COMMAND_SOURCE_ID(_)                             (((_) >> 16) & 0xFFFF)

        /**
         * @brief Function Mask <b>(WO)</b>
         *
         * [Bits 33:32] Software may use the Function Mask to perform device-selective invalidations on behalf of devices
         * supporting PCI Express Phantom Functions.
         * This field specifies which bits of the function number portion (least significant three bits) of the SID field to mask
         * when performing device selective invalidations.The following encodings are defined for this field:
         * * 00: No bits in the SID field masked
         * * 01: Mask bit 2 in the SID field
         * * 10: Mask bits 2:1 in the SID field
         * * 11: Mask bits 2:0 in the SID field
         * The context-entries corresponding to the source-ids specified through the SID and FM fields must have the domain-id
         * specified in the DID field.
         * The value returned on a read of this field is undefined.
         */
        uint64_t function_mask : 2;
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_BIT                        32
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_FLAG                       0x300000000
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_MASK                       0x03
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK(_)                         (((_) >> 32) & 0x03)
        uint64_t reserved1 : 25;

        /**
         * @brief Context Actual Invalidation Granularity <b>(RO)</b>
         *
         * [Bits 60:59] Hardware reports the granularity at which an invalidation request was processed through the CAIG field at
         * the time of reporting invalidation completion (by clearing the ICC field).
         * The following are the encodings for this field:
         * * 00: Error. This indicates hardware detected an incorrect invalidation request and ignored the request, e.g., register
         * based invalidation when Translation Table Mode (TTM) in Root Table Address Register is not programmed to legacy mode
         * (RTADDR_REG.TTM!=00b).
         * On hardware implementations with Major Version 6 or higher (VER_REG), all invalidation requests through this register
         * are treated as incorrect invalidation requests. Software should use the Queued Invalidation interface to perform
         * context-cache invalidations for such hardware implementations. Refer to Section 6.5 for more details.
         * * 01: Global Invalidation performed. This could be in response to a global, domain-selective, or device-selective
         * invalidation request.
         * * 10: Domain-selective invalidation performed using the domain-id specified by software in the DID field. This could be
         * in response to a domain-selective or device-selective invalidation request.
         * * 11: Device-selective invalidation performed using the source-id and domain-id specified by software in the SID and FM
         * fields. This can only be in response to a device-selective invalidation request.
         */
        uint64_t context_actual_invalidation_granularity : 2;
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_BIT 59
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_FLAG 0x1800000000000000
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_MASK 0x03
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY(_) (((_) >> 59) & 0x03)

        /**
         * @brief Context Invalidation Request Granularity <b>(RW)</b>
         *
         * [Bits 62:61] Software provides the requested invalidation granularity through this field when setting the ICC field:
         * * 00: Reserved.
         * * 01: Global Invalidation request.
         * * 10: Domain-selective invalidation request. The target domain-id must be specified in the DID field.
         * * 11: Device-selective invalidation request. The target source-id(s) must be specified through the SID and FM fields,
         * and the domain-id [that was programmed in the context-entry for these device(s)] must be provided in the DID field.
         * Hardware implementations may process an invalidation request by performing invalidation at a coarser granularity than
         * requested. Hardware indicates completion of the invalidation request by clearing the ICC field. At this time, hardware
         * also indicates the granularity at which the actual invalidation was performed through the CAIG field.
         */
        uint64_t context_invalidation_request_granularity : 2;
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_BIT 61
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_FLAG 0x6000000000000000
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_MASK 0x03
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY(_) (((_) >> 61) & 0x03)

        /**
         * @brief Invalidate Context-Cache <b>(RW)</b>
         *
         * [Bit 63] Software requests invalidation of context-cache by setting this field. Software must also set the requested
         * invalidation granularity by programming the CIRG field. Software must read back and check the ICC field is Clear to
         * confirm the invalidation is complete. Software must not update this register when this field is Set.
         * Hardware clears the ICC field to indicate the invalidation request is complete.Hardware also indicates the granularity
         * at which the invalidation operation was performed through the CAIG field.
         * Software must submit a context-cache invalidation request through this field only when there are no invalidation
         * requests pending at this remapping hardware unit.
         * Since information from the context-cache may be used by hardware to tag IOTLB entries, software must perform
         * domain-selective (or global) invalidation of IOTLB after the context-cache invalidation has completed.
         * Hardware implementations reporting a write-buffer flushing requirement (RWBF=1 in the Capability register) must
         * implicitly perform a write buffer flush before invalidating the context-cache.
         * When Translation Table Mode field in Root Table Address register is not setup as legacy mode (RTADDR_REG.TTM!=00b),
         * hardware will ignore the value provided by software in this register, treat it as an incorrect invalidation request, and
         * report a value of 00b in CAIG field.
         */
        uint64_t invalidate_context_cache : 1;
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_BIT             63
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_FLAG            0x8000000000000000
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_MASK            0x01
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE(_)              (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} vtd_context_command_register;


/**
 * Register to provide the DMA address whose corresponding IOTLB entry needs to be invalidated through the corresponding
 * IOTLB Invalidate register. This register is a write-only register. A value returned on a read of this register is
 * undefined.
 *
 * @remarks IVA_REG
 * @see VTd[10.4.8.2(Invalidate Address Register)]
 */
#define VTD_INVALIDATE_ADDRESS                                       0x00000000
typedef union
{
    struct
    {
        /**
         * @brief Address Mask <b>(WO)</b>
         *
         * [Bits 5:0] The value in this field specifies the number of low order bits of the ADDR field that must be masked for the
         * invalidation operation. This field enables software to request invalidation of contiguous mappings for size-aligned
         * regions.
         * When invalidating mappings for large-pages, software must specify the appropriate mask value. For example, when
         * invalidating mapping for a 2MB page, software must specify an address mask value of at least 9. Hardware implementations
         * report the maximum supported address mask value through the Capability register.
         * A value returned on a read of this field is undefined.
         */
        uint64_t address_mask : 6;
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_BIT                      0
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_FLAG                     0x3F
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_MASK                     0x3F
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK(_)                       (((_) >> 0) & 0x3F)

        /**
         * @brief Invalidation Hint <b>(WO)</b>
         *
         * [Bit 6] The field provides hints to hardware about preserving or flushing the nonleaf (context-entry) entries that may
         * be cached in hardware:
         * * 0: Software may have modified both leaf and non-leaf second-level paging-structure entries corresponding to mappings
         * specified in the ADDR and AM fields. On a page-selective-within-domain invalidation request, hardware must invalidate
         * the cached entries associated with the mappings specified by DID, ADDR and AM fields, in both IOTLB and paging-structure
         * caches.
         * * 1: Software has not modified any second-level non-leaf paging entries associated with the mappings specified by the
         * ADDR and AM fields. On a page-selective-within-domain invalidation request, hardware may preserve the cached
         * second-level mappings in paging-structurecaches.
         * A value returned on a read of this field is undefined.
         */
        uint64_t invalidation_hint : 1;
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_BIT                 6
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_FLAG                0x40
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_MASK                0x01
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT(_)                  (((_) >> 6) & 0x01)
        uint64_t reserved1 : 5;

        /**
         * @brief Address <b>(WO)</b>
         *
         * [Bits 63:12] Software provides the second-level-input-address that needs to be page selectively invalidated. To make a
         * page-selective-within-domain invalidation request to hardware, software must first write the appropriate fields in this
         * register, and then issue the page-selective-within-domain invalidate command through the IOTLB_REG. Hardware ignores
         * bits 63:N, where N is the maximum guest address width (MGAW) supported.
         * A value returned on a read of this field is undefined.
         */
        uint64_t page_address : 52;
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_BIT                      12
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_FLAG                     0xFFFFFFFFFFFFF000
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_MASK                     0xFFFFFFFFFFFFF
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS(_)                       (((_) >> 12) & 0xFFFFFFFFFFFFF)
    };

    uint64_t flags;
} vtd_invalidate_address_register;


/**
 * Register to invalidate IOTLB. The act of writing the upper byte of the IOTLB_REG with the IVT field Set causes the
 * hardware to perform the IOTLB invalidation.
 *
 * @remarks IOTLB_REG
 * @see VTd[10.4.8.1(IOTLB Invalidate Register)]
 */
#define VTD_IOTLB_INVALIDATE                                         0x00000008
typedef union
{
    struct
    {
        uint64_t reserved1 : 32;

        /**
         * @brief Domain-ID <b>(RW)</b>
         *
         * [Bits 47:32] Indicates the ID of the domain whose IOTLB entries need to be selectively invalidated. This field must be
         * programmed by software for domainselective and page-selective invalidation requests.
         * The Capability register reports the domain-id width supported by hardware. Software must ensure that the value written
         * to this field is within this limit. Hardware may ignore and not implement bits 47:(32+N), where N is the supported
         * domain-id width reported in the Capability register.
         */
        uint64_t domain_id : 16;
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_BIT                           32
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_FLAG                          0xFFFF00000000
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_MASK                          0xFFFF
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID(_)                            (((_) >> 32) & 0xFFFF)

        /**
         * @brief Drain Writes <b>(RW)</b>
         *
         * [Bit 48] This field is ignored by hardware if the DWD field is reported as Clear in the Capability register. When the
         * DWD field is reported as Set in the Capability register, the following encodings are supported for this field:
         * * 0: Hardware may complete the IOTLB invalidation without draining DMA write requests.
         * * 1: Hardware must drain relevant translated DMA write requests.
         */
        uint64_t drain_writes : 1;
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_BIT                        48
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_FLAG                       0x1000000000000
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_MASK                       0x01
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES(_)                         (((_) >> 48) & 0x01)

        /**
         * @brief Drain Reads <b>(RW)</b>
         *
         * [Bit 49] This field is ignored by hardware if the DRD field is reported as Clear in the Capability register. When the
         * DRD field is reported as Set in the Capability register, the following encodings are supported for this field:
         * * 0: Hardware may complete the IOTLB invalidation without draining DMA read requests.
         * * 1: Hardware must drain DMA read requests.
         */
        uint64_t drain_reads : 1;
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_BIT                         49
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_FLAG                        0x2000000000000
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_MASK                        0x01
#define VTD_IOTLB_INVALIDATE_DRAIN_READS(_)                          (((_) >> 49) & 0x01)
        uint64_t reserved2 : 7;

        /**
         * @brief IOTLB Actual Invalidation Granularity <b>(RO)</b>
         *
         * [Bits 58:57] Hardware reports the granularity at which an invalidation request was processed through this field when
         * reporting invalidation completion (by clearing the IVT field).
         * The following are the encodings for this field.
         * * 00: Error. This indicates hardware detected an incorrect invalidation request and ignored the request, e.g., register
         * based invalidation when Translation Table Mode (TTM) in Root Table Address Register is not programmed to legacy mode
         * (RTADDR_REG.TTM!=00b), detected an unsupported address mask value in Invalidate Address register for page-selective
         * invalidation requests.
         * On hardware implementations with Major Version 6 or higher (VER_REG), all invalidation requests through this register
         * are treated as incorrect invalidation requests. Software should use the Queued Invalidation interface to perform IOTLB
         * invalidations for such hardware implementations. Refer to Section 6.5 for more details.
         * * 01: Global Invalidation performed. This could be in response to a global, domain-selective, or page-selective
         * invalidation request.
         * * 10: Domain-selective invalidation performed using the domain-id specified by software in the DID field. This could be
         * in response to a domain-selective or a page-selective invalidation request.
         * * 11: Page-selective-within-domain invalidation performed using the address, mask and hint specified by software in the
         * Invalidate Address register and domain-id specified in DID field. This can be in response to a
         * page-selective-within-domain invalidation request.
         */
        uint64_t iotlb_actual_invalidation_granularity : 2;
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_BIT 57
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_FLAG 0x600000000000000
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_MASK 0x03
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY(_) (((_) >> 57) & 0x03)
        uint64_t reserved3 : 1;

        /**
         * @brief IOTLB Invalidation Request Granularity <b>(RW)</b>
         *
         * [Bits 61:60] When requesting hardware to invalidate the IOTLB (by setting the IVT field), software writes the requested
         * invalidation granularity through this field. The following are the encodings for the field.
         * * 00: Reserved.
         * * 01: Global invalidation request.
         * * 10: Domain-selective invalidation request. The target domain-id must be specified in the DID field.
         * * 11: Page-selective-within-domain invalidation request. The target address, mask, and invalidation hint must be
         * specified in the Invalidate Address register, and the domain-id must be provided in the DID field.
         * Hardware implementations may process an invalidation request by performing invalidation at a coarser granularity than
         * requested. Hardware indicates completion of the invalidation request by clearing the IVT field. At that time, the
         * granularity at which actual invalidation was performed is reported through the IAIG field.
         */
        uint64_t iotlb_invalidation_request_granularity : 2;
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_BIT 60
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_FLAG 0x3000000000000000
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_MASK 0x03
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY(_) (((_) >> 60) & 0x03)
        uint64_t reserved4 : 1;

        /**
         * @brief Invalidate IOTLB <b>(RW)</b>
         *
         * [Bit 63] Software requests IOTLB invalidation by setting this field. Software must also set the requested invalidation
         * granularity by programming the IIRG field.
         * Hardware clears the IVT field to indicate the invalidation request is complete. Hardware also indicates the granularity
         * at which the invalidation operation was performed through the IAIG field. Software must not submit another invalidation
         * request through this register while the IVT field is Set, nor update the associated Invalidate Address register.
         * Software must not submit IOTLB invalidation requests when there is a context-cache invalidation request pending at this
         * remapping hardware unit.
         * Hardware implementations reporting a write-buffer flushing requirement (RWBF=1 in Capability register) must implicitly
         * perform a write buffer flushing before invalidating the IOTLB. Refer to Section 6.8 for write buffer flushing
         * requirements.
         * When Translation Table Mode field in Root Table Address registers is not setup as legacy mode (RTADDR_REG.TTM!=00b),
         * hardware will ignore the value provided by software in this register, treat it as an incorrect invalidation request, and
         * report a value of 00b in IAIG field.
         */
        uint64_t invalidate_iotlb : 1;
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_BIT                    63
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_FLAG                   0x8000000000000000
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_MASK                   0x01
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB(_)                     (((_) >> 63) & 0x01)
    };

    uint64_t flags;
} vtd_iotlb_invalidate_register;

/**
 * @}
 */

typedef union
{
    struct
    {
        /**
         * [Bit 0] This bit 0 must be 1. An attempt to write 0 to this bit causes a general-protection exception.
         */
        uint64_t x87 : 1;
#define XCR0_X87_BIT                                                 0
#define XCR0_X87_FLAG                                                0x01
#define XCR0_X87_MASK                                                0x01
#define XCR0_X87(_)                                                  (((_) >> 0) & 0x01)

        /**
         * [Bit 1] If 1, the XSAVE feature set can be used to manage MXCSR and the XMM registers (XMM0-XMM15 in 64-bit mode;
         * otherwise XMM0-XMM7).
         */
        uint64_t sse : 1;
#define XCR0_SSE_BIT                                                 1
#define XCR0_SSE_FLAG                                                0x02
#define XCR0_SSE_MASK                                                0x01
#define XCR0_SSE(_)                                                  (((_) >> 1) & 0x01)

        /**
         * [Bit 2] If 1, AVX instructions can be executed and the XSAVE feature set can be used to manage the upper halves of the
         * YMM registers (YMM0-YMM15 in 64-bit mode; otherwise YMM0-YMM7).
         */
        uint64_t avx : 1;
#define XCR0_AVX_BIT                                                 2
#define XCR0_AVX_FLAG                                                0x04
#define XCR0_AVX_MASK                                                0x01
#define XCR0_AVX(_)                                                  (((_) >> 2) & 0x01)

        /**
         * [Bit 3] If 1, MPX instructions can be executed and the XSAVE feature set can be used to manage the bounds registers
         * BND0-BND3.
         */
        uint64_t bndreg : 1;
#define XCR0_BNDREG_BIT                                              3
#define XCR0_BNDREG_FLAG                                             0x08
#define XCR0_BNDREG_MASK                                             0x01
#define XCR0_BNDREG(_)                                               (((_) >> 3) & 0x01)

        /**
         * [Bit 4] If 1, MPX instructions can be executed and the XSAVE feature set can be used to manage the BNDCFGU and BNDSTATUS
         * registers.
         */
        uint64_t bndcsr : 1;
#define XCR0_BNDCSR_BIT                                              4
#define XCR0_BNDCSR_FLAG                                             0x10
#define XCR0_BNDCSR_MASK                                             0x01
#define XCR0_BNDCSR(_)                                               (((_) >> 4) & 0x01)

        /**
         * [Bit 5] If 1, AVX-512 instructions can be executed and the XSAVE feature set can be used to manage the opmask registers
         * k0-k7.
         */
        uint64_t opmask : 1;
#define XCR0_OPMASK_BIT                                              5
#define XCR0_OPMASK_FLAG                                             0x20
#define XCR0_OPMASK_MASK                                             0x01
#define XCR0_OPMASK(_)                                               (((_) >> 5) & 0x01)

        /**
         * [Bit 6] If 1, AVX-512 instructions can be executed and the XSAVE feature set can be used to manage the upper halves of
         * the lower ZMM registers (ZMM0-ZMM15 in 64-bit mode; otherwise ZMM0-ZMM7).
         */
        uint64_t zmm_hi256 : 1;
#define XCR0_ZMM_HI256_BIT                                           6
#define XCR0_ZMM_HI256_FLAG                                          0x40
#define XCR0_ZMM_HI256_MASK                                          0x01
#define XCR0_ZMM_HI256(_)                                            (((_) >> 6) & 0x01)

        /**
         * [Bit 7] If 1, AVX-512 instructions can be executed and the XSAVE feature set can be used to manage the upper ZMM
         * registers (ZMM16-ZMM31, oonly in 64-bit mode).
         */
        uint64_t zmm_hi16 : 1;
#define XCR0_ZMM_HI16_BIT                                            7
#define XCR0_ZMM_HI16_FLAG                                           0x80
#define XCR0_ZMM_HI16_MASK                                           0x01
#define XCR0_ZMM_HI16(_)                                             (((_) >> 7) & 0x01)
        uint64_t reserved1 : 1;

        /**
         * [Bit 9] If 1, the XSAVE feature set can be used to manage the PKRU register.
         */
        uint64_t pkru : 1;
#define XCR0_PKRU_BIT                                                9
#define XCR0_PKRU_FLAG                                               0x200
#define XCR0_PKRU_MASK                                               0x01
#define XCR0_PKRU(_)                                                 (((_) >> 9) & 0x01)
        uint64_t reserved2 : 54;
    };

    uint64_t flags;
} xcr0;

/**
 * @}
 */

#if defined(_MSC_EXTENSIONS)
#pragma warning(pop)
#endif

```

`hyperv-attachment/hyperv-attachment.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{13a77c37-9bb2-445d-8e81-9687e455c2e6}</ProjectGuid>
    <RootNamespace>hypervattachment</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <IncludePath>$(SolutionDir)shared;$(ProjectDir)ext;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <IncludePath>$(SolutionDir)shared;$(ProjectDir)ext;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;HYPERVATTACHMENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;HYPERVATTACHMENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;HYPERVATTACHMENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <ForcedIncludeFiles>$(ProjectDir)src\arch_config.h</ForcedIncludeFiles>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>entry_point</EntryPointSymbol>
      <AdditionalOptions>/NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;HYPERVATTACHMENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <ForcedIncludeFiles>$(ProjectDir)src\arch_config.h</ForcedIncludeFiles>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>entry_point</EntryPointSymbol>
      <AdditionalOptions>/NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\apic\apic.cpp" />
    <ClCompile Include="src\arch\arch.cpp" />
    <ClCompile Include="src\crt\crt.cpp" />
    <ClCompile Include="src\hypercall\hypercall.cpp" />
    <ClCompile Include="src\interrupts\interrupts.cpp" />
    <ClCompile Include="src\logs\logs.cpp" />
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\memory_manager\heap_manager.cpp" />
    <ClCompile Include="src\memory_manager\memory_manager.cpp" />
    <ClCompile Include="src\slat\hook\amd_page_split.cpp" />
    <ClCompile Include="src\slat\hook\hook.cpp" />
    <ClCompile Include="src\slat\hook\hook_entry.cpp" />
    <ClCompile Include="src\slat\slat.cpp" />
    <ClCompile Include="src\slat\cr3\cr3.cpp" />
    <ClCompile Include="src\slat\cr3\deep_copy.cpp" />
    <ClCompile Include="src\slat\cr3\pte.cpp" />
    <ClCompile Include="src\slat\violation\violation.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\apic\apic.h" />
    <ClInclude Include="src\apic\apic_def.h" />
    <ClInclude Include="src\apic\apic_intrin.h" />
    <ClInclude Include="src\arch\amd_def.h" />
    <ClInclude Include="src\arch_config.h" />
    <ClInclude Include="ext\ia32-doc\ia32.hpp" />
    <ClInclude Include="src\arch\arch.h" />
    <ClInclude Include="src\crt\crt.h" />
    <ClInclude Include="src\hypercall\hypercall.h" />
    <ClInclude Include="src\interrupts\interrupts.h" />
    <ClInclude Include="src\logs\logs.h" />
    <ClInclude Include="src\memory_manager\heap_manager.h" />
    <ClInclude Include="src\memory_manager\memory_manager.h" />
    <ClInclude Include="src\slat\hook\amd_page_split.h" />
    <ClInclude Include="src\slat\hook\hook_entry.h" />
    <ClInclude Include="src\slat\hook\hook.h" />
    <ClInclude Include="src\slat\slat.h" />
    <ClInclude Include="src\slat\cr3\cr3.h" />
    <ClInclude Include="src\slat\cr3\deep_copy.h" />
    <ClInclude Include="src\slat\slat_def.h" />
    <ClInclude Include="src\slat\cr3\pte.h" />
    <ClInclude Include="src\slat\violation\violation.h" />
    <ClInclude Include="src\structures\virtual_address.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\interrupts\interrupt_entry.asm" />
    <MASM Include="src\slat\cr3\intel_invept.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`hyperv-attachment/hyperv-attachment.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\arch\arch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\slat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\memory_manager\memory_manager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\crt\crt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\hypercall\hypercall.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\memory_manager\heap_manager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\logs\logs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\apic\apic.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\interrupts\interrupts.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\violation\violation.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\cr3\cr3.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\cr3\deep_copy.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\cr3\pte.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\hook\amd_page_split.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\hook\hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\slat\hook\hook_entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ext\ia32-doc\ia32.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\arch\arch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\slat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\structures\virtual_address.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\memory_manager\memory_manager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\crt\crt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\hypercall\hypercall.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\memory_manager\heap_manager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\logs\logs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\arch_config.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\apic\apic.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\apic\apic_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\apic\apic_intrin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\interrupts\interrupts.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\arch\amd_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\violation\violation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\cr3\cr3.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\cr3\deep_copy.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\slat_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\cr3\pte.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\hook\amd_page_split.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\hook\hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\slat\hook\hook_entry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\slat\cr3\intel_invept.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="src\interrupts\interrupt_entry.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`hyperv-attachment/src/apic/apic.cpp`:

```cpp
#include "apic.h"
#include "apic_intrin.h"

#include "../memory_manager/memory_manager.h"

constexpr uint64_t needed_apic_class_instance_size = sizeof(xapic_t) < sizeof(x2apic_t) ? sizeof(x2apic_t) : sizeof(xapic_t);

#ifdef APIC_RUNTIME_INSTANCE_ALLOCATION
// allocate_memory and free is up to you to implement
extern void* allocate_memory(uint64_t size);
extern void free_memory(void* p, uint64_t size);
#else
static char apic_class_instance_allocation[needed_apic_class_instance_size] = { };
#endif

cpuid_01_t perform_cpuid_01()
{
	cpuid_01_t cpuid_01;

	apic::intrin::cpuid(reinterpret_cast<int32_t*>(&cpuid_01), 1);

	return cpuid_01;
}

uint8_t apic_t::enable(const uint8_t use_x2apic)
{
	apic_base_t apic_base = read_apic_base();

	if (apic_base.apic_pfn == 0)
	{
		apic_base.apic_pfn = 0xFEE00;
	}

	apic_base.is_apic_globally_enabled = 1;
	apic_base.is_x2apic = use_x2apic;

	apic::intrin::wrmsr(apic::apic_base_msr, apic_base.flags);

	return 1;
}

uint8_t apic_t::is_any_enabled(const apic_base_t apic_base)
{
	return apic_base.is_apic_globally_enabled;
}

uint8_t apic_t::is_x2apic_enabled(const apic_base_t apic_base)
{
	return is_any_enabled(apic_base) == 1 && apic_base.is_x2apic == 1;
}

apic_base_t apic_t::read_apic_base()
{
	return { .flags = apic::intrin::rdmsr(apic::apic_base_msr) };
}

uint32_t apic_t::current_apic_id()
{
	const cpuid_01_t cpuid_01 = perform_cpuid_01();
	
	return cpuid_01.ebx.initial_apic_id;
}

uint8_t apic_t::is_x2apic_supported()
{
	const cpuid_01_t cpuid_01 = perform_cpuid_01();

	return cpuid_01.ecx.x2apic_supported == 1;
}

apic_full_icr_t apic_t::make_base_icr(const uint32_t vector, const icr_delivery_mode_t delivery_mode, const icr_destination_mode_t destination_mode)
{
	apic_full_icr_t icr = { };

	icr.low.vector = vector;
	icr.low.delivery_mode = delivery_mode;
	icr.low.destination_mode = destination_mode;
	icr.low.trigger_mode = icr_trigger_mode_t::edge;
	icr.low.level = icr_level_t::assert;

	return icr;
}

void apic_t::send_ipi(const uint32_t vector, const uint32_t apic_id, const uint8_t is_lowest_priority)
{
	const icr_delivery_mode_t delivery_mode = is_lowest_priority == 1 ? icr_delivery_mode_t::lowest_priority : icr_delivery_mode_t::fixed;

	apic_full_icr_t icr = make_base_icr(vector, delivery_mode, icr_destination_mode_t::physical);

	set_icr_longhand_destination(icr, apic_id);
	write_icr(icr);
}

void apic_t::send_ipi(const uint32_t vector, const icr_destination_shorthand_t destination_shorthand, const uint8_t is_lowest_priority)
{
	const icr_delivery_mode_t delivery_mode = is_lowest_priority == 1 ? icr_delivery_mode_t::lowest_priority : icr_delivery_mode_t::fixed;

	apic_full_icr_t icr = make_base_icr(vector, delivery_mode, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	write_icr(icr);
}

void apic_t::send_nmi(const uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::nmi, icr_destination_mode_t::physical);

	set_icr_longhand_destination(icr, apic_id);
	write_icr(icr);
}

void apic_t::send_nmi(const icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::nmi, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	write_icr(icr);
}

void apic_t::send_smi(const uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::smi, icr_destination_mode_t::physical);

	set_icr_longhand_destination(icr, apic_id);
	write_icr(icr);
}

void apic_t::send_smi(const icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::smi, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	write_icr(icr);
}

void apic_t::send_init_ipi(const uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::init, icr_destination_mode_t::physical);

	set_icr_longhand_destination(icr, apic_id);
	write_icr(icr);
}

void apic_t::send_init_ipi(const icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::init, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	write_icr(icr);
}

void apic_t::send_startup_ipi(const uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::start_up, icr_destination_mode_t::physical);

	set_icr_longhand_destination(icr, apic_id);
	write_icr(icr);
}

void apic_t::send_startup_ipi(const icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::start_up, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	write_icr(icr);
}

void* apic_t::operator new(const uint64_t size, void* const p)
{
	(void)size;

	return p;
}

void apic_t::operator delete(void* const p, const uint64_t size)
{
#ifdef APIC_RUNTIME_INSTANCE_ALLOCATION
	free_memory(p, size);
#else
	(void)p;
	(void)size;
#endif
}

xapic_t::xapic_t()
{
	const apic_base_t apic_base = read_apic_base();

	if (apic_base.flags != 0)
	{
		const uint64_t apic_physical_address = apic_base.apic_pfn << 12;

		mapped_base_ = static_cast<uint8_t*>(memory_manager::map_host_physical(apic_physical_address));
	}
}

uint32_t xapic_t::do_read(const uint16_t offset) const
{
	if (mapped_base_ == nullptr)
	{
		return 0;
	}

	return *reinterpret_cast<uint32_t*>(mapped_base_ + offset);
}

void xapic_t::do_write(const uint16_t offset, const uint32_t value) const
{
	if (mapped_base_ != nullptr)
	{
		*reinterpret_cast<uint32_t*>(mapped_base_ + offset) = value;
	}
}

void xapic_t::write_icr(const apic_full_icr_t icr)
{
	constexpr uint16_t xapic_icr = apic::icr.xapic();

	do_write(xapic_icr, icr.low.flags);
	do_write(xapic_icr + 0x10, icr.high.flags);
}

void xapic_t::set_icr_longhand_destination(apic_full_icr_t& icr, const uint32_t destination)
{
	icr.high.xapic.destination_field = destination;
}

uint64_t x2apic_t::do_read(const uint32_t msr)
{
	return apic::intrin::rdmsr(msr);
}

void x2apic_t::do_write(const uint32_t msr, const  uint64_t value)
{
	apic::intrin::wrmsr(msr, value);
}

void x2apic_t::write_icr(const apic_full_icr_t icr)
{
	do_write(apic::icr.x2apic(), icr.flags);
}

void x2apic_t::set_icr_longhand_destination(apic_full_icr_t& icr, const uint32_t destination)
{
	icr.high.x2apic.destination_field = destination;
}

void apic_t::write_icr(const apic_full_icr_t icr)
{
	(void)icr;
}

void apic_t::set_icr_longhand_destination(apic_full_icr_t& icr, const uint32_t destination)
{
	(void)icr;
	(void)destination;
}

apic_t* apic_t::create_instance()
{
#ifdef APIC_RUNTIME_INSTANCE_ALLOCATION
	void* apic_allocation = allocate_memory(needed_apic_class_instance_size);
#else
	static uint8_t has_used_allocation = 0;

	if (has_used_allocation != 0)
	{
		return nullptr;
	}

	has_used_allocation = 1;

	void* const apic_allocation = &apic_class_instance_allocation;
#endif

	const apic_base_t apic_base = read_apic_base();

	const uint8_t is_any_apic_enabled = is_any_enabled(apic_base);

	uint8_t use_x2apic;

	if (is_any_apic_enabled == 1)
	{
		use_x2apic = is_x2apic_enabled(apic_base);
	}
	else
	{
		use_x2apic = is_x2apic_supported();

		enable(use_x2apic);
	}

	apic_t* apic = nullptr;

	if (use_x2apic == 1)
	{
		apic = new (apic_allocation) x2apic_t();
	}
	else
	{
		apic = new (apic_allocation) xapic_t();
	}

	return apic;
}


```

`hyperv-attachment/src/apic/apic.h`:

```h
#pragma once
#include "apic_def.h"

// if you want apic_t::create_instance to use runtime memory allocation for the instance(s) it creates
// then make sure to #define APIC_RUNTIME_INSTANCE_ALLOCATION

class apic_t
{
public:
	apic_t() = default;

	// not = 0 as this is meant to work without crt (and we'd need to define _purecall ourselves)
	virtual void write_icr(apic_full_icr_t icr);
	virtual void set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination);

	void send_ipi(uint32_t vector, uint32_t apic_id, uint8_t is_lowest_priority = 0);
	void send_ipi(uint32_t vector, icr_destination_shorthand_t destination_shorthand, uint8_t is_lowest_priority = 0);

	void send_nmi(uint32_t apic_id);
	void send_nmi(icr_destination_shorthand_t destination_shorthand);

	void send_smi(uint32_t apic_id);
	void send_smi(icr_destination_shorthand_t destination_shorthand);

	void send_init_ipi(uint32_t apic_id);
	void send_init_ipi(icr_destination_shorthand_t destination_shorthand);

	void send_startup_ipi(uint32_t apic_id);
	void send_startup_ipi(icr_destination_shorthand_t destination_shorthand);

	void* operator new(uint64_t size, void* p);
	void operator delete(void* p, uint64_t size);

	static apic_t* create_instance();

	static uint8_t enable(uint8_t use_x2apic);
	static uint8_t is_any_enabled(apic_base_t apic_base);
	static uint8_t is_x2apic_enabled(apic_base_t apic_base);

	static uint32_t current_apic_id();
	static uint8_t is_x2apic_supported();

	static apic_base_t read_apic_base();

	static apic_full_icr_t make_base_icr(uint32_t vector, icr_delivery_mode_t delivery_mode, icr_destination_mode_t destination_mode);
};

class xapic_t : public apic_t
{
protected:
	uint8_t* mapped_base_ = nullptr;

	uint32_t do_read(uint16_t offset) const;
	void do_write(uint16_t offset, uint32_t value) const;

public:
	xapic_t();

	void write_icr(apic_full_icr_t icr) override;
	void set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination) override;
};

class x2apic_t : public apic_t
{
protected:
	static uint64_t do_read(uint32_t msr);
	static void do_write(uint32_t msr, uint64_t value);

public:
	x2apic_t() {};

	void write_icr(apic_full_icr_t icr) override;
	void set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination) override;
};

```

`hyperv-attachment/src/apic/apic_def.h`:

```h
#pragma once

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

enum class icr_delivery_mode_t : uint32_t
{
	fixed = 0b000,
	lowest_priority = 0b001,
	smi = 0b101,
	nmi = 0b100,
	init = 0b101,
	start_up = 0b110
};

enum class icr_destination_mode_t : uint32_t
{
	physical = 0b0,
	logical = 0b1
};

enum class icr_delivery_status_t : uint32_t
{
	idle = 0b0,
	send_pending = 0b1
};

enum class icr_level_t : uint32_t
{
	de_assert = 0b0,
	assert = 0b1
};

enum class icr_trigger_mode_t : uint32_t
{
	edge = 0b0,
	level = 0b1
};

enum class icr_destination_shorthand_t : uint32_t
{
	no_shorthand = 0b00,
	self = 0b01,
	all_including_self = 0b10,
	all_but_self = 0b11
};

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4201)
#endif

// Intel SDM Volume 3: 12.6.1 Interrupt Command Register (ICR)
union apic_icr_low_t
{
	uint32_t flags;

	struct
	{
		uint32_t vector : 8;
		icr_delivery_mode_t delivery_mode : 3;
		icr_destination_mode_t destination_mode : 1;
		icr_delivery_status_t delivery_status : 1;
		uint32_t reserved1 : 1;
		icr_level_t level : 1;
		icr_trigger_mode_t trigger_mode : 1;
		uint32_t reserved2 : 2;
		icr_destination_shorthand_t destination_shorthand : 2;
		uint32_t reserved3 : 10;
	};
};

union apic_icr_high_t
{
	uint32_t flags;

	struct
	{
		uint32_t reserved1 : 24;
		uint32_t destination_field : 8;
	} xapic;

	struct
	{
		uint32_t destination_field : 32;
	} x2apic;
};

union apic_full_icr_t
{
	uint64_t flags;

	struct
	{
		apic_icr_low_t low;
		apic_icr_high_t high;
	};
};

// END OF SDM SUBCHAPTER

// Intel SDM Volume 3: 12.4.4 Local APIC Status and Location
union apic_base_t
{
	uint64_t flags;

	struct
	{
		uint64_t reserved1 : 8;
		uint64_t is_boot_strap_processor : 1;
		uint64_t reserved2 : 1;
		uint64_t is_x2apic : 1;
		uint64_t is_apic_globally_enabled : 1; // permanent until reset
		uint64_t apic_pfn : 24; // apply left shift of 12
		uint64_t reserved3 : 28;
	};
};

// END OF SDM SUBCHAPTER

struct cpuid_01_t
{
	uint32_t eax;

	struct
	{
		uint32_t reserved1 : 24;
		uint32_t initial_apic_id : 8;
	} ebx;

	struct
	{
		uint32_t reserved1 : 21;
		uint32_t x2apic_supported : 1;
		uint32_t reserved2 : 10;
	} ecx;

	uint32_t edx;
};

class apic_field_t
{
public:
	explicit constexpr apic_field_t(const uint16_t xapic_offset)
			:	xapic_offset_(xapic_offset) {}

	[[nodiscard]] constexpr uint16_t xapic() const
	{
		return xapic_offset_;
	}

	[[nodiscard]] constexpr uint16_t x2apic() const
	{
		return 0x800 + (xapic_offset_ / 0x10);
	}

protected:
	const uint16_t xapic_offset_;
};

namespace apic
{
	constexpr uint32_t apic_base_msr = 0x1B;
	constexpr apic_field_t icr(0x300);

	namespace intrin
	{
		union parted_uint64_t
		{
			struct
			{
				uint32_t low_part;
				uint32_t high_part;
			};

			uint64_t value;
		};
	}
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif

```

`hyperv-attachment/src/apic/apic_intrin.h`:

```h
#pragma once
#include "apic_def.h"

#if defined(_MSC_VER) && !defined(__clang__)
#define _APIC_INTRIN_IS_PURE_MSVC
#include <intrin.h>
#endif

namespace apic
{
    namespace intrin
    {
        uint64_t rdmsr(const uint32_t msr)
        {
#ifdef _APIC_INTRIN_IS_PURE_MSVC
            return __readmsr(msr);
#else
            parted_uint64_t parted_result = { };

            asm("rdmsr" : "=a"(parted_result.low_part), "=d"(parted_result.high_part) : "c"(msr));

            return parted_result.value;
#endif
        }

        void wrmsr(const uint32_t msr, const uint64_t value)
        {
#ifdef _APIC_INTRIN_IS_PURE_MSVC
            __writemsr(msr, value);
#else
            parted_uint64_t parted_value = { };

            parted_value.value = value;

            asm("wrmsr" :: "c"(msr), "a"(parted_value.low_part), "d"(parted_value.high_part));
#endif
        }

        void cpuid(int32_t info[4], const int32_t leaf)
        {
#ifdef _APIC_INTRIN_IS_PURE_MSVC
            __cpuid(info, leaf);
#else
            asm volatile("cpuid" : "=a"(info[0]), "=b"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(leaf));
#endif
        }
    }
}

```

`hyperv-attachment/src/arch/amd_def.h`:

```h
#pragma once

#ifndef _INTELMACHINE

#include <cstdint>
#include <ia32-doc/ia32.hpp>

#pragma warning(push)
#pragma warning(disable: 4201)

enum class tlb_control_t : std::uint8_t
{
	do_not_flush = 0,
	flush_entire_tlb = 1, // should only be used on legacy hardware
	flush_guest_tlb_entries = 3,
	flush_guest_non_global_tlb_entries = 7,
};

union vmcb_clean_t
{
	std::uint32_t flags;

	struct
	{
		std::uint32_t i : 1;
		std::uint32_t iopm : 1;
		std::uint32_t asid : 1;
		std::uint32_t tpr : 1;
		std::uint32_t nested_paging : 1;
		std::uint32_t cr : 1;
		std::uint32_t dr : 1;
		std::uint32_t dt : 1;
		std::uint32_t seg : 1;
		std::uint32_t cr2 : 1;
		std::uint32_t lbr : 1;
		std::uint32_t avic : 1;
		std::uint32_t cet : 1;
		std::uint32_t reserved : 19;
	};
};

struct vmcb_control_area_t
{
	std::uint8_t pad_one[0xC];
	std::uint32_t intercept_misc_vector_3;
	std::uint8_t pad_two[0x4C];
	tlb_control_t tlb_control;
	std::uint8_t pad_three[0x13];
	std::uint64_t vmexit_reason;
	std::uint64_t first_exit_info;
	std::uint64_t second_exit_info;
	std::uint8_t pad_four[0x28];
	cr3 nested_cr3;
	std::uint8_t pad_five[0x8];
	vmcb_clean_t clean;
	std::uint8_t pad_six[0x4];
	std::uint64_t next_rip;
	std::uint8_t pad_seven[0x330];
};

struct vmcb_state_save_t
{
	std::uint8_t pad_one[0x150];
    std::uint64_t cr3;
    std::uint8_t pad_five[0x20];
    std::uint64_t rip;
    std::uint8_t pad_six[0x58];
    std::uint64_t rsp;
    std::uint8_t pad_seven[0x18];
    std::uint64_t rax;
};

struct vmcb_t
{
	vmcb_control_area_t control;
	vmcb_state_save_t save_state;
};

union npf_exit_info_1
{
	std::uint64_t flags;

	struct
	{
		std::uint64_t present : 1;
		std::uint64_t write_access : 1;
		std::uint64_t user_access : 1;
		std::uint64_t npte_reserved_set : 1;
		std::uint64_t execute_access : 1;
		std::uint64_t reserved_one : 1;
		std::uint64_t shadow_stack_access : 1;
		std::uint64_t reserved_two : 25;
		std::uint64_t final_gpa_translation : 1;
		std::uint64_t gpt_translation : 1;
		std::uint64_t reserved_three : 3;
		std::uint64_t supervisor_shadow_stack : 1;
		std::uint64_t reserved_four : 26;
	};
};

#pragma warning(pop)

#define SVM_EXIT_REASON_PHYSICAL_NMI 0x61
#define SVM_EXIT_REASON_CPUID 0x72
#define SVM_EXIT_REASON_NPF 0x400

#endif

```

`hyperv-attachment/src/arch/arch.cpp`:

```cpp
#include "arch.h"
#include "../crt/crt.h"

#include <intrin.h>

#ifdef _INTELMACHINE
#include <ia32-doc/ia32.hpp>

std::uint64_t vmread(const std::uint64_t field)
{
	std::uint64_t value = 0;

	__vmx_vmread(field, &value);

	return value;
}

void vmwrite(const std::uint64_t field, const std::uint64_t value)
{
	__vmx_vmwrite(field, value);
}

std::uint64_t get_vmexit_instruction_length()
{
	return vmread(VMCS_VMEXIT_INSTRUCTION_LENGTH);
}

vmx_exit_qualification_ept_violation arch::get_exit_qualification()
{
	return { .flags = vmread(VMCS_EXIT_QUALIFICATION) };
}

std::uint64_t arch::get_guest_physical_address()
{
	return vmread(VMCS_GUEST_PHYSICAL_ADDRESS);
}

#else
std::uint8_t get_vmcb_routine_bytes[27];

typedef vmcb_t*(*get_vmcb_routine_t)();

vmcb_t* arch::get_vmcb()
{
	get_vmcb_routine_t get_vmcb_routine = reinterpret_cast<get_vmcb_routine_t>(&get_vmcb_routine_bytes[0]);

	return get_vmcb_routine();
}

void arch::parse_vmcb_gadget(const std::uint8_t* const get_vmcb_gadget)
{
	constexpr std::uint32_t final_needed_opcode_offset = 23;

	crt::copy_memory(&get_vmcb_routine_bytes[0], get_vmcb_gadget, final_needed_opcode_offset);

	if (get_vmcb_gadget[25] == 8) // needs to be dereffed once more
	{
		constexpr std::uint8_t return_bytes[4] = {
			0x48, 0x8B, 0x00, // mov rax, [rax]
			0xC3 // ret
		};

		crt::copy_memory(&get_vmcb_routine_bytes[final_needed_opcode_offset], &return_bytes[0], sizeof(return_bytes));
	}
	else
	{
		get_vmcb_routine_bytes[final_needed_opcode_offset] = 0xC3;
	}
}
#endif

std::uint64_t arch::get_vmexit_reason()
{
#ifdef _INTELMACHINE
	return vmread(VMCS_EXIT_REASON);
#else
	const vmcb_t* const vmcb = get_vmcb();

	return vmcb->control.vmexit_reason;
#endif
}

std::uint8_t arch::is_cpuid(const std::uint64_t vmexit_reason)
{
#ifdef _INTELMACHINE
	return vmexit_reason == VMX_EXIT_REASON_EXECUTE_CPUID;
#else
	return vmexit_reason == SVM_EXIT_REASON_CPUID;
#endif
}

std::uint8_t arch::is_slat_violation(const std::uint64_t vmexit_reason)
{
#ifdef _INTELMACHINE
	return vmexit_reason == VMX_EXIT_REASON_EPT_VIOLATION;
#else
	return vmexit_reason == SVM_EXIT_REASON_NPF;
#endif
}

std::uint8_t arch::is_non_maskable_interrupt_exit(const std::uint64_t vmexit_reason)
{
#ifdef _INTELMACHINE
	if (vmexit_reason != VMX_EXIT_REASON_EXCEPTION_OR_NMI)
	{
		return 0;
	}

	const std::uint64_t raw_interruption_information = vmread(VMCS_VMEXIT_INTERRUPTION_INFORMATION);

	const vmexit_interrupt_information interrupt_information = { .flags = static_cast<std::uint32_t>(raw_interruption_information) };

	return interrupt_information.interruption_type == interruption_type::non_maskable_interrupt;
#else
	return vmexit_reason == SVM_EXIT_REASON_PHYSICAL_NMI;
#endif
}

cr3 arch::get_guest_cr3()
{
	cr3 guest_cr3;

#ifdef _INTELMACHINE
	guest_cr3.flags = vmread(VMCS_GUEST_CR3);
#else
	const vmcb_t* const vmcb = get_vmcb();

	guest_cr3.flags = vmcb->save_state.cr3;
#endif

	return guest_cr3;
}

cr3 arch::get_slat_cr3()
{
	cr3 slat_cr3;

#ifdef _INTELMACHINE
	slat_cr3.flags = vmread(VMCS_CTRL_EPT_POINTER);
#else
	const vmcb_t* const vmcb = arch::get_vmcb();

	slat_cr3 = vmcb->control.nested_cr3;
#endif

	return slat_cr3;
}

void arch::set_slat_cr3(const cr3 slat_cr3)
{
#ifdef _INTELMACHINE
	vmwrite(VMCS_CTRL_EPT_POINTER, slat_cr3.flags);
#else
	vmcb_t* const vmcb = arch::get_vmcb();

	vmcb->control.nested_cr3 = slat_cr3;
#endif
}

std::uint64_t arch::get_guest_rsp()
{
#ifdef _INTELMACHINE
	return vmread(VMCS_GUEST_RSP);
#else
	const vmcb_t* const vmcb = get_vmcb();

	return vmcb->save_state.rsp;
#endif
}

void arch::set_guest_rsp(const std::uint64_t guest_rsp)
{
#ifdef _INTELMACHINE
	vmwrite(VMCS_GUEST_RSP, guest_rsp);
#else
	vmcb_t* const vmcb = get_vmcb();

	vmcb->save_state.rsp = guest_rsp;
#endif
}

std::uint64_t arch::get_guest_rip()
{
#ifdef _INTELMACHINE
	return vmread(VMCS_GUEST_RIP);
#else
	const vmcb_t* const vmcb = get_vmcb();

	return vmcb->save_state.rip;
#endif
}

void arch::set_guest_rip(const std::uint64_t guest_rip)
{
#ifdef _INTELMACHINE
	vmwrite(VMCS_GUEST_RIP, guest_rip);
#else
	vmcb_t* const vmcb = get_vmcb();

	vmcb->save_state.rip = guest_rip;
#endif
}

void arch::advance_guest_rip()
{
#ifdef _INTELMACHINE
	const std::uint64_t guest_rip = get_guest_rip();
	const std::uint64_t instruction_length = get_vmexit_instruction_length();

	const std::uint64_t next_rip = guest_rip + instruction_length;
#else
	const vmcb_t* const vmcb = get_vmcb();

	const std::uint64_t next_rip = vmcb->control.next_rip;
#endif

	set_guest_rip(next_rip);
}

```

`hyperv-attachment/src/arch/arch.h`:

```h
#pragma once
#include <ia32-doc/ia32.hpp>
#include <cstdint>

#include "amd_def.h"

namespace arch
{
	std::uint64_t get_vmexit_reason();
	std::uint8_t is_cpuid(std::uint64_t vmexit_reason);
	std::uint8_t is_slat_violation(std::uint64_t vmexit_reason);

	std::uint8_t is_non_maskable_interrupt_exit(std::uint64_t vmexit_reason);

	cr3 get_guest_cr3();

	cr3 get_slat_cr3();
	void set_slat_cr3(cr3 slat_cr3);

	std::uint64_t get_guest_rsp();
	void set_guest_rsp(std::uint64_t guest_rsp);

	std::uint64_t get_guest_rip();
	void set_guest_rip(std::uint64_t guest_rip);

	void advance_guest_rip();

#ifdef _INTELMACHINE
	vmx_exit_qualification_ept_violation get_exit_qualification();

	std::uint64_t get_guest_physical_address();
#else
	vmcb_t* get_vmcb();
	void parse_vmcb_gadget(const std::uint8_t* get_vmcb_gadget);
#endif
}

```

`hyperv-attachment/src/arch_config.h`:

```h
#pragma once

// comment out this next line to compile for AMD
#define _INTELMACHINE

```

`hyperv-attachment/src/crt/crt.cpp`:

```cpp
#include "crt.h"
#include <intrin.h>

void crt::copy_memory(void* const destination, const void* const source, const std::uint64_t size)
{
	__movsb(static_cast<std::uint8_t*>(destination), static_cast<const std::uint8_t*>(source), size);
}

void crt::set_memory(void* const destination, const std::uint8_t value, const std::uint64_t size)
{
	__stosb(static_cast<std::uint8_t*>(destination), value, size);
}

void crt::mutex_t::lock()
{
	while (_InterlockedCompareExchange64(&value_, 1, 0) != 0)
	{
		_mm_pause();
	}
}

void crt::mutex_t::release()
{
	_InterlockedExchange64(&value_, 0);
}

void crt::bitmap_t::set_all() const
{
    if (value_ == nullptr)
    {
        return;
    }

    for (size_type i = 0; i < count_; i++)
    {
        value_type& row_state = value_[i];

        row_state = value_max;
    }
}

void crt::bitmap_t::set(const value_type index) const
{
    const pointer target_row = row(index);

    if (target_row == nullptr)
    {
        return;
    }

    const std::uint64_t bit = index % bit_count_in_row;

    *target_row |= 1ull << bit;
}

void crt::bitmap_t::clear(const value_type index) const
{
    const pointer target_row = row(index);

    if (target_row == nullptr)
    {
        return;
    }

    const size_type bit = index % bit_count_in_row;

    *target_row &= ~(1ull << bit);
}

crt::bitmap_t::bit_type crt::bitmap_t::is_set(const value_type index) const
{
    const const_pointer target_row = row(index);

    if (target_row == nullptr)
    {
        return 0;
    }

    const value_type row_value = *target_row;
    const size_type bit = index % bit_count_in_row;

    return (row_value >> bit) & 1;
}

void crt::bitmap_t::set_value(const pointer value)
{
    value_ = value;
}
	
void crt::bitmap_t::set_count(const size_type value_count)
{
    count_ = value_count;
}

crt::bitmap_t::pointer crt::bitmap_t::row(const value_type index) const
{
    if (value_ == nullptr)
    {
        return nullptr;
    }

    const size_type row_id = static_cast<size_type>(index / bit_count_in_row);

    if (count_ <= row_id)
    {
        return nullptr;
    }

    return &value_[row_id];
}

```

`hyperv-attachment/src/crt/crt.h`:

```h
#pragma once
#include <cstdint>

namespace crt
{
	void copy_memory(void* destination, const void* source, std::uint64_t size);
	void set_memory(void* destination, std::uint8_t value, std::uint64_t size);

	template <class T>
	T min(const T a, const T b)
	{
		return (a < b) ? a : b;
	}

	template <class T>
	T max(const T a, const T b)
	{
		return (a < b) ? b : a;
	}

	template <class T>
	T abs(const T n)
	{
		return (n < 0) ? -n : n;
	}

	template <class T>
	void swap(T& a, T& b) noexcept
	{
		const T cache = a;

		a = b;
		b = cache;
	}

	class mutex_t
	{
	public:
		void lock();
		void release();

	protected:
		volatile std::int64_t value_ = 0;
	};

	class bitmap_t
	{
	public:
		using size_type = std::uint64_t;

		using value_type = std::uint64_t;
		using pointer = value_type*;
		using const_pointer = const value_type*;

		using bit_type = std::uint8_t;

		bitmap_t() = default;

		void set_all() const;
		void set(value_type index) const;

		void clear(value_type index) const;

		[[nodiscard]] bit_type is_set(value_type index) const;

		void set_value(pointer value);
		void set_count(size_type value_count);

	protected:
		constexpr static size_type bit_count_in_row = sizeof(value_type) * 8;
		constexpr static value_type value_max = ~static_cast<value_type>(0);

		pointer value_ = nullptr;
		size_type count_ = 0;

		[[nodiscard]] pointer row(value_type index) const;
	};
}

```

`hyperv-attachment/src/hypercall/hypercall.cpp`:

```cpp
#include "hypercall.h"
#include "../memory_manager/memory_manager.h"
#include "../memory_manager/heap_manager.h"

#include "../slat/slat.h"
#include "../slat/cr3/cr3.h"
#include "../slat/hook/hook.h"

#include "../arch/arch.h"
#include "../logs/logs.h"
#include "../crt/crt.h"

#include <ia32-doc/ia32.hpp>
#include <hypercall/hypercall_def.h>

std::uint64_t operate_on_guest_physical_memory(const trap_frame_t* const trap_frame, const memory_operation_t operation)
{
    const cr3 guest_cr3 = arch::get_guest_cr3();
    const cr3 slat_cr3 = slat::hyperv_cr3();

    const std::uint64_t guest_buffer_virtual_address = trap_frame->r8;
    const std::uint64_t guest_physical_address = trap_frame->rdx;

    std::uint64_t size_left_to_copy = trap_frame->r9;

    std::uint64_t bytes_copied = 0;

    while (size_left_to_copy != 0)
    {
        std::uint64_t size_left_of_destination_slat_page = UINT64_MAX;
        std::uint64_t size_left_of_source_slat_page = UINT64_MAX;

        const std::uint64_t guest_buffer_physical_address = memory_manager::translate_guest_virtual_address(guest_cr3, slat_cr3, { .address = guest_buffer_virtual_address + bytes_copied });

        void* host_destination = memory_manager::map_guest_physical(slat_cr3, guest_buffer_physical_address, &size_left_of_destination_slat_page);
        void* host_source = memory_manager::map_guest_physical(slat_cr3, guest_physical_address + bytes_copied, &size_left_of_source_slat_page);

        if (size_left_of_destination_slat_page == UINT64_MAX || size_left_of_source_slat_page == UINT64_MAX)
        {
            break;
        }

        if (operation == memory_operation_t::write_operation)
        {
            crt::swap(host_source, host_destination);
        }

        const std::uint64_t size_left_of_slat_pages = crt::min(size_left_of_source_slat_page, size_left_of_destination_slat_page);

        const std::uint64_t copy_size = crt::min(size_left_to_copy, size_left_of_slat_pages);

        if (copy_size == 0)
        {
            break;
        }

        crt::copy_memory(host_destination, host_source, copy_size);

        size_left_to_copy -= copy_size;
        bytes_copied += copy_size;
    }

    return bytes_copied;
}

std::uint64_t operate_on_guest_virtual_memory(const trap_frame_t* const trap_frame, const memory_operation_t operation, const std::uint64_t address_of_page_directory)
{
    const cr3 guest_source_cr3 = { .address_of_page_directory = address_of_page_directory };

    const cr3 guest_destination_cr3 = arch::get_guest_cr3();
    const cr3 slat_cr3 = slat::hyperv_cr3();

    const std::uint64_t guest_destination_virtual_address = trap_frame->rdx;
    const  std::uint64_t guest_source_virtual_address = trap_frame->r8;

    std::uint64_t size_left_to_read = trap_frame->r9;

    std::uint64_t bytes_copied = 0;

    while (size_left_to_read != 0)
    {
        std::uint64_t size_left_of_destination_virtual_page = UINT64_MAX;
        std::uint64_t size_left_of_destination_slat_page = UINT64_MAX;

        std::uint64_t size_left_of_source_virtual_page = UINT64_MAX;
        std::uint64_t size_left_of_source_slat_page = UINT64_MAX;

        const std::uint64_t guest_source_physical_address = memory_manager::translate_guest_virtual_address(guest_source_cr3, slat_cr3, { .address = guest_source_virtual_address + bytes_copied }, &size_left_of_source_virtual_page);
        const std::uint64_t guest_destination_physical_address = memory_manager::translate_guest_virtual_address(guest_destination_cr3, slat_cr3, { .address = guest_destination_virtual_address + bytes_copied }, &size_left_of_destination_virtual_page);

        if (size_left_of_destination_virtual_page == UINT64_MAX || size_left_of_source_virtual_page == UINT64_MAX)
        {
            break;
        }

        void* host_destination = memory_manager::map_guest_physical(slat_cr3, guest_destination_physical_address, &size_left_of_destination_slat_page);
        void* host_source = memory_manager::map_guest_physical(slat_cr3, guest_source_physical_address, &size_left_of_source_slat_page);

    	if (size_left_of_destination_slat_page == UINT64_MAX || size_left_of_source_slat_page == UINT64_MAX)
        {
            break;
        }

        if (operation == memory_operation_t::write_operation)
        {
            crt::swap(host_source, host_destination);
        }

        const std::uint64_t size_left_of_slat_pages = crt::min(size_left_of_source_slat_page, size_left_of_destination_slat_page);
        const std::uint64_t size_left_of_virtual_pages = crt::min(size_left_of_source_virtual_page, size_left_of_destination_virtual_page);

        const std::uint64_t size_left_of_pages = crt::min(size_left_of_slat_pages, size_left_of_virtual_pages);

        const std::uint64_t copy_size = crt::min(size_left_to_read, size_left_of_pages);

        if (copy_size == 0)
        {
            break;
        }

        crt::copy_memory(host_destination, host_source, copy_size);

        size_left_to_read -= copy_size;
        bytes_copied += copy_size;
    }

    return bytes_copied;
}

std::uint8_t copy_stack_data_from_log_exit(std::uint64_t* const stack_data, const std::uint64_t stack_data_count, const cr3 guest_cr3, const std::uint64_t rsp)
{
    if (rsp == 0)
    {
        return 0;
    }

    const cr3 slat_cr3 = slat::hyperv_cr3();

    std::uint64_t bytes_read = 0;
    std::uint64_t bytes_remaining = stack_data_count * sizeof(std::uint64_t);

    while (bytes_remaining != 0)
    {
        std::uint64_t virtual_size_left = 0;

        const std::uint64_t rsp_guest_physical_address = memory_manager::translate_guest_virtual_address(guest_cr3, slat_cr3, { .address = rsp + bytes_read }, &virtual_size_left);

        if (rsp_guest_physical_address == 0)
        {
            return 0;
        }

        std::uint64_t physical_size_left = 0;

        // rcx has just been pushed onto stack
        const auto rsp_mapped = static_cast<const std::uint64_t*>(memory_manager::map_guest_physical(slat_cr3, rsp_guest_physical_address, &physical_size_left));

        const std::uint64_t size_left_of_page = crt::min(physical_size_left, virtual_size_left);
        const std::uint64_t size_to_read = crt::min(bytes_remaining, size_left_of_page);

        if (size_to_read == 0)
        {
            return 0;
        }

        crt::copy_memory(reinterpret_cast<std::uint8_t*>(stack_data) + bytes_read, reinterpret_cast<const std::uint8_t*>(rsp_mapped) + bytes_read, size_to_read);

        bytes_remaining -= size_to_read;
        bytes_read += size_to_read;
    }

    return 1;
}

void do_stack_data_copy(trap_frame_log_t& trap_frame, const cr3 guest_cr3)
{
    constexpr std::uint64_t stack_data_count = trap_frame_log_stack_data_count + 1;

    std::uint64_t stack_data[stack_data_count] = { };

    copy_stack_data_from_log_exit(&stack_data[0], stack_data_count, guest_cr3, trap_frame.rsp);

    crt::copy_memory(&trap_frame.stack_data, &stack_data[1], sizeof(trap_frame.stack_data));

    trap_frame.rcx = stack_data[0];
    trap_frame.rsp += 8; // get rid of the rcx value we push onto stack ourselves
}

void log_current_state(trap_frame_log_t trap_frame)
{
    cr3 guest_cr3 = arch::get_guest_cr3();

    do_stack_data_copy(trap_frame, guest_cr3);

    trap_frame.cr3 = guest_cr3.flags;
    trap_frame.rip = arch::get_guest_rip();

    logs::add_log(trap_frame);
}

std::uint64_t flush_logs(const trap_frame_t* const trap_frame)
{
    std::uint64_t stored_logs_count = logs::stored_log_index;

    const cr3 guest_cr3 = arch::get_guest_cr3();
    const cr3 slat_cr3 = slat::hyperv_cr3();

    const std::uint64_t guest_virtual_address = trap_frame->rdx;
    const std::uint16_t count = static_cast<std::uint16_t>(trap_frame->r8);

    if (logs::flush(slat_cr3, guest_virtual_address, guest_cr3, count) == 0)
    {
        return -1;
    }

    return stored_logs_count;
}

void hypercall::process(const hypercall_info_t hypercall_info, trap_frame_t* const trap_frame)
{
    switch (hypercall_info.call_type)
    {
    case hypercall_type_t::guest_physical_memory_operation:
    {
        const auto memory_operation = static_cast<memory_operation_t>(hypercall_info.call_reserved_data);

        trap_frame->rax = operate_on_guest_physical_memory(trap_frame, memory_operation);

        break;
    }
    case hypercall_type_t::guest_virtual_memory_operation:
    {
        const virt_memory_op_hypercall_info_t virt_memory_op_info = { .value = hypercall_info.value };

        const memory_operation_t memory_operation = virt_memory_op_info.memory_operation;
        const std::uint64_t address_of_page_directory = virt_memory_op_info.address_of_page_directory;

        trap_frame->rax = operate_on_guest_virtual_memory(trap_frame, memory_operation, address_of_page_directory);

        break;
    }
    case hypercall_type_t::translate_guest_virtual_address:
    {
        const virtual_address_t guest_virtual_address = { .address = trap_frame->rdx };

        const cr3 target_guest_cr3 = { .flags = trap_frame->r8 };
        const cr3 slat_cr3 = slat::hyperv_cr3();

        trap_frame->rax = memory_manager::translate_guest_virtual_address(target_guest_cr3, slat_cr3, guest_virtual_address);

        break;
    }
    case hypercall_type_t::read_guest_cr3:
    {
        const cr3 guest_cr3 = arch::get_guest_cr3();

        trap_frame->rax = guest_cr3.flags;

        break;
    }
    case hypercall_type_t::add_slat_code_hook:
    {
        const virtual_address_t target_guest_physical_address = { .address = trap_frame->rdx };
        const virtual_address_t shadow_page_guest_physical_address = { .address = trap_frame->r8 };

        trap_frame->rax = slat::hook::add(target_guest_physical_address, shadow_page_guest_physical_address);

        break;
    }
    case hypercall_type_t::remove_slat_code_hook:
    {
        const virtual_address_t target_guest_physical_address = { .address = trap_frame->rdx };

        trap_frame->rax = slat::hook::remove(target_guest_physical_address);

        break;
    }
    case hypercall_type_t::hide_guest_physical_page:
    {
        const virtual_address_t target_guest_physical_address = { .address = trap_frame->rdx };

        trap_frame->rax = slat::hide_physical_page_from_guest(target_guest_physical_address);

        break;
    }
    case hypercall_type_t::log_current_state:
    {
        trap_frame_log_t trap_frame_log;

        crt::copy_memory(&trap_frame_log, trap_frame, sizeof(trap_frame_t));

        log_current_state(trap_frame_log);

        break;
    }
    case hypercall_type_t::flush_logs:
    {
        trap_frame->rax = flush_logs(trap_frame);

        break;
    }
    case hypercall_type_t::get_heap_free_page_count:
    {
        trap_frame->rax = heap_manager::get_free_page_count();

        break;
    }
    default:
        break;
    }
}

```

`hyperv-attachment/src/hypercall/hypercall.h`:

```h
#pragma once
#include <structures/trap_frame.h>

union hypercall_info_t;

namespace hypercall
{
	void process(hypercall_info_t hypercall_info, trap_frame_t* trap_frame);
}

```

`hyperv-attachment/src/interrupts/interrupt_entry.asm`:

```asm
extern ?process_nmi@interrupts@@YAXXZ : proc
extern original_nmi_handler : qword

.code
	save_general_purpose_regisers macro
		mov [rsp], rax
		mov [rsp+8], rcx
		mov [rsp+16], rdx
		mov [rsp+24], rbx
		mov [rsp+32], rbp
		mov [rsp+40], rsi
		mov [rsp+48], rdi
		mov [rsp+56], r8
		mov [rsp+64], r9
		mov [rsp+72], r10
		mov [rsp+80], r11
		mov [rsp+88], r12
		mov [rsp+96], r13
		mov [rsp+104], r14
		mov [rsp+112], r15
	endm

	restore_general_purpose_regisers macro
		mov rax, [rsp]
		mov rcx, [rsp+8]
		mov rdx, [rsp+16]
		mov rbx, [rsp+24]
		mov rbp, [rsp+32]
		mov rsi, [rsp+40]
		mov rdi, [rsp+48]
		mov r8, [rsp+56]
		mov r9, [rsp+64]
		mov r10, [rsp+72]
		mov r11, [rsp+80]
		mov r12, [rsp+88]
		mov r13, [rsp+96]
		mov r14, [rsp+104]
		mov r15, [rsp+112]
	endm

	save_xmm_registers macro
		movdqu [rsp], xmm0
		movdqu [rsp+16], xmm1
		movdqu [rsp+32], xmm2
		movdqu [rsp+48], xmm3
		movdqu [rsp+64], xmm4
		movdqu [rsp+80], xmm5
		movdqu [rsp+96], xmm6
		movdqu [rsp+112], xmm7
		movdqu [rsp+128], xmm8
		movdqu [rsp+144], xmm9
		movdqu [rsp+160], xmm10
		movdqu [rsp+176], xmm11
		movdqu [rsp+192], xmm12
		movdqu [rsp+208], xmm13
		movdqu [rsp+224], xmm14
		movdqu [rsp+240], xmm15
	endm

	restore_xmm_registers macro
		movdqu xmm15, [rsp+240]
		movdqu xmm14, [rsp+224]
		movdqu xmm13, [rsp+208]
		movdqu xmm12, [rsp+192]
		movdqu xmm11, [rsp+176]
		movdqu xmm10, [rsp+160]
		movdqu xmm9, [rsp+144]
		movdqu xmm8, [rsp+128]
		movdqu xmm7, [rsp+112]
		movdqu xmm6, [rsp+96]
		movdqu xmm5, [rsp+80]
		movdqu xmm4, [rsp+64]
		movdqu xmm3, [rsp+48]
		movdqu xmm2, [rsp+32]
		movdqu xmm1, [rsp+16]
		movdqu xmm0, [rsp]
	endm

	handle_nmi macro
		sub rsp, 78h
		save_general_purpose_regisers

		sub rsp, 100h
		save_xmm_registers

		sub rsp, 20h
		call ?process_nmi@interrupts@@YAXXZ
		add rsp, 20h

		restore_xmm_registers
		add rsp, 100h

		restore_general_purpose_regisers
		add rsp, 78h
	endm

	nmi_standalone_entry proc
		handle_nmi

		iretq
	nmi_standalone_entry endp

	nmi_entry proc
		handle_nmi

		jmp original_nmi_handler
	nmi_entry endp
END
```

`hyperv-attachment/src/interrupts/interrupts.cpp`:

```cpp
#include "interrupts.h"
#include "../memory_manager/heap_manager.h"
#include "../slat/cr3/cr3.h"

#include "ia32-doc/ia32.hpp"
#include <intrin.h>

extern "C"
{
    std::uint64_t original_nmi_handler = 0;

    void nmi_standalone_entry();
    void nmi_entry();
}

namespace
{
    crt::bitmap_t processor_nmi_states = { };
}

void set_up_nmi_handling()
{
    segment_descriptor_register_64 idtr = { };

    __sidt(&idtr);

    if (idtr.base_address == 0)
    {
        return;
    }

    const auto interrupt_gates = reinterpret_cast<segment_descriptor_interrupt_gate_64*>(idtr.base_address);
    segment_descriptor_interrupt_gate_64* const nmi_gate = &interrupt_gates[2];
    segment_descriptor_interrupt_gate_64 new_gate = *nmi_gate;

    std::uint64_t new_handler = reinterpret_cast<std::uint64_t>(nmi_entry);

    if (new_gate.present == 0)
    {
        constexpr segment_selector gate_segment_selector = { .index = 1 };

        new_gate.segment_selector = gate_segment_selector.flags;
        new_gate.type = SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE;
        new_gate.present = 1;

        new_handler = reinterpret_cast<std::uint64_t>(nmi_standalone_entry);
    }
    else
    {
        original_nmi_handler = nmi_gate->offset_low | (nmi_gate->offset_middle << 16) | (static_cast<uint64_t>(nmi_gate->offset_high) << 32);
    }

    new_gate.offset_low = new_handler & 0xFFFF;
    new_gate.offset_middle = (new_handler >> 16) & 0xFFFF;
    new_gate.offset_high = (new_handler >> 32) & 0xFFFFFFFF;

    *nmi_gate = new_gate;
}

void interrupts::set_up()
{
    constexpr std::uint64_t processor_nmi_state_count = 0x1000 / sizeof(crt::bitmap_t::size_type);

    processor_nmi_states.set_value(static_cast<crt::bitmap_t::pointer>(heap_manager::allocate_page()));
    processor_nmi_states.set_count(processor_nmi_state_count);

    apic = apic_t::create_instance();

#ifdef _INTELMACHINE
    set_up_nmi_handling();
#endif
}

void interrupts::set_all_nmi_ready()
{
    processor_nmi_states.set_all();
}

void interrupts::set_nmi_ready(const std::uint64_t apic_id)
{
    processor_nmi_states.set(apic_id);
}

void interrupts::clear_nmi_ready(const std::uint64_t apic_id)
{
    processor_nmi_states.clear(apic_id);
}

crt::bitmap_t::bit_type interrupts::is_nmi_ready(const std::uint64_t apic_id)
{
    return processor_nmi_states.is_set(apic_id);
}

void interrupts::process_nmi()
{
    const std::uint64_t current_apic_id = apic_t::current_apic_id();

    if (is_nmi_ready(current_apic_id) == 1)
    {
        slat::flush_current_logical_processor_cache();

        clear_nmi_ready(current_apic_id);
    }
}

void interrupts::send_nmi_all_but_self()
{
    apic->send_nmi(icr_destination_shorthand_t::all_but_self);
}

```

`hyperv-attachment/src/interrupts/interrupts.h`:

```h
#pragma once
#include "../apic/apic.h"
#include "../crt/crt.h"

namespace interrupts
{
	void set_up();

	void set_all_nmi_ready();
	void set_nmi_ready(uint64_t apic_id);
	void clear_nmi_ready(uint64_t apic_id);

	crt::bitmap_t::bit_type is_nmi_ready(uint64_t apic_id);

	void process_nmi();
	void send_nmi_all_but_self();

	inline apic_t* apic = nullptr;
}

```

`hyperv-attachment/src/logs/logs.cpp`:

```cpp
#include "logs.h"
#include "../memory_manager/heap_manager.h"
#include "../memory_manager/memory_manager.h"
#include "../crt/crt.h"

namespace
{
	crt::mutex_t log_mutex = { };
}

void logs::set_up()
{
	constexpr std::uint64_t stored_logs_pages = 4; // must be at least 1
	constexpr std::uint64_t stored_logs_size = stored_logs_pages * 0x1000;

	// will be done in initialization, so will be contiguous
	stored_logs = static_cast<trap_frame_log_t*>(heap_manager::allocate_page());

	// reserve those other pages (will be contiguous)
	for (std::uint64_t i = 0; i < stored_logs_pages - 1; i++)
	{
		heap_manager::allocate_page();
	}

	stored_log_max = stored_logs_size / sizeof(trap_frame_log_t);
}

void logs::add_log(const trap_frame_log_t& trap_frame)
{
	log_mutex.lock();

	const std::uint16_t index = stored_log_index;

	if (index < stored_log_max)
	{
		stored_logs[index] = trap_frame;

		stored_log_index++;
	}

	log_mutex.release();
}

std::uint8_t logs::flush(const cr3 slat_cr3, const std::uint64_t guest_virtual_buffer, const cr3 guest_cr3, const std::uint16_t count)
{
	log_mutex.lock();

	const std::uint16_t actual_count = crt::min(count, stored_log_index);

	const std::uint16_t copy_start_index = stored_log_index - actual_count;
	const std::uint64_t write_size = sizeof(trap_frame_log_t) * actual_count;

	const std::uint64_t bytes_written = memory_manager::operate_on_guest_virtual_memory(slat_cr3, &stored_logs[copy_start_index], guest_virtual_buffer, guest_cr3, write_size, memory_operation_t::write_operation);

	stored_log_index = copy_start_index;

	log_mutex.release();

	return bytes_written == write_size;
}

```

`hyperv-attachment/src/logs/logs.h`:

```h
#pragma once
#include <structures/trap_frame.h>
#include "ia32-doc/ia32.hpp"

namespace logs
{
	void set_up();

	void add_log(const trap_frame_log_t& trap_frame);
	std::uint8_t flush(cr3 slat_cr3, std::uint64_t guest_virtual_buffer, cr3 guest_cr3, std::uint16_t count);

	inline trap_frame_log_t* stored_logs = nullptr;
	inline std::uint16_t stored_log_index = 0;
	inline std::uint16_t stored_log_max = 0;
}

```

`hyperv-attachment/src/main.cpp`:

```cpp
#include "arch/arch.h"
#include "hypercall/hypercall.h"
#include "hypercall/hypercall_def.h"
#include "memory_manager/memory_manager.h"
#include "memory_manager/heap_manager.h"
#include "logs/logs.h"
#include "structures/trap_frame.h"
#include <ia32-doc/ia32.hpp>
#include <cstdint>

#include "crt/crt.h"
#include "interrupts/interrupts.h"
#include "slat/slat.h"
#include "slat/cr3/cr3.h"
#include "slat/violation/violation.h"

#ifndef _INTELMACHINE
#include <intrin.h>
#endif

typedef std::uint64_t(*vmexit_handler_t)(std::uint64_t a1, std::uint64_t a2, std::uint64_t a3, std::uint64_t a4);

namespace
{
    std::uint8_t* original_vmexit_handler = nullptr;
    std::uint64_t uefi_boot_physical_base_address = 0;
    std::uint64_t uefi_boot_image_size = 0;
}

void clean_up_uefi_boot_image()
{
    // todo: check if windows has used this reclaimed memory
    const auto mapped_uefi_boot_base = static_cast<std::uint8_t*>(memory_manager::map_host_physical(uefi_boot_physical_base_address));

    crt::set_memory(mapped_uefi_boot_base, 0, uefi_boot_image_size);
}

void process_first_vmexit()
{
    static std::uint8_t is_first_vmexit = 1;

    if (is_first_vmexit == 1)
    {
        slat::process_first_vmexit();
        interrupts::set_up();

        clean_up_uefi_boot_image();

        is_first_vmexit = 0;
    }

    static std::uint8_t has_hidden_heap_pages = 0;
    static std::uint64_t vmexit_count = 0;

    if (has_hidden_heap_pages == 0 && 10000 <= ++vmexit_count)
    {
        // hides heap from Hyper-V slat cr3. when the hook slat cr3 is initialised, the heap must also be hidden from it

        has_hidden_heap_pages = slat::hide_heap_pages(slat::hyperv_cr3());
    }
}

std::uint64_t do_vmexit_premature_return()
{
#ifdef _INTELMACHINE
    return 0;
#else
    return __readgsqword(0);
#endif
}

std::uint64_t vmexit_handler_detour(const std::uint64_t a1, const std::uint64_t a2, const std::uint64_t a3, const std::uint64_t a4)
{
    process_first_vmexit();

    const std::uint64_t exit_reason = arch::get_vmexit_reason();

    if (arch::is_cpuid(exit_reason) == 1)
    {
#ifdef _INTELMACHINE
        trap_frame_t* const trap_frame = *reinterpret_cast<trap_frame_t**>(a1);
#else
        trap_frame_t* const trap_frame = *reinterpret_cast<trap_frame_t**>(a2);
#endif

        const hypercall_info_t hypercall_info = { .value = trap_frame->rcx };

        if (hypercall_info.primary_key == hypercall_primary_key && hypercall_info.secondary_key == hypercall_secondary_key)
        {
#ifndef _INTELMACHINE
            vmcb_t* const vmcb = arch::get_vmcb();

            trap_frame->rax = vmcb->save_state.rax;
#endif

            trap_frame->rsp = arch::get_guest_rsp();

            hypercall::process(hypercall_info, trap_frame);

#ifndef _INTELMACHINE
            vmcb->save_state.rax = trap_frame->rax;
#endif

            arch::set_guest_rsp(trap_frame->rsp);
            arch::advance_guest_rip();

            return do_vmexit_premature_return();
        }
    }
    else if (arch::is_slat_violation(exit_reason) == 1 && slat::violation::process() == 1)
    {
        return do_vmexit_premature_return();
    }
    else if (arch::is_non_maskable_interrupt_exit(exit_reason) == 1)
    {
        interrupts::process_nmi();
    }

    return reinterpret_cast<vmexit_handler_t>(original_vmexit_handler)(a1, a2, a3, a4);
}

void entry_point(std::uint8_t** const vmexit_handler_detour_out, std::uint8_t* const original_vmexit_handler_routine, const std::uint64_t heap_physical_base, const std::uint64_t heap_physical_usable_base, const std::uint64_t heap_total_size, const std::uint64_t _uefi_boot_physical_base_address, const std::uint32_t _uefi_boot_image_size,
#ifdef _INTELMACHINE
    const std::uint64_t reserved_one)
{
    (void)reserved_one;

#else
const std::uint8_t* const get_vmcb_gadget)
{
    arch::parse_vmcb_gadget(get_vmcb_gadget);
#endif
    original_vmexit_handler = original_vmexit_handler_routine;
    uefi_boot_physical_base_address = _uefi_boot_physical_base_address;
    uefi_boot_image_size = _uefi_boot_image_size;

    heap_manager::initial_physical_base = heap_physical_base;
    heap_manager::initial_size = heap_total_size;

    *vmexit_handler_detour_out = reinterpret_cast<std::uint8_t*>(vmexit_handler_detour);

    const std::uint64_t heap_physical_end = heap_physical_base + heap_total_size;
    const std::uint64_t heap_usable_size = heap_physical_end - heap_physical_usable_base;

    void* const mapped_heap_usable_base = memory_manager::map_host_physical(heap_physical_usable_base);

    heap_manager::set_up(mapped_heap_usable_base, heap_usable_size);

    logs::set_up();
    slat::set_up();
}

```

`hyperv-attachment/src/memory_manager/heap_manager.cpp`:

```cpp
#include "heap_manager.h"
#include "../crt/crt.h"
#include <intrin.h>

#include "memory_manager.h"

namespace
{
	constexpr std::uint64_t heap_block_size = 0x1000;

	heap_manager::heap_entry_t* free_block_list_head = nullptr;

	crt::mutex_t allocation_mutex = { };
}

void heap_manager::set_up(void* const heap_base, const std::uint64_t heap_size)
{
	free_block_list_head = static_cast<heap_entry_t*>(heap_base);

	const std::uint64_t heap_entries = heap_size / heap_block_size;

	heap_entry_t* entry = free_block_list_head;

	for (std::uint64_t i = 1; i < heap_entries - 1; i++)
	{
		entry->set_next(reinterpret_cast<heap_entry_t*>(reinterpret_cast<std::uint8_t*>(entry) + heap_block_size));

		entry = entry->next();
	}

	entry->set_next(nullptr);
}

void* heap_manager::allocate_page()
{
	allocation_mutex.lock();

	heap_entry_t* const entry = free_block_list_head;

	if (entry == nullptr)
	{
		allocation_mutex.release();

		return nullptr;
	}

	free_block_list_head = entry->next();

	allocation_mutex.release();

	return entry;
}

std::uint64_t heap_manager::allocate_physical_page()
{
	const void* const allocation = allocate_page();

	if (allocation == nullptr)
	{
		return 0;
	}

	return memory_manager::unmap_host_physical(allocation);
}

void heap_manager::free_page(void* const allocation_base)
{
	if (allocation_base == nullptr)
	{
		return;
	}

	allocation_mutex.lock();

	const auto entry = static_cast<heap_entry_t*>(allocation_base);

	entry->set_next(free_block_list_head);
	free_block_list_head = entry;

	allocation_mutex.release();
}

std::uint64_t heap_manager::get_free_page_count()
{
	allocation_mutex.lock();

	std::uint64_t count = 0;

	const heap_entry_t* entry = free_block_list_head;

	while (entry != nullptr)
	{
		count++;

		entry = entry->next();
	}

	allocation_mutex.release();

	return count;
}

heap_manager::heap_entry_t* heap_manager::heap_entry_t::next() const
{
	return next_;
}

void heap_manager::heap_entry_t::set_next(heap_entry_t* const next)
{
	next_ = next;
}

```

`hyperv-attachment/src/memory_manager/heap_manager.h`:

```h
#pragma once
#include <cstdint>

namespace heap_manager
{
	void set_up(void* heap_base, std::uint64_t heap_size);

	void* allocate_page();
	std::uint64_t allocate_physical_page();

	void free_page(void* allocation_base);

	std::uint64_t get_free_page_count();

	class heap_entry_t
	{
	public:
		[[nodiscard]] heap_entry_t* next() const;
		void set_next(heap_entry_t* next);

	protected:
		heap_entry_t* next_ = nullptr;
	};

	inline std::uint64_t initial_physical_base = 0;
	inline std::uint64_t initial_size = 0;
}

```

`hyperv-attachment/src/memory_manager/memory_manager.cpp`:

```cpp
#include "memory_manager.h"

#include "../crt/crt.h"
#include "../slat/slat.h"

constexpr std::uint64_t host_physical_memory_access_base = 255ull << 39;

void* memory_manager::map_host_physical(const std::uint64_t host_physical_address)
{
	return reinterpret_cast<void*>(host_physical_memory_access_base + host_physical_address);
}

std::uint64_t memory_manager::unmap_host_physical(const void* const host_mapped_address)
{
	return reinterpret_cast<std::uint64_t>(host_mapped_address) - host_physical_memory_access_base;
}

void* memory_manager::map_guest_physical(const cr3 slat_cr3, const std::uint64_t guest_physical_address, std::uint64_t* const size_left_of_page)
{
	const virtual_address_t guest_physical_address_to_map = { .address = guest_physical_address };

	const std::uint64_t host_physical_address = slat::translate_guest_physical_address(slat_cr3, guest_physical_address_to_map, size_left_of_page);

	if (!host_physical_address)
	{
		return nullptr;
	}

	return reinterpret_cast<void*>(host_physical_memory_access_base + host_physical_address);
}

std::uint64_t memory_manager::translate_guest_virtual_address(const cr3 guest_cr3, const cr3 slat_cr3, const virtual_address_t guest_virtual_address, std::uint64_t* const size_left_of_page)
{
	const auto pml4 = static_cast<const pml4e_64*>(map_guest_physical(slat_cr3, guest_cr3.address_of_page_directory << 12));
	const pml4e_64 pml4e = pml4[guest_virtual_address.pml4_idx];

	if (pml4e.present == 0)
	{
		return 0;
	}

	const auto pdpt = static_cast<const pdpte_64*>(map_guest_physical(slat_cr3, pml4e.page_frame_number << 12));
	const pdpte_64 pdpte = pdpt[guest_virtual_address.pdpt_idx];

	if (pdpte.present == 0)
	{
		return 0;
	}

	if (pdpte.large_page == 1)
	{
		const pdpte_1gb_64 large_pdpte = { .flags = pdpte.flags };
		const std::uint64_t page_offset = (guest_virtual_address.pd_idx << 21) + (guest_virtual_address.pt_idx << 12) + guest_virtual_address.offset;

		if (size_left_of_page != nullptr)
		{
			*size_left_of_page = (1ull << 30) - page_offset;
		}

		return (large_pdpte.page_frame_number << 30) + page_offset;
	}

	const auto pd = static_cast<const pde_64*>(map_guest_physical(slat_cr3, pdpte.page_frame_number << 12));
	const pde_64 pde = pd[guest_virtual_address.pd_idx];

	if (pde.present == 0)
	{
		return 0;
	}

	if (pde.large_page == 1)
	{
		const pde_2mb_64 large_pde = { .flags = pde.flags };
		const std::uint64_t page_offset = (guest_virtual_address.pt_idx << 12) + guest_virtual_address.offset;

		if (size_left_of_page != nullptr)
		{
			*size_left_of_page = (1ull << 21) - page_offset;
		}

		return (large_pde.page_frame_number << 21) + page_offset;
	}

	const auto pt = static_cast<const pte_64*>(map_guest_physical(slat_cr3, pde.page_frame_number << 12));
	const pte_64 pte = pt[guest_virtual_address.pt_idx];

	if (pte.present == 0)
	{
		return 0;
	}

	const std::uint64_t page_offset = guest_virtual_address.offset;

	if (size_left_of_page != nullptr)
	{
		*size_left_of_page = (1ull << 12) - page_offset;
	}

	return (pte.page_frame_number << 12) + page_offset;
}

std::uint64_t memory_manager::translate_host_virtual_address(const cr3 host_cr3, const virtual_address_t host_virtual_address, std::uint64_t* const size_left_of_page)
{
	const auto pml4 = static_cast<const pml4e_64*>(map_host_physical(host_cr3.address_of_page_directory << 12));
	const pml4e_64 pml4e = pml4[host_virtual_address.pml4_idx];

	if (pml4e.present == 0)
	{
		return 0;
	}

	const auto pdpt = static_cast<const pdpte_64*>(map_host_physical(pml4e.page_frame_number << 12));
	const pdpte_64 pdpte = pdpt[host_virtual_address.pdpt_idx];

	if (pdpte.present == 0)
	{
		return 0;
	}

	if (pdpte.large_page == 1)
	{
		const pdpte_1gb_64 large_pdpte = { .flags = pdpte.flags };

		const std::uint64_t page_offset = (host_virtual_address.pd_idx << 21) + (host_virtual_address.pt_idx << 12) + host_virtual_address.offset;

		if (size_left_of_page != nullptr)
		{
			*size_left_of_page = (1ull << 30) - page_offset;
		}

		return (large_pdpte.page_frame_number << 30) + page_offset;
	}

	const auto pd = static_cast<const pde_64*>(map_host_physical(pdpte.page_frame_number << 12));
	const pde_64 pde = pd[host_virtual_address.pd_idx];

	if (pde.present == 0)
	{
		return 0;
	}

	if (pde.large_page == 1)
	{
		const pde_2mb_64 large_pde = { .flags = pde.flags };
		const std::uint64_t page_offset = (host_virtual_address.pt_idx << 12) + host_virtual_address.offset;

		if (size_left_of_page != nullptr)
		{
			*size_left_of_page = (1ull << 21) - page_offset;
		}

		return (large_pde.page_frame_number << 21) + page_offset;
	}

	const auto pt = static_cast<const pte_64*>(map_host_physical(pde.page_frame_number << 12));
	const pte_64 pte = pt[host_virtual_address.pt_idx];

	if (pte.present == 0)
	{
		return 0;
	}

	const std::uint64_t page_offset = host_virtual_address.offset;

	if (size_left_of_page != nullptr)
	{
		*size_left_of_page = (1ull << 12) - page_offset;
	}

	return (pte.page_frame_number << 12) + page_offset;
}

std::uint64_t memory_manager::operate_on_guest_virtual_memory(const cr3 slat_cr3, void* const host_buffer, const std::uint64_t guest_virtual_address, const cr3 guest_cr3, const std::uint64_t total_size, const memory_operation_t operation)
{
	std::uint64_t size_left_to_read = total_size;
	std::uint64_t bytes_read = 0;

	while (size_left_to_read != 0)
	{
		std::uint64_t size_left_of_virtual_page = 0;
		std::uint64_t size_left_of_slat_page = 0;

		const std::uint64_t guest_physical_address = translate_guest_virtual_address(guest_cr3, slat_cr3, { .address = guest_virtual_address + bytes_read }, &size_left_of_virtual_page);

		if (guest_physical_address == 0)
		{
			break;
		}

		void* guest_physical_mapped = map_guest_physical(slat_cr3, guest_physical_address, &size_left_of_slat_page);
		std::uint8_t* current_host_buffer = static_cast<std::uint8_t*>(host_buffer) + bytes_read;

		const std::uint64_t size_left_of_pages = crt::min(size_left_of_virtual_page, size_left_of_slat_page);
		const std::uint64_t copy_size = crt::min(size_left_to_read, size_left_of_pages);

		if (operation == memory_operation_t::write_operation)
		{
			crt::copy_memory(guest_physical_mapped, current_host_buffer, copy_size);
		}
		else
		{
			crt::copy_memory(current_host_buffer, guest_physical_mapped, copy_size);
		}

		size_left_to_read -= copy_size;
		bytes_read += copy_size;
	}

	return bytes_read;
}

```

`hyperv-attachment/src/memory_manager/memory_manager.h`:

```h
#pragma once
#include <ia32-doc/ia32.hpp>
#include <structures/memory_operation.h>
#include "../structures/virtual_address.h"

namespace memory_manager
{
	void* map_host_physical(std::uint64_t host_physical_address);
	std::uint64_t unmap_host_physical(const void* host_mapped_address);

	void* map_guest_physical(cr3 slat_cr3, std::uint64_t guest_physical_address, std::uint64_t* size_left_of_page = nullptr);

	std::uint64_t translate_guest_virtual_address(cr3 guest_cr3, cr3 slat_cr3, virtual_address_t guest_virtual_address, std::uint64_t* size_left_of_page = nullptr);
	std::uint64_t translate_host_virtual_address(cr3 host_cr3, virtual_address_t host_virtual_address, std::uint64_t* size_left_of_page = nullptr);

	std::uint64_t operate_on_guest_virtual_memory(cr3 slat_cr3, void* host_buffer, std::uint64_t guest_virtual_address, cr3 guest_cr3, std::uint64_t total_size, memory_operation_t operation);
}

```

`hyperv-attachment/src/slat/cr3/cr3.cpp`:

```cpp
#include "cr3.h"

#include "../slat.h"
#include "../slat_def.h"
#include "deep_copy.h"
#include "pte.h"

#include "../../memory_manager/memory_manager.h"
#include "../../memory_manager/heap_manager.h"
#include "../../interrupts/interrupts.h"
#include "../../arch/arch.h"

#ifdef _INTELMACHINE
extern "C" void invalidate_ept_mappings(invept_type type, const invept_descriptor& descriptor);
#endif

namespace
{
	cr3 hook_slat_cr3 = { };
	slat_pml4e* hook_slat_pml4 = nullptr;

	cr3 hyperv_slat_cr3 = { };
}

cr3 slat::hyperv_cr3()
{
	return hyperv_slat_cr3;
}

cr3 slat::hook_cr3()
{
	return hook_slat_cr3;
}

cr3 slat::get_cr3()
{
	return arch::get_slat_cr3();
}

void slat::set_cr3(const cr3 slat_cr3)
{
	arch::set_slat_cr3(slat_cr3);

	flush_current_logical_processor_cache(1);
}

void slat::flush_current_logical_processor_cache(const std::uint8_t has_slat_cr3_changed)
{
#ifdef _INTELMACHINE
	(void)has_slat_cr3_changed;

	invalidate_ept_mappings(invept_type::invept_all_context, { });
#else
	vmcb_t* const vmcb = arch::get_vmcb();

	vmcb->control.tlb_control = tlb_control_t::flush_guest_tlb_entries;

	if (has_slat_cr3_changed == 1)
	{
		vmcb->control.clean.nested_paging = 0;
	}
#endif
}

void slat::flush_all_logical_processors_cache()
{
	flush_current_logical_processor_cache();

	interrupts::set_all_nmi_ready();
	interrupts::send_nmi_all_but_self();
}

void set_up_slat_cr3(cr3* const slat_cr3, slat_pml4e** const slat_pml4)
{
	*slat_pml4 = static_cast<slat_pml4e*>(heap_manager::allocate_page());

	crt::set_memory(*slat_pml4, 0, sizeof(slat_pml4e) * 512);

	const std::uint64_t pml4_physical_address = memory_manager::unmap_host_physical(*slat_pml4);

	*slat_cr3 = slat::hyperv_cr3();
	slat_cr3->address_of_page_directory = pml4_physical_address >> 12;
}

void slat::set_up_hyperv_cr3()
{
	hyperv_slat_cr3 = get_cr3();
}

void slat::set_up_hook_cr3()
{
	set_up_slat_cr3(&hook_slat_cr3, &hook_slat_pml4);

	const slat_pml4e* const hyperv_pml4 = get_pml4e(slat::hyperv_cr3(), { });

#ifdef _INTELMACHINE
	make_pml4_copy(hyperv_pml4, hook_slat_pml4, 0);
#else
	make_pml4_copy(hyperv_pml4, hook_slat_pml4, 1);
#endif

	// the deep copy should contain already the hidden pages
	// as we hid them in the Hyper-V slat cr3, but this is just to make sure
	slat::hide_heap_pages(hook_cr3());
}


```

`hyperv-attachment/src/slat/cr3/cr3.h`:

```h
#pragma once
#include <ia32-doc/ia32.hpp>
#include <cstdint>

namespace slat
{
	cr3 hyperv_cr3();
	cr3 hook_cr3();

	cr3 get_cr3();
	void set_cr3(cr3 slat_cr3);

	void flush_current_logical_processor_cache(std::uint8_t has_slat_cr3_changed = 0);
	void flush_all_logical_processors_cache();

	void set_up_hyperv_cr3();
	void set_up_hook_cr3();
} 

```

`hyperv-attachment/src/slat/cr3/deep_copy.cpp`:

```cpp
#include "deep_copy.h"
#include "pte.h"

#include "../../memory_manager/memory_manager.h"
#include "../../memory_manager/heap_manager.h"

void make_pt_copy(const slat_pte* const hyperv_pt, slat_pte* const hook_pt, const std::uint8_t make_non_executable)
{
	for (std::uint64_t pt_index = 0; pt_index < 512; pt_index++)
	{
		const slat_pte* const hyperv_pte = &hyperv_pt[pt_index];
		slat_pte* const hook_pte = &hook_pt[pt_index];

		hook_pte->flags = hyperv_pte->flags;

		if (make_non_executable)
		{
#ifdef _INTELMACHINE
			hook_pte->execute_access = 0;
#else
			hook_pte->execute_disable = 1;
#endif
		}
	}
}

void make_pd_copy(const slat_pde* const hyperv_pd, slat_pde* const hook_pd, const std::uint8_t make_non_executable)
{
	for (std::uint64_t pd_index = 0; pd_index < 512; pd_index++)
	{
		const slat_pde* const hyperv_pde = &hyperv_pd[pd_index];
		slat_pde* const hook_pde = &hook_pd[pd_index];

		hook_pde->flags = hyperv_pde->flags;

		if (slat::is_pte_present(hyperv_pde) == 0)
		{
			continue;
		}

		if (slat::is_pte_large(hyperv_pde) == 0)
		{
			const slat_pte* const hyperv_pt = slat::get_pte(hyperv_pde, { });
			const auto hook_pt = static_cast<slat_pte*>(heap_manager::allocate_page());

			hook_pde->page_frame_number = memory_manager::unmap_host_physical(hook_pt) >> 12;

			make_pt_copy(hyperv_pt, hook_pt, make_non_executable);
		}
		else if (make_non_executable)
		{
#ifdef _INTELMACHINE
			hook_pde->execute_access = 0;
#else
			hook_pde->execute_disable = 1;
#endif
		}
	}
}

void make_pdpt_copy(const slat_pdpte* const hyperv_pdpt, slat_pdpte* const hook_pdpt, const std::uint8_t make_non_executable)
{
	for (std::uint64_t pdpt_index = 0; pdpt_index < 512; pdpt_index++)
	{
		const slat_pdpte* const hyperv_pdpte = &hyperv_pdpt[pdpt_index];
		slat_pdpte* const hook_pdpte = &hook_pdpt[pdpt_index];

		hook_pdpte->flags = hyperv_pdpte->flags;

		if (slat::is_pte_present(hyperv_pdpte) == 0)
		{
			continue;
		}

		if (slat::is_pte_large(hyperv_pdpte) == 0)
		{
			const slat_pde* const hyperv_pd = slat::get_pde(hyperv_pdpte, { });
			const auto hook_pd = static_cast<slat_pde*>(heap_manager::allocate_page());

			hook_pdpte->page_frame_number = memory_manager::unmap_host_physical(hook_pd) >> 12;

			make_pd_copy(hyperv_pd, hook_pd, make_non_executable);
		}
		else if (make_non_executable)
		{
#ifdef _INTELMACHINE
			hook_pdpte->execute_access = 0;
#else
			hook_pdpte->execute_disable = 1;
#endif
		}
	}
}

void slat::make_pml4_copy(const slat_pml4e* const hyperv_pml4, slat_pml4e* const hook_pml4, const std::uint8_t make_non_executable)
{
	for (std::uint64_t pml4_index = 0; pml4_index < 512; pml4_index++)
	{
		const slat_pml4e* const hyperv_pml4e = &hyperv_pml4[pml4_index];
		slat_pml4e* const hook_pml4e = &hook_pml4[pml4_index];

		hook_pml4e->flags = hyperv_pml4e->flags;

		if (is_pte_present(hyperv_pml4e) == 0)
		{
			continue;
		}

		const slat_pdpte* const hyperv_pdpt = get_pdpte(hyperv_pml4e, { });
		const auto hook_pdpt = static_cast<slat_pdpte*>(heap_manager::allocate_page());

		hook_pml4e->page_frame_number = memory_manager::unmap_host_physical(hook_pdpt) >> 12;

		make_pdpt_copy(hyperv_pdpt, hook_pdpt, make_non_executable);
	}
}

```

`hyperv-attachment/src/slat/cr3/deep_copy.h`:

```h
#pragma once
#include <cstdint>
#include "../slat_def.h"

namespace slat
{
	void make_pml4_copy(const slat_pml4e* hyperv_pml4, slat_pml4e* hook_pml4, std::uint8_t make_non_executable);
}

```

`hyperv-attachment/src/slat/cr3/intel_invept.asm`:

```asm
.code
	invalidate_ept_mappings proc
		invept rcx, oword ptr [rdx]

		ret
	invalidate_ept_mappings endp
END
```

`hyperv-attachment/src/slat/cr3/pte.cpp`:

```cpp
#include "pte.h"

#include "../../memory_manager/memory_manager.h"
#include "../../memory_manager/heap_manager.h"

#include "../../structures/virtual_address.h"

slat_pml4e* slat::get_pml4e(const cr3 slat_cr3, const virtual_address_t guest_physical_address)
{
	const auto pml4 = static_cast<slat_pml4e*>(memory_manager::map_host_physical(slat_cr3.address_of_page_directory << 12));

	return &pml4[guest_physical_address.pml4_idx];
}

slat_pdpte* slat::get_pdpte(const slat_pml4e* const pml4e, const virtual_address_t guest_physical_address)
{
	const auto pdpt = static_cast<slat_pdpte*>(memory_manager::map_host_physical(pml4e->page_frame_number << 12));

	return &pdpt[guest_physical_address.pdpt_idx];
}

slat_pde* slat::get_pde(const slat_pdpte* const pdpte, const virtual_address_t guest_physical_address)
{
	const auto pd = static_cast<slat_pde*>(memory_manager::map_host_physical(pdpte->page_frame_number << 12));

	return &pd[guest_physical_address.pd_idx];
}

slat_pte* slat::get_pte(const slat_pde* const pde, const virtual_address_t guest_physical_address)
{
	const auto pt = static_cast<slat_pte*>(memory_manager::map_host_physical(pde->page_frame_number << 12));

	return &pt[guest_physical_address.pt_idx];
}

slat_pde* slat::get_pde(const cr3 slat_cr3, const virtual_address_t guest_physical_address,
	const std::uint8_t force_split_pages)
{
	const slat_pml4e* const pml4e = get_pml4e(slat_cr3, guest_physical_address);

	if (pml4e == nullptr)
	{
		return nullptr;
	}

	slat_pdpte* const pdpte = get_pdpte(pml4e, guest_physical_address);

	if (pdpte == nullptr)
	{
		return nullptr;
	}

	const auto large_pdpte = reinterpret_cast<slat_pdpte_1gb*>(pdpte);

	if (large_pdpte->large_page == 1 && (force_split_pages == 0 || split_1gb_pdpte(large_pdpte) == 0))
	{
		return nullptr;
	}

	return get_pde(pdpte, guest_physical_address);
}

slat_pte* slat::get_pte(const cr3 slat_cr3, const virtual_address_t guest_physical_address,
	const std::uint8_t force_split_pages, std::uint8_t* const paging_split_state)
{
	slat_pde* const pde = get_pde(slat_cr3, guest_physical_address, force_split_pages);

	if (pde == nullptr)
	{
		return nullptr;
	}

	const auto large_pde = reinterpret_cast<slat_pde_2mb*>(pde);

	if (large_pde->large_page == 1)
	{
		if (force_split_pages == 0 || split_2mb_pde(large_pde) == 0)
		{
			return nullptr;
		}

		if (paging_split_state != nullptr)
		{
			*paging_split_state = 1;
		}
	}

	return get_pte(pde, guest_physical_address);
}

std::uint8_t slat::split_2mb_pde(slat_pde_2mb* const large_pde)
{
	const auto pt = static_cast<slat_pte*>(heap_manager::allocate_page());

	if (pt == nullptr)
	{
		return 0;
	}

	for (std::uint64_t i = 0; i < 512; i++)
	{
		slat_pte* pte = &pt[i];

		pte->flags = 0;

#ifdef _INTELMACHINE
		pte->execute_access = large_pde->execute_access;
		pte->read_access = large_pde->read_access;
		pte->write_access = large_pde->write_access;
		pte->memory_type = large_pde->memory_type;
		pte->ignore_pat = large_pde->ignore_pat;
		pte->user_mode_execute = large_pde->user_mode_execute;
		pte->verify_guest_paging = large_pde->verify_guest_paging;
		pte->paging_write_access = large_pde->paging_write_access;
		pte->supervisor_shadow_stack = large_pde->supervisor_shadow_stack;
		pte->suppress_ve = large_pde->suppress_ve;
#else
		pte->execute_disable = large_pde->execute_disable;
		pte->present = large_pde->present;
		pte->write = large_pde->write;
		pte->global = large_pde->global;
		pte->pat = large_pde->pat;
		pte->protection_key = large_pde->protection_key;
		pte->page_level_write_through = large_pde->page_level_write_through;
		pte->page_level_cache_disable = large_pde->page_level_cache_disable;
		pte->supervisor = large_pde->supervisor;
#endif

		pte->accessed = large_pde->accessed;
		pte->dirty = large_pde->dirty;

		pte->page_frame_number = (large_pde->page_frame_number << 9) + i;
	}

	const std::uint64_t pt_physical_address = memory_manager::unmap_host_physical(pt);

	slat_pde new_pde = { };

	new_pde.page_frame_number = pt_physical_address >> 12;

#ifdef _INTELMACHINE
	new_pde.read_access = 1;
	new_pde.write_access = 1;
	new_pde.execute_access = 1;
	new_pde.user_mode_execute = 1;
#else
	new_pde.present = 1;
	new_pde.write = 1;
	new_pde.supervisor = 1;
#endif

	large_pde->flags = new_pde.flags;

	return 1;
}

std::uint8_t slat::split_1gb_pdpte(slat_pdpte_1gb* const large_pdpte)
{
	const auto pd = static_cast<slat_pde_2mb*>(heap_manager::allocate_page());

	if (pd == nullptr)
	{
		return 0;
	}

	for (std::uint64_t i = 0; i < 512; i++)
	{
		slat_pde_2mb* pde = &pd[i];

		pde->flags = 0;

#ifdef _INTELMACHINE
		pde->execute_access = large_pdpte->execute_access;
		pde->read_access = large_pdpte->read_access;
		pde->write_access = large_pdpte->write_access;
		pde->memory_type = large_pdpte->memory_type;
		pde->ignore_pat = large_pdpte->ignore_pat;
		pde->user_mode_execute = large_pdpte->user_mode_execute;
		pde->verify_guest_paging = large_pdpte->verify_guest_paging;
		pde->paging_write_access = large_pdpte->paging_write_access;
		pde->supervisor_shadow_stack = large_pdpte->supervisor_shadow_stack;
		pde->suppress_ve = large_pdpte->suppress_ve;
#else
		pde->execute_disable = large_pdpte->execute_disable;
		pde->present = large_pdpte->present;
		pde->write = large_pdpte->write;
		pde->global = large_pdpte->global;
		pde->pat = large_pdpte->pat;
		pde->protection_key = large_pdpte->protection_key;
		pde->page_level_write_through = large_pdpte->page_level_write_through;
		pde->page_level_cache_disable = large_pdpte->page_level_cache_disable;
		pde->supervisor = large_pdpte->supervisor;
#endif

		pde->accessed = large_pdpte->accessed;
		pde->dirty = large_pdpte->dirty;

		pde->page_frame_number = (large_pdpte->page_frame_number << 9) + i;
		pde->large_page = 1;
	}

	const std::uint64_t pd_physical_address = memory_manager::unmap_host_physical(pd);

	slat_pdpte new_pdpte = { .flags = 0 };

	new_pdpte.page_frame_number = pd_physical_address >> 12;

#ifdef _INTELMACHINE
	new_pdpte.read_access = 1;
	new_pdpte.write_access = 1;
	new_pdpte.execute_access = 1;
	new_pdpte.user_mode_execute = 1;
#else
	new_pdpte.present = 1;
	new_pdpte.write = 1;
	new_pdpte.supervisor = 1;
#endif

	large_pdpte->flags = new_pdpte.flags;

	return 1;
}

std::uint8_t slat::merge_4kb_pt(const cr3 slat_cr3, const virtual_address_t guest_physical_address)
{
	slat_pde* const pde = get_pde(slat_cr3, guest_physical_address);

	if (pde == nullptr)
	{
		return 0;
	}

	const auto large_pde = reinterpret_cast<slat_pde_2mb*>(pde);

	if (large_pde->large_page == 1)
	{
		return 1;
	}

	const std::uint64_t pt_physical_address = pde->page_frame_number << 12;

	slat_pte* const pte = get_pte(pde, guest_physical_address);

	slat_pde_2mb new_large_pde = { };

#ifdef _INTELMACHINE
	new_large_pde.execute_access = pte->execute_access;
	new_large_pde.read_access = pte->read_access;
	new_large_pde.write_access = pte->write_access;
	new_large_pde.memory_type = pte->memory_type;
	new_large_pde.ignore_pat = pte->ignore_pat;
	new_large_pde.user_mode_execute = pte->user_mode_execute;
	new_large_pde.verify_guest_paging = pte->verify_guest_paging;
	new_large_pde.paging_write_access = pte->paging_write_access;
	new_large_pde.supervisor_shadow_stack = pte->supervisor_shadow_stack;
	new_large_pde.suppress_ve = pte->suppress_ve;
#else
		new_large_pde.execute_disable = pte->execute_disable;
		new_large_pde.present = pte->present;
		new_large_pde.write = pte->write;
		new_large_pde.global = pte->global;
		new_large_pde.pat = pte->pat;
		new_large_pde.protection_key = pte->protection_key;
		new_large_pde.page_level_write_through = pte->page_level_write_through;
		new_large_pde.page_level_cache_disable = pte->page_level_cache_disable;
		new_large_pde.supervisor = pte->supervisor;
#endif

	new_large_pde.page_frame_number = pte->page_frame_number >> 9;
	new_large_pde.large_page = 1;

	*large_pde = new_large_pde;

	void* const pt_allocation_mapped = memory_manager::map_host_physical(pt_physical_address);

	heap_manager::free_page(pt_allocation_mapped);

	return 1;
}

std::uint8_t slat::is_pte_present(const void* const pte_in)
{
	if (!pte_in)
	{
		return 0;
	}

	const auto pte = static_cast<const slat_pte*>(pte_in);

#ifdef _INTELMACHINE
	return pte->read_access == 1;
#else
		return pte->present == 1;
#endif
}

std::uint8_t slat::is_pte_large(const void* const pte_in)
{
	if (!pte_in)
	{
		return 0;
	}

	const auto large_pte = static_cast<const slat_pde_2mb*>(pte_in);

	return large_pte->large_page;
}

```

`hyperv-attachment/src/slat/cr3/pte.h`:

```h
#pragma once
#include <cstdint>
#include "../slat_def.h"

union virtual_address_t;

namespace slat
{
	slat_pml4e* get_pml4e(cr3 slat_cr3, virtual_address_t guest_physical_address);
	slat_pdpte* get_pdpte(const slat_pml4e* pml4e, virtual_address_t guest_physical_address);
	slat_pde* get_pde(const slat_pdpte* pdpte, virtual_address_t guest_physical_address);
	slat_pte* get_pte(const slat_pde* pde, virtual_address_t guest_physical_address);

	slat_pde* get_pde(cr3 slat_cr3, virtual_address_t guest_physical_address, std::uint8_t force_split_pages = 0);
	slat_pte* get_pte(cr3 slat_cr3, virtual_address_t guest_physical_address, std::uint8_t force_split_pages = 0, std::uint8_t* paging_split_state = nullptr);

	std::uint8_t split_2mb_pde(slat_pde_2mb* large_pde);
	std::uint8_t split_1gb_pdpte(slat_pdpte_1gb* large_pdpte);

	std::uint8_t merge_4kb_pt(cr3 slat_cr3,virtual_address_t guest_physical_address);

	std::uint8_t is_pte_present(const void* pte_in);
	std::uint8_t is_pte_large(const void* pte_in);
}

```

`hyperv-attachment/src/slat/hook/amd_page_split.cpp`:

```cpp
#include "amd_page_split.h"

#ifndef _INTELMACHINE
#include "../cr3/pte.h"

#include "../../structures/virtual_address.h"
#include "../../crt/crt.h"

static void set_page_executability(const cr3 slat_cr3, const virtual_address_t target_guest_address, const std::uint8_t execute_disable)
{
	slat_pte* const pte = slat::get_pte(slat_cr3, target_guest_address, 1);

	if (pte != nullptr)
	{
		pte->execute_disable = execute_disable;
	}
}

static void set_previous_page_executability(const cr3 slat_cr3, const virtual_address_t target_guest_address, const std::uint8_t execute_disable)
{
	const virtual_address_t previous_page_address = { .address = target_guest_address.address - 0x1000 };

	set_page_executability(slat_cr3, previous_page_address, execute_disable);
}

static void set_next_page_executability(const cr3 slat_cr3, const virtual_address_t target_guest_address, const std::uint8_t execute_disable)
{
	const virtual_address_t next_page_address = { .address = target_guest_address.address + 0x1000 };

	set_page_executability(slat_cr3, next_page_address, execute_disable);
}

void slat::hook::fix_split_instructions(const cr3 slat_cr3, const virtual_address_t target_guest_address)
{
	set_previous_page_executability(slat_cr3, target_guest_address, 0);
	set_next_page_executability(slat_cr3, target_guest_address, 0);
}

void slat::hook::unfix_split_instructions(const entry_t* const hook_entry, const cr3 slat_cr3, const virtual_address_t target_guest_address)
{
	const entry_t* const other_hook_entry_in_range = entry_t::find_closest_in_2mb_range(target_guest_address.address >> 12, hook_entry);

	if (other_hook_entry_in_range != nullptr)
	{
		const std::int64_t source_pfn = static_cast<std::int64_t>(hook_entry->original_pfn());
		const std::int64_t other_pfn = static_cast<std::int64_t>(other_hook_entry_in_range->original_pfn());

		const std::int64_t pfn_difference = source_pfn - other_pfn;
		const std::int64_t abs_pfn_difference = crt::abs(pfn_difference);

		const std::uint8_t is_page_nearby = abs_pfn_difference <= 2;

		std::uint8_t has_fixed = 1;

		if (is_page_nearby == 1 && 0 < pfn_difference)
		{
			set_next_page_executability(slat_cr3, target_guest_address, 1);

			has_fixed = 1;
		}
		else if (is_page_nearby == 1) // negative pfn difference
		{
			set_previous_page_executability(slat_cr3, target_guest_address, 1);

			has_fixed = 1;
		}

		if (abs_pfn_difference == 1)
		{
			// current page must be executable for the nearby hook

			set_page_executability(slat_cr3, target_guest_address, 0);
		}

		if (has_fixed == 1)
		{
			return;
		}
	}

	// no nearby hooks enough to have to shed executability
	set_previous_page_executability(slat_cr3, target_guest_address, 0);
	set_next_page_executability(slat_cr3, target_guest_address, 0);
}
#endif

```

`hyperv-attachment/src/slat/hook/amd_page_split.h`:

```h
#pragma once
#ifndef _INTELMACHINE
#include "hook_entry.h"
#include <ia32-doc/ia32.hpp>

union virtual_address_t;

namespace slat::hook
{
	void fix_split_instructions(cr3 slat_cr3, virtual_address_t target_guest_address);
	void unfix_split_instructions(const entry_t* hook_entry, cr3 slat_cr3, virtual_address_t target_guest_address);
}
#endif

```

`hyperv-attachment/src/slat/hook/hook.cpp`:

```cpp
#include "hook.h"
#include "hook_entry.h"

#include "../cr3/cr3.h"
#include "../cr3/pte.h"
#include "../slat_def.h"
#include "../slat.h"

#include "../../memory_manager/heap_manager.h"

#include "../../structures/virtual_address.h"
#include "../../crt/crt.h"

#ifndef _INTELMACHINE
#include "amd_page_split.h"
#endif

namespace
{
	crt::mutex_t hook_mutex = { };
}

static void process_first_slat_hook()
{
	static std::uint8_t is_first_slat_hook = 1;

	if (is_first_slat_hook)
	{
		is_first_slat_hook = 0;

		slat::set_up_hook_cr3();
	}
}

void slat::hook::set_up_entries()
{
	constexpr std::uint64_t hook_entries_wanted = 0x1000 / sizeof(entry_t);

	void* const hook_entries_allocation = heap_manager::allocate_page();

	available_hook_list_head = static_cast<entry_t*>(hook_entries_allocation);

	entry_t* current_entry = available_hook_list_head;

	for (std::uint64_t i = 0; i < hook_entries_wanted - 1; i++)
	{
		current_entry->set_next(current_entry + 1);
		current_entry->set_original_pfn(0);

		current_entry = current_entry->next();
	}

	current_entry->set_original_pfn(0);
	current_entry->set_next(nullptr);
}

std::uint64_t slat::hook::add(const virtual_address_t target_guest_physical_address, const virtual_address_t shadow_guest_physical_address)
{
	hook_mutex.lock();

	process_first_slat_hook();

	const entry_t* const already_present_hook_entry = entry_t::find(target_guest_physical_address.address >> 12);

	if (already_present_hook_entry != nullptr)
	{
		hook_mutex.release();

		return 0;
	}

	std::uint8_t paging_split_state = 0;

	slat_pte* const target_pte = get_pte(hyperv_cr3(), target_guest_physical_address, 1, &paging_split_state);

	if (target_pte == nullptr)
	{
		hook_mutex.release();

		return 0;
	}

	slat_pte* const hook_target_pte = get_pte(hook_cr3(), target_guest_physical_address, 1);

	if (hook_target_pte == nullptr)
	{
		hook_mutex.release();

		return 0;
	}

	if (paging_split_state == 0)
	{
		const entry_t* const similar_space_hook_entry = entry_t::find_in_2mb_range(target_guest_physical_address.address >> 12);

		if (similar_space_hook_entry != nullptr)
		{
			paging_split_state = static_cast<std::uint8_t>(similar_space_hook_entry->paging_split_state());
		}
	}

	const std::uint64_t shadow_page_host_physical_address = translate_guest_physical_address(hyperv_cr3(), shadow_guest_physical_address);

	if (shadow_page_host_physical_address == 0)
	{
		hook_mutex.release();

		return 0;
	}

	entry_t* const hook_entry = available_hook_list_head;

	if (hook_entry == nullptr)
	{
		hook_mutex.release();

		return 0;
	}

	available_hook_list_head = hook_entry->next();

	hook_entry->set_next(used_hook_list_head);
	hook_entry->set_original_pfn(target_pte->page_frame_number);
	hook_entry->set_paging_split_state(paging_split_state);

	used_hook_list_head = hook_entry;

#ifdef _INTELMACHINE
	hook_entry->set_original_read_access(target_pte->read_access);
	hook_entry->set_original_write_access(target_pte->write_access);
	hook_entry->set_original_execute_access(target_pte->execute_access);

	target_pte->page_frame_number = shadow_page_host_physical_address >> 12;
	target_pte->execute_access = 1;
	target_pte->read_access = 0;
	target_pte->write_access = 0;

	hook_target_pte->execute_access = 0;
	hook_target_pte->read_access = 1;
	hook_target_pte->write_access = 1;
#else
	hook_entry->set_original_execute_access(!target_pte->execute_disable);

	hook_target_pte->execute_disable = 0;
	hook_target_pte->page_frame_number = shadow_page_host_physical_address >> 12;

	fix_split_instructions(hook_cr3(), target_guest_physical_address);

	target_pte->execute_disable = 1;
#endif

	hook_mutex.release();

	flush_all_logical_processors_cache();

	return 1;
}

std::uint8_t does_hook_need_merge(const slat::hook::entry_t* const hook_entry, const virtual_address_t guest_physical_address)
{
	if (hook_entry == nullptr)
	{
		return 0;
	}

	const std::uint8_t requires_merge = hook_entry->paging_split_state() == 1;

	if (requires_merge == 0)
	{
		return 0;
	}

	const slat::hook::entry_t* const other_hook = slat::hook::entry_t::find_in_2mb_range(guest_physical_address.address >> 12, hook_entry);

	return other_hook == nullptr;
}

std::uint8_t clean_up_hook_ptes(const virtual_address_t target_guest_physical_address, const slat::hook::entry_t* const hook_entry)
{
	slat_pte* const target_pte = slat::get_pte(slat::hyperv_cr3(), target_guest_physical_address);

	if (target_pte == nullptr)
	{
		return 0;
	}

	slat_pte* const hook_target_pte = slat::get_pte(slat::hook_cr3(), target_guest_physical_address);

	if (hook_target_pte == nullptr)
	{
		return 0;
	}

#ifdef _INTELMACHINE
	target_pte->page_frame_number = hook_entry->original_pfn();

	target_pte->read_access = hook_entry->original_read_access();
	target_pte->write_access = hook_entry->original_write_access();
	target_pte->execute_access = hook_entry->original_execute_access();

	hook_target_pte->read_access = hook_entry->original_read_access();
	hook_target_pte->write_access = hook_entry->original_write_access();
	hook_target_pte->execute_access = hook_entry->original_execute_access();
#else
	target_pte->execute_disable = !hook_entry->original_execute_access();

	hook_target_pte->page_frame_number = hook_entry->original_pfn();
	hook_target_pte->execute_disable = 1;

	unfix_split_instructions(hook_entry, slat::hook_cr3(), target_guest_physical_address);
#endif

	if (does_hook_need_merge(hook_entry, target_guest_physical_address) == 1)
	{
		slat::merge_4kb_pt(slat::hyperv_cr3(), target_guest_physical_address);
		slat::merge_4kb_pt(slat::hook_cr3(), target_guest_physical_address);
	}

	return 1;
}

void clean_up_hook_entry(slat::hook::entry_t* const hook_entry, slat::hook::entry_t* const previous_hook_entry)
{
	if (previous_hook_entry == nullptr)
	{
		slat::hook::used_hook_list_head = hook_entry->next();
	}
	else
	{
		previous_hook_entry->set_next(hook_entry->next());
	}

	hook_entry->set_next(slat::hook::available_hook_list_head);

	slat::hook::available_hook_list_head = hook_entry;
}

std::uint64_t slat::hook::remove(const virtual_address_t guest_physical_address)
{
	hook_mutex.lock();

	entry_t* previous_hook_entry = nullptr;

	entry_t* const hook_entry = entry_t::find(guest_physical_address.address >> 12, &previous_hook_entry);

	if (hook_entry == nullptr)
	{
		hook_mutex.release();

		return 0;
	}

	const std::uint8_t pte_cleanup_status = clean_up_hook_ptes(guest_physical_address, hook_entry);

	clean_up_hook_entry(hook_entry, previous_hook_entry);

	hook_mutex.release();

	flush_all_logical_processors_cache();

	return pte_cleanup_status;
}

```

`hyperv-attachment/src/slat/hook/hook.h`:

```h
#pragma once
#include <cstdint>

union virtual_address_t;

namespace slat::hook
{
	void set_up_entries();

	std::uint64_t add(virtual_address_t target_guest_physical_address, virtual_address_t shadow_guest_physical_address);
	std::uint64_t remove(virtual_address_t guest_physical_address);
}

```

`hyperv-attachment/src/slat/hook/hook_entry.cpp`:

```cpp
#include "hook_entry.h"
#include "../../crt/crt.h"

slat::hook::entry_t* slat::hook::entry_t::next() const
{
	return reinterpret_cast<entry_t*>(next_);
}

void slat::hook::entry_t::set_next(entry_t* const next_entry)
{
	next_ = reinterpret_cast<std::uint64_t>(next_entry);
}

std::uint64_t slat::hook::entry_t::original_pfn() const
{
	return original_pfn_;
}

void slat::hook::entry_t::set_original_pfn(const std::uint64_t original_pfn)
{
	original_pfn_ = original_pfn;
}

std::uint64_t slat::hook::entry_t::original_read_access() const
{
	return original_read_access_;
}

std::uint64_t slat::hook::entry_t::original_write_access() const
{
	return original_write_access_;
}

std::uint64_t slat::hook::entry_t::original_execute_access() const
{
	return original_execute_access_;
}

std::uint64_t slat::hook::entry_t::paging_split_state() const
{
	return paging_split_state_;
}

void slat::hook::entry_t::set_original_read_access(const std::uint64_t original_read_access)
{
	original_read_access_ = original_read_access;
}

void slat::hook::entry_t::set_original_write_access(const std::uint64_t original_write_access)
{
	original_write_access_ = original_write_access;
}

void slat::hook::entry_t::set_original_execute_access(const std::uint64_t original_execute_access)
{
	original_execute_access_ = original_execute_access;
}

void slat::hook::entry_t::set_paging_split_state(const std::uint64_t paging_split_state)
{
	paging_split_state_ = paging_split_state;
}

slat::hook::entry_t* slat::hook::entry_t::find(const std::uint64_t target_original_4kb_pfn, entry_t** const previous_entry_out)
{
	entry_t* current_entry = used_hook_list_head;
	entry_t* previous_entry = nullptr;

	while (current_entry != nullptr)
	{
		if (current_entry->original_pfn() == target_original_4kb_pfn)
		{
			if (previous_entry_out != nullptr)
			{
				*previous_entry_out = previous_entry;
			}

			return current_entry;
		}

		previous_entry = current_entry;
		current_entry = current_entry->next();
	}

	return nullptr;
}

slat::hook::entry_t* slat::hook::entry_t::find_in_2mb_range(const std::uint64_t target_original_4kb_pfn, const entry_t* const excluding_hook)
{
	entry_t* current_entry = used_hook_list_head;

	const std::uint64_t target_2mb_pfn = target_original_4kb_pfn >> 9;

	while (current_entry != nullptr)
	{
		const std::uint64_t current_hook_2mb_pfn = current_entry->original_pfn() >> 9;

		if (excluding_hook != current_entry && current_hook_2mb_pfn == target_2mb_pfn)
		{
			return current_entry;
		}

		current_entry = current_entry->next();
	}

	return nullptr;
}

slat::hook::entry_t* slat::hook::entry_t::find_closest_in_2mb_range(const std::uint64_t target_original_4kb_pfn, const entry_t* const excluding_hook)
{
	entry_t* current_entry = used_hook_list_head;

	const std::uint64_t target_2mb_pfn = target_original_4kb_pfn >> 9;

	entry_t* closest_entry = nullptr;
	std::int64_t closest_difference = INT64_MAX;

	while (current_entry != nullptr)
	{
		const std::uint64_t current_hook_4kb_pfn = current_entry->original_pfn();
		const std::uint64_t current_hook_2mb_pfn = current_hook_4kb_pfn >> 9;

		if (excluding_hook != current_entry && current_hook_2mb_pfn == target_2mb_pfn)
		{
			const std::int64_t current_difference = crt::abs(static_cast<std::int64_t>(current_hook_4kb_pfn) - static_cast<std::int64_t>(target_original_4kb_pfn));

			if (current_difference < closest_difference)
			{
				closest_difference = current_difference;
				closest_entry = current_entry;
			}
		}

		current_entry = current_entry->next();
	}

	return closest_entry;
}

```

`hyperv-attachment/src/slat/hook/hook_entry.h`:

```h
#pragma once
#include <cstdint>

namespace slat::hook
{
	class entry_t
	{
	protected:
		std::uint64_t next_ : 48;
		std::uint64_t original_read_access_ : 1;
		std::uint64_t original_write_access_ : 1;
		std::uint64_t original_execute_access_ : 1;
		std::uint64_t paging_split_state_ : 1;
		std::uint64_t original_pfn_ : 36;
		std::uint64_t reserved_ : 40;

	public:
		[[nodiscard]] entry_t* next() const;
		void set_next(entry_t* next_entry);

		[[nodiscard]] std::uint64_t original_pfn() const;
		void set_original_pfn(std::uint64_t original_pfn);

		[[nodiscard]] std::uint64_t original_read_access() const;
		[[nodiscard]] std::uint64_t original_write_access() const;
		[[nodiscard]] std::uint64_t original_execute_access() const;
		[[nodiscard]] std::uint64_t paging_split_state() const;

		void set_original_read_access(std::uint64_t original_read_access);
		void set_original_write_access(std::uint64_t original_write_access);
		void set_original_execute_access(std::uint64_t original_execute_access);
		void set_paging_split_state(std::uint64_t paging_split_state);

		static entry_t* find(std::uint64_t target_original_4kb_pfn, entry_t** previous_entry_out = nullptr);
		static entry_t* find_in_2mb_range(std::uint64_t target_original_4kb_pfn, const entry_t* excluding_hook = nullptr);
		static entry_t* find_closest_in_2mb_range(std::uint64_t target_original_4kb_pfn, const entry_t* excluding_hook = nullptr);
	};

	inline entry_t* available_hook_list_head = nullptr;
	inline entry_t* used_hook_list_head = nullptr;
}

```

`hyperv-attachment/src/slat/slat.cpp`:

```cpp
#include "slat.h"
#include "../memory_manager/memory_manager.h"
#include "../memory_manager/heap_manager.h"
#include "../crt/crt.h"
#include <ia32-doc/ia32.hpp>

#include "cr3/cr3.h"
#include "cr3/pte.h"
#include "hook/hook.h"
#include "slat_def.h"

namespace
{
	std::uint64_t dummy_page_pfn = 0;
}

void set_up_dummy_page()
{
	void* const dummy_page_allocation = heap_manager::allocate_page();

	const std::uint64_t dummy_page_physical_address = memory_manager::unmap_host_physical(dummy_page_allocation);

	dummy_page_pfn = dummy_page_physical_address >> 12;

	crt::set_memory(dummy_page_allocation, 0, 0x1000);
}

void slat::set_up()
{
	hook::set_up_entries();
	set_up_dummy_page();
}

void slat::process_first_vmexit()
{
	set_up_hyperv_cr3();
}

std::uint64_t slat::translate_guest_physical_address(const cr3 slat_cr3, const virtual_address_t guest_physical_address, std::uint64_t* const size_left_of_page)
{
	return memory_manager::translate_host_virtual_address(slat_cr3, guest_physical_address, size_left_of_page);
}

std::uint8_t slat::hide_heap_pages(const cr3 slat_cr3)
{
	const std::uint64_t heap_physical_address = heap_manager::initial_physical_base;
	const std::uint64_t heap_physical_end = heap_physical_address + heap_manager::initial_size;

	std::uint64_t current_physical_address = heap_physical_address;

	while (current_physical_address < heap_physical_end)
	{
		hide_physical_page_from_guest(slat_cr3, { .address = current_physical_address });

		current_physical_address += 0x1000;
	}

	return 1;
}

std::uint64_t slat::hide_physical_page_from_guest(const cr3 slat_cr3, const virtual_address_t guest_physical_address)
{
	slat_pte* const target_pte = get_pte(slat_cr3, guest_physical_address, 1);

	if (target_pte == nullptr)
	{
		return 0;
	}

	target_pte->page_frame_number = dummy_page_pfn;

	return 1;
}

std::uint64_t slat::hide_physical_page_from_guest(const virtual_address_t guest_physical_address)
{
	return hide_physical_page_from_guest(hyperv_cr3(), guest_physical_address) && hide_physical_page_from_guest(hook_cr3(), guest_physical_address);
}

```

`hyperv-attachment/src/slat/slat.h`:

```h
#pragma once
#include <ia32-doc/ia32.hpp>
#include <cstdint>

union virtual_address_t;

namespace slat
{
	void set_up();
	void process_first_vmexit();

	std::uint64_t translate_guest_physical_address(cr3 slat_cr3, virtual_address_t guest_physical_address, std::uint64_t* size_left_of_page = nullptr);

	std::uint8_t hide_heap_pages(cr3 slat_cr3);

	std::uint64_t hide_physical_page_from_guest(cr3 slat_cr3, virtual_address_t guest_physical_address);
	std::uint64_t hide_physical_page_from_guest(virtual_address_t guest_physical_address);
}

```

`hyperv-attachment/src/slat/slat_def.h`:

```h
#pragma once
#include "ia32-doc/ia32.hpp"

#ifdef _INTELMACHINE
using slat_pml4e = ept_pml4e;
using slat_pdpte_1gb = ept_pdpte_1gb;
using slat_pdpte = ept_pdpte;
using slat_pde_2mb = ept_pde_2mb;
using slat_pde = ept_pde;
using slat_pte = ept_pte;
#else
using slat_pml4e = pml4e_64;
using slat_pdpte_1gb = pdpte_1gb_64;
using slat_pdpte = pdpte_64;
using slat_pde_2mb = pde_2mb_64;
using slat_pde = pde_64;
using slat_pte = pte_64;
#endif

```

`hyperv-attachment/src/slat/violation/violation.cpp`:

```cpp
#include "violation.h"
#include "../cr3/cr3.h"
#include "../hook/hook_entry.h"

#include "../../arch/arch.h"

std::uint8_t slat::violation::process()
{
#ifdef _INTELMACHINE
	const auto qualification = arch::get_exit_qualification();

	if (!qualification.caused_by_translation)
	{
		return 0;
	}

	const std::uint64_t physical_address = arch::get_guest_physical_address();

	const hook::entry_t* const hook_entry = hook::entry_t::find(physical_address >> 12);

	if (hook_entry == nullptr)
	{
		// potentially newly added executable page
		if (qualification.execute_access)
		{
			set_cr3(hyperv_cr3());
		}

		return 0;
	}

	if (qualification.execute_access)
	{
		set_cr3(hyperv_cr3());

		// page is now --x, and with shadow pfn	
	}
	else
	{
		set_cr3(hook_cr3());

		// page is now rw-, and with original pfn
	}
#else
	const vmcb_t* const vmcb = arch::get_vmcb();

	const npf_exit_info_1 npf_info = { .flags = vmcb->control.first_exit_info };

	if (npf_info.present == 0 || npf_info.execute_access == 0)
	{
		return 0;
	}

	const std::uint64_t physical_address = vmcb->control.second_exit_info;

	const hook::entry_t* const hook_entry = hook::entry_t::find(physical_address >> 12);

	const cr3 hook_slat_cr3 = hook_cr3();

	if (hook_entry == nullptr)
	{
		if (vmcb->control.nested_cr3.flags == hook_slat_cr3.flags)
		{
			set_cr3(hyperv_cr3());

			return 1;
		}

		return 0;
	}

	set_cr3(hook_slat_cr3);
#endif

	return 1;
}

```

`hyperv-attachment/src/slat/violation/violation.h`:

```h
#pragma once
#include <cstdint>

namespace slat::violation
{
	std::uint8_t process();
}

```

`hyperv-attachment/src/structures/virtual_address.h`:

```h
#pragma once
#include <cstdint>

#pragma warning(push)
#pragma warning(disable: 4201)

union virtual_address_t
{
    std::uint64_t address;

    struct
    {
        std::uint64_t offset : 12;
        std::uint64_t pt_idx : 9;
        std::uint64_t pd_idx : 9;
        std::uint64_t pdpt_idx : 9;
        std::uint64_t pml4_idx : 9;
        std::uint64_t reserved : 16;
    };
};

#pragma warning(pop)

```

`load-hyper-reV.bat`:

```bat
@echo off
setlocal

mountvol Z: /S

set boot_directory=Z:\EFI\Microsoft\Boot\

if exist "%boot_directory%bootmgfw.original.efi" (
    echo hyper-reV seems to be already scheduled
) else (
    attrib -s %boot_directory%bootmgfw.efi
    move %boot_directory%bootmgfw.efi %boot_directory%bootmgfw.original.efi

    copy /Y %~dp0uefi-boot.efi %boot_directory%bootmgfw.efi
    copy /Y %~dp0hyperv-attachment.dll %boot_directory%

    bcdedit /set hypervisorlaunchtype auto

    echo hyper-reV will load at next boot
)

endlocal
pause
```

`shared/hypercall/hypercall_def.h`:

```h
#pragma once
#include <cstdint>
#include <structures/memory_operation.h>

enum class hypercall_type_t : std::uint64_t
{
    guest_physical_memory_operation,
    guest_virtual_memory_operation,
    translate_guest_virtual_address,
    read_guest_cr3,
    add_slat_code_hook,
    remove_slat_code_hook,
    hide_guest_physical_page,
    log_current_state,
    flush_logs,
    get_heap_free_page_count
};

#pragma warning(push)
#pragma warning(disable: 4201)

constexpr std::uint64_t hypercall_primary_key = 0x4E47;
constexpr std::uint64_t hypercall_secondary_key = 0x7F;

union hypercall_info_t
{
    std::uint64_t value;

    struct
    {
        std::uint64_t primary_key : 16;
        hypercall_type_t call_type : 4;
        std::uint64_t secondary_key : 7;
        std::uint64_t call_reserved_data : 37;
    };
};

union virt_memory_op_hypercall_info_t
{
    std::uint64_t value;

    struct
    {
        std::uint64_t primary_key : 16;
        hypercall_type_t call_type : 4;
        std::uint64_t secondary_key : 7;
        memory_operation_t memory_operation : 1;
        std::uint64_t address_of_page_directory : 36; // we will construct the other cr3 (aside from the caller process) involved in the operation from this
    };
};

#pragma warning(pop)

```

`shared/structures/memory_operation.h`:

```h
#pragma once
#include <cstdint>

enum class memory_operation_t : std::uint64_t
{
    read_operation,
    write_operation
};

```

`shared/structures/trap_frame.h`:

```h
#pragma once
#include <cstdint>

struct trap_frame_t
{
    std::uint64_t rax;
    std::uint64_t rcx;
    std::uint64_t rdx;
    std::uint64_t rbx;
    std::uint64_t rsp;
    std::uint64_t rbp;
    std::uint64_t rsi;
    std::uint64_t rdi;
    std::uint64_t r8;
    std::uint64_t r9;
    std::uint64_t r10;
    std::uint64_t r11;
    std::uint64_t r12;
    std::uint64_t r13;
    std::uint64_t r14;
    std::uint64_t r15;
};

constexpr std::uint64_t trap_frame_log_stack_data_count = 5;

struct trap_frame_log_t : trap_frame_t
{
    std::uint64_t rip;
    std::uint64_t cr3;

    std::uint64_t stack_data[trap_frame_log_stack_data_count];
};

struct nmi_trap_frame_t
{
    std::uint64_t rax;
    std::uint64_t rcx;
    std::uint64_t rdx;
    std::uint64_t rbx;
    std::uint64_t rbp;
    std::uint64_t rsi;
    std::uint64_t rdi;
    std::uint64_t r8;
    std::uint64_t r9;
    std::uint64_t r10;
    std::uint64_t r11;
    std::uint64_t r12;
    std::uint64_t r13;
    std::uint64_t r14;
    std::uint64_t r15;

    std::uint64_t rip;
    std::uint64_t cs;
    std::uint64_t rflags;
    std::uint64_t rsp;
    std::uint64_t ss;
};

```

`uefi-boot/ext/edk2/build/BaseCacheMaintenanceLib/BaseCacheMaintenanceLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{CE39A737-B7EE-4542-8EF7-B829E8E2FBC0}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseCacheMaintenanceLib\X86Cache.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/BaseCpuLib/BaseCpuLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{DEAFD87B-ED44-4D6E-B6AF-46762DD3B02D}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(SolutionDir)\MSBuild\nasm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(SolutionDir)\MSBuild\nasm.targets" />
  <ItemGroup>
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseCpuLib\x64\CpuFlushTlb.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseCpuLib\x64\CpuSleep.nasm" />
  </ItemGroup>
</Project>
```

`uefi-boot/ext/edk2/build/BaseCryptLib/BaseCryptLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6F08C1AF-ECF2-472D-8ABA-686F8F21CA5E}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\CryptoPkg\Library\Include;$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib;$(OPENSSL_PATH);$(OPENSSL_PATH)\crypto\include;$(OPENSSL_PATH)\crypto\modes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <UndefinePreprocessorDefinitions>_WIN32;_WIN64;_MSC_VER</UndefinePreprocessorDefinitions>
      <DisableSpecificWarnings>4090</DisableSpecificWarnings>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hash\CryptMd4.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hash\CryptMd5.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hash\CryptSha1.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hash\CryptSha256.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hash\CryptSha512.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hmac\CryptHmacMd5.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hmac\CryptHmacSha1.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Hmac\CryptHmacSha256.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Cipher\CryptAes.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Cipher\CryptTdes.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Cipher\CryptArc4.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptRsaBasic.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptRsaExt.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptPkcs5Pbkdf2.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptPkcs7Sign.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptDh.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptX509.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptAuthenticode.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pk\CryptTs.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Pem\CryptPem.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\Rand\CryptRandTsc.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\SysCall\CrtWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\SysCall\TimerWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\BaseCryptLib\SysCall\BaseMemAllocation.c" />
  </ItemGroup>
</Project>
```

`uefi-boot/ext/edk2/build/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7338D0E6-4409-49FA-BD0C-946BE5CE9081}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseDebugPrintErrorLevelLib\BaseDebugPrintErrorLevelLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/BaseLib/BaseLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7DEFAA61-169C-48B9-95B8-410B5493033B}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(SolutionDir)\MSBuild\nasm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(SolutionDir)\MSBuild\nasm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\ARShiftU64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\BitField.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\CheckSum.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\Cpu.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\CpuDeadLoop.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\DivS64x64Remainder.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\DivU64x32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\DivU64x32Remainder.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\DivU64x64Remainder.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\FilePaths.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\GetPowerOfTwo32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\GetPowerOfTwo64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\HighBitSet32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\HighBitSet64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\LinkedList.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\LowBitSet32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\LowBitSet64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\LRotU32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\LRotU64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\LShiftU64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\Math64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\ModU64x32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\MultS64x64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\MultU64x32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\MultU64x64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\RRotU32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\RRotU64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\RShiftU64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\SafeString.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\String.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\SwapBytes16.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\SwapBytes32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\SwapBytes64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\Unaligned.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\CpuBreakpoint.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\Non-existing.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMsr64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMsr64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86DisablePaging32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86DisablePaging64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86EnablePaging32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86EnablePaging64.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86FxRestore.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86FxSave.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86GetInterruptState.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86MemoryFence.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86Msr.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86ReadGdtr.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86ReadIdtr.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86Thunk.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86WriteGdtr.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X86WriteIdtr.c" />
  </ItemGroup>
  <ItemGroup>
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\CpuId.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\CpuIdEx.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\CpuPause.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\DisableCache.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\DisableInterrupts.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\DisablePaging64.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\EnableCache.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\EnableDisableInterrupts.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\EnableInterrupts.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\FlushCacheLine.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\FxRestore.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\FxSave.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\Invd.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\LongJump.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\Monitor.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\Mwait.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadCr0.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadCr2.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadCr3.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadCr4.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadCs.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr0.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr1.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr2.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr3.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr4.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr5.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr6.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDr7.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadDs.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadEflags.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadEs.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadFs.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadGdtr.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadGs.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadIdtr.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadLdtr.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm0.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm1.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm2.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm3.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm4.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm5.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm6.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadMm7.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadPmc.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadSs.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadTr.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\ReadTsc.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\SetJump.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\SwitchStack.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\Wbinvd.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteCr0.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteCr2.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteCr3.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteCr4.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr0.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr1.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr2.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr3.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr4.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr5.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr6.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteDr7.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteGdtr.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteIdtr.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteLdtr.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm0.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm1.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm2.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm3.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm4.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm5.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm6.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseLib\X64\WriteMm7.nasm" />
  </ItemGroup>
</Project>
```

`uefi-boot/ext/edk2/build/BaseLib/vshacks.h`:

```h
#include <Uefi.h>

extern UINT32 _PCD_GET_MODE_32_PcdMaximumLinkedListLength;
extern UINT32 _PCD_GET_MODE_32_PcdMaximumAsciiStringLength;
extern UINT32 _PCD_GET_MODE_32_PcdMaximumUnicodeStringLength;
extern UINT32 _PCD_GET_MODE_32_PcdUefiLibMaxPrintBufferSize;
extern UINT32 _PCD_GET_MODE_32_PcdFixedDebugPrintErrorLevel;
extern UINT32 _PCD_GET_MODE_32_PcdDebugPrintErrorLevel;
extern UINT32 _PCD_GET_MODE_32_PcdMaximumDevicePathNodeCount;
extern UINT32 _PCD_GET_MODE_32_PcdSpinLockTimeout;

extern UINT16 _PCD_GET_MODE_16_PcdUefiFileHandleLibPrintBufferSize;

extern BOOLEAN _PCD_GET_MODE_BOOL_PcdVerifyNodeInList;
extern BOOLEAN _PCD_GET_MODE_BOOL_PcdDriverDiagnosticsDisable;
extern BOOLEAN _PCD_GET_MODE_BOOL_PcdComponentNameDisable;
extern BOOLEAN _PCD_GET_MODE_BOOL_PcdComponentName2Disable;
extern BOOLEAN _PCD_GET_MODE_BOOL_PcdUgaConsumeSupport;
extern BOOLEAN _PCD_GET_MODE_BOOL_PcdDriverDiagnostics2Disable;

extern UINT8 _PCD_GET_MODE_8_PcdDebugPropertyMask;
extern UINT8 _PCD_GET_MODE_8_PcdDebugClearMemoryValue;

extern BOOLEAN _PCD_GET_MODE_BOOL_PcdShellLibAutoInitialize;
extern UINT16 _PCD_GET_MODE_16_PcdShellPrintBufferSize;

extern CHAR8 *gEfiCallerBaseName;

```

`uefi-boot/ext/edk2/build/BaseLib/vshacks.nasm`:

```nasm
%define ASM_PFX(a) a

%define PcdGet32(a) _gPcd_FixedAtBuild_ %+ a
```

`uefi-boot/ext/edk2/build/BaseMemoryLib/BaseMemoryLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{800C8E76-FFE0-4892-BD11-429B51D556D0}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\CompareMemWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\CopyMem.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\CopyMemWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\MemLibGeneric.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\MemLibGuid.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\ScanMem16Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\ScanMem32Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\ScanMem64Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\ScanMem8Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\SetMem.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\SetMem16Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\SetMem32Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\SetMem64Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\SetMemWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseMemoryLib\ZeroMemWrapper.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/BasePrintLib/BasePrintLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{0FF40B47-3294-4652-ADAD-BD484ED6C5B3}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BasePrintLib\PrintLib.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BasePrintLib\PrintLibInternal.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/BaseSynchronizationLib/BaseSynchronizationLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{D100C7E5-DECA-4BBE-AE92-4B7ED03873B1}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(SolutionDir)\MSBuild\nasm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(SolutionDir)\MSBuild\nasm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseSynchronizationLib\SynchronizationMsc.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseSynchronizationLib\X64\InterlockedCompareExchange16.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseSynchronizationLib\X64\InterlockedCompareExchange32.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\BaseSynchronizationLib\X64\InterlockedCompareExchange64.c" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseSynchronizationLib\X64\InterlockedDecrement.nasm" />
    <NASM Include="$(EDK_PATH)\MdePkg\Library\BaseSynchronizationLib\X64\InterlockedIncrement.nasm" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/EDK-II.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BaseLib", "BaseLib\BaseLib.vcxproj", "{7DEFAA61-169C-48B9-95B8-410B5493033B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BaseCpuLib", "BaseCpuLib\BaseCpuLib.vcxproj", "{DEAFD87B-ED44-4D6E-B6AF-46762DD3B02D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiLib", "UefiLib\UefiLib.vcxproj", "{1D620CCA-0BD8-4BEB-A0BC-6D7164E95634}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiApplicationEntryPoint", "UefiApplicationEntryPoint\UefiApplicationEntryPoint.vcxproj", "{93D9DC93-154F-47F0-9FCC-C93AA23CB1C3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BaseCacheMaintenanceLib", "BaseCacheMaintenanceLib\BaseCacheMaintenanceLib.vcxproj", "{CE39A737-B7EE-4542-8EF7-B829E8E2FBC0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiMemoryLib", "UefiMemoryLib\UefiMemoryLib.vcxproj", "{450578CF-FB0F-48F3-8249-B4349E252239}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiMemoryAllocationLib", "UefiMemoryAllocationLib\UefiMemoryAllocationLib.vcxproj", "{878366AB-B98A-4933-A487-DCE343F51371}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BasePrintLib", "BasePrintLib\BasePrintLib.vcxproj", "{0FF40B47-3294-4652-ADAD-BD484ED6C5B3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiDebugLibConOut", "UefiDebugLibConOut\UefiDebugLibConOut.vcxproj", "{B676BEE0-4049-445C-B20D-C3AD7B3983E4}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiBootServicesTableLib", "UefiBootServicesTableLib\UefiBootServicesTableLib.vcxproj", "{8803BB67-A004-4562-8B61-8F49E313A389}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BaseDebugPrintErrorLevelLib", "BaseDebugPrintErrorLevelLib\BaseDebugPrintErrorLevelLib.vcxproj", "{7338D0E6-4409-49FA-BD0C-946BE5CE9081}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiDevicePathLibDevicePathProtocol", "UefiDevicePathLibDevicePathProtocol\UefiDevicePathLibDevicePathProtocol.vcxproj", "{61686617-D12A-487E-A519-EC4AE9403730}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BaseSynchronizationLib", "BaseSynchronizationLib\BaseSynchronizationLib.vcxproj", "{D100C7E5-DECA-4BBE-AE92-4B7ED03873B1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiFileHandleLib", "UefiFileHandleLib\UefiFileHandleLib.vcxproj", "{F93A3A1B-0311-43FB-A6A8-B7592583EDFB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiRuntimeServicesTableLib", "UefiRuntimeServicesTableLib\UefiRuntimeServicesTableLib.vcxproj", "{6E4AF2C5-0A16-4467-A6DE-A81E682C2659}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiDriverEntryPoint", "UefiDriverEntryPoint\UefiDriverEntryPoint.vcxproj", "{A2CFE12C-B942-4A78-97AF-8A0F8FF6DDC7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GlueLib", "GlueLib\GlueLib.vcxproj", "{DF325AB7-67A6-473E-93FF-16955AFBC063}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiRuntimeLib", "UefiRuntimeLib\UefiRuntimeLib.vcxproj", "{4801026C-F7EA-4D77-A98B-C075C253CF32}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BaseMemoryLib", "BaseMemoryLib\BaseMemoryLib.vcxproj", "{800C8E76-FFE0-4892-BD11-429B51D556D0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OpensslLib", "OpensslLib\OpensslLib.vcxproj", "{362BEE7E-5FBE-45D4-B303-3C0451E87C35}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BaseCryptLib", "BaseCryptLib\BaseCryptLib.vcxproj", "{6F08C1AF-ECF2-472D-8ABA-686F8F21CA5E}"
	ProjectSection(ProjectDependencies) = postProject
		{362BEE7E-5FBE-45D4-B303-3C0451E87C35} = {362BEE7E-5FBE-45D4-B303-3C0451E87C35}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IntrinsicLib", "IntrinsicLib\IntrinsicLib.vcxproj", "{74A1C96B-5DAD-4A89-AFA0-AEB6138C1A74}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiShellLib", "UefiShellLib\UefiShellLib.vcxproj", "{D71E4E3B-6239-4AD1-A1C8-272E8673F980}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiSortLib", "UefiSortLib\UefiSortLib.vcxproj", "{9B66ED85-72D6-4581-9A56-4E1F94D0C787}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiHiiLib", "UefiHiiLib\UefiHiiLib.vcxproj", "{53122BEE-9C19-4380-8B7F-B9D8FFA28AB0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UefiHiiServicesLib", "UefiHiiServicesLib\UefiHiiServicesLib.vcxproj", "{8B3E5877-7789-4E21-9E7E-497FCFC70AC4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7DEFAA61-169C-48B9-95B8-410B5493033B}.Release|x64.ActiveCfg = Release|x64
		{7DEFAA61-169C-48B9-95B8-410B5493033B}.Release|x64.Build.0 = Release|x64
		{DEAFD87B-ED44-4D6E-B6AF-46762DD3B02D}.Release|x64.ActiveCfg = Release|x64
		{DEAFD87B-ED44-4D6E-B6AF-46762DD3B02D}.Release|x64.Build.0 = Release|x64
		{1D620CCA-0BD8-4BEB-A0BC-6D7164E95634}.Release|x64.ActiveCfg = Release|x64
		{1D620CCA-0BD8-4BEB-A0BC-6D7164E95634}.Release|x64.Build.0 = Release|x64
		{93D9DC93-154F-47F0-9FCC-C93AA23CB1C3}.Release|x64.ActiveCfg = Release|x64
		{93D9DC93-154F-47F0-9FCC-C93AA23CB1C3}.Release|x64.Build.0 = Release|x64
		{CE39A737-B7EE-4542-8EF7-B829E8E2FBC0}.Release|x64.ActiveCfg = Release|x64
		{CE39A737-B7EE-4542-8EF7-B829E8E2FBC0}.Release|x64.Build.0 = Release|x64
		{450578CF-FB0F-48F3-8249-B4349E252239}.Release|x64.ActiveCfg = Release|x64
		{450578CF-FB0F-48F3-8249-B4349E252239}.Release|x64.Build.0 = Release|x64
		{878366AB-B98A-4933-A487-DCE343F51371}.Release|x64.ActiveCfg = Release|x64
		{878366AB-B98A-4933-A487-DCE343F51371}.Release|x64.Build.0 = Release|x64
		{0FF40B47-3294-4652-ADAD-BD484ED6C5B3}.Release|x64.ActiveCfg = Release|x64
		{0FF40B47-3294-4652-ADAD-BD484ED6C5B3}.Release|x64.Build.0 = Release|x64
		{B676BEE0-4049-445C-B20D-C3AD7B3983E4}.Release|x64.ActiveCfg = Release|x64
		{B676BEE0-4049-445C-B20D-C3AD7B3983E4}.Release|x64.Build.0 = Release|x64
		{8803BB67-A004-4562-8B61-8F49E313A389}.Release|x64.ActiveCfg = Release|x64
		{8803BB67-A004-4562-8B61-8F49E313A389}.Release|x64.Build.0 = Release|x64
		{7338D0E6-4409-49FA-BD0C-946BE5CE9081}.Release|x64.ActiveCfg = Release|x64
		{7338D0E6-4409-49FA-BD0C-946BE5CE9081}.Release|x64.Build.0 = Release|x64
		{61686617-D12A-487E-A519-EC4AE9403730}.Release|x64.ActiveCfg = Release|x64
		{61686617-D12A-487E-A519-EC4AE9403730}.Release|x64.Build.0 = Release|x64
		{D100C7E5-DECA-4BBE-AE92-4B7ED03873B1}.Release|x64.ActiveCfg = Release|x64
		{D100C7E5-DECA-4BBE-AE92-4B7ED03873B1}.Release|x64.Build.0 = Release|x64
		{F93A3A1B-0311-43FB-A6A8-B7592583EDFB}.Release|x64.ActiveCfg = Release|x64
		{F93A3A1B-0311-43FB-A6A8-B7592583EDFB}.Release|x64.Build.0 = Release|x64
		{6E4AF2C5-0A16-4467-A6DE-A81E682C2659}.Release|x64.ActiveCfg = Release|x64
		{6E4AF2C5-0A16-4467-A6DE-A81E682C2659}.Release|x64.Build.0 = Release|x64
		{A2CFE12C-B942-4A78-97AF-8A0F8FF6DDC7}.Release|x64.ActiveCfg = Release|x64
		{A2CFE12C-B942-4A78-97AF-8A0F8FF6DDC7}.Release|x64.Build.0 = Release|x64
		{DF325AB7-67A6-473E-93FF-16955AFBC063}.Release|x64.ActiveCfg = Release|x64
		{DF325AB7-67A6-473E-93FF-16955AFBC063}.Release|x64.Build.0 = Release|x64
		{4801026C-F7EA-4D77-A98B-C075C253CF32}.Release|x64.ActiveCfg = Release|x64
		{4801026C-F7EA-4D77-A98B-C075C253CF32}.Release|x64.Build.0 = Release|x64
		{800C8E76-FFE0-4892-BD11-429B51D556D0}.Release|x64.ActiveCfg = Release|x64
		{800C8E76-FFE0-4892-BD11-429B51D556D0}.Release|x64.Build.0 = Release|x64
		{362BEE7E-5FBE-45D4-B303-3C0451E87C35}.Release|x64.ActiveCfg = Release|x64
		{362BEE7E-5FBE-45D4-B303-3C0451E87C35}.Release|x64.Build.0 = Release|x64
		{6F08C1AF-ECF2-472D-8ABA-686F8F21CA5E}.Release|x64.ActiveCfg = Release|x64
		{6F08C1AF-ECF2-472D-8ABA-686F8F21CA5E}.Release|x64.Build.0 = Release|x64
		{74A1C96B-5DAD-4A89-AFA0-AEB6138C1A74}.Release|x64.ActiveCfg = Release|x64
		{74A1C96B-5DAD-4A89-AFA0-AEB6138C1A74}.Release|x64.Build.0 = Release|x64
		{D71E4E3B-6239-4AD1-A1C8-272E8673F980}.Release|x64.ActiveCfg = Release|x64
		{D71E4E3B-6239-4AD1-A1C8-272E8673F980}.Release|x64.Build.0 = Release|x64
		{9B66ED85-72D6-4581-9A56-4E1F94D0C787}.Release|x64.ActiveCfg = Release|x64
		{9B66ED85-72D6-4581-9A56-4E1F94D0C787}.Release|x64.Build.0 = Release|x64
		{53122BEE-9C19-4380-8B7F-B9D8FFA28AB0}.Release|x64.ActiveCfg = Release|x64
		{53122BEE-9C19-4380-8B7F-B9D8FFA28AB0}.Release|x64.Build.0 = Release|x64
		{8B3E5877-7789-4E21-9E7E-497FCFC70AC4}.Release|x64.ActiveCfg = Release|x64
		{8B3E5877-7789-4E21-9E7E-497FCFC70AC4}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`uefi-boot/ext/edk2/build/GlueLib/GlueLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DF325AB7-67A6-473E-93FF-16955AFBC063}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="initlib.c" />
    <ClCompile Include="guid.c" />
    <ClCompile Include="pcd.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/GlueLib/guid.c`:

```c
/** @file
  Global GUID Definitions

Copyright (c) 2015, Alex Ionescu. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#include <Uefi.h>
#include <Library/UefiLib.h>

#include <Protocol/HiiFont.h>
#include <Protocol/GraphicsOutput.h>
#include <Protocol/UgaDraw.h>
#include <Protocol/DebugPort.h>
#include <Protocol/DevicePathFromText.h>
#include <Protocol/DevicePathToText.h>
#include <Protocol/DevicePathUtilities.h>
#include <Protocol/PciIo.h>
#include <Protocol/LoadedImage.h>
#include <Protocol/AcpiTable.h>
#include <Protocol/Decompress.h>

#include <Protocol/SerialIo.h>
#include <Protocol/UsbIo.h>

#include <Pi/PiDxeCis.h>
#include <Protocol/MpService.h>

#include <Guid/PcAnsi.h>
#include <Guid/GlobalVariable.h>
#include <Guid/EventGroup.h>

#include <Protocol/EfiShellInterface.h>
#include <Protocol/Shell.h>
#include <Protocol/EfiShellEnvironment2.h>
#include <Protocol/ShellParameters.h>
#include <Protocol/UnicodeCollation.h>

#include <Protocol/HiiDatabase.h>
#include <Protocol/HiiString.h>
#include <Protocol/HiiConfigRouting.h>
#include <Protocol/FormBrowser2.h>
#include <Guid/MdeModuleHii.h>

EFI_GUID gEfiPciIoProtocolGuid = EFI_PCI_IO_PROTOCOL_GUID;
EFI_GUID gEfiDriverDiagnosticsProtocolGuid = EFI_DRIVER_DIAGNOSTICS_PROTOCOL_GUID;
EFI_GUID gEfiDriverDiagnostics2ProtocolGuid = EFI_DRIVER_DIAGNOSTICS2_PROTOCOL_GUID;
EFI_GUID gEfiDriverConfigurationProtocolGuid = EFI_DRIVER_CONFIGURATION_PROTOCOL_GUID;
EFI_GUID gEfiDriverConfiguration2ProtocolGuid = EFI_DRIVER_CONFIGURATION2_PROTOCOL_GUID;
EFI_GUID gEfiComponentName2ProtocolGuid = EFI_COMPONENT_NAME2_PROTOCOL_GUID;
EFI_GUID gEfiComponentNameProtocolGuid = EFI_COMPONENT_NAME_PROTOCOL_GUID;
EFI_GUID gEfiDriverBindingProtocolGuid = EFI_DRIVER_BINDING_PROTOCOL_GUID;
EFI_GUID gEfiSimpleTextOutProtocolGuid = EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID;
EFI_GUID gEfiGraphicsOutputProtocolGuid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
EFI_GUID gEfiUgaDrawProtocolGuid = EFI_UGA_DRAW_PROTOCOL_GUID;
EFI_GUID gEfiHiiFontProtocolGuid = EFI_HII_FONT_PROTOCOL_GUID;
EFI_GUID gEfiDevicePathProtocolGuid = EFI_DEVICE_PATH_PROTOCOL_GUID;
EFI_GUID gEfiPcAnsiGuid = EFI_PC_ANSI_GUID;
EFI_GUID gEfiVT100Guid = EFI_VT_100_GUID;
EFI_GUID gEfiVT100PlusGuid = EFI_VT_100_PLUS_GUID;
EFI_GUID gEfiVTUTF8Guid = EFI_VT_UTF8_GUID;
EFI_GUID gEfiUartDevicePathGuid = DEVICE_PATH_MESSAGING_UART_FLOW_CONTROL;
EFI_GUID gEfiSasDevicePathGuid = EFI_SAS_DEVICE_PATH_GUID;
EFI_GUID gEfiDebugPortProtocolGuid = EFI_DEBUGPORT_PROTOCOL_GUID;
EFI_GUID gEfiDevicePathUtilitiesProtocolGuid = EFI_DEVICE_PATH_UTILITIES_PROTOCOL_GUID;
EFI_GUID gEfiDevicePathToTextProtocolGuid = EFI_DEVICE_PATH_TO_TEXT_PROTOCOL_GUID;
EFI_GUID gEfiDevicePathFromTextProtocolGuid = EFI_DEVICE_PATH_FROM_TEXT_PROTOCOL_GUID;
EFI_GUID gEfiGlobalVariableGuid = EFI_GLOBAL_VARIABLE;
EFI_GUID gEfiLoadedImageProtocolGuid = EFI_LOADED_IMAGE_PROTOCOL_GUID;
EFI_GUID gEfiAcpiTableProtocolGuid = EFI_ACPI_TABLE_PROTOCOL_GUID;
EFI_GUID gEfiDecompressProtocolGuid = EFI_DECOMPRESS_PROTOCOL_GUID;

EFI_GUID gEfiEventExitBootServicesGuid = EFI_EVENT_GROUP_EXIT_BOOT_SERVICES;
EFI_GUID gEfiEventVirtualAddressChangeGuid = EFI_EVENT_GROUP_VIRTUAL_ADDRESS_CHANGE;

EFI_GUID gEfiUsbIoProtocolGuid = EFI_USB_IO_PROTOCOL_GUID;
EFI_GUID gEfiSerialIoProtocolGuid = EFI_SERIAL_IO_PROTOCOL_GUID;

EFI_GUID gEfiMpServiceProtocolGuid = EFI_MP_SERVICES_PROTOCOL_GUID;

EFI_GUID gEfiShellInterfaceGuid = SHELL_INTERFACE_PROTOCOL_GUID;
EFI_GUID gEfiShellProtocolGuid = EFI_SHELL_PROTOCOL_GUID;
EFI_GUID gEfiFileInfoGuid = EFI_FILE_INFO_ID;
EFI_GUID gEfiShellEnvironment2Guid = SHELL_ENVIRONMENT_PROTOCOL_GUID;
EFI_GUID gEfiShellEnvironment2ExtGuid = EFI_SE_EXT_SIGNATURE_GUID;
EFI_GUID gEfiSimpleFileSystemProtocolGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
EFI_GUID gEfiShellParametersProtocolGuid = EFI_SHELL_PARAMETERS_PROTOCOL_GUID;
EFI_GUID gEfiUnicodeCollation2ProtocolGuid = EFI_UNICODE_COLLATION_PROTOCOL2_GUID;

EFI_GUID gEfiHiiStringProtocolGuid = EFI_HII_STRING_PROTOCOL_GUID;
EFI_GUID gEfiHiiDatabaseProtocolGuid = EFI_HII_DATABASE_PROTOCOL_GUID;
EFI_GUID gEfiHiiImageProtocolGuid = EFI_HII_IMAGE_PROTOCOL_GUID;
EFI_GUID gEfiHiiConfigRoutingProtocolGuid = EFI_HII_CONFIG_ROUTING_PROTOCOL_GUID;

EFI_GUID gEfiFormBrowser2ProtocolGuid = EFI_FORM_BROWSER2_PROTOCOL_GUID;

EFI_GUID gEdkiiIfrBitVarstoreGuid = EDKII_IFR_BIT_VARSTORE_GUID;

```

`uefi-boot/ext/edk2/build/GlueLib/initlib.c`:

```c
/** @file
  Glue Library Initialization Code

Copyright (c) 2015, Alex Ionescu. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#include <Uefi.h>

#include <Library/DevicePathLib.h>
#include <Library/UefiLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>

EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  );

EFI_STATUS
EFIAPI
UefiUnload (
  IN EFI_HANDLE        ImageHandle
  );

EFI_STATUS
EFIAPI
UefiBootServicesTableLibConstructor (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
);

EFI_STATUS
EFIAPI
UefiRuntimeServicesTableLibConstructor (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
);

EFI_STATUS
EFIAPI
UefiLibConstructor (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
);

EFI_STATUS
EFIAPI
DevicePathLibConstructor (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
);

EFI_STATUS
EFIAPI
RuntimeDriverLibConstruct (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
);

EFI_STATUS
EFIAPI
RuntimeDriverLibDeconstruct (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
);

EFI_STATUS
EFIAPI
UefiHiiServicesLibConstructor (
    IN EFI_HANDLE        ImageHandle,
    IN EFI_SYSTEM_TABLE  *SystemTable
);

/**
  Calls library constructors.

  This function calls all the constructors that the UEFI libraries contain. As
  of now this includes the Boot and Runtime Services Table Library constructor,
  the UEFI Library constructor, and the Device Path Library constructor.

  @param  ImageHandle           The image handle of the UEFI Application.
  @param  SystemTable           A pointer to the EFI System Table.

  @retval EFI_SUCCESS           Operation was completed sucessfully.
**/
EFI_STATUS 
EFIAPI
ProcessLibraryConstructorList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  UefiBootServicesTableLibConstructor(ImageHandle, SystemTable);

  UefiRuntimeServicesTableLibConstructor(ImageHandle, SystemTable);

  UefiLibConstructor(ImageHandle, SystemTable);

  DevicePathLibConstructor(ImageHandle, SystemTable);

//  RuntimeDriverLibConstruct(ImageHandle, SystemTable);

  UefiHiiServicesLibConstructor(ImageHandle, SystemTable);

  return EFI_SUCCESS;
}

/**
  Call library destructors.

  This function calls all the destructors that the UEFI libraries contain. As
  of now, none of the libraries have any destructors.

  @param  ImageHandle           The image handle of the UEFI Application.
  @param  SystemTable           A pointer to the EFI System Table.
**/
VOID
EFIAPI
ProcessLibraryDestructorList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
 // RuntimeDriverLibDeconstruct(ImageHandle, SystemTable);
}

/**
  Calls module entrypoints.

  This function calls all the entrypoints that are part of this UEFI module.
  For modules being built with this library, we assume that only one entry
  point exists, and that it is called UefiMain.

  @param  ImageHandle           The image handle of the UEFI Application.
  @param  SystemTable           A pointer to the EFI System Table.

  @retval EFI_SUCCESS           Operation was completed sucessfully.
**/
EFI_STATUS
EFIAPI
ProcessModuleEntryPointList (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  return UefiMain (ImageHandle, SystemTable);
}

/**
  Calls module unload functions.

  This function calls all the unload functions part of this UEFI module.
  For modules being built with this library, we assume that only one unload
  function exists, and that it is called UefiUnload.

  @param  ImageHandle           The image handle of the UEFI Application.

  @retval EFI_SUCCESS           Operation was completed sucessfully.
**/
EFI_STATUS
EFIAPI
ProcessModuleUnloadList (
  IN EFI_HANDLE        ImageHandle
  )
{
  return UefiUnload (ImageHandle);
}


```

`uefi-boot/ext/edk2/build/GlueLib/pcd.c`:

```c
/** @file
  Global Platform Configuration Data (PCD)

Copyright (c) 2015, Alex Ionescu. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Pi/PiStatusCode.h>

BOOLEAN _PCD_GET_MODE_BOOL_PcdComponentNameDisable = FALSE;
BOOLEAN _PCD_GET_MODE_BOOL_PcdDriverDiagnosticsDisable = FALSE;
BOOLEAN _PCD_GET_MODE_BOOL_PcdComponentName2Disable = FALSE;
BOOLEAN _PCD_GET_MODE_BOOL_PcdDriverDiagnostics2Disable = FALSE;
BOOLEAN _PCD_GET_MODE_BOOL_PcdUefiVariableDefaultLangDeprecate  = FALSE;
BOOLEAN _PCD_GET_MODE_BOOL_PcdUgaConsumeSupport = TRUE;
BOOLEAN _PCD_GET_MODE_BOOL_PcdVerifyNodeInList = FALSE;
BOOLEAN _PCD_GET_MODE_BOOL_PcdValidateOrderedCollection = FALSE;

UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueEfiWatchDogTimerExpired = EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_TIMER_EXPIRED;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueSetVirtualAddressMap = EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_RS_PC_SET_VIRTUAL_ADDRESS_MAP;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueMemoryTestStarted = EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_PC_TEST;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueUncorrectableMemoryError = EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_UNCORRECTABLE;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueRemoteConsoleError = EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_CONTROLLER_ERROR;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueRemoteConsoleReset = EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_PC_RESET;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueRemoteConsoleInputError = EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_INPUT_ERROR;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueRemoteConsoleOutputError = EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_OUTPUT_ERROR;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueMouseInterfaceError = EFI_PERIPHERAL_MOUSE | EFI_P_EC_INTERFACE_ERROR;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueMouseEnable = EFI_PERIPHERAL_MOUSE | EFI_P_PC_ENABLE;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueMouseDisable = EFI_PERIPHERAL_MOUSE | EFI_P_PC_DISABLE;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardEnable = EFI_PERIPHERAL_KEYBOARD | EFI_P_PC_ENABLE;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardDisable = EFI_PERIPHERAL_KEYBOARD | EFI_P_PC_DISABLE;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardPresenceDetect = EFI_PERIPHERAL_KEYBOARD | EFI_P_PC_PRESENCE_DETECT;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardReset = EFI_PERIPHERAL_KEYBOARD | EFI_P_PC_RESET;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardClearBuffer = EFI_PERIPHERAL_KEYBOARD | EFI_P_KEYBOARD_PC_CLEAR_BUFFER;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardSelfTest = EFI_PERIPHERAL_KEYBOARD | EFI_P_KEYBOARD_PC_SELF_TEST;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardInterfaceError = EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_INTERFACE_ERROR;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueKeyboardInputError = EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_INPUT_ERROR;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueMouseInputError = EFI_PERIPHERAL_MOUSE | EFI_P_EC_INPUT_ERROR;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueMouseReset = EFI_PERIPHERAL_MOUSE | EFI_P_PC_RESET;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValuePeiHandoffToDxe = EFI_SOFTWARE_PEI_CORE | EFI_SW_PEI_CORE_PC_HANDOFF_TO_NEXT;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValuePeimDispatch = EFI_SOFTWARE_PEI_CORE | EFI_SW_PC_INIT_BEGIN;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValuePeiCoreEntry = EFI_SOFTWARE_PEI_CORE | EFI_SW_PC_INIT;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueDxeCoreEntry = EFI_SOFTWARE_DXE_CORE | EFI_SW_DXE_CORE_PC_ENTRY_POINT;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueDxeCoreHandoffToBds = EFI_SOFTWARE_DXE_CORE | EFI_SW_DXE_CORE_PC_HANDOFF_TO_NEXT;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueBootServiceExit = EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_BS_PC_EXIT_BOOT_SERVICES;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueDxeDriverBegin = EFI_SOFTWARE_DXE_CORE | EFI_SW_PC_INIT_BEGIN;
UINT32 _PCD_GET_MODE_32_PcdStatusCodeValueDxeDriverEnd = EFI_SOFTWARE_DXE_CORE | EFI_SW_PC_INIT_END;

UINT32 _PCD_GET_MODE_32_PcdFixedDebugPrintErrorLevel = 0xFFFFFFFF;
UINT32 _PCD_GET_MODE_32_PcdMaximumUnicodeStringLength = 1000000;
UINT32 _PCD_GET_MODE_32_PcdMaximumAsciiStringLength = 1000000;
UINT32 _PCD_GET_MODE_32_PcdMaximumLinkedListLength = 1000000;
UINT32 _PCD_GET_MODE_32_PcdMaximumDevicePathNodeCount = 0;
UINT32 _PCD_GET_MODE_32_PcdSpinLockTimeout = 10000000;

UINT8 _PCD_GET_MODE_8_PcdDebugPropertyMask = 0;
UINT32 _PCD_GET_MODE_32_PcdDebugPrintErrorLevel = 0x80000000;
UINT8 _PCD_GET_MODE_8_PcdReportStatusCodePropertyMask = 0;
UINT8 _PCD_GET_MODE_8_PcdDebugClearMemoryValue = 0xAF;
UINT8 _PCD_GET_MODE_8_PcdPerformanceLibraryPropertyMask = 0;

UINT8 _PCD_GET_MODE_8_PcdPostCodePropertyMask = 0;

UINT32 _PCD_GET_MODE_32_PcdFSBClock = 200000000;
UINT32 _PCD_GET_MODE_32_PcdUefiLibMaxPrintBufferSize = 320;

UINT16 _PCD_GET_MODE_16_PcdUefiFileHandleLibPrintBufferSize = 1536;

UINT32 _PCD_GET_MODE_32_PcdMaximumGuidedExtractHandler = 0x10;
UINT32 _PCD_GET_MODE_32_PcdUsbTransferTimeoutValue = 3000;

UINT64 _PCD_GET_MODE_64_PcdGuidedExtractHandlerTableAddress = 0x1000000;
UINT64 _PCD_GET_MODE_64_PcdIoBlockBaseAddressForIpf = 0x0ffffc000000;
UINT64 _PCD_GET_MODE_64_PcdPciExpressBaseAddress = 0xE0000000;

CHAR8* PcdUefiVariableDefaultLangCodes = "engfraengfra";
CHAR8* PcdUefiVariableDefaultLang = "eng";
CHAR8* PcdUefiVariableDefaultPlatformLangCodes = "en;fr;en-US;fr-FR";
CHAR8* PcdUefiVariableDefaultPlatformLang = "en-US";

UINT64 _PCD_GET_MODE_64_PcdUartDefaultBaudRate = 115200;
UINT8 _PCD_GET_MODE_8_PcdUartDefaultDataBits = 8;
UINT8 _PCD_GET_MODE_8_PcdUartDefaultParity = 1;
UINT8 _PCD_GET_MODE_8_PcdUartDefaultStopBits = 1;
UINT8 _PCD_GET_MODE_8_PcdDefaultTerminalType = 0;

UINT16 _PCD_GET_MODE_16_PcdHardwareErrorRecordLevel = 0;
UINT16 _PCD_GET_MODE_16_PcdPlatformBootTimeOut = 0xffff;

BOOLEAN _PCD_GET_MODE_BOOL_PcdShellLibAutoInitialize = FALSE;
UINT16 _PCD_GET_MODE_16_PcdShellPrintBufferSize = 16000;
```

`uefi-boot/ext/edk2/build/IntrinsicLib/IntrinsicLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{74A1C96B-5DAD-4A89-AFA0-AEB6138C1A74}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemDefinitionGroup>
    <ClCompile>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\IntrinsicLib\MemoryIntrinsics.c" />
    <ClCompile Include="$(EDK_PATH)\CryptoPkg\Library\IntrinsicLib\CopyMem.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/MSBuild/nasm.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(NASMBeforeTargets)' == '' and '$(NASMAfterTargets)' == '' and '$(ConfigurationType)' != 'Makefile'">
    <NASMBeforeTargets>Midl</NASMBeforeTargets>
    <NASMAfterTargets>CustomBuild</NASMAfterTargets>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <NASM>
      <GenerateDebugInformation>True</GenerateDebugInformation>
      <IncludePaths>$(EDK_PATH)\MdePkg;$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Library\BaseLib\X64;$(EDK_PATH)\MdePkg\Include\X64</IncludePaths>
      <PreIncludeFiles>$(SolutionDir)BaseLib\vshacks.nasm</PreIncludeFiles>
      <OutputFormat>$(IntDir)%(FileName).obj</OutputFormat>
      <Outputswitch>1</Outputswitch>
      <CompilerNasm>$(NASM_PREFIX)nasm.exe</CompilerNasm>
      <PackAlignmentBoundary>0</PackAlignmentBoundary>
      <CommandLineTemplate>"%(CompilerNasm)" [AllOptions] [AdditionalOptions] "%(FullPath)"</CommandLineTemplate>
      <ExecutionDescription>Assembling %(Filename)%(Extension)</ExecutionDescription>
    </NASM>
  </ItemDefinitionGroup>
</Project>
```

`uefi-boot/ext/edk2/build/MSBuild/nasm.targets`:

```targets
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)$(MSBuildThisFileName).xml"/>
    <AvailableItemName Include="NASM">
      <Targets>_NASM</Targets>
    </AvailableItemName>
  </ItemGroup>
  <PropertyGroup>
    <ComputeLinkInputsTargets>
      $(ComputeLinkInputsTargets);
      ComputeNASMOutput;
    </ComputeLinkInputsTargets>
    <ComputeLibInputsTargets>
      $(ComputeLibInputsTargets);
      ComputeNASMOutput;
    </ComputeLibInputsTargets>
  </PropertyGroup>
  <UsingTask TaskName="NASM" TaskFactory="XamlTaskFactory" AssemblyName="Microsoft.Build.Tasks.v4.0">
    <Task>$(MSBuildThisFileDirectory)$(MSBuildThisFileName).xml</Task>
  </UsingTask>
  <Target Name="_NASM" BeforeTargets="$(NASMBeforeTargets)" AfterTargets="$(NASMAfterTargets)" Condition="'@(NASM)' != ''" Outputs="%(NASM.OutputFormat)" Inputs="%(NASM.Identity);%(NASM.AdditionalDependencies);$(MSBuildProjectFile)" DependsOnTargets="_SelectedFiles">
    <ItemGroup Condition="'@(SelectedFiles)' != ''">
      <NASM Remove="@(NASM)" Condition="'%(Identity)' != '@(SelectedFiles)'"/>
    </ItemGroup>
    <ItemGroup>
      <NASM_tlog Include="%(NASM.OutputFormat)" Condition="'%(NASM.OutputFormat)' != '' and '%(NASM.ExcludedFromBuild)' != 'true'">
        <Source>@(NASM, '|')</Source>
      </NASM_tlog>
    </ItemGroup>
    <Message Importance="High" Text="%(NASM.ExecutionDescription)"/>
    <WriteLinesToFile Condition="'@(NASM_tlog)' != '' and '%(NASM_tlog.ExcludedFromBuild)' != 'true'" File="$(IntDir)$(ProjectName).write.1.tlog" Lines="^%(NASM_tlog.Source);@(NASM_tlog-&gt;'%(Fullpath)')"/>
    <NASM Condition="'@(NASM)' != '' and '%(NASM.ExcludedFromBuild)' != 'true'" Inputs="%(NASM.Inputs)" OutputFormat="%(NASM.OutputFormat)" Outputswitch="%(NASM.Outputswitch)" AssembledCodeListingFile="%(NASM.AssembledCodeListingFile)" GenerateDebugInformation="%(NASM.GenerateDebugInformation)" ErrorReporting="%(NASM.ErrorReporting)" IncludePaths="%(NASM.IncludePaths)" PreIncludeFiles="%(NASM.PreIncludeFiles)" PreprocessorDefinitions="%(NASM.PreprocessorDefinitions)" UndefinePreprocessorDefinitions="%(NASM.UndefinePreprocessorDefinitions)" ErrorReportingFormat="%(NASM.ErrorReportingFormat)" TreatWarningsAsErrors="%(NASM.TreatWarningsAsErrors)" floatunderflow="%(NASM.floatunderflow)" macrodefaults="%(NASM.macrodefaults)" user="%(NASM.user)" floatoverflow="%(NASM.floatoverflow)" floatdenorm="%(NASM.floatdenorm)" numberoverflow="%(NASM.numberoverflow)" macroselfref="%(NASM.macroselfref)" floattoolong="%(NASM.floattoolong)" orphanlabels="%(NASM.orphanlabels)" CommandLineTemplate="%(NASM.CommandLineTemplate)" AdditionalOptions="%(NASM.AdditionalOptions)"/>
  </Target>
  <Target Name="ComputeNASMOutput" Condition="'@(NASM)' != ''">
    <ItemGroup>
      <Link Include="@(NASM-&gt;Metadata('OutputFormat')-&gt;Distinct()-&gt;ClearMetadata())" Condition="'%(NASM.ExcludedFromBuild)' != 'true'"/>
      <Lib Include="@(NASM-&gt;Metadata('OutputFormat')-&gt;Distinct()-&gt;ClearMetadata())" Condition="'%(NASM.ExcludedFromBuild)' != 'true'"/>
    </ItemGroup>
  </Target>
</Project>
```

`uefi-boot/ext/edk2/build/MSBuild/nasm.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ProjectSchemaDefinitions xmlns="http://schemas.microsoft.com/build/2009/properties" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <Rule Name="NASM" PageTemplate="tool" DisplayName="Netwide Assembler" Order="200">
    <Rule.DataSource>
      <DataSource Persistence="ProjectFile" ItemType="NASM"/>
    </Rule.DataSource>
    <Rule.Categories>
      <Category Name="General">
        <Category.DisplayName>
          <sys:String>General</sys:String>
        </Category.DisplayName>
      </Category>
      <Category Name="Preprocessor">
        <Category.DisplayName>
          <sys:String>Preprocessing Options</sys:String>
        </Category.DisplayName>
      </Category>
      <Category Name="Assembler Options">
        <Category.DisplayName>
          <sys:String>Assembler Options</sys:String>
        </Category.DisplayName>
      </Category>
      <Category Name="Advanced">
        <Category.DisplayName>
          <sys:String>Advanced </sys:String>
        </Category.DisplayName>
      </Category>
      <Category Name="Command Line" Subtype="CommandLine">
        <Category.DisplayName>
          <sys:String>Command Line</sys:String>
        </Category.DisplayName>
      </Category>
    </Rule.Categories>
    <StringProperty Name="Inputs" Category="Command Line" IsRequired="true">
      <StringProperty.DataSource>
        <DataSource Persistence="ProjectFile" ItemType="NASM" SourceType="Item"/>
      </StringProperty.DataSource>
    </StringProperty>
    <StringProperty Name="OutputFormat" Category="Assembler Options" HelpUrl="http://www.nasm.us/doc/" DisplayName="Output File Name" Description="Specify Output Filename.-o [value]" Switch="-o &quot;[value]&quot;"/>
    <BoolProperty Name="tasmmode" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="SciTech TASM compatible mode" Description="assemble in SciTech TASM compatible mode" Switch="-t"/>
    <EnumProperty Name="Outputswitch" Category="Assembler Options" HelpUrl="http://www.nasm.us/doc/" DisplayName="Output Switch" Description="Select the type of output format required. Linking Should be disabled for ELF and Binary ,else error will popup">
      <EnumValue Name="0" DisplayName="Object File win32" Switch="-fwin32"/>
      <EnumValue Name="1" DisplayName="Object File win64" Switch="-fwin64"/>
      <EnumValue Name="2" DisplayName="ELF32 (i386) object files (e.g. Linux)" Switch="-felf32"/>
      <EnumValue Name="3" DisplayName="ELF64 (x86_64) object files (e.g. Linux)" Switch="-felf64"/>
    </EnumProperty>
    <StringListProperty Name="AssembledCodeListingFile" Category="Assembler Options" DisplayName="Assembled Code Listing File" Description="Generates an assembled code listing file.     (-l [file])" HelpUrl="http://www.nasm.us/doc/" Switch="-l &quot;[value]&quot;"/>
    <BoolProperty Name="GenerateDebugInformation" Category="Assembler Options" DisplayName="Generate Debug Information" Description="Generates Debug Information.     (-g)" HelpUrl="http://www.nasm.us/doc/" Switch="-g"/>
    <StringListProperty Name="ErrorReporting" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Redirect Error Messages to File" Description="Drops the error Message on specified device" Switch="-Z &quot;[value]&quot;"/>
    <StringListProperty Name="IncludePaths" Category="General" DisplayName="Include Paths" Description="Sets path for include file.     (-I[path])" HelpUrl="http://www.nasm.us/doc/" Switch="-I&quot;[value]&quot;"/>
    <StringListProperty Name="PreIncludeFiles" Category="General" DisplayName="Pre-Include Files" Description="Sets files for pre-include.     (-P[path])" HelpUrl="http://www.nasm.us/doc/" Switch="-P&quot;[value]&quot;"/>
    <StringListProperty Name="PreprocessorDefinitions" Category="Preprocessor" HelpUrl="http://www.nasm.us/doc/" DisplayName="Preprocessor Definitions" Description="Defines a text macro with the given name.     (-D[symbol])" Switch="-D&quot;[value]&quot;"/>
    <StringListProperty Name="UndefinePreprocessorDefinitions" Category="Preprocessor" HelpUrl="http://www.nasm.us/doc/" DisplayName="Undefine Preprocessor Definitions" Description="Undefines a text macro with the given name.     (-U[symbol])" Switch="-U&quot;[value]&quot;"/>
    <EnumProperty Name="ErrorReportingFormat" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Error Reporting Format" Description="Select the error reporting format ie. GNU or VC">
      <EnumValue Name="0" DisplayName="-Xgnu GNU format: Default format" Switch="-Xgnu"/>
      <EnumValue Name="1" DisplayName="-Xvc Style used by Microsoft Visual C++" Switch="-Xvc"/>
    </EnumProperty>
    <BoolProperty Name="TreatWarningsAsErrors" Category="Assembler Options" DisplayName="Treat Warnings As Errors" Description="Returns an error code if warnings are generated.     (-Werror)" HelpUrl="http://www.nasm.us/doc/" Switch="-Werror"/>
    <BoolProperty Name="floatunderflow" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="float-underflow" Description="floating point underflow (default off)" Switch="-w+float-underflow"/>
    <BoolProperty Name="macrodefaults" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Disable macro-defaults" Description="macros with more default than optional parameters (default on)" Switch="-w-macro-defaults"/>
    <BoolProperty Name="user" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Disable user" Description="%warning directives (default on)" Switch="-w-user"/>
    <BoolProperty Name="floatoverflow" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Disable float-overflow" Description="floating point overflow (default on)" Switch="-w-float-overflow"/>
    <BoolProperty Name="floatdenorm" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="float-denorm" Description="floating point denormal (default off)" Switch="-w+float-denorm"/>
    <BoolProperty Name="numberoverflow" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Disable number-overflow" Description="numeric constant does not fit (default on)" Switch="-w-number-overflow"/>
    <BoolProperty Name="macroselfref" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="macro-selfref" Description="cyclic macro references (default off)" Switch="-w+macro-selfref"/>
    <BoolProperty Name="floattoolong" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Disable float-toolong" Description=" too many digits in floating-point number (default on)" Switch="-w-float-toolong"/>
    <BoolProperty Name="orphanlabels" Category="Advanced" HelpUrl="http://www.nasm.us/doc/" DisplayName="Disable orphan-labels" Description="labels alone on lines without trailing `:' (default on)" Switch="-w-orphan-labels"/>
    <StringProperty Name="CommandLineTemplate" DisplayName="Command Line" Visible="False" IncludeInCommandLine="False"/>
    <DynamicEnumProperty Name="NASMBeforeTargets" Category="General" EnumProvider="Targets" IncludeInCommandLine="False">
      <DynamicEnumProperty.DisplayName>
        <sys:String>Execute Before</sys:String>
      </DynamicEnumProperty.DisplayName>
      <DynamicEnumProperty.Description>
        <sys:String>Specifies the targets for the build customization to run before.</sys:String>
      </DynamicEnumProperty.Description>
      <DynamicEnumProperty.ProviderSettings>
        <NameValuePair Name="Exclude" Value="^NASMBeforeTargets|^Compute"/>
      </DynamicEnumProperty.ProviderSettings>
      <DynamicEnumProperty.DataSource>
        <DataSource Persistence="ProjectFile" ItemType="" HasConfigurationCondition="true"/>
      </DynamicEnumProperty.DataSource>
    </DynamicEnumProperty>
    <DynamicEnumProperty Name="NASMAfterTargets" Category="General" EnumProvider="Targets" IncludeInCommandLine="False">
      <DynamicEnumProperty.DisplayName>
        <sys:String>Execute After</sys:String>
      </DynamicEnumProperty.DisplayName>
      <DynamicEnumProperty.Description>
        <sys:String>Specifies the targets for the build customization to run after.</sys:String>
      </DynamicEnumProperty.Description>
      <DynamicEnumProperty.ProviderSettings>
        <NameValuePair Name="Exclude" Value="^NASMAfterTargets|^Compute"/>
      </DynamicEnumProperty.ProviderSettings>
      <DynamicEnumProperty.DataSource>
        <DataSource Persistence="ProjectFile" ItemType="" HasConfigurationCondition="true"/>
      </DynamicEnumProperty.DataSource>
    </DynamicEnumProperty>
    <StringProperty Name="ExecutionDescription" DisplayName="Execution Description" IncludeInCommandLine="False" Visible="False"/>
    <StringListProperty Name="AdditionalDependencies" DisplayName="Additional Dependencies" IncludeInCommandLine="False" Visible="False"/>
    <StringProperty Subtype="AdditionalOptions" Name="AdditionalOptions" Category="Command Line">
      <StringProperty.DisplayName>
        <sys:String>Additional Options</sys:String>
      </StringProperty.DisplayName>
      <StringProperty.Description>
        <sys:String>Additional Options</sys:String>
      </StringProperty.Description>
    </StringProperty>
  </Rule>
  <ItemType Name="NASM" DisplayName="Netwide Assembler"/>
  <FileExtension Name="*.asm" ContentType="NASM"/>
  <FileExtension Name="*.nasm" ContentType="NASM"/>
  <ContentType Name="NASM" DisplayName="Netwide Assembler" ItemType="NASM"/>
</ProjectSchemaDefinitions>
```

`uefi-boot/ext/edk2/build/OpensslLib/OpensslLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{362BEE7E-5FBE-45D4-B303-3C0451E87C35}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\CryptoPkg\Library\Include;$(EDK_PATH)\CryptoPkg\Library\OpensslLib;$(OPENSSL_PATH);$(OPENSSL_PATH)\crypto\include;$(OPENSSL_PATH)\crypto\modes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalOptions>/wd4133 /wd4244 /wd4245 /wd4267 /wd4701 /wd4305 /wd4306 /wd4702 /wd4706 /wd4311 /wd4090 /wd4146 %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>L_ENDIAN;OPENSSL_SMALL_FOOTPRINT;NO_SYSLOG</PreprocessorDefinitions>
      <UndefinePreprocessorDefinitions>_WIN32;_WIN64;_MSC_VER</UndefinePreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="$(OPENSSL_PATH)\crypto\cryptlib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\mem.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\mem_clr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\mem_dbg.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\cversion.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ex_data.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\cpt_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ebcdic.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\uid.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\o_time.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\o_str.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\o_dir.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\threads_pthread.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\threads_win.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\threads_none.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\o_init.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\o_fips.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\mem_sec.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\init.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\objects\o_names.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\objects\obj_dat.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\objects\obj_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\objects\obj_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\objects\obj_xref.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\md4\md4_dgst.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\md4\md4_one.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\md5\md5_dgst.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\md5\md5_one.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\sha\sha1dgst.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\sha\sha1_one.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\sha\sha256.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\sha\sha512.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\hmac\hmac.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\hmac\hm_ameth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\hmac\hm_pmeth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\poly1305\poly1305.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\cbc_cksm.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\cbc_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\cfb64enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\cfb_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\ecb3_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\ecb_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\fcrypt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\ofb64enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\ofb_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\pcbc_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\qud_cksm.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\rand_key.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\rpc_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\set_key.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\des_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\fcrypt_b.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\xcbc_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\str2key.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\cfb64ede.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\des\ofb64ede.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_core.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_misc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_ecb.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_cbc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_cfb.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_ofb.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_ige.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\aes\aes_wrap.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rc4\rc4_skey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rc4\rc4_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\chacha\chacha_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\cbc128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\ctr128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\cts128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\cfb128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\ofb128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\gcm128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\ccm128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\xts128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\wrap128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\modes\ocb128.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_add.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_div.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_exp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_ctx.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_mul.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_mod.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_print.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_rand.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_shift.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_word.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_blind.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_kron.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_sqrt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_gcd.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_prime.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_sqr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_asm.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_recp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_mont.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_mpi.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_exp2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_gf2m.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_nist.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_depr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_const.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_x931p.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_intern.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_dh.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bn\bn_srp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_ossl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_gen.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_sign.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_saos.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_pk1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_ssl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_none.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_oaep.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_chk.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_null.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_pss.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_x931.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_asn1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_depr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_ameth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_prn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_pmeth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_crpt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rsa\rsa_x931g.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_asn1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_gen.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_key.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_check.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_depr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_ameth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_pmeth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_prn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_rfc5114.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dh\dh_kdf.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dso\dso_dl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dso\dso_dlfcn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dso\dso_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dso\dso_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dso\dso_openssl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dso\dso_win32.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\dso\dso_vms.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\buffer\buffer.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\buffer\buf_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bio_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bio_cb.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bio_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bio_meth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_mem.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_null.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_fd.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_file.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_sock.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_conn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bf_null.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bf_buff.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\b_dump.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\b_addr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\b_sock.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\b_sock2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_acpt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bf_nbio.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_log.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_bio.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\bio\bss_dgram.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\stack\stack.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\lhash\lhash.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\lhash\lh_stats.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rand\md_rand.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rand\randfile.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rand\rand_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rand\rand_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rand\rand_egd.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rand\rand_win.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\rand\rand_unix.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\err\err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\err\err_all.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\err\err_prn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\encode.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\digest.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\evp_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\evp_key.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\evp_cnf.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_des.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_bf.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_idea.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_des3.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_camellia.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_rc4.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_aes.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\names.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_seed.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_xcbc_d.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_rc2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_cast.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_rc5.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_null.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_md2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_md4.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_md5.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_sha1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_wp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_md5_sha1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_mdc2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_ripemd.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p_open.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p_seal.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p_sign.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p_verify.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p_dec.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\bio_md.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\bio_b64.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\bio_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\evp_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_null.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\c_allc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\c_alld.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\evp_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\bio_ok.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\evp_pkey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\evp_pbe.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p5_crpt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\p5_crpt2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\scrypt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_old.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\pmeth_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\pmeth_fn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\pmeth_gn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\m_sigver.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_aes_cbc_hmac_sha1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_aes_cbc_hmac_sha256.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_rc4_hmac_md5.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\e_chacha20_poly1305.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\evp\cmeth_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_object.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_bitstr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_utctm.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_gentm.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_time.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_int.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_octet.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_print.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_type.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_dup.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_d2i_fp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_i2d_fp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_utf8.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_sign.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_digest.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_verify.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_mbstr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_strex.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_algor.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_val.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_sig.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_bignum.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_long.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_info.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_spki.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\nsseq.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\d2i_pu.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\d2i_pr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\i2d_pu.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\i2d_pr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\t_pkey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\t_spki.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\t_bitst.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_new.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_fre.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_enc.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_dec.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_utl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_typ.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_prn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\tasn_scn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\ameth_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\f_int.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\f_string.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\n_pkey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\x_pkey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\bio_asn1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\bio_ndef.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn_mime.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn1_gen.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn1_par.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn1_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn1_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\a_strnid.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\evp_asn1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn_pack.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\p5_pbe.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\p5_pbev2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\p5_scrypt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\p8_pkey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn_moid.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\asn1\asn_mstbl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_sign.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_info.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_all.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_x509.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_xaux.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_oth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_pk8.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pem_pkey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pem\pvkfmt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_def.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_d2.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_r2x.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_cmp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_obj.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_req.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509spki.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_vfy.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_set.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509cset.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509rset.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509name.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_v3.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_ext.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_att.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509type.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_lu.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_all.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_txt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_trs.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\by_file.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\by_dir.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x509_vpm.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_crl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\t_crl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_req.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\t_req.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_x509.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\t_x509.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_x509a.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_attrib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_exten.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_name.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509\x_pubkey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_bcons.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_bitst.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_conf.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_extku.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_ia5.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_prn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_utl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_genn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_alt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_skey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_akey.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_pku.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_int.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_enum.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_sxnet.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_cpols.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_crld.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_purp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_info.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_akeya.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_pmaps.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_pcons.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_ncons.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_pcia.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_pci.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\pcy_cache.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\pcy_node.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\pcy_data.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\pcy_map.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\pcy_tree.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\pcy_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_asid.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_addr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\x509v3\v3_tlsf.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\conf\conf_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\conf\conf_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\conf\conf_api.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\conf\conf_def.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\conf\conf_mod.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\conf\conf_mall.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\conf\conf_sap.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\txt_db\txt_db.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\pk7_asn1.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\pk7_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\pkcs7err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\pk7_doit.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\pk7_smime.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\pk7_attr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\pk7_mime.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs7\bio_pk7.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_add.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_asn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_attr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_crpt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_crt.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_decr.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_init.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_key.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_kiss.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_mutl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_sbag.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_utl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_npas.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\pk12err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_p8d.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\pkcs12\p12_p8e.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\comp\comp_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\comp\comp_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\comp\c_zlib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_asn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_ext.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_ht.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_lib.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_cl.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_srv.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_prn.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_vfy.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\ocsp_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\ocsp\v3_ocsp.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\cmac\cmac.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\cmac\cm_ameth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\cmac\cm_pmeth.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\async\async.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\async\async_wait.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\async\async_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\async\arch\async_posix.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\async\arch\async_win.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\async\arch\async_null.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\kdf\tls1_prf.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\kdf\kdf_err.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\kdf\hkdf.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\blake2\blake2b.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\blake2\m_blake2b.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\blake2\blake2s.c" />
    <ClCompile Include="$(OPENSSL_PATH)\crypto\blake2\m_blake2s.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiApplicationEntryPoint/UefiApplicationEntryPoint.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{93D9DC93-154F-47F0-9FCC-C93AA23CB1C3}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiApplicationEntryPoint\ApplicationEntryPoint.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiBootServicesTableLib/UefiBootServicesTableLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8803BB67-A004-4562-8B61-8F49E313A389}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiBootServicesTableLib\UefiBootServicesTableLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiDebugLibConOut/UefiDebugLibConOut.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{B676BEE0-4049-445C-B20D-C3AD7B3983E4}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiDebugLibConOut\DebugLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiDevicePathLibDevicePathProtocol/UefiDevicePathLibDevicePathProtocol.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{61686617-D12A-487E-A519-EC4AE9403730}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiDevicePathLibDevicePathProtocol\UefiDevicePathLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiDriverEntryPoint/UefiDriverEntryPoint.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{A2CFE12C-B942-4A78-97AF-8A0F8FF6DDC7}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiDriverEntryPoint\DriverEntryPoint.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiFileHandleLib/UefiFileHandleLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{F93A3A1B-0311-43FB-A6A8-B7592583EDFB}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiFileHandleLib\UefiFileHandleLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiHiiLib/UefiHiiLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{53122BEE-9C19-4380-8B7F-B9D8FFA28AB0}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdeModulePkg\Library\UefiHiiLib\HiiLanguage.c" />
    <ClCompile Include="$(EDK_PATH)\MdeModulePkg\Library\UefiHiiLib\HiiLib.c" />
    <ClCompile Include="$(EDK_PATH)\MdeModulePkg\Library\UefiHiiLib\HiiString.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiHiiServicesLib/UefiHiiServicesLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8B3E5877-7789-4E21-9E7E-497FCFC70AC4}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdeModulePkg\Library\UefiHiiServicesLib\UefiHiiServicesLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiLib/UefiLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1D620CCA-0BD8-4BEB-A0BC-6D7164E95634}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiLib\Console.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiLib\UefiDriverModel.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiLib\UefiLib.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiLib\UefiLibPrint.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiLib\UefiNotTiano.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiMemoryAllocationLib/UefiMemoryAllocationLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{878366AB-B98A-4933-A487-DCE343F51371}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryAllocationLib\MemoryAllocationLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiMemoryLib/UefiMemoryLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{450578CF-FB0F-48F3-8249-B4349E252239}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\CompareMemWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\CopyMemWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\MemLib.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\MemLibGeneric.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\MemLibGuid.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\ScanMem16Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\ScanMem32Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\ScanMem64Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\ScanMem8Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\SetMem16Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\SetMem32Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\SetMem64Wrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\SetMemWrapper.c" />
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiMemoryLib\ZeroMemWrapper.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiRuntimeLib/UefiRuntimeLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4801026C-F7EA-4D77-A98B-C075C253CF32}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiRuntimeLib\RuntimeLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6E4AF2C5-0A16-4467-A6DE-A81E682C2659}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdePkg\Library\UefiRuntimeServicesTableLib\UefiRuntimeServicesTableLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiShellLib/UefiShellLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{D71E4E3B-6239-4AD1-A1C8-272E8673F980}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\ShellPkg\Library\UefiShellLib\UefiShellLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/UefiSortLib/UefiSortLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9B66ED85-72D6-4581-9A56-4E1F94D0C787}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\edk2.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  <Import Project="$(SolutionDir)\edk2.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <ItemGroup>
    <ClCompile Include="$(EDK_PATH)\MdeModulePkg\Library\UefiSortLib\UefiSortLib.c" />
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/edk2.default.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EDK_PATH>$(SolutionDir)..\src</EDK_PATH>
    <OPENSSL_PATH>$(SolutionDir)..\..\openssl</OPENSSL_PATH>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Include\X64;$(EDK_PATH)\MdeModulePkg\Include;$(EDK_PATH)\ShellPkg\Include;$(EDK_PATH)\CryptoPkg\include;$(OPENSSL_PATH)\include</IncludePath>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <ItemGroup>
    <BuildMacro Include="EDK_PATH">
      <Value>$(EDK_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
    <BuildMacro Include="OPENSSL_PATH">
      <Value>$(OPENSSL_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
  </ItemGroup>
</Project>

```

`uefi-boot/ext/edk2/build/edk2.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup>
    <GenerateManifest />
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <WarningLevel>Level4</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <OmitFramePointers>true</OmitFramePointers>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>$(SolutionDir)\BaseLib\vshacks.h</ForcedIncludeFiles>
      <CallingConvention />
      <TreatWChar_tAsBuiltInType />
      <StringPooling>true</StringPooling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ForceConformanceInForLoopScope />
      <AdditionalOptions>/Gs32768 %(AdditionalOptions)</AdditionalOptions>
      <ErrorReporting />
      <FloatingPointModel />
    </ClCompile>
    <Link>
      <AdditionalDependencies />
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>Debug</GenerateDebugInformation>
      <SubSystem>EFI Boot Service Driver</SubSystem>
      <Driver>Driver</Driver>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding />
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>0</BaseAddress>
      <SectionAlignment>32</SectionAlignment>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <RegisterOutput>true</RegisterOutput>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <ManifestFile />
      <AllowIsolation />
      <EnableUAC />
      <UACExecutionLevel />
      <UACUIAccess />
      <TypeLibraryResourceID />
      <AdditionalOptions>/OPT:ICF=10 /IGNORE:4001 /IGNORE:4254 /IGNORE:4281 %(AdditionalOptions)</AdditionalOptions>
      <MergeSections>.rdata=.data</MergeSections>
      <SpecifySectionAttributes>.pdata,D</SpecifySectionAttributes>
      <LinkErrorReporting />
      <ProfileGuidedDatabase />
    </Link>
  </ItemDefinitionGroup>
</Project>

```

`uefi-boot/ext/ia32-doc/ia32_compact.h`:

```h
#pragma once

typedef unsigned __int64    UINT64;
typedef __int64             INT64;
typedef unsigned __int32    UINT32;
typedef __int32             INT32;
typedef unsigned short      UINT16;
typedef unsigned short      CHAR16;
typedef short               INT16;
typedef unsigned char       BOOLEAN;
typedef unsigned char       UINT8;
typedef char                CHAR8;
typedef signed char         INT8;

#if defined(_MSC_EXTENSIONS)
#pragma warning(push)
#pragma warning(disable: 4201)
#endif

/**
 * @defgroup intel_manual \
 *           Intel Manual
 * @{
 */
 /**
  * @defgroup control_registers \
  *           Control registers
  * @{
  */
typedef union {
    struct {
        UINT64 protection_enable : 1;
        UINT64 monitor_coprocessor : 1;
        UINT64 emulate_fpu : 1;
        UINT64 task_switched : 1;
        UINT64 extensionype : 1;
        UINT64 numeric_error : 1;
        UINT64 reserved_1 : 10;
        UINT64 write_protect : 1;
        UINT64 reserved_2 : 1;
        UINT64 alignment_mask : 1;
        UINT64 reserved_3 : 10;
        UINT64 not_writehrough : 1;
        UINT64 cache_disable : 1;
        UINT64 paging_enable : 1;
    };

    UINT64 flags;
} cr0;

typedef union {
    struct {
        UINT64 reserved_1 : 3;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 reserved_2 : 7;
        UINT64 address_of_page_directory : 36;
    };

    UINT64 flags;
} cr3;

typedef union {
    struct {
        UINT64 virtual_mode_extensions : 1;
        UINT64 protected_mode_virtual_interrupts : 1;
        UINT64 timestamp_disable : 1;
        UINT64 debugging_extensions : 1;
        UINT64 page_size_extensions : 1;
        UINT64 physical_address_extension : 1;
        UINT64 machine_check_enable : 1;
        UINT64 page_global_enable : 1;
        UINT64 performance_monitoring_counter_enable : 1;
        UINT64 os_fxsave_fxrstor_support : 1;
        UINT64 os_xmm_exception_support : 1;
        UINT64 usermode_instruction_prevention : 1;
        UINT64 linear_addresses_57_bit : 1;
        UINT64 vmx_enable : 1;
        UINT64 smx_enable : 1;
        UINT64 reserved_1 : 1;
        UINT64 fsgsbase_enable : 1;
        UINT64 pcid_enable : 1;
        UINT64 os_xsave : 1;
        UINT64 key_locker_enable : 1;
        UINT64 smep_enable : 1;
        UINT64 smap_enable : 1;
        UINT64 protection_key_enable : 1;
        UINT64 control_flow_enforcement_enable : 1;
        UINT64 protection_key_for_supervisor_mode_enable : 1;
    };

    UINT64 flags;
} cr4;

typedef union {
    struct {
        UINT64 task_priority_level : 4;
        UINT64 reserved : 60;
    };

    UINT64 flags;
} cr8;

/**
 * @}
 */

 /**
  * @defgroup debug_registers \
  *           Debug registers
  * @{
  */
typedef union {
    struct {
        UINT64 breakpoint_condition : 4;
        UINT64 reserved_1 : 9;
        UINT64 debug_register_access_detected : 1;
        UINT64 single_instruction : 1;
        UINT64 task_switch : 1;
        UINT64 restrictedransactional_memory : 1;
    };

    UINT64 flags;
} dr6;

typedef union {
    struct {
        UINT64 local_breakpoint_0 : 1;
        UINT64 global_breakpoint_0 : 1;
        UINT64 local_breakpoint_1 : 1;
        UINT64 global_breakpoint_1 : 1;
        UINT64 local_breakpoint_2 : 1;
        UINT64 global_breakpoint_2 : 1;
        UINT64 local_breakpoint_3 : 1;
        UINT64 global_breakpoint_3 : 1;
        UINT64 local_exact_breakpoint : 1;
        UINT64 global_exact_breakpoint : 1;
        UINT64 reserved_1 : 1;
        UINT64 restrictedransactional_memory : 1;
        UINT64 reserved_2 : 1;
        UINT64 general_detect : 1;
        UINT64 reserved_3 : 2;
        UINT64 read_write_0 : 2;
        UINT64 length_0 : 2;
        UINT64 read_write_1 : 2;
        UINT64 length_1 : 2;
        UINT64 read_write_2 : 2;
        UINT64 length_2 : 2;
        UINT64 read_write_3 : 2;
        UINT64 length_3 : 2;
    };

    UINT64 flags;
} dr7;

/**
 * @}
 */

 /**
  * @defgroup cpuid \
  *           CPUID
  * @{
  */
#define CPUID_SIGNATURE                                              0x00000000
typedef struct {
    UINT32 max_cpuid_input_value;
    UINT32 ebx_value_genu;
    UINT32 ecx_value_ntel;
    UINT32 edx_value_inei;
} cpuid_eax_00;

#define CPUID_VERSION_INFO                                           0x00000001
typedef struct {
    union {
        struct {
            UINT32 stepping_id : 4;
            UINT32 model : 4;
            UINT32 family_id : 4;
            UINT32 processorype : 2;
            UINT32 reserved_1 : 2;
            UINT32 extended_model_id : 4;
            UINT32 extended_family_id : 8;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 brand_index : 8;
            UINT32 clflush_line_size : 8;
            UINT32 max_addressable_ids : 8;
            UINT32 initial_apic_id : 8;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 streaming_simd_extensions_3 : 1;
            UINT32 pclmulqdq_instruction : 1;
            UINT32 ds_area_64bit_layout : 1;
            UINT32 monitor_mwait_instruction : 1;
            UINT32 cpl_qualified_debug_store : 1;
            UINT32 virtual_machine_extensions : 1;
            UINT32 safer_mode_extensions : 1;
            UINT32 enhanced_intel_speedstepechnology : 1;
            UINT32 thermal_monitor_2 : 1;
            UINT32 supplemental_streaming_simd_extensions_3 : 1;
            UINT32 l1_context_id : 1;
            UINT32 silicon_debug : 1;
            UINT32 fma_extensions : 1;
            UINT32 cmpxchg16b_instruction : 1;
            UINT32 xtpr_update_control : 1;
            UINT32 perfmon_and_debug_capability : 1;
            UINT32 reserved_1 : 1;
            UINT32 process_context_identifiers : 1;
            UINT32 direct_cache_access : 1;
            UINT32 sse41_support : 1;
            UINT32 sse42_support : 1;
            UINT32 x2apic_support : 1;
            UINT32 movbe_instruction : 1;
            UINT32 popcnt_instruction : 1;
            UINT32 tsc_deadline : 1;
            UINT32 aesni_instruction_extensions : 1;
            UINT32 xsave_xrstor_instruction : 1;
            UINT32 osx_save : 1;
            UINT32 avx_support : 1;
            UINT32 half_precision_conversion_instructions : 1;
            UINT32 rdrand_instruction : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 floating_point_unit_on_chip : 1;
            UINT32 virtual_8086_mode_enhancements : 1;
            UINT32 debugging_extensions : 1;
            UINT32 page_size_extension : 1;
            UINT32 timestamp_counter : 1;
            UINT32 rdmsr_wrmsr_instructions : 1;
            UINT32 physical_address_extension : 1;
            UINT32 machine_check_exception : 1;
            UINT32 cmpxchg8b_instruction : 1;
            UINT32 apic_on_chip : 1;
            UINT32 reserved_1 : 1;
            UINT32 sysenter_sysexit_instructions : 1;
            UINT32 memoryype_range_registers : 1;
            UINT32 page_global_bit : 1;
            UINT32 machine_check_architecture : 1;
            UINT32 conditional_move_instructions : 1;
            UINT32 page_attributeable : 1;
            UINT32 page_size_extension_36bit : 1;
            UINT32 processor_serial_number : 1;
            UINT32 clflush_instruction : 1;
            UINT32 reserved_2 : 1;
            UINT32 debug_store : 1;
            UINT32 thermal_control_msrs_for_acpi : 1;
            UINT32 mmx_support : 1;
            UINT32 fxsave_fxrstor_instructions : 1;
            UINT32 sse_support : 1;
            UINT32 sse2_support : 1;
            UINT32 self_snoop : 1;
            UINT32 hyperhreadingechnology : 1;
            UINT32 thermal_monitor : 1;
            UINT32 reserved_3 : 1;
            UINT32 pending_break_enable : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_01;

#define CPUID_CACHE_PARAMS                                           0x00000004
typedef struct {
    union {
        struct {
            UINT32 cacheype_field : 5;
            UINT32 cache_level : 3;
            UINT32 self_initializing_cache_level : 1;
            UINT32 fully_associative_cache : 1;
            UINT32 reserved_1 : 4;
            UINT32 max_addressable_ids_for_logical_processors_sharinghis_cache : 12;
            UINT32 max_addressable_ids_for_processor_cores_in_physical_package : 6;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 system_coherency_line_size : 12;
            UINT32 physical_line_partitions : 10;
            UINT32 ways_of_associativity : 10;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 number_of_sets : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 write_back_invalidate : 1;
            UINT32 cache_inclusiveness : 1;
            UINT32 complex_cache_indexing : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_04;

#define CPUID_MONITOR_MWAIT                                          0x00000005
typedef struct {
    union {
        struct {
            UINT32 smallest_monitor_line_size : 16;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 largest_monitor_line_size : 16;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 enumeration_of_monitor_mwait_extensions : 1;
            UINT32 supportsreating_interrupts_as_break_event_for_mwait : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 number_of_c0_sub_c_states : 4;
            UINT32 number_of_c1_sub_c_states : 4;
            UINT32 number_of_c2_sub_c_states : 4;
            UINT32 number_of_c3_sub_c_states : 4;
            UINT32 number_of_c4_sub_c_states : 4;
            UINT32 number_of_c5_sub_c_states : 4;
            UINT32 number_of_c6_sub_c_states : 4;
            UINT32 number_of_c7_sub_c_states : 4;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_05;

#define CPUIDHERMAL_POWER_MANAGEMENT                               0x00000006
typedef struct {
    union {
        struct {
            UINT32 temperature_sensor_supported : 1;
            UINT32 intelurbo_boostechnology_available : 1;
            UINT32 apicimer_always_running : 1;
            UINT32 reserved_1 : 1;
            UINT32 power_limit_notification : 1;
            UINT32 clock_modulation_duty : 1;
            UINT32 packagehermal_management : 1;
            UINT32 hwp_base_registers : 1;
            UINT32 hwp_notification : 1;
            UINT32 hwp_activity_window : 1;
            UINT32 hwp_energy_performance_preference : 1;
            UINT32 hwp_package_level_request : 1;
            UINT32 reserved_2 : 1;
            UINT32 hdc : 1;
            UINT32 intelurbo_boost_maxechnology_3_available : 1;
            UINT32 hwp_capabilities : 1;
            UINT32 hwp_peci_override : 1;
            UINT32 flexible_hwp : 1;
            UINT32 fast_access_mode_for_hwp_request_msr : 1;
            UINT32 reserved_3 : 1;
            UINT32 ignoring_idle_logical_processor_hwp_request : 1;
            UINT32 reserved_4 : 2;
            UINT32 intelhread_director : 1;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 number_of_interrupthresholds_inhermal_sensor : 4;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 hardware_coordination_feedback_capability : 1;
            UINT32 reserved_1 : 2;
            UINT32 number_of_intelhread_director_classes : 1;
            UINT32 reserved_2 : 4;
            UINT32 performance_energy_bias_preference : 8;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_06;

#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS                      0x00000007
typedef struct {
    union {
        struct {
            UINT32 number_of_sub_leaves : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 fsgsbase : 1;
            UINT32 ia32sc_adjust_msr : 1;
            UINT32 sgx : 1;
            UINT32 bmi1 : 1;
            UINT32 hle : 1;
            UINT32 avx2 : 1;
            UINT32 fdp_excptn_only : 1;
            UINT32 smep : 1;
            UINT32 bmi2 : 1;
            UINT32 enhanced_rep_movsb_stosb : 1;
            UINT32 invpcid : 1;
            UINT32 rtm : 1;
            UINT32 rdt_m : 1;
            UINT32 deprecates : 1;
            UINT32 mpx : 1;
            UINT32 rdt : 1;
            UINT32 avx512f : 1;
            UINT32 avx512dq : 1;
            UINT32 rdseed : 1;
            UINT32 adx : 1;
            UINT32 smap : 1;
            UINT32 avx512_ifma : 1;
            UINT32 reserved_1 : 1;
            UINT32 clflushopt : 1;
            UINT32 clwb : 1;
            UINT32 intel : 1;
            UINT32 avx512pf : 1;
            UINT32 avx512er : 1;
            UINT32 avx512cd : 1;
            UINT32 sha : 1;
            UINT32 avx512bw : 1;
            UINT32 avx512vl : 1;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 prefetchwt1 : 1;
            UINT32 avx512_vbmi : 1;
            UINT32 umip : 1;
            UINT32 pku : 1;
            UINT32 ospke : 1;
            UINT32 waitpkg : 1;
            UINT32 avx512_vbmi2 : 1;
            UINT32 cet_ss : 1;
            UINT32 gfni : 1;
            UINT32 vaes : 1;
            UINT32 vpclmulqdq : 1;
            UINT32 avx512_vnni : 1;
            UINT32 avx512_bitalg : 1;
            UINT32 tme_en : 1;
            UINT32 avx512_vpopcntdq : 1;
            UINT32 reserved_1 : 1;
            UINT32 la57 : 1;
            UINT32 mawau : 5;
            UINT32 rdpid : 1;
            UINT32 kl : 1;
            UINT32 reserved_2 : 1;
            UINT32 cldemote : 1;
            UINT32 reserved_3 : 1;
            UINT32 movdiri : 1;
            UINT32 movdir64b : 1;
            UINT32 reserved_4 : 1;
            UINT32 sgx_lc : 1;
            UINT32 pks : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved_1 : 2;
            UINT32 avx512_4vnniw : 1;
            UINT32 avx512_4fmaps : 1;
            UINT32 fast_short_rep_mov : 1;
            UINT32 reserved_2 : 3;
            UINT32 avx512_vp2intersect : 1;
            UINT32 reserved_3 : 1;
            UINT32 md_clear : 1;
            UINT32 reserved_4 : 3;
            UINT32 serialize : 1;
            UINT32 hybrid : 1;
            UINT32 reserved_5 : 2;
            UINT32 pconfig : 1;
            UINT32 reserved_6 : 1;
            UINT32 cet_ibt : 1;
            UINT32 reserved_7 : 5;
            UINT32 ibrs_ibpb : 1;
            UINT32 stibp : 1;
            UINT32 l1d_flush : 1;
            UINT32 ia32_arch_capabilities : 1;
            UINT32 ia32_core_capabilities : 1;
            UINT32 ssbd : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_07;

#define CPUID_DIRECT_CACHE_ACCESS_INFO                               0x00000009
typedef struct {
    union {
        struct {
            UINT32 ia32_platform_dca_cap : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_09;

#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING                   0x0000000A
typedef struct {
    union {
        struct {
            UINT32 version_id_of_architectural_performance_monitoring : 8;
            UINT32 number_of_performance_monitoring_counter_per_logical_processor : 8;
            UINT32 bit_width_of_performance_monitoring_counter : 8;
            UINT32 ebx_bit_vector_length : 8;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 core_cycle_event_not_available : 1;
            UINT32 instruction_retired_event_not_available : 1;
            UINT32 reference_cycles_event_not_available : 1;
            UINT32 last_level_cache_reference_event_not_available : 1;
            UINT32 last_level_cache_misses_event_not_available : 1;
            UINT32 branch_instruction_retired_event_not_available : 1;
            UINT32 branch_mispredict_retired_event_not_available : 1;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 number_of_fixed_function_performance_counters : 5;
            UINT32 bit_width_of_fixed_function_performance_counters : 8;
            UINT32 reserved_1 : 2;
            UINT32 anyhread_deprecation : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_0a;

#define CPUID_EXTENDEDOPOLOGY                                      0x0000000B
typedef struct {
    union {
        struct {
            UINT32 x2apic_ido_uniqueopology_id_shift : 5;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 number_of_logical_processors_athis_levelype : 16;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 level_number : 8;
            UINT32 levelype : 8;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 x2apic_id : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_0b;

/**
 * @defgroup cpuid_eax_0d \
 *           EAX = 0x0D
 * @{
 */
#define CPUID_EXTENDED_STATE                                         0x0000000D
typedef struct {
    union {
        struct {
            UINT32 x87_state : 1;
            UINT32 sse_state : 1;
            UINT32 avx_state : 1;
            UINT32 mpx_state : 2;
            UINT32 avx_512_state : 3;
            UINT32 used_for_ia32_xss_1 : 1;
            UINT32 pkru_state : 1;
            UINT32 reserved_1 : 3;
            UINT32 used_for_ia32_xss_2 : 1;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 max_size_required_by_enabled_features_in_xcr0 : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 max_size_of_xsave_xrstor_save_area : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 xcr0_supported_bits : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_0d_ecx_00;

typedef struct {
    union {
        struct {
            UINT32 reserved_1 : 1;
            UINT32 supports_xsavec_and_compacted_xrstor : 1;
            UINT32 supports_xgetbv_with_ecx_1 : 1;
            UINT32 supports_xsave_xrstor_and_ia32_xss : 1;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 size_of_xsave_aread : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 used_for_xcr0_1 : 8;
            UINT32 pt_state : 1;
            UINT32 used_for_xcr0_2 : 1;
            UINT32 reserved_1 : 1;
            UINT32 cet_user_state : 1;
            UINT32 cet_supervisor_state : 1;
            UINT32 hdc_state : 1;
            UINT32 reserved_2 : 1;
            UINT32 lbr_state : 1;
            UINT32 hwp_state : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 supported_upper_ia32_xss_bits : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_0d_ecx_01;

typedef struct {
    union {
        struct {
            UINT32 ia32_platform_dca_cap : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 ecx_2 : 1;
            UINT32 ecx_1 : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_0d_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_0f \
  *           EAX = 0x0F
  * @{
  */
#define CPUID_INTEL_RDT_MONITORING                                   0x0000000F
typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 rmid_max_range : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved_1 : 1;
            UINT32 supports_l3_cache_intel_rdt_monitoring : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_0f_ecx_00;

typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 conversion_factor : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 rmid_max_range : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 supports_l3_occupancy_monitoring : 1;
            UINT32 supports_l3otal_bandwidth_monitoring : 1;
            UINT32 supports_l3_local_bandwidth_monitoring : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_0f_ecx_01;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_10 \
  *           EAX = 0x10
  * @{
  */
#define CPUID_INTEL_RDT_ALLOCATION                                   0x00000010
typedef struct {
    union {
        struct {
            UINT32 ia32_platform_dca_cap : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved_1 : 1;
            UINT32 supports_l3_cache_allocationechnology : 1;
            UINT32 supports_l2_cache_allocationechnology : 1;
            UINT32 supports_memory_bandwidth_allocation : 1;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_10_ecx_00;

typedef struct {
    union {
        struct {
            UINT32 length_of_capacity_bit_mask : 5;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 ebx_0 : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved_1 : 2;
            UINT32 code_and_data_priorizationechnology_supported : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 highest_cos_number_supported : 16;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_10_ecx_01;

typedef struct {
    union {
        struct {
            UINT32 length_of_capacity_bit_mask : 5;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 ebx_0 : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 highest_cos_number_supported : 16;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_10_ecx_02;

typedef struct {
    union {
        struct {
            UINT32 max_mbahrottling_value : 12;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved_1 : 2;
            UINT32 response_of_delay_is_linear : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 highest_cos_number_supported : 16;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_10_ecx_03;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_12 \
  *           EAX = 0x12
  * @{
  */
#define CPUID_INTEL_SGX                                              0x00000012
typedef struct {
    union {
        struct {
            UINT32 sgx1 : 1;
            UINT32 sgx2 : 1;
            UINT32 reserved_1 : 3;
            UINT32 sgx_enclv_advanced : 1;
            UINT32 sgx_encls_advanced : 1;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 miscselect : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 max_enclave_size_not64 : 8;
            UINT32 max_enclave_size_64 : 8;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_12_ecx_00;

typedef struct {
    union {
        struct {
            UINT32 valid_secs_attributes_0 : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 valid_secs_attributes_1 : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 valid_secs_attributes_2 : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 valid_secs_attributes_3 : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_12_ecx_01;

typedef struct {
    union {
        struct {
            UINT32 sub_leafype : 4;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 zero : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 zero : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 zero : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_0;

typedef struct {
    union {
        struct {
            UINT32 sub_leafype : 4;
            UINT32 reserved_1 : 8;
            UINT32 epc_base_physical_address_1 : 20;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 epc_base_physical_address_2 : 20;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 epc_section_property : 4;
            UINT32 reserved_1 : 8;
            UINT32 epc_size_1 : 20;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 epc_size_2 : 20;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_12_ecx_02p_slt_1;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_14 \
  *           EAX = 0x14
  * @{
  */
#define CPUID_INTEL_PROCESSORRACE                                  0x00000014
typedef struct {
    union {
        struct {
            UINT32 max_sub_leaf : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 flag0 : 1;
            UINT32 flag1 : 1;
            UINT32 flag2 : 1;
            UINT32 flag3 : 1;
            UINT32 flag4 : 1;
            UINT32 flag5 : 1;
            UINT32 flag6 : 1;
            UINT32 flag7 : 1;
            UINT32 flag8 : 1;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 flag0 : 1;
            UINT32 flag1 : 1;
            UINT32 flag2 : 1;
            UINT32 flag3 : 1;
            UINT32 reserved_1 : 27;
            UINT32 flag31 : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_14_ecx_00;

typedef struct {
    union {
        struct {
            UINT32 number_of_configurable_address_ranges_for_filtering : 3;
            UINT32 reserved_1 : 13;
            UINT32 bitmap_of_supported_mtc_period_encodings : 16;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 bitmap_of_supported_cyclehreshold_value_encodings : 16;
            UINT32 bitmap_of_supported_configurable_psb_frequency_encodings : 16;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_14_ecx_01;

/**
 * @}
 */

#define CPUIDIME_STAMP_COUNTER                                     0x00000015
typedef struct {
    union {
        struct {
            UINT32 denominator : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 numerator : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 nominal_frequency : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_15;

#define CPUID_PROCESSOR_FREQUENCY                                    0x00000016
typedef struct {
    union {
        struct {
            UINT32 procesor_base_frequency_mhz : 16;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 processor_maximum_frequency_mhz : 16;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 bus_frequency_mhz : 16;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_16;

/**
 * @defgroup cpuid_eax_17 \
 *           EAX = 0x17
 * @{
 */
#define CPUID_SOC_VENDOR                                             0x00000017
typedef struct {
    union {
        struct {
            UINT32 max_soc_id_index : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 soc_vendor_id : 16;
            UINT32 is_vendor_scheme : 1;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 project_id : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 stepping_id : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_17_ecx_00;

typedef struct {
    union {
        struct {
            UINT32 soc_vendor_brand_string : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 soc_vendor_brand_string : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 soc_vendor_brand_string : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 soc_vendor_brand_string : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_17_ecx_01_03;

typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_17_ecx_n;

/**
 * @}
 */

 /**
  * @defgroup cpuid_eax_18 \
  *           EAX = 0x18
  * @{
  */
#define CPUID_DETERMINISTIC_ADDRESSRANSLATION_PARAMETERS           0x00000018
typedef struct {
    union {
        struct {
            UINT32 max_sub_leaf : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 page_entries_4kb_supported : 1;
            UINT32 page_entries_2mb_supported : 1;
            UINT32 page_entries_4mb_supported : 1;
            UINT32 page_entries_1gb_supported : 1;
            UINT32 reserved_1 : 4;
            UINT32 partitioning : 3;
            UINT32 reserved_2 : 5;
            UINT32 ways_of_associativity_00 : 16;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 number_of_sets : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 translation_cacheype_field : 5;
            UINT32 translation_cache_level : 3;
            UINT32 fully_associative_structure : 1;
            UINT32 reserved_1 : 5;
            UINT32 max_addressable_ids_for_logical_processors : 12;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_18_ecx_00;

typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 page_entries_4kb_supported : 1;
            UINT32 page_entries_2mb_supported : 1;
            UINT32 page_entries_4mb_supported : 1;
            UINT32 page_entries_1gb_supported : 1;
            UINT32 reserved_1 : 4;
            UINT32 partitioning : 3;
            UINT32 reserved_2 : 5;
            UINT32 ways_of_associativity_01 : 16;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 number_of_sets : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 translation_cacheype_field : 5;
            UINT32 translation_cache_level : 3;
            UINT32 fully_associative_structure : 1;
            UINT32 reserved_1 : 5;
            UINT32 max_addressable_ids_for_logical_processors : 12;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_18_ecx_01p;

/**
 * @}
 */

#define CPUID_EXTENDED_FUNCTION                                      0x80000000
typedef struct {
    union {
        struct {
            UINT32 max_extended_functions : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000000;

#define CPUID_EXTENDED_CPU_SIGNATURE                                 0x80000001
typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 lahf_sahf_available_in_64_bit_mode : 1;
            UINT32 reserved_1 : 4;
            UINT32 lzcnt : 1;
            UINT32 reserved_2 : 2;
            UINT32 prefetchw : 1;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved_1 : 11;
            UINT32 syscall_sysret_available_in_64_bit_mode : 1;
            UINT32 reserved_2 : 8;
            UINT32 execute_disable_bit_available : 1;
            UINT32 reserved_3 : 5;
            UINT32 pages_1gb_available : 1;
            UINT32 rdtscp_available : 1;
            UINT32 reserved_4 : 1;
            UINT32 ia64_available : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000001;

#define CPUID_BRAND_STRING1                                          0x80000002
#define CPUID_BRAND_STRING2                                          0x80000003
#define CPUID_BRAND_STRING3                                          0x80000004
typedef struct {
    union {
        struct {
            UINT32 processor_brand_string_1 : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 processor_brand_string_2 : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 processor_brand_string_3 : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 processor_brand_string_4 : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000002;

typedef struct {
    union {
        struct {
            UINT32 processor_brand_string_5 : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 processor_brand_string_6 : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 processor_brand_string_7 : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 processor_brand_string_8 : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000003;

typedef struct {
    union {
        struct {
            UINT32 processor_brand_string_9 : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 processor_brand_string_10 : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 processor_brand_string_11 : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 processor_brand_string_12 : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000004;

typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000005;

#define CPUID_EXTENDED_CACHE_INFO                                    0x80000006
typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 cache_line_size_in_bytes : 8;
            UINT32 reserved_1 : 4;
            UINT32 l2_associativity_field : 4;
            UINT32 cache_size_in_1k_units : 16;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000006;

#define CPUID_EXTENDEDIME_STAMP_COUNTER                            0x80000007
typedef struct {
    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved_1 : 8;
            UINT32 invariantsc_available : 1;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000007;

#define CPUID_EXTENDED_VIRT_PHYS_ADDRESS_SIZE                        0x80000008
typedef struct {
    union {
        struct {
            UINT32 number_of_physical_address_bits : 8;
            UINT32 number_of_linear_address_bits : 8;
        };

        UINT32 flags;
    } eax;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ebx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } ecx;

    union {
        struct {
            UINT32 reserved : 32;
        };

        UINT32 flags;
    } edx;

} cpuid_eax_80000008;

/**
 * @}
 */

 /**
  * @defgroup model_specific_registers \
  *           Model Specific Registers
  * @{
  */
  /**
   * @defgroup ia32_p5_mc \
   *           IA32_P5_MC_(x)
   * @{
   */
#define IA32_P5_MC_ADDR                                              0x00000000
#define IA32_P5_MCYPE                                              0x00000001
   /**
    * @}
    */

#define IA32_MONITOR_FILTER_SIZE                                     0x00000006
#define IA32IME_STAMP_COUNTER                                      0x00000010
#define IA32_PLATFORM_ID                                             0x00000017
typedef union {
    struct {
        UINT64 reserved_1 : 50;
        UINT64 platform_id : 3;
    };

    UINT64 flags;
} ia32_platform_id_register;

#define IA32_APIC_BASE                                               0x0000001B
typedef union {
    struct {
        UINT64 reserved_1 : 8;
        UINT64 bsp_flag : 1;
        UINT64 reserved_2 : 1;
        UINT64 enable_x2apic_mode : 1;
        UINT64 apic_global_enable : 1;
        UINT64 apic_base : 36;
    };

    UINT64 flags;
} ia32_apic_base_register;

#define IA32_FEATURE_CONTROL                                         0x0000003A
typedef union {
    struct {
        UINT64 lock_bit : 1;
        UINT64 enable_vmx_inside_smx : 1;
        UINT64 enable_vmx_outside_smx : 1;
        UINT64 reserved_1 : 5;
        UINT64 senter_local_function_enables : 7;
        UINT64 senter_global_enable : 1;
        UINT64 reserved_2 : 1;
        UINT64 sgx_launch_control_enable : 1;
        UINT64 sgx_global_enable : 1;
        UINT64 reserved_3 : 1;
        UINT64 lmce_on : 1;
    };

    UINT64 flags;
} ia32_feature_control_register;

#define IA32SC_ADJUST                                              0x0000003B
typedef struct {
    UINT64 thread_adjust;
} ia32sc_adjust_register;

#define IA32_SPEC_CTRL                                               0x00000048
typedef union {
    struct {
        UINT64 ibrs : 1;
        UINT64 stibp : 1;
        UINT64 ssbd : 1;
    };

    UINT64 flags;
} ia32_spec_ctrl_register;

#define IA32_PRED_CMD                                                0x00000049
typedef union {
    struct {
        UINT64 ibpb : 1;
    };

    UINT64 flags;
} ia32_pred_cmd_register;

#define IA32_BIOS_UPDTRIG                                          0x00000079
#define IA32_BIOS_SIGN_ID                                            0x0000008B
typedef union {
    struct {
        UINT64 reserved : 32;
        UINT64 microcode_update_signature : 32;
    };

    UINT64 flags;
} ia32_bios_sign_id_register;

/**
 * @defgroup ia32_sgxlepubkeyhash \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0                                        0x0000008C
#define IA32_SGXLEPUBKEYHASH1                                        0x0000008D
#define IA32_SGXLEPUBKEYHASH2                                        0x0000008E
#define IA32_SGXLEPUBKEYHASH3                                        0x0000008F
 /**
  * @}
  */

#define IA32_SMM_MONITOR_CTL                                         0x0000009B
typedef union {
    struct {
        UINT64 valid : 1;
        UINT64 reserved_1 : 1;
        UINT64 smi_unblocking_by_vmxoff : 1;
        UINT64 reserved_2 : 9;
        UINT64 mseg_base : 20;
    };

    UINT64 flags;
} ia32_smm_monitor_ctl_register;

typedef struct {
    UINT32 mseg_header_revision;
    UINT32 monitor_features;

#define IA32_STM_FEATURES_IA32E                                      0x00000001
    UINT32 gdtr_limit;
    UINT32 gdtr_base_offset;
    UINT32 cs_selector;
    UINT32 eip_offset;
    UINT32 esp_offset;
    UINT32 cr3_offset;
} ia32_mseg_header;

#define IA32_SMBASE                                                  0x0000009E
/**
 * @defgroup ia32_pmc \
 *           IA32_PMC(n)
 * @{
 */
#define IA32_PMC0                                                    0x000000C1
#define IA32_PMC1                                                    0x000000C2
#define IA32_PMC2                                                    0x000000C3
#define IA32_PMC3                                                    0x000000C4
#define IA32_PMC4                                                    0x000000C5
#define IA32_PMC5                                                    0x000000C6
#define IA32_PMC6                                                    0x000000C7
#define IA32_PMC7                                                    0x000000C8
 /**
  * @}
  */

#define IA32_MPERF                                                   0x000000E7
typedef struct {
    UINT64 c0_mcnt;
} ia32_mperf_register;

#define IA32_APERF                                                   0x000000E8
typedef struct {
    UINT64 c0_acnt;
} ia32_aperf_register;

#define IA32_MTRRCAP                                                 0x000000FE
typedef union {
    struct {
        UINT64 variable_range_registers_count : 8;
        UINT64 fixed_range_registers_supported : 1;
        UINT64 reserved_1 : 1;
        UINT64 write_combining : 1;
        UINT64 system_management_range_register : 1;
    };

    UINT64 flags;
} ia32_mtrrcap_register;

#define IA32_ARCH_CAPABILITIES                                       0x0000010A
typedef union {
    struct {
        UINT64 rdcl_no : 1;
        UINT64 ibrs_all : 1;
        UINT64 rsba : 1;
        UINT64 skip_l1dfl_vmentry : 1;
        UINT64 ssb_no : 1;
        UINT64 mds_no : 1;
        UINT64 if_pschange_mc_no : 1;
        UINT64 tsx_ctrl : 1;
        UINT64 taa_no : 1;
    };

    UINT64 flags;
} ia32_arch_capabilities_register;

#define IA32_FLUSH_CMD                                               0x0000010B
typedef union {
    struct {
        UINT64 l1d_flush : 1;
    };

    UINT64 flags;
} ia32_flush_cmd_register;

#define IA32SX_CTRL                                                0x00000122
typedef union {
    struct {
        UINT64 rtm_disable : 1;
        UINT64 tsx_cpuid_clear : 1;
    };

    UINT64 flags;
} ia32sx_ctrl_register;

#define IA32_SYSENTER_CS                                             0x00000174
typedef union {
    struct {
        UINT64 cs_selector : 16;
        UINT64 not_used_1 : 16;
        UINT64 not_used_2 : 32;
    };

    UINT64 flags;
} ia32_sysenter_cs_register;

#define IA32_SYSENTER_ESP                                            0x00000175
#define IA32_SYSENTER_EIP                                            0x00000176
#define IA32_MCG_CAP                                                 0x00000179
typedef union {
    struct {
        UINT64 count : 8;
        UINT64 mcg_ctl_p : 1;
        UINT64 mcg_ext_p : 1;
        UINT64 mcp_cmci_p : 1;
        UINT64 mcges_p : 1;
        UINT64 reserved_1 : 4;
        UINT64 mcg_ext_cnt : 8;
        UINT64 mcg_ser_p : 1;
        UINT64 reserved_2 : 1;
        UINT64 mcg_elog_p : 1;
        UINT64 mcg_lmce_p : 1;
    };

    UINT64 flags;
} ia32_mcg_cap_register;

#define IA32_MCG_STATUS                                              0x0000017A
typedef union {
    struct {
        UINT64 ripv : 1;
        UINT64 eipv : 1;
        UINT64 mcip : 1;
        UINT64 lmce_s : 1;
    };

    UINT64 flags;
} ia32_mcg_status_register;

#define IA32_MCG_CTL                                                 0x0000017B
/**
 * @defgroup ia32_perfevtsel \
 *           IA32_PERFEVTSEL(n)
 * @{
 */
#define IA32_PERFEVTSEL0                                             0x00000186
#define IA32_PERFEVTSEL1                                             0x00000187
#define IA32_PERFEVTSEL2                                             0x00000188
#define IA32_PERFEVTSEL3                                             0x00000189
typedef union {
    struct {
        UINT64 event_select : 8;
        UINT64 u_mask : 8;
        UINT64 usr : 1;
        UINT64 os : 1;
        UINT64 edge : 1;
        UINT64 pc : 1;
        UINT64 intr : 1;
        UINT64 anyhread : 1;
        UINT64 en : 1;
        UINT64 inv : 1;
        UINT64 cmask : 8;
    };

    UINT64 flags;
} ia32_perfevtsel_register;

/**
 * @}
 */

#define IA32_PERF_STATUS                                             0x00000198
typedef union {
    struct {
        UINT64 current_performance_state_value : 16;
    };

    UINT64 flags;
} ia32_perf_status_register;

#define IA32_PERF_CTL                                                0x00000199
typedef union {
    struct {
        UINT64 target_performance_state_value : 16;
        UINT64 reserved_1 : 16;
        UINT64 ida_engage : 1;
    };

    UINT64 flags;
} ia32_perf_ctl_register;

#define IA32_CLOCK_MODULATION                                        0x0000019A
typedef union {
    struct {
        UINT64 extended_on_demand_clock_modulation_duty_cycle : 1;
        UINT64 on_demand_clock_modulation_duty_cycle : 3;
        UINT64 on_demand_clock_modulation_enable : 1;
    };

    UINT64 flags;
} ia32_clock_modulation_register;

#define IA32HERM_INTERRUPT                                         0x0000019B
typedef union {
    struct {
        UINT64 highemperature_interrupt_enable : 1;
        UINT64 lowemperature_interrupt_enable : 1;
        UINT64 prochot_interrupt_enable : 1;
        UINT64 forcepr_interrupt_enable : 1;
        UINT64 criticalemperature_interrupt_enable : 1;
        UINT64 reserved_1 : 3;
        UINT64 threshold1_value : 7;
        UINT64 threshold1_interrupt_enable : 1;
        UINT64 threshold2_value : 7;
        UINT64 threshold2_interrupt_enable : 1;
        UINT64 power_limit_notification_enable : 1;
    };

    UINT64 flags;
} ia32herm_interrupt_register;

#define IA32HERM_STATUS                                            0x0000019C
typedef union {
    struct {
        UINT64 thermal_status : 1;
        UINT64 thermal_status_log : 1;
        UINT64 prochot_forcepr_event : 1;
        UINT64 prochot_forcepr_log : 1;
        UINT64 criticalemperature_status : 1;
        UINT64 criticalemperature_status_log : 1;
        UINT64 thermalhreshold1_status : 1;
        UINT64 thermalhreshold1_log : 1;
        UINT64 thermalhreshold2_status : 1;
        UINT64 thermalhreshold2_log : 1;
        UINT64 power_limitation_status : 1;
        UINT64 power_limitation_log : 1;
        UINT64 current_limit_status : 1;
        UINT64 current_limit_log : 1;
        UINT64 cross_domain_limit_status : 1;
        UINT64 cross_domain_limit_log : 1;
        UINT64 digital_readout : 7;
        UINT64 reserved_1 : 4;
        UINT64 resolution_in_degrees_celsius : 4;
        UINT64 reading_valid : 1;
    };

    UINT64 flags;
} ia32herm_status_register;

#define IA32_MISC_ENABLE                                             0x000001A0
typedef union {
    struct {
        UINT64 fast_strings_enable : 1;
        UINT64 reserved_1 : 2;
        UINT64 automatichermal_control_circuit_enable : 1;
        UINT64 reserved_2 : 3;
        UINT64 performance_monitoring_available : 1;
        UINT64 reserved_3 : 3;
        UINT64 branchrace_storage_unavailable : 1;
        UINT64 processor_event_based_sampling_unavailable : 1;
        UINT64 reserved_4 : 3;
        UINT64 enhanced_intel_speedstepechnology_enable : 1;
        UINT64 reserved_5 : 1;
        UINT64 enable_monitor_fsm : 1;
        UINT64 reserved_6 : 3;
        UINT64 limit_cpuid_maxval : 1;
        UINT64 xtpr_message_disable : 1;
        UINT64 reserved_7 : 10;
        UINT64 xd_bit_disable : 1;
    };

    UINT64 flags;
} ia32_misc_enable_register;

#define IA32_ENERGY_PERF_BIAS                                        0x000001B0
typedef union {
    struct {
        UINT64 power_policy_preference : 4;
    };

    UINT64 flags;
} ia32_energy_perf_bias_register;

#define IA32_PACKAGEHERM_STATUS                                    0x000001B1
typedef union {
    struct {
        UINT64 thermal_status : 1;
        UINT64 thermal_status_log : 1;
        UINT64 prochot_event : 1;
        UINT64 prochot_log : 1;
        UINT64 criticalemperature_status : 1;
        UINT64 criticalemperature_status_log : 1;
        UINT64 thermalhreshold1_status : 1;
        UINT64 thermalhreshold1_log : 1;
        UINT64 thermalhreshold2_status : 1;
        UINT64 thermalhreshold2_log : 1;
        UINT64 power_limitation_status : 1;
        UINT64 power_limitation_log : 1;
        UINT64 reserved_1 : 4;
        UINT64 digital_readout : 7;
    };

    UINT64 flags;
} ia32_packageherm_status_register;

#define IA32_PACKAGEHERM_INTERRUPT                                 0x000001B2
typedef union {
    struct {
        UINT64 highemperature_interrupt_enable : 1;
        UINT64 lowemperature_interrupt_enable : 1;
        UINT64 prochot_interrupt_enable : 1;
        UINT64 reserved_1 : 1;
        UINT64 overheat_interrupt_enable : 1;
        UINT64 reserved_2 : 3;
        UINT64 threshold1_value : 7;
        UINT64 threshold1_interrupt_enable : 1;
        UINT64 threshold2_value : 7;
        UINT64 threshold2_interrupt_enable : 1;
        UINT64 power_limit_notification_enable : 1;
    };

    UINT64 flags;
} ia32_packageherm_interrupt_register;

#define IA32_DEBUGCTL                                                0x000001D9
typedef union {
    struct {
        UINT64 lbr : 1;
        UINT64 btf : 1;
        UINT64 reserved_1 : 4;
        UINT64 tr : 1;
        UINT64 bts : 1;
        UINT64 btint : 1;
        UINT64 bts_off_os : 1;
        UINT64 bts_off_usr : 1;
        UINT64 freeze_lbrs_on_pmi : 1;
        UINT64 freeze_perfmon_on_pmi : 1;
        UINT64 enable_uncore_pmi : 1;
        UINT64 freeze_while_smm : 1;
        UINT64 rtm_debug : 1;
    };

    UINT64 flags;
} ia32_debugctl_register;

#define IA32_SMRR_PHYSBASE                                           0x000001F2
typedef union {
    struct {
        UINT64 type : 8;
        UINT64 reserved_1 : 4;
        UINT64 smrr_physical_base_address : 20;
    };

    UINT64 flags;
} ia32_smrr_physbase_register;

#define IA32_SMRR_PHYSMASK                                           0x000001F3
typedef union {
    struct {
        UINT64 reserved_1 : 11;
        UINT64 enable_range_mask : 1;
        UINT64 smrr_address_range_mask : 20;
    };

    UINT64 flags;
} ia32_smrr_physmask_register;

#define IA32_PLATFORM_DCA_CAP                                        0x000001F8
#define IA32_CPU_DCA_CAP                                             0x000001F9
#define IA32_DCA_0_CAP                                               0x000001FA
typedef union {
    struct {
        UINT64 dca_active : 1;
        UINT64 transaction : 2;
        UINT64 dcaype : 4;
        UINT64 dca_queue_size : 4;
        UINT64 reserved_1 : 2;
        UINT64 dca_delay : 4;
        UINT64 reserved_2 : 7;
        UINT64 sw_block : 1;
        UINT64 reserved_3 : 1;
        UINT64 hw_block : 1;
    };

    UINT64 flags;
} ia32_dca_0_cap_register;

/**
 * @defgroup ia32_mtrr_physbase \
 *           IA32_MTRR_PHYSBASE(n)
 * @{
 */
typedef union {
    struct {
        UINT64 type : 8;
        UINT64 reserved_1 : 4;
        UINT64 physical_addres_base : 36;
    };

    UINT64 flags;
} ia32_mtrr_physbase_register;

#define IA32_MTRR_PHYSBASE0                                          0x00000200
#define IA32_MTRR_PHYSBASE1                                          0x00000202
#define IA32_MTRR_PHYSBASE2                                          0x00000204
#define IA32_MTRR_PHYSBASE3                                          0x00000206
#define IA32_MTRR_PHYSBASE4                                          0x00000208
#define IA32_MTRR_PHYSBASE5                                          0x0000020A
#define IA32_MTRR_PHYSBASE6                                          0x0000020C
#define IA32_MTRR_PHYSBASE7                                          0x0000020E
#define IA32_MTRR_PHYSBASE8                                          0x00000210
#define IA32_MTRR_PHYSBASE9                                          0x00000212
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_physmask \
  *           IA32_MTRR_PHYSMASK(n)
  * @{
  */
typedef union {
    struct {
        UINT64 reserved_1 : 11;
        UINT64 valid : 1;
        UINT64 physical_addres_mask : 36;
    };

    UINT64 flags;
} ia32_mtrr_physmask_register;

#define IA32_MTRR_PHYSMASK0                                          0x00000201
#define IA32_MTRR_PHYSMASK1                                          0x00000203
#define IA32_MTRR_PHYSMASK2                                          0x00000205
#define IA32_MTRR_PHYSMASK3                                          0x00000207
#define IA32_MTRR_PHYSMASK4                                          0x00000209
#define IA32_MTRR_PHYSMASK5                                          0x0000020B
#define IA32_MTRR_PHYSMASK6                                          0x0000020D
#define IA32_MTRR_PHYSMASK7                                          0x0000020F
#define IA32_MTRR_PHYSMASK8                                          0x00000211
#define IA32_MTRR_PHYSMASK9                                          0x00000213
/**
 * @}
 */

 /**
  * @defgroup ia32_mtrr_fix \
  *           IA32_MTRR_FIX(x)
  * @{
  */
  /**
   * @defgroup ia32_mtrr_fix64k \
   *           IA32_MTRR_FIX64K(x)
   * @{
   */
#define IA32_MTRR_FIX64K_BASE                                        0x00000000
#define IA32_MTRR_FIX64K_SIZE                                        0x00010000
#define IA32_MTRR_FIX64K_00000                                       0x00000250
   /**
    * @}
    */

    /**
     * @defgroup ia32_mtrr_fix16k \
     *           IA32_MTRR_FIX16K(x)
     * @{
     */
#define IA32_MTRR_FIX16K_BASE                                        0x00080000
#define IA32_MTRR_FIX16K_SIZE                                        0x00004000
#define IA32_MTRR_FIX16K_80000                                       0x00000258
#define IA32_MTRR_FIX16K_A0000                                       0x00000259
     /**
      * @}
      */

      /**
       * @defgroup ia32_mtrr_fix4k \
       *           IA32_MTRR_FIX4K(x)
       * @{
       */
#define IA32_MTRR_FIX4K_BASE                                         0x000C0000
#define IA32_MTRR_FIX4K_SIZE                                         0x00001000
#define IA32_MTRR_FIX4K_C0000                                        0x00000268
#define IA32_MTRR_FIX4K_C8000                                        0x00000269
#define IA32_MTRR_FIX4K_D0000                                        0x0000026A
#define IA32_MTRR_FIX4K_D8000                                        0x0000026B
#define IA32_MTRR_FIX4K_E0000                                        0x0000026C
#define IA32_MTRR_FIX4K_E8000                                        0x0000026D
#define IA32_MTRR_FIX4K_F0000                                        0x0000026E
#define IA32_MTRR_FIX4K_F8000                                        0x0000026F
       /**
        * @}
        */

#define IA32_MTRR_FIX_COUNT                                          ((1 + 2 + 8) * 8)
#define IA32_MTRR_VARIABLE_COUNT                                     0x0000000A
#define IA32_MTRR_COUNT                                              (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
        /**
         * @}
         */

#define IA32_PAT                                                     0x00000277
typedef union {
    struct {
        UINT64 pa0 : 3;
        UINT64 reserved_1 : 5;
        UINT64 pa1 : 3;
        UINT64 reserved_2 : 5;
        UINT64 pa2 : 3;
        UINT64 reserved_3 : 5;
        UINT64 pa3 : 3;
        UINT64 reserved_4 : 5;
        UINT64 pa4 : 3;
        UINT64 reserved_5 : 5;
        UINT64 pa5 : 3;
        UINT64 reserved_6 : 5;
        UINT64 pa6 : 3;
        UINT64 reserved_7 : 5;
        UINT64 pa7 : 3;
    };

    UINT64 flags;
} ia32_pat_register;

/**
 * @defgroup ia32_mc_ctl2 \
 *           IA32_MC(i)_CTL2
 * @{
 */
#define IA32_MC0_CTL2                                                0x00000280
#define IA32_MC1_CTL2                                                0x00000281
#define IA32_MC2_CTL2                                                0x00000282
#define IA32_MC3_CTL2                                                0x00000283
#define IA32_MC4_CTL2                                                0x00000284
#define IA32_MC5_CTL2                                                0x00000285
#define IA32_MC6_CTL2                                                0x00000286
#define IA32_MC7_CTL2                                                0x00000287
#define IA32_MC8_CTL2                                                0x00000288
#define IA32_MC9_CTL2                                                0x00000289
#define IA32_MC10_CTL2                                               0x0000028A
#define IA32_MC11_CTL2                                               0x0000028B
#define IA32_MC12_CTL2                                               0x0000028C
#define IA32_MC13_CTL2                                               0x0000028D
#define IA32_MC14_CTL2                                               0x0000028E
#define IA32_MC15_CTL2                                               0x0000028F
#define IA32_MC16_CTL2                                               0x00000290
#define IA32_MC17_CTL2                                               0x00000291
#define IA32_MC18_CTL2                                               0x00000292
#define IA32_MC19_CTL2                                               0x00000293
#define IA32_MC20_CTL2                                               0x00000294
#define IA32_MC21_CTL2                                               0x00000295
#define IA32_MC22_CTL2                                               0x00000296
#define IA32_MC23_CTL2                                               0x00000297
#define IA32_MC24_CTL2                                               0x00000298
#define IA32_MC25_CTL2                                               0x00000299
#define IA32_MC26_CTL2                                               0x0000029A
#define IA32_MC27_CTL2                                               0x0000029B
#define IA32_MC28_CTL2                                               0x0000029C
#define IA32_MC29_CTL2                                               0x0000029D
#define IA32_MC30_CTL2                                               0x0000029E
#define IA32_MC31_CTL2                                               0x0000029F
typedef union {
    struct {
        UINT64 corrected_error_counthreshold : 15;
        UINT64 reserved_1 : 15;
        UINT64 cmci_en : 1;
    };

    UINT64 flags;
} ia32_mc_ctl2_register;

/**
 * @}
 */

#define IA32_MTRR_DEFYPE                                           0x000002FF
typedef union {
    struct {
        UINT64 default_memoryype : 3;
        UINT64 reserved_1 : 7;
        UINT64 fixed_range_mtrr_enable : 1;
        UINT64 mtrr_enable : 1;
    };

    UINT64 flags;
} ia32_mtrr_defype_register;

/**
 * @defgroup ia32_fixed_ctr \
 *           IA32_FIXED_CTR(n)
 * @{
 */
#define IA32_FIXED_CTR0                                              0x00000309
#define IA32_FIXED_CTR1                                              0x0000030A
#define IA32_FIXED_CTR2                                              0x0000030B
 /**
  * @}
  */

#define IA32_PERF_CAPABILITIES                                       0x00000345
typedef union {
    struct {
        UINT64 lbr_format : 6;
        UINT64 pebsrap : 1;
        UINT64 pebs_save_arch_regs : 1;
        UINT64 pebs_record_format : 4;
        UINT64 freeze_while_smm_is_supported : 1;
        UINT64 full_width_counter_write : 1;
    };

    UINT64 flags;
} ia32_perf_capabilities_register;

#define IA32_FIXED_CTR_CTRL                                          0x0000038D
typedef union {
    struct {
        UINT64 en0_os : 1;
        UINT64 en0_usr : 1;
        UINT64 anyhread0 : 1;
        UINT64 en0_pmi : 1;
        UINT64 en1_os : 1;
        UINT64 en1_usr : 1;
        UINT64 anyhread1 : 1;
        UINT64 en1_pmi : 1;
        UINT64 en2_os : 1;
        UINT64 en2_usr : 1;
        UINT64 anyhread2 : 1;
        UINT64 en2_pmi : 1;
    };

    UINT64 flags;
} ia32_fixed_ctr_ctrl_register;

#define IA32_PERF_GLOBAL_STATUS                                      0x0000038E
typedef union {
    struct {
        UINT64 ovf_pmc0 : 1;
        UINT64 ovf_pmc1 : 1;
        UINT64 ovf_pmc2 : 1;
        UINT64 ovf_pmc3 : 1;
        UINT64 reserved_1 : 28;
        UINT64 ovf_fixedctr0 : 1;
        UINT64 ovf_fixedctr1 : 1;
        UINT64 ovf_fixedctr2 : 1;
        UINT64 reserved_2 : 20;
        UINT64 traceopa_pmi : 1;
        UINT64 reserved_3 : 2;
        UINT64 lbr_frz : 1;
        UINT64 ctr_frz : 1;
        UINT64 asci : 1;
        UINT64 ovf_uncore : 1;
        UINT64 ovf_buf : 1;
        UINT64 cond_chgd : 1;
    };

    UINT64 flags;
} ia32_perf_global_status_register;

#define IA32_PERF_GLOBAL_CTRL                                        0x0000038F
typedef union {
    struct {
        UINT64 en_pmcn : 32;
        UINT64 en_fixed_ctrn : 32;
    };

    UINT64 flags;
} ia32_perf_global_ctrl_register;

#define IA32_PERF_GLOBAL_STATUS_RESET                                0x00000390
typedef union {
    struct {
        UINT64 clear_ovf_pmcn : 32;
        UINT64 clear_ovf_fixed_ctrn : 3;
        UINT64 reserved_1 : 20;
        UINT64 clearraceopa_pmi : 1;
        UINT64 reserved_2 : 2;
        UINT64 clear_lbr_frz : 1;
        UINT64 clear_ctr_frz : 1;
        UINT64 clear_asci : 1;
        UINT64 clear_ovf_uncore : 1;
        UINT64 clear_ovf_buf : 1;
        UINT64 clear_cond_chgd : 1;
    };

    UINT64 flags;
} ia32_perf_global_status_reset_register;

#define IA32_PERF_GLOBAL_STATUS_SET                                  0x00000391
typedef union {
    struct {
        UINT64 ovf_pmcn : 32;
        UINT64 ovf_fixed_ctrn : 3;
        UINT64 reserved_1 : 20;
        UINT64 traceopa_pmi : 1;
        UINT64 reserved_2 : 2;
        UINT64 lbr_frz : 1;
        UINT64 ctr_frz : 1;
        UINT64 asci : 1;
        UINT64 ovf_uncore : 1;
        UINT64 ovf_buf : 1;
    };

    UINT64 flags;
} ia32_perf_global_status_set_register;

#define IA32_PERF_GLOBAL_INUSE                                       0x00000392
typedef union {
    struct {
        UINT64 ia32_perfevtseln_in_use : 32;
        UINT64 ia32_fixed_ctrn_in_use : 3;
        UINT64 reserved_1 : 28;
        UINT64 pmi_in_use : 1;
    };

    UINT64 flags;
} ia32_perf_global_inuse_register;

#define IA32_PEBS_ENABLE                                             0x000003F1
typedef union {
    struct {
        UINT64 enable_pebs : 1;
        UINT64 reservedormodelspecific1 : 3;
        UINT64 reserved_1 : 28;
        UINT64 reservedormodelspecific2 : 4;
    };

    UINT64 flags;
} ia32_pebs_enable_register;

/**
 * @defgroup ia32_mc_ctl \
 *           IA32_MC(i)_CTL
 * @{
 */
#define IA32_MC0_CTL                                                 0x00000400
#define IA32_MC1_CTL                                                 0x00000404
#define IA32_MC2_CTL                                                 0x00000408
#define IA32_MC3_CTL                                                 0x0000040C
#define IA32_MC4_CTL                                                 0x00000410
#define IA32_MC5_CTL                                                 0x00000414
#define IA32_MC6_CTL                                                 0x00000418
#define IA32_MC7_CTL                                                 0x0000041C
#define IA32_MC8_CTL                                                 0x00000420
#define IA32_MC9_CTL                                                 0x00000424
#define IA32_MC10_CTL                                                0x00000428
#define IA32_MC11_CTL                                                0x0000042C
#define IA32_MC12_CTL                                                0x00000430
#define IA32_MC13_CTL                                                0x00000434
#define IA32_MC14_CTL                                                0x00000438
#define IA32_MC15_CTL                                                0x0000043C
#define IA32_MC16_CTL                                                0x00000440
#define IA32_MC17_CTL                                                0x00000444
#define IA32_MC18_CTL                                                0x00000448
#define IA32_MC19_CTL                                                0x0000044C
#define IA32_MC20_CTL                                                0x00000450
#define IA32_MC21_CTL                                                0x00000454
#define IA32_MC22_CTL                                                0x00000458
#define IA32_MC23_CTL                                                0x0000045C
#define IA32_MC24_CTL                                                0x00000460
#define IA32_MC25_CTL                                                0x00000464
#define IA32_MC26_CTL                                                0x00000468
#define IA32_MC27_CTL                                                0x0000046C
#define IA32_MC28_CTL                                                0x00000470
 /**
  * @}
  */

  /**
   * @defgroup ia32_mc_status \
   *           IA32_MC(i)_STATUS
   * @{
   */
#define IA32_MC0_STATUS                                              0x00000401
#define IA32_MC1_STATUS                                              0x00000405
#define IA32_MC2_STATUS                                              0x00000409
#define IA32_MC3_STATUS                                              0x0000040D
#define IA32_MC4_STATUS                                              0x00000411
#define IA32_MC5_STATUS                                              0x00000415
#define IA32_MC6_STATUS                                              0x00000419
#define IA32_MC7_STATUS                                              0x0000041D
#define IA32_MC8_STATUS                                              0x00000421
#define IA32_MC9_STATUS                                              0x00000425
#define IA32_MC10_STATUS                                             0x00000429
#define IA32_MC11_STATUS                                             0x0000042D
#define IA32_MC12_STATUS                                             0x00000431
#define IA32_MC13_STATUS                                             0x00000435
#define IA32_MC14_STATUS                                             0x00000439
#define IA32_MC15_STATUS                                             0x0000043D
#define IA32_MC16_STATUS                                             0x00000441
#define IA32_MC17_STATUS                                             0x00000445
#define IA32_MC18_STATUS                                             0x00000449
#define IA32_MC19_STATUS                                             0x0000044D
#define IA32_MC20_STATUS                                             0x00000451
#define IA32_MC21_STATUS                                             0x00000455
#define IA32_MC22_STATUS                                             0x00000459
#define IA32_MC23_STATUS                                             0x0000045D
#define IA32_MC24_STATUS                                             0x00000461
#define IA32_MC25_STATUS                                             0x00000465
#define IA32_MC26_STATUS                                             0x00000469
#define IA32_MC27_STATUS                                             0x0000046D
#define IA32_MC28_STATUS                                             0x00000471
   /**
    * @}
    */

    /**
     * @defgroup ia32_mc_addr \
     *           IA32_MC(i)_ADDR
     * @{
     */
#define IA32_MC0_ADDR                                                0x00000402
#define IA32_MC1_ADDR                                                0x00000406
#define IA32_MC2_ADDR                                                0x0000040A
#define IA32_MC3_ADDR                                                0x0000040E
#define IA32_MC4_ADDR                                                0x00000412
#define IA32_MC5_ADDR                                                0x00000416
#define IA32_MC6_ADDR                                                0x0000041A
#define IA32_MC7_ADDR                                                0x0000041E
#define IA32_MC8_ADDR                                                0x00000422
#define IA32_MC9_ADDR                                                0x00000426
#define IA32_MC10_ADDR                                               0x0000042A
#define IA32_MC11_ADDR                                               0x0000042E
#define IA32_MC12_ADDR                                               0x00000432
#define IA32_MC13_ADDR                                               0x00000436
#define IA32_MC14_ADDR                                               0x0000043A
#define IA32_MC15_ADDR                                               0x0000043E
#define IA32_MC16_ADDR                                               0x00000442
#define IA32_MC17_ADDR                                               0x00000446
#define IA32_MC18_ADDR                                               0x0000044A
#define IA32_MC19_ADDR                                               0x0000044E
#define IA32_MC20_ADDR                                               0x00000452
#define IA32_MC21_ADDR                                               0x00000456
#define IA32_MC22_ADDR                                               0x0000045A
#define IA32_MC23_ADDR                                               0x0000045E
#define IA32_MC24_ADDR                                               0x00000462
#define IA32_MC25_ADDR                                               0x00000466
#define IA32_MC26_ADDR                                               0x0000046A
#define IA32_MC27_ADDR                                               0x0000046E
#define IA32_MC28_ADDR                                               0x00000472
     /**
      * @}
      */

      /**
       * @defgroup ia32_mc_misc \
       *           IA32_MC(i)_MISC
       * @{
       */
#define IA32_MC0_MISC                                                0x00000403
#define IA32_MC1_MISC                                                0x00000407
#define IA32_MC2_MISC                                                0x0000040B
#define IA32_MC3_MISC                                                0x0000040F
#define IA32_MC4_MISC                                                0x00000413
#define IA32_MC5_MISC                                                0x00000417
#define IA32_MC6_MISC                                                0x0000041B
#define IA32_MC7_MISC                                                0x0000041F
#define IA32_MC8_MISC                                                0x00000423
#define IA32_MC9_MISC                                                0x00000427
#define IA32_MC10_MISC                                               0x0000042B
#define IA32_MC11_MISC                                               0x0000042F
#define IA32_MC12_MISC                                               0x00000433
#define IA32_MC13_MISC                                               0x00000437
#define IA32_MC14_MISC                                               0x0000043B
#define IA32_MC15_MISC                                               0x0000043F
#define IA32_MC16_MISC                                               0x00000443
#define IA32_MC17_MISC                                               0x00000447
#define IA32_MC18_MISC                                               0x0000044B
#define IA32_MC19_MISC                                               0x0000044F
#define IA32_MC20_MISC                                               0x00000453
#define IA32_MC21_MISC                                               0x00000457
#define IA32_MC22_MISC                                               0x0000045B
#define IA32_MC23_MISC                                               0x0000045F
#define IA32_MC24_MISC                                               0x00000463
#define IA32_MC25_MISC                                               0x00000467
#define IA32_MC26_MISC                                               0x0000046B
#define IA32_MC27_MISC                                               0x0000046F
#define IA32_MC28_MISC                                               0x00000473
       /**
        * @}
        */

#define IA32_VMX_BASIC                                               0x00000480
typedef union {
    struct {
        UINT64 vmcs_revision_id : 31;
        UINT64 must_be_zero : 1;
        UINT64 vmcs_size_in_bytes : 13;
        UINT64 reserved_1 : 3;
        UINT64 vmcs_physical_address_width : 1;
        UINT64 dual_monitor : 1;
        UINT64 memoryype : 4;
        UINT64 ins_outs_vmexit_information : 1;
        UINT64 true_controls : 1;
    };

    UINT64 flags;
} ia32_vmx_basic_register;

#define IA32_VMX_PINBASED_CTLS                                       0x00000481
typedef union {
    struct {
        UINT64 external_interrupt_exiting : 1;
        UINT64 reserved_1 : 2;
        UINT64 nmi_exiting : 1;
        UINT64 reserved_2 : 1;
        UINT64 virtual_nmis : 1;
        UINT64 activate_vmx_preemptionimer : 1;
        UINT64 process_posted_interrupts : 1;
    };

    UINT64 flags;
} ia32_vmx_pinbased_ctls_register;

#define IA32_VMX_PROCBASED_CTLS                                      0x00000482
typedef union {
    struct {
        UINT64 reserved_1 : 2;
        UINT64 interrupt_window_exiting : 1;
        UINT64 usesc_offsetting : 1;
        UINT64 reserved_2 : 3;
        UINT64 hlt_exiting : 1;
        UINT64 reserved_3 : 1;
        UINT64 invlpg_exiting : 1;
        UINT64 mwait_exiting : 1;
        UINT64 rdpmc_exiting : 1;
        UINT64 rdtsc_exiting : 1;
        UINT64 reserved_4 : 2;
        UINT64 cr3_load_exiting : 1;
        UINT64 cr3_store_exiting : 1;
        UINT64 activateertiary_controls : 1;
        UINT64 reserved_5 : 1;
        UINT64 cr8_load_exiting : 1;
        UINT64 cr8_store_exiting : 1;
        UINT64 usepr_shadow : 1;
        UINT64 nmi_window_exiting : 1;
        UINT64 mov_dr_exiting : 1;
        UINT64 unconditional_io_exiting : 1;
        UINT64 use_io_bitmaps : 1;
        UINT64 reserved_6 : 1;
        UINT64 monitorrap_flag : 1;
        UINT64 use_msr_bitmaps : 1;
        UINT64 monitor_exiting : 1;
        UINT64 pause_exiting : 1;
        UINT64 activate_secondary_controls : 1;
    };

    UINT64 flags;
} ia32_vmx_procbased_ctls_register;

#define IA32_VMX_EXIT_CTLS                                           0x00000483
typedef union {
    struct {
        UINT64 reserved_1 : 2;
        UINT64 save_debug_controls : 1;
        UINT64 reserved_2 : 6;
        UINT64 host_address_space_size : 1;
        UINT64 reserved_3 : 2;
        UINT64 load_ia32_perf_global_ctrl : 1;
        UINT64 reserved_4 : 2;
        UINT64 acknowledge_interrupt_on_exit : 1;
        UINT64 reserved_5 : 2;
        UINT64 save_ia32_pat : 1;
        UINT64 load_ia32_pat : 1;
        UINT64 save_ia32_efer : 1;
        UINT64 load_ia32_efer : 1;
        UINT64 save_vmx_preemptionimer_value : 1;
        UINT64 clear_ia32_bndcfgs : 1;
        UINT64 conceal_vmx_from_pt : 1;
        UINT64 clear_ia32_rtit_ctl : 1;
        UINT64 clear_ia32_lbr_ctl : 1;
        UINT64 clear_uinv : 1;
        UINT64 load_ia32_cet_state : 1;
        UINT64 load_ia32_pkrs : 1;
        UINT64 save_ia32_perf_global_ctl : 1;
        UINT64 activate_secondary_controls : 1;
    };

    UINT64 flags;
} ia32_vmx_exit_ctls_register;

#define IA32_VMX_ENTRY_CTLS                                          0x00000484
typedef union {
    struct {
        UINT64 reserved_1 : 2;
        UINT64 load_debug_controls : 1;
        UINT64 reserved_2 : 6;
        UINT64 ia32e_mode_guest : 1;
        UINT64 entryo_smm : 1;
        UINT64 deactivate_dual_monitorreatment : 1;
        UINT64 reserved_3 : 1;
        UINT64 load_ia32_perf_global_ctrl : 1;
        UINT64 load_ia32_pat : 1;
        UINT64 load_ia32_efer : 1;
        UINT64 load_ia32_bndcfgs : 1;
        UINT64 conceal_vmx_from_pt : 1;
        UINT64 load_ia32_rtit_ctl : 1;
        UINT64 load_uinv : 1;
        UINT64 load_cet_state : 1;
        UINT64 load_ia32_lbr_ctl : 1;
        UINT64 load_ia32_pkrs : 1;
    };

    UINT64 flags;
} ia32_vmx_entry_ctls_register;

#define IA32_VMX_MISC                                                0x00000485
typedef union {
    struct {
        UINT64 preemptionimersc_relationship : 5;
        UINT64 store_efer_lma_on_vmexit : 1;
        UINT64 activity_states : 3;
        UINT64 reserved_1 : 5;
        UINT64 intel_pt_available_in_vmx : 1;
        UINT64 rdmsr_can_read_ia32_smbase_msr_in_smm : 1;
        UINT64 cr3arget_count : 9;
        UINT64 max_number_of_msr : 3;
        UINT64 smm_monitor_ctl_b2 : 1;
        UINT64 vmwrite_vmexit_info : 1;
        UINT64 zero_length_instruction_vmentry_injection : 1;
        UINT64 reserved_2 : 1;
        UINT64 mseg_id : 32;
    };

    UINT64 flags;
} ia32_vmx_misc_register;

#define IA32_VMX_CR0_FIXED0                                          0x00000486
#define IA32_VMX_CR0_FIXED1                                          0x00000487
#define IA32_VMX_CR4_FIXED0                                          0x00000488
#define IA32_VMX_CR4_FIXED1                                          0x00000489
#define IA32_VMX_VMCS_ENUM                                           0x0000048A
typedef union {
    struct {
        UINT64 accessype : 1;
        UINT64 highest_index_value : 9;
        UINT64 fieldype : 2;
        UINT64 reserved_1 : 1;
        UINT64 field_width : 2;
    };

    UINT64 flags;
} ia32_vmx_vmcs_enum_register;

#define IA32_VMX_PROCBASED_CTLS2                                     0x0000048B
typedef union {
    struct {
        UINT64 virtualize_apic_accesses : 1;
        UINT64 enable_ept : 1;
        UINT64 descriptorable_exiting : 1;
        UINT64 enable_rdtscp : 1;
        UINT64 virtualize_x2apic_mode : 1;
        UINT64 enable_vpid : 1;
        UINT64 wbinvd_exiting : 1;
        UINT64 unrestricted_guest : 1;
        UINT64 apic_register_virtualization : 1;
        UINT64 virtual_interrupt_delivery : 1;
        UINT64 pause_loop_exiting : 1;
        UINT64 rdrand_exiting : 1;
        UINT64 enable_invpcid : 1;
        UINT64 enable_vm_functions : 1;
        UINT64 vmcs_shadowing : 1;
        UINT64 enable_encls_exiting : 1;
        UINT64 rdseed_exiting : 1;
        UINT64 enable_pml : 1;
        UINT64 ept_violation : 1;
        UINT64 conceal_vmx_from_pt : 1;
        UINT64 enable_xsaves : 1;
        UINT64 enable_pasidranslation : 1;
        UINT64 mode_based_execute_control_for_ept : 1;
        UINT64 sub_page_write_permissions_for_ept : 1;
        UINT64 pt_uses_guest_physical_addresses : 1;
        UINT64 usesc_scaling : 1;
        UINT64 enable_user_wait_pause : 1;
        UINT64 enable_pconfig : 1;
        UINT64 enable_enclv_exiting : 1;
        UINT64 reserved_1 : 1;
        UINT64 enable_vmm_bus_lock_detection : 1;
        UINT64 enable_instructionimeout_exit : 1;
    };

    UINT64 flags;
} ia32_vmx_procbased_ctls2_register;

#define IA32_VMX_EPT_VPID_CAP                                        0x0000048C
typedef union {
    struct {
        UINT64 execute_only_pages : 1;
        UINT64 reserved_1 : 5;
        UINT64 page_walk_length_4 : 1;
        UINT64 reserved_2 : 1;
        UINT64 memoryype_uncacheable : 1;
        UINT64 reserved_3 : 5;
        UINT64 memoryype_write_back : 1;
        UINT64 reserved_4 : 1;
        UINT64 pde_2mb_pages : 1;
        UINT64 pdpte_1gb_pages : 1;
        UINT64 reserved_5 : 2;
        UINT64 invept : 1;
        UINT64 ept_accessed_and_dirty_flags : 1;
        UINT64 advanced_vmexit_ept_violations_information : 1;
        UINT64 supervisor_shadow_stack : 1;
        UINT64 reserved_6 : 1;
        UINT64 invept_single_context : 1;
        UINT64 invept_all_contexts : 1;
        UINT64 reserved_7 : 5;
        UINT64 invvpid : 1;
        UINT64 reserved_8 : 7;
        UINT64 invvpid_individual_address : 1;
        UINT64 invvpid_single_context : 1;
        UINT64 invvpid_all_contexts : 1;
        UINT64 invvpid_single_context_retain_globals : 1;
        UINT64 reserved_9 : 4;
        UINT64 max_hlat_prefix_size : 6;
    };

    UINT64 flags;
} ia32_vmx_ept_vpid_cap_register;

/**
 * @defgroup ia32_vmxrue_ctls \
 *           IA32_VMXRUE_(x)_CTLS
 * @{
 */
#define IA32_VMXRUE_PINBASED_CTLS                                  0x0000048D
#define IA32_VMXRUE_PROCBASED_CTLS                                 0x0000048E
#define IA32_VMXRUE_EXIT_CTLS                                      0x0000048F
#define IA32_VMXRUE_ENTRY_CTLS                                     0x00000490
typedef union {
    struct {
        UINT64 allowed_0_settings : 32;
        UINT64 allowed_1_settings : 32;
    };

    UINT64 flags;
} ia32_vmxrue_ctls_register;

/**
 * @}
 */

#define IA32_VMX_VMFUNC                                              0x00000491
typedef union {
    struct {
        UINT64 eptp_switching : 1;
    };

    UINT64 flags;
} ia32_vmx_vmfunc_register;

#define IA32_VMX_PROCBASED_CTLS3                                     0x00000492
typedef union {
    struct {
        UINT64 loadiwkey_exiting : 1;
        UINT64 enable_hlat : 1;
        UINT64 ept_paging_write : 1;
        UINT64 guest_paging : 1;
        UINT64 enable_ipi_virtualization : 1;
        UINT64 reserved_1 : 1;
        UINT64 enable_rdmsrlist_wrmsrlist : 1;
        UINT64 virtualize_ia32_spec_ctrl : 1;
    };

    UINT64 flags;
} ia32_vmx_procbased_ctls3_register;

#define IA32_VMX_EXIT_CTLS2                                          0x00000493
typedef union {
    struct {
        UINT64 reserved_1 : 3;
        UINT64 enable_prematurely_busy_shadow_stack_indication : 1;
    };

    UINT64 flags;
} ia32_vmx_exit_ctls2_register;

/**
 * @defgroup ia32_a_pmc \
 *           IA32_A_PMC(n)
 * @{
 */
#define IA32_A_PMC0                                                  0x000004C1
#define IA32_A_PMC1                                                  0x000004C2
#define IA32_A_PMC2                                                  0x000004C3
#define IA32_A_PMC3                                                  0x000004C4
#define IA32_A_PMC4                                                  0x000004C5
#define IA32_A_PMC5                                                  0x000004C6
#define IA32_A_PMC6                                                  0x000004C7
#define IA32_A_PMC7                                                  0x000004C8
 /**
  * @}
  */

#define IA32_MCG_EXT_CTL                                             0x000004D0
typedef union {
    struct {
        UINT64 lmce_en : 1;
    };

    UINT64 flags;
} ia32_mcg_ext_ctl_register;

#define IA32_SGX_SVN_STATUS                                          0x00000500
typedef union {
    struct {
        UINT64 lock : 1;
        UINT64 reserved_1 : 15;
        UINT64 sgx_svn_sinit : 8;
    };

    UINT64 flags;
} ia32_sgx_svn_status_register;

#define IA32_RTIT_OUTPUT_BASE                                        0x00000560
typedef union {
    struct {
        UINT64 reserved_1 : 7;
        UINT64 base_physical_address : 41;
    };

    UINT64 flags;
} ia32_rtit_output_base_register;

#define IA32_RTIT_OUTPUT_MASK_PTRS                                   0x00000561
typedef union {
    struct {
        UINT64 lower_mask : 7;
        UINT64 mask_orable_offset : 25;
        UINT64 output_offset : 32;
    };

    UINT64 flags;
} ia32_rtit_output_mask_ptrs_register;

#define IA32_RTIT_CTL                                                0x00000570
typedef union {
    struct {
        UINT64 trace_en : 1;
        UINT64 cyc_en : 1;
        UINT64 os : 1;
        UINT64 user : 1;
        UINT64 pwr_evt_en : 1;
        UINT64 fup_on_ptw : 1;
        UINT64 fabric_en : 1;
        UINT64 cr3_filter : 1;
        UINT64 topa : 1;
        UINT64 mtc_en : 1;
        UINT64 tsc_en : 1;
        UINT64 dis_retc : 1;
        UINT64 ptw_en : 1;
        UINT64 branch_en : 1;
        UINT64 mtc_freq : 4;
        UINT64 reserved_1 : 1;
        UINT64 cychresh : 4;
        UINT64 reserved_2 : 1;
        UINT64 psb_freq : 4;
        UINT64 reserved_3 : 4;
        UINT64 addr0_cfg : 4;
        UINT64 addr1_cfg : 4;
        UINT64 addr2_cfg : 4;
        UINT64 addr3_cfg : 4;
        UINT64 reserved_4 : 8;
        UINT64 inject_psb_pmi_on_enable : 1;
    };

    UINT64 flags;
} ia32_rtit_ctl_register;

#define IA32_RTIT_STATUS                                             0x00000571
typedef union {
    struct {
        UINT64 filter_en : 1;
        UINT64 contex_en : 1;
        UINT64 trigger_en : 1;
        UINT64 reserved_1 : 1;
        UINT64 error : 1;
        UINT64 stopped : 1;
        UINT64 pend_psb : 1;
        UINT64 pendopa_pmi : 1;
        UINT64 reserved_2 : 24;
        UINT64 packet_byte_cnt : 17;
    };

    UINT64 flags;
} ia32_rtit_status_register;

#define IA32_RTIT_CR3_MATCH                                          0x00000572
typedef union {
    struct {
        UINT64 reserved_1 : 5;
        UINT64 cr3_valueo_match : 59;
    };

    UINT64 flags;
} ia32_rtit_cr3_match_register;

/**
 * @defgroup ia32_rtit_addr \
 *           IA32_RTIT_ADDR(x)
 * @{
 */
 /**
  * @defgroup ia32_rtit_addr_a \
  *           IA32_RTIT_ADDR(n)_A
  * @{
  */
#define IA32_RTIT_ADDR0_A                                            0x00000580
#define IA32_RTIT_ADDR1_A                                            0x00000582
#define IA32_RTIT_ADDR2_A                                            0x00000584
#define IA32_RTIT_ADDR3_A                                            0x00000586
  /**
   * @}
   */

   /**
    * @defgroup ia32_rtit_addr_b \
    *           IA32_RTIT_ADDR(n)_B
    * @{
    */
#define IA32_RTIT_ADDR0_B                                            0x00000581
#define IA32_RTIT_ADDR1_B                                            0x00000583
#define IA32_RTIT_ADDR2_B                                            0x00000585
#define IA32_RTIT_ADDR3_B                                            0x00000587
    /**
     * @}
     */

typedef union {
    struct {
        UINT64 virtual_address : 48;
        UINT64 sign_ext_va : 16;
    };

    UINT64 flags;
} ia32_rtit_addr_register;

/**
 * @}
 */

#define IA32_DS_AREA                                                 0x00000600
#define IA32_U_CET                                                   0x000006A0
typedef union {
    struct {
        UINT64 sh_stk_en : 1;
        UINT64 wr_shstk_en : 1;
        UINT64 endbr_en : 1;
        UINT64 leg_iw_en : 1;
        UINT64 norack_en : 1;
        UINT64 suppress_dis : 1;
        UINT64 reserved_1 : 4;
        UINT64 suppress : 1;
        UINT64 tracker : 1;
        UINT64 eb_leg_bitmap_base : 52;
    };

    UINT64 flags;
} ia32_u_cet_register;

#define IA32_S_CET                                                   0x000006A2
typedef union {
    struct {
        UINT64 sh_stk_en : 1;
        UINT64 wr_shstk_en : 1;
        UINT64 endbr_en : 1;
        UINT64 leg_iw_en : 1;
        UINT64 norack_en : 1;
        UINT64 suppress_dis : 1;
        UINT64 reserved_1 : 4;
        UINT64 suppress : 1;
        UINT64 tracker : 1;
        UINT64 eb_leg_bitmap_base : 52;
    };

    UINT64 flags;
} ia32_s_cet_register;

#define IA32_PL0_SSP                                                 0x000006A4
#define IA32_PL1_SSP                                                 0x000006A5
#define IA32_PL2_SSP                                                 0x000006A6
#define IA32_PL3_SSP                                                 0x000006A7
#define IA32_INTERRUPT_SSPABLE_ADDR                                0x000006A8
#define IA32SC_DEADLINE                                            0x000006E0
#define IA32_PM_ENABLE                                               0x00000770
typedef union {
    struct {
        UINT64 hwp_enable : 1;
    };

    UINT64 flags;
} ia32_pm_enable_register;

#define IA32_HWP_CAPABILITIES                                        0x00000771
typedef union {
    struct {
        UINT64 highest_performance : 8;
        UINT64 guaranteed_performance : 8;
        UINT64 most_efficient_performance : 8;
        UINT64 lowest_performance : 8;
    };

    UINT64 flags;
} ia32_hwp_capabilities_register;

#define IA32_HWP_REQUEST_PKG                                         0x00000772
typedef union {
    struct {
        UINT64 minimum_performance : 8;
        UINT64 maximum_performance : 8;
        UINT64 desired_performance : 8;
        UINT64 energy_performance_preference : 8;
        UINT64 activity_window : 10;
    };

    UINT64 flags;
} ia32_hwp_request_pkg_register;

#define IA32_HWP_INTERRUPT                                           0x00000773
typedef union {
    struct {
        UINT64 en_guaranteed_performance_change : 1;
        UINT64 en_excursion_minimum : 1;
    };

    UINT64 flags;
} ia32_hwp_interrupt_register;

#define IA32_HWP_REQUEST                                             0x00000774
typedef union {
    struct {
        UINT64 minimum_performance : 8;
        UINT64 maximum_performance : 8;
        UINT64 desired_performance : 8;
        UINT64 energy_performance_preference : 8;
        UINT64 activity_window : 10;
        UINT64 package_control : 1;
    };

    UINT64 flags;
} ia32_hwp_request_register;

#define IA32_HWP_STATUS                                              0x00000777
typedef union {
    struct {
        UINT64 guaranteed_performance_change : 1;
        UINT64 reserved_1 : 1;
        UINT64 excursiono_minimum : 1;
    };

    UINT64 flags;
} ia32_hwp_status_register;

#define IA32_X2APIC_APICID                                           0x00000802
#define IA32_X2APIC_VERSION                                          0x00000803
#define IA32_X2APICPR                                              0x00000808
#define IA32_X2APIC_PPR                                              0x0000080A
#define IA32_X2APIC_EOI                                              0x0000080B
#define IA32_X2APIC_LDR                                              0x0000080D
#define IA32_X2APIC_SIVR                                             0x0000080F
/**
 * @defgroup ia32_x2apic_isr \
 *           IA32_X2APIC_ISR(n)
 * @{
 */
#define IA32_X2APIC_ISR0                                             0x00000810
#define IA32_X2APIC_ISR1                                             0x00000811
#define IA32_X2APIC_ISR2                                             0x00000812
#define IA32_X2APIC_ISR3                                             0x00000813
#define IA32_X2APIC_ISR4                                             0x00000814
#define IA32_X2APIC_ISR5                                             0x00000815
#define IA32_X2APIC_ISR6                                             0x00000816
#define IA32_X2APIC_ISR7                                             0x00000817
 /**
  * @}
  */

  /**
   * @defgroup ia32_x2apicmr \
   *           IA32_X2APICMR(n)
   * @{
   */
#define IA32_X2APICMR0                                             0x00000818
#define IA32_X2APICMR1                                             0x00000819
#define IA32_X2APICMR2                                             0x0000081A
#define IA32_X2APICMR3                                             0x0000081B
#define IA32_X2APICMR4                                             0x0000081C
#define IA32_X2APICMR5                                             0x0000081D
#define IA32_X2APICMR6                                             0x0000081E
#define IA32_X2APICMR7                                             0x0000081F
   /**
    * @}
    */

    /**
     * @defgroup ia32_x2apic_irr \
     *           IA32_X2APIC_IRR(n)
     * @{
     */
#define IA32_X2APIC_IRR0                                             0x00000820
#define IA32_X2APIC_IRR1                                             0x00000821
#define IA32_X2APIC_IRR2                                             0x00000822
#define IA32_X2APIC_IRR3                                             0x00000823
#define IA32_X2APIC_IRR4                                             0x00000824
#define IA32_X2APIC_IRR5                                             0x00000825
#define IA32_X2APIC_IRR6                                             0x00000826
#define IA32_X2APIC_IRR7                                             0x00000827
     /**
      * @}
      */

#define IA32_X2APIC_ESR                                              0x00000828
#define IA32_X2APIC_LVT_CMCI                                         0x0000082F
#define IA32_X2APIC_ICR                                              0x00000830
#define IA32_X2APIC_LVTIMER                                        0x00000832
#define IA32_X2APIC_LVTHERMAL                                      0x00000833
#define IA32_X2APIC_LVT_PMI                                          0x00000834
#define IA32_X2APIC_LVT_LINT0                                        0x00000835
#define IA32_X2APIC_LVT_LINT1                                        0x00000836
#define IA32_X2APIC_LVT_ERROR                                        0x00000837
#define IA32_X2APIC_INIT_COUNT                                       0x00000838
#define IA32_X2APIC_CUR_COUNT                                        0x00000839
#define IA32_X2APIC_DIV_CONF                                         0x0000083E
#define IA32_X2APIC_SELF_IPI                                         0x0000083F
#define IA32_DEBUG_INTERFACE                                         0x00000C80
typedef union {
    struct {
        UINT64 enable : 1;
        UINT64 reserved_1 : 29;
        UINT64 lock : 1;
        UINT64 debug_occurred : 1;
    };

    UINT64 flags;
} ia32_debug_interface_register;

#define IA32_L3_QOS_CFG                                              0x00000C81
typedef union {
    struct {
        UINT64 enable : 1;
    };

    UINT64 flags;
} ia32_l3_qos_cfg_register;

#define IA32_L2_QOS_CFG                                              0x00000C82
typedef union {
    struct {
        UINT64 enable : 1;
    };

    UINT64 flags;
} ia32_l2_qos_cfg_register;

#define IA32_QM_EVTSEL                                               0x00000C8D
typedef union {
    struct {
        UINT64 event_id : 8;
        UINT64 reserved_1 : 24;
        UINT64 resource_monitoring_id : 32;
    };

    UINT64 flags;
} ia32_qm_evtsel_register;

#define IA32_QM_CTR                                                  0x00000C8E
typedef union {
    struct {
        UINT64 resource_monitored_data : 62;
        UINT64 unavailable : 1;
        UINT64 error : 1;
    };

    UINT64 flags;
} ia32_qm_ctr_register;

#define IA32_PQR_ASSOC                                               0x00000C8F
typedef union {
    struct {
        UINT64 resource_monitoring_id : 32;
        UINT64 cos : 32;
    };

    UINT64 flags;
} ia32_pqr_assoc_register;

#define IA32_BNDCFGS                                                 0x00000D90
typedef union {
    struct {
        UINT64 enable : 1;
        UINT64 bnd_preserve : 1;
        UINT64 reserved_1 : 10;
        UINT64 bound_directory_base_address : 52;
    };

    UINT64 flags;
} ia32_bndcfgs_register;

#define IA32_XSS                                                     0x00000DA0
typedef union {
    struct {
        UINT64 reserved_1 : 8;
        UINT64 trace_packet_configuration_state : 1;
    };

    UINT64 flags;
} ia32_xss_register;

#define IA32_PKG_HDC_CTL                                             0x00000DB0
typedef union {
    struct {
        UINT64 hdc_pkg_enable : 1;
    };

    UINT64 flags;
} ia32_pkg_hdc_ctl_register;

#define IA32_PM_CTL1                                                 0x00000DB1
typedef union {
    struct {
        UINT64 hdc_allow_block : 1;
    };

    UINT64 flags;
} ia32_pm_ctl1_register;

#define IA32HREAD_STALL                                            0x00000DB2
typedef struct {
    UINT64 stall_cycle_cnt;
} ia32hread_stall_register;

#define IA32_EFER                                                    0xC0000080
typedef union {
    struct {
        UINT64 syscall_enable : 1;
        UINT64 reserved_1 : 7;
        UINT64 ia32e_mode_enable : 1;
        UINT64 reserved_2 : 1;
        UINT64 ia32e_mode_active : 1;
        UINT64 execute_disable_bit_enable : 1;
    };

    UINT64 flags;
} ia32_efer_register;

#define IA32_STAR                                                    0xC0000081
#define IA32_LSTAR                                                   0xC0000082
#define IA32_CSTAR                                                   0xC0000083
#define IA32_FMASK                                                   0xC0000084
#define IA32_FS_BASE                                                 0xC0000100
#define IA32_GS_BASE                                                 0xC0000101
#define IA32_KERNEL_GS_BASE                                          0xC0000102
#define IA32SC_AUX                                                 0xC0000103
typedef union {
    struct {
        UINT64 tsc_auxiliary_signature : 32;
    };

    UINT64 flags;
} ia32sc_aux_register;

/**
 * @}
 */

 /**
  * @defgroup paging \
  *           Paging
  * @{
  */
  /**
   * @defgroup paging_32 \
   *           32-Bit Paging
   * @{
   */
typedef union {
    struct {
        UINT32 present : 1;
        UINT32 write : 1;
        UINT32 supervisor : 1;
        UINT32 page_level_writehrough : 1;
        UINT32 page_level_cache_disable : 1;
        UINT32 accessed : 1;
        UINT32 dirty : 1;
        UINT32 large_page : 1;
        UINT32 global : 1;
        UINT32 ignored_1 : 3;
        UINT32 pat : 1;
        UINT32 page_frame_number_low : 8;
        UINT32 reserved_1 : 1;
        UINT32 page_frame_number_high : 10;
    };

    UINT32 flags;
} pde_4mb_32;

typedef union {
    struct {
        UINT32 present : 1;
        UINT32 write : 1;
        UINT32 supervisor : 1;
        UINT32 page_level_writehrough : 1;
        UINT32 page_level_cache_disable : 1;
        UINT32 accessed : 1;
        UINT32 ignored_1 : 1;
        UINT32 large_page : 1;
        UINT32 ignored_2 : 4;
        UINT32 page_frame_number : 20;
    };

    UINT32 flags;
} pde_32;

typedef union {
    struct {
        UINT32 present : 1;
        UINT32 write : 1;
        UINT32 supervisor : 1;
        UINT32 page_level_writehrough : 1;
        UINT32 page_level_cache_disable : 1;
        UINT32 accessed : 1;
        UINT32 dirty : 1;
        UINT32 pat : 1;
        UINT32 global : 1;
        UINT32 ignored_1 : 3;
        UINT32 page_frame_number : 20;
    };

    UINT32 flags;
} pte_32;

typedef union {
    struct {
        UINT32 present : 1;
        UINT32 write : 1;
        UINT32 supervisor : 1;
        UINT32 page_level_writehrough : 1;
        UINT32 page_level_cache_disable : 1;
        UINT32 accessed : 1;
        UINT32 dirty : 1;
        UINT32 large_page : 1;
        UINT32 global : 1;
        UINT32 ignored_1 : 3;
        UINT32 page_frame_number : 20;
    };

    UINT32 flags;
} pt_entry_32;

/**
 * @defgroup paging_structures_entry_count_32 \
 *           Paging structures entry counts
 * @{
 */
#define PDE_ENTRY_COUNT_32                                           0x00000400
#define PTE_ENTRY_COUNT_32                                           0x00000400
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @defgroup paging_64 \
    *           64-Bit (4-Level) Paging
    * @{
    */
typedef union {
    struct {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 reserved_1 : 1;
        UINT64 must_be_zero : 1;
        UINT64 ignored_1 : 3;
        UINT64 restart : 1;
        UINT64 page_frame_number : 36;
        UINT64 reserved_2 : 4;
        UINT64 ignored_2 : 11;
        UINT64 execute_disable : 1;
    };

    UINT64 flags;
} pml4e_64;

typedef union {
    struct {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 large_page : 1;
        UINT64 global : 1;
        UINT64 ignored_1 : 2;
        UINT64 restart : 1;
        UINT64 pat : 1;
        UINT64 reserved_1 : 17;
        UINT64 page_frame_number : 18;
        UINT64 reserved_2 : 4;
        UINT64 ignored_2 : 7;
        UINT64 protection_key : 4;
        UINT64 execute_disable : 1;
    };

    UINT64 flags;
} pdpte_1gb_64;

typedef union {
    struct {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 reserved_1 : 1;
        UINT64 large_page : 1;
        UINT64 ignored_1 : 3;
        UINT64 restart : 1;
        UINT64 page_frame_number : 36;
        UINT64 reserved_2 : 4;
        UINT64 ignored_2 : 11;
        UINT64 execute_disable : 1;
    };

    UINT64 flags;
} pdpte_64;

typedef union {
    struct {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 large_page : 1;
        UINT64 global : 1;
        UINT64 ignored_1 : 2;
        UINT64 restart : 1;
        UINT64 pat : 1;
        UINT64 reserved_1 : 8;
        UINT64 page_frame_number : 27;
        UINT64 reserved_2 : 4;
        UINT64 ignored_2 : 7;
        UINT64 protection_key : 4;
        UINT64 execute_disable : 1;
    };

    UINT64 flags;
} pde_2mb_64;

typedef union {
    struct {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 reserved_1 : 1;
        UINT64 large_page : 1;
        UINT64 ignored_1 : 3;
        UINT64 restart : 1;
        UINT64 page_frame_number : 36;
        UINT64 reserved_2 : 4;
        UINT64 ignored_2 : 11;
        UINT64 execute_disable : 1;
    };

    UINT64 flags;
} pde_64;

typedef union {
    struct {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 pat : 1;
        UINT64 global : 1;
        UINT64 ignored_1 : 2;
        UINT64 restart : 1;
        UINT64 page_frame_number : 36;
        UINT64 reserved_1 : 4;
        UINT64 ignored_2 : 7;
        UINT64 protection_key : 4;
        UINT64 execute_disable : 1;
    };

    UINT64 flags;
} pte_64;

typedef union {
    struct {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 large_page : 1;
        UINT64 global : 1;
        UINT64 ignored_1 : 2;
        UINT64 restart : 1;
        UINT64 page_frame_number : 36;
        UINT64 reserved_1 : 4;
        UINT64 ignored_2 : 7;
        UINT64 protection_key : 4;
        UINT64 execute_disable : 1;
    };

    UINT64 flags;
} pt_entry_64;

/**
 * @defgroup paging_structures_entry_count_64 \
 *           Paging structures entry counts
 * @{
 */
#define PML4_ENTRY_COUNT_64                                          0x00000200
#define PDPTE_ENTRY_COUNT_64                                         0x00000200
#define PDE_ENTRY_COUNT_64                                           0x00000200
#define PTE_ENTRY_COUNT_64                                           0x00000200
 /**
  * @}
  */

  /**
   * @}
   */

   /**
    * @}
    */

typedef enum {
    invpcid_individual_address = 0x00000000,
    invpcid_single_context = 0x00000001,
    invpcid_all_context_with_globals = 0x00000002,
    invpcid_all_context = 0x00000003,
} invpcidype;

typedef union {
    struct {
        UINT64 pcid : 12;
        UINT64 reserved1 : 52;
        UINT64 linear_address : 64;
    };

    UINT64 flags;
} invpcid_descriptor;

/**
 * @defgroup segment_descriptors \
 *           Segment descriptors
 * @{
 */
#pragma pack(push, 1)
typedef struct {
    UINT16 limit;
    UINT32 base_address;
} segment_descriptor_register_32;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct {
    UINT16 limit;
    UINT64 base_address;
} segment_descriptor_register_64;
#pragma pack(pop)

typedef union {
    struct {
        UINT32 reserved_1 : 8;
        UINT32 type : 4;
        UINT32 descriptorype : 1;
        UINT32 descriptor_privilege_level : 2;
        UINT32 present : 1;
        UINT32 reserved_2 : 4;
        UINT32 available_bit : 1;
        UINT32 long_mode : 1;
        UINT32 default_big : 1;
        UINT32 granularity : 1;
    };

    UINT32 flags;
} segment_access_rights;

typedef struct {
    UINT16 segment_limit_low;
    UINT16 base_address_low;
    union {
        struct {
            UINT32 base_address_middle : 8;
            UINT32 type : 4;
            UINT32 descriptorype : 1;
            UINT32 descriptor_privilege_level : 2;
            UINT32 present : 1;
            UINT32 segment_limit_high : 4;
            UINT32 available_bit : 1;
            UINT32 long_mode : 1;
            UINT32 default_big : 1;
            UINT32 granularity : 1;
            UINT32 base_address_high : 8;
        };

        UINT32 flags;
    };

} segment_descriptor_32;

typedef struct {
    UINT16 segment_limit_low;
    UINT16 base_address_low;
    union {
        struct {
            UINT32 base_address_middle : 8;
            UINT32 type : 4;
            UINT32 descriptorype : 1;
            UINT32 descriptor_privilege_level : 2;
            UINT32 present : 1;
            UINT32 segment_limit_high : 4;
            UINT32 available_bit : 1;
            UINT32 long_mode : 1;
            UINT32 default_big : 1;
            UINT32 granularity : 1;
            UINT32 base_address_high : 8;
        };

        UINT32 flags;
    };

    UINT32 base_address_upper;
    UINT32 must_be_zero;
} segment_descriptor_64;

typedef struct {
    UINT16 offset_low;
    UINT16 segment_selector;
    union {
        struct {
            UINT32 interrupt_stackable : 3;
            UINT32 must_be_zero_0 : 5;
            UINT32 type : 4;
            UINT32 must_be_zero_1 : 1;
            UINT32 descriptor_privilege_level : 2;
            UINT32 present : 1;
            UINT32 offset_middle : 16;
        };

        UINT32 flags;
    };

    UINT32 offset_high;
    UINT32 reserved;
} segment_descriptor_interrupt_gate_64;

#define SEGMENT_DESCRIPTORYPE_SYSTEM                               0x00000000
#define SEGMENT_DESCRIPTORYPE_CODE_OR_DATA                         0x00000001
/**
 * @defgroup segment_descriptor_code_and_dataype \
 *           Code- and Data-Segment Descriptor Types
 * @{
 */
#define SEGMENT_DESCRIPTORYPE_DATA_R                               0x00000000
#define SEGMENT_DESCRIPTORYPE_DATA_RA                              0x00000001
#define SEGMENT_DESCRIPTORYPE_DATA_RW                              0x00000002
#define SEGMENT_DESCRIPTORYPE_DATA_RWA                             0x00000003
#define SEGMENT_DESCRIPTORYPE_DATA_RE                              0x00000004
#define SEGMENT_DESCRIPTORYPE_DATA_REA                             0x00000005
#define SEGMENT_DESCRIPTORYPE_DATA_RWE                             0x00000006
#define SEGMENT_DESCRIPTORYPE_DATA_RWEA                            0x00000007
#define SEGMENT_DESCRIPTORYPE_CODE_E                               0x00000008
#define SEGMENT_DESCRIPTORYPE_CODE_EA                              0x00000009
#define SEGMENT_DESCRIPTORYPE_CODE_ER                              0x0000000A
#define SEGMENT_DESCRIPTORYPE_CODE_ERA                             0x0000000B
#define SEGMENT_DESCRIPTORYPE_CODE_EC                              0x0000000C
#define SEGMENT_DESCRIPTORYPE_CODE_ECA                             0x0000000D
#define SEGMENT_DESCRIPTORYPE_CODE_ERC                             0x0000000E
#define SEGMENT_DESCRIPTORYPE_CODE_ERCA                            0x0000000F
 /**
  * @}
  */

  /**
   * @defgroup segment_descriptor_systemype \
   *           System Descriptor Types
   * @{
   */
#define SEGMENT_DESCRIPTORYPE_RESERVED_1                           0x00000000
#define SEGMENT_DESCRIPTORYPESS_16_AVAILABLE                     0x00000001
#define SEGMENT_DESCRIPTORYPE_LDT                                  0x00000002
#define SEGMENT_DESCRIPTORYPESS_16_BUSY                          0x00000003
#define SEGMENT_DESCRIPTORYPE_CALL_GATE_16                         0x00000004
#define SEGMENT_DESCRIPTORYPEASK_GATE                            0x00000005
#define SEGMENT_DESCRIPTORYPE_INTERRUPT_GATE_16                    0x00000006
#define SEGMENT_DESCRIPTORYPERAP_GATE_16                         0x00000007
#define SEGMENT_DESCRIPTORYPE_RESERVED_2                           0x00000008
#define SEGMENT_DESCRIPTORYPESS_AVAILABLE                        0x00000009
#define SEGMENT_DESCRIPTORYPE_RESERVED_3                           0x0000000A
#define SEGMENT_DESCRIPTORYPESS_BUSY                             0x0000000B
#define SEGMENT_DESCRIPTORYPE_CALL_GATE                            0x0000000C
#define SEGMENT_DESCRIPTORYPE_RESERVED_4                           0x0000000D
#define SEGMENT_DESCRIPTORYPE_INTERRUPT_GATE                       0x0000000E
#define SEGMENT_DESCRIPTORYPERAP_GATE                            0x0000000F
   /**
    * @}
    */

typedef union {
    struct {
        UINT16 request_privilege_level : 2;
        UINT16 table_indicator : 1;
        UINT16 index : 13;
    };

    UINT16 flags;
} segment_selector;

/**
 * @}
 */

#pragma pack(push, 1)
typedef struct {
    UINT32 reserved_0;
    UINT64 rsp0;
    UINT64 rsp1;
    UINT64 rsp2;
    UINT64 reserved_1;
    UINT64 ist1;
    UINT64 ist2;
    UINT64 ist3;
    UINT64 ist4;
    UINT64 ist5;
    UINT64 ist6;
    UINT64 ist7;
    UINT64 reserved_2;
    UINT16 reserved_3;
    UINT16 io_map_base;
} task_state_segment_64;
#pragma pack(pop)

/**
 * @defgroup vmx \
 *           VMX
 * @{
 */
 /**
  * @{
  */
  /**
   * @defgroup vmx_basic_exit_reasons \
   *           VMX Basic Exit Reasons
   * @{
   */
#define VMX_EXIT_REASON_XCPT_OR_NMI                                  0x00000000
#define VMX_EXIT_REASON_EXT_INT                                      0x00000001
#define VMX_EXIT_REASONRIPLE_FAULT                                 0x00000002
#define VMX_EXIT_REASON_INIT_SIGNAL                                  0x00000003
#define VMX_EXIT_REASON_SIPI                                         0x00000004
#define VMX_EXIT_REASON_IO_SMI                                       0x00000005
#define VMX_EXIT_REASON_SMI                                          0x00000006
#define VMX_EXIT_REASON_INT_WINDOW                                   0x00000007
#define VMX_EXIT_REASON_NMI_WINDOW                                   0x00000008
#define VMX_EXIT_REASONASK_SWITCH                                  0x00000009
#define VMX_EXIT_REASON_CPUID                                        0x0000000A
#define VMX_EXIT_REASON_GETSEC                                       0x0000000B
#define VMX_EXIT_REASON_HLT                                          0x0000000C
#define VMX_EXIT_REASON_INVD                                         0x0000000D
#define VMX_EXIT_REASON_INVLPG                                       0x0000000E
#define VMX_EXIT_REASON_RDPMC                                        0x0000000F
#define VMX_EXIT_REASON_RDTSC                                        0x00000010
#define VMX_EXIT_REASON_RSM                                          0x00000011
#define VMX_EXIT_REASON_VMCALL                                       0x00000012
#define VMX_EXIT_REASON_VMCLEAR                                      0x00000013
#define VMX_EXIT_REASON_VMLAUNCH                                     0x00000014
#define VMX_EXIT_REASON_VMPTRLD                                      0x00000015
#define VMX_EXIT_REASON_VMPTRST                                      0x00000016
#define VMX_EXIT_REASON_VMREAD                                       0x00000017
#define VMX_EXIT_REASON_VMRESUME                                     0x00000018
#define VMX_EXIT_REASON_VMWRITE                                      0x00000019
#define VMX_EXIT_REASON_VMXOFF                                       0x0000001A
#define VMX_EXIT_REASON_VMXON                                        0x0000001B
#define VMX_EXIT_REASON_MOV_CRX                                      0x0000001C
#define VMX_EXIT_REASON_MOV_DRX                                      0x0000001D
#define VMX_EXIT_REASON_IO_INSTR                                     0x0000001E
#define VMX_EXIT_REASON_RDMSR                                        0x0000001F
#define VMX_EXIT_REASON_WRMSR                                        0x00000020
#define VMX_EXIT_REASON_ERR_INVALID_GUEST_STATE                      0x00000021
#define VMX_EXIT_REASON_ERR_MSR_LOAD                                 0x00000022
#define VMX_EXIT_REASON_MWAIT                                        0x00000024
#define VMX_EXIT_REASON_MTF                                          0x00000025
#define VMX_EXIT_REASON_MONITOR                                      0x00000027
#define VMX_EXIT_REASON_PAUSE                                        0x00000028
#define VMX_EXIT_REASON_ERR_MACHINE_CHECK                            0x00000029
#define VMX_EXIT_REASONPR_BELOWHRESHOLD                          0x0000002B
#define VMX_EXIT_REASON_APIC_ACCESS                                  0x0000002C
#define VMX_EXIT_REASON_VIRTUALIZED_EOI                              0x0000002D
#define VMX_EXIT_REASON_XDTR_ACCESS                                  0x0000002E
#define VMX_EXIT_REASONR_ACCESS                                    0x0000002F
#define VMX_EXIT_REASON_EPT_VIOLATION                                0x00000030
#define VMX_EXIT_REASON_EPT_MISCONFIG                                0x00000031
#define VMX_EXIT_REASON_INVEPT                                       0x00000032
#define VMX_EXIT_REASON_RDTSCP                                       0x00000033
#define VMX_EXIT_REASON_PREEMPTIMER                                0x00000034
#define VMX_EXIT_REASON_INVVPID                                      0x00000035
#define VMX_EXIT_REASON_WBINVD                                       0x00000036
#define VMX_EXIT_REASON_XSETBV                                       0x00000037
#define VMX_EXIT_REASON_APIC_WRITE                                   0x00000038
#define VMX_EXIT_REASON_RDRAND                                       0x00000039
#define VMX_EXIT_REASON_INVPCID                                      0x0000003A
#define VMX_EXIT_REASON_VMFUNC                                       0x0000003B
#define VMX_EXIT_REASON_ENCLS                                        0x0000003C
#define VMX_EXIT_REASON_RDSEED                                       0x0000003D
#define VMX_EXIT_REASON_PML_FULL                                     0x0000003E
#define VMX_EXIT_REASON_XSAVES                                       0x0000003F
#define VMX_EXIT_REASON_XRSTORS                                      0x00000040
#define VMX_EXIT_REASON_PCONFIG                                      0x00000041
#define VMX_EXIT_REASON_SPP_EVENT                                    0x00000042
#define VMX_EXIT_REASON_UMWAIT                                       0x00000043
#define VMX_EXIT_REASONPAUSE                                       0x00000044
#define VMX_EXIT_REASON_LOADIWKEY                                    0x00000045
#define VMX_EXIT_REASON_ENCLV                                        0x00000046
#define VMX_EXIT_REASON_ENQCMD                                       0x00000048
#define VMX_EXIT_REASON_ENQCMDS                                      0x00000049
#define VMX_EXIT_REASON_BUS_LOCK                                     0x0000004A
#define VMX_EXIT_REASON_INSTRUCTIONIMEOUT                          0x0000004B
#define VMX_EXIT_REASON_SEAMCALL                                     0x0000004C
#define VMX_EXIT_REASONDCALL                                       0x0000004D
#define VMX_EXIT_REASON_RDMSRLIST                                    0x0000004E
#define VMX_EXIT_REASON_WRMSRLIST                                    0x0000004F
   /**
    * @}
    */

    /**
     * @defgroup vmx_instruction_error_numbers \
     *           VM-Instruction Error Numbers
     * @{
     */
#define VMX_ERROR_VMCALL                                             0x00000001
#define VMX_ERROR_VMCLEAR_INVALID_PHYS_ADDR                          0x00000002
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_PTR                          0x00000003
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS                             0x00000004
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS                         0x00000005
#define VMX_ERROR_VMRESUME_CORRUPTED_VMCS                            0x00000006
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS                     0x00000007
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE                         0x00000008
#define VMX_ERROR_VMPTRLD_INVALID_PHYS_ADDR                          0x00000009
#define VMX_ERROR_VMPTRLD_VMXON_PTR                                  0x0000000A
#define VMX_ERROR_VMPTRLD_WRONG_VMCS_REVISION                        0x0000000B
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT                   0x0000000C
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT                         0x0000000D
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP                               0x0000000F
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXEC_PTR                      0x00000010
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXEC_VMCS                     0x00000011
#define VMX_ERROR_VMENTRY_EXEC_VMCS_PTR                              0x00000012
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS                              0x00000013
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS                       0x00000014
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION                       0x00000016
#define VMX_ERROR_VMXOFF_DUAL_MONITOR                                0x00000017
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR                         0x00000018
#define VMX_ERROR_VMENTRY_INVALID_VM_EXEC_CTRL                       0x00000019
#define VMX_ERROR_VMENTRY_MOV_SS                                     0x0000001A
#define VMX_ERROR_INVEPTVPID_INVALID_OPERAND                         0x0000001C
     /**
      * @}
      */

      /**
       * @defgroup vmx_exceptions \
       *           Virtualization Exceptions
       * @{
       */
typedef struct {
    UINT32 reason;
    UINT32 exception_mask;
    UINT64 exit;
    UINT64 guest_linear_address;
    UINT64 guest_physical_address;
    UINT16 current_eptp_index;
} vmx_ve_except_info;

/**
 * @}
 */

 /**
  * @defgroup vmx_basic_exit_information \
  *           Basic VM-Exit Information
  * @{
  */
typedef union {
    struct {
        UINT64 breakpoint_condition : 4;
        UINT64 reserved_1 : 9;
        UINT64 debug_register_access_detected : 1;
        UINT64 single_instruction : 1;
    };

    UINT64 flags;
} vmx_exit_qualification_debug_exception;

typedef union {
    struct {
        UINT64 selector : 16;
        UINT64 reserved_1 : 14;
        UINT64 type : 2;
#define VMX_EXIT_QUALIFICATIONYPE_CALL                             0x00000000
#define VMX_EXIT_QUALIFICATIONYPE_IRET                             0x00000001
#define VMX_EXIT_QUALIFICATIONYPE_JMP                              0x00000002
#define VMX_EXIT_QUALIFICATIONYPE_IDT                              0x00000003
    };

    UINT64 flags;
} vmx_exit_qualificationask_switch;

typedef union {
    struct {
        UINT64 cr_number : 4;
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                          0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                          0x00000008
        UINT64 accessype : 2;
#define VMX_EXIT_QUALIFICATION_ACCESS_MOVO_CR                      0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR                    0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS                           0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW                           0x00000003
        UINT64 lmsw_operandype : 1;
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER                      0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                        0x00000001
        UINT64 reserved_1 : 1;
        UINT64 gp_register : 4;
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                            0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                            0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                            0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                            0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                            0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                            0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                            0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                            0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                             0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                             0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                            0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                            0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                            0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                            0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                            0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                            0x0000000F
        UINT64 reserved_2 : 4;
        UINT64 lmsw_source_data : 16;
    };

    UINT64 flags;
} vmx_exit_qualification_cr_access;

typedef union {
    struct {
        UINT64 dr_number : 3;
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0                          0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1                          0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2                          0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3                          0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6                          0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7                          0x00000007
        UINT64 reserved_1 : 1;
        UINT64 direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOVO_DR                   0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR                 0x00000001
        UINT64 reserved_2 : 3;
        UINT64 gp_register : 4;
    };

    UINT64 flags;
} vmx_exit_qualification_dr_access;

typedef union {
    struct {
        UINT64 size_of_access : 3;
#define VMX_EXIT_QUALIFICATION_WIDTH_1B                              0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2B                              0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4B                              0x00000003
        UINT64 direction_of_access : 1;
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                         0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                          0x00000001
        UINT64 string_instruction : 1;
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                  0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                      0x00000001
        UINT64 rep_prefixed : 1;
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                        0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                            0x00000001
        UINT64 operand_encoding : 1;
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                           0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMM                          0x00000001
        UINT64 reserved_1 : 9;
        UINT64 port_number : 16;
    };

    UINT64 flags;
} vmx_exit_qualification_io_inst;

typedef union {
    struct {
        UINT64 page_offset : 12;
        UINT64 accessype : 4;
#define VMX_EXIT_QUALIFICATIONYPE_LINEAR_READ                      0x00000000
#define VMX_EXIT_QUALIFICATIONYPE_LINEAR_WRITE                     0x00000001
#define VMX_EXIT_QUALIFICATIONYPE_LINEAR_INSTR_FETCH               0x00000002
#define VMX_EXIT_QUALIFICATIONYPE_LINEAR_EVENT_DELIVERY            0x00000003
#define VMX_EXIT_QUALIFICATIONYPE_PHYSICAL_EVENT_DELIVERY          0x0000000A
#define VMX_EXIT_QUALIFICATIONYPE_PHYSICAL_INSTR                   0x0000000F
    };

    UINT64 flags;
} vmx_exit_qualification_apic_access;

typedef union {
    struct {
        UINT64 data_read : 1;
        UINT64 data_write : 1;
        UINT64 instruction_fetch : 1;
        UINT64 entry_present : 1;
        UINT64 entry_write : 1;
        UINT64 entry_execute : 1;
        UINT64 entry_execute_for_user_mode : 1;
        UINT64 valid_guest_linear_address : 1;
        UINT64 eptranslated_access : 1;
        UINT64 user_mode_linear_address : 1;
        UINT64 readable_writable_page : 1;
        UINT64 execute_disable_page : 1;
        UINT64 nmi_unblocking : 1;
        UINT64 shadow_stack_access : 1;
        UINT64 supervisor_shadow_stack : 1;
        UINT64 guest_paging_verification : 1;
        UINT64 asynchronouso_instruction : 1;
    };

    UINT64 flags;
} vmx_exit_qualification_ept_violation;

/**
 * @}
 */

 /**
  * @defgroup vmx_vmexit_instruction_information \
  *           Information for VM Exits Due to Instruction Execution
  * @{
  */
typedef union {
    struct {
        UINT64 reserved_1 : 7;
        UINT64 address_size : 3;
        UINT64 reserved_2 : 5;
        UINT64 segment_register : 3;
    };

    UINT64 flags;
} vmx_vmexit_instruction_info_ins_outs;

typedef union {
    struct {
        UINT64 scaling : 2;
        UINT64 reserved_1 : 5;
        UINT64 address_size : 3;
        UINT64 reserved_2 : 5;
        UINT64 segment_register : 3;
        UINT64 gp_register : 4;
        UINT64 gp_register_invalid : 1;
        UINT64 base_register : 4;
        UINT64 base_register_invalid : 1;
        UINT64 register_2 : 4;
    };

    UINT64 flags;
} vmx_vmexit_instruction_info_invalidate;

typedef union {
    struct {
        UINT64 scaling : 2;
        UINT64 reserved_1 : 5;
        UINT64 address_size : 3;
        UINT64 reserved_2 : 1;
        UINT64 operand_size : 1;
        UINT64 reserved_3 : 3;
        UINT64 segment_register : 3;
        UINT64 gp_register : 4;
        UINT64 gp_register_invalid : 1;
        UINT64 base_register : 4;
        UINT64 base_register_invalid : 1;
        UINT64 instruction_identity : 2;
    };

    UINT64 flags;
} vmx_vmexit_instruction_info_gdtr_idtr_access;

typedef union {
    struct {
        UINT64 scaling : 2;
        UINT64 reserved_1 : 1;
        UINT64 reg_1 : 4;
        UINT64 address_size : 3;
        UINT64 memory_register : 1;
        UINT64 reserved_2 : 4;
        UINT64 segment_register : 3;
        UINT64 gp_register : 4;
        UINT64 gp_register_invalid : 1;
        UINT64 base_register : 4;
        UINT64 base_register_invalid : 1;
        UINT64 instruction_identity : 2;
    };

    UINT64 flags;
} vmx_vmexit_instruction_info_ldtrr_access;

typedef union {
    struct {
        UINT64 reserved_1 : 3;
        UINT64 destination_register : 4;
        UINT64 reserved_2 : 4;
        UINT64 operand_size : 2;
    };

    UINT64 flags;
} vmx_vmexit_instruction_info_rdrand_rdseed;

typedef union {
    struct {
        UINT64 scaling : 2;
        UINT64 reserved_1 : 5;
        UINT64 address_size : 3;
        UINT64 reserved_2 : 5;
        UINT64 segment_register : 3;
        UINT64 gp_register : 4;
        UINT64 gp_register_invalid : 1;
        UINT64 base_register : 4;
        UINT64 base_register_invalid : 1;
    };

    UINT64 flags;
} vmx_vmexit_instruction_info_vmx_and_xsaves;

typedef union {
    struct {
        UINT64 scaling : 2;
        UINT64 reserved_1 : 1;
        UINT64 register_1 : 4;
        UINT64 address_size : 3;
        UINT64 memory_register : 1;
        UINT64 reserved_2 : 4;
        UINT64 segment_register : 3;
        UINT64 gp_register : 4;
        UINT64 gp_register_invalid : 1;
        UINT64 base_register : 4;
        UINT64 base_register_invalid : 1;
        UINT64 register_2 : 4;
    };

    UINT64 flags;
} vmx_vmexit_instruction_info_vmread_vmwrite;

/**
 * @}
 */

typedef union {
    struct {
        UINT32 type : 4;
        UINT32 descriptorype : 1;
        UINT32 descriptor_privilege_level : 2;
        UINT32 present : 1;
        UINT32 reserved_1 : 4;
        UINT32 available_bit : 1;
        UINT32 long_mode : 1;
        UINT32 default_big : 1;
        UINT32 granularity : 1;
        UINT32 unusable : 1;
    };

    UINT32 flags;
} vmx_segment_access_rights;

typedef union {
    struct {
        UINT32 blocking_by_sti : 1;
        UINT32 blocking_by_mov_ss : 1;
        UINT32 blocking_by_smi : 1;
        UINT32 blocking_by_nmi : 1;
        UINT32 enclave_interruption : 1;
    };

    UINT32 flags;
} vmx_interruptibility_state;

typedef enum {
    vmx_active = 0x00000000,
    vmx_hlt = 0x00000001,
    vmx_shutdown = 0x00000002,
    vmx_wait_for_sipi = 0x00000003,
} vmx_guest_activity_state;

typedef union {
    struct {
        UINT64 b0 : 1;
        UINT64 b1 : 1;
        UINT64 b2 : 1;
        UINT64 b3 : 1;
        UINT64 reserved_1 : 8;
        UINT64 enabled_breakpoint : 1;
        UINT64 reserved_2 : 1;
        UINT64 bs : 1;
        UINT64 reserved_3 : 1;
        UINT64 rtm : 1;
    };

    UINT64 flags;
} vmx_pending_debug_exceptions;

/**
 * @}
 */

typedef union {
    struct {
        UINT32 basic_exit_reason : 16;
        UINT32 always0 : 1;
        UINT32 reserved1 : 10;
        UINT32 enclave_mode : 1;
        UINT32 pending_mtf_vm_exit : 1;
        UINT32 vm_exit_from_vmx_root : 1;
        UINT32 reserved2 : 1;
        UINT32 vm_entry_failure : 1;
    };

    UINT32 flags;
} vmx_vmexit_reason;

typedef struct {
#define IO_BITMAP_A_MIN                                              0x00000000
#define IO_BITMAP_A_MAX                                              0x00007FFF
#define IO_BITMAP_B_MIN                                              0x00008000
#define IO_BITMAP_B_MAX                                              0x0000FFFF
    UINT8 io_a[4096];
    UINT8 io_b[4096];
} vmx_io_bitmap;

typedef struct {
#define MSR_ID_LOW_MIN                                               0x00000000
#define MSR_ID_LOW_MAX                                               0x00001FFF
#define MSR_ID_HIGH_MIN                                              0xC0000000
#define MSR_ID_HIGH_MAX                                              0xC0001FFF
    UINT8 rdmsr_low[1024];
    UINT8 rdmsr_high[1024];
    UINT8 wrmsr_low[1024];
    UINT8 wrmsr_high[1024];
} vmx_msr_bitmap;

/**
 * @defgroup ept \
 *           The extended page-table mechanism
 * @{
 */
typedef union {
    struct {
        UINT64 memoryype : 3;
        UINT64 page_walk_length : 3;
#define EPT_PAGE_WALK_LENGTH_4                                       0x00000003
        UINT64 enable_access_and_dirty_flags : 1;
        UINT64 enable_supervisor_shadow_stack_pages : 1;
        UINT64 reserved_1 : 4;
        UINT64 page_frame_number : 36;
    };

    UINT64 flags;
} eptp;

typedef union {
    struct {
        UINT64 read_access : 1;
        UINT64 write_access : 1;
        UINT64 execute_access : 1;
        UINT64 reserved_1 : 5;
        UINT64 accessed : 1;
        UINT64 reserved_2 : 1;
        UINT64 user_mode_execute : 1;
        UINT64 reserved_3 : 1;
        UINT64 page_frame_number : 36;
    };

    UINT64 flags;
} epml4e;

typedef union {
    struct {
        UINT64 read_access : 1;
        UINT64 write_access : 1;
        UINT64 execute_access : 1;
        UINT64 memoryype : 3;
        UINT64 ignore_pat : 1;
        UINT64 large_page : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 user_mode_execute : 1;
        UINT64 reserved_1 : 19;
        UINT64 page_frame_number : 18;
        UINT64 reserved_2 : 9;
        UINT64 verify_guest_paging : 1;
        UINT64 paging_write_access : 1;
        UINT64 reserved_3 : 1;
        UINT64 supervisor_shadow_stack : 1;
        UINT64 reserved_4 : 2;
        UINT64 suppress_ve : 1;
    };

    UINT64 flags;
} epdpte_1gb;

typedef union {
    struct {
        UINT64 read_access : 1;
        UINT64 write_access : 1;
        UINT64 execute_access : 1;
        UINT64 reserved_1 : 5;
        UINT64 accessed : 1;
        UINT64 reserved_2 : 1;
        UINT64 user_mode_execute : 1;
        UINT64 reserved_3 : 1;
        UINT64 page_frame_number : 36;
    };

    UINT64 flags;
} epdpte;

typedef union {
    struct {
        UINT64 read_access : 1;
        UINT64 write_access : 1;
        UINT64 execute_access : 1;
        UINT64 memoryype : 3;
        UINT64 ignore_pat : 1;
        UINT64 large_page : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 user_mode_execute : 1;
        UINT64 reserved_1 : 10;
        UINT64 page_frame_number : 27;
        UINT64 reserved_2 : 9;
        UINT64 verify_guest_paging : 1;
        UINT64 paging_write_access : 1;
        UINT64 reserved_3 : 1;
        UINT64 supervisor_shadow_stack : 1;
        UINT64 reserved_4 : 2;
        UINT64 suppress_ve : 1;
    };

    UINT64 flags;
} epde_2mb;

typedef union {
    struct {
        UINT64 read_access : 1;
        UINT64 write_access : 1;
        UINT64 execute_access : 1;
        UINT64 reserved_1 : 5;
        UINT64 accessed : 1;
        UINT64 reserved_2 : 1;
        UINT64 user_mode_execute : 1;
        UINT64 reserved_3 : 1;
        UINT64 page_frame_number : 36;
    };

    UINT64 flags;
} epde;

typedef union {
    struct {
        UINT64 read_access : 1;
        UINT64 write_access : 1;
        UINT64 execute_access : 1;
        UINT64 memoryype : 3;
        UINT64 ignore_pat : 1;
        UINT64 reserved_1 : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 user_mode_execute : 1;
        UINT64 reserved_2 : 1;
        UINT64 page_frame_number : 36;
        UINT64 reserved_3 : 9;
        UINT64 verify_guest_paging : 1;
        UINT64 paging_write_access : 1;
        UINT64 reserved_4 : 1;
        UINT64 supervisor_shadow_stack : 1;
        UINT64 sub_page_write_permissions : 1;
        UINT64 reserved_5 : 1;
        UINT64 suppress_ve : 1;
    };

    UINT64 flags;
} epte;

typedef union {
    struct {
        UINT64 read_access : 1;
        UINT64 write_access : 1;
        UINT64 execute_access : 1;
        UINT64 memoryype : 3;
        UINT64 ignore_pat : 1;
        UINT64 large_page : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 user_mode_execute : 1;
        UINT64 reserved_1 : 1;
        UINT64 page_frame_number : 36;
        UINT64 reserved_2 : 15;
        UINT64 suppress_ve : 1;
    };

    UINT64 flags;
} ept_entry;

/**
 * @defgroup eptable_level \
 *           EPT Table level numbers
 * @{
 */
#define EPT_LEVEL_PML4E                                              0x00000003
#define EPT_LEVEL_PDPTE                                              0x00000002
#define EPT_LEVEL_PDE                                                0x00000001
#define EPT_LEVEL_PTE                                                0x00000000
 /**
  * @}
  */

  /**
   * @defgroup ept_entry_count \
   *           EPT Entry counts
   * @{
   */
#define EPML4_ENTRY_COUNT                                            0x00000200
#define EPDPTE_ENTRY_COUNT                                           0x00000200
#define EPDE_ENTRY_COUNT                                             0x00000200
#define EPTE_ENTRY_COUNT                                             0x00000200
   /**
    * @}
    */

    /**
     * @}
     */

typedef enum {
    invept_single_context = 0x00000001,
    invept_all_context = 0x00000002,
} inveptype;

typedef enum {
    invvpid_individual_address = 0x00000000,
    invvpid_single_context = 0x00000001,
    invvpid_all_context = 0x00000002,
    invvpid_single_context_retaining_globals = 0x00000003,
} invvpidype;

typedef struct {
    UINT64 ept_pointer;
    UINT64 reserved;
} invept_descriptor;

typedef struct {
    UINT16 vpid;
    UINT16 reserved1;
    UINT32 reserved2;
    UINT64 linear_address;
} invvpid_descriptor;

typedef union {
    struct {
        UINT64 reserved_1 : 3;
        UINT64 page_level_writehrough : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 reserved_2 : 7;
        UINT64 page_frame_number : 36;
    };

    UINT64 flags;
} hlatp;

typedef struct {
    struct {
        UINT32 revision_id : 31;
        UINT32 shadow_vmcs_indicator : 1;
    };

    UINT32 abort_indicator;
    UINT8 data[4088];
} vmcs;

typedef struct {
    struct {
        UINT32 revision_id : 31;
        UINT32 must_be_zero : 1;
    };

    UINT8 data[4092];
} vmxon;

/**
 * @defgroup vmcs_fields \
 *           VMCS (VM Control Structure)
 * @{
 */
typedef union {
    struct {
        UINT16 accessype : 1;
        UINT16 index : 9;
        UINT16 type : 2;
        UINT16 must_be_zero : 1;
        UINT16 width : 2;
    };

    UINT16 flags;
} vmcs_component_encoding;

/**
 * @defgroup vmcs_16_bit \
 *           16-Bit Fields
 * @{
 */
 /**
  * @defgroup vmcs_16_bit_control_fields \
  *           16-Bit Control Fields
  * @{
  */
#define VMCS_CTRL_VPID                                               0x00000000
#define VMCS_CTRL_POSTED_INTR_NOTIFY_VECTOR                          0x00000002
#define VMCS_CTRL_EPTP_INDEX                                         0x00000004
#define VMCS_CTRL_HLAT_PREFIX_SIZE                                   0x00000006
#define VMCS_CTRL_LAST_PID_PTR_INDEX                                 0x00000008
  /**
   * @}
   */

   /**
    * @defgroup vmcs_16_bit_guest_state_fields \
    *           16-Bit Guest-State Fields
    * @{
    */
#define VMCS_GUEST_ES_SEL                                            0x00000800
#define VMCS_GUEST_CS_SEL                                            0x00000802
#define VMCS_GUEST_SS_SEL                                            0x00000804
#define VMCS_GUEST_DS_SEL                                            0x00000806
#define VMCS_GUEST_FS_SEL                                            0x00000808
#define VMCS_GUEST_GS_SEL                                            0x0000080A
#define VMCS_GUEST_LDTR_SEL                                          0x0000080C
#define VMCS_GUESTR_SEL                                            0x0000080E
#define VMCS_GUEST_INTR_STATUS                                       0x00000810
#define VMCS_GUEST_PML_INDEX                                         0x00000812
#define VMCS_GUEST_UINV                                              0x00000814
    /**
     * @}
     */

     /**
      * @defgroup vmcs_16_bit_host_state_fields \
      *           16-Bit Host-State Fields
      * @{
      */
#define VMCS_HOST_ES_SEL                                             0x00000C00
#define VMCS_HOST_CS_SEL                                             0x00000C02
#define VMCS_HOST_SS_SEL                                             0x00000C04
#define VMCS_HOST_DS_SEL                                             0x00000C06
#define VMCS_HOST_FS_SEL                                             0x00000C08
#define VMCS_HOST_GS_SEL                                             0x00000C0A
#define VMCS_HOSTR_SEL                                             0x00000C0C
      /**
       * @}
       */

       /**
        * @}
        */

        /**
         * @defgroup vmcs_64_bit \
         *           64-Bit Fields
         * @{
         */
         /**
          * @defgroup vmcs_64_bit_control_fields \
          *           64-Bit Control Fields
          * @{
          */
#define VMCS_CTRL_IO_BITMAP_A                                        0x00002000
#define VMCS_CTRL_IO_BITMAP_B                                        0x00002002
#define VMCS_CTRL_MSR_BITMAP                                         0x00002004
#define VMCS_CTRL_VMEXIT_MSR_STORE                                   0x00002006
#define VMCS_CTRL_VMEXIT_MSR_LOAD                                    0x00002008
#define VMCS_CTRL_VMENTRY_MSR_LOAD                                   0x0000200A
#define VMCS_CTRL_EXEC_VMCS_PTR                                      0x0000200C
#define VMCS_CTRL_PML_ADDR                                           0x0000200E
#define VMCS_CTRLSC_OFFSET                                         0x00002010
#define VMCS_CTRL_VAPIC_PAGEADDR                                     0x00002012
#define VMCS_CTRL_APIC_ACCESSADDR                                    0x00002014
#define VMCS_CTRL_POSTED_INTR_DESC                                   0x00002016
#define VMCS_CTRL_VMFUNC_CTRLS                                       0x00002018
#define VMCS_CTRL_EPTP                                               0x0000201A
#define VMCS_CTRL_EOI_BITMAP_0                                       0x0000201C
#define VMCS_CTRL_EOI_BITMAP_1                                       0x0000201E
#define VMCS_CTRL_EOI_BITMAP_2                                       0x00002020
#define VMCS_CTRL_EOI_BITMAP_3                                       0x00002022
#define VMCS_CTRL_EPTP_LIST                                          0x00002024
#define VMCS_CTRL_VMREAD_BITMAP                                      0x00002026
#define VMCS_CTRL_VMWRITE_BITMAP                                     0x00002028
#define VMCS_CTRL_VIRTXCPT_INFO_ADDR                                 0x0000202A
#define VMCS_CTRL_XSS_EXITING_BITMAP                                 0x0000202C
#define VMCS_CTRL_ENCLS_EXITING_BITMAP                               0x0000202E
#define VMCS_CTRL_SPPABLE_POINTER                                  0x00002030
#define VMCS_CTRLSC_MULTIPLIER                                     0x00002032
#define VMCS_CTRL_PROC_EXEC3                                         0x00002034
#define VMCS_CTRL_ENCLV_EXITING_BITMAP                               0x00002036
#define VMCS_CTRL_LOW_PASID_DIR_ADDR                                 0x00002038
#define VMCS_CTRL_HIGH_PASID_DIR_ADDR                                0x0000203A
#define VMCS_CTRL_SHARED_EPTP                                        0x0000203C
#define VMCS_CTRL_PCONFIG_BITMAP                                     0x0000203E
#define VMCS_CTRL_HLATP                                              0x00002040
#define VMCS_CTRL_PID_PTRABLE                                      0x00002042
#define VMCS_CTRL_SECONDARY_EXIT                                     0x00002044
#define VMCS_CTRL_SPEC_CTRL_MASK                                     0x0000204A
#define VMCS_CTRL_SPEC_CTRL_SHADOW                                   0x0000204C
          /**
           * @}
           */

           /**
            * @defgroup vmcs_64_bit_read_only_data_fields \
            *           64-Bit Read-Only Data Field
            * @{
            */
#define VMCS_GUEST_PHYS_ADDR                                         0x00002400
            /**
             * @}
             */

             /**
              * @defgroup vmcs_64_bit_guest_state_fields \
              *           64-Bit Guest-State Fields
              * @{
              */
#define VMCS_GUEST_VMCS_LINK_PTR                                     0x00002800
#define VMCS_GUEST_DEBUGCTL                                          0x00002802
#define VMCS_GUEST_PAT                                               0x00002804
#define VMCS_GUEST_EFER                                              0x00002806
#define VMCS_GUEST_PERF_GLOBAL_CTRL                                  0x00002808
#define VMCS_GUEST_PDPTE0                                            0x0000280A
#define VMCS_GUEST_PDPTE1                                            0x0000280C
#define VMCS_GUEST_PDPTE2                                            0x0000280E
#define VMCS_GUEST_PDPTE3                                            0x00002810
#define VMCS_GUEST_BNDCFGS                                           0x00002812
#define VMCS_GUEST_RTIT_CTL                                          0x00002814
#define VMCS_GUEST_LBR_CTL                                           0x00002816
#define VMCS_GUEST_PKRS                                              0x00002818
              /**
               * @}
               */

               /**
                * @defgroup vmcs_64_bit_host_state_fields \
                *           64-Bit Host-State Fields
                * @{
                */
#define VMCS_HOST_PAT                                                0x00002C00
#define VMCS_HOST_EFER                                               0x00002C02
#define VMCS_HOST_PERF_GLOBAL_CTRL                                   0x00002C04
#define VMCS_HOST_PKRS                                               0x00002C06
                /**
                 * @}
                 */

                 /**
                  * @}
                  */

                  /**
                   * @defgroup vmcs_32_bit \
                   *           32-Bit Fields
                   * @{
                   */
                   /**
                    * @defgroup vmcs_32_bit_control_fields \
                    *           32-Bit Control Fields
                    * @{
                    */
#define VMCS_CTRL_PIN_EXEC                                           0x00004000
#define VMCS_CTRL_PROC_EXEC                                          0x00004002
#define VMCS_CTRL_EXCEPTION_BITMAP                                   0x00004004
#define VMCS_CTRL_PAGEFAULT_ERROR_MASK                               0x00004006
#define VMCS_CTRL_PAGEFAULT_ERROR_MATCH                              0x00004008
#define VMCS_CTRL_CR3ARGET_COUNT                                   0x0000400A
#define VMCS_CTRL_PRIMARY_EXIT                                       0x0000400C
#define VMCS_CTRL_EXIT_MSR_STORE_COUNT                               0x0000400E
#define VMCS_CTRL_EXIT_MSR_LOAD_COUNT                                0x00004010
#define VMCS_CTRL_ENTRY                                              0x00004012
#define VMCS_CTRL_ENTRY_MSR_LOAD_COUNT                               0x00004014
#define VMCS_CTRL_ENTRY_INTERRUPTION_INFO                            0x00004016
#define VMCS_CTRL_ENTRY_EXCEPTION_ERRCODE                            0x00004018
#define VMCS_CTRL_ENTRY_INSTR_LENGTH                                 0x0000401A
#define VMCS_CTRLPRHRESHOLD                                      0x0000401C
#define VMCS_CTRL_PROC_EXEC2                                         0x0000401E
#define VMCS_CTRL_PLE_GAP                                            0x00004020
#define VMCS_CTRL_PLE_WINDOW                                         0x00004022
                    /**
                     * @}
                     */

                     /**
                      * @defgroup vmcs_32_bit_read_only_data_fields \
                      *           32-Bit Read-Only Data Fields
                      * @{
                      */
#define VMCS_VM_INSTR_ERROR                                          0x00004400
#define VMCS_EXIT_REASON                                             0x00004402
#define VMCS_EXIT_INTERRUPTION_INFO                                  0x00004404
#define VMCS_EXIT_INTERRUPTION_ERROR_CODE                            0x00004406
#define VMCS_IDT_VECTORING_INFO                                      0x00004408
#define VMCS_IDT_VECTORING_ERROR_CODE                                0x0000440A
#define VMCS_EXIT_INSTR_LENGTH                                       0x0000440C
#define VMCS_EXIT_INSTR_INFO                                         0x0000440E
                      /**
                       * @}
                       */

                       /**
                        * @defgroup vmcs_32_bit_guest_state_fields \
                        *           32-Bit Guest-State Fields
                        * @{
                        */
#define VMCS_GUEST_ES_LIMIT                                          0x00004800
#define VMCS_GUEST_CS_LIMIT                                          0x00004802
#define VMCS_GUEST_SS_LIMIT                                          0x00004804
#define VMCS_GUEST_DS_LIMIT                                          0x00004806
#define VMCS_GUEST_FS_LIMIT                                          0x00004808
#define VMCS_GUEST_GS_LIMIT                                          0x0000480A
#define VMCS_GUEST_LDTR_LIMIT                                        0x0000480C
#define VMCS_GUESTR_LIMIT                                          0x0000480E
#define VMCS_GUEST_GDTR_LIMIT                                        0x00004810
#define VMCS_GUEST_IDTR_LIMIT                                        0x00004812
#define VMCS_GUEST_ES_ACCESS_RIGHTS                                  0x00004814
#define VMCS_GUEST_CS_ACCESS_RIGHTS                                  0x00004816
#define VMCS_GUEST_SS_ACCESS_RIGHTS                                  0x00004818
#define VMCS_GUEST_DS_ACCESS_RIGHTS                                  0x0000481A
#define VMCS_GUEST_FS_ACCESS_RIGHTS                                  0x0000481C
#define VMCS_GUEST_GS_ACCESS_RIGHTS                                  0x0000481E
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                                0x00004820
#define VMCS_GUESTR_ACCESS_RIGHTS                                  0x00004822
#define VMCS_GUEST_INTERRUPTIBILITY_STATE                            0x00004824
#define VMCS_GUEST_ACTIVITY_STATE                                    0x00004826
#define VMCS_GUEST_SMBASE                                            0x00004828
#define VMCS_GUEST_SYSENTER_CS                                       0x0000482A
#define VMCS_GUEST_PREEMPTIMER_VALUE                               0x0000482E
                        /**
                         * @}
                         */

                         /**
                          * @defgroup vmcs_32_bit_host_state_fields \
                          *           32-Bit Host-State Field
                          * @{
                          */
#define VMCS_HOST_SYSENTER_CS                                        0x00004C00
                          /**
                           * @}
                           */

                           /**
                            * @}
                            */

                            /**
                             * @defgroup vmcs_natural_width \
                             *           Natural-Width Fields
                             * @{
                             */
                             /**
                              * @defgroup vmcs_natural_width_control_fields \
                              *           Natural-Width Control Fields
                              * @{
                              */
#define VMCS_CTRL_CR0_MASK                                           0x00006000
#define VMCS_CTRL_CR4_MASK                                           0x00006002
#define VMCS_CTRL_CR0_READ_SHADOW                                    0x00006004
#define VMCS_CTRL_CR4_READ_SHADOW                                    0x00006006
#define VMCS_CTRL_CR3ARGET_VAL0                                    0x00006008
#define VMCS_CTRL_CR3ARGET_VAL1                                    0x0000600A
#define VMCS_CTRL_CR3ARGET_VAL2                                    0x0000600C
#define VMCS_CTRL_CR3ARGET_VAL3                                    0x0000600E
                              /**
                               * @}
                               */

                               /**
                                * @defgroup vmcs_natural_width_read_only_data_fields \
                                *           Natural-Width Read-Only Data Fields
                                * @{
                                */
#define VMCS_EXIT_QUALIFICATION                                      0x00006400
#define VMCS_IO_RCX                                                  0x00006402
#define VMCS_IO_RSI                                                  0x00006404
#define VMCS_IO_RDI                                                  0x00006406
#define VMCS_IO_RIP                                                  0x00006408
#define VMCS_EXIT_GUEST_LINEAR_ADDR                                  0x0000640A
                                /**
                                 * @}
                                 */

                                 /**
                                  * @defgroup vmcs_natural_width_guest_state_fields \
                                  *           Natural-Width Guest-State Fields
                                  * @{
                                  */
#define VMCS_GUEST_CR0                                               0x00006800
#define VMCS_GUEST_CR3                                               0x00006802
#define VMCS_GUEST_CR4                                               0x00006804
#define VMCS_GUEST_ES_BASE                                           0x00006806
#define VMCS_GUEST_CS_BASE                                           0x00006808
#define VMCS_GUEST_SS_BASE                                           0x0000680A
#define VMCS_GUEST_DS_BASE                                           0x0000680C
#define VMCS_GUEST_FS_BASE                                           0x0000680E
#define VMCS_GUEST_GS_BASE                                           0x00006810
#define VMCS_GUEST_LDTR_BASE                                         0x00006812
#define VMCS_GUESTR_BASE                                           0x00006814
#define VMCS_GUEST_GDTR_BASE                                         0x00006816
#define VMCS_GUEST_IDTR_BASE                                         0x00006818
#define VMCS_GUEST_DR7                                               0x0000681A
#define VMCS_GUEST_RSP                                               0x0000681C
#define VMCS_GUEST_RIP                                               0x0000681E
#define VMCS_GUEST_RFLAGS                                            0x00006820
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                          0x00006822
#define VMCS_GUEST_SYSENTER_ESP                                      0x00006824
#define VMCS_GUEST_SYSENTER_EIP                                      0x00006826
#define VMCS_GUEST_S_CET                                             0x00006828
#define VMCS_GUEST_SSP                                               0x0000682A
#define VMCS_GUEST_INTERRUPT_SSPABLE_ADDR                          0x0000682C
                                  /**
                                   * @}
                                   */

                                   /**
                                    * @defgroup vmcs_natural_width_host_state_fields \
                                    *           Natural-Width Host-State Fields
                                    * @{
                                    */
#define VMCS_HOST_CR0                                                0x00006C00
#define VMCS_HOST_CR3                                                0x00006C02
#define VMCS_HOST_CR4                                                0x00006C04
#define VMCS_HOST_FS_BASE                                            0x00006C06
#define VMCS_HOST_GS_BASE                                            0x00006C08
#define VMCS_HOSTR_BASE                                            0x00006C0A
#define VMCS_HOST_GDTR_BASE                                          0x00006C0C
#define VMCS_HOST_IDTR_BASE                                          0x00006C0E
#define VMCS_HOST_SYSENTER_ESP                                       0x00006C10
#define VMCS_HOST_SYSENTER_EIP                                       0x00006C12
#define VMCS_HOST_RSP                                                0x00006C14
#define VMCS_HOST_RIP                                                0x00006C16
#define VMCS_HOST_S_CET                                              0x00006C18
#define VMCS_HOST_SSP                                                0x00006C1A
#define VMCS_HOST_INTERRUPT_SSPABLE_ADDR                           0x00006C1C
                                    /**
                                     * @}
                                     */

                                     /**
                                      * @}
                                      */

                                      /**
                                       * @}
                                       */

typedef enum {
    external_interrupt = 0x00000000,
    non_maskable_interrupt = 0x00000002,
    hardware_exception = 0x00000003,
    software_interrupt = 0x00000004,
    privileged_software_exception = 0x00000005,
    software_exception = 0x00000006,
    other_event = 0x00000007,
} interruptionype;

typedef union {
    struct {
        UINT32 vector : 8;
        UINT32 interruptionype : 3;
        UINT32 deliver_error_code : 1;
        UINT32 reserved_1 : 19;
        UINT32 valid : 1;
    };

    UINT32 flags;
} vmentry_interrupt_info;

typedef union {
    struct {
        UINT32 vector : 8;
        UINT32 interruptionype : 3;
        UINT32 error_code_valid : 1;
        UINT32 nmi_unblocking : 1;
        UINT32 reserved_1 : 18;
        UINT32 valid : 1;
    };

    UINT32 flags;
} vmexit_interrupt_info;

/**
 * @}
 */

 /**
  * @defgroup apic \
  *           Advanced Programmable Interrupt Controller (APIC)
  * @{
  */
#define APIC_BASE                                                    0xFEE00000
#define APIC_ID                                                      0x00000020
#define APIC_VERSION                                                 0x00000030
#define APICPR                                                     0x00000080
#define APIC_APR                                                     0x00000090
#define APIC_PPR                                                     0x000000A0
#define APIC_EOI                                                     0x000000B0
#define APIC_REMOTE_READ                                             0x000000C0
#define APIC_LOGICAL_DESTINATION                                     0x000000D0
#define APIC_DESTINATION_FORMAT                                      0x000000E0
#define APIC_SIV                                                     0x000000F0
#define APIC_ISR_31_0                                                0x00000100
#define APIC_ISR_63_32                                               0x00000110
#define APIC_ISR_95_64                                               0x00000120
#define APIC_ISR_127_96                                              0x00000130
#define APIC_ISR_159_128                                             0x00000140
#define APIC_ISR_191_160                                             0x00000150
#define APIC_ISR_223_192                                             0x00000160
#define APIC_ISR_255_224                                             0x00000170
#define APICMR_31_0                                                0x00000180
#define APICMR_63_32                                               0x00000190
#define APICMR_95_64                                               0x000001A0
#define APICMR_127_96                                              0x000001B0
#define APICMR_159_128                                             0x000001C0
#define APICMR_191_160                                             0x000001D0
#define APICMR_223_192                                             0x000001E0
#define APICMR_255_224                                             0x000001F0
#define APIC_IRR_31_0                                                0x00000200
#define APIC_IRR_63_32                                               0x00000210
#define APIC_IRR_95_64                                               0x00000220
#define APIC_IRR_127_96                                              0x00000230
#define APIC_IRR_159_128                                             0x00000240
#define APIC_IRR_191_160                                             0x00000250
#define APIC_IRR_223_192                                             0x00000260
#define APIC_IRR_255_224                                             0x00000270
#define APIC_ERROR_STATUS                                            0x00000280
#define APIC_CMCI                                                    0x000002F0
#define APIC_ICR_0_31                                                0x00000300
#define APIC_ICR_32_63                                               0x00000310
#define APIC_LVTIMER                                               0x00000320
#define APIC_LVTHERMAL_SENSOR                                      0x00000330
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS                     0x00000340
#define APIC_LVT_LINT0                                               0x00000350
#define APIC_LVT_LINT1                                               0x00000360
#define APIC_LVT_ERROR                                               0x00000370
#define APIC_INITIAL_COUNT                                           0x00000380
#define APIC_CURRENT_COUNT                                           0x00000390
#define APIC_DIVIDE_CONFIGURATION                                    0x000003E0
  /**
   * @}
   */

typedef union {
    struct {
        UINT32 carry_flag : 1;
        UINT32 read_as_1 : 1;
        UINT32 parity_flag : 1;
        UINT32 reserved_1 : 1;
        UINT32 auxiliary_carry_flag : 1;
        UINT32 reserved_2 : 1;
        UINT32 zero_flag : 1;
        UINT32 sign_flag : 1;
        UINT32 trap_flag : 1;
        UINT32 interrupt_enable_flag : 1;
        UINT32 direction_flag : 1;
        UINT32 overflow_flag : 1;
        UINT32 io_privilege_level : 2;
        UINT32 nestedask_flag : 1;
        UINT32 reserved_3 : 1;
        UINT32 resume_flag : 1;
        UINT32 virtual_8086_mode_flag : 1;
        UINT32 alignment_check_flag : 1;
        UINT32 virtual_interrupt_flag : 1;
        UINT32 virtual_interrupt_pending_flag : 1;
        UINT32 identification_flag : 1;
    };

    UINT32 flags;
} efl;

typedef union {
    struct {
        UINT64 carry_flag : 1;
        UINT64 read_as_1 : 1;
        UINT64 parity_flag : 1;
        UINT64 reserved_1 : 1;
        UINT64 auxiliary_carry_flag : 1;
        UINT64 reserved_2 : 1;
        UINT64 zero_flag : 1;
        UINT64 sign_flag : 1;
        UINT64 trap_flag : 1;
        UINT64 interrupt_enable_flag : 1;
        UINT64 direction_flag : 1;
        UINT64 overflow_flag : 1;
        UINT64 io_privilege_level : 2;
        UINT64 nestedask_flag : 1;
        UINT64 reserved_3 : 1;
        UINT64 resume_flag : 1;
        UINT64 virtual_8086_mode_flag : 1;
        UINT64 alignment_check_flag : 1;
        UINT64 virtual_interrupt_flag : 1;
        UINT64 virtual_interrupt_pending_flag : 1;
        UINT64 identification_flag : 1;
    };

    UINT64 flags;
} rfl;

/**
 * @defgroup exceptions \
 *           Exceptions
 * @{
 */
typedef union {
    struct {
        UINT32 cpec : 15;
        UINT32 encl : 1;
    };

    UINT32 flags;
} control_protection_exception;

typedef enum {
    divide_error = 0x00000000,
    debug = 0x00000001,
    nmi = 0x00000002,
    breakpoint = 0x00000003,
    overflow = 0x00000004,
    bound_range_exceeded = 0x00000005,
    invalid_opcode = 0x00000006,
    device_not_available = 0x00000007,
    double_fault = 0x00000008,
    coprocessor_segment_overrun = 0x00000009,
    invalidss = 0x0000000A,
    segment_not_present = 0x0000000B,
    stack_segment_fault = 0x0000000C,
    general_protection = 0x0000000D,
    page_fault = 0x0000000E,
    x87_floating_point_error = 0x00000010,
    alignment_check = 0x00000011,
    machine_check = 0x00000012,
    simd_floating_point_error = 0x00000013,
    virtualization_exception = 0x00000014,
    control_protection = 0x00000015,
} exception_vector;

typedef union {
    struct {
        UINT32 external_event : 1;
        UINT32 descriptor_location : 1;
        UINT32 gdt_ldt : 1;
        UINT32 index : 13;
    };

    UINT32 flags;
} exception_error_code;

typedef union {
    struct {
        UINT32 present : 1;
        UINT32 write : 1;
        UINT32 user_mode_access : 1;
        UINT32 reserved_bit_violation : 1;
        UINT32 execute : 1;
        UINT32 protection_key_violation : 1;
        UINT32 shadow_stack : 1;
        UINT32 hlat : 1;
        UINT32 reserved_1 : 7;
        UINT32 sgx : 1;
    };

    UINT32 flags;
} page_fault_exception;

/**
 * @}
 */

 /**
  * @defgroup memoryype \
  *           Memory caching type
  * @{
  */
#define MEMORYYPE_UC                                               0x00000000
#define MEMORYYPE_WC                                               0x00000001
#define MEMORYYPE_WT                                               0x00000004
#define MEMORYYPE_WP                                               0x00000005
#define MEMORYYPE_WB                                               0x00000006
#define MEMORYYPE_UC_MINUS                                         0x00000007
#define MEMORYYPE_INVALID                                          0x000000FF
  /**
   * @}
   */

   /**
    * @defgroup vtd \
    *           VTD
    * @{
    */
typedef struct {
    union {
        struct {
            UINT64 present : 1;
            UINT64 reserved_1 : 11;
            UINT64 contextable_pointer : 52;
        };

        UINT64 flags;
    } lower64;

    union {
        struct {
            UINT64 reserved : 64;
        };

        UINT64 flags;
    } upper64;

} vtd_root_entry;

typedef struct {
    union {
        struct {
            UINT64 present : 1;
            UINT64 fault_processing_disable : 1;
            UINT64 translationype : 2;
            UINT64 reserved_1 : 8;
            UINT64 second_level_pageranslation_pointer : 52;
        };

        UINT64 flags;
    } lower64;

    union {
        struct {
            UINT64 address_width : 3;
            UINT64 ignored : 4;
            UINT64 reserved_1 : 1;
            UINT64 domain_identifier : 10;
        };

        UINT64 flags;
    } upper64;

} vtd_context_entry;

/**
 * @defgroup vtd_entry_count \
 *           Table entry counts
 * @{
 */
#define VTD_ROOT_ENTRY_COUNT                                         0x00000100
#define VTD_CONTEXT_ENTRY_COUNT                                      0x00000100
 /**
  * @}
  */

#define VTD_VERSION                                                  0x00000000
typedef union {
    struct {
        UINT32 minor : 4;
        UINT32 major : 4;
    };

    UINT32 flags;
} vtd_version_register;

#define VTD_CAPABILITY                                               0x00000008
typedef union {
    struct {
        UINT64 number_of_domains_supported : 3;
        UINT64 advanced_fault_logging : 1;
        UINT64 required_write_buffer_flushing : 1;
        UINT64 protected_low_memory_region : 1;
        UINT64 protected_high_memory_region : 1;
        UINT64 caching_mode : 1;
        UINT64 supported_adjusted_guest_address_widths : 5;
        UINT64 reserved_1 : 3;
        UINT64 maximum_guest_address_width : 6;
        UINT64 zero_length_read : 1;
        UINT64 deprecated : 1;
        UINT64 fault_recording_register_offset : 10;
        UINT64 second_level_large_page_support : 4;
        UINT64 reserved_2 : 1;
        UINT64 page_selective_invalidation : 1;
        UINT64 number_of_fault_recording_registers : 8;
        UINT64 maximum_address_mask_value : 6;
        UINT64 write_draining : 1;
        UINT64 read_draining : 1;
        UINT64 first_level_1gbyte_page_support : 1;
        UINT64 reserved_3 : 2;
        UINT64 posted_interrupts_support : 1;
        UINT64 first_level_5level_paging_support : 1;
        UINT64 reserved_4 : 1;
        UINT64 enhanced_set_interrupt_remapable_pointer_support : 1;
        UINT64 enhanced_set_rootable_pointer_support : 1;
    };

    UINT64 flags;
} vtd_capability_register;

#define VTD_EXTENDED_CAPABILITY                                      0x00000010
typedef union {
    struct {
        UINT64 page_walk_coherency : 1;
        UINT64 queued_invalidation_support : 1;
        UINT64 devicelb_support : 1;
        UINT64 interrupt_remapping_support : 1;
        UINT64 extended_interrupt_mode : 1;
        UINT64 deprecated1 : 1;
        UINT64 passhrough : 1;
        UINT64 snoop_control : 1;
        UINT64 iotlb_register_offset : 10;
        UINT64 reserved_1 : 2;
        UINT64 maximum_handle_mask_value : 4;
        UINT64 deprecated2 : 1;
        UINT64 memoryype_support : 1;
        UINT64 nestedranslation_support : 1;
        UINT64 reserved_2 : 1;
        UINT64 deprecated3 : 1;
        UINT64 page_request_support : 1;
        UINT64 execute_request_support : 1;
        UINT64 reserved_3 : 2;
        UINT64 no_write_flag_support : 1;
        UINT64 extended_accessed_flag_support : 1;
        UINT64 pasid_size_supported : 5;
        UINT64 process_address_space_id_support : 1;
        UINT64 devicelb_invalidationhrottle : 1;
        UINT64 page_request_drain_support : 1;
        UINT64 scalable_moderanslation_support : 1;
        UINT64 virtual_command_support : 1;
        UINT64 second_level_accessed_dirty_support : 1;
        UINT64 second_levelranslation_support : 1;
        UINT64 first_levelranslation_support : 1;
        UINT64 scalable_mode_page_walk_coherency : 1;
        UINT64 rid_pasid_support : 1;
        UINT64 reserved_4 : 2;
        UINT64 abort_dma_mode_support : 1;
        UINT64 rid_priv_support : 1;
    };

    UINT64 flags;
} vtd_extended_capability_register;

#define VTD_GLOBAL_COMMAND                                           0x00000018
typedef union {
    struct {
        UINT32 reserved_1 : 23;
        UINT32 compatibility_format_interrupt : 1;
        UINT32 set_interrupt_remapable_pointer : 1;
        UINT32 interrupt_remapping_enable : 1;
        UINT32 queued_invalidation_enable : 1;
        UINT32 write_buffer_flush : 1;
        UINT32 enable_advanced_fault_logging : 1;
        UINT32 set_fault_log : 1;
        UINT32 set_rootable_pointer : 1;
        UINT32 translation_enable : 1;
    };

    UINT32 flags;
} vtd_global_command_register;

#define VTD_GLOBAL_STATUS                                            0x0000001C
typedef union {
    struct {
        UINT32 reserved_1 : 23;
        UINT32 compatibility_format_interrupt_status : 1;
        UINT32 interrupt_remappingable_pointer_status : 1;
        UINT32 interrupt_remapping_enable_status : 1;
        UINT32 queued_invalidation_enable_status : 1;
        UINT32 write_buffer_flush_status : 1;
        UINT32 advanced_fault_logging_status : 1;
        UINT32 fault_log_status : 1;
        UINT32 rootable_pointer_status : 1;
        UINT32 translation_enable_status : 1;
    };

    UINT32 flags;
} vtd_global_status_register;

#define VTD_ROOTABLE_ADDRESS                                       0x00000020
typedef union {
    struct {
        UINT64 reserved_1 : 10;
        UINT64 translationable_mode : 2;
        UINT64 rootable_address : 52;
    };

    UINT64 flags;
} vtd_rootable_address_register;

#define VTD_CONTEXT_COMMAND                                          0x00000028
typedef union {
    struct {
        UINT64 domain_id : 16;
        UINT64 source_id : 16;
        UINT64 function_mask : 2;
        UINT64 reserved_1 : 25;
        UINT64 context_actual_invalidation_granularity : 2;
        UINT64 context_invalidation_request_granularity : 2;
        UINT64 invalidate_context_cache : 1;
    };

    UINT64 flags;
} vtd_context_command_register;

#define VTD_INVALIDATE_ADDRESS                                       0x00000000
typedef union {
    struct {
        UINT64 address_mask : 6;
        UINT64 invalidation_hint : 1;
        UINT64 reserved_1 : 5;
        UINT64 page_address : 52;
    };

    UINT64 flags;
} vtd_invalidate_address_register;

#define VTD_IOTLB_INVALIDATE                                         0x00000008
typedef union {
    struct {
        UINT64 reserved_1 : 32;
        UINT64 domain_id : 16;
        UINT64 drain_writes : 1;
        UINT64 drain_reads : 1;
        UINT64 reserved_2 : 7;
        UINT64 iotlb_actual_invalidation_granularity : 2;
        UINT64 reserved_3 : 1;
        UINT64 iotlb_invalidation_request_granularity : 2;
        UINT64 reserved_4 : 1;
        UINT64 invalidate_iotlb : 1;
    };

    UINT64 flags;
} vtd_iotlb_invalidate_register;

/**
 * @}
 */

typedef union {
    struct {
        UINT64 x87 : 1;
        UINT64 sse : 1;
        UINT64 avx : 1;
        UINT64 bndreg : 1;
        UINT64 bndcsr : 1;
        UINT64 opmask : 1;
        UINT64 zmm_hi256 : 1;
        UINT64 zmm_hi16 : 1;
        UINT64 reserved_1 : 1;
        UINT64 pkru : 1;
    };

    UINT64 flags;
} xcr0;

/**
 * @}
 */

#if defined(_MSC_EXTENSIONS)
#pragma warning(pop)
#endif

```

`uefi-boot/src/bootmgfw/bootmgfw.c`:

```c
#include "bootmgfw.h"

#include "../winload/winload.h"
#include "../memory_manager/memory_manager.h"
#include "../hooks/hooks.h"
#include "../image/image.h"
#include "../disk/disk.h"
#include "../structures/ntdef.h"

UINT64 uefi_boot_physical_base_address = 0;
UINT32 uefi_boot_image_size = 0;

#define d_bootmgfw_path L"\\efi\\microsoft\\boot\\bootmgfw.efi"
#define d_path_original_bootmgfw L"\\efi\\microsoft\\boot\\bootmgfw.original.efi"

hook_data_t bootmgfw_load_pe_image_hook_data = { 0 };

EFI_STATUS write_original_bootmgfw_back(EFI_FILE_INFO* original_bootmgfw_file_info, EFI_FILE_PROTOCOL* bootmgfw_file, void* buffer, UINT64 buffer_size)
{
    EFI_STATUS status = disk_write_file(bootmgfw_file, buffer, buffer_size);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    EFI_FILE_INFO* bootmgfw_file_info = NULL;
    UINT64 file_info_size = 0;

    status = disk_get_generic_file_info(&bootmgfw_file_info, &file_info_size, bootmgfw_file);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    bootmgfw_file_info->CreateTime = original_bootmgfw_file_info->CreateTime;
    bootmgfw_file_info->ModificationTime = original_bootmgfw_file_info->ModificationTime;

    status = disk_set_generic_file_info(bootmgfw_file, bootmgfw_file_info, file_info_size);

    mm_free_pool(bootmgfw_file_info);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    return EFI_SUCCESS;
}

EFI_STATUS bootmgfw_restore_original_file(EFI_HANDLE* device_handle_out)
{
    EFI_FILE_PROTOCOL* bootmgfw_original_file = NULL;

    EFI_STATUS status = disk_open_file(&bootmgfw_original_file, device_handle_out, d_path_original_bootmgfw, EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, EFI_FILE_SYSTEM);

    if (status == EFI_SUCCESS)
    {
        EFI_FILE_INFO* original_bootmgfw_file_info = NULL;
        UINT64 file_info_size = 0;

        status = disk_get_generic_file_info(&original_bootmgfw_file_info, &file_info_size, bootmgfw_original_file);

        if (status == EFI_SUCCESS)
        {
            UINT64 original_bootmgfw_buffer_size = original_bootmgfw_file_info->FileSize;
            void* original_bootmgfw_buffer = NULL;

            status = disk_load_file(bootmgfw_original_file, &original_bootmgfw_buffer, original_bootmgfw_buffer_size);

            if (status == EFI_SUCCESS)
            {
                EFI_FILE_PROTOCOL* bootmgfw_file = NULL;

                status = disk_open_file(&bootmgfw_file, device_handle_out, d_bootmgfw_path, EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, EFI_FILE_SYSTEM);

                if (status == EFI_SUCCESS)
                {
                    status = write_original_bootmgfw_back(original_bootmgfw_file_info, bootmgfw_file, original_bootmgfw_buffer, original_bootmgfw_buffer_size);

                    disk_close_file(bootmgfw_file);
                }

                mm_free_pool(original_bootmgfw_buffer);
            }

            mm_free_pool(original_bootmgfw_file_info);
        }

        disk_delete_file(bootmgfw_original_file);
    }

    return status;
}

UINT64 bootmgfw_load_pe_image_detour(bl_file_info_t* file_info, INT32 a2, UINT64* image_base, UINT32* image_size, UINT64* a5, UINT32* a6, UINT32* a7, UINT64 a8, UINT64 a9, unknown_param_t a10, unknown_param_t a11, unknown_param_t a12, unknown_param_t a13, unknown_param_t a14, unknown_param_t a15)
{
    hook_disable(&bootmgfw_load_pe_image_hook_data);

    boot_load_pe_image_t original_subroutine = (boot_load_pe_image_t)bootmgfw_load_pe_image_hook_data.hooked_subroutine_address;

    UINT64 return_value = original_subroutine(file_info, a2, image_base, image_size, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);

    if (StrStr(file_info->file_name, L"winload.efi") != NULL)
    {
        if (winload_place_hooks(*image_base, (UINT64)*image_size) == EFI_SUCCESS)
        {
            Print(L"success in winload hooks\n");
        }
        else
        {
            Print(L"error in winload hooks\n");
        }

        return return_value;
    }

    hook_enable(&bootmgfw_load_pe_image_hook_data);

    return return_value;
}

EFI_STATUS bootmgfw_place_load_pe_image_hook(EFI_LOADED_IMAGE* bootmgfw_image_info)
{
    CHAR8* code_ref_to_load_pe_image = NULL;

    // ImgpLoadPEImage
    EFI_STATUS status = scan_image(&code_ref_to_load_pe_image, bootmgfw_image_info->ImageBase, bootmgfw_image_info->ImageSize, d_boot_load_pe_image_pattern, d_boot_load_pe_image_mask);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    CHAR8* load_pe_image_subroutine = (code_ref_to_load_pe_image + 10) + *(UINT32*)(code_ref_to_load_pe_image + 6);

    status = hook_create(&bootmgfw_load_pe_image_hook_data, load_pe_image_subroutine, (void*)bootmgfw_load_pe_image_detour);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    return hook_enable(&bootmgfw_load_pe_image_hook_data);
}

EFI_STATUS bootmgfw_place_hooks(EFI_HANDLE bootmgfw_image_handle)
{
    EFI_LOADED_IMAGE* bootmgfw_image_info = NULL;

    EFI_STATUS status = get_image_info(&bootmgfw_image_info, bootmgfw_image_handle);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    return bootmgfw_place_load_pe_image_hook(bootmgfw_image_info);
}

EFI_STATUS parse_uefi_boot_image_info(EFI_HANDLE image_handle)
{
    EFI_LOADED_IMAGE* image_info = NULL;

    EFI_STATUS status = get_image_info(&image_info, image_handle);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    uefi_boot_physical_base_address = (UINT64)image_info->ImageBase;
    uefi_boot_image_size = (UINT32)image_info->ImageSize;

    return EFI_SUCCESS;
}

EFI_STATUS bootmgfw_run_original_image(EFI_HANDLE parent_image_handle, EFI_HANDLE device_handle)
{
    EFI_STATUS status = parse_uefi_boot_image_info(parent_image_handle);

    if (status == EFI_SUCCESS)
    {
        EFI_DEVICE_PATH* device_path = NULL;

		status = disk_get_device_path(&device_path, device_handle, d_bootmgfw_path);

        if (status == EFI_SUCCESS)
        {
            EFI_HANDLE loaded_image = NULL;

            status = load_image(&loaded_image, TRUE, parent_image_handle, device_path);

            if (status == EFI_SUCCESS)
            {
                status = bootmgfw_place_hooks(loaded_image);

                if (status == EFI_SUCCESS)
                {
                    status = start_image(loaded_image);
                }
                else
                {
                    unload_image(loaded_image);
                }
            }
            else
            {
                unload_image(loaded_image);
            }
        }
    }

    return status;
}
```

`uefi-boot/src/bootmgfw/bootmgfw.h`:

```h
#pragma once
#include <Library/UefiLib.h>

// this image's info - will be zeroed by the hyperv-attachment
extern UINT64 uefi_boot_physical_base_address;
extern UINT32 uefi_boot_image_size;

typedef UINT64 unknown_param_t;
typedef UINT64(*boot_load_pe_image_t)(void* file_info, INT32 a2, UINT64* image_base, UINT32* image_size, UINT64* a5, UINT32* a6, UINT32* a7, UINT64 a8, UINT64 a9, unknown_param_t a10, unknown_param_t a11, unknown_param_t a12, unknown_param_t a13, unknown_param_t a14, unknown_param_t a15);

#define d_boot_load_pe_image_pattern "\x48\x89\x44\x24\x00\xE8\x00\x00\x00\x00\x8B\xD8\xEB\x00\xBB\x00\x00\x00\x00\x48\x8B"
#define d_boot_load_pe_image_mask "xxxx?x????xxx?x????xx"

EFI_STATUS bootmgfw_restore_original_file(EFI_HANDLE* device_handle_out);
EFI_STATUS bootmgfw_run_original_image(EFI_HANDLE parent_image_handle, EFI_HANDLE device_handle);

```

`uefi-boot/src/disk/disk.c`:

```c
#include "disk.h"
#include "../memory_manager/memory_manager.h"

#include <Library/UefiBootServicesTableLib.h>
#include <Library/DevicePathLib.h>

EFI_STATUS disk_get_all_file_system_handles(EFI_HANDLE** handle_list_out, UINT64* handle_count_out)
{
    EFI_GUID simple_fs_protocol_guid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;

    return gBS->LocateHandleBuffer(ByProtocol, &simple_fs_protocol_guid, NULL, handle_count_out, handle_list_out);
}

EFI_STATUS disk_open_file_system(EFI_SIMPLE_FILE_SYSTEM_PROTOCOL** file_system_out, EFI_HANDLE handle)
{
    EFI_GUID simple_fs_protocol_guid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
    
    return gBS->HandleProtocol(handle, &simple_fs_protocol_guid, file_system_out);
}

EFI_STATUS disk_open_volume(EFI_FILE_PROTOCOL** volume_handle_out, EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* file_system)
{
    return file_system->OpenVolume(file_system, volume_handle_out);
}

EFI_STATUS disk_open_file_on_volume(EFI_FILE_PROTOCOL** file_handle_out, EFI_FILE_PROTOCOL* volume, CHAR16* file_path, UINT64 open_mode, UINT64 attributes)
{
    return volume->Open(volume, file_handle_out, file_path, open_mode, attributes);
}

EFI_STATUS disk_open_file(EFI_FILE_PROTOCOL** file_handle_out, EFI_HANDLE* file_system_handle_out_opt, CHAR16* file_path, UINT64 open_mode, UINT64 attributes)
{
    EFI_HANDLE* handle_list = NULL;
    UINT64 handle_count = 0;

    EFI_STATUS status = disk_get_all_file_system_handles(&handle_list, &handle_count);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    for (UINT64 i = 0; i < handle_count; i++)
    {
        EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* current_file_system = NULL;

        status = disk_open_file_system(&current_file_system, handle_list[i]);

        if (status != EFI_SUCCESS)
        {
            continue;
        }

        EFI_FILE_PROTOCOL* current_volume = NULL;

        status = disk_open_volume(&current_volume, current_file_system);

        if (status != EFI_SUCCESS)
        {
            continue;
        }

        status = disk_open_file_on_volume(file_handle_out, current_volume, file_path, open_mode, attributes);

        if (status == EFI_SUCCESS)
        {
            if (file_system_handle_out_opt != NULL)
            {
                *file_system_handle_out_opt = handle_list[i];
            }

            mm_free_pool(handle_list);

            return EFI_SUCCESS;
        }
    }

    mm_free_pool(handle_list);

    return EFI_NOT_FOUND;
}

EFI_STATUS disk_close_file(EFI_FILE_PROTOCOL* file_handle)
{
    return file_handle->Close(file_handle);
}

EFI_STATUS disk_read_file(EFI_FILE_PROTOCOL* file_handle, void* buffer, UINT64 size)
{
    return file_handle->Read(file_handle, &size, buffer);
}

EFI_STATUS disk_write_file(EFI_FILE_PROTOCOL* file_handle, void* buffer, UINT64 size)
{
    return file_handle->Write(file_handle, &size, buffer);
}

EFI_STATUS disk_delete_file(EFI_FILE_PROTOCOL* file_handle)
{
    return file_handle->Delete(file_handle);
}

EFI_STATUS disk_load_file(EFI_FILE_PROTOCOL* file_handle, void** buffer, UINT64 buffer_size)
{
    EFI_STATUS status = mm_allocate_pool(buffer, buffer_size, EfiBootServicesData);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    status = disk_read_file(file_handle, *buffer, buffer_size);

    if (status != EFI_SUCCESS)
    {
        mm_free_pool(*buffer);

        return status;
    }

    return EFI_SUCCESS;
}

EFI_STATUS disk_get_specified_type_file_info(void** buffer_out, UINT64* buffer_size_out, EFI_FILE_PROTOCOL* file_handle, EFI_GUID* information_type)
{
    EFI_STATUS status = file_handle->GetInfo(file_handle, information_type, buffer_size_out, NULL);

    if (status != EFI_BUFFER_TOO_SMALL)
    {
        return EFI_BAD_BUFFER_SIZE;
    }

    status = mm_allocate_pool(buffer_out, *buffer_size_out, EfiBootServicesData);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    status = file_handle->GetInfo(file_handle, information_type, buffer_size_out, *buffer_out);

    return status;
}

EFI_STATUS disk_get_generic_file_info(EFI_FILE_INFO** file_info_out, UINT64* file_info_size_out, EFI_FILE_PROTOCOL* file_handle)
{
    EFI_GUID information_type = EFI_FILE_INFO_ID;

    return disk_get_specified_type_file_info(file_info_out, file_info_size_out, file_handle, &information_type);
}

EFI_STATUS disk_set_specified_type_file_info(EFI_FILE_PROTOCOL* file_handle, EFI_GUID* information_type, void* buffer, UINT64 buffer_size)
{
    return file_handle->SetInfo(file_handle, information_type, buffer_size, buffer);
}

EFI_STATUS disk_set_generic_file_info(EFI_FILE_PROTOCOL* file_handle, EFI_FILE_INFO* file_info, UINT64 file_info_size)
{
    EFI_GUID information_type = EFI_FILE_INFO_ID;

    return disk_set_specified_type_file_info(file_handle, &information_type, file_info, file_info_size);
}

EFI_STATUS disk_get_device_path(EFI_DEVICE_PATH** device_path_out, EFI_HANDLE device_handle, CHAR16* file_path)
{
    *device_path_out = FileDevicePath(device_handle, file_path);

    return (*device_path_out != NULL) ? EFI_SUCCESS : EFI_OUT_OF_RESOURCES;
}

```

`uefi-boot/src/disk/disk.h`:

```h
#pragma once
#include <Library/ShellLib.h>

EFI_STATUS disk_get_all_file_system_handles(EFI_HANDLE** handle_list_out, UINT64* handle_count_out);
EFI_STATUS disk_open_file_system(EFI_SIMPLE_FILE_SYSTEM_PROTOCOL** file_system_out, EFI_HANDLE handle);
EFI_STATUS disk_open_volume(EFI_FILE_PROTOCOL** volume_handle_out, EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* file_system);
EFI_STATUS disk_open_file_on_volume(EFI_FILE_PROTOCOL** file_handle_out, EFI_FILE_PROTOCOL* volume, CHAR16* file_path, UINT64 open_mode, UINT64 attributes);
EFI_STATUS disk_open_file(EFI_FILE_PROTOCOL** file_handle_out, EFI_HANDLE* device_handle_out_opt, CHAR16* file_path, UINT64 open_mode, UINT64 attributes);
EFI_STATUS disk_close_file(EFI_FILE_PROTOCOL* file_handle);
EFI_STATUS disk_read_file(EFI_FILE_PROTOCOL* file_handle, void* buffer, UINT64 size);
EFI_STATUS disk_write_file(EFI_FILE_PROTOCOL* file_handle, void* buffer, UINT64 size);
EFI_STATUS disk_delete_file(EFI_FILE_PROTOCOL* file_handle);
EFI_STATUS disk_load_file(EFI_FILE_PROTOCOL* file_handle, void** buffer, UINT64 buffer_size);
EFI_STATUS disk_get_specified_type_file_info(void** buffer_out, UINT64* buffer_size_out, EFI_FILE_PROTOCOL* file_handle, EFI_GUID* information_type);
EFI_STATUS disk_get_generic_file_info(EFI_FILE_INFO** file_info_out, UINT64* file_info_size_out, EFI_FILE_PROTOCOL* file_handle);
EFI_STATUS disk_set_specified_type_file_info(EFI_FILE_PROTOCOL* file_handle, EFI_GUID* information_type, void* buffer, UINT64 buffer_size);
EFI_STATUS disk_set_generic_file_info(EFI_FILE_PROTOCOL* file_handle, EFI_FILE_INFO* file_info, UINT64 file_info_size);
EFI_STATUS disk_get_device_path(EFI_DEVICE_PATH** device_path_out, EFI_HANDLE device_handle, CHAR16* file_path);

```

`uefi-boot/src/hooks/hooks.c`:

```c
#include "hooks.h"
#include "../memory_manager/memory_manager.h"

EFI_STATUS hook_create(hook_data_t* hook_data_out, void* subroutine_to_hook, void* subroutine_to_jmp_to)
{
	if (hook_data_out == NULL || subroutine_to_hook == NULL || subroutine_to_jmp_to == NULL)
	{
		return EFI_INVALID_PARAMETER;
	}

	UINT8 hook_bytes[14] = {
		0x68, 0x21, 0x43, 0x65, 0x87, // push   0xffffffff87654321
		0xC7, 0x44, 0x24, 0x04, 0x78, 0x56, 0x34, 0x12, // mov    DWORD PTR [rsp+0x4],0x12345678
		0xC3 // ret
	};

	parted_address_t parted_subroutine_to_jmp_to = { .value = (UINT64)subroutine_to_jmp_to };

	*(UINT32*)(&hook_bytes[1]) = parted_subroutine_to_jmp_to.u.low_part;
	*(UINT32*)(&hook_bytes[9]) = parted_subroutine_to_jmp_to.u.high_part;

	mm_copy_memory(hook_data_out->original_bytes, subroutine_to_hook, sizeof(hook_bytes));
	mm_copy_memory(hook_data_out->hook_bytes, hook_bytes, sizeof(hook_bytes));

	hook_data_out->hooked_subroutine_address = subroutine_to_hook;

	return EFI_SUCCESS;
}

EFI_STATUS hook_enable(hook_data_t* hook_data)
{
	if (hook_data == NULL)
	{
		return EFI_INVALID_PARAMETER;
	}

	mm_copy_memory(hook_data->hooked_subroutine_address, hook_data->hook_bytes, 14);

	return EFI_SUCCESS;
}

EFI_STATUS hook_disable(hook_data_t* hook_data)
{
	if (hook_data == NULL)
	{
		return EFI_INVALID_PARAMETER;
	}

	mm_copy_memory(hook_data->hooked_subroutine_address, hook_data->original_bytes, 14);

	return EFI_SUCCESS;
}

```

`uefi-boot/src/hooks/hooks.h`:

```h
#pragma once
#include <Library/UefiLib.h>

typedef union _parted_address_t
{
	struct
	{
		UINT32 low_part;
		UINT32 high_part;
	} u;

	UINT64 value;
} parted_address_t;

typedef struct _hook_data_t
{
	VOID* hooked_subroutine_address;
	UINT8 hook_bytes[14];
	UINT8 original_bytes[14];
} hook_data_t;

EFI_STATUS hook_create(hook_data_t* hook_data_out, void* subroutine_to_hook, void* subroutine_to_jmp_to);
EFI_STATUS hook_enable(hook_data_t* hook_data);
EFI_STATUS hook_disable(hook_data_t* hook_data);

```

`uefi-boot/src/hvloader/hvloader.c`:

```c
#include "hvloader.h"

#include "../bootmgfw/bootmgfw.h"
#include "../hooks/hooks.h"
#include "../image/image.h"
#include "../structures/virtual_address.h"
#include "../memory_manager/memory_manager.h"
#include "../hyperv_attachment/hyperv_attachment.h"
#include "../winload/winload.h"

hook_data_t hvloader_launch_hv_hook_data = { 0 };
hook_data_t hv_vmexit_hook_data = { 0 };

typedef void(*hvloader_launch_hv_t)(cr3 a1, virtual_address_t a2, UINT64 a3, UINT64 a4);

void set_up_identity_map(pml4e_64* pml4e)
{
    pdpte_1gb_64* pdpt = (pdpte_1gb_64*)pdpt_physical_allocation;

    pml4e->flags = 0;
    pml4e->page_frame_number = pdpt_physical_allocation >> 12;
    pml4e->present = 1;
    pml4e->write = 1;

    for (UINT64 i = 0; i < 512; i++)
    {
        pdpte_1gb_64* pdpte = &pdpt[i];

        pdpte->flags = 0;
        pdpte->page_frame_number = i;
        pdpte->present = 1;
        pdpte->write = 1;
        pdpte->large_page = 1;
    }
}

void load_identity_map_into_hyperv_cr3(cr3 identity_map_cr3, cr3 hyperv_cr3, pml4e_64 identity_map_pml4e, pml4e_64* initial_hyperv_pml4e)
{
    AsmWriteCr3(identity_map_cr3.flags);

    pml4e_64* hyperv_pml4 = (pml4e_64*)(hyperv_cr3.address_of_page_directory << 12);

    *initial_hyperv_pml4e = hyperv_pml4[0];

    hyperv_pml4[0] = identity_map_pml4e;
    hyperv_pml4[255] = identity_map_pml4e;
}

void restore_initial_hyperv_pml4e(cr3 identity_map_cr3, cr3 hyperv_cr3, pml4e_64 initial_hyperv_pml4e)
{
    AsmWriteCr3(identity_map_cr3.flags);

    pml4e_64* hyperv_pml4 = (pml4e_64*)(hyperv_cr3.address_of_page_directory << 12);

    hyperv_pml4[0] = initial_hyperv_pml4e;
}

// must have identity map in 0th pml4e
UINT8 is_page_executable(cr3 cr3_to_search, virtual_address_t page)
{
    pml4e_64* pml4 = (pml4e_64*)(cr3_to_search.address_of_page_directory << 12);
    pml4e_64 pml4e = pml4[page.pml4_idx];

    if (pml4e.present == 0 || pml4e.execute_disable == 1)
    {
        return 0;
    }

    pdpte_64* pdpt = (pdpte_64*)(pml4e.page_frame_number << 12);
    pdpte_64 pdpte = pdpt[page.pdpt_idx];

    if (pdpte.present == 0 || pdpte.execute_disable == 1)
    {
        return 0;
    }

    if (pdpte.large_page == 1)
    {
        return 1;
    }

    pde_64* pd = (pde_64*)(pdpte.page_frame_number << 12);
    pde_64 pde = pd[page.pd_idx];

    if (pde.present == 0 || pde.execute_disable == 1)
    {
        return 0;
    }

    if (pde.large_page == 1)
    {
        return 1;
    }

    pte_64* pt = (pte_64*)(pde.page_frame_number << 12);
    pte_64 pte = pt[page.pt_idx];

    if (pte.present == 0 || pte.execute_disable == 1)
    {
        return 0;
    }

    return 1;
}

UINT64 find_hyperv_text_base(cr3 hyperv_cr3, virtual_address_t entry_point)
{
    virtual_address_t text_address = entry_point;

    while (is_page_executable(hyperv_cr3, text_address) == 1)
    {
        text_address.address -= 0x1000;
    }

    return text_address.address + 0x1000;
}

UINT64 find_hyperv_text_end(cr3 hyperv_cr3, virtual_address_t entry_point)
{
    virtual_address_t text_address = entry_point;

    while (is_page_executable(hyperv_cr3, text_address) == 1)
    {
        text_address.address += 0x1000;
    }

    return text_address.address - 0x1000;
}

void set_up_hyperv_hooks(cr3 hyperv_cr3, virtual_address_t entry_point)
{
    AsmWriteCr3(hyperv_cr3.flags);

    UINT64 hyperv_text_base = find_hyperv_text_base(hyperv_cr3, entry_point);
    UINT64 hyperv_text_end = find_hyperv_text_end(hyperv_cr3, entry_point);
    UINT64 hyperv_text_size = hyperv_text_end - hyperv_text_base;

    if (hyperv_text_base != 0)
    {
        UINT8* hyperv_attachment_entry_point = NULL;

        EFI_STATUS status = hyperv_attachment_get_relocated_entry_point(&hyperv_attachment_entry_point);

        if (status == EFI_SUCCESS)
        {
            CHAR8* code_ref_to_vmexit_handler = NULL;

            UINT8 is_intel = 0;

            // search for AMD's vmexit handler
            status = scan_image(&code_ref_to_vmexit_handler, (CHAR8*)hyperv_text_base, hyperv_text_size, "\xE8\x00\x00\x00\x00\x48\x89\x04\x24\xE9", "x????xxxxx");

            if (status == EFI_NOT_FOUND)
            {
                // search for Intel's vmexit handler
                status = scan_image(&code_ref_to_vmexit_handler, (CHAR8*)hyperv_text_base, hyperv_text_size, "\xE8\x00\x00\x00\x00\xE9\x00\x00\x00\x00\x74", "x????x????x");

                is_intel = 1;
            }

            if (status == EFI_SUCCESS)
            {
                INT32 original_vmexit_handler_rva = *(INT32*)(code_ref_to_vmexit_handler + 1);
                CHAR8* original_vmexit_handler = (code_ref_to_vmexit_handler + 5) + original_vmexit_handler_rva;

                UINT8* hyperv_attachment_vmexit_handler_detour = NULL;

                CHAR8* get_vmcb_gadget = NULL;

                if (is_intel == 0)
                {
                    status = scan_image(&get_vmcb_gadget, (CHAR8*)hyperv_text_base, hyperv_text_size, "\x65\x48\x8B\x04\x25\x00\x00\x00\x00\x48\x8B\x88\x00\x00\x00\x00\x48\x8B\x81\x00\x00\x00\x00\x48\x8B", "xxxxx????xxx????xxx????xx");

                    if (status != EFI_SUCCESS)
                    {
                        return;
                    }
                }

                UINT64 heap_physical_base = hyperv_attachment_heap_allocation_base;
                UINT64 heap_physical_usable_base = hyperv_attachment_heap_allocation_usable_base;
                UINT64 heap_total_size = hyperv_attachment_heap_allocation_size;

                hyperv_attachment_invoke_entry_point(&hyperv_attachment_vmexit_handler_detour, hyperv_attachment_entry_point, original_vmexit_handler, heap_physical_base, heap_physical_usable_base, heap_total_size, uefi_boot_physical_base_address, uefi_boot_image_size, get_vmcb_gadget);

                CHAR8* code_cave = NULL;

                status = scan_image(&code_cave, (CHAR8*)hyperv_text_base, hyperv_text_size, "\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC", "xxxxxxxxxxxxxxxx");

                if (status == EFI_SUCCESS)
                {
                    status = hook_create(&hv_vmexit_hook_data, code_cave, hyperv_attachment_vmexit_handler_detour);

                    if (status == EFI_SUCCESS)
                    {
                        hook_enable(&hv_vmexit_hook_data);

                        UINT32 new_call_rva = (UINT32)(code_cave - (code_ref_to_vmexit_handler + 5));

                        mm_copy_memory(code_ref_to_vmexit_handler + 1, (UINT8*)&new_call_rva, sizeof(new_call_rva));
                    }
                }
            }
        }
    }
}

void hvloader_launch_hv_detour(cr3 hyperv_cr3, virtual_address_t hyperv_entry_point, UINT64 jmp_gadget, UINT64 kernel_cr3)
{
    hook_disable(&hvloader_launch_hv_hook_data);

    pml4e_64* virtual_pml4 = (pml4e_64*)pml4_physical_allocation;

    set_up_identity_map(&virtual_pml4[0]);

    UINT64 original_cr3 = AsmReadCr3();

    cr3 identity_map_cr3 = { .address_of_page_directory = pml4_physical_allocation >> 12 };

    pml4e_64 initial_hyperv_pml4e = { 0 };

    load_identity_map_into_hyperv_cr3(identity_map_cr3, hyperv_cr3, virtual_pml4[0], &initial_hyperv_pml4e);

    set_up_hyperv_hooks(hyperv_cr3, hyperv_entry_point);

    restore_initial_hyperv_pml4e(identity_map_cr3, hyperv_cr3, initial_hyperv_pml4e);

    AsmWriteCr3(original_cr3);

    hvloader_launch_hv_t original_subroutine = (hvloader_launch_hv_t)hvloader_launch_hv_hook_data.hooked_subroutine_address;

    original_subroutine(hyperv_cr3, hyperv_entry_point, jmp_gadget, kernel_cr3);
}

EFI_STATUS hvloader_place_hooks(UINT64 image_base, UINT64 image_size)
{
    CHAR8* hvloader_launch_hv = NULL;

    EFI_STATUS status = scan_image(&hvloader_launch_hv, (CHAR8*)image_base, image_size, "\x48\x53\x55\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x83\xEC\x00\x48\x89\x25", "xxxxxxxxxxxxxxxx?xxx");

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    status = hook_create(&hvloader_launch_hv_hook_data, hvloader_launch_hv, (void*)hvloader_launch_hv_detour);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    return hook_enable(&hvloader_launch_hv_hook_data);
}

```

`uefi-boot/src/hvloader/hvloader.h`:

```h
#pragma once
#include <Library/UefiLib.h>

EFI_STATUS hvloader_place_hooks(UINT64 image_base, UINT64 image_size);

```

`uefi-boot/src/hyperv_attachment/hyperv_attachment.c`:

```c
#include "hyperv_attachment.h"
#include "../memory_manager/memory_manager.h"
#include "../structures/relocation_entry.h"
#include "../image/image.h"
#include "../winload/winload.h"
#include "../disk/disk.h"

UINT8* hyperv_attachment_file_buffer = NULL;
UINT64 hyperv_attachment_file_size = 0;
UINT8* hyperv_attachment_physical_base = NULL;

UINT64 hyperv_attachment_heap_allocation_base = 0;
UINT64 hyperv_attachment_heap_allocation_usable_base = 0;
UINT64 hyperv_attachment_heap_allocation_size = 0;
UINT32 hyperv_attachment_heap_4kb_pages_reserved = 1024;

#define d_hyperv_attachment_path L"\\efi\\microsoft\\boot\\hyperv-attachment.dll"

EFI_STATUS hyperv_attachment_set_up_heap(UINT64 hyperv_attachment_pages_needed)
{
    UINT64 total_pages_needed = 2 + hyperv_attachment_pages_needed + hyperv_attachment_heap_4kb_pages_reserved;

    EFI_STATUS status = mm_allocate_pages((void**)&hyperv_attachment_heap_allocation_base, total_pages_needed, EfiRuntimeServicesData);

    if (status == EFI_SUCCESS)
    {
        hyperv_attachment_heap_allocation_usable_base = hyperv_attachment_heap_allocation_base;
        hyperv_attachment_heap_allocation_size = total_pages_needed * 0x1000;

        mm_fill_memory((UINT8*)hyperv_attachment_heap_allocation_base, hyperv_attachment_heap_allocation_size, 0);
    }

    return status;
}

EFI_STATUS hyperv_attachment_set_up()
{
    EFI_STATUS status = hyperv_attachment_load_and_delete_from_disk(&hyperv_attachment_file_buffer);

    if (status == EFI_SUCCESS)
    {
        UINT64 hyperv_attachment_pages_needed = hyperv_attachment_get_pages_needed();

        status = hyperv_attachment_set_up_heap(hyperv_attachment_pages_needed);

        if (status == EFI_SUCCESS)
        {
            status = hyperv_attachment_allocate_and_copy(hyperv_attachment_pages_needed);

            if (status == EFI_SUCCESS)
            {
                status = hyperv_attachment_do_heap_allocation((void**)&pml4_physical_allocation, 1);

                if (status == EFI_SUCCESS)
                {
                    status = hyperv_attachment_do_heap_allocation((void**)&pdpt_physical_allocation, 1);
                }
            }
        }
    }

    return status;
}

UINT64 hyperv_attachment_get_pages_needed()
{
    EFI_IMAGE_NT_HEADERS64* nt_headers = image_get_nt_headers(hyperv_attachment_file_buffer);

    UINT8 is_page_aligned = (nt_headers->OptionalHeader.SizeOfImage % 0x1000) == 0;

    UINT64 pages_needed = (nt_headers->OptionalHeader.SizeOfImage & ~0xFFF) / 0x1000;

    if (is_page_aligned == 0)
    {
        pages_needed += 1;
    }

    return pages_needed;
}

EFI_STATUS hyperv_attachment_do_heap_allocation(void** allocation_base_out, UINT64 pages_needed)
{
    if (allocation_base_out == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    if (hyperv_attachment_heap_allocation_usable_base == 0)
    {
        return EFI_OUT_OF_RESOURCES;
    }

    UINT64 next_usable_base = hyperv_attachment_heap_allocation_usable_base + (pages_needed * 0x1000);
    UINT64 heap_end = hyperv_attachment_heap_allocation_base + hyperv_attachment_heap_allocation_size;

    if (heap_end < next_usable_base)
    {
        return EFI_OUT_OF_RESOURCES;
    }

    *allocation_base_out = (void*)hyperv_attachment_heap_allocation_usable_base;

    hyperv_attachment_heap_allocation_usable_base = next_usable_base;

    return EFI_SUCCESS;
}

void free_hyperv_attachment_file_buffer()
{
    mm_fill_memory(hyperv_attachment_file_buffer, hyperv_attachment_file_size, 0);
    mm_free_pool(hyperv_attachment_file_buffer);
}

EFI_STATUS hyperv_attachment_allocate_and_copy(UINT64 pages_needed)
{
    EFI_STATUS status = hyperv_attachment_do_heap_allocation((void**)&hyperv_attachment_physical_base, pages_needed);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    EFI_IMAGE_NT_HEADERS64* nt_headers = image_get_nt_headers(hyperv_attachment_file_buffer);

    mm_copy_memory(hyperv_attachment_physical_base, hyperv_attachment_file_buffer, nt_headers->OptionalHeader.SizeOfHeaders);

    EFI_IMAGE_SECTION_HEADER* current_section = (EFI_IMAGE_SECTION_HEADER*)((UINT8*)&nt_headers->OptionalHeader + nt_headers->FileHeader.SizeOfOptionalHeader);

    for (UINT32 i = 0; i < nt_headers->FileHeader.NumberOfSections; i++, current_section++)
    {
        mm_copy_memory(hyperv_attachment_physical_base + current_section->VirtualAddress, hyperv_attachment_file_buffer + current_section->PointerToRawData, current_section->SizeOfRawData);
    }

    free_hyperv_attachment_file_buffer();

    return EFI_SUCCESS;
}

EFI_STATUS hyperv_attachment_remap_image(UINT8** hyperv_attachment_virtual_base_out)
{
    if (hyperv_attachment_virtual_base_out == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    const UINT64 physical_memory_access_base = 255ull << 39;

    *hyperv_attachment_virtual_base_out = physical_memory_access_base + hyperv_attachment_physical_base;

    return EFI_SUCCESS;
}

EFI_STATUS hyperv_attachment_apply_relocation(UINT8* hyperv_attachment_virtual_base)
{
    EFI_IMAGE_NT_HEADERS64* nt_headers = image_get_nt_headers(hyperv_attachment_virtual_base);

    EFI_IMAGE_DATA_DIRECTORY* base_relocation_directory = &nt_headers->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC];

    if (base_relocation_directory->VirtualAddress != 0)
    {
        UINT64 relocation_to_apply = (UINT64)hyperv_attachment_virtual_base - nt_headers->OptionalHeader.ImageBase;

        EFI_IMAGE_BASE_RELOCATION* base_relocation = (EFI_IMAGE_BASE_RELOCATION*)(hyperv_attachment_virtual_base + base_relocation_directory->VirtualAddress);

        while (base_relocation->VirtualAddress)
        {
            relocation_entry_t* current_relocation_entry = (relocation_entry_t*)(base_relocation + 1);
            UINT32 entry_count = (base_relocation->SizeOfBlock - sizeof(EFI_IMAGE_BASE_RELOCATION)) / sizeof(UINT16);

            for (UINT32 i = 0; i < entry_count; i++, current_relocation_entry++)
            {
                if (current_relocation_entry->type == EFI_IMAGE_REL_BASED_DIR64)
                {
                    *(UINT64*)(hyperv_attachment_virtual_base + base_relocation->VirtualAddress + current_relocation_entry->offset) += relocation_to_apply;
                }
            }

            base_relocation = (EFI_IMAGE_BASE_RELOCATION*)((UINT8*)base_relocation + base_relocation->SizeOfBlock);
        }
    }

    return EFI_SUCCESS;
}

EFI_STATUS hyperv_attachment_get_entry_point(UINT8** entry_point_out, UINT8* hyperv_attachment_virtual_base)
{
    if (entry_point_out == NULL || hyperv_attachment_virtual_base == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    EFI_IMAGE_NT_HEADERS64* nt_headers = image_get_nt_headers(hyperv_attachment_virtual_base);

    *entry_point_out = hyperv_attachment_virtual_base + nt_headers->OptionalHeader.AddressOfEntryPoint;

    return EFI_SUCCESS;
}

EFI_STATUS hyperv_attachment_get_relocated_entry_point(UINT8** hyperv_attachment_entry_point)
{
    UINT8* hyperv_attachment_virtual_base = NULL;

    EFI_STATUS status = hyperv_attachment_remap_image(&hyperv_attachment_virtual_base);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    status = hyperv_attachment_apply_relocation(hyperv_attachment_virtual_base);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    return hyperv_attachment_get_entry_point(hyperv_attachment_entry_point, hyperv_attachment_virtual_base);
}

typedef void(*hyperv_attachment_entry_point_t)(UINT8** hyperv_attachment_vmexit_handler_detour_out, CHAR8* original_vmexit_handler, UINT64 heap_physical_base, UINT64 heap_physical_usable_base, UINT64 heap_total_size, UINT64 uefi_boot_physical_base_address, UINT32 uefi_boot_image_size, CHAR8* get_vmcb_gadget);

void hyperv_attachment_invoke_entry_point(UINT8** hyperv_attachment_vmexit_handler_detour_out, UINT8* hyperv_attachment_entry_point, CHAR8* original_vmexit_handler, UINT64 heap_physical_base, UINT64 heap_physical_usable_base, UINT64 heap_total_size, UINT64 uefi_boot_physical_base_address, UINT32 uefi_boot_image_size, CHAR8* get_vmcb_gadget)
{
    ((hyperv_attachment_entry_point_t)hyperv_attachment_entry_point)(hyperv_attachment_vmexit_handler_detour_out, original_vmexit_handler, heap_physical_base, heap_physical_usable_base, heap_total_size, uefi_boot_physical_base_address, uefi_boot_image_size, get_vmcb_gadget);
}

EFI_STATUS hyperv_attachment_load_and_delete_from_disk(UINT8** file_buffer_out)
{
    if (file_buffer_out == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    EFI_FILE_PROTOCOL* file_handle = NULL;

    EFI_HANDLE device_handle = NULL;

    EFI_STATUS status = disk_open_file(&file_handle, &device_handle, d_hyperv_attachment_path, EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, EFI_FILE_SYSTEM);

    if (status == EFI_SUCCESS)
    {
        EFI_FILE_INFO* file_info = NULL;
        UINT64 file_info_size = 0;

        status = disk_get_generic_file_info(&file_info, &file_info_size, file_handle);

        if (status == EFI_SUCCESS)
        {
            hyperv_attachment_file_size = file_info->FileSize;

            mm_free_pool(file_info);

            if (hyperv_attachment_file_size < sizeof(EFI_IMAGE_DOS_HEADER))
            {
                status = EFI_NOT_FOUND;
            }
            else
            {
                status = disk_load_file(file_handle, (void**)file_buffer_out, hyperv_attachment_file_size);

                if (status == EFI_SUCCESS)
                {
                    EFI_IMAGE_DOS_HEADER* dos_header = (EFI_IMAGE_DOS_HEADER*)(*file_buffer_out);

                    if (dos_header->e_magic != 0x5a4d)
                    {
                        mm_free_pool(*file_buffer_out);

                        status = EFI_NOT_FOUND;
                    }
                }
            }
        }

        disk_delete_file(file_handle);
    }

	return status;
}

```

`uefi-boot/src/hyperv_attachment/hyperv_attachment.h`:

```h
#pragma once
#include <Library/UefiLib.h>
#include <IndustryStandard/PeImage.h>

extern UINT8* hyperv_attachment_file_buffer;

extern UINT64 hyperv_attachment_heap_allocation_base;
extern UINT64 hyperv_attachment_heap_allocation_usable_base;
extern UINT64 hyperv_attachment_heap_allocation_size;
extern UINT32 hyperv_attachment_heap_4kb_pages_reserved;

EFI_STATUS hyperv_attachment_set_up();
UINT64 hyperv_attachment_get_pages_needed();
EFI_STATUS hyperv_attachment_do_heap_allocation(void** allocation_base_out, UINT64 pages_needed);
EFI_STATUS hyperv_attachment_allocate_and_copy(UINT64 pages_needed);
EFI_STATUS hyperv_attachment_get_relocated_entry_point(UINT8** hyperv_attachment_entry_point);
void hyperv_attachment_invoke_entry_point(UINT8** hyperv_attachment_vmexit_handler_detour_out, UINT8* hyperv_attachment_entry_point, CHAR8* original_vmexit_handler, UINT64 heap_physical_base, UINT64 heap_physical_usable_base, UINT64 heap_total_size, UINT64 uefi_boot_physical_base_address, UINT32 uefi_boot_image_size, CHAR8* get_vmcb_gadget);
EFI_STATUS hyperv_attachment_load_and_delete_from_disk(UINT8** file_buffer_out);


```

`uefi-boot/src/image/image.c`:

```c
#include "image.h"
#include <Library/UefiBootServicesTableLib.h>

EFI_STATUS load_image(EFI_HANDLE* loaded_image_handle_out, BOOLEAN boot_policy, EFI_HANDLE parent_image_handle, EFI_DEVICE_PATH* device_path)
{
    return gBS->LoadImage(boot_policy, parent_image_handle, device_path, NULL, 0, loaded_image_handle_out);
}

EFI_STATUS unload_image(EFI_HANDLE image_handle)
{
    return gBS->UnloadImage(image_handle);
}

EFI_STATUS start_image(EFI_HANDLE image_handle)
{
    return gBS->StartImage(image_handle, NULL, NULL);
}

EFI_STATUS get_image_info(EFI_LOADED_IMAGE** image_info_out, EFI_HANDLE image_handle)
{
    EFI_GUID loaded_image_protocol_guid = EFI_LOADED_IMAGE_PROTOCOL_GUID;

    return gBS->HandleProtocol(image_handle, &loaded_image_protocol_guid, image_info_out);
}

EFI_STATUS scan_image(CHAR8** location_out, CHAR8* scan_base, UINT64 scan_max_size, UINT8* pattern, UINT8* mask)
{
    if (location_out == NULL || scan_base == NULL || scan_max_size == 0 || pattern == NULL || mask == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    UINT64 mask_size = AsciiStrLen(mask);

    CHAR8* scan_limit = scan_base + scan_max_size - mask_size;

    for (CHAR8* current_byte = scan_base; current_byte <= scan_limit; current_byte++)
    {
        BOOLEAN was_pattern_found = 1;

        for (UINT64 i = 0; i < mask_size; i++)
        {
            CHAR8 current_mask_byte = mask[i];

            if (current_mask_byte == '?')
            {
                continue;
            }

            CHAR8 current_pattern_byte = pattern[i];

            if (current_pattern_byte != current_byte[i])
            {
                was_pattern_found = 0;

                break;
            }
        }

        if (was_pattern_found == 1)
        {
            *location_out = current_byte;

            return EFI_SUCCESS;
        }
    }

    return EFI_NOT_FOUND;
}

EFI_IMAGE_NT_HEADERS64* image_get_nt_headers(UINT8* image_base)
{
    EFI_IMAGE_DOS_HEADER* dos_header = (EFI_IMAGE_DOS_HEADER*)image_base;

    EFI_IMAGE_NT_HEADERS64* nt_headers = (EFI_IMAGE_NT_HEADERS64*)(image_base + dos_header->e_lfanew);

    return nt_headers;
}

```

`uefi-boot/src/image/image.h`:

```h
#pragma once
#include <Library/UefiLib.h>
#include <IndustryStandard/PeImage.h>
#include <Protocol/LoadedImage.h>

EFI_STATUS load_image(EFI_HANDLE* loaded_image_handle_out, BOOLEAN boot_policy, EFI_HANDLE parent_image_handle, EFI_DEVICE_PATH* device_path);
EFI_STATUS unload_image(EFI_HANDLE image_handle);
EFI_STATUS start_image(EFI_HANDLE image_handle);
EFI_STATUS get_image_info(EFI_LOADED_IMAGE** image_info_out, EFI_HANDLE image_handle);
EFI_STATUS scan_image(CHAR8** location_out, CHAR8* scan_base, UINT64 scan_max_size, UINT8* pattern, UINT8* mask);
EFI_IMAGE_NT_HEADERS64* image_get_nt_headers(UINT8* image_base);
```

`uefi-boot/src/main.c`:

```c
#include <Library/UefiBootServicesTableLib.h>

#include "bootmgfw/bootmgfw.h"
#include "hyperv_attachment/hyperv_attachment.h"

const UINT8 _gDriverUnloadImageCount = 1;
const UINT32 _gUefiDriverRevision = 0x200;
CHAR8* gEfiCallerBaseName = "hyper-reV";

EFI_STATUS
EFIAPI
UefiUnload(
    IN EFI_HANDLE image_handle
)
{
    return EFI_SUCCESS;
}

EFI_STATUS
EFIAPI
UefiMain(
    IN EFI_HANDLE image_handle,
    IN EFI_SYSTEM_TABLE* system_table
)
{
    EFI_HANDLE device_handle = NULL;

    EFI_STATUS status = bootmgfw_restore_original_file(&device_handle);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    status = hyperv_attachment_set_up();

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    return bootmgfw_run_original_image(image_handle, device_handle);
}

```

`uefi-boot/src/memory_manager/memory_manager.c`:

```c
#include "memory_manager.h"
#include <Library/UefiBootServicesTableLib.h>

#include <intrin.h>

cr0 read_cr0();
void write_cr0(cr0 value);
void disable_write_protection(cr0 original_cr0);

EFI_STATUS mm_allocate_pages(VOID** buffer_out, UINT64 page_count, EFI_MEMORY_TYPE memory_type)
{
	return gBS->AllocatePages(AllocateAnyPages, memory_type, page_count, (EFI_PHYSICAL_ADDRESS*)buffer_out);
}

EFI_STATUS mm_allocate_pool(VOID** buffer_out, UINT64 size, EFI_MEMORY_TYPE memory_type)
{
	return gBS->AllocatePool(memory_type, size, buffer_out);
}

EFI_STATUS mm_free_pool(VOID* buffer)
{
	return gBS->FreePool(buffer);
}

void mm_copy_memory(UINT8* destination, const UINT8* source, UINT64 size)
{
	cr0 original_cr0 = read_cr0();

	disable_write_protection(original_cr0);

	__movsb(destination, source, size);

	write_cr0(original_cr0);
}

void mm_fill_memory(UINT8* destination, UINT64 size, UINT8 value)
{
	cr0 original_cr0 = read_cr0();

	disable_write_protection(original_cr0);

	__stosb(destination, value, size);

	write_cr0(original_cr0);
}

cr0 read_cr0()
{
	cr0 value = { .flags = __readcr0() };

	return value;
}

void write_cr0(cr0 value)
{
	__writecr0(value.flags);
}

void disable_write_protection(cr0 original_cr0)
{
	cr0 new_cr0 = original_cr0;

	new_cr0.write_protect = 0;

	write_cr0(new_cr0);
}

```

`uefi-boot/src/memory_manager/memory_manager.h`:

```h
#pragma once
#include <Library/UefiLib.h>
#include <ia32-doc/ia32_compact.h>

EFI_STATUS mm_allocate_pages(VOID** buffer_out, UINT64 page_count, EFI_MEMORY_TYPE memory_type);
EFI_STATUS mm_allocate_pool(VOID** buffer_out, UINT64 size, EFI_MEMORY_TYPE memory_type);
EFI_STATUS mm_free_pool(VOID* buffer);
void mm_copy_memory(UINT8* destination, const UINT8* source, UINT64 size);
void mm_fill_memory(UINT8* destination, UINT64 size, UINT8 value);

```

`uefi-boot/src/structures/ntdef.h`:

```h
#pragma once

typedef struct _bl_file_info_t
{
    CHAR8 pad[24];
    CHAR16* file_name;
} bl_file_info_t;

```

`uefi-boot/src/structures/relocation_entry.h`:

```h
#pragma once

typedef struct _relocation_entry_t
{
    UINT16 offset : 12;
    UINT16 type : 4;
} relocation_entry_t;

```

`uefi-boot/src/structures/virtual_address.h`:

```h
#pragma once

#pragma warning(push)
#pragma warning(disable: 4201)

typedef union _virtual_address_t
{
    UINT64 address;

    struct
    {
        UINT64 offset : 12;
        UINT64 pt_idx : 9;
        UINT64 pd_idx : 9;
        UINT64 pdpt_idx : 9;
        UINT64 pml4_idx : 9;
        UINT64 reserved : 16;
    };
} virtual_address_t;

#pragma warning(pop)

```

`uefi-boot/src/winload/winload.c`:

```c
#include "winload.h"
#include "../hooks/hooks.h"
#include "../image/image.h"
#include "../bootmgfw/bootmgfw.h"
#include "../structures/ntdef.h"
#include "../hvloader/hvloader.h"

UINT64 pml4_physical_allocation = 0;
UINT64 pdpt_physical_allocation = 0;

hook_data_t winload_load_pe_image_hook_data = { 0 };

UINT64 winload_load_pe_image_detour(bl_file_info_t* file_info, INT32 a2, UINT64* image_base, UINT32* image_size, UINT64* a5, UINT32* a6, UINT32* a7, UINT64 a8, UINT64 a9, unknown_param_t a10, unknown_param_t a11, unknown_param_t a12, unknown_param_t a13, unknown_param_t a14, unknown_param_t a15)
{
    hook_disable(&winload_load_pe_image_hook_data);

    boot_load_pe_image_t original_subroutine = (boot_load_pe_image_t)winload_load_pe_image_hook_data.hooked_subroutine_address;

    UINT64 return_value = original_subroutine(file_info, a2, image_base, image_size, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);

    if (StrStr(file_info->file_name, L"hvloader") != NULL)
    {
        hvloader_place_hooks(*image_base, *image_size);

        return return_value;
    }

    hook_enable(&winload_load_pe_image_hook_data);

    return return_value;
}

EFI_STATUS winload_place_load_pe_image_hook(UINT64 image_base, UINT64 image_size)
{
    CHAR8* code_ref_to_load_pe_image = NULL;

    // ImgpLoadPEImage
    EFI_STATUS status = scan_image(&code_ref_to_load_pe_image, (CHAR8*)image_base, image_size, d_boot_load_pe_image_pattern, d_boot_load_pe_image_mask);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    CHAR8* load_pe_image_subroutine = (code_ref_to_load_pe_image + 10) + *(UINT32*)(code_ref_to_load_pe_image + 6);

    status = hook_create(&winload_load_pe_image_hook_data, load_pe_image_subroutine, (void*)winload_load_pe_image_detour);

    if (status != EFI_SUCCESS)
    {
        return status;
    }

    return hook_enable(&winload_load_pe_image_hook_data);
}

EFI_STATUS winload_place_hooks(UINT64 image_base, UINT64 image_size)
{
    return winload_place_load_pe_image_hook(image_base, image_size);
}
```

`uefi-boot/src/winload/winload.h`:

```h
#pragma once
#include <Library/UefiLib.h>
#include <ia32-doc/ia32_compact.h>

extern UINT64 pml4_physical_allocation;
extern UINT64 pdpt_physical_allocation;

EFI_STATUS winload_place_hooks(UINT64 image_base, UINT64 image_size);

```

`uefi-boot/uefi-boot.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\bootmgfw\bootmgfw.c" />
    <ClCompile Include="src\disk\disk.c" />
    <ClCompile Include="src\hooks\hooks.c" />
    <ClCompile Include="src\hvloader\hvloader.c" />
    <ClCompile Include="src\hyperv_attachment\hyperv_attachment.c" />
    <ClCompile Include="src\image\image.c" />
    <ClCompile Include="src\main.c" />
    <ClCompile Include="src\memory_manager\memory_manager.c" />
    <ClCompile Include="src\winload\winload.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ext\ia32-doc\ia32_compact.h" />
    <ClInclude Include="src\bootmgfw\bootmgfw.h" />
    <ClInclude Include="src\disk\disk.h" />
    <ClInclude Include="src\hooks\hooks.h" />
    <ClInclude Include="src\hvloader\hvloader.h" />
    <ClInclude Include="src\hyperv_attachment\hyperv_attachment.h" />
    <ClInclude Include="src\image\image.h" />
    <ClInclude Include="src\memory_manager\memory_manager.h" />
    <ClInclude Include="src\structures\ntdef.h" />
    <ClInclude Include="src\structures\relocation_entry.h" />
    <ClInclude Include="src\structures\virtual_address.h" />
    <ClInclude Include="src\winload\winload.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a8c03eeb-3fe7-4eab-b1f8-273a441bc8b9}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(ProjectDir)\uefi.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <Import Project="$(ProjectDir)\uefi.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
  <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(ProjectDir)ext;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <Link>
      <AdditionalDependencies>UefiDriverEntryPoint.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem Condition="'$(Configuration)|$(Platform)'=='Release|x64'">EFI Application</SubSystem>
    </Link>
  </ItemDefinitionGroup>
</Project>
```

`uefi-boot/uefi.default.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EDK_PATH>$(ProjectDir)ext\edk2\src</EDK_PATH>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Include\X64;$(EDK_PATH)\ShellPkg\Include;$(EDK_PATH)\CryptoPkg\Include</IncludePath>
    <LibraryPath>$(ProjectDir)ext\edk2\build\$(Platform)\$(Configuration)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <ItemGroup>
    <BuildMacro Include="EDK_PATH">
      <Value>$(EDK_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
  </ItemGroup>
</Project>

```

`uefi-boot/uefi.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup>
    <GenerateManifest />
    <IntDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <TargetExt>.efi</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <WarningLevel>Level4</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <OmitFramePointers>true</OmitFramePointers>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>$(ProjectDir)ext\edk2\build\BaseLib\vshacks.h</ForcedIncludeFiles>
      <CallingConvention />
      <TreatWChar_tAsBuiltInType />
      <StringPooling>true</StringPooling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ForceConformanceInForLoopScope />
      <AdditionalOptions>/Gs32768 %(AdditionalOptions)</AdditionalOptions>
      <ErrorReporting />
      <FloatingPointModel />
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib</AdditionalDependencies>
      <GenerateDebugInformation>DebugFastLink</GenerateDebugInformation>
      <SubSystem>EFI Boot Service Driver</SubSystem>
      <Driver>Driver</Driver>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding />
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>0</BaseAddress>
      <SectionAlignment>32</SectionAlignment>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <ManifestFile />
      <AllowIsolation />
      <EnableUAC />
      <UACExecutionLevel />
      <UACUIAccess />
      <TypeLibraryResourceID />
      <AdditionalOptions>/OPT:ICF=10 /IGNORE:4001 /IGNORE:4254 /IGNORE:4281 %(AdditionalOptions)</AdditionalOptions>
      <MergeSections>.rdata=.data</MergeSections>
      <SpecifySectionAttributes>.xdata,D</SpecifySectionAttributes>
      <LinkErrorReporting />
      <ProfileGuidedDatabase />
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
</Project>

```

`usermode/ext/portable_executable/data_directory.cpp`:

```cpp
#include "data_directory.hpp"

bool portable_executable::data_directory_t::present() const
{
	return this->size != 0;
}

```

`usermode/ext/portable_executable/data_directory.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstddef>

namespace portable_executable
{
    static constexpr std::size_t max_data_directories = 16;

    struct data_directory_t
    {
        std::uint32_t virtual_address;
        std::uint32_t size;

        [[nodiscard]] bool present() const;
    };

    struct data_directories_t
    {
        union
        {
            struct
            {
                data_directory_t export_directory;
                data_directory_t import_directory;
                data_directory_t resource_directory;
                data_directory_t exception_directory;
                data_directory_t security_directory;
                data_directory_t basereloc_directory;
                data_directory_t debug_directory;
                data_directory_t architecture_directory;
                data_directory_t globalptr_directory;
                data_directory_t tls_directory;
                data_directory_t load_config_directory;
                data_directory_t bound_import_directory;
                data_directory_t iat_directory;
                data_directory_t delay_import_directory;
                data_directory_t com_descriptor_directory;
                data_directory_t _reserved0;
            };

            data_directory_t entries[max_data_directories];
        };
    };
}
```

`usermode/ext/portable_executable/dos_header.cpp`:

```cpp
#include "dos_header.hpp"

bool portable_executable::dos_header_t::valid() const
{
    return this->e_magic == dos_magic;
}

portable_executable::nt_headers_t* portable_executable::dos_header_t::nt_headers()
{
    return reinterpret_cast<nt_headers_t*>(reinterpret_cast<std::uintptr_t>(this) + this->e_lfanew);
}

const portable_executable::nt_headers_t* portable_executable::dos_header_t::nt_headers() const
{
    return reinterpret_cast<const nt_headers_t*>(reinterpret_cast<std::uintptr_t>(this) + this->e_lfanew);
}
```

`usermode/ext/portable_executable/dos_header.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "nt_headers.hpp"

namespace portable_executable
{
    static constexpr std::uint16_t dos_magic = 0x5A4D;

    struct dos_header_t
    {
        std::uint16_t e_magic;
        std::uint16_t e_cblp;
        std::uint16_t e_cp;
        std::uint16_t e_crlc;
        std::uint16_t e_cparhdr;
        std::uint16_t e_minalloc;
        std::uint16_t e_maxalloc;
        std::uint16_t e_ss;
        std::uint16_t e_sp;
        std::uint16_t e_csum;
        std::uint16_t e_ip;
        std::uint16_t e_cs;
        std::uint16_t e_lfarlc;
        std::uint16_t e_ovno;
        std::uint16_t e_res[4];
        std::uint16_t e_oemid;
        std::uint16_t e_oeminfo;
        std::uint16_t e_res2[10];
        std::uint32_t e_lfanew;

        [[nodiscard]] bool valid() const;

        nt_headers_t* nt_headers();

        [[nodiscard]] const nt_headers_t* nt_headers() const;
    };
}
```

`usermode/ext/portable_executable/export_directory.cpp`:

```cpp
#include "export_directory.hpp"

portable_executable::exports_iterator_t::exports_iterator_t(const std::uint8_t* module, const std::uint32_t* names, const std::uint32_t* functions, const std::uint16_t* ordinals, std::uint32_t index) :
	m_module(module), m_names(names), m_functions(functions), m_ordinals(ordinals), m_index(index)
{

}

portable_executable::exports_iterator_t::value_type portable_executable::exports_iterator_t::operator*() const
{
	const std::uint32_t name_offset = this->m_names[this->m_index];

	const std::uint16_t ordinal_offset = this->m_ordinals[this->m_index];

	const std::uint32_t functions_offset = this->m_functions[ordinal_offset];

	return
	{
		reinterpret_cast<const char*>(this->m_module + name_offset),
		const_cast<std::uint8_t*>(this->m_module + functions_offset)
	};
}

portable_executable::exports_iterator_t& portable_executable::exports_iterator_t::operator++()
{
	++this->m_index;

	return *this;
}

bool portable_executable::exports_iterator_t::operator==(const exports_iterator_t& other) const
{
	return this->m_index == other.m_index;
}

bool portable_executable::exports_iterator_t::operator!=(const exports_iterator_t& other) const
{
	return this->m_index != other.m_index;
}

```

`usermode/ext/portable_executable/export_directory.hpp`:

```hpp
#pragma once

#include <string>
#include <iterator>

namespace portable_executable
{
    struct export_entry_t
    {
        std::string name;
        std::uint8_t* address;
    };

    class exports_iterator_t
    {
        const std::uint8_t* m_module = nullptr;
        const std::uint32_t* m_names = nullptr;
        const std::uint32_t* m_functions = nullptr;
        const std::uint16_t* m_ordinals = nullptr;
        std::uint32_t m_index = 0;

    public:
        exports_iterator_t(const std::uint8_t* module, const std::uint32_t* names, const std::uint32_t* functions, const std::uint16_t* ordinals, std::uint32_t index);

        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = export_entry_t;
        using pointer = value_type*;
        using reference = value_type&;

        value_type operator*() const;

        exports_iterator_t& operator++();

        bool operator==(const exports_iterator_t& other) const;

        bool operator!=(const exports_iterator_t& other) const;
    };

    template<typename T>
    class exports_range_t
    {
    private:
        using pointer_type = std::conditional_t<std::is_const_v<T>, const std::uint8_t*, std::uint8_t*>;
        using uint32_pointer = std::conditional_t<std::is_const_v<T>, const std::uint32_t*, std::uint32_t*>;
        using uint16_pointer = std::conditional_t<std::is_const_v<T>, const std::uint16_t*, std::uint16_t*>;

        pointer_type m_module = nullptr;
        uint32_pointer m_names = nullptr;
        uint32_pointer m_functions = nullptr;
        uint16_pointer m_ordinals = nullptr;

        std::uint32_t m_num_exports = 0;

    public:
        exports_range_t() = default;

        exports_range_t(pointer_type module, uint32_pointer names, uint32_pointer functions, uint16_pointer ordinals, const std::uint32_t num_exports) :
            m_module(module), m_names(names), m_functions(functions), m_ordinals(ordinals), m_num_exports(num_exports)
        {

        }

        T begin() const
        {
            return { this->m_module, this->m_names, this->m_functions, this->m_ordinals, 0 };
        }

        T end() const
        {
            return { this->m_module, this->m_names, this->m_functions, this->m_ordinals, this->m_num_exports };
        }
    };

    struct export_directory_t
    {
        std::uint32_t characteristics;
        std::uint32_t time_date_stamp;
        std::uint16_t major_version;
        std::uint16_t minor_version;
        std::uint32_t name;
        std::uint32_t base;
        std::uint32_t number_of_functions;
        std::uint32_t number_of_names;
        std::uint32_t address_of_functions;
        std::uint32_t address_of_names;
        std::uint32_t address_of_name_ordinals;
    };
}
```

`usermode/ext/portable_executable/file.cpp`:

```cpp
#include "file.hpp"
#include "image.hpp"

#include <fstream>

portable_executable::file_t::file_t(const std::string_view file_path) : m_file_path(file_path)
{
}

portable_executable::file_t::file_t(const std::wstring_view file_path) : m_file_path(file_path)
{
}

portable_executable::file_t::file_t(std::filesystem::path file_path) : m_file_path(std::move(file_path))
{
}

bool portable_executable::file_t::load()
{
	std::ifstream file_stream(this->m_file_path, std::ios::binary);

	if (!file_stream.is_open())
	{
		return false;
	}

	file_stream.seekg(0, std::ios::end);

	const std::streampos file_size = file_stream.tellg();

	file_stream.seekg(0, std::ios::beg);

	std::vector<std::uint8_t> raw_buffer(file_size);
	file_stream.read(reinterpret_cast<char*>(raw_buffer.data()), static_cast<std::streamsize>(raw_buffer.size()));

	const auto raw_image = reinterpret_cast<const image_t*>(raw_buffer.data());

	if (!raw_image->dos_header()->valid() || !raw_image->nt_headers()->valid())
	{
		return false;
	}

	this->m_buffer.resize(raw_image->nt_headers()->optional_header.size_of_image, 0);

	std::memcpy(this->m_buffer.data(), raw_buffer.data(), 0x1000);

	for (const auto& section : raw_image->sections())
	{
		std::memcpy(this->m_buffer.data() + section.virtual_address, raw_buffer.data() + section.pointer_to_raw_data, section.size_of_raw_data);
	}

	return true;
}

portable_executable::image_t* portable_executable::file_t::image()
{
	return reinterpret_cast<image_t*>(this->m_buffer.data());
}

const portable_executable::image_t* portable_executable::file_t::image() const
{
	return reinterpret_cast<const image_t*>(this->m_buffer.data());
}

```

`usermode/ext/portable_executable/file.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <filesystem>

namespace portable_executable
{
	class image_t;

	class file_t
	{
		std::filesystem::path m_file_path;

		std::vector<std::uint8_t> m_buffer;

	public:
		explicit file_t(std::string_view file_path);

		explicit file_t(std::wstring_view file_path);

		explicit file_t(std::filesystem::path file_path);

		bool load();

		image_t* image();

		[[nodiscard]] const image_t* image() const;
	};
}
```

`usermode/ext/portable_executable/file_header.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace portable_executable
{
    struct file_header_t
    {
        std::uint16_t machine;
        std::uint16_t number_of_sections;
        std::uint32_t time_date_stamp;
        std::uint32_t pointer_to_symbol_table;
        std::uint32_t number_of_symbols;
        std::uint16_t sizeof_optional_header;
        std::uint16_t characteristics;
    };
}

```

`usermode/ext/portable_executable/image.cpp`:

```cpp
#include "image.hpp"

#include <vector>

portable_executable::dos_header_t* portable_executable::image_t::dos_header()
{
	return &this->m_dos_header;
}

const portable_executable::dos_header_t* portable_executable::image_t::dos_header() const
{
	return &this->m_dos_header;
}

portable_executable::nt_headers_t* portable_executable::image_t::nt_headers()
{
	return this->dos_header()->nt_headers();
}

const portable_executable::nt_headers_t* portable_executable::image_t::nt_headers() const
{
	return this->dos_header()->nt_headers();
}

portable_executable::section_header_t* portable_executable::image_t::find_section(const std::string_view name)
{
	for (auto& section : this->sections())
	{
		if (section.to_str() == name)
		{
			return &section;
		}
	}

	return nullptr;
}

const portable_executable::section_header_t* portable_executable::image_t::find_section(const std::string_view name) const
{
	for (const auto& section : this->sections())
	{
		if (section.to_str() == name)
		{
			return &section;
		}
	}

	return nullptr;
}

std::uint8_t* portable_executable::image_t::find_export(const std::string_view name) const
{
	for (const auto& [export_name, export_address] : this->exports())
	{
		if (export_name == name)
		{
			return export_address;
		}
	}

	return nullptr;
}

std::uint8_t* portable_executable::image_t::signature_scan(const std::string_view signature) const
{
	auto pattern_to_bytes = [](const std::string_view pattern) -> std::vector<std::int32_t>
	{
		std::vector<std::int32_t> bytes;

		const char* start = pattern.data();
		const char* end = start + pattern.size();

		for (auto current = const_cast<char*>(start); current < end; current++)
		{
			if (*current == '?')
			{
				current++;

				if (*current == '?')
				{
					current++;
				}

				bytes.push_back(-1);
			}
			else
			{
				bytes.push_back(static_cast<std::int32_t>(std::strtoul(current, &current, 16)));
			}
		}

		return bytes;
	};

	const std::vector<std::int32_t> pattern_bytes = pattern_to_bytes(signature);
	const std::size_t pattern_bytes_size = pattern_bytes.size();

	for (const auto& section : this->sections())
	{
		const std::uint8_t* section_start = this->as<const std::uint8_t*>() + section.virtual_address;
		const std::uint8_t* section_end = section_start + section.virtual_size;

		for (const std::uint8_t* byte = section_start; byte < (section_end - pattern_bytes_size); byte++)
		{
			bool found = true;

			for (std::size_t j = 0; j < pattern_bytes_size; j++)
			{
				if (pattern_bytes[j] != -1 && pattern_bytes[j] != byte[j])
				{
					found = false;
					break;
				}
			}

			if (found)
			{
				return const_cast<std::uint8_t*>(byte);
			}
		}
	}

	return nullptr;
}

std::uint8_t* portable_executable::image_t::signature_scan(const std::uint8_t* pattern, const std::size_t pattern_size) const
{
	for (const auto& section : this->sections())
	{
		const std::uint8_t* section_start = this->as<const std::uint8_t*>() + section.virtual_address;
		const std::uint8_t* section_end = section_start + section.virtual_size;

		for (const std::uint8_t* byte = section_start; byte < (section_end - pattern_size); byte++)
		{
			bool found = true;

			for (std::size_t j = 0; j < pattern_size; j++)
			{
				if (pattern[j] != 0x00 && pattern[j] != byte[j])
				{
					found = false;
					break;
				}
			}

			if (found)
			{
				return const_cast<std::uint8_t*>(byte);
			}
		}
	}

	return nullptr;
}
```

`usermode/ext/portable_executable/image.hpp`:

```hpp
#pragma once

#include "dos_header.hpp"
#include "nt_headers.hpp"

#include "section_header.hpp"
#include "export_directory.hpp"
#include "imports_directory.hpp"
#include "relocations_directory.hpp"

#include <vector>

namespace portable_executable
{
	class image_t
	{
		dos_header_t m_dos_header = { };

	public:
		template<typename T = std::uintptr_t>
		[[nodiscard]] T as() const
		{
			return reinterpret_cast<T>(this);
		}

		dos_header_t* dos_header();

		[[nodiscard]] const dos_header_t* dos_header() const;
		
		nt_headers_t* nt_headers();

		[[nodiscard]] const nt_headers_t* nt_headers() const;

		section_iterator_t<section_header_t> sections()
		{
			return { this->nt_headers()->section_headers(), this->nt_headers()->num_sections() };
		}

		[[nodiscard]] section_iterator_t<const section_header_t> sections() const
		{
			return { this->nt_headers()->section_headers(), this->nt_headers()->num_sections() };
		}

		template <class t>
		t calculate_alignment(t address, t alignment)
		{
			return address + (alignment - (address % alignment));
		}

		std::vector<std::uint8_t> add_section(std::string_view name, std::uint32_t size, std::uint32_t characteristics, bool is_image_decompressed = false)
		{
			if (8 < name.size())
			{
				return { };
			}

			const portable_executable::nt_headers_t* nt_headers = this->nt_headers();

			const portable_executable::section_header_t* section_header = this->nt_headers()->section_headers();

			const portable_executable::section_header_t* last_section_header = &section_header[nt_headers->num_sections() - 1];

			portable_executable::section_header_t* new_section_header = reinterpret_cast<portable_executable::section_header_t*>(reinterpret_cast<std::uint64_t>(&last_section_header->characteristics) + 4);

			memcpy(new_section_header, name.data(), name.size());

			new_section_header->virtual_address = calculate_alignment(last_section_header->virtual_address + last_section_header->virtual_size, nt_headers->optional_header.section_alignment);
			new_section_header->virtual_size = calculate_alignment(size + 5, nt_headers->optional_header.section_alignment);
			new_section_header->pointer_to_raw_data = is_image_decompressed ? new_section_header->virtual_address : calculate_alignment(last_section_header->pointer_to_raw_data + last_section_header->size_of_raw_data, nt_headers->optional_header.file_alignment);
			new_section_header->size_of_raw_data = is_image_decompressed ? new_section_header->virtual_size : calculate_alignment(size + 5, nt_headers->optional_header.file_alignment);
			new_section_header->characteristics = { .flags = characteristics };

			new_section_header->pointer_to_linenumbers = 0;
			new_section_header->pointer_to_relocations = 0;
			new_section_header->number_of_linenumbers = 0;
			new_section_header->number_of_relocations = 0;

			std::vector<std::uint8_t> binary_snapshot = { this->as<const std::uint8_t*>(), this->as<const std::uint8_t*>() + nt_headers->optional_header.size_of_image };

			image_t* new_image = reinterpret_cast<image_t*>(binary_snapshot.data());

			for (portable_executable::section_header_t& section : new_image->sections())
			{
				section.pointer_to_raw_data = section.virtual_address;
			}

			new_image->nt_headers()->optional_header.size_of_image = calculate_alignment(new_image->nt_headers()->optional_header.size_of_image + size + 5 + static_cast<std::uint32_t>(sizeof(portable_executable::section_header_t)), nt_headers->optional_header.section_alignment);
			new_image->nt_headers()->optional_header.size_of_headers = calculate_alignment(new_image->nt_headers()->optional_header.size_of_headers + static_cast<std::uint32_t>(sizeof(portable_executable::section_header_t)), nt_headers->optional_header.file_alignment);
			new_image->nt_headers()->file_header.number_of_sections++;

			binary_snapshot.resize(new_image->nt_headers()->optional_header.size_of_image);

			return binary_snapshot;
		}

		exports_range_t<exports_iterator_t> exports()
		{
			const data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.export_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<std::uint8_t*>(this);

			const auto export_directory = reinterpret_cast<export_directory_t*>(module + data_directory.virtual_address);

			auto names = reinterpret_cast<std::uint32_t*>(module + export_directory->address_of_names);
			auto functions = reinterpret_cast<std::uint32_t*>(module + export_directory->address_of_functions);
			auto ordinals = reinterpret_cast<std::uint16_t*>(module + export_directory->address_of_name_ordinals);

			return { module, names, functions, ordinals, export_directory->number_of_names };
		}

		[[nodiscard]] exports_range_t<const exports_iterator_t> exports() const
		{
			const data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.export_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<const std::uint8_t*>(this);

			const auto export_directory = reinterpret_cast<const export_directory_t*>(module + data_directory.virtual_address);

			auto names = reinterpret_cast<const std::uint32_t*>(module + export_directory->address_of_names);
			auto functions = reinterpret_cast<const std::uint32_t*>(module + export_directory->address_of_functions);
			auto ordinals = reinterpret_cast<const std::uint16_t*>(module + export_directory->address_of_name_ordinals);

			return { module, names, functions, ordinals, export_directory->number_of_names };
		}

		imports_range_t<imports_iterator_t> imports()
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.import_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<std::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		[[nodiscard]] imports_range_t<const imports_iterator_t> imports() const
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.import_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<const std::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		relocations_range_t<relocations_iterator_t> relocations()
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.basereloc_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<std::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		[[nodiscard]] relocations_range_t<const relocations_iterator_t> relocations() const
		{
			data_directory_t data_directory = this->nt_headers()->optional_header.data_directories.basereloc_directory;

			if (!data_directory.present())
			{
				return { };
			}

			auto module = reinterpret_cast<const std::uint8_t*>(this);

			return { module, data_directory.virtual_address };
		}

		section_header_t* find_section(std::string_view name);

		[[nodiscard]] const section_header_t* find_section(std::string_view name) const;

		[[nodiscard]] std::uint8_t* find_export(std::string_view name) const;

		// IDA signatures
		[[nodiscard]] std::uint8_t* signature_scan(std::string_view signature) const;

		// byte signatures
		[[nodiscard]] std::uint8_t* signature_scan(const std::uint8_t* pattern, std::size_t pattern_size) const;
	};
}
```

`usermode/ext/portable_executable/imports_directory.cpp`:

```cpp
#include "imports_directory.hpp"

portable_executable::imports_iterator_t::imports_iterator_t(const std::uint8_t* module, const import_descriptor_t* descriptor) :
	m_module(module), m_current_descriptor(descriptor)
{
    if (this->m_current_descriptor && this->m_current_descriptor->first_thunk)
    {
        this->m_current_thunk = reinterpret_cast<const thunk_data_t*>(this->m_module + m_current_descriptor->first_thunk);
        this->m_original_thunk = reinterpret_cast<const thunk_data_t*>(this->m_module + m_current_descriptor->misc.original_first_thunk);
    }
}

portable_executable::imports_iterator_t::value_type portable_executable::imports_iterator_t::operator*() const
{
    std::string import_name;

    if (this->m_original_thunk->is_ordinal)
    {
        import_name = reinterpret_cast<const char*>(this->m_module + this->m_original_thunk->ordinal);
    }
    else
    {
        const auto import_by_name = reinterpret_cast<const import_by_name_t*>(this->m_module + this->m_original_thunk->address);

        import_name = import_by_name->name;
    }

    const std::string module_name(reinterpret_cast<const char*>(this->m_module + this->m_current_descriptor->name));

    auto* import_addr_ref = const_cast<std::uint64_t*>(&this->m_current_thunk->function);
    auto& import_addr = *reinterpret_cast<std::uint8_t**>(import_addr_ref);

    return { module_name, import_name, import_addr };
}

portable_executable::imports_iterator_t& portable_executable::imports_iterator_t::operator++()
{
    if (this->m_current_thunk && this->m_current_thunk->address)
    {
        ++this->m_current_thunk;
        ++this->m_original_thunk;

        if (!this->m_current_thunk->address)
        {
            ++this->m_current_descriptor;

            while (this->m_current_descriptor && this->m_current_descriptor->first_thunk)
            {
                this->m_current_thunk = reinterpret_cast<const thunk_data_t*>(this->m_module + this->m_current_descriptor->first_thunk);
                this->m_original_thunk = reinterpret_cast<const thunk_data_t*>(this->m_module + this->m_current_descriptor->misc.original_first_thunk);

                if (this->m_current_thunk->address)
                {
                    break;
                }

                ++this->m_current_descriptor;
            }

            if (!this->m_current_descriptor || !this->m_current_descriptor->first_thunk)
            {
                this->m_current_descriptor = nullptr;
                this->m_current_thunk = nullptr;
            }
        }
    }

    return *this;
}

bool portable_executable::imports_iterator_t::operator==(const imports_iterator_t& other) const
{
    return this->m_current_descriptor == other.m_current_descriptor && this->m_current_thunk == other.m_current_thunk;
}

bool portable_executable::imports_iterator_t::operator!=(const imports_iterator_t& other) const
{
    return this->m_current_descriptor != other.m_current_descriptor || this->m_current_thunk != other.m_current_thunk;
}

```

`usermode/ext/portable_executable/imports_directory.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <iterator>

namespace portable_executable
{
    struct import_descriptor_t
    {
        union
        {
            std::uint32_t characteristics;
            std::uint32_t original_first_thunk;
        } misc;

        std::uint32_t time_date_stamp;
        std::uint32_t forwarder_chain;
        std::uint32_t name;
        std::uint32_t first_thunk;
    };

    struct thunk_data_t
    {
        union
        {
            std::uint64_t forwarder_string;
            std::uint64_t function;
            std::uint64_t address;

            struct  // NOLINT(clang-diagnostic-nested-anon-types)
            {
                std::uint64_t ordinal : 16;
                std::uint64_t reserved0 : 47;
                std::uint64_t is_ordinal : 1;
            };
        };
    };

    struct import_by_name_t
    {
        std::uint16_t hint;
        char name[1];
    };

    struct import_entry_t
    {
        std::string module_name;
        std::string import_name;
        std::uint8_t*& address;
    };

    class imports_iterator_t
    {
        const std::uint8_t* m_module = nullptr;

        const import_descriptor_t* m_current_descriptor = nullptr;
        const thunk_data_t* m_current_thunk = nullptr;
        const thunk_data_t* m_original_thunk = nullptr;

    public:
        imports_iterator_t(const std::uint8_t* module, const import_descriptor_t* descriptor);

        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = import_entry_t;
        using pointer = value_type*;
        using reference = value_type&;

        value_type operator*() const;

        imports_iterator_t& operator++();

        bool operator==(const imports_iterator_t& other) const;

        bool operator!=(const imports_iterator_t& other) const;
    };
    
    template<typename T>
    class imports_range_t
    {
    private:
        using pointer_type = std::conditional_t<std::is_const_v<T>, const std::uint8_t*, std::uint8_t*>;
        using import_descriptor_type = std::conditional_t<std::is_const_v<T>, const import_descriptor_t*, import_descriptor_t*>;

        pointer_type m_module = nullptr;

        import_descriptor_type m_import_descriptor = nullptr;

    public:
        imports_range_t() = default;

        imports_range_t(pointer_type module, std::uint32_t imports_rva) :
            m_module(module), m_import_descriptor(reinterpret_cast<import_descriptor_type>(module + imports_rva))
        {

        }

        T begin() const
        {
            return { this->m_module, this->m_import_descriptor };
        }

        T end() const
        {
            return { this->m_module, nullptr };
        }
    };
}
```

`usermode/ext/portable_executable/nt_headers.cpp`:

```cpp
#include "nt_headers.hpp"

bool portable_executable::nt_headers_t::valid() const
{
	return this->signature == nt_magic;
}

portable_executable::section_header_t* portable_executable::nt_headers_t::section_headers()
{
	return reinterpret_cast<section_header_t*>(reinterpret_cast<std::uintptr_t>(&this->optional_header) + this->file_header.sizeof_optional_header);
}

const portable_executable::section_header_t* portable_executable::nt_headers_t::section_headers() const
{
	return reinterpret_cast<const section_header_t*>(reinterpret_cast<std::uintptr_t>(&this->optional_header) + this->file_header.sizeof_optional_header);
}

std::uint16_t portable_executable::nt_headers_t::num_sections() const
{
	return this->file_header.number_of_sections;
}
```

`usermode/ext/portable_executable/nt_headers.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "file_header.hpp"
#include "optional_header.hpp"

#include "section_header.hpp"

namespace portable_executable
{
    static constexpr std::uint32_t nt_magic = 0x00004550;

    struct nt_headers_t
    {
        std::uint32_t signature;
        file_header_t file_header;
        optional_header_t optional_header;

        [[nodiscard]] bool valid() const;

        section_header_t* section_headers();

        [[nodiscard]] const section_header_t* section_headers() const;

        [[nodiscard]] std::uint16_t num_sections() const;
    };
} 
```

`usermode/ext/portable_executable/optional_header.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "data_directory.hpp"

namespace portable_executable
{
    struct optional_header_t
    {
        std::uint16_t magic;
        std::uint8_t major_linker_version;
        std::uint8_t minor_linker_version;
        std::uint32_t size_of_code;
        std::uint32_t size_of_initialized_data;
        std::uint32_t size_of_uninitialized_data;
        std::uint32_t address_of_entry_point;
        std::uint32_t base_of_code;
        std::uint64_t image_base;
        std::uint32_t section_alignment;
        std::uint32_t file_alignment;
        std::uint16_t major_operating_system_version;
        std::uint16_t minor_operating_system_version;
        std::uint16_t major_image_version;
        std::uint16_t minor_image_version;
        std::uint16_t major_subsystem_version;
        std::uint16_t minor_subsystem_version;
        std::uint32_t win32_version_value;
        std::uint32_t size_of_image;
        std::uint32_t size_of_headers;
        std::uint32_t check_sum;
        std::uint16_t subsystem;
        std::uint16_t dll_characteristics;
        std::uint64_t size_of_stack_reserve;
        std::uint64_t size_of_stack_commit;
        std::uint64_t size_of_heap_reserve;
        std::uint64_t size_of_heap_commit;
        std::uint32_t loader_flags;
        std::uint32_t number_of_rva_and_sizes;
        data_directories_t data_directories;
    };
}
```

`usermode/ext/portable_executable/relocations_directory.cpp`:

```cpp
#include "relocations_directory.hpp"

void portable_executable::relocations_iterator_t::load_block(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor)
{
    this->m_current_raw_relocation_block_descriptor = raw_relocation_block_descriptor;

    if (this->m_current_raw_relocation_block_descriptor && this->m_current_raw_relocation_block_descriptor->virtual_address)
    {
        const std::uint64_t real_block_size = this->m_current_raw_relocation_block_descriptor->size_of_block - sizeof(raw_relocation_block_descriptor_t);

        this->m_current_relocation_block.max_entry_index = static_cast<std::uint32_t>(real_block_size / sizeof(relocation_entry_descriptor_t));
        this->m_current_relocation_block.current_entry_index = 1;

        this->m_current_descriptor = reinterpret_cast<const relocation_entry_descriptor_t*>(this->m_current_raw_relocation_block_descriptor + 1);
    }
}

portable_executable::relocations_iterator_t::relocations_iterator_t(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor)
{
    if (raw_relocation_block_descriptor)
    {
        this->load_block(raw_relocation_block_descriptor);
    }
}

portable_executable::relocations_iterator_t::value_type portable_executable::relocations_iterator_t::operator*() const
{
    return { *this->m_current_descriptor, this->m_current_raw_relocation_block_descriptor->virtual_address };
}

portable_executable::relocations_iterator_t& portable_executable::relocations_iterator_t::operator++()
{
    if (this->m_current_descriptor && this->m_current_relocation_block.current_entry_index < this->m_current_relocation_block.max_entry_index)
    {
        ++this->m_current_descriptor;

        this->m_current_relocation_block.current_entry_index++;
    }
    else if (this->m_current_raw_relocation_block_descriptor && this->m_current_raw_relocation_block_descriptor->virtual_address)
    {
        this->load_block(reinterpret_cast<const raw_relocation_block_descriptor_t*>(reinterpret_cast<std::uint64_t>(this->m_current_raw_relocation_block_descriptor) + this->m_current_raw_relocation_block_descriptor->size_of_block));
    }
    else
    {
        this->m_current_descriptor = nullptr;
    }

    return *this;
}

bool portable_executable::relocations_iterator_t::operator==(const relocations_iterator_t& other)
{
    return this->m_current_descriptor == other.m_current_descriptor;
}

bool portable_executable::relocations_iterator_t::operator!=(const relocations_iterator_t& other)
{
    return this->m_current_descriptor != other.m_current_descriptor;
}

```

`usermode/ext/portable_executable/relocations_directory.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <iterator>

namespace portable_executable
{
    enum class relocation_type_t : std::uint16_t
    {
        absolute,
        high,
        low,
        high_low,
        high_adj,
        machine_specific_5,
        reserved,
        machine_specific_7,
        machine_specific_8,
        machine_specific_9,
        dir64,
        null
    };

    struct relocation_entry_descriptor_t
    {
        std::uint16_t offset : 12;
        relocation_type_t type : 4;
    };

    struct raw_relocation_block_descriptor_t
    {
        std::uint32_t virtual_address;
        std::uint32_t size_of_block;
    };

    struct relocation_block_t
    {
        std::uint32_t current_entry_index;
        std::uint32_t max_entry_index;
    };

    struct relocation_entry_t
    {
        relocation_entry_descriptor_t descriptor;
        std::uint32_t virtual_address;
    };

    class relocations_iterator_t
    {
    private:
        const raw_relocation_block_descriptor_t* m_current_raw_relocation_block_descriptor = nullptr;
        relocation_block_t m_current_relocation_block = { };

        const relocation_entry_descriptor_t* m_current_descriptor = nullptr;

        void load_block(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor);

    public:
        relocations_iterator_t() = default;

        // ReSharper disable once CppNonExplicitConvertingConstructor
        relocations_iterator_t(const raw_relocation_block_descriptor_t* raw_relocation_block_descriptor);

        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = relocation_entry_t;
        using pointer = value_type*;
        using reference = value_type&;

        value_type operator*() const;

        relocations_iterator_t& operator++();

        bool operator==(const relocations_iterator_t& other);

        bool operator!=(const relocations_iterator_t& other);
    };

    template<typename T>
    class relocations_range_t
    {
    private:
        using pointer_type = std::conditional_t<std::is_const_v<T>, const std::uint8_t*, std::uint8_t*>;
        using relocation_descriptor_type = std::conditional_t<std::is_const_v<T>, const raw_relocation_block_descriptor_t*, raw_relocation_block_descriptor_t*>;

        pointer_type m_module = nullptr;

        const raw_relocation_block_descriptor_t* m_raw_relocation_block_descriptor = nullptr;

    public:
        relocations_range_t() = default;

        relocations_range_t(pointer_type module, std::uint32_t relocations_rva) :
            m_module(module), m_raw_relocation_block_descriptor(reinterpret_cast<relocation_descriptor_type>(module + relocations_rva))
        {

        }

        T begin() const
        {
            return { this->m_raw_relocation_block_descriptor };
        }

        // ReSharper disable once CppMemberFunctionMayBeStatic
        T end()
        {
            return { nullptr };
        }
    };
}
```

`usermode/ext/portable_executable/section_header.cpp`:

```cpp
#include "section_header.hpp"

std::string portable_executable::section_header_t::to_str() const
{
	return this->name;
}

```

`usermode/ext/portable_executable/section_header.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdint>
#include <cstddef>

namespace portable_executable
{
    static constexpr std::size_t section_name_size_limit = 8;

    union section_characteristics_t
    {
        struct
        {
            std::uint32_t _pad0 : 5;
            std::uint32_t cnt_code : 1;
            std::uint32_t cnt_init_data : 1;
            std::uint32_t cnt_uninit_data : 1;
            std::uint32_t _pad1 : 1;
            std::uint32_t lnk_info : 1;
            std::uint32_t _pad2 : 1;
            std::uint32_t lnk_remove : 1;
            std::uint32_t lnk_comdat : 1;
            std::uint32_t _pad3 : 1;
            std::uint32_t no_defer_spec_exc : 1;
            std::uint32_t mem_far : 1;
            std::uint32_t _pad4 : 1;
            std::uint32_t mem_purgeable : 1;
            std::uint32_t mem_locked : 1;
            std::uint32_t mem_preload : 1;
            std::uint32_t alignment : 4;
            std::uint32_t lnk_nreloc_ovfl : 1;
            std::uint32_t mem_discardable : 1;
            std::uint32_t mem_not_cached : 1;
            std::uint32_t mem_not_paged : 1;
            std::uint32_t mem_shared : 1;
            std::uint32_t mem_execute : 1;
            std::uint32_t mem_read : 1;
            std::uint32_t mem_write : 1;
        };

        std::uint32_t flags;
    };

    struct section_header_t
    {
        char name[section_name_size_limit];
        std::uint32_t virtual_size;
        std::uint32_t virtual_address;
        std::uint32_t size_of_raw_data;
        std::uint32_t pointer_to_raw_data;
        std::uint32_t pointer_to_relocations;
        std::uint32_t pointer_to_linenumbers;
        std::uint16_t number_of_relocations;
        std::uint16_t number_of_linenumbers;
        section_characteristics_t characteristics;

        [[nodiscard]] std::string to_str() const;
    };

    template<typename T>
    class section_iterator_t
    {
    private:
        T* m_base = nullptr;

        std::uint16_t m_num_sections = 0;

    public:
        section_iterator_t(T* base, const std::uint16_t num_sections) : m_base(base), m_num_sections(num_sections)
        {

        }

        T* begin() const
        {
            return this->m_base;
        }

        T* end() const
        {
            return this->m_base + this->m_num_sections;
        }
    };
}
```

`usermode/src/commands/commands.cpp`:

```cpp
#include "commands.h"
#include <CLI/CLI.hpp>
#include <hypercall/hypercall_def.h>
#include "../hook/hook.h"
#include "../hypercall/hypercall.h"
#include "../system/system.h"

#include <print>
#include <array>

#define d_invoke_command_processor(command) process_##command(##command)
#define d_initial_process_command(command) if (*##command) d_invoke_command_processor(command)
#define d_process_command(command) else if (*##command) d_invoke_command_processor(command)

template <class t>
t get_command_option(CLI::App* app, std::string option_name)
{
	auto option = app->get_option(option_name);

	return option->empty() == false ? option->as<t>() : t{};
}

CLI::Option* add_command_option(CLI::App* app, std::string option_name)
{
	return app->add_option(option_name);
}

CLI::Option* add_transformed_command_option(CLI::App* app, std::string option_name, CLI::Transformer& transformer)
{
	CLI::Option* option = add_command_option(app, option_name);

	return option->transform(transformer);
}

std::uint8_t get_command_flag(CLI::App* app, std::string flag_name)
{
	auto option = app->get_option(flag_name);

	return !option->empty();
}

CLI::Option* add_command_flag(CLI::App* app, std::string flag_name)
{
	return app->add_flag(flag_name);
}

CLI::App* init_rgpm(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* rgpm = app.add_subcommand("rgpm", "reads memory from a given guest physical address")->ignore_case();

	add_transformed_command_option(rgpm, "physical_address", aliases_transformer)->required();
	add_command_option(rgpm, "size")->check(CLI::Range(0, 8))->required();

	return rgpm;
}

void process_rgpm(CLI::App* rgpm)
{
	const std::uint64_t guest_physical_address = get_command_option<std::uint64_t>(rgpm, "physical_address");
	const std::uint64_t size = get_command_option<std::uint64_t>(rgpm, "size");

	std::uint64_t value = 0;

	const std::uint64_t bytes_read = hypercall::read_guest_physical_memory(&value, guest_physical_address, size);

	if (bytes_read == size)
	{
		std::println("value: 0x{:x}", value);
	}
	else
	{
		std::println("failed to read");
	}
}

CLI::App* init_wgpm(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* wgpm = app.add_subcommand("wgpm", "writes memory to a given guest physical address")->ignore_case();

	add_transformed_command_option(wgpm, "physical_address", aliases_transformer)->required();
	add_command_option(wgpm, "value")->required();
	add_command_option(wgpm, "size")->check(CLI::Range(0, 8))->required();

	return wgpm;
}

void process_wgpm(CLI::App* wgpm)
{
	const std::uint64_t guest_physical_address = get_command_option<std::uint64_t>(wgpm, "physical_address");
	const std::uint64_t size = get_command_option<std::uint64_t>(wgpm, "size");

	std::uint64_t value = get_command_option<std::uint64_t>(wgpm, "value");

	const std::uint64_t bytes_written = hypercall::write_guest_physical_memory(&value, guest_physical_address, size);

	if (bytes_written == size)
	{
		std::println("success in write");
	}
	else
	{
		std::println("failed to write");
	}
}

CLI::App* init_cgpm(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* cgpm = app.add_subcommand("cgpm", "copies memory from a given source to a destination (guest physical addresses)")->ignore_case();

	add_transformed_command_option(cgpm, "destination_physical_address", aliases_transformer)->required();
	add_transformed_command_option(cgpm, "source_physical_address", aliases_transformer)->required();
	add_command_option(cgpm, "size")->required();

	return cgpm;
}

void process_cgpm(CLI::App* cgpm)
{
	const std::uint64_t guest_destination_physical_address = get_command_option<std::uint64_t>(cgpm, "destination_physical_address");
	const std::uint64_t guest_source_physical_address = get_command_option<std::uint64_t>(cgpm, "source_physical_address");
	const std::uint64_t size = get_command_option<std::uint64_t>(cgpm, "size");

	std::vector<std::uint8_t> buffer(size);

	const std::uint64_t bytes_read = hypercall::read_guest_physical_memory(buffer.data(), guest_source_physical_address, size);
	const std::uint64_t bytes_written = hypercall::write_guest_physical_memory(buffer.data(), guest_destination_physical_address, size);

	if ((bytes_read == size) && (bytes_written == size))
	{
		std::println("success in copy");
	}
	else
	{
		std::println("failed to copy");
	}
}

CLI::App* init_gvat(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* gvat = app.add_subcommand("gvat", "translates a guest virtual address to its corresponding guest physical address, with the given guest cr3 value")->ignore_case();

	add_transformed_command_option(gvat, "virtual_address", aliases_transformer)->required();
	add_transformed_command_option(gvat, "cr3", aliases_transformer)->required();

	return gvat;
}

void process_gvat(CLI::App* gvat)
{
	const std::uint64_t virtual_address = get_command_option<std::uint64_t>(gvat, "virtual_address");
	const std::uint64_t cr3 = get_command_option<std::uint64_t>(gvat, "cr3");

	const std::uint64_t physical_address = hypercall::translate_guest_virtual_address(virtual_address, cr3);

	std::println("physical address: 0x{:x}", physical_address);
}

CLI::App* init_rgvm(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* rgvm = app.add_subcommand("rgvm", "reads memory from a given guest virtual address (when given the corresponding guest cr3 value)")->ignore_case();

	add_transformed_command_option(rgvm, "virtual_address", aliases_transformer)->required();
	add_transformed_command_option(rgvm, "cr3", aliases_transformer)->required();
	add_command_option(rgvm, "size")->check(CLI::Range(0, 8))->required();

	return rgvm;
}

void process_rgvm(CLI::App* rgvm)
{
	const std::uint64_t guest_virtual_address = get_command_option<std::uint64_t>(rgvm, "virtual_address");
	const std::uint64_t cr3 = get_command_option<std::uint64_t>(rgvm, "cr3");
	const std::uint64_t size = get_command_option<std::uint64_t>(rgvm, "size");

	std::uint64_t value = 0;

	const std::uint64_t bytes_read = hypercall::read_guest_virtual_memory(&value, guest_virtual_address, cr3, size);

	if (bytes_read == size)
	{
		std::println("value: 0x{:x}", value);
	}
	else
	{
		std::println("failed to read");
	}
}

CLI::App* init_wgvm(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* wgvm = app.add_subcommand("wgvm", "writes memory from a given guest virtual address (when given the corresponding guest cr3 value)")->ignore_case();

	add_transformed_command_option(wgvm, "virtual_address", aliases_transformer)->required();
	add_transformed_command_option(wgvm, "cr3", aliases_transformer)->required();
	add_command_option(wgvm, "value")->required();
	add_command_option(wgvm, "size")->check(CLI::Range(0, 8))->required();

	return wgvm;
}

void process_wgvm(CLI::App* wgvm)
{
	const std::uint64_t guest_virtual_address = get_command_option<std::uint64_t>(wgvm, "virtual_address");
	const std::uint64_t cr3 = get_command_option<std::uint64_t>(wgvm, "cr3");
	const std::uint64_t size = get_command_option<std::uint64_t>(wgvm, "size");

	std::uint64_t value = get_command_option<std::uint64_t>(wgvm, "value");

	const std::uint64_t bytes_written = hypercall::write_guest_virtual_memory(&value, guest_virtual_address, cr3, size);

	if (bytes_written == size)
	{
		std::println("success in write at given address");
	}
	else
	{
		std::println("failed to write at given address");
	}
}

CLI::App* init_cgvm(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* cgvm = app.add_subcommand("cgvm", "copies memory from a given source to a destination (guest virtual addresses) (when given the corresponding guest cr3 values)")->ignore_case();

	add_transformed_command_option(cgvm, "destination_virtual_address", aliases_transformer)->required();
	add_transformed_command_option(cgvm, "destination_cr3", aliases_transformer)->required();
	add_transformed_command_option(cgvm, "source_virtual_address", aliases_transformer)->required();
	add_transformed_command_option(cgvm, "source_cr3", aliases_transformer)->required();
	add_command_option(cgvm, "size")->required();

	return cgvm;
}

void process_cgvm(CLI::App* wgvm)
{
	const std::uint64_t guest_destination_virtual_address = get_command_option<std::uint64_t>(wgvm, "destination_virtual_address");
	const std::uint64_t guest_destination_cr3 = get_command_option<std::uint64_t>(wgvm, "destination_cr3");

	const std::uint64_t guest_source_virtual_address = get_command_option<std::uint64_t>(wgvm, "source_virtual_address");
	const std::uint64_t guest_source_cr3 = get_command_option<std::uint64_t>(wgvm, "source_cr3");

	const std::uint64_t size = get_command_option<std::uint64_t>(wgvm, "size");

	std::vector<std::uint8_t> buffer(size);

	const std::uint64_t bytes_read = hypercall::read_guest_virtual_memory(buffer.data(), guest_source_virtual_address, guest_source_cr3, size);
	const std::uint64_t bytes_written = hypercall::write_guest_virtual_memory(buffer.data(), guest_destination_virtual_address, guest_destination_cr3, size);

	if ((bytes_read == size) && (bytes_written == size))
	{
		std::println("success in copy");
	}
	else
	{
		std::println("failed to copy");
	}
}

CLI::App* init_akh(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* akh = app.add_subcommand("akh", "add a hook on specified kernel code (given the guest virtual address) (asmbytes in form: 0xE8 0x12 0x23 0x34 0x45)")->ignore_case();

	add_transformed_command_option(akh, "virtual_address", aliases_transformer)->required();
	add_command_option(akh, "--asmbytes")->multi_option_policy(CLI::MultiOptionPolicy::TakeAll)->expected(-1);
	add_command_option(akh, "--post_original_asmbytes")->multi_option_policy(CLI::MultiOptionPolicy::TakeAll)->expected(-1);
	add_command_flag(akh, "--monitor");

	return akh;
}

void process_akh(CLI::App* akh)
{
	const std::uint64_t virtual_address = get_command_option<std::uint64_t>(akh, "virtual_address");

	std::vector<uint8_t> asm_bytes = get_command_option<std::vector<uint8_t>>(akh, "--asmbytes");
	const std::vector<uint8_t> post_original_asm_bytes = get_command_option<std::vector<uint8_t>>(akh, "--post_original_asmbytes");

	const std::uint8_t monitor = get_command_flag(akh, "--monitor");

	if (monitor == 1)
	{
		std::array<std::uint8_t, 9> monitor_bytes = {
			0x51, // push rcx
			0xB9, 0x00, 0x00, 0x00, 0x00, // mov ecx, 0
			0x0F, 0xA2, // cpuid
			0x59 // pop rcx
		};

		hypercall_info_t call_info = { };

		call_info.primary_key = hypercall_primary_key;
		call_info.secondary_key = hypercall_secondary_key;
		call_info.call_type = hypercall_type_t::log_current_state;

		*reinterpret_cast<std::uint32_t*>(&monitor_bytes[2]) = static_cast<std::uint32_t>(call_info.value);

		asm_bytes.insert(asm_bytes.end(), monitor_bytes.begin(), monitor_bytes.end());
	}

	const std::uint8_t hook_status = hook::add_kernel_hook(virtual_address, asm_bytes, post_original_asm_bytes);

	if (hook_status == 1)
	{
		std::println("success in hook");
	}
	else
	{
		std::println("failed to hook");
	}
}

CLI::App* init_rkh(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* rkh = app.add_subcommand("rkh", "remove a previously placed hook on specified kernel code (given the guest virtual address)")->ignore_case();

	add_transformed_command_option(rkh, "virtual_address", aliases_transformer)->required();

	return rkh;
}

void process_rkh(CLI::App* rkh)
{
	const std::uint64_t virtual_address = get_command_option<std::uint64_t>(rkh, "virtual_address");

	const std::uint8_t hook_removal_status = hook::remove_kernel_hook(virtual_address, 1);

	if (hook_removal_status == 1)
	{
		std::println("success in hook removal");
	}
	else
	{
		std::println("failed to remove hook");
	}
}

CLI::App* init_hgpp(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* hgpp = app.add_subcommand("hgpp", "hide a physical page's real contents from the guest")->ignore_case();

	add_transformed_command_option(hgpp, "physical_address", aliases_transformer)->required();

	return hgpp;
}

void process_hgpp(CLI::App* hgpp)
{
	const std::uint64_t physical_address = get_command_option<std::uint64_t>(hgpp, "physical_address");

	const std::uint64_t hide_status = hypercall::hide_guest_physical_page(physical_address);

	if (hide_status == 1)
	{
		std::println("success in hiding page");
	}
	else
	{
		std::println("failed to hide page");
	}
}

CLI::App* init_fl(CLI::App& app)
{
	CLI::App* fl = app.add_subcommand("fl", "flush trap frame logs from hooks")->ignore_case();

	return fl;
}

void process_fl(CLI::App* fl)
{
	constexpr std::uint64_t log_count = 100;
	constexpr std::uint64_t failed_log_count = -1;

	std::vector<trap_frame_log_t> logs(log_count);

	const std::uint64_t logs_flushed = hypercall::flush_logs(logs);

	if (logs_flushed == failed_log_count)
	{
		std::println("failed to flush logs");
	}
	else if (logs_flushed == 0)
	{
		std::println("there are no logs to flush");
	}
	else
	{
		std::println("success in flushing logs ({}), outputting logs now:\n\n", logs_flushed);

		for (std::uint64_t i = 0; i < logs_flushed; i++)
		{
			const trap_frame_log_t& log = logs[i];

			if (log.rip == 0)
			{
				break;
			}

			std::println("{}. rip=0x{:X} rax=0x{:X} rcx=0x{:X}\nrdx=0x{:X} rbx=0x{:X} rsp=0x{:X} rbp=0x{:X}\nrsi=0x{:X} rdi=0x{:X} r8=0x{:X} r9=0x{:X}\nr10=0x{:X} r11=0x{:X} r12=0x{:X} r13=0x{:X} r14=0x{:X}\nr15=0x{:X} cr3=0x{:X}\n"
				,i, log.rip, log.rax, log.rcx, log.rdx, log.rbx, log.rsp, log.rbp, log.rsi, log.rdi, log.r8, log.r9, log.r10, log.r11, log.r12, log.r13, log.r14, log.r15, log.cr3);

			std::println("stack data:");
			
			for (const std::uint64_t stack_value : log.stack_data)
			{
				std::println("  0x{:X}", stack_value);
			}

			std::println();
		}
	}
}

CLI::App* init_hfpc(CLI::App& app)
{
	CLI::App* hfpc = app.add_subcommand("hfpc", "get hyperv-attachment's heap free page count")->ignore_case();

	return hfpc;
}

void process_hfpc(CLI::App* hfpc)
{
	const std::uint64_t heap_free_page_count = hypercall::get_heap_free_page_count();

	std::println("heap free page count: {}", heap_free_page_count);
}

CLI::App* init_lkm(CLI::App& app)
{
	CLI::App* lkm = app.add_subcommand("lkm", "print list of loaded kernel modules")->ignore_case();

	return lkm;
}

void process_lkm(CLI::App* lkm)
{
	for (const auto& [module_name, module_info] : sys::kernel::modules_list)
	{
		std::println("'{}' has a base address of: 0x{:x}, and a size of: 0x{:X}", module_name, module_info.base_address, module_info.size);
	}
}

CLI::App* init_kme(CLI::App& app)
{
	CLI::App* kme = app.add_subcommand("kme", "list the exports of a loaded kernel module (when given the name)")->ignore_case();

	add_command_option(kme, "module_name")->required();

	return kme;
}

void process_kme(CLI::App* kme)
{
	const std::string module_name = get_command_option<std::string>(kme, "module_name");

	if (sys::kernel::modules_list.contains(module_name) == false)
	{
		std::println("module not found");

		return;
	}

	const sys::kernel_module_t module = sys::kernel::modules_list[module_name];

	for (auto& [export_name, export_address] : module.exports)
	{
		std::println("{} = 0x{:X}", export_name, export_address);
	}
}

CLI::App* init_dkm(CLI::App& app)
{
	CLI::App* dkm = app.add_subcommand("dkm", "dump kernel module to a file on disk")->ignore_case();

	add_command_option(dkm, "module_name")->required();
	add_command_option(dkm, "output_directory")->required();

	return dkm;
}

void process_dkm(CLI::App* dkm)
{
	const std::string module_name = get_command_option<std::string>(dkm, "module_name");

	if (sys::kernel::modules_list.contains(module_name) == false)
	{
		std::println("module not found");

		return;
	}

	const std::string output_directory = get_command_option<std::string>(dkm, "output_directory");

	const std::uint8_t status = sys::kernel::dump_module_to_disk(module_name, output_directory);

	if (status == 1)
	{
		std::println("success in dumping module");
	}
	else
	{
		std::println("failed to dump module");
	}
}

CLI::App* init_gva(CLI::App& app, CLI::Transformer& aliases_transformer)
{
	CLI::App* gva = app.add_subcommand("gva", "get the numerical value of an alias")->ignore_case();

	add_transformed_command_option(gva, "alias_name", aliases_transformer)->required();

	return gva;
}

void process_gva(CLI::App* gva)
{
	const std::uint64_t alias_value = get_command_option<std::uint64_t>(gva, "alias_name");

	std::println("alias value: 0x{:X}", alias_value);
}

std::unordered_map<std::string, std::uint64_t> form_aliases()
{
	std::unordered_map<std::string, std::uint64_t> aliases = { { "current_cr3", sys::current_cr3 } };

	for (auto& [module_name, module_info] : sys::kernel::modules_list)
	{
		aliases.insert({ module_name, module_info.base_address });
		aliases.insert(module_info.exports.begin(), module_info.exports.end());
	}

	return aliases;
}

void commands::process(const std::string command)
{
	if (command.empty() == true)
	{
		return;
	}

	CLI::App app;
	app.require_subcommand();

	sys::kernel::parse_modules();

	const std::unordered_map<std::string, std::uint64_t> aliases = form_aliases();

	CLI::Transformer aliases_transformer = CLI::Transformer(aliases, CLI::ignore_case);

	aliases_transformer.description(" can_use_aliases");

	CLI::App* rgpm = init_rgpm(app, aliases_transformer);
	CLI::App* wgpm = init_wgpm(app, aliases_transformer);
	CLI::App* cgpm = init_cgpm(app, aliases_transformer);
	CLI::App* gvat = init_gvat(app, aliases_transformer);
	CLI::App* rgvm = init_rgvm(app, aliases_transformer);
	CLI::App* wgvm = init_wgvm(app, aliases_transformer);
	CLI::App* cgvm = init_cgvm(app, aliases_transformer);
	CLI::App* akh = init_akh(app, aliases_transformer);
	CLI::App* rkh = init_rkh(app, aliases_transformer);
	CLI::App* gva = init_gva(app, aliases_transformer);
	CLI::App* hgpp = init_hgpp(app, aliases_transformer);
	CLI::App* fl = init_fl(app);
	CLI::App* hfpc = init_hfpc(app);
	CLI::App* lkm = init_lkm(app);
	CLI::App* kme = init_kme(app);
	CLI::App* dkm = init_dkm(app);

	try
	{
		app.parse(command);

		d_initial_process_command(rgpm);
		d_process_command(wgpm);
		d_process_command(cgpm);
		d_process_command(gvat);
		d_process_command(rgvm);
		d_process_command(wgvm);
		d_process_command(cgvm);
		d_process_command(akh);
		d_process_command(rkh);
		d_process_command(gva);
		d_process_command(hgpp);
		d_process_command(fl);
		d_process_command(hfpc);
		d_process_command(lkm);
		d_process_command(kme);
		d_process_command(dkm);
	}
	catch (const CLI::ParseError& error)
	{
		app.exit(error);
	}
}


```

`usermode/src/commands/commands.h`:

```h
#pragma once
#include <string>

namespace commands
{
	void process(std::string command);
}

```

`usermode/src/hook/hook.cpp`:

```cpp
#include "hook.h"
#include "kernel_detour_holder.h"
#include "../system/system.h"
#include "../hypercall/hypercall.h"

#include <Windows.h>
#include <print>
#include <vector>
#include <array>
#include <memory_resource>

#include "hook_disassembly.h"

std::uint8_t hook::set_up()
{
	kernel_detour_holder_shadow_page_mapped = static_cast<std::uint8_t*>(sys::user::allocate_locked_memory(0x1000, PAGE_READWRITE));

	if (kernel_detour_holder_shadow_page_mapped == nullptr)
	{
		return 0;
	}

	std::uint64_t shadow_page_physical = hypercall::translate_guest_virtual_address(reinterpret_cast<std::uint64_t>(kernel_detour_holder_shadow_page_mapped), sys::current_cr3);

	if (shadow_page_physical == 0)
	{
		return 0;
	}

	kernel_detour_holder_physical_page = hypercall::translate_guest_virtual_address(kernel_detour_holder_base, sys::current_cr3);

	if (kernel_detour_holder_physical_page == 0)
	{
		return 0;
	}

	// in case of a previously wrongfully ended session which would've left the hook still applied
	hypercall::remove_slat_code_hook(kernel_detour_holder_physical_page);

	hypercall::read_guest_physical_memory(kernel_detour_holder_shadow_page_mapped, kernel_detour_holder_physical_page, 0x1000);

	std::uint64_t hook_status = hypercall::add_slat_code_hook(kernel_detour_holder_physical_page, shadow_page_physical);

	if (hook_status == 0)
	{
		return 0;
	}

	kernel_detour_holder::set_up(reinterpret_cast<std::uint64_t>(kernel_detour_holder_shadow_page_mapped), 0x1000);

	return 1;
}

void hook::clean_up()
{
	for (const auto& [virtual_address, info] : kernel_hook_list)
	{
		remove_kernel_hook(virtual_address, 0);
	}

	kernel_hook_list.clear();

	if (kernel_detour_holder_physical_page != 0)
	{
		hypercall::remove_slat_code_hook(kernel_detour_holder_physical_page);
	}
}

#define d_inline_hook_bytes_size 14

std::pair<std::vector<std::uint8_t>, std::uint64_t> load_original_bytes_into_shadow_page(std::uint8_t* shadow_page_virtual, const std::uint64_t routine_to_hook_virtual, const std::uint8_t is_overflow_hook, const std::uint64_t extra_asm_byte_count)
{
	const std::uint64_t page_offset = routine_to_hook_virtual & 0xFFF;

	hypercall::read_guest_virtual_memory(shadow_page_virtual, routine_to_hook_virtual - page_offset, sys::current_cr3, is_overflow_hook == 1 ? 0x2000 : 0x1000);

	return hook_disasm::get_routine_aligned_bytes(shadow_page_virtual + page_offset, d_inline_hook_bytes_size + extra_asm_byte_count, routine_to_hook_virtual);
}

std::uint8_t set_up_inline_hook(std::uint8_t* shadow_page_virtual, std::uint64_t routine_to_hook_virtual, std::uint64_t routine_to_hook_physical, std::uint64_t detour_address, const std::pair<std::vector<std::uint8_t>, std::uint64_t>& original_bytes, const std::vector<std::uint8_t>& extra_assembled_bytes, const std::vector<uint8_t>& post_original_assembled_bytes, const std::uint8_t is_overflow_hook, std::uint64_t& overflow_shadow_page_physical_address, std::uint64_t& overflow_original_page_physical_address)
{
	std::array<std::uint8_t, d_inline_hook_bytes_size> jmp_to_detour_bytes = {
		0x68, 0x21, 0x43, 0x65, 0x87, // push   0xffffffff87654321
		0xC7, 0x44, 0x24, 0x04, 0x78, 0x56, 0x34, 0x12, // mov    DWORD PTR [rsp+0x4],0x12345678
		0xC3 // ret
	};

	parted_address_t parted_subroutine_to_jmp_to = { .value = detour_address };

	*reinterpret_cast<std::uint32_t*>(&jmp_to_detour_bytes[1]) = parted_subroutine_to_jmp_to.u.low_part;
	*reinterpret_cast<std::uint32_t*>(&jmp_to_detour_bytes[9]) = parted_subroutine_to_jmp_to.u.high_part;

	std::vector<std::uint8_t> inline_hook_bytes = extra_assembled_bytes;

	inline_hook_bytes.insert(inline_hook_bytes.end(), jmp_to_detour_bytes.begin(), jmp_to_detour_bytes.end());

	if (post_original_assembled_bytes.empty() == 0)
	{
		inline_hook_bytes.insert(inline_hook_bytes.end(), post_original_assembled_bytes.begin(), post_original_assembled_bytes.end());

		std::uint64_t nop_bytes_needed = original_bytes.second - inline_hook_bytes.size();

		inline_hook_bytes.insert(inline_hook_bytes.end(), nop_bytes_needed, 0x90); // nop padding until next actual instruction
	}

	const std::uint64_t page_offset = routine_to_hook_physical & 0xFFF;

	if (is_overflow_hook == 1)
	{
		std::uint8_t* overflow_shadow_page_virtual = shadow_page_virtual + 0x1000;

		overflow_shadow_page_physical_address = hypercall::translate_guest_virtual_address(reinterpret_cast<std::uint64_t>(overflow_shadow_page_virtual), sys::current_cr3);

		if (overflow_shadow_page_physical_address == 0)
		{
			return 0;
		}

		const std::uint64_t overflow_page_virtual_address = routine_to_hook_virtual + 0x1000;

		overflow_original_page_physical_address = hypercall::translate_guest_virtual_address(overflow_page_virtual_address, sys::current_cr3);

		if (overflow_original_page_physical_address == 0)
		{
			return 0;
		}

		const std::uint64_t hook_end = page_offset + inline_hook_bytes.size();
		const std::uint64_t bytes_overflowed = hook_end - 0x1000;

		const std::uint64_t prior_page_copy_size = inline_hook_bytes.size() - bytes_overflowed;

		memcpy(shadow_page_virtual + page_offset, inline_hook_bytes.data(), prior_page_copy_size);
		memcpy(overflow_shadow_page_virtual, inline_hook_bytes.data() + prior_page_copy_size, bytes_overflowed);
	}
	else
	{
		memcpy(shadow_page_virtual + page_offset, inline_hook_bytes.data(), inline_hook_bytes.size());
	}

	return 1;
}

std::uint8_t set_up_hook_handler(std::uint64_t routine_to_hook_virtual, std::uint16_t& detour_holder_shadow_offset, const std::pair<std::vector<std::uint8_t>, std::uint64_t>& original_bytes, const std::vector<uint8_t>& extra_assembled_bytes, const std::vector<uint8_t>& post_original_assembled_bytes)
{
	std::array<std::uint8_t, 14> return_to_original_bytes = {
		0x68, 0x21, 0x43, 0x65, 0x87, // push   0xffffffff87654321
		0xC7, 0x44, 0x24, 0x04, 0x78, 0x56, 0x34, 0x12, // mov    DWORD PTR [rsp+0x4],0x12345678
		0xC3 // ret
	};

	parted_address_t parted_subroutine_to_jmp_to = { };

	if (post_original_assembled_bytes.empty() == 0)
	{
		parted_subroutine_to_jmp_to.value = routine_to_hook_virtual + extra_assembled_bytes.size() + d_inline_hook_bytes_size;
	}
	else
	{
		parted_subroutine_to_jmp_to.value = routine_to_hook_virtual + original_bytes.second;
	}

	*reinterpret_cast<std::uint32_t*>(&return_to_original_bytes[1]) = parted_subroutine_to_jmp_to.u.low_part;
	*reinterpret_cast<std::uint32_t*>(&return_to_original_bytes[9]) = parted_subroutine_to_jmp_to.u.high_part;

	std::vector<std::uint8_t> hook_handler_bytes = original_bytes.first;

	hook_handler_bytes.insert(hook_handler_bytes.end(), return_to_original_bytes.begin(), return_to_original_bytes.end());

	void* bytes_buffer = kernel_detour_holder::allocate_memory(static_cast<std::uint16_t>(hook_handler_bytes.size()));

	if (bytes_buffer == nullptr)
	{
		return 0;
	}

	detour_holder_shadow_offset = kernel_detour_holder::get_allocation_offset(bytes_buffer);

	memcpy(bytes_buffer, hook_handler_bytes.data(), hook_handler_bytes.size());

	return 1;
}

std::uint8_t hook::add_kernel_hook(std::uint64_t routine_to_hook_virtual, const std::vector<std::uint8_t>& extra_assembled_bytes, const std::vector<uint8_t>& post_original_assembled_bytes)
{
	if (kernel_hook_list.contains(routine_to_hook_virtual) == true)
	{
		return 0;
	}

	std::uint64_t routine_to_hook_physical = hypercall::translate_guest_virtual_address(routine_to_hook_virtual, sys::current_cr3);

	if (routine_to_hook_physical == 0)
	{
		return 0;
	}

	const std::uint64_t page_offset = routine_to_hook_physical & 0xFFF;
	const std::uint64_t hook_end = page_offset + d_inline_hook_bytes_size + extra_assembled_bytes.size();

	const std::uint8_t is_overflow_hook = 0x1000 < hook_end;

	void* shadow_page_virtual = sys::user::allocate_locked_memory(is_overflow_hook == 1 ? 0x2000 : 0x1000, PAGE_READWRITE);

	if (shadow_page_virtual == nullptr)
	{
		return 0;
	}

	std::uint64_t shadow_page_physical = hypercall::translate_guest_virtual_address(reinterpret_cast<std::uint64_t>(shadow_page_virtual), sys::current_cr3);

	if (shadow_page_physical == 0)
	{
		return 0;
	}

	std::pair<std::vector<std::uint8_t>, std::uint64_t> original_bytes = load_original_bytes_into_shadow_page(static_cast<std::uint8_t*>(shadow_page_virtual), routine_to_hook_virtual, is_overflow_hook, extra_assembled_bytes.size() + post_original_assembled_bytes.size());

	if (original_bytes.first.empty() == true)
	{
		return 0;
	}

	std::uint16_t detour_holder_shadow_offset = 0;

	std::uint8_t status = set_up_hook_handler(routine_to_hook_virtual, detour_holder_shadow_offset, original_bytes, extra_assembled_bytes, post_original_assembled_bytes);

	if (status == 0)
	{
		return 0;
	}

	std::uint64_t detour_address = kernel_detour_holder_base + detour_holder_shadow_offset;

	std::uint64_t overflow_shadow_page_physical_address = 0;
	std::uint64_t overflow_original_page_physical_address = 0;

	std::uint64_t hook_status = set_up_inline_hook(static_cast<std::uint8_t*>(shadow_page_virtual), routine_to_hook_virtual, routine_to_hook_physical, detour_address, original_bytes, extra_assembled_bytes, post_original_assembled_bytes, is_overflow_hook, overflow_shadow_page_physical_address, overflow_original_page_physical_address);

	if (hook_status == 0)
	{
		return 0;
	}

	hook_status = hypercall::add_slat_code_hook(routine_to_hook_physical, shadow_page_physical);

	if (hook_status == 0)
	{
		return 0;
	}

	if (overflow_shadow_page_physical_address != 0)
	{
		hook_status = hypercall::add_slat_code_hook(overflow_original_page_physical_address, overflow_shadow_page_physical_address);

		if (hook_status == 0)
		{
			return 0;
		}
	}

	kernel_hook_info_t hook_info = { };

	hook_info.set_mapped_shadow_page(shadow_page_virtual);
	hook_info.original_page_pfn = routine_to_hook_physical >> 12;
	hook_info.overflow_original_page_pfn = overflow_original_page_physical_address >> 12;
	hook_info.detour_holder_shadow_offset = detour_holder_shadow_offset;
	
	kernel_hook_list[routine_to_hook_virtual] = hook_info;

	return 1;
}

std::uint8_t hook::remove_kernel_hook(std::uint64_t hooked_routine_virtual, std::uint8_t do_list_erase)
{
	if (kernel_hook_list.contains(hooked_routine_virtual) == false)
	{
		std::println("unable to find kernel hook");

		return 0;
	}

	kernel_hook_info_t hook_info = kernel_hook_list[hooked_routine_virtual];

	if (hypercall::remove_slat_code_hook(hook_info.original_page_pfn << 12) == 0)
	{
		std::println("unable to remove slat counterpart of kernel hook");

		return 0;
	}

	if (hook_info.overflow_original_page_pfn != 0 && hypercall::remove_slat_code_hook(hook_info.overflow_original_page_pfn << 12) == 0)
	{
		std::println("unable to remove slat counterpart of kernel hook (2)");

		return 0;
	}

	if (do_list_erase == 1)
	{
		kernel_hook_list.erase(hooked_routine_virtual);
	}

	void* detour_holder_allocation = kernel_detour_holder::get_allocation_from_offset(hook_info.detour_holder_shadow_offset);

	kernel_detour_holder::free_memory(detour_holder_allocation);

	if (sys::user::free_memory(hook_info.get_mapped_shadow_page()) == 0)
	{
		std::println("unable to deallocate mapped shadow page");

		return 0;
	}

	return 1;
}

```

`usermode/src/hook/hook.h`:

```h
#pragma once
#include <cstdint>
#include <vector>
#include <unordered_map>

namespace hook
{
	std::uint8_t set_up();
	void clean_up();

	std::uint8_t add_kernel_hook(std::uint64_t routine_to_hook_virtual, const std::vector<std::uint8_t>& extra_assembled_bytes, const std::vector<uint8_t>& post_original_assembled_bytes);
	std::uint8_t remove_kernel_hook(std::uint64_t hooked_routine_virtual, std::uint8_t do_list_erase);

	struct kernel_hook_info_t
	{
		std::uint64_t original_page_pfn : 36;
		std::uint64_t overflow_original_page_pfn : 36;
		std::uint64_t mapped_shadow_page : 48;
		std::uint64_t detour_holder_shadow_offset : 16;
		std::uint64_t reserved : 56;

		void* get_mapped_shadow_page() const
		{
			return reinterpret_cast<void*>(this->mapped_shadow_page);
		}

		void set_mapped_shadow_page(void* pointer)
		{
			this->mapped_shadow_page = reinterpret_cast<std::uint64_t>(pointer);
		}
	};

	inline std::unordered_map<std::uint64_t, kernel_hook_info_t> kernel_hook_list = { };

	inline std::uint64_t kernel_detour_holder_base = 0;
	inline std::uint64_t kernel_detour_holder_physical_page = 0;
	inline std::uint8_t* kernel_detour_holder_shadow_page_mapped = nullptr;
}

```

`usermode/src/hook/hook_disassembly.cpp`:

```cpp
#include "hook_disassembly.h"

#include <Zydis/Zydis.h>
#include <array>
#include <optional>
#include <print>
#include <vector>

ZydisDecoder make_zydis_decoder()
{
	ZydisDecoder decoder = { };

	ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_STACK_WIDTH_64);

	return decoder;
}

std::uint8_t decode_instruction(const ZydisDecoder* decoder, ZydisDecoderContext* decoder_context, ZydisDecodedInstruction* decoded_instruction, const std::uint8_t* instruction)
{
	ZyanStatus status = ZydisDecoderDecodeInstruction(decoder, decoder_context, instruction, ZYDIS_MAX_INSTRUCTION_LENGTH, decoded_instruction);

	return ZYAN_SUCCESS(status) == 1;
}

std::uint8_t decode_operands(const ZydisDecoder* decoder, const ZydisDecoderContext* decoder_context, const ZydisDecodedInstruction* decoded_instruction, std::array<ZydisDecodedOperand, ZYDIS_MAX_OPERAND_COUNT>& operands)
{
	ZyanStatus status = ZydisDecoderDecodeOperands(decoder, decoder_context, decoded_instruction, operands.data(), static_cast<ZyanU8>(operands.size()));

	return ZYAN_SUCCESS(status) == 1;
}

std::uint8_t get_instruction_length(const ZydisDecodedInstruction& decoded_instruction)
{
	return decoded_instruction.length;
}

std::vector<std::uint8_t> do_push(std::uint64_t value)
{
	std::vector<std::uint8_t> bytes = {
		0x68, 0x21, 0x43, 0x65, 0x87, // push   0xffffffff87654321
		0xC7, 0x44, 0x24, 0x04, 0x78, 0x56, 0x34, 0x12, // mov    DWORD PTR [rsp+0x4],0x12345678
	};

	parted_address_t push_value_parted = { .value = value };

	*reinterpret_cast<std::uint32_t*>(&bytes[1]) = push_value_parted.u.low_part;
	*reinterpret_cast<std::uint32_t*>(&bytes[9]) = push_value_parted.u.high_part;

	return bytes;
}

std::vector<std::uint8_t> do_rip_relative_push(std::uint32_t offset)
{
	std::vector<std::uint8_t> bytes = {
		0xE8, 0x00, 0x00, 0x00, 0x00, // call $+5
		0x48, 0x81, 0x04, 0x24, 0x78, 0x56, 0x34, 0x12 // add QWORD PTR [rsp],0x12345678
	};

	*reinterpret_cast<std::uint32_t*>(&bytes[9]) = offset - 5;

	return bytes;
}

std::vector<std::uint8_t> add_rsp(std::int32_t offset)
{
	std::vector<std::uint8_t> bytes = {
		0x48, 0x81, 0xC4, 0x78, 0x56, 0x34, 0x12 // add    rsp,0x12345678
	};

	*reinterpret_cast<std::int32_t*>(&bytes[3]) = offset;

	return bytes;
}

std::vector<std::uint8_t> do_jmp(std::uint64_t address_to_jmp)
{
	std::vector<std::uint8_t> bytes = do_push(address_to_jmp);

	bytes.insert(bytes.end(), 0xC3); // ret

	return bytes;
}

std::vector<std::uint8_t> do_relative_jmp(std::int32_t offset)
{
	std::vector<std::uint8_t> bytes = { 0xE9, 0x00, 0x00, 0x00, 0x00 };

	*reinterpret_cast<std::int32_t*>(&bytes[1]) = offset;

	return bytes;
}

std::vector<std::uint8_t> do_call(std::uint64_t address_to_call)
{
	std::vector<std::uint8_t> bytes = do_jmp(address_to_call);

	// insert return address
	std::vector<std::uint8_t> return_address_push = do_rip_relative_push(0); // placeholder to see the size of push

	return_address_push = do_rip_relative_push(static_cast<std::uint32_t>(bytes.size() + return_address_push.size()));

	bytes.insert(bytes.begin(), return_address_push.begin(), return_address_push.end());

	return bytes;
}

// all of below are rel32 when applicable
constexpr std::array<ZydisMnemonic, 22> jcc_instructions = {
	ZYDIS_MNEMONIC_JB,
	ZYDIS_MNEMONIC_JBE,
	ZYDIS_MNEMONIC_JCXZ,
	ZYDIS_MNEMONIC_JECXZ,
	ZYDIS_MNEMONIC_JKNZD,
	ZYDIS_MNEMONIC_JKZD,
	ZYDIS_MNEMONIC_JL,
	ZYDIS_MNEMONIC_JLE,
	ZYDIS_MNEMONIC_JNB,
	ZYDIS_MNEMONIC_JNBE,
	ZYDIS_MNEMONIC_JNL,
	ZYDIS_MNEMONIC_JNLE,
	ZYDIS_MNEMONIC_JNO,
	ZYDIS_MNEMONIC_JNP,
	ZYDIS_MNEMONIC_JNS,
	ZYDIS_MNEMONIC_JNZ,
	ZYDIS_MNEMONIC_JO,
	ZYDIS_MNEMONIC_JP,
	ZYDIS_MNEMONIC_JRCXZ,
	ZYDIS_MNEMONIC_JS,
	ZYDIS_MNEMONIC_JZ
};

std::uint8_t is_jcc_instruction(const ZydisDecodedInstruction& decoded_instruction)
{
	return std::ranges::find(jcc_instructions, decoded_instruction.mnemonic) != jcc_instructions.end();
}

std::vector<std::uint8_t> encode_instruction(const ZydisEncoderRequest* encoder_request)
{
	std::array<std::uint8_t, ZYDIS_MAX_INSTRUCTION_LENGTH> encoded_instruction = { };

	std::uint64_t encoded_instruction_size = sizeof(encoded_instruction);

	ZyanStatus status = ZydisEncoderEncodeInstruction(encoder_request, encoded_instruction.data(), &encoded_instruction_size);

	if (ZYAN_SUCCESS(status) == 0)
	{
		return { };
	}

	return { encoded_instruction.data(), encoded_instruction.data() + encoded_instruction_size };
}

constexpr std::array<ZydisRegister, 16> general_purpose_registers = {
	ZYDIS_REGISTER_RAX,
	ZYDIS_REGISTER_RCX,
	ZYDIS_REGISTER_RDX,
	ZYDIS_REGISTER_RBX,
	ZYDIS_REGISTER_RSP,
	ZYDIS_REGISTER_RBP,
	ZYDIS_REGISTER_RSI,
	ZYDIS_REGISTER_RDI,
	ZYDIS_REGISTER_R8,
	ZYDIS_REGISTER_R9,
	ZYDIS_REGISTER_R10,
	ZYDIS_REGISTER_R11,
	ZYDIS_REGISTER_R12,
	ZYDIS_REGISTER_R13,
	ZYDIS_REGISTER_R14,
	ZYDIS_REGISTER_R15
};

void remove_register_from_list(std::vector<ZydisRegister>& unused_registers, const ZydisRegister register_used)
{
	auto found = std::ranges::find(unused_registers, register_used);

	if (found != unused_registers.end())
	{
		unused_registers.erase(found);
	}
}

std::vector<ZydisRegister> find_unused_general_purpose_registers(const ZydisDecodedInstruction& decoded_instruction, const std::array<ZydisDecodedOperand, ZYDIS_MAX_OPERAND_COUNT>& operands)
{
	std::vector<ZydisRegister> unused_registers = { general_purpose_registers.begin(), general_purpose_registers.end() };

	for (std::uint64_t i = 0; i < decoded_instruction.operand_count; i++)
	{
		const ZydisDecodedOperand& current_operand = operands[i];

		if (current_operand.type == ZYDIS_OPERAND_TYPE_REGISTER)
		{
			remove_register_from_list(unused_registers, current_operand.reg.value);
		}
		else if (current_operand.type == ZYDIS_OPERAND_TYPE_MEMORY)
		{
			remove_register_from_list(unused_registers, current_operand.mem.base);
			remove_register_from_list(unused_registers, current_operand.mem.index);
		}
	}

	return unused_registers;
}

std::vector<std::uint8_t> do_stack_register_operation(ZydisMnemonic mnemonic, ZydisRegister register_involved)
{
	ZydisEncoderRequest encoder_request = { };

	encoder_request.machine_mode = ZYDIS_MACHINE_MODE_LONG_64;
	encoder_request.mnemonic = mnemonic;

	encoder_request.operands[0].type = ZYDIS_OPERAND_TYPE_REGISTER;
	encoder_request.operands[0].reg.value = register_involved;

	encoder_request.operand_count = 1;

	return encode_instruction(&encoder_request);
}

std::vector<std::uint8_t> do_mov_to_register_64(ZydisRegister register_involved, std::uint64_t value)
{
	ZydisEncoderRequest encoder_request = { };

	encoder_request.machine_mode = ZYDIS_MACHINE_MODE_LONG_64;
	encoder_request.mnemonic = ZYDIS_MNEMONIC_MOV;

	encoder_request.operands[0].type = ZYDIS_OPERAND_TYPE_REGISTER;
	encoder_request.operands[0].reg.value = register_involved;

	encoder_request.operands[1].type = ZYDIS_OPERAND_TYPE_IMMEDIATE;
	encoder_request.operands[1].imm.u = value;

	encoder_request.operand_count = 2;

	return encode_instruction(&encoder_request);
}

std::vector<std::uint8_t> do_register_push(ZydisRegister pushable_register)
{
	return do_stack_register_operation(ZYDIS_MNEMONIC_PUSH, pushable_register);
}

std::vector<std::uint8_t> do_register_pop(ZydisRegister pushable_register)
{
	return do_stack_register_operation(ZYDIS_MNEMONIC_POP, pushable_register);
}

// this should only be used on instructions that do not modify the rip, as we use more efficient ways to fix those
std::uint8_t fix_rip_relative_operand(std::vector<std::uint8_t>& instruction_bytes, const ZydisDecodedInstruction& decoded_instruction, const std::pair<std::uint64_t, std::uint64_t>& rip_relative_operand, const std::array<ZydisDecodedOperand, ZYDIS_MAX_OPERAND_COUNT>& operands)
{
	std::vector<ZydisRegister> unused_registers = find_unused_general_purpose_registers(decoded_instruction, operands);

	if (unused_registers.empty() == 1)
	{
		return 0;
	}

	const ZydisRegister usable_register = unused_registers[0];

	std::vector<std::uint8_t> pre_bytes = do_register_push(usable_register);
	std::vector<std::uint8_t> post_bytes = do_register_pop(usable_register);

	ZydisEncoderRequest encoder_request = { };

	ZyanStatus status = ZydisEncoderDecodedInstructionToEncoderRequest(&decoded_instruction, operands.data(), decoded_instruction.operand_count_visible, &encoder_request);

	if (ZYAN_SUCCESS(status) == 0)
	{
		return 0;
	}

	const std::uint64_t absolute_address = rip_relative_operand.second;

	if (absolute_address != 0)
	{
		auto& operand = encoder_request.operands[rip_relative_operand.first];
		auto& memory_operand = operand.mem;

		const std::vector<std::uint8_t> mov_bytes = do_mov_to_register_64(usable_register, absolute_address);

		pre_bytes.insert(pre_bytes.end(), mov_bytes.begin(), mov_bytes.end());

		operand.type = ZYDIS_OPERAND_TYPE_MEMORY;

		memory_operand.base = usable_register;
		memory_operand.displacement = 0;
	}

	instruction_bytes = encode_instruction(&encoder_request);

	instruction_bytes.insert(instruction_bytes.begin(), pre_bytes.begin(), pre_bytes.end());
	instruction_bytes.insert(instruction_bytes.end(), post_bytes.begin(), post_bytes.end());

	return 1;
}

std::uint8_t encode_rel8_instruction_as_rel32(std::vector<std::uint8_t>& instruction_bytes, const ZydisDecodedInstruction& decoded_instruction, const std::array<ZydisDecodedOperand, ZYDIS_MAX_OPERAND_COUNT>& operands)
{
	ZydisEncoderRequest encoder_request = { };

	ZyanStatus status = ZydisEncoderDecodedInstructionToEncoderRequest(&decoded_instruction, operands.data(), decoded_instruction.operand_count_visible, &encoder_request);

	if (ZYAN_SUCCESS(status) == 0)
	{
		return 0;
	}

	encoder_request.branch_type = ZYDIS_BRANCH_TYPE_NEAR;
	encoder_request.branch_width = ZYDIS_BRANCH_WIDTH_32;

	instruction_bytes = encode_instruction(&encoder_request);

	return 1;
}

std::vector<std::uint8_t> load_instruction_bytes(const ZydisDecoder& decoder, const ZydisDecoderContext& decoder_context, const ZydisDecodedInstruction& decoded_instruction, std::uint8_t* instruction, std::uint64_t instruction_runtime_address, std::uint64_t original_instruction_length, std::uint64_t instruction_aligned_bytes_offset, std::uint64_t routine_runtime_start, std::vector<std::pair<std::uint64_t, std::uint64_t>>& jcc_jumps, std::vector<std::tuple<std::uint64_t, std::uint64_t, std::uint64_t>>& rip_altering_instructions)
{
	std::vector<std::uint8_t> instruction_bytes = { instruction, instruction + original_instruction_length };

	const std::uint8_t is_relative = (decoded_instruction.attributes & ZYDIS_ATTRIB_IS_RELATIVE) != 0;

	if (is_relative == 1)
	{
		std::array<ZydisDecodedOperand, ZYDIS_MAX_OPERAND_COUNT> operands = { };
		std::uint8_t status = decode_operands(&decoder, &decoder_context, &decoded_instruction, operands);

		if (status == 1)
		{
			// pair<operand_index, absolute_address>
			std::optional<std::pair<std::uint64_t, std::uint64_t>> rip_relative_operand = std::nullopt;

			for (std::uint64_t i = 0; i < decoded_instruction.operand_count; i++)
			{
				const ZydisDecodedOperand& current_operand = operands[i];

				if ((current_operand.type == ZYDIS_OPERAND_TYPE_MEMORY && current_operand.mem.base == ZYDIS_REGISTER_RIP) || (current_operand.type == ZYDIS_OPERAND_TYPE_IMMEDIATE && current_operand.imm.is_relative == 1))
				{
					std::uint64_t absolute_address = 0;

					status = ZYAN_SUCCESS(ZydisCalcAbsoluteAddress(&decoded_instruction, &current_operand, instruction_runtime_address, &absolute_address));

					if (status == 1)
					{
						rip_relative_operand = { i, absolute_address };

						break;
					}
				}
			}

			if (rip_relative_operand.has_value() == 1)
			{
				const auto& rip_relative_operand_info = rip_relative_operand.value();

				const std::uint64_t absolute_location = rip_relative_operand_info.second;

				if (is_jcc_instruction(decoded_instruction) == 1)
				{
					if (original_instruction_length == 2)
					{
						std::uint8_t encode_status = encode_rel8_instruction_as_rel32(instruction_bytes, decoded_instruction, operands);

						if (encode_status == 0)
						{
							std::println("failed to re-encode jcc instruction");
						}
					}

					jcc_jumps.emplace_back(instruction_aligned_bytes_offset, absolute_location);
					rip_altering_instructions.emplace_back(instruction_aligned_bytes_offset, absolute_location, 0);
				}
				else if (decoded_instruction.mnemonic == ZYDIS_MNEMONIC_JMP || decoded_instruction.mnemonic == ZYDIS_MNEMONIC_CALL)
				{
					// todo: find real relative jmp after now obviously we expand stuff
					if (decoded_instruction.mnemonic == ZYDIS_MNEMONIC_JMP && (instruction[0] == 0xE9 || instruction[0] == 0xEB))
					{
						instruction_bytes = do_jmp(absolute_location);
					}
					else if (decoded_instruction.mnemonic == ZYDIS_MNEMONIC_CALL && instruction[0] == 0xE8)
					{
						instruction_bytes = do_call(absolute_location);
					}

					rip_altering_instructions.emplace_back(instruction_aligned_bytes_offset, absolute_location, 0);
				}
				else
				{
					fix_rip_relative_operand(instruction_bytes, decoded_instruction, rip_relative_operand_info, operands);
				}

				for (auto& [inst_aligned_bytes_offset, inst_calculated_absolute_address, inst_offset] : rip_altering_instructions)
				{
					if (instruction_aligned_bytes_offset == inst_aligned_bytes_offset || inst_calculated_absolute_address < (routine_runtime_start + inst_aligned_bytes_offset))
					{
						continue;
					}

					inst_offset += instruction_bytes.size() - original_instruction_length;
				}
			}
		}
	}

	return instruction_bytes;
}

void add_offset_to_instruction(const ZydisDecoder* decoder, std::uint8_t* current_instruction, std::int32_t offset)
{
	ZydisDecoderContext decoder_context = { };

	ZydisDecodedInstruction decoded_instruction = { };

	std::uint8_t status = decode_instruction(decoder, &decoder_context, &decoded_instruction, current_instruction);

	if (status == 0)
	{
		return;
	}

	std::array<ZydisDecodedOperand, ZYDIS_MAX_OPERAND_COUNT> operands = { };

	status = decode_operands(decoder, &decoder_context, &decoded_instruction, operands);

	if (status == 0)
	{
		return;
	}

	ZydisEncoderRequest encoder_request = { };

	status = ZYAN_SUCCESS(ZydisEncoderDecodedInstructionToEncoderRequest(&decoded_instruction, operands.data(), decoded_instruction.operand_count_visible, &encoder_request));

	if (status == 0)
	{
		return;
	}

	auto& operand = encoder_request.operands[0];

	if (operand.type == ZYDIS_OPERAND_TYPE_MEMORY)
	{
		operand.mem.displacement += offset;
	}
	else if (operand.type == ZYDIS_OPERAND_TYPE_IMMEDIATE)
	{
		operand.imm.s += offset;
	}

	std::vector<std::uint8_t> instruction_bytes = encode_instruction(&encoder_request);

	memcpy(current_instruction, instruction_bytes.data(), instruction_bytes.size());
}

void fix_rip_altering_instructions(const ZydisDecoder* decoder, std::vector<std::uint8_t>& aligned_bytes, const std::vector<std::tuple<std::uint64_t, std::uint64_t, std::uint64_t>>& rip_altering_instructions, const std::uint64_t routine_runtime_address)
{
	for (auto& [inst_aligned_bytes_offset, inst_calculated_absolute_address, inst_offset] : rip_altering_instructions)
	{
		if (routine_runtime_address + aligned_bytes.size() < inst_calculated_absolute_address)
		{
			continue;
		}

		add_offset_to_instruction(decoder, &aligned_bytes[inst_aligned_bytes_offset], static_cast<std::int32_t>(inst_offset));
	}
}

void make_jcc_patches(std::vector<std::uint8_t>& aligned_bytes, const std::vector<std::pair<std::uint64_t, std::uint64_t>>& jcc_jumps, const std::uint64_t routine_runtime_address)
{
	if (jcc_jumps.empty() == 1)
	{
		return;
	}

	std::uint64_t bytes_added = 0;

	for (auto& [instruction_aligned_bytes_offset, jmp_address] : jcc_jumps)
	{
		std::vector<std::uint8_t> bytes = do_jmp(jmp_address);

		aligned_bytes.insert(aligned_bytes.begin(), bytes.begin(), bytes.end());

		bytes_added += bytes.size();

		constexpr std::int64_t jcc_rel32_instruction_length = 6;

		std::int32_t rip_change = static_cast<std::int32_t>(-jcc_rel32_instruction_length - bytes_added - instruction_aligned_bytes_offset);

		*reinterpret_cast<std::int32_t*>(&aligned_bytes[instruction_aligned_bytes_offset + bytes_added + 2]) = rip_change;
	}

	// calculate instruction size
	std::vector<std::uint8_t> stub_pass_bytes = do_relative_jmp(0);

	std::int32_t relative_jmp_offset = static_cast<std::int32_t>(bytes_added);

	stub_pass_bytes = do_relative_jmp(relative_jmp_offset);

	aligned_bytes.insert(aligned_bytes.begin(), stub_pass_bytes.begin(), stub_pass_bytes.end());
}

std::pair<std::vector<std::uint8_t>, std::uint64_t> hook_disasm::get_routine_aligned_bytes(std::uint8_t* routine, const std::uint64_t minimum_size, const std::uint64_t routine_runtime_address)
{
	std::vector<std::pair<std::uint64_t, std::uint64_t>> jcc_jumps = { };
	std::vector<std::tuple<std::uint64_t, std::uint64_t, std::uint64_t>> rip_altering_instructions = { };

	ZydisDecoder decoder = make_zydis_decoder();

	std::vector<std::uint8_t> aligned_bytes = { };

	std::uint8_t* current_instruction = routine;
	std::uint64_t original_routine_bytes_copied = 0;

	while (original_routine_bytes_copied < minimum_size)
	{
		ZydisDecoderContext decoder_context = { };

		ZydisDecodedInstruction decoded_instruction = { };

		std::uint8_t decode_status = decode_instruction(&decoder, &decoder_context, &decoded_instruction, current_instruction);

		if (decode_status == 0)
		{
			break;
		}

		std::uint8_t original_instruction_length = get_instruction_length(decoded_instruction);

		std::uint64_t instruction_runtime_address = routine_runtime_address + original_routine_bytes_copied;

		std::vector<std::uint8_t> instruction_bytes = load_instruction_bytes(decoder, decoder_context, decoded_instruction, current_instruction, instruction_runtime_address, original_instruction_length, aligned_bytes.size(), routine_runtime_address, jcc_jumps, rip_altering_instructions);

		aligned_bytes.insert(aligned_bytes.end(), instruction_bytes.begin(), instruction_bytes.end());

		current_instruction += original_instruction_length;
		original_routine_bytes_copied += original_instruction_length;
	}

	fix_rip_altering_instructions(&decoder, aligned_bytes, rip_altering_instructions, routine_runtime_address);
	make_jcc_patches(aligned_bytes, jcc_jumps, routine_runtime_address);

	return { aligned_bytes, original_routine_bytes_copied };
}

```

`usermode/src/hook/hook_disassembly.h`:

```h
#pragma once
#include <vector>

union parted_address_t
{
	struct
	{
		std::uint32_t low_part;
		std::uint32_t high_part;
	} u;

	std::uint64_t value;
};

namespace hook_disasm
{
	std::pair<std::vector<std::uint8_t>, std::uint64_t> get_routine_aligned_bytes(std::uint8_t* routine, std::uint64_t minimum_size, std::uint64_t routine_runtime_address);
}

```

`usermode/src/hook/kernel_detour_holder.cpp`:

```cpp
#include "kernel_detour_holder.h"

void kernel_detour_holder::set_up(std::uint64_t holder_base, std::uint64_t holder_size)
{
	list_head = reinterpret_cast<detour_entry_t*>(holder_base);

	list_head->size = static_cast<std::uint16_t>(holder_size - sizeof(detour_entry_t));
	list_head->is_allocated = 0;

	holder_end = holder_base + holder_size;
}

void* kernel_detour_holder::allocate_memory(const std::uint16_t size)
{
	detour_entry_t* entry = list_head;

	detour_entry_t* best_split = nullptr;

	while (entry != nullptr)
	{
		if (entry->is_allocated == 0)
		{
			if (entry->size == size)
			{
				entry->is_allocated = 1;

				return ++entry;
			}

			if (size + sizeof(detour_entry_t) < entry->size)
			{
				if (best_split == nullptr || entry->size < best_split->size)
				{
					best_split = entry;
				}
			}
		}

		entry = entry->get_next();
	}

	if (best_split != nullptr)
	{
		detour_entry_t* split_entry = best_split->split(size);

		if (split_entry != nullptr)
		{
			return ++split_entry;
		}
	}

	return nullptr;
}

std::uint16_t kernel_detour_holder::get_allocation_offset(void* pointer)
{
	std::uint64_t base = reinterpret_cast<std::uint64_t>(list_head);
	std::uint64_t allocation = reinterpret_cast<std::uint64_t>(pointer);

	std::uint16_t offset = static_cast<std::uint16_t>(allocation - base);

	return offset;
}

void* kernel_detour_holder::get_allocation_from_offset(std::uint16_t offset)
{
	std::uint64_t base = reinterpret_cast<std::uint64_t>(list_head);
	std::uint64_t allocation = base + offset;

	return reinterpret_cast<void*>(allocation);
}

void try_merge_of_next_entry(kernel_detour_holder::detour_entry_t* current_entry)
{
	kernel_detour_holder::detour_entry_t* next = current_entry->get_next();

	if (next != nullptr && next->is_allocated == 0)
	{
		current_entry->size = next->size + sizeof(kernel_detour_holder::detour_entry_t);
	}
}

void kernel_detour_holder::free_memory(void* allocation_base)
{
	if (allocation_base == nullptr)
	{
		return;
	}

	detour_entry_t* entry = static_cast<detour_entry_t*>(allocation_base) - 1;

	entry->is_allocated = 0;

	try_merge_of_next_entry(entry);
}

kernel_detour_holder::detour_entry_t* kernel_detour_holder::detour_entry_t::get_next()
{
	std::uint64_t next_entry = reinterpret_cast<std::uint64_t>(this + 1) + this->size;

	if (holder_end <= next_entry)
	{
		return nullptr;
	}

	return reinterpret_cast<detour_entry_t*>(next_entry);
}

// note for future: if we ever need any size above 0x1000 (at the time of writing, we do not)
// then we will start changing the shrink direction by the size
// if the allocation is less than or equal to 4kb, then it will be shrank from 1 direction,
// if its bigger than 4kb, then it will shrink from the other direction
// this will allow us to manage the memory better, so when we search for deallocated entries of the same size,
// we wont have to search as far
kernel_detour_holder::detour_entry_t* kernel_detour_holder::detour_entry_t::split(std::uint16_t size_of_next_entry)
{
	std::uint16_t needed_size = size_of_next_entry + sizeof(detour_entry_t);

	if (this->is_allocated == 1 || this->size <= needed_size)
	{
		return nullptr;
	}

	this->size -= needed_size;

	detour_entry_t* next_entry = this->get_next();

	next_entry->is_allocated = 1;
	next_entry->size = size_of_next_entry;

	return next_entry;
}
```

`usermode/src/hook/kernel_detour_holder.h`:

```h
#pragma once
#include <cstdint>

namespace kernel_detour_holder
{
	void set_up(std::uint64_t holder_base, std::uint64_t holder_size);

	void* allocate_memory(std::uint16_t size);
	void free_memory(void* pointer);

	std::uint16_t get_allocation_offset(void* pointer);
	void* get_allocation_from_offset(std::uint16_t offset);

	union detour_entry_t
	{
		std::uint16_t value;

		struct
		{
			std::uint16_t size : 15;
			std::uint16_t is_allocated : 1;
		};

		detour_entry_t* get_next();
		detour_entry_t* split(std::uint16_t size_of_next_entry);
	};

	inline detour_entry_t* list_head = 0;
	inline std::uint64_t holder_end = 0;
}
```

`usermode/src/hypercall/hypercall.cpp`:

```cpp
#include "hypercall.h"
#include <hypercall/hypercall_def.h>

extern "C" std::uint64_t launch_raw_hypercall(hypercall_info_t rcx, std::uint64_t rdx, std::uint64_t r8, std::uint64_t r9);

std::uint64_t make_hypercall(hypercall_type_t call_type, std::uint64_t call_reserved_data, std::uint64_t rdx, std::uint64_t r8, std::uint64_t r9)
{
	hypercall_info_t hypercall_info = { };

	hypercall_info.primary_key = hypercall_primary_key;
	hypercall_info.secondary_key = hypercall_secondary_key;
	hypercall_info.call_type = call_type;
	hypercall_info.call_reserved_data = call_reserved_data;

	return launch_raw_hypercall(hypercall_info, rdx, r8, r9);
}

std::uint64_t hypercall::read_guest_physical_memory(void* guest_destination_buffer, std::uint64_t guest_source_physical_address, std::uint64_t size)
{
	hypercall_type_t call_type = hypercall_type_t::guest_physical_memory_operation;

	std::uint64_t call_data = static_cast<std::uint64_t>(memory_operation_t::read_operation);

	std::uint64_t guest_destination_virtual_address = reinterpret_cast<std::uint64_t>(guest_destination_buffer);

	return make_hypercall(call_type, call_data, guest_source_physical_address, guest_destination_virtual_address, size);
}

std::uint64_t hypercall::write_guest_physical_memory(void* guest_source_buffer, std::uint64_t guest_destination_physical_address, std::uint64_t size)
{
	hypercall_type_t call_type = hypercall_type_t::guest_physical_memory_operation;

	std::uint64_t call_data = static_cast<std::uint64_t>(memory_operation_t::write_operation);

	std::uint64_t guest_source_virtual_address = reinterpret_cast<std::uint64_t>(guest_source_buffer);

	return make_hypercall(call_type, call_data, guest_destination_physical_address, guest_source_virtual_address, size);
}

std::uint64_t hypercall::read_guest_virtual_memory(void* guest_destination_buffer, std::uint64_t guest_source_virtual_address, std::uint64_t source_cr3, std::uint64_t size)
{
	virt_memory_op_hypercall_info_t memory_op_call = { };

	memory_op_call.call_type = hypercall_type_t::guest_virtual_memory_operation;
	memory_op_call.memory_operation = memory_operation_t::read_operation;
	memory_op_call.address_of_page_directory = source_cr3 >> 12;

	hypercall_info_t hypercall_info = { .value = memory_op_call.value };

	std::uint64_t guest_destination_virtual_address = reinterpret_cast<std::uint64_t>(guest_destination_buffer);

	return make_hypercall(hypercall_info.call_type, hypercall_info.call_reserved_data, guest_destination_virtual_address, guest_source_virtual_address, size);
}

std::uint64_t hypercall::write_guest_virtual_memory(void* guest_source_buffer, std::uint64_t guest_destination_virtual_address, std::uint64_t destination_cr3, std::uint64_t size)
{
	virt_memory_op_hypercall_info_t memory_op_call = { };

	memory_op_call.call_type = hypercall_type_t::guest_virtual_memory_operation;
	memory_op_call.memory_operation = memory_operation_t::write_operation;
	memory_op_call.address_of_page_directory = destination_cr3 >> 12;

	hypercall_info_t hypercall_info = { .value = memory_op_call.value };

	std::uint64_t guest_source_virtual_address = reinterpret_cast<std::uint64_t>(guest_source_buffer);

	return make_hypercall(hypercall_info.call_type, hypercall_info.call_reserved_data, guest_source_virtual_address, guest_destination_virtual_address, size);
}

std::uint64_t hypercall::translate_guest_virtual_address(std::uint64_t guest_virtual_address, std::uint64_t guest_cr3)
{
	hypercall_type_t call_type = hypercall_type_t::translate_guest_virtual_address;

	return make_hypercall(call_type, 0, guest_virtual_address, guest_cr3, 0);
}

std::uint64_t hypercall::read_guest_cr3()
{
	hypercall_type_t call_type = hypercall_type_t::read_guest_cr3;

	return make_hypercall(call_type, 0, 0, 0, 0);
}

std::uint64_t hypercall::add_slat_code_hook(std::uint64_t target_guest_physical_address, std::uint64_t shadow_page_guest_physical_address)
{
	hypercall_type_t call_type = hypercall_type_t::add_slat_code_hook;

	return make_hypercall(call_type, 0, target_guest_physical_address, shadow_page_guest_physical_address, 0);
}

std::uint64_t hypercall::remove_slat_code_hook(std::uint64_t target_guest_physical_address)
{
	hypercall_type_t call_type = hypercall_type_t::remove_slat_code_hook;

	return make_hypercall(call_type, 0, target_guest_physical_address, 0, 0);
}

std::uint64_t hypercall::hide_guest_physical_page(std::uint64_t target_guest_physical_address)
{
	hypercall_type_t call_type = hypercall_type_t::hide_guest_physical_page;

	return make_hypercall(call_type, 0, target_guest_physical_address, 0, 0);
}

std::uint64_t hypercall::flush_logs(std::vector<trap_frame_log_t>& logs)
{
	hypercall_type_t call_type = hypercall_type_t::flush_logs;

	return make_hypercall(call_type, 0, reinterpret_cast<std::uint64_t>(logs.data()), logs.size(), 0);
}

std::uint64_t hypercall::get_heap_free_page_count()
{
	hypercall_type_t call_type = hypercall_type_t::get_heap_free_page_count;

	return make_hypercall(call_type, 0, 0, 0, 0);
}

```

`usermode/src/hypercall/hypercall.h`:

```h
#pragma once
#include <cstdint>
#include <vector>
#include <structures/trap_frame.h>

namespace hypercall
{
	std::uint64_t read_guest_physical_memory(void* guest_destination_buffer, std::uint64_t guest_source_physical_address, std::uint64_t size);
	std::uint64_t write_guest_physical_memory(void* guest_source_buffer, std::uint64_t guest_destination_physical_address, std::uint64_t size);

	std::uint64_t read_guest_virtual_memory(void* guest_destination_buffer, std::uint64_t guest_source_virtual_address, std::uint64_t source_cr3, std::uint64_t size);
	std::uint64_t write_guest_virtual_memory(void* guest_source_buffer, std::uint64_t guest_destination_virtual_address, std::uint64_t destination_cr3, std::uint64_t size);

	std::uint64_t translate_guest_virtual_address(std::uint64_t guest_virtual_address, std::uint64_t guest_cr3);

	std::uint64_t read_guest_cr3();

	std::uint64_t add_slat_code_hook(std::uint64_t target_guest_physical_address, std::uint64_t shadow_page_guest_physical_address);
	std::uint64_t remove_slat_code_hook(std::uint64_t target_guest_physical_address);
	std::uint64_t hide_guest_physical_page(std::uint64_t target_guest_physical_address);

	std::uint64_t flush_logs(std::vector<trap_frame_log_t>& logs);

	std::uint64_t get_heap_free_page_count();
}

```

`usermode/src/hypercall/vmexit.asm`:

```asm
.code
	launch_raw_hypercall proc
		cpuid

		ret
	launch_raw_hypercall endp
END
```

`usermode/src/main.cpp`:

```cpp
#include <iostream>
#include <thread>
#include <string>
#include <print>
#include <Windows.h>

#include "commands/commands.h"
#include "hook/hook.h"
#include "system/system.h"

std::int32_t main()
{
    if (sys::set_up() == 0)
    {
        std::system("pause");

        return 1;
    }

	while (true)
	{
		std::print("> ");

		std::string command = { };
		std::getline(std::cin, command);

		if (command == "exit")
		{
			break;
		}
			
		commands::process(command);

		std::this_thread::sleep_for(std::chrono::milliseconds(25));
	}

	sys::clean_up();

	return 0;
}

```

`usermode/src/system/system.cpp`:

```cpp
#include "system.h"

#include <algorithm>
#include <filesystem>
#include <fstream>

#include "../hypercall/hypercall.h"
#include "../hook/hook.h"

#include <portable_executable/image.hpp>

#include <print>
#include <vector>
#include <Windows.h>
#include <winternl.h>
#include <intrin.h>

extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(std::uint32_t privilege, std::uint8_t enable, std::uint8_t current_thread, std::uint8_t* previous_enabled_state);

std::vector<std::uint8_t> dump_kernel_module(std::uint64_t module_base_address)
{
	constexpr std::uint64_t headers_size = 0x1000;

	std::vector<std::uint8_t> headers(headers_size);

	std::uint64_t bytes_read = hypercall::read_guest_virtual_memory(headers.data(), module_base_address, sys::current_cr3, headers_size);

	if (bytes_read != headers_size)
	{
		return { };
	}

	std::uint16_t magic = *reinterpret_cast<std::uint16_t*>(headers.data());

	if (magic != 0x5a4d)
	{
		return { };
	}

	const portable_executable::image_t* image = reinterpret_cast<portable_executable::image_t*>(headers.data());

	std::vector<std::uint8_t> image_buffer(image->nt_headers()->optional_header.size_of_image);

	memcpy(image_buffer.data(), headers.data(), 0x1000);

	for (const auto& current_section : image->sections())
	{
		std::uint64_t read_offset = current_section.virtual_address;
		std::uint64_t read_size = current_section.virtual_size;

		hypercall::read_guest_virtual_memory(image_buffer.data() + read_offset, module_base_address + read_offset, sys::current_cr3, read_size);
	}

	return image_buffer;
}

std::uint64_t find_kernel_detour_holder_base_address(portable_executable::image_t* ntoskrnl, std::uint64_t ntoskrnl_base_address)
{
	for (const auto& current_section : ntoskrnl->sections())
	{
		std::string_view current_section_name(current_section.name);

		if (current_section_name.contains("Pad") == true && current_section.characteristics.mem_execute == 1)
		{
			return ntoskrnl_base_address + current_section.virtual_address;
		}
	}

	return 0;
}

std::unordered_map<std::string, std::uint64_t> parse_module_exports(const portable_executable::image_t* image, const std::string& module_name, const std::uint64_t module_base_address)
{
	std::unordered_map<std::string, std::uint64_t> exports = { };

	for (const auto& current_export : image->exports())
	{
		std::string current_export_name = module_name + "!" + current_export.name;

		std::uint64_t delta = reinterpret_cast<std::uint64_t>(current_export.address) - image->as<std::uint64_t>();

		exports[current_export_name] = module_base_address + delta;
	}

	return exports;
}

void add_module_to_list(const std::string& module_name, const std::vector<std::uint8_t>& module_dump, const std::uint64_t module_base_address, const std::uint32_t module_size)
{
	sys::kernel_module_t kernel_module = { };

	const portable_executable::image_t* image = reinterpret_cast<const portable_executable::image_t*>(module_dump.data());

	kernel_module.exports = parse_module_exports(image, module_name, module_base_address);
	kernel_module.base_address = module_base_address;
	kernel_module.size = module_size;

	sys::kernel::modules_list[module_name] = kernel_module;
}

void erase_unused_modules(const std::unordered_map<std::string, sys::kernel_module_t>& modules_not_found)
{
	for (const auto& [module_name, module_info] : modules_not_found)
	{
		sys::kernel::modules_list.erase(module_name);
	}
}

// requires SeDebugPriviledge, use PsLoadedModulesList instead unless if using before ntoskrnl.exe is parsed
std::vector<rtl_process_module_information_t> get_loaded_modules_priviledged()
{
	std::uint32_t size_of_information = 0;

	sys::user::query_system_information(11, nullptr, 0, &size_of_information);

	if (size_of_information == 0)
	{
		return { };
	}

	std::vector<std::uint8_t> buffer(size_of_information);

	std::uint32_t status = sys::user::query_system_information(11, buffer.data(), size_of_information, &size_of_information);

	if (NT_SUCCESS(status) == false)
	{
		return { };
	}

	rtl_process_modules_t* process_modules = reinterpret_cast<rtl_process_modules_t*>(buffer.data());

	rtl_process_module_information_t* start = &process_modules->modules[0];
	rtl_process_module_information_t* end = start + process_modules->module_count;

	return { start, end };
}

template <class t>
t read_kernel_virtual_memory(std::uint64_t address)
{
	t buffer = t();

	hypercall::read_guest_virtual_memory(&buffer, address, sys::current_cr3, sizeof(t));

	return buffer;
}

std::wstring read_unicode_string(std::uint64_t address)
{
	std::uint16_t length = read_kernel_virtual_memory<std::uint16_t>(address);

	if (length == 0)
	{
		return { };
	}

	std::uint64_t buffer_address = read_kernel_virtual_memory<std::uint64_t>(address + 8);

	std::wstring string(length / 2, L'\0');

	hypercall::read_guest_virtual_memory(string.data(), buffer_address, sys::current_cr3, length);

	return string;
}

std::uint64_t get_ps_loaded_module_list()
{
	const std::string ntoskrnl_name = "ntoskrnl.exe";

	if (sys::kernel::modules_list.contains(ntoskrnl_name) == 0)
	{
		return 0;
	}

	sys::kernel_module_t& ntoskrnl = sys::kernel::modules_list[ntoskrnl_name];

	const std::string ps_loaded_module_list_name = "ntoskrnl.exe!PsLoadedModuleList";

	return ntoskrnl.exports[ps_loaded_module_list_name];
}

std::uint8_t sys::kernel::parse_modules()
{
	const std::uint64_t ps_loaded_module_list = get_ps_loaded_module_list();

	if (ps_loaded_module_list == 0)
	{
		std::println("can't locate PsLoadedModuleList");

		return 0;
	}

	std::unordered_map<std::string, kernel_module_t> modules_not_found = modules_list;

	const std::uint64_t start_entry = ps_loaded_module_list;

	std::uint64_t current_entry = read_kernel_virtual_memory<std::uint64_t>(start_entry); // flink

	while (current_entry != start_entry)
	{
		kernel_module_t kernel_module = { };

		std::uint64_t module_base_address = read_kernel_virtual_memory<std::uint64_t>(current_entry + 0x30); // DllBase
		std::uint32_t module_size = read_kernel_virtual_memory<std::uint32_t>(current_entry + 0x40); // SizeOfImage
		std::string module_name = user::to_string(read_unicode_string(current_entry + 0x58)); // BaseDllName

		// current_entry must not be accessed after this point in this iteration
		current_entry = read_kernel_virtual_memory<std::uint64_t>(current_entry); // flink

		if (modules_list.contains(module_name) == true)
		{
			modules_not_found.erase(module_name);

			const kernel_module_t already_present_module = modules_list[module_name];

			if (already_present_module.base_address == module_base_address && already_present_module.size == module_size)
			{
				continue;
			}
		}

		std::vector<std::uint8_t> module_dump = dump_kernel_module(module_base_address);

		if (module_dump.empty() == true)
		{
			continue;
		}

		add_module_to_list(module_name, module_dump, module_base_address, module_size);
	}

	erase_unused_modules(modules_not_found);

	return 1;
}

void fix_dump(std::vector<std::uint8_t>& buffer)
{
	portable_executable::image_t* image = reinterpret_cast<portable_executable::image_t*>(buffer.data());

	for (auto& current_section : image->sections())
	{
		current_section.pointer_to_raw_data = current_section.virtual_address;
		current_section.size_of_raw_data = current_section.virtual_size;
	}
}

std::uint8_t sys::kernel::dump_module_to_disk(const std::string_view target_module_name, const std::string_view output_directory)
{
	const auto module_info = modules_list[target_module_name.data()];

	const std::uint64_t module_base_address = module_info.base_address;

	if (module_base_address == 0)
	{
		return 0;
	}

	std::vector<std::uint8_t> buffer = dump_kernel_module(module_base_address);

	if (buffer.empty() == 1)
	{
		return 0;
	}

	fix_dump(buffer);

	std::string output_path = std::string(output_directory) + "\\" + "dump_" + std::string(target_module_name);

	return fs::write_to_disk(output_path, buffer);
}

struct ntoskrnl_information_t
{
	std::uint64_t base_address;
	std::uint32_t size;

	std::vector<std::uint8_t> dump;
};

std::optional<ntoskrnl_information_t> load_ntoskrnl_information()
{
	std::uint8_t desired_privilege_state = 1;
	std::uint8_t previous_privilege_state = 0;

	if (sys::user::set_debug_privilege(desired_privilege_state, &previous_privilege_state) == 0)
	{
		std::println("unable to acquire necessary privilege");

		return std::nullopt;
	}

	const std::vector<rtl_process_module_information_t> loaded_modules = get_loaded_modules_priviledged();

	sys::user::set_debug_privilege(previous_privilege_state, &desired_privilege_state);

	for (const rtl_process_module_information_t& current_module : loaded_modules)
	{
		std::string_view current_module_name = reinterpret_cast<const char*>(current_module.full_path_name + current_module.offset_to_file_name);

		if (current_module_name == "ntoskrnl.exe")
		{
			std::vector<std::uint8_t> ntoskrnl_dump = dump_kernel_module(current_module.image_base);

			if (ntoskrnl_dump.empty() == true)
			{
				std::println("unable to dump ntoskrnl.exe");

				return std::nullopt;
			}

			ntoskrnl_information_t ntoskrnl_info = { };

			ntoskrnl_info.base_address = current_module.image_base;
			ntoskrnl_info.size = current_module.image_size;
			ntoskrnl_info.dump = ntoskrnl_dump;

			return ntoskrnl_info;
		}
	}

	return std::nullopt;
}

std::uint8_t parse_ntoskrnl()
{
	std::optional<ntoskrnl_information_t> ntoskrnl_info = load_ntoskrnl_information();

	if (ntoskrnl_info.has_value() == 0)
	{
		std::println("unable to load ntoskrnl.exe's information");

		return 0;
	}

	std::vector<std::uint8_t>& ntoskrnl_dump = ntoskrnl_info->dump;

	portable_executable::image_t* ntoskrnl_image = reinterpret_cast<portable_executable::image_t*>(ntoskrnl_dump.data());

	add_module_to_list("ntoskrnl.exe", ntoskrnl_dump, ntoskrnl_info->base_address, ntoskrnl_info->size);

	hook::kernel_detour_holder_base = find_kernel_detour_holder_base_address(ntoskrnl_image, ntoskrnl_info->base_address);

	if (hook::kernel_detour_holder_base == 0)
	{
		std::println("unable to locate kernel hook holder");

		return 0;
	}

	return 1;
}

std::uint8_t sys::set_up()
{
	current_cr3 = hypercall::read_guest_cr3();

	if (current_cr3 == 0)
	{
		std::println("hyperv-attachment doesn't seem to be loaded");

		return 0;
	}

	if (parse_ntoskrnl() == 0)
	{
		std::println("unable to parse ntoskrnl.exe");

		return 0;
	}

	if (kernel::parse_modules() == 0)
	{
		std::println("unable to parse kernel modules");

		return 0;
	}

	if (hook::set_up() == 0)
	{
		std::println("unable to set up kernel hook helper");

		return 0;
	}

	return 1;
}

void sys::clean_up()
{
	hook::clean_up();
}

std::uint32_t sys::user::query_system_information(std::int32_t information_class, void* information_out, std::uint32_t information_size, std::uint32_t* returned_size)
{
	return NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(information_class), information_out, information_size, reinterpret_cast<ULONG*>(returned_size));
}

std::uint32_t sys::user::adjust_privilege(std::uint32_t privilege, std::uint8_t enable, std::uint8_t current_thread_only, std::uint8_t* previous_enabled_state)
{
	return RtlAdjustPrivilege(privilege, enable, current_thread_only, previous_enabled_state);
}

std::uint8_t sys::user::set_debug_privilege(const std::uint8_t state, std::uint8_t* previous_state)
{
	constexpr std::uint32_t debug_privilege_id = 20;

	std::uint32_t status = adjust_privilege(debug_privilege_id, state, 0, previous_state);

	return NT_SUCCESS(status);
}

void* sys::user::allocate_locked_memory(std::uint64_t size, std::uint32_t protection)
{
	void* allocation_base = VirtualAlloc(nullptr, size, MEM_COMMIT | MEM_RESERVE, protection);

	if (allocation_base == nullptr)
	{
		return nullptr;
	}

	std::int32_t lock_status = VirtualLock(allocation_base, size);

	if (lock_status == 0)
	{
		free_memory(allocation_base);

		return nullptr;
	}

	return allocation_base;
}

std::uint8_t sys::user::free_memory(void* address)
{
	std::int32_t free_status = VirtualFree(address, 0, MEM_RELEASE);

	return free_status != 0;
}

std::string sys::user::to_string(const std::wstring& wstring)
{
	if (wstring.empty() == 1)
	{
		return { };
	}

	std::string converted_string = { };

	std::ranges::transform(wstring,
		std::back_inserter(converted_string), [](wchar_t character)
		{
			return static_cast<char>(character);
		});

	return converted_string;
}

std::uint8_t sys::fs::exists(std::string_view path)
{
	return std::filesystem::exists(path);
}

std::uint8_t sys::fs::write_to_disk(const std::string_view full_path, const std::vector<std::uint8_t>& buffer)
{
	std::ofstream file(full_path.data(),std::ios::binary);

	if (file.is_open() == 0)
	{
		return 0;
	}

	file.write(reinterpret_cast<const char*>(buffer.data()), buffer.size());

	return file.good();
}

```

`usermode/src/system/system.h`:

```h
#pragma once
#include <unordered_map>
#include <optional>
#include <string>
#include "system_def.h"

namespace sys
{
	struct kernel_module_t;

	std::uint8_t set_up();
	void clean_up();

	namespace kernel
	{
		std::uint8_t parse_modules();
		std::uint8_t dump_module_to_disk(std::string_view target_module_name, const std::string_view output_directory);

		inline std::unordered_map<std::string, kernel_module_t> modules_list = { };
	}

	namespace user
	{
		std::uint32_t query_system_information(std::int32_t information_class, void* information_out, std::uint32_t information_size, std::uint32_t* returned_size);

		std::uint32_t adjust_privilege(std::uint32_t privilege, std::uint8_t enable, std::uint8_t current_thread_only, std::uint8_t* previous_enabled_state);
		std::uint8_t set_debug_privilege(std::uint8_t state, std::uint8_t* previous_state);

		void* allocate_locked_memory(std::uint64_t size, std::uint32_t protection);
		std::uint8_t free_memory(void* address);

		std::string to_string(const std::wstring& wstring);
	}

	namespace fs
	{
		std::uint8_t exists(std::string_view path);

		std::uint8_t write_to_disk(std::string_view full_path, const std::vector<std::uint8_t>& buffer);
	}

	struct kernel_module_t
	{
		std::unordered_map<std::string, std::uint64_t> exports;
		
		std::uint64_t base_address;
		std::uint32_t size;
	};

	inline std::uint64_t current_cr3 = 0;
}

```

`usermode/src/system/system_def.h`:

```h
#pragma once
#include <cstdint>

struct rtl_process_module_information_t
{
    std::uint64_t section;
    std::uint64_t mapped_base;
    std::uint64_t image_base;
    std::uint32_t image_size;
    std::uint32_t flags;
    std::uint16_t load_order_index;
    std::uint16_t init_order_index;
    std::uint16_t load_count;
    std::uint16_t offset_to_file_name;
    std::uint8_t full_path_name[256];
};

struct rtl_process_modules_t
{
    std::uint32_t module_count;
	rtl_process_module_information_t modules[1];
};

```

`usermode/usermode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2ea786e4-1147-4804-aead-17975e24ec46}</ProjectGuid>
    <RootNamespace>usermode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <IncludePath>$(SolutionDir)shared;$(ProjectDir)ext;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <IncludePath>$(SolutionDir)shared;$(ProjectDir)ext;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ext\portable_executable\data_directory.cpp" />
    <ClCompile Include="ext\portable_executable\dos_header.cpp" />
    <ClCompile Include="ext\portable_executable\export_directory.cpp" />
    <ClCompile Include="ext\portable_executable\file.cpp" />
    <ClCompile Include="ext\portable_executable\image.cpp" />
    <ClCompile Include="ext\portable_executable\imports_directory.cpp" />
    <ClCompile Include="ext\portable_executable\nt_headers.cpp" />
    <ClCompile Include="ext\portable_executable\relocations_directory.cpp" />
    <ClCompile Include="ext\portable_executable\section_header.cpp" />
    <ClCompile Include="src\commands\commands.cpp" />
    <ClCompile Include="src\hook\hook.cpp" />
    <ClCompile Include="src\hook\hook_disassembly.cpp" />
    <ClCompile Include="src\hook\kernel_detour_holder.cpp" />
    <ClCompile Include="src\hypercall\hypercall.cpp" />
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\system\system.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\hypercall\vmexit.asm" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ext\portable_executable\data_directory.hpp" />
    <ClInclude Include="ext\portable_executable\dos_header.hpp" />
    <ClInclude Include="ext\portable_executable\export_directory.hpp" />
    <ClInclude Include="ext\portable_executable\file.hpp" />
    <ClInclude Include="ext\portable_executable\file_header.hpp" />
    <ClInclude Include="ext\portable_executable\image.hpp" />
    <ClInclude Include="ext\portable_executable\imports_directory.hpp" />
    <ClInclude Include="ext\portable_executable\nt_headers.hpp" />
    <ClInclude Include="ext\portable_executable\optional_header.hpp" />
    <ClInclude Include="ext\portable_executable\relocations_directory.hpp" />
    <ClInclude Include="ext\portable_executable\section_header.hpp" />
    <ClInclude Include="src\commands\commands.h" />
    <ClInclude Include="src\hook\hook.h" />
    <ClInclude Include="src\hook\hook_disassembly.h" />
    <ClInclude Include="src\hook\kernel_detour_holder.h" />
    <ClInclude Include="src\hypercall\hypercall.h" />
    <ClInclude Include="src\system\system.h" />
    <ClInclude Include="src\system\system_def.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`usermode/usermode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\hypercall\hypercall.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\commands\commands.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\system\system.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\hook\hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\data_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\dos_header.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\export_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\file.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\image.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\imports_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\nt_headers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\relocations_directory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ext\portable_executable\section_header.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\hook\kernel_detour_holder.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\hook\hook_disassembly.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\hypercall\vmexit.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\hypercall\hypercall.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\commands\commands.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\system\system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\system\system_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\hook\hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\data_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\dos_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\export_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\file.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\file_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\image.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\imports_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\nt_headers.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\optional_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\relocations_directory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ext\portable_executable\section_header.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\hook\kernel_detour_holder.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\hook\hook_disassembly.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`usermode/vcpkg.json`:

```json
{
  "dependencies": [
    "zydis",
    "cli11"
  ]
}

```