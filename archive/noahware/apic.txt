Project Path: arc_noahware_apic_i2ffjgg2

Source Tree:

```txt
arc_noahware_apic_i2ffjgg2
├── README.md
├── examples
│   └── windows
│       ├── apic-kernel-dynamic
│       │   ├── apic-kernel-dynamic.inf
│       │   ├── apic-kernel-dynamic.vcxproj
│       │   ├── apic-kernel-dynamic.vcxproj.filters
│       │   └── main.cpp
│       ├── apic-kernel-static
│       │   ├── apic-kernel-static.inf
│       │   ├── apic-kernel-static.vcxproj
│       │   ├── apic-kernel-static.vcxproj.filters
│       │   └── main.cpp
│       └── apic.sln
└── src
    ├── apic.cpp
    ├── apic.h
    ├── apic_def.h
    └── apic_intrin.h

```

`README.md`:

```md
# apic
C++ library for sending processor interrupts via x2apic & xapic.

# Usage
The library is OS independent, it doesn't rely on any operating system specific libraries. This means you are easily able to implement this into your own: operating system, hypervisor, kernel driver, etc.

To get an instance of the apic class, call the static routine `apic_t::create_instance()`, but I assume you are wondering, how is it allocating memory for the class?
To specify the allocation of the class instance, you can either `#define APIC_RUNTIME_INSTANCE_ALLOCATION` - which will make the library expect you to define
two routines: `allocate_memory(uint64_t size)` and `free_memory(void* p, uint64_t size)` (which will then be invoked to allocate and deallocate memory for class instances at runtime if you have opted out of compile time allocation).
If you do not define `APIC_RUNTIME_INSTANCE_ALLOCATION`, then the library will reserve enough memory for an instance of either `xapic_t` or `x2apic_t` at compile time, so it won't rely on any runtime memory allocation.
The aforementioned routine: `apic_t::create_instance()` checks whether apic has already been enabled, and if it has, then it uses the apic version which is already running. 
If apic is not already enabled, it will enable it with x2apic if it is supported by the CPU (if x2apic is not supported, then it will enable xapic only).

Once you have an instance, sending interrupts to processors is simple. The library exposes such routines for this:

```cpp
void send_ipi(uint32_t vector, uint32_t apic_id, uint8_t is_lowest_priority);
void send_ipi(uint32_t vector, icr_destination_shorthand_t destination_shorthand, uint8_t is_lowest_priority);

void send_nmi(uint32_t apic_id);
void send_nmi(icr_destination_shorthand_t destination_shorthand);

void send_smi(uint32_t apic_id);
void send_smi(icr_destination_shorthand_t destination_shorthand);

void send_init_ipi(uint32_t apic_id);
void send_init_ipi(icr_destination_shorthand_t destination_shorthand);

void send_startup_ipi(uint32_t apic_id);
void send_startup_ipi(icr_destination_shorthand_t destination_shorthand);
```

These routines allow you to either specify a specific logical processors's apic id - you can read the current logical processor's apic id by invoking the static routine `apic_t::current_apic_id()` - or to specify a shorthand identifier.
What are shorthand identifiers, you ask? Well this is the way the Intel SDM has provided to describe these following destinations: `self` (current logical processor), `all_including_self` (all logical processors including the sender), and `all_but_self` (all logical processors except the sender).

Heres an example on how to send a NMI (non maskable interrupt) to all logical processors except the logical processor we are currently executing on:

```cpp
apic_t* apic = apic_t::create_instance();

apic->send_nmi(icr_destination_shorthand_t::all_but_self);
```

Heres another example on how to send an interrupt with vector `0xE1` to the apic id `3`:

```cpp
apic_t* apic = apic_t::create_instance();

uint32_t interrupt_vector = 0xE1;
uint32_t apic_id = 3;

apic->send_ipi(interrupt_vector, apic_id);
```

Finally, heres another example on how to send an interrupt with vector `0xE1` to the apic id `3` with the `lowest priority`:

```cpp
apic_t* apic = apic_t::create_instance();

uint32_t interrupt_vector = 0xE1;
uint32_t apic_id = 3;

apic->send_ipi(interrupt_vector, apic_id, 1);
```

Once you are ready to free the apic instance, then just use the delete operator on the object. An example is linked below:

```cpp
apic_t* apic = apic_t::create_instance();

delete apic;
apic = nullptr; // optional, but good practice to do so
```

# Compilable examples
Compilable examples are provided in the [examples](examples) directory, where there is currently an two examples of a windows kernel driver. One uses [compile time instance allocation](examples/windows/apic-kernel-static), and the other uses [runtime instance allocation](examples/windows/apic-kernel-dynamic).

# Showcase
Both of the videos below are using the [windows kernel driver example](examples/windows/apic-kernel-static). They show me placing a breakpoint on the Windows kernel's ipi handler (of vector 0xE1) right before sending an ipi with 0xE1 on the current logical processor. I then allow the ipi to be sent by the example, which is then led to a breakpoint being hit on nt!KiIpiInterrupt. I am then able to read the stack pointer, and find that the `interrupted instruction pointer` has just been pushed on the stack (which is within our example driver - showing that the self ipi was sent successfully).

X2apic:

https://github.com/user-attachments/assets/dd30bf92-f3c8-4a28-88ea-6d67782bb591

Xapic:

https://github.com/user-attachments/assets/b10a9f32-f17e-478c-872e-57c82c6415a4

```

`examples/windows/apic-kernel-dynamic/apic-kernel-dynamic.inf`:

```inf
;
; apic-kernel-dynamic.inf
;

[Version]
Signature   = "$WINDOWS NT$"
Class       = System ; TODO: specify appropriate Class
ClassGuid   = {4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider    = %ManufacturerName%
CatalogFile = apic-kernel-dynamic.cat
DriverVer   = ; TODO: set DriverVer in stampinf property pages
PnpLockdown = 1

[DestinationDirs]
DefaultDestDir = 13

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
apic-kernel-dynamic.sys = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName% = Standard,NT$ARCH$.10.0...16299 ; %13% support introduced in build 16299

[Standard.NT$ARCH$.10.0...16299]
%apic-kernel-dynamic.DeviceDesc% = apic-kernel-dynamic_Device, Root\apic-kernel-dynamic ; TODO: edit hw-id

[apic-kernel-dynamic_Device.NT]
CopyFiles = File_Copy

[File_Copy]
apic-kernel-dynamic.sys

;-------------- Service installation
[apic-kernel-dynamic_Device.NT.Services]
AddService = apic-kernel-dynamic,%SPSVCINST_ASSOCSERVICE%, apic-kernel-dynamic_Service_Inst

; -------------- apic-kernel-dynamic driver install sections
[apic-kernel-dynamic_Service_Inst]
DisplayName    = %apic-kernel-dynamic.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %13%\apic-kernel-dynamic.sys

[apic-kernel-dynamic_Device.NT.Wdf]
KmdfService = apic-kernel-dynamic, apic-kernel-dynamic_wdfsect

[apic-kernel-dynamic_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE = 0x00000002
ManufacturerName = "<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "apic-kernel-dynamic Installation Disk"
apic-kernel-dynamic.DeviceDesc = "apic-kernel-dynamic Device"
apic-kernel-dynamic.SVCDESC = "apic-kernel-dynamic Service"

```

`examples/windows/apic-kernel-dynamic/apic-kernel-dynamic.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>apic_kernel_dynamic</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <PreprocessorDefinitions>APIC_RUNTIME_INSTANCE_ALLOCATION;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <PreprocessorDefinitions>APIC_RUNTIME_INSTANCE_ALLOCATION;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="apic-kernel-dynamic.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\src\apic.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\apic.h" />
    <ClInclude Include="..\..\..\src\apic_def.h" />
    <ClInclude Include="..\..\..\src\apic_intrin.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/windows/apic-kernel-dynamic/apic-kernel-dynamic.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="apic-kernel-dynamic.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\src\apic.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\apic.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\apic_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\apic_intrin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/windows/apic-kernel-dynamic/main.cpp`:

```cpp
#include <ntifs.h>

#include "..\..\..\src\apic.h"

#define d_log(format, ...) DbgPrintEx(77, 0, format, __VA_ARGS__)

void driver_unload(PDRIVER_OBJECT driver_object)
{
	UNREFERENCED_PARAMETER(driver_object);
}

void* map_physical_address(uint64_t physical_address)
{
	PHYSICAL_ADDRESS address_to_map = { };
	address_to_map.QuadPart = static_cast<int64_t>(physical_address);

	return MmMapIoSpace(address_to_map, 0x1000, MmNonCached);
}

void unmap_physical_address(void* map_base_address)
{
	return MmUnmapIoSpace(map_base_address, 0x1000);
}

void* allocate_memory(uint64_t size)
{
	return ExAllocatePool2(POOL_FLAG_NON_PAGED, size, 'apic');
}

void free_memory(void* p, uint64_t size)
{
	UNREFERENCED_PARAMETER(size);

	ExFreePoolWithTag(p, 'apic');
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path)
{
	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);

	driver_object->DriverUnload = driver_unload;

	apic_t* apic = apic_t::create_instance();

	if (apic == nullptr)
	{
		d_log("[apic] unable to create instance of apic class\n");

		return STATUS_MEMORY_NOT_ALLOCATED;
	}

	uint32_t interrupt_vector = 0xE1; // vector points to nt!KiIpiInterrupt

	d_log("[apic] current apic id: %x\n", apic_t::current_apic_id());
	d_log("[apic] sending interrupt of vector 0x%x\n", interrupt_vector);

	apic->send_ipi(interrupt_vector, icr_destination_shorthand_t::self);

	delete apic;
	apic = nullptr;

	return STATUS_SUCCESS;
}
```

`examples/windows/apic-kernel-static/apic-kernel-static.inf`:

```inf
;
; apic-kernel-static.inf
;

[Version]
Signature   = "$WINDOWS NT$"
Class       = System ; TODO: specify appropriate Class
ClassGuid   = {4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider    = %ManufacturerName%
CatalogFile = apic-kernel-static.cat
DriverVer   = ; TODO: set DriverVer in stampinf property pages
PnpLockdown = 1

[DestinationDirs]
DefaultDestDir = 13

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
apic-kernel-static.sys = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName% = Standard,NT$ARCH$.10.0...16299 ; %13% support introduced in build 16299

[Standard.NT$ARCH$.10.0...16299]
%apic-kernel-static.DeviceDesc% = apic-kernel-static_Device, Root\apic-kernel-static ; TODO: edit hw-id

[apic-kernel-static_Device.NT]
CopyFiles = File_Copy

[File_Copy]
apic-kernel-static.sys

;-------------- Service installation
[apic-kernel-static_Device.NT.Services]
AddService = apic-kernel-static,%SPSVCINST_ASSOCSERVICE%, apic-kernel-static_Service_Inst

; -------------- apic-kernel-static driver install sections
[apic-kernel-static_Service_Inst]
DisplayName    = %apic-kernel-static.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %13%\apic-kernel-static.sys

[apic-kernel-static_Device.NT.Wdf]
KmdfService = apic-kernel-static, apic-kernel-static_wdfsect

[apic-kernel-static_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE = 0x00000002
ManufacturerName = "<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "apic-kernel-static Installation Disk"
apic-kernel-static.DeviceDesc = "apic-kernel-static Device"
apic-kernel-static.SVCDESC = "apic-kernel-static Service"

```

`examples/windows/apic-kernel-static/apic-kernel-static.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{6F115E3F-5203-4B14-A567-A11643FAF8D3}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>apic_kernel_static</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>true</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>true</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="apic-kernel-static.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\src\apic.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\apic.h" />
    <ClInclude Include="..\..\..\src\apic_def.h" />
    <ClInclude Include="..\..\..\src\apic_intrin.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/windows/apic-kernel-static/apic-kernel-static.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="apic-kernel-static.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\apic.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\apic.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\apic_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\apic_intrin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/windows/apic-kernel-static/main.cpp`:

```cpp
#include <ntifs.h>

#include "..\..\..\src\apic.h"

#define d_log(format, ...) DbgPrintEx(77, 0, format, __VA_ARGS__)

void driver_unload(PDRIVER_OBJECT driver_object)
{
	UNREFERENCED_PARAMETER(driver_object);
}

void* map_physical_address(uint64_t physical_address)
{
	PHYSICAL_ADDRESS address_to_map = { };
	address_to_map.QuadPart = physical_address;

	return MmMapIoSpace(address_to_map, 0x1000, MmNonCached);
}

void unmap_physical_address(void* map_base_address)
{
	return MmUnmapIoSpace(map_base_address, 0x1000);
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path)
{
	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);

	driver_object->DriverUnload = driver_unload;

	apic_t* apic = apic_t::create_instance();

	if (apic == nullptr)
	{
		d_log("[apic] unable to create instance of apic class\n");

		return STATUS_MEMORY_NOT_ALLOCATED;
	}

	uint32_t interrupt_vector = 0xE1; // vector points to nt!KiIpiInterrupt

	d_log("[apic] current apic id: %x\n", apic_t::current_apic_id());
	d_log("[apic] sending interrupt of vector 0x%x\n", interrupt_vector);

	apic->send_ipi(interrupt_vector, icr_destination_shorthand_t::all_but_self);

	delete apic;
	apic = nullptr;

	return STATUS_SUCCESS;
}
```

`examples/windows/apic.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35514.174
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "apic-kernel-static", "apic-kernel-static\apic-kernel-static.vcxproj", "{6F115E3F-5203-4B14-A567-A11643FAF8D3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "apic-kernel-dynamic", "apic-kernel-dynamic\apic-kernel-dynamic.vcxproj", "{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Debug|ARM64.Build.0 = Debug|ARM64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Debug|x64.ActiveCfg = Debug|x64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Debug|x64.Build.0 = Debug|x64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Debug|x64.Deploy.0 = Debug|x64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Release|ARM64.ActiveCfg = Release|ARM64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Release|ARM64.Build.0 = Release|ARM64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Release|ARM64.Deploy.0 = Release|ARM64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Release|x64.ActiveCfg = Release|x64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Release|x64.Build.0 = Release|x64
		{6F115E3F-5203-4B14-A567-A11643FAF8D3}.Release|x64.Deploy.0 = Release|x64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Debug|ARM64.Build.0 = Debug|ARM64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Debug|x64.ActiveCfg = Debug|x64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Debug|x64.Build.0 = Debug|x64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Debug|x64.Deploy.0 = Debug|x64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Release|ARM64.ActiveCfg = Release|ARM64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Release|ARM64.Build.0 = Release|ARM64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Release|ARM64.Deploy.0 = Release|ARM64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Release|x64.ActiveCfg = Release|x64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Release|x64.Build.0 = Release|x64
		{B36AF111-EEF5-4E71-B8AB-CB2B50D6583B}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`src/apic.cpp`:

```cpp
#include "apic.h"
#include "apic_intrin.h"

// map_physical_address and unmap_physical_address is up to you to implement
extern void* map_physical_address(uint64_t physical_address);
extern void unmap_physical_address(void* map_base_address);

constexpr uint64_t needed_apic_class_instance_size = sizeof(xapic_t) < sizeof(x2apic_t) ? sizeof(x2apic_t) : sizeof(xapic_t);

#ifdef APIC_RUNTIME_INSTANCE_ALLOCATION
// allocate_memory and free is up to you to implement
extern void* allocate_memory(uint64_t size);
extern void free_memory(void* p, uint64_t size);
#else
static char apic_class_instance_allocation[needed_apic_class_instance_size] = { };
#endif

cpuid_01_t perform_cpuid_01()
{
	cpuid_01_t cpuid_01 = { };
	apic::intrin::cpuid(reinterpret_cast<int32_t*>(&cpuid_01), 1);

	return cpuid_01;
}

uint8_t apic_t::enable(uint8_t use_x2apic)
{
	apic_base_t apic_base = read_apic_base();

	if (apic_base.apic_pfn == 0)
	{
		apic_base.apic_pfn = 0xFEE00;
	}

	apic_base.is_apic_globally_enabled = 1;
	apic_base.is_x2apic = use_x2apic;

	apic::intrin::wrmsr(apic::apic_base_msr, apic_base.flags);

	return 1;
}

uint8_t apic_t::is_any_enabled(apic_base_t apic_base)
{
	return apic_base.is_apic_globally_enabled;
}

uint8_t apic_t::is_x2apic_enabled(apic_base_t apic_base)
{
	return is_any_enabled(apic_base) == 1 && apic_base.is_x2apic == 1;
}

apic_base_t apic_t::read_apic_base()
{
	apic_base_t apic_base = { };

	apic_base.flags = apic::intrin::rdmsr(apic::apic_base_msr);

	return apic_base;
}

uint32_t apic_t::current_apic_id()
{
	cpuid_01_t cpuid_01 = perform_cpuid_01();
	
	return cpuid_01.ebx.initial_apic_id;
}

uint8_t apic_t::is_x2apic_supported()
{
	cpuid_01_t cpuid_01 = perform_cpuid_01();

	return cpuid_01.ecx.x2apic_supported == 1;
}

apic_full_icr_t apic_t::make_base_icr(uint32_t vector, icr_delivery_mode_t delivery_mode, icr_destination_mode_t destination_mode)
{
	apic_full_icr_t icr = { };

	icr.low.vector = vector;
	icr.low.delivery_mode = delivery_mode;
	icr.low.destination_mode = destination_mode;
	icr.low.trigger_mode = icr_trigger_mode_t::edge;
	icr.low.level = icr_level_t::assert;

	return icr;
}

void apic_t::send_ipi(uint32_t vector, uint32_t apic_id, uint8_t is_lowest_priority)
{
	icr_delivery_mode_t delivery_mode = is_lowest_priority == 1 ? icr_delivery_mode_t::lowest_priority : icr_delivery_mode_t::fixed;

	apic_full_icr_t icr = make_base_icr(vector, delivery_mode, icr_destination_mode_t::physical);

	this->set_icr_longhand_destination(icr, apic_id);
	this->write_icr(icr);
}

void apic_t::send_ipi(uint32_t vector, icr_destination_shorthand_t destination_shorthand, uint8_t is_lowest_priority)
{
	icr_delivery_mode_t delivery_mode = is_lowest_priority == 1 ? icr_delivery_mode_t::lowest_priority : icr_delivery_mode_t::fixed;

	apic_full_icr_t icr = make_base_icr(vector, delivery_mode, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	this->write_icr(icr);
}

void apic_t::send_nmi(uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::nmi, icr_destination_mode_t::physical);

	this->set_icr_longhand_destination(icr, apic_id);
	this->write_icr(icr);
}

void apic_t::send_nmi(icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::nmi, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	this->write_icr(icr);
}

void apic_t::send_smi(uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::smi, icr_destination_mode_t::physical);

	this->set_icr_longhand_destination(icr, apic_id);
	this->write_icr(icr);
}

void apic_t::send_smi(icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::smi, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	this->write_icr(icr);
}

void apic_t::send_init_ipi(uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::init, icr_destination_mode_t::physical);

	this->set_icr_longhand_destination(icr, apic_id);
	this->write_icr(icr);
}

void apic_t::send_init_ipi(icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::init, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	this->write_icr(icr);
}

void apic_t::send_startup_ipi(uint32_t apic_id)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::start_up, icr_destination_mode_t::physical);

	this->set_icr_longhand_destination(icr, apic_id);
	this->write_icr(icr);
}

void apic_t::send_startup_ipi(icr_destination_shorthand_t destination_shorthand)
{
	apic_full_icr_t icr = make_base_icr(0, icr_delivery_mode_t::start_up, icr_destination_mode_t::physical);

	icr.low.destination_shorthand = destination_shorthand;

	this->write_icr(icr);
}

void* apic_t::operator new(uint64_t size, void* p)
{
	size;

	return p;
}

void apic_t::operator delete(void* p, uint64_t size)
{
#ifdef APIC_RUNTIME_INSTANCE_ALLOCATION
	free_memory(p, size);
#else
	p;
	size;
#endif
}

xapic_t::xapic_t()
{
	apic_base_t apic_base = read_apic_base();

	uint64_t apic_physical_address = apic_base.apic_pfn << 12;

	this->mapped_apic_base = static_cast<uint8_t*>(map_physical_address(apic_physical_address));
}

xapic_t::~xapic_t()
{
	if (this->mapped_apic_base != nullptr)
	{
		unmap_physical_address(this->mapped_apic_base);
	}
}

uint32_t xapic_t::do_read(uint16_t offset) const
{
	if (this->mapped_apic_base == nullptr)
	{
		return 0;
	}

	return *reinterpret_cast<uint32_t*>(this->mapped_apic_base + offset);
}

void xapic_t::do_write(uint16_t offset, uint32_t value) const
{
	if (this->mapped_apic_base != nullptr)
	{
		*reinterpret_cast<uint32_t*>(this->mapped_apic_base + offset) = value;
	}
}

void xapic_t::write_icr(apic_full_icr_t icr)
{
	constexpr uint16_t xapic_icr = apic::icr.get_xapic();

	do_write(xapic_icr, icr.low.flags);
	do_write(xapic_icr + 0x10, icr.high.flags);
}

void xapic_t::set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination)
{
	icr.high.xapic.destination_field = destination;
}

void xapic_t::signal_eoi()
{
	constexpr uint16_t xapic_eoi = apic::eoi.get_xapic();

	do_write(xapic_eoi, 0);
}

uint64_t x2apic_t::do_read(uint32_t msr)
{
	return apic::intrin::rdmsr(msr);
}

void x2apic_t::do_write(uint32_t msr, uint64_t value)
{
	apic::intrin::wrmsr(msr, value);
}

void x2apic_t::write_icr(apic_full_icr_t icr)
{
	constexpr uint16_t x2apic_icr = apic::icr.get_x2apic();

	do_write(x2apic_icr, icr.flags);
}

void x2apic_t::set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination)
{
	icr.high.x2apic.destination_field = destination;
}

void x2apic_t::signal_eoi()
{
	constexpr uint16_t x2apic_eoi = apic::eoi.get_x2apic();

	do_write(x2apic_eoi, 0);
}

apic_t* apic_t::create_instance()
{
#ifdef APIC_RUNTIME_INSTANCE_ALLOCATION
	void* apic_allocation = allocate_memory(needed_apic_class_instance_size);
#else
	static uint8_t has_used_allocation = 0;

	if (has_used_allocation != 0)
	{
		return nullptr;
	}

	has_used_allocation = 1;

	void* apic_allocation = &apic_class_instance_allocation;
#endif

	apic_base_t apic_base = read_apic_base();

	uint8_t is_any_apic_enabled = is_any_enabled(apic_base);

	uint8_t use_x2apic = 0;

	if (is_any_apic_enabled == 1)
	{
		use_x2apic = is_x2apic_enabled(apic_base);
	}
	else
	{
		use_x2apic = is_x2apic_supported();

		enable(use_x2apic);
	}

	apic_t* apic = nullptr;

	if (use_x2apic == 1)
	{
		apic = new (apic_allocation) x2apic_t();
	}
	else
	{
		apic = new (apic_allocation) xapic_t();
	}

	return apic;
}

```

`src/apic.h`:

```h
#pragma once
#include "apic_def.h"

// if you want apic_t::create_instance to use runtime memory allocation for the instance(s) it creates
// then make sure to #define APIC_RUNTIME_INSTANCE_ALLOCATION

class apic_t
{
public:
	apic_t() = default;
	virtual ~apic_t() = default;

	virtual void write_icr(apic_full_icr_t icr) = 0;
	virtual void set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination) = 0;
	virtual void signal_eoi() = 0;

	static apic_t* create_instance();

	static uint8_t enable(uint8_t use_x2apic);
	static uint8_t is_any_enabled(apic_base_t apic_base);
	static uint8_t is_x2apic_enabled(apic_base_t apic_base);

	static uint32_t current_apic_id();
	static uint8_t is_x2apic_supported();

	static apic_base_t read_apic_base();

	static apic_full_icr_t make_base_icr(uint32_t vector, icr_delivery_mode_t delivery_mode, icr_destination_mode_t destination_mode);

	void send_ipi(uint32_t vector, uint32_t apic_id, uint8_t is_lowest_priority = 0);
	void send_ipi(uint32_t vector, icr_destination_shorthand_t destination_shorthand, uint8_t is_lowest_priority = 0);

	void send_nmi(uint32_t apic_id);
	void send_nmi(icr_destination_shorthand_t destination_shorthand);

	void send_smi(uint32_t apic_id);
	void send_smi(icr_destination_shorthand_t destination_shorthand);

	void send_init_ipi(uint32_t apic_id);
	void send_init_ipi(icr_destination_shorthand_t destination_shorthand);

	void send_startup_ipi(uint32_t apic_id);
	void send_startup_ipi(icr_destination_shorthand_t destination_shorthand);

	void* operator new(uint64_t size, void* p);
	void operator delete(void* p, uint64_t size);
};

class xapic_t : public apic_t
{
protected:
	uint8_t* mapped_apic_base = nullptr;

	uint32_t do_read(uint16_t offset) const;
	void do_write(uint16_t offset, uint32_t value) const;

public:
	xapic_t();
	~xapic_t() override;

	void write_icr(apic_full_icr_t icr) override;
	void set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination) override;
	void signal_eoi() override;
};

class x2apic_t : public apic_t
{
protected:
	static uint64_t do_read(uint32_t msr);
	static void do_write(uint32_t msr, uint64_t value);

public:
	void write_icr(apic_full_icr_t icr) override;
	void set_icr_longhand_destination(apic_full_icr_t& icr, uint32_t destination) override;
	void signal_eoi() override;
};

```

`src/apic_def.h`:

```h
#pragma once

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

enum class icr_delivery_mode_t : uint32_t
{
	fixed = 0b000,
	lowest_priority = 0b001,
	smi = 0b101,
	nmi = 0b100,
	init = 0b101,
	start_up = 0b110
};

enum class icr_destination_mode_t : uint32_t
{
	physical = 0b0,
	logical = 0b1
};

enum class icr_delivery_status_t : uint32_t
{
	idle = 0b0,
	send_pending = 0b1
};

enum class icr_level_t : uint32_t
{
	de_assert = 0b0,
	assert = 0b1
};

enum class icr_trigger_mode_t : uint32_t
{
	edge = 0b0,
	level = 0b1
};

enum class icr_destination_shorthand_t : uint32_t
{
	no_shorthand = 0b00,
	self = 0b01,
	all_including_self = 0b10,
	all_but_self = 0b11
};

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4201)
#endif

// Intel SDM Volume 3: 12.6.1 Interrupt Command Register (ICR)
union apic_icr_low_t
{
	uint32_t flags;

	struct
	{
		uint32_t vector : 8;
		icr_delivery_mode_t delivery_mode : 3;
		icr_destination_mode_t destination_mode : 1;
		icr_delivery_status_t delivery_status : 1;
		uint32_t reserved1 : 1;
		icr_level_t level : 1;
		icr_trigger_mode_t trigger_mode : 1;
		uint32_t reserved2 : 2;
		icr_destination_shorthand_t destination_shorthand : 2;
		uint32_t reserved3 : 10;
	};
};

union apic_icr_high_t
{
	uint32_t flags;

	struct
	{
		uint32_t reserved1 : 24;
		uint32_t destination_field : 8;
	} xapic;

	struct
	{
		uint32_t destination_field : 32;
	} x2apic;
};

union apic_full_icr_t
{
	uint64_t flags;

	struct
	{
		apic_icr_low_t low;
		apic_icr_high_t high;
	};
};

// END OF SDM SUBCHAPTER

// Intel SDM Volume 3: 12.4.4 Local APIC Status and Location
union apic_base_t
{
	uint64_t flags;

	struct
	{
		uint64_t reserved1 : 8;
		uint64_t is_boot_strap_processor : 1;
		uint64_t reserved2 : 1;
		uint64_t is_x2apic : 1;
		uint64_t is_apic_globally_enabled : 1; // permanent until reset
		uint64_t apic_pfn : 24; // apply left shift of 12
		uint64_t reserved3 : 28;
	};
};

// END OF SDM SUBCHAPTER

struct cpuid_01_t
{
	uint32_t eax;

	struct
	{
		uint32_t reserved1 : 24;
		uint32_t initial_apic_id : 8;
	} ebx;

	struct
	{
		uint32_t reserved1 : 21;
		uint32_t x2apic_supported : 1;
		uint32_t reserved2 : 10;
	} ecx;

	uint32_t edx;
};

class apic_field_t
{
protected:
	const uint16_t xapic_offset;

public:
	constexpr apic_field_t(uint16_t xapic_offset_in) : xapic_offset(xapic_offset_in) {}

	constexpr uint16_t get_xapic() const
	{
		return this->xapic_offset;
	}

	constexpr uint16_t get_x2apic() const
	{
		return 0x800 + (this->xapic_offset / 0x10);
	}
};

namespace apic
{
	constexpr uint32_t apic_base_msr = 0x1B;
	constexpr apic_field_t eoi(0xB0);
	constexpr apic_field_t icr(0x300);

	namespace intrin
	{
		union parted_uint64_t
		{
			struct
			{
				uint32_t low_part;
				uint32_t high_part;
			};

			uint64_t value;
		};
	}
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif

```

`src/apic_intrin.h`:

```h
#pragma once
#include "apic_def.h"

#if defined(_MSC_VER) && !defined(__clang__)
#define _APIC_INTRIN_IS_PURE_MSVC
#include <intrin.h>
#endif

namespace apic
{
    namespace intrin
    {
        uint64_t rdmsr(uint32_t msr)
        {
#ifdef _APIC_INTRIN_IS_PURE_MSVC
            return __readmsr(msr);
#else
            parted_uint64_t parted_result = { };

            asm("rdmsr" : "=a"(parted_result.low_part), "=d"(parted_result.high_part) : "c"(msr));

            return parted_result.value;
#endif
        }

        void wrmsr(uint32_t msr, uint64_t value)
        {
#ifdef _APIC_INTRIN_IS_PURE_MSVC
            __writemsr(msr, value);
#else
            parted_uint64_t parted_value = { };

            parted_value.value = value;

            asm("wrmsr" :: "c"(msr), "a"(parted_value.low_part), "d"(parted_value.high_part));
#endif
        }

        void cpuid(int32_t info[4], int32_t leaf)
        {
#ifdef _APIC_INTRIN_IS_PURE_MSVC
            __cpuid(info, leaf);
#else
            asm volatile("cpuid" : "=a"(info[0]), "=b"(info[1]), "=c"(info[2]), "=d"(info[3]) : "a"(leaf));
#endif
        }
    }
}

```